ion->Md5Context, SessionKey, USER_SESSION_KEY_LENGTH );
    }

    MD5Update( &Connection->Md5Context, ChallengeResponse, ChallengeResponseLength );

    Connection->SmbSecuritySignatureIndex = 0;
    Connection->SmbSecuritySignatureActive = TRUE;

    //
    // We don't know how to do RAW and security signatures
    //
    Connection->EnableRawIo = FALSE;

    IF_DEBUG( SECSIG ) {
        KdPrint(( "SRV: SMB sigs enabled for %wZ, conn %p, build %d\n",
                &Connection->PagedConnection->ClientMachineNameString,
                Connection, Connection->PagedConnection->ClientBuildNumber ));
    }
}

VOID SRVFASTCALL
SrvAddSmbSecuritySignature(
    IN OUT PWORK_CONTEXT WorkContext,
    IN PMDL Mdl,
    IN ULONG SendLength
    )
/*++

Routine Description:

    Generates the next security signature

Arguments:

    WorkContext - the context to sign

Return Value:

    none.

--*/
{
    MD5_CTX Context;
    PSMB_HEADER Smb = MmGetSystemAddressForMdl( Mdl );

    IF_DEBUG( SECSIG ) {
        KdPrint(( "SRV: resp sig: cmd %x, index %u, len %d\n",
                Smb->Command, WorkContext->ResponseSmbSecuritySignatureIndex, SendLength ));
    }

#if DBG
    //
    // Put the index number right after the signature.  This allows us to figure out on the client
    //  side if we have a signature mismatch.
    //
    SmbPutUshort( &Smb->SecuritySignature[SMB_SECURITY_SIGNATURE_LENGTH],
        (USHORT)WorkContext->ResponseSmbSecuritySignatureIndex );

#endif

    //
    // Put the next index number into the SMB
    //
    SmbPutUlong( Smb->SecuritySignature, WorkContext->ResponseSmbSecuritySignatureIndex );
    RtlZeroMemory(  Smb->SecuritySignature + sizeof(ULONG),
                    SMB_SECURITY_SIGNATURE_LENGTH-sizeof(ULONG)
                 );

    //
    // Start out with our initial context
    //
    RtlCopyMemory( &Context, &WorkContext->Connection->Md5Context, sizeof( Context ) );

    //
    // Compute the signature for the SMB we're about to send
    //
    do {
        PCHAR SystemAddressForBuffer;

        ULONG len = MIN( SendLength, MmGetMdlByteCount( Mdl ) );

        SystemAddressForBuffer = MmGetSystemAddressForMdlSafe(Mdl,NormalPoolPriority);

        if (SystemAddressForBuffer == NULL) {
            // return without updating the security signature field. This will
            // in turn cause the client to reject the packet and tear down the
            // connection
            return;
        }

        MD5Update( &Context, SystemAddressForBuffer, len );

        SendLength -= len;

    } while( SendLength && (Mdl = Mdl->Next) != NULL );

    MD5Final( &Context );

    //
    // Put the signature into the SMB
    //
    RtlCopyMemory(
        Smb->SecuritySignature,
        Context.digest,
        SMB_SECURITY_SIGNATURE_LENGTH
        );
}

//
// Print the mismatched signature information to the debugger
//
VOID
SrvDumpSignatureError(
    IN PWORK_CONTEXT WorkContext,
    IN PUCHAR ExpectedSignature,
    IN PUCHAR ActualSignature,
    IN ULONG Length,
    IN ULONG ExpectedIndexNumber

    )
{
#if DBG
    DWORD i;
    PMDL Mdl = WorkContext->RequestBuffer->Mdl;
    ULONG requestLength = MIN( WorkContext->RequestBuffer->DataLength, 64 );
    PSMB_HEADER Smb = MmGetSystemAddressForMdl( Mdl );

    if( Smb->Command == SMB_COM_ECHO ) {
        return;
    }

    //
    // Security Signature Mismatch!
    //
    IF_DEBUG( ERRORS ) {
        KdPrint(( "SRV: Invalid security signature in request smb (cmd %X)", Smb->Command ));

        if( WorkContext->Connection && WorkContext->Connection->PagedConnection ) {
            KdPrint(( " from %wZ" ,
                        &WorkContext->Connection->PagedConnection->ClientMachineNameString ));
        }
    }
    IF_DEBUG( SECSIG ) {
        KdPrint(( "\n\tExpected: " ));
        for( i = 0; i < SMB_SECURITY_SIGNATURE_LENGTH; i++ ) {
            KdPrint(( "%X ", ExpectedSignature[i] & 0xff ));
        }
        KdPrint(( "\n\tReceived: " ));
        for( i = 0; i < SMB_SECURITY_SIGNATURE_LENGTH; i++ ) {
            KdPrint(( "%X ", ActualSignature[i] & 0xff ));
        }
        KdPrint(( "\n\tLength %u, Expected Index Number %u\n", Length, ExpectedIndexNumber ));

        //
        // Dump out some of the errant SMB
        //
        i = 1;
        do {
            ULONG len = MIN( requestLength, Mdl->ByteCount );
            PBYTE p = MmGetSystemAddressForMdl( Mdl );
            PBYTE ep = (PBYTE)MmGetSystemAddressForMdl( Mdl ) + len;

            for( ; p < ep; p++, i++ ) {
                KdPrint(("%2.2x ", (*p) & 0xff ));
                if( !(i%32) ) {
                    KdPrint(( "\n" ));
                }
            }

            requestLength -= len;

        } while( requestLength != 0 && (Mdl = Mdl->Next) != NULL );

        KdPrint(( "\n" ));
    }

    IF_DEBUG( SECSIG ) {
        DbgPrint( "WorkContext: %p\n", WorkContext );
        DbgBreakPoint();
    }

#endif
}

BOOLEAN SRVFASTCALL
SrvCheckSmbSecuritySignature(
    IN OUT PWORK_CONTEXT WorkContext
    )
{
    MD5_CTX Context;
    PMDL Mdl = WorkContext->RequestBuffer->Mdl;
    ULONG requestLength = WorkContext->RequestBuffer->DataLength;
    CHAR SavedSignature[ SMB_SECURITY_SIGNATURE_LENGTH ];
    PSMB_HEADER Smb = MmGetSystemAddressForMdl( Mdl );
    ULONG len;

    //
    // Initialize the Context
    //
    RtlCopyMemory( &Context, &WorkContext->Connection->Md5Context, sizeof( Context ) );

    //
    // Save the signature that's presently in the SMB
    //
    RtlCopyMemory( SavedSignature, Smb->SecuritySignature, sizeof( SavedSignature ));

    //
    // Put the correct (expected) signature index into the buffer
    //
    SmbPutUlong( Smb->SecuritySignature, WorkContext->SmbSecuritySignatureIndex );
    RtlZeroMemory(  Smb->SecuritySignature + sizeof(ULONG),
                    SMB_SECURITY_SIGNATURE_LENGTH-sizeof(ULONG)
                 );

    //
    // Compute what the signature should be
    //
    do {

        len = MIN( requestLength, Mdl->ByteCount );

        MD5Update( &Context, MmGetSystemAddressForMdl( Mdl ), len );

        requestLength -= len;

    } while( requestLength != 0 && (Mdl = Mdl->Next) != NULL );

    MD5Final( &Context );

    //
    // Put the signature back
    //
    RtlCopyMemory( Smb->SecuritySignature, SavedSignature, sizeof( Smb->SecuritySignature ));

    //
    // Now compare them!
    //
    if( RtlCompareMemory( Context.digest, SavedSignature, sizeof( SavedSignature ) ) !=
        sizeof( SavedSignature ) ) {

        SrvDumpSignatureError(  WorkContext,
                                Context.digest,
                                SavedSignature,
                                WorkContext->RequestBuffer->DataLength,
                                WorkContext->SmbSecuritySignatureIndex
                              );
        return FALSE;

    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\srv\blkendp.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    blkendp.c

Abstract:

    This module implements routines for managing endpoint blocks.

Author:

    Chuck Lenzmeier (chuckl) 4-Oct-1989

Revision History:

--*/

#include "precomp.h"
#include "blkendp.tmh"
#pragma hdrstop

#define BugCheckFileId SRV_FILE_BLKENDP

#ifdef ALLOC_PRAGMA
#pragma alloc_text( PAGE, SrvAllocateEndpoint )
#pragma alloc_text( PAGE, SrvCheckAndReferenceEndpoint )
#pragma alloc_text( PAGE, SrvCloseEndpoint )
#pragma alloc_text( PAGE, SrvDereferenceEndpoint )
#pragma alloc_text( PAGE, SrvFreeEndpoint )
#pragma alloc_text( PAGE, SrvReferenceEndpoint )
#pragma alloc_text( PAGE, SrvFindNamedEndpoint )
#endif
#if 0
NOT PAGEABLE -- EmptyFreeConnectionList
NOT PAGEABLE -- WalkConnectionTable
#endif


VOID
SrvAllocateEndpoint (
    OUT PENDPOINT *Endpoint,
    IN PUNICODE_STRING NetworkName,
    IN PUNICODE_STRING TransportName,
    IN PANSI_STRING TransportAddress,
    IN PUNICODE_STRING DomainName
    )

/*++

Routine Description:

    This function allocates an Endpoint Block from the system nonpaged
    pool.

Arguments:

    Endpoint - Returns a pointer to the endpoint block, or NULL if no
        pool was available.

    NetworkName - Supplies a pointer to the network name (e.g., NET1).

    TransportName - The fully qualified name of the transport device.
        For example, "\Device\Nbf".

    TransportAddress - The fully qualified address (or name ) of the
        server's endpoint.  This name is used exactly as specified.  For
        NETBIOS-compatible networks, the caller must upcase and
        blank-fill the name.  E.g., "\Device\Nbf\NTSERVERbbbbbbbb".

    DomainName - the domain being serviced by this endpoint

Return Value:

    None.

--*/

{
    CLONG length;
    PENDPOINT endpoint;
    NTSTATUS status;

    PAGED_CODE( );

    //
    // Attempt to allocate from nonpaged pool.
    //

    length = sizeof(ENDPOINT) +
                NetworkName->Length + sizeof(*NetworkName->Buffer) +
                TransportName->Length + sizeof(*TransportName->Buffer) +
                TransportAddress->Length + sizeof(*TransportAddress->Buffer) +
                RtlOemStringToUnicodeSize( TransportAddress ) +
                DNLEN * sizeof( *DomainName->Buffer ) +
                DNLEN + sizeof(CHAR);

    endpoint = ALLOCATE_NONPAGED_POOL( length, BlockTypeEndpoint );
    *Endpoint = endpoint;

    if ( endpoint == NULL ) {

        INTERNAL_ERROR (
            ERROR_LEVEL_EXPECTED,
            "SrvAllocateEndpoint: Unable to allocate %d bytes from nonpaged "
                "pool.",
            length,
            NULL
            );

        return;
    }

    IF_DEBUG(HEAP) {
        SrvPrint1( "SrvAllocateEndpoint: Allocated endpoint at %p\n",
                    endpoint );
    }

    //
    // Initialize the endpoint block.  Zero it first.
    //

    RtlZeroMemory( endpoint, length );

    SET_BLOCK_TYPE_STATE_SIZE( endpoint, BlockTypeEndpoint, BlockStateActive, length );
    endpoint->BlockHeader.ReferenceCount = 2;       // allow for Active status
                                                    //  and caller's pointer

    //
    // Allocate connection table.
    //

    SrvAllocateTable(
        &endpoint->ConnectionTable,
        6, // !!!
        TRUE
        );
    if ( endpoint->ConnectionTable.Table == NULL ) {
        DEALLOCATE_NONPAGED_POOL( endpoint );
        *Endpoint = NULL;
        return;
    }

    InitializeListHead( &endpoint->FreeConnectionList );
#if SRVDBG29
    UpdateConnectionHistory( "INIT", endpoint, NULL );
#endif

    //
    // Copy the network name, transport name, and server address, and domain
    // name into the block.
    //

    endpoint->NetworkName.Length = NetworkName->Length;
    endpoint->NetworkName.MaximumLength =
            (SHORT)(NetworkName->Length + sizeof(*NetworkName->Buffer));
    endpoint->NetworkName.Buffer = (PWCH)(endpoint + 1);
    RtlCopyMemory(
        endpoint->NetworkName.Buffer,
        NetworkName->Buffer,
        NetworkName->Length
        );

    endpoint->TransportName.Length = TransportName->Length;
    endpoint->TransportName.MaximumLength =
            (SHORT)(TransportName->Length + sizeof(*TransportName->Buffer));
    endpoint->TransportName.Buffer =
                            (PWCH)((PCHAR)endpoint->NetworkName.Buffer +
                                    endpoint->NetworkName.MaximumLength);
    RtlCopyMemory(
        endpoint->TransportName.Buffer,
        TransportName->Buffer,
        TransportName->Length
        );

    endpoint->ServerName.MaximumLength = (USHORT)RtlOemStringToUnicodeSize( TransportAddress );
    endpoint->ServerName.Length = 0;
    endpoint->ServerName.Buffer = endpoint->TransportName.Buffer +
                                    endpoint->TransportName.MaximumLength / sizeof( WCHAR );

    endpoint->TransportAddress.Length = TransportAddress->Length;
    endpoint->TransportAddress.MaximumLength =
                                (SHORT)(TransportAddress->Length + 1);
    endpoint->TransportAddress.Buffer =
                            (PCHAR)endpoint->ServerName.Buffer +
                                    endpoint->ServerName.MaximumLength;
    RtlCopyMemory(
        endpoint->TransportAddress.Buffer,
        TransportAddress->Buffer,
        TransportAddress->Length
        );

    status = RtlOemStringToUnicodeString( &endpoint->ServerName, TransportAddress, FALSE );

    if (!NT_SUCCESS(status)) {
        DbgPrint("SRv ENDPOINT Name translation failed status %lx\n",status);
        KdPrint(("SRv ENDPOINT Name translation failed status %lx\n",status));
    }

    //
    // Trim the trailing blanks off the end of servername
    //
    while( endpoint->ServerName.Length &&
        endpoint->ServerName.Buffer[ (endpoint->ServerName.Length / sizeof(WCHAR))-1 ] == L' ' ) {

        endpoint->ServerName.Length -= sizeof( WCHAR );
    }

    endpoint->DomainName.Length = DomainName->Length;
    endpoint->DomainName.MaximumLength =  DNLEN * sizeof( *endpoint->DomainName.Buffer );
    endpoint->DomainName.Buffer = (PWCH)((PCHAR)endpoint->TransportAddress.Buffer +
                                         TransportAddress->MaximumLength);
    RtlCopyMemory(
        endpoint->DomainName.Buffer,
        DomainName->Buffer,
        DomainName->Length
    );

    endpoint->OemDomainName.Length = (SHORT)RtlUnicodeStringToOemSize( DomainName );
    endpoint->OemDomainName.MaximumLength = DNLEN + sizeof( CHAR );
    endpoint->OemDomainName.Buffer = (PCHAR)endpoint->DomainName.Buffer +
                                     endpoint->DomainName.MaximumLength;

    status = RtlUnicodeStringToOemString(
                &endpoint->OemDomainName,
                &endpoint->DomainName,
                FALSE     // Do not allocate the OEM string
                );
    ASSERT( NT_SUCCESS(status) );


    //
    // Initialize the network address field.
    //

    endpoint->NetworkAddress.Buffer = endpoint->NetworkAddressData;
    endpoint->NetworkAddress.Length = sizeof( endpoint->NetworkAddressData ) -
                                      sizeof(endpoint->NetworkAddressData[0]);
    endpoint->NetworkAddress.MaximumLength = sizeof( endpoint->NetworkAddressData );

    //
    // Increment the count of endpoints in the server.
    //

    ACQUIRE_LOCK( &SrvEndpointLock );
    SrvEndpointCount++;
    RELEASE_LOCK( &SrvEndpointLock );

    INITIALIZE_REFERENCE_HISTORY( endpoint );

    INCREMENT_DEBUG_STAT( SrvDbgStatistics.EndpointInfo.Allocations );

    return;

} // SrvAllocateEndpoint


BOOLEAN SRVFASTCALL
SrvCheckAndReferenceEndpoint (
    PENDPOINT Endpoint
    )

/*++

Routine Description:

    This function atomically verifies that an endpoint is active and
    increments the reference count on the endpoint if it is.

Arguments:

    Endpoint - Address of endpoint

Return Value:

    BOOLEAN - Returns TRUE if the endpoint is active, FALSE otherwise.

--*/

{
    PAGED_CODE( );

    //
    // Acquire the lock that guards the endpoint's state field.
    //

    ACQUIRE_LOCK( &SrvEndpointLock );

    //
    // If the endpoint is active, reference it and return TRUE.
    //

    if ( GET_BLOCK_STATE(Endpoint) == BlockStateActive ) {

        SrvReferenceEndpoint( Endpoint );

        RELEASE_LOCK( &SrvEndpointLock );

        return TRUE;

    }

    //
    // The endpoint isn't active.  Return FALSE.
    //

    RELEASE_LOCK( &SrvEndpointLock );

    return FALSE;

} // SrvCheckAndReferenceEndpoint


VOID
SrvCloseEndpoint (
    IN PENDPOINT Endpoint
    )

/*++

Routine Description:

    This function closes a transport endpoint.

    *** This function must be called with SrvEndpointLock held exactly
        once.  The lock is released on exit.

Arguments:

    Endpoint - Supplies a pointer to an Endpoint Block

Return Value:

    None.

--*/

{
    USHORT index;
    PCONNECTION connection;

    PAGED_CODE( );

    ASSERT( ExIsResourceAcquiredExclusiveLite(&RESOURCE_OF(SrvEndpointLock)) );

    if ( GET_BLOCK_STATE(Endpoint) == BlockStateActive ) {

        IF_DEBUG(BLOCK1) SrvPrint1( "Closing endpoint at %p\n", Endpoint );

        SET_BLOCK_STATE( Endpoint, BlockStateClosing );

        //
        // Close all active connections.
        //

        index = (USHORT)-1;

        while ( TRUE ) {

            //
            // Get the next active connection in the table.  If no more
            // are available, WalkConnectionTable returns NULL.
            // Otherwise, it returns a referenced pointer to a
            // connection.
            //

            connection = WalkConnectionTable( Endpoint, &index );
            if ( connection == NULL ) {
                break;
            }

            //
            // We don't want to hold the endpoint lock while we close the
            // connection (this causes lock level problems).  Since we
            // already have a referenced pointer to the connection, this
            // is safe.
            //

            RELEASE_LOCK( &SrvEndpointLock );

#if SRVDBG29
            UpdateConnectionHistory( "CEND", Endpoint, connection );
#endif
            connection->DisconnectReason = DisconnectEndpointClosing;
            SrvCloseConnection( connection, FALSE );

            ACQUIRE_LOCK( &SrvEndpointLock );

            SrvDereferenceConnection( connection );

        }

        //
        // Close all free connections.
        //

        EmptyFreeConnectionList( Endpoint );

        //
        // We don't need to hold the endpoint lock anymore.
        //

        RELEASE_LOCK( &SrvEndpointLock );

        //
        // Close the endpoint file handle.  This causes all pending
        // requests to be aborted.  It also deregisters all event
        // handlers.
        //
        // *** Note that we have a separate reference to the file
        //     object, in addition to the handle.  We don't release that
        //     reference until all activity on the endpoint has ceased
        //     (in SrvDereferenceEndpoint).
        //

        SRVDBG_RELEASE_HANDLE( Endpoint->EndpointHandle, "END", 2, Endpoint );
        SrvNtClose( Endpoint->EndpointHandle, FALSE );
        if ( Endpoint->IsConnectionless ) {
            SRVDBG_RELEASE_HANDLE( Endpoint->NameSocketHandle, "END", 2, Endpoint );
            SrvNtClose( Endpoint->NameSocketHandle, FALSE );
        }

        //
        // Dereference the endpoint (to indicate that it's no longer
        // open).
        //

        SrvDereferenceEndpoint( Endpoint );

        INCREMENT_DEBUG_STAT( SrvDbgStatistics.EndpointInfo.Closes );

    } else {

        RELEASE_LOCK( &SrvEndpointLock );

    }

    return;

} // SrvCloseEndpoint


VOID SRVFASTCALL
SrvDereferenceEndpoint (
    IN PENDPOINT Endpoint
    )

/*++

Routine Description:

    This function decrements the reference count on an endpoint.  If the
    reference count goes to zero, the endpoint block is deleted.

Arguments:

    Endpoint - Address of endpoint

Return Value:

    None.

--*/

{
    ULONG newEndpointCount;

    PAGED_CODE( );

    //
    // Enter a critical section and decrement the reference count on the
    // block.
    //

    ACQUIRE_LOCK( &SrvEndpointLock );

    IF_DEBUG(REFCNT) {
        SrvPrint2( "Dereferencing endpoint %p; old refcnt %lx\n",
                    Endpoint, Endpoint->BlockHeader.ReferenceCount );
    }

    ASSERT( GET_BLOCK_TYPE( Endpoint ) == BlockTypeEndpoint );
    ASSERT( (LONG)Endpoint->BlockHeader.ReferenceCount > 0 );
    UPDATE_REFERENCE_HISTORY( Endpoint, TRUE );

    if ( --Endpoint->BlockHeader.ReferenceCount == 0 ) {

        //
        // The new reference count is 0, meaning that it's time to
        // delete this block.
        //

        ASSERT( GET_BLOCK_STATE(Endpoint) != BlockStateActive );

        //
        // Decrement the count of endpoints in the server.  If the new
        // count is zero, set the endpoint event.
        //

        ASSERT( SrvEndpointCount >= 1 );

        newEndpointCount = --SrvEndpointCount;

        RELEASE_LOCK( &SrvEndpointLock );

        if ( newEndpointCount == 0 ) {
            KeSetEvent( &SrvEndpointEvent, 0, FALSE );
        }

        //
        // Remove the endpoint from the global list of endpoints.
        //

        SrvRemoveEntryOrderedList( &SrvEndpointList, Endpoint );

        //
        // Dereference the file object pointer.  (The handle to the file
        // object was closed in SrvCloseEndpoint.)
        //

        ObDereferenceObject( Endpoint->FileObject );
        if ( Endpoint->IsConnectionless ) {
            ObDereferenceObject( Endpoint->NameSocketFileObject );
        }

        //
        // Free the endpoint block's storage.
        //

        SrvFreeEndpoint( Endpoint );

    } else {

        RELEASE_LOCK( &SrvEndpointLock );

    }

    return;

} // SrvDereferenceEndpoint


VOID
SrvFreeEndpoint (
    IN PENDPOINT Endpoint
    )

/*++

Routine Description:

    This function returns an Endpoint Block to the system nonpaged pool.

Arguments:

    Endpoint - Address of endpoint

Return Value:

    None.

--*/

{
    PAGED_CODE( );

    DEBUG SET_BLOCK_TYPE_STATE_SIZE( Endpoint, BlockTypeGarbage, BlockStateDead, -1 );
    DEBUG Endpoint->BlockHeader.ReferenceCount = (ULONG)-1;
    TERMINATE_REFERENCE_HISTORY( Endpoint );

    if ( Endpoint->IpxMaxPacketSizeArray != NULL ) {
        FREE_HEAP( Endpoint->IpxMaxPacketSizeArray );
    }

    if ( Endpoint->ConnectionTable.Table != NULL ) {
        SrvFreeTable( &Endpoint->ConnectionTable );
    }

    DEALLOCATE_NONPAGED_POOL( Endpoint );
    IF_DEBUG(HEAP) SrvPrint1( "SrvFreeEndpoint: Freed endpoint block at %p\n", Endpoint );

    INCREMENT_DEBUG_STAT( SrvDbgStatistics.EndpointInfo.Frees );

    return;

} // SrvFreeEndpoint


VOID
SrvReferenceEndpoint (
    PENDPOINT Endpoint
    )

/*++

Routine Description:

    This function increments the reference count on an endpoint block.

Arguments:

    Endpoint - Address of endpoint

Return Value:

    None.

--*/

{
    PAGED_CODE( );

    //
    // Enter a critical section and increment the reference count on the
    // endpoint.
    //

    ACQUIRE_LOCK( &SrvEndpointLock );

    ASSERT( (LONG)Endpoint->BlockHeader.ReferenceCount > 0 );
    ASSERT( GET_BLOCK_TYPE(Endpoint) == BlockTypeEndpoint );
    ASSERT( GET_BLOCK_STATE(Endpoint) == BlockStateActive );
    UPDATE_REFERENCE_HISTORY( Endpoint, FALSE );

    Endpoint->BlockHeader.ReferenceCount++;

    IF_DEBUG(REFCNT) SrvPrint2( "Referencing endpoint %p; new refcnt %lx\n",
            Endpoint, Endpoint->BlockHeader.ReferenceCount );

    RELEASE_LOCK( &SrvEndpointLock );

    return;

} // SrvReferenceEndpoint

BOOLEAN
SrvFindNamedEndpoint(
    IN PUNICODE_STRING ServerName,
    OUT PBOOLEAN RemapPipeNames OPTIONAL
)
/*++

Routine Description:

    This routine returns TRUE of any endpoint is supporting 'ServerName'.

    Additionally, set the RemapPipeNames variable from the found endpoint.

--*/
{
    PLIST_ENTRY listEntry;
    PENDPOINT endpoint = NULL;

    PAGED_CODE( );

    if( ARGUMENT_PRESENT( RemapPipeNames ) ) {
        *RemapPipeNames = FALSE;
    }

    //
    // Find an endpoint block supporting the specified name.
    //

    ACQUIRE_LOCK_SHARED( &SrvEndpointLock );

    for( listEntry = SrvEndpointList.ListHead.Flink;
         listEntry != &SrvEndpointList.ListHead;
         endpoint = NULL, listEntry = listEntry->Flink ) {

        endpoint = CONTAINING_RECORD(
                        listEntry,
                        ENDPOINT,
                        GlobalEndpointListEntry
                        );

        //
        // Skip any inappropriate endpoints
        //
        if( GET_BLOCK_STATE( endpoint ) != BlockStateActive ||
            endpoint->IsConnectionless ||
            (ARGUMENT_PRESENT( RemapPipeNames ) && endpoint->IsNoNetBios) ) {

            continue;
        }

        //
        // See if this endpoint literally matches the name we're looking for
        //
        if( RtlEqualUnicodeString( ServerName, &endpoint->ServerName, TRUE ) ) {
            break;
        }

        //
        // We might have a case where the ServerName is something like
        //      server.dns.company.com
        //  but the endpoint netbios name is only 'server'.  We should match this
        //
        if( endpoint->ServerName.Length < ServerName->Length ) {
            UNICODE_STRING shortServerName;

            shortServerName = *ServerName;
            shortServerName.Length = endpoint->ServerName.Length;

            if (RtlEqualUnicodeString( &endpoint->ServerName, &shortServerName, TRUE)) {
                if (endpoint->ServerName.Length < ((NETBIOS_NAME_LEN - 1) * sizeof(WCHAR))) {
                    if (ServerName->Buffer[ shortServerName.Length / sizeof( WCHAR ) ] == L'.') {
                        break;
                    }
                } else {
                    if (endpoint->ServerName.Length == (NETBIOS_NAME_LEN - 1) * sizeof(WCHAR)) {
                        break;
                    }
                }
            }
        }

        //
        // See if this endpoint domain name literally matches the name we're
        // looking for. The following two tests against the domain name are
        // required to cover the case when there are certain components that
        // use the domain name to talk to the server. Given the way name resolution
        // records are setup this used to work before this checkin. This change
        // breaks them. These tests provide us the backward compatibility.
        //
        if( RtlEqualUnicodeString( ServerName, &endpoint->DomainName, TRUE ) ) {
            break;
        }

        //
        // We might have a case where the ServerName is something like
        //      server.dns.company.com
        //  but the endpoint netbios name is only 'server'.  We should match this
        //

        if( endpoint->DomainName.Length < ServerName->Length ) {
            UNICODE_STRING shortServerName;

            shortServerName = *ServerName;
            shortServerName.Length = endpoint->DomainName.Length;

            if (RtlEqualUnicodeString( &endpoint->DomainName, &shortServerName, TRUE)) {
                if (endpoint->DomainName.Length <= (NETBIOS_NAME_LEN * sizeof(WCHAR))) {
                    if (ServerName->Buffer[ shortServerName.Length / sizeof( WCHAR ) ] == L'.') {
                        break;
                    }
                } else {
                    if (endpoint->DomainName.Length == (NETBIOS_NAME_LEN - 1) * sizeof(WCHAR)) {
                        break;
                    }
                }
            }
        }

    }

    if( ARGUMENT_PRESENT( RemapPipeNames ) && endpoint != NULL ) {
        *RemapPipeNames = ( endpoint->RemapPipeNames == TRUE );
    }

    RELEASE_LOCK( &SrvEndpointLock );

    return endpoint != NULL;
}


VOID
EmptyFreeConnectionList (
    IN PENDPOINT Endpoint
    )
{
    PCONNECTION connection;
    PLIST_ENTRY listEntry;
    KIRQL oldIrql;

    //
    // *** In order to synchronize with the TDI connect handler in
    //     the FSD, which only uses a spin lock to serialize access
    //     to the free connection list (and does not check the
    //     endpoint state), we need to atomically capture the list
    //     head and empty the list.
    //

    ACQUIRE_GLOBAL_SPIN_LOCK( Fsd, &oldIrql );

    listEntry = Endpoint->FreeConnectionList.Flink;
    InitializeListHead( &Endpoint->FreeConnectionList );
#if SRVDBG29
    UpdateConnectionHistory( "CLOS", Endpoint, NULL );
#endif

    RELEASE_GLOBAL_SPIN_LOCK( Fsd, oldIrql );

    while ( listEntry != &Endpoint->FreeConnectionList ) {

        connection = CONTAINING_RECORD(
                        listEntry,
                        CONNECTION,
                        EndpointFreeListEntry
                        );

        listEntry = listEntry->Flink;
        SrvCloseFreeConnection( connection );

    }

    return;

} // EmptyFreeConnectionList


PCONNECTION
WalkConnectionTable (
    IN PENDPOINT Endpoint,
    IN OUT PUSHORT Index
    )
{
    USHORT i;
    PTABLE_HEADER tableHeader;
    PCONNECTION connection;
    KIRQL oldIrql;

    ACQUIRE_SPIN_LOCK( &ENDPOINT_SPIN_LOCK(0), &oldIrql );
    for ( i = 1; i < ENDPOINT_LOCK_COUNT ; i++ ) {
        ACQUIRE_DPC_SPIN_LOCK( &ENDPOINT_SPIN_LOCK(i) );
    }

    tableHeader = &Endpoint->ConnectionTable;

    for ( i = *Index + 1; i < tableHeader->TableSize; i++ ) {

        connection = (PCONNECTION)tableHeader->Table[i].Owner;
        if ( (connection != NULL) &&
             (GET_BLOCK_STATE(connection) == BlockStateActive) ) {
            *Index = i;
            SrvReferenceConnectionLocked( connection );
            goto exit;
        }
    }
    connection = NULL;

exit:

    for ( i = ENDPOINT_LOCK_COUNT-1 ; i > 0  ; i-- ) {
        RELEASE_DPC_SPIN_LOCK( &ENDPOINT_SPIN_LOCK(i) );
    }
    RELEASE_SPIN_LOCK( &ENDPOINT_SPIN_LOCK(0), oldIrql );

    return connection;
} // WalkConnectionTable
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\sis\tools\volreparsetest\volreparsetest.c ===
#include <stdio.h>
#include <nt.h>


VOID
DisplayUsage(
    wchar_t *ExeName
    )
{
    printf( "This program tests opening a Volume with FILE_OPEN_REPARSE_POINT CreatOptions\n");
    printf( "usage: %S [volume]\n", ExeName );
}


//
//  Main program for TEST program
//

int _cdecl wmain(int argc, wchar_t *argv[])
{
    NTSTATUS status;
    NTSTATUS closeStatus;
    HANDLE volHandle;
    IO_STATUS_BLOCK ioStatusBlock;
    OBJECT_ATTRIBUTES obja;
    UNICODE_STRING fname;
    wchar_t nameBuf[128];


    if (argc < 2)  {
        DisplayUsage( argv[0] );
        return 1;
    }

    //
    //  Create file normally
    //

    wcscpy(nameBuf,L"\\??\\");
    wcscat(nameBuf,argv[1]);


    fname.Buffer = nameBuf;
    fname.MaximumLength = (USHORT)(sizeof( nameBuf ) * sizeof( wchar_t ));
    fname.Length = (USHORT)(wcslen( nameBuf ) * sizeof( wchar_t ));

    InitializeObjectAttributes(
            &obja,
            &fname,
            OBJ_CASE_INSENSITIVE,
            NULL,
            NULL);


    status = NtCreateFile(
                &volHandle,
                (GENERIC_READ | GENERIC_EXECUTE | SYNCHRONIZE),
                &obja,
                &ioStatusBlock,
                NULL,                                                       //Initial allocation size
                FILE_ATTRIBUTE_NORMAL,                                      //FileAttributes
                FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,     //ShareMode
                FILE_OPEN,                                                  //CreateDisposition
                (FILE_OPEN_FOR_BACKUP_INTENT     |                          //CreateOptions
                 FILE_SEQUENTIAL_ONLY            |
                 FILE_OPEN_NO_RECALL             |
                 /*FILE_OPEN_REPARSE_POINT       |*/
                 FILE_SYNCHRONOUS_IO_NONALERT),
                NULL,0);                                                    //ea buffer and length


    if (status != 0)  {
        printf("Error opening \"%S\" without FILE_FLAG_OPEN_REPARSE_POINT flag, status=%08x\n",argv[1],status);
        return 0;
    }

    printf("Successfully opened \"%S\" without FILE_FLAG_OPEN_REPARSE_POINT set\n",argv[1]);


    closeStatus = NtClose( volHandle );
    if (closeStatus != 0)  {
        printf("Close failed, status=%08x\n",closeStatus);
    }


    //
    //  Create file with FILE_FLAG_OPEN_REPARSE_POINT flag.
    //

    status = NtCreateFile(
                &volHandle,
                (GENERIC_READ | GENERIC_EXECUTE | SYNCHRONIZE),
                &obja,
                &ioStatusBlock,
                NULL,                                                       //Initial allocation size
                FILE_ATTRIBUTE_NORMAL,                                      //FileAttributes
                FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,     //ShareMode
                FILE_OPEN,                                                  //CreateDisposition
                (FILE_OPEN_FOR_BACKUP_INTENT     |                          //CreateOptions
                 FILE_SEQUENTIAL_ONLY            |
                 FILE_OPEN_NO_RECALL             |
                 FILE_OPEN_REPARSE_POINT         |
                 FILE_SYNCHRONOUS_IO_NONALERT),
                NULL,0);                                                    //ea buffer and length

    if (status != 0)  {
        printf("Error opening \"%S\" with FILE_FLAG_OPEN_REPARSE_POINT flag, status=%08x\n",argv[1],status);
        return 0;
    }

    printf("Successfully opened \"%S\" with FILE_FLAG_OPEN_REPARSE_POINT set\n",argv[1]);

    closeStatus = NtClose( volHandle );
    if (closeStatus != 0)  {
        printf("Close failed, status=%08x\n",closeStatus);
    }

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\smbtrsup\smbtrsup.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    smbtrsup.c

Abstract:

    This module contains the code to implement the kernel mode SmbTrace
    component within the LanMan server and redirector.
    The interface between the kernel mode component and the
    server/redirector is found in nt\private\inc\smbtrsup.h
    The interface providing user-level access to SmbTrace is found in
    nt\private\inc\smbtrace.h

Author:

    Peter Gray (w-peterg)   23-March-1992

Revision History:

    Stephan Mueller (t-stephm)   21-July-1992

        Completed, fixed bugs, moved all associated declarations here
        from various places in the server, ported to the redirector
        and converted to a kernel DLL.

--*/

#include <ntifs.h>
#include <smbtrace.h>     // for names and structs shared with user-mode app

#define _SMBTRSUP_SYS_ 1  // to get correct definitions for exported variables
#include <smbtrsup.h>     // for functions exported to server/redirector

#if DBG
ULONG SmbtrsupDebug = 0;
#define TrPrint(x) if (SmbtrsupDebug) KdPrint(x)
#else
#define TrPrint(x)
#endif

//
// we assume all well-known names are #defined in Unicode, and require
// them to be so: in the SmbTrace application and the smbtrsup.sys package
//
#ifndef UNICODE
#error "UNICODE build required"
#endif


#if DBG
#define PAGED_DBG 1
#endif
#ifdef PAGED_DBG
#undef PAGED_CODE
#define PAGED_CODE() \
    struct { ULONG bogus; } ThisCodeCantBePaged; \
    ThisCodeCantBePaged; \
    if (KeGetCurrentIrql() > APC_LEVEL) { \
        KdPrint(( "SMBTRSUP: Pageable code called at IRQL %d.  File %s, Line %d\n", KeGetCurrentIrql(), __FILE__, __LINE__ )); \
        ASSERT(FALSE); \
        }
#define PAGED_CODE_CHECK() if (ThisCodeCantBePaged) ;
ULONG ThisCodeCantBePaged;
#else
#define PAGED_CODE_CHECK()
#endif


#if PAGED_DBG
#define ACQUIRE_SPIN_LOCK(a, b) {               \
    PAGED_CODE_CHECK();                         \
    KeAcquireSpinLock(a, b);                    \
    }
#define RELEASE_SPIN_LOCK(a, b) {               \
    PAGED_CODE_CHECK();                         \
    KeReleaseSpinLock(a, b);                    \
    }

#else
#define ACQUIRE_SPIN_LOCK(a, b) KeAcquireSpinLock(a, b)
#define RELEASE_SPIN_LOCK(a, b) KeReleaseSpinLock(a, b)
#endif

//
// Increment shared variable in instance data using appropriate interlock
//
#define LOCK_INC_ID(var)                                     \
     ExInterlockedAddUlong( (PULONG)&ID(var),                \
                            1, &ID(var##Interlock) )

//
// Zero shared variable in instance data using appropriate interlock
//
#define LOCK_ZERO_ID(var) {                                  \
     ID(var) = 0;                                            \
     }


//
// The various states SmbTrace can be in.  These states are internal
// only.  The external SmbTraceActive variable contains much less
// detailed information:  it is TRUE when TraceRunning, FALSE in any other
// state.
//
typedef enum _SMBTRACE_STATE {
    TraceStopped,          // not running
    TraceStarting,         // preparing to run
    TraceStartStopFile,    // starting, but want to shut down immediately
                           // because the FileObject closed
    TraceStartStopNull,    // starting, but want to shut down immediately
                           // because a new fsctl came in
    TraceAppWaiting,       // waiting for application to die
    TraceRunning,          // processing SMBs
    TraceStopping          // waiting for smbtrace thread to stop
} SMBTRACE_STATE;


//
// Structure used to hold information regarding an SMB which is put into
// the SmbTrace thread queue.
//
typedef struct _SMBTRACE_QUEUE_ENTRY {
    LIST_ENTRY  ListEntry;      // usual doubly-linked list
    ULONG       SmbLength;      // the length of this SMB
    PVOID       Buffer;         // pointer into SmbTracePortMemoryHeap
                                // or non-paged pool
    PVOID       SmbAddress;     // address of real SMB, if SMB still
                                // available (i.e. if slow mode)
    BOOLEAN     BufferNonPaged; // TRUE if Buffer in non-paged pool, FALSE if
                                // Buffer in SmbTracePortMemoryHeap
                                // Redirector-specific
    PKEVENT     WaitEvent;      // pointer to worker thread event to be
                                // signalled when SMB has been processed
                                // slow mode specific
} SMBTRACE_QUEUE_ENTRY, *PSMBTRACE_QUEUE_ENTRY;


//
// Instance data is specific to the component being traced.  In order
// to unclutter the source code, use the following macro to access
// instance specific data.
// Every exported function either has an explicit parameter (named
// Component) which the caller provides, or is implicitly applicable
// only to one component, and has a local variable named Component
// which is always set to the appropriate value.
//
#define ID(field) (SmbTraceData[Component].field)

//
// Instance data.  The fields which need to be statically initialized
// are declared before those that we don't care to initialize.
//
typedef struct _INSTANCE_DATA {

    //
    // Statically initialized fields.
    //

    //
    // Names for identifying the component being traced in KdPrint messages,
    // and global objects
    //
    PCHAR ComponentName;
    PWSTR SharedMemoryName;
    PWSTR NewSmbEventName;
    PWSTR DoneSmbEventName;

    //
    //  Prevent reinitializing resources if rdr/srv reloaded
    //
    BOOLEAN InstanceInitialized;

    //
    // some tracing parameters, from SmbTrace application
    //
    BOOLEAN SingleSmbMode;
    CLONG   Verbosity;

    //
    // State of the current trace.
    //
    SMBTRACE_STATE TraceState;

    //
    // Pointer to file object of client who started the current trace.
    //
    PFILE_OBJECT StartersFileObject;

    //
    // Fsp process of the component we're tracing in.
    //
    PEPROCESS FspProcess;

    //
    // All subsequent fields are not expliticly statically initiliazed.
    //

    //
    // Current count of number of SMBs lost since last one output.
    // Use an interlock to access, cleared when an SMB is sent to
    // the client successfully.  This lock is used with ExInterlockedXxx
    // routines, so it cannot be treated as a real spin lock (i.e.
    // don't use KeAcquireSpinLock.)
    //
    KSPIN_LOCK SmbsLostInterlock;
    ULONG      SmbsLost;

    //
    // some events, only accessed within the kernel
    //
    KEVENT ActiveEvent;
    KEVENT TerminatedEvent;
    KEVENT TerminationEvent;
    KEVENT AppTerminationEvent;
    KEVENT NeedMemoryEvent;

    //
    // some events, shared with the outside world
    //
    HANDLE NewSmbEvent;
    HANDLE DoneSmbEvent;

    //
    // Handle to the shared memory used for communication between
    // the server/redirector and SmbTrace.
    //
    HANDLE SectionHandle;

    //
    // Pointers to control the shared memory for the SmbTrace application.
    // The port memory heap handle is initialized to NULL to indicate that
    // there is no connection with SmbTrace yet.
    //
    PVOID PortMemoryBase;
    ULONG_PTR PortMemorySize;
    ULONG TableSize;
    PVOID PortMemoryHeap;

    //
    // serialized access to the heap,
    // to allow clean shutdown (StateInterlock)
    //
    KSPIN_LOCK  HeapReferenceCountLock;
    PERESOURCE  StateInterlock;
    PERESOURCE  HeapInterlock;
    ULONG       HeapReferenceCount;
     
    WORK_QUEUE_ITEM    DereferenceWorkQueueItem;

    //
    // Pointers to the structured data, located in the shared memory.
    //
    PSMBTRACE_TABLE_HEADER  TableHeader;
    PSMBTRACE_TABLE_ENTRY   Table;

    //
    // Fields for the SmbTrace queue.  The server/redirector puts
    // incoming and outgoing SMBs into this queue (when
    // SmbTraceActive[Component] is TRUE and they are processed
    // by the SmbTrace thread.
    //
    LIST_ENTRY Queue;            // The queue itself
    KSPIN_LOCK QueueInterlock;   // Synchronizes access to queue
    KSEMAPHORE QueueSemaphore;   // Counts elements in queue

} INSTANCE_DATA;


#ifdef  ALLOC_DATA_PRAGMA
#pragma data_seg("PAGESMBD")
#endif
//
// Global variables for SmbTrace support
//

INSTANCE_DATA SmbTraceData[] = {

    //
    // Server data
    //

    {
        "Srv",                                 // ComponentName
        SMBTRACE_SRV_SHARED_MEMORY_NAME,       // SharedMemoryName
        SMBTRACE_SRV_NEW_SMB_EVENT_NAME,       // NewSmbEventName
        SMBTRACE_SRV_DONE_SMB_EVENT_NAME,      // DoneSmbEventName

        FALSE,                                 // InstanceInitialized

        FALSE,                                 // SingleSmbMode
        SMBTRACE_VERBOSITY_ERROR,              // Verbosity

        TraceStopped,                          // TraceState

        NULL,                                  // StartersFileObject
        NULL                                   // FspProcess

        // rest of fields expected to get 'all-zeroes'
    },

    //
    // Redirector data
    //

    {
        "Rdr",                                 // ComponentName
        SMBTRACE_LMR_SHARED_MEMORY_NAME,       // SharedMemoryName
        SMBTRACE_LMR_NEW_SMB_EVENT_NAME,       // NewSmbEventName
        SMBTRACE_LMR_DONE_SMB_EVENT_NAME,      // DoneSmbEventName

        FALSE,                                 // InstanceInitialized

        FALSE,                                 // SingleSmbMode
        SMBTRACE_VERBOSITY_ERROR,              // Verbosity

        TraceStopped,                          // TraceState

        NULL,                                  // StartersFileObject
        NULL                                   // FspProcess

        // rest of fields expected to get 'all-zeroes'
    }
};


//
// some state booleans, exported to clients.  For this reason,
// they're stored separately from the rest of the instance data.
// Initially, SmbTrace is neither active nor transitioning.
//
BOOLEAN SmbTraceActive[] = {FALSE, FALSE};
BOOLEAN SmbTraceTransitioning[] = {FALSE, FALSE};

HANDLE
SmbTraceDiscardableCodeHandle = 0;

HANDLE
SmbTraceDiscardableDataHandle = 0;

#ifdef  ALLOC_DATA_PRAGMA
#pragma data_seg()
#endif

//
// Forward declarations of internal routines
//

BOOLEAN
SmbTraceReferenceHeap(
    IN SMBTRACE_COMPONENT Component
    );

VOID
SmbTraceDereferenceHeap(
    IN SMBTRACE_COMPONENT Component
    );

VOID
SmbTraceDisconnect(
    IN SMBTRACE_COMPONENT Component
    );

VOID
SmbTraceEmptyQueue (
    IN SMBTRACE_COMPONENT Component
    );

VOID
SmbTraceThreadEntry(
    IN PVOID Context
    );

NTSTATUS
SmbTraceFreeMemory (
    IN SMBTRACE_COMPONENT Component
    );

VOID
SmbTraceToClient(
    IN PVOID Smb,
    IN CLONG SmbLength,
    IN PVOID SmbAddress,
    IN SMBTRACE_COMPONENT Component
    );

ULONG
SmbTraceMdlLength(
    IN PMDL Mdl
    );

VOID
SmbTraceCopyMdlContiguous(
    OUT PVOID Destination,
    IN  PMDL Mdl,
    IN  ULONG Length
    );

//NTSTATUS
//DriverEntry(
//    IN PDRIVER_OBJECT DriverObject,
//    IN PUNICODE_STRING RegistryPath
//    );

VOID
SmbTraceDeferredDereferenceHeap(
    IN PVOID Context
    );

#ifdef  ALLOC_PRAGMA
#pragma alloc_text(PAGE, SmbTraceInitialize)
#pragma alloc_text(PAGE, SmbTraceTerminate)
#pragma alloc_text(PAGE, SmbTraceStart)
#pragma alloc_text(PAGE, SmbTraceStop)
#pragma alloc_text(PAGE, SmbTraceCompleteSrv)
#pragma alloc_text(PAGE, SmbTraceDisconnect)
#pragma alloc_text(PAGE, SmbTraceEmptyQueue)
#pragma alloc_text(PAGE, SmbTraceThreadEntry)
#pragma alloc_text(PAGE, SmbTraceFreeMemory)
#pragma alloc_text(PAGE, SmbTraceToClient)
#pragma alloc_text(PAGE, SmbTraceDeferredDereferenceHeap)
#pragma alloc_text(PAGESMBC, SmbTraceCompleteRdr)
#pragma alloc_text(PAGESMBC, SmbTraceReferenceHeap)
#pragma alloc_text(PAGESMBC, SmbTraceDereferenceHeap)
#pragma alloc_text(PAGESMBC, SmbTraceMdlLength)
#pragma alloc_text(PAGESMBC, SmbTraceCopyMdlContiguous)
#endif



//
// Exported routines
//


NTSTATUS
SmbTraceInitialize (
    IN SMBTRACE_COMPONENT Component
    )

/*++

Routine Description:

    This routine initializes the SmbTrace component-specific instance
    globals.  On first-ever invocation, it performs truly global
    initialization.

Arguments:

    Component - Context from which we're called: server or redirector

Return Value:

    NTSTATUS - Indicates failure if unable to allocate resources

--*/

{
    PAGED_CODE();

    if ( ID(InstanceInitialized) == FALSE ) {
        //
        // Component specific initialization -- events and locks.
        //

        KeInitializeEvent( &ID(ActiveEvent), NotificationEvent, FALSE);
        KeInitializeEvent( &ID(TerminatedEvent), NotificationEvent, FALSE);
        KeInitializeEvent( &ID(TerminationEvent), NotificationEvent, FALSE);
        KeInitializeEvent( &ID(AppTerminationEvent), NotificationEvent, FALSE);
        KeInitializeEvent( &ID(NeedMemoryEvent), NotificationEvent, FALSE);

        KeInitializeSpinLock( &ID(SmbsLostInterlock) );
        KeInitializeSpinLock( &ID(HeapReferenceCountLock) );

        ID(StateInterlock) = ExAllocatePoolWithTag(
                                NonPagedPool,
                                sizeof(ERESOURCE),
                                'tbmS'
                                );
        if ( ID(StateInterlock) == NULL ) {
            return STATUS_INSUFFICIENT_RESOURCES;
        }
        ExInitializeResourceLite( ID(StateInterlock) );

        ID(HeapInterlock) = ExAllocatePoolWithTag(
                                NonPagedPool,
                                sizeof(ERESOURCE),
                                'tbmS'
                                );
        if ( ID(HeapInterlock) == NULL ) {
            ExDeleteResourceLite( ID(StateInterlock) );
            ExFreePool( ID(StateInterlock) );
            ID(StateInterlock) = NULL;
            return STATUS_INSUFFICIENT_RESOURCES;
        }
        ExInitializeResourceLite( ID(HeapInterlock) );

        ID(InstanceInitialized) = TRUE;
    }

    return STATUS_SUCCESS;

} // SmbTraceInitialize


VOID
SmbTraceTerminate (
    IN SMBTRACE_COMPONENT Component
    )

/*++

Routine Description:

    This routine cleans up the SmbTrace component-specific instance
    globals.  It should be called by the component when the component
    is unloaded.

Arguments:

    Component - Context from which we're called: server or redirector

Return Value:

    None

--*/

{
    PAGED_CODE();

    if ( ID(InstanceInitialized) ) {

        ExDeleteResourceLite( ID(StateInterlock) );
        ExFreePool( ID(StateInterlock) );

        ExDeleteResourceLite( ID(HeapInterlock) );
        ExFreePool( ID(HeapInterlock) );

        ID(InstanceInitialized) = FALSE;
    }

    return;

} // SmbTraceTerminate


NTSTATUS
SmbTraceStart (
    IN ULONG InputBufferLength,
    IN ULONG OutputBufferLength,
    IN OUT PVOID ConfigInOut,
    IN PFILE_OBJECT FileObject,
    IN SMBTRACE_COMPONENT Component
    )

/*++

Routine Description:

    This routine performs all the work necessary to connect the server/
    redirector to SmbTrace.  It creates the section of shared memory to
    be used, then creates the events needed. All these objects are then
    opened by the client (smbtrace) program. This code initializes the
    table, the heap stored in the section and table header.  This routine
    must be called from an Fsp process.

Arguments:

    InputBufferLength - Length of the ConfigInOut packet

    OutputBufferLength - Length expected for the ConfigInOut packet returned

    ConfigInOut - A structure that has configuration information.

    FileObject - FileObject of the process requesting that SmbTrace be started,
                 used to automatically shut down when the app dies.

    Component - Context from which we're called: server or redirector

Return Value:

    NTSTATUS - result of operation.

--*/

// size of our one, particular, ACL
#define ACL_LENGTH  (ULONG)sizeof(ACL) +                 \
                    (ULONG)sizeof(ACCESS_ALLOWED_ACE) +  \
                    sizeof(LUID) +                       \
                    8

{
    NTSTATUS status;
    UNICODE_STRING memoryNameU;

    SID_IDENTIFIER_AUTHORITY NtAuthority = SECURITY_NT_AUTHORITY;
    UCHAR Buffer[ACL_LENGTH];
    PACL AdminAcl = (PACL)(&Buffer[0]);
    SECURITY_DESCRIPTOR securityDescriptor;

    UNICODE_STRING eventNameU;
    OBJECT_ATTRIBUTES objectAttributes;
    ULONG i;
    LARGE_INTEGER sectionSize;
    PSMBTRACE_CONFIG_PACKET_REQ  ConfigPacket;
    PSMBTRACE_CONFIG_PACKET_RESP ConfigPacketResp;
    HANDLE threadHandle;

    PAGED_CODE();

    ASSERT( ID(InstanceInitialized) );

    //
    // Validate the buffer lengths passed in.
    //

    if ( ( InputBufferLength  != sizeof( SMBTRACE_CONFIG_PACKET_REQ ) )
      || ( OutputBufferLength != sizeof( SMBTRACE_CONFIG_PACKET_RESP ) )
    ) {

        TrPrint(( "%s!SmbTraceStart: config packet(s) of wrong size!\n",
                  ID(ComponentName) ));

        return STATUS_INFO_LENGTH_MISMATCH;

    }

    ExAcquireResourceExclusiveLite( ID(StateInterlock), TRUE );

    if ( ID(TraceState) != TraceStopped ) {
        ExReleaseResourceLite( ID(StateInterlock) );
        return STATUS_INVALID_DEVICE_STATE;
    }

    ASSERT(!SmbTraceActive[Component]);

    ASSERT (SmbTraceDiscardableDataHandle == NULL);

    ASSERT (SmbTraceDiscardableCodeHandle == NULL);

    SmbTraceDiscardableCodeHandle = MmLockPagableCodeSection(SmbTraceReferenceHeap);

    SmbTraceDiscardableDataHandle = MmLockPagableDataSection(SmbTraceData);

    ID(TraceState) = TraceStarting;

    //
    // Initialize global variables so that we know what to close on errexit
    //

    ID(SectionHandle) = NULL;
    ID(PortMemoryHeap) = NULL;
    ID(NewSmbEvent) = NULL;
    ID(DoneSmbEvent) = NULL;

    //
    // Caution! Both input and output packets are the same, we must
    // read all of the input before we write any output.
    //

    ConfigPacket = (PSMBTRACE_CONFIG_PACKET_REQ) ConfigInOut;
    ConfigPacketResp = (PSMBTRACE_CONFIG_PACKET_RESP) ConfigInOut;

    //
    // Set the mode of operation (read all values).
    //

    ID(SingleSmbMode)  = ConfigPacket->SingleSmbMode;
    ID(Verbosity)      = ConfigPacket->Verbosity;
    ID(PortMemorySize) = ConfigPacket->BufferSize;
    ID(TableSize)      = ConfigPacket->TableSize;

    //
    // Create a security descriptor containing a discretionary Acl
    // allowing administrator access.  This SD will be used to allow
    // Smbtrace access to the shared memory and the notification events.
    //

    // Create Acl allowing administrator access using well-known Sid.

    status = RtlCreateAcl( AdminAcl, ACL_LENGTH, ACL_REVISION2 );
    if ( !NT_SUCCESS(status) ) {
        TrPrint((
            "%s!SmbTraceStart: RtlCreateAcl failed: %X\n",
            ID(ComponentName), status ));
        goto errexit;
    }

    status = RtlAddAccessAllowedAce(
             AdminAcl,
             ACL_REVISION2,
             GENERIC_ALL,
             SeExports->SeAliasAdminsSid
             );
    if ( !NT_SUCCESS(status) ) {
        TrPrint((
            "%s!SmbTraceStart: RtlAddAccessAllowedAce failed: %X\n",
            ID(ComponentName), status ));
        goto errexit;
    }

    // Create SecurityDescriptor containing AdminAcl as a discrectionary ACL.

    RtlCreateSecurityDescriptor(
             &securityDescriptor,
             SECURITY_DESCRIPTOR_REVISION1
             );
    if ( !NT_SUCCESS(status) ) {
        TrPrint((
            "%s!SmbTraceStart: RtlCreateSecurityDescriptor failed: %X\n",
            ID(ComponentName), status ));
        goto errexit;
    }

    status = RtlSetDaclSecurityDescriptor(
             &securityDescriptor,
             TRUE,
             AdminAcl,
             FALSE
             );
    if ( !NT_SUCCESS(status) ) {
        TrPrint((
            "%s!SmbTraceStart: "
            "RtlSetDAclAllowedSecurityDescriptor failed: %X\n",
            ID(ComponentName), status ));
        goto errexit;
    }

    //
    // Create the section to be used for communication between the
    // server/redirector and SmbTrace.
    //

    // Define the object name.

    RtlInitUnicodeString( &memoryNameU, ID(SharedMemoryName) );

    // Define the object information, including security descriptor and name.

    InitializeObjectAttributes(
        &objectAttributes,
        &memoryNameU,
        OBJ_CASE_INSENSITIVE,
        NULL,
        &securityDescriptor
        );

    // Setup the section size.

    sectionSize.QuadPart = ID(PortMemorySize);

    // Create the named section of memory with all of our attributes.

    status = ZwCreateSection(
                &ID(SectionHandle),
                SECTION_MAP_READ | SECTION_MAP_WRITE,
                &objectAttributes,
                &sectionSize,
                PAGE_READWRITE,
                SEC_RESERVE,
                NULL                        // file handle
                );

    if ( !NT_SUCCESS(status) ) {
        TrPrint(( "%s!SmbTraceStart: ZwCreateSection failed: %X\n",
                  ID(ComponentName), status ));
        goto errexit;
    }

    // Now, map it into our address space.

    ID(PortMemoryBase) = NULL;

    status = ZwMapViewOfSection(
                    ID(SectionHandle),
                    NtCurrentProcess(),
                    &ID(PortMemoryBase),
                    0,                        // zero bits (don't care)
                    0,                        // commit size
                    NULL,                     // SectionOffset
                    &ID(PortMemorySize),      // viewSize
                    ViewUnmap,                // inheritDisposition
                    0L,                       // allocation type
                    PAGE_READWRITE            // protection
                    );

    if ( !NT_SUCCESS(status) ) {
        TrPrint(( "%s!SmbTraceStart: NtMapViewOfSection failed: %X\n",
                  ID(ComponentName), status ));
        goto errexit;
    }

    //
    // Set up the shared section memory as a heap.
    //
    // *** Note that the HeapInterlock for the client instance is passed
    //     to the heap manager to be used for serialization of
    //     allocation and deallocation.  It is necessary for the
    //     resource to be allocated FROM NONPAGED POOL externally to the
    //     heap manager, because if we let the heap manager allocate
    //     the resource, if would allocate it from process virtual
    //     memory.
    //

    ID(PortMemoryHeap) = RtlCreateHeap(
                              0,                            // Flags
                              ID(PortMemoryBase),           // HeapBase
                              ID(PortMemorySize),           // ReserveSize
                              PAGE_SIZE,                    // CommitSize
                              ID(HeapInterlock),            // Lock
                              0                             // Reserved
                              );

    //
    // Allocate and initialize the table and its header.
    //

    ID(TableHeader) = RtlAllocateHeap(
                                    ID(PortMemoryHeap), 0,
                                    sizeof( SMBTRACE_TABLE_HEADER )
                                    );

    ID(Table) = RtlAllocateHeap(
                        ID(PortMemoryHeap), 0,
                        sizeof( SMBTRACE_TABLE_ENTRY ) * ID(TableSize)
                        );

    if ( (ID(TableHeader) == NULL) || (ID(Table) == NULL) ) {
        TrPrint((
            "%s!SmbTraceStart: Not enough memory!\n",
            ID(ComponentName) ));

        status = STATUS_NO_MEMORY;

        goto errexit;
    }

    // Initialize the values inside.

    ID(TableHeader)->HighestConsumed = 0;
    ID(TableHeader)->NextFree = 1;
    ID(TableHeader)->ApplicationStop = FALSE;

    for ( i = 0; i < ID(TableSize); i++) {
        ID(Table)[i].BufferOffset = 0L;
        ID(Table)[i].SmbLength = 0L;
    }

    //
    // Create the required event handles.
    //

    // Define the object information.

    RtlInitUnicodeString( &eventNameU, ID(NewSmbEventName) );

    InitializeObjectAttributes(
        &objectAttributes,
        &eventNameU,
        OBJ_CASE_INSENSITIVE,
        NULL,
        &securityDescriptor
        );

    // Open the named object.

    status = ZwCreateEvent(
                &ID(NewSmbEvent),
                EVENT_ALL_ACCESS,
                &objectAttributes,
                NotificationEvent,
                FALSE                        // initial state
                );

    if ( !NT_SUCCESS(status) ) {
        TrPrint(( "%s!SmbTraceStart: ZwCreateEvent (1st) failed: %X\n",
                  ID(ComponentName), status ));

        goto errexit;
    }

    if ( ID(SingleSmbMode) ) {    // this event may not be required.

        // Define the object information.

        RtlInitUnicodeString( &eventNameU, ID(DoneSmbEventName) );

        InitializeObjectAttributes(
            &objectAttributes,
            &eventNameU,
            OBJ_CASE_INSENSITIVE,
            NULL,
            &securityDescriptor
            );

        // Create the named object.

        status = ZwCreateEvent(
                    &ID(DoneSmbEvent),
                    EVENT_ALL_ACCESS,
                    &objectAttributes,
                    NotificationEvent,
                    FALSE                    // initial state
                    );

        if ( !NT_SUCCESS(status) ) {
            TrPrint((
                "%s!SmbTraceStart: NtCreateEvent (2nd) failed: %X\n",
                 ID(ComponentName), status ));
            goto errexit;
        }
        TrPrint(( "%s!SmbTraceStart: DoneSmbEvent handle %x in process %x\n",
                ID(ComponentName), ID(DoneSmbEvent), PsGetCurrentProcess()));

    }

    //
    //  Reset any events that may be in the wrong state from a previous run.
    //

    KeResetEvent(&ID(TerminationEvent));
    KeResetEvent(&ID(TerminatedEvent));

    //
    // Connection was successful, now start the SmbTrace thread.
    //

    //
    // Create the SmbTrace thread and wait for it to finish
    // initializing (at which point SmbTraceActiveEvent is set)
    //

    status = PsCreateSystemThread(
        &threadHandle,
        THREAD_ALL_ACCESS,
        NULL,
        NtCurrentProcess(),
        NULL,
        (PKSTART_ROUTINE) SmbTraceThreadEntry,
        (PVOID)Component
        );

    if ( !NT_SUCCESS(status) ) {

        TrPrint((
            "%s!SmbTraceStart: PsCreateSystemThread failed: %X\n",
            ID(ComponentName), status ));

        goto errexit;
    }

    //
    // Wait until SmbTraceThreadEntry has finished initializing
    //

    (VOID)KeWaitForSingleObject(
            &ID(ActiveEvent),
            UserRequest,
            KernelMode,
            FALSE,
            NULL
            );

    //
    // Close the handle to the process so the object will be
    // destroyed when the thread dies.
    //

    ZwClose( threadHandle );


    //
    // Record who started SmbTrace so we can stop if he dies or otherwise
    // closes this handle to us.
    //

    ID(StartersFileObject) = FileObject;

    //
    // Record caller's process; which is always the appropriate Fsp
    // process.
    //

    ID(FspProcess) = PsGetCurrentProcess();


    //
    // Setup the response packet, since everything worked (write all values).
    //

    ConfigPacketResp->HeaderOffset = (ULONG)
                                ( (ULONG_PTR)ID(TableHeader)
                                - (ULONG_PTR)ID(PortMemoryBase) );

    ConfigPacketResp->TableOffset = (ULONG)
                                ( (ULONG_PTR)ID(Table)
                                - (ULONG_PTR)ID(PortMemoryBase) );

    TrPrint(( "%s!SmbTraceStart: SmbTrace started.\n", ID(ComponentName) ));

    ExReleaseResourceLite( ID(StateInterlock) );

    //
    // if someone wanted it shut down while it was starting, shut it down
    //

    switch ( ID(TraceState) ) {

    case TraceStartStopFile :
        SmbTraceStop( ID(StartersFileObject), Component );
        return STATUS_UNSUCCESSFUL;  // app closed, so we should shut down
        break;

    case TraceStartStopNull :
        SmbTraceStop( NULL, Component );
        return STATUS_UNSUCCESSFUL;  // someone requested a shut down
        break;

    default :
        ID(TraceState) = TraceRunning;
        SmbTraceActive[Component] = TRUE;
        return STATUS_SUCCESS;
    }

errexit:

    SmbTraceDisconnect( Component );

    ID(TraceState) = TraceStopped;

    ExReleaseResourceLite( ID(StateInterlock) );

    //
    // return original failure status code, not success of cleanup
    //

    return status;

} // SmbTraceStart

// constant only of interest while constructing the particular Acl
// in SmbTraceStart
#undef ACL_LENGTH


NTSTATUS
SmbTraceStop(
    IN PFILE_OBJECT FileObject OPTIONAL,
    IN SMBTRACE_COMPONENT Component
    )

/*++

Routine Description:

    This routine stops tracing in the server/redirector.  If no
    FileObject is provided, the SmbTrace application is stopped.
    If a FileObject is provided, SmbTrace is stopped if the
    FileObject refers to the one who started it.

Arguments:

    FileObject - FileObject of a process that terminated.  If it's the process
                 that requested SmbTracing, we shut down automatically.

    Component - Context from which we're called: server or redirector

Return Value:

    NTSTATUS - result of operation.  Possible results are:
        STATUS_SUCCESS - SmbTrace was stopped
        STATUS_UNSUCCESSFUL - SmbTrace was not stopped because the
            provided FileObject did not refer to the SmbTrace starter
            or because SmbTrace was not running.

--*/

{
    PAGED_CODE();

    //
    // If we haven't been initialized, there's nothing to stop.  (And no
    // resource to acquire!)
    //

    if ( !ID(InstanceInitialized) ) {
        return STATUS_UNSUCCESSFUL;
    }

    //
    // If it's not the FileObject that started SmbTrace, we don't care.
    // From then on, if ARGUMENT_PRESENT(FileObject) it's the right one.
    //

    if ( ARGUMENT_PRESENT(FileObject) &&
         FileObject != ID(StartersFileObject)
    ) {
       return STATUS_UNSUCCESSFUL;
    }

    ExAcquireResourceExclusiveLite( ID(StateInterlock), TRUE );

    //
    // Depending on the current state of SmbTrace and whether this is
    // a FileObject or unconditional shutdown request, we do different
    // things.  It is always clear at this point, though, that
    // SmbTraceActive should be set to FALSE.
    //

    SmbTraceActive[Component] = FALSE;

    switch ( ID(TraceState) ) {
    case TraceStopped :
    case TraceStopping :
    case TraceStartStopFile :
    case TraceStartStopNull :

        // if we're not running or already in a mode where we know we'll
        // soon be shut down, ignore the request.
        ExReleaseResourceLite( ID(StateInterlock) );
        return STATUS_UNSUCCESSFUL;
        break;

    case TraceStarting :

        // inform starting SmbTrace that it should shut down immediately
        // upon finishing initialization.  It needs to know whether this
        // is a FileObject or unconditional shutdown request.

        ID(TraceState) = ARGUMENT_PRESENT(FileObject)
                       ? TraceStartStopFile
                       : TraceStartStopNull;
        ExReleaseResourceLite( ID(StateInterlock) );
        return STATUS_SUCCESS;
        break;

    case TraceAppWaiting :

        // we're waiting for the application to die already, so ignore
        // new unconditional requests.  But FileObject requests are
        // welcomed.  We cause the SmbTrace thread to kill itself.
        if ( ARGUMENT_PRESENT(FileObject) ) {
            break;  // thread kill code follows switch
        } else {
            ExReleaseResourceLite( ID(StateInterlock) );
            return STATUS_UNSUCCESSFUL;
        }
        break;

    case TraceRunning :

        // if it's a FileObject request, the app is dead, so we cause
        // the SmbTrace thread to kill itself.  Otherwise, we need to
        // signal the app to stop and return.  When the app is gone, we
        // will be called again; this time with a FileObject.

        if ( ARGUMENT_PRESENT(FileObject) ) {
            break;  // thread kill code follows switch
        } else {
            KeSetEvent( &ID(AppTerminationEvent), 2, FALSE );
            ID(TraceState) = TraceAppWaiting;
            ExReleaseResourceLite( ID(StateInterlock) );
            return STATUS_SUCCESS;
        }

        break;

    default :
        ASSERT(!"SmbTraceStop: invalid TraceState");
        break;
    }

    //
    // We reach here from within the switch only in the case where
    // we actually want to kill the SmbTrace thread.  Signal it to
    // wake up, and wait until it terminates.  Signal DoneSmbEvent
    // in case it is currently waiting for the application to signal
    // it in slow mode.
    //

    ID(StartersFileObject) = NULL;

    if ( ID(SingleSmbMode)) {

        BOOLEAN ProcessAttached = FALSE;

        if (PsGetCurrentProcess() != ID(FspProcess)) {
            KeAttachProcess(ID(FspProcess));
            ProcessAttached = TRUE;
        }

        TrPrint(( "%s!SmbTraceStop: Signal DoneSmbEvent, handle %x, process %x.\n",
                    ID(ComponentName), ID(DoneSmbEvent), PsGetCurrentProcess()));
        ZwSetEvent( ID(DoneSmbEvent), NULL );

        if (ProcessAttached) {
            KeDetachProcess();
        }

    }

    TrPrint(( "%s!SmbTraceStop: Signal Termination Event.\n", ID(ComponentName) ));
    ID(TraceState) = TraceStopping;
    KeSetEvent( &ID(TerminationEvent), 2, FALSE );

    ExReleaseResourceLite( ID(StateInterlock) );

    KeWaitForSingleObject(
        &ID(TerminatedEvent),
        UserRequest,
        KernelMode,
        FALSE,
        NULL
        );

    TrPrint(( "%s!SmbTraceStop: Terminated Event is set.\n", ID(ComponentName) ));
    ExAcquireResourceExclusiveLite( ID(StateInterlock), TRUE );

    ID(TraceState) = TraceStopped;

    ExReleaseResourceLite( ID(StateInterlock) );

    TrPrint(( "%s!SmbTraceStop: SmbTrace stopped.\n", ID(ComponentName) ));

    MmUnlockPagableImageSection(SmbTraceDiscardableCodeHandle);

    SmbTraceDiscardableCodeHandle = NULL;

    MmUnlockPagableImageSection(SmbTraceDiscardableDataHandle);

    SmbTraceDiscardableDataHandle = NULL;

    return STATUS_SUCCESS;

} // SmbTraceStop


VOID
SmbTraceCompleteSrv (
    IN PMDL SmbMdl,
    IN PVOID Smb,
    IN CLONG SmbLength
    )

/*++

Routine Description:

    Server version.

    Snapshot an SMB and export it to the SmbTrace application.  How
    this happens is determined by which mode (fast or slow) SmbTracing
    was requested in.  In the server, it is easy to guarantee that when
    tracing, a thread is always executing in the Fsp.

    Fast mode: the SMB is copied into shared memory and an entry for it
    is queued to the server SmbTrace thread, which asynchronously
    passes SMBs to the app.  If there is insufficient memory
    for anything (SMB, queue entry, etc.) the SMB is lost.

    Slow mode: identical to Fast mode except that this thread waits
    until the server SmbTrace thread signals that the app has finished
    processing the SMB.  Because each thread waits until its SMB has
    been completely processed, there is much less chance of running
    out of any resources.

    The SMB is either contained in SmbMdl, or at address Smb with length
    SmbLength.

Arguments:

    SmbMdl - an Mdl containing the SMB.

    Smb - a pointer to the SMB.

    SmbLength - the length of the SMB.

Return Value:

    None

--*/

{
    PSMBTRACE_QUEUE_ENTRY  queueEntry;
    PVOID  buffer;
    SMBTRACE_COMPONENT Component = SMBTRACE_SERVER;
    KEVENT WaitEvent;

    PAGED_CODE();

    //
    // This routine is server specific.
    //

    ASSERT( ID(TraceState) == TraceRunning );
    ASSERT( SmbTraceActive[SMBTRACE_SERVER] );

    //
    // We want either an Mdl, or a pointer and a length, or occasionally,
    // a completely NULL response.
    //

    ASSERT( ( SmbMdl == NULL  &&  Smb != NULL  &&  SmbLength != 0 )
         || ( SmbMdl != NULL  &&  Smb == NULL  &&  SmbLength == 0 )
         || ( SmbMdl == NULL  &&  Smb == NULL  &&  SmbLength == 0 ) );

    //
    // We've taken pains not to be at DPC level and to be in
    // the Fsp context too, for that matter.
    //

    ASSERT( KeGetCurrentIrql() < DISPATCH_LEVEL);
    ASSERT( PsGetCurrentProcess() == ID(FspProcess) );

    //
    // Ensure that SmbTrace really is still active and hence, the
    // shared memory is still around.
    //

    if ( SmbTraceReferenceHeap( Component ) == FALSE ) {
        return;
    }

    //
    // If the SMB is currently in an MDL, we don't yet have the length,
    // which we need, to know how much memory to allocate.
    //

    if ( SmbMdl != NULL ) {
        SmbLength = SmbTraceMdlLength(SmbMdl);
    }

    //
    // If we are in slow mode, then we wait after queuing the SMB
    // to the SmbTrace thread.  If we are set for fast mode we
    // garbage collect in case of no memory.
    //

    if ( ID(SingleSmbMode) ) {
        KeInitializeEvent( &WaitEvent, NotificationEvent, FALSE );
    }

    queueEntry = ExAllocatePoolWithTag( NonPagedPool,
                                        sizeof(SMBTRACE_QUEUE_ENTRY),
                                        'tbmS'
                                        );

    if ( queueEntry == NULL ) {
        // No free memory, this SMB is lost.  Record its loss.
        LOCK_INC_ID(SmbsLost);
        SmbTraceDereferenceHeap( Component );
        return;
    }

    //
    // Allocate the required amount of memory in our heap
    // in the shared memory.
    //

    buffer = RtlAllocateHeap( ID(PortMemoryHeap), 0, SmbLength );

    if ( buffer == NULL ) {
        // No free memory, this SMB is lost.  Record its loss.
        // Very unlikely in slow mode.
        LOCK_INC_ID(SmbsLost);
        ExFreePool( queueEntry );

        if ( !ID(SingleSmbMode) ) {
            //
            // Encourage some garbage collection.
            //
            KeSetEvent( &ID(NeedMemoryEvent), 0, FALSE );
        }

        SmbTraceDereferenceHeap( Component );
        return;
    }

    //
    // Copy the SMB to shared memory pointed to by the queue entry,
    // keeping in mind whether it's in an Mdl or contiguous to begin
    // with, and also preserving the address of the real SMB...
    //

    if ( SmbMdl != NULL ) {
        SmbTraceCopyMdlContiguous( buffer, SmbMdl, SmbLength );
        queueEntry->SmbAddress = SmbMdl;
    } else {
        RtlCopyMemory( buffer, Smb, SmbLength );
        queueEntry->SmbAddress = Smb;
    }

    queueEntry->SmbLength = SmbLength;
    queueEntry->Buffer = buffer;
    queueEntry->BufferNonPaged = FALSE;

    //
    // In slow mode, we want to wait until the SMB has been eaten,
    // in fast mode, we don't want to pass the address of the real
    // SMB along, since the SMB is long gone by the time it gets
    // decoded and printed.
    //

    if ( ID(SingleSmbMode) ) {
        queueEntry->WaitEvent = &WaitEvent;
    } else {
        queueEntry->WaitEvent = NULL;
        queueEntry->SmbAddress = NULL;
    }

    //
    // ...queue the entry to the SmbTrace thread...
    //

    ExInterlockedInsertTailList(
            &ID(Queue),
            &queueEntry->ListEntry,
            &ID(QueueInterlock)
            );

    KeReleaseSemaphore(
            &ID(QueueSemaphore),
            SEMAPHORE_INCREMENT,
            1,
            FALSE
            );

    //
    // ...and wait for the SMB to be eaten, in slow mode.
    //

    if ( ID(SingleSmbMode) ) {
        TrPrint(( "%s!SmbTraceCompleteSrv: Slow mode wait\n", ID(ComponentName) ));
        KeWaitForSingleObject(
            &WaitEvent,
            UserRequest,
            KernelMode,
            FALSE,
            NULL
            );
        TrPrint(( "%s!SmbTraceCompleteSrv: Slow mode wait done\n", ID(ComponentName) ));
    }

    SmbTraceDereferenceHeap( Component );

    return;

} // SmbTraceCompleteSrv


VOID
SmbTraceCompleteRdr (
    IN PMDL SmbMdl,
    IN PVOID Smb,
    IN CLONG SmbLength
    )

/*++

Routine Description:

    Redirector version

    Snapshot an SMB and export it to the SmbTrace application.  How
    this happens is determined by which mode (fast or slow) SmbTracing
    was requested in, and which context (DPC, Fsp or Fsd) the current
    thread is executing in.

    Fast mode: the SMB is copied into shared memory and an entry for it
    is queued to the redirector SmbTrace thread, which asynchronously
    passes SMBs to the app.  (When in DPC, the SMB is copied to non-paged
    pool instead of shared memory, and the SmbTrace thread deals with
    moving it to shared memory later.)  If there is insufficient memory
    for anything (SMB, queue entry, etc.) the SMB is lost.

    Slow mode: identical to Fast mode except that this thread waits
    until the server SmbTrace thread signals that the app has finished
    processing the SMB.  Because each thread waits until its SMB has
    been completely processed, there is much less chance of running
    out of any resources. If at DPC level, we behave exactly as in the
    fast mode case, because it would be a Bad Thing to block this thread
    at DPC level.

    The SMB is either contained in SmbMdl, or at address Smb with length
    SmbLength.

Arguments:

    SmbMdl - an Mdl containing the SMB.

    Smb - a pointer to the SMB.

    SmbLength - the length of the SMB.

Return Value:

    None

--*/

{
    PSMBTRACE_QUEUE_ENTRY  queueEntry;
    PVOID  buffer;
    BOOLEAN ProcessAttached = FALSE;
    BOOLEAN AtDpcLevel;
    SMBTRACE_COMPONENT Component = SMBTRACE_REDIRECTOR;
    KEVENT WaitEvent;

    //
    // This routine is redirector specific.
    //

    ASSERT( ID(TraceState) == TraceRunning );
    ASSERT( SmbTraceActive[SMBTRACE_REDIRECTOR] );

    //
    // We want either an Mdl, or a pointer and a length, or occasionally,
    // a completely NULL response
    //

    ASSERT( ( SmbMdl == NULL  &&  Smb != NULL  &&  SmbLength != 0 )
         || ( SmbMdl != NULL  &&  Smb == NULL  &&  SmbLength == 0 )
         || ( SmbMdl == NULL  &&  Smb == NULL  &&  SmbLength == 0 ) );

    //
    // Ensure that SmbTrace really is still active and hence, the
    // shared memory is still around.
    //

    if ( SmbTraceReferenceHeap( Component ) == FALSE ) {
        return;
    }

    //
    // To avoid multiple system calls, we find out once and for all.
    //

    AtDpcLevel = (BOOLEAN)(KeGetCurrentIrql() >= DISPATCH_LEVEL);

    //
    // If the SMB is currently in an MDL, we don't yet have the length,
    // which we need to know how much memory to allocate.
    //

    if ( SmbMdl != NULL ) {
        SmbLength = SmbTraceMdlLength(SmbMdl);
    }

    //
    // If we are in slow mode, then we wait after queuing the SMB
    // to the SmbTrace thread.  If we are set for fast mode we
    // garbage collect in case of no memory.  If we're at DPC level,
    // we store the SMB in non-paged pool.
    //

    if ( ID(SingleSmbMode) ) {
        KeInitializeEvent( &WaitEvent, NotificationEvent, FALSE );
    }

    //
    // allocate queue entry
    //

    queueEntry = ExAllocatePoolWithTag(
                     NonPagedPool,
                     sizeof(SMBTRACE_QUEUE_ENTRY),
                     'tbmS'
                     );

    if ( queueEntry == NULL ) {
        // No free memory, this SMB is lost.  Record its loss.
        LOCK_INC_ID(SmbsLost);
        SmbTraceDereferenceHeap( Component );
        return;
    }

    //
    // allocate buffer for SMB, in non-paged pool or shared heap as
    // appropriate
    //

    if ( AtDpcLevel ) {

        buffer = ExAllocatePoolWithTag( NonPagedPool, SmbLength, 'tbmS' );
        queueEntry->BufferNonPaged = TRUE;

    } else {

        if ( PsGetCurrentProcess() != ID(FspProcess) ) {
            KeAttachProcess(ID(FspProcess));
            ProcessAttached = TRUE;
        }

        buffer = RtlAllocateHeap( ID(PortMemoryHeap), 0, SmbLength );
        queueEntry->BufferNonPaged = FALSE;

    }

    if ( buffer == NULL ) {

        if ( ProcessAttached ) {
            KeDetachProcess();
        }

        // No free memory, this SMB is lost.  Record its loss.
        LOCK_INC_ID(SmbsLost);

        if (!ID(SingleSmbMode)) {

            //
            // If it was shared memory we ran out of, encourage
            // some garbage collection.
            //
            if ( !queueEntry->BufferNonPaged ) {
                KeSetEvent( &ID(NeedMemoryEvent), 0, FALSE );
            }
        }

        ExFreePool( queueEntry );
        SmbTraceDereferenceHeap( Component );
        return;
    }

    //
    // Copy the SMB to shared or non-paged memory pointed to by the
    // queue entry, keeping in mind whether it's in an Mdl or contiguous
    // to begin with, and also preserving the address of the real SMB...
    //

    if ( SmbMdl != NULL ) {
        SmbTraceCopyMdlContiguous( buffer, SmbMdl, SmbLength );
        queueEntry->SmbAddress = SmbMdl;
    } else {
        RtlCopyMemory( buffer, Smb, SmbLength );
        queueEntry->SmbAddress = Smb;
    }

    if ( ProcessAttached ) {
        KeDetachProcess();
    }

    queueEntry->SmbLength = SmbLength;
    queueEntry->Buffer = buffer;

    //
    // In slow mode, we want to wait until the SMB has been eaten,
    // in fast mode, we don't want to pass the address of the real
    // SMB along, since the SMB is long gone by the time it gets
    // decoded and printed.
    //

    if ( ID(SingleSmbMode) && !AtDpcLevel ) {
        queueEntry->WaitEvent = &WaitEvent;
    } else {
        queueEntry->WaitEvent = NULL;
        queueEntry->SmbAddress = NULL;
    }

    //
    // ...queue the entry to the SmbTrace thread...
    //

    ExInterlockedInsertTailList(
            &ID(Queue),
            &queueEntry->ListEntry,
            &ID(QueueInterlock)
            );

    KeReleaseSemaphore(
            &ID(QueueSemaphore),
            SEMAPHORE_INCREMENT,
            1,
            FALSE
            );

    //
    // ...and wait for the SMB to be eaten, in slow mode.
    //

    if ( ID(SingleSmbMode) && !AtDpcLevel ) {
        TrPrint(( "%s!SmbTraceCompleteRdr: Slow mode wait\n", ID(ComponentName) ));
        KeWaitForSingleObject(
            &WaitEvent,
            UserRequest,
            KernelMode,
            FALSE,
            NULL
            );
        TrPrint(( "%s!SmbTraceCompleteRdr: Slow mode wait done\n", ID(ComponentName) ));
    }

    SmbTraceDereferenceHeap( Component );

    return;

} // SmbTraceCompleteRdr


//
// Internal routines
//


BOOLEAN
SmbTraceReferenceHeap(
    IN SMBTRACE_COMPONENT Component
    )

/*++

Routine Description:

    This routine references the SmbTrace shared memory heap,
    ensuring it isn't disposed of while caller is using it.

Arguments:

    Component - Context from which we're called: server or redirector

Return Value:

    BOOLEAN - TRUE if SmbTrace is still active, and hence
              heap exists and was successfully referenced.
              FALSE otherwise.

--*/

{
    BOOLEAN retval = TRUE;  // assume we'll get it
    KIRQL OldIrql;

    ACQUIRE_SPIN_LOCK( &ID(HeapReferenceCountLock), &OldIrql );

    if ( ID(TraceState) != TraceRunning ) {
        retval = FALSE;
    } else {
        ASSERT( ID(HeapReferenceCount) > 0 );
        if( ID(HeapReferenceCount) > 0 )
        {
            ID(HeapReferenceCount)++;
            TrPrint(( "%s!SmbTraceReferenceHeap: Count now %lx\n",
                ID(ComponentName),
                ID(HeapReferenceCount) ));
        }
        else
        {
            retval = FALSE;
        }
    }

    RELEASE_SPIN_LOCK( &ID(HeapReferenceCountLock), OldIrql );

    return retval;

} // SmbTraceReferenceHeap


VOID
SmbTraceDeferredDereferenceHeap(
    IN PVOID Context
    )
/*++

Routine Description:

    If a caller dereferences a heap to 0 from DPC_LEVEL, this routine will
    be called in a system thread to complete the dereference at task time.

Arguments:

    Component - Context from which we're called: server or redirector

Return Value:

    None

--*/

{
    PAGED_CODE();

    SmbTraceDereferenceHeap((SMBTRACE_COMPONENT)Context);
}


VOID
SmbTraceDereferenceHeap(
    IN SMBTRACE_COMPONENT Component
    )

/*++

Routine Description:

    This routine dereferences the SmbTrace shared memory heap,
    disposing of it when the reference count is zero.

Arguments:

    Component - Context from which we're called: server or redirector

Return Value:

    None

--*/

{
    ULONG oldCount;
    KIRQL OldIrql;

    ACQUIRE_SPIN_LOCK( &ID(HeapReferenceCountLock), &OldIrql );

    if (ID(HeapReferenceCount) > 1) {
        ID(HeapReferenceCount) --;

        TrPrint(( "%s!SmbTraceDereferenceHeap: Count now %lx\n",
            ID(ComponentName),
            ID(HeapReferenceCount) ));

        RELEASE_SPIN_LOCK( &ID(HeapReferenceCountLock), OldIrql );

        return;
    }

    RELEASE_SPIN_LOCK( &ID(HeapReferenceCountLock), OldIrql );

    //
    //  If we are executing at DPC_LEVEL, we cannot dereference the heap
    //  to 0.
    //

    if (KeGetCurrentIrql() >= DISPATCH_LEVEL) {
        ExInitializeWorkItem(&ID(DereferenceWorkQueueItem), SmbTraceDeferredDereferenceHeap, (PVOID)Component);

        ExQueueWorkItem(&ID(DereferenceWorkQueueItem), DelayedWorkQueue);

        return;

    }

    ACQUIRE_SPIN_LOCK( &ID(HeapReferenceCountLock), &OldIrql );

    oldCount = ID(HeapReferenceCount)--;

    TrPrint(( "%s!SmbTraceDereferenceHeap: Count now %lx\n",
        ID(ComponentName),
        ID(HeapReferenceCount) ));

    RELEASE_SPIN_LOCK( &ID(HeapReferenceCountLock), OldIrql );

    if ( oldCount == 1 ) {

        //
        // Free the section, release the handles and such.
        //

        SmbTraceDisconnect( Component );
    }

    return;

} // SmbTraceDereferenceHeap


VOID
SmbTraceDisconnect (
    IN SMBTRACE_COMPONENT Component
    )

/*++

Routine Description:

    This routine reverses all the effects of SmbTraceStart. Mostly,
    it just needs to close certain handles to do this.

Arguments:

    Component - Context from which we're called: server or redirector

Return Value:

    None - always works

--*/

{
    BOOLEAN ProcessAttached = FALSE;

    PAGED_CODE();

    if (PsGetCurrentProcess() != ID(FspProcess)) {
        KeAttachProcess(ID(FspProcess));
        ProcessAttached = TRUE;

    }


    if ( ID(DoneSmbEvent) != NULL ) {
        // Worker thread may be blocked on this, so we set it first
        TrPrint(( "%s!SmbTraceDisconnect: Signal DoneSmbEvent, handle %x, process %x.\n",
                    ID(ComponentName), ID(DoneSmbEvent), PsGetCurrentProcess()));
        ZwSetEvent( ID(DoneSmbEvent), NULL );

        TrPrint(( "%s!SmbTraceDisconnect: Close DoneSmbEvent, handle %x, process %x.\n",
                    ID(ComponentName), ID(DoneSmbEvent), PsGetCurrentProcess()));
        ZwClose( ID(DoneSmbEvent) );
        ID(DoneSmbEvent) = NULL;
    }

    if ( ID(NewSmbEvent) != NULL ) {
        ZwClose( ID(NewSmbEvent) );
        ID(NewSmbEvent) = NULL;
    }

    if ( ID(PortMemoryHeap) != NULL ) {
        RtlDestroyHeap( ID(PortMemoryHeap) );
        ID(PortMemoryHeap) = NULL;
    }

    if ( ID(SectionHandle) != NULL ) {
        ZwClose( ID(SectionHandle) );
        ID(SectionHandle) = NULL;
    }

    if (ProcessAttached) {
        KeDetachProcess();
    }

    return;

} // SmbTraceDisconnect


VOID
SmbTraceEmptyQueue (
    IN SMBTRACE_COMPONENT Component
    )

/*++

Routine Description:

    This routine empties the queue of unprocessed SMBs.

Arguments:

    Component - Context from which we're called: server or redirector

Return Value:

    None - always works

--*/

{
    PLIST_ENTRY            listEntry;
    PSMBTRACE_QUEUE_ENTRY  queueEntry;

    PAGED_CODE();

    while ( ( listEntry = ExInterlockedRemoveHeadList(
                              &ID(Queue),
                              &ID(QueueInterlock)
                              )
            ) != NULL
    ) {
        queueEntry = CONTAINING_RECORD(
                          listEntry,
                          SMBTRACE_QUEUE_ENTRY,
                          ListEntry
                          );

        //
        // If data for this entry is in non-paged pool, free it too.
        // This only ever happens in the redirector.
        //

        if ( queueEntry->BufferNonPaged ) {

            ASSERT( Component == SMBTRACE_REDIRECTOR );

            ExFreePool( queueEntry->Buffer );
        }

        //
        // If a worker thread is waiting on this event, let it go.
        // This only ever happens in slow mode.
        //

        if ( queueEntry->WaitEvent != NULL ) {

            ASSERT( ID(SingleSmbMode) == TRUE );

            KeSetEvent( queueEntry->WaitEvent, 0, FALSE );
        }

        ExFreePool( queueEntry );
    }

    return;

} // SmbTraceEmptyQueue


VOID
SmbTraceThreadEntry (
    IN PVOID Context
    )

/*++

Routine Description:

    This routine is the entry point of the SmbTrace thread for the server/
    redirector.  It is started by SmbTraceStart. This thread loops
    continuously until the client SmbTrace dies or another SmbTrace sends
    an FsCtl to stop the trace.

Arguments:

    Context - pointer to context block containing component from which
              we're called: server or redirector

Return Value:

    None

--*/

// we wait for termination, work-to-do and need-memory events
#define NUMBER_OF_BLOCKING_OBJECTS 4

// keep these definitions in sync

#define INDEX_WAIT_TERMINATIONEVENT     0
#define INDEX_WAIT_APPTERMINATIONEVENT  1
#define INDEX_WAIT_NEEDMEMORYEVENT      2
#define INDEX_WAIT_QUEUESEMAPHORE       3

#define STATUS_WAIT_TERMINATIONEVENT    STATUS_WAIT_0
#define STATUS_WAIT_APPTERMINATIONEVENT STATUS_WAIT_1
#define STATUS_WAIT_NEEDMEMORYEVENT     STATUS_WAIT_2
#define STATUS_WAIT_QUEUESEMAPHORE      STATUS_WAIT_3

{
    NTSTATUS status;
    PLIST_ENTRY listEntry;
    PSMBTRACE_QUEUE_ENTRY    queueEntry;
    PVOID buffer;
    PVOID waitObjects[NUMBER_OF_BLOCKING_OBJECTS];
    SMBTRACE_COMPONENT Component;
    BOOLEAN Looping;

#if NUMBER_OF_BLOCKING_OBJECTS > THREAD_WAIT_OBJECTS
    //
    // If we try to wait on too many objects, we need to allocate
    // our own wait blocks.
    //

    KWAIT_BLOCK waitBlocks[NUMBER_OF_BLOCKING_OBJECTS];
#endif

    PAGED_CODE();

    //
    // Context is really just the component
    //
    Component = (SMBTRACE_COMPONENT)(UINT_PTR)Context;

    //
    // Initialize the queue.
    //

    InitializeListHead(    &ID(Queue) );
    KeInitializeSpinLock(  &ID(QueueInterlock) );
    KeInitializeSemaphore( &ID(QueueSemaphore), 0, 0x7FFFFFFF );

    //
    // Set up the array of objects to wait on.  We wait (in order)
    // for our termination event, the appliction termination event,
    // a no shared memory event or an SMB request to show up in the
    // SmbTrace queue.
    //

    waitObjects[INDEX_WAIT_TERMINATIONEVENT]    = &ID(TerminationEvent);
    waitObjects[INDEX_WAIT_APPTERMINATIONEVENT] = &ID(AppTerminationEvent);
    waitObjects[INDEX_WAIT_NEEDMEMORYEVENT]     = &ID(NeedMemoryEvent);
    waitObjects[INDEX_WAIT_QUEUESEMAPHORE]      = &ID(QueueSemaphore);

    //
    // No SMBs have been lost yet, and this thread is the first user
    // of the shared memory.  It's also a special user in that it gets
    // access before TraceState == TraceRunning, a requirement for all
    // subsequent referencers.
    //

    ID(SmbsLost) = 0L;
    ID(HeapReferenceCount) = 1;

    //
    // Signal to the FSP that we are ready to start capturing SMBs.
    //

    KeSetEvent( &ID(ActiveEvent), 0, FALSE );

    //
    // Main loop, executed until the thread is terminated.
    //

    TrPrint(( "%s!SmbTraceThread: Tracing started.\n", ID(ComponentName) ));

    Looping = TRUE;
    while( Looping ) {

        TrPrint(( "%s!SmbTraceThread: WaitForMultiple.\n", ID(ComponentName) ));
        status = KeWaitForMultipleObjects(
                    NUMBER_OF_BLOCKING_OBJECTS,
                    &waitObjects[0],
                    WaitAny,
                    UserRequest,
                    KernelMode,
                    FALSE,
                    NULL,
#if NUMBER_OF_BLOCKING_OBJECTS > THREAD_WAIT_OBJECTS
                    &waitBlocks[0]
#else
                    NULL
#endif
                    );

        if ( !NT_SUCCESS(status) ) {
            TrPrint((
                "%s!SmbTraceThreadEntry: KeWaitForMultipleObjectsfailed: %X\n",
                ID(ComponentName), status ));
        } else {
            TrPrint((
                "%s!SmbTraceThreadEntry: %lx\n",
                ID(ComponentName), status ));
        }

        switch( status ) {

        case STATUS_WAIT_TERMINATIONEVENT:

            //
            // Stop looping, and then proceed to clean up and die.
            //

            Looping = FALSE;
            break;

        case STATUS_WAIT_APPTERMINATIONEVENT:

            //  Turn off the event so we don't go in a tight loop
            KeResetEvent(&ID(AppTerminationEvent));

            //
            // Inform the app that it is time to die.  The NULL SMB
            // sent here may not be the next to be processed by the
            // app, but the ApplicationStop bit will be detected
            // immediately.
            //

            ID(TableHeader)->ApplicationStop = TRUE;
            SmbTraceToClient( NULL, 0, NULL, Component );

            break;

        case STATUS_WAIT_NEEDMEMORYEVENT:

            //  Turn off the event so we don't go in a loop.
            KeResetEvent(&ID(NeedMemoryEvent));
            //
            // Do a garbage collection, freeing all memory that is
            // allocated in the shared memory but that has been read
            // by the client.
            //

            SmbTraceFreeMemory( Component );

            break;

        case STATUS_WAIT_QUEUESEMAPHORE:

            //
            // If any get through once we've gone into AppWaiting
            // state, don't bother sending them on, they're not
            // going to get processed.
            //

            if ( ID(TraceState) == TraceAppWaiting ) {
                SmbTraceEmptyQueue( Component );
                break;
            }

            //
            // Remove the first element in the our queue.  A
            // work item is represented by our header followed by
            // an SMB. We must free the entry after we are done
            // with it.
            //

            listEntry = ExInterlockedRemoveHeadList(
                            &ID(Queue),
                            &ID(QueueInterlock)
                            );

            if ( listEntry != NULL ) {

                //
                // Get the address of the queue entry.
                //

                queueEntry = CONTAINING_RECORD(
                                  listEntry,
                                  SMBTRACE_QUEUE_ENTRY,
                                  ListEntry
                                  );

                //
                // If the data is in non-paged pool, move it to shared
                // memory and free the non-paged pool before passing
                // the SMB to the client.  Note that in this case,
                // there's no need to signal anyone.  They ain't waiting.
                //

                if ( queueEntry->BufferNonPaged ) {

                    //
                    // Server never uses non-paged pool.
                    //

                    ASSERT( Component != SMBTRACE_SERVER );

                    buffer = RtlAllocateHeap( ID(PortMemoryHeap), 0,
                                              queueEntry->SmbLength );

                    if ( buffer == NULL ) {

                        LOCK_INC_ID(SmbsLost);

                        ExFreePool( queueEntry->Buffer );
                        ExFreePool( queueEntry );

                        break;

                    }

                    RtlCopyMemory( buffer, queueEntry->Buffer,
                                   queueEntry->SmbLength );

                    ExFreePool( queueEntry->Buffer );

                    //
                    // Send it off.  Because the original SMB is long
                    // dead, we don't pass its real address along (not
                    // that we have it, anyway.)
                    //

                    ASSERT( queueEntry->SmbAddress == NULL );

                    SmbTraceToClient(
                            buffer,
                            queueEntry->SmbLength,
                            NULL,
                            Component
                            );

                } else {

                    //
                    // Enter the SMB into the table and send it to the
                    // client. Can block in slow mode.  When it does so, we'll
                    // signal the applicable thread.
                    //

                    SmbTraceToClient(
                            queueEntry->Buffer,
                            queueEntry->SmbLength,
                            queueEntry->SmbAddress,
                            Component
                            );

                    if ( queueEntry->WaitEvent != NULL ) {
                        KeSetEvent( queueEntry->WaitEvent, 0, FALSE );
                    }
                }

                //
                // Now, we must free the queue entry.
                //

                ExFreePool( queueEntry );

            }

            break;

        default:
            break;
        }

    }

    //
    // Clean up!
    //
    TrPrint(( "%s!SmbTraceThread: Tracing clean up.\n", ID(ComponentName) ));

    SmbTraceDereferenceHeap( Component );

    SmbTraceEmptyQueue( Component );

    //
    // Signal to SmbTraceStop that we're dying.
    //

    TrPrint(( "%s!SmbTraceThread: Tracing terminated.\n", ID(ComponentName) ));

    KeSetEvent( &ID(TerminatedEvent), 0, FALSE );

    //
    // Kill this thread.
    //

    status = PsTerminateSystemThread( STATUS_SUCCESS );

    // Shouldn't get here
    TrPrint((
        "%s!SmbTraceThreadEntry: PsTerminateSystemThread() failed: %X\n",
        ID(ComponentName), status ));

} // SmbTraceThreadEntry

// constant only of interest while constructing waitObject arrays
// in SmbTraceThreadEntry
#undef NUMBER_OF_BLOCKING_OBJECTS


NTSTATUS
SmbTraceFreeMemory (
    IN SMBTRACE_COMPONENT Component
    )

/*++

Routine Description:

    This procedure frees any memory that may have been allocated to an
    SMB that the client has already consumed. It does not alter table
    entries, except to record that the memory buffer has been cleared.
    This routinue is not espectally fast, it should not be called often,
    only when needed.

Arguments:

    Component - Context from which we're called: server or redirector

Return Value:

    NTSTATUS - result of operation.

--*/

{
    PVOID    buffer;
    PSMBTRACE_TABLE_ENTRY    tableEntry;
    ULONG    tableIndex;

    PAGED_CODE();

    TrPrint(( "%s!SmbTraceFreeMemory: Called for garbage collection.\n",
              ID(ComponentName) ));

    //
    // No free memory in the heap, perhaps we can free some by freeing
    // memory in old table entries. This is expensive for time.
    //

    tableIndex = ID(TableHeader)->NextFree;

    while( tableIndex != ID(TableHeader)->HighestConsumed ) {

        tableEntry = ID(Table) + tableIndex;

        //
        // Check if this table entry has been used but its memory has not
        // been freed yet. If so, free it.
        //

        if ( tableEntry->BufferOffset != 0L ) {

            buffer = (PVOID)( (ULONG_PTR)tableEntry->BufferOffset
                        + (ULONG_PTR)ID(PortMemoryBase) );

            RtlFreeHeap( ID(PortMemoryHeap), 0, buffer);

            tableEntry->BufferOffset = 0L;
        }


        tableIndex = (tableIndex + 1) % ID(TableSize);
    }

    return( STATUS_SUCCESS );

} // SmbTraceFreeMemory


VOID
SmbTraceToClient(
    IN PVOID Smb,
    IN CLONG SmbLength,
    IN PVOID SmbAddress,
    IN SMBTRACE_COMPONENT Component
    )

/*++

Routine Description:

    Enter an SMB already found in shared memory into the table.  Set
    an event for the client.  If there is no table space, the SMB is
    not saved.  If in slow mode, wait for the client to finish with
    and then free the memory occupied by the SMB.

Arguments:

    Smb - a pointer to the SMB (which is ALREADY in shared memory).
          Can be NULL, indicating no new SMB is to be added, but the
          application is to be signalled anyway.

    SmbLength - the length of the SMB.

    SmbAddress - the address of the real SMB, not in shared memory.

    Component - Context from which we're called: server or redirector

Return Value:

    None

--*/

{
    NTSTATUS status;
    PVOID    buffer;
    PSMBTRACE_TABLE_ENTRY    tableEntry;
    ULONG    tableIndex;

    PAGED_CODE();

    //
    //  Reset DoneSmbEvent so we can determine when the request has been processed
    //

    if ( ID(SingleSmbMode) ) {
        PKEVENT DoneEvent;

        TrPrint(( "%s!SmbTraceToClient: Reset DoneSmbEvent, handle %x, process %x.\n",
                    ID(ComponentName), ID(DoneSmbEvent), PsGetCurrentProcess()));

        status = ObReferenceObjectByHandle( ID(DoneSmbEvent),
                                            EVENT_MODIFY_STATE,
                                            NULL,
                                            KernelMode,
                                            (PVOID *)&DoneEvent,
                                            NULL
                                            );

        ASSERT ( NT_SUCCESS(status) );

        KeResetEvent(DoneEvent);

        ObDereferenceObject(DoneEvent);
    }

    if (Smb != NULL) {

        //
        // See if there is room in the table for a pointer to our SMB.
        //

        if ( ID(TableHeader)->NextFree == ID(TableHeader)->HighestConsumed ) {
            // Tough luck. No memory in the table, this SMB is lost.
            LOCK_INC_ID( SmbsLost );
            RtlFreeHeap( ID(PortMemoryHeap), 0, Smb );
            return;
        }

        tableIndex = ID(TableHeader)->NextFree;

        tableEntry = ID(Table) + tableIndex;

        //
        // Record the number of SMBs that were lost before this one and
        // (maybe) zero the count for the next one.
        //

        tableEntry->NumberMissed = ID(SmbsLost);

        if ( tableEntry->NumberMissed != 0 ) {
            LOCK_ZERO_ID(SmbsLost);
        }

        //
        // Check if this table entry has been used but its memory has not
        // been freed yet. If so, free it.
        //
        if ( tableEntry->BufferOffset != 0L ) {

            buffer = (PVOID)( (ULONG_PTR)tableEntry->BufferOffset
                        + (ULONG_PTR)ID(PortMemoryBase) );

            RtlFreeHeap( ID(PortMemoryHeap), 0, buffer);
            tableEntry->BufferOffset = 0L;
        }

        //
        // Record the location and size of this SMB in the table.
        //

        tableEntry->BufferOffset = (ULONG)((ULONG_PTR)Smb - (ULONG_PTR)ID(PortMemoryBase));
        tableEntry->SmbLength = SmbLength;

        //
        // Record the real address of the actual SMB (i.e. not the shared
        // memory copy) if it's available.
        //

        tableEntry->SmbAddress = SmbAddress;

        //
        // Increment the Next Free counter.
        //

        ID(TableHeader)->NextFree = (tableIndex + 1) % ID(TableSize);

    }


    //
    // Unlock the client so it will process this new SMB.
    //

    TrPrint(( "%s!SmbTraceToClient: Set NewSmbEvent.\n", ID(ComponentName) ));
    status = ZwSetEvent( ID(NewSmbEvent), NULL );

    //
    //  When stopping the trace we set TraceState to TraceStopping and then
    //  DoneSmbEvent. This prevents this routine from blocking indefinitely
    //  because it Resets DoneSmbEvent processes the Smb and then checks TraceState
    //  before blocking.
    //
    if (( ID(SingleSmbMode) ) &&
        ( ID(TraceState) == TraceRunning )) {

        //
        // Wait for the app to acknowledge that the SMB has been
        // processed.
        //

        TrPrint(( "%s!SmbTraceToClient: Waiting for DoneSmbEvent, handle %x, process %x.\n",
                    ID(ComponentName), ID(DoneSmbEvent), PsGetCurrentProcess()));
        status = ZwWaitForSingleObject(
                    ID(DoneSmbEvent),
                    FALSE,
                    NULL
                    );

        TrPrint(( "%s!SmbTraceToClient: DoneSmbEvent is set, handle %x, process %x.\n",
                    ID(ComponentName), ID(DoneSmbEvent), PsGetCurrentProcess()));
        ASSERT( NT_SUCCESS(status) );

        if (Smb != NULL) {

            tableEntry->BufferOffset = 0L;
            RtlFreeHeap( ID(PortMemoryHeap), 0, Smb);
        }

    }

    return;

} // SmbTraceToClient


ULONG
SmbTraceMdlLength(
    IN PMDL Mdl
    )

/*++

Routine Description:

    Determine the total number of bytes of data found in an Mdl.

Arguments:

    Mdl - a pointer to an Mdl whose length is to be calculated

Return Value:

    ULONG - total number of data bytes in Mdl

--*/

{
    ULONG Bytes = 0;

    while (Mdl != NULL) {
        Bytes += MmGetMdlByteCount(Mdl);
        Mdl = Mdl->Next;
    }

    return Bytes;
} // SmbTraceMdlLength


VOID
SmbTraceCopyMdlContiguous(
    OUT PVOID Destination,
    IN  PMDL Mdl,
    IN  ULONG Length
    )

/*++

Routine Description:

    Copy the data stored in Mdl into the contiguous memory at
    Destination.  Length is present to keep the same interface
    as RtlCopyMemory.

Arguments:

    Destination - a pointer to previously allocated memory into which
                  the Mdl is to be copied.

    Mdl - a pointer to an Mdl which is to be copied to Destination

    Length - number of data bytes expected in Mdl

Return Value:

    None

--*/

{
    PCHAR Dest = Destination;
    PCHAR Src  = NULL;

    UNREFERENCED_PARAMETER(Length);

    while (Mdl != NULL) {

        Src = MmGetSystemAddressForMdlSafe(Mdl,NormalPagePriority);

        if (Src != NULL) {
            RtlCopyMemory(
                Dest,
                Src,
                MmGetMdlByteCount(Mdl)
                );
        }

        Dest += MmGetMdlByteCount(Mdl);
        Mdl = Mdl->Next;
    }

    ASSERT((ULONG)(Dest - (PCHAR)Destination) == Length);

    return;

} // SmbTraceCopyMdlContiguous
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\srv\blktable.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    blktable.c

Abstract:

    This module implements routines for managing tables.

Author:

    Chuck Lenzmeier (chuckl) 4-Oct-1989

Revision History:

--*/

#include "precomp.h"
#include "blktable.tmh"
#pragma hdrstop

#define BugCheckFileId SRV_FILE_BLKTABLE

#ifdef ALLOC_PRAGMA
#pragma alloc_text( PAGE, SrvAllocateTable )
#endif
#if 0
NOT PAGEABLE -- SrvGrowTable
NOT PAGEABLE -- SrvRemoveEntryTable
#endif


VOID
SrvAllocateTable (
    IN PTABLE_HEADER TableHeader,
    IN ULONG NumberOfEntries,
    IN BOOLEAN Nonpaged
    )

/*++

Routine Description:

    This routine allocates a table and sets those fields that it can.

Arguments:

    TableHeader - a pointer to the table header structure

    NumberOfEntries - the number of table entries to allocate

    Nonpaged - indicates whether the table should be allocated from
        nonpaged pool

Return Value:

    None.

--*/

{
    SHORT i;
    CLONG tableSize;
    PTABLE_ENTRY table;

    PAGED_CODE( );

    //
    // Allocate space for the table.
    //

    tableSize = sizeof(TABLE_ENTRY) * NumberOfEntries;

    if ( Nonpaged ) {
        table = ALLOCATE_NONPAGED_POOL( tableSize, BlockTypeTable );
    } else {
        table = ALLOCATE_HEAP_COLD( tableSize, BlockTypeTable );
    }

    if ( table == NULL ) {

        INTERNAL_ERROR(
            ERROR_LEVEL_EXPECTED,
            "SrvAllocateTable: Unable to allocate %d bytes from paged pool.",
            tableSize,
            NULL
            );

        TableHeader->Table = NULL;
        return;

    }

    IF_DEBUG(HEAP) {
        SrvPrint1( "SrvAllocateTable: Allocated table at %p\n", table );
    }

    //
    // Initialize the table, creating a linked list of free entries.
    //

    RtlZeroMemory( table, tableSize );

    table[NumberOfEntries-1].NextFreeEntry = -1;

    for ( i = (SHORT)(NumberOfEntries - 2); i >= 0; i-- ) {
        table[i].NextFreeEntry = (SHORT)(i + 1);
    }

    //
    // Point the table header to the table and set the first and
    // free entry indexes.
    //

    TableHeader->Table = table;
    TableHeader->Nonpaged = Nonpaged;
    TableHeader->TableSize = (USHORT)NumberOfEntries;
    TableHeader->FirstFreeEntry = 0;
    TableHeader->LastFreeEntry = (SHORT)(NumberOfEntries-1);

    return;

} // SrvAllocateTable


BOOLEAN
SrvGrowTable (
    IN PTABLE_HEADER TableHeader,
    IN ULONG NumberOfNewEntries,
    IN ULONG MaxNumberOfEntries,
    OPTIONAL OUT NTSTATUS* pStatus
    )

/*++

Routine Description:

    This routine grows a table by the number of entries specified.  It
    allocates new space that is large enough to hold the expanded
    table, copies over the current table, initializes the entries
    that were added, and frees the old table.

    WARNING: The calling routine *must* hold a lock for the table to
    prevent access to the table while it is being copied over.

Arguments:

    TableHeader - a pointer to the table header structure

    NumberOfNewEntries - the number of table entries to add to the table

    MaxNumberOfEntries - the maximum allowable size for the table
    
    pStatus - Optional return value.  INSUFFICIENT_RESOURCES means mem allocation error,
              while INSUFF_SERVER_RESOURCES means we're over our table limit

Return Value:

    BOOLEAN - TRUE if the table was successfully grown, FALSE otherwise.

--*/

{
    ULONG newTableSize, totalEntries, oldNumberOfEntries;
    USHORT i;
    PTABLE_ENTRY table;

    oldNumberOfEntries = TableHeader->TableSize;
    totalEntries = oldNumberOfEntries + NumberOfNewEntries;

    //
    // If the table is already at the maximum size, kick out the request.
    //

    if ( oldNumberOfEntries >= MaxNumberOfEntries ) {
        INTERNAL_ERROR(
            ERROR_LEVEL_EXPECTED,
            "SrvGrowTable: Unable to grow table at max size (%ld).",
            MaxNumberOfEntries,
            NULL
            );
        if( ARGUMENT_PRESENT(pStatus) )
        {
            *pStatus = STATUS_INSUFF_SERVER_RESOURCES;
        }
        return FALSE;
    }

    //
    // If adding the requested number would put the table size over the
    // maximum, allocate to the maximum size.
    //

    if ( totalEntries > MaxNumberOfEntries ) {
        totalEntries = MaxNumberOfEntries;
        NumberOfNewEntries = totalEntries - oldNumberOfEntries;
    }

    newTableSize = totalEntries * sizeof(TABLE_ENTRY);

    //
    // Allocate space for the new table.
    //

    if ( TableHeader->Nonpaged ) {
        table = ALLOCATE_NONPAGED_POOL( newTableSize, BlockTypeTable );
    } else {
        table = ALLOCATE_HEAP_COLD( newTableSize, BlockTypeTable );
    }

    if ( table == NULL ) {
        INTERNAL_ERROR(
            ERROR_LEVEL_EXPECTED,
            "SrvGrowTable: Unable to allocate %d bytes from paged pool",
            sizeof( BLOCK_HEADER ) + newTableSize,
            NULL
            );
        if( ARGUMENT_PRESENT(pStatus) )
        {
            *pStatus = STATUS_INSUFFICIENT_RESOURCES;
        }
        return FALSE;
    }

    IF_DEBUG(HEAP) {
        SrvPrint1( "SrvGrowTable: Allocated new table at %p\n", table );
    }

    //
    // Copy over the information from the old table.  Zero the remainder
    // of the table.
    //

    RtlCopyMemory(
        table,
        TableHeader->Table,
        oldNumberOfEntries * sizeof(TABLE_ENTRY)
        );

    RtlZeroMemory(
        (PCHAR)table + (oldNumberOfEntries * sizeof(TABLE_ENTRY)),
        (totalEntries - oldNumberOfEntries) * sizeof(TABLE_ENTRY)
        );

    //
    // Free the old table.
    //

    SrvFreeTable( TableHeader );

    //
    // Initialize the new table locations in the free list of the table.
    //

    table[totalEntries-1].NextFreeEntry = -1;

    for ( i = (USHORT)(totalEntries-2); i >= oldNumberOfEntries; i-- ) {
        table[i].NextFreeEntry = (SHORT)(i + 1);
    }

    //
    // Reinitialize the fields of the table header.  It is assumed that
    // the table did not previously have any free entries.
    //

    TableHeader->Table = table;
    TableHeader->TableSize = (USHORT)totalEntries;
    TableHeader->FirstFreeEntry = (SHORT)oldNumberOfEntries;
    TableHeader->LastFreeEntry = (SHORT)(totalEntries-1);

    if( ARGUMENT_PRESENT( pStatus ) )
    {
        *pStatus = STATUS_SUCCESS;
    }
    return TRUE;

} // SrvGrowTable


VOID
SrvRemoveEntryTable (
    IN PTABLE_HEADER TableHeader,
    IN USHORT Index
    )

/*++

Routine Description:

    This function removes an entry from a table.

    *** The lock controlling access to the table must be held when this
        function is called.

Arguments:

    Table - Address of table header.

    Index - Index within table of entry to remove.

Return Value:

    None.

--*/

{
    PTABLE_ENTRY entry;

    ASSERT( Index < TableHeader->TableSize );

    entry = &TableHeader->Table[Index];

    if ( TableHeader->LastFreeEntry >= 0 ) {

        //
        // Free list was not empty.
        //

        TableHeader->Table[TableHeader->LastFreeEntry].NextFreeEntry = Index;
        TableHeader->LastFreeEntry = Index;

    } else {

        //
        // Free list was empty.
        //

        TableHeader->FirstFreeEntry = Index;
        TableHeader->LastFreeEntry = Index;
    }

    entry->Owner = NULL;
    entry->NextFreeEntry = -1;

    return;

} // SrvRemoveEntryTable
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\srv\blksess.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    blksess.c

Abstract:

    This module implements routines for managing session blocks.

Author:

    Chuck Lenzmeier (chuckl) 4-Oct-1989

Revision History:

--*/

#include "precomp.h"
#include "blksess.tmh"
#pragma hdrstop

#define BugCheckFileId SRV_FILE_BLKSESS

#ifdef ALLOC_PRAGMA
#pragma alloc_text( PAGE, SrvAllocateSession )
#pragma alloc_text( PAGE, SrvCheckAndReferenceSession )
#pragma alloc_text( PAGE, SrvCloseSession )
#pragma alloc_text( PAGE, SrvCloseSessionsOnConnection )
#pragma alloc_text( PAGE, SrvDereferenceSession )
#pragma alloc_text( PAGE, SrvFreeSession )
#endif


VOID
SrvAllocateSession (
    OUT PSESSION *Session,
    IN PUNICODE_STRING UserName OPTIONAL,
    IN PUNICODE_STRING Domain OPTIONAL
    )

/*++

Routine Description:

    This function allocates a Session Block from the FSP heap.

Arguments:

    Session - Returns a pointer to the session block, or NULL if
        no heap space was available.

Return Value:

    None.

--*/

{
    ULONG blockLength;
    PNONPAGED_HEADER header;
    PSESSION session;
    PWCH buffer;

    PAGED_CODE( );

    blockLength = sizeof(SESSION);
    if( ARGUMENT_PRESENT( UserName ) ) {
        blockLength += UserName->Length;
    }

    if( ARGUMENT_PRESENT( Domain ) ) {
        blockLength += Domain->Length;
    }

    //
    // Attempt to allocate from the heap.
    //

    session = ALLOCATE_HEAP( blockLength, BlockTypeSession );
    *Session = session;

    if ( session == NULL ) {
        INTERNAL_ERROR(
            ERROR_LEVEL_EXPECTED,
            "SrvAllocateSession: Unable to allocate %d bytes from heap",
            blockLength,
            NULL
            );
        return;
    }


    IF_DEBUG(HEAP) {
        SrvPrint1( "SrvAllocateSession: Allocated session at %p\n", session );
    }

    //
    // Allocate the nonpaged header.
    //

    header = ALLOCATE_NONPAGED_POOL(
                sizeof(NONPAGED_HEADER),
                BlockTypeNonpagedHeader
                );
    if ( header == NULL ) {
        INTERNAL_ERROR(
            ERROR_LEVEL_EXPECTED,
            "SrvAllocateSession: Unable to allocate %d bytes from pool.",
            sizeof( NONPAGED_HEADER ),
            NULL
            );
        FREE_HEAP( session );
        *Session = NULL;
        return;
    }

    header->Type = BlockTypeSession;
    header->PagedBlock = session;

    RtlZeroMemory( session, blockLength );

    session->NonpagedHeader = header;
    SET_BLOCK_TYPE_STATE_SIZE( session, BlockTypeSession, BlockStateActive, blockLength );

    INVALIDATE_SECURITY_HANDLE( session->UserHandle );


    header->ReferenceCount = 2; // allow for Active status and caller's pointer

    //
    // Initialize times for autologoff.
    //

    KeQuerySystemTime( &session->StartTime );
    session->LastUseTime.QuadPart = session->StartTime.QuadPart;

    buffer = (PWCH)( session + 1 );

    //
    // Initialize the user name.
    //
    if( ARGUMENT_PRESENT( UserName ) ) {
        session->NtUserName.Length = UserName->Length;
        session->NtUserName.MaximumLength = UserName->Length;
        session->NtUserName.Buffer = buffer;
        buffer += UserName->Length / sizeof( WCHAR );

        if( UserName->Length != 0 ) {
            RtlCopyUnicodeString( &session->NtUserName, UserName );
        }
    }

    //
    // Initialize the domain name.
    //
    if( ARGUMENT_PRESENT( Domain ) ) {
        session->NtUserDomain.Length = Domain->Length;
        session->NtUserDomain.MaximumLength = Domain->Length;
        session->NtUserDomain.Buffer = buffer;

        if( Domain->Buffer != NULL ) {
            RtlCopyUnicodeString( &session->NtUserDomain, Domain );
        }
    }

#if SRVDBG2
    session->BlockHeader.ReferenceCount = 2; // for INITIALIZE_REFERENCE_HISTORY
#endif
    INITIALIZE_REFERENCE_HISTORY( session );

    INCREMENT_DEBUG_STAT( SrvDbgStatistics.SessionInfo.Allocations );

    return;

} // SrvAllocateSession


BOOLEAN SRVFASTCALL
SrvCheckAndReferenceSession (
    PSESSION Session
    )

/*++

Routine Description:

    This function atomically verifies that a session is active and
    increments the reference count on the session if it is.

Arguments:

    Session - Address of session

Return Value:

    BOOLEAN - Returns TRUE if the session is active, FALSE otherwise.

--*/

{
    PAGED_CODE( );

    if( Session->LogonSequenceInProgress == FALSE ) {
        //
        // Acquire the lock that guards the session's state field.
        //

        ACQUIRE_LOCK( &Session->Connection->Lock );

        //
        // If the session is active, reference it and return TRUE.
        //

        if ( GET_BLOCK_STATE(Session) == BlockStateActive ) {

            SrvReferenceSession( Session );

            RELEASE_LOCK( &Session->Connection->Lock );

            return TRUE;

        }

        //
        // The session isn't active.  Return FALSE.
        //

        RELEASE_LOCK( &Session->Connection->Lock );
    }

    return FALSE;

} // SrvCheckAndReferenceSession


VOID
SrvCloseSession (
    PSESSION Session
    )

/*++

Routine Description:

    This routine does the core of a logoff (disconnect session).  It
    sets the state of the session to Closing, closes open files and
    pending transactions, and dereferences the session block.

Arguments:

    Session - Supplies a pointer to the session block that is to be
        closed.

Return Value:

    None.

--*/

{
    PCONNECTION connection = Session->Connection;
    PPAGED_CONNECTION pagedConnection = connection->PagedConnection;
    PAGED_CODE( );

    ACQUIRE_LOCK( &connection->Lock );

    if ( GET_BLOCK_STATE(Session) == BlockStateActive ) {

        IF_DEBUG(BLOCK1) SrvPrint1( "Closing session at %p\n", Session );

        SET_BLOCK_STATE( Session, BlockStateClosing );

        //
        // Free the session table entry.
        //
        // *** This must be done here, not in SrvDereferenceSession!
        //     This routine can be called from SrvSmbSessionSetupAndX
        //     when it needs to free up session table entry 0 for
        //     IMMEDIATE reuse.
        //

        SrvRemoveEntryTable(
            &pagedConnection->SessionTable,
            UID_INDEX( Session->Uid )
            );

        pagedConnection->CurrentNumberOfSessions--;

        RELEASE_LOCK( &connection->Lock );

        //
        // Disconnect the tree connects from this session
        //
        SrvDisconnectTreeConnectsFromSession( connection, Session );

        //
        // Close all open files.
        //

        SrvCloseRfcbsOnSessionOrPid( Session, NULL );

        //
        // Close all pending transactions.
        //

        SrvCloseTransactionsOnSession( Session );

        //
        // Close all DOS searches on this session.
        //

        SrvCloseSearches(
                connection,
                (PSEARCH_FILTER_ROUTINE)SrvSearchOnSession,
                (PVOID) Session,
                NULL
                );

        //
        // Close all cached directories on this session.
        //
        SrvCloseCachedDirectoryEntries( connection );

        //
        // Dereference the session (to indicate that it's no longer
        // open).
        //

        SrvDereferenceSession( Session );

        INCREMENT_DEBUG_STAT( SrvDbgStatistics.SessionInfo.Closes );

    } else {

        RELEASE_LOCK( &connection->Lock );
    }

    return;

} // SrvCloseSession


VOID
SrvCloseSessionsOnConnection (
    IN PCONNECTION Connection,
    IN PUNICODE_STRING UserName OPTIONAL
    )

/*++

Routine Description:

    This function closes sessions on a connection.  It walks the
    connection's list of sessions, calling SrvCloseSession as
    appropriate.

Arguments:

    Connection - Supplies a pointer to a Connection Block

    UserName - if specified, only sessions with the given user name
        are closed.

Return Value:

    None.

--*/

{
    PTABLE_HEADER tableHeader;
    PPAGED_CONNECTION pagedConnection = Connection->PagedConnection;
    LONG i;
    UNICODE_STRING userName;
    NTSTATUS status;

    PAGED_CODE( );

    //
    // Close all active sessions.  (This also causes all open files
    // and pending transactions to be closed.)
    //
    // *** In order to prevent the session from being deallocated
    //     between when we find it in the table and the call to
    //     SrvCloseSession, we reference the session.  It is not
    //     legal to hold the connection lock while calling
    //     SrvCloseSession, so simply holding the lock while we walk
    //     the list is not legal.

    tableHeader = &pagedConnection->SessionTable;

    ACQUIRE_LOCK( &Connection->Lock );

    for ( i = 0; i < tableHeader->TableSize; i++ ) {

        PSESSION session = (PSESSION)tableHeader->Table[i].Owner;

        if( session == NULL || GET_BLOCK_STATE( session ) != BlockStateActive ) {
            //
            // This session either doesn't exist, or is already going away
            //
            continue;
        }

        if( UserName != NULL ) {
            //
            // Get the user name for this session.  We don't care about the
            //  domain name.
            //
            status = SrvGetUserAndDomainName( session, &userName, NULL );

            if( !NT_SUCCESS( status ) ) {
                //
                // We can't figure out the name for the user for this session.
                //  We probably shouldn't just blow it away, so let's just keep
                //  going.
                //
                continue;
            }

            if( RtlCompareUnicodeString( &userName, UserName, TRUE ) != 0 ) {
                //
                // This is not the user we're interested in. Skip it.
                //
                SrvReleaseUserAndDomainName( session, &userName, NULL );
                continue;
            }

            SrvReleaseUserAndDomainName( session, &userName, NULL );
        }

        SrvReferenceSession( session );
        RELEASE_LOCK( &Connection->Lock );

        SrvStatistics.SessionsErroredOut++;
        SrvCloseSession( session );

        SrvDereferenceSession( session );
        ACQUIRE_LOCK( &Connection->Lock );
    }

    RELEASE_LOCK( &Connection->Lock );

} // SrvCloseSessionsOnConnection


VOID SRVFASTCALL
SrvDereferenceSession (
    IN PSESSION Session
    )

/*++

Routine Description:

    This function decrements the reference count on a session.  If the
    reference count goes to zero, the session block is deleted.

    Since this routine may call SrvDereferenceConnection, the caller
    must be careful if he holds the connection lock that he also
    holds a referenced pointer to the connection.

Arguments:

    Session - Address of session

Return Value:

    None.

--*/

{
    PCONNECTION connection;
    LONG result;

    PAGED_CODE( );

    //
    // Enter a critical section and decrement the reference count on the
    // block.
    //

    connection = Session->Connection;

    IF_DEBUG(REFCNT) {
        SrvPrint2( "Dereferencing session %p; old refcnt %lx\n",
                    Session, Session->NonpagedHeader->ReferenceCount );
    }

    ASSERT( GET_BLOCK_TYPE( Session ) == BlockTypeSession );
    ASSERT( Session->NonpagedHeader->ReferenceCount > 0 );
    UPDATE_REFERENCE_HISTORY( Session, TRUE );

    result = InterlockedDecrement(
                &Session->NonpagedHeader->ReferenceCount
                );

    if ( result == 0 ) {

        //
        // The new reference count is 0, meaning that it's time to
        // delete this block.
        //
        // Remove the session from the global list of sessions.
        //

        SrvRemoveEntryOrderedList( &SrvSessionList, Session );

        //
        // Dereference the connection.
        //

        SrvDereferenceConnection( connection );
        DEBUG Session->Connection = NULL;

        //
        // Free the session block.
        //

        SrvFreeSession( Session );

    }

    return;

} // SrvDereferenceSession


VOID
SrvFreeSession (
    IN PSESSION Session
    )

/*++

Routine Description:

    This function returns a Session Block to the FSP heap.

Arguments:

    Session - Address of session

Return Value:

    None.

--*/

{
    KAPC_STATE ApcState;
    PEPROCESS process;

    PAGED_CODE( );

    DEBUG SET_BLOCK_TYPE_STATE_SIZE( Session, BlockTypeGarbage, BlockStateDead, -1 );
    DEBUG Session->NonpagedHeader->ReferenceCount = -1;
    TERMINATE_REFERENCE_HISTORY( Session );

    //
    // Ensure we are in the system process
    //
    process = IoGetCurrentProcess();
    if ( process != SrvServerProcess ) {
        KeStackAttachProcess( SrvServerProcess, &ApcState );
    }

    //
    // Tell the License Server
    //
    SrvXsLSOperation( Session, XACTSRV_MESSAGE_LSRELEASE );

    //
    // Close the logon token
    //
    SrvFreeSecurityContexts( Session );

    //
    // Get back to where we were
    //
    if( process != SrvServerProcess ) {
        KeUnstackDetachProcess( &ApcState );
    }

    //
    // Deallocate the session's memory.
    //

    DEALLOCATE_NONPAGED_POOL( Session->NonpagedHeader );
    FREE_HEAP( Session );
    IF_DEBUG(HEAP) {
        SrvPrint1( "SrvFreeSession: Freed session block at %p\n", Session );
    }

    INCREMENT_DEBUG_STAT( SrvDbgStatistics.SessionInfo.Frees );

    return;

} // SrvFreeSession
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\srv\blklock.c ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    blklock.c

Abstract:

    This module implements routines for managing byte range lock blocks.

Author:

    Andy Herron (andyhe) 15-Nov-1999

Revision History:

--*/

#include "precomp.h"
#include "blklock.tmh"
#pragma hdrstop

#ifdef INCLUDE_SMB_PERSISTENT

#define BugCheckFileId SRV_FILE_BLKLOCK

#ifdef ALLOC_PRAGMA
#pragma alloc_text( PAGE, SrvAllocateLock )
#pragma alloc_text( PAGE, SrvFindAndReferenceLock )
#pragma alloc_text( PAGE, SrvCloseLock )
#pragma alloc_text( PAGE, SrvCloseLocksOnRfcb )
#pragma alloc_text( PAGE, SrvDereferenceLock )
#endif


VOID
SrvAllocateLock (
    OUT PBYTELOCK *Lock,
    IN PRFCB Rfcb,
    IN LARGE_INTEGER Offset,
    IN LARGE_INTEGER Length,
    IN BOOLEAN Exclusive
    )

/*++

Routine Description:

    This function allocates a lock block from the FSP heap.

Arguments:

    Lock - Returns a pointer to the lock block, or NULL if
        no heap space was available.

    Rfcb - file which owns this lock.  MFCB lock will be taken to insert lock
        into list.

    Offset - offset of lock in file.

    Length - lock length.

    Exclusive - is this a shared or exclusive lock?

Return Value:

    None.

--*/

{
    PBYTELOCK lock;
    PNONPAGED_MFCB npMfcb;

    PAGED_CODE( );

    if ( ! Rfcb->PersistentHandle ) {

        *Lock = NULL;
        return;
    }

    //
    // Attempt to allocate from the heap.
    //

    lock = ALLOCATE_HEAP( sizeof(BYTELOCK), BlockTypeByteRangeLock );
    *Lock = lock;

    if ( lock == NULL ) {
        INTERNAL_ERROR(
            ERROR_LEVEL_EXPECTED,
            "SrvAllocateLock: Unable to allocate %d bytes from heap",
            sizeof(BYTELOCK),
            NULL
            );
        return;
    }

    IF_DEBUG(HEAP) {
        SrvPrint1( "SrvAllocateLock: Allocated byte range lock at %lx\n", lock );
    }

    RtlZeroMemory( lock, sizeof(BYTELOCK) );

    SET_BLOCK_TYPE_STATE_SIZE( lock, BlockTypeByteRangeLock, BlockStateActive, BlockTypeByteRangeLock );

    lock->BlockHeader.ReferenceCount = 2; // allow for Active status and caller's pointer

    lock->Rfcb = Rfcb;
    lock->LockOffset.QuadPart = Offset.QuadPart;
    lock->LockLength.QuadPart = Length.QuadPart;
    lock->Exclusive = Exclusive;

    INITIALIZE_REFERENCE_HISTORY( lock );

    npMfcb = Rfcb->Lfcb->Mfcb->NonpagedMfcb;
    ACQUIRE_LOCK( &npMfcb->Lock );

    SrvInsertHeadList( &Rfcb->PagedRfcb->ByteRangeLocks, &lock->RfcbListEntry );

    RELEASE_LOCK( &npMfcb->Lock );

//  INCREMENT_DEBUG_STAT( SrvDbgStatistics.SessionInfo.Allocations );

    return;

} // SrvAllocateLock


PBYTELOCK
SrvFindAndReferenceLock (
    IN PRFCB Rfcb,
    IN LARGE_INTEGER Offset,
    IN LARGE_INTEGER Length,
    IN BOOLEAN Exclusive
    )

/*++

Routine Description:

    This function finds a lock, references it and returns it.

Arguments:

    Rfcb - file which owns this lock.  MFCB lock will be taken to insert lock
        into list.

    Offset - offset of lock in file.

    Length - lock length.

    Exclusive - is this a shared or exclusive lock?

Return Value:

    PBYTELOCK - pointer to lock structure, null if doesn't exist.

--*/

{
    PBYTELOCK lock = NULL;
    PLIST_ENTRY listEntry;
    PLIST_ENTRY listHead;
    PNONPAGED_MFCB npMfcb;

    PAGED_CODE( );

    if (! Rfcb->PersistentHandle ) {

        return NULL;
    }

    npMfcb = Rfcb->Lfcb->Mfcb->NonpagedMfcb;
    ACQUIRE_LOCK( &npMfcb->Lock );

    listHead =  &Rfcb->PagedRfcb->ByteRangeLocks;
    listEntry = listHead->Flink;

    while (listEntry != listHead) {

        lock = CONTAINING_RECORD(   listEntry,
                                    BYTELOCK,
                                    RfcbListEntry
                                    );

        if ( GET_BLOCK_STATE(lock) == BlockStateActive &&
             lock->LockOffset.QuadPart == Offset.QuadPart &&
             lock->LockLength.QuadPart == Length.QuadPart &&
             lock->Exclusive == Exclusive ) {

            IF_DEBUG(REFCNT) {
                SrvPrint2( "Referencing byte lock 0x%lx; old refcnt %lx\n",
                            lock, lock->BlockHeader.ReferenceCount );
            }

            ASSERT( GET_BLOCK_TYPE( lock ) == BlockTypeByteRangeLock );
            ASSERT( lock->BlockHeader.ReferenceCount > 0 );

            InterlockedIncrement( &lock->BlockHeader.ReferenceCount );
            break;
        }
        lock = NULL;
        listEntry = listEntry->Flink;
    }

    RELEASE_LOCK( &npMfcb->Lock );

    return lock;

} // SrvFindAndReferenceLock


VOID
SrvCloseLock (
    IN PBYTELOCK Lock,
    IN BOOLEAN HaveLock
    )

/*++

Routine Description:

    This routine closes out the byte range lock block.

Arguments:

    Lock - Supplies a pointer to the lock block that is to be closed.

Return Value:

    None.

--*/

{
    PNONPAGED_MFCB npMfcb;
    PAGED_CODE( );

    ASSERT( Lock->Rfcb != NULL );

    if (!HaveLock) {
        npMfcb = Lock->Rfcb->Lfcb->Mfcb->NonpagedMfcb;
        ACQUIRE_LOCK( &npMfcb->Lock );
    }

    if ( GET_BLOCK_STATE(Lock) == BlockStateActive ) {

        IF_DEBUG(BLOCK1) SrvPrint1( "Closing byte lock at 0x%lx\n", Lock );

        SET_BLOCK_STATE( Lock, BlockStateClosing );

        SrvRemoveEntryList( &Rfcb->PagedRfcb->ByteRangeLocks, &Lock->RfcbListEntry );

        if (!HaveLock) {
            RELEASE_LOCK( &npMfcb->Lock );
        }

//      if ( we're in the state file ) {
//
//          remove us from state file.
//      }
        Lock->Rfcb = NULL;

        //
        // Dereference the lock (to indicate that it's no longer
        // open).
        //

        SrvDereferenceLock( Lock );

    } else {

        if (!HaveLock) {
            RELEASE_LOCK( &npMfcb->Lock );
        }
    }

    return;

} // SrvCloseLock


VOID
SrvCloseLocksOnRfcb (
    IN PRFCB Rfcb
    )

/*++

Routine Description:

    This function closes all locks on an RFCB.  It walks the RFCB's
    list of locks, calling SrvCloseLock as appropriate.

Arguments:

    Rfcb - Supplies a pointer to a Rfcb Block

Return Value:

    None.

--*/

{
    PBYTELOCK lock;
    PLIST_ENTRY listEntry;
    PLIST_ENTRY listHead;
    PNONPAGED_MFCB npMfcb;

    PAGED_CODE( );

    if (! Rfcb->PersistentHandle ) {

        return;
    }

    npMfcb = Rfcb->Lfcb->Mfcb->NonpagedMfcb;
    ACQUIRE_LOCK( &npMfcb->Lock );

    listHead =  &Rfcb->PagedRfcb->ByteRangeLocks;
    listEntry = listHead->Flink;

    while (listEntry != listHead) {

        lock = CONTAINING_RECORD(   listEntry,
                                    BYTELOCK,
                                    RfcbListEntry
                                    );

        listEntry = listEntry->Flink;
        SrvCloseLock( lock, TRUE );
    }

    RELEASE_LOCK( &npMfcb->Lock );
    return;

} // SrvCloseLocksOnRfcb


VOID SRVFASTCALL
SrvDereferenceLock (
    IN PBYTELOCK Lock
    )

/*++

Routine Description:

    This function decrements the reference count on a lock.  If the
    reference count goes to zero, the lock block is deleted.

Arguments:

    Lock - Address of lock

Return Value:

    None.

--*/

{
    LONG result;

    PAGED_CODE( );

    //
    // Enter a critical section and decrement the reference count on the
    // block.
    //

    IF_DEBUG(REFCNT) {
        SrvPrint2( "Dereferencing byte lock 0x%lx; old refcnt %lx\n",
                    Lock, Lock->BlockHeader.ReferenceCount );
    }

    ASSERT( GET_BLOCK_TYPE( Lock ) == BlockTypeByteRangeLock );
    ASSERT( Lock->BlockHeader.ReferenceCount > 0 );

    result = InterlockedDecrement(
                &Lock->BlockHeader.ReferenceCount
                );

    if ( result == 0 ) {

        ASSERT( GET_BLOCK_STATE(Lock) == BlockStateClosing );

        //
        // Free the session block.
        //

        DEBUG SET_BLOCK_TYPE_STATE_SIZE( Lock, BlockTypeGarbage, BlockStateDead, -1 );
        DEBUG Lock->BlockHeader.ReferenceCount = -1;

        FREE_HEAP( Lock );
        IF_DEBUG(HEAP) {
            SrvPrint1( "SrvDereferenceLock: Freed session byte lock at 0x%lx\n", Lock );
        }
    }

    return;

} // SrvDereferenceLock

#endif   // def INCLUDE_SMB_PERSISTENT

// blklock.c eof
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\srv\blkfile.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    blkfile.c

Abstract:

    This module implements routines for managing various kinds of file
    control blocks.

    Master File Control Block (MFCB) -- one per named file that is open
        at least once.  Used to support compatibility mode and oplocks.

    Local File Control Block (LFCB) -- one for each local open instance.
        Represents local file object/handle.  There may be multiple
        LFCBs linked to a single MFCB.

    Remote File Control Block (RFCB) -- one for each remote open instance.
        Represents remote FID.  There is usually one RFCB per LFCB, but
        multiple compatibility mode RFCBs may be linked to a single LFCB.
        Multiple remote FCB opens for a single file from a single session
        are folded into one RFCB, because old DOS redirectors only send
        one close.

Author:

    Chuck Lenzmeier (chuckl) 4-Oct-1989

Revision History:

--*/

#include "precomp.h"
#include "blkfile.tmh"
#pragma hdrstop

#define BugCheckFileId SRV_FILE_BLKFILE

//
// Get the address of the SRV_LOCK which corresponds to FileNameHashValue bucket
//
#define MFCB_LOCK_ADDR( _hash ) SrvMfcbHashTable[ HASH_TO_MFCB_INDEX( _hash ) ].Lock

//
// Forward declarations of local functions.
//
VOID
AllocateMfcb(
    OUT PMFCB *Mfcb,
    IN PUNICODE_STRING FileName,
    IN ULONG FileNameHashValue,
    IN PWORK_CONTEXT WorkContext
    );

STATIC
VOID
CloseRfcbInternal (
    IN PRFCB Rfcb,
    IN KIRQL OldIrql
    );

STATIC
VOID
DereferenceRfcbInternal (
    IN PRFCB Rfcb,
    IN KIRQL OldIrql
    );

STATIC
VOID
ReferenceRfcbInternal (
    PRFCB Rfcb,
    IN KIRQL OldIrql
    );

STATIC
VOID
UnlinkLfcbFromMfcb (
    IN PLFCB Lfcb
    );

STATIC
VOID
UnlinkRfcbFromLfcb (
    IN PRFCB Rfcb
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text( PAGE, AllocateMfcb )
#pragma alloc_text( PAGE, SrvCreateMfcb )
#pragma alloc_text( PAGE, SrvFindMfcb )
#pragma alloc_text( PAGE, SrvFreeMfcb )
#pragma alloc_text( PAGE, UnlinkLfcbFromMfcb )
#pragma alloc_text( PAGE, SrvDereferenceMfcb )
#pragma alloc_text( PAGE, SrvAllocateLfcb )
#pragma alloc_text( PAGE, SrvDereferenceLfcb )
#pragma alloc_text( PAGE, SrvFreeLfcb )
#pragma alloc_text( PAGE, UnlinkRfcbFromLfcb )
#pragma alloc_text( PAGE, SrvAllocateRfcb )
#pragma alloc_text( PAGE, SrvCloseRfcbsOnLfcb )
#pragma alloc_text( PAGE, SrvFreeRfcb )
#pragma alloc_text( PAGE8FIL, SrvCheckAndReferenceRfcb )
#pragma alloc_text( PAGE8FIL, SrvCloseRfcb )
#pragma alloc_text( PAGE8FIL, CloseRfcbInternal )
#pragma alloc_text( PAGE8FIL, SrvCompleteRfcbClose )
//#pragma alloc_text( PAGE8FIL, SrvDereferenceRfcb )
//#pragma alloc_text( PAGE8FIL, DereferenceRfcbInternal )
#pragma alloc_text( PAGE8FIL, SrvReferenceRfcb )
#pragma alloc_text( PAGE8FIL, ReferenceRfcbInternal )
#pragma alloc_text( PAGE8FIL, SrvCloseCachedRfcb )
//#pragma alloc_text( PAGE8FIL, SrvCloseCachedRfcbsOnConnection )
#pragma alloc_text( PAGE8FIL, SrvCloseCachedRfcbsOnLfcb )
#endif
#if 0
#pragma alloc_text( PAGECONN, SrvCloseRfcbsOnSessionOrPid )
#pragma alloc_text( PAGECONN, SrvCloseRfcbsOnTree )
#pragma alloc_text( PAGECONN, SrvFindCachedRfcb )
#endif

//
// Master File Control Block (MFCB) routines.
//
VOID
AllocateMfcb (
    OUT PMFCB *Mfcb,
    IN PUNICODE_STRING FileName,
    IN ULONG FileNameHashValue,
    IN PWORK_CONTEXT WorkContext
    )

/*++

Routine Description:

    This function allocates an MFCB from pool and places it in the hash table.

    The bucket's Lock must be held exclusive when this is called!!

Arguments:

    Mfcb - Returns a pointer to the MFCB, or NULL if no space was
        available.

Return Value:

    None.

--*/

{
    CLONG blockLength;
    PMFCB mfcb;
    PNONPAGED_MFCB nonpagedMfcb = NULL;
    PWORK_QUEUE queue = WorkContext->CurrentWorkQueue;
    PLIST_ENTRY listHead;
    PSINGLE_LIST_ENTRY listEntry;

    PAGED_CODE();

    //
    // Attempt to allocate from pool.
    //

    blockLength = sizeof(MFCB) + FileName->Length + sizeof(WCHAR);

    mfcb = ALLOCATE_HEAP( blockLength, BlockTypeMfcb );
    *Mfcb = mfcb;

    if ( mfcb == NULL ) {

        INTERNAL_ERROR(
            ERROR_LEVEL_EXPECTED,
            "AllocateMfcb: Unable to allocate %d bytes from pool\n",
            blockLength,
            NULL
            );

        // The caller will log the error

        return;
    }

    nonpagedMfcb = (PNONPAGED_MFCB)InterlockedExchangePointer(
                                    &queue->CachedFreeMfcb,
                                    nonpagedMfcb );

    if( nonpagedMfcb == NULL ) {

        listEntry = ExInterlockedPopEntrySList(
                        &queue->MfcbFreeList,
                        &queue->SpinLock
                        );

        if( listEntry != NULL ) {

            InterlockedDecrement( &queue->FreeMfcbs );
            nonpagedMfcb = CONTAINING_RECORD( listEntry, NONPAGED_MFCB, SingleListEntry );

        } else {

            nonpagedMfcb = ALLOCATE_NONPAGED_POOL(
                                    sizeof(NONPAGED_MFCB),
                                    BlockTypeNonpagedMfcb );

            if ( nonpagedMfcb == NULL ) {

                INTERNAL_ERROR(
                    ERROR_LEVEL_EXPECTED,
                    "AllocateMfcb: Unable to allocate %d bytes from pool\n",
                    sizeof(NONPAGED_MFCB),
                    NULL
                    );

                // The caller will log the error

                FREE_HEAP( mfcb );
                *Mfcb = NULL;
                return;
            }

            IF_DEBUG(HEAP) {
                KdPrint(( "AllocateMfcb: Allocated MFCB at 0x%p\n", mfcb ));
            }

            nonpagedMfcb->Type = BlockTypeNonpagedMfcb;
        }
    }

    nonpagedMfcb->PagedBlock = mfcb;

    RtlZeroMemory( mfcb, blockLength );

    mfcb->NonpagedMfcb = nonpagedMfcb;

    //
    // Initialize the MFCB.
    //

    SET_BLOCK_TYPE_STATE_SIZE( mfcb, BlockTypeMfcb, BlockStateClosing, blockLength );
    mfcb->BlockHeader.ReferenceCount = 1;

    InitializeListHead( &mfcb->LfcbList );
    INITIALIZE_LOCK( &nonpagedMfcb->Lock, MFCB_LOCK_LEVEL, "MfcbLock" );

    //
    // Store the filename as it was passed into us
    //
    mfcb->FileName.Length = FileName->Length;
    mfcb->FileName.MaximumLength = (SHORT)(FileName->Length + sizeof(WCHAR));
    mfcb->FileName.Buffer = (PWCH)(mfcb + 1);
    RtlCopyMemory( mfcb->FileName.Buffer, FileName->Buffer, FileName->Length );

    //
    // Store the hash value for the filename
    //
    mfcb->FileNameHashValue = FileNameHashValue;

    //
    // Store the SnapShot time if set
    //
    mfcb->SnapShotTime.QuadPart = WorkContext->SnapShotTime.QuadPart;

    INITIALIZE_REFERENCE_HISTORY( mfcb );

    //
    // Add it to the hash table
    //
    listHead = &SrvMfcbHashTable[ HASH_TO_MFCB_INDEX( FileNameHashValue ) ].List;
    InsertHeadList( listHead, &mfcb->MfcbHashTableEntry );

#if SRVCATCH
    if( SrvCatch.Length ) {
        UNICODE_STRING baseName;

        SrvGetBaseFileName( FileName, &baseName );
        if( RtlCompareUnicodeString( &SrvCatch, &baseName, TRUE ) == 0 ) {
            mfcb->SrvCatch = 1;
        }
    }
    if( SrvCatchExt.Length && WorkContext->TreeConnect->Share->IsCatchShare ) {
        UNICODE_STRING baseName;

        SrvGetBaseFileName( FileName, &baseName );
        if( baseName.Length > 6 )
        {
            baseName.Buffer += (baseName.Length-6)>>1;
            baseName.Length = 6;
            if( RtlCompareUnicodeString( &SrvCatchExt, &baseName, TRUE ) == 0 ) {
                mfcb->SrvCatch = 2;
            }
        }
    }
#endif

    INCREMENT_DEBUG_STAT( SrvDbgStatistics.MfcbInfo.Allocations );

    return;

} // AllocateMfcb


PMFCB
SrvCreateMfcb(
    IN PUNICODE_STRING FileName,
    IN PWORK_CONTEXT WorkContext,
    IN ULONG HashValue
    )

/*++

Routine Description:

    Called when a file is about to be opened.  Searches the Master File
    Table to see if the named file is already open.  If it isn't, a
    Master File Control Block is allocated and added to the list.

    *** The MFCB list lock must be held when this routine is called.  It
        remains held on exit.

    *** Note that the master file list CANNOT be walked to find and
        possibly delete open file instances.  This is because new
        instances are added to the list before the file is actually
        opened.  The connection file tables must be used to find "real"
        open file instances.

Arguments:

    FileName - Fully qualified name of file being opened.  If a new
        master file block is created, the string data is copied to that
        block, so the original data is no longer needed.

    HashValue - the pre-computed hash value for this filename

Return Value:

    PMFCB - Pointer to existing or newly created MFCB; NULL if unable
        allocate space for MFCB.

--*/

{
    PMFCB mfcb;
    PLIST_ENTRY listEntryRoot, listEntry;

    PAGED_CODE( );

    //
    // Search the Hash File List to determine whether the named file
    // is already open.
    //

    ASSERT( ExIsResourceAcquiredExclusiveLite( MFCB_LOCK_ADDR( HashValue )) );

    listEntryRoot = &SrvMfcbHashTable[ HASH_TO_MFCB_INDEX( HashValue ) ].List;

    for( listEntry = listEntryRoot->Flink;
         listEntry != listEntryRoot;
         listEntry = listEntry->Flink ) {

        mfcb = CONTAINING_RECORD( listEntry, MFCB, MfcbHashTableEntry );

        if( mfcb->FileNameHashValue == HashValue &&
            mfcb->FileName.Length == FileName->Length &&
            mfcb->SnapShotTime.QuadPart == WorkContext->SnapShotTime.QuadPart &&
            RtlEqualMemory( mfcb->FileName.Buffer,
                            FileName->Buffer,
                            FileName->Length ) ) {
                //
                // We've found a matching entry!
                //
                return mfcb;
        }
    }

    //
    // The named file is not yet open.  Allocate an MFCB
    //

    AllocateMfcb( &mfcb, FileName, HashValue, WorkContext );

    return mfcb;

} // SrvCreateMfcb


PMFCB
SrvFindMfcb(
    IN PUNICODE_STRING FileName,
    IN BOOLEAN CaseInsensitive,
    OUT PSRV_LOCK *Lock,
    OUT PULONG HashValue,
    IN PWORK_CONTEXT WorkContext
    )

/*++

Routine Description:

    Searches the Master File Table to see if the named file is already
    open, returning the address of an MFCB if it is.

    *** The MFCB list lock will be acquire exclusively whether or not
        this routine succeeds.  The address of the lock is placed in *Lock

Arguments:

    FileName - Fully qualified name of file being opened.

    CaseInsensitive - TRUE if the search should be case-insensitive.

    HashValue - if the MFCB was NOT found, *HashValue filled in with the hash
        value derived from the filename.  This can then be passed into
        SrvCreateMfcb later

Return Value:

    PMFCB - Pointer to existing created MFCB, if the named file is
        already open; NULL otherwise.

--*/

{
    PLIST_ENTRY listEntry, listEntryRoot;
    ULONG localHashValue;
    PMFCB mfcb;

    PAGED_CODE( );

    //
    // Search the Master File List to determine whether the named file
    // is already open.  If the length of the file name is zero, then
    // do not actually look in the list--the prefix routines do not
    // work with zero-length strings, and we know that we'll never
    // open a file with a name length == 0.
    //
    // !!! For SMB 4.0 (NT-NT), do we need to worry about share root
    //     directories?


    if ( FileName->Length == 0 ) {
        *HashValue = 0;
        *Lock = NULL;
        return NULL;
    }

    COMPUTE_STRING_HASH( FileName, &localHashValue );
    listEntryRoot = &SrvMfcbHashTable[ HASH_TO_MFCB_INDEX( localHashValue ) ].List;

    *Lock = MFCB_LOCK_ADDR( localHashValue );
    ACQUIRE_LOCK( *Lock );

    //
    // Search the Hash File List to determine whether the named file
    // is already open.
    //
    for( listEntry = listEntryRoot->Flink;
         listEntry != listEntryRoot;
         listEntry = listEntry->Flink ) {

        mfcb = CONTAINING_RECORD( listEntry, MFCB, MfcbHashTableEntry );

        if( mfcb->FileNameHashValue == localHashValue &&
            mfcb->FileName.Length == FileName->Length &&
            mfcb->SnapShotTime.QuadPart == WorkContext->SnapShotTime.QuadPart &&
            RtlEqualUnicodeString( &mfcb->FileName, FileName,CaseInsensitive)) {
                //
                // We've found a matching entry!
                //
                ASSERT( GET_BLOCK_TYPE(mfcb) == BlockTypeMfcb );
                ASSERT( GET_BLOCK_STATE(mfcb) == BlockStateClosing );

                mfcb->BlockHeader.ReferenceCount++;

                UPDATE_REFERENCE_HISTORY( mfcb, FALSE );

                IF_DEBUG(REFCNT) {
                    KdPrint(( "Referencing MFCB %p; new refcnt %lx\n",
                                mfcb, mfcb->BlockHeader.ReferenceCount ));
                }

                return mfcb;
        }
    }

    //
    // We didn't find the entry!  The file is not open
    //
    *HashValue = localHashValue;

    return NULL;

} // SrvFindMfcb


VOID
SrvFreeMfcb (
    IN PMFCB Mfcb
    )

/*++

Routine Description:

    This function returns an MFCB to the FSP heap.
    If you change this code, you should also look in FreeIdleWorkItems
        in scavengr.c

Arguments:

    Mfcb - Address of MFCB

Return Value:

    None.

--*/

{
    PWORK_QUEUE queue = PROCESSOR_TO_QUEUE();
    PNONPAGED_MFCB nonpagedMfcb = Mfcb->NonpagedMfcb;

    PAGED_CODE();

    DEBUG SET_BLOCK_TYPE_STATE_SIZE( Mfcb, BlockTypeGarbage, BlockStateDead, -1 );
    TERMINATE_REFERENCE_HISTORY( Mfcb );

    //
    // Delete the lock on the MFCB.  The lock must not be held.
    //

    ASSERT( RESOURCE_OF(nonpagedMfcb->Lock).ActiveCount == 0 );
    DELETE_LOCK( &nonpagedMfcb->Lock );

    nonpagedMfcb = (PNONPAGED_MFCB)InterlockedExchangePointer(
                            &queue->CachedFreeMfcb,
                            nonpagedMfcb );

    if( nonpagedMfcb != NULL ) {
        //
        // This check allows for the possibility that FreeMfcbs might exceed
        // MaxFreeMfcbs, but it's fairly unlikely given the operation of kernel
        // queue objects.  But even so, it probably won't exceed it by much and
        // is really only advisory anyway.
        //
        if( queue->FreeMfcbs < queue->MaxFreeMfcbs ) {

            ExInterlockedPushEntrySList(
                &queue->MfcbFreeList,
                &nonpagedMfcb->SingleListEntry,
                &queue->SpinLock
            );

            InterlockedIncrement( &queue->FreeMfcbs );

        } else {

            DEALLOCATE_NONPAGED_POOL( nonpagedMfcb );
        }
    }

    FREE_HEAP( Mfcb );
    IF_DEBUG(HEAP) KdPrint(( "SrvFreeMfcb: Freed MFCB at 0x%p\n", Mfcb ));

    INCREMENT_DEBUG_STAT( SrvDbgStatistics.MfcbInfo.Frees );

    return;

} // SrvFreeMfcb


VOID
UnlinkLfcbFromMfcb (
    IN PLFCB Lfcb
    )

/*++

Routine Description:

    This function unlinks an LFCB from its parent MFCB and decrements
    the MFCB's reference count.  If the count goes to zero, the MFCB
    is removed from the Master File Table and deleted.

    *** The MFCB lock must be held when this routine is called.  It
        is released before exit.

Arguments:

    Lfcb - Address of LFCB

Return Value:

    None.

--*/

{
    PMFCB mfcb = Lfcb->Mfcb;

    PAGED_CODE( );

    ASSERT( mfcb != NULL );

    ASSERT( ExIsResourceAcquiredExclusiveLite(&RESOURCE_OF(mfcb->NonpagedMfcb->Lock)) );

    //
    // Remove the LFCB from the MFCB's list.  Decrement the reference
    // count on the MFCB.  The MFCB lock must be released before
    // dereferencing the MFCB, because that may cause the MFCB to be
    // deleted.
    //

    SrvRemoveEntryList( &mfcb->LfcbList, &Lfcb->MfcbListEntry );

    RELEASE_LOCK( &mfcb->NonpagedMfcb->Lock );

    SrvDereferenceMfcb( mfcb );

    return;

} // UnlinkLfcbFromMfcb


VOID
SrvDereferenceMfcb (
    IN PMFCB Mfcb
    )

/*++

Routine Description:

    This function decrements the reference count for an MFCB.  If
    the reference count reaches zero, the block is freed.

    *** The MFCB lock (not the MFCB _list_ lock) must not be held when
        this routine is called, unless the caller has an extra reference
        to the MFCB, because otherwise this routine could destroy the
        MFCB and the lock.  Note that sequences beginning in DoDelete
        and SrvMoveFile and coming here via SrvCloseRfcbsOnLfcb cause
        this routine to be called with the MFCB lock held.

Arguments:

    Mfcb - A pointer to the MFCB

Return Value:

    None.

--*/

{
    PSRV_LOCK lock = MFCB_LOCK_ADDR( Mfcb->FileNameHashValue );

    PAGED_CODE( );

    IF_DEBUG(REFCNT) {
        KdPrint(( "Dereferencing MFCB %p; old refcnt %lx\n",
                    Mfcb, Mfcb->BlockHeader.ReferenceCount ));
    }

    //
    // Acquire the MFCB table lock.  This lock protects the reference
    // count on the MFCB.
    //

    ACQUIRE_LOCK( lock );

    ASSERT( GET_BLOCK_TYPE( Mfcb ) == BlockTypeMfcb );
    ASSERT( (LONG)Mfcb->BlockHeader.ReferenceCount > 0 );
    UPDATE_REFERENCE_HISTORY( Mfcb, TRUE );

    if ( --Mfcb->BlockHeader.ReferenceCount == 0 ) {

        //
        // This is the last reference to the MFCB.  Delete the block.
        // Unlink the MFCB from the Master File Table.
        //
        ASSERT( Mfcb->LfcbList.Flink == &Mfcb->LfcbList );

        RemoveEntryList( &Mfcb->MfcbHashTableEntry );

        RELEASE_LOCK( lock );

        //
        // Free the MFCB.  Note that SrvFreeMfcb deletes the MFCB's
        // lock.
        //

        SrvFreeMfcb( Mfcb );

    } else {

        RELEASE_LOCK( lock );

    }

} // SrvDereferenceMfcb


//
// Local File Control Block (LFCB) routines.
//

VOID
SrvAllocateLfcb (
    OUT PLFCB *Lfcb,
    IN PWORK_CONTEXT WorkContext
    )

/*++

Routine Description:

    This function allocates an LFCB from pool.

Arguments:

    Lfcb - Returns a pointer to the LFCB, or NULL if no space was
        available.

Return Value:

    None.

--*/

{
    PLFCB lfcb = NULL;
    PWORK_QUEUE queue = WorkContext->CurrentWorkQueue;

    PAGED_CODE();

    //
    // Attempt to allocate from pool.
    //

    lfcb = ALLOCATE_HEAP( sizeof(LFCB), BlockTypeLfcb );
    *Lfcb = lfcb;

    if ( lfcb == NULL ) {

        ULONG size = sizeof( LFCB );

        INTERNAL_ERROR(
            ERROR_LEVEL_EXPECTED,
            "SrvAllocateLfcb: Unable to allocate %d bytes from paged pool.",
            sizeof( LFCB ),
            NULL
            );

        // The caller will log the error

        return;
    }

    IF_DEBUG(HEAP) {
        KdPrint(( "SrvAllocateLfcb: Allocated LFCB at 0x%p\n", lfcb ));
    }

    //
    // Initialize the LFCB.  Zero it first.
    //

    RtlZeroMemory( lfcb, sizeof(LFCB) );

    //
    // Initialize the LFCB.
    //

    SET_BLOCK_TYPE_STATE_SIZE( lfcb, BlockTypeLfcb, BlockStateClosing, sizeof( LFCB ) );

    //
    // !!! Note that the block's reference count is set to 1 to account
    //     for the open handle.  No other reference is needed
    //     because 1) the LFCB is a temporary object, and 2) the
    //     caller (SrvAddOpenFileInstance) doesn't really need to
    //     reference the block, because it owns the appropriate lock
    //     for the entire time that it's doing its thing.
    //

    lfcb->BlockHeader.ReferenceCount = 1;

    InitializeListHead( &lfcb->RfcbList );

    INITIALIZE_REFERENCE_HISTORY( lfcb );

    INCREMENT_DEBUG_STAT( SrvDbgStatistics.LfcbInfo.Allocations );

    return;

} // SrvAllocateLfcb


VOID
SrvDereferenceLfcb (
    IN PLFCB Lfcb
    )

/*++

Routine Description:

    This function dereference the LFCB and frees the LFCB if the reference
    count reaches 0.

    *** The caller of this function must own the MFCB lock for the file.
        The lock is released by this function.

Arguments:

    Lfcb - The LFCB to dereference

Return Value:

    None.

--*/

{
    PAGED_CODE( );

    ASSERT( ExIsResourceAcquiredExclusiveLite(&RESOURCE_OF(Lfcb->Mfcb->NonpagedMfcb->Lock)) );
    ASSERT( GET_BLOCK_TYPE( Lfcb ) == BlockTypeLfcb );
    ASSERT( (LONG)Lfcb->BlockHeader.ReferenceCount > 0 );
    UPDATE_REFERENCE_HISTORY( Lfcb, TRUE );

    if ( --Lfcb->BlockHeader.ReferenceCount == 0 ) {

        //
        // This is the last reference to the LFCB.  Unlink the
        // LFCB from the MFCB's list.
        //

        ASSERT( Lfcb->RfcbList.Flink == &Lfcb->RfcbList );
        ASSERT( Lfcb->HandleCount == 0 );

        IF_DEBUG( CREATE ) {
            KdPrint(( "SrvDereferenceLfcb: deref %wZ fileObject\n",
                &Lfcb->Mfcb->FileName ));
        }

        //
        // UnlinkLfcbFromMfcb will release the MFCB lock that we hold.
        //

        UnlinkLfcbFromMfcb( Lfcb );

        //
        // Dereference the file object.
        //

        ObDereferenceObject( Lfcb->FileObject );
        DEBUG Lfcb->FileObject = NULL;

        //
        // Decrement the count of open files on the session and tree
        // connect.
        //

        ACQUIRE_LOCK( &Lfcb->Connection->Lock );

        ASSERT( Lfcb->Session->CurrentFileOpenCount != 0 );
        Lfcb->Session->CurrentFileOpenCount--;

        ASSERT( Lfcb->TreeConnect->CurrentFileOpenCount != 0 );
        Lfcb->TreeConnect->CurrentFileOpenCount--;

        RELEASE_LOCK( &Lfcb->Connection->Lock );

        //
        // Dereference the tree connect, session, and connection that
        // the LFCB points to.
        //

        SrvDereferenceTreeConnect( Lfcb->TreeConnect );
        DEBUG Lfcb->TreeConnect = NULL;

        SrvDereferenceSession( Lfcb->Session );
        DEBUG Lfcb->Session = NULL;

        SrvDereferenceConnection( Lfcb->Connection );
        DEBUG Lfcb->Connection = NULL;

        //
        // Free the LFCB.
        //

        SrvFreeLfcb( Lfcb, PROCESSOR_TO_QUEUE() );

    } else {

        RELEASE_LOCK( &Lfcb->Mfcb->NonpagedMfcb->Lock );

    }

} // SrvDereferenceLfcb


VOID
SrvFreeLfcb (
    IN PLFCB Lfcb,
    IN PWORK_QUEUE queue
    )

/*++

Routine Description:

    This function returns an LFCB to the system nonpaged pool.
    If you change this routine, look also in FreeIdleWorkItems in scavengr.c

Arguments:

    Lfcb - Address of LFCB

Return Value:

    None.

--*/

{
    PAGED_CODE();

    ASSERT ( Lfcb->HandleCount == 0 );

    DEBUG SET_BLOCK_TYPE_STATE_SIZE( Lfcb, BlockTypeGarbage, BlockStateDead, -1 );
    DEBUG Lfcb->BlockHeader.ReferenceCount = (ULONG)-1;
    TERMINATE_REFERENCE_HISTORY( Lfcb );

    FREE_HEAP( Lfcb );

    INCREMENT_DEBUG_STAT( SrvDbgStatistics.LfcbInfo.Frees );

    IF_DEBUG(HEAP) KdPrint(( "SrvFreeLfcb: Freed LFCB at 0x%p\n", Lfcb ));

    return;

} // SrvFreeLfcb


VOID
UnlinkRfcbFromLfcb (
    IN PRFCB Rfcb
    )

/*++

Routine Description:

    This function unlinks an RFCB from its parent LFCB and decrements
    the LFCB's reference count.  If the count goes to zero, the LFCB
    is unlinked from its parent MFCB and deleted.

Arguments:

    Rfcb - Address of RFCB

Return Value:

    None.

--*/

{
    PLFCB lfcb = Rfcb->Lfcb;
    LARGE_INTEGER offset;
    HANDLE handle;

    PAGED_CODE( );

    UpdateRfcbHistory( Rfcb, 'klnu' );

    ASSERT( lfcb != NULL );

    if( Rfcb->PagedRfcb->IpxSmartCardContext ) {
        IF_DEBUG( SIPX ) {
            KdPrint(("Calling Smart Card Close for Rfcb %p\n", Rfcb ));
        }
        SrvIpxSmartCard.Close( Rfcb->PagedRfcb->IpxSmartCardContext );
    }

#ifdef INCLUDE_SMB_PERSISTENT
    if (Rfcb->PersistentHandle) {
//      SrvPostPersistentClose( Rfcb );
    }
#endif

    //
    // Acquire the lock that guards access to the LFCB's RFCB list.
    //

    ACQUIRE_LOCK( &lfcb->Mfcb->NonpagedMfcb->Lock );

    //
    // Decrement the active RFCB count for the LFCB.  This must be here
    // instead of in SrvCloseRfcb because the MFCB lock must be held to
    // update the count.
    //

    --lfcb->Mfcb->ActiveRfcbCount;
    UPDATE_REFERENCE_HISTORY( lfcb, FALSE );

    //
    // Decrement the open handle count on the LFCB.
    //

    if ( --lfcb->HandleCount == 0 ) {

        handle = lfcb->FileHandle;

        //
        // Other SMB processors may still have a referenced pointer to
        // the LFCB.  Ensure that any attempt to use the file handle fails.
        //

        lfcb->FileHandle = 0;

        //
        // This was the last open RFCB referencing the LFCB.  Close the
        // file handle.
        //

        SRVDBG_RELEASE_HANDLE( handle, "FIL", 3, lfcb );

        IF_DEBUG( CREATE ) {
            KdPrint(( "UnlinkRfcbFromLfcb: rfcb %p, close handle for %wZ\n",
                Rfcb, &lfcb->Mfcb->FileName ));
        }

        SrvNtClose( handle, TRUE );

        //
        // If this is a print spool file, schedule the job on the
        // printer.
        //

        if ( Rfcb->ShareType == ShareTypePrint ) {
            SrvSchedulePrintJob(
                lfcb->TreeConnect->Share->Type.hPrinter,
                lfcb->JobId
                );
        }

        //
        // Release the open handle reference to the LFCB.  The open
        // lock is release by SrvDereferenceLfcb().  Note that this
        // releases the MFCB lock.
        //

        SrvDereferenceLfcb( lfcb );

    } else {

        //
        // Other RFCBs have references to the LFCB, so we can't close
        // the file yet.  (This must be a compatibility mode open.)
        // Release all locks taken out by the process that opened the
        // file.
        //
        // *** Note that if any locks were taken out using PIDs other
        //     than that which opened the FID, those locks cannot be
        //     automatically deleted.  We count on the redirector to do
        //     the right thing in this case.
        //

        offset.QuadPart = 0;

        IF_SMB_DEBUG(LOCK1) {
            KdPrint(( "UnlinkRfcbFromLfcb: Issuing UnlockAllByKey for "
                        "file object 0x%p, key 0x%lx\n",
                        lfcb->FileObject,
                        Rfcb->ShiftedFid | Rfcb->Pid ));
        }
        (VOID)SrvIssueUnlockRequest(
                lfcb->FileObject,
                &lfcb->DeviceObject,
                IRP_MN_UNLOCK_ALL_BY_KEY,
                offset,
                offset,
                Rfcb->ShiftedFid | Rfcb->Pid
                );




        //
        // Release the MFCB lock.
        //

        RELEASE_LOCK( &lfcb->Mfcb->NonpagedMfcb->Lock );

    }

    return;

} // UnlinkRfcbFromLfcb


//
// Remote File Control Block (RFCB) routines.
//

VOID SRVFASTCALL
SrvAllocateRfcb (
    OUT PRFCB *Rfcb,
    IN PWORK_CONTEXT WorkContext
    )

/*++

Routine Description:

    This function allocates an RFCB from nonpaged pool.  Nonpaged pool
    is used so that read/write completion can be handled in the FSD.

Arguments:

    Rfcb - Returns a pointer to the RFCB, or NULL if no space was
        available.

Return Value:

    None.

--*/

{
    PRFCB rfcb = NULL;
    PPAGED_RFCB pagedRfcb;
    PWORK_QUEUE queue = WorkContext->CurrentWorkQueue;

    PAGED_CODE();

    //
    // Attempt to grab an rfcb structure off the per-queue free list
    //
    rfcb = (PRFCB)InterlockedExchangePointer( &queue->CachedFreeRfcb,
                                              rfcb );

    if( rfcb != NULL ) {

        *Rfcb = rfcb;
        pagedRfcb = rfcb->PagedRfcb;

    } else {

        if( queue->FreeRfcbs ) {

            PSINGLE_LIST_ENTRY listEntry;

            listEntry = ExInterlockedPopEntrySList(
                                    &queue->RfcbFreeList,
                                    &queue->SpinLock
                                    );

            if( listEntry != NULL ) {
                InterlockedIncrement( &queue->FreeRfcbs );
                rfcb = CONTAINING_RECORD( listEntry, RFCB, SingleListEntry );
                *Rfcb= rfcb;
                pagedRfcb = rfcb->PagedRfcb;
            }
        }

        if( rfcb == NULL ) {
            //
            // Attempt to allocate from nonpaged pool.
            //

            rfcb = ALLOCATE_NONPAGED_POOL( sizeof(RFCB), BlockTypeRfcb );
            *Rfcb = rfcb;

            if ( rfcb == NULL ) {
                INTERNAL_ERROR (
                    ERROR_LEVEL_EXPECTED,
                    "SrvAllocateRfcb: Unable to allocate %d bytes from nonpaged pool.",
                    sizeof( RFCB ),
                    NULL
                    );
                return;
            }

            pagedRfcb = ALLOCATE_HEAP( sizeof(PAGED_RFCB), BlockTypePagedRfcb );

            if ( pagedRfcb == NULL ) {
                INTERNAL_ERROR (
                    ERROR_LEVEL_EXPECTED,
                    "SrvAllocateRfcb: Unable to allocate %d bytes from paged pool.",
                    sizeof( PAGED_RFCB ),
                    NULL
                    );
                DEALLOCATE_NONPAGED_POOL( rfcb );
                *Rfcb = NULL;
                return;
            }

            IF_DEBUG(HEAP) {
                KdPrint(( "SrvAllocateRfcb: Allocated RFCB at 0x%p\n", rfcb ));
            }
        }
    }

    //
    // Initialize the RFCB.  Zero it first.
    //

    RtlZeroMemory( rfcb, sizeof( RFCB ));
    RtlZeroMemory( pagedRfcb, sizeof(PAGED_RFCB) );

    rfcb->PagedRfcb = pagedRfcb;
    pagedRfcb->PagedHeader.NonPagedBlock = rfcb;
    pagedRfcb->PagedHeader.Type = BlockTypePagedRfcb;

    SET_BLOCK_TYPE_STATE_SIZE( rfcb, BlockTypeRfcb, BlockStateActive, sizeof(RFCB) );
    rfcb->BlockHeader.ReferenceCount = 2;       // allow for Active status
                                                //  and caller's pointer

    INITIALIZE_REFERENCE_HISTORY( rfcb );

    rfcb->NewOplockLevel = NO_OPLOCK_BREAK_IN_PROGRESS;
    pagedRfcb->LastFailingLockOffset.QuadPart = -1;
    rfcb->IsCacheable = ( SrvCachedOpenLimit > 0 );

    InterlockedIncrement(
        (PLONG)&SrvStatistics.CurrentNumberOfOpenFiles
        );

    INCREMENT_DEBUG_STAT( SrvDbgStatistics.RfcbInfo.Allocations );

    //
    // Lock the file-based code section.
    //

    REFERENCE_UNLOCKABLE_CODE( 8FIL );

    InitializeListHead( &rfcb->RawWriteSerializationList );

    InitializeListHead( &rfcb->WriteMpx.GlomDelayList );

#ifdef INCLUDE_SMB_PERSISTENT
    InitializeListHead( &pagedRfcb->ByteRangeLocks );
#endif

    return;

} // SrvAllocateRfcb


BOOLEAN SRVFASTCALL
SrvCheckAndReferenceRfcb (
    PRFCB Rfcb
    )

/*++

Routine Description:

    This function atomically verifies that an RFCB is active and
    increments the reference count on the RFCB if it is.

Arguments:

    Rfcb - Address of RFCB

Return Value:

    BOOLEAN - Returns TRUE if the RFCB is active, FALSE otherwise.

--*/

{
    KIRQL oldIrql;

    UNLOCKABLE_CODE( 8FIL );

    //
    // Acquire the lock that guards the RFCB's state field.
    //

    ACQUIRE_SPIN_LOCK( &Rfcb->Connection->SpinLock, &oldIrql );

    //
    // If the RFCB is active, reference it and return TRUE.  Note that
    // ReferenceRfcbInternal releases the spin lock.
    //

    if ( GET_BLOCK_STATE(Rfcb) == BlockStateActive ) {

        ReferenceRfcbInternal( Rfcb, oldIrql );

        return TRUE;

    }

    //
    // The RFCB isn't active.  Return FALSE.
    //

    RELEASE_SPIN_LOCK( &Rfcb->Connection->SpinLock, oldIrql );

    return FALSE;

} // SrvCheckAndReferenceRfcb


VOID SRVFASTCALL
SrvCloseRfcb (
    PRFCB Rfcb
    )

/*++

Routine Description:

    This is the external routine for closing a file.  It acquires the
    appropriate spin lock, then calls CloseRfcbInternal.

Arguments:

    Rfcb - Supplies a pointer to the RFCB to be closed.

Return Value:

    None.

--*/

{
    KIRQL oldIrql;

    UNLOCKABLE_CODE( 8FIL );

    //
    // Acquire the lock that guards the RFCB's state field.  Call the
    // internal close routine.  That routine releases the spin lock.
    //

    ACQUIRE_SPIN_LOCK( &Rfcb->Connection->SpinLock, &oldIrql );

    CloseRfcbInternal( Rfcb, oldIrql );

    return;

} // SrvCloseRfcb


VOID
CloseRfcbInternal (
    PRFCB Rfcb,
    IN KIRQL OldIrql
    )

/*++

Routine Description:

    This internal function does the core of a file close.  It sets the
    state of the RFCB to Closing, unlinks it from its parent LFCB, and
    dereferences the RFCB.  The RFCB will be destroyed as soon as all
    other references to it are eliminated.

    *** This routine must be called with the spin lock synchronizing
        access to the RFCB's state field (the connection spin lock)
        held.  The lock is released on exit from this routine.

Arguments:

    Rfcb - Supplies a pointer to the RFCB to be closed.

    OldIrql - The previous IRQL value obtained when the spin lock was
        acquired.

Return Value:

    None.

--*/

{
    KIRQL oldIrql = OldIrql;
    LARGE_INTEGER cacheOffset;
    PMDL mdlChain;
    PCONNECTION connection = Rfcb->Connection;
    PWORK_CONTEXT workContext;
    ULONG i;
    ULONG writeLength;
    NTSTATUS status;

    UNLOCKABLE_CODE( 8FIL );

    ASSERT( GET_BLOCK_TYPE( Rfcb ) == BlockTypeRfcb );

    //
    // If the RFCB's state is still Active, change it to Closing and
    // cause cleanup to happen.
    //

    if ( GET_BLOCK_STATE(Rfcb) == BlockStateActive ) {

        IF_DEBUG(BLOCK1) KdPrint(( "Closing RFCB at 0x%p\n", Rfcb ));
        UpdateRfcbHistory( Rfcb, 'solc' );

        SET_BLOCK_STATE( Rfcb, BlockStateClosing );

        //
        // Invalidate the cached rfcb
        //

        if ( connection->CachedFid == (ULONG)Rfcb->Fid ) {
            connection->CachedFid = (ULONG)-1;
        }

        //
        // Don't cleanup if raw writes are still in progress
        //

        if ( Rfcb->RawWriteCount != 0 ) {

            //
            // Cleanup will happen in SrvDecrementRawWriteCount
            //

            RELEASE_SPIN_LOCK( &connection->SpinLock, oldIrql );
            return;

        }

        //
        // Do we have write mpx outstanding?
        //

        if ( Rfcb->WriteMpx.ReferenceCount != 0 ) {

            //
            // Cleanup will happen when the ref count drops to 0
            //

            RELEASE_SPIN_LOCK( &connection->SpinLock, oldIrql );
            return;

        } else if ( Rfcb->WriteMpx.Glomming ) {

            //
            // We need to complete this write mdl
            //

            Rfcb->WriteMpx.Glomming = FALSE;
            Rfcb->WriteMpx.GlomComplete = FALSE;

            //
            // Save the offset and MDL address.
            //

            cacheOffset.QuadPart = Rfcb->WriteMpx.StartOffset;
            mdlChain = Rfcb->WriteMpx.MdlChain;
            writeLength = Rfcb->WriteMpx.Length;

            DEBUG Rfcb->WriteMpx.MdlChain = NULL;
            DEBUG Rfcb->WriteMpx.StartOffset = 0;
            DEBUG Rfcb->WriteMpx.Length = 0;

            //
            // Now we can release the lock.
            //

            RELEASE_SPIN_LOCK( &connection->SpinLock, oldIrql );

            //
            // Tell the cache manager that we're done with this MDL write.
            //

            if( Rfcb->Lfcb->MdlWriteComplete == NULL ||
                Rfcb->Lfcb->MdlWriteComplete(
                    Rfcb->WriteMpx.FileObject,
                    &cacheOffset,
                    mdlChain,
                    Rfcb->Lfcb->DeviceObject ) == FALSE ) {

                status = SrvIssueMdlCompleteRequest( NULL, Rfcb->WriteMpx.FileObject,
                                            mdlChain,
                                            IRP_MJ_WRITE,
                                            &cacheOffset,
                                            writeLength
                                           );

                if( !NT_SUCCESS( status ) ) {
                    SrvLogServiceFailure( SRV_SVC_MDL_COMPLETE, status );
                }
            }

        } else {

            RELEASE_SPIN_LOCK( &connection->SpinLock, oldIrql );
        }

        //
        // Do the actual close
        //

        SrvCompleteRfcbClose( Rfcb );

    } else {

        RELEASE_SPIN_LOCK( &connection->SpinLock, oldIrql );

    }

    return;

} // CloseRfcbInternal


VOID
SrvCloseRfcbsOnLfcb (
    PLFCB Lfcb
    )

/*++

Routine Description:

    This routine closes all RFCBs on an LFCB.  It is used by Delete and
    Rename processors to close all open instances of a file opened in
    compability mode (or FCB).

    *** The MFCB lock of the MFCB corresponding to this LFCB must be
        held on entry to this routine; the lock remains held on exit.
        The caller must also have an additional reference to the MFCB,
        in order to prevent it from being deleted while the MFCB lock
        is held.

Arguments:

    Lfcb - Supplies a pointer to the LFCB whose RFCBs are to be closed.

Return Value:

    None.

--*/

{
    PPAGED_RFCB pagedRfcb;
    PPAGED_RFCB nextPagedRfcb;
    PRFCB rfcb;

    PAGED_CODE( );

    ASSERT( ExIsResourceAcquiredExclusiveLite(&RESOURCE_OF(Lfcb->Mfcb->NonpagedMfcb->Lock)) );

    //
    // Loop through the LFCB's RFCB list.  Note that the fact that we
    // hold the MFCB lock throughout this routine means that no changes
    // to the list, other than the ones we make, can occur.  This makes
    // it safe to capture the address of the next RFCB in the list
    // before closing the current one.
    //

    pagedRfcb = CONTAINING_RECORD(
                        Lfcb->RfcbList.Flink,
                        PAGED_RFCB,
                        LfcbListEntry
                        );

    while ( &pagedRfcb->LfcbListEntry != &Lfcb->RfcbList ) {

        nextPagedRfcb = CONTAINING_RECORD(
                        pagedRfcb->LfcbListEntry.Flink,
                        PAGED_RFCB,
                        LfcbListEntry
                        );

        //
        // A file owned by the specified LFCB has been found.  Close it.
        //

        rfcb = pagedRfcb->PagedHeader.NonPagedBlock;
        if ( GET_BLOCK_STATE(rfcb) == BlockStateActive ) {
            SrvCloseRfcb( rfcb );
        }

        //
        // Move to the next RFCB in the LFCB's list.
        //

        pagedRfcb = nextPagedRfcb;

    }

    //
    // Close cached RFCBs.  These aren't dealt with in the loop above
    // because their state is BlockStateClosing.
    //

    SrvCloseCachedRfcbsOnLfcb( Lfcb );

    return;

} // SrvCloseRfcbsOnLfcb


VOID
SrvCloseRfcbsOnSessionOrPid (
    IN PSESSION Session,
    IN PUSHORT Pid OPTIONAL
    )

/*++

Routine Description:

    This routine closes all files "owned" by the specified session and/or
    PID in response to a Process Exit SMB.  PIDs are unique within the
    session that creates them.  This routine walks the file table of the
    connection that owns the specified session, closing all RFCBs whose
    owning session and PID are equal to the PID passed to this routine.

    Each session has a unique UID, so we can compare Uid's instead of comparing
    the actual session pointer.

Arguments:

    Session - Supplies a pointer to the session block corresponding to
        the specified PID, if specified.

    Pid - if present, Supplies pointer to the PID for which files are
        to be closed.

Return Value:

    None.

--*/

{
    PTABLE_HEADER tableHeader;
    PCONNECTION connection;
    PRFCB rfcb;
    USHORT i;
    KIRQL oldIrql;
    USHORT Uid;
    PLIST_ENTRY listEntry;

    //UNLOCKABLE_CODE( CONN );

    //
    // Get the address of the connection's file table.
    //

    connection = Session->Connection;
    tableHeader = &connection->FileTable;
    Uid = Session->Uid;

    //
    // Acquire the lock that guards the file table.  This lock is held
    // while walking the table, in order to prevent the table from
    // changing.
    //

    ACQUIRE_SPIN_LOCK( &connection->SpinLock, &oldIrql );

    //
    // Walk the file table, looking for files owned by the specified
    // session and/or PID.
    //

    for ( i = 0; i < tableHeader->TableSize; i++ ) {

        rfcb = (PRFCB)tableHeader->Table[i].Owner;

        if((rfcb != NULL) &&
          (GET_BLOCK_STATE(rfcb) == BlockStateActive) &&
          (rfcb->Uid == Uid) &&
          (!ARGUMENT_PRESENT( Pid ) || (rfcb->Pid == *Pid)) ) {

            //
            // A file owned by the specified session/process has
            // been found.  Close the RFCB, and make sure it doesn't
            // end up in the RFCB cache.
            //

            rfcb->IsCacheable = FALSE;
            CloseRfcbInternal( rfcb, oldIrql );
            ACQUIRE_SPIN_LOCK( &connection->SpinLock, &oldIrql );
        }
    }

    //
    // Now walk the RFCB cache to see if we have cached files that refer
    //  to this session that need to be closed.
    //

again:

    IF_DEBUG(FILE_CACHE) KdPrint(( "SrvCloseRfcbsOnSessionOrPid: "
                                    "checking for cached RFCBS\n" ));

    for ( listEntry = connection->CachedOpenList.Flink;
          listEntry != &connection->CachedOpenList;
          listEntry = listEntry->Flink ) {

        rfcb = CONTAINING_RECORD( listEntry, RFCB, CachedOpenListEntry );

        if( (rfcb->Uid == Uid) &&
            ( !ARGUMENT_PRESENT( Pid ) || rfcb->Pid == *Pid) ) {

            //
            // This cached file is owned by session and/or process.
            // Close the RFCB.
            //
            SrvCloseCachedRfcb( rfcb, oldIrql );
            ACQUIRE_SPIN_LOCK( &connection->SpinLock, &oldIrql );
            goto again;
        }
    }

    //
    // All done.  Release the lock.
    //

    RELEASE_SPIN_LOCK( &connection->SpinLock, oldIrql );

    return;

} // SrvCloseRfcbsOnSessionOrPid


VOID
SrvCloseRfcbsOnTree (
    PTREE_CONNECT TreeConnect
    )

/*++

Routine Description:

    This routine closes all files "owned" by the specified tree connect.
    It walks the file table of the connection that owns the tree
    connection.  Each file in that table that is owned by the tree
    connect is closed.

Arguments:

    TreeConnect - Supplies a pointer to the tree connect block for which
        files are to be closed.

Return Value:

    None.

--*/

{
    PRFCB rfcb;
    PTABLE_HEADER tableHeader;
    PCONNECTION connection;
    USHORT i;
    KIRQL oldIrql;
    PLIST_ENTRY listEntry;
    USHORT Tid;

    //UNLOCKABLE_CODE( CONN );

    //
    // Get the address of the connection's file table.
    //

    connection = TreeConnect->Connection;
    tableHeader = &connection->FileTable;
    Tid = TreeConnect->Tid;

    //
    // Acquire the lock that guards the file table.  This lock is held
    // while walking the table, in order to prevent the table from
    // changing.
    //

    ACQUIRE_SPIN_LOCK( &connection->SpinLock, &oldIrql );

    //
    // Walk the file table, looking for files owned by the specified
    // tree and PID.
    //

    for ( i = 0; i < tableHeader->TableSize; i++ ) {

        rfcb = (PRFCB)tableHeader->Table[i].Owner;

        if((rfcb != NULL) &&
           (GET_BLOCK_STATE(rfcb) == BlockStateActive) &&
           (rfcb->Tid == Tid )) {

             //
             // A file owned by the specified tree connect has been found.
             // Close the RFCB and make sure it doesn't get cached
             //

             rfcb->IsCacheable = FALSE;
             CloseRfcbInternal( rfcb, oldIrql );
             ACQUIRE_SPIN_LOCK( &connection->SpinLock, &oldIrql );
        }
    }

    //
    // Walk the cached open list, looking for files open on this tree
    //  Close any that we find.
    //

again:

    IF_DEBUG(FILE_CACHE) KdPrint(( "SrvCloseRfcbsOnTree: checking for cached RFCBS\n" ));

    for ( listEntry = connection->CachedOpenList.Flink;
          listEntry != &connection->CachedOpenList;
          listEntry = listEntry->Flink ) {

        rfcb = CONTAINING_RECORD( listEntry, RFCB, CachedOpenListEntry );

        if( rfcb->Tid == Tid ) {
            //
            // This cached file is owned by the specifiec tree connect.
            // Close the RFCB.
            //
            SrvCloseCachedRfcb( rfcb, oldIrql );
            ACQUIRE_SPIN_LOCK( &connection->SpinLock, &oldIrql );
            goto again;
        }
    }

    //
    // All done.  Release the lock.
    //

    RELEASE_SPIN_LOCK( &connection->SpinLock, oldIrql );

    return;

} // SrvCloseRfcbsOnTree


VOID
SrvCompleteRfcbClose (
    IN PRFCB Rfcb
    )

/*++

Routine Description:

    This routine completes the rfcb close.

Arguments:

    Rfcb - Supplies a pointer to the RFCB to be closed.

Return Value:

    None.

--*/

{
    KIRQL oldIrql;
    PCONNECTION connection = Rfcb->Connection;

    UNLOCKABLE_CODE( 8FIL );

    UpdateRfcbHistory( Rfcb, 'tlpc' );

    //
    // Remove the Rfcb from the oplockbreaksinprogresslist.  When the
    // Rfcb gets closed, we don't process any more oplock breaks
    // responses.
    //

    ACQUIRE_LOCK( &SrvOplockBreakListLock );
    if ( Rfcb->OnOplockBreaksInProgressList ) {

        Rfcb->NewOplockLevel = NO_OPLOCK_BREAK_IN_PROGRESS;
        Rfcb->OplockState = OplockStateNone;

        //
        // Remove the Rfcb from the Oplock breaks in progress list, and
        // release the Rfcb reference.
        //

        SrvRemoveEntryList( &SrvOplockBreaksInProgressList, &Rfcb->ListEntry );
        Rfcb->OnOplockBreaksInProgressList = FALSE;
#if DBG
        Rfcb->ListEntry.Flink = Rfcb->ListEntry.Blink = NULL;
#endif
        RELEASE_LOCK( &SrvOplockBreakListLock );
        SrvDereferenceRfcb( Rfcb );

        ExInterlockedAddUlong(
            &connection->OplockBreaksInProgress,
            (ULONG)-1,
            connection->EndpointSpinLock
            );

    } else {

        RELEASE_LOCK( &SrvOplockBreakListLock );

    }

    //
    // If this RFCB has a batch oplock, then it is eligible for caching.
    //

    if ( Rfcb->IsCacheable && Rfcb->NumberOfLocks == 0 &&
         ((Rfcb->OplockState == OplockStateOwnBatch) ||
          (Rfcb->OplockState == OplockStateOwnServerBatch)) &&
         (Rfcb->PagedRfcb->FcbOpenCount == 0) &&
          !Rfcb->Mfcb->CompatibilityOpen ) {

        ACQUIRE_SPIN_LOCK( &connection->SpinLock, &oldIrql );

        if ( Rfcb->IsCacheable &&
             ((Rfcb->OplockState == OplockStateOwnBatch) ||
             (Rfcb->OplockState == OplockStateOwnServerBatch)) &&
             (GET_BLOCK_STATE(connection) == BlockStateActive) ) {

            //
            // Indicate that this RFCB now has a server-owned batch
            // oplock.  Indicate that it is on the cached-after-close
            // list.  Insert it on that list.
            //

            UpdateRfcbHistory( Rfcb, 'hcac' );

            Rfcb->OplockState = OplockStateOwnServerBatch;
            Rfcb->CachedOpen = TRUE;
            InsertHeadList(
                &connection->CachedOpenList,
                &Rfcb->CachedOpenListEntry
                );
            IF_DEBUG(FILE_CACHE) KdPrint(( "SrvCompleteRfcbClose: caching rfcb %p\n", Rfcb ));

            //
            // Increment the count of cached RFCBs.  If there are now
            // too many cached RFCBs, close the oldest one.
            //

            if ( ++connection->CachedOpenCount > SrvCachedOpenLimit ) {
                PRFCB rfcbToClose;
                rfcbToClose = CONTAINING_RECORD(
                                connection->CachedOpenList.Blink,
                                RFCB,
                                CachedOpenListEntry
                                );

                //
                // SrvCloseCachedRfcb releases the spin lock.
                //

                SrvCloseCachedRfcb( rfcbToClose, oldIrql );

            } else {
                RELEASE_SPIN_LOCK( &connection->SpinLock, oldIrql );
            }

            if( Rfcb->PagedRfcb->IpxSmartCardContext ) {
                IF_DEBUG( SIPX ) {
                    KdPrint(("Calling Smart Card Close for Rfcb %p\n", Rfcb ));
                }
                SrvIpxSmartCard.Close( Rfcb->PagedRfcb->IpxSmartCardContext );
                Rfcb->PagedRfcb->IpxSmartCardContext = NULL;
            }

            return;
        }

        RELEASE_SPIN_LOCK( &connection->SpinLock, oldIrql );


    }
    IF_DEBUG(FILE_CACHE) KdPrint(( "SrvCompleteRfcbClose: can't cache rfcb %p, %wZ\n",
        Rfcb, &Rfcb->Lfcb->Mfcb->FileName ));

    //
    // Unlink the RFCB from the LFCB.  If this is the last RFCB for
    // this LFCB, this will force the file closed even if there are
    // still references to the RFCB.  This will unblock blocked I/O.
    //

    UnlinkRfcbFromLfcb( Rfcb );

    //
    // Now reacquire the spin lock so that we can release the "open"
    // reference to the Rfcb.  DereferenceRfcbInternal releases the
    // spin lock before returning.
    //

    ACQUIRE_SPIN_LOCK( &connection->SpinLock, &oldIrql );
    DereferenceRfcbInternal( Rfcb, oldIrql );

    INCREMENT_DEBUG_STAT( SrvDbgStatistics.RfcbInfo.Closes );

    return;

} // SrvCompleteRfcbClose


VOID SRVFASTCALL
SrvDereferenceRfcb (
    IN PRFCB Rfcb
    )

/*++

Routine Description:

    This function decrements the reference count on an RFCB.  If the
    reference count goes to zero, the RFCB is deleted.

Arguments:

    Rfcb - Address of RFCB.

Return Value:

    None.

--*/

{
    KIRQL oldIrql;

    UNLOCKABLE_CODE( 8FIL );

    //
    // Acquire the lock that guards the RFCB's reference count and the
    // connection's file table.  Then call the internal routine to
    // decrement the count and possibly delete the RFCB.  That function
    // releases the spin lock before returning.
    //

    //
    // !!! If you change the way this routine and
    //     DereferenceRfcbInternal work, make sure you check
    //     fsd.c\SrvFsdRestartSmbComplete to see if it needs to be
    //     changed too.
    //

    ACQUIRE_SPIN_LOCK( &Rfcb->Connection->SpinLock, &oldIrql );

    DereferenceRfcbInternal( Rfcb, oldIrql );

    return;

} // SrvDereferenceRfcb


VOID
DereferenceRfcbInternal (
    IN PRFCB Rfcb,
    IN KIRQL OldIrql
    )

/*++

Routine Description:

    This internal function decrements the reference count on an RFCB.
    If the reference count goes to zero, the RFCB is deleted.  This
    function is called from other routines in this module.

    *** The spin lock synchronizing access to the RFCB's reference count
        must be held when this function is called.  The lock is released
        before this function returns.

Arguments:

    Rfcb - Address of RFCB.

    OldIrql - The previous IRQL value obtained when the spin lock was
        acquired.

Return Value:

    None.

--*/

{
    PLFCB lfcb;
    PPAGED_RFCB pagedRfcb;
    PCONNECTION connection;
    PWORK_QUEUE queue;

    UNLOCKABLE_CODE( 8FIL );

    ASSERT( GET_BLOCK_TYPE( Rfcb ) == BlockTypeRfcb );
    ASSERT( (LONG)Rfcb->BlockHeader.ReferenceCount > 0 );

    //
    // The lock that guards the RFCB's reference count is held when this
    // function is called.
    //
    // Decrement the reference count.  If it goes to zero, remove the
    // RFCB's entry in the file table, remove the RFCB from its parent
    // LFCB's list, and deallocate the RFCB.
    //

    //
    // !!! If you change the way this routine and SrvDereferenceRfcb
    //     work, make sure you check fsd.c\SrvFsdRestartSmbComplete to
    //     see if it needs to be changed too.
    //

    IF_DEBUG(REFCNT) {
        KdPrint(( "Dereferencing RFCB 0x%p; old refcnt 0x%lx\n",
                    Rfcb, Rfcb->BlockHeader.ReferenceCount ));
    }

    connection = Rfcb->Connection;
    queue = connection->CurrentWorkQueue;
    Rfcb->BlockHeader.ReferenceCount--;
    UPDATE_REFERENCE_HISTORY( Rfcb, TRUE );

    if ( Rfcb->BlockHeader.ReferenceCount != 0 ) {

        //
        // Release the spin lock.
        //

        RELEASE_SPIN_LOCK( &connection->SpinLock, OldIrql );

    } else {

        ASSERT( GET_BLOCK_STATE(Rfcb) == BlockStateClosing );
        ASSERT( Rfcb->ListEntry.Flink == NULL &&  \
                Rfcb->ListEntry.Blink == NULL );
        UpdateRfcbHistory( Rfcb, '0fer' );

        //
        // Remove the file entry from the appropriate connection file
        // table.
        //

        SrvRemoveEntryTable(
            &connection->FileTable,
            FID_INDEX( Rfcb->Fid )
            );

        //
        // Release the spin lock.
        //

        RELEASE_SPIN_LOCK( &connection->SpinLock, OldIrql );

        //
        // Free the IRP if one has been allocated.
        //

        if ( Rfcb->Irp != NULL ) {
            UpdateRfcbHistory( Rfcb, 'prif' );
            IoFreeIrp( Rfcb->Irp );
        }

        //
        // Remove the RFCB from the LFCB's list and dereference the LFCB.
        // Acquire the MFCB lock.  SrvDereferenceLfcb will release it.
        //

        pagedRfcb = Rfcb->PagedRfcb;
        lfcb = Rfcb->Lfcb;

        ACQUIRE_LOCK( &lfcb->Mfcb->NonpagedMfcb->Lock);

        //
        // Remove the RFCB from the global list of RFCBs.
        //

        SrvRemoveEntryOrderedList( &SrvRfcbList, Rfcb );

        SrvRemoveEntryList( &lfcb->RfcbList, &pagedRfcb->LfcbListEntry );
        SrvDereferenceLfcb( lfcb );
        DEBUG Rfcb->Lfcb = 0;

        //
        // Free the RFCB.
        //

        SrvFreeRfcb( Rfcb, queue );

    }

    return;

} // DereferenceRfcbInternal


VOID SRVFASTCALL
SrvFreeRfcb (
    IN PRFCB Rfcb,
    PWORK_QUEUE queue
    )

/*++

Routine Description:

    This function returns an RFCB to the system nonpaged pool.  If changes are
    made here, check out FreeIdleWorkItems in scavengr.c!

Arguments:

    Rfcb - Address of RFCB

Return Value:

    None.

--*/

{
    PAGED_CODE();

    IF_DEBUG(FILE_CACHE) KdPrint(( "SrvFreeRfcb: %p\n", Rfcb ));
    ASSERT( Rfcb->RawWriteCount == 0 );
    ASSERT( IsListEmpty(&Rfcb->RawWriteSerializationList) );
    UpdateRfcbHistory( Rfcb, 'eerf' );

    //
    // Free the the RFCB.
    //

    DEBUG SET_BLOCK_TYPE_STATE_SIZE( Rfcb, BlockTypeGarbage, BlockStateDead, -1 );
    DEBUG Rfcb->BlockHeader.ReferenceCount = (ULONG)-1;
    TERMINATE_REFERENCE_HISTORY( Rfcb );

    Rfcb = (PRFCB)InterlockedExchangePointer( &queue->CachedFreeRfcb,
                                              Rfcb );

    if( Rfcb != NULL ) {
        //
        // This check allows for the possibility that FreeRfcbs might exceed
        // MaxFreeRfcbs, but it's fairly unlikely given the operation of kernel
        // queue objects.  But even so, it probably won't exceed it by much and
        // is really only advisory anyway.
        //
        if( queue->FreeRfcbs < queue->MaxFreeRfcbs ) {

            ExInterlockedPushEntrySList(
                &queue->RfcbFreeList,
                &Rfcb->SingleListEntry,
                &queue->SpinLock
            );

            InterlockedIncrement( &queue->FreeRfcbs );

        } else {

            FREE_HEAP( Rfcb->PagedRfcb );
            DEALLOCATE_NONPAGED_POOL( Rfcb );
            IF_DEBUG(HEAP) KdPrint(( "SrvFreeRfcb: Freed RFCB at 0x%p\n", Rfcb ));

            INCREMENT_DEBUG_STAT( SrvDbgStatistics.RfcbInfo.Frees );

        }
    }

    //
    // Unlock the file-based code section.
    //

    DEREFERENCE_UNLOCKABLE_CODE( 8FIL );

    InterlockedDecrement(
        (PLONG)&SrvStatistics.CurrentNumberOfOpenFiles
        );



    return;

} // SrvFreeRfcb


VOID SRVFASTCALL
SrvReferenceRfcb (
    PRFCB Rfcb
    )

/*++

Routine Description:

    This function increments the reference count on an RFCB.

Arguments:

    Rfcb - Address of RFCB

Return Value:

    None.

--*/

{
    KIRQL oldIrql;

    UNLOCKABLE_CODE( 8FIL );

    //
    // Acquire the spin lock that protects the RFCB's reference count,
    // then call an internal routine to increment the RFCB's reference
    // count.  That routine releases the spin lock.
    //

    ACQUIRE_SPIN_LOCK( &Rfcb->Connection->SpinLock, &oldIrql );

    ReferenceRfcbInternal( Rfcb, oldIrql );

    return;

} // SrvReferenceRfcb


VOID
ReferenceRfcbInternal (
    PRFCB Rfcb,
    KIRQL OldIrql
    )

/*++

Routine Description:

    This function increments the reference count on an RFCB.

    *** The spin lock synchronizing access to the RFCB's reference count
        must be held when this function is called.  The lock is released
        before this function returns.

Arguments:

    Rfcb - Address of RFCB

Return Value:

    None.

--*/

{
    UNLOCKABLE_CODE( 8FIL );

    ASSERT( (LONG)Rfcb->BlockHeader.ReferenceCount > 0 );
    ASSERT( GET_BLOCK_TYPE(Rfcb) == BlockTypeRfcb );
    // ASSERT( GET_BLOCK_STATE(Rfcb) == BlockStateActive );
    UPDATE_REFERENCE_HISTORY( Rfcb, FALSE );

    //
    // Increment the RFCB's reference count.
    //

    Rfcb->BlockHeader.ReferenceCount++;

    IF_DEBUG(REFCNT) {
        KdPrint(( "Referencing RFCB 0x%p; new refcnt 0x%lx\n",
                    Rfcb, Rfcb->BlockHeader.ReferenceCount ));
    }

    //
    // Release the spin lock before returning to the caller.
    //

    RELEASE_SPIN_LOCK( &Rfcb->Connection->SpinLock, OldIrql );

    return;

} // ReferenceRfcbInternal


BOOLEAN
SrvFindCachedRfcb (
    IN PWORK_CONTEXT WorkContext,
    IN PMFCB Mfcb,
    IN ACCESS_MASK DesiredAccess,
    IN ULONG ShareAccess,
    IN ULONG CreateDisposition,
    IN ULONG CreateOptions,
    IN OPLOCK_TYPE RequestedOplockType,
    OUT PNTSTATUS Status
    )

/*++

Routine Description:

    This routine searches a connection's cached-after-close RFCB list
    to attempt to find an existing handle that can be matched up with
    a new open attempt.  If one is found, it is removed from the list
    and reactivated.

Arguments:

    WorkContext - Pointer to work context block.

    Mfcb - Address of MFCB for file being opened.

    DesiredAccess - Desired access for new open.  Used for matching
        purposes.

    ShareAccess - Share access for new open.  Used for matching
        purposes.

    CreateDisposition - Create disposition for new open.  Used for
        matching purposes.

    CreateOptions - Create options for new open.  Used for matching
        purposes.

    RequestedOplockType - Oplock type requested by the client (or the
        server) for the new open.  Used for matching purposes.

    Status - Returns the status of the search.  Only valid if return
        value is TRUE.  Will be STATUS_SUCCESS if a cached open was
        found and taken out of the cache.  In this case, the RFCB
        address is stored in WorkContext->Rfcb.  Status will be
        STATUS_OBJECT_NAME_COLLISION if the file is cached but the
        caller wants the open to file if the file exists.

Return Value:

    BOOLEAN - TRUE if a cached open was found and returned.

--*/

{
    PCONNECTION connection = WorkContext->Connection;
    PLIST_ENTRY listEntry;
    PRFCB rfcb;
    KIRQL oldIrql;
    USHORT uid, tid;
    BOOLEAN wantsWriteThrough, isWriteThrough;
    ACCESS_MASK nongenericDesiredAccess;

    //UNLOCKABLE_CODE( CONN );

    IF_DEBUG(FILE_CACHE) KdPrint(( "SrvFindCachedRfcb: called for %wZ\n", &Mfcb->FileName ));

    //
    // If the client doesn't want an oplock, then the server should have
    // asked for its own batch oplock.
    //

    ASSERT( (RequestedOplockType == OplockTypeBatch) ||
            (RequestedOplockType == OplockTypeExclusive) ||
            (RequestedOplockType == OplockTypeServerBatch) );

    //
    // This routine must not be called for create dispositions that are
    // inconsistent with reusing a cached open.  Specifically, supersede
    // and overwrite are not allowed.
    //

    ASSERT( (CreateDisposition == FILE_OPEN) ||
            (CreateDisposition == FILE_CREATE) ||
            (CreateDisposition == FILE_OPEN_IF) );

    //
    // If the connection has no cached RFCBs, get out quick.
    //

    if ( connection->CachedOpenCount == 0 ) {
        IF_DEBUG(FILE_CACHE) KdPrint(( "SrvFindCachedRfcb: connection has no cached RFCBs\n" ));
        return FALSE;
    }

    //
    // The input DesiredAccess may include generic access modes, but the
    // RFCB has specific access modes, so we have to translate
    // DesiredAccess.
    //

    nongenericDesiredAccess = DesiredAccess;
    IoCheckDesiredAccess( &nongenericDesiredAccess, 0 );

    uid = WorkContext->Session->Uid;
    tid = WorkContext->TreeConnect->Tid;

    //
    // Lock the cached open list and look for a matching RFCB.
    //

    ACQUIRE_SPIN_LOCK( &connection->SpinLock, &oldIrql );

    for ( listEntry = connection->CachedOpenList.Flink;
          listEntry != &connection->CachedOpenList;
          listEntry = listEntry->Flink ) {

        rfcb = CONTAINING_RECORD( listEntry, RFCB, CachedOpenListEntry );

        IF_DEBUG(FILE_CACHE) KdPrint(( "SrvFindCachedRfcb: checking rfcb %p; mfcb = %p\n",
                                        rfcb, rfcb->Mfcb ));
        ASSERT( rfcb->OplockState == OplockStateOwnServerBatch );
        ASSERT( rfcb->CachedOpen );
        ASSERT( GET_BLOCK_STATE(rfcb) == BlockStateClosing );

        //
        // If this RFCB is for the right file, we can proceed with other
        // checks.
        //

        if ( rfcb->Mfcb == Mfcb ) {

            //
            // If the client asked for FILE_CREATE, we can fail the open
            // now, because the file exists.
            //

            if ( CreateDisposition == FILE_CREATE ) {
                IF_DEBUG(FILE_CACHE) KdPrint(( "SrvFindCachedRfcb: client wants to create\n" ));
                RELEASE_SPIN_LOCK( &connection->SpinLock, oldIrql );
                *Status = STATUS_OBJECT_NAME_COLLISION;
                return TRUE;
            }

            //
            // Check the access modes to make sure they're compatible.
            // The new open must:
            //
            //   a) have the same desired access as what was granted before;
            //   b) have the same share access;
            //   c) have the create disposition (in the bits we care about);
            //   d) be requesting a batch oplock;
            //   e) be for the same UID and TID.
            //

#define FILE_MODE_FLAGS (FILE_DIRECTORY_FILE |          \
                         FILE_SEQUENTIAL_ONLY |         \
                         FILE_NON_DIRECTORY_FILE |      \
                         FILE_NO_EA_KNOWLEDGE |         \
                         FILE_RANDOM_ACCESS |           \
                         FILE_OPEN_REPARSE_POINT | \
                         FILE_OPEN_FOR_BACKUP_INTENT)

            if ( (rfcb->GrantedAccess != nongenericDesiredAccess) ||
                 (rfcb->ShareAccess != ShareAccess) ||
                 ((rfcb->FileMode & FILE_MODE_FLAGS) !=
                  (CreateOptions & FILE_MODE_FLAGS)) ||
                 (RequestedOplockType == OplockTypeExclusive) ||
                 (rfcb->Uid != uid) ||
                 (rfcb->Tid != tid) ) {

#if 0
              IF_DEBUG(FILE_CACHE) {
                if ( rfcb->GrantedAccess != nongenericDesiredAccess )
                    KdPrint(( "SrvFindCachedRfcb: granted access %x doesn't match desired access %x\n",
                                rfcb->GrantedAccess, nongenericDesiredAccess ));
                if ( rfcb->ShareAccess != ShareAccess )
                    KdPrint(( "SrvFindCachedRfcb: share access %x doesn't match share access %x\n",
                                rfcb->ShareAccess, ShareAccess ));
                if ( (rfcb->FileMode & FILE_MODE_FLAGS) != (CreateOptions & FILE_MODE_FLAGS))
                    KdPrint(( "SrvFindCachedRfcb: share access %x doesn't match share access %x\n",
                                rfcb->FileMode&FILE_MODE_FLAGS, CreateOptions&FILE_MODE_FLAGS ));
                if ( RequestedOplockType == OplockTypeExclusive )
                    KdPrint(( "SrvFindCachedRfcb: client wants exclusive oplock\n" ));
                if ( rfcb->Uid != uid )
                    KdPrint(( "SrvFindCachedRfcb: UID %x doesn't match UID %x\n", rfcb->Uid, uid ));
                if ( rfcb->Tid != tid )
                    KdPrint(( "SrvFindCachedRfcb: TID %x doesn't match TID %x\n", rfcb->Tid, tid ));
              }
#endif

                //
                // The file is cached, but the new open is inconsistent
                // with the cached open.  We must not use the cached
                // open.  It would be more efficient to close the cached
                // RFCB here, since we know the caller is going to turn
                // around and open the file because we're returning
                // FALSE, thus breaking the batch oplock.  However, our
                // caller owns the MFCB lock, while closing an RFCB
                // requires obtaining the MFCB list lock.  Acquiring
                // these locks in this order leads to deadlock.
                //
                // Note that there is no need to continue the list walk.
                // We have a batch oplock, so we can only have the file
                // open once.
                //

#if 0
                SrvCloseCachedRfcb( rfcb, oldIrql );
#else
                RELEASE_SPIN_LOCK( &connection->SpinLock, oldIrql );
#endif
                return FALSE;
            }

            //
            // The file is cached and the new open is consistent with the
            // cached open.  Remove the open from the cache and give it
            // to the new opener.
            //

            IF_DEBUG(FILE_CACHE) KdPrint(( "SrvFindCachedRfcb: Reusing cached RFCB %p\n", rfcb ));

            UpdateRfcbHistory( rfcb, ' $nu' );

            RemoveEntryList( &rfcb->CachedOpenListEntry );
            connection->CachedOpenCount--;
            ASSERT( (LONG)connection->CachedOpenCount >= 0 );
            rfcb->CachedOpen = FALSE;

            if ( RequestedOplockType == OplockTypeBatch ) {
                rfcb->OplockState = OplockStateOwnBatch;
            }
            SET_BLOCK_STATE( rfcb, BlockStateActive );
            RELEASE_SPIN_LOCK( &connection->SpinLock, oldIrql );

            WorkContext->Rfcb = rfcb;
            SrvReferenceRfcb( rfcb );

            rfcb->IsActive = FALSE;
            rfcb->WrittenTo = FALSE;
            wantsWriteThrough = (BOOLEAN)((CreateOptions & FILE_WRITE_THROUGH) != 0);
            isWriteThrough = (BOOLEAN)((rfcb->Lfcb->FileMode & FILE_WRITE_THROUGH) == 0);
            if ( wantsWriteThrough != isWriteThrough ) {
                SrvSetFileWritethroughMode( rfcb->Lfcb, wantsWriteThrough );
            }

            INCREMENT_DEBUG_STAT( SrvDbgStatistics.OpensSatisfiedWithCachedRfcb );

            WorkContext->Irp->IoStatus.Information = FILE_OPENED;

            *Status = STATUS_SUCCESS;
            return TRUE;

        }

    }

    //
    // We couldn't find the requested file in the cache.
    //

    RELEASE_SPIN_LOCK( &connection->SpinLock, oldIrql );
    return FALSE;

} // SrvFindCachedRfcb

ULONG
SrvCountCachedRfcbsForTid(
    PCONNECTION connection,
    USHORT Tid
)
/*++

Routine Description:

    This returns the number of RFCBS in the cache that are associated with Tid

Arguments:

    connection - Address of the CONNECTION structure of interest

Return Value:

    Count of cached RFCBs

--*/
{
    PLIST_ENTRY listEntry;
    PRFCB rfcb;
    KIRQL oldIrql;
    USHORT count = 0;

    ACQUIRE_SPIN_LOCK( &connection->SpinLock, &oldIrql );

    for ( listEntry = connection->CachedOpenList.Flink;
          listEntry != &connection->CachedOpenList;
          listEntry = listEntry->Flink ) {

        rfcb = CONTAINING_RECORD( listEntry, RFCB, CachedOpenListEntry );

        if( rfcb->Tid == Tid ) {
            ++count;
        }
    }

    RELEASE_SPIN_LOCK( &connection->SpinLock, oldIrql );

    return count;
}

ULONG
SrvCountCachedRfcbsForUid(
    PCONNECTION connection,
    USHORT Uid
)
/*++

Routine Description:

    This returns the number of RFCBS in the cache that are associated with Uid

Arguments:

    connection - Address of the CONNECTION structure of interest

Return Value:

    Count of cached RFCBs

--*/
{
    PLIST_ENTRY listEntry;
    PRFCB rfcb;
    KIRQL oldIrql;
    ULONG count = 0;

    ACQUIRE_SPIN_LOCK( &connection->SpinLock, &oldIrql );

    for ( listEntry = connection->CachedOpenList.Flink;
          listEntry != &connection->CachedOpenList;
          listEntry = listEntry->Flink ) {

        rfcb = CONTAINING_RECORD( listEntry, RFCB, CachedOpenListEntry );

        if( rfcb->Uid == Uid ) {
            ++count;
        }
    }

    RELEASE_SPIN_LOCK( &connection->SpinLock, oldIrql );
    return count;
}


VOID
SrvCloseCachedRfcb (
    IN PRFCB Rfcb,
    IN KIRQL OldIrql
    )

/*++

Routine Description:

    This routine closes a cached open.

    *** This routine must be called with the connection spin lock held.

Arguments:

    Rfcb - Address of RFCB to close.

    OldIrql - IRQL at which the called acquired the connection spin
        lock.  This must be lower than DISPATCH_LEVEL!

Return Value:

    None.

--*/

{
    PCONNECTION connection = Rfcb->Connection;
    KIRQL oldIrql;

    UNLOCKABLE_CODE( 8FIL );

    UpdateRfcbHistory( Rfcb, '$slc' );

    //
    // This routine must be called with the connection spin lock held.
    // The caller must have been at low IRQL before acquiring the spin
    // lock.
    //

    IF_DEBUG(FILE_CACHE) KdPrint(( "SrvCloseCachedRfcb called for rfcb %p", Rfcb ));
    ASSERT( OldIrql < DISPATCH_LEVEL );
    ASSERT( KeGetCurrentIrql() == DISPATCH_LEVEL );

    //
    // Remove the RFCB from the connection's cache.
    //

    ASSERT( Rfcb->CachedOpen );
    Rfcb->CachedOpen = FALSE;
    Rfcb->OplockState = OplockStateNone;

    RemoveEntryList( &Rfcb->CachedOpenListEntry );
    connection->CachedOpenCount--;
    ASSERT( (LONG)connection->CachedOpenCount >= 0 );

    RELEASE_SPIN_LOCK( &connection->SpinLock, OldIrql );
    IF_DEBUG(FILE_CACHE) KdPrint(( "; file %wZ\n", &Rfcb->Mfcb->FileName ));

    //
    // Unlink the RFCB from the LFCB.  If this is the last RFCB for
    // this LFCB, this will force the file closed even if there are
    // still references to the RFCB.  This will unblock blocked I/O.
    //

    UnlinkRfcbFromLfcb( Rfcb );

    //
    // Now acquire the FSD spin lock so that we can release the "open"
    // reference to the Rfcb.  DereferenceRfcbInternal releases the spin
    // lock before returning.
    //

    ACQUIRE_SPIN_LOCK( &connection->SpinLock, &oldIrql );
    DereferenceRfcbInternal( Rfcb, oldIrql );

    INCREMENT_DEBUG_STAT( SrvDbgStatistics.RfcbInfo.Closes );

    return;

} // SrvCloseCachedRfcb


VOID
SrvCloseCachedRfcbsOnConnection (
    IN PCONNECTION Connection
    )

/*++

Routine Description:

    This routine closes all cached opens on a connection.

Arguments:

    Connection - Address of connection for which cached opens are to be closed.

Return Value:

    None.

--*/

{
    PLIST_ENTRY listEntry;
    PRFCB rfcb;
    KIRQL OldIrql;

    IF_DEBUG(FILE_CACHE) {
        KdPrint(( "SrvCloseCachedRfcbsOnConnection called for connection %p\n", Connection ));
    }

    //
    // Remove all RFCBs from the connection's open file cache.
    //

    // This routine needs to be protected from the situation where a Blocking Rename causes us to close all
    // cached opens, but an Oplock break comes during that time and sees that Cached Open is still set to TRUE
    // (Since we didn't hold the SpinLock during the operation)

    ACQUIRE_SPIN_LOCK( &Connection->SpinLock, &OldIrql );

    while ( IsListEmpty( &Connection->CachedOpenList ) == FALSE ) {

        listEntry = RemoveHeadList( &Connection->CachedOpenList );

        rfcb = CONTAINING_RECORD( listEntry, RFCB, CachedOpenListEntry );

        UpdateRfcbHistory( rfcb, 'nc$c' );

        //
        // Remove the RFCB from the connection's cache.
        //

        Connection->CachedOpenCount--;

        ASSERT( rfcb->CachedOpen );
        rfcb->CachedOpen = FALSE;

        ASSERT( rfcb->OplockState == OplockStateOwnServerBatch );
        rfcb->OplockState = OplockStateNone;

        IF_DEBUG(FILE_CACHE) {
            KdPrint(( "SrvCloseCachedRfcbsOnConnection; closing rfcb %p file %wZ\n",
                        rfcb, &rfcb->Mfcb->FileName ));
        }

        RELEASE_SPIN_LOCK( &Connection->SpinLock, OldIrql );

        //
        // Unlink the RFCB from the LFCB.  If this is the last RFCB for
        // this LFCB, this will force the file closed even if there are
        // still references to the RFCB.  This will unblock blocked I/O.
        //

        UnlinkRfcbFromLfcb( rfcb );

        //
        // Release the "open" reference to the Rfcb.
        //

        SrvDereferenceRfcb( rfcb );

        INCREMENT_DEBUG_STAT( SrvDbgStatistics.RfcbInfo.Closes );

        ACQUIRE_SPIN_LOCK( &Connection->SpinLock, &OldIrql );
    }

    RELEASE_SPIN_LOCK( &Connection->SpinLock, OldIrql );

    return;

} // SrvCloseCachedRfcbsOnConnection


VOID
SrvCloseCachedRfcbsOnLfcb (
    IN PLFCB Lfcb
    )

/*++

Routine Description:

    This routine closes all cached opens associated with a specific LFCB.

Arguments:

    Lfcb - Address of LFCB for which cached opens are to be closed.

Return Value:

    None.

--*/

{
    PCONNECTION connection;
    PLIST_ENTRY listEntry;
    PLIST_ENTRY nextListEntry;
    PRFCB rfcb;
    KIRQL oldIrql;
    LIST_ENTRY rfcbsToClose;

    ASSERT( KeGetCurrentIrql() < DISPATCH_LEVEL );

    connection = Lfcb->Connection;
    IF_DEBUG(FILE_CACHE) {
        KdPrint(( "SrvCloseCachedRfcbsOnLfcb called for lfcb %p connection %p", Lfcb, connection ));
    }

    InitializeListHead( &rfcbsToClose );

    //
    // Lock and walk the connection's cached open list.  We don't
    // actually closed the RFCBs on the first pass, since that would
    // require releasing the lock.  Instead, we remove them from the
    // connection list and add them to a local list.
    //

    ACQUIRE_SPIN_LOCK( &connection->SpinLock, &oldIrql );

    for ( listEntry = connection->CachedOpenList.Flink;
          listEntry != &connection->CachedOpenList;
          listEntry = nextListEntry ) {

        rfcb = CONTAINING_RECORD( listEntry, RFCB, CachedOpenListEntry );
        nextListEntry = listEntry->Flink;

        if ( rfcb->Lfcb == Lfcb ) {

            //
            // Remove the RFCB from the connection's cache.
            //

            UpdateRfcbHistory( rfcb, 'fl$c' );

            RemoveEntryList( listEntry );
            connection->CachedOpenCount--;

            InsertTailList( &rfcbsToClose, listEntry );

            ASSERT( rfcb->CachedOpen );
            rfcb->CachedOpen = FALSE;

            ASSERT( rfcb->OplockState == OplockStateOwnServerBatch );
            rfcb->OplockState = OplockStateNone;

        }

    }

    RELEASE_SPIN_LOCK( &connection->SpinLock, oldIrql );

    //
    // Walk the local list and close each RFCB.
    //

    for ( listEntry = rfcbsToClose.Flink;
          listEntry != &rfcbsToClose;
          listEntry = nextListEntry ) {

        rfcb = CONTAINING_RECORD( listEntry, RFCB, CachedOpenListEntry );
        nextListEntry = listEntry->Flink;

        IF_DEBUG(FILE_CACHE) {
            KdPrint(( "SrvCloseCachedRfcbsOnConnection; closing rfcb %p file %wZ\n",
                        rfcb, &rfcb->Mfcb->FileName ));
        }

        //
        // Unlink the RFCB from the LFCB.  If this is the last RFCB for
        // this LFCB, this will force the file closed even if there are
        // still references to the RFCB.  This will unblock blocked I/O.
        //

        UnlinkRfcbFromLfcb( rfcb );

        //
        // Release the "open" reference to the Rfcb.
        //

        SrvDereferenceRfcb( rfcb );

        INCREMENT_DEBUG_STAT( SrvDbgStatistics.RfcbInfo.Closes );

    }

    return;

} // SrvCloseCachedRfcbsOnLfcb


#ifdef SRVDBG_RFCBHIST
VOID
UpdateRfcbHistory (
    IN PRFCB Rfcb,
    IN ULONG Event
    )
{
    KIRQL oldIrql;
    ACQUIRE_SPIN_LOCK( &Rfcb->SpinLock, &oldIrql );
    Rfcb->History[Rfcb->HistoryIndex++] = Event;
    RELEASE_SPIN_LOCK( &Rfcb->SpinLock, oldIrql );
    return;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\srv\blktimer.c ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    blkwork.c

Abstract:

    This module implements routines for managing work context blocks.

Author:

    Chuck Lenzmeier (chuckl) 9-Feb-1994

Revision History:

--*/

#include "precomp.h"
#include "blktimer.tmh"
#pragma hdrstop

#define BugCheckFileId SRV_FILE_BLKTIMER

#ifdef ALLOC_PRAGMA
#pragma alloc_text( PAGE, SrvAllocateTimer )
#pragma alloc_text( PAGE, SrvCancelTimer )
#pragma alloc_text( PAGE, SrvSetTimer )
#endif


PSRV_TIMER
SrvAllocateTimer (
    VOID
    )

/*++

Routine Description:

    This routine allocates a timer structure.

Arguments:

    None.

Return Value:

    PSRV_TIMER -- pointer to the allocated timer structure, or NULL.

--*/

{
    PSINGLE_LIST_ENTRY entry;
    PSRV_TIMER timer;

    PAGED_CODE( );

    entry = ExInterlockedPopEntrySList( &SrvTimerList, &GLOBAL_SPIN_LOCK(Timer) );
    if ( entry == NULL ) {
        timer = ALLOCATE_NONPAGED_POOL( sizeof(SRV_TIMER), BlockTypeTimer );
        if ( timer != NULL ) {
            KeInitializeEvent( &timer->Event, NotificationEvent, FALSE );
            KeInitializeTimer( &timer->Timer );
        }
    } else {
        timer = CONTAINING_RECORD( entry, SRV_TIMER, Next );
    }

    return timer;

} // SrvAllocateTimer


VOID
SrvCancelTimer (
    PSRV_TIMER Timer
    )

/*++

Routine Description:

    This routine cancels a timer.

Arguments:

    Timer -- pointer to the timer

Return Value:

    None.

--*/

{
    PAGED_CODE( );

    //
    // Cancel the timer.
    //

    if ( !KeCancelTimer( &Timer->Timer ) ) {

        //
        // We were unable to cancel the timer.  This means that the
        // timer routine has either already run or is scheduled to run.
        // We need to wait for the timer routine to complete before we
        // continue.
        //
        // We expect that if we couldn't cancel the timer (which
        // shouldn't happen often), then the timer routine has probably
        // already completed, so we call KeReadStateEvent first to avoid
        // the overhead of KeWaitForSingleObject.
        //

        if ( !KeReadStateEvent( &Timer->Event ) ) {
            KeWaitForSingleObject(
                &Timer->Event,
                UserRequest,
                KernelMode,     // don't let kernel stack be paged
                FALSE,          // not alertable
                NULL            // no timeout
                );
        }

    }

    return;

} // SrvCancelTimer


VOID
SrvSetTimer (
    IN PSRV_TIMER Timer,
    IN PLARGE_INTEGER Timeout,
    IN PKDEFERRED_ROUTINE TimeoutHandler,
    IN PVOID Context
    )

/*++

Routine Description:

    This routine starts a timer.

Arguments:

    Timer -- pointer to the timer

    Timeout -- number of milliseconds to wait

    TimeoutHandler -- routine to call if the timer expires

    Context -- context value for the timer routine

Return Value:

    None.

--*/

{
    PRKDPC Dpc = &Timer->Dpc;

    PAGED_CODE( );

    //
    // Initialize the DPC associated with the timer.  Reset the event
    // that indicates that the timer routine has run.  Set the timer.
    //

    KeInitializeDpc( Dpc, TimeoutHandler, Context );

    KeSetTargetProcessorDpc( Dpc, (CCHAR)KeGetCurrentProcessorNumber() );

    KeClearEvent( &Timer->Event );

    KeSetTimer( &Timer->Timer, *Timeout, Dpc );

    return;

} // SrvSetTimer
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\srv\blkshare.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    blkshare.c

Abstract:

    This module implements routines for managing share blocks.

Author:

    Chuck Lenzmeier (chuckl) 4-Oct-1989
    David Treadwell (davidtr)

Revision History:

--*/

#include "precomp.h"
#include "blkshare.tmh"
#pragma hdrstop

#define BugCheckFileId SRV_FILE_BLKSHARE

VOID
GetShareQueryNamePrefix (
    PSHARE Share
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text( PAGE, SrvAllocateShare )
#pragma alloc_text( PAGE, SrvCloseShare )
#pragma alloc_text( PAGE, SrvDereferenceShare )
#pragma alloc_text( PAGE, SrvDereferenceShareForTreeConnect )
#pragma alloc_text( PAGE, SrvFreeShare )
#pragma alloc_text( PAGE, SrvReferenceShare )
#pragma alloc_text( PAGE, SrvReferenceShareForTreeConnect )
#pragma alloc_text( PAGE, SrvFillInFileSystemName )
#pragma alloc_text( PAGE, SrvGetShareRootHandle )
#pragma alloc_text( PAGE, SrvRefreshShareRootHandle )
#pragma alloc_text( PAGE, GetShareQueryNamePrefix )
#endif


VOID
SrvAllocateShare (
    OUT PSHARE *Share,
    IN PUNICODE_STRING ShareName,
    IN PUNICODE_STRING NtPathName,
    IN PUNICODE_STRING DosPathName,
    IN PUNICODE_STRING Remark,
    IN PSECURITY_DESCRIPTOR SecurityDescriptor,
    IN PSECURITY_DESCRIPTOR FileSecurityDescriptor OPTIONAL,
    IN SHARE_TYPE ShareType
    )

/*++

Routine Description:

    This function allocates a Share Block from the FSP heap.

Arguments:

    Share - Returns a pointer to the share block, or NULL if no
        heap space was available.

    ShareName - Supplies the name of the share.

    NtPathName - Supplies a fully qualified directory path in NT format
        to the share.

    DosPathName - Supplies a fully qualified directory path in DOS
        format to the share.

    Remark - a comment to store with the share.

    SecurityDescriptor - security descriptor used for determining whether
        a user can connect to this share.

    FileSecurityDescriptor - security descriptor used for determining the
        permissions of clients on files in this share.

    ShareType - Enumerated type indicating type of resource.

Return Value:

    None.

--*/

{
    CLONG blockSize;
    PSHARE share;
    ULONG securityDescriptorLength;
    ULONG fileSdLength;

    PAGED_CODE( );

    //
    // Attempt to allocate from the heap.  Note that space for the
    // remark (if any) is allocated separately.  Allocate extra space
    // for the security descriptor since it must be longword aligned,
    // and there may be padding between the DOS path name and the
    // security descriptor.
    //

    securityDescriptorLength = RtlLengthSecurityDescriptor( SecurityDescriptor );

    blockSize = sizeof(SHARE) +
                    ShareName->Length + sizeof(WCHAR) +
                    NtPathName->Length + sizeof(WCHAR) +
                    DosPathName->Length + sizeof(WCHAR) +
                    securityDescriptorLength + sizeof(ULONG);

    share = ALLOCATE_HEAP( blockSize, BlockTypeShare );
    *Share = share;

    if ( share == NULL ) {
        INTERNAL_ERROR(
            ERROR_LEVEL_EXPECTED,
            "SrvAllocateShare: Unable to allocate %d bytes from heap.",
             blockSize,
             NULL
             );
        return;
    }

    IF_DEBUG(HEAP) {
        SrvPrint1( "SrvAllocateShare: Allocated share at %p\n", share );
    }

    RtlZeroMemory( share, blockSize );

    SET_BLOCK_TYPE_STATE_SIZE( share, BlockTypeShare, BlockStateActive, blockSize );
    share->BlockHeader.ReferenceCount = 2;      // allow for Active status
                                                //  and caller's pointer

    //
    // Save the share type.
    //

    share->ShareType = ShareType;

    //
    // Indicate that we've haven't determined the share's query name prefix yet.
    //

    share->QueryNamePrefixLength = -1;

    //
    // Put the share name after the share block.
    //

    share->ShareName.Buffer = (PWSTR)(share + 1);
    share->ShareName.Length = ShareName->Length;
    share->ShareName.MaximumLength =
                            (SHORT)(ShareName->Length + sizeof(WCHAR));

    RtlCopyMemory(
        share->ShareName.Buffer,
        ShareName->Buffer,
        ShareName->Length
        );

    //
    // Put the NT path name after share name.  If no NT path name was
    // specified, just set the path name string to NULL.
    //

   share->NtPathName.Buffer = (PWSTR)((PCHAR)share->ShareName.Buffer +
                                        share->ShareName.MaximumLength);

    share->NtPathName.Length = NtPathName->Length;
    share->NtPathName.MaximumLength = (SHORT)(NtPathName->Length +
                                                        sizeof(WCHAR));

    RtlCopyMemory(
        share->NtPathName.Buffer,
        NtPathName->Buffer,
        NtPathName->Length
        );


    //
    // Put the DOS path name after share name.  If no DOS path name was
    // specified, just set the path name string to NULL.
    //

    share->DosPathName.Buffer = (PWSTR)((PCHAR)share->NtPathName.Buffer +
                                        share->NtPathName.MaximumLength);
    share->DosPathName.Length = DosPathName->Length;
    share->DosPathName.MaximumLength = (SHORT)(DosPathName->Length +
                                                        sizeof(WCHAR));

    RtlCopyMemory(
        share->DosPathName.Buffer,
        DosPathName->Buffer,
        DosPathName->Length
        );

    //
    // Initialize the security RESOURCE for the share
    //
    share->SecurityDescriptorLock = ALLOCATE_NONPAGED_POOL( sizeof(ERESOURCE), BlockTypeShare );
    if( !share->SecurityDescriptorLock )
    {
        INTERNAL_ERROR(
            ERROR_LEVEL_EXPECTED,
            "SrvAllocateShare: Unable to allocate %d bytes from NP pool.",
             sizeof(ERESOURCE),
             NULL
             );
        SrvFreeShare( share );
        *Share = NULL;
        return;
    }
    INITIALIZE_LOCK( share->SecurityDescriptorLock, 1,  "Share Security Descriptor Lock" );

    share->SnapShotLock = ALLOCATE_NONPAGED_POOL( sizeof(SRV_LOCK), BlockTypeShare );
    if( !share->SnapShotLock )
    {
        INTERNAL_ERROR(
            ERROR_LEVEL_EXPECTED,
            "SrvAllocateShare: Unable to allocate %d bytes from NP pool.",
             sizeof(ERESOURCE),
             NULL
             );
        SrvFreeShare( share );
        *Share = NULL;
        return;
    }
    INITIALIZE_LOCK( share->SnapShotLock, 1,  "Share SnapShot Lock" );



    //
    // Allocate space for the remark and copy over the remark.  We
    // cannot put the remark after the share block because the remark is
    // settable by NetShareSetInfo.  It is possible for the storage
    // required for the remark to increase.
    //
    // If no remark was passed in, do not allocate space.  Just set up
    // a null string to describe it.
    //

    if ( ARGUMENT_PRESENT( Remark ) ) {

        share->Remark.Buffer = ALLOCATE_HEAP(
                                    Remark->Length + sizeof(*Remark->Buffer),
                                    BlockTypeShareRemark
                                    );

        if ( share->Remark.Buffer == NULL ) {
            INTERNAL_ERROR(
                ERROR_LEVEL_EXPECTED,
                "SrvAllocateShare: Unable to allocate %d bytes from heap.",
                 blockSize,
                 NULL
                 );
            SrvFreeShare( share );
            *Share = NULL;
            return;
        }

        share->Remark.Length = Remark->Length;
        share->Remark.MaximumLength =
                        (SHORT)(Remark->Length + sizeof(*Remark->Buffer));

        RtlCopyMemory(
            share->Remark.Buffer,
            Remark->Buffer,
            Remark->Length
            );

        *(PWCH)((PCHAR)share->Remark.Buffer + share->Remark.Length) = 0;

    } else {

        RtlInitUnicodeString( &share->Remark, NULL );

    }

    //
    // Set up the security descriptor for the share.  It must be longword-
    // aligned to be used in various calls.
    //

    share->SecurityDescriptor =
        (PSECURITY_DESCRIPTOR)( ((ULONG_PTR)share->DosPathName.Buffer +
                                share->DosPathName.MaximumLength + 3) & ~3);

    RtlCopyMemory(
        share->SecurityDescriptor,
        SecurityDescriptor,
        securityDescriptorLength
        );

    //
    // Set up the file security descriptor for the share.  We did not allocate
    // space for the file SD because this is settable and thus cannot have
    // preallocated space.
    //

    ASSERT( share->FileSecurityDescriptor == NULL );

    if ( ARGUMENT_PRESENT( FileSecurityDescriptor) ) {

        fileSdLength = RtlLengthSecurityDescriptor( FileSecurityDescriptor );

        share->FileSecurityDescriptor = ALLOCATE_HEAP(
                                                fileSdLength,
                                                BlockTypeShareSecurityDescriptor
                                                );

        if ( share->FileSecurityDescriptor == NULL ) {
            INTERNAL_ERROR(
                ERROR_LEVEL_EXPECTED,
                "SrvAllocateShare: Unable to allocate %d bytes from heap.",
                 fileSdLength,
                 NULL
                 );

            SrvFreeShare( share );
            *Share = NULL;
            return;
        }

        RtlCopyMemory(
            share->FileSecurityDescriptor,
            FileSecurityDescriptor,
            fileSdLength
            );
    }

    //
    // Indicate whether or not this share potentially contains the system directory.
    //
    if( DosPathName->Length != 0 && SrvSystemRoot.Length != 0 ) {

        UNICODE_STRING tmpString;

        if( DosPathName->Length == SrvSystemRoot.Length ) {
            //
            // If the two names are the same, then the share is exactly at the system
            //   directory.  All files within this share are system files!
            //
            if( RtlCompareUnicodeString( DosPathName, &SrvSystemRoot, TRUE ) == 0 ) {
                share->PotentialSystemFile = TRUE;
            }

        } else if( DosPathName->Length < SrvSystemRoot.Length ) {
            //
            // If the share path is a substring of the system root path...
            //
            if( DosPathName->Buffer[ DosPathName->Length/sizeof(WCHAR) - 1 ] ==
                  OBJ_NAME_PATH_SEPARATOR ||
                SrvSystemRoot.Buffer[ DosPathName->Length/sizeof(WCHAR) ] ==
                  OBJ_NAME_PATH_SEPARATOR ) {

                //
                // .. and if the share path is for the root of the drive...
                //
                tmpString = SrvSystemRoot;
                tmpString.Length = DosPathName->Length;
                //
                // ... and if the system root is on the same drive...
                //
                if( RtlCompareUnicodeString( DosPathName, &tmpString, TRUE ) == 0 ) {
                    //
                    // ... then we potentially are accessing system files
                    //
                    share->PotentialSystemFile = TRUE;
                }

            }

        } else {
            //
            // If the system root path is a substring of the share path, then every file
            //  within the share is a system file.
            //
            if( DosPathName->Buffer[ SrvSystemRoot.Length / sizeof( WCHAR ) ] ==
                OBJ_NAME_PATH_SEPARATOR ) {

                tmpString = *DosPathName;
                tmpString.Length = SrvSystemRoot.Length;

                if( RtlCompareUnicodeString( DosPathName, &tmpString, TRUE ) == 0 ) {
                    //
                    // Every file in the share is a system file
                    //
                    share->PotentialSystemFile = TRUE;
                }
            }
        }
    }

    //
    // Initialize the share's tree connect list.
    //

    InitializeListHead( &share->TreeConnectList );

    //
    // Initialize the SnapShot list
    //
    InitializeListHead( &share->SnapShots );


    INITIALIZE_REFERENCE_HISTORY( share );

    INCREMENT_DEBUG_STAT( SrvDbgStatistics.ShareInfo.Allocations );

#ifdef SRVCATCH
    SrvIsMonitoredShare( share );
#endif

    return;

} // SrvAllocateShare


VOID
SrvCloseShare (
    IN PSHARE Share
    )

/*++

Routine Description:

    This function closes a share.

Arguments:

    Share - Supplies a pointer to a share Block

Return Value:

    None.

--*/

{
    PAGED_CODE( );

    ACQUIRE_LOCK( &SrvShareLock );

    //
    // If the share hasn't already been closed, do so now.
    //

    if ( GET_BLOCK_STATE(Share) == BlockStateActive ) {

        IF_DEBUG(BLOCK1) SrvPrint1( "Closing share at %p\n", Share );

        SET_BLOCK_STATE( Share, BlockStateClosing );

        RELEASE_LOCK( &SrvShareLock );

        //
        // Close all the tree connects on this share.
        //

        SrvCloseTreeConnectsOnShare( Share );

        //
        // Dereference the share--this will cause it to be freed when
        // all other references are closed.
        //

        SrvDereferenceShare( Share );

        INCREMENT_DEBUG_STAT( SrvDbgStatistics.ShareInfo.Closes );

    } else {

        RELEASE_LOCK( &SrvShareLock );

    }

    return;

} // SrvCloseShare


VOID
SrvDereferenceShare (
    IN PSHARE Share
    )

/*++

Routine Description:

    This function decrements the reference count on a share.  If the
    reference count goes to zero, the share block is deleted.

Arguments:

    Share - Address of share

Return Value:

    None.

--*/

{
    PAGED_CODE( );

    //
    // Enter a critical section and decrement the reference count on the
    // block.
    //

    ACQUIRE_LOCK( &SrvShareLock );

    IF_DEBUG(REFCNT) {
        SrvPrint2( "Dereferencing share %p; old refcnt %lx\n",
                    Share, Share->BlockHeader.ReferenceCount );
    }

    ASSERT( GET_BLOCK_TYPE(Share) == BlockTypeShare );
    ASSERT( (LONG)Share->BlockHeader.ReferenceCount > 0 );
    UPDATE_REFERENCE_HISTORY( Share, TRUE );

    if ( --Share->BlockHeader.ReferenceCount == 0 ) {

        //
        // The new reference count is 0, meaning that it's time to
        // delete this block.
        //

        ASSERT( Share->CurrentUses == 0 );
        ASSERT( GET_BLOCK_STATE( Share ) != BlockStateActive );

        RELEASE_LOCK( &SrvShareLock );

        //
        // Remove the block from the global list.
        //

        SrvRemoveShare( Share );

        //
        // Free the share block.
        //

        SrvFreeShare( Share );

    } else {

        RELEASE_LOCK( &SrvShareLock );

    }

    return;

} // SrvDereferenceShare


VOID
SrvDereferenceShareForTreeConnect (
    PSHARE Share
    )

/*++

Routine Description:

    This function decrements the reference count on a share block for
    the referenced pointer in a tree connect block.  If this is the last
    reference by a tree connect to the share, the share root directory
    is closed.

Arguments:

    Share - Address of share

Return Value:

    None.

--*/

{
    PAGED_CODE( );

    ACQUIRE_LOCK( &SrvShareLock );

    //
    // Update the count of tree connects on the share.
    //

    ASSERT( Share->CurrentUses > 0 );

    Share->CurrentUses--;

    //
    // If this is the last reference by a tree connect to the share and
    // this is a disk share, close the share root directory handle.
    //

    if ( Share->CurrentUses == 0 && Share->ShareType == ShareTypeDisk ) {
        if ( !Share->Removable ) {
            SRVDBG_RELEASE_HANDLE( Share->RootDirectoryHandle, "RTD", 5, Share );
            SrvNtClose( Share->RootDirectoryHandle, FALSE );
        }
        Share->RootDirectoryHandle = NULL;
    }

    //
    // Dereference the share and return.
    //

    SrvDereferenceShare( Share );

    RELEASE_LOCK( &SrvShareLock );

    return;

} // SrvDereferenceShareForTreeConnect

VOID
SrvFreeShare (
    IN PSHARE Share
    )

/*++

Routine Description:

    This function returns a Share Block to the FSP heap.

Arguments:

    Share - Address of share

Return Value:

    None.

--*/

{
    PLIST_ENTRY shareList;

    PAGED_CODE( );

    DEBUG SET_BLOCK_TYPE_STATE_SIZE( Share, BlockTypeGarbage, BlockStateDead, -1 );
    DEBUG Share->BlockHeader.ReferenceCount = (ULONG)-1;
    TERMINATE_REFERENCE_HISTORY( Share );

    // Delete all the SnapShot shares
    shareList = Share->SnapShots.Flink;
    while( shareList != &Share->SnapShots )
    {
        PSHARE_SNAPSHOT snapShare = CONTAINING_RECORD( shareList, SHARE_SNAPSHOT, SnapShotList );
        shareList = shareList->Flink;
        SrvSnapRemoveShare( snapShare );
    }

    //
    // Remove storage for the remark, if any.
    //

    if ( Share->Remark.Buffer != NULL ) {
        FREE_HEAP( Share->Remark.Buffer );
    }

    //
    // Remove storage for the file security descriptor, if any.
    //

    if ( Share->FileSecurityDescriptor != NULL ) {
        FREE_HEAP( Share->FileSecurityDescriptor );
    }

    //
    // Cleanup the file security descriptor lock
    //
    if( Share->SecurityDescriptorLock )
    {
        DELETE_LOCK( Share->SecurityDescriptorLock );
        DEALLOCATE_NONPAGED_POOL( Share->SecurityDescriptorLock );
    }

    //
    // Cleanup the SnapShot lock
    //
    if( Share->SnapShotLock )
    {
        DELETE_LOCK( Share->SnapShotLock );
        DEALLOCATE_NONPAGED_POOL( Share->SnapShotLock );
    }

    //
    // Remove storage for the filesystem name
    //

    if ( Share->Type.FileSystem.Name.Buffer != NULL ) {
        FREE_HEAP( Share->Type.FileSystem.Name.Buffer );
    }

    FREE_HEAP( Share );
    IF_DEBUG(HEAP) {
        SrvPrint1( "SrvFreeShare: Freed share block at %p\n", Share );
    }

    INCREMENT_DEBUG_STAT( SrvDbgStatistics.ShareInfo.Frees );

    return;

} // SrvFreeShare


VOID
SrvReferenceShare (
    PSHARE Share
    )

/*++

Routine Description:

    This function increments the reference count on a share block.

Arguments:

    Share - Address of share

Return Value:

    None.

--*/

{
    PAGED_CODE( );

    //
    // Enter a critical section and increment the reference count on the
    // share.
    //

    ACQUIRE_LOCK( &SrvShareLock );

    ASSERT( (LONG)Share->BlockHeader.ReferenceCount > 0 );
    ASSERT( GET_BLOCK_TYPE(Share) == BlockTypeShare );
    // ASSERT( GET_BLOCK_STATE(Share) == BlockStateActive );
    UPDATE_REFERENCE_HISTORY( Share, FALSE );

    Share->BlockHeader.ReferenceCount++;

    IF_DEBUG(REFCNT) {
        SrvPrint2( "Referencing share %p; new refcnt %lx\n",
                    Share, Share->BlockHeader.ReferenceCount );
    }

    RELEASE_LOCK( &SrvShareLock );

    return;

} // SrvReferenceShare


NTSTATUS
SrvReferenceShareForTreeConnect (
    PSHARE Share
    )

/*++

Routine Description:

    This function increments the reference count on a share block for
    the referenced pointer in a tree connect block.  If this is the
    first tree connect to reference the share, the share root directory
    is opened.

Arguments:

    Share - Address of share

Return Value:

    None.

--*/

{
    NTSTATUS status;
    OBJECT_ATTRIBUTES objectAttributes;
    IO_STATUS_BLOCK iosb;
    PFILE_FS_ATTRIBUTE_INFORMATION attributeInfo;
    CHAR buffer[ FIELD_OFFSET(FILE_FS_ATTRIBUTE_INFORMATION, FileSystemName ) + 32 ];
    PVOID allocatedBuffer = NULL;
    PFILE_OBJECT fileObject;
    PDEVICE_OBJECT deviceObject;

    PAGED_CODE( );

    ACQUIRE_LOCK( &SrvShareLock );

    //
    // Update the count of tree connects on the share.
    //

    Share->CurrentUses++;

    //
    // Check if this is the first tree connect to the share.
    //

    if ( Share->CurrentUses > 1 ) {

        //
        // There are already open tree connects on the share.  Just
        // reference the share and return.
        //

        SrvReferenceShare( Share );

        goto done;
    }

    //
    // If this is not a disk share, then we do not need to open the
    // share root directory, so reference the share and return.
    //

    if ( Share->ShareType != ShareTypeDisk || Share->Removable ) {
        SrvReferenceShare( Share );
        goto done;
    }

#ifdef INCLUDE_SMB_IFMODIFIED
    //
    //  by default, we'll assume USN capable until we get back an "unsupported"
    //  from the filesystem.
    //

    Share->UsnCapable = TRUE;
#endif

    //
    // This is the first tree connect, so we need to open the share root
    // directory.  Future opens of files within the share will be relative
    // to the root of the share.
    //
    Share->RootDirectoryHandle = NULL;

    if( SrvRefreshShareRootHandle( Share, &status ) == FALSE ) {
        Share->CurrentUses--;
        RELEASE_LOCK( &SrvShareLock );
        return status;
    }

    //
    // All is well -- we are now going to return STATUS_SUCCESS no matter what!
    //

    SrvReferenceShare( Share );

    if ( Share->QueryNamePrefixLength == -1 ) {

        //
        // Query the name associated with the share root directory.
        // The prefix is removed whenever the name of a file in the
        // share is queried.  (The logical root must be preserved
        // for remote clients.)
        //

        GetShareQueryNamePrefix( Share );
    }

    //
    // Now extract the name of the file system, so that it can be returned
    // in the TreeConnectAndX response.
    //
    //
    if ( Share->Type.FileSystem.Name.Buffer == NULL ) {

        attributeInfo = (PFILE_FS_ATTRIBUTE_INFORMATION)buffer;

        status = NtQueryVolumeInformationFile(
                     Share->RootDirectoryHandle,
                     &iosb,
                     attributeInfo,
                     sizeof( buffer ),
                     FileFsAttributeInformation
                     );

        if ( status == STATUS_BUFFER_OVERFLOW ) {

            //
            // The file system information was too large to fit in our small
            // stack buffer.  Allocate an ample buffer and try again.
            //

            allocatedBuffer = ALLOCATE_HEAP(
                                 FIELD_OFFSET(FILE_FS_ATTRIBUTE_INFORMATION,FileSystemName) +
                                     attributeInfo->FileSystemNameLength,
                                 BlockTypeVolumeInformation
                                 );

            if ( allocatedBuffer == NULL ) {

                //
                // Couldn't allocate the buffer.  Give up.
                //

                goto done;
            }

            status = NtQueryVolumeInformationFile(
                         Share->RootDirectoryHandle,
                         &iosb,
                         allocatedBuffer,
                         FIELD_OFFSET(FILE_FS_ATTRIBUTE_INFORMATION, FileSystemName) +
                                     attributeInfo->FileSystemNameLength,
                         FileFsAttributeInformation
                         );

            if ( !NT_SUCCESS( status ) ) {
                goto done;
            }

            attributeInfo = (PFILE_FS_ATTRIBUTE_INFORMATION)allocatedBuffer;

        } else if ( !NT_SUCCESS( status ) ) {

            //
            // Some other, unexpected error occured.  Give up.
            //

            goto done;
        }

        //
        // Fill in the file system name
        //

        SrvFillInFileSystemName(
                            Share,
                            attributeInfo->FileSystemName,
                            attributeInfo->FileSystemNameLength
                            );
    }

done:

    if ( allocatedBuffer != NULL ) {
        FREE_HEAP( allocatedBuffer );
    }

    RELEASE_LOCK( &SrvShareLock );
    return STATUS_SUCCESS;

} // SrvReferenceShareForTreeConnect

BOOLEAN
SrvCheckNtfsForUniqueFiles()
{
    ULONG lengthNeeded;
    NTSTATUS status;
    HANDLE keyHandle;
    UNICODE_STRING unicodeParamPath;
    UNICODE_STRING unicodeKeyName;
    OBJECT_ATTRIBUTES objAttributes;
    PKEY_VALUE_FULL_INFORMATION infoBuffer = NULL;

    RtlInitUnicodeString( &unicodeParamPath, L"\\Registry\\Machine\\System\\CurrentControlSet\\Control\\FileSystem" );
    RtlInitUnicodeString( &unicodeKeyName, L"NtfsDisable8dot3NameCreation" );

    InitializeObjectAttributes(
                        &objAttributes,
                        &unicodeParamPath,
                        OBJ_CASE_INSENSITIVE,
                        NULL,
                        NULL
                        );

    status = ZwOpenKey(
                    &keyHandle,
                    KEY_QUERY_VALUE,
                    &objAttributes
                    );

    if ( !NT_SUCCESS(status) ) {
        return FALSE;
    }

    status = ZwQueryValueKey(
                        keyHandle,
                        &unicodeKeyName,
                        KeyValueFullInformation,
                        NULL,
                        0,
                        &lengthNeeded
                        );

    if ( status != STATUS_BUFFER_TOO_SMALL ) {
        NtClose( keyHandle );
        return FALSE;
    }

    infoBuffer = ALLOCATE_NONPAGED_POOL( lengthNeeded, BlockTypeDataBuffer );

    if ( infoBuffer == NULL ) {
        NtClose( keyHandle );
        return FALSE;
    }

    status = ZwQueryValueKey(
                        keyHandle,
                        &unicodeKeyName,
                        KeyValueFullInformation,
                        infoBuffer,
                        lengthNeeded,
                        &lengthNeeded
                        );

    NtClose( keyHandle );

    if( NT_SUCCESS(status) )
    {
        if( infoBuffer->DataLength == sizeof(DWORD) )
        {
            if( *((LPDWORD)(((PBYTE)infoBuffer)+infoBuffer->DataOffset)) )
            {
                DEALLOCATE_NONPAGED_POOL( infoBuffer );
                return TRUE;
            }
        }
    }

    DEALLOCATE_NONPAGED_POOL( infoBuffer );
    return FALSE;
}


VOID
SrvFillInFileSystemName (
            IN PSHARE Share,
            IN PWSTR FileSystemName,
            IN ULONG FileSystemNameLength
            )

/*++

Routine Description:

    This function fills in the stores the given file system name into the
    share block.

Arguments:

    Share - Address of share

    FileSystemName - A string containing the name of the file system

    FileSystemNameLength - Length of the above string

Return Value:

    None.

--*/

{
    PAGED_CODE( );

    //
    // If we have a FATxx filesystem, we need to return FAT back to the clients,
    //  else they will not believe they can create long names.  I know, I know....
    //
    if( (FileSystemNameLength > 3 * sizeof( WCHAR ) ) &&
        (FileSystemName[0] == L'F' || FileSystemName[0] == L'f') &&
        (FileSystemName[1] == L'A' || FileSystemName[0] == L'a') &&
        (FileSystemName[2] == L'T' || FileSystemName[0] == L't') ) {

        FileSystemNameLength = 3 * sizeof( WCHAR );
        FileSystemName[3] = UNICODE_NULL;
    }

#ifdef INCLUDE_SMB_PERSISTENT
    if( (FileSystemNameLength >= 3 * sizeof( WCHAR ) ) &&
        (FileSystemName[0] == L'F' || FileSystemName[0] == L'f') &&
        (FileSystemName[1] == L'A' || FileSystemName[0] == L'a') &&
        (FileSystemName[2] == L'T' || FileSystemName[0] == L't') ) {

        //
        //  persistent handles are not allowed for fat volumes
        //

        Share->AllowPersistentHandles = FALSE;
    }
#endif

    if( (FileSystemNameLength == 4*sizeof(WCHAR)) &&
        !STRNICMP(FileSystemName,L"NTFS",4) )
    {
        if( SrvCheckNtfsForUniqueFiles() )
        {
            Share->UniqueNames = TRUE;
        }
    }


    //
    // Allocate enough storage for the ANSI and Unicode representations.
    //

    Share->Type.FileSystem.Name.Length = (USHORT)FileSystemNameLength;
    Share->Type.FileSystem.Name.MaximumLength =
            (USHORT)(FileSystemNameLength + sizeof( UNICODE_NULL ));

    Share->Type.FileSystem.Name.Buffer = FileSystemName;
    Share->Type.FileSystem.OemName.MaximumLength =
        (USHORT)RtlUnicodeStringToOemSize( &Share->Type.FileSystem.Name );

    Share->Type.FileSystem.Name.Buffer =
        ALLOCATE_HEAP(
            Share->Type.FileSystem.Name.MaximumLength +
                            Share->Type.FileSystem.OemName.MaximumLength,
            BlockTypeFSName
            );

    if ( Share->Type.FileSystem.Name.Buffer == NULL) {
        return;
    }


    RtlCopyMemory(
        Share->Type.FileSystem.Name.Buffer,
        FileSystemName,
        FileSystemNameLength
        );

    //
    // Generate the OEM version of the string to return to non-unicode
    // clients.
    //

    Share->Type.FileSystem.OemName.Buffer =
        (PCHAR)Share->Type.FileSystem.Name.Buffer +
             Share->Type.FileSystem.Name.MaximumLength;

    RtlUnicodeStringToOemString(
        &Share->Type.FileSystem.OemName,
        &Share->Type.FileSystem.Name,
        FALSE
        );

    //
    // Append a NUL character to the strings.
    //

    {
        PCHAR endOfBuffer;

        endOfBuffer = (PCHAR)Share->Type.FileSystem.Name.Buffer +
                            Share->Type.FileSystem.Name.Length;

        *(PWCH)endOfBuffer = UNICODE_NULL;

        Share->Type.FileSystem.Name.Length += sizeof( UNICODE_NULL );
    }

    Share->Type.FileSystem.OemName.Length++;

    return;

} // SrvFillInFileSystemName


NTSTATUS
SrvGetShareRootHandle (
    IN PSHARE Share
    )
/*++

Routine Description:

    This routine returns the root handle for a given share.  If the
    root has been opened, return the existing handle.  If not, open
    the share root directory and return the handle obtained.

Arguments:

    Share - The share for which the root directory handle is to be returned.

Return Value:

    Status of request.

--*/
{
    NTSTATUS status = STATUS_SUCCESS;

    PAGED_CODE( );

    if ( Share->ShareType != ShareTypeDisk ) {
        return STATUS_INVALID_DEVICE_REQUEST;
    }

    if ( Share->Removable ) {

        ACQUIRE_LOCK( &SrvShareLock );

        ++Share->CurrentRootHandleReferences;

        //
        // This is the first open
        //

        if ( Share->CurrentRootHandleReferences == 1 ) {

            ASSERT( Share->RootDirectoryHandle == NULL );

            //
            // Make sure we have a good handle to the media
            //
            SrvRefreshShareRootHandle( Share, &status );

            if( NT_SUCCESS( status ) ) {

                SrvReferenceShare( Share );

                if ( Share->QueryNamePrefixLength == -1 ) {

                    //
                    // Query the name associated with the share root directory.
                    // The prefix is removed whenever the name of a file in the
                    // share is queried.  (The logical root must be preserved
                    // for remote clients.)
                    //

                    GetShareQueryNamePrefix( Share );
                }

            } else {

                IF_DEBUG(ERRORS) {
                    KdPrint(( "SrvGetShareRootHandle: NtOpenFile failed %x.\n",
                                status ));
                }

                Share->CurrentRootHandleReferences--;
            }

        }

        RELEASE_LOCK( &SrvShareLock );
    }

    return status;

} // SrvGetShareRootHandle

BOOLEAN
SrvRefreshShareRootHandle (
    IN PSHARE Share,
    OUT PNTSTATUS Status
)
/*++

Routine Description:

    This routine tries to obtain a fresh share root handle, replacing the
    one that was there.  The handle will need to be refreshed if, for instance,
    the volume has been dismounted and remounted.

Arguments:

    Share - The share for which the root directory handle is to be refreshed.

Returns:
    TRUE - if a new handle was generated
    FALSE - if a new handle was not generated

--*/
{
    HANDLE h;
    OBJECT_ATTRIBUTES objectAttributes;
    IO_STATUS_BLOCK iosb;
    PFILE_OBJECT fileObject;
    PDEVICE_OBJECT deviceObject;

    PAGED_CODE();

    *Status = STATUS_SUCCESS;

    if( Share->ShareType != ShareTypeDisk ) {
        return FALSE;
    }

    //
    // Open the root directory of the share.  Future opens of files within
    // the share will be relative to the root of the share.
    //

    SrvInitializeObjectAttributes_U(
        &objectAttributes,
        &Share->NtPathName,
        OBJ_CASE_INSENSITIVE,
        NULL,
        NULL
        );

    *Status = NtOpenFile(
                &h,
                FILE_TRAVERSE,
                &objectAttributes,
                &iosb,
                FILE_SHARE_READ | FILE_SHARE_WRITE,
                FILE_DIRECTORY_FILE
                );

    if( !NT_SUCCESS( *Status ) ) {
        return FALSE;
    }

    //
    // Check the irp stack size needed to access this share.
    // If it is bigger than what we have allocated, fail
    // this share.
    //

    *Status = SrvVerifyDeviceStackSize(
                h,
                FALSE,
                &fileObject,
                &deviceObject,
                NULL
                );

    if ( !NT_SUCCESS( *Status )) {

        INTERNAL_ERROR(
            ERROR_LEVEL_EXPECTED,
            "SrvReferenceShareForTreeConnect: Verify Device Stack Size failed: %X\n",
            *Status,
            NULL
            );

        NtClose( h );
        return FALSE;
    }

    //
    // This handle looks suitable for use.  Set it to be the handle
    // for this share
    //
    h = (PRFCB)InterlockedExchangePointer( &Share->RootDirectoryHandle, h );

    //
    // If we have picked up a different handle, we need to close it
    //
    if( h != 0 ) {
        NtClose( h );
    }

    return TRUE;
}


VOID
GetShareQueryNamePrefix (
    IN PSHARE Share
    )
/*++

Routine Description:

    This routine queries the name associated with the share root
    directory.  The prefix is removed whenever the name of a file in the
    share is queried.  (The logical root must be preserved for remote
    clients.) For example, if the root of the share X is c:\shares\x,
    then for a query of \\server\x\y, the file system will return
    \shares\x\y, and we need to remove \shares\x and return just \y.

    It is not sufficient to just remove the local path (e.g.,
    \shares\x), because the file system may have a different idea of the
    name of the root directory.  For example, the Netware client
    redirector prefixes the name with volume information from the
    Netware server.  So we have to query the filesystem's idea of the
    name of the root to know what to strip off.

Arguments:

    Share - The share for which the query name prefix length is desired.

Return Value:

    None.

--*/
{
    NTSTATUS status;
    IO_STATUS_BLOCK iosb;
    ULONG localBuffer[ (FIELD_OFFSET(FILE_NAME_INFORMATION,FileName) + 20) / sizeof( ULONG ) ];
    PFILE_NAME_INFORMATION nameInfo;
    ULONG nameInfoLength;

    PAGED_CODE( );

    //
    // Do a short query to get the length of the name.  This query will
    // fail with STATUS_BUFFER_OVERFLOW unless the path to the share
    // root is short (10 characters or less).
    //

    nameInfo = (PFILE_NAME_INFORMATION)localBuffer;
    nameInfoLength = sizeof(localBuffer);

    status = NtQueryInformationFile(
                 Share->RootDirectoryHandle,
                 &iosb,
                 nameInfo,
                 nameInfoLength,
                 FileNameInformation
                 );

    if ( status == STATUS_BUFFER_OVERFLOW ) {

        //
        // We got an expected buffer overflow error.  Allocate a buffer
        // to hold the entire file name and redo the query.
        //

        nameInfoLength = sizeof(FILE_NAME_INFORMATION) + nameInfo->FileNameLength;
        nameInfo = ALLOCATE_HEAP( nameInfoLength, BlockTypeNameInfo );

        if ( nameInfo == NULL ) {
            status = STATUS_INSUFF_SERVER_RESOURCES;
        } else {
            status = NtQueryInformationFile(
                         Share->RootDirectoryHandle,
                         &iosb,
                         nameInfo,
                         nameInfoLength,
                         FileNameInformation
                         );
        }

    }

    if ( NT_SUCCESS(status) ) {

        //
        // We have the name.  The length of this name is the length we
        // want to strip from each query, unless the last character of
        // the name is \, in which case we need to strip up to, but not
        // including, the \.
        //

        Share->QueryNamePrefixLength = nameInfo->FileNameLength;
        if ( nameInfo->FileName[nameInfo->FileNameLength/sizeof(WCHAR) - 1] == L'\\') {
            Share->QueryNamePrefixLength -= sizeof(WCHAR);
        }

    } else {

        //
        // An unexpected error occurred.  Just set the prefix length to 0.
        //

        Share->QueryNamePrefixLength = 0;

    }

    //
    // If we allocated a temporary buffer, free it now.
    //

    if ( (nameInfo != NULL) && (nameInfo != (PFILE_NAME_INFORMATION)localBuffer) ) {
        FREE_HEAP( nameInfo );
    }

    return;

} // GetShareQueryNamePrefix
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\srv\blksrch.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    blksrch.c

Abstract:

    This module implements routines for managing search blocks.

Author:

    David Treadwell (davidtr) 23-Feb-1990

Revision History:

--*/

#include "precomp.h"
#include "blksrch.tmh"
#pragma hdrstop

#define BugCheckFileId SRV_FILE_BLKSRCH

#ifdef ALLOC_PRAGMA
#pragma alloc_text( PAGE, SrvAllocateSearch )
#pragma alloc_text( PAGE, SrvCloseSearch )
#pragma alloc_text( PAGE, SrvCloseSearches )
#pragma alloc_text( PAGE, SrvDereferenceSearch )
#pragma alloc_text( PAGE, SrvFreeSearch )
#pragma alloc_text( PAGE, SrvReferenceSearch )
#pragma alloc_text( PAGE, SrvSearchOnDelete )
#pragma alloc_text( PAGE, SrvSearchOnPid )
#pragma alloc_text( PAGE, SrvSearchOnSession )
#pragma alloc_text( PAGE, SrvSearchOnTreeConnect )
#pragma alloc_text( PAGE, SrvTimeoutSearches )
#pragma alloc_text( PAGE, SrvForceTimeoutSearches )
#pragma alloc_text( PAGE, RemoveDuplicateCoreSearches )
#pragma alloc_text( PAGE, SrvAddToSearchHashTable )
#endif


VOID
SrvAllocateSearch (
    OUT PSEARCH *Search,
    IN PUNICODE_STRING SearchName,
    IN BOOLEAN IsCoreSearch
    )

/*++

Routine Description:

    This function allocates a Search Block from the FSP heap.

Arguments:

    Search - Returns a pointer to the search block, or NULL if no heap
        space was available.

    SearchName - Supplies a pointer to the string describing the search
        file name.

    IsCoreSearch - Indicates whether a core search block or regular
        search block should be allocated.  A core search block has a
        different block type and has the LastUsedTime field set.

Return Value:

    None.

--*/

{
    ULONG blockLength;
    PSEARCH search;

    PAGED_CODE( );

    blockLength = sizeof(SEARCH) + SearchName->Length +
                                            sizeof(*SearchName->Buffer);

    //
    // Attempt to allocate from the heap.
    //

    search = ALLOCATE_HEAP( blockLength, BlockTypeSearch );
    *Search = search;

    if ( search == NULL ) {
        INTERNAL_ERROR(
            ERROR_LEVEL_EXPECTED,
            "SrvAllocateSearch: Unable to allocate %d bytes from heap.",
            blockLength,
            NULL
            );

        // An error is logged by the caller

        return;
    }

    IF_DEBUG(HEAP) {
        SrvPrint1( "SrvAllocateSearch: Allocated search block at %p\n",
                    search );
    }

    RtlZeroMemory( search, blockLength );

    search->BlockHeader.ReferenceCount = 2;

    //
    // If this is a core search, set the block type and the LastUsedTime
    // fields.
    //

    if ( IsCoreSearch ) {
        SET_BLOCK_TYPE_STATE_SIZE( search, BlockTypeSearchCore, BlockStateActive, blockLength );
        KeQuerySystemTime( &search->LastUseTime );
    } else {
        SET_BLOCK_TYPE_STATE_SIZE( search, BlockTypeSearch, BlockStateActive, blockLength );
    }

    //
    // Set the list entry fields to NULL.  They will stay this way in
    // OS/2-style searches (non-core), but will change to include the
    // search block in a last-use list if a core search.
    //
    // We zeroed the block above, so we don't have to do it here.
    //

    //search->LastUseListEntry.Flink = NULL;
    //search->LastUseListEntry.Blink = NULL;

    //
    // Set the Buffer field of the LastFileNameReturned field to NULL
    // so that we know that it is not in use.
    //
    // We zeroed the block above, so we don't have to do it here.
    //

    //search->LastFileNameReturned.Buffer == NULL;

    //
    // Set the directory cache pointer to NULL so that we don't try to
    // free it when the search block closes.
    //

    //search->DirectoryCache = NULL;

    //
    // Put search name after search block.
    //

    search->SearchName.Buffer = (PWCH)(search + 1);
    search->SearchName.Length = SearchName->Length;
    search->SearchName.MaximumLength = (SHORT)(SearchName->Length +
                                            sizeof(*SearchName->Buffer));

    RtlCopyMemory(
        search->SearchName.Buffer,
        SearchName->Buffer,
        SearchName->Length
        );

    INITIALIZE_REFERENCE_HISTORY( search );

    InterlockedIncrement(
        (PLONG)&SrvStatistics.CurrentNumberOfOpenSearches
        );

    INCREMENT_DEBUG_STAT( SrvDbgStatistics.SearchInfo.Allocations );

    return;

} // SrvAllocateSearch


VOID
SrvCloseSearch (
    IN PSEARCH Search
    )

/*++

Routine Description:

    This routine prepares a search block to be closed.  It changes the
    block state to closing and dereferences the search block so that is
    will be closed as soon as all other references are closed.

Arguments:

    Search - Supplies a pointer to the search block that is to be closed.

Return Value:

    None.

--*/

{
    PAGED_CODE( );

    ACQUIRE_LOCK( &Search->Session->Connection->Lock );

    if ( GET_BLOCK_STATE(Search) == BlockStateActive ) {

        IF_DEBUG(BLOCK1) {
            SrvPrint2( "Closing search block at %p, %wZ\n",
                          Search, &Search->SearchName );
        }

        SET_BLOCK_STATE( Search, BlockStateClosing );

        RELEASE_LOCK( &Search->Session->Connection->Lock );

        //
        // Dereference the search block (to indicate that it's no longer
        // open).
        //

        SrvDereferenceSearch( Search );

        INCREMENT_DEBUG_STAT( SrvDbgStatistics.SearchInfo.Closes );

    } else {

        RELEASE_LOCK( &Search->Session->Connection->Lock );

    }

    return;

} // SrvCloseSearch


VOID
SrvCloseSearches (
    IN PCONNECTION Connection,
    IN PSEARCH_FILTER_ROUTINE SearchFilterRoutine,
    IN PVOID FunctionParameter1,
    IN PVOID FunctionParameter2
    )

/*++

Routine Description:

    This is the common routine to close searches based on the
    filter routine and the parameters passed.

Arguments:

    Connection - the connection which contains the search blocks to be
        closed.

    SearchFilterRoutine - a routine that determines whether the
        search block is to be closed or not.

    FunctionParameter1
    FunctionParameter2 -  parameters to be passed to the filter routine

Return Value:

    None.

--*/

{
    PLIST_ENTRY searchEntry;
    PLIST_ENTRY nextSearchEntry;
    PPAGED_CONNECTION pagedConnection = Connection->PagedConnection;
    PSEARCH search;
    ULONG i;

    PAGED_CODE( );

    ACQUIRE_LOCK( &Connection->Lock );

    //
    // Go through the list's search blocks, closing those which passes
    // the check in the filter routine.  While a search block is
    // being used it is taken off the lists, so there is no danger of
    // dereferencing a block whose last use time is about to be updated.
    //

    searchEntry = pagedConnection->CoreSearchList.Flink;

    while ( searchEntry != &pagedConnection->CoreSearchList ) {

        nextSearchEntry = searchEntry->Flink;

        search = CONTAINING_RECORD( searchEntry, SEARCH, LastUseListEntry );

        if ( SearchFilterRoutine(
                        search,
                        FunctionParameter1,
                        FunctionParameter2
                        ) ) {

            IF_SMB_DEBUG(SEARCH2) {
                SrvPrint1( "SrvCloseSearches: Closing search block at %p\n", search );
            }

            SrvCloseSearch( search );
        }

        searchEntry = nextSearchEntry;
    }

    //
    // Close all active non-core searches.
    //

    for ( i = 0; i < (ULONG)pagedConnection->SearchTable.TableSize; i++ ) {

        PSEARCH search = (PSEARCH)pagedConnection->SearchTable.Table[i].Owner;

        if ( (search != NULL) &&
             (GET_BLOCK_STATE( search ) == BlockStateActive) &&
             SearchFilterRoutine(
                            search,
                            FunctionParameter1,
                            FunctionParameter2
                            ) ) {

            IF_SMB_DEBUG(SEARCH2) {
                SrvPrint1( "SrvCloseSearches: Closing non-core search block at %p\n", search );
            }

            SrvCloseSearch( search );
        }
    }

    RELEASE_LOCK( &Connection->Lock );
    return;

} // SrvCloseSearches

VOID
SrvDereferenceSearch (
    IN PSEARCH Search
    )

/*++

Routine Description:

    This function decrements the reference count on a search block.  If
    the reference count goes to zero, the search block is deleted.

Arguments:

    Search - Address of search block

Return Value:

    None.

--*/

{
    PCONNECTION connection = Search->Session->Connection;
    PPAGED_CONNECTION pagedConnection = connection->PagedConnection;

    PAGED_CODE( );

    //
    // Enter a critical section and decrement the reference count on the
    // block.
    //

    ACQUIRE_LOCK( &connection->Lock );

    ASSERT( GET_BLOCK_TYPE(Search) == BlockTypeSearch ||
            GET_BLOCK_TYPE(Search) == BlockTypeSearchCore );

    IF_DEBUG(REFCNT) {
        SrvPrint2( "Dereferencing search block %p; old refcnt %lx\n",
                    Search, Search->BlockHeader.ReferenceCount );
    }

    ASSERT( (LONG)Search->BlockHeader.ReferenceCount > 0 );
    UPDATE_REFERENCE_HISTORY( Search, TRUE );

    if ( --Search->BlockHeader.ReferenceCount == 0 ) {

        ASSERT( GET_BLOCK_STATE(Search) != BlockStateActive );

        //
        // The new reference count is 0, meaning that it's time to
        // delete this block.  Free the search block entry in the search
        // table.
        //
        // If the search block is for a find unique, then the table
        // index will be -1, indicating that it has no entry on the
        // search table.
        //

        if ( Search->TableIndex != -1 ) {

            SrvRemoveEntryTable(
                &pagedConnection->SearchTable,
                Search->TableIndex
                );
        }

        //
        // If it was an old-style search, remove it from the hash table and
        // the last-use list it was on.
        //

        if ( Search->BlockHeader.Type == BlockTypeSearchCore ) {

            if (Search->LastUseListEntry.Flink != NULL ) {

                SrvRemoveEntryList(
                    &pagedConnection->CoreSearchList,
                    &Search->LastUseListEntry
                    );

                DECREMENT_DEBUG_STAT2( SrvDbgStatistics.CoreSearches );

            }

            if (Search->HashTableEntry.Flink != NULL ) {

                SrvRemoveEntryList(
                    &pagedConnection->SearchHashTable[Search->HashTableIndex].ListHead,
                    &Search->HashTableEntry
                    );
            }

            pagedConnection->CurrentNumberOfCoreSearches--;
        }

        // Decrement the count of open files in the session.  Including
        // searches in the count of open files on the session ensures
        // that a session with an open search will not be closed.
        //

        ASSERT( Search->Session->CurrentSearchOpenCount != 0 );
        Search->Session->CurrentSearchOpenCount--;

        RELEASE_LOCK( &connection->Lock );

        //
        // Close the directory handle for the search.
        //

        if ( Search->DirectoryHandle != NULL ) {
            SRVDBG_RELEASE_HANDLE( Search->DirectoryHandle, "SCH", 7, Search );
            SrvNtClose( Search->DirectoryHandle, TRUE );
        }

        //
        // Dereference the session and tree connect.
        //

        SrvDereferenceSession( Search->Session );
        SrvDereferenceTreeConnect( Search->TreeConnect );

        //
        // Free the LastFileNameReturned buffer, if any.
        //

        if ( Search->LastFileNameReturned.Buffer != NULL ) {
            FREE_HEAP( Search->LastFileNameReturned.Buffer );
        }

        //
        // Free the directory cache, if any.
        //

        if ( Search->DirectoryCache != NULL ) {
            FREE_HEAP( Search->DirectoryCache );
        }

        //
        // Free the search block.
        //

        SrvFreeSearch( Search );

    } else {

        RELEASE_LOCK( &connection->Lock );

    }

    return;

} // SrvDereferenceSearch


VOID
SrvFreeSearch (
    IN PSEARCH Search
    )

/*++

Routine Description:

    This function returns a Search Block to the server heap.

Arguments:

    Search - Address of Search Block

Return Value:

    None.

--*/

{
    PAGED_CODE( );

    DEBUG SET_BLOCK_TYPE_STATE_SIZE( Search, BlockTypeGarbage, BlockStateDead, -1 );
    DEBUG Search->BlockHeader.ReferenceCount = (ULONG)-1;
    TERMINATE_REFERENCE_HISTORY( Search );

    FREE_HEAP( Search );
    IF_DEBUG(HEAP) {
        SrvPrint1( "SrvFreeSearch: Freed search block at %p\n", Search );
    }

    InterlockedDecrement(
        (PLONG)&SrvStatistics.CurrentNumberOfOpenSearches
        );

    INCREMENT_DEBUG_STAT( SrvDbgStatistics.SearchInfo.Frees );

    return;

} // SrvFreeSearch


VOID
SrvReferenceSearch (
    PSEARCH Search
    )

/*++

Routine Description:

    This function increments the reference count on a search block.

Arguments:

    Search - Address of search block.

Return Value:

    None.

--*/

{
    PAGED_CODE( );

    ACQUIRE_LOCK( &Search->Session->Connection->Lock );

    ASSERT( (LONG)Search->BlockHeader.ReferenceCount > 0 );
    ASSERT( GET_BLOCK_TYPE(Search) == BlockTypeSearch ||
            GET_BLOCK_TYPE(Search) == BlockTypeSearchCore );
    ASSERT( GET_BLOCK_STATE(Search) == BlockStateActive );
    UPDATE_REFERENCE_HISTORY( Search, FALSE );

    //
    // Enter a critical section and increment the reference count on the
    // search block.
    //

    Search->BlockHeader.ReferenceCount++;

    IF_DEBUG(REFCNT) {
        SrvPrint2( "Referencing search block %p; new refcnt %lx\n",
                    Search, Search->BlockHeader.ReferenceCount );
    }

    RELEASE_LOCK( &Search->Session->Connection->Lock );

    return;

} // SrvReferenceSearch


BOOLEAN
SrvSearchOnDelete(
    IN PSEARCH Search,
    IN PUNICODE_STRING DirectoryName,
    IN PTREE_CONNECT TreeConnect
    )

/*++

Routine Description:

    Filter routine to determine to pick the search blocks on this
    directory.

Arguments:

    Search - the search block currently being looked at.
    DirectoryName - name of directory currently being deleted.
    TreeConnect - the TreeConnect which is currently being looked at.

Return Value:

    TRUE, if search block belongs to the TreeConnect.
    FALSE, otherwise.

--*/

{
    UNICODE_STRING searchDirectoryName;

    PAGED_CODE( );

    //
    // We'll use the same buffer as the SearchName string in the
    // search for the comparison, but use the length from the
    // passed-in directory name if it is less.  This allows
    // all searches on subdirectories of a deleted directory to
    // be closed.
    //

    searchDirectoryName = Search->SearchName;

    if ( searchDirectoryName.Length > DirectoryName->Length ) {
        searchDirectoryName.Length = DirectoryName->Length;
    }

    return ( Search->TreeConnect == TreeConnect &&
             RtlCompareUnicodeString(
                 &searchDirectoryName,
                 DirectoryName,
                 TRUE ) == 0 );
}

BOOLEAN
SrvSearchOnPid(
    IN PSEARCH Search,
    IN USHORT Pid,
    IN PVOID Dummy
    )

/*++

Routine Description:

    Filter routine to determine to pick the search blocks on this
    Pid.

Arguments:

    Search - the search block currently being looked at.
    Pid - the Pid which is currently being run down.

Return Value:

    TRUE, if search block belongs to the pid.
    FALSE, otherwise.

--*/

{
    PAGED_CODE( );

    return ( Search->Pid == Pid );
}

BOOLEAN
SrvSearchOnSession(
    IN PSEARCH Search,
    IN PSESSION Session,
    IN PVOID Dummy
    )

/*++

Routine Description:

    Filter routine to determine to pick the search blocks on this
    Session.

Arguments:

    Search - the search block currently being looked at.
    Session - the session which is currently being closed.

Return Value:

    TRUE, if search block belongs to the session.
    FALSE, otherwise.

--*/

{
    PAGED_CODE( );

    return ( Search->Session == Session );
}

BOOLEAN
SrvSearchOnTreeConnect(
    IN PSEARCH Search,
    IN PTREE_CONNECT TreeConnect,
    IN PVOID Dummy
    )

/*++

Routine Description:

    Filter routine to determine to pick the search blocks on this
    Tree Connect.

Arguments:

    Search - the search block currently being looked at.
    TreeConnect - the TreeConnect which is currently being run down.

Return Value:

    TRUE, if search block belongs to the TreeConnect.
    FALSE, otherwise.

--*/

{
    PAGED_CODE( );

    return ( Search->TreeConnect == TreeConnect );
}

ULONG
SrvTimeoutSearches (
    IN PLARGE_INTEGER SearchCutoffTime OPTIONAL,
    IN PCONNECTION Connection,
    IN BOOLEAN TimeoutAtLeastOne
    )

/*++

Routine Description:

    Goes through the lists of core search blocks, dereferencing those
    that have timed out.

Arguments:

    SearchCutoffTime - The cutoff time for closing core search blocks.

    Connection - the connection whose search blocks are to be
        checked for timeouts.

    TimeoutAtLeastOne - if TRUE, a minimum of one block is closed.  This
        is used when we are timing out because the search table is full
        and we need to allocate a search block and when the total number of
        search blocks have reached our limit.

Return Value:

    The number of search blocks that were timed out.

--*/

{

    LARGE_INTEGER currentTime;
    LARGE_INTEGER searchCutoffTime;
    PPAGED_CONNECTION pagedConnection = Connection->PagedConnection;
    PLIST_ENTRY searchEntry;
    PLIST_ENTRY nextSearchEntry;
    ULONG count = 0;

    PAGED_CODE( );

    //
    // First, get the current time, then subtract off the timeout
    // value.  Any block older than this result is too old.
    //

    if ( !ARGUMENT_PRESENT( SearchCutoffTime ) ) {
        KeQuerySystemTime( &currentTime );

        //
        // Get the current search timeout values.  This must be protected
        // by the configuration lock because these values are changed
        // dynamically.
        //

        ACQUIRE_LOCK( &SrvConfigurationLock );
        searchCutoffTime.QuadPart =
                        currentTime.QuadPart - SrvSearchMaxTimeout.QuadPart;
        RELEASE_LOCK( &SrvConfigurationLock );

    } else {
        searchCutoffTime = *SearchCutoffTime;
    }

    //
    // Acquire the connection lock.
    //

    ACQUIRE_LOCK( &Connection->Lock );

    IF_SMB_DEBUG(SEARCH2) {
        SrvPrint2( "Core blocks: Oldest valid time is %lx,%lx\n",
                    searchCutoffTime.HighPart,
                    searchCutoffTime.LowPart );
    }

    //
    // Go through the list's search blocks, dereferencing those who
    // are older than the list timeout.  While a search block
    // is being used it is taken off the lists, so there is no
    // danger of dereferencing a block whose last use time is
    // about to be updated.
    //

    searchEntry = pagedConnection->CoreSearchList.Flink;

    while ( searchEntry != &pagedConnection->CoreSearchList ) {

        PSEARCH search;

        nextSearchEntry = searchEntry->Flink;

        search = CONTAINING_RECORD( searchEntry, SEARCH, LastUseListEntry );

        IF_SMB_DEBUG(SEARCH2) {
            SrvPrint2( "Comparing time %lx,%lx\n",
                        search->LastUseTime.HighPart,
                        search->LastUseTime.LowPart );
        }

        //
        // If the time on the current search block is greater than
        // the oldest valid time, it is sufficiently new, so
        // we can stop searching the list, as all further
        // search blocks are newer than this one.
        //

        if ( (search->LastUseTime.QuadPart > searchCutoffTime.QuadPart) &&
             ( !TimeoutAtLeastOne || (count != 0) ) ) {
            break;
        }

        IF_SMB_DEBUG(SEARCH2) {
            SrvPrint1( "Closing search block at %p\n", search );
        }

        SrvCloseSearch( search );

        count++;

        searchEntry = nextSearchEntry;
    }

    RELEASE_LOCK( &Connection->Lock );
    return count;

} // SrvTimeoutSearches


VOID
SrvForceTimeoutSearches(
    IN PCONNECTION Connection
    )
/*++

Routine Description:

    Goes through the lists of core search blocks, closing those
    that have timed out.  This forces the close of at least one
    search block.

Arguments:

    Connection - Pointer to the connection from which a search
        block is to be closed first.

Return Value:

    None.

--*/

{
    USHORT index;
    PENDPOINT endpoint;
    PLIST_ENTRY listEntry;
    PCONNECTION testConnection;
    LARGE_INTEGER currentTime;
    LARGE_INTEGER searchCutoffTime;
    ULONG count;

    PAGED_CODE( );

    //
    // Attempt to timeout the oldest search block for this connection.
    //

    KeQuerySystemTime( &currentTime );

    //
    // Get the current search timeout values.  This must be protected
    // by the configuration lock because these values are changed
    // dynamically.
    //

    ACQUIRE_LOCK( &SrvConfigurationLock );
    searchCutoffTime.QuadPart =
                    currentTime.QuadPart - SrvSearchMaxTimeout.QuadPart;
    RELEASE_LOCK( &SrvConfigurationLock );

    count = SrvTimeoutSearches(
                            &searchCutoffTime,
                            Connection,
                            TRUE
                            );

    //
    // Walk each connection and determine if we should close it.
    //

    ACQUIRE_LOCK( &SrvEndpointLock );

    listEntry = SrvEndpointList.ListHead.Flink;

    while ( listEntry != &SrvEndpointList.ListHead ) {

        endpoint = CONTAINING_RECORD(
                        listEntry,
                        ENDPOINT,
                        GlobalEndpointListEntry
                        );

        //
        //
        // If this endpoint is closing, skip to the next one.
        // Otherwise, reference the endpoint so that it can't go away.
        //

        if ( GET_BLOCK_STATE(endpoint) != BlockStateActive ) {
            listEntry = listEntry->Flink;
            continue;
        }

        SrvReferenceEndpoint( endpoint );

        //
        // Walk the endpoint's connection table.
        //

        index = (USHORT)-1;

        while ( TRUE ) {

            //
            // Get the next active connection in the table.  If no more
            // are available, WalkConnectionTable returns NULL.
            // Otherwise, it returns a referenced pointer to a
            // connection.
            //

            testConnection = WalkConnectionTable( endpoint, &index );
            if ( testConnection == NULL ) {
                break;
            }

            RELEASE_LOCK( &SrvEndpointLock );

            //
            // Time out old core search blocks.
            //

            count += SrvTimeoutSearches(
                                    &searchCutoffTime,
                                    testConnection,
                                    (BOOLEAN)(count == 0)
                                    );

            ACQUIRE_LOCK( &SrvEndpointLock );

            //
            // Dereference the connection to account for the reference
            // from WalkConnectionTable.
            //

            SrvDereferenceConnection( testConnection );

        } // walk connection table

        //
        // Capture a pointer to the next endpoint in the list (that one
        // can't go away because we hold the endpoint list), then
        // dereference the current endpoint.
        //

        listEntry = listEntry->Flink;
        SrvDereferenceEndpoint( endpoint );

    } // walk endpoint list

    RELEASE_LOCK( &SrvEndpointLock );

} // SrvForceTimeoutSearches


VOID
RemoveDuplicateCoreSearches(
    IN PPAGED_CONNECTION PagedConnection
    )

/*++

Routine Description:

    Goes through the connection hash table and removes duplicate searches.

    *** Connection lock assumed held.  Remains held on exit. ***

Arguments:

    PagedConnection - Pointer to the paged portion of the connection block.

Return Value:

    None.

--*/

{
    ULONG i, j;
    PSEARCH firstSearch;
    PSEARCH tmpSearch;
    PLIST_ENTRY listHead;
    PLIST_ENTRY searchEntry;
    PLIST_ENTRY nextSearchEntry;
    PTREE_CONNECT treeConnect;
    USHORT pid;
    PUNICODE_STRING searchName;

    PAGED_CODE( );

    for ( i = 0; i < SEARCH_HASH_TABLE_SIZE; i++ ) {

        //
        // If this slot has been idle, skip.
        //

        if ( !PagedConnection->SearchHashTable[i].Dirty ) {
            continue;
        }

        PagedConnection->SearchHashTable[i].Dirty = FALSE;
        listHead = &PagedConnection->SearchHashTable[i].ListHead;

        //
        // Skip the first 3 searches.  This will hopefully take care of
        // weird dos apps that plays with multiple search blocks. 3 is
        // an arbitrary number.
        //

        searchEntry = listHead->Flink;
        for ( j = 0; j < 3; j++) {

            if ( searchEntry != listHead ) {
                searchEntry = searchEntry->Flink;
            } else {
                continue;
            }
        }

next_search:

        firstSearch = CONTAINING_RECORD(
                                searchEntry,
                                SEARCH,
                                HashTableEntry
                                );

        //
        // Assign these to locals so they don't get recomputed each
        // time we go through the loop.
        //

        treeConnect = firstSearch->TreeConnect;
        pid = firstSearch->Pid;
        searchName = &firstSearch->SearchName;

        searchEntry = searchEntry->Flink;

        //
        // Close all duplicates.
        //

        while ( searchEntry != listHead ) {

            nextSearchEntry = searchEntry->Flink;
            tmpSearch = CONTAINING_RECORD(
                                    searchEntry,
                                    SEARCH,
                                    HashTableEntry
                                    );

            if ( ( tmpSearch->TreeConnect == treeConnect ) &&
                 ( tmpSearch->Pid == pid ) &&
                 ( RtlCompareUnicodeString(
                           searchName,
                           &tmpSearch->SearchName,
                           FALSE                       // case sensitive
                           ) == 0 ) ) {

                SrvCloseSearch( tmpSearch );
            }

            searchEntry = nextSearchEntry;
        }

        //
        // If we have another search candidate. Repeat.
        //

        if ( firstSearch->HashTableEntry.Flink != listHead ) {
            searchEntry = firstSearch->HashTableEntry.Flink;
            goto next_search;
        }
    }

} // RemoveDuplicateCoreSearches

VOID
SrvAddToSearchHashTable(
    IN PPAGED_CONNECTION PagedConnection,
    IN PSEARCH Search
    )

/*++

Routine Description:

    Inserts a search block into the connection hash table.

    *** Connection lock assumed held.  Remains held on exit. ***

Arguments:

    PagedConnection - Pointer to the paged portion of the connection block.

    Search - Pointer to the search block to be inserted.

Return Value:

    None.

--*/

{
    ULONG nameLength;
    ULONG lastChar;
    ULONG hashSum;
    ULONG i;

    PAGED_CODE( );

    //
    // Get the hash value
    //

    nameLength = Search->SearchName.Length / sizeof(WCHAR);

    //
    // add the length and the first 3 bytes of the tree connect block address
    //

    //
    // NT64: Note that before the port, this line read:
    //
    // hashSum = nameLength + (ULONG)Search->TreeConnect >> 4;
    //
    // It is likely true that the original author intended to right-shift
    // only the pointer, not the sum.  However, after discussion with the
    // current owners of this component, it was decided to leave the current
    // precedence intact.  As part of the 64-bit port, the actual precedence
    // has been made explicit.
    //

    hashSum = (ULONG)((nameLength + (ULONG_PTR)Search->TreeConnect) >> 4);

    //
    // If the length < 8, then this is probably not an interesting core
    // search.
    //

    if ( nameLength > 7 ) {

        lastChar = nameLength - 5;

        //
        // Add the last 5 characters
        //

        for ( i = nameLength-1 ; i >= lastChar ; i-- ) {
            hashSum += (ULONG)Search->SearchName.Buffer[i];
        }
    }

    //
    // get the slot number.
    //

    i = hashSum & (SEARCH_HASH_TABLE_SIZE-1);

    //
    // Tell the scavenger that a search has been inserted to this slot.
    //

    PagedConnection->SearchHashTable[i].Dirty = TRUE;

    //
    // Insert this new search block into the hash table
    //

    SrvInsertHeadList(
                &PagedConnection->SearchHashTable[i].ListHead,
                &Search->HashTableEntry
                );

    Search->HashTableIndex = (USHORT)i;
    return;

} // SrvAddToSearchHashTable
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\srv\blktrans.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    blktrans.c

Abstract:

    This module implements routines for managing transaction blocks.

Author:

    Chuck Lenzmeier (chuckl) 23-Feb-1990

Revision History:

--*/

#include "precomp.h"
#include "blktrans.tmh"
#pragma hdrstop

#define BugCheckFileId SRV_FILE_BLKTRANS

//
// If a transaction block has no space for extra data, and its name is
// the null string, it is eligible to be cached when it is free.  This
// means that instead of freeing the transaction block, a pointer to the
// block is stored in the connection block.
//
// An eligible transaction will be four bytes longer than the base
// transaction block size.  This allows for a Unicode string terminator
// padded to a longword.
//

#define CACHED_TRANSACTION_BLOCK_SIZE sizeof(TRANSACTION) + 4

//
// We allow up to four transactions to be cached.
//
// !!! This should be a configuration parameter.
//

#define CACHED_TRANSACTION_LIMIT 4

#ifdef ALLOC_PRAGMA
#pragma alloc_text( PAGE, SrvCloseTransaction )
#pragma alloc_text( PAGE, SrvCloseTransactionsOnSession )
#pragma alloc_text( PAGE, SrvCloseTransactionsOnTree )
#pragma alloc_text( PAGE, SrvDereferenceTransaction )
#pragma alloc_text( PAGE, SrvAllocateTransaction )
#pragma alloc_text( PAGE, SrvFreeTransaction )
#endif
#if 0
#endif


VOID
SrvAllocateTransaction (
    OUT PTRANSACTION *Transaction,
    OUT PVOID *TrailingBytes,
    IN PCONNECTION Connection,
    IN CLONG TrailingByteCount,
    IN PVOID TransactionName,
    IN PVOID EndOfSourceBuffer OPTIONAL,
    IN BOOLEAN SourceIsUnicode,
    IN BOOLEAN RemoteApiRequest
    )

/*++

Routine Description:

    This function allocates a Transaction block from the FSP heap.

Arguments:

    Transaction - Returns a pointer to the transaction block, or NULL if
        no heap space was available.

    TrailingBytes - Returns a pointer to the trailing bytes allocated at
        the end of the transaction block.  Invalid if *Transaction is
        NULL.

    TrailingByteCount - Supplies the count of bytes (not including the
        transaction name) to be allocated at the tail end of the
        transaction block.

    TransactionName - Supplies a pointer to the null-terminated
        transaction name string.  Is SourceIsUnicode is TRUE, this must
        be an aligned pointer.

    EndOfSourceBuffer - A pointer to the end of the SMB buffer.  Used to
        protect the server from accessing beyond the end of the SMB buffer,
        if the format is invalid.  If NULL, indicates that checking is not
        necessary.

    SourceIsUnicode - Indicates whether the TransactionName buffer contains
        Unicode characters.

    RemoteApiRequest - TRUE if this is a remote API request and should
        hence be allocated from the shared memory that XACTSRV can see.

Return Value:

    None.

--*/

{
    USHORT nameLength;
    CLONG extraLength;
    CLONG blockSize;
    PSINGLE_LIST_ENTRY listEntry;
    PNONPAGED_HEADER header;
    PTRANSACTION transaction;

    PAGED_CODE();

    //
    // Get the length of the name (in bytes) including the null terminator.
    //

    if ( EndOfSourceBuffer == NULL ) {

        //
        // No checking is required
        //

        if ( SourceIsUnicode ) {
            nameLength = (USHORT)(wcslen( (PWCH)TransactionName ) + 1);
        } else {
            nameLength = (USHORT)(strlen( (PCHAR)TransactionName ) + 1);
        }
        nameLength *= sizeof(WCHAR);

    } else {

        nameLength = SrvGetStringLength(
                             TransactionName,
                             EndOfSourceBuffer,
                             SourceIsUnicode,
                             TRUE               // include null terminator
                             );

        if ( nameLength == (USHORT)-1 ) {

            //
            // If the name is messed up, assume L'\0'
            //

            nameLength = sizeof(WCHAR);

        } else if ( !SourceIsUnicode ) {

            nameLength *= sizeof(WCHAR);
        }
    }

    extraLength = ((nameLength + 3) & ~3) + TrailingByteCount;
    blockSize = sizeof(TRANSACTION) + extraLength;

    //
    // Attempt to allocate from the heap.  Make sure they aren't asking for
    //  too much memory
    //

    if( TrailingByteCount > MAX_TRANSACTION_TAIL_SIZE ) {

        transaction = NULL;

    } else if ( !RemoteApiRequest ) {

        //
        // If the extra length required allows us to use a cached
        // transaction block, try to get one of those first.
        //

        if ( blockSize == CACHED_TRANSACTION_BLOCK_SIZE ) {

            listEntry = ExInterlockedPopEntrySList( &Connection->CachedTransactionList, &Connection->SpinLock );

            if ( listEntry != NULL ) {

                ASSERT( Connection->CachedTransactionCount > 0 );
                InterlockedDecrement( &Connection->CachedTransactionCount );

                header = CONTAINING_RECORD(
                            listEntry,
                            NONPAGED_HEADER,
                            ListEntry
                            );
                transaction = header->PagedBlock;

                IF_DEBUG(HEAP) {
                    SrvPrint1( "SrvAllocateTransaction: Found cached transaction block at %p\n", transaction );
                }

                *Transaction = transaction;
                goto got_cached_transaction;

            }
        }

        transaction = ALLOCATE_HEAP( blockSize, BlockTypeTransaction );

    } else {

        NTSTATUS status;    // ignore this
        transaction = SrvXsAllocateHeap( blockSize, &status );

    }

    *Transaction = transaction;

    if ( transaction == NULL ) {
        INTERNAL_ERROR(
            ERROR_LEVEL_EXPECTED,
            "SrvAllocateTransaction: Unable to allocate %d bytes from heap.",
            blockSize,
            NULL
            );

        // An error will be logged by the caller

        return;
    }
    IF_DEBUG(HEAP) {
        SrvPrint1( "SrvAllocateTransaction: Allocated transaction block at %p\n", transaction );
    }

    //
    // Allocate the nonpaged header.
    //

    header = ALLOCATE_NONPAGED_POOL(
                sizeof(NONPAGED_HEADER),
                BlockTypeNonpagedHeader
                );
    if ( header == NULL ) {
        INTERNAL_ERROR(
            ERROR_LEVEL_EXPECTED,
            "SrvAllocateTransaction: Unable to allocate %d bytes from pool.",
            sizeof( NONPAGED_HEADER ),
            NULL
            );
        if ( !RemoteApiRequest ) {
            FREE_HEAP( transaction );
        } else {
            SrvXsFreeHeap( transaction );
        }
        *Transaction = NULL;
        return;
    }

    header->Type = BlockTypeTransaction;
    header->PagedBlock = transaction;

    INCREMENT_DEBUG_STAT( SrvDbgStatistics.TransactionInfo.Allocations );

#if SRVDBG2
    transaction->BlockHeader.ReferenceCount = 2; // for INITIALIZE_REFERENCE_HISTORY
#endif
    INITIALIZE_REFERENCE_HISTORY( transaction );

got_cached_transaction:

    RtlZeroMemory( transaction, sizeof(TRANSACTION) );

    transaction->NonpagedHeader = header;

    SET_BLOCK_TYPE_STATE_SIZE( transaction, BlockTypeTransaction, BlockStateActive, blockSize );
    header->ReferenceCount = 2; // allow for Active status and caller's pointer

    transaction->RemoteApiRequest = RemoteApiRequest;

    //
    // Put transaction name after main part of transaction block.
    //

    transaction->TransactionName.Buffer = (PWCH)( transaction + 1 );
    transaction->TransactionName.MaximumLength = (USHORT)nameLength;
    transaction->TransactionName.Length = (USHORT)(nameLength - sizeof(WCHAR));

    if ( nameLength == sizeof(WCHAR) ) {

        transaction->TransactionName.Buffer = L'\0';

    } else {

        if ( SourceIsUnicode ) {

            RtlCopyMemory(
                (PVOID)transaction->TransactionName.Buffer,
                TransactionName,
                nameLength
                );

        } else {

            ANSI_STRING ansiName;

            ansiName.Buffer = (PCHAR)TransactionName;
            ansiName.Length = (nameLength / sizeof(WCHAR)) - 1;

            RtlOemStringToUnicodeString(
                &transaction->TransactionName,
                &ansiName,
                FALSE
                );

        }

    }

    //
    // Set address of trailing bytes.
    //

    *TrailingBytes = (PCHAR)transaction + sizeof(TRANSACTION) +
                        ((nameLength + 3) & ~3);

    return;

} // SrvAllocateTransaction


VOID
SrvCloseTransaction (
    IN PTRANSACTION Transaction
    )

/*++

Routine Description:

    This routine closes a pending transaction.  It sets the state of the
    transaction to Closing and dereferences the transaction block.  The
    block will be destroyed as soon as all other references to it are
    eliminated.

Arguments:

    Transaction - Supplies a pointer to the transaction block that is
        to be closed.

Return Value:

    None.

--*/

{
    PAGED_CODE( );

    ACQUIRE_LOCK( &Transaction->Connection->Lock );

    if ( GET_BLOCK_STATE(Transaction) == BlockStateActive ) {

        IF_DEBUG(BLOCK1) {
            SrvPrint1( "Closing transaction at %p\n", Transaction );
        }

        SET_BLOCK_STATE( Transaction, BlockStateClosing );

        RELEASE_LOCK( &Transaction->Connection->Lock );

        //
        // If the transaction request indicated that the tree connect
        // should be closed on completion, do so now.
        //

        if ( Transaction->Flags & SMB_TRANSACTION_DISCONNECT ) {
            SrvCloseTreeConnect( Transaction->TreeConnect );
        }

        //
        // Dereference the transaction (to indicate that it's no longer
        // open).
        //

        SrvDereferenceTransaction( Transaction );

        INCREMENT_DEBUG_STAT( SrvDbgStatistics.TransactionInfo.Closes );

    } else {

        RELEASE_LOCK( &Transaction->Connection->Lock );

    }

    return;

} // SrvCloseTransaction


VOID
SrvCloseTransactionsOnSession (
    PSESSION Session
    )

/*++

Routine Description:

    This routine closes all pending transactions that are "owned" by the
    specified session.  It walks the transaction list of the connection
    that owns the session.  Each transaction in that list that is owned
    by the session is closed.

Arguments:

    Session - Supplies a pointer to the session block for which
        transactions are to be closed.

Return Value:

    None.

--*/

{
    PCONNECTION connection;
    PPAGED_CONNECTION pagedConnection;
    PLIST_ENTRY entry;
    PTRANSACTION previousTransaction;
    PTRANSACTION transaction;

    PAGED_CODE( );

    //
    // Get the address of the owning connection.
    //

    connection = Session->Connection;
    pagedConnection = connection->PagedConnection;

    //
    // Walk the transaction list, looking for transactions owned by the
    // specified session.
    //
    // *** This routine is complicated by the following requirements:
    //
    //      1) We must hold the transaction lock while looking at the
    //         list, and we must ensure the integrity of the list as
    //         we walk it.
    //
    //      2) The transaction lock must NOT be held when closing or
    //         dereferencing a transaction, because its lock level is
    //         higher than that of other locks that may need to be
    //         taken out as a result of the close or dereference.
    //
    //     We work around these problems in the following way:
    //
    //      1) We hold the transaction lock while we search for a
    //         transaction to close.
    //
    //      2) We reference the transaction we're about to close, then
    //         release the lock.  This prevents someone else from
    //         invalidating the transaction after we release the lock
    //         but before we close it ourselves.
    //
    //      3) We close the transaction.  Our extra reference to the
    //         transaction prevents it from being deleted.  This also
    //         keeps it on the transaction list.
    //
    //      4) We retake the lock, find another transaction (using the
    //         previous transaction as a starting point), reference it,
    //         then release the lock.
    //
    //      5) We dereference the original transaction and go to step 3.
    //
    // Note that the loop below is NOT structured in exactly the same
    // way as the steps above are listed.
    //

    entry = &pagedConnection->TransactionList;
    previousTransaction = NULL;

    while ( TRUE ) {

        ACQUIRE_LOCK( &connection->Lock );

        //
        // Find a transaction that is owned by the specified session.
        //

        while ( TRUE ) {

            //
            // Get the address of the next list entry.  If we hit the
            // end of the list, exit the inner loop.
            //

            entry = entry->Flink;
            if ( entry == &pagedConnection->TransactionList ) break;

            //
            // Get the address of the transaction.  If it's owned by
            // the specified session and currently active, exit the
            // inner loop.  If it is closing don't touch it.
            //

            transaction = CONTAINING_RECORD(
                            entry,
                            TRANSACTION,
                            ConnectionListEntry
                            );

            if ( transaction->Session == Session &&
                 GET_BLOCK_STATE(transaction) == BlockStateActive) {

                 break;
            }

        }

        //
        // If we hit the end of the list without finding a transaction
        // that was owned by the specified session, exit the main loop.
        //

        if ( entry == &pagedConnection->TransactionList ) break;

        //
        // Reference the transaction to ensure that it isn't deleted
        // when we close it.
        //

        SrvReferenceTransaction( transaction );

        //
        // Unlock the transaction list, so that we can dereference the
        // previous transaction and close the current one.
        //

        RELEASE_LOCK( &connection->Lock );

        //
        // If this is not the first matching transaction that we've
        // found, dereference the previous one now.
        //

        if ( previousTransaction != NULL ) {
            SrvDereferenceTransaction( previousTransaction );
        }

        //
        // Close the current transaction and mark that we need to
        // dereference it.
        //

        SrvCloseTransaction( transaction );

        previousTransaction = transaction;

        //
        // Go find another matching transaction.
        //

    } // while ( TRUE )

    //
    // We have hit the end of the transaction list.  Release the
    // transaction lock.  If we have a transaction that needs to be
    // dereferenced, do so.  Then return to the caller.
    //

    RELEASE_LOCK( &connection->Lock );

    if ( previousTransaction != NULL ) {
        SrvDereferenceTransaction( previousTransaction );
    }

    return;

} // SrvCloseTransactionsOnSession


VOID
SrvCloseTransactionsOnTree (
    IN PTREE_CONNECT TreeConnect
    )

/*++

Routine Description:

    This routine closes all pending transactions that are "owned" by the
    specified tree connect.  It walks the transaction list of the
    connection that owns the tree connect.  Each transaction in that
    list that is owned by the tree connect is closed.

Arguments:

    TreeConnect - Supplies a pointer to the tree connect block for which
        transactions are to be closed.

Return Value:

    None.

--*/

{
    PCONNECTION connection;
    PPAGED_CONNECTION pagedConnection;
    PLIST_ENTRY entry;
    PTRANSACTION previousTransaction;
    PTRANSACTION transaction;

    PAGED_CODE( );

    //
    // Get the address of the owning connection.
    //

    connection = TreeConnect->Connection;
    pagedConnection = connection->PagedConnection;

    //
    // Walk the transaction list, looking for transactions owned by the
    // specified tree connect.
    //
    // *** See the description of SrvCloseTransactionsOnSession, which
    //     explains why this loop is so complicated.
    //

    entry = &pagedConnection->TransactionList;
    previousTransaction = NULL;

    while ( TRUE ) {

        ACQUIRE_LOCK( &connection->Lock );

        //
        // Find a transaction that is owned by the specified tree
        // connect.
        //

        while ( TRUE ) {

            //
            // Get the address of the next list entry.  If we hit the
            // end of the list, exit the inner loop.
            //

            entry = entry->Flink;
            if ( entry == &pagedConnection->TransactionList ) break;

            //
            // Get the address of the transaction.  If it's owned by
            // the specified tree connect and currently active, exit
            // the inner loop.
            //

            transaction = CONTAINING_RECORD(
                            entry,
                            TRANSACTION,
                            ConnectionListEntry
                            );
            if ( transaction->TreeConnect == TreeConnect &&
                  GET_BLOCK_STATE(transaction) == BlockStateActive) {

                  break;

            }

        }

        //
        // If we hit the end of the list without finding a transaction
        // that was owned by the specified tree connect, exit the main
        // loop.
        //

        if ( entry == &pagedConnection->TransactionList ) break;

        //
        // Reference the transaction to ensure that it isn't deleted
        // when we close it.
        //

        SrvReferenceTransaction( transaction );

        //
        // Unlock the transaction list, so that we can dereference the
        // previous transaction and close the current one.
        //

        RELEASE_LOCK( &connection->Lock );

        //
        // If this is not the first matching transaction that we've
        // found, dereference the previous one now.
        //

        if ( previousTransaction != NULL ) {
            SrvDereferenceTransaction( previousTransaction );
        }

        //
        // Close the current transaction and mark that we need to
        // dereference it.
        //

        SrvCloseTransaction( transaction );

        previousTransaction = transaction;

        //
        // Go find another matching transaction.
        //

    } // while ( TRUE )

    //
    // We have hit the end of the transaction list.  Release the
    // transaction lock.  If we have a transaction that needs to be
    // dereferenced, do so.  Then return to the caller.
    //

    RELEASE_LOCK( &connection->Lock );

    if ( previousTransaction != NULL ) {
        SrvDereferenceTransaction( previousTransaction );
    }

    return;

} // SrvCloseTransactionsOnTree


VOID
SrvDereferenceTransaction (
    IN PTRANSACTION Transaction
    )

/*++

Routine Description:

    This function decrements the reference count on a transaction.  If
    the reference count goes to zero, the transaction block is deleted.

Arguments:

    Transaction - Address of transaction

Return Value:

    None.

--*/

{
    PCONNECTION connection;
    LONG result;

    PAGED_CODE( );

    //
    // Decrement the reference count on the block.
    //

    connection = Transaction->Connection;

    IF_DEBUG(REFCNT) {
        SrvPrint2( "Dereferencing transaction %p; old refcnt %lx\n",
                    Transaction, Transaction->NonpagedHeader->ReferenceCount );
    }

    ASSERT( GET_BLOCK_TYPE( Transaction ) == BlockTypeTransaction );
    ASSERT( Transaction->NonpagedHeader->ReferenceCount > 0 );
    UPDATE_REFERENCE_HISTORY( Transaction, TRUE );

    result = InterlockedDecrement(
                &Transaction->NonpagedHeader->ReferenceCount
                );

    if ( result == 0 ) {

        //
        // The new reference count is 0, meaning that it's time to
        // delete this block.
        //
        // If the transaction is on the connection's pending transaction
        // list, remove it and dereference the connection, session, and
        // tree connect.  If the transaction isn't on the list, then the
        // session and tree connect pointers are not referenced
        // pointers, but just copies from the (single) work context
        // block associated with the transaction.
        //

        if ( Transaction->Inserted ) {

            ACQUIRE_LOCK( &connection->Lock );

            SrvRemoveEntryList(
                &connection->PagedConnection->TransactionList,
                &Transaction->ConnectionListEntry
                );

            RELEASE_LOCK( &connection->Lock );

            if ( Transaction->Session != NULL ) {
                SrvDereferenceSession( Transaction->Session );
                DEBUG Transaction->Session = NULL;
            }

            if ( Transaction->TreeConnect != NULL ) {
                SrvDereferenceTreeConnect( Transaction->TreeConnect );
                DEBUG Transaction->TreeConnect = NULL;
            }

        } else {

            DEBUG Transaction->Session = NULL;
            DEBUG Transaction->TreeConnect = NULL;

        }

        //
        // Free the transaction block, then release the transaction's
        // reference to the connection.  Note that we have to do the
        // dereference after calling SrvFreeConnection because that
        // routine may try to put the transaction on the connection's
        // cached transaction list.
        //

        SrvFreeTransaction( Transaction );

        SrvDereferenceConnection( connection );

    }

    return;

} // SrvDereferenceTransaction


VOID
SrvFreeTransaction (
    IN PTRANSACTION Transaction
    )

/*++

Routine Description:

    This function returns a Transaction block to the server heap.

Arguments:

    Transaction - Address of Transaction block

Return Value:

    None.

--*/

{
    ULONG blockSize;
    PCONNECTION connection;
    PNONPAGED_HEADER header;

    PAGED_CODE();

    blockSize = GET_BLOCK_SIZE( Transaction );

    DEBUG SET_BLOCK_TYPE_STATE_SIZE( Transaction, BlockTypeGarbage, BlockStateDead, -1 );
    DEBUG Transaction->NonpagedHeader->ReferenceCount = -1;
    TERMINATE_REFERENCE_HISTORY( Transaction );

    connection = Transaction->Connection;

    //
    // If the transaction was not allocated from the XACTSRV heap and
    // its block size is correct, cache this transaction instead of
    // freeing it back to pool.
    //

    header = Transaction->NonpagedHeader;

    if( Transaction->OutDataAllocated == TRUE ) {
        FREE_HEAP( Transaction->OutData );
        Transaction->OutData = NULL;
    }

    if ( !Transaction->RemoteApiRequest ) {

        if ( blockSize == CACHED_TRANSACTION_BLOCK_SIZE ) {
            //
            // Check the count of cached transactions on the connection.
            // If there aren't already enough transactions cached, link
            // this transaction to the list.  Otherwise, free the
            // transaction block.
            //

            if ( connection->CachedTransactionCount < CACHED_TRANSACTION_LIMIT ) {

                if ( connection->CachedTransactionCount < CACHED_TRANSACTION_LIMIT ) {

                    ExInterlockedPushEntrySList(
                        &connection->CachedTransactionList,
                        &header->ListEntry,
                        &connection->SpinLock
                        );
                    InterlockedIncrement( &connection->CachedTransactionCount );

                    return;
                }
            }
        }

        FREE_HEAP( Transaction );

    } else {

        SrvXsFreeHeap( Transaction );

    }

    DEALLOCATE_NONPAGED_POOL( header );

    IF_DEBUG(HEAP) {
        SrvPrint1( "SrvFreeTransaction: Freed transaction block at %p\n",
                    Transaction );
    }

    INCREMENT_DEBUG_STAT( SrvDbgStatistics.TransactionInfo.Frees );

    return;

} // SrvFreeTransaction
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\srv\copy.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    copy.c

Abstract:

    This module contains the routine to copy a file.

Author:

    David Treadwell (davidtr) 24-Jan-1990

Revision History:

--*/

#include "precomp.h"
#include "copy.tmh"
#pragma hdrstop

#define BugCheckFileId SRV_FILE_COPY

#ifdef ALLOC_PRAGMA
#pragma alloc_text( PAGE, SrvCopyFile )
#endif

#define EOF 0x1A                    // Control-Z == end of file


NTSTATUS
SrvCopyFile (
    IN HANDLE SourceHandle,
    IN HANDLE TargetHandle,
    IN USHORT SmbOpenFunction,
    IN USHORT SmbFlags,
    IN ULONG ActionTaken
    )

/*++

Routine Description:

    This routine copies or appends from the source file to the target file.
    It does the following:

        read sources EAs, attributes, size
        create/open target using source's info
        read data from source and write it to target

Arguments:

    SourceHandle - handle to source file opened with SRV_COPY_SOURCE_ACCESS
        for synchronous access.

    TargetHandle - handle to target file opened with SRV_COPY_SOURCE_ACCESS
        for synchronous access.

    SmbOpenFunction - used to determine whether the source should be
        appended to the end of the target.

    ActionTaken - Information field of IO status block from the NtCreateFile
        where the target was opened.  This is used to determine whether
        the target should be deleted if an error occurs.


Return Value:

    NTSTATUS - STATUS_SUCCESS or error.

--*/

{

    NTSTATUS status;
    NTSTATUS readStatus = STATUS_SUCCESS;
    NTSTATUS writeStatus = STATUS_SUCCESS;

    IO_STATUS_BLOCK ioStatusBlock;
    FILE_EA_INFORMATION eaInfo;
    SRV_NETWORK_OPEN_INFORMATION sourceNetworkOpenInformation;
    SRV_NETWORK_OPEN_INFORMATION targetNetworkOpenInformation;
    FILE_POSITION_INFORMATION positionInfo;
    FILE_ALLOCATION_INFORMATION allocationInfo;
    LARGE_INTEGER fileOffset;

    BOOLEAN append;
    BOOLEAN sourceIsAscii;
    BOOLEAN targetIsAscii;

    PCHAR ioBuffer;
    ULONG ioBufferSize;
    ULONG offset = 0;
    ULONG bytesRead;

    BOOLEAN eofFound = FALSE;
    CHAR lastByte;

    PAGED_CODE( );

    //
    // Find out if we are supposed to append to the target file or
    // overwrite it, and whether this is a binary or ASCII copy for
    // the source and target.  In a binary copy for the source, we stop
    // the first time we see EOF (control-Z).  In a binary copy for the
    // target, we must make sure that there is exactly one EOF in the
    // file and that this is the last character of the file.
    //

    append = SmbOfunAppend( SmbOpenFunction );
    sourceIsAscii = (BOOLEAN)((SmbFlags & SMB_COPY_SOURCE_ASCII) != 0);
    targetIsAscii = (BOOLEAN)((SmbFlags & SMB_COPY_TARGET_ASCII) != 0);

    //
    // Find the size of the EAs on the source.
    //

    status = NtQueryInformationFile(
                 SourceHandle,
                 &ioStatusBlock,
                 &eaInfo,
                 sizeof(eaInfo),
                 FileEaInformation
                 );

    if ( !NT_SUCCESS(status) ) {

        INTERNAL_ERROR(
            ERROR_LEVEL_UNEXPECTED,
            "SrvCopyFile: NtQueryInformationFile (source EA size) failed: %X",
            status,
            NULL
            );

        SrvLogServiceFailure( SRV_SVC_NT_QUERY_INFO_FILE, status );
        return status;
    }

    //
    // If the source file has EAs, get them and write them to the target
    // file.
    //

    if ( eaInfo.EaSize > 0 ) {

        PCHAR eaBuffer;
        ULONG eaBufferSize;

        //
        // Allocate a buffer large enough to hold the EAs.
        //
        //
        // HACKHACK: eaInfo.EaSize is the size needed by OS/2.  For NT,
        // the system has no way of telling us how big a buffer we need.
        // According to BrianAn, this should not be bigger than twice
        // what OS/2 needs.
        //

        eaBufferSize = eaInfo.EaSize * EA_SIZE_FUDGE_FACTOR;

        eaBuffer = ALLOCATE_NONPAGED_POOL( eaBufferSize, BlockTypeDataBuffer );
        if ( eaBuffer == NULL ) {

            INTERNAL_ERROR(
                ERROR_LEVEL_EXPECTED,
                "SrvCopyFile:  Unable to allocate %d bytes nonpaged pool",
                eaBufferSize,
                NULL
                );

            return STATUS_INSUFF_SERVER_RESOURCES;
        }

        status = SrvIssueQueryEaRequest(
                     SourceHandle,
                     eaBuffer,
                     eaBufferSize,
                     NULL,
                     0L,
                     FALSE,
                     NULL
                     );

        if ( NT_SUCCESS(status) ) {
            status = ioStatusBlock.Status;
        }

        if ( !NT_SUCCESS(status) ) {

            INTERNAL_ERROR(
                ERROR_LEVEL_UNEXPECTED,
                "SrvCopyFile: SrvIssueQueryEaRequest failed: %X",
                status,
                NULL
                );

            SrvLogServiceFailure( SRV_SVC_NT_QUERY_EAS, status );
            DEALLOCATE_NONPAGED_POOL( eaBuffer );
            return status;
        }

        status = SrvIssueSetEaRequest(
                     TargetHandle,
                     eaBuffer,
                     eaBufferSize,
                     NULL
                     );

        if ( NT_SUCCESS(status) ) {
            status = ioStatusBlock.Status;
        }

        if ( status == STATUS_EAS_NOT_SUPPORTED ||
                 status == STATUS_NOT_IMPLEMENTED ) {

            if ( SrvAreEasNeeded( (PFILE_FULL_EA_INFORMATION)eaBuffer ) ) {
                DEALLOCATE_NONPAGED_POOL( eaBuffer );
                return STATUS_EAS_NOT_SUPPORTED;
            }

            status = STATUS_SUCCESS;
        }

        DEALLOCATE_NONPAGED_POOL( eaBuffer );

        if ( !NT_SUCCESS(status) ) {

            INTERNAL_ERROR(
                ERROR_LEVEL_UNEXPECTED,
                "SrvCopyFile: SrvIssueSetEaRequest failed: %X",
                status,
                NULL
                );

            SrvLogServiceFailure( SRV_SVC_NT_SET_EAS, status );
            return status;
        }

    }

    //
    // Get the various attributes of the source file--size, times, etc.
    // These are used later on to set attributes of the target file.
    //

    status = SrvQueryNetworkOpenInformation(
                                            SourceHandle,
                                            NULL,
                                            &sourceNetworkOpenInformation,
                                            FALSE
                                            );

    if ( !NT_SUCCESS(status) ) {
        INTERNAL_ERROR(
            ERROR_LEVEL_UNEXPECTED,
            "SrvCopyFile: NtQueryInformationFile "
                "returned %X",
            status,
            NULL
            );

        SrvLogServiceFailure( SRV_SVC_NT_QUERY_INFO_FILE, status );
        return status;
    }

    //
    // If target was opened and we're in append mode, save the target's
    // original size and time and set target file pointer to the end of
    // the file.
    //

    if ( append ) {

        status = SrvQueryNetworkOpenInformation(
                                                TargetHandle,
                                                NULL,
                                                &targetNetworkOpenInformation,
                                                FALSE
                                                );

        if ( !NT_SUCCESS(status) ) {
            INTERNAL_ERROR(
                ERROR_LEVEL_UNEXPECTED,
                "SrvCopyFile: NtQueryInformationFile "
                    "for target returned %X",
                status,
                NULL
                );

            SrvLogServiceFailure( SRV_SVC_NT_QUERY_INFO_FILE, status );
            return status;
        }

        //
        // If the target is in ASCII mode, then see if the last character
        // of the target file is EOF (^Z).  If so, then set EndOfFile
        // such that this character will be overwritten.
        //

        if ( targetIsAscii && (targetNetworkOpenInformation.EndOfFile.QuadPart > 0) ) {

            LARGE_INTEGER fileOffset;

            fileOffset.QuadPart = targetNetworkOpenInformation.EndOfFile.QuadPart - 1;

            status = NtReadFile(
                         TargetHandle,
                         NULL,
                         NULL,
                         NULL,
                         &ioStatusBlock,
                         &lastByte,
                         sizeof(lastByte),
                         &fileOffset,
                         NULL
                         );

            if ( !NT_SUCCESS(status) ) {
                INTERNAL_ERROR(
                    ERROR_LEVEL_UNEXPECTED,
                    "SrvCopyFile: NtReadFile for target last byte"
                        "returned %X",
                    status,
                    NULL
                    );

                SrvLogServiceFailure( SRV_SVC_NT_READ_FILE, status );
                return status;
            }

            if ( lastByte == EOF ) {
                targetNetworkOpenInformation.EndOfFile = fileOffset;
            }
        }

        positionInfo.CurrentByteOffset = targetNetworkOpenInformation.EndOfFile;
        status = NtSetInformationFile(
                     TargetHandle,
                     &ioStatusBlock,
                     &positionInfo,
                     sizeof(positionInfo),
                     FilePositionInformation
                     );

        if ( !NT_SUCCESS(status) ) {
            INTERNAL_ERROR(
                ERROR_LEVEL_UNEXPECTED,
                "SrvCopyFile: NtSetInformationFile(position information)"
                    "for target returned %X",
                status,
                NULL
                );

            SrvLogServiceFailure( SRV_SVC_NT_SET_INFO_FILE, status );
            return status;
        }
    }

    //
    // Set the new size of the output file.  Doing this avoids forcing
    // the file system to automatically extend the file bit by bit.
    //

    if ( append ) {
        allocationInfo.AllocationSize.QuadPart =
            targetNetworkOpenInformation.EndOfFile.QuadPart +
            sourceNetworkOpenInformation.EndOfFile.QuadPart;
    } else {
        allocationInfo.AllocationSize = sourceNetworkOpenInformation.EndOfFile;
    }

    if ( 0 ) {
        KdPrint(( "SrvCopyFile: Setting allocation size of target to "
                    "%ld (0x%lx) bytes\n",
                    allocationInfo.AllocationSize.LowPart,
                    allocationInfo.AllocationSize.LowPart
                    ));
        KdPrint(( "             %ld (0x%lx) blocks + %ld (0x%lx) bytes\n",
                    allocationInfo.AllocationSize.LowPart / 512,
                    allocationInfo.AllocationSize.LowPart / 512,
                    allocationInfo.AllocationSize.LowPart % 512,
                    allocationInfo.AllocationSize.LowPart % 512
                    ));
    }

    status = NtSetInformationFile(
                 TargetHandle,
                 &ioStatusBlock,
                 &allocationInfo,
                 sizeof(allocationInfo),
                 FileAllocationInformation
                 );

    if ( !NT_SUCCESS(status) ) {
        INTERNAL_ERROR(
            ERROR_LEVEL_UNEXPECTED,
            "SrvCopyFile: NtSetInformationFile(allocation information)"
                "for target returned %X",
            status,
            NULL
            );

        SrvLogServiceFailure( SRV_SVC_NT_SET_INFO_FILE, status );
        return status;
    }

    //
    // Allocate a buffer from server heap to use for the data copy.
    //

    ioBufferSize = 4096;

    ioBuffer = ALLOCATE_HEAP_COLD( ioBufferSize, BlockTypeDataBuffer );
    if ( ioBuffer == NULL ) {
        INTERNAL_ERROR(
            ERROR_LEVEL_EXPECTED,
            "SrvCopyFile: Unable to allocate %d bytes from heap.",
            ioBufferSize,
            NULL
            );

        return STATUS_INSUFF_SERVER_RESOURCES;
    }

    //
    // Copy data--read from source, write to target.  Do this until
    // all the data is written or an error occurs.
    //

    fileOffset.QuadPart = (LONG)FILE_USE_FILE_POINTER_POSITION;

    while ( !eofFound ) {

        if ( 0 ) {
            KdPrint(( "SrvCopyFile: reading %ld (0x%lx) bytes at "
                        "offset %ld (0x%lx)\n",
                        ioBufferSize, ioBufferSize, offset, offset ));
        }

        readStatus = NtReadFile(
                         SourceHandle,
                         NULL,                // Event
                         NULL,                // ApcRoutine
                         NULL,                // ApcContext
                         &ioStatusBlock,
                         ioBuffer,
                         ioBufferSize,
                         &fileOffset,
                         NULL                 // Key
                         );

        if ( !NT_SUCCESS(readStatus) && readStatus != STATUS_END_OF_FILE ) {
            INTERNAL_ERROR(
                ERROR_LEVEL_UNEXPECTED,
                "SrvCopyFile: NtReadFile returned %X",
                readStatus,
                NULL
                );
            FREE_HEAP( ioBuffer );

            SrvLogServiceFailure( SRV_SVC_NT_READ_FILE, readStatus );
            return readStatus;
        }

        IF_SMB_DEBUG(FILE_CONTROL2) {
            KdPrint(( "NtReadFile:  Read %p bytes from source file\n",
                         (PVOID)ioStatusBlock.Information ));
        }
        if ( ioStatusBlock.Information == 0 ||
             readStatus == STATUS_END_OF_FILE ) {
            break;
        }

        bytesRead = (ULONG)ioStatusBlock.Information;
        if ( 0 ) {
            IO_STATUS_BLOCK iosb;

            status = NtQueryInformationFile(
                         SourceHandle,
                         &iosb,
                         &positionInfo,
                         sizeof(positionInfo),
                         FilePositionInformation
                         );

            if ( !NT_SUCCESS( status ) ) {
                INTERNAL_ERROR(
                    ERROR_LEVEL_UNEXPECTED,
                    "SrvCopyFile: NtQueryInformationFile returned %X",
                    status,
                    NULL
                    );

                FREE_HEAP( ioBuffer );

                SrvLogServiceFailure( SRV_SVC_NT_QUERY_INFO_FILE, status );
                return status;
            }

            if ( positionInfo.CurrentByteOffset.LowPart !=
                    offset + bytesRead ) {
                KdPrint(( "SrvCopyFile: SOURCE FILE POSITION NOT PROPERLY "
                            "UPDATED!!!\n" ));
                KdPrint(( "             expected %ld + %ld = %ld (0x%lx); ",
                            offset, bytesRead,
                            offset + bytesRead, offset + bytesRead ));
                KdPrint(( "got %ld (0x%lx)\n",
                            positionInfo.CurrentByteOffset.LowPart,
                            positionInfo.CurrentByteOffset.LowPart ));
            }
            KdPrint(( "SrvCopyFile: writing 0x%p bytes at offset %ld (0x%lx)\n",
                        (PVOID)ioStatusBlock.Information, 
                        offset, offset ));
        }

        //
        // If the source file is in ASCII mode, then search for EOF in the
        // buffer.  We copy until we hit the first EOF, at which point
        // we quit.
        //

        if ( sourceIsAscii ) {

            ULONG i;

            for ( i = 0; i < bytesRead; i++ ) {
                if ( ((PCHAR)ioBuffer)[i] == EOF ) {
                    bytesRead = i + 1;
                    eofFound = TRUE;
                    break;
                }
            }
        }

        //
        // Save the last byte read.  This is useful to make sure that
        // there is an EOF character if the target file is ASCII.
        //

        lastByte = ((PCHAR)ioBuffer)[bytesRead-1];

        writeStatus = NtWriteFile(
                          TargetHandle,
                          NULL,               // Event
                          NULL,               // ApcRoutine
                          NULL,               // ApcContext
                          &ioStatusBlock,
                          ioBuffer,
                          bytesRead,
                          &fileOffset,
                          NULL                // Key
                          );

        if ( !NT_SUCCESS(writeStatus) ) {
            INTERNAL_ERROR(
                ERROR_LEVEL_UNEXPECTED,
                "SrvCopyFile: NtWriteFile returned %X",
                writeStatus,
                NULL
                );
            FREE_HEAP( ioBuffer );

            SrvLogServiceFailure( SRV_SVC_NT_WRITE_FILE, writeStatus );
            return writeStatus;
        }

        IF_SMB_DEBUG(FILE_CONTROL2) {
            KdPrint(( "NtWriteFile:  wrote %p bytes to target file\n",
                          (PVOID)ioStatusBlock.Information ));
        }

        if ( 0 ) {
            IO_STATUS_BLOCK iosb;
            if ( ioStatusBlock.Information != bytesRead ) {
                KdPrint(( "SrvCopyFile: WRITE COUNT MISMATCH!!!\n" ));
                KdPrint(( "             Bytes read: %ld (0x%lx); Bytes written: 0x%p \n",
                            bytesRead, bytesRead,
                            (PVOID)ioStatusBlock.Information ));
            }
            status = NtQueryInformationFile(
                        SourceHandle,
                        &iosb,
                        &positionInfo,
                        sizeof(positionInfo),
                        FilePositionInformation
                        );

            if ( !NT_SUCCESS( status ) ) {
                INTERNAL_ERROR(
                    ERROR_LEVEL_UNEXPECTED,
                    "SrvCopyFile: NtQueryInformationFile returned %X",
                    status,
                    NULL
                    );
                FREE_HEAP( ioBuffer );

                SrvLogServiceFailure( SRV_SVC_NT_QUERY_INFO_FILE, status );
                return status;
            }

            if ( positionInfo.CurrentByteOffset.LowPart !=
                    offset + ioStatusBlock.Information ) {

                KdPrint(( "SrvCopyFile: TARGET FILE POSITION NOT PROPERLY "
                            "UPDATED!!!\n" ));
                KdPrint(( "             expected 0x%lx + 0x%p = 0x%p; ",
                            offset, (PVOID)(ioStatusBlock.Information),
                            (PVOID)(offset + ioStatusBlock.Information) ));
                KdPrint(( "got %ld (0x%lx)\n",
                            positionInfo.CurrentByteOffset.LowPart,
                            positionInfo.CurrentByteOffset.LowPart ));
            }
        }

        offset += bytesRead;

    }

    FREE_HEAP( ioBuffer );

    //
    // If target was created or replaced, set its time to that of the source.
    //

    if ( ActionTaken == FILE_CREATED || ActionTaken == FILE_SUPERSEDED ) {

        FILE_BASIC_INFORMATION basicInfo;

        basicInfo.CreationTime = sourceNetworkOpenInformation.CreationTime;
        basicInfo.LastAccessTime = sourceNetworkOpenInformation.LastAccessTime;
        basicInfo.LastWriteTime = sourceNetworkOpenInformation.LastWriteTime;
        basicInfo.ChangeTime = sourceNetworkOpenInformation.ChangeTime;
        basicInfo.FileAttributes = sourceNetworkOpenInformation.FileAttributes;

        status = NtSetInformationFile(
                     TargetHandle,
                     &ioStatusBlock,
                     &basicInfo,
                     sizeof(basicInfo),
                     FileBasicInformation
                     );

        if ( !NT_SUCCESS(status) ) {
            INTERNAL_ERROR(
                ERROR_LEVEL_UNEXPECTED,
                "SrvCopyFile: NtSetInformationFile(basic information) for"
                    "target returned %X",
                status,
                NULL
                );

            SrvLogServiceFailure( SRV_SVC_NT_SET_INFO_FILE, status );
            return status;
        }
    }

    //
    // If the target is ASCII and the last byte was not an EOF, then
    // put on an EOF character.
    //

    if ( targetIsAscii && lastByte != EOF ) {

        lastByte = EOF;

        status = NtWriteFile(
                     TargetHandle,
                     NULL,
                     NULL,
                     NULL,
                     &ioStatusBlock,
                     &lastByte,
                     sizeof(lastByte),
                     NULL,
                     NULL
                     );

        if ( !NT_SUCCESS(status) ) {
            INTERNAL_ERROR(
                ERROR_LEVEL_UNEXPECTED,
                "SrvCopyFile: NtWriteFile returned %X",
                status,
                NULL
                );

            SrvLogServiceFailure( SRV_SVC_NT_WRITE_FILE, status );
            return status;
        }
    }

    return STATUS_SUCCESS;

} // SrvCopyFile
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\srv\ea.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    ea.c

Abstract:

    This module contains various support routines for extended attributes.

Author:

    David Treadwell (davidtr) 5-Apr-1990

Revision History:

--*/

#include "precomp.h"
#include "ea.tmh"
#pragma hdrstop

#define BugCheckFileId SRV_FILE_EA

#ifdef ALLOC_PRAGMA
#pragma alloc_text( PAGE, SrvAreEasNeeded )
#pragma alloc_text( PAGE, SrvGetOs2FeaOffsetOfError )
#pragma alloc_text( PAGE, SrvGetOs2GeaOffsetOfError )
#pragma alloc_text( PAGE, SrvOs2FeaListToNt )
#pragma alloc_text( PAGE, SrvOs2FeaListSizeToNt )
#pragma alloc_text( PAGE, SrvOs2FeaToNt )
#pragma alloc_text( PAGE, SrvOs2GeaListToNt )
#pragma alloc_text( PAGE, SrvOs2GeaListSizeToNt )
#pragma alloc_text( PAGE, SrvOs2GeaToNt )
#pragma alloc_text( PAGE, SrvNtFullEaToOs2 )
#pragma alloc_text( PAGE, SrvGetNumberOfEasInList )
#pragma alloc_text( PAGE, SrvQueryOs2FeaList )
#pragma alloc_text( PAGE, SrvSetOs2FeaList )
#pragma alloc_text( PAGE, SrvConstructNullOs2FeaList )
#endif


BOOLEAN
SrvAreEasNeeded (
    IN PFILE_FULL_EA_INFORMATION NtFullEa
    )

/*++

Routine Description:

    This routine checks whether any of the full EAs in the list have the
    FILE_NEED_EA bit set in the flags field.

Arguments:

    NtFullEa - a pointer to a pointer to where the NT-style full EA list
        is stored.

Return Value:

    BOOLEAN - TRUE if any EA has FILE_NEED_EA set, FALSE otherwise.

--*/

{
    PFILE_FULL_EA_INFORMATION lastEa;

    PAGED_CODE( );

    do {

        if ( NtFullEa->Flags & FILE_NEED_EA ) {
            return TRUE;
        }

        lastEa = NtFullEa;
        NtFullEa = (PFILE_FULL_EA_INFORMATION)(
                       (PCHAR)NtFullEa + NtFullEa->NextEntryOffset );

    } while ( lastEa->NextEntryOffset != 0 );

    return FALSE;

} // SrvAreEasNeeded


USHORT
SrvGetOs2FeaOffsetOfError (
    IN ULONG NtErrorOffset,
    IN PFILE_FULL_EA_INFORMATION NtFullEa,
    IN PFEALIST FeaList
    )

/*++

Routine Description:

    Finds the offset in a FEALIST that corresponds to an offset into
    a list of FILE_FULL_EA_INFORMATION structures.  This is used when
    NtSetEaFile returns an offset to an EA that caused an error, and we
    need to return the offset into the list of EAs given to us by the
    client.

Arguments:

    NtErrorOffset - offset of the EA in the NT full EA list that caused
        the error.

    NtFullEa - a pointer to a pointer to where the NT-style full EA list
        is stored.  A buffer is allocated and pointer to by *NtFullEa.

    FeaList - pointer to the OS/2 1.2 FEALIST.

Return Value:

    USHORT - offset into the FEALIST.

--*/

{
    PFEA fea = FeaList->list;
    PFEA lastFeaStartLocation;
    PFILE_FULL_EA_INFORMATION offsetLocation;

    PAGED_CODE( );

    //
    // If the NT error offset is zero, return 0 for the FEA error offset.
    //
    // !!! this shouldn't be necessary if the loop below is written
    //     correctly.

    //if ( NtErrorOffset == 0 ) {
    //    return 0;
    //}

    //
    // Find where in the NT full EA list the error occurred and the
    // last possible start location for an FEA in the FEALIST.
    //

    offsetLocation = (PFILE_FULL_EA_INFORMATION)(
                         (PCHAR)NtFullEa + NtErrorOffset);
    lastFeaStartLocation = (PFEA)( (PCHAR)FeaList +
                               SmbGetUlong( &FeaList->cbList ) -
                               sizeof(FEA) - 1 );

    //
    // Walk through both lists simultaneously until one of three conditions
    // is true:
    //     - we reach or pass the offset in the NT full EA list
    //     - we reach the end of the NT full EA list
    //     - we reach the end of the FEALIST.
    //

    while ( NtFullEa < offsetLocation &&
            NtFullEa->NextEntryOffset != 0 &&
            fea <= lastFeaStartLocation ) {

        NtFullEa = (PFILE_FULL_EA_INFORMATION)(
                       (PCHAR)NtFullEa + NtFullEa->NextEntryOffset );
        fea = (PFEA)( (PCHAR)fea + sizeof(FEA) + fea->cbName + 1 +
                      SmbGetUshort( &fea->cbValue ) );
    }

    //
    // If NtFullEa is not equal to the offset location we calculated,
    // somebody messed up.
    //

    //ASSERT( NtFullEa == offsetLocation );

    return PTR_DIFF_SHORT(fea, FeaList );

} // SrvGetOs2FeaOffsetOfError


USHORT
SrvGetOs2GeaOffsetOfError (
    IN ULONG NtErrorOffset,
    IN PFILE_GET_EA_INFORMATION NtGetEa,
    IN PGEALIST GeaList
    )

/*++

Routine Description:

    Finds the offset in a GEALIST that corresponds to an offset into
    a list of FILE_GET_EA_INFORMATION structures.  This is used when
    NtQueryEaFile returns an offset to an EA that caused an error, and we
    need to return the offset into the list of EAs given to us by the
    client.

Arguments:

    NtErrorOffset - offset of the EA in the NT get EA list that caused
        the error.

    NtGetEa - a pointer to a pointer to where the NT-style get EA list
        is stored.  A buffer is allocated and pointer to by *NtGetEa.

    GeaList - pointer to the OS/2 1.2 GEALIST.

Return Value:

    USHORT - offset into the GEALIST.

--*/

{
    PGEA gea = GeaList->list;
    PGEA lastGeaStartLocation;
    PFILE_GET_EA_INFORMATION offsetLocation;

    PAGED_CODE( );

    //
    // Find where in the NT get EA list the error occurred and the
    // last possible start location for an GEA in the GEALIST.
    //

    offsetLocation = (PFILE_GET_EA_INFORMATION)((PCHAR)NtGetEa + NtErrorOffset);
    lastGeaStartLocation = (PGEA)( (PCHAR)GeaList +
                               SmbGetUlong( &GeaList->cbList ) - sizeof(GEA) );


    //
    // Walk through both lists simultaneously until one of three conditions
    // is true:
    //     - we reach or pass the offset in the NT full EA list
    //     - we reach the end of the NT get EA list
    //     - we reach the end of the GEALIST.
    //

    while ( NtGetEa < offsetLocation &&
            NtGetEa->NextEntryOffset != 0 &&
            gea <= lastGeaStartLocation ) {

        NtGetEa = (PFILE_GET_EA_INFORMATION)(
                      (PCHAR)NtGetEa + NtGetEa->NextEntryOffset );
        gea = (PGEA)( (PCHAR)gea + sizeof(GEA) + gea->cbName );
    }

    //
    // If NtGetEa is not equal to the offset location we calculated,
    // somebody messed up.
    //

//    ASSERT( NtGetEa == offsetLocation );

    return PTR_DIFF_SHORT(gea, GeaList);

} // SrvGetOs2GeaOffsetOfError


NTSTATUS
SrvOs2FeaListToNt (
    IN PFEALIST FeaList,
    OUT PFILE_FULL_EA_INFORMATION *NtFullEa,
    OUT PULONG BufferLength,
    OUT PUSHORT EaErrorOffset
    )

/*++

Routine Description:

    Converts a list of OS/2 1.2 FEAs to NT style.  Memory is allocated from
    non-paged pool to hold the NT full EA list.  The calling routine is
    responsible for deallocating this memory when it is done with it.

    WARNING!  It is the responsibility of the calling routine to ensure
    that the value in FeaList->cbList will fit within the buffer allocated
    to FeaList.  This prevents malicious redirectors from causing an
    access violation in the server.

Arguments:

    FeaList - pointer to the OS/2 1.2 FEALIST to convert.

    NtFullEa - a pointer to a pointer to where the NT-style full EA list
        is stored.  A buffer is allocated and pointer to by *NtFullEa.

    BufferLength - length of the allocated buffer.


Return Value:

    NTSTATUS - STATUS_SUCCESS or STATUS_INSUFF_SERVER_RESOURCES.

--*/

{
    PFEA lastFeaStartLocation;
    PFEA fea = NULL;
    PFEA lastFea = NULL;
    PFILE_FULL_EA_INFORMATION ntFullEa = NULL;
    PFILE_FULL_EA_INFORMATION lastNtFullEa = NULL;

    PAGED_CODE( );

    //
    // Find out how large the OS/2 1.2 FEALIST will be after it is
    // converted to NT format.  This is necessary in order to
    // determine how large a buffer to allocate to receive the NT
    // EAs.
    //

    *BufferLength = SrvOs2FeaListSizeToNt( FeaList );

    //
    // It is possible for SrvOs2FeaListSizeToNt to return 0 in the event
    // that the very first FEA in the list is corrupt.  Return an error
    // if this is the case with an appropriate EaErrorOffset value.
    //

    if (*BufferLength == 0) {
        *EaErrorOffset = 0;
        return STATUS_OS2_EA_LIST_INCONSISTENT;
    }

    //
    // Allocate a buffer to hold the NT list.  This is allocated from
    // non-paged pool so that it may be used in IRP-based IO requests.
    //

    *NtFullEa = ALLOCATE_NONPAGED_POOL( *BufferLength, BlockTypeDataBuffer );

    if ( *NtFullEa == NULL ) {
        INTERNAL_ERROR(
            ERROR_LEVEL_EXPECTED,
            "SrvOs2FeaListToNt: Unable to allocate %d bytes from nonpaged "
                "pool.",
            *BufferLength,
            NULL
            );

        return STATUS_INSUFF_SERVER_RESOURCES;
    }

    //
    // Find the last location at which an FEA can start.  The -1 is to
    // account for the zero terminator on the name field of the FEA.
    //

    lastFeaStartLocation = (PFEA)( (PCHAR)FeaList +
                               SmbGetUlong( &FeaList->cbList ) -
                               sizeof(FEA) - 1 );

    //
    // Go through the FEA list, converting from OS/2 1.2 format to NT
    // until we pass the last possible location in which an FEA can start.
    //

    for ( fea = FeaList->list, ntFullEa = *NtFullEa, lastNtFullEa = ntFullEa;
          fea <= lastFeaStartLocation;
          fea = (PFEA)( (PCHAR)fea + sizeof(FEA) +
                        fea->cbName + 1 + SmbGetUshort( &fea->cbValue ) ) ) {

        //
        // Check for an invalid flag bit.  If set, return an error.
        //

        if ( (fea->fEA & ~FEA_NEEDEA) != 0 ) {
            *EaErrorOffset = PTR_DIFF_SHORT(fea, FeaList);
            DEALLOCATE_NONPAGED_POOL( *NtFullEa );
            return STATUS_INVALID_PARAMETER;
        }

        lastNtFullEa = ntFullEa;
        lastFea = fea;
        ntFullEa = SrvOs2FeaToNt( ntFullEa, fea );
    }

    //
    // Make sure that the FEALIST size parameter was correct.  If we ended
    // on an EA that was not the first location after the end of the
    // last FEA, then the size parameter was wrong.  Return an offset to
    // the EA that caused the error.
    //

    if ( (PCHAR)fea != (PCHAR)FeaList + SmbGetUlong( &FeaList->cbList ) ) {
        *EaErrorOffset = PTR_DIFF_SHORT(lastFea, FeaList);
        DEALLOCATE_NONPAGED_POOL( *NtFullEa );
        return STATUS_UNSUCCESSFUL;
    }

    //
    // Set the NextEntryOffset field of the last full EA to 0 to indicate
    // the end of the list.
    //

    lastNtFullEa->NextEntryOffset = 0;

    return STATUS_SUCCESS;

} // SrvOs2FeaListToNt


ULONG
SrvOs2FeaListSizeToNt (
    IN PFEALIST FeaList
    )

/*++

Routine Description:

    Get the number of bytes that would be required to represent the
    FEALIST in NT format.

    WARNING: This routine makes no checks on the size of the FEALIST
    buffer.  It is assumed that FeaList->cbList is a legitimate value.

    WARNING: The value returned by this routine may be as much as three
    higher than the actual size needed to hold the FEAs in NT format.
    See comments below.

Arguments:

    Fea - a pointer to the list of FEAs.

Return Value:

    ULONG - number of bytes required to hold the EAs in NT format.

--*/

{
    ULONG size = 0;

    PCHAR lastValidLocation;
    PCHAR variableBuffer;
    PFEA  fea;

    PAGED_CODE( );

    //
    // Find the last valid location in the FEA buffer.
    //

    lastValidLocation = (PCHAR)FeaList + SmbGetUlong( &FeaList->cbList );

    //
    // Go through the FEA list until we pass the last location
    //   indicated in the buffer.
    //

    for ( fea = FeaList->list;
          fea < (PFEA)lastValidLocation;
          fea = (PFEA)( (PCHAR)fea + sizeof(FEA) +
                          fea->cbName + 1 + SmbGetUshort( &fea->cbValue ) ) ) {

        //
        //  Be very careful accessing the embedded FEA since there are so many possibly
        //    conflicting sizes running around here.  The first part of the conditional
        //    below makes sure that the cbName and cbValue fields of the FEA buffer can
        //    actually be dereferenced.  The second part verifies that they contain
        //    reasonable values.
        //

        variableBuffer = (PCHAR)fea + sizeof(FEA);

        if (variableBuffer >= lastValidLocation ||
            (variableBuffer + fea->cbName + 1 + SmbGetUshort(&fea->cbValue)) > lastValidLocation) {

            //
            //  The values in this part of the buffer indicate a range outside the
            //    buffer.  Don't calculate a size, and shrink the cbList value to
            //    include only the prior FEA.
            //

            SmbPutUshort( &FeaList->cbList, PTR_DIFF_SHORT(fea, FeaList) );
            break;

        }

        //
        // SmbGetNtSizeOfFea returns the number of bytes needed to hold
        // a single FEA in NT format, including any padding needed for
        // longword-alignment.  Since the size of the buffer needed to
        // hold the NT EA list does not include any padding after the
        // last EA, the value returned by this routine may be as much as
        // three higher than the size actually needed.
        //

        size += SmbGetNtSizeOfFea( fea );
    }

    return size;

} // SrvOs2FeaListSizeToNt


PVOID
SrvOs2FeaToNt (
    OUT PFILE_FULL_EA_INFORMATION NtFullEa,
    IN PFEA Fea
    )

/*++

Routine Description:

    Converts a single OS/2 FEA to NT full EA style.  The FEA need not have
    any particular alignment.  This routine makes no checks on buffer
    overrunning--this is the responsibility of the calling routine.

Arguments:

    NtFullEa - a pointer to where the NT full EA is to be written.

    Fea - pointer to the OS/2 1.2 FEA to convert.

Return Value:

    A pointer to the location after the last byte written.

--*/

{
    PCHAR ptr;

    PAGED_CODE( );

    NtFullEa->Flags = Fea->fEA;
    NtFullEa->EaNameLength = Fea->cbName;
    NtFullEa->EaValueLength = SmbGetUshort( &Fea->cbValue );

    ptr = NtFullEa->EaName;
    RtlMoveMemory( ptr, (PVOID)(Fea+1), Fea->cbName );

    ptr += NtFullEa->EaNameLength;
    *ptr++ = '\0';

    //
    // Copy the EA value to the NT full EA.
    //

    RtlMoveMemory(
        ptr,
        (PCHAR)(Fea+1) + NtFullEa->EaNameLength + 1,
        NtFullEa->EaValueLength
        );

    ptr += NtFullEa->EaValueLength;

    //
    // Longword-align ptr to determine the offset to the next location
    // for an NT full EA.
    //

    ptr = (PCHAR)( ((ULONG_PTR)ptr + 3) & ~3 );
    NtFullEa->NextEntryOffset = (ULONG)( ptr - (PCHAR)NtFullEa );

    return ptr;

} // SrvOs2FeaToNt


NTSTATUS
SrvOs2GeaListToNt (
    IN PGEALIST GeaList,
    OUT PFILE_GET_EA_INFORMATION *NtGetEa,
    OUT PULONG BufferLength,
    OUT PUSHORT EaErrorOffset
    )

/*++

Routine Description:

    Converts a list of OS/2 1.2 GEAs to NT style.  Memory is allocated from
    non-paged pool to hold the NT get EA list.  The calling routine is
    responsible for deallocating this memory when it is done with it.

    WARNING!  It is the responsibility of the calling routine to ensure
    that the value in GeaList->cbList will fit within the buffer allocated
    to GeaList.  This prevents malicious redirectors from causing an
    access violation in the server.

Arguments:

    GeaList - pointer to the OS/2 1.2 GEALIST to convert.

    NtGetEa - a pointer to a pointer to where the NT-style get EA list
        is stored.  A buffer is allocated and pointer to by *NtGetEa.

    BufferLength - length of the allocated buffer.

Return Value:

    NTSTATUS - STATUS_SUCCESS or STATUS_INSUFF_SERVER_RESOURCES.

--*/

{
    PGEA lastGeaStartLocation;
    PGEA gea = NULL;
    PGEA lastGea = NULL;
    PFILE_GET_EA_INFORMATION ntGetEa = NULL;
    PFILE_GET_EA_INFORMATION lastNtGetEa = NULL;

    PAGED_CODE( );

    //
    // Find out how large the OS/2 1.2 GEALIST will be after it is
    // converted to NT format.  This is necessary in order to
    // determine how large a buffer to allocate to receive the NT
    // EAs.
    //

    *BufferLength = SrvOs2GeaListSizeToNt( GeaList );

    if ( *BufferLength == 0 ) {
        *EaErrorOffset = 0;
        return STATUS_OS2_EA_LIST_INCONSISTENT;
    }

    //
    // Allocate a buffer to hold the NT list.  This is allocated from
    // non-paged pool so that it may be used in IRP-based IO requests.
    //

    *NtGetEa = ALLOCATE_NONPAGED_POOL( *BufferLength, BlockTypeDataBuffer );

    if ( *NtGetEa == NULL ) {
        INTERNAL_ERROR(
            ERROR_LEVEL_EXPECTED,
            "SrvOs2GeaListToNt: Unable to allocate %d bytes from nonpaged "
                "pool.",
            *BufferLength,
            NULL
            );

        return STATUS_INSUFF_SERVER_RESOURCES;
    }

    //
    // Find the last location at which a GEA can start.  The zero
    // terminator on the name field of the GEA is accounted for by the
    // szName[0] field in the GEA structure.
    //

    lastGeaStartLocation = (PGEA)( (PCHAR)GeaList +
                               SmbGetUlong( &GeaList->cbList ) - sizeof(GEA) );

    //
    // Go through the GEA list, converting from OS/2 1.2 format to NT
    // until we pass the last possible location in which an GEA can start.
    //

    for ( gea = GeaList->list, ntGetEa = *NtGetEa, lastNtGetEa = ntGetEa;
          gea <= lastGeaStartLocation;
          gea = (PGEA)( (PCHAR)gea + sizeof(GEA) + gea->cbName ) ) {

        lastNtGetEa = ntGetEa;
        lastGea = gea;
        ntGetEa = SrvOs2GeaToNt( ntGetEa, gea );
    }

    //
    // Make sure that the GEALIST size parameter was correct.  If we ended
    // on an EA that was not the first location after the end of the
    // last GEA, then the size parameter was wrong.  Return an offset to
    // the EA that caused the error.
    //

    if ( (PCHAR)gea != (PCHAR)GeaList + SmbGetUlong( &GeaList->cbList ) ) {
        DEALLOCATE_NONPAGED_POOL(*NtGetEa);
        *EaErrorOffset = PTR_DIFF_SHORT(lastGea, GeaList);
        return STATUS_UNSUCCESSFUL;
    }

    //
    // Set the NextEntryOffset field of the last get EA to 0 to indicate
    // the end of the list.
    //

    lastNtGetEa->NextEntryOffset = 0;

    return STATUS_SUCCESS;

} // SrvOs2GeaListToNt


ULONG
SrvOs2GeaListSizeToNt (
    IN PGEALIST GeaList
    )

/*++

Routine Description:

    Get the number of bytes that would be required to represent the
    GEALIST in NT format.

    WARNING: This routine makes no checks on the size of the GEALIST
    buffer.  It is assumed that GeaList->cbList is a legitimate value.

    WARNING: The value returned by this routine may be as much as three
    higher than the actual size needed to hold the GEAs in NT format.
    See comments below.

Arguments:

    Gea - a pointer to the list of GEAs.

    Size - number of bytes required to hold the EAs in NT format.

Return Value:

    NTSTATUS - STATUS_SUCCESS or STATUS_BUFFER_OVERFLOW if the GEA list was
        larger than it's buffer.

--*/

{
    ULONG size = 0;

    PCHAR lastValidLocation;
    PCHAR variableBuffer;
    PGEA gea;

    PAGED_CODE( );

    //
    // Find the last location in the GEA buffer.
    //

    lastValidLocation = (PCHAR)GeaList + SmbGetUlong( &GeaList->cbList );


    //
    // Go through the GEA list until we pass the last possible location
    // in which an GEA can start.
    //

    for ( gea = GeaList->list;
          gea < (PGEA)lastValidLocation;
          gea = (PGEA)( (PCHAR)gea + sizeof(GEA) + gea->cbName ) ) {

        //
        //  Be very careful accessing the embedded GEA.  The first part of the conditional
        //    below makes sure that the cbName field of the GEA buffer can
        //    actually be dereferenced.  The second part verifies that it contains
        //    reasonable values.
        //

        variableBuffer = (PCHAR)gea + sizeof(GEA);

        if ( variableBuffer >= lastValidLocation ||
             variableBuffer + gea->cbName > lastValidLocation ) {

           //
           //  If there's a bogus value in the buffer stop processing the size
           //    and reset the cbList value to only enclose the previous GEA.
           //

           SmbPutUshort(&GeaList->cbList, PTR_DIFF_SHORT(gea, GeaList));
           break;

        }


        //
        // SmbGetNtSizeOfGea returns the number of bytes needed to hold
        // a single GEA in NT format.  This includes any padding needed
        // for longword-alignment.  Since the size of the buffer needed
        // to hold the NT EA list does not include any padding after the
        // last EA, the value returned by this routine may be as much as
        // three higher than the size actually needed.
        //

        size += SmbGetNtSizeOfGea( gea );
    }

    return size;

} // SrvOs2GeaListSizeToNt


PVOID
SrvOs2GeaToNt (
    OUT PFILE_GET_EA_INFORMATION NtGetEa,
    IN PGEA Gea
    )

/*++

Routine Description:

    Converts a single OS/2 GEA to NT get EA style.  The GEA need not have
    any particular alignment.  This routine makes no checks on buffer
    overrunning--this is the responsibility of the calling routine.

Arguments:

    NtGetEa - a pointer to where the NT get EA is to be written.

    Gea - pointer to the OS/2 1.2 GEA to convert.

Return Value:

    A pointer to the location after the last byte written.

--*/

{
    PCHAR ptr;

    PAGED_CODE( );

    NtGetEa->EaNameLength = Gea->cbName;

    ptr = NtGetEa->EaName;
    RtlMoveMemory( ptr, Gea->szName, Gea->cbName );

    ptr += NtGetEa->EaNameLength;
    *ptr++ = '\0';

    //
    // Longword-align ptr to determine the offset to the next location
    // for an NT full EA.
    //

    ptr = (PCHAR)( ((ULONG_PTR)ptr + 3) & ~3 );
    NtGetEa->NextEntryOffset = (ULONG)( ptr - (PCHAR)NtGetEa );

    return ptr;

} // SrvOs2GeaToNt


PVOID
SrvNtFullEaToOs2 (
    OUT PFEA Fea,
    IN PFILE_FULL_EA_INFORMATION NtFullEa
    )

/*++

Routine Description:

    Converts a single NT full EA to OS/2 FEA style.  The FEA need not have
    any particular alignment.  This routine makes no checks on buffer
    overrunning--this is the responsibility of the calling routine.

Arguments:

    Fea - a pointer to the location where the OS/2 FEA is to be written.

    NtFullEa - a pointer to the NT full EA.

Return Value:

    A pointer to the location after the last byte written.

--*/

{
    PCHAR ptr;
    ULONG i;

    PAGED_CODE( );

    Fea->fEA = (UCHAR)NtFullEa->Flags;
    Fea->cbName = NtFullEa->EaNameLength;
    SmbPutUshort( &Fea->cbValue, NtFullEa->EaValueLength );

    //
    // Copy the attribute name.
    //

    for ( i = 0, ptr = (PCHAR) (Fea + 1);
          i < (ULONG) NtFullEa->EaNameLength;
          i++, ptr++) {

        *ptr = RtlUpperChar( NtFullEa->EaName[i] );

    }

    *ptr++ = '\0';

    RtlMoveMemory(
        ptr,
        NtFullEa->EaName + NtFullEa->EaNameLength + 1,
        NtFullEa->EaValueLength
        );

    return (ptr + NtFullEa->EaValueLength);

} // SrvNtFullEaToOs2


CLONG
SrvGetNumberOfEasInList (
    IN PVOID List
    )

/*++

Routine Description:

    Finds the number of EAs in an NT get or full EA list.  The list
    should have already been verified to be legitimate to prevent access
    violations.

Arguments:

    List - a pointer to the NT get or full EA list.

Return Value:

    CLONG - the number of EAs in the list.

--*/

{
    CLONG count = 1;
    PULONG ea;

    PAGED_CODE( );

    //
    // Walk through the list.  The first longword of each EA is the offset
    // to the next EA.
    //

    for ( ea = List; *ea != 0; ea = (PULONG)( (PCHAR)ea + *ea ) ) {
        count++;
    }

    return count;

} // SrvGetNumberOfEasInList


NTSTATUS
SrvQueryOs2FeaList (
    IN HANDLE FileHandle,
    IN PGEALIST GeaList OPTIONAL,
    IN PFILE_GET_EA_INFORMATION NtGetEaList OPTIONAL,
    IN ULONG GeaListLength OPTIONAL,
    IN PFEALIST FeaList,
    IN ULONG BufferLength,
    OUT PUSHORT EaErrorOffset
    )

/*++

Routine Description:

    Converts a single NT full EA list to OS/2 FEALIST style.  The FEALIST
    need not have any particular alignment.

Arguments:

    FileHandle - handle to a file open with FILE_READ_EA access.

    GeaList - if non-NULL, an OS/2 1.2 style GEALIST used to get only
        a subset of the files EAs rather than all the EAs.  Only the
        EAs listed in GEALIST are returned.

    NtGetEaList - if non-NULL, an NT style get EA list used to get only
        a subset of the files EAs rather than all the EAs.  Only the
        EAs listed in GEALIST are returned.

    GeaListLength - the maximum possible length of the GeaList (used to
        prevent access violations) or the actual size of the NtGetEaList.

    FeaList - where to write the OS/2 1.2 style FEALIST for the file.

    BufferLength - length of Buffer.

Return Value:

    NTSTATUS - STATUS_SUCCESS, STATUS_BUFFER_OVERFLOW if the EAs wouldn't
        fit in Buffer, or a value returned by NtQuery{Information,Ea}File.

--*/

{
    NTSTATUS status;

    PFEA fea = FeaList->list;
    PFILE_FULL_EA_INFORMATION ntFullEa;

    PFILE_GET_EA_INFORMATION ntGetEa = NULL;
    ULONG ntGetEaBufferLength = 0;

    FILE_EA_INFORMATION eaInfo;
    IO_STATUS_BLOCK ioStatusBlock;

    PSRV_EA_INFORMATION eaInformation = NULL;
    ULONG eaBufferSize;
    ULONG errorOffset;

    BOOLEAN isFirstCall = TRUE;

    PAGED_CODE( );

    *EaErrorOffset = 0;

    //
    // Find out how big a buffer we need to get the EAs.
    //

    status = NtQueryInformationFile(
                 FileHandle,
                 &ioStatusBlock,
                 &eaInfo,
                 sizeof(FILE_EA_INFORMATION),
                 FileEaInformation
                 );

    if ( !NT_SUCCESS(status) ) {
        INTERNAL_ERROR(
            ERROR_LEVEL_UNEXPECTED,
            "SrvQueryOs2FeaList: NtQueryInformationFile(ea information) "
                "returned %X",
            status,
            NULL
            );

        SrvLogServiceFailure( SRV_SVC_NT_QUERY_INFO_FILE, status );
        goto exit;
    }

    //
    // If the file has no EAs, return an FEA size = 4 (that's what OS/2
    // does--it accounts for the size of the cbList field of an
    // FEALIST).  Also, store the NT EA size in case there is a buffer
    // overflow and we need to return the total EA size to the client.
    //

    if ( eaInfo.EaSize == 0 ) {
        SmbPutUlong( &FeaList->cbList, 4 );
    } else {
        SmbPutUlong( &FeaList->cbList, eaInfo.EaSize );
    }

    if ( eaInfo.EaSize == 0 && GeaList == NULL && NtGetEaList == NULL ) {
        status = STATUS_SUCCESS;
        goto exit;
    }

    //
    // If a GEALIST was specified, convert it to NT style.
    //

    if ( ARGUMENT_PRESENT(GeaList) ) {

        //
        // Make sure that the value in GeaList->cbList is legitimate
        // (allows the GEALIST to fit within its buffer).
        //

        if ( GeaListLength < sizeof(GEALIST) ||
             SmbGetUlong( &GeaList->cbList ) < sizeof(GEALIST) ||
             SmbGetUlong( &GeaList->cbList ) > GeaListLength ) {
            status = STATUS_OS2_EA_LIST_INCONSISTENT;
            goto exit;
        }

        //
        // Convert the GEALIST to NT style.  SrvOs2GeaListToNt allocates
        // space to hold the NT get EA list, so remember to deallocate
        // this before exiting this routine.
        //

        status = SrvOs2GeaListToNt(
                     GeaList,
                     &ntGetEa,
                     &ntGetEaBufferLength,
                     EaErrorOffset
                     );

        if ( !NT_SUCCESS(status) ) {
            return status;
        }
    }

    //
    // If an NT-style get EA list was specified, use it.
    //

    if ( ARGUMENT_PRESENT(NtGetEaList) ) {
        ntGetEa = NtGetEaList;
        ntGetEaBufferLength = GeaListLength;
    }

    //
    // HACKHACK: eaInfo.EaSize is the size needed by OS/2.  For NT,
    // the system has no way of telling us how big a buffer we need.
    // According to BrianAn, this should not be bigger than twice
    // what OS/2 needs.
    //

    eaBufferSize = eaInfo.EaSize * EA_SIZE_FUDGE_FACTOR;

    //
    // If a get EA list was specified, a larger buffer is needed to hold
    // all the EAs.  This is because some or all of the specified EAs
    // may not exist, yet they will still be returned by the file system
    // with value length = 0.  Add to the EA size the amount of space the
    // get EA list would use if it were converted to a full EA list.
    //

    if ( ntGetEa != NULL ) {
        eaBufferSize += ntGetEaBufferLength +
                             ( SrvGetNumberOfEasInList( ntGetEa ) *
                              ( sizeof(FILE_FULL_EA_INFORMATION) -
                                sizeof(FILE_GET_EA_INFORMATION) ));
    }

    //
    // Allocate a buffer to receive the EAs.  If the total EA size is
    // small enough to get it all in one call to NtQueryEaFile, allocate
    // a buffer that large.  If The EAs are large, use a buffer size that
    // is the smallest size guaranteed to hold at least one EA.
    //
    // The buffer must be allocated from non-paged pool for the IRP
    // request built below.
    //

    eaBufferSize = MIN( MAX_SIZE_OF_SINGLE_EA, eaBufferSize ) +
                       sizeof(SRV_EA_INFORMATION);

    eaInformation = ALLOCATE_NONPAGED_POOL( eaBufferSize, BlockTypeDataBuffer );

    if ( eaInformation == NULL ) {
        INTERNAL_ERROR(
            ERROR_LEVEL_EXPECTED,
            "SrvQueryOs2FeaList: Unable to allocate %d bytes from nonpaged "
                "pool.",
            eaBufferSize,
            NULL
            );

        status = STATUS_INSUFF_SERVER_RESOURCES;
        goto exit;
    }

    //
    // Get the EAs.
    //

    while(1) {

        ULONG feaSize;

        status = SrvQueryEaFile(
                     isFirstCall,
                     FileHandle,
                     ntGetEa,
                     ntGetEaBufferLength,
                     eaInformation,
                     eaBufferSize,
                     &errorOffset
                     );

        if ( status == STATUS_NO_MORE_EAS ) {
            break;
        }

        if ( !NT_SUCCESS(status) ) {

            if ( ARGUMENT_PRESENT(GeaList) ) {
                *EaErrorOffset = SrvGetOs2GeaOffsetOfError(
                                     errorOffset,
                                     ntGetEa,
                                     GeaList
                                     );
                //
                // SrvQueryEaFile has already logged the error.  Do not
                // create another log entry here.
                //

                IF_DEBUG(SMB_ERRORS) {
                    PGEA errorGea = (PGEA)( (PCHAR)GeaList + *EaErrorOffset );
                    SrvPrint1( "EA error offset in GEALIST: 0x%lx\n", *EaErrorOffset );
                    SrvPrint1( "name: %s\n", errorGea->szName );
                }
            }

            goto exit;
        }

        isFirstCall = FALSE;
        ntFullEa = eaInformation->CurrentEntry;

        //
        // See if there is enough room to hold the EA in the user buffer.
        //
        // *** STATUS_BUFFER_OVERFLOW is a special status code for the
        //     find2 logic.  See that code before making changes here.

        feaSize = SmbGetOs2SizeOfNtFullEa( ntFullEa );
        if ( feaSize > (ULONG)( (PCHAR)FeaList + BufferLength - (PCHAR)fea ) ) {
            status = STATUS_BUFFER_OVERFLOW;
            goto exit;
        }

        //
        // Copy the NT format EA to OS/2 1.2 format and set the fea
        // pointer for the next iteration.
        //

        fea = SrvNtFullEaToOs2( fea, ntFullEa );

        ASSERT( (ULONG_PTR)fea <= (ULONG_PTR)FeaList + BufferLength );
    }

    //
    // Set the number of bytes in the FEALIST.
    //

    SmbPutUlong(
        &FeaList->cbList,
        PTR_DIFF(fea, FeaList)
        );

    status = STATUS_SUCCESS;

exit:
    //
    // Deallocate the buffers used to hold the NT get and full EA lists.
    //

    if ( ntGetEa != NULL && ARGUMENT_PRESENT(GeaList) ) {
        DEALLOCATE_NONPAGED_POOL( ntGetEa );
    }

    if ( eaInformation != NULL ) {
        DEALLOCATE_NONPAGED_POOL( eaInformation );
    }

    return status;

} // SrvQueryOs2FeaList


NTSTATUS
SrvSetOs2FeaList (
    IN HANDLE FileHandle,
    IN PFEALIST FeaList,
    IN ULONG BufferLength,
    OUT PUSHORT EaErrorOffset
    )

/*++

Routine Description:

    Sets the EAs on a file given an OS/2 1.2 representation of the EAs.

Arguments:

    FileHandle - handle to a file open with FILE_WRITE_EA access whose
        EAs are to be set.

    FeaList - a pointer to the location where the OS/2 FEALIST is stored.

    BufferLength - maximum size of the buffer the FEALIST structure can
        have.  This is used to prevent a malicious redirector from causing
        an access violation in the server.

Return Value:

    NTSTATUS - what happened

--*/

{
    NTSTATUS status;

    PFILE_FULL_EA_INFORMATION ntFullEa;
    ULONG ntFullEaBufferLength;
    ULONG errorOffset;

    PAGED_CODE( );

    *EaErrorOffset = 0;

    //
    // Special case for too-small FEALIST: don't set anything.
    // sizeof(FEALIST) will cover the buffer size and one FEA structure.
    // Without at least this much info there isn't anything to do here.
    //
    // NOTE:  If there is space for at least one FEA in the list, but the
    //        FEA is corrupt, we'll return an error below, i.e. insufficient
    //        information is not an error condition while corrupt info is.
    //

    if ( BufferLength <= sizeof(FEALIST) ||
         SmbGetUlong( &FeaList->cbList ) <= sizeof(FEALIST)) {
        return STATUS_SUCCESS;
    }

    //
    // Make sure that the value in Fealist->cbList is legitimate.
    //

    if ( SmbGetUlong( &FeaList->cbList ) > BufferLength ) {
        DEBUG SrvPrint2(
            "SrvSetOs2FeaList: EA list size is inconsistent.  Actual size"
                "is %d, expected maximum size is %d",
            SmbGetUlong( &FeaList->cbList ),
            BufferLength
            );
        return STATUS_OS2_EA_LIST_INCONSISTENT;
    }

    //
    // Convert the FEALIST to NT style.
    //

    status = SrvOs2FeaListToNt(
                 FeaList,
                 &ntFullEa,
                 &ntFullEaBufferLength,
                 EaErrorOffset
                 );

    if ( !NT_SUCCESS(status) ) {

        //
        // SrvOs2FeaListToNt has already logged the error.  Do not
        // create another log entry here.
        //

        return status;

    }

    //
    // Set the file's EAs with a directly-built IRP.  Doing this rather
    // than calling the NtSetEaFile system service prevents a copy of
    // the input data from occurring.
    //
    // *** The operation is performed synchronously.
    //

    status = SrvIssueSetEaRequest(
                FileHandle,
                ntFullEa,
                ntFullEaBufferLength,
                &errorOffset
                );

    if ( !NT_SUCCESS(status) ) {

        //
        // An error occurred.  Find the offset into the EA list of the
        // error.
        //

        *EaErrorOffset = SrvGetOs2FeaOffsetOfError(
                             errorOffset,
                             ntFullEa,
                             FeaList
                             );

        INTERNAL_ERROR(
            ERROR_LEVEL_EXPECTED,
            "SrvSetOs2FeaList: SrvIssueSetEaRequest returned %X",
            status,
            NULL
            );

        IF_DEBUG(ERRORS) {
            PFEA errorFea = (PFEA)( (PCHAR)FeaList + *EaErrorOffset );
            SrvPrint1( "EA error offset in FEALIST: 0x%lx\n", *EaErrorOffset );
            SrvPrint3( "name: %s, value len: %ld, value: %s", (PCHAR)(errorFea+1),
                          SmbGetUshort( &errorFea->cbValue ),
                          (PCHAR)(errorFea+1) + errorFea->cbName + 1 );
        }
    }

    //
    // Deallocate the buffer used to hold the NT full EA list.
    //

    DEALLOCATE_NONPAGED_POOL( ntFullEa );

    return status;

} // SrvSetOs2FeaList


NTSTATUS
SrvConstructNullOs2FeaList (
    IN PFILE_GET_EA_INFORMATION NtGeaList,
    OUT PFEALIST FeaList,
    IN ULONG BufferLength
    )

/*++

Routine Description:

    Converts a single NT full EA list to OS/2 FEALIST style for files
    with no eas.  When a file has no eas but a GEAlist was supplied,
    we need to return an ealist that has all the attributes specified
    in the GEAlist present but with CbValues of 0.  This routine was
    specifically written for the files . and .. but can be used to get
    the FEAlist of a no ea file given the NT Gea list.

Arguments:

    NtGetEaList - if non-NULL, an NT style get EA list used to get only
        a subset of the files EAs rather than all the EAs.  Only the
        EAs listed in GEALIST are returned.

    FeaList - where to write the OS/2 1.2 style FEALIST for the file.

    BufferLength - length of Buffer.

Return Value:

    NTSTATUS - STATUS_SUCCESS, STATUS_BUFFER_OVERFLOW if the EAs wouldn't
        fit in Buffer, or a value returned by NtQuery{Information,Ea}File.

--*/

{

    PCHAR ptr;
    PFEA fea = FeaList->list;
    PFILE_GET_EA_INFORMATION currentGea = NtGeaList;
    LONG remainingBytes = BufferLength;
    ULONG i;

    PAGED_CODE( );

    //
    // Get the EAs.
    //

    for ( ; ; ) {

        //
        // Is our buffer big enough?
        //

        remainingBytes -= ( sizeof( FEA ) + currentGea->EaNameLength + 1 );

        if ( remainingBytes < 0 ) {

            return  STATUS_BUFFER_OVERFLOW;

        }

        //
        // We know what these are.
        //

        fea->fEA = 0;
        fea->cbName = currentGea->EaNameLength;
        SmbPutUshort( &fea->cbValue, 0);

        //
        // Copy the attribute name.
        //

        for ( i = 0, ptr = (PCHAR) (fea + 1);
              i < (ULONG) currentGea->EaNameLength;
              i++, ptr++) {

            *ptr = RtlUpperChar( currentGea->EaName[i] );

        }

        *ptr++ = '\0';

        fea = (PFEA) ptr;

        //
        // Is this the last one?
        //

        if ( currentGea->NextEntryOffset == 0 ) {
            break;
        }

        //
        // Move to the next attribute
        //

        currentGea = (PFILE_GET_EA_INFORMATION)
                        ((PCHAR) currentGea + currentGea->NextEntryOffset);

    }

    //
    // Set the number of bytes in the FEALIST.
    //

    SmbPutUlong(
        &FeaList->cbList,
        (ULONG)((ULONG_PTR)fea - (ULONG_PTR)FeaList)
        );

    return STATUS_SUCCESS;

} // SrvConstructNullOs2FeaList
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\srv\dfs.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    dfs.c

Abstract:

    This module contains various support routines for processing Dfs related operations.

--*/

#include "precomp.h"
#include "dfs.tmh"
#pragma hdrstop

#include    <dfsfsctl.h>

#define BugCheckFileId SRV_FILE_DFS

NTSTATUS
DfsGetReferrals(
    ULONG ClientIPAddress,
    PUNICODE_STRING DfsName,
    USHORT MaxReferralLevel,
    PVOID ReferralListBuffer,
    PULONG SizeReferralListBuffer
);

#ifdef ALLOC_PRAGMA
#pragma alloc_text( PAGE, SrvInitializeDfs )
#pragma alloc_text( PAGE, SrvTerminateDfs )
#pragma alloc_text( PAGE, SrvSmbGetDfsReferral )
#pragma alloc_text( PAGE, SrvSmbReportDfsInconsistency )
#pragma alloc_text( PAGE, DfsGetReferrals )
#pragma alloc_text( PAGE, DfsNormalizeName )
#pragma alloc_text( PAGE, DfsFindShareName )
#pragma alloc_text( PAGE, SrvIsShareInDfs )
#endif

//
// Initialize with the Dfs driver.  Called at startup
//
VOID
SrvInitializeDfs()
{
    NTSTATUS status;
    HANDLE dfsHandle;
    UNICODE_STRING dfsDriverName;
    OBJECT_ATTRIBUTES objectAttributes;
    IO_STATUS_BLOCK ioStatusBlock;

    PAGED_CODE();

    //
    // Get the DFS dispatch entry for file control operations
    //
    RtlInitUnicodeString( &dfsDriverName, DFS_SERVER_NAME );

    SrvInitializeObjectAttributes_U(
        &objectAttributes,
        &dfsDriverName,
        0,
        NULL,
        NULL
        );

    status = IoCreateFile(
                &dfsHandle,
                GENERIC_READ | GENERIC_WRITE,
                &objectAttributes,
                &ioStatusBlock,
                NULL,
                FILE_ATTRIBUTE_NORMAL,
                FILE_SHARE_READ | FILE_SHARE_WRITE,
                FILE_OPEN,
                0,                      // Create Options
                NULL,                   // EA Buffer
                0,                      // EA Length
                CreateFileTypeNone,     // File type
                NULL,                   // ExtraCreateParameters
                IO_FORCE_ACCESS_CHECK   // Options
                );

    if( NT_SUCCESS( status ) ) {

        //
        // Get a pointer to the fast Device Control entry point of the Dfs driver so
        //  we can quickly perform Dfs operations
        //

        status = ObReferenceObjectByHandle(
                    dfsHandle,
                    0,
                    NULL,
                    KernelMode,
                    (PVOID *)&SrvDfsFileObject,
                    NULL
                    );

        if( NT_SUCCESS( status ) ) {

            PFAST_IO_DISPATCH fastIoDispatch;

            SrvDfsDeviceObject = IoGetRelatedDeviceObject( SrvDfsFileObject );
            fastIoDispatch = SrvDfsDeviceObject->DriverObject->FastIoDispatch;

            if( fastIoDispatch != NULL &&
                fastIoDispatch->SizeOfFastIoDispatch > FIELD_OFFSET( FAST_IO_DISPATCH, FastIoDeviceControl ) ) {

                SrvDfsFastIoDeviceControl = fastIoDispatch->FastIoDeviceControl;

            }

            if( SrvDfsFastIoDeviceControl == NULL ) {
                ObDereferenceObject( SrvDfsFileObject );
                SrvDfsFileObject = NULL;
                SrvDfsDeviceObject = NULL;
            }
        }

        SrvNtClose( dfsHandle, FALSE );
    }

    IF_DEBUG( DFS ) {
        if( SrvDfsFastIoDeviceControl == NULL ) {
            KdPrint(( "SRV: Dfs operations unavailable, status %X\n", status ));
        }
    }
}

//
// De-initialize with the Dfs driver.  Called at server shutdown
//
VOID
SrvTerminateDfs()
{
    PAGED_CODE();

    //
    // Disconnect from the Dfs driver
    //
    if( SrvDfsFileObject != NULL ) {
        SrvDfsFastIoDeviceControl = NULL;
        SrvDfsDeviceObject = NULL;
        ObDereferenceObject( SrvDfsFileObject );
        SrvDfsFileObject = NULL;
    }
}

SMB_TRANS_STATUS
SrvSmbGetDfsReferral (
    IN OUT PWORK_CONTEXT WorkContext
    )
{
    PTRANSACTION transaction;
    UNICODE_STRING dfsName;
    PREQ_GET_DFS_REFERRAL request;
    NTSTATUS status = STATUS_SUCCESS;
    PTREE_CONNECT treeConnect;
    PSHARE share;
    PVOID referrals;
    ULONG size;
    ULONG dataCount;
    SMB_TRANS_STATUS SmbStatus = SmbTransStatusInProgress;

    PAGED_CODE();

    if (WorkContext->PreviousSMB == EVENT_TYPE_SMB_LAST_EVENT)
        WorkContext->PreviousSMB = EVENT_TYPE_SMB_GET_DFS_REFERRALS;
    SrvWmiStartContext(WorkContext);

    transaction = WorkContext->Parameters.Transaction;

    request = (PREQ_GET_DFS_REFERRAL)transaction->InParameters;

    //
    // Verify that enough parameter bytes were sent and that we're allowed
    // to return enough parameter bytes.
    // The +1 is to ensure that there is at least room for a single unicode
    // character in the supplied buffer, since this assumption is implicitly
    // made below.
    //

    if( (transaction->ParameterCount <
            sizeof( REQ_GET_DFS_REFERRAL ) + 1) ||

        !SMB_IS_UNICODE( WorkContext ) ) {

        //
        // Not enough parameter bytes were sent.
        //

        IF_DEBUG( DFS ) {
            KdPrint(( "SrvSmbGetDfsReferral: bad parameter byte counts: "
                        "%ld\n",
                        transaction->ParameterCount ));

            if( !SMB_IS_UNICODE( WorkContext ) ) {
                KdPrint(( "SrvSmbGetDfsReferral: NOT UNICODE!\n" ));
            }
        }

        SrvLogInvalidSmb( WorkContext );

        SrvSetSmbError( WorkContext, STATUS_INVALID_SMB );
        SmbStatus = SmbTransStatusErrorWithoutData;
        status    = STATUS_INVALID_SMB;
        goto Cleanup;
    }

    //
    // This SMB can only be sent over IPC$, by a logged-in user
    //
    treeConnect = transaction->TreeConnect;
    share = treeConnect->Share;

    if( share->ShareType != ShareTypePipe ) {

        IF_DEBUG( DFS ) {
            if( share->ShareType != ShareTypePipe ) {
                KdPrint(( "SrvSmbGetDfsReferral: Wrong share type %d\n", share->ShareType ));
            }
        }

        SrvSetSmbError( WorkContext, STATUS_ACCESS_DENIED );
        SmbStatus = SmbTransStatusErrorWithoutData;
        status    = STATUS_ACCESS_DENIED;
        goto Cleanup;
    }

    dfsName.Buffer = (PWCHAR)( request->RequestFileName );
    dfsName.Length = (USHORT)(transaction->TotalParameterCount -
                        FIELD_OFFSET(REQ_GET_DFS_REFERRAL, RequestFileName));
    dfsName.MaximumLength = dfsName.Length;
    dfsName.Length -= sizeof(UNICODE_NULL);

    dataCount = transaction->MaxDataCount;

    status = DfsGetReferrals( WorkContext->Connection->ClientIPAddress,
                                        &dfsName, request->MaxReferralLevel,
                                        transaction->OutData,
                                        &dataCount );

    if( !NT_SUCCESS( status ) ) {
        SrvSetSmbError( WorkContext, status );
        SmbStatus = SmbTransStatusErrorWithoutData;
        goto Cleanup;
    }

    transaction->SetupCount = 0;
    transaction->ParameterCount = 0;
    transaction->DataCount = dataCount;
    SmbStatus = SmbTransStatusSuccess;

Cleanup:
    SrvWmiEndContext(WorkContext);
    return SmbStatus;
}

NTSTATUS
DfsGetReferrals(
    ULONG IPAddress,
    PUNICODE_STRING DfsName,
    USHORT MaxReferralLevel,
    PVOID  ReferralListBuffer,
    PULONG SizeReferralListBuffer
)
{
    DFS_GET_REFERRALS_INPUT_ARG dfsArgs;
    IO_STATUS_BLOCK ioStatus;
    PRESP_GET_DFS_REFERRAL pResp;
    PUCHAR eBuffer;
    ULONG i;

    PAGED_CODE();

    if( SrvDfsFastIoDeviceControl == NULL ) {
        return STATUS_FS_DRIVER_REQUIRED;
    }

    IF_DEBUG( DFS ) {
        KdPrint(( "SRV: Referral sought for: <%wZ>\n", DfsName ));
    }

    //
    // Call DFS, getting back the vector of referrals
    //
    RtlZeroMemory( &dfsArgs, sizeof(dfsArgs) );
    dfsArgs.DfsPathName = *DfsName;
    dfsArgs.MaxReferralLevel = MaxReferralLevel;

    if( IPAddress != 0 ) {
        dfsArgs.IpAddress.IpFamily = TDI_ADDRESS_TYPE_IP;
        dfsArgs.IpAddress.IpLen = sizeof( IPAddress );
        RtlCopyMemory( dfsArgs.IpAddress.IpData, &IPAddress, sizeof( IPAddress ) );
    }

    SrvDfsFastIoDeviceControl(
        SrvDfsFileObject,
        TRUE,
        &dfsArgs,
        sizeof( dfsArgs ),
        ReferralListBuffer,
        *SizeReferralListBuffer,
        FSCTL_DFS_GET_REFERRALS,
        &ioStatus,
        SrvDfsDeviceObject
    );

    if( NT_SUCCESS( ioStatus.Status ) ||
        ioStatus.Status == STATUS_BUFFER_OVERFLOW ) {

        *SizeReferralListBuffer = (ULONG)ioStatus.Information;

    } else {

        IF_DEBUG( DFS ) {
            KdPrint(("\tSrvDfsFastIoDeviceControl returned %X, 0x%p\n",
                      ioStatus.Status, (PVOID)ioStatus.Information ));
        }

    }

    return ioStatus.Status;
}

SMB_TRANS_STATUS
SrvSmbReportDfsInconsistency (
    IN OUT PWORK_CONTEXT WorkContext
    )
{
    //
    // We no longer support middle triangles in DFS
    //
    SrvSetSmbError( WorkContext, STATUS_NOT_SUPPORTED );
    return SmbTransStatusErrorWithoutData;

#if XXX
    PTRANSACTION transaction;
    UNICODE_STRING dfsName;
    PREQ_REPORT_DFS_INCONSISTENCY request;
    PDFS_REFERRAL_V1 ref;
    PTREE_CONNECT treeConnect;
    PSHARE share;
    DFS_REPORT_INCONSISTENCY_ARG dfsArgs;
    IO_STATUS_BLOCK ioStatus;

    PAGED_CODE();

    transaction = WorkContext->Parameters.Transaction;

    request = (PREQ_REPORT_DFS_INCONSISTENCY)transaction->InParameters;
    ref = (PDFS_REFERRAL_V1)transaction->InData;

    //
    // Verify that enough parameter bytes were sent and the SMB is unicode
    //

    if( transaction->ParameterCount < sizeof( *request ) ||
        !SMB_IS_UNICODE( WorkContext ) ) {

        //
        // Not enough parameter bytes were sent.
        //

        IF_DEBUG( DFS ) {
            KdPrint(( "SrvSmbReportDfsInconsistency: bad parameter byte counts: "
                        "%ld %ld\n",
                        transaction->ParameterCount, sizeof( *request ) ));

            if( !SMB_IS_UNICODE( WorkContext ) ) {
                KdPrint(( "SrvSmbReportDfsInconsistency: NOT UNICODE!\n" ));
            }
        }

        SrvLogInvalidSmb( WorkContext );

        SrvSetSmbError( WorkContext, STATUS_INVALID_SMB );
        return SmbTransStatusErrorWithoutData;
    }

    //
    // This SMB can only be sent over IPC$, by a logged-in user
    //
    treeConnect = transaction->TreeConnect;
    share = treeConnect->Share;

    if( share->ShareType != ShareTypePipe ||
        transaction->Session->IsNullSession ) {

        IF_DEBUG( DFS ) {
            if( share->ShareType != ShareTypePipe ) {
                KdPrint(( "SrvSmbReportDfsInconsistency: Wrong share type %d\n", share->ShareType ));
            }
            if( transaction->Session->IsNullSession ) {
                KdPrint(( "SrvSmbReportDfsInconsistency: NULL session!\n" ));
            }
        }

        SrvSetSmbError( WorkContext, STATUS_ACCESS_DENIED );
        return SmbTransStatusErrorWithoutData;
    }

    dfsName.Buffer = ALIGN_SMB_WSTR( request->RequestFileName );
    dfsName.Length = (USHORT)transaction->TotalParameterCount -
                        sizeof(UNICODE_NULL);
    dfsName.MaximumLength = dfsName.Length;

    IF_DEBUG( DFS ) {
        KdPrint(( "SrvSmbReportDfsInconsistency: %wZ\n", &dfsName ));
    }

    dfsArgs.DfsPathName = dfsName;
    dfsArgs.Ref = (PBYTE) ref;

    if (SrvDfsFastIoDeviceControl != NULL) {

        SrvDfsFastIoDeviceControl(
            SrvDfsFileObject,
            TRUE,
            &dfsArgs,
            sizeof( dfsArgs ),
            NULL,
            0,
            FSCTL_DFS_REPORT_INCONSISTENCY,
            &ioStatus,
            SrvDfsDeviceObject
            );

    }

    transaction->ParameterCount = 0;
    transaction->DataCount = 0;
    return SmbTransStatusSuccess;
#endif
}

NTSTATUS SRVFASTCALL
DfsNormalizeName(
    IN PSHARE Share,
    IN PUNICODE_STRING RelatedPath OPTIONAL,
    IN BOOLEAN StripLastComponent,
    IN PUNICODE_STRING String
    )
{
    DFS_TRANSLATE_PATH_ARG dfsArgs;
    IO_STATUS_BLOCK ioStatus;

#if DBG
    UNICODE_STRING save = *String;
#endif

    PAGED_CODE();

    //
    // If Share->NtPathName covers String, then the remaining pathname in String->Buffer should
    //  be moved to String->Buffer and String->Length should be adjusted.  In other words, on return
    //  the value of String->Buffer must not be changed, but the contents of String->Buffer needs to
    //  be adjusted.
    //

    ASSERT( String->Buffer != NULL );

    IF_DEBUG( DFS ) {
        KdPrint(( "DfsNormalizeName: %p, Share: %wZ\n", String, &Share->NtPathName ));
    }

    if( Share->ShareType == ShareTypeDisk &&
        SrvDfsFastIoDeviceControl != NULL ) {
        //
        // Make an FSCTL to the DFS driver to normalize the name
        //

        dfsArgs.Flags = 0;

        if (StripLastComponent)
            dfsArgs.Flags |= DFS_TRANSLATE_STRIP_LAST_COMPONENT;

        dfsArgs.SubDirectory = Share->NtPathName;
        if (ARGUMENT_PRESENT(RelatedPath)) {
            UNICODE_STRING Parent;

            //ASSERT(RelatedPath->Length >= Share->DosPathName.Length);

            if (RelatedPath->Length <= Share->DosPathName.Length) {
                Parent.MaximumLength = Parent.Length = sizeof(WCHAR);
                Parent.Buffer = L"\\";
            } else {
                Parent.MaximumLength = Parent.Length = 
                           RelatedPath->Length - Share->DosPathName.Length;
                Parent.Buffer =
                    &RelatedPath->Buffer[ Share->DosPathName.Length/sizeof(WCHAR) ];
            }

            dfsArgs.ParentPathName = Parent;

        } else {
            dfsArgs.ParentPathName.Length = 0;
            dfsArgs.ParentPathName.MaximumLength = 0;
            dfsArgs.ParentPathName.Buffer = NULL;
        }
        dfsArgs.DfsPathName = *String;

        SrvDfsFastIoDeviceControl(
            SrvDfsFileObject,
            TRUE,
            &dfsArgs,
            sizeof( dfsArgs ),
            NULL,
            0,
            FSCTL_DFS_TRANSLATE_PATH,
            &ioStatus,
            SrvDfsDeviceObject
            );

        if (NT_SUCCESS(ioStatus.Status)) {

            ASSERT( dfsArgs.DfsPathName.Buffer == String->Buffer );
            ASSERT( dfsArgs.DfsPathName.Length <= String->Length );
            ASSERT( dfsArgs.DfsPathName.MaximumLength >= dfsArgs.DfsPathName.Length );

            *String = dfsArgs.DfsPathName;

            IF_DEBUG( DFS ) {
                KdPrint(( "\t%wZ\n", String ));
            }
        }

    } else {
        ioStatus.Status = STATUS_FS_DRIVER_REQUIRED;
    }

    ASSERT( save.Buffer == String->Buffer );
    ASSERT( save.Length >= String->Length );

    if( !NT_SUCCESS( ioStatus.Status ) ) {
        IF_DEBUG( DFS ) {
            KdPrint(( "\tStatus %X\n", ioStatus.Status ));
        }
    }

    return ioStatus.Status;
}

NTSTATUS SRVFASTCALL
DfsFindShareName(
    IN PUNICODE_STRING ShareName
    )
{
    NTSTATUS status = STATUS_BAD_NETWORK_NAME;
    DFS_FIND_SHARE_ARG dfsArgs;
    IO_STATUS_BLOCK ioStatus;
    KAPC_STATE ApcState;
    PEPROCESS process;

    //
    // Ensure we are in the system process
    //
    process = IoGetCurrentProcess();
    if ( process != SrvServerProcess ) {
        KeStackAttachProcess( SrvServerProcess, &ApcState );
    }

    //
    // If 'shareName' is known to the DFS driver, then we must return
    //  STATUS_PATH_NOT_COVERED.  Otherwise we must return STATUS_BAD_NETWORK_NAME.
    //  This will cause the DFS client to come back and ask for a referral through
    //  the normal mechanism.
    //

    IF_DEBUG( DFS ) {
        KdPrint(( "SRV: DfsFindShareName: %wZ\n", ShareName ));
    }

    if( SrvDfsFastIoDeviceControl != NULL ) {

        dfsArgs.ShareName = *ShareName;

        SrvDfsFastIoDeviceControl(
            SrvDfsFileObject,
            TRUE,
            &dfsArgs,
            sizeof( dfsArgs ),
            NULL,
            0,
            FSCTL_DFS_FIND_SHARE,
            &ioStatus,
            SrvDfsDeviceObject
            );

        if( ioStatus.Status == STATUS_PATH_NOT_COVERED ) {
            status = ioStatus.Status;
        }
    }

    IF_DEBUG( DFS ) {
        KdPrint(( "SRV: DfsFindShareName: status %X\n", status ));
    }

    //
    // Get back to where we were
    //
    if( process != SrvServerProcess ) {
        KeUnstackDetachProcess( &ApcState );
    }

    return status;
}

VOID SRVFASTCALL
SrvIsShareInDfs(
    IN PSHARE Share,
    OUT BOOLEAN *IsDfs,
    OUT BOOLEAN *IsDfsRoot
)
{
    DFS_IS_SHARE_IN_DFS_ARG dfsArgs;
    IO_STATUS_BLOCK ioStatus;
    KAPC_STATE ApcState;
    PEPROCESS process;

    PAGED_CODE();

    *IsDfs = FALSE;
    *IsDfsRoot = FALSE;

    if( Share->ShareType != ShareTypeDisk ||
        SrvDfsFastIoDeviceControl == NULL ) {

        return;
    }

    dfsArgs.ServerType = 1;         // SMB server
    dfsArgs.ShareName = Share->ShareName;
    dfsArgs.SharePath = Share->NtPathName;

    //
    // Ensure we are in the system process
    //
    process = IoGetCurrentProcess();
    if ( process != SrvServerProcess ) {
        KeStackAttachProcess( SrvServerProcess, &ApcState );
    }

    SrvDfsFastIoDeviceControl(
        SrvDfsFileObject,
        TRUE,
        &dfsArgs,
        sizeof( dfsArgs ),
        NULL,
        0,
        FSCTL_DFS_IS_SHARE_IN_DFS,
        &ioStatus,
        SrvDfsDeviceObject
        );

    //
    // Get back to where we were
    //
    if( process != SrvServerProcess ) {
        KeUnstackDetachProcess( &ApcState );
    }

    if (NT_SUCCESS(ioStatus.Status)) {

        if (dfsArgs.ShareType & DFS_SHARE_TYPE_DFS_VOLUME)
            *IsDfs = TRUE;

        if (dfsArgs.ShareType & DFS_SHARE_TYPE_ROOT)
            *IsDfsRoot = TRUE;

    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\srv\blkwork.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    blkwork.c

Abstract:

    This module implements routines for managing work context blocks.

Author:

    Chuck Lenzmeier (chuckl) 4-Oct-1989
    David Treadwell (davidtr)

Revision History:

--*/

#include "precomp.h"
#include "blkwork.tmh"
#pragma hdrstop

#define BugCheckFileId SRV_FILE_BLKWORK

#define FREE_EXTRA_SMB_BUFFER( _wc ) {                                  \
        ASSERT( (_wc)->UsingExtraSmbBuffer );                           \
        ASSERT( (_wc)->ResponseBuffer != NULL );                        \
        DEALLOCATE_NONPAGED_POOL( (_wc)->ResponseBuffer );              \
        DEBUG (_wc)->ResponseBuffer = NULL;                             \
        DEBUG (_wc)->ResponseHeader = NULL;                             \
        DEBUG (_wc)->ResponseParameters = NULL;                         \
        (_wc)->UsingExtraSmbBuffer = FALSE;                             \
    }
//
// Local functions.
//

#define TransportHeaderSize 80


PWORK_CONTEXT
InitializeWorkItem (
    IN PVOID WorkItem,
    IN UCHAR BlockType,
    IN CLONG TotalSize,
    IN CLONG IrpSize,
    IN CCHAR IrpStackSize,
    IN CLONG MdlSize,
    IN CLONG BufferSize,
    IN PVOID Buffer
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text( PAGE, SrvAllocateInitialWorkItems )
#pragma alloc_text( PAGE, SrvAllocateRawModeWorkItem )
#pragma alloc_text( PAGE, SrvFreeInitialWorkItems )
#pragma alloc_text( PAGE, SrvFreeNormalWorkItem )
#pragma alloc_text( PAGE, SrvFreeRawModeWorkItem )
//#pragma alloc_text( PAGE, SrvDereferenceWorkItem )
#pragma alloc_text( PAGE, SrvAllocateExtraSmbBuffer )
#pragma alloc_text( PAGE, SrvGetRawModeWorkItem )
#pragma alloc_text( PAGE, SrvRequeueRawModeWorkItem )
#endif
#if 0
NOT PAGEABLE -- SrvFsdDereferenceWorkItem
#endif


NTSTATUS
SrvAllocateInitialWorkItems (
    VOID
    )

/*++

Routine Description:

    This routine allocates the initial set of normal server work items.
    It allocates one large block of memory to contain the entire set.
    The purpose of this single allocation is to eliminate the wasted
    space inherent in the allocation of a single work item.  (Normal
    work items occupy about 5K bytes.  Because of the way nonpaged pool
    is managed, allocating 5K actually uses 8K.)

    Each normal work item includes enough memory to hold the following:

        - work context block,
        - IRP,
        - buffer descriptor,
        - two MDLs, and
        - buffer for sends and receives

    This routine also queues each of the work items to the receive
    work item list.

Arguments:

    None.

Return Value:

    NTSTATUS - Returns STATUS_INSUFFICIENT_RESOURCES if unable to
        allocate nonpaged pool; STATUS_SUCCESS otherwise.

--*/

{
    CLONG totalSize;
    CLONG workItemSize;
    CLONG irpSize = SrvReceiveIrpSize;
    CLONG mdlSize = SrvMaxMdlSize;
    CLONG bufferSize = SrvReceiveBufferSize;
    ULONG cacheLineSize = SrvCacheLineSize;

    PVOID workItem;
    PVOID buffer;
    PWORK_CONTEXT workContext;
    CLONG i;
    PWORK_QUEUE queue;

    PAGED_CODE();

    //
    // If the initial set of work items is to be empty, don't do
    // anything.
    //
    // *** This will almost certainly never happen, but let's be
    //     prepared just in case.
    //

    if ( SrvInitialReceiveWorkItemCount == 0 ) {
        return STATUS_SUCCESS;
    }

    while( SrvInitialWorkItemBlock == NULL && SrvInitialReceiveWorkItemCount != 0 ) {

        //
        // Find out the sizes of the IRP, the SMB buffer, and the MDLs.  The
        // MDL size is "worst case" -- the actual MDL size may be smaller,
        // but this calculation ensures that the MDL will be large enough.
        //
        // *** Note that the space allocated for the SMB buffer must be made
        //     large enough to allow the buffer to be aligned such that it
        //     falls, alone, within a set of cache-line-sized blocks.  This
        //     allows I/O to be performed to or from the buffer without
        //     concern for cache line tearing.  (Note the assumption below
        //     that the cache line size is a power of two.)
        //

        //
        // Determine how large a buffer is needed for a single work item,
        // not including the SMB buffer.  Round this number to a quadword
        // boundary.
        //

        workItemSize = sizeof(WORK_CONTEXT) + irpSize + sizeof(BUFFER) +
                        (mdlSize * 2);
        workItemSize = (workItemSize + (MEMORY_ALLOCATION_ALIGNMENT - 1)) & ~(MEMORY_ALLOCATION_ALIGNMENT - 1);

        //
        // Determine the total amount of space needed.  The allocation
        // must be padded in order to allow the SMB buffers to be aligned
        // on cache line boundaries.
        //


        totalSize = (bufferSize + TransportHeaderSize + workItemSize) * SrvInitialReceiveWorkItemCount +
                    cacheLineSize;

        IF_DEBUG(HEAP) {
            SrvPrint0( "SrvAllocateInitialWorkItems:\n" );
            SrvPrint1( "  work item size = 0x%lx bytes\n", workItemSize );
            SrvPrint1( "  buffer size = 0x%lx bytes\n", bufferSize );
            SrvPrint1( "  Backfill size = 0x%lx bytes\n", TransportHeaderSize );
            SrvPrint1( "  number of work items = %ld\n",
                        SrvInitialReceiveWorkItemCount );
            SrvPrint1( "  total allocation = 0x%lx bytes\n", totalSize );
            SrvPrint1( "  wasted space = 0x%p bytes\n",
                        (PVOID)(ROUND_TO_PAGES( totalSize ) - totalSize) );
            SrvPrint1( "  amount saved over separate allocation = 0x%p bytes\n",
                        (PVOID)(((ROUND_TO_PAGES( workItemSize ) +
                          ROUND_TO_PAGES( bufferSize )) *
                                            SrvInitialReceiveWorkItemCount) -
                            ROUND_TO_PAGES( totalSize )) );
        }

        //
        // Attempt to allocate from nonpaged pool.
        //

        SrvInitialWorkItemBlock = ALLOCATE_NONPAGED_POOL(
                                    totalSize,
                                    BlockTypeWorkContextInitial
                                    );

        if ( SrvInitialWorkItemBlock == NULL ) {

            INTERNAL_ERROR(
                ERROR_LEVEL_EXPECTED,
                "SrvAllocateInitialWorkItems: Unable to allocate %d bytes "
                    "from nonpaged pool.",
                totalSize,
                NULL
                );

            //
            // Let's try reducing the count and give it another shot.
            //
            SrvInitialReceiveWorkItemCount /= 2;
        }
    }

    if( SrvInitialWorkItemBlock == 0 ) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    // Round the allocation to a cache line boundary, then reserve
    // space for SMB buffers and control structures.
    //

    buffer = (PVOID)(((ULONG_PTR)SrvInitialWorkItemBlock + cacheLineSize) &
                                                    ~((LONG_PTR)cacheLineSize));

    workItem = (PCHAR)buffer + ((bufferSize + TransportHeaderSize) * SrvInitialReceiveWorkItemCount);

    //
    // Initialize the work items and update the count of work items in
    // the server.
    //
    // *** Note that the update is not synchronized -- that shouldn't be
    //     necessary at this stage of server initialization.
    //

    queue = SrvWorkQueues;
    for ( i = 0; i < SrvInitialReceiveWorkItemCount; i++ ) {

        if (((PAGE_SIZE - 1) - BYTE_OFFSET(buffer)) < (TransportHeaderSize + sizeof(SMB_HEADER))) {

           buffer = (PCHAR)buffer + PAGE_SIZE - BYTE_OFFSET(buffer);
           i++;
           IF_DEBUG(HEAP) {
              SrvPrint2("buffer adjusted!! %p offset %x \n",buffer,BYTE_OFFSET(buffer));
           }
        }

        workContext = InitializeWorkItem(
                            workItem,
                            BlockTypeWorkContextInitial,
                            workItemSize,
                            irpSize,
                            SrvReceiveIrpStackSize,
                            mdlSize,
                            bufferSize,
                            buffer
                            );

        workContext->PartOfInitialAllocation = TRUE;
        workContext->FreeList = &queue->InitialWorkItemList;
        workContext->CurrentWorkQueue = queue;

        if( ++queue == eSrvWorkQueues )
            queue = SrvWorkQueues;

        //
        // Setup the work item and queue it to the free list
        //

        SrvPrepareReceiveWorkItem( workContext, TRUE );

        buffer = (PCHAR)buffer + TransportHeaderSize + bufferSize;

        workItem = (PCHAR)workItem + workItemSize;

        INCREMENT_DEBUG_STAT2( SrvDbgStatistics.WorkContextInfo.Allocations );

    }

    return STATUS_SUCCESS;

} // SrvAllocateInitialWorkItems


NTSTATUS
SrvAllocateNormalWorkItem (
    OUT PWORK_CONTEXT *WorkContext,
    PWORK_QUEUE queue
    )

/*++

Routine Description:

    This routine allocates a normal server work item.  It allocates
    enough memory to hold the following:

        - work context block,
        - IRP,
        - buffer descriptor,
        - two MDLs, and
        - buffer for sends and receives

    It then initializes each of these blocks in the buffer.

    If the number of normal work items in the server is already at the
    configured maximum, this routine refuses to create a new one.

Arguments:

    WorkContext - Returns a pointer to the Work Context Block, or NULL
        if the limit has been reached or if no space is available.  The
        work context block has pointers to the other blocks.

Return Value:

    None.

--*/

{
    CLONG totalSize;
    CLONG workItemSize;
    CLONG irpSize = SrvReceiveIrpSize;
    CLONG mdlSize = SrvMaxMdlSize;
    CLONG bufferSize = SrvReceiveBufferSize;
    CLONG cacheLineSize = SrvCacheLineSize;

    PVOID workItem;
    PVOID buffer;
    CLONG oldWorkItemCount;

    //
    // If we're already at the limit of how many work items we can
    // have, don't create another one.
    //
    // *** Note that the method used below leaves a small window in
    //     which we may refuse to create a work item when we're not
    //     really at the limit -- we increment the value, another thread
    //     frees a work item and decrements the value, yet another
    //     thread tests to see whether it can create a new work item.
    //     Both testing threads will refuse to create a new work item,
    //     even though the final number of work items is one less than
    //     the maximum.
    //

    if ( queue->AllocatedWorkItems >= queue->MaximumWorkItems ) {

        //
        // Can't create any more work items just now.
        //

        IF_DEBUG(ERRORS) {
            SrvPrint0( "SrvAllocateNormalWorkItem: Work item limit reached\n" );
        }

        *WorkContext = NULL;
        return STATUS_INSUFF_SERVER_RESOURCES;

    }

    InterlockedIncrement( &queue->AllocatedWorkItems );

    //
    // Find out the sizes of the IRP, the SMB buffer, and the MDLs.  The
    // MDL size is "worst case" -- the actual MDL size may be smaller,
    // but this calculation ensures that the MDL will be large enough.
    //
    // *** Note that the space allocated for the SMB buffer must be made
    //     large enough to allow the buffer to be aligned such that it
    //     falls, alone, within a set of cache-line-sized blocks.  This
    //     allows I/O to be performed to or from the buffer without
    //     concern for cache line tearing.  (Note the assumption below
    //     that the cache line size is a power of two.)
    //

    //
    // Determine how large a buffer is needed for the SMB buffer and
    // control structures.  The allocation must be padded in order to
    // allow the SMB buffer to be aligned on a cache line boundary.
    //

    workItemSize = sizeof(WORK_CONTEXT) + irpSize + sizeof(BUFFER) +
                    (mdlSize * 2);
    totalSize = workItemSize + bufferSize + TransportHeaderSize+ cacheLineSize;


    //
    // Attempt to allocate from nonpaged pool.
    //

    workItem = ALLOCATE_NONPAGED_POOL( totalSize, BlockTypeWorkContextNormal );

    if ( workItem == NULL ) {

        INTERNAL_ERROR(
            ERROR_LEVEL_EXPECTED,
            "SrvAllocateNormalWorkItem: Unable to allocate %d bytes "
                "from nonpaged pool.",
            totalSize,
            NULL
            );

        InterlockedDecrement( &queue->AllocatedWorkItems );

        *WorkContext = NULL;
        return STATUS_INSUFFICIENT_RESOURCES;

    }

    //
    // Reserve space for the SMB buffer on a cache line boundary.
    //


    buffer = (PVOID)(((ULONG_PTR)workItem + workItemSize + cacheLineSize) &
                                                ~((LONG_PTR)cacheLineSize));

    if (((PAGE_SIZE - 1) - BYTE_OFFSET(buffer)) < (TransportHeaderSize + sizeof(SMB_HEADER))) {

        INTERNAL_ERROR(
            ERROR_LEVEL_EXPECTED,
            "SrvAllocateNormalWorkItem: Unable to allocate header with in a page ",
            totalSize,
            NULL
            );

        InterlockedDecrement( &queue->AllocatedWorkItems );
        DEALLOCATE_NONPAGED_POOL( workItem );
        *WorkContext = NULL;
        return STATUS_INSUFFICIENT_RESOURCES;

    }

    //
    // Initialize the work item and increment the count of work items in
    // the server.
    //

    *WorkContext = InitializeWorkItem(
                        workItem,
                        BlockTypeWorkContextNormal,
                        workItemSize,
                        irpSize,
                        SrvReceiveIrpStackSize,
                        mdlSize,
                        bufferSize,
                        buffer
                        );

    (*WorkContext)->PartOfInitialAllocation = FALSE;

    INCREMENT_DEBUG_STAT2( SrvDbgStatistics.WorkContextInfo.Allocations );

    (*WorkContext)->FreeList = &queue->NormalWorkItemList;
    (*WorkContext)->CurrentWorkQueue = queue;

    return STATUS_SUCCESS;

} // SrvAllocateNormalWorkItem


VOID
SrvAllocateRawModeWorkItem (
    OUT PWORK_CONTEXT *WorkContext,
    IN PWORK_QUEUE queue
    )

/*++

Routine Description:

    This routine allocates a raw mode work item.  It allocates enough
    memory to hold the following:

        - work context block,
        - IRP,
        - buffer descriptor, and
        - one MDL

    It then initializes each of these blocks in the buffer.

    If the number of raw mode work items in the server is already at the
    configured maximum, this routine refuses to create a new one.

Arguments:

    WorkContext - Returns a pointer to the Work Context Block, or NULL
        if no space was available.  The work context block has pointers
        to the other blocks.

Return Value:

    None.

--*/

{
    CLONG workItemSize;
    CLONG irpSize = SrvReceiveIrpSize;
    CLONG mdlSize = SrvMaxMdlSize;

    PVOID workItem;
    CLONG oldWorkItemCount;

    PAGED_CODE( );

    //
    // If we're already at the limit of how many work items we can
    // have, don't create another one.
    //
    // *** Note that the method used below leaves a small window in
    //     which we may refuse to create a work item when we're not
    //     really at the limit -- we increment the value, another thread
    //     frees a work item and decrements the value, yet another
    //     thread tests to see whether it can create a new work item.
    //     Both testing threads will refuse to create a new work item,
    //     even though the final number of work items is one less than
    //     the maximum.
    //

    if ( (ULONG)queue->AllocatedRawModeWorkItems >=
                 SrvMaxRawModeWorkItemCount / SrvNumberOfProcessors ) {

        //
        // Can't create any more work items just now.
        //
        // !!! This should be logged somehow, but we don't want to
        //     breakpoint the server when it happens.
        //

        IF_DEBUG(ERRORS) {
            SrvPrint0( "SrvAllocateRawModeWorkItem: Work item limit reached\n" );
        }

        *WorkContext = NULL;
        return;

    }

    InterlockedIncrement( &queue->AllocatedRawModeWorkItems );

    //
    // Find out the sizes of the IRP and the MDL.  The MDL size is
    // "worst case" -- the actual MDL size may be smaller, but this
    // calculation ensures that the MDL will be large enough.
    //

    workItemSize = sizeof(WORK_CONTEXT) + sizeof(BUFFER) + irpSize + mdlSize;

    //
    // Attempt to allocate from nonpaged pool.
    //

    workItem = ALLOCATE_NONPAGED_POOL( workItemSize, BlockTypeWorkContextRaw );

    if ( workItem == NULL ) {

        INTERNAL_ERROR(
            ERROR_LEVEL_EXPECTED,
            "SrvAllocateRawModeWorkItem: Unable to allocate %d bytes "
                "from nonpaged pool.",
            workItemSize,
            NULL
            );

        InterlockedDecrement( &queue->AllocatedRawModeWorkItems );

        *WorkContext = NULL;
        return;
    }

    //
    // Initialize the work item and increment the count of work items in
    // the server.
    //

    *WorkContext = InitializeWorkItem(
                        workItem,
                        BlockTypeWorkContextRaw,
                        workItemSize,
                        irpSize,
                        SrvReceiveIrpStackSize,
                        mdlSize,
                        0,
                        NULL
                        );

    INCREMENT_DEBUG_STAT2( SrvDbgStatistics.WorkContextInfo.Allocations );

    (*WorkContext)->FreeList = &queue->RawModeWorkItemList;
    (*WorkContext)->CurrentWorkQueue = queue;

} // SrvAllocateRawModeWorkItem


PWORK_CONTEXT
SrvGetRawModeWorkItem ()
{
    PSINGLE_LIST_ENTRY listEntry;
    PWORK_CONTEXT workContext;
    PWORK_QUEUE queue = PROCESSOR_TO_QUEUE();

    PAGED_CODE();

    //
    // Attempt to allocate a raw mode work item off the current processor's queue
    //

    listEntry = ExInterlockedPopEntrySList( &queue->RawModeWorkItemList, &queue->SpinLock );
    if( listEntry != NULL ) {

        workContext = CONTAINING_RECORD( listEntry, WORK_CONTEXT, SingleListEntry );
        InterlockedDecrement( &queue->FreeRawModeWorkItems );
        ASSERT( queue->FreeRawModeWorkItems >= 0 );

    } else {

        SrvAllocateRawModeWorkItem( &workContext, queue );
    }

    if( workContext != NULL || SrvNumberOfProcessors == 1 ) {
        return workContext;
    }

    //
    // We were unable to get or allocate a raw mode workitem off the current
    // work queue.  We're a multiprocessor system, so look around for one off
    // of a different work queue.
    //
    for( queue = SrvWorkQueues; queue < eSrvWorkQueues; queue++ ) {

        listEntry = ExInterlockedPopEntrySList( &queue->RawModeWorkItemList, &queue->SpinLock );

        if ( listEntry != NULL ) {

                InterlockedDecrement( &queue->FreeRawModeWorkItems );
                ASSERT( queue->FreeRawModeWorkItems >= 0 );
                workContext = CONTAINING_RECORD( listEntry, WORK_CONTEXT, SingleListEntry );

                return workContext;
        }
    }

    //
    // We were unable to get a free raw mode workitem off a different processor's
    //  raw work item queue.  See if any of the queues allow allocation of a new one.
    //
    for( queue = SrvWorkQueues; queue < eSrvWorkQueues; queue++ ) {

        SrvAllocateRawModeWorkItem( &workContext, queue );

        if( workContext != NULL ) {
            break;
        }

    }

    return workContext;

} // SrvGetRawModeWorkItem


VOID
SrvRequeueRawModeWorkItem (
    PWORK_CONTEXT WorkContext
    )
{
    PWORK_QUEUE queue = CONTAINING_RECORD( WorkContext->FreeList,
                                         WORK_QUEUE, RawModeWorkItemList );

    PAGED_CODE();

    InterlockedIncrement( &queue->FreeRawModeWorkItems );

    ExInterlockedPushEntrySList( &queue->RawModeWorkItemList,
                                 &WorkContext->SingleListEntry,
                                 &queue->SpinLock
                               );

                            
    return;

} // SrvRequeueRawModeWorkItem


VOID
SrvFreeInitialWorkItems (
    VOID
    )

/*++

Routine Description:

    This function deallocates the large block of work items allocated
    at server startup.

Arguments:

    None.

Return Value:

    None.

--*/

{
    PAGED_CODE( );

    if ( SrvInitialWorkItemBlock != NULL ) {

        IF_DEBUG(BLOCK1) {
            SrvPrint1( "Releasing initial work item block at 0x%p\n",
                        SrvInitialWorkItemBlock );
        }

        DEALLOCATE_NONPAGED_POOL( SrvInitialWorkItemBlock );
        IF_DEBUG(HEAP) {
            SrvPrint1( "SrvFreeInitialWorkItems: Freed initial work item block at 0x%p\n", SrvInitialWorkItemBlock );
        }

        SrvInitialWorkItemBlock = NULL;

    }

    return;

} // SrvFreeInitialWorkItems


VOID
SrvFreeNormalWorkItem (
    IN PWORK_CONTEXT WorkContext
    )

/*++

Routine Description:

    This function deallocates a work item block.

Arguments:

    WorkContext - Address of Work Context block that heads up the work
        item.

Return Value:

    None.

--*/

{
    PWORK_QUEUE queue = WorkContext->CurrentWorkQueue;

    PAGED_CODE( );

    IF_DEBUG(BLOCK1) {
        SrvPrint1( "Closing work item at 0x%p\n", WorkContext );
    }

    ASSERT( GET_BLOCK_STATE( WorkContext ) == BlockStateActive );
    ASSERT( !WorkContext->PartOfInitialAllocation );

    //
    // Free the work item block itself.
    //

    DEBUG SET_BLOCK_TYPE_STATE_SIZE( WorkContext, BlockTypeGarbage, BlockStateDead, -1 );
    DEBUG WorkContext->BlockHeader.ReferenceCount = (ULONG)-1;

    DEALLOCATE_NONPAGED_POOL( WorkContext );
    IF_DEBUG(HEAP) {
        SrvPrint1( "SrvFreeNormalWorkItem: Freed Work Item block at 0x%p\n",
                    WorkContext );
    }

    //
    // Update the count of work items in the server.
    //

    InterlockedDecrement( &queue->AllocatedWorkItems );
    INCREMENT_DEBUG_STAT2( SrvDbgStatistics.WorkContextInfo.Frees );

    return;

} // SrvFreeNormalWorkItem


VOID
SrvFreeRawModeWorkItem (
    IN PWORK_CONTEXT WorkContext
    )

/*++

Routine Description:

    This function deallocates a raw mode work item block.

Arguments:

    WorkContext - Address of Work Context block that heads up the work
        item.

Return Value:

    None.

--*/

{
    PWORK_QUEUE queue = CONTAINING_RECORD( WorkContext->FreeList,
                                         WORK_QUEUE, RawModeWorkItemList );
    PAGED_CODE( );

    IF_DEBUG(BLOCK1) {
        SrvPrint1( "Closing workitem at 0x%p\n", WorkContext );
    }

    ASSERT( GET_BLOCK_STATE( WorkContext ) == BlockStateActive );
    ASSERT( !WorkContext->PartOfInitialAllocation );

    //
    // Free the work item block itself.
    //

    DEBUG SET_BLOCK_TYPE_STATE_SIZE( WorkContext, BlockTypeGarbage, BlockStateDead, -1 );
    DEBUG WorkContext->BlockHeader.ReferenceCount = (ULONG)-1;

    DEALLOCATE_NONPAGED_POOL( WorkContext );
    IF_DEBUG(HEAP) {
        SrvPrint1( "SrvFreeRawModeWorkItem: Freed Work Item block at 0x%p\n",
                    WorkContext );
    }

    //
    // Update the count of work items in the server.
    //
    InterlockedDecrement( &queue->AllocatedRawModeWorkItems );
    ASSERT( queue->AllocatedRawModeWorkItems >= 0 );

    INCREMENT_DEBUG_STAT2( SrvDbgStatistics.WorkContextInfo.Frees );

    return;

} // SrvFreeRawModeWorkItem


PWORK_CONTEXT
InitializeWorkItem (
    IN PVOID WorkItem,
    IN UCHAR BlockType,
    IN CLONG WorkItemSize,
    IN CLONG IrpSize,
    IN CCHAR IrpStackSize,
    IN CLONG MdlSize,
    IN CLONG BufferSize,
    IN PVOID Buffer
    )

/*++

Routine Description:

    This routine initializes the following components of a work item:
        - a work context block,
        - an IRP,
        - the CurrentWorkQueue
        - optionally, a buffer descriptor,
        - one or two MDLs, and
        - optionally, a buffer for sends and receives

    The storage for these components must have been allocated by the
    caller, in contiguous storage starting at WorkContext.

Arguments:

    WorkItem - Supplies a pointer to the storage allocated to the
        work item.

    BlockType - The type of work item being initialized.

    WorkItemSize - Indicates the total amount of space allocated to the
        work item control structures (i.e., not including the data
        buffer, if any).

    IrpSize - Indicates the amount of space in the work item to be
        reserved for the IRP.

    IrpStackSize - Indicates the number of stack locations in the IRP.

    MdlSize - Indicates the amount of space in the work item to be
        reserved for each MDL.  One MDL is created if Buffer is NULL;
        two are created if Buffer is not NULL.

    BufferSize - Indicates the amount of space allocated to be
        data buffer.  This parameter is ignored if Buffer is NULL.

    Buffer - Supplies a pointer to a data buffer.  NULL indicates that
        no data buffer was allocated.  (This is used for raw mode work
        items.)

Return Value:

    PWORK_CONTEXT - Returns a pointer to the work context block that
        forms the "root" of the work item.

--*/

{
    PVOID nextAddress;
    PWORK_CONTEXT workContext;
    PIRP irp;
    PBUFFER bufferDescriptor;
    PMDL fullMdl;
    PMDL partialMdl;

    ASSERT( ((ULONG_PTR)WorkItem & 7) == 0 );

    //
    // Zero the work item control structures.
    //

    RtlZeroMemory( WorkItem, WorkItemSize );

    //
    // Allocate and initialize the work context block.
    //

    workContext = WorkItem;
    nextAddress = workContext + 1;
    ASSERT( ((ULONG_PTR)nextAddress & 7) == 0 );

    SET_BLOCK_TYPE_STATE_SIZE( workContext, BlockType, BlockStateActive, sizeof(WORK_CONTEXT) );
    workContext->BlockHeader.ReferenceCount = 0;

    INITIALIZE_REFERENCE_HISTORY( workContext );

    INITIALIZE_SPIN_LOCK( &workContext->SpinLock );

    //
    // Allocate and initialize an IRP.
    //

    irp = nextAddress;
    nextAddress = (PCHAR)irp + IrpSize;
    ASSERT( ((ULONG_PTR)nextAddress & 7) == 0 );

    workContext->Irp = irp;

    IoInitializeIrp( irp, (USHORT)IrpSize, IrpStackSize );

    CHECKIRP( irp );

    //
    // Allocate a buffer descriptor.  It will be initialized as we
    // find out the necessary information.
    //

    bufferDescriptor = nextAddress;
    nextAddress = bufferDescriptor + 1;
    ASSERT( ((ULONG_PTR)nextAddress & 7) == 0 );

    workContext->RequestBuffer = bufferDescriptor;
    workContext->ResponseBuffer = bufferDescriptor;

    //
    // Allocate an MDL.  In normal work items, this is the "full MDL"
    // describing the entire SMB buffer.  In raw mode work items, this
    // MDL is used to describe raw buffers.
    //

    fullMdl = nextAddress;
    nextAddress = (PCHAR)fullMdl + MdlSize;
    ASSERT( ((ULONG_PTR)nextAddress & 7) == 0 );

    bufferDescriptor->Mdl = fullMdl;

    //
    // If this is a normal work item, initialize the first MDL and
    // allocate and initialize a second MDL and the SMB buffer.
    //

    if ( Buffer != NULL ) {

        partialMdl = nextAddress;

        bufferDescriptor->Buffer = TransportHeaderSize + (PCHAR)Buffer;
        MmInitializeMdl( fullMdl, TransportHeaderSize + (PCHAR)Buffer, BufferSize );
        memset(Buffer,'N', TransportHeaderSize);

        bufferDescriptor->PartialMdl = partialMdl;
        MmInitializeMdl( partialMdl, (PVOID)(PAGE_SIZE-1), MAX_PARTIAL_BUFFER_SIZE );

        bufferDescriptor->BufferLength = BufferSize;
        MmBuildMdlForNonPagedPool( fullMdl );

        fullMdl->MdlFlags|=MDL_NETWORK_HEADER;
        ASSERT( fullMdl->ByteOffset >= TransportHeaderSize );
    }

    //
    // Initialize the client address pointer
    //

    workContext->ClientAddress = &workContext->ClientAddressData;

    //
    // Initialize the processor
    //
    workContext->CurrentWorkQueue = PROCESSOR_TO_QUEUE();

    //
    // Print debugging information.
    //

    IF_DEBUG(HEAP) {

        SrvPrint2( "  InitializeWorkItem: work item of 0x%lx bytes at 0x%p\n", WorkItemSize, WorkItem );
        SrvPrint2( "    Work Context: 0x%lx bytes at 0x%p\n",
                    sizeof(WORK_CONTEXT), workContext );
        SrvPrint2( "    IRP: 0x%lx bytes at 0x%p\n",
                    workContext->Irp->Size, workContext->Irp );

        SrvPrint2( "    Buffer Descriptor: 0x%lx bytes at 0x%p\n",
                    sizeof(BUFFER), workContext->RequestBuffer );
        SrvPrint2( "    Full MDL: 0x%lx bytes at 0x%p\n",
                    MdlSize, workContext->RequestBuffer->Mdl );
        if ( Buffer != NULL ) {
            SrvPrint2( "    Partial MDL: 0x%lx bytes at 0x%p\n",
                        MdlSize, workContext->ResponseBuffer->PartialMdl );
            SrvPrint2( "    Buffer: 0x%lx bytes at 0x%p\n",
                        workContext->RequestBuffer->BufferLength,
                        workContext->RequestBuffer->Buffer );
        } else {
            SrvPrint0( "    No buffer allocated\n" );
        }

    }

    //
    // Return the address of the work context block, which is the "root"
    // of the work item.
    //

    return workContext;

} // InitializeWorkItem


VOID SRVFASTCALL
SrvDereferenceWorkItem (
    IN PWORK_CONTEXT WorkContext
    )

/*++

Routine Description:

    This function decrements the reference count of a work context block.

    *** This routine must not be called at DPC level!  Use
        SrvFsdDereferenceWorkItem from DPC level.

Arguments:

    WorkContext - Pointer to the work context block to reference.

Return Value:

    None.

--*/

{
    ULONG oldCount;

    PAGED_CODE( );

    ASSERT( (LONG)WorkContext->BlockHeader.ReferenceCount > 0 );
    ASSERT( (GET_BLOCK_TYPE(WorkContext) == BlockTypeWorkContextInitial) ||
            (GET_BLOCK_TYPE(WorkContext) == BlockTypeWorkContextNormal) ||
            (GET_BLOCK_TYPE(WorkContext) == BlockTypeWorkContextRaw) );
    UPDATE_REFERENCE_HISTORY( WorkContext, TRUE );

    //
    // Decrement the WCB's reference count.
    //

    oldCount = ExInterlockedAddUlong(
                (PULONG)&WorkContext->BlockHeader.ReferenceCount,
                (ULONG)-1,
                &WorkContext->SpinLock
                );

    IF_DEBUG(REFCNT) {
        SrvPrint2( "Dereferencing WorkContext 0x%p; new refcnt 0x%lx\n",
                    WorkContext, WorkContext->BlockHeader.ReferenceCount );
    }

    if ( oldCount == 1 ) {

        //
        // We are done with the work context, replace it on the free queue.
        //
        // If we are using an extra SMB buffer, free it now.
        //
        SrvWmiTraceEvent(WorkContext);

        if ( WorkContext->UsingExtraSmbBuffer ) {
            FREE_EXTRA_SMB_BUFFER( WorkContext );
        }

        ASSERT( !WorkContext->UsingExtraSmbBuffer );

        //
        // Release references.
        //

        SrvReleaseContext( WorkContext );

        SrvFsdRequeueReceiveWorkItem( WorkContext );

    }

    return;

} // SrvDereferenceWorkItem


VOID
SrvFsdDereferenceWorkItem (
    IN PWORK_CONTEXT WorkContext
    )

/*++

Routine Description:

    This function decrements the reference count of a work context block.

Arguments:

    WorkContext - Pointer to the work context block to reference.

Return Value:

    None.

--*/

{
    ULONG oldCount;

    ASSERT( KeGetCurrentIrql() == DISPATCH_LEVEL );

    ASSERT( (LONG)WorkContext->BlockHeader.ReferenceCount > 0 );
    ASSERT( (GET_BLOCK_TYPE(WorkContext) == BlockTypeWorkContextInitial) ||
            (GET_BLOCK_TYPE(WorkContext) == BlockTypeWorkContextNormal) ||
            (GET_BLOCK_TYPE(WorkContext) == BlockTypeWorkContextRaw) );
    UPDATE_REFERENCE_HISTORY( WorkContext, TRUE );

    //
    // Decrement the WCB's reference count.
    //

    oldCount = ExInterlockedAddUlong(
                (PULONG)&WorkContext->BlockHeader.ReferenceCount,
                (ULONG)-1,
                &WorkContext->SpinLock
                );

    IF_DEBUG(REFCNT) {
        SrvPrint2( "Dereferencing WorkContext 0x%p; new refcnt 0x%lx\n",
                    WorkContext, WorkContext->BlockHeader.ReferenceCount );
    }

    if ( oldCount == 1 ) {

        //
        // We are done with the work context, replace it on the free queue.
        //
        // If we are using an extra SMB buffer, free it now.
        //

        if ( WorkContext->UsingExtraSmbBuffer ) {
            FREE_EXTRA_SMB_BUFFER( WorkContext );
        }

        ASSERT( !WorkContext->UsingExtraSmbBuffer );

        //
        // If the work context block has references to a share, a
        // session, or a tree connect, queue it to the FSP immediately.
        // These blocks are not in nonpaged pool, so they can't be
        // touched at DPC level.
        //

        if ( (WorkContext->Share != NULL) ||
             (WorkContext->Session != NULL) ||
             (WorkContext->TreeConnect != NULL) ) {

            UPDATE_REFERENCE_HISTORY( WorkContext, FALSE );

            ExInterlockedAddUlong(
                (PULONG)&WorkContext->BlockHeader.ReferenceCount,
                1,
                &WorkContext->SpinLock
                );

            WorkContext->QueueToHead = TRUE;
            WorkContext->FspRestartRoutine = SrvDereferenceWorkItem;
            QUEUE_WORK_TO_FSP( WorkContext );

        } else {

            //
            // Try to requeue the work item.  This will fail if the
            // reference count on the connection goes to zero.
            //
            // *** Note that even if the requeueing fails, the work item
            //     is still removed from the in-progress list, so we
            //     can't just requeue to SrvDereferenceWorkItem.
            //

            SrvFsdRequeueReceiveWorkItem( WorkContext );

        }
    }

    return;

} // SrvFsdDereferenceWorkItem

NTSTATUS
SrvAllocateExtraSmbBuffer (
    IN OUT PWORK_CONTEXT WorkContext
    )
{
    ULONG cacheLineSize = SrvCacheLineSize;
    ULONG bufferSize = SrvReceiveBufferSize;
    ULONG mdlSize = SrvMaxMdlSize;
    PBUFFER bufferDescriptor;
    PMDL fullMdl;
    PMDL partialMdl;
    PVOID data;

    PAGED_CODE( );

    ASSERT( !WorkContext->UsingExtraSmbBuffer );

    //
    // Allocate an SMB buffer for use with SMB's that require a separate
    // request and response buffer.
    //

    bufferDescriptor = ALLOCATE_NONPAGED_POOL(
                            sizeof(BUFFER) +
                                mdlSize * 2 +
                                bufferSize +
                                TransportHeaderSize +
                                cacheLineSize,
                            BlockTypeDataBuffer
                            );
    if ( bufferDescriptor == NULL) {
        return STATUS_INSUFF_SERVER_RESOURCES;
    }

    //
    // Initialize one MDL.  This is the "full MDL" describing the
    // entire SMB buffer.
    //

    fullMdl = (PMDL)(bufferDescriptor + 1);
    partialMdl = (PMDL)( (PCHAR)fullMdl + mdlSize );
    data = (PVOID)( ((ULONG_PTR)partialMdl + mdlSize + TransportHeaderSize + cacheLineSize) & ~(LONG_PTR)(cacheLineSize) );

    bufferDescriptor->Mdl = fullMdl;
    MmInitializeMdl( fullMdl, data, bufferSize );

    fullMdl->MdlFlags |= MDL_NETWORK_HEADER;


    //
    // Initialize a second MDL and the SMB buffer.
    //

    bufferDescriptor->PartialMdl = partialMdl;
    MmInitializeMdl( partialMdl, (PVOID)(PAGE_SIZE-1), MAX_PARTIAL_BUFFER_SIZE );

    MmBuildMdlForNonPagedPool( fullMdl );

    bufferDescriptor->Buffer = data;
    bufferDescriptor->BufferLength = bufferSize;

    WorkContext->ResponseBuffer = bufferDescriptor;
    WorkContext->ResponseHeader = bufferDescriptor->Buffer;
    WorkContext->ResponseParameters = (PCHAR)bufferDescriptor->Buffer +
                                                sizeof( SMB_HEADER );

    WorkContext->UsingExtraSmbBuffer = TRUE;

    return STATUS_SUCCESS;

} // SrvAllocateExtraSmbBuffer
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\srv\errorlog.h ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    errorlog.h

Abstract:

    This module contains the manifests and macros used for error logging
    in the server.

Author:

    Manny Weiser (mannyw)    11-Feb-92

Revision History:

--*/

//
// Routines for writing error log entries.
//

VOID
SrvLogError (
    IN PVOID DeviceOrDriverObject,
    IN ULONG UniqueErrorCode,
    IN NTSTATUS NtStatusCode,
    IN PVOID RawDataBuffer,
    IN USHORT RawDataLength,
    IN PUNICODE_STRING InsertionString,
    IN ULONG InsertionStringCount
    );

VOID
SrvLogInvalidSmbDirect (
    IN PWORK_CONTEXT WorkContext,
    IN ULONG LineNumber
    );

VOID
SrvLogServiceFailureDirect (
    IN ULONG LineAndService,
    IN NTSTATUS Status
    );

#define SrvLogSimpleEvent( _event, _status ) SrvLogError( SrvDeviceObject, (_event), (_status), NULL, 0, NULL, 0 )
#define SrvLogServiceFailure( _Service, _Status ) SrvLogServiceFailureDirect( (__LINE__<<16) | _Service, _Status )
#define SrvLogInvalidSmb( _Context ) SrvLogInvalidSmbDirect( _Context, __LINE__ )

VOID
SrvLogTableFullError (
    IN ULONG Type
    );

VOID
SrvCheckSendCompletionStatus(
    IN NTSTATUS status,
    IN ULONG LineNumber
    );

//
// Error log raw data constants.  Used to describe allocation type or
// service call that failed.  These codes are encoded in the lower word
// by the 'SrvLogServiceFailure' macro above, therefore the value must
// fit into 2 bytes.
//
// Not every error is logged.  There is an error code filter that weeds out
//  some of the most common, and somewhat expected, error codes.  However,
//  a component bypasses this error code weeding if the 0x1 bit is set in
//  the constant.
//
// These numeric codes are arbitrary, just ensure they are unique
//
//

#define SRV_TABLE_FILE                      0x300
#define SRV_TABLE_SEARCH                    0x302
#define SRV_TABLE_SESSION                   0x304
#define SRV_TABLE_TREE_CONNECT              0x306

#define SRV_RSRC_BLOCKING_IO                0x308
#define SRV_RSRC_FREE_CONNECTION            0x30a
#define SRV_RSRC_FREE_RAW_WORK_CONTEXT      0x30c
#define SRV_RSRC_FREE_WORK_CONTEXT          0x30e

#define SRV_SVC_IO_CREATE_FILE              0x310
#define SRV_SVC_KE_WAIT_MULTIPLE            0x312
#define SRV_SVC_KE_WAIT_SINGLE              0x314
#define SRV_SVC_LSA_CALL_AUTH_PACKAGE       0x317       // log all codes
#define SRV_SVC_NT_IOCTL_FILE               0x31a
#define SRV_SVC_NT_QUERY_EAS                0x31c
#define SRV_SVC_NT_QUERY_INFO_FILE          0x31e
#define SRV_SVC_NT_QUERY_VOL_INFO_FILE      0x320
#define SRV_SVC_NT_READ_FILE                0x322
#define SRV_SVC_NT_REQ_WAIT_REPLY_PORT      0x324
#define SRV_SVC_NT_SET_EAS                  0x326
#define SRV_SVC_NT_SET_INFO_FILE            0x328
#define SRV_SVC_NT_SET_INFO_PROCESS         0x32a
#define SRV_SVC_NT_SET_INFO_THREAD          0x32c
#define SRV_SVC_NT_SET_VOL_INFO_FILE        0x32e
#define SRV_SVC_NT_WRITE_FILE               0x330
#define SRV_SVC_OB_REF_BY_HANDLE            0x333       // log all codes
#define SRV_SVC_PS_CREATE_SYSTEM_THREAD     0x334
#define SRV_SVC_SECURITY_PKG_PROBLEM        0x337       // log all codes
#define SRV_SVC_LSA_LOOKUP_PACKAGE          0x339       // log all codes
#define SRV_SVC_IO_CREATE_FILE_NPFS         0x33a
#define SRV_SVC_PNP_TDI_NOTIFICATION        0x33c
#define SRV_SVC_IO_FAST_QUERY_NW_ATTRS      0x33e
#define SRV_SVC_PS_TERMINATE_SYSTEM_THREAD  0x341       // log all codes
#define SRV_SVC_MDL_COMPLETE                0x342
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\srv\blktree.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    blktree.c

Abstract:

    This module implements routines for managing tree connect blocks.

Author:

    Chuck Lenzmeier (chuckl) 4-Oct-1989

Revision History:

--*/

#include "precomp.h"
#include "blktree.tmh"
#pragma hdrstop

#define BugCheckFileId SRV_FILE_BLKTREE

#ifdef ALLOC_PRAGMA
#pragma alloc_text( PAGE, SrvAllocateTreeConnect )
#pragma alloc_text( PAGE, SrvCheckAndReferenceTreeConnect )
#pragma alloc_text( PAGE, SrvCloseTreeConnect )
#pragma alloc_text( PAGE, SrvCloseTreeConnectsOnShare )
#pragma alloc_text( PAGE, SrvDereferenceTreeConnect )
#pragma alloc_text( PAGE, SrvFreeTreeConnect )
#endif


VOID
SrvAllocateTreeConnect (
    OUT PTREE_CONNECT *TreeConnect,
    IN PUNICODE_STRING ServerName OPTIONAL
    )

/*++

Routine Description:

    This function allocates a TreeConnect Block from the FSP heap.

Arguments:

    TreeConnect - Returns a pointer to the tree connect block, or NULL
        if no heap space was available.

    ServerName - the name of the server to which the client is connecting

Return Value:

    None.

--*/

{
    PNONPAGED_HEADER header;
    PTREE_CONNECT treeConnect;
    CLONG numberOfBytes; 

    PAGED_CODE( );

    //
    // Attempt to allocate from the heap.
    //

    numberOfBytes = sizeof( TREE_CONNECT );
    if( ARGUMENT_PRESENT( ServerName ) ) {
        numberOfBytes += ServerName->Length;
    }

    treeConnect = ALLOCATE_HEAP( numberOfBytes, BlockTypeTreeConnect );
    *TreeConnect = treeConnect;

    if ( treeConnect == NULL ) {
        INTERNAL_ERROR(
            ERROR_LEVEL_EXPECTED,
            "SrvAllocateTreeConnect: Unable to allocate %d bytes from heap",
            sizeof( TREE_CONNECT ),
            NULL
            );

        // An error will be logged by the caller.

        return;
    }
    IF_DEBUG(HEAP) {
        SrvPrint1( "SrvAllocateTreeConnect: Allocated tree connect at %p\n",
                    treeConnect );
    }

    //
    // Allocate the nonpaged header.
    //

    header = ALLOCATE_NONPAGED_POOL(
                sizeof(NONPAGED_HEADER),
                BlockTypeNonpagedHeader
                );
    if ( header == NULL ) {
        INTERNAL_ERROR(
            ERROR_LEVEL_EXPECTED,
            "SrvAllocateTreeConnect: Unable to allocate %d bytes from pool.",
            sizeof( NONPAGED_HEADER ),
            NULL
            );
        FREE_HEAP( treeConnect );
        *TreeConnect = NULL;
        return;
    }

    header->Type = BlockTypeTreeConnect;
    header->PagedBlock = treeConnect;

    RtlZeroMemory( treeConnect, numberOfBytes );

    treeConnect->NonpagedHeader = header;

    SET_BLOCK_TYPE_STATE_SIZE( treeConnect, BlockTypeTreeConnect, BlockStateActive, sizeof( TREE_CONNECT) );
    header->ReferenceCount = 2; // allow for Active status and caller's pointer

    //
    // Set up the time at which the tree connect block was allocated.
    //
    KeQuerySystemTime( &treeConnect->StartTime );

    //
    // Save the ServerName, if supplied
    //
    if( ARGUMENT_PRESENT( ServerName ) ) {
        treeConnect->ServerName.Buffer = (PWCHAR)(treeConnect + 1);
        treeConnect->ServerName.MaximumLength = ServerName->Length;
        RtlCopyUnicodeString( &treeConnect->ServerName, ServerName );
    }

#if SRVDBG2
    treeConnect->BlockHeader.ReferenceCount = 2; // for INITIALIZE_REFERENCE_HISTORY
#endif
    INITIALIZE_REFERENCE_HISTORY( treeConnect );

    INCREMENT_DEBUG_STAT( SrvDbgStatistics.TreeConnectInfo.Allocations );

    return;

} // SrvAllocateTreeConnect


BOOLEAN SRVFASTCALL
SrvCheckAndReferenceTreeConnect (
    PTREE_CONNECT TreeConnect
    )

/*++

Routine Description:

    This function atomically verifies that a tree connect is active and
    increments the reference count on the tree connect if it is.

Arguments:

    TreeConnect - Address of tree connect

Return Value:

    BOOLEAN - Returns TRUE if the tree connect is active, FALSE otherwise.

--*/

{
    PAGED_CODE( );

    //
    // Acquire the lock that guards the tree connect's state field.
    //

    ACQUIRE_LOCK( &TreeConnect->Connection->Lock );

    //
    // If the tree connect is active, reference it and return TRUE.
    //

    if ( GET_BLOCK_STATE(TreeConnect) == BlockStateActive ) {

        SrvReferenceTreeConnect( TreeConnect );

        RELEASE_LOCK( &TreeConnect->Connection->Lock );

        return TRUE;

    }

    //
    // The tree connect isn't active.  Return FALSE.
    //

    RELEASE_LOCK( &TreeConnect->Connection->Lock );

    return FALSE;

} // SrvCheckAndReferenceTreeConnect


VOID
SrvCloseTreeConnect (
    IN PTREE_CONNECT TreeConnect
    )

/*++

Routine Description:

    This routine does the core of a tree disconnect.  It sets the state
    of the tree connect to Closing, closes all files open on the tree
    connect, and dereferences the tree connect block.  The block will be
    destroyed as soon as all other references to it are eliminated.

Arguments:

    TreeConnect - Supplies a pointer to the tree connect block that is
        to be closed.

Return Value:

    None.

--*/

{
    PAGED_CODE( );

    ACQUIRE_LOCK( &TreeConnect->Connection->Lock );

    if ( GET_BLOCK_STATE(TreeConnect) == BlockStateActive ) {

        IF_DEBUG(BLOCK1) SrvPrint1( "Closing tree at %p\n", TreeConnect );

        SET_BLOCK_STATE( TreeConnect, BlockStateClosing );

        RELEASE_LOCK( &TreeConnect->Connection->Lock );
        //
        // Close any open files or pending transactions on this tree
        // connect.
        //

        SrvCloseRfcbsOnTree( TreeConnect );

        SrvCloseTransactionsOnTree( TreeConnect );

        //
        // Close any open DOS searches on this tree connect.
        //

        SrvCloseSearches(
            TreeConnect->Connection,
            (PSEARCH_FILTER_ROUTINE)SrvSearchOnTreeConnect,
            (PVOID)TreeConnect,
            NULL
            );

        //
        // Close any cached directories on this connection
        //
        SrvCloseCachedDirectoryEntries( TreeConnect->Connection );

        //
        // Dereference the tree connect (to indicate that it's no longer
        // open).
        //

        SrvDereferenceTreeConnect( TreeConnect );

        INCREMENT_DEBUG_STAT( SrvDbgStatistics.TreeConnectInfo.Closes );

    } else {

        RELEASE_LOCK( &TreeConnect->Connection->Lock );

    }

    return;

} // SrvCloseTreeConnect


VOID
SrvCloseTreeConnectsOnShare (
    IN PSHARE Share
    )

/*++

Routine Description:

    This function close all tree connects on a given share.

Arguments:

    Share - A pointer to the share block.

Return Value:

    None.

--*/

{
    PLIST_ENTRY treeConnectEntry, nextTreeConnectEntry;
    PTREE_CONNECT treeConnect;

    PAGED_CODE( );

    //
    // Acquire the lock that protects the share's tree connect list.
    //
    // *** Note that this routine can be called with this lock already
    //     held by SrvCloseShare from SrvNetShareDel.
    //

    ACQUIRE_LOCK( &SrvShareLock );

    //
    // Loop through the list of TreeConnects for the given share,
    // closing all of them.  The share block and the list are guaranteed
    // to remain valid because we hold the share lock.
    //

    treeConnectEntry = Share->TreeConnectList.Flink;

    while ( treeConnectEntry != &Share->TreeConnectList ) {

        //
        // Capture the address of the next tree connect now, because
        // we're about to close the current one, and we can look at it
        // after we've done that.
        //

        nextTreeConnectEntry = treeConnectEntry->Flink;

        //
        // Close the tree connect.  This will close all files open on
        // this tree connect, and will stop blocked activity on the tree
        // connect.  The tree connect itself will not be removed from
        // the share's TreeConnect list until its reference count
        // reaches zero.
        //

        treeConnect = CONTAINING_RECORD(
                          treeConnectEntry,
                          TREE_CONNECT,
                          ShareListEntry
                          );

        SrvCloseTreeConnect( treeConnect );

        //
        // Point to the next tree connect.
        //

        treeConnectEntry = nextTreeConnectEntry;

    }

    //
    // Release the share's tree connect list lock.
    //

    RELEASE_LOCK( &SrvShareLock );

} // SrvCloseTreeConnectsOnShare


VOID SRVFASTCALL
SrvDereferenceTreeConnect (
    IN PTREE_CONNECT TreeConnect
    )

/*++

Routine Description:

    This function decrements the reference count on a tree connect.  If
    the reference count goes to zero, the tree connect block is deleted.

    Since this routine may call SrvDereferenceConnection, the caller
    must be careful if he holds the connection lock that he also
    holds a referenced pointer to the connection.

Arguments:

    TreeConnect - Address of tree connect

Return Value:

    None.

--*/

{
    PCONNECTION connection;
    LONG result;

    PAGED_CODE( );

    //
    // Enter a critical section and decrement the reference count on the
    // block.
    //

    connection = TreeConnect->Connection;

    IF_DEBUG(REFCNT) {
        SrvPrint2( "Dereferencing tree connect %p; old refcnt %lx\n",
                    TreeConnect, TreeConnect->NonpagedHeader->ReferenceCount );
    }

    ASSERT( GET_BLOCK_TYPE( TreeConnect ) == BlockTypeTreeConnect );
    ASSERT( TreeConnect->NonpagedHeader->ReferenceCount > 0 );
    UPDATE_REFERENCE_HISTORY( TreeConnect, TRUE );

    result = InterlockedDecrement(
                &TreeConnect->NonpagedHeader->ReferenceCount
                );

    if ( result == 0 ) {

        //
        // The new reference count is 0, meaning that it's time to
        // delete this block.
        //
        // Free the tree connect entry in the tree table.  (Note that
        // the connection lock guards this table.)
        //

        ACQUIRE_LOCK( &connection->Lock );

        SrvRemoveEntryTable(
            &connection->PagedConnection->TreeConnectTable,
            TID_INDEX( TreeConnect->Tid )
            );

        if( TreeConnect->Session )
        {
            DEBUG TreeConnect->Session = NULL;

            RELEASE_LOCK( &connection->Lock );

            SrvDereferenceSession( TreeConnect->Session );
        }
        else
        {
            RELEASE_LOCK( &connection->Lock );
        }

        //
        // Remove the tree connect from the list of active tree connects
        // for the share.
        //

        SrvRemoveEntryOrderedList( &SrvTreeConnectList, TreeConnect );

        //
        // Take the tree connect off the list of tree connects for the
        // share and decrement the count of active uses of the share.
        //

        ACQUIRE_LOCK( &SrvShareLock );

        SrvRemoveEntryList(
            &TreeConnect->Share->TreeConnectList,
            &TreeConnect->ShareListEntry
            );

        RELEASE_LOCK( &SrvShareLock );

        //
        // Dereference the share and the connection.
        //

        SrvDereferenceShareForTreeConnect( TreeConnect->Share );
        DEBUG TreeConnect->Share = NULL;

        SrvDereferenceConnection( connection );
        DEBUG TreeConnect->Connection = NULL;       

        //
        // Free the tree connect block.
        //

        SrvFreeTreeConnect( TreeConnect );

    }

    return;

} // SrvDereferenceTreeConnect


VOID
SrvFreeTreeConnect (
    IN PTREE_CONNECT TreeConnect
    )

/*++

Routine Description:

    This function returns a TreeConnect Block to the FSP heap.

Arguments:

    TreeConnect - Address of tree connect

Return Value:

    None.

--*/

{
    PAGED_CODE( );

    DEBUG SET_BLOCK_TYPE_STATE_SIZE( TreeConnect, BlockTypeGarbage, BlockStateDead, -1 );
    DEBUG TreeConnect->NonpagedHeader->ReferenceCount = -1;

    TERMINATE_REFERENCE_HISTORY( TreeConnect );

    DEALLOCATE_NONPAGED_POOL( TreeConnect->NonpagedHeader );
    FREE_HEAP( TreeConnect );
    IF_DEBUG(HEAP) {
        SrvPrint1( "SrvFreeTreeConnect: Freed tree connect block at %p\n",
                    TreeConnect );
    }

    INCREMENT_DEBUG_STAT( SrvDbgStatistics.TreeConnectInfo.Frees );

    return;

} // SrvFreeTreeConnect


VOID
SrvDisconnectTreeConnectsFromSession (
    PCONNECTION connection,
    PSESSION Session
    )

/*++

Routine Description:

    This routine removes the session association on all associated
    TreeConnects and dereferences the session, allowing the session
    to exit normally.  The caller MUST have the Connection Lock acquired.
    
Arguments:

    Connection - The connection we're walking           
    Session - Supplies a pointer to the session block for which
        transactions are to be closed.

Return Value:

    None.

--*/

{
    PTABLE_HEADER tableHeader;
    PLIST_ENTRY entry;
    USHORT i;

    PAGED_CODE( );

    SrvReferenceSession( Session );

    tableHeader = &connection->PagedConnection->SessionTable;

    for ( i = 0; i < tableHeader->TableSize; i++ ) {

        PTREE_CONNECT treeConnect =
                    (PTREE_CONNECT)tableHeader->Table[i].Owner;

        if ( treeConnect != NULL  ) {

            if( treeConnect->Session == Session )
            {
                SrvDereferenceSession( Session );
                treeConnect->Session = NULL;
            }
        }
    }

    SrvDereferenceSession( Session );

} // SrvDisconnectTreeConnectsFromSession
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\srv\fsd.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    fsd.c

Abstract:

    This module implements the File System Driver for the LAN Manager
    server.

Author:

    Chuck Lenzmeier (chuckl)    22-Sep-1989

Revision History:

--*/

//
//  This module is laid out as follows:
//      Includes
//      Local #defines
//      Local type definitions
//      Forward declarations of local functions
//      Device driver entry points
//      Server I/O completion routine
//      Server transport event handlers
//      SMB processing support routines
//

#include "precomp.h"
#include "fsd.tmh"
#pragma hdrstop

#define BugCheckFileId SRV_FILE_FSD

extern UNICODE_STRING SrvDeviceName;
extern UNICODE_STRING SrvRegistryPath;

// We allow a connection a couple extra work contexts to cover the MAILSLOT and ECHO operation cases
#define MAX_MPX_MARGIN 10

//
// Forward declarations
//

NTSTATUS
DriverEntry (
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    );

VOID
UnloadServer (
    IN PDRIVER_OBJECT DriverObject
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text( INIT, DriverEntry )
#pragma alloc_text( PAGE, UnloadServer )
#pragma alloc_text( PAGE, SrvPnpBindingHandler )
#pragma alloc_text( PAGE8FIL, SrvFsdOplockCompletionRoutine )
#pragma alloc_text( PAGE8FIL, SrvFsdRestartSendOplockIItoNone )
#endif
#if 0
NOT PAGEABLE -- SrvFsdIoCompletionRoutine
NOT PAGEABLE -- SrvFsdSendCompletionRoutine
NOT PAGEABLE -- SrvFsdTdiConnectHandler
NOT PAGEABLE -- SrvFsdTdiDisconnectHandler
NOT PAGEABLE -- SrvFsdTdiReceiveHandler
NOT PAGEABLE -- SrvFsdGetReceiveWorkItem
NOT PAGEABLE -- SrvFsdRestartSmbComplete
NOT PAGEABLE -- SrvFsdRestartSmbAtSendCompletion
NOT PAGEABLE -- SrvFsdServiceNeedResourceQueue
NOT PAGEABLE -- SrvAddToNeedResourceQueue
#endif

#if SRVDBG_STATS2
ULONG IndicationsCopied = 0;
ULONG IndicationsNotCopied = 0;
#endif

extern BOOLEAN RunSuspectConnectionAlgorithm;


NTSTATUS
DriverEntry (
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    )

/*++

Routine Description:

    This is the initialization routine for the LAN Manager server file
    system driver.  This routine creates the device object for the
    LanmanServer device and performs all other driver initialization.

Arguments:

    DriverObject - Pointer to driver object created by the system.

Return Value:

    The function value is the final status from the initialization operation.

--*/

{
    NTSTATUS status;
    CLONG i;

    PAGED_CODE( );

    //
    // Make sure we haven't messed up the size of a WORK_QUEUE structure.
    //  Really needs to be a multiple of CACHE_LINE_SIZE bytes to get
    //  proper performance on MP systems.
    //
    // This code gets optimized out when the size is correct.
    //
    if( sizeof( WORK_QUEUE ) & (CACHE_LINE_SIZE-1) ) {
        KdPrint(( "sizeof(WORK_QUEUE) == %d!\n", sizeof( WORK_QUEUE )));
        KdPrint(("Fix the WORK_QUEUE structure to be multiple of CACHE_LINE_SIZE!\n" ));
        DbgBreakPoint();
    }

#if SRVDBG_BREAK
    KdPrint(( "SRV: At DriverEntry\n" ));
    DbgBreakPoint( );
#endif

#if 0
    SrvDebug.QuadPart = DEBUG_ERRORS | DEBUG_SMB_ERRORS | DEBUG_TDI | DEBUG_PNP;
#endif

    IF_DEBUG(FSD1) KdPrint(( "SrvFsdInitialize entered\n" ));

#ifdef MEMPRINT
    //
    // Initialize in-memory printing.
    //

    MemPrintInitialize( );
#endif

    //
    // Create the device object.  (IoCreateDevice zeroes the memory
    // occupied by the object.)
    //
    // !!! Apply an ACL to the device object.
    //

    RtlInitUnicodeString(& SrvDeviceName, StrServerDevice);

    status = IoCreateDevice(
                 DriverObject,                   // DriverObject
                 sizeof(DEVICE_EXTENSION),       // DeviceExtension
                 & SrvDeviceName,                // DeviceName
                 FILE_DEVICE_NETWORK,            // DeviceType
                 0,                              // DeviceCharacteristics
                 FALSE,                          // Exclusive
                 &SrvDeviceObject                // DeviceObject
                 );

    if ( !NT_SUCCESS(status) ) {
        INTERNAL_ERROR(
            ERROR_LEVEL_EXPECTED,
            "SrvFsdInitialize: Unable to create device object: %X",
            status,
            NULL
            );

        SrvLogError(
            DriverObject,
            EVENT_SRV_CANT_CREATE_DEVICE,
            status,
            NULL,
            0,
            NULL,
            0
            );
        return status;
    }

    IF_DEBUG(FSD1) {
        KdPrint(( "  Server device object: 0x%p\n", SrvDeviceObject ));
    }

    //
    // Initialize the driver object for this file system driver.
    //

    DriverObject->DriverUnload = UnloadServer;
    for (i = 0; i <= IRP_MJ_MAXIMUM_FUNCTION; i++) {
        DriverObject->MajorFunction[i] = SrvFsdDispatch;
    }

    //
    // Initialize global data fields.
    //

    SrvInitializeData( );

    // Remember registry path
    //
    SrvRegistryPath.MaximumLength = RegistryPath->Length + sizeof(UNICODE_NULL);
    SrvRegistryPath.Buffer = ExAllocatePool(PagedPool,
                                            SrvRegistryPath.MaximumLength);
    if (SrvRegistryPath.Buffer != NULL) {
        RtlCopyUnicodeString(& SrvRegistryPath, RegistryPath);
    }
    else {
        SrvRegistryPath.Length = SrvRegistryPath.MaximumLength = 0;
    }

    IF_DEBUG(FSD1) KdPrint(( "SrvFsdInitialize complete\n" ));

    return (status);

} // DriverEntry


VOID
UnloadServer (
    IN PDRIVER_OBJECT DriverObject
    )

/*++

Routine Description:

    This is the unload routine for the server driver.

Arguments:

    DriverObject - Pointer to server driver object.

Return Value:

    None.

--*/

{
    PAGED_CODE( );

    ExFreePool(SrvRegistryPath.Buffer);

    //
    // If we are using a smart card to accelerate direct host IPX clients,
    //   let it know we are going away.
    //
    if( SrvIpxSmartCard.DeRegister ) {
        IF_DEBUG( SIPX ) {
            KdPrint(("Calling Smart Card DeRegister\n" ));
        }
        SrvIpxSmartCard.DeRegister();
    }


    //
    // Clean up global data structures.
    //

    SrvTerminateData( );

    //
    // Delete the server's device object.
    //

    IoDeleteDevice( SrvDeviceObject );

    return;

} // UnloadServer


NTSTATUS
SrvFsdIoCompletionRoutine (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    )

/*++

Routine Description:

    This is the I/O completion routine for the server.  It is specified
    as the completion routine for asynchronous I/O requests issued by
    the server.  It simply calls the restart routine specified for the
    work item when the asynchronous request was started.

Arguments:

    DeviceObject - Pointer to target device object for the request.

    Irp - Pointer to I/O request packet

    Context - Caller-specified context parameter associated with IRP.
        This is actually a pointer to a Work Context block.

Return Value:

    NTSTATUS - If STATUS_MORE_PROCESSING_REQUIRED is returned, I/O
        completion processing by IoCompleteRequest terminates its
        operation.  Otherwise, IoCompleteRequest continues with I/O
        completion.

--*/

{
    KIRQL oldIrql;

    DeviceObject;   // prevent compiler warnings

    IF_DEBUG(FSD2) {
        KdPrint(( "SrvFsdIoCompletionRoutine entered for IRP 0x%p\n", Irp ));
    }

#if DBG
    if( Irp->Type != (CSHORT) IO_TYPE_IRP ) {
        DbgPrint( "SRV: Irp->Type = %u!\n", Irp->Type );
        DbgBreakPoint();
    }
#endif

    //
    // Reset the IRP cancelled bit.
    //

    Irp->Cancel = FALSE;

    //
    // Call the restart routine associated with the work item.
    //

    IF_DEBUG(FSD2) {
        KdPrint(( "FSD working on work context 0x%p", Context ));
    }
    KeRaiseIrql( DISPATCH_LEVEL, &oldIrql );
    ((PWORK_CONTEXT)Context)->FsdRestartRoutine( (PWORK_CONTEXT)Context );
    KeLowerIrql( oldIrql );

    //
    // Return STATUS_MORE_PROCESSING_REQUIRED so that IoCompleteRequest
    // will stop working on the IRP.
    //

    return STATUS_MORE_PROCESSING_REQUIRED;

} // SrvFsdIoCompletionRoutine


NTSTATUS
SrvFsdSendCompletionRoutine (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    )

/*++

Routine Description:

    This is the TDI send completion routine for the server. It simply
    calls the restart routine specified for the work item when the
    send request was started.

    !!! This routine does the exact same thing as SrvFsdIoCompletionRoutine.
        It offers, however, a convienient network debugging routine since
        it completes only sends.

Arguments:

    DeviceObject - Pointer to target device object for the request.

    Irp - Pointer to I/O request packet

    Context - Caller-specified context parameter associated with IRP.
        This is actually a pointer to a Work Context block.

Return Value:

    NTSTATUS - If STATUS_MORE_PROCESSING_REQUIRED is returned, I/O
        completion processing by IoCompleteRequest terminates its
        operation.  Otherwise, IoCompleteRequest continues with I/O
        completion.

--*/

{
    KIRQL oldIrql;
    PWORK_CONTEXT WorkContext = (PWORK_CONTEXT)(Context);
    DeviceObject;   // prevent compiler warnings

    IF_DEBUG(FSD2) {
        KdPrint(( "SrvFsdSendCompletionRoutine entered for IRP 0x%p\n", Irp ));
    }

    //
    // Check the status of the send completion.
    //

    CHECK_SEND_COMPLETION_STATUS( Irp->IoStatus.Status );

    //
    // Reset the IRP cancelled bit.
    //

    Irp->Cancel = FALSE;

    //
    // Call the restart routine associated with the work item.
    //

    IF_DEBUG(FSD2) {
        KdPrint(( "FSD working on work context 0x%p", Context ));
    }
    KeRaiseIrql( DISPATCH_LEVEL, &oldIrql );
    ((PWORK_CONTEXT)Context)->FsdRestartRoutine( (PWORK_CONTEXT)Context );
    KeLowerIrql( oldIrql );

    //
    // Return STATUS_MORE_PROCESSING_REQUIRED so that IoCompleteRequest
    // will stop working on the IRP.
    //

    return STATUS_MORE_PROCESSING_REQUIRED;

} // SrvFsdSendCompletionRoutine


NTSTATUS
SrvFsdOplockCompletionRoutine (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    )

/*++

Routine Description:

    This is the I/O completion routine oplock requests.

Arguments:

    DeviceObject - Pointer to target device object for the request.

    Irp - Pointer to I/O request packet

    Context - A pointer to the oplock context block.

Return Value:

    NTSTATUS - If STATUS_MORE_PROCESSING_REQUIRED is returned, I/O
        completion processing by IoCompleteRequest terminates its
        operation.  Otherwise, IoCompleteRequest continues with I/O
        completion.

--*/

{
    PRFCB rfcb = Context;

    UNLOCKABLE_CODE( 8FIL );

    DeviceObject;   // prevent compiler warnings

    IF_DEBUG(FSD2) {
        KdPrint(( "SrvFsdOplockCompletionRoutine entered for IRP 0x%p\n", Irp ));
    }

    //
    // Queue the oplock context to the FSP work queue, except in the
    // following special case: If a level I oplock request failed, and
    // we want to retry for level II, simply set the oplock retry event
    // and dismiss IRP processing.  This is useful because it eliminates
    // a trip to an FSP thread and necessary in order to avoid a
    // deadlock where all of the FSP threads are waiting for their
    // oplock retry events.
    //

    IF_DEBUG(FSD2) {
        KdPrint(( "FSD working on work context 0x%p", Context ));
    }

    if ( (rfcb->RetryOplockRequest != NULL) &&
         !NT_SUCCESS(Irp->IoStatus.Status) ) {

        //
        // Set the event that tells the oplock request routine that it
        // is OK to retry the request.
        //

        IF_DEBUG(OPLOCK) {
            KdPrint(( "SrvFsdOplockCompletionRoutine: oplock retry event "
                        "set for RFCB %p\n", rfcb ));
        }

        KeSetEvent(
            rfcb->RetryOplockRequest,
            EVENT_INCREMENT,
            FALSE );

        return STATUS_MORE_PROCESSING_REQUIRED;

    }

    //
    // Insert the RFCB at the tail of the nonblocking work queue.
    //

    rfcb->FspRestartRoutine = SrvOplockBreakNotification;

    SrvInsertWorkQueueTail(
        rfcb->Connection->PreferredWorkQueue,
        (PQUEUEABLE_BLOCK_HEADER)rfcb
        );

    //
    // Return STATUS_MORE_PROCESSING_REQUIRED so that IoCompleteRequest
    // will stop working on the IRP.
    //

    return STATUS_MORE_PROCESSING_REQUIRED;

} // SrvFsdOplockCompletionRoutine


NTSTATUS
SrvFsdTdiConnectHandler(
    IN PVOID TdiEventContext,
    IN int RemoteAddressLength,
    IN PVOID RemoteAddress,
    IN int UserDataLength,
    IN PVOID UserData,
    IN int OptionsLength,
    IN PVOID Options,
    OUT CONNECTION_CONTEXT *ConnectionContext,
    OUT PIRP *AcceptIrp
    )

/*++

Routine Description:

    This is the transport connect event handler for the server.  It is
    specified as the connect handler for all endpoints opened by the
    server.  It attempts to dequeue a free connection from a list
    anchored in the endpoint.  If successful, it returns the connection
    to the transport.  Otherwise, the connection is rejected.

Arguments:

    TdiEventContext -

    RemoteAddressLength -

    RemoteAddress -

    UserDataLength -

    UserData -

    OptionsLength -

    Options -

    ConnectionContext -

Return Value:

    NTSTATUS - !!! (apparently ignored by transport driver)

--*/

{
    PENDPOINT endpoint;
    PLIST_ENTRY listEntry;
    PCONNECTION connection;
    PWORK_CONTEXT workContext;
    PTA_NETBIOS_ADDRESS address;
    KIRQL oldIrql;
    PWORK_QUEUE queue = PROCESSOR_TO_QUEUE();

    UserDataLength, UserData;               // avoid compiler warnings
    OptionsLength, Options;

    endpoint = (PENDPOINT)TdiEventContext;

    IF_DEBUG(FSD2) {
        KdPrint(( "SrvFsdTdiConnectHandler entered for endpoint 0x%p\n",
                    endpoint ));
    }

    if( SrvCompletedPNPRegistration == FALSE ) {
        //
        // Do not become active on any single transport until all of the
        //   transports have been registered
        //
        return STATUS_REQUEST_NOT_ACCEPTED;
    }

    //
    // Take a receive work item off the free list.
    //

    ALLOCATE_WORK_CONTEXT( queue, &workContext );

    if ( workContext == NULL ) {

        //
        // We're out of WorkContext structures, and we aren't able to allocate
        // any more just now.  Let's at least cause a worker thread to allocate some more
        // by incrementing the NeedWorkItem counter.  This will cause the next
        // freed WorkContext structure to get dispatched to SrvServiceWorkItemShortage.
        // While SrvServiceWorkItemShortage probably won't find any work to do, it will
        // allocate more WorkContext structures if it can.  Clients generally retry
        // on connection attempts -- perhaps we'll have a free WorkItem structure next time.
        //

        InterlockedIncrement( &queue->NeedWorkItem );

        // Set it up to refill the connection cache
        // We need to do this because previous attempts could have failed due to
        // out-of-memory, leaving us in a state where we don't try to refill anymore
        if( GET_BLOCK_STATE(endpoint) == BlockStateActive )
        {
            SrvResourceFreeConnection = TRUE;
            SrvFsdQueueExWorkItem(
                &SrvResourceThreadWorkItem,
                &SrvResourceThreadRunning,
                CriticalWorkQueue
                );
        }

        INTERNAL_ERROR(
            ERROR_LEVEL_EXPECTED,
            "SrvFsdTdiConnectHandler: no work item available",
            NULL,
            NULL
            );

        return STATUS_INSUFFICIENT_RESOURCES;
    }

    KeRaiseIrql( DISPATCH_LEVEL, &oldIrql );

    ACQUIRE_DPC_GLOBAL_SPIN_LOCK( Fsd );

    //
    // Take a connection off the endpoint's free connection list.
    //
    // *** Note that all of the modifications done to the connection
    //     block are done with the spin lock held.  This ensures that
    //     closing of the endpoint's connections will work properly
    //     if it happens simultaneously.  Note that we assume that the
    //     endpoint is active here.  When the TdiAccept completes, we
    //     check the endpoint state.
    //

    listEntry = RemoveHeadList( &endpoint->FreeConnectionList );

    if ( listEntry == &endpoint->FreeConnectionList ) {

        //
        // Unable to get a free connection.
        //
        // Dereference the work item manually.  We cannot call
        // SrvDereferenceWorkItem from here.
        //

        RELEASE_DPC_GLOBAL_SPIN_LOCK( Fsd );
        KeLowerIrql( oldIrql );

        ASSERT( workContext->BlockHeader.ReferenceCount == 1 );
        workContext->BlockHeader.ReferenceCount = 0;

        RETURN_FREE_WORKITEM( workContext );


        IF_DEBUG(TDI) {
            KdPrint(( "SrvFsdTdiConnectHandler: no connection available\n" ));
        }

        SrvOutOfFreeConnectionCount++;

        // Set it up to refill the connection cache
        // We need to do this because previous attempts could have failed due to
        // out-of-memory, leaving us in a state where we don't try to refill anymore
        if( GET_BLOCK_STATE(endpoint) == BlockStateActive )
        {
            SrvResourceFreeConnection = TRUE;
            SrvFsdQueueExWorkItem(
                &SrvResourceThreadWorkItem,
                &SrvResourceThreadRunning,
                CriticalWorkQueue
                );
        }

        return STATUS_INSUFFICIENT_RESOURCES;
    }

    endpoint->FreeConnectionCount--;

    //
    // Wake up the resource thread to create a new free connection for
    // the endpoint.
    //

    if ( (endpoint->FreeConnectionCount < SrvFreeConnectionMinimum) &&
         (GET_BLOCK_STATE(endpoint) == BlockStateActive) ) {
        SrvResourceFreeConnection = TRUE;
        SrvFsdQueueExWorkItem(
            &SrvResourceThreadWorkItem,
            &SrvResourceThreadRunning,
            CriticalWorkQueue
            );
    }

    RELEASE_DPC_GLOBAL_SPIN_LOCK( Fsd );

    //
    // Reference the connection twice -- once to account for its being
    // "open", and once to account for the Accept request we're about
    // to issue.
    //

    connection = CONTAINING_RECORD(
                    listEntry,
                    CONNECTION,
                    EndpointFreeListEntry
                    );


    ACQUIRE_DPC_SPIN_LOCK( connection->EndpointSpinLock );

#if SRVDBG29
    if ( GET_BLOCK_STATE(connection) == BlockStateActive ) {
        KdPrint(( "SRV: Connection %x is ACTIVE on free connection list!\n", connection ));
        DbgBreakPoint( );
    }
    if ( connection->BlockHeader.ReferenceCount != 0 ) {
        KdPrint(( "SRV: Connection %x has nonzero refcnt on free connection list!\n", connection ));
        DbgBreakPoint( );
    }
    UpdateConnectionHistory( "CONN", endpoint, connection );
#endif

    SrvReferenceConnectionLocked( connection );
    SrvReferenceConnectionLocked( connection );

    //
    // Indicate that we are a VC-oriented connection
    //
    connection->DirectHostIpx = FALSE;

    //
    // Set the processor affinity
    //
    connection->PreferredWorkQueue = queue;
    connection->CurrentWorkQueue = queue;

    InterlockedIncrement( &queue->CurrentClients );

#if MULTIPROCESSOR
    //
    // Get this client onto the best processor
    //
    SrvBalanceLoad( connection );
#endif

    //
    // Initialize the SMB security signature handling
    //
    connection->SmbSecuritySignatureActive = FALSE;

    //
    // Put the work item on the in-progress list.
    //

    SrvInsertTailList(
        &connection->InProgressWorkItemList,
        &workContext->InProgressListEntry
        );
    connection->InProgressWorkContextCount++;

    //
    // Set the last used timestamp for this connection
    //
    GET_SERVER_TIME( connection->CurrentWorkQueue, &connection->LastRequestTime );

    //
    // Mark the connection active.
    //

    SET_BLOCK_STATE( connection, BlockStateActive );

    //
    // Now we can release the spin lock.
    //

    RELEASE_DPC_SPIN_LOCK( connection->EndpointSpinLock );

    //
    // Save the client's address/name in the connection block.
    //
    // *** This code only handles NetBIOS names!
    //

    address = (PTA_NETBIOS_ADDRESS)RemoteAddress;
    ASSERT( address->TAAddressCount == 1 );
    ASSERT( address->Address[0].AddressType == TDI_ADDRESS_TYPE_NETBIOS );
    ASSERT( address->Address[0].AddressLength == sizeof(TDI_ADDRESS_NETBIOS) );
    ASSERT( address->Address[0].Address[0].NetbiosNameType ==
                                            TDI_ADDRESS_NETBIOS_TYPE_UNIQUE );

    //
    // Copy the oem name at this time.  We convert it to unicode when
    // we get to the fsp.
    //

    {
        ULONG len;
        PCHAR oemClientName = address->Address[0].Address[0].NetbiosName;
        ULONG oemClientNameLength =
                    (MIN( RemoteAddressLength, COMPUTER_NAME_LENGTH ));

        PCHAR clientMachineName = connection->OemClientMachineName;

        RtlCopyMemory(
                clientMachineName,
                oemClientName,
                oemClientNameLength
                );

        clientMachineName[oemClientNameLength] = '\0';

        //
        // Determine the number of characters that aren't blanks.  This is
        // used by the session APIs to simplify their processing.
        //

        for ( len = oemClientNameLength;
              len > 0 &&
                 (clientMachineName[len-1] == ' ' ||
                  clientMachineName[len-1] == '\0');
              len-- ) ;

        connection->OemClientMachineNameString.Length = (USHORT)len;

    }

    IF_DEBUG(TDI) {
        KdPrint(( "SrvFsdTdiConnectHandler accepting connection from %z on connection %p\n",
                    (PCSTRING)&connection->OemClientMachineNameString, connection ));
    }

    //
    // Convert the prebuilt TdiReceive request into a TdiAccept request.
    //

    workContext->Connection = connection;
    workContext->Endpoint = endpoint;

    (VOID)SrvBuildIoControlRequest(
            workContext->Irp,                   // input IRP address
            connection->FileObject,             // target file object address
            workContext,                        // context
            IRP_MJ_INTERNAL_DEVICE_CONTROL,     // major function
            TDI_ACCEPT,                         // minor function
            NULL,                               // input buffer address
            0,                                  // input buffer length
            NULL,                               // output buffer address
            0,                                  // output buffer length
            NULL,                               // MDL address
            NULL                                // completion routine
            );

    //
    // Make the next stack location current.  Normally IoCallDriver would
    // do this, but since we're bypassing that, we do it directly.
    //

    IoSetNextIrpStackLocation( workContext->Irp );

    //
    // Set up the restart routine.  This routine will verify that the
    // endpoint is active when the TdiAccept completes; if it isn't, the
    // connection will be closed at that time.
    //

    workContext->FsdRestartRoutine = SrvQueueWorkToFspAtDpcLevel;
    workContext->FspRestartRoutine = SrvRestartAccept;

    //
    // Return the connection context (the connection address) to the
    // transport.  Return a pointer to the Accept IRP.  Indicate that
    // the Connect event has been handled.
    //

    *ConnectionContext = connection;
    *AcceptIrp = workContext->Irp;

    KeLowerIrql( oldIrql );
    return STATUS_MORE_PROCESSING_REQUIRED;

} // SrvFsdTdiConnectHandler


NTSTATUS
SrvFsdTdiDisconnectHandler(
    IN PVOID TdiEventContext,
    IN CONNECTION_CONTEXT ConnectionContext,
    IN int DisconnectDataLength,
    IN PVOID DisconnectData,
    IN int DisconnectInformationLength,
    IN PVOID DisconnectInformation,
    IN ULONG DisconnectFlags
    )

/*++

Routine Description:

    This is the transport disconnect event handler for the server.  It
    is specified as the disconnect handler for all endpoints opened by
    the server.  It attempts to dequeue a preformatted receive item from
    a list anchored in the device object.  If successful, it turns this
    receive item into a disconnect item and queues it to the FSP work
    queue.  Otherwise, the resource thread is started to format
    additional work items and service pended (dis)connections.

Arguments:

    TransportEndpoint - Pointer to file object for receiving endpoint

    ConnectionContext - Value associated with endpoint by owner.  For
        the server, this points to a Connection block maintained in
        nonpaged pool.

    DisconnectIndicators - Set of flags indicating the status of the
        disconnect

Return Value:

    NTSTATUS - !!! (apparently ignored by transport driver)

--*/

{
    PCONNECTION connection;
    KIRQL oldIrql;

    TdiEventContext, DisconnectDataLength, DisconnectData;
    DisconnectInformationLength, DisconnectInformation, DisconnectFlags;

    if( DisconnectFlags & TDI_DISCONNECT_ABORT ) {
        SrvAbortiveDisconnects++;
    }

    connection = (PCONNECTION)ConnectionContext;

#if SRVDBG29
    UpdateConnectionHistory( "DISC", connection->Endpoint, connection );
#endif

    IF_DEBUG(FSD2) {
        KdPrint(( "SrvFsdTdiDisconnectHandler entered for endpoint 0x%p, connection 0x%p\n", TdiEventContext, connection ));
    }

    IF_DEBUG(TDI) {
        KdPrint(( "SrvFsdTdiDisconnectHandler received disconnect from %z on connection %p\n",
                    (PCSTRING)&connection->OemClientMachineNameString, connection ));
    }

    //
    // Mark the connection and wake up the resource thread so that it
    // can service the pending (dis)connections.
    //

    ACQUIRE_GLOBAL_SPIN_LOCK( Fsd, &oldIrql );
    ACQUIRE_DPC_SPIN_LOCK( connection->EndpointSpinLock );

    //
    // If the connection is already closing, don't bother queueing it to
    // the disconnect queue.
    //

    if ( GET_BLOCK_STATE(connection) != BlockStateActive ) {

        RELEASE_DPC_SPIN_LOCK( connection->EndpointSpinLock );
        RELEASE_GLOBAL_SPIN_LOCK( Fsd, oldIrql );
        return STATUS_SUCCESS;

    }

    if ( connection->DisconnectPending ) {

        //
        // Error! Error! Error!  This connection is already on
        // a queue for processing.  Ignore the disconnect request.
        //

        RELEASE_DPC_SPIN_LOCK( connection->EndpointSpinLock );
        RELEASE_GLOBAL_SPIN_LOCK( Fsd, oldIrql );

        INTERNAL_ERROR(
            ERROR_LEVEL_UNEXPECTED,
            "SrvFsdTdiDisconnectHandler:  Received unexpected disconnect"
                "indication",
            NULL,
            NULL
            );

        SrvLogSimpleEvent( EVENT_SRV_UNEXPECTED_DISC, STATUS_SUCCESS );
        return STATUS_SUCCESS;
    }

    connection->DisconnectPending = TRUE;

    if ( connection->OnNeedResourceQueue ) {

        //
        // This connection is waiting for a resource.  Take it
        // off the need resource queue before putting it on the
        // disconnect queue.
        //
        // *** Note that the connection has already been referenced to
        //     account for its being on the need-resource queue, so we
        //     don't reference it again here.
        //

        SrvRemoveEntryList(
            &SrvNeedResourceQueue,
            &connection->ListEntry
            );
        connection->OnNeedResourceQueue = FALSE;

        DEBUG connection->ReceivePending = FALSE;

    } else {

        //
        // The connection isn't already on the need-resource queue, so
        // we need to reference it before we put it on the disconnect
        // queue.  This is necessary in order to make the code in
        // scavengr.c that removes things from the queue work right.
        //

        SrvReferenceConnectionLocked( connection );

    }

    connection->DisconnectReason = DisconnectTransportIssuedDisconnect;
    SrvInsertTailList(
        &SrvDisconnectQueue,
        &connection->ListEntry
        );

    RELEASE_DPC_SPIN_LOCK( connection->EndpointSpinLock );

    SrvResourceDisconnectPending = TRUE;
    SrvFsdQueueExWorkItem(
        &SrvResourceThreadWorkItem,
        &SrvResourceThreadRunning,
        CriticalWorkQueue
        );

    RELEASE_GLOBAL_SPIN_LOCK( Fsd, oldIrql );

    return STATUS_SUCCESS;

} // SrvFsdTdiDisconnectHandler

BOOLEAN
SrvFsdAcceptReceive(
    PCONNECTION Connection,
    PBYTE Data,
    ULONG BytesIndicated,
    ULONG BytesAvailible
    )
/*++

Routine Description:

    This routine allows us to trivially reject a receive if we don't think its valid.
    This can be expanded later to include maintaining a list of bad IP addresses and other
    such DoS schemes to help protect us more.

Arguments:

    Connection - the connection this was received on

    Data - Pointer to the availible data

    BytesIndicated - the total size of the receive

    Bytes Availible - How much is currently pointed at by the Data pointer.

Return Value:

    TRUE - Accept receive, FALSE = reject receive

--*/

{
    PSMB_HEADER pHeader = (PSMB_HEADER)Data;

    //
    // Trivially reject certain packets
    //
    if( BytesIndicated < sizeof(SMB_HEADER)+sizeof(BYTE) )
    {
        return FALSE;
    }

    if( BytesAvailible > sizeof(SMB_HEADER) )
    {
        if( SmbGetUlong(Data) != SMB_HEADER_PROTOCOL )
        {
            return FALSE;
        }

        if( Connection->SmbDialect == SmbDialectIllegal &&
            pHeader->Command != SMB_COM_NEGOTIATE )
        {
            return FALSE;
        }
        else if( Connection->SmbDialect != SmbDialectIllegal &&
                 pHeader->Command == SMB_COM_NEGOTIATE )
        {
            return FALSE;
        }

        if( SrvSmbIndexTable[pHeader->Command] == ISrvSmbIllegalCommand )
        {
            return FALSE;
        }
    }

    return TRUE;
} // SrvFsdAcceptReceive


NTSTATUS
SrvFsdTdiReceiveHandler (
    IN PVOID TdiEventContext,
    IN CONNECTION_CONTEXT ConnectionContext,
    IN ULONG ReceiveFlags,
    IN ULONG BytesIndicated,
    IN ULONG BytesAvailable,
    OUT ULONG *BytesTaken,
    IN PVOID Tsdu,
    OUT PIRP *IoRequestPacket
    )

/*++

Routine Description:

    This is the transport receive event handler for the server.  It is
    specified as the receive handler for all endpoints opened by the
    server.  It attempts to dequeue a preformatted work item from a list
    anchored in the device object.  If this is successful, it returns
    the IRP associated with the work item to the transport provider to
    be used to receive the data.  Otherwise, the resource thread is
    awakened to format additional receive work items and service pended
    connections.

Arguments:

    TransportEndpoint - Pointer to file object for receiving endpoint

    ConnectionContext - Value associated with endpoint by owner.  For
        the server, this points to a Connection block maintained in
        nonpaged pool.

    ReceiveIndicators - Set of flags indicating the status of the
        received message

    Tsdu - Pointer to received data.

    Irp - Returns a pointer to I/O request packet, if the returned
        status is STATUS_MORE_PROCESSING_REQUIRED.  This IRP is
        made the 'current' Receive for the connection.

Return Value:

    NTSTATUS - If STATUS_SUCCESS, the receive handler completely
        processed the request.  If STATUS_MORE_PROCESSING_REQUIRED,
        the Irp parameter points to a formatted Receive request to
        be used to receive the data.  If STATUS_DATA_NOT_ACCEPTED,
        no IRP is returned, but the transport provider should check
        for previously queued Receive requests.

--*/

{
    NTSTATUS status;
    PCONNECTION connection;
    PWORK_CONTEXT workContext;
    PIRP irp;
    PIO_STACK_LOCATION irpSp;
    PWORK_QUEUE queue;
    ULONG receiveLength;
    LONG OplocksInProgress;
    PMDL mdl;

    KIRQL oldIrql;

    TdiEventContext;    // prevent compiler warnings

    connection = (PCONNECTION)ConnectionContext;

    IF_DEBUG(FSD2) {
        KdPrint(( "SrvFsdTdiReceiveHandler entered for endpoint 0x%p, "
                    "connection 0x%p\n", TdiEventContext, connection ));
    }

    //
    // If the connection is closing, don't bother servicing this
    // indication.
    //

    if ( GET_BLOCK_STATE(connection) == BlockStateActive ) {

        // See if we can trivially reject this receive
        if( !SrvFsdAcceptReceive( connection, Tsdu, BytesIndicated, BytesAvailable ) )
        {
            // Mark them as suspect.  If a DoS is triggered, they will be nuked first.
            connection->IsConnectionSuspect = TRUE;
            return STATUS_DATA_NOT_ACCEPTED;
        }

        //
        // Set the last used timestamp for this connection
        //
        GET_SERVER_TIME( connection->CurrentWorkQueue, &connection->LastRequestTime );

        if ( !(ReceiveFlags & TDI_RECEIVE_AT_DISPATCH_LEVEL) ) {
            KeRaiseIrql( DISPATCH_LEVEL, &oldIrql );
        }

#if MULTIPROCESSOR
        //
        // See if it's time to home this connection to another
        // processor
        //
        if( --(connection->BalanceCount) == 0 ) {
            SrvBalanceLoad( connection );
        }
#endif

        queue = connection->CurrentWorkQueue;

        //
        // We're going to either get a free work item and point it to
        // the connection, or put the connection on the need-resource
        // queue, so we'll need to reference the connection block.
        //
        // *** Note that we are able to access the connection block
        //     because it's in nonpaged pool.  Referencing the
        //     connection block here accounts for the I/O request we're
        //     'starting', and prevents the block from being deleted
        //     until the FSP processes the completed Receive.  To make
        //     all this work right, the transport provider must
        //     guarantee that it won't deliver any events after it
        //     delivers a Disconnect event or completes a client-issued
        //     Disconnect request.
        //
        // *** Note that we don't reference the endpoint file object
        //     directly.  The connection block, which we do reference,
        //     references an endpoint block, which in turn references
        //     the file object.
        //

        //
        // Try to dequeue a work item from the free list.
        //

        // Make sure we're not trying to do too much

        // Note the 2x in this calculation.  The reason for this is that if you have a fast client and a busy server,
        // the client can actually turn around and re-use the MID for an operation while the completion call for this
        // operation is still stuck in our queue.  This means that it is possible for the client to legally have up to
        // 2x MpxCt items in our queue.  This is an upper-bound to ensure compatibility.  Note that this is only the first
        // line of defense against DoS, so it is not too bad to allow this many ops through.  If they actually get multiple
        // connections going and run us out of resources, we will kick in and start aggressively disconnecting suspicious
        // connections.
        if( (connection->InProgressWorkContextCount > 2*(SrvMaxMpxCount + MAX_MPX_MARGIN)) && !SrvDisableDoSChecking )
        {
            PSMB_HEADER SmbHeader = (PSMB_HEADER)Tsdu;

            // We normally don't overrun the above bounds.  If we do, lets validate that we are truly exceeding our
            // bounds including oplock breaks.  Still no good way to include Mailslot operations and echos, so we have a fudge factor.
            // Note that the need to do 2x covers this too.
            OplocksInProgress = InterlockedCompareExchange( &connection->OplockBreaksInProgress, 0, 0 );

            if( !(connection->InProgressWorkContextCount > 2*(SrvMaxMpxCount + OplocksInProgress + MAX_MPX_MARGIN)) )
            {
                goto abort_dos;
            }

            // We're going to enforce the max number of work-items a single client can claim
            INTERNAL_ERROR(
                ERROR_LEVEL_EXPECTED,
                "SrvFsdTdiReceiveHandler: client overruning their WorkItem limit",
                NULL,
                NULL
                );

            connection->IsConnectionSuspect = TRUE;
            RunSuspectConnectionAlgorithm = TRUE;
            status = STATUS_DATA_NOT_ACCEPTED;
        }
        else
        {
abort_dos:
            ALLOCATE_WORK_CONTEXT( queue, &workContext );

            if ( workContext != NULL ) {

                //
                // We found a work item to handle this receive.  Reference
                // the connection.  Put the work item on the in-progress
                // list.  Save the connection and endpoint block addresses
                // in the work context block.
                //

                ACQUIRE_DPC_SPIN_LOCK( connection->EndpointSpinLock );
                SrvReferenceConnectionLocked( connection );

                SrvInsertTailList(
                    &connection->InProgressWorkItemList,
                    &workContext->InProgressListEntry
                    );

                connection->InProgressWorkContextCount++;

                RELEASE_DPC_SPIN_LOCK( connection->EndpointSpinLock );

                //
                // Keep track of the amount of data that was indicated
                //
                workContext->BytesAvailable = BytesAvailable;

                irp = workContext->Irp;

                workContext->Connection = connection;
                workContext->Endpoint = connection->Endpoint;

                if( connection->SmbSecuritySignatureActive &&
                    BytesIndicated >= FIELD_OFFSET( SMB_HEADER, Command ) ) {

                    //
                    // Save this security signature index
                    //
                    workContext->SmbSecuritySignatureIndex =
                            connection->SmbSecuritySignatureIndex++;

                    //
                    // And if we don't have a CANCEL smb, save the response
                    //  security signature index.  We skip this for CANCEL, because
                    //  CANCEL has no response SMB
                    //
                    if( ((PSMB_HEADER)Tsdu)->Command != SMB_COM_NT_CANCEL ) {
                        workContext->ResponseSmbSecuritySignatureIndex =

                            connection->SmbSecuritySignatureIndex++;
                    }
                }

                //
                // If the entire SMB has been received, and it is completely
                // within the indicated data, copy it directly into the
                // buffer, avoiding the overhead of passing an IRP down to
                // the transport.
                //

                if ( ((ReceiveFlags & TDI_RECEIVE_ENTIRE_MESSAGE) != 0) &&
                     (BytesIndicated == BytesAvailable) &&
                     BytesAvailable <= workContext->RequestBuffer->BufferLength ) {

                    TdiCopyLookaheadData(
                        workContext->RequestBuffer->Buffer,
                        Tsdu,
                        BytesIndicated,
                        ReceiveFlags
                        );

    #if SRVDBG_STATS2
                    IndicationsCopied++;
    #endif

                    //
                    // Pretend the transport completed an IRP by doing what
                    // the restart routine, which is known to be
                    // SrvQueueWorkToFspAtDpcLevel, would do.
                    //

                    irp->IoStatus.Status = STATUS_SUCCESS;
                    irp->IoStatus.Information = BytesIndicated;

                    irp->Cancel = FALSE;

                    IF_DEBUG(FSD2) {
                        KdPrint(( "FSD working on work context 0x%p", workContext ));
                    }
                    ASSERT( workContext->FsdRestartRoutine == SrvQueueWorkToFspAtDpcLevel );

                    //
                    // *** THE FOLLOWING IS COPIED FROM SrvQueueWorkToFspAtDpcLevel.
                    //
                    // Increment the processing count.
                    //

                    workContext->ProcessingCount++;

                    //
                    // Insert the work item at the tail of the nonblocking
                    // work queue.
                    //

                    SrvInsertWorkQueueTail(
                        workContext->CurrentWorkQueue,
                        (PQUEUEABLE_BLOCK_HEADER)workContext
                        );

                    //
                    // Tell the transport that we copied the data.
                    //

                    *BytesTaken = BytesIndicated;
                    *IoRequestPacket = NULL;

                    status = STATUS_SUCCESS;

                } else {

                    PTDI_REQUEST_KERNEL_RECEIVE parameters;

    #if SRVDBG_STATS2
                    IndicationsNotCopied++;
    #endif

                    *BytesTaken = 0;
                    receiveLength = workContext->RequestBuffer->BufferLength;
                    mdl = workContext->RequestBuffer->Mdl;

                    //
                    // We can't copy the indicated data.  Set up the receive
                    // IRP.
                    //

                    irp->Tail.Overlay.OriginalFileObject = NULL;
                    irp->Tail.Overlay.Thread = queue->IrpThread;
                    DEBUG irp->RequestorMode = KernelMode;

                    //
                    // Get a pointer to the next stack location.  This one is used to
                    // hold the parameters for the device I/O control request.
                    //

                    irpSp = IoGetNextIrpStackLocation( irp );

                    //
                    // Set up the completion routine.
                    //

                    IoSetCompletionRoutine(
                        irp,
                        SrvFsdIoCompletionRoutine,
                        workContext,
                        TRUE,
                        TRUE,
                        TRUE
                        );

                    irpSp->MajorFunction = IRP_MJ_INTERNAL_DEVICE_CONTROL;
                    irpSp->MinorFunction = (UCHAR)TDI_RECEIVE;

                    //
                    // Copy the caller's parameters to the service-specific portion of the
                    // IRP for those parameters that are the same for all three methods.
                    //

                    parameters = (PTDI_REQUEST_KERNEL_RECEIVE)&irpSp->Parameters;
                    parameters->ReceiveLength = receiveLength;
                    parameters->ReceiveFlags = 0;

                    irp->MdlAddress = mdl;
                    irp->AssociatedIrp.SystemBuffer = NULL;

                    //
                    // Make the next stack location current.  Normally
                    // IoCallDriver would do this, but since we're bypassing
                    // that, we do it directly.  Load the target device
                    // object address into the stack location.  This
                    // especially important because the server likes to
                    // reuse IRPs.
                    //

                    irpSp->Flags = 0;
                    irpSp->DeviceObject = connection->DeviceObject;
                    irpSp->FileObject = connection->FileObject;

                    IoSetNextIrpStackLocation( irp );

                    ASSERT( irp->StackCount >= irpSp->DeviceObject->StackSize );

                    //
                    // Return STATUS_MORE_PROCESSING_REQUIRED so that the
                    // transport provider will use our IRP to service the
                    // receive.
                    //

                    *IoRequestPacket = irp;

                    status = STATUS_MORE_PROCESSING_REQUIRED;
                }

            } else {

                //
                // No preformatted work items are available.  Mark the
                // connection, put it on a queue of connections waiting for
                // work items, and wake up the resource thread so that it
                // can format some more work items and service pended
                // connections.
                //

                INTERNAL_ERROR(
                    ERROR_LEVEL_EXPECTED,
                    "SrvFsdTdiReceiveHandler: no receive work items available",
                    NULL,
                    NULL
                    );

                connection->NoResponseSignatureIndex =
                    (((PSMB_HEADER)Tsdu)->Command == SMB_COM_NT_CANCEL);

                //
                // Remember the amount of data available, so we can set it
                //  in the workcontext when we eventually find one to use
                //
                connection->BytesAvailable = BytesAvailable;

                // If we've been under DOS attacks recently, queue a tear-down
                if( SrvDoSWorkItemTearDown > SRV_DOS_TEARDOWN_MIN )
                {
                    SrvCheckForAndQueueDoS( queue );
                }

                (VOID)SrvAddToNeedResourceQueue( connection, ReceivePending, NULL );

                status = STATUS_DATA_NOT_ACCEPTED;
            }
        }

        if ( !(ReceiveFlags & TDI_RECEIVE_AT_DISPATCH_LEVEL) ) {
            KeLowerIrql( oldIrql );
        }

    } else {

        //
        // The connection is not active.  Ignore this message.
        //

        status = STATUS_DATA_NOT_ACCEPTED;

    }

    return status;

} // SrvFsdTdiReceiveHandler

VOID
SrvPnpBindingHandler(
    IN TDI_PNP_OPCODE   PnPOpcode,
    IN PUNICODE_STRING  DeviceName,
    IN PWSTR            MultiSZBindList
)
{
    KAPC_STATE ApcState;
    BOOLEAN Attached = FALSE;

    PAGED_CODE();

    switch( PnPOpcode ) {
    case TDI_PNP_OP_DEL:
    case TDI_PNP_OP_ADD:
    case TDI_PNP_OP_UPDATE:

        IF_DEBUG( PNP ) {
            KdPrint(("SRV: SrvPnpBindingHandler( %wZ, %u ) entered\n", DeviceName, PnPOpcode ));
        }

        if( IoGetCurrentProcess() != SrvServerProcess ) {
            IF_DEBUG( PNP ) {
                KdPrint(("SRV: attach to system process\n" ));
            }
            FsRtlEnterFileSystem();
            KeStackAttachProcess( SrvServerProcess, &ApcState );
            Attached = TRUE;
        }

        if ((PnPOpcode == TDI_PNP_OP_DEL) ||
            (PnPOpcode == TDI_PNP_OP_ADD)) {
            SrvXsPnpOperation( DeviceName, (BOOLEAN)(PnPOpcode == TDI_PNP_OP_ADD) );
        }

        SrvpNotifyChangesToNetBt(PnPOpcode,DeviceName,MultiSZBindList);

        if( Attached == TRUE ) {
            KeUnstackDetachProcess( &ApcState );
            FsRtlExitFileSystem();
        }

        IF_DEBUG( PNP ) {
            KdPrint(("SRV: SrvPnpBindingHandler( %p, %u ) returning\n", DeviceName, PnPOpcode ));
        }

        break;

    default:
        break;
    }

}

//
// This routine can not be pageable, since the set power state calls can
// come through with the disk already disabled.  We need to make sure that
// no pageable code is invoked.  Fortunately, we don't need to do anything
// on a set power state
//
NTSTATUS
SrvPnpPowerHandler(
    IN PUNICODE_STRING  DeviceName,
    IN PNET_PNP_EVENT   PnPEvent,
    IN PTDI_PNP_CONTEXT Context1,
    IN PTDI_PNP_CONTEXT Context2
)
{
    NET_DEVICE_POWER_STATE powerState;
    NTSTATUS status = STATUS_SUCCESS;
    PLIST_ENTRY listEntry;

    IF_DEBUG( PNP ) {
        KdPrint(( "SRV: SrvPnpPowerHandler( %wZ, %u )\n", DeviceName, PnPEvent->NetEvent ));
    }

    switch( PnPEvent->NetEvent ) {
    case NetEventQueryPower:

        if( PnPEvent->BufferLength != sizeof( powerState ) ) {
            IF_DEBUG( ERRORS ) {
                KdPrint(( "SRV: NetEventQueryPower BufferLength %u (should be %u)\n",
                            PnPEvent->BufferLength, sizeof( powerState ) ));
            }
            break;
        }

        powerState = *(PNET_DEVICE_POWER_STATE)(PnPEvent->Buffer);

        //
        // Powering up is always OK!
        //
        if( powerState == NetDeviceStateD0 ) {
            break;
        }

        //
        // Lack of break is intentional
        //
    case NetEventQueryRemoveDevice:

    //
    // The following code is disabled, because we couldn't come up with a reasonable
    //  way to present UI to the user on failure.  We know this leg of the code is only
    //  executed when the user specifically wants to standby the system or remove a device.
    //  The analogy is that of a TV set -- if the user wants to turn off the system, then who
    //  are we to say "no"?
    //
    // If this is really the decision, then IMHO the system shouldn't even ask us.  But
    //  that's a battle long lost.
    //
#if 0
        //
        // Run through the endpoints using this device.  If any clients are
        //  connected, refuse the change.
        //

        ACQUIRE_LOCK( &SrvEndpointLock );

        listEntry = SrvEndpointList.ListHead.Flink;

        while( listEntry != &SrvEndpointList.ListHead ) {

            PENDPOINT endpoint = CONTAINING_RECORD( listEntry,
                                                    ENDPOINT,
                                                    GlobalEndpointListEntry
                                                    );

            if( GET_BLOCK_STATE( endpoint ) == BlockStateActive &&
                RtlEqualUnicodeString( DeviceName, &endpoint->TransportName, TRUE ) ) {

                USHORT index = (USHORT)-1;
                PCONNECTION connection = WalkConnectionTable( endpoint, &index );

                if( connection != NULL ) {
                    IF_DEBUG( PNP ) {
                        KdPrint(("    Endpoint %X, Connection %X\n", endpoint, connection ));
                        KdPrint(("    SRV rejects power down request!\n" ));
                    }
                    //
                    // We have found a connected client.  Cannot allow powerdown.
                    //
                    SrvDereferenceConnection( connection );
                    status = STATUS_UNSUCCESSFUL;
                    break;
                }
            }

            listEntry = listEntry->Flink;
        }

        RELEASE_LOCK( &SrvEndpointLock );
#endif

        break;
    }

    IF_DEBUG( PNP ) {
        KdPrint(( "    SrvPnpPowerHandler status %X\n", status ));
    }

    return status;
}


PWORK_CONTEXT SRVFASTCALL
SrvFsdGetReceiveWorkItem (
    IN PWORK_QUEUE queue
    )

/*++

Routine Description:

    This function removes a receive work item from the free queue.  It can
    be called at either Passive or DPC level

Arguments:

    None.

Return Value:

    PWORK_CONTEXT - A pointer to a WORK_CONTEXT structure,
         or NULL if none exists.
--*/

{
    PSINGLE_LIST_ENTRY listEntry;
    PWORK_CONTEXT workContext;
    ULONG i;
    KIRQL oldIrql;
    NTSTATUS Status;
    BOOLEAN AllocFailed = FALSE;

    ASSERT( queue >= SrvWorkQueues && queue < eSrvWorkQueues );

    //
    // Try to get a work context block from the initial work queue first.
    // If this fails, try the normal work queue.  If this fails, try to allocate
    // one.  If we still failed, schedule a worker thread to allocate some later.
    //

    listEntry = ExInterlockedPopEntrySList( &queue->InitialWorkItemList, &queue->SpinLock );

    if ( listEntry == NULL ) {

        listEntry = ExInterlockedPopEntrySList( &queue->NormalWorkItemList, &queue->SpinLock );

        if( listEntry == NULL ) {

            IF_DEBUG( WORKITEMS ) {
                KdPrint(("No workitems for queue %p\n", (PVOID)(queue-SrvWorkQueues) ));
            }

            Status = SrvAllocateNormalWorkItem( &workContext, queue );
            if( workContext != NULL ) {
                IF_DEBUG( WORKITEMS ) {
                    KdPrint(("SrvFsdGetReceiveWorkItem: new work context %p\n",
                              workContext ));
                }
                SrvPrepareReceiveWorkItem( workContext, FALSE );
                INITIALIZE_WORK_CONTEXT( queue, workContext );
                return workContext;
            }
            else
            {
                if( Status == STATUS_INSUFFICIENT_RESOURCES )
                {
                    AllocFailed = TRUE;
                }
            }

            //
            // Before we steal from another processor, ensure that
            //  we're setup to replenish this exhausted free list
            //
            ACQUIRE_SPIN_LOCK( &queue->SpinLock, &oldIrql );
            if( queue->AllocatedWorkItems < queue->MaximumWorkItems &&
                GET_BLOCK_TYPE(&queue->CreateMoreWorkItems) == BlockTypeGarbage ) {

                SET_BLOCK_TYPE( &queue->CreateMoreWorkItems, BlockTypeWorkContextSpecial );
                queue->CreateMoreWorkItems.FspRestartRoutine = SrvServiceWorkItemShortage;
                SrvInsertWorkQueueHead( queue, &queue->CreateMoreWorkItems );
            }
            RELEASE_SPIN_LOCK( &queue->SpinLock, oldIrql );

#if MULTIPROCESSOR
            //
            // We couldn't find a work item on our processor's free queue.
            //   See if we can steal one from another processor
            //

            IF_DEBUG( WORKITEMS ) {
                KdPrint(("Looking for workitems on other processors\n" ));
            }

            //
            // Look around for a workitem we can borrow
            //
            for( i = SrvNumberOfProcessors; i > 1; --i ) {

                if( ++queue == eSrvWorkQueues )
                    queue = SrvWorkQueues;


                listEntry = ExInterlockedPopEntrySList( &queue->InitialWorkItemList,
                                                        &queue->SpinLock );

                if( listEntry == NULL ) {
                    listEntry = ExInterlockedPopEntrySList( &queue->NormalWorkItemList,
                                                            &queue->SpinLock );
                    if( listEntry == NULL ) {

                        Status = SrvAllocateNormalWorkItem( &workContext, queue );

                        if( workContext != NULL ) {
                            //
                            // Got a workItem from another processor's queue!
                            //
                            ++(queue->StolenWorkItems);

                            IF_DEBUG( WORKITEMS ) {
                                KdPrint(("SrvFsdGetReceiveWorkItem: new work context %p\n",
                                          workContext ));
                            }

                            SrvPrepareReceiveWorkItem( workContext, FALSE );
                            INITIALIZE_WORK_CONTEXT( queue, workContext );
                            return workContext;
                        }
                        else
                        {
                            if( Status == STATUS_INSUFFICIENT_RESOURCES )
                            {
                                AllocFailed = TRUE;
                            }
                        }

                        //
                        // Make sure this processor knows it is low on workitems
                        //
                        ACQUIRE_SPIN_LOCK( &queue->SpinLock, &oldIrql );
                        if( queue->AllocatedWorkItems < queue->MaximumWorkItems &&
                            GET_BLOCK_TYPE(&queue->CreateMoreWorkItems) == BlockTypeGarbage ) {

                            SET_BLOCK_TYPE( &queue->CreateMoreWorkItems,
                                            BlockTypeWorkContextSpecial );

                            queue->CreateMoreWorkItems.FspRestartRoutine
                                            = SrvServiceWorkItemShortage;
                            SrvInsertWorkQueueHead( queue, &queue->CreateMoreWorkItems );
                        }

                        RELEASE_SPIN_LOCK( &queue->SpinLock, oldIrql );
                        continue;
                    }
                }

                //
                // Got a workItem from another processor's queue!
                //
                ++(queue->StolenWorkItems);

                break;
            }
#endif

            if( listEntry == NULL ) {
                //
                // We didn't have any free workitems on our queue, and
                //  we couldn't borrow a workitem from another processor.
                //  Give up!
                //

                IF_DEBUG( WORKITEMS ) {
                    KdPrint(("No workitems anywhere!\n" ));
                }
                ++SrvStatistics.WorkItemShortages;

                if( !AllocFailed )
                {
                    SrvCheckForAndQueueDoS( queue );
                }

                return NULL;
            }
        }
    }

    //
    // We've successfully gotten a free workitem of a processor's queue.
    //  (it may not be our processor).
    //

    IF_DEBUG( WORKITEMS ) {
        if( queue != PROCESSOR_TO_QUEUE() ) {
            KdPrint(("\tGot WORK_ITEM from processor %p\n" , (PVOID)(queue - SrvWorkQueues) ));
        }
    }

    //
    // Decrement the count of free receive work items.
    //
    InterlockedDecrement( &queue->FreeWorkItems );

    if( queue->FreeWorkItems < queue->MinFreeWorkItems &&
        queue->AllocatedWorkItems < queue->MaximumWorkItems &&
        GET_BLOCK_TYPE(&queue->CreateMoreWorkItems) == BlockTypeGarbage ) {

        ACQUIRE_SPIN_LOCK( &queue->SpinLock, &oldIrql );

        if( queue->FreeWorkItems < queue->MinFreeWorkItems &&
            queue->AllocatedWorkItems < queue->MaximumWorkItems &&
            GET_BLOCK_TYPE(&queue->CreateMoreWorkItems) == BlockTypeGarbage ) {

            //
            // We're running short of free workitems. Queue a request to
            // allocate more of them.
            //
            SET_BLOCK_TYPE( &queue->CreateMoreWorkItems, BlockTypeWorkContextSpecial );

            queue->CreateMoreWorkItems.FspRestartRoutine = SrvServiceWorkItemShortage;
            SrvInsertWorkQueueHead( queue, &queue->CreateMoreWorkItems );
        }

        RELEASE_SPIN_LOCK( &queue->SpinLock, oldIrql );
    }


    workContext = CONTAINING_RECORD( listEntry, WORK_CONTEXT, SingleListEntry );
    ASSERT( workContext->BlockHeader.ReferenceCount == 0 );
    ASSERT( workContext->CurrentWorkQueue != NULL );

    INITIALIZE_WORK_CONTEXT( queue, workContext );

    return workContext;

} // SrvFsdGetReceiveWorkItem

VOID SRVFASTCALL
SrvFsdRequeueReceiveWorkItem (
    IN OUT PWORK_CONTEXT WorkContext
    )

/*++

Routine Description:

    This routine requeues a Receive work item to the queue in the server
    FSD device object.  This routine is called when processing of a
    receive work item is done.

Arguments:

    WorkContext - Supplies a pointer to the work context block associated
        with the receive buffer and IRP.  The following fields must be
        valid:

            Connection
            TdiRequest
            Irp
            RequestBuffer
                RequestBuffer->BufferLength
                RequestBuffer->Mdl

Return Value:

    None.

--*/

{
    PCONNECTION connection;
    PSMB_HEADER header;
    KIRQL oldIrql;
    PBUFFER requestBuffer;

    IF_DEBUG(TRACE2) KdPrint(( "SrvFsdRequeueReceiveWorkItem entered\n" ));
    IF_DEBUG(NET2) {
        KdPrint(( "  Work context %p, request buffer %p\n",
                    WorkContext, WorkContext->RequestBuffer ));
        KdPrint(( "  IRP %p, MDL %p\n",
                    WorkContext->Irp, WorkContext->RequestBuffer->Mdl ));
    }

    //
    // Save the connection pointer before reinitializing the work item.
    //

    connection = WorkContext->Connection;
    ASSERT( connection != NULL );

    ASSERT( WorkContext->Share == NULL );
    ASSERT( WorkContext->Session == NULL );
    ASSERT( WorkContext->TreeConnect == NULL );
    ASSERT( WorkContext->Rfcb == NULL );

    //
    // Reset the IRP cancelled bit, in case it was set during
    // operation.
    //

    WorkContext->Irp->Cancel = FALSE;

    //
    // Set up the restart routine in the work context.
    //

    WorkContext->FsdRestartRoutine = SrvQueueWorkToFspAtDpcLevel;
    WorkContext->FspRestartRoutine = SrvRestartReceive;

    //
    // Make sure the length specified in the MDL is correct -- it may
    // have changed while sending a response to the previous request.
    // Call an I/O subsystem routine to build the I/O request packet.
    //

    requestBuffer = WorkContext->RequestBuffer;
    requestBuffer->Mdl->ByteCount = requestBuffer->BufferLength;

    //
    // Replace the Response buffer.
    //

    WorkContext->ResponseBuffer = requestBuffer;

    header = (PSMB_HEADER)requestBuffer->Buffer;

    //WorkContext->RequestHeader = header;
    ASSERT( WorkContext->RequestHeader == header );

    WorkContext->ResponseHeader = header;
    WorkContext->ResponseParameters = (PVOID)(header + 1);
    WorkContext->RequestParameters = (PVOID)(header + 1);

    //
    // Initialize this to zero so this will not be mistakenly cancelled
    // by SrvSmbNtCancel.
    //

    SmbPutAlignedUshort( &WorkContext->RequestHeader->Uid, (USHORT)0 );

    //
    // Remove the work item from the in-progress list.
    //

    KeRaiseIrql( DISPATCH_LEVEL, &oldIrql );
    ACQUIRE_DPC_SPIN_LOCK( connection->EndpointSpinLock );

    SrvRemoveEntryList(
        &connection->InProgressWorkItemList,
        &WorkContext->InProgressListEntry
        );
    connection->InProgressWorkContextCount--;

    //
    // Attempt to dereference the connection.
    //

    if ( --connection->BlockHeader.ReferenceCount == 0 ) {

        //
        // The refcount went to zero.  We can't handle this with the
        // spin lock held.  Reset the refcount, then release the lock,
        // then check to see whether we can continue here.
        //

        connection->BlockHeader.ReferenceCount++;

        //
        // We're in the FSD, so we can't do this here.  We need
        // to tell our caller this.
        //

        RELEASE_DPC_SPIN_LOCK( connection->EndpointSpinLock );

        //
        // orphaned.  Send to Boys Town.
        //

        DispatchToOrphanage( (PVOID)connection );
        connection = NULL;

    } else {

        UPDATE_REFERENCE_HISTORY( connection, TRUE );
        RELEASE_DPC_SPIN_LOCK( connection->EndpointSpinLock );
    }

    KeLowerIrql( oldIrql );

    //
    // Requeue the work item.
    //

    RETURN_FREE_WORKITEM( WorkContext );

    return;

} // SrvFsdRequeueReceiveWorkItem


NTSTATUS
SrvFsdRestartSendOplockIItoNone(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN OUT PWORK_CONTEXT WorkContext
    )

/*++

Routine Description:

    This routine is the send completion routine for oplock breaks from
    II to None.  This is handled differently from other oplock breaks
    in that we don't queue it to the OplockBreaksInProgressList but
    increment our count so we will not have raw reads while this is
    being sent.


    This is done in such a manner as to be safe at DPC level.

Arguments:

    DeviceObject - Pointer to target device object for the request.

    Irp - Pointer to I/O request packet

    WorkContext - Caller-specified context parameter associated with IRP.
        This is actually a pointer to a Work Context block.

Return Value:

    None.

--*/

{
    KIRQL oldIrql;
    PCONNECTION connection;

    UNLOCKABLE_CODE( 8FIL );

    IF_DEBUG(OPLOCK) {
        KdPrint(("SrvFsdRestartSendOplockIItoNone: Oplock send complete.\n"));
    }

    //
    // Check the status of the send completion.
    //

    CHECK_SEND_COMPLETION_STATUS( Irp->IoStatus.Status );

    //
    // Reset the IRP cancelled bit.
    //

    Irp->Cancel = FALSE;

    KeRaiseIrql( DISPATCH_LEVEL, &oldIrql );

    //
    // Mark the connection to indicate that we just sent a break II to
    // none.  If the next SMB received is a raw read, we will return a
    // zero-byte send.  This is necessary because the client doesn't
    // respond to this break, so we don't really know when they've
    // received it.  But when we receive an SMB, we know that they've
    // gotten it.  Note that a non-raw SMB could be on its way when we
    // send the break, and we'll clear the flag, but since the client
    // needs to lock the VC to do the raw read, it must receive the SMB
    // response (and hence the oplock break) before it can send the raw
    // read.  If a raw read crosses with the oplock break, it will be
    // rejected because the OplockBreaksInProgress count is nonzero.
    //

    connection = WorkContext->Connection;
    connection->BreakIIToNoneJustSent = TRUE;

    ExInterlockedAddUlong(
        &connection->OplockBreaksInProgress,
        (ULONG)-1,
        connection->EndpointSpinLock
        );

    SrvFsdRestartSmbComplete( WorkContext );

    KeLowerIrql( oldIrql );
    return(STATUS_MORE_PROCESSING_REQUIRED);

} // SrvFsdRestartSendOplockIItoNone


VOID SRVFASTCALL
SrvFsdRestartSmbComplete (
    IN OUT PWORK_CONTEXT WorkContext
    )

/*++

Routine Description:

    This routine is called when all request processing on an SMB is
    complete, including sending a response, if any.  This routine
    dereferences control blocks and requeues the work item to the
    receive work item list.

    This is done in such a manner as to be safe at DPC level.

Arguments:

    WorkContext - Supplies a pointer to the work context block
        containing information about the SMB.

Return Value:

    None.

--*/

{
    PRFCB rfcb;
    ULONG oldCount;

    ASSERT( KeGetCurrentIrql() == DISPATCH_LEVEL );

    IF_DEBUG(FSD2) KdPrint(( "SrvFsdRestartSmbComplete entered\n" ));

    //
    // If we may have backlogged oplock breaks to send, do the work
    // in the FSP.
    //

    if ( WorkContext->OplockOpen ) {
        goto queueToFsp;
    }

    //
    // Attempt to dereference the file block.
    //

    rfcb = WorkContext->Rfcb;

    if ( rfcb != NULL ) {
        oldCount = ExInterlockedAddUlong(
            &rfcb->BlockHeader.ReferenceCount,
            (ULONG)-1,
            &rfcb->Connection->SpinLock
            );

        UPDATE_REFERENCE_HISTORY( rfcb, TRUE );

        if ( oldCount == 1 ) {
            UPDATE_REFERENCE_HISTORY( rfcb, FALSE );
            (VOID) ExInterlockedAddUlong(
                    &rfcb->BlockHeader.ReferenceCount,
                    (ULONG) 1,
                    &rfcb->Connection->SpinLock
                    );
            goto queueToFsp;
        }

        WorkContext->Rfcb = NULL;
    }

    //
    // If this was a blocking operation, update the blocking i/o count.
    //

    if ( WorkContext->BlockingOperation ) {
        InterlockedDecrement( &SrvBlockingOpsInProgress );
        WorkContext->BlockingOperation = FALSE;
    }

    //
    // !!! Need to handle failure of response send -- kill connection?
    //

    //
    // Attempt to dereference the work item.  This will fail (and
    // automatically be queued to the FSP) if it cannot be done from
    // within the FSD.
    //

    SrvFsdDereferenceWorkItem( WorkContext );

    return;

queueToFsp:

    //
    // We were unable to do all the necessary cleanup at DPC level.
    // Queue the work item to the FSP.
    //

    WorkContext->FspRestartRoutine = SrvRestartFsdComplete;
    SrvQueueWorkToFspAtDpcLevel( WorkContext );

    IF_DEBUG(FSD2) KdPrint(( "SrvFsdRestartSmbComplete complete\n" ));
    return;

} // SrvFsdRestartSmbComplete

NTSTATUS
SrvFsdRestartSmbAtSendCompletion (
    IN PDEVICE_OBJECT DeviceObject OPTIONAL,
    IN PIRP Irp,
    IN PWORK_CONTEXT WorkContext
    )

/*++

Routine Description:

    Send completion routine for all request processing on an SMB is
    complete, including sending a response, if any.  This routine
    dereferences control blocks and requeues the work item to the
    receive work item list.

    This is done in such a manner as to be safe at DPC level.

Arguments:

    DeviceObject - Pointer to target device object for the request.

    Irp - Pointer to I/O request packet

    WorkContext - Caller-specified context parameter associated with IRP.
        This is actually a pointer to a Work Context block.

Return Value:

    None.

--*/

{
    PRFCB rfcb;
    KIRQL oldIrql;

    ULONG oldCount;

    IF_DEBUG(FSD2)KdPrint(( "SrvFsdRestartSmbComplete entered\n" ));

    //
    // Check the status of the send completion.
    //

    CHECK_SEND_COMPLETION_STATUS( Irp->IoStatus.Status );

    //
    // Reset the IRP cancelled bit.
    //

    Irp->Cancel = FALSE;

    //
    // Free any associated buffers
    //
    if( Irp->AssociatedIrp.SystemBuffer != NULL &&
        (Irp->Flags & IRP_DEALLOCATE_BUFFER) ) {

        ExFreePool( Irp->AssociatedIrp.SystemBuffer );
        Irp->AssociatedIrp.SystemBuffer = NULL;
        Irp->Flags &= ~IRP_DEALLOCATE_BUFFER;
    }

    KeRaiseIrql( DISPATCH_LEVEL, &oldIrql );

    //
    // If we may have backlogged oplock breaks to send, do the work
    // in the FSP.
    //

    if ( WorkContext->OplockOpen ) {
        goto queueToFsp;
    }

    //
    // Attempt to dereference the file block.  We can do this without acquiring
    // SrvFsdSpinlock around the decrement/increment pair since the ref
    // count cannot be zero unless the rfcb is closed and we are the last
    // reference to it.  None of our code references the rfcb when it has been
    // closed.
    //

    rfcb = WorkContext->Rfcb;

    if ( rfcb != NULL ) {
        oldCount = ExInterlockedAddUlong(
            &rfcb->BlockHeader.ReferenceCount,
            (ULONG)-1,
            &rfcb->Connection->SpinLock
            );

        UPDATE_REFERENCE_HISTORY( rfcb, TRUE );

        if ( oldCount == 1 ) {
            UPDATE_REFERENCE_HISTORY( rfcb, FALSE );
            (VOID) ExInterlockedAddUlong(
                    &rfcb->BlockHeader.ReferenceCount,
                    (ULONG) 1,
                    &rfcb->Connection->SpinLock
                    );
            goto queueToFsp;
        }

        WorkContext->Rfcb = NULL;
    }

    //
    // If this was a blocking operation, update the blocking i/o count.
    //

    if ( WorkContext->BlockingOperation ) {
        InterlockedDecrement( &SrvBlockingOpsInProgress );
        WorkContext->BlockingOperation = FALSE;
    }

    //
    // !!! Need to handle failure of response send -- kill connection?
    //

    //
    // Attempt to dereference the work item.  This will fail (and
    // automatically be queued to the FSP) if it cannot be done from
    // within the FSD.
    //

    SrvFsdDereferenceWorkItem( WorkContext );

    KeLowerIrql( oldIrql );
    return(STATUS_MORE_PROCESSING_REQUIRED);

queueToFsp:

    //
    // We were unable to do all the necessary cleanup at DPC level.
    // Queue the work item to the FSP.
    //

    WorkContext->FspRestartRoutine = SrvRestartFsdComplete;
    SrvQueueWorkToFspAtDpcLevel( WorkContext );

    KeLowerIrql( oldIrql );
    IF_DEBUG(FSD2) KdPrint(( "SrvFsdRestartSmbComplete complete\n" ));
    return(STATUS_MORE_PROCESSING_REQUIRED);

} // SrvFsdRestartSmbAtSendCompletion


VOID
SrvFsdServiceNeedResourceQueue (
    IN PWORK_CONTEXT *WorkContext,
    IN PKIRQL OldIrql
    )

/*++

Routine Description:

    This function attempts to service a receive pending by creating
    a new SMB buffer and passing it on to the transport provider.

    *** SrvFsdSpinLock held when called.  Held on exit ***
    *** EndpointSpinLock held when called.  Held on exit ***

Arguments:

    WorkContext - A pointer to the work context block that will be used
                  to service the connection. If the work context supplied
                  was used, a null will be returned here.
                  *** The workcontext block must be referencing the
                      connection on entry. ***

    OldIrql -

Return Value:

    TRUE, if there is still work left for this connection.
    FALSE, otherwise.

--*/

{
    PIO_STACK_LOCATION irpSp;
    PIRP irp;
    PWORK_CONTEXT workContext = *WorkContext;
    PCONNECTION connection = workContext->Connection;

    IF_DEBUG( OPLOCK ) {
        KdPrint(("SrvFsdServiceNeedResourceQueue: entered. WorkContext %p , Connection = %p.\n", workContext, connection ));
    }

    //
    // If there are any oplock break sends pending, supply the WCB.
    //

restart:

    if ( !IsListEmpty( &connection->OplockWorkList ) ) {

        PLIST_ENTRY listEntry;
        PRFCB rfcb;

        //
        // Dequeue the oplock context from the list of pending oplock
        // sends.
        //

        listEntry = RemoveHeadList( &connection->OplockWorkList );

        rfcb = CONTAINING_RECORD( listEntry, RFCB, ListEntry );

#if DBG
        rfcb->ListEntry.Flink = rfcb->ListEntry.Blink = NULL;
#endif

        IF_DEBUG( OPLOCK ) {
            KdPrint(("SrvFsdServiceNeedResourceQueue: rfcb %p removed from OplockWorkList.\n", rfcb ));
        }

        //
        // The connection spinlock guards the rfcb block header.
        //

        ACQUIRE_DPC_SPIN_LOCK( &connection->SpinLock);

        if ( GET_BLOCK_STATE( rfcb ) != BlockStateActive ) {

            //
            // This file is closing, don't bother send the oplock break
            //
            // Attempt to dereference the file block.
            //

            IF_DEBUG( OPLOCK ) {
                KdPrint(("SrvFsdServiceNeedResourceQueue: rfcb %p closing.\n", rfcb));
            }

            UPDATE_REFERENCE_HISTORY( rfcb, TRUE );

            connection->OplockBreaksInProgress--;
            if ( --rfcb->BlockHeader.ReferenceCount == 0 ) {

                //
                // Put the work item on the in-progress list.
                //

                SrvInsertTailList(
                    &connection->InProgressWorkItemList,
                    &workContext->InProgressListEntry
                    );
                connection->InProgressWorkContextCount++;

                UPDATE_REFERENCE_HISTORY( rfcb, FALSE );
                rfcb->BlockHeader.ReferenceCount++;

                RELEASE_DPC_SPIN_LOCK( &connection->SpinLock);
                RELEASE_DPC_SPIN_LOCK( connection->EndpointSpinLock);
                RELEASE_GLOBAL_SPIN_LOCK( Fsd, *OldIrql );

                //
                // Send this to the Fsp
                //

                workContext->Rfcb = rfcb;
                workContext->FspRestartRoutine = SrvRestartFsdComplete;
                SrvQueueWorkToFsp( workContext );
                goto exit_used;

            } else {

                //
                // Before we get rid of the workcontext block, see
                // if we need to do more work for this connection.
                //

                if ( !IsListEmpty(&connection->OplockWorkList) ||
                      connection->ReceivePending) {

                    IF_DEBUG( OPLOCK ) {
                        KdPrint(("SrvFsdServiceNeedResourceQueue: Reusing WorkContext block %p.\n", workContext ));
                    }

                    RELEASE_DPC_SPIN_LOCK( &connection->SpinLock);
                    goto restart;
                }

                RELEASE_DPC_SPIN_LOCK( &connection->SpinLock);
                RELEASE_DPC_SPIN_LOCK( connection->EndpointSpinLock);
                RELEASE_GLOBAL_SPIN_LOCK( Fsd, *OldIrql );

                IF_DEBUG( OPLOCK ) {
                    KdPrint(("SrvFsdServiceNeedResourceQueue: WorkContext block not used.\n"));
                }

                SrvDereferenceConnection( connection );
                workContext->Connection = NULL;
                workContext->Endpoint = NULL;
                goto exit_not_used;
            }
        }

        RELEASE_DPC_SPIN_LOCK( &connection->SpinLock);

        //
        // Put the work item on the in-progress list.
        //

        SrvInsertTailList(
            &connection->InProgressWorkItemList,
            &workContext->InProgressListEntry
            );
        connection->InProgressWorkContextCount++;

        //
        // Copy the oplock work queue RFCB reference to the work
        // context block.  There is no need to re-reference the RFCB.
        //

        RELEASE_DPC_SPIN_LOCK( connection->EndpointSpinLock);
        RELEASE_GLOBAL_SPIN_LOCK( Fsd, *OldIrql );
        workContext->Rfcb = rfcb;

        IF_DEBUG( OPLOCK ) {
            KdPrint(("SrvFsdServiceNeedResourceQueue: Sending oplock break.\n"));
        }

        SrvRestartOplockBreakSend( workContext );

    } else {

        IF_DEBUG( OPLOCK ) {
            KdPrint(("SrvFsdServiceNeedResourceQueue: Have ReceivePending.\n"));
        }

        //
        // Offer the newly free, or newly created, SMB buffer to the
        // transport to complete the receive.
        //
        // *** Note that the connection has already been referenced in
        //     SrvFsdTdiReceiveHandler.
        //

        connection->ReceivePending = FALSE;

        //
        // Check the request security signature, and calculate the response signature
        //
        if( connection->SmbSecuritySignatureActive ) {

            //
            // Save this security signature index
            //
            workContext->SmbSecuritySignatureIndex =
                    connection->SmbSecuritySignatureIndex++;

            //
            // Save the response signature index, if we require one
            //
            if( connection->NoResponseSignatureIndex == FALSE ) {

                workContext->ResponseSmbSecuritySignatureIndex =
                    connection->SmbSecuritySignatureIndex++;
            }
        }

        SET_OPERATION_START_TIME( &workContext );

        //
        // Put the work item on the in-progress list.
        //

        SrvInsertTailList(
            &connection->InProgressWorkItemList,
            &workContext->InProgressListEntry
            );
        connection->InProgressWorkContextCount++;

        //
        // Remember the amount of data that is avilable, in case it
        //  turns out to be a LargeIndication.
        //
        workContext->BytesAvailable = connection->BytesAvailable;

        //
        // Finish setting up the IRP.  This involves putting the
        // file object and device object addresses in the IRP.
        //

        RELEASE_DPC_SPIN_LOCK( connection->EndpointSpinLock);
        RELEASE_GLOBAL_SPIN_LOCK( Fsd, *OldIrql );

        irp = workContext->Irp;

        //
        // Build the receive irp
        //

        (VOID)SrvBuildIoControlRequest(
                  irp,                                // input IRP address
                  NULL,                               // target file object address
                  workContext,                        // context
                  IRP_MJ_INTERNAL_DEVICE_CONTROL,     // major function
                  TDI_RECEIVE,                        // minor function
                  NULL,                               // input buffer address
                  0,                                  // input buffer length
                  workContext->RequestBuffer->Buffer, // output buffer address
                  workContext->RequestBuffer->BufferLength,  // output buffer length
                  workContext->RequestBuffer->Mdl,    // MDL address
                  NULL                                // completion routine
                  );

        //
        // Get a pointer to the next stack location.  This one is used to
        // hold the parameters for the receive request.
        //

        irpSp = IoGetNextIrpStackLocation( irp );

        irpSp->Flags = 0;
        irpSp->DeviceObject = connection->DeviceObject;
        irpSp->FileObject = connection->FileObject;

        ASSERT( irp->StackCount >= irpSp->DeviceObject->StackSize );

        //
        // Pass the SMB buffer to the driver.
        //

        IoCallDriver( irpSp->DeviceObject, irp );

    }

exit_used:

    //
    // We made good use of the work context block.
    //

    *WorkContext = NULL;

    IF_DEBUG( OPLOCK ) {
        KdPrint(("SrvFsdServiceNeedResourceQueue: WorkContext block used.\n"));
    }

exit_not_used:

    ACQUIRE_GLOBAL_SPIN_LOCK( Fsd, OldIrql );
    ACQUIRE_DPC_SPIN_LOCK( connection->EndpointSpinLock);
    return;

} // SrvFsdServiceNeedResourceQueue


BOOLEAN
SrvAddToNeedResourceQueue(
    IN PCONNECTION Connection,
    IN RESOURCE_TYPE ResourceType,
    IN PRFCB Rfcb OPTIONAL
    )

/*++

Routine Description:

    This function appends a connection to the need resource queue.
    The connection is marked indicating what resource is needed,
    and the resource thread is started to do the work.

Arguments:

    Connection - The connection that need a resource.
    Resource - The resource that is needed.
    Rfcb - A pointer to the RFCB that needs the resource.

Return Value:

    None.

--*/

{
    KIRQL oldIrql;

    ACQUIRE_GLOBAL_SPIN_LOCK( Fsd, &oldIrql );
    ACQUIRE_DPC_SPIN_LOCK( Connection->EndpointSpinLock );

    IF_DEBUG( WORKITEMS ) {
        KdPrint(("SrvAddToNeedResourceQueue entered. connection = %p, type %d\n", Connection, ResourceType));
    }

    //
    // Check again to see if the connection is closing.  If it is,
    // don't bother putting it on the need resource queue.
    //
    // *** We have to do this while holding the need-resource queue
    //     spin lock in order to synchronize with
    //     SrvCloseConnection.  We don't want to queue this
    //     connection after SrvCloseConnection tries to take it off
    //     the queue.
    //

    if ( GET_BLOCK_STATE(Connection) != BlockStateActive ||
         Connection->DisconnectPending ) {

        RELEASE_DPC_SPIN_LOCK( Connection->EndpointSpinLock );
        RELEASE_GLOBAL_SPIN_LOCK( Fsd, oldIrql );

        IF_DEBUG( WORKITEMS ) {
            KdPrint(("SrvAddToNeedResourceQueue: connection closing. Not queued\n"));
        }

        return FALSE;

    }

    //
    // Mark the connection so that the resource thread will know what to
    // do with this connection.
    //

    switch ( ResourceType ) {

    case ReceivePending:

        ASSERT( !Connection->ReceivePending );
        Connection->ReceivePending = TRUE;
        break;

    case OplockSendPending:

        //
        // Queue the context information to the connection, if necessary.
        //

        ASSERT( ARGUMENT_PRESENT( Rfcb ) );

        SrvInsertTailList( &Connection->OplockWorkList, &Rfcb->ListEntry );

        break;

    }

    //
    // Put the connection on the need-resource queue and increment its
    // reference count.
    //

    if( Connection->OnNeedResourceQueue == FALSE ) {

        Connection->OnNeedResourceQueue = TRUE;

        SrvInsertTailList(
            &SrvNeedResourceQueue,
            &Connection->ListEntry
            );

        SrvReferenceConnectionLocked( Connection );

        IF_DEBUG( WORKITEMS ) {
            KdPrint(("SrvAddToNeedResourceQueue: connection %p inserted on the queue.\n", Connection));
        }
    }

    RELEASE_DPC_SPIN_LOCK( Connection->EndpointSpinLock );

    RELEASE_GLOBAL_SPIN_LOCK( Fsd, oldIrql );

    //
    // Make sure we know that this connection needs a WorkItem
    //
    InterlockedIncrement( &Connection->CurrentWorkQueue->NeedWorkItem );

    IF_DEBUG( WORKITEMS ) {
        KdPrint(("SrvAddToNeedResourceQueue complete: NeedWorkItem = %d\n",
                  Connection->CurrentWorkQueue->NeedWorkItem ));
    }

    return TRUE;

} // SrvAddToNeedResourceQueue

VOID
SrvCheckForAndQueueDoS(
    PWORK_QUEUE queue
    )
{
    KIRQL oldIrql;
    LARGE_INTEGER CurrentTime;
    BOOLEAN LogEvent = FALSE;

    if( !SrvDisableDoSChecking &&
        queue->AllocatedWorkItems >= queue->MaximumWorkItems )
    {
        // Potential DoS
        SrvDoSDetected = TRUE;

        // Make sure we only queue one of these at a time globally
        if( SRV_DOS_CAN_START_TEARDOWN() )
        {

            KeQuerySystemTime( &CurrentTime );

            if( CurrentTime.QuadPart > SrvDoSLastRan.QuadPart + SRV_DOS_MINIMUM_DOS_WAIT_PERIOD )
            {
                // Setup a refresher/DOS item
                ACQUIRE_SPIN_LOCK( &queue->SpinLock, &oldIrql );
                ACQUIRE_DPC_SPIN_LOCK( &SrvDosSpinLock );

                if( GET_BLOCK_TYPE(&SrvDoSWorkItem) == BlockTypeGarbage ) {

                    SET_BLOCK_TYPE( &SrvDoSWorkItem, BlockTypeWorkContextSpecial );

                    if( SrvDoSLastRan.QuadPart + SRV_ONE_DAY < CurrentTime.QuadPart )
                    {
                        // Only log events when there has been no DoS for 24 hours
                        LogEvent = TRUE;
                    }

                    SrvDoSLastRan = CurrentTime;
                    SrvDoSWorkItem.FspRestartRoutine = SrvServiceDoSTearDown;
                    SrvDoSWorkItem.CurrentWorkQueue = queue;
                    SrvInsertWorkQueueHead( queue, &SrvDoSWorkItem );
                }
                else
                {
                    // Some error occurred, leave the DoS for another queue
                    SRV_DOS_COMPLETE_TEARDOWN();
                }

                RELEASE_DPC_SPIN_LOCK( &SrvDosSpinLock );
                RELEASE_SPIN_LOCK( &queue->SpinLock, oldIrql );
            }
            else
            {
                SRV_DOS_COMPLETE_TEARDOWN();
            }

            // Log the event if necessary
            if( LogEvent )
            {
                SrvLogError(
                    SrvDeviceObject,
                    EVENT_SRV_OUT_OF_WORK_ITEM_DOS,
                    STATUS_ACCESS_DENIED,
                    NULL,
                    0,
                    NULL,
                    0
                    );
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\srv\errorlog.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    errorlog.c

Abstract:

    This module implements the error logging in the server.

Author:

    Manny Weiser (mannyw)    11-Feb-92

Revision History:

--*/

#include "precomp.h"
#include "errorlog.tmh"
#pragma hdrstop

#ifdef ALLOC_PRAGMA
#pragma alloc_text( PAGE, SrvLogInvalidSmbDirect )
#pragma alloc_text( PAGE, SrvLogServiceFailureDirect )
#if DBG
#pragma alloc_text( PAGE, SrvLogTableFullError )
#endif
#endif
#if 0
NOT PAGEABLE -- SrvLogError
NOT PAGEABLE -- SrvCheckSendCompletionStatus
NOT PAGEABLE -- SrvIsLoggableError
#endif


VOID
SrvLogInvalidSmbDirect (
    IN PWORK_CONTEXT WorkContext,
    IN ULONG LineNumber
    )
{
    UNICODE_STRING unknownClient;
    PUNICODE_STRING clientName;
    ULONG LocalBuffer[ 13 ];

    PAGED_CODE( );

    //
    // Let this client log at most one SMB error
    //
    if( ARGUMENT_PRESENT( WorkContext ) ) {

        if( WorkContext->Connection->PagedConnection->LoggedInvalidSmb ) {
            return;
        }

        WorkContext->Connection->PagedConnection->LoggedInvalidSmb = TRUE;
    }

    if ( ARGUMENT_PRESENT(WorkContext) &&
         (WorkContext->Connection->PagedConnection->ClientMachineNameString.Length != 0) ) {

        clientName = &WorkContext->Connection->PagedConnection->ClientMachineNameString;

    } else {

        RtlInitUnicodeString( &unknownClient, StrUnknownClient );
        clientName = &unknownClient;

    }

    if ( ARGUMENT_PRESENT(WorkContext) ) {

        LocalBuffer[0] = LineNumber;

        RtlCopyMemory(
            &LocalBuffer[1],
            WorkContext->RequestHeader,
            MIN( WorkContext->RequestBuffer->DataLength, sizeof( LocalBuffer ) - sizeof( LocalBuffer[0] ) )
            );

        SrvLogError(
            SrvDeviceObject,
            EVENT_SRV_INVALID_REQUEST,
            STATUS_INVALID_SMB,
            LocalBuffer,
            (USHORT)MIN( WorkContext->RequestBuffer->DataLength + sizeof( LocalBuffer[0] ), sizeof( LocalBuffer ) ),
            clientName,
            1
            );

    } else {

        SrvLogError(
            SrvDeviceObject,
            EVENT_SRV_INVALID_REQUEST,
            STATUS_INVALID_SMB,
            &LineNumber,
            (USHORT)sizeof( LineNumber ),
            clientName,
            1
            );
    }

    return;

} // SrvLogInvalidSmb

BOOLEAN
SrvIsLoggableError( IN NTSTATUS Status )
{
    NTSTATUS *pstatus;
    BOOLEAN ret = TRUE;

    for( pstatus = SrvErrorLogIgnore; *pstatus; pstatus++ ) {
        if( *pstatus == Status ) {
            ret = FALSE;
            break;
        }
    }

    return ret;
}


VOID
SrvLogServiceFailureDirect (
    IN ULONG LineAndService,
    IN NTSTATUS Status
    )
/*++

Routine Description:

    This function logs a srv svc error.  You should use the 'SrvLogServiceFailure'
      macro instead of calling this routine directly.

Arguments:
    LineAndService consists of the line number of the original call in the highword, and
      the service code in the lowword

    Status is the status code of the called routine

Return Value:

    None.

--*/
{
    PAGED_CODE( );

    //
    // Don't log certain errors that are expected to happen occasionally.
    //

    if( (LineAndService & 01) || SrvIsLoggableError( Status ) ) {

        SrvLogError(
            SrvDeviceObject,
            EVENT_SRV_SERVICE_FAILED,
            Status,
            &LineAndService,
            sizeof(LineAndService),
            NULL,
            0
            );

    }

    return;

} // SrvLogServiceFailure

//
// I have disabled this for retail builds because it is not a good idea to
//   allow an evil client to so easily fill the server's system log
//
VOID
SrvLogTableFullError (
    IN ULONG Type
    )
{
#if DBG
    PAGED_CODE( );

    SrvLogError(
        SrvDeviceObject,
        EVENT_SRV_CANT_GROW_TABLE,
        STATUS_INSUFFICIENT_RESOURCES,
        &Type,
        sizeof(ULONG),
        NULL,
        0
        );

    return;
#endif

} // SrvLogTableFullError

VOID
SrvLogError(
    IN PVOID DeviceOrDriverObject,
    IN ULONG UniqueErrorCode,
    IN NTSTATUS NtStatusCode,
    IN PVOID RawDataBuffer,
    IN USHORT RawDataLength,
    IN PUNICODE_STRING InsertionString OPTIONAL,
    IN ULONG InsertionStringCount
    )

/*++

Routine Description:

    This function allocates an I/O error log record, fills it in and writes it
    to the I/O error log.

Arguments:



Return Value:

    None.


--*/

{
    PIO_ERROR_LOG_PACKET errorLogEntry;
    ULONG insertionStringLength = 0;
    ULONG i;
    PWCHAR buffer;
    USHORT paddedRawDataLength = 0;

    //
    // Update the server error counts
    //

    if ( UniqueErrorCode == EVENT_SRV_NETWORK_ERROR ) {
        SrvUpdateErrorCount( &SrvNetworkErrorRecord, TRUE );
    } else {
        SrvUpdateErrorCount( &SrvErrorRecord, TRUE );
    }

    for ( i = 0; i < InsertionStringCount ; i++ ) {
        insertionStringLength += (InsertionString[i].Length + sizeof(WCHAR));
    }

    //
    // pad the raw data buffer so that the insertion string starts
    // on an even address.
    //

    if ( ARGUMENT_PRESENT( RawDataBuffer ) ) {
        paddedRawDataLength = (RawDataLength + 1) & ~1;
    }

    errorLogEntry = IoAllocateErrorLogEntry(
                        DeviceOrDriverObject,
                        (UCHAR)(sizeof(IO_ERROR_LOG_PACKET) +
                                paddedRawDataLength + insertionStringLength)
                        );

    if (errorLogEntry != NULL) {

        //
        // Fill in the error log entry
        //

        errorLogEntry->ErrorCode = UniqueErrorCode;
        errorLogEntry->MajorFunctionCode = 0;
        errorLogEntry->RetryCount = 0;
        errorLogEntry->UniqueErrorValue = 0;
        errorLogEntry->FinalStatus = NtStatusCode;
        errorLogEntry->IoControlCode = 0;
        errorLogEntry->DeviceOffset.QuadPart = 0;
        errorLogEntry->DumpDataSize = RawDataLength;
        errorLogEntry->StringOffset =
            (USHORT)(FIELD_OFFSET(IO_ERROR_LOG_PACKET, DumpData) + paddedRawDataLength);
        errorLogEntry->NumberOfStrings = (USHORT)InsertionStringCount;

        errorLogEntry->SequenceNumber = 0;

        //
        // Append the extra information.  This information is typically
        // an SMB header.
        //

        if ( ARGUMENT_PRESENT( RawDataBuffer ) ) {

            RtlCopyMemory(
                errorLogEntry->DumpData,
                RawDataBuffer,
                RawDataLength
                );
        }

        buffer = (PWCHAR)((PCHAR)errorLogEntry->DumpData + paddedRawDataLength);

        for ( i = 0; i < InsertionStringCount ; i++ ) {

            RtlCopyMemory(
                buffer,
                InsertionString[i].Buffer,
                InsertionString[i].Length
                );

            buffer += (InsertionString[i].Length/2);
            *buffer++ = L'\0';
        }

        //
        // Write the entry
        //

        IoWriteErrorLogEntry(errorLogEntry);
    }

} // SrvLogError

VOID
SrvCheckSendCompletionStatus(
    IN NTSTATUS Status,
    IN ULONG LineNumber
    )

/*++

Routine Description:

    Routine to log send completion errors.

Arguments:


Return Value:

    None.

--*/

{
    if( SrvIsLoggableError( Status ) ) {

        SrvLogError( SrvDeviceObject,
                     EVENT_SRV_NETWORK_ERROR,
                     Status,
                     &LineNumber, sizeof(LineNumber),
                     NULL, 0 );
    }

} // SrvCheckSendCompletionStatus
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\srv\fsdraw.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    fsdraw.c

Abstract:

    This module contains routines for processing the following SMBs in
    the server FSD:

        Read Block Raw
        Write Block Raw

    The routines in this module generally work closely with the routines
    in smbraw.c.

    *** There is no support here for raw writes from MS-NET 1.03 clients.
        There are very few of these machines in existence, and raw mode
        is only a performance issue, so it is not worth the trouble to
        add the necessary hacks for MS-NET 1.03, which sends raw write
        requests in a different format.

Author:

    Chuck Lenzmeier (chuckl) 8-Sep-1990
    Manny Weiser (mannyw)
    David Treadwell (davidtr)

Revision History:

--*/

#include "precomp.h"
#include "fsdraw.tmh"
#pragma hdrstop

//
// Forward declarations.
//

STATIC
VOID SRVFASTCALL
RestartWriteCompleteResponse (
    IN OUT PWORK_CONTEXT WorkContext
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text( PAGE8FIL, SrvFsdBuildWriteCompleteResponse )
#pragma alloc_text( PAGE8FIL, RestartWriteCompleteResponse )
#endif
#if 0
NOT PAGEABLE -- RestartCopyReadRawResponse
NOT PAGEABLE -- SrvFsdRestartPrepareRawMdlWrite
NOT PAGEABLE -- SrvFsdRestartReadRaw
NOT PAGEABLE -- SrvFsdRestartWriteRaw
#endif

#if DBG
VOID
DumpMdlChain(
    IN PMDL mdl
    );
#endif


VOID
SrvFsdBuildWriteCompleteResponse (
    IN OUT PWORK_CONTEXT WorkContext,
    IN NTSTATUS Status,
    IN ULONG BytesWritten
    )

/*++

Routine Description:

    Sets up a final response to a Write Block Raw/Mpx request.

    This routine is called in both the FSP and the FSD.  It can be called
    in the FSD only if Status == STATUS_SUCCESS.

Arguments:

    WorkContext - Supplies a pointer to the work context block
        describing server-specific context for the request.

    Status - Supplies a status value to be returned to the client.

    BytesWritten - Supplies the number of bytes actually written.

Return Value:

    SMB_PROCESSOR_RETURN_TYPE - Returns SmbStatusSendResponse.

--*/

{
    PSMB_HEADER header;
    PRESP_WRITE_COMPLETE response;

    if ( WorkContext->Rfcb != NULL ) {
        UNLOCKABLE_CODE( 8FIL );
    } else {
        ASSERT( KeGetCurrentIrql() < DISPATCH_LEVEL );
    }

    //
    // Get pointers to the header and the response parameters area.
    // Note that Write Block Raw/Mpx can't be chained to an AndX SMB.
    //

    header = WorkContext->ResponseHeader;
    response = (PRESP_WRITE_COMPLETE)WorkContext->ResponseParameters;

    //
    // Change the SMB command code to Write Complete.
    //

    header->Command = SMB_COM_WRITE_COMPLETE;

    //
    // Put the error code in the header.  Note that SrvSetSmbError
    // writes a null parameter area to the end of the SMB; we overwrite
    // that with our own parameter area.
    //

    if ( Status != STATUS_SUCCESS ) {
        ASSERT( KeGetCurrentIrql() < DISPATCH_LEVEL );
        SrvSetSmbError2( WorkContext, Status, TRUE );
    }

    //
    // Build the response SMB.
    //

    response->WordCount = 1;
    SmbPutUshort( &response->Count, (USHORT)BytesWritten );
    SmbPutUshort( &response->ByteCount, 0 );

    WorkContext->ResponseParameters = NEXT_LOCATION(
                                        response,
                                        RESP_WRITE_COMPLETE,
                                        0
                                        );

    return;

} // SrvFsdBuildWriteCompleteResponse


NTSTATUS
RestartCopyReadRawResponse (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN OUT PWORK_CONTEXT WorkContext
    )

/*++

Routine Description:

    This is the restart routine that is invoked when the send of a
    Read Block Raw response completes.

    This routine is called in the FSD.

Arguments:

    DeviceObject - Pointer to target device object for the request.

    Irp - Pointer to I/O request packet

    WorkContext - Caller-specified context parameter associated with IRP.
        This is actually a pointer to a Work Context block.

Return Value:

    STATUS_MORE_PROCESSING_REQUIRED.

--*/

{
    KIRQL oldIrql;
    PCONNECTION connection;

    IF_DEBUG(FSD1) SrvPrint0( " - RestartCopyReadRawResponse\n" );

    //
    // Check the status of the send completion.
    //

    CHECK_SEND_COMPLETION_STATUS( Irp->IoStatus.Status );

    //
    // Reset the IRP cancelled bit.
    //

    Irp->Cancel = FALSE;

    //
    // Deallocate the raw buffer, if the original SMB buffer was not
    // used.  Note that we do not need to unlock the raw buffer, because
    // it was allocated out of nonpaged pool and locked using
    // MmBuildMdlForNonPagedPool, which doesn't increment reference
    // counts and therefore has no inverse.
    //

    if ( WorkContext->Parameters.ReadRaw.SavedResponseBuffer != NULL ) {

        DEALLOCATE_NONPAGED_POOL( WorkContext->ResponseBuffer->Buffer );

        IoFreeMdl( WorkContext->ResponseBuffer->Mdl );

        DEALLOCATE_NONPAGED_POOL( WorkContext->ResponseBuffer );
        WorkContext->ResponseBuffer =
                        WorkContext->Parameters.ReadRaw.SavedResponseBuffer;

    }

    //
    // If there is an oplock break request pending, then we must go to the
    // FSP to initiate the break, otherwise complete processing in the FSD.
    //

    connection = WorkContext->Connection;

    KeRaiseIrql( DISPATCH_LEVEL, &oldIrql );
    ACQUIRE_DPC_SPIN_LOCK( connection->EndpointSpinLock );

    if ( IsListEmpty( &connection->OplockWorkList ) ) {

        //
        // Dereference control blocks and put the work item back on the
        // receive queue.
        //

        WorkContext->Connection->RawReadsInProgress--;
        RELEASE_DPC_SPIN_LOCK( connection->EndpointSpinLock );
        SrvFsdRestartSmbComplete( WorkContext );

    } else {

        //
        // Send this work context to the FSP for completion.
        //

        RELEASE_DPC_SPIN_LOCK( connection->EndpointSpinLock );
        WorkContext->FspRestartRoutine = SrvRestartReadRawComplete;
        QUEUE_WORK_TO_FSP( WorkContext );

    }

    IF_DEBUG(TRACE2) SrvPrint0( "RestartCopyReadRawResponse complete\n" );

    KeLowerIrql( oldIrql );
    return STATUS_MORE_PROCESSING_REQUIRED;

} // RestartCopyReadRawResponse


VOID SRVFASTCALL
SrvFsdRestartPrepareRawMdlWrite(
    IN OUT PWORK_CONTEXT WorkContext
    )

/*++

Routine Description:

    Restart routine for completion of a "prepare MDL write" I/O request.
    Prepares a work context block and an IRP describing the raw receive,
    posts the receive, and sends a "go-ahead" response.

    This routine is called in both the FSP and the FSD.

Arguments:

    WorkContext - Supplies a pointer to the work context block
        describing server-specific context for the request.

Return Value:

    None.

--*/

{
    PREQ_WRITE_RAW request;
    PRESP_WRITE_RAW_INTERIM response;

    PVOID finalResponseBuffer;
    PWORK_CONTEXT rawWorkContext;
    ULONG writeLength;
    ULONG immediateLength;
    BOOLEAN immediateWriteDone;
    PMDL mdl;

    PCHAR src;
    PCHAR dest;
    ULONG lengthToCopy;

    PIO_STACK_LOCATION irpSp;
    BOOLEAN       bNeedTrace = (WorkContext->bAlreadyTrace == FALSE);

    if (bNeedTrace) {
        if (WorkContext->PreviousSMB == EVENT_TYPE_SMB_LAST_EVENT)
            WorkContext->PreviousSMB = EVENT_TYPE_SMB_WRITE_RAW;
        SrvWmiStartContext(WorkContext);
    }
    else
        WorkContext->bAlreadyTrace = FALSE;

    IF_DEBUG(FSD1) SrvPrint0( " - SrvFsdRestartPrepareRawMdlWrite\n" );

    //
    // Get request parameters and saved context.
    //

    request = (PREQ_WRITE_RAW)WorkContext->RequestParameters;

    rawWorkContext = WorkContext->Parameters.WriteRawPhase1.RawWorkContext;

    writeLength = SmbGetUshort( &request->Count );
    immediateLength = SmbGetUshort( &request->DataLength );
    immediateWriteDone = rawWorkContext->Parameters.WriteRaw.ImmediateWriteDone;
    if ( immediateWriteDone ) {
        writeLength -= immediateLength;
    }

    finalResponseBuffer =
        rawWorkContext->Parameters.WriteRaw.FinalResponseBuffer;

    //
    // If the prepare MDL write I/O failed, send an error response.
    //

    if ( !NT_SUCCESS(WorkContext->Irp->IoStatus.Status) ) {

        IF_DEBUG(ERRORS) {
            SrvPrint1( "SrvFsdRestartPrepareRawMdlWrite: Write failed: %X\n",
                        WorkContext->Irp->IoStatus.Status );
        }

        //
        // We won't be needing the final response buffer or the raw mode
        // work item.
        //

        if ( finalResponseBuffer != NULL ) {
            DEALLOCATE_NONPAGED_POOL( finalResponseBuffer );
        }

        rawWorkContext->ResponseBuffer->Buffer = NULL;
        RestartWriteCompleteResponse( rawWorkContext );

        //
        // Build and send the response.
        //

        if ( KeGetCurrentIrql() >= DISPATCH_LEVEL ) {
            WorkContext->Irp->IoStatus.Information =
                                    immediateWriteDone ? immediateLength : 0;
            WorkContext->FspRestartRoutine = SrvBuildAndSendWriteCompleteResponse;
            WorkContext->FsdRestartRoutine = SrvFsdRestartSmbComplete; // after response
            QUEUE_WORK_TO_FSP( WorkContext );
        } else {
            SrvFsdBuildWriteCompleteResponse(
                WorkContext,
                WorkContext->Irp->IoStatus.Status,
                immediateWriteDone ? immediateLength : 0
                );
            SrvFsdSendResponse( WorkContext );
        }

        IF_DEBUG(TRACE2) {
            SrvPrint0( "SrvFsdRestartPrepareRawMdlWrite complete\n" );
        }
        goto Cleanup;

    }

    //
    // If a final response is going to be sent, save information from
    // the request in the final response buffer.
    //

    if ( finalResponseBuffer != NULL ) {
        RtlCopyMemory(
            (PSMB_HEADER)finalResponseBuffer,
            WorkContext->RequestHeader,
            sizeof(SMB_HEADER)
            );
    }

    //
    // If the immediate data has not yet been written, copy it now.
    //

    mdl = WorkContext->Irp->MdlAddress;
#if DBG
    IF_SMB_DEBUG(RAW2) {
        KdPrint(( "SrvFsdRestartPrepareRawMdlWrite: input chain:\n" ));
        DumpMdlChain( mdl );
    }
#endif
    rawWorkContext->Parameters.WriteRaw.FirstMdl = mdl;

    if ( !immediateWriteDone ) {

        src = (PCHAR)WorkContext->RequestHeader +
                                    SmbGetUshort( &request->DataOffset );

        while ( immediateLength ) {

            lengthToCopy = MIN( immediateLength, mdl->ByteCount );
            dest = MmGetSystemAddressForMdlSafe( mdl,NormalPoolPriority );

            if (dest == NULL) {
                WorkContext->Irp->IoStatus.Status = STATUS_INSUFFICIENT_RESOURCES;

                WorkContext->Irp->IoStatus.Information = 0;
                WorkContext->FspRestartRoutine = SrvBuildAndSendWriteCompleteResponse;
                WorkContext->FsdRestartRoutine = SrvFsdRestartSmbComplete; // after response
                QUEUE_WORK_TO_FSP( WorkContext );
                goto Cleanup;
            }

            RtlCopyMemory( dest, src, lengthToCopy );

            src += lengthToCopy;
            immediateLength -= lengthToCopy;
            writeLength -= lengthToCopy;

            if ( lengthToCopy == mdl->ByteCount ) {

                mdl = mdl->Next;

            } else {

                PCHAR baseVa;
                ULONG lengthOfMdl;
                PMDL rawMdl;

                ASSERT( immediateLength == 0 );
                baseVa = (PCHAR)MmGetMdlVirtualAddress(mdl) + lengthToCopy;
                lengthOfMdl = mdl->ByteCount - lengthToCopy;
                ASSERT( lengthOfMdl <= 65535 );

                rawMdl = rawWorkContext->RequestBuffer->Mdl;
                rawMdl->Size = (CSHORT)(sizeof(MDL) + (sizeof(ULONG_PTR) *
                    ADDRESS_AND_SIZE_TO_SPAN_PAGES( baseVa, lengthOfMdl )));

                IoBuildPartialMdl( mdl, rawMdl, baseVa, lengthOfMdl );

                rawMdl->Next = mdl->Next;
#if DBG
                IF_SMB_DEBUG(RAW2) {
                    KdPrint(( "SrvFsdRestartPrepareRawMdlWrite: built partial MDL at 0x%p\n", rawMdl ));
                    DumpMdlChain( rawMdl );
                }
#endif

                mdl = rawMdl;

            }

        }

    }

    //
    // Save the length of the raw write.
    //

    rawWorkContext->RequestBuffer->BufferLength = writeLength;

    //
    // Set up the restart routines in the work context.
    //

    rawWorkContext->FsdRestartRoutine = SrvQueueWorkToFspAtDpcLevel;
    rawWorkContext->FspRestartRoutine = SrvRestartRawReceive;

    //
    // Build the TdiReceive request packet.
    //


    {
        PIRP irp = rawWorkContext->Irp;
        PIO_STACK_LOCATION irpSp;
        PTDI_REQUEST_KERNEL_RECEIVE parameters;

        irp->Tail.Overlay.OriginalFileObject = NULL;
        irp->Tail.Overlay.Thread = WorkContext->CurrentWorkQueue->IrpThread;
        DEBUG irp->RequestorMode = KernelMode;

        //
        // Get a pointer to the next stack location.  This one is used to
        // hold the parameters for the device I/O control request.
        //

        irpSp = IoGetNextIrpStackLocation( irp );

        //
        // Set up the completion routine.
        //

        IoSetCompletionRoutine(
            irp,
            SrvFsdIoCompletionRoutine,
            rawWorkContext,
            TRUE,
            TRUE,
            TRUE
            );

        irpSp->MajorFunction = IRP_MJ_INTERNAL_DEVICE_CONTROL;
        irpSp->MinorFunction = (UCHAR)TDI_RECEIVE;

        irpSp->FileObject = NULL;
        irpSp->DeviceObject = NULL;

        //
        // Copy the caller's parameters to the service-specific portion of the
        // IRP for those parameters that are the same for all three methods.
        //

        parameters = (PTDI_REQUEST_KERNEL_RECEIVE)&irpSp->Parameters;
        parameters->ReceiveLength = writeLength;
        parameters->ReceiveFlags = 0;

        irp->MdlAddress = mdl;
        irp->AssociatedIrp.SystemBuffer = NULL;
        irp->Flags = (ULONG)IRP_BUFFERED_IO;
    }

    IF_SMB_DEBUG(RAW2) {
        KdPrint(( "Issuing receive with MDL %p\n", rawWorkContext->Irp->MdlAddress ));
    }

    irpSp = IoGetNextIrpStackLocation( rawWorkContext->Irp );

    //
    // If this is a writebehind write, tell the transport that we don't
    // plan to reply to the received message.
    //

    if ( finalResponseBuffer == NULL ) {
        ((PTDI_REQUEST_KERNEL_RECEIVE)&irpSp->Parameters)->ReceiveFlags |=
                                                TDI_RECEIVE_NO_RESPONSE_EXP;
    }

    //
    // Post the receive.
    //

    irpSp->Flags = 0;
    irpSp->DeviceObject = rawWorkContext->Connection->DeviceObject;
    irpSp->FileObject = rawWorkContext->Connection->FileObject;

    ASSERT( rawWorkContext->Irp->StackCount >=
                                    irpSp->DeviceObject->StackSize );

    (VOID)IoCallDriver( irpSp->DeviceObject, rawWorkContext->Irp );

    //
    // Send the interim (go-ahead) response.
    //

    response = (PRESP_WRITE_RAW_INTERIM)WorkContext->ResponseParameters;

    response->WordCount = 1;
    SmbPutUshort( &response->Remaining, (USHORT)-1 );
    SmbPutUshort( &response->ByteCount, 0 );
    WorkContext->ResponseParameters = NEXT_LOCATION(
                                        response,
                                        RESP_WRITE_RAW_INTERIM,
                                        0
                                        );

    SrvFsdSendResponse( WorkContext );

    IF_DEBUG(TRACE2) SrvPrint0( "SrvFsdRestartPrepareRawMdlWrite complete\n" );

Cleanup:
    if (bNeedTrace) {
        SrvWmiEndContext(WorkContext);
    }
    return;

} // SrvFsdRestartPrepareRawMdlWrite


VOID SRVFASTCALL
SrvFsdRestartReadRaw (
    IN OUT PWORK_CONTEXT WorkContext
    )

/*++

Routine Description:

    Processes file read completion for the Read Block Raw SMB.

    This routine is called in both the FSP and the FSD.

Arguments:

    WorkContext - Supplies a pointer to the work context block
        describing server-specific context for the request.

Return Value:

    None.

--*/

{
    PRFCB rfcb;
    KIRQL oldIrql;
    USHORT readLength;
    BOOLEAN       bNeedTrace = (WorkContext->bAlreadyTrace == FALSE);

    if (bNeedTrace) {
        if (WorkContext->PreviousSMB == EVENT_TYPE_SMB_LAST_EVENT)
            WorkContext->PreviousSMB = EVENT_TYPE_SMB_READ_RAW;
        SrvWmiStartContext(WorkContext);
    }
    else
        WorkContext->bAlreadyTrace = FALSE;

    IF_DEBUG(FSD1) SrvPrint0( " - SrvFsdRestartReadRaw\n" );

    //
    // Get the file pointer.
    //

    rfcb = WorkContext->Rfcb;
    IF_DEBUG(TRACE2) {
        SrvPrint2( "  connection 0x%p, RFCB 0x%p\n",
                    WorkContext->Connection, rfcb );
    }

    //
    // Calculate the amount of data read.
    //

    if ( WorkContext->Irp->IoStatus.Status == STATUS_END_OF_FILE ) {

        readLength = 0;
        IF_SMB_DEBUG(RAW2) {
            SrvPrint0( "SrvFsdRestartReadRaw: 0 bytes read, at end-of-file\n" );
        }

    } else if ( !NT_SUCCESS(WorkContext->Irp->IoStatus.Status) ) {

        readLength = 0;
        IF_SMB_DEBUG(ERRORS) {
            SrvPrint1( "SrvFsdRestartReadRaw: read request failed: %X\n",
                           WorkContext->Irp->IoStatus.Status );
        }

    } else if ( WorkContext->Parameters.ReadRaw.MdlRead ) {

        //
        // For an MDL read, we have to walk the MDL chain in order to
        // determine how much data was read.  This is because the
        // operation may have happened in multiple step, with the MDLs
        // being chained together.  For example, part of the read may
        // have been satisfied by the fast path, while the rest was
        // satisfied using an IRP.
        //

#if DBG
        ULONG mdlCount = 0;
#endif
        PMDL mdl = WorkContext->Irp->MdlAddress;

        readLength = 0;

        while ( mdl != NULL ) {
            IF_SMB_DEBUG(RAW2) {
#if DBG
                SrvPrint3( "  mdl %ld at 0x%p, %ld bytes\n",
                            mdlCount, 
                            mdl, MmGetMdlByteCount(mdl) );
#else
                SrvPrint3( "  mdl 0x%p, %ld bytes\n",
                            mdl, MmGetMdlByteCount(mdl) );
#endif                
            }
            readLength += (USHORT)MmGetMdlByteCount(mdl);
#if DBG
            mdlCount++;
#endif
            mdl = mdl->Next;
        }
        IF_SMB_DEBUG(RAW2) {
#if DBG
            SrvPrint2( "SrvFsdRestartReadRaw: %ld bytes in %ld MDLs\n",
                        readLength, mdlCount );
#else
            SrvPrint2( "SrvFsdRestartReadRaw: %ld bytes\n",
                        readLength );
#endif            
            SrvPrint1( "                      info = 0x%p\n",
                        (PVOID)WorkContext->Irp->IoStatus.Information );
        }

    } else {

        //
        // Copy read.  The I/O status block has the length.
        //

        readLength = (USHORT)WorkContext->Irp->IoStatus.Information;
        IF_SMB_DEBUG(RAW2) {
            SrvPrint1( "SrvFsdRestartReadRaw: %ld bytes read\n", readLength );
        }

    }

#ifdef SLMDBG
    {
        PRFCB_TRACE entry;
        ACQUIRE_GLOBAL_SPIN_LOCK( Fsd, &oldIrql );
        rfcb->OperationCount++;
        entry = &rfcb->Trace[rfcb->NextTrace];
        if ( ++rfcb->NextTrace == SLMDBG_TRACE_COUNT ) {
            rfcb->NextTrace = 0;
            rfcb->TraceWrapped = TRUE;
        }
        RELEASE_GLOBAL_SPIN_LOCK( Fsd, oldIrql );
        entry->Command = WorkContext->NextCommand;
        entry->Flags =
                (UCHAR)(WorkContext->Parameters.ReadRaw.MdlRead ? 1 : 0);
        KeQuerySystemTime( &entry->Time );
        entry->Data.ReadWrite.Offset =
            WorkContext->Parameters.ReadRaw.ReadRawOtherInfo.Offset.LowPart;
        entry->Data.ReadWrite.Length = readLength;
    }
#endif

    //
    // Update the file position.
    //
    // *** Note that we ignore the status of the operation, except to
    //     check for end-of-file, since we can't tell the client what
    //     the status was.  We simply return as many bytes as the file
    //     system says were read.
    //
    // !!! Should we save the error and return it when the client
    //     retries?
    //
    // !!! Need to worry about wraparound?
    //

    if ( rfcb->ShareType == ShareTypeDisk ) {

        rfcb->CurrentPosition =
            WorkContext->Parameters.ReadRaw.ReadRawOtherInfo.Offset.LowPart +
            readLength;

    }

    //
    // Save the count of bytes read, to be used to update the server
    // statistics database.
    //

    UPDATE_READ_STATS( WorkContext, readLength );

    //
    // Send the raw read data as the response.
    //

    WorkContext->ResponseBuffer->DataLength = readLength;

    //
    // There is no header on this SMB, do not generate a security signature
    //
    WorkContext->NoResponseSmbSecuritySignature = TRUE;

    if ( WorkContext->Parameters.ReadRaw.MdlRead ) {

        //
        // MDL read.  The data is described by the MDL returned by the
        // file system (in irp->MdlAddress).
        //
        // *** Note that if the read failed completely (which happens if
        //     the read starts beyond EOF), there is no MDL.
        //     SrvStartSend handles this appropriately.  So must
        //     RestartMdlReadRawResponse.
        //

        //
        // Send the response.
        //

        SRV_START_SEND(
            WorkContext,
            WorkContext->Irp->MdlAddress,
            0,
            SrvQueueWorkToFspAtSendCompletion,
            NULL,
            RestartMdlReadRawResponse
            );

    } else {

        //
        // Copy read.  The data is described by the MDL allocated in
        // SrvFsdSmbReadRaw.
        //
        // *** Changing Mdl->ByteCount like this would be a problem if
        //     we had to unlock the pages in RestartCopyReadRawResponse,
        //     because we might end up unlocking fewer pages than we
        //     locked.  But we don't actually lock the pages to build
        //     the MDL -- the buffer is allocated from nonpaged pool, so
        //     we use MmBuildMdlForNonPagedPool rather than
        //     MmProbeAndLockPages.  So the pages haven't been
        //     referenced to account for the MDL, so there's no need to
        //     unlock them, so changing ByteCount isn't a problem.
        //

        //
        // Send the response.
        //

        SRV_START_SEND_2(
            WorkContext,
            RestartCopyReadRawResponse,
            NULL,
            NULL
            );

    }

    //
    // The response send has been started.
    //

    IF_DEBUG(TRACE2) SrvPrint0( "SrvFsdRestartReadRaw complete\n" );

    if (bNeedTrace) {
        SrvWmiEndContext(WorkContext);
    }
    return;

} // SrvFsdRestartReadRaw


VOID SRVFASTCALL
RestartWriteCompleteResponse (
    IN OUT PWORK_CONTEXT WorkContext
    )

/*++

Routine Description:

    This routine attempts, at DPC level, to clean up after a Write Raw
    completes.  It tries to dereference control blocks referenced by the
    raw mode work item.  If this cannot be done at DPC level (e.g., a
    reference count goes to zero), this routine queues the work item to
    the FSP for processing.

    This routine is called in the FSD.  Its FSP counterpart is
    SrvRestartWriteCompleteResponse.

Arguments:

    WorkContext - Supplies a pointer to the work context block
        describing server-specific context for the request.

Return Value:

    None.

--*/

{
    PCONNECTION connection;
    KIRQL oldIrql;
    PRFCB rfcb;
    PWORK_QUEUE queue;

    UNLOCKABLE_CODE( 8FIL );

    IF_DEBUG(FSD1) SrvPrint0( " - RestartWriteCompleteResponse\n" );

    connection = WorkContext->Connection;
    queue = connection->CurrentWorkQueue;

    //
    // If a final response was sent, check the status and deallocate the
    // buffer.
    //

    if ( WorkContext->ResponseBuffer->Buffer != NULL ) {

        //
        // If the I/O request failed or was canceled, print an error
        // message.
        //
        // !!! If I/O failure, should we drop the connection?
        //

        if ( WorkContext->Irp->Cancel ||
             !NT_SUCCESS(WorkContext->Irp->IoStatus.Status) ) {

            IF_DEBUG(FSD1) {
                if ( WorkContext->Irp->Cancel ) {
                    SrvPrint0( "  I/O canceled\n" );
                } else {
                    SrvPrint1( "  I/O failed: %X\n",
                                WorkContext->Irp->IoStatus.Status );
                }
            }

        }

        //
        // Deallocate the final response buffer.
        //
        // *** Note that we don't need to unlock it, because it was
        //     allocated from nonpaged pool.
        //

        DEALLOCATE_NONPAGED_POOL( WorkContext->ResponseBuffer->Buffer );

    }

    //
    // If the work context block has references to a share, a session,
    // or a tree connect, queue it to the FSP immediately.  These blocks
    // are not in nonpaged pool, so they can't be touched at DPC level.
    //

    if ( (WorkContext->Share != NULL) ||
         (WorkContext->Session != NULL) ||
         (WorkContext->TreeConnect != NULL) ) {

        goto queueToFsp;

    }

    ACQUIRE_SPIN_LOCK( &connection->SpinLock, &oldIrql );

    //
    // See if we can dereference the RawWriteCount here.  If the raw
    // write count goes to 0, and the RFCB is closing, or if there are
    // work items queued waiting for the raw write to complete, we need
    // to do this in the FSP.
    //
    // NOTE: The FSP decrements the count if WorkContext->Rfcb != NULL.
    //

    rfcb = WorkContext->Rfcb;
    --rfcb->RawWriteCount;

    if ( (rfcb->RawWriteCount == 0) &&
         ( (GET_BLOCK_STATE(rfcb) == BlockStateClosing) ||
           !IsListEmpty(&rfcb->RawWriteSerializationList) ) ) {

        rfcb->RawWriteCount++;

        RELEASE_SPIN_LOCK( &connection->SpinLock, oldIrql );
        goto queueToFsp;

    }

    //
    // Dereference the file block.  It is safe to decrement the count here
    // because either the rfcb is not closed or RawWriteCount is not zero
    // which means that the active reference is still there.
    //

    UPDATE_REFERENCE_HISTORY( rfcb, TRUE );
    --rfcb->BlockHeader.ReferenceCount;
    ASSERT( rfcb->BlockHeader.ReferenceCount > 0 );

    RELEASE_SPIN_LOCK( &connection->SpinLock, oldIrql );
    WorkContext->Rfcb = NULL;

    //
    // Attempt to dereference the connection.
    //

    ACQUIRE_SPIN_LOCK( connection->EndpointSpinLock, &oldIrql );

    if ( connection->BlockHeader.ReferenceCount == 1 ) {
        RELEASE_SPIN_LOCK( connection->EndpointSpinLock, oldIrql );
        goto queueToFsp;
    }

    --connection->BlockHeader.ReferenceCount;
    RELEASE_SPIN_LOCK( connection->EndpointSpinLock, oldIrql );

    UPDATE_REFERENCE_HISTORY( connection, TRUE );

    WorkContext->Connection = NULL;
    WorkContext->Endpoint = NULL;       // not a referenced pointer

    //
    // Put the work item back on the raw mode work item list.
    //

    InterlockedIncrement( &queue->FreeRawModeWorkItems );

    ExInterlockedPushEntrySList( &queue->RawModeWorkItemList,
                                 &WorkContext->SingleListEntry,
                                 &queue->SpinLock );

    IF_DEBUG(FSD2) SrvPrint0( "RestartWriteCompleteResponse complete\n" );
    return;

queueToFsp:

    //
    // We were unable to do all the necessary cleanup at DPC level.
    // Queue the work item to the FSP.
    //

    WorkContext->FspRestartRoutine = SrvRestartWriteCompleteResponse;

    SrvQueueWorkToFsp( WorkContext );

    IF_DEBUG(FSD2) SrvPrint0( "RestartWriteCompleteResponse complete\n" );
    return;

} // RestartWriteCompleteResponse


VOID SRVFASTCALL
SrvFsdRestartWriteRaw (
    IN OUT PWORK_CONTEXT WorkContext
    )

/*++

Routine Description:

    Processes file write completion for the Write Block Raw SMB.

    This routine is called in both the FSP and the FSD.

Arguments:

    WorkContext - Supplies a pointer to the work context block
        describing server-specific context for the request.

Return Value:

    None.

--*/

{
    KIRQL oldIrql;
    ULONG writeLength;
    ULONG immediateLength;
    BOOLEAN immediateWriteDone;
    SHARE_TYPE shareType;
    PMDL mdl;
    ULONG sendLength;
    PVOID finalResponseBuffer;
    NTSTATUS status = STATUS_SUCCESS;
    PRFCB rfcb = WorkContext->Rfcb;

    if (WorkContext->PreviousSMB == EVENT_TYPE_SMB_LAST_EVENT)
        WorkContext->PreviousSMB = EVENT_TYPE_SMB_WRITE_RAW;
    SrvWmiStartContext(WorkContext);
    IF_DEBUG(FSD1) SrvPrint0( " - SrvFsdRestartWriteRaw\n" );

    //
    // Find out the file type that we are dealing with.  If it is a pipe
    // then we have not prewritten the immediate data.
    //
    // immediateLength is the length of the data sent with the write
    // block raw request.
    //

    shareType = rfcb->ShareType;
    immediateLength = WorkContext->Parameters.WriteRaw.ImmediateLength;
    immediateWriteDone = WorkContext->Parameters.WriteRaw.ImmediateWriteDone;

    //
    // Deallocate the raw receive buffer.  Note that we do not need to
    // unlock the raw buffer, because it was allocated out of nonpaged
    // pool and locked using MmBuildMdlForNonPagedPool, which doesn't
    // increment reference counts and therefore has no inverse.
    //

    if ( !WorkContext->Parameters.WriteRaw.MdlWrite ) {

        //
        // If this is a named pipe the request buffer actually points
        // "immediateLength" bytes into the write buffer.
        //

        if ( immediateWriteDone ) {
            DEALLOCATE_NONPAGED_POOL( WorkContext->RequestBuffer->Buffer );
            IF_SMB_DEBUG(RAW2) {
                SrvPrint1( "raw buffer 0x%p deallocated\n",
                            WorkContext->RequestBuffer->Buffer );
            }
        } else {
            DEALLOCATE_NONPAGED_POOL(
               (PCHAR)WorkContext->RequestBuffer->Buffer - immediateLength );
            IF_SMB_DEBUG(RAW2) {
                SrvPrint1( "raw buffer 0x%p deallocated\n",
                 (PCHAR)WorkContext->RequestBuffer->Buffer - immediateLength );
            }
        }

    }

    status = WorkContext->Irp->IoStatus.Status;

    //
    // If this is not a pipe we have already successfully written the
    // immediate pipe data, so return the total bytes written by the two
    // write operations.
    //

    writeLength = (ULONG)WorkContext->Irp->IoStatus.Information;

    if( NT_SUCCESS( status ) && writeLength == 0 ) {

        writeLength = WorkContext->Parameters.WriteRaw.Length;

    } else {

        if ( immediateWriteDone ) {
            writeLength += immediateLength;
        }
    }

    UPDATE_WRITE_STATS( WorkContext, writeLength );

    finalResponseBuffer = WorkContext->Parameters.WriteRaw.FinalResponseBuffer;

    //
    // Update the file position.
    //
    // !!! Need to worry about wraparound?
    //

    if ( shareType == ShareTypeDisk || shareType == ShareTypePrint ) {

        rfcb->CurrentPosition =
                WorkContext->Parameters.WriteRaw.Offset.LowPart + writeLength;

    }

    if ( finalResponseBuffer == NULL ) {

        //
        // Update server statistics.
        //

        UPDATE_STATISTICS( WorkContext, 0, SMB_COM_WRITE_RAW );

        //
        // Save the write behind error, if any.
        //

        if ( !NT_SUCCESS( status ) ) {

            //
            // because of our assumption that the cached rfcb does
            // not have a write behind error stored.  This saves us
            // a compare on our critical path.
            //

            if ( WorkContext->Connection->CachedFid == (ULONG)rfcb->Fid ) {
                WorkContext->Connection->CachedFid = (ULONG)-1;
            }
            rfcb->SavedError = status;
        }

        //
        // Dereference control blocks, etc.
        //

        WorkContext->ResponseBuffer->Buffer = NULL;

        RestartWriteCompleteResponse( WorkContext );

        IF_DEBUG(TRACE2) SrvPrint0( "SrvFsdRestartWriteRaw complete\n" );
        goto Cleanup;

    }

    //
    // Writethrough mode.  Send a response to the client.  We have to
    // get a little tricky here, to make the raw mode work item look
    // enough like a normal one to be able to send using it.  Note that
    // the header from the original request SMB was copied into the
    // final response buffer.
    //

    WorkContext->ResponseHeader = (PSMB_HEADER)finalResponseBuffer;
    WorkContext->ResponseParameters = WorkContext->ResponseHeader + 1;

    ASSERT( WorkContext->RequestBuffer == WorkContext->ResponseBuffer );

    WorkContext->ResponseBuffer->Buffer = finalResponseBuffer;
    sendLength = (ULONG)( (PCHAR)NEXT_LOCATION(
                                    WorkContext->ResponseParameters,
                                    RESP_WRITE_COMPLETE,
                                    0
                                    ) - (PCHAR)finalResponseBuffer );
    WorkContext->ResponseBuffer->DataLength = sendLength;

    //
    // Remap the MDL to describe the final response buffer.
    //

    mdl = WorkContext->ResponseBuffer->Mdl;

    MmInitializeMdl( mdl, finalResponseBuffer, sendLength );
    MmBuildMdlForNonPagedPool( mdl );

    //
    // Set the bit in the SMB that indicates this is a response from the
    // server.
    //

    WorkContext->ResponseHeader->Flags |= SMB_FLAGS_SERVER_TO_REDIR;

    //
    // Send the response.  When the send completes, the restart routine
    // RestartWriteCompleteResponse is called.  We then dereference
    // control blocks and put the raw mode work item back on the free
    // list.
    //

    if ( (status != STATUS_SUCCESS) &&
         (KeGetCurrentIrql() >= DISPATCH_LEVEL) ) {
        WorkContext->Irp->IoStatus.Status = status;
        WorkContext->Irp->IoStatus.Information = writeLength;
        WorkContext->FspRestartRoutine = SrvBuildAndSendWriteCompleteResponse;
        WorkContext->FsdRestartRoutine = RestartWriteCompleteResponse; // after response
        QUEUE_WORK_TO_FSP( WorkContext );
    } else {
        SrvFsdBuildWriteCompleteResponse(
            WorkContext,
            status,
            writeLength
            );
        SRV_START_SEND_2(
            WorkContext,
            SrvFsdSendCompletionRoutine,
            RestartWriteCompleteResponse,
            NULL
            );
    }

Cleanup:
    SrvWmiEndContext(WorkContext);
    return;

} // SrvFsdRestartWriteRaw
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\srv\fspinit.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    fspinit.c

Abstract:

    This module implements the initialization phase of the LAN Manager
    server File System Process.

Author:

    Chuck Lenzmeier (chuckl)    22-Sep-1989
    David Treadwell (davidtr)

Revision History:

--*/

#include "precomp.h"
#include "fspinit.tmh"
#pragma hdrstop

#define BugCheckFileId SRV_FILE_FSPINIT

//
// Forward declarations.
//

PIRP
DequeueConfigurationIrp (
    VOID
    );

STATIC
NTSTATUS
InitializeServer (
    VOID
    );

STATIC
NTSTATUS
TerminateServer (
    VOID
    );

VOID
SrvFreeRegTables (
    VOID
    );

VOID
SrvGetRegTables (
    VOID
    );

#if SRVNTVERCHK
VOID
SrvGetRegClientNumber (
    VOID
    );
#endif

VOID
StartQueueDepthComputations(
    PWORK_QUEUE queue
    );

VOID
StopQueueDepthComputations(
    PWORK_QUEUE queue
    );

VOID
ComputeAvgQueueDepth (
    IN PKDPC Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemArgument1,
    IN PVOID SystemArgument2
    );

BOOLEAN
GenerateCrcTable();

BOOLEAN
CleanupCrcTable();

#ifdef ALLOC_PRAGMA
#pragma alloc_text( PAGE, SrvConfigurationThread )
#pragma alloc_text( PAGE, InitializeServer )
#pragma alloc_text( PAGE, TerminateServer )
#pragma alloc_text( PAGE, SrvFreeRegTables )
#pragma alloc_text( PAGE, SrvGetRegTables )
#if SRVNTVERCHK
#pragma alloc_text( PAGE, SrvGetRegClientNumber )
#endif
#pragma alloc_text( PAGE, DequeueConfigurationIrp )
#pragma alloc_text( PAGE, StartQueueDepthComputations )
#endif


VOID
SrvConfigurationThread (
    IN PDEVICE_OBJECT pDevice,
    IN PIO_WORKITEM pWorkItem
    )

/*++

Routine Description:

    This routine processes configuration IRPs.

Arguments:

    None.

Return Value:

    None.

--*/

{
    NTSTATUS status;
    PIRP irp;
    PIO_STACK_LOCATION irpSp;
    ULONG code;

    PAGED_CODE( );

    IF_DEBUG(FSP1) KdPrint(( "SrvConfigurationThread entered\n" ));

    //
    // Loop processing requests.
    //

    while ( TRUE ) {

        irp = DequeueConfigurationIrp( );

        if ( irp == NULL ) break;

        ASSERT( (LONG)SrvConfigurationIrpsInProgress >= 1 );

        //
        // Get the IRP stack pointer.
        //

        irpSp = IoGetCurrentIrpStackLocation( irp );

        if( irpSp->MajorFunction == IRP_MJ_CLOSE ) {

            //
            // If the dispatcher routed this irp here, it means
            //  that we unexpectededly got the last handle close without
            //  having gotten cleanly terminated first. Ok, so we should
            //  shut ourselves down, since we can't sensibly run without
            //  our usermode counterpart.
            //

            ACQUIRE_LOCK( &SrvStartupShutdownLock );
            status = TerminateServer();
            RELEASE_LOCK( &SrvStartupShutdownLock );

        } else {

            ASSERT( irpSp->MajorFunction == IRP_MJ_FILE_SYSTEM_CONTROL );

            try {

                //
                // Dispatch on the FsControlCode.
                //

                code = irpSp->Parameters.FileSystemControl.FsControlCode;

                switch ( code ) {

                case FSCTL_SRV_STARTUP:
                    ACQUIRE_LOCK( &SrvStartupShutdownLock );

                    status = InitializeServer();

                    if ( !NT_SUCCESS(status) ) {

                        //
                        // Terminate the server FSP.
                        //
                        (void)TerminateServer();

                    }

                    RELEASE_LOCK( &SrvStartupShutdownLock );

                    break;

                case FSCTL_SRV_SHUTDOWN:

                    ACQUIRE_LOCK( &SrvStartupShutdownLock );
                    status = TerminateServer();
                    RELEASE_LOCK( &SrvStartupShutdownLock );

                    //
                    // If there is more than one handle open to the server
                    // device (i.e., any handles other than the server service's
                    // handle), return a special status code to the caller (who
                    // should be the server service).  This tells the caller to
                    // NOT unload the driver, in order prevent weird situations
                    // where the driver is sort of unloaded, so it can't be used
                    // but also can't be reloaded, thus preventing the server
                    // from being restarted.
                    //

                    if( NT_SUCCESS( status ) && SrvOpenCount != 1 ) {
                        status = STATUS_SERVER_HAS_OPEN_HANDLES;
                    }

                    break;

                case FSCTL_SRV_REGISTRY_CHANGE:
                    //
                    // The Parameters section of the server service registry has changed.
                    // That's likely due to somebody changing the Null Session pipe or
                    //  share lists.  Pick up the new settings.
                    //
                    ACQUIRE_LOCK( &SrvConfigurationLock );

                    SrvFreeRegTables();
                    SrvGetRegTables();
    #if SRVNTVERCHK
                    SrvGetRegClientNumber();
    #endif

                    RELEASE_LOCK( &SrvConfigurationLock );

                    status = STATUS_SUCCESS;

                    break;

                case FSCTL_SRV_BEGIN_PNP_NOTIFICATIONS:
                    //
                    // If somebody tries to shut down the server while
                    //  we are registering our handlers, block them until
                    //  we are finished.
                    //
                    ACQUIRE_LOCK( &SrvStartupShutdownLock );

                    {
                        TDI_CLIENT_INTERFACE_INFO ClientInterfaceInfo;

                        RtlZeroMemory(&ClientInterfaceInfo, sizeof(TDI_CLIENT_INTERFACE_INFO));

                        ClientInterfaceInfo.MajorTdiVersion = 2;
                        ClientInterfaceInfo.MinorTdiVersion = 0;
                        ClientInterfaceInfo.ClientName = &StrRegSrvPnpClientName;
                        ClientInterfaceInfo.BindingHandler = SrvPnpBindingHandler;
                        ClientInterfaceInfo.PnPPowerHandler = SrvPnpPowerHandler;


                        status = TdiRegisterPnPHandlers(
                                                        &ClientInterfaceInfo,
                                                        sizeof( ClientInterfaceInfo ),
                                                        &SrvTdiNotificationHandle
                                                        );

                        if (status != STATUS_SUCCESS) {
                            SrvTdiNotificationHandle = NULL;
                        }
                    }

                    RELEASE_LOCK( &SrvStartupShutdownLock );

                    if( !NT_SUCCESS( status ) ) {

                            IF_DEBUG( PNP ) {
                                KdPrint(("TdiRegisterNotificationHandler: status %X\n", status ));
                            }

                            SrvLogServiceFailure( SRV_SVC_PNP_TDI_NOTIFICATION, status );
                    }

                    //
                    // Allow the transports to begin receiving connections
                    //
                    SrvCompletedPNPRegistration = TRUE;

                    break;

                case FSCTL_SRV_XACTSRV_CONNECT:
                {
                    ANSI_STRING ansiPortName;
                    UNICODE_STRING portName;

                    IF_DEBUG(XACTSRV) {
                        KdPrint(( "SrvFspConfigurationThread: XACTSRV FSCTL "
                                  "received.\n" ));
                    }

                    ansiPortName.Buffer = irp->AssociatedIrp.SystemBuffer;
                    ansiPortName.Length =
                        (USHORT)irpSp->Parameters.FileSystemControl.InputBufferLength;

                    status = RtlAnsiStringToUnicodeString(
                                 &portName,
                                 &ansiPortName,
                                 TRUE
                                 );
                    if ( NT_SUCCESS(status) ) {
                        status = SrvXsConnect( &portName );
                        RtlFreeUnicodeString( &portName );
                    }

                    break;
                }

                case FSCTL_SRV_XACTSRV_DISCONNECT:
                {
                    //
                    // This is now obsolete
                    //
                    status = STATUS_SUCCESS;

                    break;
                }

                case FSCTL_SRV_START_SMBTRACE:
                {
                    KdPrint(( "SrvFspConfigurationThread: START_SMBTRACE FSCTL "
                                                  "received.\n" ));

                    //
                    // Initialize the SmbTrace related events.
                    //

                    status = SmbTraceInitialize( SMBTRACE_SERVER );

                    if ( NT_SUCCESS(status) ) {

                        //
                        // Create shared memory, create events, start SmbTrace thread,
                        // and indicate that this is the server.
                        //

                        status = SmbTraceStart(
                                    irpSp->Parameters.FileSystemControl.InputBufferLength,
                                    irpSp->Parameters.FileSystemControl.OutputBufferLength,
                                    irp->AssociatedIrp.SystemBuffer,
                                    irpSp->FileObject,
                                    SMBTRACE_SERVER
                                    );

                        if ( NT_SUCCESS(status) ) {

                            //
                            // Record the length of the return information, which is
                            // simply the length of the output buffer, validated by
                            // SmbTraceStart.
                            //

                            irp->IoStatus.Information =
                                    irpSp->Parameters.FileSystemControl.OutputBufferLength;

                        }

                    }

                    break;
                }

                case FSCTL_SRV_SEND_DATAGRAM:
                {
                    ANSI_STRING domain;
                    ULONG buffer1Length;
                    PVOID buffer2;
                    PSERVER_REQUEST_PACKET srp;

                    buffer1Length = ALIGN_UP(
                        irpSp->Parameters.FileSystemControl.InputBufferLength,
                        PVOID );

                    buffer2 = (PCHAR)irp->AssociatedIrp.SystemBuffer + buffer1Length;

                    srp = irp->AssociatedIrp.SystemBuffer;

                    //
                    // Send the second-class mailslot in Buffer2 to the domain
                    // specified in srp->Name1 on transport specified by srp->Name2.
                    //

                    domain = *((PANSI_STRING) &srp->Name1);

                    status = SrvSendDatagram(
                                 &domain,
                                 ( srp->Name2.Length != 0 ? &srp->Name2 : NULL ),
                                 buffer2,
                                 irpSp->Parameters.FileSystemControl.OutputBufferLength
                                 );

                    ExFreePool( irp->AssociatedIrp.SystemBuffer );
                    DEBUG irp->AssociatedIrp.SystemBuffer = NULL;

                    break;
                }

                case FSCTL_SRV_NET_FILE_CLOSE:
                case FSCTL_SRV_NET_SERVER_XPORT_ADD:
                case FSCTL_SRV_NET_SERVER_XPORT_DEL:
                case FSCTL_SRV_NET_SESSION_DEL:
                case FSCTL_SRV_NET_SHARE_ADD:
                case FSCTL_SRV_NET_SHARE_DEL:
                {
                    PSERVER_REQUEST_PACKET srp;
                    PVOID buffer2;
                    ULONG buffer1Length;
                    ULONG buffer2Length;

                    //
                    // These APIs are handled in the server FSP because they
                    // open or close FSP handles.
                    //

                    ACQUIRE_LOCK_SHARED( &SrvConfigurationLock );
                    if( SrvFspTransitioning == TRUE && SrvFspActive == TRUE ) {
                        //
                        // The server is coming down.  Do not allow these
                        //  irps to continue.
                        //
                        RELEASE_LOCK( &SrvConfigurationLock );
                        status = STATUS_SERVER_NOT_STARTED;
                        break;
                    }
                    RELEASE_LOCK( &SrvConfigurationLock );

                    //
                    // Get the server request packet and secondary input buffer
                    // pointers.
                    //

                    buffer1Length = ALIGN_UP(
                        irpSp->Parameters.FileSystemControl.InputBufferLength,
                        PVOID );

                    buffer2Length =
                        irpSp->Parameters.FileSystemControl.OutputBufferLength;

                    srp = irp->AssociatedIrp.SystemBuffer;
                    buffer2 = (PCHAR)srp + buffer1Length;

                    //
                    // Dispatch the API request to the appripriate API processing
                    // routine.
                    //

                    status = SrvApiDispatchTable[ SRV_API_INDEX(code) ](
                                 srp,
                                 buffer2,
                                 buffer2Length
                                 );

                    break;
                }

                default:
                    IF_DEBUG(ERRORS) {
                        KdPrint((
                            "SrvFspConfigurationThread: Invalid control code %lx\n",
                            irpSp->Parameters.FileSystemControl.FsControlCode ));
                    }

                    status = STATUS_INVALID_PARAMETER;
                }
            } except(EXCEPTION_EXECUTE_HANDLER) {
                status = GetExceptionCode();
            }
        }

        //
        // Make sure we're still at PASSIVE_LEVEL
        //
        if( KeGetCurrentIrql() > PASSIVE_LEVEL )
        {
            goto bad_irql_failure;
        }

        //
        // Complete the IO request.
        //

        irp->IoStatus.Status = status;
        IoCompleteRequest( irp, 2 );

        //
        // Make sure we're still at PASSIVE_LEVEL
        //
        if( KeGetCurrentIrql() > PASSIVE_LEVEL )
        {
            goto bad_irql_failure;
        }

        ASSERT( (LONG)SrvConfigurationIrpsInProgress >= 0 );

        // Make sure we don't continue if there are no IRP's left
        if( InterlockedDecrement( (PLONG)&SrvConfigurationIrpsInProgress ) == 0 )
        {
            break;
        }
    }

    IoFreeWorkItem( pWorkItem );

    return;

bad_irql_failure:

    DbgPrint( "ERROR: SrvConfigurationThread returning at >PASSIVE level\n" );
    DbgBreakPoint();

    IoFreeWorkItem( pWorkItem );

    return;

} // SrvConfigurationThread


PIRP
DequeueConfigurationIrp (
    VOID
    )

/*++

Routine Description:

    This routine retrieves an IRP from the configuration work queue.

Arguments:

    None.

Return Value:

    PIRP - Pointer to configuration IRP, or NULL.

--*/

{
    PLIST_ENTRY listEntry;
    PIRP irp;

    PAGED_CODE( );

    //
    // Take an IRP off the configuration queue.
    //

    ACQUIRE_LOCK( &SrvConfigurationLock );

    listEntry = RemoveHeadList( &SrvConfigurationWorkQueue );

    if ( listEntry == &SrvConfigurationWorkQueue ) {

        //
        // The queue is empty.
        //

        irp = NULL;

    } else {

        irp = CONTAINING_RECORD( listEntry, IRP, Tail.Overlay.ListEntry );

    }

    RELEASE_LOCK( &SrvConfigurationLock );

    return irp;

} // DequeueConfigurationIrp


STATIC
NTSTATUS
InitializeServer (
    VOID
    )

/*++

Routine Description:

    This routine initializes the server.

Arguments:

    None.

Return Value:

    None.

--*/

{
    NTSTATUS status;
    CLONG i;
    PWORK_CONTEXT workContext;
    OBJECT_ATTRIBUTES objectAttributes;
    IO_STATUS_BLOCK ioStatusBlock;
    OBJECT_HANDLE_INFORMATION handleInformation;
    PSID AdminSid;
    PSID AnonymousSid;
    PACL Acl;
    ULONG length;
    SID_IDENTIFIER_AUTHORITY BuiltinAuthority = SECURITY_NT_AUTHORITY;
    PWORK_QUEUE queue;
    HANDLE handle;
    UNICODE_STRING string;

    PAGED_CODE();

    //
    // If running as an Advanced Server, lock all pageable server code.
    //

    if ( SrvProductTypeServer ) {
        for ( i = 0; i < SRV_CODE_SECTION_MAX; i++ ) {
            SrvReferenceUnlockableCodeSection( i );
        }
    }

    //
    // Initialize the server start time
    //

    KeQuerySystemTime( &SrvStatistics.StatisticsStartTime );

    //
    // Get actual alert service name using the display name found in the
    // registry.
    //

    SrvGetAlertServiceName( );

    //
    // Get the Os versions strings.
    //

    SrvGetOsVersionString( );

    //
    // Get the list of null session pipes and shares
    //
    SrvGetRegTables( );

#if SRVNTVERCHK
    SrvGetRegClientNumber();
#endif

#if MULTIPROCESSOR
    //
    // Allocate and init the nonblocking work queues, paying attention to cache lines
    //
    i = SrvNumberOfProcessors * sizeof( *SrvWorkQueues );
    i += CACHE_LINE_SIZE;
    SrvWorkQueuesBase = ALLOCATE_NONPAGED_POOL( i, BlockTypeWorkQueue );

    if( SrvWorkQueuesBase == NULL ) {
         return STATUS_INSUFF_SERVER_RESOURCES;
    }

    //
    // Round up the start of the work queue data structure to
    // the next cache line boundry
    //
    SrvWorkQueues = (PWORK_QUEUE)(((ULONG_PTR)SrvWorkQueuesBase + CACHE_LINE_SIZE-1) &
                    ~(CACHE_LINE_SIZE-1));
#endif


    eSrvWorkQueues = SrvWorkQueues + SrvNumberOfProcessors;

    RtlZeroMemory( SrvWorkQueues, (char *)eSrvWorkQueues - (char *)SrvWorkQueues );

    for( queue = SrvWorkQueues; queue < eSrvWorkQueues; queue++ ) {
        KeInitializeQueue( &queue->Queue, 1 );
        queue->WaitMode         = SrvProductTypeServer ? KernelMode : UserMode;
        queue->MaxThreads       = SrvMaxThreadsPerQueue;
        queue->MaximumWorkItems = SrvMaxReceiveWorkItemCount / SrvNumberOfProcessors;
        queue->MinFreeWorkItems = SrvMinReceiveQueueLength / SrvNumberOfProcessors;
        queue->MaxFreeRfcbs     = SrvMaxFreeRfcbs;
        queue->MaxFreeMfcbs     = SrvMaxFreeMfcbs;
        ExInitializeSListHead(&queue->InitialWorkItemList);
        ExInitializeSListHead(&queue->NormalWorkItemList);
        ExInitializeSListHead(&queue->RawModeWorkItemList);
        ExInitializeSListHead(&queue->RfcbFreeList);
        ExInitializeSListHead(&queue->MfcbFreeList);
        queue->PagedPoolLookAsideList.MaxSize  = SrvMaxPagedPoolChunkSize;
        queue->NonPagedPoolLookAsideList.MaxSize  = SrvMaxNonPagedPoolChunkSize;
        queue->CreateMoreWorkItems.CurrentWorkQueue = queue;
        queue->CreateMoreWorkItems.BlockHeader.ReferenceCount = 1;
        queue->IdleTimeOut.QuadPart = SrvIdleThreadTimeOut;

        INITIALIZE_SPIN_LOCK( &queue->SpinLock );
        SET_SERVER_TIME( queue );

#if MULTIPROCESSOR
        StartQueueDepthComputations( queue );
#endif
    }

    RtlZeroMemory( &SrvDoSWorkItem, sizeof(SPECIAL_WORK_ITEM) );
    SrvDoSWorkItem.BlockHeader.ReferenceCount = 1;
    SrvDoSWorkItemTearDown = SRV_DOS_TEARDOWN_MIN;
    KeInitializeSpinLock( &SrvDosSpinLock );

    //
    // Init the Blocking work queue
    //
    RtlZeroMemory( &SrvBlockingWorkQueue, sizeof( SrvBlockingWorkQueue ) );

    KeInitializeQueue( &SrvBlockingWorkQueue.Queue, 0 );

    SrvBlockingWorkQueue.WaitMode =
                SrvProductTypeServer ? KernelMode : UserMode;

    SrvBlockingWorkQueue.MaxThreads = SrvMaxThreadsPerQueue;
    SrvBlockingWorkQueue.IdleTimeOut.QuadPart = SrvIdleThreadTimeOut;

    //
    // If we are a multiprocessor server system, increase the number of blocking worker threads.
    //  Since most file opens end up being handled by the blocking queue, this can significantly
    //  improve performance for open-intensive workloads.
    //
    if( SrvProductTypeServer == TRUE && SrvNumberOfProcessors > 1 ) {
        SrvBlockingWorkQueue.MaxThreads *= 2;
    }

    SET_SERVER_TIME( &SrvBlockingWorkQueue );

    //
    // Build the receive work item list.
    //

    status = SrvAllocateInitialWorkItems( );
    if ( !NT_SUCCESS(status) ) {
        return status;
    }

    //
    // Build the raw mode work item list, and spread it around
    //  the processors
    //

    queue = SrvWorkQueues;
    for ( i = 0; i < SrvInitialRawModeWorkItemCount; i++ ) {

        SrvAllocateRawModeWorkItem( &workContext, queue );

        if ( workContext == NULL ) {
            return STATUS_INSUFFICIENT_RESOURCES;
        }

        GET_SERVER_TIME( queue, &workContext->Timestamp );

        SrvRequeueRawModeWorkItem( workContext );

        if( ++queue == eSrvWorkQueues )
            queue = SrvWorkQueues;
    }

    //
    // Create worker threads.
    //

    status = SrvCreateWorkerThreads( );
    if ( !NT_SUCCESS(status) ) {
        return status;
    }

    //
    // Initialize the scavenger.
    //

    status = SrvInitializeScavenger( );
    if ( !NT_SUCCESS(status) ) {
        return status;
    }

    //
    // Initialize the global ordered lists.
    //
    // *** WARNING:  Be careful when changing the locks associated with
    //     these ordered lists.  Certain places in the code depend on
    //     the level of the lock associated with a list.  Examples
    //     include (but are NOT limited to) SrvSmbSessionSetupAndX,
    //     SrvSmbTreeConnect, SrvSmbTreeConnectAndX, and CompleteOpen.
    //

    SrvInitializeOrderedList(
        &SrvEndpointList,
        FIELD_OFFSET( ENDPOINT, GlobalEndpointListEntry ),
        SrvCheckAndReferenceEndpoint,
        SrvDereferenceEndpoint,
        &SrvEndpointLock
        );

    SrvInitializeOrderedList(
        &SrvRfcbList,
        FIELD_OFFSET( RFCB, GlobalRfcbListEntry ),
        SrvCheckAndReferenceRfcb,
        SrvDereferenceRfcb,
        &SrvOrderedListLock
        );

    SrvInitializeOrderedList(
        &SrvSessionList,
        FIELD_OFFSET( SESSION, GlobalSessionListEntry ),
        SrvCheckAndReferenceSession,
        SrvDereferenceSession,
        &SrvOrderedListLock
        );

    SrvInitializeOrderedList(
        &SrvTreeConnectList,
        FIELD_OFFSET( TREE_CONNECT, GlobalTreeConnectListEntry ),
        SrvCheckAndReferenceTreeConnect,
        SrvDereferenceTreeConnect,
        &SrvShareLock
        );

    //
    // Open handle to NPFS.  Do not return an error if we fail so that
    // the server can still run without NPFS in the system.
    //

    SrvInitializeObjectAttributes_U(
        &objectAttributes,
        &SrvNamedPipeRootDirectory,
        0,
        NULL,
        NULL
        );

    status = IoCreateFile(
                &SrvNamedPipeHandle,
                GENERIC_READ | GENERIC_WRITE,
                &objectAttributes,
                &ioStatusBlock,
                NULL,
                FILE_ATTRIBUTE_NORMAL,
                FILE_SHARE_READ | FILE_SHARE_WRITE,
                FILE_OPEN,
                0,                      // Create Options
                NULL,                   // EA Buffer
                0,                      // EA Length
                CreateFileTypeNone,     // File type
                NULL,                   // ExtraCreateParameters
                IO_FORCE_ACCESS_CHECK   // Options
                );

    if (!NT_SUCCESS(status)) {

        INTERNAL_ERROR (
            ERROR_LEVEL_EXPECTED,
            "InitializeServer: Failed to open NPFS, err=%X\n",
            status,
            NULL
            );

        SrvLogServiceFailure( SRV_SVC_IO_CREATE_FILE_NPFS, status );
        SrvNamedPipeHandle = NULL;
        return status;

    } else {

        //
        // Get a pointer to the NPFS device object
        //

        status = SrvVerifyDeviceStackSize(
                                SrvNamedPipeHandle,
                                TRUE,
                                &SrvNamedPipeFileObject,
                                &SrvNamedPipeDeviceObject,
                                &handleInformation
                                );

        if ( !NT_SUCCESS( status )) {

            INTERNAL_ERROR(
                ERROR_LEVEL_EXPECTED,
                "InitializeServer: Verify Device Stack Size failed: %X\n",
                status,
                NULL
                );

            SrvNtClose( SrvNamedPipeHandle, FALSE );
            SrvNamedPipeHandle = NULL;
            return status;
        }
    }

    //
    // Initialize Dfs operations
    //
    SrvInitializeDfs();

    //
    // Intialize SrvAdminSecurityDescriptor, which allows Administrators READ access.
    //   This descriptor is used by the server to check if a user is an administrator
    //   in SrvIsAdmin().

    status = RtlCreateSecurityDescriptor( &SrvAdminSecurityDescriptor, SECURITY_DESCRIPTOR_REVISION );
    if( !NT_SUCCESS( status ) ) {
        return status;
    }

    //
    // Create an admin SID
    //
    AdminSid  = ALLOCATE_HEAP_COLD( RtlLengthRequiredSid( 2 ), BlockTypeAdminCheck );
    if( AdminSid == NULL ) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlInitializeSid( AdminSid, &BuiltinAuthority, (UCHAR)2 );
    *(RtlSubAuthoritySid( AdminSid, 0 )) = SECURITY_BUILTIN_DOMAIN_RID;
    *(RtlSubAuthoritySid( AdminSid, 1 )) = DOMAIN_ALIAS_RID_ADMINS;

    length = sizeof(ACL) + sizeof( ACCESS_ALLOWED_ACE ) + RtlLengthSid( AdminSid );
    Acl = ALLOCATE_HEAP_COLD( length, BlockTypeAdminCheck );
    if( Acl == NULL ) {
        FREE_HEAP( AdminSid );
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    status = RtlCreateAcl( Acl, length, ACL_REVISION2 );

    if( NT_SUCCESS( status ) ) {
        status = RtlAddAccessAllowedAce( Acl, ACL_REVISION2, FILE_GENERIC_READ, AdminSid );
    }

    if( NT_SUCCESS( status ) ) {
        status = RtlSetDaclSecurityDescriptor( &SrvAdminSecurityDescriptor, TRUE, Acl, FALSE );
    }

    if( NT_SUCCESS( status ) ) {
        status = RtlSetOwnerSecurityDescriptor( &SrvAdminSecurityDescriptor, AdminSid, FALSE );
    }

    if( !NT_SUCCESS( status ) ) {
        return status;
    }

    //
    // Intialize SrvNullSessionSecurityDescriptor, which allows anonymous
    // logons READ access. This descriptor is used by the server to check
    // if a user is an null session in SrvIsNullSession().
    //

    status = RtlCreateSecurityDescriptor( &SrvNullSessionSecurityDescriptor, SECURITY_DESCRIPTOR_REVISION );
    if( !NT_SUCCESS( status ) ) {
        return status;
    }

    //
    // Create an anonymous SID
    //
    AnonymousSid  = ALLOCATE_HEAP_COLD( RtlLengthRequiredSid( 1 ), BlockTypeAdminCheck );
    if( AnonymousSid == NULL ) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlInitializeSid( AnonymousSid, &BuiltinAuthority, (UCHAR)1 );
    *(RtlSubAuthoritySid( AnonymousSid, 0 )) = SECURITY_ANONYMOUS_LOGON_RID;

    length = sizeof(ACL) + sizeof( ACCESS_ALLOWED_ACE ) + RtlLengthSid( AnonymousSid );
    Acl = ALLOCATE_HEAP_COLD( length, BlockTypeAdminCheck );
    if( Acl == NULL ) {
        FREE_HEAP( AnonymousSid );
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    status = RtlCreateAcl( Acl, length, ACL_REVISION2 );

    if( NT_SUCCESS( status ) ) {
        status = RtlAddAccessAllowedAce( Acl, ACL_REVISION2, FILE_GENERIC_READ, AnonymousSid );
    }

    if( NT_SUCCESS( status ) ) {
        status = RtlSetDaclSecurityDescriptor( &SrvNullSessionSecurityDescriptor, TRUE, Acl, FALSE );
    }

    if( NT_SUCCESS( status ) ) {
        status = RtlSetOwnerSecurityDescriptor( &SrvNullSessionSecurityDescriptor, AnonymousSid, FALSE );
    }

    if( !NT_SUCCESS( status ) ) {
        return status;
    }

    (VOID) InitSecurityInterface();

    status = SrvValidateUser(
                &SrvNullSessionToken,
                NULL,
                NULL,
                NULL,
                StrNullAnsi,
                1,
                NULL,
                0,
                FALSE,
                NULL
                );

    if ( !NT_SUCCESS(status) ) {

        //
        // LSA doesn't want to let the null session in.  He's the boss!
        //
        INVALIDATE_SECURITY_HANDLE( SrvNullSessionToken );
    }

    //
    // See if the filesystems are allowing extended characters in 8.3 names.  If
    //  so, we need to filter them out ourself.
    //
    RtlInitUnicodeString( &string, StrRegExtendedCharsInPath );
    InitializeObjectAttributes( &objectAttributes,
                                &string,
                                OBJ_CASE_INSENSITIVE,
                                NULL,
                                NULL
                              );

    status = ZwOpenKey( &handle, KEY_READ, &objectAttributes );

    if( NT_SUCCESS( status ) ) {
        ULONG resultLength;
        union {
            KEY_VALUE_FULL_INFORMATION;
            UCHAR   buffer[ sizeof( KEY_VALUE_FULL_INFORMATION ) + 100 ];
        } keyValueInformation;

        RtlInitUnicodeString( &string, StrRegExtendedCharsInPathValue );
        status = ZwQueryValueKey( handle,
                                  &string,
                                  KeyValueFullInformation,
                                  &keyValueInformation,
                                  sizeof( keyValueInformation ),
                                  &resultLength
                                );

        if( NT_SUCCESS( status ) &&
            keyValueInformation.Type == REG_DWORD &&
            keyValueInformation.DataLength != 0 ) {

            SrvFilterExtendedCharsInPath =
                *(PULONG)(((PUCHAR)(&keyValueInformation)) + keyValueInformation.DataOffset) ?
                TRUE : FALSE;
        }

        ZwClose( handle );
    }

    //
    // Get a handle to use in PoRegisterSystemState() calls
    //
    SrvPoRegistrationState = PoRegisterSystemState( NULL, 0 );

    //
    // Indicate that the server is active.
    //

    ACQUIRE_LOCK( &SrvConfigurationLock );

    SrvFspTransitioning = FALSE;
    SrvFspActive = TRUE;

    RELEASE_LOCK( &SrvConfigurationLock );

    return STATUS_SUCCESS;

} // InitializeServer


STATIC
NTSTATUS
TerminateServer ( VOID )

/*++

Routine Description:

    This routine terminates the server.  The following steps are performed:

        - Walk through SrvEndpointList and close all open endpoints.

        - Walk through the work context blocks in the work queues
            getting rid of them as appropiate

        - Close all shares open in the server

        - Deallocate the search table

Arguments:

Return Value:

    None.

--*/

{
    PLIST_ENTRY listEntry;
    PSINGLE_LIST_ENTRY singleListEntry;
    PENDPOINT endpoint;
    ULONG numberOfThreads;
    PWORK_CONTEXT workContext;
    PSHARE share;
    ULONG i;
    SPECIAL_WORK_ITEM WorkItem;
    PSRV_TIMER timer;
    PSID adminsid;
    PSID anonymoussid;
    PACL acl;
    BOOLEAN defaulted;
    BOOLEAN daclpresent;
    NTSTATUS status;
    PWORK_QUEUE queue;
    PIRP irp;
    PLIST_ENTRY listEntryRoot;

    PAGED_CODE( );

    IF_DEBUG(FSP1) KdPrint(( "LAN Manager server FSP terminating.\n" ));

    //
    // Do not receive PNP notifications anymore
    //
    if( SrvTdiNotificationHandle != NULL ) {

        status = TdiDeregisterPnPHandlers( SrvTdiNotificationHandle );

        if( !NT_SUCCESS( status ) ) {
            KdPrint(( "TdiDeregisterPnPHandlers status %X\n", status ));
            SrvLogServiceFailure( SRV_SVC_PNP_TDI_NOTIFICATION, status );
            return status;
        }

        SrvTdiNotificationHandle = NULL;
    }

    //
    // Make sure we are not processing any other configuration IRPs.  We know
    //  that no new configuration IRPs can enter the queue because SrvFspTransitioning
    //  has been set.
    //
    // First drain the configuration queue
    //
    while( 1 ) {

        ACQUIRE_LOCK( &SrvConfigurationLock );

        irp = DequeueConfigurationIrp( );

        RELEASE_LOCK( &SrvConfigurationLock );

        if( irp == NULL ) {
            break;
        }

        irp->IoStatus.Status = STATUS_SERVER_NOT_STARTED;
        IoCompleteRequest( irp, 2 );
        InterlockedDecrement( (PLONG)&SrvConfigurationIrpsInProgress );
    }

    //
    // Now wait until any already dequeued configuration IRPs have been completed.  We
    //  check for >1 because we need to account for our own IRP
    //
    while( SrvConfigurationIrpsInProgress > 1 ) {

        LARGE_INTEGER interval;

        interval.QuadPart = -1*10*1000*10; // .01 second

        ASSERT( (LONG)SrvConfigurationIrpsInProgress > 0 );

        KeDelayExecutionThread( KernelMode, FALSE, &interval );
    }

    //
    // If there are outstanding API requests in the server FSD,
    // wait for them to complete.  The last one to complete will
    // set SrvApiCompletionEvent.
    //

    ACQUIRE_LOCK( &SrvConfigurationLock );

    if ( SrvApiRequestCount != 0 ) {

        //
        // We must release the lock before waiting so that the FSD
        // threads can get it to decrement SrvApiRequestCount.
        //

        RELEASE_LOCK( &SrvConfigurationLock );


        for (;;) {
            NTSTATUS WaitStatus;

            //
            // Wait until the last API has completed.  Since
            // SrvFspTransitioning was set to TRUE earlier, we know that the
            // API that makes SrvApiRequestCount go to zero will set the
            // event.
            //
            // This wait allows us to make the assumption later on that no
            // other thread is operating on server data structures.
            //

            WaitStatus = KeWaitForSingleObject(
                             &SrvApiCompletionEvent,
                             UserRequest,
                             UserMode,   // let kernel stack be paged
                             FALSE,
                             NULL
                         );

            if (WaitStatus != STATUS_USER_APC) {
                break;
            }
        }

    } else {

        RELEASE_LOCK( &SrvConfigurationLock );
    }


    //
    // Close all the endpoints opened by the server.  This also results
    // in the connections, sessions, tree connects, and files opened
    // by the server being closed.
    //

    ACQUIRE_LOCK( &SrvEndpointLock );

    if ( SrvEndpointCount != 0 ) {

        listEntry = SrvEndpointList.ListHead.Flink;

        while ( listEntry != &SrvEndpointList.ListHead ) {

            endpoint = CONTAINING_RECORD(
                            listEntry,
                            ENDPOINT,
                            GlobalEndpointListEntry
                            );

            if ( GET_BLOCK_STATE(endpoint) != BlockStateActive ) {
                listEntry = listEntry->Flink;
                continue;
            }

            //
            // We don't want to hold the endpoint lock while we close
            // the endpoint (this causes lock level problems), so we have
            // to play some games.
            //
            // Reference the endpoint to ensure that it doesn't go away.
            // (We'll need its Flink later.)  Close the endpoint.  This
            // releases the endpoint lock.  Reacquire the endpoint lock.
            // Capture the address of the next endpoint.  Dereference the
            // current endpoint.
            //

            SrvReferenceEndpoint( endpoint );
            SrvCloseEndpoint( endpoint );

            ACQUIRE_LOCK( &SrvEndpointLock );

            listEntry = listEntry->Flink;
            SrvDereferenceEndpoint( endpoint );

        }

        RELEASE_LOCK( &SrvEndpointLock );

        for (;;) {
            NTSTATUS WaitStatus;

            //
            // Wait until all the endpoints have actually closed.
            //

            WaitStatus = KeWaitForSingleObject(
                            &SrvEndpointEvent,
                            UserRequest,
                            UserMode,   // let kernel stack be paged
                            FALSE,
                            NULL
                            );

            if (WaitStatus != STATUS_USER_APC) {
                break;
            }
        }

    } else {

        RELEASE_LOCK( &SrvEndpointLock );

    }

    KeClearEvent( &SrvEndpointEvent );

    //
    // All the endpoints are closed, so it's impossible for there to
    // be any outstanding requests to xactsrv.  So shut it down.
    //
    SrvXsDisconnect();

    //
    // Queue a special work item to each of the work queues.  This
    // work item, when received by a worker thread. causes the thread
    // to requeue the work item and terminate itself.  In this way,
    // each of the worker threads receives the work item and kills
    // itself.
    //

    WorkItem.FspRestartRoutine = SrvTerminateWorkerThread;
    SET_BLOCK_TYPE( &WorkItem, BlockTypeWorkContextSpecial );

    //
    // Kill the threads on the nonblocking work queues
    //

    if ( SrvWorkQueues != NULL ) {

        for( queue=SrvWorkQueues; queue && queue < eSrvWorkQueues; queue++ ) {

            WorkItem.CurrentWorkQueue = queue;

            SrvInsertWorkQueueTail(
                queue,
                (PQUEUEABLE_BLOCK_HEADER)&WorkItem
                );

            //
            // Wait for the threads to all die
            //
            while( queue->Threads != 0 ) {

                LARGE_INTEGER interval;

                interval.QuadPart = -1*10*1000*10; // .01 second

                KeDelayExecutionThread( KernelMode, FALSE, &interval );
            }

            KeRundownQueue( &queue->Queue );
        }

        //
        // Kill the threads on the blocking work queues
        //
        WorkItem.CurrentWorkQueue = &SrvBlockingWorkQueue;

        SrvInsertWorkQueueTail(
            &SrvBlockingWorkQueue,
            (PQUEUEABLE_BLOCK_HEADER)&WorkItem
            );

        //
        // Wait for the threads to all die
        //
        while( SrvBlockingWorkQueue.Threads != 0 ) {

            LARGE_INTEGER interval;

            interval.QuadPart = -1*10*1000*10; // .01 second

            KeDelayExecutionThread( KernelMode, FALSE, &interval );
        }

        KeRundownQueue( &SrvBlockingWorkQueue.Queue );
    }

    //
    // Free any space allocated for the Null Session pipe and share lists
    //
    SrvFreeRegTables();

    //
    // If we allocated memory for the os version strings, free it now.
    //

    if ( SrvNativeOS.Buffer != NULL &&
         SrvNativeOS.Buffer != StrDefaultNativeOs ) {

        FREE_HEAP( SrvNativeOS.Buffer );
        SrvNativeOS.Buffer = NULL;

        RtlFreeOemString( &SrvOemNativeOS );
        SrvOemNativeOS.Buffer = NULL;
    }

    //
    // If allocated memory for the display name, free it now.
    //

    if ( SrvAlertServiceName != NULL &&
         SrvAlertServiceName != StrDefaultSrvDisplayName ) {

        FREE_HEAP( SrvAlertServiceName );
        SrvAlertServiceName = NULL;
    }

    //
    // Make sure the scavenger is not running.
    //

    SrvTerminateScavenger( );

#if MULTIPROCESSOR
    if( SrvWorkQueues ) {
        for( queue = SrvWorkQueues; queue < eSrvWorkQueues; queue++ ) {
            StopQueueDepthComputations( queue );
        }
    }
#endif


    //
    // Free the work items in the work queues and the receive work item
    // list.  This also deallocates the SMB buffers.  Note that work
    // items allocated dynamically may be deallocated singly, while work
    // items allocated at server startup are part of one large block,
    // and may not be deallocated singly.
    //
    // !!! Does this properly clean up buffers allocated during SMB
    //     processing?  Probably not.  Should probably allow the worker
    //     threads to run the work queue normally before they stop.
    //

    if( SrvWorkQueues ) {

        for( queue = SrvWorkQueues; queue < eSrvWorkQueues; queue++ ) {

            //
            // Clean out the single FreeContext spot
            //
            workContext = NULL;
            workContext = (PWORK_CONTEXT)InterlockedExchangePointer(
                                            &queue->FreeContext, workContext );

            if( workContext != NULL && workContext->PartOfInitialAllocation == FALSE ) {
                SrvFreeNormalWorkItem( workContext );
            }

            //
            // Clean out the normal work item list
            //
            while( 1 ) {
                singleListEntry = ExInterlockedPopEntrySList(
                                            &queue->NormalWorkItemList, &queue->SpinLock );
                if( singleListEntry == NULL ) {
                    break;
                }
                workContext =
                    CONTAINING_RECORD( singleListEntry, WORK_CONTEXT, SingleListEntry );

                SrvFreeNormalWorkItem( workContext );
                queue->FreeWorkItems--;
            }

            //
            // Clean out the raw mode work item list
            //
            while( 1 ) {
                singleListEntry = ExInterlockedPopEntrySList(
                                            &queue->RawModeWorkItemList, &queue->SpinLock );
                if( singleListEntry == NULL ) {
                    break;
                }

                workContext =
                    CONTAINING_RECORD( singleListEntry, WORK_CONTEXT, SingleListEntry );

                SrvFreeRawModeWorkItem( workContext );
            }

            //
            // Free up any saved rfcbs
            //
            if( queue->CachedFreeRfcb != NULL ) {
                FREE_HEAP( queue->CachedFreeRfcb->PagedRfcb );
                DEALLOCATE_NONPAGED_POOL( queue->CachedFreeRfcb );
                queue->CachedFreeRfcb = NULL;
            }

            while( 1 ) {
                PRFCB Rfcb;

                singleListEntry = ExInterlockedPopEntrySList( &queue->RfcbFreeList, &queue->SpinLock );
                if( singleListEntry == NULL ) {
                    break;
                }

                Rfcb =
                    CONTAINING_RECORD( singleListEntry, RFCB, SingleListEntry );
                FREE_HEAP( Rfcb->PagedRfcb );
                DEALLOCATE_NONPAGED_POOL( Rfcb );
            }

            //
            // Free up any saved mfcbs
            //
            if( queue->CachedFreeMfcb != NULL ) {
                DEALLOCATE_NONPAGED_POOL( queue->CachedFreeMfcb );
                queue->CachedFreeMfcb = NULL;
            }

            while( 1 ) {
                PNONPAGED_MFCB nonpagedMfcb;

                singleListEntry = ExInterlockedPopEntrySList( &queue->MfcbFreeList, &queue->SpinLock );
                if( singleListEntry == NULL ) {
                    break;
                }

                nonpagedMfcb =
                    CONTAINING_RECORD( singleListEntry, NONPAGED_MFCB, SingleListEntry );

                DEALLOCATE_NONPAGED_POOL( nonpagedMfcb );
            }
        }

    } // SrvWorkQueues

    //
    // All dynamic work items have been freed, and the work item queues
    // have been emptied.  Release the initial work item allocation.
    //
    SrvFreeInitialWorkItems( );

    //
    // Walk through the global share list, closing them all.
    //

    for( listEntryRoot = SrvShareHashTable;
         listEntryRoot < &SrvShareHashTable[ NSHARE_HASH_TABLE ];
         listEntryRoot++ ) {

        while( listEntryRoot->Flink != listEntryRoot ) {

            share = CONTAINING_RECORD( listEntryRoot->Flink, SHARE, GlobalShareList );

            SrvCloseShare( share );
        }
    }

    //
    // If we opened the NPFS during initialization, close the handle now
    // and dereference the NPFS file object.
    //

    if ( SrvNamedPipeHandle != NULL) {

        SrvNtClose( SrvNamedPipeHandle, FALSE );
        ObDereferenceObject( SrvNamedPipeFileObject );

        SrvNamedPipeHandle = NULL;

    }

    //
    // Disconnect from the Dfs driver
    //
    SrvTerminateDfs();

    //
    // Clean up the Dns Domain Name if necessary
    //
    if( SrvDnsDomainName )
    {
        DEALLOCATE_NONPAGED_POOL( SrvDnsDomainName );
        SrvDnsDomainName = NULL;
    }

    //
    // Clean up the admin security descriptor
    //


    status = RtlGetDaclSecurityDescriptor( &SrvAdminSecurityDescriptor,
                                           &daclpresent,
                                           &acl,
                                           &defaulted );
    if( !NT_SUCCESS( status ) || !daclpresent ) {
        acl = NULL;
    }

    status = RtlGetOwnerSecurityDescriptor( &SrvAdminSecurityDescriptor,
                                            &adminsid,
                                            &defaulted );

    if( NT_SUCCESS( status ) && adminsid != NULL ) {
        FREE_HEAP( adminsid );
    }

    if( acl != NULL ) {
        FREE_HEAP( acl );
    }

    //
    // Clean up the null session security descriptor
    //

    status = RtlGetDaclSecurityDescriptor( &SrvNullSessionSecurityDescriptor,
                                           &daclpresent,
                                           &acl,
                                           &defaulted );
    if( !NT_SUCCESS( status ) || !daclpresent ) {
        acl = NULL;
    }

    status = RtlGetOwnerSecurityDescriptor( &SrvNullSessionSecurityDescriptor,
                                            &anonymoussid,
                                            &defaulted );

    if( NT_SUCCESS( status ) && anonymoussid != NULL ) {
        FREE_HEAP( anonymoussid );
    }

    if( acl != NULL ) {
        FREE_HEAP( acl );
    }


    if (!CONTEXT_NULL(SrvNullSessionToken)) {
        DeleteSecurityContext(&SrvNullSessionToken);
        INVALIDATE_SECURITY_HANDLE( SrvNullSessionToken );
    }

    //
    // Delete the global ordered lists.
    //

    SrvDeleteOrderedList( &SrvEndpointList );
    SrvDeleteOrderedList( &SrvRfcbList );
    SrvDeleteOrderedList( &SrvSessionList );
    SrvDeleteOrderedList( &SrvTreeConnectList );

    //
    // Clear out the timer pool.
    //

    while ( (singleListEntry = ExInterlockedPopEntrySList(
                                    &SrvTimerList,
                                    &GLOBAL_SPIN_LOCK(Timer) )) != NULL ) {
        timer = CONTAINING_RECORD( singleListEntry, SRV_TIMER, Next );
        DEALLOCATE_NONPAGED_POOL( timer );
    }

    if( SrvWorkQueues ) {

        //
        // Clear out the saved pool chunks
        //
        for( queue = SrvWorkQueues; queue < eSrvWorkQueues; queue++ ) {
            //
            // Free up any paged pool that we've saved.
            //
            SrvClearLookAsideList( &queue->PagedPoolLookAsideList, SrvFreePagedPool );

            //
            // Free up any nonpaged pool that we've saved.
            //
            SrvClearLookAsideList( &queue->NonPagedPoolLookAsideList, SrvFreeNonPagedPool );
        }

#if MULTIPROCESSOR
        DEALLOCATE_NONPAGED_POOL( SrvWorkQueuesBase );
        SrvWorkQueuesBase = NULL;
        SrvWorkQueues = NULL;
#endif
    }

    //
    // Unlock pageable sections.
    //

    for ( i = 0; i < SRV_CODE_SECTION_MAX; i++ ) {
        if ( SrvSectionInfo[i].Handle != NULL ) {
            ASSERT( SrvSectionInfo[i].ReferenceCount != 0 );
            MmUnlockPagableImageSection( SrvSectionInfo[i].Handle );
            SrvSectionInfo[i].Handle = 0;
            SrvSectionInfo[i].ReferenceCount = 0;
        }
    }

    //
    // Zero out the statistics database.
    //

    RtlZeroMemory( &SrvStatistics, sizeof(SrvStatistics) );
#if SRVDBG_STATS || SRVDBG_STATS2
    RtlZeroMemory( &SrvDbgStatistics, sizeof(SrvDbgStatistics) );
#endif

    //
    // Free the handle used in PoRegisterSystemState
    //
    if( SrvPoRegistrationState != NULL ) {
        PoUnregisterSystemState( SrvPoRegistrationState );
        SrvPoRegistrationState = NULL;
    }

    //
    // Indicate that the server is no longer active.
    //

    ACQUIRE_LOCK( &SrvConfigurationLock );

    SrvFspTransitioning = FALSE;
    SrvFspActive = FALSE;
    SrvSvcProcess = NULL;

    RELEASE_LOCK( &SrvConfigurationLock );

    IF_DEBUG(FSP1) KdPrint(( "LAN Manager server FSP termination complete.\n" ));

    return STATUS_SUCCESS;

} // TerminateServer

VOID
SrvFreeRegTables (
    VOID
    )
/*++

Routine Description:

    This routine frees space allocated for the list of legal Null session shares
     and pipes.  The SrvConfigurationLock must be held when this routine is called.

Arguments:

    None.

Return Value:

    None.

--*/
{
    PAGED_CODE( );

    //
    // If we allocated a buffer for the list of null session pipes,
    // free it now.
    //

    if ( SrvNullSessionPipes != NULL &&
         SrvNullSessionPipes != StrDefaultNullSessionPipes ) {

        FREE_HEAP( SrvNullSessionPipes );
    }
    SrvNullSessionPipes = NULL;

    if( SrvNoRemapPipeNames != NULL &&
        SrvNoRemapPipeNames != StrDefaultNoRemapPipeNames ) {

        FREE_HEAP( SrvNoRemapPipeNames );
    }
    SrvNoRemapPipeNames = NULL;


    if ( SrvPipesNeedLicense != NULL &&
         SrvPipesNeedLicense != StrDefaultPipesNeedLicense ) {

        FREE_HEAP( SrvPipesNeedLicense );
    }
    SrvPipesNeedLicense = NULL;

    if ( SrvNullSessionShares != NULL &&
         SrvNullSessionShares != StrDefaultNullSessionShares ) {

        FREE_HEAP( SrvNullSessionShares );
    }
    SrvNullSessionShares = NULL;

#if SRVNTVERCHK
    if( SrvInvalidDomainNames != NULL ) {
        FREE_HEAP( SrvInvalidDomainNames );
    }
    SrvInvalidDomainNames = NULL;
#endif

#if SRVCATCH
    if( SrvCatchBuf != NULL ) {
        FREE_HEAP( SrvCatchBuf );
        SrvCatchBuf = NULL;
    }
    if( SrvCatchExtBuf != NULL ) {
        FREE_HEAP( SrvCatchExtBuf );
        SrvCatchExtBuf = NULL;
    }
    if( SrvCatchShareNames != NULL ) {
        FREE_HEAP( SrvCatchShareNames );
        SrvCatchShareNames = NULL;
        SrvCatchShares = 0;
        CleanupCrcTable();
    }
#endif
}

VOID
SrvGetRegTables (
    VOID
    )
/*++

Routine Description:

    This routine loads the lists of valid shares and pipes for null sessions.
      The SrvConfigurationLock must be held when this routine is called.

Arguments:

    None.

Return Value:

    None.

--*/
{
    PWSTR *strErrorLogIgnore;

    PAGED_CODE( );

    //
    // Get the list of null session pipes.
    //
    ASSERT( SrvNullSessionPipes == NULL );
    SrvGetMultiSZList(
            &SrvNullSessionPipes,
            StrRegSrvParameterPath,
            StrRegNullSessionPipes,
            StrDefaultNullSessionPipes
            );

    //
    // Get the list of non-remappable pipe names
    //
    ASSERT( SrvNoRemapPipeNames == NULL );
    SrvGetMultiSZList(
            &SrvNoRemapPipeNames,
            StrRegSrvParameterPath,
            StrRegNoRemapPipes,
            StrDefaultNoRemapPipeNames
            );

    //
    // Get the list of pipes requiring licenses
    //
    ASSERT( SrvPipesNeedLicense == NULL );
    SrvGetMultiSZList(
            &SrvPipesNeedLicense,
            StrRegSrvParameterPath,
            StrRegPipesNeedLicense,
            StrDefaultPipesNeedLicense
            );

    //
    // Get the list of null session pipes.
    //
    ASSERT( SrvNullSessionShares == NULL );
    SrvGetMultiSZList(
            &SrvNullSessionShares,
            StrRegSrvParameterPath,
            StrRegNullSessionShares,
            StrDefaultNullSessionShares
            );

#if SRVCATCH
    {
    USHORT i;

    SrvCatch.Length = 0;
    SrvCatch.Buffer = 0;
    if( SrvCatchBuf != NULL ) {
        FREE_HEAP( SrvCatchBuf );
        SrvCatchBuf = NULL;
    }

    SrvGetMultiSZList(
                &SrvCatchBuf,
                StrRegSrvParameterPath,
                L"CheckFile",
                0
                );

    if( SrvCatchBuf != NULL ) {
        SrvCatch.Buffer = SrvCatchBuf[0];
        for( i = 0; SrvCatch.Buffer[i]; i++ )
            ;
        SrvCatch.Length = i * sizeof( SrvCatch.Buffer[0] );
    }

    SrvCatchExt.Length = 0;
    SrvCatchExt.Buffer = 0;
    if( SrvCatchExtBuf != NULL )
    {
        FREE_HEAP( SrvCatchExtBuf );
        SrvCatchExtBuf = NULL;
    }
    SrvGetMultiSZList(
                &SrvCatchExtBuf,
                StrRegSrvParameterPath,
                L"CheckExtension",
                0
                );

    if( SrvCatchExtBuf != NULL ) {
        SrvCatchExt.Buffer = SrvCatchExtBuf[0];
        for( i = 0; SrvCatchExt.Buffer[i]; i++ )
            ;
        SrvCatchExt.Length = i * sizeof( SrvCatchExt.Buffer[0] );
    }
    if( SrvCatchShareNames != NULL )
    {
        FREE_HEAP( SrvCatchShareNames );
        SrvCatchShareNames = NULL;
    }
    SrvGetMultiSZList(
        &SrvCatchShareNames,
        StrRegSrvParameterPath,
        L"CheckShares",
        0
        );
    if( SrvCatchShareNames != NULL )
    {
        for( i=0; SrvCatchShareNames[i]; i++ ) ;
        SrvCatchShares = i;
    }

    if( SrvCatchShares > 0 )
    {
        if( !GenerateCrcTable() )
        {
            FREE_HEAP( SrvCatchShareNames );
            SrvCatchShareNames = NULL;
            SrvCatchShares = 0;
        }
    }
    }
#endif

    //
    // Get the list of error codes that we don't log
    //

    SrvGetMultiSZList(
            &strErrorLogIgnore,
            StrRegSrvParameterPath,
            StrRegErrorLogIgnore,
            StrDefaultErrorLogIgnore
            );

    if( strErrorLogIgnore != NULL ) {
        DWORD i;

        //
        // They came in as strings, convert to NTSTATUS codes
        //
        for( i=0; i < SRVMAXERRLOGIGNORE; i++ ) {
            NTSTATUS Status;
            PWSTR p;

            if( (p = strErrorLogIgnore[i]) == NULL )
                break;

            for( Status = 0; *p; p++ ) {
                if( *p >= L'A' && *p <= L'F' ) {
                    Status <<= 4;
                    Status += 10 + (*p - L'A');
                } else if( *p >= '0' && *p <= '9' ) {
                    Status <<= 4;
                    Status += *p - L'0';
                }
            }

            SrvErrorLogIgnore[i] = Status;

            IF_DEBUG(FSP1) KdPrint(( "LAN Manager server:  %X errs not logged\n", Status ));
        }
        SrvErrorLogIgnore[i] = 0;

        if( strErrorLogIgnore != StrDefaultErrorLogIgnore ) {
            FREE_HEAP( strErrorLogIgnore );
        }
    }

#if SRVNTVERCHK
    //
    // Get the list of Domains that we disallow if the client
    //  is running NT5
    //
    ASSERT( SrvInvalidDomainNames == NULL );
    SrvGetMultiSZList(
            &SrvInvalidDomainNames,
            StrRegSrvParameterPath,
            StrRegInvalidDomainNames,
            NULL
            );

    if( SrvInvalidDomainNames != NULL ) {

        int i;

        KdPrint(( "SRV disallows NT5 clients from the following domains:\n" ));
        for( i = 0; SrvInvalidDomainNames[i]; i++ ) {
            KdPrint(( " %ws\n", SrvInvalidDomainNames[i] ));
        }
    }

    //
    // Get the list of IP addresses of clients that we will allow to connect
    //  regardless of build number
    //
    {
    PWSTR *strAllowedIPAddresses;
    int i;

    //
    // Wipe out the current list
    //
    RtlZeroMemory( SrvAllowIPAddress, sizeof( SrvAllowIPAddress ) );

    SrvGetMultiSZList(
        &strAllowedIPAddresses,
        StrRegSrvParameterPath,
        StrRegAllowedIPAddresses,
        NULL
        );

    if( strAllowedIPAddresses != NULL ) {

        KdPrint(( "SRV ignores NT build version of clients at following IP addrs:\n" ));
        //
        // Fill it with the new ones
        //
        for(i = 0;
            strAllowedIPAddresses[i] &&
             i < (sizeof(SrvAllowIPAddress)/sizeof(SrvAllowIPAddress[0]))-1;
            i++ ) {

            LPWSTR p;
            DWORD addr = 0;
            char *s = (char *)&addr;

            //
            // Convert the IP address to a DWORD and store it
            //
            for( p = strAllowedIPAddresses[i]; *p && s < ((char *)&addr)+sizeof(addr); p++ ) {
                if( *p == L'.' ) {
                    s++;
                } else if( *p >= '0' && *p <= '9' ) {
                    *s = (*s * 10) + (*p - L'0');
                }
            }

            SrvAllowIPAddress[i] = addr;

            KdPrint(( "    %ws\n", strAllowedIPAddresses[i] ));

        }
        FREE_HEAP( strAllowedIPAddresses );
    }

    }
#endif
}

#if SRVNTVERCHK
VOID
SrvGetRegClientNumber (
    VOID
    )
/*++

Routine Description:

    This routine reads MinNt5Client REG_DWORD from the registry and sets
    the global SrvMinNT5Client to the retrieved value.  Later, if a client
    running >= NT5 with a build number less than SrvMinNT5Client tries to
    connect to a disk share, we reject the connection.  This mechanism
    is used on our SLM servers to ensure that people are upgrading to
    current builds.

--*/
{
    UNICODE_STRING unicodeKeyName;
    UNICODE_STRING unicodeParamPath;
    OBJECT_ATTRIBUTES objAttributes;
    HANDLE keyHandle;
    PKEY_VALUE_PARTIAL_INFORMATION infoBuffer;
    ULONG lengthNeeded;
    NTSTATUS status;

    PAGED_CODE( );

    SrvMinNT5Client = 0;
    SrvMinNT5ClientIPCToo = FALSE;

    RtlInitUnicodeString( &unicodeParamPath, StrRegSrvParameterPath );
    RtlInitUnicodeString( &unicodeKeyName, L"MinNT5Client" );

    InitializeObjectAttributes(
                        &objAttributes,
                        &unicodeParamPath,
                        OBJ_CASE_INSENSITIVE,
                        NULL,
                        NULL
                        );

    status = ZwOpenKey(
                    &keyHandle,
                    KEY_QUERY_VALUE,
                    &objAttributes
                    );


    if ( NT_SUCCESS(status) ) {

        status = ZwQueryValueKey(
                        keyHandle,
                        &unicodeKeyName,
                        KeyValuePartialInformation,
                        NULL,
                        0,
                        &lengthNeeded
                        );

        if( status != STATUS_BUFFER_TOO_SMALL ) {

            RtlInitUnicodeString( &unicodeKeyName, L"MinNT5ClientIPC" );

            status = ZwQueryValueKey(
                            keyHandle,
                            &unicodeKeyName,
                            KeyValuePartialInformation,
                            NULL,
                            0,
                            &lengthNeeded
                            );

            SrvMinNT5ClientIPCToo = TRUE;
        }

        if( status == STATUS_BUFFER_TOO_SMALL ) {

            infoBuffer = ALLOCATE_HEAP_COLD( lengthNeeded, BlockTypeDataBuffer );

            if( infoBuffer ) {

                status = ZwQueryValueKey(
                            keyHandle,
                            &unicodeKeyName,
                            KeyValuePartialInformation,
                            infoBuffer,
                            lengthNeeded,
                            &lengthNeeded
                            );

                if( NT_SUCCESS( status ) &&
                    infoBuffer->Type == REG_DWORD &&
                    infoBuffer->DataLength == sizeof( DWORD )  ) {

                    SrvMinNT5Client = *(DWORD *)(&infoBuffer->Data[0]);

                    KdPrint(( "SRV: Restrict NT5 clients to builds >= %u\n",
                        SrvMinNT5Client ));

                    if( SrvMinNT5ClientIPCToo ) {
                        KdPrint(( "    Restrict IPC clients\n" ));
                    }
                }

                FREE_HEAP( infoBuffer );
            }
        }

        NtClose( keyHandle );
    }
}
#endif

#if MULTIPROCESSOR
VOID
StartQueueDepthComputations(
    PWORK_QUEUE queue
    )
{
    LARGE_INTEGER currentTime;

    PAGED_CODE();

    if( SrvNumberOfProcessors == 1 )
        return;

    //
    // We're going to schedule a dpc to call the 'ComputeAvgQueueDepth' routine
    //   Initialize the dpc
    //
    KeInitializeDpc( &queue->QueueAvgDpc, ComputeAvgQueueDepth, queue );

    //
    // We want to make sure the dpc runs on the same processor handling the
    //   queue -- to avoid thrashing the cache
    //
    KeSetTargetProcessorDpc( &queue->QueueAvgDpc, (CCHAR)(queue - SrvWorkQueues));

    //
    // Initialize a timer object to schedule our dpc later
    //
    KeInitializeTimer( &queue->QueueAvgTimer );
    KeQuerySystemTime( &currentTime );
    queue->NextAvgUpdateTime.QuadPart = currentTime.QuadPart + SrvQueueCalc.QuadPart;

    //
    // Initialize the sample vector
    //
    queue->NextSample = queue->DepthSamples;
    RtlZeroMemory( queue->DepthSamples, sizeof( queue->DepthSamples ) );

    //
    // And start it going!
    //
    KeSetTimer( &queue->QueueAvgTimer, queue->NextAvgUpdateTime, &queue->QueueAvgDpc );
}

VOID
StopQueueDepthComputations(
    PWORK_QUEUE queue
    )
{
    KIRQL oldIrql;

    if( SrvNumberOfProcessors == 1 )
        return;

    KeInitializeEvent( &queue->AvgQueueDepthTerminationEvent,
                       NotificationEvent,
                       FALSE
                     );


    ACQUIRE_SPIN_LOCK( &queue->SpinLock, &oldIrql );

    queue->NextSample = NULL;

    RELEASE_SPIN_LOCK( &queue->SpinLock, oldIrql );

    //
    // Cancel the computation timer.  If this works, then we know that
    //  the DPC code is not running.  Otherwise, it is running or queued
    //  to run and we need to wait until it completes.
    //
    if( !KeCancelTimer( &queue->QueueAvgTimer ) ) {
        KeWaitForSingleObject(
            &queue->AvgQueueDepthTerminationEvent,
            Executive,
            KernelMode,
            FALSE,
            NULL
            );
    }
}

VOID
ComputeAvgQueueDepth (
    IN PKDPC Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemArgument1,
    IN PVOID SystemArgument2
    )
{
    LARGE_INTEGER currentTime;
    PWORK_QUEUE queue = (PWORK_QUEUE)DeferredContext;

    ACQUIRE_DPC_SPIN_LOCK( &queue->SpinLock );

    if( queue->NextSample == NULL ) {

        KeSetEvent( &queue->AvgQueueDepthTerminationEvent, 0, FALSE );

    } else {

        //
        // Compute the sliding window average by taking a queue depth
        // sample, removing the old sample value from the running sum
        // and adding in the new value
        //

        currentTime.LowPart= PtrToUlong(SystemArgument1);
        currentTime.HighPart = PtrToUlong(SystemArgument2);

        queue->AvgQueueDepthSum -= *queue->NextSample;
        *(queue->NextSample) = KeReadStateQueue( &queue->Queue );
        queue->AvgQueueDepthSum += *queue->NextSample;

        if( ++(queue->NextSample) == &queue->DepthSamples[ QUEUE_SAMPLES ] )
            queue->NextSample = queue->DepthSamples;

        queue->NextAvgUpdateTime.QuadPart =
               currentTime.QuadPart + SrvQueueCalc.QuadPart;

        KeSetTimer( &queue->QueueAvgTimer,
                    queue->NextAvgUpdateTime,
                    &queue->QueueAvgDpc );
    }

    RELEASE_DPC_SPIN_LOCK( &queue->SpinLock );
}
#endif  // MULTIPROCESSOR
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\srv\heapmgr.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    heapmgr.c

Abstract:

    This module contains initialization and termination routines for
    server FSP heap, as well as debug routines for memory tracking.

--*/

#include "precomp.h"
#include "heapmgr.tmh"
#pragma hdrstop

// Make the retry time 15 milli-seconds
#define SRV_LOW_PRIORITY_RETRY_TIME -1*1000*10*15

#ifdef POOL_TAGGING
//
// Array correlating BlockType numbers to pool tags.
//
// *** This array must be maintained in concert with the BlockType
//     definitions in srvblock.h!
//

ULONG SrvPoolTags[BlockTypeMax-1] = {
        'fbSL',     // BlockTypeBuffer
        'ncSL',     // BlockTypeConnection
        'peSL',     // BlockTypeEndpoint
        'flSL',     // BlockTypeLfcb
        'fmSL',     // BlockTypeMfcb
        'frSL',     // BlockTypeRfcb
        'rsSL',     // BlockTypeSearch
        'csSL',     // BlockTypeSearchCore
        'lbSL',     // BlockTypeByteRangeLock       for persistent handles
        'ssSL',     // BlockTypeSession
        'hsSL',     // BlockTypeShare
        'rtSL',     // BlockTypeTransaction
        'ctSL',     // BlockTypeTreeConnect
        'poSL',     // BlockTypeOplockBreak
        'dcSL',     // BlockTypeCommDevice
        'iwSL',     // BlockTypeWorkContextInitial
        'nwSL',     // BlockTypeWorkContextNormal
        'rwSL',     // BlockTypeWorkContextRaw
        'swSL',     // BlockTypeWorkContextSpecial
        'dcSL',     // BlockTypeCachedDirectory
        'bdSL',     // BlockTypeDataBuffer
        'btSL',     // BlockTypeTable
        'hnSL',     // BlockTypeNonpagedHeader
        'cpSL',     // BlockTypePagedConnection
        'rpSL',     // BlockTypePagedRfcb
        'mpSL',     // BlockTypePagedMfcb
        'itSL',     // BlockTypeTimer
        'caSL',     // BlockTypeAdminCheck
        'qwSL',     // BlockTypeWorkQueue
        'fsSL',     // BlockTypeDfs
        'rlSL',     // BlockTypeLargeReadX
        'saSL',     // BlockTypeAdapterStatus
        'rsSL',     // BlockTypeShareRemark
        'dsSL',     // BlockTypeShareSecurityDescriptor
        'ivSL',     // BlockTypeVolumeInformation
        'nfSL',     // BlockTypeFSName
        'inSL',     // BlockTypeNameInfo
        'idSL',     // BlockTypeDirectoryInfo
        'cdSL',     // BlockTypeDirCache
        'imSL',     // BlockTypeMisc
        'nsSL',     // BlockTypeSnapShot
#ifdef INCLUDE_SMB_PERSISTENT
        'spSL',     // BlockTypePersistentState
        'bpSL',     // BlockTypePersistentBitMap
        'hpSL',     // BlockTypePersistShareState
#endif
        };

//
// Macro to map from block type to pool tag.
//

#define TAG_FROM_TYPE(_type) SrvPoolTags[(_type)-1]

#else

#define TAG_FROM_TYPE(_type) ignoreme

#endif // def POOL_TAGGING

#ifdef ALLOC_PRAGMA
#pragma alloc_text( PAGE, SrvAllocatePagedPool )
#pragma alloc_text( PAGE, SrvFreePagedPool )
#pragma alloc_text( PAGE, SrvClearLookAsideList )
#endif
#if 0
NOT PAGEABLE -- SrvAllocateNonPagedPool
NOT PAGEABLE -- SrvFreeNonPagedPool
#endif

extern LONG SrvMemoryAllocationRetries;
extern LONG SrvMemoryAllocationRetriesSuccessful;


PVOID SRVFASTCALL
SrvInterlockedAllocate( PLOOK_ASIDE_LIST l, ULONG NumberOfBytes, PLONG statistics )
{
    PPOOL_HEADER newPool;
    PPOOL_HEADER *pentry = NumberOfBytes > LOOK_ASIDE_SWITCHOVER ?
                                            l->LargeFreeList : l->SmallFreeList;

    PPOOL_HEADER *pend   = pentry + LOOK_ASIDE_MAX_ELEMENTS;

    do {
        //
        // Exchange with the lookaside spot and see if we get anything
        //

        newPool = NULL;
        newPool = (PPOOL_HEADER)InterlockedExchangePointer( pentry, newPool );

        if( newPool == NULL ) {
            continue;
        }

        if( newPool->RequestedSize >= NumberOfBytes ) {
            //
            // The one we got is big enough!  Return it.
            //
            ++(l->AllocHit);
            return newPool + 1;
        }

        //
        // It wasn't big enough, so put it back.
        //
        newPool = (PPOOL_HEADER)InterlockedExchangePointer( pentry, newPool );
        if( newPool == NULL ) {
            continue;
        }

        //
        // Oops, somebody else freed some memory to this spot.  Can we use it?
        //
        if( newPool->RequestedSize >= NumberOfBytes ) {
            //
            // We can use it!
            //
            ++(l->AllocHit);
            return newPool + 1;
        }

        //
        // Can't use the memory -- so really free it and keep looking
        //
        if( statistics ) {
            InterlockedExchangeAdd(
                statistics,
                -(LONG)newPool->RequestedSize
                );
        }

        ExFreePool( newPool );

    } while( ++pentry < pend );

    ++(l->AllocMiss);
    return NULL;
}

PPOOL_HEADER SRVFASTCALL
SrvInterlockedFree( PPOOL_HEADER block )
{
    PPOOL_HEADER *pentry = block->FreeList;
    PPOOL_HEADER *pend   = pentry + LOOK_ASIDE_MAX_ELEMENTS;

    do {

        block = (PPOOL_HEADER)InterlockedExchangePointer( pentry, block );

    } while( block != NULL && ++pentry < pend );

    return block;
}

VOID SRVFASTCALL
SrvClearLookAsideList( PLOOK_ASIDE_LIST l, VOID (SRVFASTCALL *FreeRoutine )( PVOID ) )
{
    PPOOL_HEADER *pentry, *pend, block;

    PAGED_CODE();

    //
    // Clear out the list of large chunks
    //
    pentry = l->LargeFreeList;
    pend   = pentry + LOOK_ASIDE_MAX_ELEMENTS;

    do {
        block = NULL;
        block = (PPOOL_HEADER)InterlockedExchangePointer( pentry, block );

        if( block != NULL ) {
            block->FreeList = NULL;
            FreeRoutine( block + 1 );
        }

    } while( ++pentry < pend );

    //
    // Clear out the list of small chunks
    //
    pentry = l->SmallFreeList;
    pend   = pentry + LOOK_ASIDE_MAX_ELEMENTS;

    do {
        block = NULL;
        block = (PPOOL_HEADER)InterlockedExchangePointer( pentry, block );

        if( block != NULL ) {
            block->FreeList = NULL;
            FreeRoutine( block + 1 );
        }

    } while( ++pentry < pend );
}


PVOID SRVFASTCALL
SrvAllocateNonPagedPool (
    IN CLONG NumberOfBytes
#ifdef POOL_TAGGING
    , IN CLONG BlockType
#endif
    )

/*++

Routine Description:

    This routine allocates nonpaged pool in the server.  A check is
    made to ensure that the server's total nonpaged pool usage is below
    the configurable limit.

Arguments:

    NumberOfBytes - the number of bytes to allocate.

    BlockType - the type of block (used to pass pool tag to allocator)

Return Value:

    PVOID - a pointer to the allocated memory or NULL if the memory could
       not be allocated.

--*/

{
    PPOOL_HEADER newPool;
    PPOOL_HEADER *FreeList = NULL;
    ULONG newUsage;
    BOOLEAN IsLowPriority = FALSE;
    LARGE_INTEGER interval;

#ifdef POOL_TAGGING
    ASSERT( BlockType > 0 && BlockType < BlockTypeMax );
#endif

    //
    // Pull this allocation off the per-processor free list if we can
    //
    if( SrvWorkQueues ) {

        PWORK_QUEUE queue = PROCESSOR_TO_QUEUE();

        if( NumberOfBytes <= queue->NonPagedPoolLookAsideList.MaxSize ) {

            newPool = SrvInterlockedAllocate(
                                &queue->NonPagedPoolLookAsideList,
                                NumberOfBytes,
                                (PLONG)&SrvStatistics.CurrentNonPagedPoolUsage
                                );

            if( newPool != NULL ) {
                return newPool;
            }

            FreeList = NumberOfBytes > LOOK_ASIDE_SWITCHOVER ?
                                    queue->NonPagedPoolLookAsideList.LargeFreeList :
                                    queue->NonPagedPoolLookAsideList.SmallFreeList ;
        }
    }

    //
    // Account for this allocation in the statistics database and make
    // sure that this allocation will not put us over the limit of
    // nonpaged pool that we can allocate.
    //

    newUsage = InterlockedExchangeAdd( (PLONG)&SrvStatistics.CurrentNonPagedPoolUsage,
                                       (LONG)NumberOfBytes );
    newUsage += NumberOfBytes;

    if ( newUsage > SrvMaxNonPagedPoolUsage ) {

        //
        // Count the failure, but do NOT log an event.  The scavenger
        // will log an event when it next wakes up.  This keeps us from
        // flooding the event log.
        //

        SrvNonPagedPoolLimitHitCount++;
        SrvStatistics.NonPagedPoolFailures++;

        InterlockedExchangeAdd( (PLONG)&SrvStatistics.CurrentNonPagedPoolUsage,
                                -(LONG)NumberOfBytes );

        return NULL;

    }

    if (SrvStatistics.CurrentNonPagedPoolUsage > SrvStatistics.PeakNonPagedPoolUsage) {
        SrvStatistics.PeakNonPagedPoolUsage = SrvStatistics.CurrentNonPagedPoolUsage;
    }

    //
    // Do the actual memory allocation.  Allocate extra space so that we
    // can store the size of the allocation for the free routine.
    //
    if( NumberOfBytes > 2*4096 )
    {
        IsLowPriority = TRUE;
    }

    newPool = ExAllocatePoolWithTagPriority(
                NonPagedPool,
                NumberOfBytes + sizeof(POOL_HEADER),
                TAG_FROM_TYPE(BlockType),
                IsLowPriority ? LowPoolPriority : NormalPoolPriority
                );

    if( (newPool == NULL) && IsLowPriority && (KeGetCurrentIrql() <= APC_LEVEL) )
    {
        interval.QuadPart = SRV_LOW_PRIORITY_RETRY_TIME;
        InterlockedIncrement( &SrvMemoryAllocationRetries );

        // Wait and try again
        KeDelayExecutionThread( KernelMode, FALSE, &interval );

        newPool = ExAllocatePoolWithTagPriority(
                NonPagedPool,
                NumberOfBytes + sizeof(POOL_HEADER),
                TAG_FROM_TYPE(BlockType),
                LowPoolPriority
                );

        if( newPool )
        {
            InterlockedIncrement( &SrvMemoryAllocationRetriesSuccessful );
        }
    }


    //
    // If the system couldn't satisfy the request, return NULL.
    //

    if ( newPool != NULL ) {
        //
        // Save the size of this block in the extra space we allocated.
        //

        newPool->RequestedSize = NumberOfBytes;
        newPool->FreeList = FreeList;

        //
        // Return a pointer to the memory after the size longword.
        //

        return (PVOID)( newPool + 1 );
    }

    //
    // Count the failure, but do NOT log an event.  The scavenger
    // will log an event when it next wakes up.  This keeps us from
    // flooding the event log.
    //

    SrvStatistics.NonPagedPoolFailures++;


    InterlockedExchangeAdd( (PLONG)&SrvStatistics.CurrentNonPagedPoolUsage,
                                -(LONG)NumberOfBytes );

    return NULL;

} // SrvAllocateNonPagedPool

VOID SRVFASTCALL
SrvFreeNonPagedPool (
    IN PVOID Address
    )

/*++

Routine Description:

    Frees the memory allocated by a call to SrvAllocateNonPagedPool.
    The statistics database is updated to reflect the current nonpaged
    pool usage.

Arguments:

    Address - the address of allocated memory returned by
        SrvAllocateNonPagedPool.

Return Value:

    None.

--*/

{
    PPOOL_HEADER actualBlock = (PPOOL_HEADER)Address - 1;

    //
    // See if we can stash this bit of memory away in the NonPagedPoolFreeList
    //
    if( actualBlock->FreeList ) {

        actualBlock = SrvInterlockedFree( actualBlock );
    }

    if( actualBlock != NULL ) {

        //
        // Update the nonpaged pool usage statistic.
        //
        InterlockedExchangeAdd(
                (PLONG)&SrvStatistics.CurrentNonPagedPoolUsage,
                -(LONG)actualBlock->RequestedSize
                );

        //
        // Free the pool and return.
        //

        ExFreePool( actualBlock );
    }

} // SrvFreeNonPagedPool


PVOID SRVFASTCALL
SrvAllocatePagedPool (
    IN POOL_TYPE PoolType,
    IN CLONG NumberOfBytes
#ifdef POOL_TAGGING
    , IN CLONG BlockType
#endif
    )

/*++

Routine Description:

    This routine allocates Paged pool in the server.  A check is
    made to ensure that the server's total Paged pool usage is below
    the configurable limit.

Arguments:

    NumberOfBytes - the number of bytes to allocate.

    BlockType - the type of block (used to pass pool tag to allocator)

Return Value:

    PVOID - a pointer to the allocated memory or NULL if the memory could
       not be allocated.

--*/

{
    PPOOL_HEADER newPool;
    PPOOL_HEADER *FreeList = NULL;
    ULONG newUsage;
    BOOLEAN IsLowPriority = FALSE;
    LARGE_INTEGER interval;

    PAGED_CODE();

#ifdef POOL_TAGGING
    ASSERT( BlockType > 0 && BlockType < BlockTypeMax );
#endif

    //
    // Pull this allocation off the per-processor free list if we can
    //
    if( SrvWorkQueues ) {

        PWORK_QUEUE queue = PROCESSOR_TO_QUEUE();

        if( NumberOfBytes <= queue->PagedPoolLookAsideList.MaxSize ) {

            newPool = SrvInterlockedAllocate(
                                &queue->PagedPoolLookAsideList,
                                NumberOfBytes,
                                (PLONG)&SrvStatistics.CurrentPagedPoolUsage
                              );

            if( newPool != NULL ) {
                return newPool;
            }

            FreeList = NumberOfBytes > LOOK_ASIDE_SWITCHOVER ?
                                    queue->PagedPoolLookAsideList.LargeFreeList :
                                    queue->PagedPoolLookAsideList.SmallFreeList ;
        }
    }

    //
    // Account for this allocation in the statistics database and make
    // sure that this allocation will not put us over the limit of
    // nonpaged pool that we can allocate.
    //


    newUsage = InterlockedExchangeAdd(  (PLONG)&SrvStatistics.CurrentPagedPoolUsage,
                                        (LONG)NumberOfBytes );
    newUsage += NumberOfBytes;

    if ( newUsage > SrvMaxPagedPoolUsage ) {

        //
        // Count the failure, but do NOT log an event.  The scavenger
        // will log an event when it next wakes up.  This keeps us from
        // flooding the event log.
        //

        SrvPagedPoolLimitHitCount++;
        SrvStatistics.PagedPoolFailures++;

        InterlockedExchangeAdd( (PLONG)&SrvStatistics.CurrentPagedPoolUsage,
                                -(LONG)NumberOfBytes );

        return NULL;
    }

    if (SrvStatistics.CurrentPagedPoolUsage > SrvStatistics.PeakPagedPoolUsage ) {
        SrvStatistics.PeakPagedPoolUsage = SrvStatistics.CurrentPagedPoolUsage;
    }

    //
    // Do the actual memory allocation.  Allocate extra space so that we
    // can store the size of the allocation for the free routine.
    //
    if( NumberOfBytes > 2*4096 )
    {
        IsLowPriority = TRUE;
    }

    newPool = ExAllocatePoolWithTagPriority(
                PoolType,
                NumberOfBytes + sizeof(POOL_HEADER),
                TAG_FROM_TYPE(BlockType),
                IsLowPriority ? LowPoolPriority : NormalPoolPriority
                );

    if( (newPool == NULL) && IsLowPriority && (KeGetCurrentIrql() <= APC_LEVEL) )
    {
        interval.QuadPart = SRV_LOW_PRIORITY_RETRY_TIME;
        InterlockedIncrement( &SrvMemoryAllocationRetries );

        // Wait and try again
        KeDelayExecutionThread( KernelMode, FALSE, &interval );

        newPool = ExAllocatePoolWithTagPriority(
                PoolType,
                NumberOfBytes + sizeof(POOL_HEADER),
                TAG_FROM_TYPE(BlockType),
                LowPoolPriority
                );

        if( newPool )
        {
            InterlockedIncrement( &SrvMemoryAllocationRetriesSuccessful );
        }
    }

    if( newPool != NULL ) {

        newPool->FreeList = FreeList;
        newPool->RequestedSize = NumberOfBytes;

        //
        // Return a pointer to the memory after the POOL_HEADER
        //

        return newPool + 1;
    }

    //
    // If the system couldn't satisfy the request, return NULL.
    //
    // Count the failure, but do NOT log an event.  The scavenger
    // will log an event when it next wakes up.  This keeps us from
    // flooding the event log.
    //

    SrvStatistics.PagedPoolFailures++;

    InterlockedExchangeAdd( (PLONG)&SrvStatistics.CurrentPagedPoolUsage,
                            -(LONG)NumberOfBytes );


    return NULL;


} // SrvAllocatePagedPool

VOID SRVFASTCALL
SrvFreePagedPool (
    IN PVOID Address
    )

/*++

Routine Description:

    Frees the memory allocated by a call to SrvAllocatePagedPool.
    The statistics database is updated to reflect the current Paged
    pool usage.  If this routine is change, look at scavengr.c

Arguments:

    Address - the address of allocated memory returned by
        SrvAllocatePagedPool.

Return Value:

    None.

--*/

{
    PPOOL_HEADER actualBlock = (PPOOL_HEADER)Address - 1;

    PAGED_CODE();

    ASSERT( actualBlock != NULL );

    //
    // See if we can stash this bit of memory away in the PagedPoolFreeList
    //
    if( actualBlock->FreeList ) {

        actualBlock = SrvInterlockedFree( actualBlock );
    }

    if( actualBlock != NULL ) {

        //
        // Update the Paged pool usage statistic.
        //

        ASSERT( SrvStatistics.CurrentPagedPoolUsage >= actualBlock->RequestedSize );

        InterlockedExchangeAdd(
            (PLONG)&SrvStatistics.CurrentPagedPoolUsage,
            -(LONG)actualBlock->RequestedSize
            );

        ASSERT( (LONG)SrvStatistics.CurrentPagedPoolUsage >= 0 );

        //
        // Free the pool and return.
        //

        ExFreePool( actualBlock );
    }

} // SrvFreePagedPool
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\srv\io.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    io.c

Abstract:

    !!! Need to handle inability to allocate IRP.

    !!! Need to modify to accept file object pointer, not file handle,
        to avoid unnecessary translations.

Author:

    Chuck Lenzmeier (chuckl)    28-Oct-1989

Revision History:

--*/

#include "precomp.h"
#include "io.tmh"
#pragma hdrstop

#define BugCheckFileId SRV_FILE_IO

//
// Forward declarations
//

PIRP
BuildCoreOfSyncIoRequest (
    IN HANDLE FileHandle,
    IN PFILE_OBJECT FileObject OPTIONAL,
    IN PKEVENT Event,
    IN PIO_STATUS_BLOCK IoStatusBlock,
    IN OUT PDEVICE_OBJECT *DeviceObject
    );

NTSTATUS
StartIoAndWait (
    IN PIRP Irp,
    IN PDEVICE_OBJECT DeviceObject,
    IN PKEVENT Event,
    IN PIO_STATUS_BLOCK IoStatusBlock
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text( PAGE, BuildCoreOfSyncIoRequest )
#pragma alloc_text( PAGE, StartIoAndWait )
#pragma alloc_text( PAGE, SrvBuildFlushRequest )
#pragma alloc_text( PAGE, SrvBuildLockRequest )
#pragma alloc_text( PAGE, SrvBuildMailslotWriteRequest )
#pragma alloc_text( PAGE, SrvBuildReadOrWriteRequest )
#pragma alloc_text( PAGE, SrvBuildNotifyChangeRequest )
#pragma alloc_text( PAGE, SrvIssueAssociateRequest )
#pragma alloc_text( PAGE, SrvIssueDisconnectRequest )
#pragma alloc_text( PAGE, SrvIssueTdiAction )
#pragma alloc_text( PAGE, SrvIssueTdiQuery )
#pragma alloc_text( PAGE, SrvIssueQueryDirectoryRequest )
#pragma alloc_text( PAGE, SrvIssueQueryEaRequest )
#pragma alloc_text( PAGE, SrvIssueSendDatagramRequest )
#pragma alloc_text( PAGE, SrvIssueSetClientProcessRequest )
#pragma alloc_text( PAGE, SrvIssueSetEaRequest )
#pragma alloc_text( PAGE, SrvIssueSetEventHandlerRequest )
#pragma alloc_text( PAGE, SrvIssueUnlockRequest )
#pragma alloc_text( PAGE, SrvIssueUnlockSingleRequest )
#pragma alloc_text( PAGE, SrvIssueWaitForOplockBreak )
#pragma alloc_text( PAGE, SrvQuerySendEntryPoint )
#ifdef INCLUDE_SMB_IFMODIFIED
#pragma alloc_text( PAGE, SrvIssueQueryUsnInfoRequest )
#endif
#endif
#if 0
NOT PAGEABLE -- SrvBuildIoControlRequest
#endif


STATIC
PIRP
BuildCoreOfSyncIoRequest (
    IN HANDLE FileHandle,
    IN PFILE_OBJECT FileObject OPTIONAL,
    IN PKEVENT Event,
    IN PIO_STATUS_BLOCK IoStatusBlock,
    IN OUT PDEVICE_OBJECT *DeviceObject
    )

/*++

Routine Description:

    This (local) function builds the request-independent portion of
    an I/O request packet for an I/O operation that will be performed
    synchronously.  It initializes a kernel event object, references
    the target file object, and allocates and initializes an IRP.

Arguments:

    FileHandle - Supplies a handle to the target file object.

    FileObject - Optionall supplies a pointer to the target file object.

    Event - Supplies a pointer to a kernel event object.  This routine
        initializes the event.

    IoStatusBlock - Supplies a pointer to an I/O status block.  This
        pointer is placed in the IRP.

    DeviceObject - Supplies or receives the address of the device object
        associated with the target file object.  This address is
        subsequently used by StartIoAndWait.  *DeviceObject must be
        valid or NULL on entry if FileObject != NULL.

Return Value:

    PIRP - Returns a pointer to the constructed IRP.

--*/

{
    NTSTATUS status;
    PIRP irp;
    PIO_STACK_LOCATION irpSp;

    PAGED_CODE();

    //
    // Initialize the kernel event that will signal I/O completion.
    //

    KeInitializeEvent( Event, SynchronizationEvent, FALSE );

    //
    // Get the file object corresponding to the directory's handle.
    // Referencing the file object every time is necessary because the
    // IO completion routine dereferneces it.
    //

    if ( ARGUMENT_PRESENT(FileObject) ) {

        ObReferenceObject(FileObject);

    } else {

        *DeviceObject = NULL;

        status = ObReferenceObjectByHandle(
                    FileHandle,
                    0L,                         // DesiredAccess
                    NULL,                       // ObjectType
                    KernelMode,
                    (PVOID *)&FileObject,
                    NULL
                    );

        if ( !NT_SUCCESS(status) ) {
            return NULL;
        }
    }

    //
    // Set the file object event to a non-signaled state.
    //

    KeClearEvent( &FileObject->Event );

    //
    // Attempt to allocate and initialize the I/O Request Packet (IRP)
    // for this operation.
    //

    if ( *DeviceObject == NULL ) {
        *DeviceObject = IoGetRelatedDeviceObject( FileObject );
    }

    irp = IoAllocateIrp( (*DeviceObject)->StackSize, TRUE );

    if ( irp == NULL ) {

        ULONG packetSize = sizeof(IRP) +
                ((*DeviceObject)->StackSize * sizeof(IO_STACK_LOCATION));

        INTERNAL_ERROR(
            ERROR_LEVEL_EXPECTED,
            "BuildCoreOfSyncIoRequest: Failed to allocate IRP",
             NULL,
             NULL
             );

        SrvLogError(
            SrvDeviceObject,
            EVENT_SRV_NO_NONPAGED_POOL,
            STATUS_INSUFFICIENT_RESOURCES,
            &packetSize,
            sizeof(ULONG),
            NULL,
            0
            );

        return NULL;
    }

    //
    // Fill in the service independent parameters in the IRP.
    //

    irp->MdlAddress = NULL;

    irp->Flags = (LONG)IRP_SYNCHRONOUS_API;
    irp->RequestorMode = KernelMode;
    irp->PendingReturned = FALSE;

    irp->UserIosb = IoStatusBlock;
    irp->UserEvent = Event;

    irp->Overlay.AsynchronousParameters.UserApcRoutine = NULL;

    irp->AssociatedIrp.SystemBuffer = NULL;
    irp->UserBuffer = NULL;

    irp->Tail.Overlay.Thread = PsGetCurrentThread();
    irp->Tail.Overlay.OriginalFileObject = FileObject;
    irp->Tail.Overlay.AuxiliaryBuffer = NULL;

    irp->IoStatus.Status = 0;
    irp->IoStatus.Information = 0;

    //
    // Put the file object pointer in the stack location.
    //

    irpSp = IoGetNextIrpStackLocation( irp );
    irpSp->FileObject = FileObject;
    irpSp->DeviceObject = *DeviceObject;

    return irp;

} // BuildCoreOfSyncIoRequest


STATIC
NTSTATUS
StartIoAndWait (
    IN PIRP Irp,
    IN PDEVICE_OBJECT DeviceObject,
    IN PKEVENT Event,
    IN PIO_STATUS_BLOCK IoStatusBlock
    )

/*++

Routine Description:

    This (local) function passes a fully built I/O request packet to the
    target driver, then waits for the driver to complete the request.

Arguments:

    Irp - Supplies a pointer to the I/O request packet.

    DeviceObject - Supplies a pointer to the target device object.

    Event - Supplies a pointer to a kernel event object.  This routine
        waits for the I/O to complete using this event.

    IoStatusBlock - Supplies a pointer to an I/O status block.  The
        Status field of this structure becomes the return status of
        this function.

Return Value:

    NTSTATUS - Either an error status returned by the driver from
        IoCallDriver, indicating that the driver rejected the request,
        or the I/O status placed in the I/O status block by the driver
        at I/O completion.

--*/

{
    NTSTATUS status;
    KIRQL oldIrql;

    PAGED_CODE();

    //
    // Queue the IRP to the thread and pass it to the driver.
    //

    IoQueueThreadIrp( Irp );

    status = IoCallDriver( DeviceObject, Irp );

    //
    // If necessary, wait for the I/O to complete.
    //

    if ( status == STATUS_PENDING ) {
        KeWaitForSingleObject(
            Event,
            UserRequest,
            KernelMode, // don't let stack be paged -- event is on stack!
            FALSE,
            NULL
            );
    }

    //
    // If the request was successfully queued, get the final I/O status.
    //

    if ( NT_SUCCESS(status) ) {
        status = IoStatusBlock->Status;
    }

    return status;

} // StartIoAndWait


PIRP
SrvBuildIoControlRequest (
    IN OUT PIRP Irp OPTIONAL,
    IN PFILE_OBJECT FileObject OPTIONAL,
    IN PVOID Context,
    IN UCHAR MajorFunction,
    IN ULONG IoControlCode,
    IN PVOID MainBuffer,
    IN ULONG InputBufferLength,
    IN PVOID AuxiliaryBuffer OPTIONAL,
    IN ULONG OutputBufferLength,
    IN OUT PMDL Mdl OPTIONAL,
    IN PIO_COMPLETION_ROUTINE CompletionRoutine OPTIONAL
    )

/*++

Routine Description:

    This function builds an I/O request packet for a device or
    file system I/O control request.

    *** This routine sure takes a lot of arguments!

Arguments:

    Irp - Supplies a pointer to an IRP.  If NULL, this routine allocates
        an IRP and returns its address.  Otherwise, it supplies the
        address of an IRP allocated by the caller.

    FileObject - Supplies a pointer the file object to which this
        request is directed.  This pointer is copied into the IRP, so
        that the called driver can find its file-based context.  NOTE
        THAT THIS IS NOT A REFERENCED POINTER.  The caller must ensure
        that the file object is not deleted while the I/O operation is
        in progress.  The server accomplishes this by incrementing a
        reference count in a local block to account for the I/O; the
        local block in turn references the file object.

        If this parameter is omitted, it is the responsiblity of the
        calling program to load the file object address before starting
        the I/O.

    Context - Supplies a PVOID value that is passed to the completion
        routine.

    MajorFunction - The major function that we are calling.  Currently
        this most be one of IRP_MJ_FILE_SYSTEM_CONTROL or
        IRP_MJ_DEVICE_IO_CONTROL.

    IoControlCode - Supplies the control code for the operation.

    MainBuffer - Supplies the address of the main buffer.  This must
        be a system virtual address, and the buffer must be locked in
        memory.  If ControlCode specifies a method 0 request, the actual
        length of the buffer must be the greater of InputBufferLength
        and OutputBufferLength.

    InputBufferLength - Supplies the length of the input buffer.

    AuxiliaryBuffer - Supplies the address of the auxiliary buffer.  If the
        control code method is 0, this is a buffered I/O buffer, but the
        data returned by the called driver in the system buffer is not
        automatically copied into the auxiliary buffer.  Instead, the
        auxiliary data ends up in MainBuffer.  If the caller wishes the
        data to be in AuxiliaryBuffer, it must copy the data at some point
        after the completion routine runs.

        If the control code method is 1 or 2, this parameter is ignored;
        instead, the Mdl parameter is used to obtain the starting
        virtual address of the buffer.

    OutputBufferLength - Supplies the length of the output buffer.  Note
        that this parameter must be specified even when the Mdl
        parameter is specified.

    Mdl - If the control code method is 1 or 2, indicating direct I/O on
        the "output" buffer, this parameter is used to supply a pointer
        to an MDL describing a buffer.  Mdl must not be NULL, and the
        AuxiliaryBuffer parameter is ignored.  The buffer must reside in
        the system virtual address space (for the benefit of the
        transport provider).  If the buffer is not already locked, this
        routine locks it.  It is the calling program's responsibility to
        unlock the buffer and (potentially) deallocate the MDL after the
        I/O is complete.

        This parameter is ignored if the control method is not 1 or 2.

    CompletionRoutine - An optional IO completion routine.  If none
        is specified, SrvFsdIoCompletionRoutine is used.

Return Value:

    PIRP - Returns a pointer to the constructed IRP.  If the Irp
        parameter was not NULL on input, the function return value will
        be the same value (so it is safe to discard the return value in
        this case).  It is the responsibility of the calling program to
        deallocate the IRP after the I/O request is complete.

--*/

{
    CLONG method;
    PDEVICE_OBJECT deviceObject;
    PIO_STACK_LOCATION irpSp;

    ASSERT( MajorFunction == IRP_MJ_DEVICE_CONTROL ||
            MajorFunction == IRP_MJ_INTERNAL_DEVICE_CONTROL ||
            MajorFunction == IRP_MJ_FILE_SYSTEM_CONTROL );

    //
    // Get the method with which the buffers are being passed.
    //

    if ((MajorFunction == IRP_MJ_DEVICE_CONTROL)  ||
        (MajorFunction == IRP_MJ_FILE_SYSTEM_CONTROL)) {
        method = IoControlCode & 3;
    } else {
        method = 4;
    }

    if ( ARGUMENT_PRESENT(Irp) ) {
        if( Irp->AssociatedIrp.SystemBuffer &&
            (Irp->Flags & IRP_DEALLOCATE_BUFFER) ) {

            ExFreePool( Irp->AssociatedIrp.SystemBuffer );
            Irp->Flags &= ~IRP_DEALLOCATE_BUFFER;
        }
    }

    //
    // If the FileObject parameter was specified, obtain the address of
    // the device object and allocate the IRP based on the stack size
    // for that device.  Otherwise, allocate the IRP based on the
    // server's receive IRP stack size.
    //

    if ( ARGUMENT_PRESENT(FileObject) ) {

        //
        // Allocate an IRP, if necessary.  The stack size is one higher
        // than that of the target device, to allow for the caller's
        // completion routine.
        //

        deviceObject = IoGetRelatedDeviceObject( FileObject );

        if ( ARGUMENT_PRESENT(Irp) ) {

            ASSERT( Irp->StackCount >= deviceObject->StackSize );

        } else {

            //
            // Get the address of the target device object.
            //

            Irp = IoAllocateIrp( SrvReceiveIrpStackSize, FALSE );
            if ( Irp == NULL ) {

                //
                // Unable to allocate an IRP.  Inform the caller.
                //

                return NULL;
            }

        }

    } else {

        deviceObject = NULL;

        if ( !ARGUMENT_PRESENT(Irp) ) {
            Irp = IoAllocateIrp( SrvReceiveIrpStackSize, FALSE );
            if ( Irp == NULL ) {
                return NULL;
            }
        }

    }

    Irp->Tail.Overlay.OriginalFileObject = FileObject;
    Irp->Tail.Overlay.Thread = PROCESSOR_TO_QUEUE()->IrpThread;
    DEBUG Irp->RequestorMode = KernelMode;

    Irp->IoStatus.Status = 0;
    Irp->IoStatus.Information = 0;

    //
    // Get a pointer to the next stack location.  This one is used to
    // hold the parameters for the device I/O control request.
    //

    irpSp = IoGetNextIrpStackLocation( Irp );

    //
    // Set up the completion routine.
    //

    IoSetCompletionRoutine(
        Irp,
        (ARGUMENT_PRESENT( CompletionRoutine ) ?
            CompletionRoutine : SrvFsdIoCompletionRoutine),
        Context,
        TRUE,
        TRUE,
        TRUE
        );

    irpSp->MajorFunction = MajorFunction;
    irpSp->MinorFunction = 0;
    if ( MajorFunction == IRP_MJ_INTERNAL_DEVICE_CONTROL ) {
        irpSp->MinorFunction = (UCHAR)IoControlCode;
    }
    irpSp->FileObject = FileObject;
    irpSp->DeviceObject = deviceObject;

    //
    // Copy the caller's parameters to the service-specific portion of the
    // IRP for those parameters that are the same for all three methods.
    //

    if ( MajorFunction == IRP_MJ_DEVICE_CONTROL ) {
        irpSp->Parameters.DeviceIoControl.OutputBufferLength =
            OutputBufferLength;
        irpSp->Parameters.DeviceIoControl.InputBufferLength =
            InputBufferLength;
        irpSp->Parameters.DeviceIoControl.IoControlCode = IoControlCode;
    } else if ( MajorFunction == IRP_MJ_INTERNAL_DEVICE_CONTROL ) {
        if ( IoControlCode == TDI_RECEIVE ) {
            PTDI_REQUEST_KERNEL_RECEIVE parameters =
                        (PTDI_REQUEST_KERNEL_RECEIVE)&irpSp->Parameters;
            parameters->ReceiveLength = OutputBufferLength;
            parameters->ReceiveFlags = 0;
            method = 1;
        } else if ( IoControlCode == TDI_ACCEPT ) {
            PTDI_REQUEST_KERNEL_ACCEPT parameters =
                        (PTDI_REQUEST_KERNEL_ACCEPT)&irpSp->Parameters;
            parameters->RequestConnectionInformation = NULL;
            parameters->ReturnConnectionInformation = NULL;
            method = 0;
        } else {
            ASSERTMSG( "Invalid TDI request type", 0 );
        }
    } else {
        irpSp->Parameters.FileSystemControl.OutputBufferLength =
            OutputBufferLength;
        irpSp->Parameters.FileSystemControl.InputBufferLength =
            InputBufferLength;
        irpSp->Parameters.FileSystemControl.FsControlCode = IoControlCode;
    }

    //
    // Based on the method by which the buffers are being passed,
    // describe a system buffer and optionally build an MDL.
    //

    switch ( method ) {

    case 0:

        //
        // For this case, InputBuffer must be large enough to contain
        // both the input and the output buffers.
        //

        Irp->MdlAddress = NULL;
        Irp->AssociatedIrp.SystemBuffer = MainBuffer;
        Irp->UserBuffer = AuxiliaryBuffer;

        //
        // !!! Does Irp->Flags need to be set?  Isn't this only looked
        //     at by I/O competion, which we bypass?
        //

        Irp->Flags = (ULONG)IRP_BUFFERED_IO;
        if ( ARGUMENT_PRESENT(AuxiliaryBuffer) ) {
            Irp->Flags |= IRP_INPUT_OPERATION;
        }

        break;

    case 1:
    case 2:

        //
        // For these two cases, InputBuffer is the buffered I/O "system
        // buffer".  Build an MDL for either read or write access,
        // depending on the method, for the output buffer.
        //

        Irp->MdlAddress = Mdl;
        Irp->AssociatedIrp.SystemBuffer = MainBuffer;
        // !!! Ditto above about setting Flags.
        Irp->Flags = (ULONG)IRP_BUFFERED_IO;

        break;

    case 3:

        //
        // For this case, do nothing.  Everything is up to the driver.
        // Simply give the driver a copy of the caller's parameters and
        // let the driver do everything itself.
        //

        Irp->MdlAddress = NULL;
        Irp->AssociatedIrp.SystemBuffer = NULL;
        Irp->UserBuffer = AuxiliaryBuffer;
        Irp->Flags = 0;
        irpSp->Parameters.DeviceIoControl.Type3InputBuffer = MainBuffer;
        break;

    case 4:

        //
        // This is the case for file system io request.  Both MainBuffer
        // and AuxiliaryBuffer are locked system buffers.
        //

        Irp->MdlAddress = NULL;
        Irp->Flags = 0;
        Irp->AssociatedIrp.SystemBuffer = MainBuffer;
        irpSp->Parameters.DeviceIoControl.Type3InputBuffer = AuxiliaryBuffer;
        break;

    }

    return Irp;

} // SrvBuildIoControlRequest


VOID
SrvBuildFlushRequest (
    IN PIRP Irp,
    IN PFILE_OBJECT FileObject,
    IN PVOID Context OPTIONAL
    )

/*++

Routine Description:

    This function builds an I/O request packet for a flush request.

Arguments:

    Irp - Supplies a pointer to an IRP.

    FileObject - Supplies a pointer the file object to which this
        request is directed.  This pointer is copied into the IRP, so
        that the called driver can find its file-based context.  NOTE
        THAT THIS IS NOT A REFERENCED POINTER.  The caller must ensure
        that the file object is not deleted while the I/O operation is
        in progress.  The server accomplishes this by incrementing a
        reference count in a local block to account for the I/O; the
        local block in turn references the file object.

    Context - Supplies a PVOID value that is passed to the completion
        routine.

Return Value:

    None.

--*/

{
    PDEVICE_OBJECT deviceObject;
    PIO_STACK_LOCATION irpSp;

    PAGED_CODE( );

    deviceObject = IoGetRelatedDeviceObject( FileObject );

    ASSERT( Irp->StackCount >= deviceObject->StackSize );

    Irp->Tail.Overlay.OriginalFileObject = FileObject;
    Irp->Tail.Overlay.Thread = PROCESSOR_TO_QUEUE()->IrpThread;
    DEBUG Irp->RequestorMode = KernelMode;

    Irp->IoStatus.Status = 0;
    Irp->IoStatus.Information = 0;

    //
    // Get a pointer to the next stack location.  This one is used to
    // hold the parameters for the read request.  Fill in the
    // service-dependent parameters for the request.
    //

    irpSp = IoGetNextIrpStackLocation( Irp );

    //
    // Set up the completion routine.
    //

    IoSetCompletionRoutine(
        Irp,
        SrvFsdIoCompletionRoutine,
        Context,
        TRUE,
        TRUE,
        TRUE
        );

    irpSp->MajorFunction = IRP_MJ_FLUSH_BUFFERS;
    irpSp->FileObject = FileObject;
    irpSp->DeviceObject = deviceObject;

    irpSp->Flags = 0;

    return;

} // SrvBuildFlushRequest


VOID
SrvBuildLockRequest (
    IN PIRP Irp,
    IN PFILE_OBJECT FileObject,
    IN PVOID Context OPTIONAL,
    IN LARGE_INTEGER ByteOffset,
    IN LARGE_INTEGER Length,
    IN ULONG Key,
    IN BOOLEAN FailImmediately,
    IN BOOLEAN ExclusiveLock
    )

/*++

Routine Description:

    This function builds an I/O request packet for a lock request.

Arguments:

    Irp - Supplies a pointer to an IRP.

    FileObject - Supplies a pointer the file object to which this
        request is directed.  This pointer is copied into the IRP, so
        that the called driver can find its file-based context.  NOTE
        THAT THIS IS NOT A REFERENCED POINTER.  The caller must ensure
        that the file object is not deleted while the I/O operation is
        in progress.  The server accomplishes this by incrementing a
        reference count in a local block to account for the I/O; the
        local block in turn references the file object.

    Context - Supplies a PVOID value that is passed to the completion
        routine.

    StartingBlock - the block number of the beginning of the locked
        range.

    ByteOffset - the offset within block of the beginning of the locked
        range.

    Length - the length of the locked range.

    Key - the key value to be associated with the lock.

Return Value:

    None.

--*/

{
    PDEVICE_OBJECT deviceObject;
    PIO_STACK_LOCATION irpSp;

    PAGED_CODE( );

    deviceObject = IoGetRelatedDeviceObject( FileObject );

    ASSERT( Irp->StackCount >= deviceObject->StackSize );

    Irp->Tail.Overlay.OriginalFileObject = FileObject;
    Irp->Tail.Overlay.Thread = PROCESSOR_TO_QUEUE()->IrpThread;
    DEBUG Irp->RequestorMode = KernelMode;

    Irp->IoStatus.Status = 0;
    Irp->IoStatus.Information = 0;

    //
    // Get a pointer to the next stack location.  This one is used to
    // hold the parameters for the read request.  Fill in the
    // service-dependent parameters for the request.
    //

    irpSp = IoGetNextIrpStackLocation( Irp );

    //
    // Set up the completion routine.
    //

    IoSetCompletionRoutine(
        Irp,
        SrvFsdIoCompletionRoutine,
        Context,
        TRUE,
        TRUE,
        TRUE
        );

    irpSp->MajorFunction = IRP_MJ_LOCK_CONTROL;
    irpSp->MinorFunction = IRP_MN_LOCK;
    irpSp->FileObject = FileObject;
    irpSp->DeviceObject = deviceObject;

    irpSp->Flags = 0;
    if ( FailImmediately ) {
        irpSp->Flags = SL_FAIL_IMMEDIATELY;
    }
    if ( ExclusiveLock ) {
        irpSp->Flags |= SL_EXCLUSIVE_LOCK;
    }

    ((PWORK_CONTEXT)Context)->Parameters2.LockLength = Length;
    irpSp->Parameters.LockControl.Length = &((PWORK_CONTEXT)Context)->Parameters2.LockLength;
    irpSp->Parameters.LockControl.Key = Key;
    irpSp->Parameters.LockControl.ByteOffset = ByteOffset;

    return;

} // SrvBuildLockRequest


NTSTATUS
SrvMdlCompletionRoutine (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    )
{
    DeviceObject; Irp; Context;
    return STATUS_MORE_PROCESSING_REQUIRED;
}

NTSTATUS
SrvIssueMdlCompleteRequest (
    IN PWORK_CONTEXT WorkContext OPTIONAL,
    IN PFILE_OBJECT FileObject OPTIONAL,
    IN PMDL Mdl,
    IN UCHAR Function,
    IN PLARGE_INTEGER ByteOffset,
    IN ULONG Length
    )
{
    PIRP irp;
    PIO_STACK_LOCATION irpSp;
    PFILE_OBJECT fileObject = FileObject ? FileObject : WorkContext->Rfcb->Lfcb->FileObject;
    PDEVICE_OBJECT deviceObject = IoGetRelatedDeviceObject( fileObject );
    KEVENT userEvent;
    NTSTATUS status;
    IO_STATUS_BLOCK ioStatusBlock;

    if(  (irp = IoAllocateIrp( deviceObject->StackSize, TRUE )) == NULL ) {

        return STATUS_INSUFFICIENT_RESOURCES;
    }

    // Reference the file object
    ObReferenceObject( fileObject );

    KeInitializeEvent( &userEvent, SynchronizationEvent, FALSE );
    KeClearEvent( &userEvent );

    irp->MdlAddress = Mdl;
    irp->Flags = IRP_SYNCHRONOUS_API;
    irp->UserEvent = &userEvent;
    irp->UserIosb = &ioStatusBlock;
    irp->RequestorMode = KernelMode;
    irp->PendingReturned = FALSE;
    irp->Tail.Overlay.Thread = PsGetCurrentThread();
    irp->Tail.Overlay.OriginalFileObject = fileObject;
    irp->IoStatus.Status = 0;
    irp->IoStatus.Information = 0;

    irpSp = IoGetNextIrpStackLocation( irp );
    irpSp->FileObject = fileObject;
    irpSp->DeviceObject = deviceObject;
    irpSp->Flags = 0;
    irpSp->MinorFunction = IRP_MN_MDL | IRP_MN_COMPLETE;
    irpSp->MajorFunction = Function;

    if( Function == IRP_MJ_WRITE ) {
        irpSp->Parameters.Write.ByteOffset = *ByteOffset;
        irpSp->Parameters.Write.Length = Length;
    } else {
        irpSp->Parameters.Read.ByteOffset = *ByteOffset;
        irpSp->Parameters.Read.Length = Length;
    }

    status = IoCallDriver( deviceObject, irp );

    if (status == STATUS_PENDING) {
        (VOID) KeWaitForSingleObject( &userEvent,
                                      UserRequest,
                                      KernelMode,
                                      FALSE,
                                      (PLARGE_INTEGER) NULL );

        status = ioStatusBlock.Status;
    }

    ASSERT( status == STATUS_SUCCESS );

    return status;
}


VOID
SrvBuildMailslotWriteRequest (
    IN PIRP Irp,
    IN PFILE_OBJECT FileObject,
    IN PVOID Context OPTIONAL,
    IN PVOID Buffer OPTIONAL,
    IN ULONG Length
    )

/*++

Routine Description:

    This function builds an I/O request packet for a mailslot write
    request.

Arguments:

    Irp - Supplies a pointer to an IRP.

    FileObject - Supplies a pointer the file object to which this
        request is directed.  This pointer is copied into the IRP, so
        that the called driver can find its file-based context.  NOTE
        THAT THIS IS NOT A REFERENCED POINTER.  The caller must ensure
        that the file object is not deleted while the I/O operation is
        in progress.  The server accomplishes this by incrementing a
        reference count in a local block to account for the I/O; the
        local block in turn references the file object.

    Context - Supplies a PVOID value that is passed to the completion
        routine.

    Buffer - Supplies the system virtual address of the write
        buffer.

    Length - Supplies the length of the write.

Return Value:

    None.

--*/

{
    PDEVICE_OBJECT deviceObject;
    PIO_STACK_LOCATION irpSp;

    PAGED_CODE( );

    deviceObject = IoGetRelatedDeviceObject( FileObject );

    ASSERT( Irp->StackCount >= deviceObject->StackSize );

    Irp->Tail.Overlay.OriginalFileObject = FileObject;
    Irp->Tail.Overlay.Thread = PROCESSOR_TO_QUEUE()->IrpThread;
    DEBUG Irp->RequestorMode = KernelMode;

    Irp->IoStatus.Status = 0;
    Irp->IoStatus.Information = 0;

    //
    // Get a pointer to the next stack location.  This one is used to
    // hold the parameters for the read request.
    //

    irpSp = IoGetNextIrpStackLocation( Irp );

    //
    // Set up the completion routine.
    //

    IoSetCompletionRoutine(
        Irp,
        SrvFsdIoCompletionRoutine,
        Context,
        TRUE,
        TRUE,
        TRUE
        );

    irpSp->MajorFunction = IRP_MJ_WRITE;
    irpSp->MinorFunction = 0;
    irpSp->FileObject = FileObject;
    irpSp->DeviceObject = deviceObject;

    //
    // Set the write buffer.
    //

    //Irp->AssociatedIrp.SystemBuffer = Buffer;
    Irp->UserBuffer = Buffer;
    Irp->Flags = IRP_BUFFERED_IO;

    //
    // Set the write parameters.
    //

    irpSp->Parameters.Write.Length = Length;

    return;

} // SrvBuildMailslotWriteRequest


VOID
SrvBuildReadOrWriteRequest (
    IN OUT PIRP Irp,
    IN PFILE_OBJECT FileObject,
    IN PVOID Context OPTIONAL,
    IN UCHAR MajorFunction,
    IN UCHAR MinorFunction,
    IN PVOID Buffer OPTIONAL,
    IN ULONG Length,
    IN OUT PMDL Mdl OPTIONAL,
    IN LARGE_INTEGER ByteOffset,
    IN ULONG Key OPTIONAL
    )

/*++

Routine Description:

    This function builds an I/O request packet for a read or write
    request.

Arguments:

    Irp - Supplies a pointer to an IRP.

    FileObject - Supplies a pointer the file object to which this
        request is directed.  This pointer is copied into the IRP, so
        that the called driver can find its file-based context.  NOTE
        THAT THIS IS NOT A REFERENCED POINTER.  The caller must ensure
        that the file object is not deleted while the I/O operation is
        in progress.  The server accomplishes this by incrementing a
        reference count in a local block to account for the I/O; the
        local block in turn references the file object.

    Context - Supplies a PVOID value that is passed to the completion
        routine.

    MajorFunction - Indicates the function to be performed.  Must be
        either IRP_MJ_READ or IRP_MJ_WRITE.

    MinorFunction - Qualifies the function to be performed.  (For
        example, issued at DPC level, MDL read, etc.)

    Buffer - Supplies the system virtual address of the read or write
        buffer.  This parameter is ignored when MinorFunction is
        IRP_MN_*_MDL_*.  Otherwise, the buffer must be mapped in the
        system virtual address space in order to support buffered I/O
        devices and other device drivers that need to look at the user
        data.  This routine always treats the buffer as a direct I/O
        buffer, locking it for I/O with an MDL.  It does, however, set
        up the IRP appropriately for the device type.

        If the Mdl parameter is NULL, this routine locks the buffer in
        memory for the I/O.  It is then the responsibility of the
        calling program to unlock the buffer and deallocate the MDL
        after the I/O is complete.

    Length - Supplies the length of the read or write.

    Mdl - This parameter is used to supply a pointer to an MDL
        describing a buffer.  It is ignored when MinorFunction is
        IRP_MN_MDL_*.  Otherwise, Mdl must not be NULL.  The buffer must
        reside in the system virtual address space (for the benefit of
        buffered I/O devices/drivers).  If the buffer is not already
        locked, this routine locks it.  It is the calling program's
        responsibility to unlock the buffer and (potentially) deallocate
        the MDL after the I/O is complete.

    ByteOffset - the offset within the file of the beginning of the read
        or write.

    Key - the key value to be associated with the read or write.

Return Value:

    None.

--*/

{
    PDEVICE_OBJECT deviceObject;
    PIO_STACK_LOCATION irpSp;

    PAGED_CODE( );

    if( Irp->AssociatedIrp.SystemBuffer &&
        (Irp->Flags & IRP_DEALLOCATE_BUFFER) ) {

        ExFreePool( Irp->AssociatedIrp.SystemBuffer );
        Irp->Flags &= ~IRP_DEALLOCATE_BUFFER;
    }

    //
    // Obtain the address of the device object and allocate the IRP
    // based on the stack size for that device.
    //

    deviceObject = IoGetRelatedDeviceObject( FileObject );

    ASSERT( Irp->StackCount >= deviceObject->StackSize );

    Irp->Tail.Overlay.OriginalFileObject = FileObject;
    Irp->Tail.Overlay.Thread = PROCESSOR_TO_QUEUE()->IrpThread;
    DEBUG Irp->RequestorMode = KernelMode;

    Irp->IoStatus.Status = 0;
    Irp->IoStatus.Information = 0;

    //
    // Get a pointer to the next stack location.  This one is used to
    // hold the parameters for the read request.
    //

    irpSp = IoGetNextIrpStackLocation( Irp );

    //
    // Set up the completion routine.
    //

    IoSetCompletionRoutine(
        Irp,
        SrvFsdIoCompletionRoutine,
        Context,
        TRUE,
        TRUE,
        TRUE
        );

    irpSp->MajorFunction = MajorFunction;
    irpSp->MinorFunction = MinorFunction;
    irpSp->FileObject = FileObject;
    irpSp->DeviceObject = deviceObject;

    //
    // This routine used to handle MDL read/write completion, but it
    // doesn't now.
    //

    ASSERT( IRP_MN_DPC == 1 );
    ASSERT( IRP_MN_MDL == 2 );
    ASSERT( IRP_MN_MDL_DPC == 3 );
    ASSERT( IRP_MN_COMPLETE_MDL == 6 );
    ASSERT( IRP_MN_COMPLETE_MDL_DPC == 7 );

    ASSERT( (MinorFunction & 4) == 0 );

    //
    // Set the parameters according to whether this is a read or a write
    // operation.  Notice that these parameters must be set even if the
    // driver has not specified buffered or direct I/O.
    //

    if ( MajorFunction == IRP_MJ_WRITE ) {

        irpSp->Parameters.Write.ByteOffset = ByteOffset;
        irpSp->Parameters.Write.Length = Length;
        irpSp->Parameters.Write.Key = Key;

    } else {

        irpSp->Parameters.Read.ByteOffset = ByteOffset;
        irpSp->Parameters.Read.Length = Length;
        irpSp->Parameters.Read.Key = Key;

    }

    //
    // Indicate to the file system that this operation can be handled
    // synchronously.  Basically, this means that the file system can
    // use the server's thread to fault pages in, etc.  This avoids
    // having to context switch to a file system thread.
    //

    Irp->Flags = IRP_SYNCHRONOUS_API;

    //
    // If this is the start of an MDL-based read or write, we simply
    // need to put the supplied MDL address in the IRP.  This optional
    // MDL address can provide a partial chain for a read or write that
    // was partially satisfied using the fast I/O path.
    //

    if ( (MinorFunction & IRP_MN_MDL) != 0 ) {

        Irp->MdlAddress = Mdl;

        DEBUG Irp->UserBuffer = NULL;
        DEBUG Irp->AssociatedIrp.SystemBuffer = NULL;

        return;

    }

    //
    // Normal ("copy") read or write.
    //

    ASSERT( Buffer != NULL );
    ASSERT( Mdl != NULL );

    //
    // If the target device does buffered I/O, load the address of the
    // caller's buffer as the "system buffered I/O buffer".  If the
    // target device does direct I/O, load the MDL address.  If it does
    // neither, load both the user buffer address and the MDL address.
    // (This is necessary to support file systems, such as HPFS, that
    // sometimes treat the I/O as buffered and sometimes treat it as
    // direct.)
    //

    if ( (deviceObject->Flags & DO_BUFFERED_IO) != 0 ) {

        Irp->AssociatedIrp.SystemBuffer = Buffer;
        if ( MajorFunction == IRP_MJ_WRITE ) {
            Irp->Flags |= IRP_BUFFERED_IO;
        } else {
            Irp->Flags |= IRP_BUFFERED_IO | IRP_INPUT_OPERATION;
        }

    } else if ( (deviceObject->Flags & DO_DIRECT_IO) != 0 ) {

        Irp->MdlAddress = Mdl;

    } else {

        Irp->UserBuffer = Buffer;
        Irp->MdlAddress = Mdl;
    }

    return;

} // SrvBuildReadOrWriteRequest


PIRP
SrvBuildNotifyChangeRequest (
    IN OUT PIRP Irp,
    IN PFILE_OBJECT FileObject,
    IN PVOID Context OPTIONAL,
    IN ULONG CompletionFilter,
    IN PVOID Buffer,
    IN ULONG BufferLength,
    IN BOOLEAN WatchTree
    )

/*++

Routine Description:

    This function builds an I/O request packet for a notify change request.

Arguments:

    Irp - Supplies a pointer to an IRP.

    FileObject - Supplies a pointer the file object to which this
        request is directed.  This pointer is copied into the IRP, so
        that the called driver can find its file-based context.  NOTE
        THAT THIS IS NOT A REFERENCED POINTER.  The caller must ensure
        that the file object is not deleted while the I/O operation is
        in progress.  The server accomplishes this by incrementing a
        reference count in a local block to account for the I/O; the
        local block in turn references the file object.

    Context - Supplies a PVOID value that is passed to the completion
        routine.

    CompletionFilter - Specifies which directory changes will cause the
        File sytsem to complete the IRP.

    Buffer - The buffer to receive the directory change data.

    BufferLength - The size, in bytes, of the buffer.

    WatchTree - If TRUE, recursively watch all subdirectories for changes.

Return Value:

    PIRP - Returns a pointer to the constructed IRP.  If the Irp
        parameter was not NULL on input, the function return value will
        be the same value (so it is safe to discard the return value in
        this case).  It is the responsibility of the calling program to
        deallocate the IRP after the I/O request is complete.

--*/

{
    PDEVICE_OBJECT deviceObject;
    PIO_STACK_LOCATION irpSp;
    PMDL mdl;

    PAGED_CODE( );

    if( Irp->AssociatedIrp.SystemBuffer &&
        (Irp->Flags & IRP_DEALLOCATE_BUFFER) ) {

        ExFreePool( Irp->AssociatedIrp.SystemBuffer );
        Irp->Flags &= ~IRP_DEALLOCATE_BUFFER;
    }

    //
    // Obtain the address of the device object and initialize the IRP.
    //

    deviceObject = IoGetRelatedDeviceObject( FileObject );

    Irp->Tail.Overlay.OriginalFileObject = FileObject;
    Irp->Tail.Overlay.Thread = PROCESSOR_TO_QUEUE()->IrpThread;
    Irp->RequestorMode = KernelMode;
    Irp->MdlAddress = NULL;

    Irp->IoStatus.Status = 0;
    Irp->IoStatus.Information = 0;

    //
    // Get a pointer to the next stack location.  This one is used to
    // hold the parameters for the read request.  Fill in the
    // service-dependent parameters for the request.
    //

    irpSp = IoGetNextIrpStackLocation( Irp );

    //
    // Set up the completion routine.
    //

    IoSetCompletionRoutine(
        Irp,
        SrvFsdIoCompletionRoutine,
        Context,
        TRUE,
        TRUE,
        TRUE
        );

    irpSp->MajorFunction = IRP_MJ_DIRECTORY_CONTROL;
    irpSp->MinorFunction = IRP_MN_NOTIFY_CHANGE_DIRECTORY;
    irpSp->FileObject = FileObject;
    irpSp->DeviceObject = deviceObject;

    irpSp->Flags = 0;
    if (WatchTree) {
        irpSp->Flags = SL_WATCH_TREE;
    }

    irpSp->Parameters.NotifyDirectory.Length = BufferLength;
    irpSp->Parameters.NotifyDirectory.CompletionFilter = CompletionFilter;

    if ( (deviceObject->Flags & DO_DIRECT_IO) != 0 ) {

        mdl = IoAllocateMdl(
                Buffer,
                BufferLength,
                FALSE,
                FALSE,
                Irp     // stores MDL address in irp->MdlAddress
                );

        if ( mdl == NULL ) {

            //
            // Unable to allocate an MDL.  Fail the I/O.
            //

            return NULL;

        }

        try {
            MmProbeAndLockPages( mdl, KernelMode, IoWriteAccess );
        } except( EXCEPTION_EXECUTE_HANDLER ) {
            IoFreeMdl( mdl );
            return NULL;
        }

        Irp->AssociatedIrp.SystemBuffer = NULL;
        Irp->UserBuffer = NULL;

    } else {

        Irp->AssociatedIrp.SystemBuffer = Buffer;
        Irp->UserBuffer = NULL;
    }

    //
    // Return a pointer to the IRP.
    //

    return Irp;

} // SrvBuildNotifyChangeRequest


NTSTATUS
SrvIssueAssociateRequest (
    IN PFILE_OBJECT FileObject,
    IN PDEVICE_OBJECT *DeviceObject,
    IN HANDLE AddressFileHandle
    )

/*++

Routine Description:

    This function issues an I/O request packet for a TdiAssociateAddress
    request.  It builds an I/O request packet, passes the IRP to the
    driver (using IoCallDriver), and waits for the I/O to complete.

Arguments:

    FileObject - pointer to file object for a connection.

    DeviceObject - pointer to pointer to device object for a connection.

    AddressFileHandle - handle to an address endpoint.

Return Value:

    NTSTATUS - the status of the operation.  Either the return value of
        IoCallDriver, if the driver didn't accept the request, or the
        value returned by the driver in the I/O status block.

--*/

{
    PIRP irp;
    PIO_STACK_LOCATION irpSp;
    PTDI_REQUEST_KERNEL_ASSOCIATE parameters;
    KEVENT event;
    IO_STATUS_BLOCK iosb;

    PAGED_CODE( );

    //
    // Allocate an IRP and fill in the service-independent parameters
    // for the request.
    //

    irp = BuildCoreOfSyncIoRequest(
              NULL,
              FileObject,
              &event,
              &iosb,
              DeviceObject
              );

    if ( irp == NULL ) {

        //
        // Unable to allocate an IRP.  Fail the I/O.
        //

        return STATUS_INSUFF_SERVER_RESOURCES;

    }

    //
    // Fill in the service-dependent parameters for the request.
    //

    irpSp = IoGetNextIrpStackLocation( irp );
    parameters = (PTDI_REQUEST_KERNEL_ASSOCIATE)&irpSp->Parameters;

    irpSp->MajorFunction = IRP_MJ_INTERNAL_DEVICE_CONTROL;
    irpSp->MinorFunction = TDI_ASSOCIATE_ADDRESS;

    parameters->AddressHandle = AddressFileHandle;

    //
    // Start the I/O, wait for it to complete, and return the final status.
    //

    return StartIoAndWait( irp, *DeviceObject, &event, &iosb );

} // SrvIssueAssociateRequest


NTSTATUS
SrvIssueDisconnectRequest (
    IN PFILE_OBJECT FileObject,
    IN PDEVICE_OBJECT *DeviceObject,
    IN ULONG Flags
    )

/*++

Routine Description:

    This function issues an I/O request packet for a TdiDisconnect
    request.  It builds an I/O request packet, passes the IRP to the
    driver (using IoCallDriver), and waits for the I/O to complete.

Arguments:

    FileObject - pointer to file object for a connection.

    DeviceObject - pointer to pointer to device object for a connection.

    Flags -

Return Value:

    NTSTATUS - the status of the operation.  Either the return value of
        IoCallDriver, if the driver didn't accept the request, or the
        value returned by the driver in the I/O status block.

--*/

{
    PIRP irp;
    PIO_STACK_LOCATION irpSp;
    PTDI_REQUEST_KERNEL parameters;
    KEVENT event;
    IO_STATUS_BLOCK iosb;

    PAGED_CODE( );

    //
    // Allocate an IRP and fill in the service-independent parameters
    // for the request.
    //

    irp = BuildCoreOfSyncIoRequest(
              NULL,
              FileObject,
              &event,
              &iosb,
              DeviceObject
              );

    if ( irp == NULL ) {

        //
        // Unable to allocate an IRP.  Fail the I/O.
        //

        return STATUS_INSUFF_SERVER_RESOURCES;

    }

    //
    // Fill in the service-dependent parameters for the request.
    //

    irpSp = IoGetNextIrpStackLocation( irp );
    parameters = (PTDI_REQUEST_KERNEL)&irpSp->Parameters;

    irpSp->MajorFunction = IRP_MJ_INTERNAL_DEVICE_CONTROL;
    irpSp->MinorFunction = TDI_DISCONNECT;

    parameters->RequestFlags = Flags;

    //
    // Start the I/O, wait for it to complete, and return the final status.
    //

    return StartIoAndWait( irp, *DeviceObject, &event, &iosb );

} // SrvIssueDisconnectRequest


NTSTATUS
SrvIssueTdiAction (
    IN PFILE_OBJECT FileObject,
    IN PDEVICE_OBJECT *DeviceObject,
    IN PCHAR Buffer,
    IN ULONG BufferLength
    )

/*++

Routine Description:

    This function issues an I/O request packet for a TdiQueryInformation
    (Query Adapter Status) request.  It builds an I/O request packet,
    passes the IRP to the driver (using IoCallDriver), and waits for the
    I/O to complete.

Arguments:

    FileObject - pointer to file object for a connection.

    DeviceObject - pointer to pointer to device object for a connection.

Return Value:

    NTSTATUS - the status of the operation.  Either the return value of
        IoCallDriver, if the driver didn't accept the request, or the
        value returned by the driver in the I/O status block.

--*/

{
    PIRP irp;
    PIO_STACK_LOCATION irpSp;
    KEVENT event;
    IO_STATUS_BLOCK iosb;
    PMDL mdl;

    PAGED_CODE( );

    //
    // Allocate and build an MDL that we'll use to describe the output
    // buffer for the request.
    //

    mdl = IoAllocateMdl( Buffer, BufferLength, FALSE, FALSE, NULL );
    if ( mdl == NULL ) {
        return STATUS_INSUFF_SERVER_RESOURCES;
    }

    try {
        MmProbeAndLockPages( mdl, KernelMode, IoWriteAccess );
    } except( EXCEPTION_EXECUTE_HANDLER ) {
        IoFreeMdl( mdl );
        return GetExceptionCode();
    }

    //
    // Allocate an IRP and fill in the service-independent parameters
    // for the request.
    //

    irp = BuildCoreOfSyncIoRequest(
              NULL,
              FileObject,
              &event,
              &iosb,
              DeviceObject
              );

    if ( irp == NULL ) {

        //
        // Unable to allocate an IRP.  Fail the I/O.
        //

        MmUnlockPages( mdl );
        IoFreeMdl( mdl );
        return STATUS_INSUFF_SERVER_RESOURCES;

    }

    //
    // Fill in the service-dependent parameters for the request.
    //

    irpSp = IoGetNextIrpStackLocation( irp );

    TdiBuildAction(
        irp,
        *DeviceObject,
        FileObject,
        NULL,
        NULL,
        mdl
        );

    //
    // Start the I/O, wait for it to complete, and return the final status.
    //

    return StartIoAndWait( irp, *DeviceObject, &event, &iosb );

} // SrvIssueTdiAction


NTSTATUS
SrvIssueTdiQuery (
    IN PFILE_OBJECT FileObject,
    IN PDEVICE_OBJECT *DeviceObject,
    IN PCHAR Buffer,
    IN ULONG BufferLength,
    IN ULONG QueryType
    )

/*++

Routine Description:

    This function issues an I/O request packet for a TdiQueryInformation
    (Query Adapter Status) request.  It builds an I/O request packet,
    passes the IRP to the driver (using IoCallDriver), and waits for the
    I/O to complete.

Arguments:

    FileObject - pointer to file object for a connection.

    DeviceObject - pointer to pointer to device object for a connection.

Return Value:

    NTSTATUS - the status of the operation.  Either the return value of
        IoCallDriver, if the driver didn't accept the request, or the
        value returned by the driver in the I/O status block.

--*/

{
    PIRP irp;
    PIO_STACK_LOCATION irpSp;
    KEVENT event;
    IO_STATUS_BLOCK iosb;
    PMDL mdl;

    PAGED_CODE( );

    //
    // Allocate and build an MDL that we'll use to describe the output
    // buffer for the request.
    //

    mdl = IoAllocateMdl( Buffer, BufferLength, FALSE, FALSE, NULL );
    if ( mdl == NULL ) {
        return STATUS_INSUFF_SERVER_RESOURCES;
    }

    try {
        MmProbeAndLockPages( mdl, KernelMode, IoWriteAccess );
    } except( EXCEPTION_EXECUTE_HANDLER ) {
        IoFreeMdl( mdl );
        return GetExceptionCode();
    }

    //
    // Allocate an IRP and fill in the service-independent parameters
    // for the request.
    //

    irp = BuildCoreOfSyncIoRequest(
              NULL,
              FileObject,
              &event,
              &iosb,
              DeviceObject
              );

    if ( irp == NULL ) {

        //
        // Unable to allocate an IRP.  Fail the I/O.
        //

        MmUnlockPages( mdl );
        IoFreeMdl( mdl );
        return STATUS_INSUFF_SERVER_RESOURCES;

    }

    //
    // Fill in the service-dependent parameters for the request.
    //

    irpSp = IoGetNextIrpStackLocation( irp );

    TdiBuildQueryInformation(
        irp,
        *DeviceObject,
        FileObject,
        NULL,
        NULL,
        QueryType,
        mdl
        );

    //
    // Start the I/O, wait for it to complete, and return the final status.
    //

    return StartIoAndWait( irp, *DeviceObject, &event, &iosb );

} // SrvIssueTdiQuery


NTSTATUS
SrvIssueQueryDirectoryRequest (
    IN HANDLE FileHandle,
    IN PCHAR Buffer,
    IN ULONG Length,
    IN FILE_INFORMATION_CLASS FileInformationClass,
    IN PUNICODE_STRING FileName OPTIONAL,
    IN PULONG FileIndex OPTIONAL,
    IN BOOLEAN RestartScan,
    IN BOOLEAN SingleEntriesOnly
    )

/*++

Routine Description:

    This function issues an I/O request packet for a query directory
    request.  It builds an I/O request packet, passes the IRP to the
    driver (using IoCallDriver), and waits for the I/O to complete.

Arguments:

    FileHandle - handle to a directory open with FILE_LIST_DIRECTORY
        access.

    Buffer - supplies the system virtual address of the buffer.  The
        buffer must be in nonpaged pool.

    Length - supplies the length of the buffer.

    FileInformationClass - Specfies the type of information that is to be
        returned about the files in the specified directory.

    FileName - an optional pointer to a file name.  If FileIndex is NULL,
        then this is the search specification, i.e. the template that
        files must match in order to be returned.  If FileIndex is
        non-NULL, then this is the name of a file after which to resume
        a search.

    FileIndex - if specified, the index of a file after which to resume
        the search (first file returned is the one after the one
        corresponding to the index).

    RestartScan - Supplies a BOOLEAN value that, if TRUE, indicates that the
        scan should be restarted from the beginning.

    SingleEntriesOnly - Supplies a BOOLEAN value that, if TRUE, indicates that
        the scan should ask only for one entry at a time.

Return Value:

    NTSTATUS - the status of the operation.  Either the return value of
        IoCallDriver, if the driver didn't accept the request, or the
        value returned by the driver in the I/O status block.

--*/

{
    ULONG actualBufferLength;
    PIRP irp;
    PIO_STACK_LOCATION irpSp;
    KEVENT event;
    IO_STATUS_BLOCK iosb;
    PDEVICE_OBJECT deviceObject;
    PUNICODE_STRING fileNameString;
    PMDL mdl;

    PAGED_CODE( );

    //
    // Reject rewind requests if debugging for it.  If a file index is
    // specified, this must be a rewind request, so reject the request.
    //

    IF_DEBUG(BRUTE_FORCE_REWIND) {
        if ( ARGUMENT_PRESENT( FileIndex ) ) {
            return STATUS_NOT_IMPLEMENTED;
        }
    }

    //
    // Copy the file name into the end of the specified buffer, setting
    // the actualBufferLength accordingly.
    //

    if ( !ARGUMENT_PRESENT(FileName) || FileName->Length == 0 ) {

        actualBufferLength = Length;
        fileNameString = NULL;

    } else {

        //
        // *** Remember that the string must be longword-aligned!
        //

        actualBufferLength = (Length - FileName->Length -
                                        sizeof(UNICODE_STRING)) & ~(sizeof(PVOID)-1);
        fileNameString = (PUNICODE_STRING)( Buffer + actualBufferLength );

        RtlCopyMemory(
            fileNameString + 1,
            FileName->Buffer,
            FileName->Length
            );

        fileNameString->Length = FileName->Length;
        fileNameString->MaximumLength = FileName->Length;
        fileNameString->Buffer = (PWCH)(fileNameString + 1);

    }

    //
    // Allocate an IRP and fill in the service-independent parameters
    // for the request.
    //

    irp = BuildCoreOfSyncIoRequest(
              FileHandle,
              NULL,
              &event,
              &iosb,
              &deviceObject
              );

    if ( irp == NULL ) {

        //
        // Unable to allocate an IRP.  Fail the I/O.
        //

        return STATUS_INSUFF_SERVER_RESOURCES;

    }

    //
    // Fill in the service-dependent parameters for the request.
    //

    irpSp = IoGetNextIrpStackLocation( irp );
    irpSp->MajorFunction = IRP_MJ_DIRECTORY_CONTROL;
    irpSp->MinorFunction = IRP_MN_QUERY_DIRECTORY;

    irpSp->Parameters.QueryDirectory.FileName = (PSTRING)fileNameString;

    irpSp->Parameters.QueryDirectory.FileIndex =
                    (ULONG)( ARGUMENT_PRESENT( FileIndex ) ? *FileIndex : 0 );

    irpSp->Parameters.QueryDirectory.Length = actualBufferLength;
    irpSp->Parameters.QueryDirectory.FileInformationClass =
                                                    FileInformationClass;

    //
    // Set the flags in the stack location.
    //

    irpSp->Flags = 0;

    if ( ARGUMENT_PRESENT( FileIndex ) ) {
        IF_DEBUG( SEARCH ) {
            KdPrint(("SrvIssueQueryDirectoryRequest: SL_INDEX_SPECIFIED\n" ));
        }
        irpSp->Flags |= SL_INDEX_SPECIFIED;
    }

    if ( RestartScan ) {
        IF_DEBUG( SEARCH ) {
            KdPrint(("SrvIssueQueryDirectoryRequest: SL_RESTART_SCAN\n" ));
        }
        irpSp->Flags |= SL_RESTART_SCAN;
    }

    if( SingleEntriesOnly ) {
        IF_DEBUG( SEARCH ) {
            KdPrint(("SrvIssueQueryDirectoryRequest: SL_RETURN_SINGLE_ENTRY\n" ));
        }
        irpSp->Flags |= SL_RETURN_SINGLE_ENTRY;
    }

    //
    // The file system has been updated.  Determine whether the driver wants
    // buffered, direct, or "neither" I/O.
    //

    if ( (deviceObject->Flags & DO_BUFFERED_IO) != 0 ) {

        //
        // The file system wants buffered I/O.  Pass the address of the
        // "system buffer" in the IRP.  Note that we don't want the buffer
        // deallocated, nor do we want the I/O system to copy to a user
        // buffer, so we don't set the corresponding flags in irp->Flags.
        //

        irp->AssociatedIrp.SystemBuffer = Buffer;

    } else if ( (deviceObject->Flags & DO_DIRECT_IO) != 0 ) {

        //
        // The file system wants direct I/O.  Allocate an MDL and lock the
        // buffer into memory.
        //

        mdl = IoAllocateMdl(
                Buffer,
                actualBufferLength,
                FALSE,
                FALSE,
                irp     // stores MDL address in irp->MdlAddress
                );

        if ( mdl == NULL ) {

            //
            // Unable to allocate an MDL.  Fail the I/O.
            //

            IoFreeIrp( irp );

            return STATUS_INSUFF_SERVER_RESOURCES;

        }

        try {
            MmProbeAndLockPages( mdl, KernelMode, IoWriteAccess );
        } except( EXCEPTION_EXECUTE_HANDLER ) {
            IoFreeIrp( irp );
            MmUnlockPages( mdl );
            IoFreeMdl( mdl );
            return GetExceptionCode();
        }

    } else {

        //
        // The file system wants "neither" I/O.  Simply pass the address
        // of the buffer.
        //
        // *** Note that if the file system decides to do this as buffered
        //     I/O, it will be wasting nonpaged pool, since our buffer is
        //     already in nonpaged pool.  But since we're doing this as a
        //     synchronous request, the file system probably won't do that.
        //

        irp->UserBuffer = Buffer;

    }

    //
    // Start the I/O, wait for it to complete, and return the final status.
    //

    return StartIoAndWait( irp, deviceObject, &event, &iosb );

} // SrvIssueQueryDirectoryRequest


NTSTATUS
SrvIssueQueryEaRequest (
    IN HANDLE FileHandle,
    IN PVOID Buffer,
    IN ULONG Length,
    IN PVOID EaList OPTIONAL,
    IN ULONG EaListLength,
    IN BOOLEAN RestartScan,
    OUT PULONG EaErrorOffset OPTIONAL
    )

/*++

Routine Description:

    This function issues an I/O request packet for an EA query request.
    It builds an I/O request packet, passes the IRP to the driver (using
    IoCallDriver), and waits for the I/O to complete.

Arguments:

    FileHandle - handle to a file open with FILE_READ_EA access.

    Buffer - supplies the system virtual address of the buffer.  The
        buffer must be in nonpaged pool.

    Length - supplies the length of the buffer.

    EaList - supplies a pointer to a list of EAs to query.  If omitted,
        all EAs are returned.

    EaListLength - supplies the length of EaList.

    RestartScan - if TRUE, then the query of EAs is to start from the
        beginning.  Otherwise, continue from where we left off.

    EaErrorOffset - if not NULL, returns the offset into EaList of an
        invalid EA, if any.

Return Value:

    NTSTATUS - the status of the operation.  Either the return value of
        IoCallDriver, if the driver didn't accept the request, or the
        value returned by the driver in the I/O status block.

--*/

{
    NTSTATUS status;
    PIRP irp;
    PIO_STACK_LOCATION irpSp;
    KEVENT event;
    IO_STATUS_BLOCK iosb;
    PDEVICE_OBJECT deviceObject;
    PMDL mdl;

    PAGED_CODE( );

    //
    // Allocate an IRP and fill in the service-independent parameters
    // for the request.
    //

    irp = BuildCoreOfSyncIoRequest(
              FileHandle,
              NULL,
              &event,
              &iosb,
              &deviceObject
              );

    if ( irp == NULL ) {

        //
        // Unable to allocate an IRP.  Fail the i/o.
        //

        return STATUS_INSUFF_SERVER_RESOURCES;

    }

    //
    // Fill in the service-dependent parameters for the request.
    //

    irpSp = IoGetNextIrpStackLocation( irp );
    irpSp->MajorFunction = IRP_MJ_QUERY_EA;
    irpSp->MinorFunction = 0;

    irpSp->Parameters.QueryEa.Length = Length;
    irpSp->Parameters.QueryEa.EaList = EaList;
    irpSp->Parameters.QueryEa.EaListLength = EaListLength;
    irpSp->Parameters.QueryEa.EaIndex = 0L;

    irpSp->Flags = (UCHAR)( RestartScan ? SL_RESTART_SCAN : 0 );

    //
    // The file system has been updated.  Determine whether the
    // driver wants buffered, direct, or "neither" I/O.
    //

    if ( (deviceObject->Flags & DO_BUFFERED_IO) != 0 ) {

        //
        // The file system wants buffered I/O.  Pass the address of the
        // "system buffer" in the IRP.  Note that we don't want the buffer
        // deallocated, nor do we want the I/O system to copy to a user
        // buffer, so we don't set the corresponding flags in irp->Flags.
        //

        irp->AssociatedIrp.SystemBuffer = Buffer;

    } else if ( (deviceObject->Flags & DO_DIRECT_IO) != 0 ) {

        //
        // The file system wants direct I/O.  Allocate an MDL and lock the
        // buffer into memory.
        //

        mdl = IoAllocateMdl(
                Buffer,
                Length,
                FALSE,
                FALSE,
                irp     // stores MDL address in irp->MdlAddress
                );

        if ( mdl == NULL ) {

            //
            // Unable to allocate an MDL.  Fail the I/O.
            //

            IoFreeIrp( irp );

            return STATUS_INSUFF_SERVER_RESOURCES;

        }

        try {
            MmProbeAndLockPages( mdl, KernelMode, IoWriteAccess );
        } except( EXCEPTION_EXECUTE_HANDLER ) {
            IoFreeIrp( irp );
            IoFreeMdl( mdl );
            return GetExceptionCode();
        }

    } else {

        //
        // The file system wants "neither" I/O.  Simply pass the address
        // of the buffer.
        //
        // *** Note that if the file system decides to do this as buffered
        //     I/O, it will be wasting nonpaged pool, since out buffer is
        //     already in nonpaged pool.  But since we're doing this as a
        //     synchronous request, the file system probably won't do that.
        //

        irp->UserBuffer = Buffer;

    }

    //
    // Start the I/O, wait for it to complete, and return the final
    // status.
    //

    status = StartIoAndWait( irp, deviceObject, &event, &iosb );

    if ( ARGUMENT_PRESENT(EaErrorOffset) ) {
        *EaErrorOffset = (ULONG)iosb.Information;
    }

    return status;

} // SrvIssueQueryEaRequest


NTSTATUS
SrvIssueSendDatagramRequest (
    IN PFILE_OBJECT FileObject,
    IN PDEVICE_OBJECT *DeviceObject,
    IN PTDI_CONNECTION_INFORMATION SendDatagramInformation,
    IN PVOID Buffer,
    IN ULONG Length
    )

/*++

Routine Description:

    This function issues an I/O request packet for a TDI Send Datagram
    request.  It builds an I/O request packet, passes the IRP to the
    driver (using IoCallDriver), and waits for the I/O to complete.

Arguments:

    FileObject - pointer to file object for an endpoint.

    DeviceObject - pointer to pointer to device object for an endpoint.

    SendDatagramInformation - pointer to a buffer describing the
        target of the datagram.

    Buffer - Supplies the system virtual address of the buffer.  The
        buffer must be in nonpaged pool.

    Length - Supplies the length of the buffer.

Return Value:

    NTSTATUS - the status of the operation.  Either the return value of
        IoCallDriver, if the driver didn't accept the request, or the
        value returned by the driver in the I/O status block.

--*/

{
    PIRP irp;
    PIO_STACK_LOCATION irpSp;
    PTDI_REQUEST_KERNEL_SENDDG parameters;
    KEVENT event;
    IO_STATUS_BLOCK iosb;
    PMDL mdl;

    PAGED_CODE( );

    //
    // Allocate an IRP and fill in the service-independent parameters
    // for the request.
    //

    irp = BuildCoreOfSyncIoRequest(
              NULL,
              FileObject,
              &event,
              &iosb,
              DeviceObject
              );

    if ( irp == NULL ) {

        //
        // Unable to allocate an IRP.  Fail the i/o.
        //

        return STATUS_INSUFF_SERVER_RESOURCES;

    }

    //
    // Fill in the service-dependent parameters for the request.
    //

    irpSp = IoGetNextIrpStackLocation( irp );
    parameters = (PTDI_REQUEST_KERNEL_SENDDG)&irpSp->Parameters;

    irpSp->MajorFunction = IRP_MJ_INTERNAL_DEVICE_CONTROL;
    irpSp->MinorFunction = TDI_SEND_DATAGRAM;

    parameters->SendLength = Length;
    parameters->SendDatagramInformation = SendDatagramInformation;

    //
    // The file system wants direct I/O.  Allocate an MDL and lock the
    // buffer into memory.
    //

    mdl = IoAllocateMdl(
            Buffer,
            Length,
            FALSE,
            FALSE,
            irp     // stores MDL address in irp->MdlAddress
            );

    if ( mdl == NULL ) {

        //
        // Unable to allocate an MDL.  Fail the I/O.
        //

        IoFreeIrp( irp );

        return STATUS_INSUFF_SERVER_RESOURCES;

    }

    try {
        MmProbeAndLockPages( mdl, KernelMode, IoWriteAccess );
    } except( EXCEPTION_EXECUTE_HANDLER ) {
        IoFreeIrp( irp );
        IoFreeMdl( mdl );
        return GetExceptionCode();
    }

    //
    // Start the I/O, wait for it to complete, and return the final
    // status.
    //

    return StartIoAndWait( irp, *DeviceObject, &event, &iosb );

} // SrvIssueSendDatagramRequest


NTSTATUS
SrvIssueSetClientProcessRequest (
    IN PFILE_OBJECT FileObject,
    IN PDEVICE_OBJECT *DeviceObject,
    IN PCONNECTION Connection,
    IN PVOID ClientSession,
    IN PVOID ClientProcess
    )

/*++

Routine Description:

    This function issues an I/O request packet for a named pipe Set
    Client Process file system control function.  It builds an I/O
    request packet, passes the IRP to the driver (using IoCallDriver),
    and waits for the I/O to complete.

Arguments:

    FileObject - pointer to file object for a pipe.

    DeviceObject - pointer to pointer to device object for a pipe.

    ClientSession - A unique identifier for the client's session with
        the server.  Assigned by the server.

    ClientProcess - A unique identifier for the client process.
        Assigned by the redirector.

Return Value:

    NTSTATUS - the status of the operation.  Either the return value of
        IoCallDriver, if the driver didn't accept the request, or the
        value returned by the driver in the I/O status block.

--*/

{
    PIRP irp;
    PIO_STACK_LOCATION irpSp;
    FILE_PIPE_CLIENT_PROCESS_BUFFER_EX clientIdBuffer;
    KEVENT event;
    IO_STATUS_BLOCK iosb;
    UNICODE_STRING unicodeString;
    NTSTATUS status;

    PAGED_CODE( );

    //
    // Set the client ID in the FSCTL buffer.
    //

    clientIdBuffer.ClientSession = ClientSession;
    clientIdBuffer.ClientProcess = ClientProcess;

    // Set ClientComputerName in the buffer
    // The Rtl function terminates the string, so leave enough room

    unicodeString.Buffer = clientIdBuffer.ClientComputerBuffer;
    unicodeString.MaximumLength =
        (USHORT) ((FILE_PIPE_COMPUTER_NAME_LENGTH+1) * sizeof(WCHAR));

    status = RtlOemStringToUnicodeString( &unicodeString,
                                 &Connection->OemClientMachineNameString,
                                 FALSE );
    if (!NT_SUCCESS(status)) {
        // Set length to zero in case conversion fails
        unicodeString.Length = 0;
    }
    clientIdBuffer.ClientComputerNameLength = unicodeString.Length;

    //
    // Allocate an IRP and fill in the service-independent parameters
    // for the request.
    //

    irp = BuildCoreOfSyncIoRequest(
              NULL,
              FileObject,
              &event,
              &iosb,
              DeviceObject
              );

    if ( irp == NULL ) {

        //
        // Unable to allocate an IRP.  Fail the i/o.
        //

        return STATUS_INSUFF_SERVER_RESOURCES;

    }

    //
    // Fill in the service-dependent parameters for the request.
    //

    irpSp = IoGetNextIrpStackLocation( irp );

    irpSp->MajorFunction = IRP_MJ_FILE_SYSTEM_CONTROL;
    irpSp->MinorFunction = IRP_MN_KERNEL_CALL;

    irpSp->Parameters.FileSystemControl.OutputBufferLength = 0;
    irpSp->Parameters.FileSystemControl.InputBufferLength =
                                            sizeof( clientIdBuffer );
    irpSp->Parameters.FileSystemControl.FsControlCode =
                                            FSCTL_PIPE_SET_CLIENT_PROCESS;

    irp->MdlAddress = NULL;
    irp->AssociatedIrp.SystemBuffer = &clientIdBuffer;
    irp->Flags |= IRP_BUFFERED_IO;
    irp->UserBuffer = NULL;

    //
    // Start the I/O, wait for it to complete, and return the final
    // status.
    //

    return StartIoAndWait( irp, *DeviceObject, &event, &iosb );

} // SrvIssueSetClientProcessRequest


NTSTATUS
SrvIssueSetEaRequest (
    IN HANDLE FileHandle,
    IN PVOID Buffer,
    IN ULONG Length,
    OUT PULONG EaErrorOffset OPTIONAL
    )

/*++

Routine Description:

    This function issues an I/O request packet for an EA set request.
    It builds an I/O request packet, passes the IRP to the driver (using
    IoCallDriver), and waits for the I/O to complete.

    WARNING!  The server must walk the list of EAs to set if it
    comes directly from a client.  This is because the file system
    trusts that this list is legitimate and could run into problems
    if the list has an error.

Arguments:

    FileHandle - handle to a file open with FILE_WRITE_EA access.

    Buffer - Supplies the system virtual address of the buffer.  The
        buffer must be in nonpaged pool.

    Length - Supplies the length of the buffer.

    EaErrorOffset - if not NULL, returns the offset into EaList of an
        invalid EA, if any.

Return Value:

    NTSTATUS - the status of the operation.  Either the return value of
        IoCallDriver, if the driver didn't accept the request, or the
        value returned by the driver in the I/O status block.

--*/

{
    NTSTATUS status;
    PIRP irp;
    PIO_STACK_LOCATION irpSp;
    KEVENT event;
    IO_STATUS_BLOCK iosb;
    PDEVICE_OBJECT deviceObject;
    PMDL mdl;

    PAGED_CODE( );

    //
    // Allocate an IRP and fill in the service-independent parameters
    // for the request.
    //

    irp = BuildCoreOfSyncIoRequest(
              FileHandle,
              NULL,
              &event,
              &iosb,
              &deviceObject
              );

    if ( irp == NULL ) {

        //
        // Unable to allocate an IRP.  Fail the i/o.
        //

        return STATUS_INSUFF_SERVER_RESOURCES;

    }

    //
    // Fill in the service-dependent parameters for the request.
    //

    irpSp = IoGetNextIrpStackLocation( irp );
    irpSp->MajorFunction = IRP_MJ_SET_EA;
    irpSp->MinorFunction = 0;

    irpSp->Parameters.SetEa.Length = Length;

    irpSp->Flags = 0;

    //
    // The file system has been updated.  Determine whether the driver
    // wants buffered, direct, or "neither" I/O.
    //

    if ( (deviceObject->Flags & DO_BUFFERED_IO) != 0 ) {

        //
        // The file system wants buffered I/O.  Pass the address of the
        // "system buffer" in the IRP.  Note that we don't want the buffer
        // deallocated, nor do we want the I/O system to copy to a user
        // buffer, so we don't set the corresponding flags in irp->Flags.
        //

        irp->AssociatedIrp.SystemBuffer = Buffer;

    } else if ( (deviceObject->Flags & DO_DIRECT_IO) != 0 ) {

        //
        // The file system wants direct I/O.  Allocate an MDL and lock the
        // buffer into memory.
        //

        mdl = IoAllocateMdl(
                Buffer,
                Length,
                FALSE,
                FALSE,
                irp     // stores MDL address in irp->MdlAddress
                );

        if ( mdl == NULL ) {

            //
            // Unable to allocate an MDL.  Fail the I/O.
            //

            IoFreeIrp( irp );

            return STATUS_INSUFF_SERVER_RESOURCES;

        }

        try {
            MmProbeAndLockPages( mdl, KernelMode, IoWriteAccess );
        } except( EXCEPTION_EXECUTE_HANDLER ) {
            IoFreeIrp( irp );
            IoFreeMdl( mdl );
            return GetExceptionCode();
        }

    } else {

        //
        // The file system wants "neither" I/O.  Simply pass the address
        // of the buffer.
        //
        // *** Note that if the file system decides to do this as buffered
        //     I/O, it will be wasting nonpaged pool, since our buffer is
        //     already in nonpaged pool.  But since we're doing this as a
        //     synchronous request, the file system probably won't do that.
        //

        irp->UserBuffer = Buffer;

    }

    //
    // Start the I/O, wait for it to complete, and return the final
    // status.
    //

    status = StartIoAndWait( irp, deviceObject, &event, &iosb );

    if ( ARGUMENT_PRESENT(EaErrorOffset) ) {
        *EaErrorOffset = (ULONG)iosb.Information;
    }

    return status;

} // SrvIssueSetEaRequest


NTSTATUS
SrvIssueSetEventHandlerRequest (
    IN PFILE_OBJECT FileObject,
    IN PDEVICE_OBJECT *DeviceObject,
    IN ULONG EventType,
    IN PVOID EventHandler,
    IN PVOID EventContext
    )

/*++

Routine Description:

    This function issues an I/O request packet for a TdiSetEventHandler
    request.  It builds an I/O request packet, passes the IRP to the
    driver (using IoCallDriver), and waits for the I/O to complete.

Arguments:

    FileObject - pointer to file object for a connection.

    DeviceObject - pointer to pointer to device object for a connection.

    EventType -

    EventHandler -

    EventContext -

Return Value:

    NTSTATUS - the status of the operation.  Either the return value of
        IoCallDriver, if the driver didn't accept the request, or the
        value returned by the driver in the I/O status block.

--*/

{
    PIRP irp;
    PIO_STACK_LOCATION irpSp;
    PTDI_REQUEST_KERNEL_SET_EVENT parameters;
    KEVENT event;
    IO_STATUS_BLOCK iosb;
    PDEVICE_OBJECT deviceObject = NULL;

    PAGED_CODE( );

    //
    // Allocate an IRP and fill in the service-independent parameters
    // for the request.
    //

    irp = BuildCoreOfSyncIoRequest(
              NULL,
              FileObject,
              &event,
              &iosb,
              DeviceObject
              );

    if ( irp == NULL ) {

        //
        // Unable to allocate an IRP.  Fail the I/O.
        //

        return STATUS_INSUFF_SERVER_RESOURCES;

    }

    //
    // Fill in the service-dependent parameters for the request.
    //

    irpSp = IoGetNextIrpStackLocation( irp );
    parameters = (PTDI_REQUEST_KERNEL_SET_EVENT)&irpSp->Parameters;

    irpSp->MajorFunction = IRP_MJ_INTERNAL_DEVICE_CONTROL;
    irpSp->MinorFunction = TDI_SET_EVENT_HANDLER;

    parameters->EventType = EventType;
    parameters->EventHandler = EventHandler;
    parameters->EventContext = EventContext;

    //
    // Start the I/O, wait for it to complete, and return the final status.
    //

    return StartIoAndWait( irp, *DeviceObject, &event, &iosb );

} // SrvIssueSetEventHandlerRequest


NTSTATUS
SrvIssueUnlockRequest (
    IN PFILE_OBJECT FileObject,
    IN PDEVICE_OBJECT *DeviceObject,
    IN UCHAR UnlockOperation,
    IN LARGE_INTEGER ByteOffset,
    IN LARGE_INTEGER Length,
    IN ULONG Key
    )

/*++

Routine Description:

    This function issues an I/O request packet for an unlock request.
    It builds an I/O request packet, passes the IRP to the driver
    (using IoCallDriver), and waits for the I/O to complete.

Arguments:

    FileObject - Pointer to the file object.

    DeviceObject - Pointer to pointer to the related device object.

    UnlockOperation - the minor function code describing the unlock
        operation -- IRP_MN_UNLOCK_SINGLE or IRP_MN_UNLOCK_ALL_BY_KEY.

    StartingBlock - the block number of the beginning of the locked
        range.  Ignored if UnlockOperation is IRP_MN_UNLOCK_ALL_BY_KEY.

    ByteOffset - the offset within block of the beginning of the locked
        range.  Ignored if UnlockOperation is IRP_MN_UNLOCK_ALL_BY_KEY.

    Length - the length of the locked range.  Ignored if UnlockOperation
        is IRP_MN_UNLOCK_ALL_BY_KEY.

    Key - the key value used to obtain the lock.

Return Value:

    NTSTATUS - the status of the operation.  Either the return value of
        IoCallDriver, if the driver didn't accept the request, or the
        value returned by the driver in the I/O status block.

--*/

{
    PIRP irp;
    PIO_STACK_LOCATION irpSp;
    KEVENT event;
    IO_STATUS_BLOCK iosb;
    PFAST_IO_DISPATCH fastIoDispatch;

    PAGED_CODE( );

    //
    // Try the turbo unlock path first.
    //

    fastIoDispatch = (*DeviceObject)->DriverObject->FastIoDispatch;

    if ( fastIoDispatch != NULL ) {

        if ( (UnlockOperation == IRP_MN_UNLOCK_SINGLE) &&
             (fastIoDispatch->FastIoUnlockSingle != NULL) ) {

            INCREMENT_DEBUG_STAT2( SrvDbgStatistics.FastUnlocksAttempted );
            if ( fastIoDispatch->FastIoUnlockSingle(
                                    FileObject,
                                    &ByteOffset,
                                    &Length,
                                    IoGetCurrentProcess(),
                                    Key,
                                    &iosb,
                                    *DeviceObject
                                    ) ) {
                return iosb.Status;
            }
            INCREMENT_DEBUG_STAT2( SrvDbgStatistics.FastUnlocksFailed );

        } else if ( (UnlockOperation == IRP_MN_UNLOCK_ALL_BY_KEY) &&
                    (fastIoDispatch->FastIoUnlockAllByKey != NULL) ) {

            INCREMENT_DEBUG_STAT2( SrvDbgStatistics.FastUnlocksAttempted );
            if ( fastIoDispatch->FastIoUnlockAllByKey(
                                    FileObject,
                                    IoGetCurrentProcess(),
                                    Key,
                                    &iosb,
                                    *DeviceObject
                                    ) ) {

                return iosb.Status;

            }
            INCREMENT_DEBUG_STAT2( SrvDbgStatistics.FastUnlocksFailed );

        }

    }

    //
    // The turbo path failed or was unavailable.  Allocate an IRP and
    // fill in the service-independent parameters for the request.
    //

    irp = BuildCoreOfSyncIoRequest(
              NULL,
              FileObject,
              &event,
              &iosb,
              DeviceObject
              );

    if ( irp == NULL ) {

        //
        // Unable to allocate an IRP.  Fail the i/o.
        //

        return STATUS_INSUFF_SERVER_RESOURCES;

    }

    //
    // Fill in the service-dependent parameters for the request.
    //

    irpSp = IoGetNextIrpStackLocation( irp );
    irpSp->MajorFunction = IRP_MJ_LOCK_CONTROL;
    irpSp->MinorFunction = UnlockOperation;

    irpSp->Parameters.LockControl.Length = &Length;
    irpSp->Parameters.LockControl.Key = Key;
    irpSp->Parameters.LockControl.ByteOffset = ByteOffset;

    //
    // Start the I/O, wait for it to complete, and return the final
    // status.
    //

    return StartIoAndWait( irp, *DeviceObject, &event, &iosb );

} // SrvIssueUnlockRequest

NTSTATUS
SrvIssueUnlockSingleRequest (
    IN PFILE_OBJECT FileObject,
    IN PDEVICE_OBJECT *DeviceObject,
    IN LARGE_INTEGER ByteOffset,
    IN LARGE_INTEGER Length,
    IN ULONG Key
    )

/*++

Routine Description:

    This function issues an I/O request packet for an unlock single request.
    It builds an I/O request packet, passes the IRP to the driver
    (using IoCallDriver), and waits for the I/O to complete.

Arguments:

    FileObject - Pointer to the file object.

    DeviceObject - Pointer to pointer to the related device object.

    StartingBlock - the block number of the beginning of the locked
        range.  Ignored if UnlockOperation is IRP_MN_UNLOCK_ALL_BY_KEY.

    ByteOffset - the offset within block of the beginning of the locked
        range.  Ignored if UnlockOperation is IRP_MN_UNLOCK_ALL_BY_KEY.

    Length - the length of the locked range.  Ignored if UnlockOperation
        is IRP_MN_UNLOCK_ALL_BY_KEY.

    Key - the key value used to obtain the lock.

Return Value:

    NTSTATUS - the status of the operation.  Either the return value of
        IoCallDriver, if the driver didn't accept the request, or the
        value returned by the driver in the I/O status block.

--*/

{
    PIRP irp;
    PIO_STACK_LOCATION irpSp;
    KEVENT event;
    IO_STATUS_BLOCK iosb;

    PAGED_CODE( );

    //
    // Allocate an IRP and fill in the service-independent
    // parameters for the request.
    //

    irp = BuildCoreOfSyncIoRequest(
              NULL,
              FileObject,
              &event,
              &iosb,
              DeviceObject
              );

    if ( irp == NULL ) {

        //
        // Unable to allocate an IRP.  Fail the i/o.
        //

        return STATUS_INSUFF_SERVER_RESOURCES;

    }

    //
    // Fill in the service-dependent parameters for the request.
    //

    irpSp = IoGetNextIrpStackLocation( irp );
    irpSp->MajorFunction = IRP_MJ_LOCK_CONTROL;
    irpSp->MinorFunction = IRP_MN_UNLOCK_SINGLE;

    irpSp->Parameters.LockControl.Length = &Length;
    irpSp->Parameters.LockControl.Key = Key;
    irpSp->Parameters.LockControl.ByteOffset = ByteOffset;

    //
    // Start the I/O, wait for it to complete, and return the final
    // status.
    //

    return StartIoAndWait( irp, *DeviceObject, &event, &iosb );

} // SrvIssueUnlockSingleRequest


NTSTATUS
SrvIssueWaitForOplockBreak (
    IN HANDLE FileHandle,
    PWAIT_FOR_OPLOCK_BREAK WaitForOplockBreak
    )

/*++

Routine Description:

    This function issues an I/O request packet for a wait for oplock
    break request.

    It builds an I/O request packet, passes the IRP to the driver
    (using IoCallDriver), and waits for the I/O to complete.

Arguments:

    FileHandle - handle to a file.

    WaitForOplockBreak - Context information for this wait for oplock break.

Return Value:

    NTSTATUS - the status of the operation.  Either the return value of
        IoCallDriver, if the driver didn't accept the request, or the
        value returned by the driver in the I/O status block.

--*/

{
    PIRP irp;
    PIO_STACK_LOCATION irpSp;
    KEVENT event;
    IO_STATUS_BLOCK iosb;
    PDEVICE_OBJECT deviceObject;
    NTSTATUS status;
    KIRQL oldIrql;

    PAGED_CODE( );

    //
    // Allocate an IRP and fill in the service-independent parameters
    // for the request.
    //

    irp = BuildCoreOfSyncIoRequest(
              FileHandle,
              NULL,
              &event,
              &iosb,
              &deviceObject
              );

    if (irp == NULL) {

        //
        // Unable to allocate an IRP.  Fail the i/o.
        //

        return STATUS_INSUFF_SERVER_RESOURCES;
    }

    //
    // Fill in the service-dependent parameters for the request.
    //

    irpSp = IoGetNextIrpStackLocation( irp );
    irpSp->MajorFunction = IRP_MJ_FILE_SYSTEM_CONTROL;
    irpSp->MinorFunction = 0;

    irpSp->Parameters.FileSystemControl.OutputBufferLength = 0;
    irpSp->Parameters.FileSystemControl.InputBufferLength = 0;
    irpSp->Parameters.FileSystemControl.FsControlCode =
                                          FSCTL_OPLOCK_BREAK_NOTIFY;

    //
    // Queue the WaitForOplockBreak block on the global list.
    //
    // We must hold the lock that protects wait for oplock breaks
    // from the time we queue this wait for oplock break on the global
    // list, to the time the IRP has actually been submitted.  Otherwise
    // the scavenger might wake up and attempt to cancel an IRP that
    // has not yet been submitted.
    //

    WaitForOplockBreak->Irp = irp;

    ACQUIRE_LOCK( &SrvOplockBreakListLock );

    SrvInsertTailList(
        &SrvWaitForOplockBreakList,
        &WaitForOplockBreak->ListEntry
        );

    //
    // The following code is a duplicate of the code from StartIoAndWait().
    //
    // Start the I/O, wait for it to complete, and return the final
    // status.
    //

    //
    // Queue the IRP to the thread and pass it to the driver.
    //

    IoQueueThreadIrp( irp );

    status = IoCallDriver( deviceObject, irp );

    RELEASE_LOCK( &SrvOplockBreakListLock );

    //
    // If necessary, wait for the I/O to complete.
    //

    if ( status == STATUS_PENDING ) {
        KeWaitForSingleObject(
            &event,
            UserRequest,
            KernelMode, // don't let stack be paged -- event is on stack!
            FALSE,
            NULL
            );
    }

    //
    // If the request was successfully queued, get the final I/O status.
    //

    if ( NT_SUCCESS(status) ) {
       status = iosb.Status;
    }

    return status;

} // SrvIssueWaitForOplockBreak

VOID
SrvQuerySendEntryPoint(
    IN PFILE_OBJECT FileObject,
    IN PDEVICE_OBJECT *DeviceObject,
    IN ULONG IoControlCode,
    IN PVOID *EntryPoint
    )

/*++

Routine Description:

    This function queries the transport for its send entry point.

Arguments:

    FileObject - pointer to file object for a connection.

    DeviceObject - pointer to pointer to device object for a connection.

    EntryPoint -

Return Value:

    NTSTATUS - the status of the operation.  Either the return value of
        IoCallDriver, if the driver didn't accept the request, or the
        value returned by the driver in the I/O status block.

--*/

{
    PIRP irp;
    PIO_STACK_LOCATION irpSp;
    KEVENT event;
    IO_STATUS_BLOCK iosb;
    NTSTATUS status;

    PAGED_CODE( );

    //
    // Allocate an IRP and fill in the service-independent parameters
    // for the request.
    //

    irp = BuildCoreOfSyncIoRequest(
              NULL,
              FileObject,
              &event,
              &iosb,
              DeviceObject
              );

    if ( irp == NULL ) {

        //
        // Unable to allocate an IRP.  Fail the I/O.
        //

        *EntryPoint = NULL;
        return;

    }

    //
    // Fill in the service-dependent parameters for the request.
    //

    irpSp = IoGetNextIrpStackLocation( irp );

    irpSp->MajorFunction = IRP_MJ_DEVICE_CONTROL;
    irpSp->MinorFunction = 0;
    irpSp->Parameters.DeviceIoControl.IoControlCode = IoControlCode;

    irpSp->Parameters.DeviceIoControl.Type3InputBuffer = EntryPoint;

    //
    // Start the I/O, wait for it to complete, and return the final status.
    //

    status = StartIoAndWait( irp, *DeviceObject, &event, &iosb );

    if ( !NT_SUCCESS(status) ) {
        *EntryPoint = NULL;
    }

    return;

} // SrvQuerySendEntryPoint

#ifdef INCLUDE_SMB_IFMODIFIED

NTSTATUS
SrvIssueQueryUsnInfoRequest (
    IN PRFCB Rfcb,
    IN BOOLEAN SubmitClose,
    OUT PLARGE_INTEGER Usn,
    OUT PLARGE_INTEGER FileRefNumber
    )

/*++

Routine Description:

    This function issues an I/O request packet for a USN query or close
    request.  It builds an I/O request packet, passes the IRP to the
    driver (using IoCallDriver), and waits for the I/O to complete.

Arguments:

    Rfcb - pointer to handle that we're querying

    SubmitClose - do we submit a close USN record or just simply a USN query?

    Usn & FileRefNumber - USN record results

Return Value:

    NTSTATUS - the status of the operation.  Either the return value of
        IoCallDriver, if the driver didn't accept the request, or the
        value returned by the driver in the I/O status block.

--*/

{
    PIRP irp = NULL;
    PMDL mdl = NULL;
    PUSN_RECORD usnRecord = NULL;

    PIO_STACK_LOCATION irpSp;
    KEVENT event;
    IO_STATUS_BLOCK iosb;
    PDEVICE_OBJECT deviceObject;
    NTSTATUS status;
    ULONG sizeRequired;

    PAGED_CODE( );

    //
    //  if the share doesn't have a USN log, don't bother with this request
    //

    Usn->QuadPart = 0;
    FileRefNumber->QuadPart = 0;

    if (! Rfcb->Lfcb->TreeConnect->Share->UsnCapable ) {

        return STATUS_SUCCESS;
    }

    deviceObject = Rfcb->Lfcb->DeviceObject;

    //
    // Allocate an IRP and fill in the service-independent parameters
    // for the request.
    //

    irp = BuildCoreOfSyncIoRequest(
              NULL,
              Rfcb->Lfcb->FileObject,
              &event,
              &iosb,
              &deviceObject
              );

    if ( irp == NULL ) {

        //
        // Unable to allocate an IRP.  Fail the I/O.
        //

        status = STATUS_INSUFF_SERVER_RESOURCES;
        goto exitGetUsn;
    }

    // if the client opened the file with the short name, we could end up
    // having a buffer that's woefully too small.   We'll bump the
    // allocation up to a large amount so that we don't have to
    // go back and do it again.

    sizeRequired = MAXIMUM_FILENAME_LENGTH * sizeof(WCHAR);
    sizeRequired += sizeof( USN_RECORD );
    sizeRequired = QuadAlign( sizeRequired );

    usnRecord = ALLOCATE_NONPAGED_POOL( sizeRequired, BlockTypeDataBuffer );

    if ( usnRecord == NULL) {

        IF_DEBUG(ERRORS) {
            KdPrint(( "SrvGetUsnInfoForFile: unable to alloc block of size %u for handle 0x%x\n",
                         sizeRequired, Rfcb->Lfcb->FileObject ));
        }

        status = STATUS_INSUFF_SERVER_RESOURCES;
        goto exitGetUsn;
    }

    //
    // Fill in the service-dependent parameters for the request.
    //

    irpSp = IoGetNextIrpStackLocation( irp );
    irpSp->MajorFunction = IRP_MJ_FILE_SYSTEM_CONTROL;
    irpSp->MinorFunction = 0;

    irpSp->Parameters.FileSystemControl.FsControlCode = SubmitClose ? FSCTL_WRITE_USN_CLOSE_RECORD : FSCTL_READ_FILE_USN_DATA;

    irpSp->Parameters.FileSystemControl.OutputBufferLength = sizeRequired;
    irpSp->Parameters.FileSystemControl.InputBufferLength  = 0;
    irpSp->Parameters.FileSystemControl.Type3InputBuffer = NULL;

    irp->MdlAddress = NULL;
    irp->AssociatedIrp.SystemBuffer = NULL;
    irp->UserBuffer = usnRecord;

    //
    // The file system has been updated.  Determine whether the driver wants
    // buffered, direct, or "neither" I/O.
    //

    if ( (deviceObject->Flags & DO_BUFFERED_IO) != 0 ) {

        //
        // The file system wants buffered I/O.  Pass the address of the
        // "system buffer" in the IRP.  Note that we don't want the buffer
        // deallocated, nor do we want the I/O system to copy to a user
        // buffer, so we don't set the corresponding flags in irp->Flags.
        //

        irp->AssociatedIrp.SystemBuffer = usnRecord;

    } else if ( (deviceObject->Flags & DO_DIRECT_IO) != 0 ) {

        //
        // The file system wants direct I/O.  Allocate an MDL and lock the
        // buffer into memory.
        //

        mdl = IoAllocateMdl(
                usnRecord,
                sizeRequired,
                FALSE,
                FALSE,
                irp     // stores MDL address in irp->MdlAddress
                );

        if ( mdl == NULL ) {

            //
            // Unable to allocate an MDL.  Fail the I/O.
            //

            status = STATUS_INSUFF_SERVER_RESOURCES;
            goto exitGetUsn;
        }

        try {
            MmProbeAndLockPages( mdl, KernelMode, IoWriteAccess );
        } except( EXCEPTION_EXECUTE_HANDLER ) {
            IoFreeIrp( irp );
            MmUnlockPages( mdl );
            IoFreeMdl( mdl );
            irp = NULL;
            status = GetExceptionCode();
            goto exitGetUsn;
        }

    } else {

        //
        // The file system wants "neither" I/O.  Simply pass the address
        // of the buffer.
        //
        // *** Note that if the file system decides to do this as buffered
        //     I/O, it will be wasting nonpaged pool, since our buffer is
        //     already in nonpaged pool.  But since we're doing this as a
        //     synchronous request, the file system probably won't do that.
        //

        irp->UserBuffer = usnRecord;
    }

    //
    // Start the I/O, wait for it to complete, and return the final status.
    //

    status = StartIoAndWait( irp, deviceObject, &event, &iosb );

    irp = NULL; // it was freed by call to IoCallDriver

    if (NT_SUCCESS(status)) {
        status = iosb.Status;
    }
    if (NT_SUCCESS(status)) {

        Usn->QuadPart = usnRecord->Usn;
        FileRefNumber->QuadPart = usnRecord->FileReferenceNumber;

    } else {

        ASSERT( status != STATUS_MORE_PROCESSING_REQUIRED );
        ASSERT( status != STATUS_PENDING );

        IF_DEBUG(ERRORS) {
            KdPrint(( "SrvGetUsnInfoForFile: Query USN info failed: 0x%X for handle %u\n",
                        status, Rfcb->Lfcb->FileObject ));
        }
        if (status == STATUS_JOURNAL_NOT_ACTIVE ||
            status == STATUS_INVALID_DEVICE_REQUEST) {

            Rfcb->Lfcb->TreeConnect->Share->UsnCapable = FALSE;
        }
    }

exitGetUsn:

    if (irp != NULL) {

        IoFreeIrp( irp );
    }

    if ( usnRecord != NULL ) {

        DEALLOCATE_NONPAGED_POOL( usnRecord );
    }

    return status;

} // SrvIssueQueryUsnInfoRequest

#endif  // def INCLUDE_SMB_IFMODIFIED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\srv\fsddisp.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    fsddisp.c

Abstract:

    This module implements the File System Driver for the LAN Manager
    server.

Author:

    David Treadwell (davidtr)    20-May-1990

Revision History:

--*/

#include "precomp.h"
#include "wmikm.h"
#include "fsddisp.tmh"
#pragma hdrstop

#define BugCheckFileId SRV_FILE_FSDDISP

#define CHANGE_HEURISTIC(heuristic) \
            (newValues->HeuristicsChangeMask & SRV_HEUR_ ## heuristic) != 0

// Used for WMI event tracing
//
UNICODE_STRING SrvDeviceName;
UNICODE_STRING SrvRegistryPath;
ULONG          SrvWmiInitialized  = FALSE;
ULONG          SrvWmiEnableLevel  = 0;
ULONG          SrvWmiEnableFlags  = 0;
TRACEHANDLE    LoggerHandle       = 0;

GUID SrvCounterGuid  =  /* f7c3b22a-5992-44d6-968b-d3757dbab6f7 */
{ 0xf7c3b22a, 0x5992, 0x44d6, 0x96, 0x8b, 0xd3, 0x75, 0x7d, 0xba, 0xb6, 0xf7 };
GUID SrvControlGuid  =  /* 3121cf5d-c5e6-4f37-be86-57083590c333 */
{ 0x3121cf5d, 0xc5e6, 0x4f37, 0xbe, 0x86, 0x57, 0x08, 0x35, 0x90, 0xc3, 0x33 };
GUID SrvEventGuid    =  /* e09074ae-0a98-4805-9a41-a8940af97086 */
{ 0xe09074ae, 0x0a98, 0x4805, 0x9a, 0x41, 0xa8, 0x94, 0x0a, 0xf9, 0x70, 0x86 };

WMIGUIDREGINFO SrvPerfGuidList[] =
{
  { & SrvCounterGuid, 1, 0 },
  { & SrvControlGuid, 0,   WMIREG_FLAG_TRACED_GUID
                         | WMIREG_FLAG_TRACE_CONTROL_GUID }
};

#define SrvPerfGuidCount (sizeof(SrvPerfGuidList) / sizeof(WMIGUIDREGINFO))

typedef struct _SRV_WMI_EVENT_TRACE {
    EVENT_TRACE_HEADER EventHeader;
    MOF_FIELD          MofField[3];
} SRV_WMI_EVENT_TRACE, * PSRV_WMI_EVENT_TRACE;

//
// Forward declarations
//

STATIC
NTSTATUS
SrvFsdDispatchFsControl (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PIO_STACK_LOCATION IrpSp
    );

VOID
QueueConfigurationIrp (
    IN PIRP Irp,
    IN PIO_WORKITEM pIoWorkItem
    );

NTSTATUS
SrvQueryWmiRegInfo(
    IN PDEVICE_OBJECT DeviceObject,
    OUT ULONG *RegFlags,
    OUT PUNICODE_STRING InstanceName,
    OUT PUNICODE_STRING *RegistryPath,
    OUT PUNICODE_STRING MofResourceName,
    OUT PDEVICE_OBJECT *Pdo
    );
NTSTATUS
SrvQueryWmiDataBlock(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN ULONG GuidIndex,
    IN ULONG InstanceIndex,
    IN ULONG InstanceCount,
    IN OUT PULONG InstanceLengthArray,
    IN ULONG BufferAvail,
    OUT PUCHAR Buffer
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text( PAGE, SrvFsdDispatch )
#pragma alloc_text( PAGE, SrvFsdDispatchFsControl )
#pragma alloc_text( PAGE, QueueConfigurationIrp )
#pragma alloc_text( PAGE, SrvWmiTraceEvent )
#pragma alloc_text( PAGE, SrvQueryWmiRegInfo )
#pragma alloc_text( PAGE, SrvQueryWmiDataBlock )
#pragma alloc_text( PAGE, SrvWmiDispatch )
#endif

// These 2 routines can be called at DISPATCH_LEVEL, so they are non-paged
// NONPAGED - SrvWmiStartContext
// NONPAGED - SrvWmiEndContext

void
SrvWmiInitContext(
    PWORK_CONTEXT WorkContext
    )
{
    if (! SrvWmiInitialized) {
        return;
    }

    if ( SRV_WMI_LEVEL( SPARSE ) ) {
        WorkContext->PreviousSMB          = EVENT_TYPE_SMB_LAST_EVENT;
        WorkContext->bAlreadyTrace        = FALSE;
        WorkContext->ElapseKCPU           = 0;
        WorkContext->ElapseUCPU           = 0;
        WorkContext->FileNameSize         = 0;
        WorkContext->ClientAddr           = 0;
        WorkContext->FileObject           = NULL;
        WorkContext->G_StartTime.QuadPart =
                        (ULONGLONG) WmiGetClock(WMICT_DEFAULT, NULL);
    }
}

void
SrvWmiStartContext(
    PWORK_CONTEXT   WorkContext
    )
{
    LARGE_INTEGER ThreadTime;

    if (! SrvWmiInitialized) {
        return;
    }

    if ( SRV_WMI_LEVEL( SPARSE ) ) {
        if (WorkContext->G_StartTime.QuadPart == 0) {
            WorkContext->G_StartTime.QuadPart =
                            (ULONGLONG) WmiGetClock(WMICT_DEFAULT, NULL);
        }
    }

    if ( SRV_WMI_LEVEL( VERBOSE ) ) {
        ThreadTime.QuadPart    = (ULONGLONG) WmiGetClock(WMICT_THREAD, NULL);
        WorkContext->KCPUStart = ThreadTime.HighPart;
        WorkContext->UCPUStart = ThreadTime.LowPart;
    }
}

void
SrvWmiEndContext(
    PWORK_CONTEXT   WorkContext
    )
{
    LARGE_INTEGER     TimeEnd;
    BOOL NotDispatch = (KeGetCurrentIrql() < DISPATCH_LEVEL);

    if (! SrvWmiInitialized) {
        return;
    }

    if ( SRV_WMI_LEVEL( SPARSE ) ) {
        if ( NotDispatch && WorkContext && WorkContext->Rfcb && WorkContext->Rfcb->Lfcb) {
            WorkContext->FileObject = WorkContext->Rfcb->Lfcb->FileObject;
        }
    }

    if ( (SrvWmiEnableFlags == SRV_WMI_FLAG_CAPACITY) && SRV_WMI_LEVEL( VERBOSE ) ) {
        TimeEnd.QuadPart        = (ULONGLONG) WmiGetClock(WMICT_THREAD, NULL);
        WorkContext->ElapseKCPU = TimeEnd.HighPart - WorkContext->KCPUStart;
        WorkContext->ElapseUCPU = TimeEnd.LowPart  - WorkContext->UCPUStart;

        if( NotDispatch )
        {
            if (WorkContext && WorkContext->Rfcb
                            && WorkContext->Rfcb->Lfcb
                            && WorkContext->Rfcb->Lfcb->Mfcb
                            && WorkContext->Rfcb->Lfcb->Mfcb->FileName.Buffer
                            && WorkContext->Rfcb->Lfcb->Mfcb->FileName.Length > 0)
            {
                LPWSTR strFileName = WorkContext->Rfcb->Lfcb->Mfcb->FileName.Buffer;
                WorkContext->FileNameSize =
                        (USHORT) ((wcslen(strFileName) + 1) * sizeof(WCHAR));
                if (WorkContext->FileNameSize > 1024 * sizeof(WCHAR)) {
                    WorkContext->FileNameSize = 1024 * sizeof(WCHAR);
                }
                RtlCopyMemory(WorkContext->strFileName,
                              strFileName,
                              WorkContext->FileNameSize);
                WorkContext->strFileName[1023] = L'\0';
            }
        }
        else
        {
            WorkContext->strFileName[0] = L'\0';
        }
    }
}

void
SrvWmiTraceEvent(
    PWORK_CONTEXT WorkContext
    )
{

    PAGED_CODE();

    if (! SrvWmiInitialized) {
        return;
    }

    if ( (SrvWmiEnableFlags == SRV_WMI_FLAG_CAPACITY) && SRV_WMI_LEVEL( SPARSE ) ) {
        NTSTATUS             status;
        SRV_WMI_EVENT_TRACE  Wnode;

        if (WorkContext->PreviousSMB >= EVENT_TYPE_SMB_LAST_EVENT) {
            return;
        }

        if (WorkContext->Connection->DirectHostIpx) {
            WorkContext->ClientAddr =
                    WorkContext->Connection->IpxAddress.NetworkAddress;
        }
        else {
            WorkContext->ClientAddr =
                    WorkContext->Connection->ClientIPAddress;
        }

        RtlZeroMemory(& Wnode, sizeof(SRV_WMI_EVENT_TRACE));
        if (WorkContext->FileNameSize > 0) {
            Wnode.EventHeader.Size = sizeof(SRV_WMI_EVENT_TRACE);
        }
        else {
            Wnode.EventHeader.Size = sizeof(EVENT_TRACE_HEADER)
                                   + sizeof(MOF_FIELD);
        }
        Wnode.EventHeader.Flags      = WNODE_FLAG_TRACED_GUID
                                     | WNODE_FLAG_USE_GUID_PTR
                                     | WNODE_FLAG_USE_MOF_PTR;
        Wnode.EventHeader.GuidPtr    = (ULONGLONG) & SrvEventGuid;
        Wnode.EventHeader.Class.Type = WorkContext->PreviousSMB;

        ((PWNODE_HEADER) (& Wnode.EventHeader))->HistoricalContext =
                        LoggerHandle;

        Wnode.MofField[0].Length  = sizeof(LARGE_INTEGER) // G_StartTime
                                  + sizeof(ULONG)         // ElapseKCPU
                                  + sizeof(ULONG)         // ElapseUCPU
                                  + sizeof(ULONG)         // ClientAddr
                                  + sizeof(PFILE_OBJECT); // FileObject
        Wnode.MofField[0].DataPtr = (ULONGLONG) (& WorkContext->G_StartTime);

        if (WorkContext->FileNameSize > 0) {
            Wnode.MofField[1].Length  = sizeof(USHORT);
            Wnode.MofField[1].DataPtr =
                            (ULONGLONG) (& WorkContext->FileNameSize);
            Wnode.MofField[2].Length  = WorkContext->FileNameSize;
            Wnode.MofField[2].DataPtr =
                            (ULONGLONG) (WorkContext->strFileName);
        }

        // Call TraceLogger to  write this event
        //
        status = IoWMIWriteEvent((PVOID) & Wnode);
        if (!NT_SUCCESS(status)) {
            DbgPrint("SrvWmiTraceEvent(0x%08X,%d) fails 0x%08X\n",
                            WorkContext, WorkContext->PreviousSMB, status);
        }
    }
}

NTSTATUS
SrvQueryWmiRegInfo(
    IN PDEVICE_OBJECT DeviceObject,
    OUT ULONG *RegFlags,
    OUT PUNICODE_STRING InstanceName,
    OUT PUNICODE_STRING *RegistryPath,
    OUT PUNICODE_STRING MofResourceName,
    OUT PDEVICE_OBJECT *Pdo
    )
/*++

Routine Description:

    This routine is a callback into the driver to retrieve information about
    the guids being registered.

    Implementations of this routine may be in paged memory

Arguments:

    DeviceObject is the device whose registration information is needed

    *RegFlags returns with a set of flags that describe all of the guids being
        registered for this device. If the device wants enable and disable
        collection callbacks before receiving queries for the registered
        guids then it should return the WMIREG_FLAG_EXPENSIVE flag. Also the
        returned flags may specify WMIREG_FLAG_INSTANCE_PDO in which case
        the instance name is determined from the PDO associated with the
        device object. Note that the PDO must have an associated devnode. If
        WMIREG_FLAG_INSTANCE_PDO is not set then Name must return a unique
        name for the device. These flags are ORed into the flags specified
        by the GUIDREGINFO for each guid.

    InstanceName returns with the instance name for the guids if
        WMIREG_FLAG_INSTANCE_PDO is not set in the returned *RegFlags. The
        caller will call ExFreePool with the buffer returned.

    *RegistryPath returns with the registry path of the driver. This is
        required

    MofResourceName returns with the name of the MOF resource attached to
        the binary file. If the driver does not have a mof resource attached
        then this can be returned unmodified. If a value is returned then
        it is NOT freed.
        The MOF file is assumed to be already included in wmicore.mof

    *Pdo returns with the device object for the PDO associated with this
        device if the WMIREG_FLAG_INSTANCE_PDO flag is retured in
        *RegFlags.

Return Value:

    status

--*/
{
    PDEVICE_EXTENSION pDeviceExtension = (PDEVICE_EXTENSION)
                                         DeviceObject->DeviceExtension;
    PAGED_CODE();

    if (! SrvWmiInitialized) {
        return STATUS_DEVICE_NOT_READY;
    }

    pDeviceExtension->TestCounter ++;

    * RegFlags     = WMIREG_FLAG_EXPENSIVE;
    InstanceName->MaximumLength = SrvDeviceName.Length
                                + sizeof(UNICODE_NULL);
    InstanceName->Buffer = ExAllocatePool(PagedPool,
                                          InstanceName->MaximumLength);
    if (InstanceName->Buffer != NULL) {
        InstanceName->Length = InstanceName->MaximumLength
                             - sizeof(UNICODE_NULL);
        RtlCopyUnicodeString(InstanceName, & SrvDeviceName);
    }
    else {
        InstanceName->MaximumLength = InstanceName->Length = 0;
    }

    MofResourceName->MaximumLength = 0;
    MofResourceName->Length        = 0;
    MofResourceName->Buffer        = NULL;

    * RegistryPath = & SrvRegistryPath;

    return STATUS_SUCCESS;
}

NTSTATUS
SrvQueryWmiDataBlock(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN ULONG GuidIndex,
    IN ULONG InstanceIndex,
    IN ULONG InstanceCount,
    IN OUT PULONG InstanceLengthArray,
    IN ULONG BufferAvail,
    OUT PUCHAR Buffer
    )
/*++

Routine Description:

    This routine is a callback into the driver to query for the contents of
    all instances of a data block. When the driver has finished filling the
    data block it must call WmiCompleteRequest to complete the irp. The
    driver can return STATUS_PENDING if the irp cannot be completed
    immediately.

Arguments:

    DeviceObject is the device whose data block is being queried

    Irp is the Irp that makes this request

    GuidIndex is the index into the list of guids provided when the
        device registered

    InstanceCount is the number of instnaces expected to be returned for
        the data block.

    InstanceLengthArray is a pointer to an array of ULONG that returns the
        lengths of each instance of the data block. If this is NULL then
        there was not enough space in the output buffer to fufill the request
        so the irp should be completed with the buffer needed.

    BufferAvail on entry has the maximum size available to write the data
        blocks.

    Buffer on return is filled with the returned data blocks. Note that each
        instance of the data block must be aligned on a 8 byte boundry.


Return Value:

    status

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    PDEVICE_EXTENSION pDeviceExtension = (PDEVICE_EXTENSION)
                                         DeviceObject->DeviceExtension;
    ULONG SizeNeeded = sizeof(ULONG);

    PAGED_CODE();

    if (! SrvWmiInitialized) {
        return STATUS_DEVICE_NOT_READY;
    }

    pDeviceExtension->TestCounter ++;

    if (GuidIndex == 0) {
        * InstanceLengthArray = SizeNeeded;
        * ((PULONG) Buffer)   = pDeviceExtension->TestCounter;
    }
    else {
        Status = STATUS_WMI_GUID_NOT_FOUND;
    }

    Status = WmiCompleteRequest(DeviceObject,
                                Irp,
                                Status,
                                SizeNeeded,
                                IO_NO_INCREMENT);
    return Status;
}

NTSTATUS
SrvWmiDispatch(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
{
    PIO_STACK_LOCATION irpSp      = IoGetCurrentIrpStackLocation(Irp);
    ULONG              BufferSize = irpSp->Parameters.WMI.BufferSize;
    PVOID              Buffer     = irpSp->Parameters.WMI.Buffer;
    ULONG              ReturnSize = 0;
    NTSTATUS           Status     = STATUS_SUCCESS;
    PWNODE_HEADER      pWnode     = NULL;
    PDEVICE_EXTENSION  pDeviceExtension = (PDEVICE_EXTENSION)
                                          DeviceObject->DeviceExtension;
    SYSCTL_IRP_DISPOSITION disposition;

    PAGED_CODE();

    switch (irpSp->MinorFunction) {
    case IRP_MN_ENABLE_EVENTS:
        pWnode = (PWNODE_HEADER) Buffer;
        if (BufferSize >= sizeof(WNODE_HEADER)) {
            LoggerHandle = pWnode->HistoricalContext;
            InterlockedExchange(& SrvWmiEnableLevel,
                    ((PTRACE_ENABLE_CONTEXT) (& LoggerHandle))->Level + 1);
            InterlockedExchange(& SrvWmiEnableFlags,
                    ((PTRACE_ENABLE_CONTEXT) (& LoggerHandle))->EnableFlags );
        }
        Irp->IoStatus.Status      = Status;
        Irp->IoStatus.Information = ReturnSize;
        IoCompleteRequest(Irp, IO_NO_INCREMENT);
        break;

    case IRP_MN_DISABLE_EVENTS:
        InterlockedExchange(& SrvWmiEnableLevel, 0);
        LoggerHandle = 0;
        Irp->IoStatus.Status      = Status;
        Irp->IoStatus.Information = ReturnSize;
        IoCompleteRequest(Irp, IO_NO_INCREMENT);
        break;

    default:
        Status = WmiSystemControl(& pDeviceExtension->WmiLibContext,
                                    DeviceObject,
                                    Irp,
                                  & disposition);
        switch(disposition) {
        case IrpProcessed:
            break;

        case IrpNotCompleted:
            IoCompleteRequest(Irp, IO_NO_INCREMENT);
            break;

        case IrpForward:
        case IrpNotWmi:
        default:
            ASSERT(FALSE);
            Irp->IoStatus.Status = Status = STATUS_NOT_SUPPORTED;
            IoCompleteRequest(Irp, IO_NO_INCREMENT);
            break;
        }
        break;
    }
    return Status;
}


NTSTATUS
SrvFsdDispatch (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This is the dispatch routine for the LAN Manager server FSD.  At the
    present time, the server FSD does not accept any I/O requests.

Arguments:

    DeviceObject - Pointer to device object for target device

    Irp - Pointer to I/O request packet

Return Value:

    NTSTATUS -- Indicates whether the request was successfully queued.

--*/

{
    NTSTATUS status = STATUS_SUCCESS;
    PIO_STACK_LOCATION irpSp;
    PIO_WORKITEM pWorkItem;

    PAGED_CODE( );

    DeviceObject;   // prevent compiler warnings

    if( SrvSvcProcess == NULL &&
        SeSinglePrivilegeCheck( SeExports->SeLoadDriverPrivilege, Irp->RequestorMode ) ) {

        //
        // This is the first fsctl to the server from a process having
        //  driver load/unload privileges -- it must be from
        //  the service controller.  Remember the process id of the
        //  service controller to validate future fsctls
        //

        SrvSvcProcess = IoGetCurrentProcess();
    }

    irpSp = IoGetCurrentIrpStackLocation( Irp );

#if defined( _WIN64 )
    // There is no reason for us to support downlevel clients because all communication with the
    // server (that is not network packets) goes through the Server Service via RPC resulting in
    // it being serialized and interpreted correctly.  If we get IOCTL's called directly, it must
    // be a hack attempt, so we're free to turn it away.
    if ( IoIs32bitProcess( Irp ) )
    {
        status = STATUS_NOT_SUPPORTED;
        Irp->IoStatus.Status = status;
        IoCompleteRequest( Irp, 2 );
        return status;
    }
#endif

    switch ( irpSp->MajorFunction ) {

    case IRP_MJ_CREATE:

        FsRtlEnterFileSystem();
        ACQUIRE_LOCK( &SrvConfigurationLock );

        do {

            if( SrvOpenCount == 0 ) {
                //
                // This is the first open.  Let's not allow it if the server
                // seems to be in a weird state.
                //
                if( SrvFspActive != FALSE || SrvFspTransitioning != FALSE ) {
                    //
                    // How can this be?  Better not let anybody in, since we're sick
                    //
                    status = STATUS_ACCESS_DENIED;
                    break;
                }

            } else if( SrvFspActive && SrvFspTransitioning ) {
                //
                // We currently have some open handles, but
                // we are in the middle of terminating. Don't let new
                // opens in
                //
                status = STATUS_ACCESS_DENIED;
                break;
            }

            SrvOpenCount++;

        } while( 0 );

        RELEASE_LOCK( &SrvConfigurationLock );
        FsRtlExitFileSystem();

        break;

    case IRP_MJ_CLEANUP:

        //
        // Stop SmbTrace if the one closing is the client who started it.
        //

        SmbTraceStop( irpSp->FileObject, SMBTRACE_SERVER );
        break;

    case IRP_MJ_CLOSE:
        FsRtlEnterFileSystem();
        ACQUIRE_LOCK( &SrvConfigurationLock );
        if( --SrvOpenCount == 0 ) {
            if( SrvFspActive && !SrvFspTransitioning ) {
                //
                // Uh oh.  This is our last close, and we think
                //  we're still running.  We can't run sensibly
                //  without srvsvc to help out.  Suicide time!
                //
                pWorkItem = IoAllocateWorkItem( SrvDeviceObject );
                if( !pWorkItem )
                {
                    status = STATUS_INSUFFICIENT_RESOURCES;
                    RELEASE_LOCK( &SrvConfigurationLock );
                    FsRtlExitFileSystem();
                    goto exit;
                }

                SrvXsActive = FALSE;
                SrvFspTransitioning = TRUE;
                IoMarkIrpPending( Irp );
                QueueConfigurationIrp( Irp, pWorkItem );
                RELEASE_LOCK( &SrvConfigurationLock );
                status = STATUS_PENDING;
                FsRtlExitFileSystem();
                goto exit;
            }
        }
        RELEASE_LOCK( &SrvConfigurationLock );
        FsRtlExitFileSystem();
        break;

    case IRP_MJ_FILE_SYSTEM_CONTROL:

        status = SrvFsdDispatchFsControl( DeviceObject, Irp, irpSp );
        goto exit;

    case IRP_MJ_SYSTEM_CONTROL:
        if (SrvWmiInitialized) {
            status = SrvWmiDispatch(DeviceObject, Irp);
            goto exit;
        }
        // else fall through default processing
        //

    default:

        IF_DEBUG(ERRORS) {
            SrvPrint1(
                "SrvFsdDispatch: Invalid major function %lx\n",
                irpSp->MajorFunction
                );
        }
        status = STATUS_NOT_IMPLEMENTED;
        break;
    }

    Irp->IoStatus.Status = status;
    IoCompleteRequest( Irp, 2 );

exit:

    return status;

} // SrvFsdDispatch


NTSTATUS
SrvFsdDispatchFsControl (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PIO_STACK_LOCATION IrpSp
    )

/*++

Routine Description:

    This routine handles device IO control requests to the server,
    including starting the server, stopping the server, and more.

Arguments:

    DeviceObject - Pointer to device object for target device

    Irp - Pointer to I/O request packet

    IrpSp - Pointer to the current IRP stack location

Return Value:

    NTSTATUS -- Indicates whether the request was successfully handled.

--*/

{
    NTSTATUS status;
    ULONG code;
    PIO_WORKITEM pWorkItem;

    DeviceObject;   // prevent compiler warnings

    //
    // Initialize the I/O status block.
    //

    Irp->IoStatus.Status = STATUS_PENDING;
    Irp->IoStatus.Information = 0;

    FsRtlEnterFileSystem();

    //
    // Process the request if possible.
    //

    code = IrpSp->Parameters.FileSystemControl.FsControlCode;

    //
    // Only the serice controller can issue most of the FSCTL requests.
    //
    if( Irp->RequestorMode != KernelMode &&
        IoGetCurrentProcess() != SrvSvcProcess ) {

        if( code != FSCTL_SRV_SEND_DATAGRAM &&
            code != FSCTL_SRV_GET_QUEUE_STATISTICS &&
            code != FSCTL_SRV_GET_STATISTICS &&
            code != FSCTL_SRV_IPX_SMART_CARD_START &&
            code != FSCTL_SRV_SHARE_STATE_CHANGE &&
            code != FSCTL_SRV_GET_CHALLENGE &&
            code != FSCTL_SRV_START_SMBTRACE &&
            code != FSCTL_SRV_SMBTRACE_FREE_SMB &&
            code != FSCTL_SRV_END_SMBTRACE &&
            code != FSCTL_SRV_INTERNAL_TEST_REAUTH) {

            status = STATUS_ACCESS_DENIED;
            goto exit_without_lock;
        }
    }

    //
    // Acquire the configuration lock.
    //
    ACQUIRE_LOCK( &SrvConfigurationLock );

    switch ( code ) {

    case FSCTL_SRV_STARTUP: {

        PSERVER_REQUEST_PACKET srp;
        ULONG srpLength;
        PVOID inputBuffer;
        ULONG inputBufferLength;

        PDEVICE_EXTENSION pDeviceExtension;
        PWMILIB_CONTEXT   pWmiLibContext;

        //
        // Get a pointer to the SRP that describes the set info request
        // for the startup server configuration, and the buffer that
        // contains this information.
        //

        srp = IrpSp->Parameters.FileSystemControl.Type3InputBuffer;
        srpLength = IrpSp->Parameters.FileSystemControl.InputBufferLength;
        inputBuffer = Irp->UserBuffer;
        inputBufferLength = IrpSp->Parameters.FileSystemControl.OutputBufferLength;

        //
        // If the server FSP is already started, or is in the process of
        // starting up, reject this request.
        //

        if ( SrvFspActive || SrvFspTransitioning ) {

            //IF_DEBUG(ERRORS) {
            //    SrvPrint0( "LAN Manager server FSP already started.\n" );
            //}

            srp->ErrorCode = NERR_ServiceInstalled;
            status = STATUS_SUCCESS;
            goto exit_with_lock;
        }

        //
        // Make sure that the buffer was large enough to be an SRP.
        //

        if ( srpLength < sizeof(SERVER_REQUEST_PACKET) ) {
            status = STATUS_INVALID_PARAMETER;
            goto exit_with_lock;
        }

        //
        // If a domain name was specified in the SRP, the buffer field
        // contains an offset rather than a pointer.  Convert the offset
        // to a pointer and verify that that it is a legal pointer.
        //

        OFFSET_TO_POINTER( srp->Name1.Buffer, srp );

        if ( !POINTER_IS_VALID( srp->Name1.Buffer, srp, srpLength ) ) {

            status = STATUS_ACCESS_VIOLATION;
            goto exit_with_lock;
        }

        //
        // If a server name was specified in the SRP, the buffer field
        // contains an offset rather than a pointer.  Convert the offset
        // to a pointer and verify that that it is a legal pointer.
        //

        OFFSET_TO_POINTER( srp->Name2.Buffer, srp );

        if ( !POINTER_IS_VALID( srp->Name2.Buffer, srp, srpLength ) ) {

            status = STATUS_ACCESS_VIOLATION;
            goto exit_with_lock;
        }

        //
        // Call SrvNetServerSetInfo to set the initial server configuration
        // information.
        //

        status = SrvNetServerSetInfo(
                     srp,
                     inputBuffer,
                     inputBufferLength
                     );

        //
        // Indicate that the server is starting up.  This prevents
        // further startup requests from being issued.
        //

        SrvFspTransitioning = TRUE;

        // Setup device extension for Perf counter registration and register
        // with WMI here
        //
        pDeviceExtension = (PDEVICE_EXTENSION) SrvDeviceObject->DeviceExtension;
        RtlZeroMemory(pDeviceExtension, sizeof(DEVICE_EXTENSION));
        pDeviceExtension->pDeviceObject = SrvDeviceObject;

        pWmiLibContext = & pDeviceExtension->WmiLibContext;
        RtlZeroMemory(pWmiLibContext, sizeof(WMILIB_CONTEXT));
        pWmiLibContext->GuidCount         = SrvPerfGuidCount;
        pWmiLibContext->GuidList          = SrvPerfGuidList;
        pWmiLibContext->QueryWmiDataBlock = SrvQueryWmiDataBlock;
        pWmiLibContext->QueryWmiRegInfo   = SrvQueryWmiRegInfo;

        SrvWmiInitialized = TRUE;
        status = IoWMIRegistrationControl(
                        SrvDeviceObject, WMIREG_ACTION_REGISTER);
        if (!NT_SUCCESS(status)) {
            DbgPrint("SRV: Failed to register for WMI support\n");
        }

        break;
    }

    case FSCTL_SRV_SHUTDOWN: {

        //
        // If the server is not running, or if it is in the process
        // of shutting down, ignore this request.
        //

        if ( !SrvFspActive || SrvFspTransitioning ) {

            //
            // If there is more than one handle open to the server
            // device (i.e., any handles other than the server service's
            // handle), return a special status code to the caller (who
            // should be the server service).  This tells the caller to
            // NOT unload the driver, in order prevent weird situations
            // where the driver is sort of unloaded, so it can't be used
            // but also can't be reloaded, thus preventing the server
            // from being restarted.
            //

            if ( SrvOpenCount != 1 ) {
                status = STATUS_SERVER_HAS_OPEN_HANDLES;
            } else {
                status = STATUS_SUCCESS;
            }

            goto exit_with_lock;

        }

        if (SrvWmiInitialized) {
            // Deregister WMI
            //
            SrvWmiInitialized = FALSE;
            IoWMIRegistrationControl(SrvDeviceObject, WMIREG_ACTION_DEREGISTER);
        }
        //
        // Indicate that the server is shutting down.  This prevents
        // further requests from being issued until the server is
        // restarted.
        //

        SrvFspTransitioning = TRUE;

        //
        // If SmbTrace is running, stop it.
        //

        SmbTraceStop( NULL, SMBTRACE_SERVER );

        break;
    }

    case FSCTL_SRV_REGISTRY_CHANGE:
    case FSCTL_SRV_BEGIN_PNP_NOTIFICATIONS:
    case FSCTL_SRV_XACTSRV_CONNECT:
    {
        if( !SrvFspActive || SrvFspTransitioning ) {
            //IF_DEBUG(ERRORS) {
            //    SrvPrint0( "LAN Manager server FSP not started.\n" );
            //}
            status = STATUS_SERVER_NOT_STARTED;
            goto exit_with_lock;
        }
        break;
    }
    case FSCTL_SRV_XACTSRV_DISCONNECT: {

        //
        // If the server is not running, or if it is in the process
        // of shutting down, ignore this request.
        //

        if ( !SrvFspActive || SrvFspTransitioning ) {

            //IF_DEBUG(ERRORS) {
            //    SrvPrint0( "LAN Manager server FSP not started.\n" );
            //}

            status = STATUS_SUCCESS;
            goto exit_with_lock;
        }

        break;
    }

    case FSCTL_SRV_IPX_SMART_CARD_START: {

        //
        // If the server is not running, or if it is in the process of
        //  shutting down, ignore this request.
        //
        if( !SrvFspActive || SrvFspTransitioning ) {
            status = STATUS_SERVER_NOT_STARTED;
            goto exit_with_lock;
        }

        //
        // Make sure the caller is a driver
        //
        if( Irp->RequestorMode != KernelMode ) {
            status = STATUS_ACCESS_DENIED;
            goto exit_with_lock;
        }

        //
        // Make sure the buffer is big enough
        //
        if( IrpSp->Parameters.FileSystemControl.InputBufferLength <
            sizeof( SrvIpxSmartCard ) ) {

            status = STATUS_BUFFER_TOO_SMALL;
            goto exit_with_lock;
        }

        if( SrvIpxSmartCard.Open == NULL ) {

            PSRV_IPX_SMART_CARD pSipx;

            //
            // Load up the pointers
            //

            pSipx = (PSRV_IPX_SMART_CARD)(Irp->AssociatedIrp.SystemBuffer);

            if( pSipx == NULL ) {
                status = STATUS_INVALID_PARAMETER;
                goto exit_with_lock;
            }

            if( pSipx->Read && pSipx->Close && pSipx->DeRegister && pSipx->Open ) {

                IF_DEBUG( SIPX ) {
                    KdPrint(( "Accepting entry points for IPX Smart Card:\n" ));
                    KdPrint(( "    Open %p, Read %p, Close %p, DeRegister %p",
                                SrvIpxSmartCard.Open,
                                SrvIpxSmartCard.Read,
                                SrvIpxSmartCard.Close,
                                SrvIpxSmartCard.DeRegister
                            ));
                }

                //
                // First set our entry point
                //
                pSipx->ReadComplete = SrvIpxSmartCardReadComplete;

                //
                // Now accept the card's entry points.
                //
                SrvIpxSmartCard.Read = pSipx->Read;
                SrvIpxSmartCard.Close= pSipx->Close;
                SrvIpxSmartCard.DeRegister = pSipx->DeRegister;
                SrvIpxSmartCard.Open = pSipx->Open;

                status = STATUS_SUCCESS;
            } else {
                status = STATUS_INVALID_PARAMETER;
            }

        } else {

            status = STATUS_DEVICE_ALREADY_ATTACHED;
        }

        goto exit_with_lock;

        break;
    }

    case FSCTL_SRV_SEND_DATAGRAM:
    {
        PVOID systemBuffer;
        ULONG systemBufferLength;
        PVOID buffer1;
        ULONG buffer1Length;
        PVOID buffer2;
        ULONG buffer2Length;
        PSERVER_REQUEST_PACKET srp;

        //
        // Ignore this request if the server is not active.
        //

        if ( !SrvFspActive || SrvFspTransitioning ) {
            status = STATUS_SUCCESS;
            goto exit_with_lock;
        }


        //
        // Determine the input buffer lengths, and make sure that the
        // first buffer is large enough to be an SRP.
        //

        buffer1Length = IrpSp->Parameters.FileSystemControl.InputBufferLength;
        buffer2Length = IrpSp->Parameters.FileSystemControl.OutputBufferLength;

        //
        // Make sure that the buffer was large enough to be a SRP.
        //
        if ( buffer1Length < sizeof(SERVER_REQUEST_PACKET) ) {
            status = STATUS_INVALID_PARAMETER;
            goto exit_with_lock;
        }

        // Make sure the lengths are nominally reasonable.
        //
        if( buffer1Length >= MAXUSHORT ||
            buffer2Length >= MAXUSHORT ) {

            status = STATUS_INVALID_PARAMETER;
            goto exit_with_lock;
        }

        //
        // Make the first buffer size is properly aligned so that the second
        // buffer will be aligned as well.
        //

        buffer1Length = ALIGN_UP( buffer1Length, PVOID );
        systemBufferLength = buffer1Length + buffer2Length;

        //
        // Make sure the lengths are nominally reasonable.
        //
        if( buffer1Length >= MAXUSHORT ||
            buffer2Length >= MAXUSHORT ||
            systemBufferLength == 0 ) {

            status = STATUS_INVALID_PARAMETER;
            goto exit_with_lock;
        }

        if( Irp->RequestorMode != KernelMode ) {
            try {

                ProbeForRead( IrpSp->Parameters.FileSystemControl.Type3InputBuffer,
                              buffer1Length, sizeof( CHAR )
                            );

                if( buffer2Length ) {
                    ProbeForRead( Irp->UserBuffer, buffer2Length, sizeof( CHAR ) );
                }

            } except( EXCEPTION_EXECUTE_HANDLER ) {
                status = GetExceptionCode();
                goto exit_with_lock;
            }
        }

        //
        // Allocate a single buffer that will hold both input buffers.
        //

        systemBuffer = ExAllocatePoolWithTagPriority( PagedPool, systemBufferLength, BlockTypeMisc, LowPoolPriority );

        if ( systemBuffer == NULL ) {
            status = STATUS_INSUFF_SERVER_RESOURCES;
            goto exit_with_lock;
        }

        buffer1 = systemBuffer;
        buffer2 = (PCHAR)systemBuffer + buffer1Length;

        //
        // Copy the information into the buffers.
        //

        try {

            RtlCopyMemory(
                buffer1,
                IrpSp->Parameters.FileSystemControl.Type3InputBuffer,
                IrpSp->Parameters.FileSystemControl.InputBufferLength
                );
            if ( buffer2Length > 0 ) {
                RtlCopyMemory( buffer2, Irp->UserBuffer, buffer2Length );
            }

        } except( EXCEPTION_EXECUTE_HANDLER ) {
            status = GetExceptionCode();
            ExFreePool( buffer1 );
            goto exit_with_lock;
        }

        //
        // If a name was specified in the SRP, the buffer field will
        // contain an offset rather than a pointer.  Convert the offset
        // to a pointer and verify that that it is a legal pointer.
        //

        srp = buffer1;

        OFFSET_TO_POINTER( srp->Name1.Buffer, srp );

        if ( !POINTER_IS_VALID( srp->Name1.Buffer, srp, buffer1Length ) ) {
            status = STATUS_ACCESS_VIOLATION;
            ExFreePool( buffer1 );
            goto exit_with_lock;
        }

        OFFSET_TO_POINTER( srp->Name2.Buffer, srp );

        if ( !POINTER_IS_VALID( srp->Name2.Buffer, srp, buffer1Length ) ) {
            status = STATUS_ACCESS_VIOLATION;
            ExFreePool( buffer1 );
            goto exit_with_lock;
        }

        Irp->AssociatedIrp.SystemBuffer = systemBuffer;

        break;
    }

    case FSCTL_SRV_SHARE_STATE_CHANGE:
    {
        ULONG srpLength;
        PSERVER_REQUEST_PACKET srp;
        PSHARE share;

        if ( !SrvFspActive || SrvFspTransitioning ) {
            status = STATUS_SUCCESS;
            goto exit_with_lock;
        }

        srp = Irp->AssociatedIrp.SystemBuffer;
        srpLength = IrpSp->Parameters.FileSystemControl.InputBufferLength;

        //
        // Make sure that the buffer was large enough to be a SRP.
        //

        if ( srpLength < sizeof(SERVER_REQUEST_PACKET) ||
             srp->Name1.Length == 0) {

            status = STATUS_INVALID_PARAMETER;
            goto exit_with_lock;
        }

        //
        // Adjust the buffer pointer to the srp address
        //
        (ULONG_PTR) (srp->Name1.Buffer) += (ULONG_PTR) srp;

        if( (PCHAR) (srp->Name1.Buffer) < (PCHAR) srp ||
            srp->Name1.Length > srpLength ||
            (PCHAR) (srp->Name1.Buffer) > (PCHAR)srp + srpLength - srp->Name1.Length ||
            (((ULONG_PTR)(srp->Name1.Buffer) & ((sizeof(WCHAR)) - 1)) != 0) ) {

            status = STATUS_ACCESS_VIOLATION;
            goto exit_with_lock;
        }

        ACQUIRE_LOCK( &SrvShareLock );

        share = SrvFindShare( &srp->Name1 );

        if ( share != NULL) {

            share->IsDfs = ((srp->Flags & SRP_SET_SHARE_IN_DFS) != 0);

            status = STATUS_SUCCESS;

        } else {

            status = STATUS_OBJECT_NAME_NOT_FOUND;

        }

        RELEASE_LOCK( &SrvShareLock );

        goto exit_with_lock;

        break;
    }

    case FSCTL_SRV_CHANGE_DOMAIN_NAME:
    {
        ULONG srpLength;
        PSERVER_REQUEST_PACKET srp;
        PSHARE share;
        PLIST_ENTRY listEntry;
        PENDPOINT endpoint;

        if ( !SrvFspActive || SrvFspTransitioning ) {
            status = STATUS_SUCCESS;
            goto exit_with_lock;
        }

        srp = Irp->AssociatedIrp.SystemBuffer;
        srpLength = IrpSp->Parameters.FileSystemControl.InputBufferLength;

        //
        // Make sure that the buffer was large enough to be a SRP.
        //

        if ( srpLength < sizeof(SERVER_REQUEST_PACKET) ||
             srp->Name1.Length == 0) {

            status = STATUS_INVALID_PARAMETER;
            goto exit_with_lock;
        }

        //
        // Adjust the buffer pointer to the srp address
        //
        (UINT_PTR) (srp->Name1.Buffer) += (UINT_PTR) srp;
        (UINT_PTR) (srp->Name2.Buffer) += (UINT_PTR) srp;

        if( (PCHAR) (srp->Name1.Buffer) < (PCHAR) srp ||
            srp->Name1.Length > srpLength ||
            (PCHAR) (srp->Name1.Buffer) > (PCHAR)srp + srpLength - srp->Name1.Length ||
            (((UINT_PTR)(srp->Name1.Buffer) & ((sizeof(WCHAR)) - 1)) != 0) ) {

            status = STATUS_ACCESS_VIOLATION;
            goto exit_with_lock;
        }

        if( (PCHAR) (srp->Name2.Buffer) < (PCHAR) srp ||
            srp->Name2.Length > srpLength ||
            (PCHAR) (srp->Name2.Buffer) > (PCHAR)srp + srpLength - srp->Name2.Length ||
            (((UINT_PTR)(srp->Name2.Buffer) & ((sizeof(WCHAR)) - 1)) != 0) ) {

            status = STATUS_ACCESS_VIOLATION;
            goto exit_with_lock;
        }

        //
        // Run the endpoints and change the domain name for any endpoint having
        //  the original domain name.  Note that the endpoint's domain name string buffers
        //  have already been allocated to the largest possible domain name.
        //
        ACQUIRE_LOCK( &SrvEndpointLock );

        for(    listEntry = SrvEndpointList.ListHead.Flink;
                listEntry != &SrvEndpointList.ListHead;
                listEntry = listEntry->Flink
            ) {

            endpoint = CONTAINING_RECORD(
                            listEntry,
                            ENDPOINT,
                            GlobalEndpointListEntry
                            );

            if( GET_BLOCK_STATE(endpoint) == BlockStateActive ) {

                if( RtlEqualUnicodeString( &srp->Name1, &endpoint->DomainName, TRUE ) ) {

                    //
                    // Update the UNICODE domain name string
                    //
                    RtlCopyUnicodeString( &endpoint->DomainName, &srp->Name2 );

                    //
                    // Update the Oem domain name string
                    //
                    endpoint->OemDomainName.Length =
                                (SHORT)RtlUnicodeStringToOemSize( &endpoint->DomainName );

                    ASSERT( endpoint->OemDomainName.Length <=
                            endpoint->OemDomainName.MaximumLength );

                    RtlUnicodeStringToOemString(
                                &endpoint->OemDomainName,
                                &endpoint->DomainName,
                                FALSE                   // no allocate
                                );
                }
            }
        }

        RELEASE_LOCK( &SrvEndpointLock );

        break;
    }

    case FSCTL_SRV_CHANGE_DNS_DOMAIN_NAME:
    {
        ULONG srpLength;
        PSERVER_REQUEST_PACKET srp;
        PSHARE share;
        PLIST_ENTRY listEntry;
        PENDPOINT endpoint;
        PUNICODE_STRING pStr;

        if ( !SrvFspActive || SrvFspTransitioning ) {
            status = STATUS_SUCCESS;
            goto exit_with_lock;
        }

        srp = Irp->AssociatedIrp.SystemBuffer;
        srpLength = IrpSp->Parameters.FileSystemControl.InputBufferLength;

        //
        // Make sure that the buffer was large enough to be a SRP.
        //

        if ( srpLength < sizeof(SERVER_REQUEST_PACKET) ||
             srp->Name1.Length == 0) {

            status = STATUS_INVALID_PARAMETER;
            goto exit_with_lock;
        }

        //
        // Adjust the buffer pointer to the srp address
        //
        (UINT_PTR) (srp->Name1.Buffer) += (UINT_PTR) srp;
        (UINT_PTR) (srp->Name2.Buffer) += (UINT_PTR) srp;

        if( (PCHAR) (srp->Name1.Buffer) < (PCHAR) srp ||
            srp->Name1.Length > srpLength ||
            (PCHAR) (srp->Name1.Buffer) > (PCHAR)srp + srpLength - srp->Name1.Length ||
            (((UINT_PTR)(srp->Name1.Buffer) & ((sizeof(WCHAR)) - 1)) != 0) ) {

            status = STATUS_ACCESS_VIOLATION;
            goto exit_with_lock;
        }

        if( (PCHAR) (srp->Name2.Buffer) < (PCHAR) srp ||
            srp->Name2.Length > srpLength ||
            (PCHAR) (srp->Name2.Buffer) > (PCHAR)srp + srpLength - srp->Name2.Length ||
            (((UINT_PTR)(srp->Name2.Buffer) & ((sizeof(WCHAR)) - 1)) != 0) ) {

            status = STATUS_ACCESS_VIOLATION;
            goto exit_with_lock;
        }

        if( RtlEqualUnicodeString( &srp->Name1, &srp->Name2, TRUE ) )
        {
            // The DNS name is equal to the Netbios name, so avoid the check
            ACQUIRE_LOCK( &SrvEndpointLock );

            if( SrvDnsDomainName )
            {
                DEALLOCATE_NONPAGED_POOL( SrvDnsDomainName );
                SrvDnsDomainName = NULL;
            }

            RELEASE_LOCK( &SrvEndpointLock );

            status = STATUS_SUCCESS;
        }
        else
        {
            //
            // Change the DNS domain name
            //
            pStr = (PUNICODE_STRING)ALLOCATE_NONPAGED_POOL( sizeof(UNICODE_STRING) + srp->Name2.Length, BlockTypeMisc );
            if( !pStr )
            {
                status = STATUS_INSUFFICIENT_RESOURCES;
                goto exit_with_lock;
            }

            pStr->MaximumLength = pStr->Length = srp->Name2.Length;
            pStr->Buffer = (PWSTR)(pStr+1);
            RtlCopyMemory( pStr->Buffer, srp->Name2.Buffer, srp->Name2.Length );

            ACQUIRE_LOCK( &SrvEndpointLock );

            if( SrvDnsDomainName )
            {
                DEALLOCATE_NONPAGED_POOL( SrvDnsDomainName );
            }

            SrvDnsDomainName = pStr;

            RELEASE_LOCK( &SrvEndpointLock );

            status = STATUS_SUCCESS;
        }

        break;
    }

    case FSCTL_SRV_GET_QUEUE_STATISTICS:
    {
        PSRV_QUEUE_STATISTICS qstats;
        SRV_QUEUE_STATISTICS  tmpqstats;
        PWORK_QUEUE queue;
        LONG timeIncrement = (LONG)KeQueryTimeIncrement();

        //
        // Make sure the server is active.
        //
        if ( !SrvFspActive || SrvFspTransitioning ) {

            status = STATUS_SERVER_NOT_STARTED;
            goto exit_with_lock;
        }

        if ( IrpSp->Parameters.FileSystemControl.OutputBufferLength <
                 (SrvNumberOfProcessors+1) * sizeof( *qstats ) ) {

            status = STATUS_BUFFER_TOO_SMALL;
            goto exit_with_lock;
        }

        qstats = Irp->AssociatedIrp.SystemBuffer;

        //
        // Get the data for the normal processor queues
        //
        for( queue = SrvWorkQueues; queue < eSrvWorkQueues; queue++, qstats++ ) {

            tmpqstats.QueueLength      = KeReadStateQueue( &queue->Queue );
            tmpqstats.ActiveThreads    = queue->Threads - queue->AvailableThreads;
            tmpqstats.AvailableThreads = queue->Threads;
            tmpqstats.FreeWorkItems    = queue->FreeWorkItems;                 // no lock!
            tmpqstats.StolenWorkItems  = queue->StolenWorkItems;               // no lock!
            tmpqstats.NeedWorkItem     = queue->NeedWorkItem;
            tmpqstats.CurrentClients   = queue->CurrentClients;

            tmpqstats.BytesReceived.QuadPart    = queue->stats.BytesReceived;
            tmpqstats.BytesSent.QuadPart        = queue->stats.BytesSent;
            tmpqstats.ReadOperations.QuadPart   = queue->stats.ReadOperations;
            tmpqstats.BytesRead.QuadPart        = queue->stats.BytesRead;
            tmpqstats.WriteOperations.QuadPart  = queue->stats.WriteOperations;
            tmpqstats.BytesWritten.QuadPart     = queue->stats.BytesWritten;
            tmpqstats.TotalWorkContextBlocksQueued = queue->stats.WorkItemsQueued;
            tmpqstats.TotalWorkContextBlocksQueued.Count *= STATISTICS_SMB_INTERVAL;
            tmpqstats.TotalWorkContextBlocksQueued.Time.QuadPart *= timeIncrement;

            RtlCopyMemory( qstats, &tmpqstats, sizeof(tmpqstats) );
        }

        //
        // Get the data for the blocking work queue
        //

        tmpqstats.QueueLength      = KeReadStateQueue( &SrvBlockingWorkQueue.Queue );
        tmpqstats.ActiveThreads    = SrvBlockingWorkQueue.Threads -
                                     SrvBlockingWorkQueue.AvailableThreads;
        tmpqstats.AvailableThreads = SrvBlockingWorkQueue.Threads;
        tmpqstats.FreeWorkItems    = SrvBlockingWorkQueue.FreeWorkItems;         // no lock!
        tmpqstats.StolenWorkItems  = SrvBlockingWorkQueue.StolenWorkItems;       // no lock!
        tmpqstats.NeedWorkItem     = SrvBlockingWorkQueue.NeedWorkItem;
        tmpqstats.CurrentClients   = SrvBlockingWorkQueue.CurrentClients;

        tmpqstats.BytesReceived.QuadPart    = SrvBlockingWorkQueue.stats.BytesReceived;
        tmpqstats.BytesSent.QuadPart        = SrvBlockingWorkQueue.stats.BytesSent;
        tmpqstats.ReadOperations.QuadPart   = SrvBlockingWorkQueue.stats.ReadOperations;
        tmpqstats.BytesRead.QuadPart        = SrvBlockingWorkQueue.stats.BytesRead;
        tmpqstats.WriteOperations.QuadPart  = SrvBlockingWorkQueue.stats.WriteOperations;
        tmpqstats.BytesWritten.QuadPart     = SrvBlockingWorkQueue.stats.BytesWritten;

        tmpqstats.TotalWorkContextBlocksQueued
                                   = SrvBlockingWorkQueue.stats.WorkItemsQueued;
        tmpqstats.TotalWorkContextBlocksQueued.Count *= STATISTICS_SMB_INTERVAL;
        tmpqstats.TotalWorkContextBlocksQueued.Time.QuadPart *= timeIncrement;

        RtlCopyMemory( qstats, &tmpqstats, sizeof(tmpqstats) );

        Irp->IoStatus.Information = (SrvNumberOfProcessors + 1) * sizeof( *qstats );

        status = STATUS_SUCCESS;
        goto exit_with_lock;

        break;

    }

    case FSCTL_SRV_GET_STATISTICS:

        //
        // Make sure that the server is active.
        //

        if ( !SrvFspActive || SrvFspTransitioning ) {
            //IF_DEBUG(ERRORS) {
            //    SrvPrint0( "LAN Manager server FSP not started.\n" );
            //}

            status = STATUS_SERVER_NOT_STARTED;
            goto exit_with_lock;
        }

        {
            SRV_STATISTICS tmpStatistics;
            ULONG size;

            //
            // Make sure that the user buffer is large enough to hold some of the
            // statistics database.
            //

            size = MIN( IrpSp->Parameters.FileSystemControl.OutputBufferLength,
                        sizeof( tmpStatistics ) );

            if ( size == 0 ) {
                status = STATUS_BUFFER_TOO_SMALL;
                goto exit_with_lock;
            }

            //
            // Copy the statistics database to the user buffer.  Store
            // the statistics in a temporary buffer so we can convert
            // the tick count stored to system time.
            //

            SrvUpdateStatisticsFromQueues( &tmpStatistics );

            tmpStatistics.TotalWorkContextBlocksQueued.Time.QuadPart *=
                                                (LONG)KeQueryTimeIncrement();

            RtlCopyMemory(
                Irp->AssociatedIrp.SystemBuffer,
                &tmpStatistics,
                size
                );

            Irp->IoStatus.Information = size;

        }

        status = STATUS_SUCCESS;
        goto exit_with_lock;

#if SRVDBG_STATS || SRVDBG_STATS2
    case FSCTL_SRV_GET_DEBUG_STATISTICS:

        //
        // Make sure that the server is active.
        //

        if ( !SrvFspActive || SrvFspTransitioning ) {
            //IF_DEBUG(ERRORS) {
            //    SrvPrint0( "LAN Manager server FSP not started.\n" );
            //}

            status = STATUS_SERVER_NOT_STARTED;
            goto exit_with_lock;
        }

        {
            PSRV_STATISTICS_DEBUG stats;

            //
            // Make sure that the user buffer is large enough to hold the
            // statistics database.
            //

            if ( IrpSp->Parameters.FileSystemControl.OutputBufferLength <
                     FIELD_OFFSET(SRV_STATISTICS_DEBUG,QueueStatistics) ) {

                status = STATUS_BUFFER_TOO_SMALL;
                goto exit_with_lock;
            }

            //
            // Acquire the statistics lock, then copy the statistics database
            // to the user buffer.
            //

            stats = (PSRV_STATISTICS_DEBUG)Irp->AssociatedIrp.SystemBuffer;

            RtlCopyMemory(
                stats,
                &SrvDbgStatistics,
                FIELD_OFFSET(SRV_STATISTICS_DEBUG,QueueStatistics) );

            Irp->IoStatus.Information =
                    FIELD_OFFSET(SRV_STATISTICS_DEBUG,QueueStatistics);

            if ( IrpSp->Parameters.FileSystemControl.OutputBufferLength >=
                     sizeof(SrvDbgStatistics) ) {
                PWORK_QUEUE queue;
                ULONG i, j;
                i = 0;
                stats->QueueStatistics[i].Depth = 0;
                stats->QueueStatistics[i].Threads = 0;
#if SRVDBG_STATS2
                stats->QueueStatistics[i].ItemsQueued = 0;
                stats->QueueStatistics[i].MaximumDepth = 0;
#endif
                for( queue = SrvWorkQueues; queue < eSrvWorkQueues; queue++ ) {
                    stats->QueueStatistics[i].Depth += KeReadStateQueue( &queue->Queue );
                    stats->QueueStatistics[i].Threads += queue->Threads;
#if SRVDBG_STATS2
                    stats->QueueStatistics[i].ItemsQueued += queue->ItemsQueued;
                    stats->QueueStatistics[i].MaximumDepth += queue->MaximumDepth + 1;
#endif
                }
                Irp->IoStatus.Information = sizeof(SrvDbgStatistics);
            }

        }

        status = STATUS_SUCCESS;
        goto exit_with_lock;
#endif // SRVDBG_STATS || SRVDBG_STATS2
    //
    // The follwing APIs must be processed in the server FSP because
    // they open or close handles.
    //

    case FSCTL_SRV_NET_FILE_CLOSE:
    case FSCTL_SRV_NET_SERVER_XPORT_ADD:
    case FSCTL_SRV_NET_SERVER_XPORT_DEL:
    case FSCTL_SRV_NET_SESSION_DEL:
    case FSCTL_SRV_NET_SHARE_ADD:
    case FSCTL_SRV_NET_SHARE_DEL:

    {
        PSERVER_REQUEST_PACKET srp;
        PVOID buffer1;
        PVOID buffer2;
        PVOID systemBuffer;
        ULONG buffer1Length;
        ULONG buffer2Length;
        ULONG systemBufferLength;

        //
        // Get the server request packet pointer.
        //

        srp = IrpSp->Parameters.FileSystemControl.Type3InputBuffer;

        //
        // If the server is not running, or if it is in the process
        // of shutting down, reject this request.
        //

        if ( !SrvFspActive || SrvFspTransitioning ) {
            //IF_DEBUG(ERRORS) {
            //    SrvPrint0( "LAN Manager server FSP not started.\n" );
            //}

            srp->ErrorCode = NERR_ServerNotStarted;
            status = STATUS_SUCCESS;
            goto exit_with_lock;
        }

        //
        // Determine the input buffer lengths, and make sure that the
        // first buffer is large enough to be an SRP.
        //

        buffer1Length = IrpSp->Parameters.FileSystemControl.InputBufferLength;
        buffer2Length = IrpSp->Parameters.FileSystemControl.OutputBufferLength;

        if ( buffer1Length < sizeof(SERVER_REQUEST_PACKET) ) {
            status = STATUS_INVALID_PARAMETER;
            goto exit_with_lock;
        }

        //
        // Make the first buffer size is properly aligned so that the second
        // buffer will be aligned as well.
        //

        buffer1Length = ALIGN_UP( buffer1Length, PVOID );

        //
        // Allocate a single buffer that will hold both input buffers.
        // Note that the SRP part of the first buffer is copied back
        // to the user as an output buffer.
        //

        systemBufferLength = buffer1Length + buffer2Length;

        if( buffer1Length > SrvMaxFsctlBufferSize ||
            buffer2Length > SrvMaxFsctlBufferSize ) {

            status = STATUS_INVALID_PARAMETER;
            goto exit_with_lock;

        }

        systemBuffer = ExAllocatePoolWithTagPriority( PagedPool, systemBufferLength, BlockTypeMisc, LowPoolPriority );

        if ( systemBuffer == NULL ) {
            status = STATUS_INSUFF_SERVER_RESOURCES;
            goto exit_with_lock;
        }

        buffer1 = systemBuffer;
        buffer2 = (PCHAR)systemBuffer + buffer1Length;

        //
        // Copy the information into the buffers.
        //

        RtlCopyMemory(
            buffer1,
            srp,
            IrpSp->Parameters.FileSystemControl.InputBufferLength
            );
        if ( buffer2Length > 0 ) {
            RtlCopyMemory( buffer2, Irp->UserBuffer, buffer2Length );
        }

        //
        // If a name was specified in the SRP, the buffer field will
        // contain an offset rather than a pointer.  Convert the offset
        // to a pointer and verify that that it is a legal pointer.
        //

        srp = buffer1;

        OFFSET_TO_POINTER( srp->Name1.Buffer, srp );

        if ( !POINTER_IS_VALID( srp->Name1.Buffer, srp, buffer1Length ) ) {
            status = STATUS_ACCESS_VIOLATION;
            ExFreePool( buffer1 );
            goto exit_with_lock;
        }

        OFFSET_TO_POINTER( srp->Name2.Buffer, srp );

        if ( !POINTER_IS_VALID( srp->Name2.Buffer, srp, buffer1Length ) ) {
            status = STATUS_ACCESS_VIOLATION;
            ExFreePool( buffer1 );
            goto exit_with_lock;
        }

        //
        // Set up pointers in the IRP.  The system buffer points to the
        // buffer we just allocated to contain the input buffers.  User
        // buffer points to the SRP from the server service.  This
        // allows the SRP to be used as an output buffer-- the number of
        // bytes specified by the Information field of the IO status
        // block are copied from the system buffer to the user buffer at
        // IO completion.
        //

        Irp->AssociatedIrp.SystemBuffer = systemBuffer;
        Irp->UserBuffer = IrpSp->Parameters.FileSystemControl.Type3InputBuffer;

        //
        // Set up other fields in the IRP so that the SRP is copied from
        // the system buffer to the user buffer, and the system buffer
        // is deallocated by IO completion.
        //

        Irp->Flags |= IRP_BUFFERED_IO | IRP_DEALLOCATE_BUFFER |
                          IRP_INPUT_OPERATION;
        Irp->IoStatus.Information = sizeof(SERVER_REQUEST_PACKET);

        break;
    }

    //
    // The following APIs should be processed in the server FSP because
    // they reference and dereference structures, which could lead to
    // handles being closed.  However, it was too hard to change this
    // (because of the need to return a separate SRP and data buffer) at
    // the time this was realized (just before Product 1 shipment), so
    // they are processed in the FSD, and all calls to NtClose attach to
    // the server process first if necessary.
    //

    case FSCTL_SRV_NET_CONNECTION_ENUM:
    case FSCTL_SRV_NET_FILE_ENUM:
    case FSCTL_SRV_NET_SERVER_DISK_ENUM:
    case FSCTL_SRV_NET_SERVER_XPORT_ENUM:
    case FSCTL_SRV_NET_SESSION_ENUM:
    case FSCTL_SRV_NET_SHARE_ENUM:

    //
    // These APIs are processed here in the server FSD.
    //

    case FSCTL_SRV_NET_SERVER_SET_INFO:
    case FSCTL_SRV_NET_SHARE_SET_INFO:
    case FSCTL_SRV_NET_STATISTICS_GET:
    {
        PSERVER_REQUEST_PACKET srp;
        ULONG buffer1Length;

        //
        // Get the server request packet pointer.
        //

        srp = IrpSp->Parameters.FileSystemControl.Type3InputBuffer;
        buffer1Length = IrpSp->Parameters.FileSystemControl.InputBufferLength;

        //
        // If the server is not running, or if it is in the process
        // of shutting down, reject this request.
        //

        if ( !SrvFspActive || SrvFspTransitioning ) {
            //IF_DEBUG(ERRORS) {
            //    SrvPrint0( "LAN Manager server FSP not started.\n" );
            //}

            srp->ErrorCode = NERR_ServerNotStarted;
            status = STATUS_SUCCESS;
            goto exit_with_lock;
        }

        //
        // Increment the count of API requests in the server FSD.
        //

        SrvApiRequestCount++;

        //
        // Make sure that the buffer was large enough to be an SRP.
        //

        if ( buffer1Length < sizeof(SERVER_REQUEST_PACKET) ) {
            status = STATUS_INVALID_PARAMETER;
            goto exit_with_lock;
        }

        //
        // If a name was specified in the SRP, the buffer field will
        // contain an offset rather than a pointer.  Convert the offset
        // to a pointer and verify that that it is a legal pointer.
        //

        OFFSET_TO_POINTER( srp->Name1.Buffer, srp );

        if ( !POINTER_IS_VALID( srp->Name1.Buffer, srp, buffer1Length ) ) {
            status = STATUS_ACCESS_VIOLATION;
            goto exit_with_lock;
        }

        OFFSET_TO_POINTER( srp->Name2.Buffer, srp );

        if ( !POINTER_IS_VALID( srp->Name2.Buffer, srp, buffer1Length ) ) {
            status = STATUS_ACCESS_VIOLATION;
            goto exit_with_lock;
        }

        //
        // We don't need the configuration lock any more.
        //

        RELEASE_LOCK( &SrvConfigurationLock );

        //
        // Dispatch the API request to the appripriate API processing
        // routine.  All these API requests are handled in the FSD.
        //

        status = SrvApiDispatchTable[ SRV_API_INDEX(code) ](
                     srp,
                     Irp->UserBuffer,
                     IrpSp->Parameters.FileSystemControl.OutputBufferLength
                     );

        //
        // Decrement the count of outstanding API requests in the
        // server.  Hold the configuration lock while doing this, as it
        // protects the API count variable.
        //

        ACQUIRE_LOCK( &SrvConfigurationLock );
        SrvApiRequestCount--;

        //
        // Check to see whether the server is transitioning from started
        // to not started.  If so, and if this is the last API request
        // to be completed, then set the API completion event which the
        // shutdown code is waiting on.
        //
        // Since we checked SrvFspTransitioning at the start of the
        // request, we know that the shutdown came after we started
        // processing the API.  If SrvApiRequestCount is 0, then there
        // are no other threads in the FSD processing API requests.
        // Therefore, it is safe for the shutdown code to proceed with
        // the knowledge that no other thread in the server is
        // operating.
        //

        if ( SrvFspTransitioning && SrvApiRequestCount == 0 ) {
            KeSetEvent( &SrvApiCompletionEvent, 0, FALSE );
        }

        goto exit_with_lock;
    }

    case FSCTL_SRV_START_SMBTRACE:

        if ( SmbTraceActive[SMBTRACE_SERVER] ) {
            status = STATUS_SHARING_VIOLATION;
            goto exit_with_lock;
        }

        if ( !SrvFspActive || SrvFspTransitioning ) {
            status = STATUS_SERVER_NOT_STARTED;
            goto exit_with_lock;
        }

        break;        // FSP continues the processing.

    case FSCTL_SRV_END_SMBTRACE:

        //
        // If the server is not running, or if it is in the process
        // of shutting down, reject this request.
        //

        if ( !SrvFspActive || SrvFspTransitioning ) {
            status = STATUS_SERVER_NOT_STARTED;
            goto exit_with_lock;
        }

        //
        // Attempt to stop SmbTrace.  It will likely return
        // STATUS_PENDING, indicating that it is in the process
        // of shutting down.  STATUS_PENDING is a poor value
        // to return (according to an assertion in io\iosubs.c)
        // so we convert it to success.  Better would be for
        // SmbTraceStop to wait until it has successfully stopped.
        //

        status = SmbTraceStop( NULL, SMBTRACE_SERVER );

        //
        // Complete the request with success.
        //

        status = STATUS_SUCCESS;
        goto exit_with_lock;

    case FSCTL_SRV_PAUSE:

        //
        // If the server is not running, or if it is in the process
        // of shutting down, reject this request.
        //

        if ( !SrvFspActive || SrvFspTransitioning ) {
            //IF_DEBUG(ERRORS) {
            //    SrvPrint0( "LAN Manager server FSP not started.\n" );
            //}

            status = STATUS_SERVER_NOT_STARTED;
            goto exit_with_lock;
        }

        SrvPaused = TRUE;

        status = STATUS_SUCCESS;
        goto exit_with_lock;

    case FSCTL_SRV_CONTINUE:

        //
        // If the server is not running, or if it is in the process
        // of shutting down, reject this request.
        //

        if ( !SrvFspActive || SrvFspTransitioning ) {
            //IF_DEBUG(ERRORS) {
            //    SrvPrint0( "LAN Manager server FSP not started.\n" );
            //}

            status = STATUS_SERVER_NOT_STARTED;
            goto exit_with_lock;
        }

        SrvPaused = FALSE;

        status = STATUS_SUCCESS;
        goto exit_with_lock;

    case FSCTL_SRV_GET_CHALLENGE:
    {
        PLIST_ENTRY sessionEntry;
        PLUID inputLuid;
        PSESSION session;

        //
        // If the server is not running, or if it is in the process
        // of shutting down, reject this request.
        //

        if ( !SrvFspActive || SrvFspTransitioning ) {
            //IF_DEBUG(ERRORS) {
            //    SrvPrint0( "LAN Manager server FSP not started.\n" );
            //}

            status = STATUS_SERVER_NOT_STARTED;
            goto exit_with_lock;
        }

        if ( IrpSp->Parameters.FileSystemControl.InputBufferLength <
                 sizeof(LUID) ||
             IrpSp->Parameters.FileSystemControl.OutputBufferLength <
                 sizeof(session->NtUserSessionKey) ) {

            status = STATUS_BUFFER_TOO_SMALL;
            goto exit_with_lock;
        }

        RELEASE_LOCK( &SrvConfigurationLock );

        inputLuid = (PLUID)Irp->AssociatedIrp.SystemBuffer;

        //
        // Acquire the lock that protects the session list and walk the
        // list looking for a user token that matches the one specified
        // in the input buffer.
        //

        ACQUIRE_LOCK( SrvSessionList.Lock );

        for ( sessionEntry = SrvSessionList.ListHead.Flink;
              sessionEntry != &SrvSessionList.ListHead;
              sessionEntry = sessionEntry->Flink ) {

            session = CONTAINING_RECORD(
                          sessionEntry,
                          SESSION,
                          GlobalSessionListEntry
                          );

            if ( RtlEqualLuid( inputLuid, &session->LogonId ) ) {

                //
                // We found a match.  Write the NT user session key into
                // the output buffer.
                //

                RtlCopyMemory(
                    Irp->AssociatedIrp.SystemBuffer,
                    session->NtUserSessionKey,
                    sizeof(session->NtUserSessionKey)
                    );

                RELEASE_LOCK( SrvSessionList.Lock );

                Irp->IoStatus.Information = sizeof(session->NtUserSessionKey);
                status = STATUS_SUCCESS;
                goto exit_without_lock;
            }
        }

        RELEASE_LOCK( SrvSessionList.Lock );

        //
        // There was no matching token in our session list.  Fail the
        // request.
        //

        status = STATUS_NO_TOKEN;
        goto exit_without_lock;
    }

    case FSCTL_SRV_INTERNAL_TEST_REAUTH:
    {
        PSRV_REAUTH_TEST pReauthData;
        ULONG BufferLength;

        pReauthData = (PSRV_REAUTH_TEST)Irp->AssociatedIrp.SystemBuffer;
        BufferLength = IrpSp->Parameters.FileSystemControl.InputBufferLength;

        // Make sure the buffer size is good
        if( BufferLength < sizeof(SRV_REAUTH_TEST) )
        {
            status = STATUS_INVALID_PARAMETER;
            goto exit_with_lock;
        }

        // Pull out the parameters
        SessionInvalidateCommand = pReauthData->InvalidateCommand;
        SessionInvalidateMod = pReauthData->InvalidateModulo;
        status = STATUS_SUCCESS;
        goto exit_with_lock;
    }

    default:

        INTERNAL_ERROR(
            ERROR_LEVEL_EXPECTED,
            "SrvFsdDispatchFsControl: Invalid I/O control "
                "code received: %lx\n",
            IrpSp->Parameters.FileSystemControl.FsControlCode,
            NULL
            );
        status = STATUS_INVALID_PARAMETER;
        goto exit_with_lock;
    }

    pWorkItem = IoAllocateWorkItem( SrvDeviceObject );
    if( !pWorkItem )
    {
        status = STATUS_INSUFFICIENT_RESOURCES;
        goto exit_with_lock;
    }

    //
    // Queue the request to the FSP for processing.
    //
    // *** Note that the request must be queued while the configuration
    //     lock is held in order to prevent an add/delete/etc request
    //     from checking the server state before a shutdown request, but
    //     being queued after that request.
    //

    IoMarkIrpPending( Irp );

    QueueConfigurationIrp( Irp, pWorkItem );

    RELEASE_LOCK( &SrvConfigurationLock );

    FsRtlExitFileSystem();

    return STATUS_PENDING;

exit_with_lock:

    RELEASE_LOCK( &SrvConfigurationLock );

exit_without_lock:

    FsRtlExitFileSystem();

    Irp->IoStatus.Status = status;
    IoCompleteRequest( Irp, 2 );

    return status;

} // SrvFsdDispatchFsControl


VOID
QueueConfigurationIrp (
    IN PIRP Irp,
    IN PIO_WORKITEM pWorkItem
    )
{
    PAGED_CODE( );

    InterlockedIncrement( (PLONG)&SrvConfigurationIrpsInProgress );

    SrvInsertTailList(
        &SrvConfigurationWorkQueue,
        &Irp->Tail.Overlay.ListEntry
        );


    IoQueueWorkItem( pWorkItem, SrvConfigurationThread, DelayedWorkQueue, (PVOID)pWorkItem );

} // QueueConfigurationIrp
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\srv\ipx.c ===
/*++

Copyright (c) 1993  Microsoft Corporation

Module Name:

    ipx.c

Abstract:

    This module implements IPX transport handling for the server.

Author:

    Chuck Lenzmeier (chuckl)    28-Oct-1993

Revision History:

--*/

#include "precomp.h"
#include "ipx.tmh"
#pragma hdrstop

#if SRVDBG_PERF
BOOLEAN Trap512s = FALSE;
BOOLEAN Break512s = FALSE;
ULONG Trapped512s = 0;
BOOLEAN UnlocksGoFast = TRUE;
BOOLEAN OpensGoSlow = TRUE;
BOOLEAN GlommingAllowed = TRUE;
#endif

#define NAME_CLAIM_ATTEMPTS 5
#define NAME_CLAIM_INTERVAL 500 // milliseconds

#define MPX_HEADER_SIZE (sizeof(SMB_HEADER) + sizeof(REQ_WRITE_MPX))

PCONNECTION
GetIpxConnection (
    IN PWORK_CONTEXT WorkContext,
    IN PENDPOINT Endpoint,
    IN PTDI_ADDRESS_IPX ClientAddress,
    IN PUCHAR ClientName
    );

VOID
PurgeIpxConnections (
    IN PENDPOINT Endpoint
    );

NTSTATUS
SendNameClaim (
    IN PENDPOINT Endpoint,
    IN PVOID ServerNetbiosName,
    IN PVOID DestinationNetbiosName,
    IN PTA_IPX_ADDRESS DestinationAddress,
    IN UCHAR NameClaimPacketType,
    IN USHORT ClientMessageId,
    IN UCHAR IpxPacketType,
    IN PIPX_DATAGRAM_OPTIONS DatagramOptions
    );

VOID SRVFASTCALL
IpxRestartNegotiate(
    IN OUT PWORK_CONTEXT WorkContext
    );

VOID SRVFASTCALL
IpxRestartReceive (
    IN OUT PWORK_CONTEXT WorkContext
    );

VOID
SrvFreeIpxConnectionInIndication(
    IN PWORK_CONTEXT WorkContext
    );

VOID
StartSendNoConnection (
    IN OUT PWORK_CONTEXT WorkContext,
    IN BOOLEAN UseNameSocket,
    IN BOOLEAN LocalTargetValid
    );

VOID SRVFASTCALL
SrvIpxFastRestartRead (
    IN OUT PWORK_CONTEXT WorkContext
    );

BOOLEAN
SetupIpxFastCoreRead (
    IN OUT PWORK_CONTEXT WorkContext
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text( PAGE, SrvIpxClaimServerName )
#pragma alloc_text( PAGE, IpxRestartReceive )
#pragma alloc_text( PAGE, SrvIpxFastRestartRead )
#endif
#if 0
NOT PAGEABLE -- GetWorkItem
NOT PAGEABLE -- SendNameClaim
NOT PAGEABLE -- SrvIpxServerDatagramHandler
NOT PAGEABLE -- SrvIpxNameDatagramHandler
NOT PAGEABLE -- SrvIpxStartSend
NOT PAGEABLE -- StartSendNoConnection
NOT PAGEABLE -- RequeueIpxWorkItemAtSendCompletion
NOT PAGEABLE -- PurgeIpxConnections
NOT PAGEABLE -- IpxRestartNegotiate
NOT PAGEABLE -- SetupIpxFastCoreRead
NOT PAGEABLE -- SrvFreeIpxConnectionInIndication
#endif


NTSTATUS
SendNameClaim (
    IN PENDPOINT Endpoint,
    IN PVOID ServerNetbiosName,
    IN PVOID DestinationNetbiosName,
    IN PTA_IPX_ADDRESS DestinationAddress,
    IN UCHAR NameClaimPacketType,
    IN USHORT MessageId,
    IN UCHAR IpxPacketType,
    IN PIPX_DATAGRAM_OPTIONS DatagramOptions
    )
{
    PWORK_CONTEXT workContext;
    PSMB_IPX_NAME_PACKET buffer;
    PWORK_QUEUE queue = PROCESSOR_TO_QUEUE();

    //
    // Get a work item to use for the send.
    //

    ALLOCATE_WORK_CONTEXT( queue, &workContext );

    if ( workContext == NULL ) {
        //
        // We're out of WorkContext structures, and we aren't able to allocate
        // any more just now.  Let's at least cause a worker thread to allocate some more
        // by incrementing the NeedWorkItem counter.  This will cause the next
        // freed WorkContext structure to get dispatched to SrvServiceWorkItemShortage.
        // While SrvServiceWorkItemShortage probably won't find any work to do, it will
        // allocate more WorkContext structures if it can.  Maybe this will help next time.
        //
        InterlockedIncrement( &queue->NeedWorkItem );

        return STATUS_INSUFFICIENT_RESOURCES;
    }


    //
    // Format the name claim packet.
    //

    buffer = (PSMB_IPX_NAME_PACKET)workContext->ResponseBuffer->Buffer;
    RtlZeroMemory( buffer->Route, sizeof(buffer->Route) );
    buffer->Operation = NameClaimPacketType;
    buffer->NameType = SMB_IPX_NAME_TYPE_MACHINE;
    buffer->MessageId = MessageId;
    RtlCopyMemory( buffer->Name, ServerNetbiosName, SMB_IPX_NAME_LENGTH );
    RtlCopyMemory( buffer->SourceName, DestinationNetbiosName, SMB_IPX_NAME_LENGTH );

    workContext->ResponseBuffer->DataLength = sizeof(SMB_IPX_NAME_PACKET);
    workContext->ResponseBuffer->Mdl->ByteCount = sizeof(SMB_IPX_NAME_PACKET);

    //
    // Format the destination address and send the packet.
    //

    workContext->Endpoint = Endpoint;
    DEBUG workContext->FsdRestartRoutine = NULL;

    workContext->ClientAddress->IpxAddress = *DestinationAddress;

    if ( ARGUMENT_PRESENT(DatagramOptions) ) {

        workContext->ClientAddress->DatagramOptions = *DatagramOptions;
        workContext->ClientAddress->DatagramOptions.PacketType = IpxPacketType;

        StartSendNoConnection( workContext, TRUE, TRUE );

    } else {
        workContext->ClientAddress->DatagramOptions.PacketType = IpxPacketType;
        StartSendNoConnection( workContext, TRUE, FALSE );
    }

    return STATUS_SUCCESS;

} // SendNameClaim


NTSTATUS
SrvIpxClaimServerName (
    IN PENDPOINT Endpoint,
    IN PVOID NetbiosName
    )
{
    NTSTATUS status;
    ULONG i;
    LARGE_INTEGER interval;
    TA_IPX_ADDRESS broadcastAddress;

    PAGED_CODE( );

    //
    // The destination of the name claim packet is the broadcast address.
    //

    broadcastAddress.TAAddressCount = 1;
    broadcastAddress.Address[0].AddressLength = sizeof(TDI_ADDRESS_IPX);
    broadcastAddress.Address[0].AddressType = TDI_ADDRESS_TYPE_IPX;
    broadcastAddress.Address[0].Address[0].NetworkAddress = 0;
    broadcastAddress.Address[0].Address[0].NodeAddress[0] = 0xff;
    broadcastAddress.Address[0].Address[0].NodeAddress[1] = 0xff;
    broadcastAddress.Address[0].Address[0].NodeAddress[2] = 0xff;
    broadcastAddress.Address[0].Address[0].NodeAddress[3] = 0xff;
    broadcastAddress.Address[0].Address[0].NodeAddress[4] = 0xff;
    broadcastAddress.Address[0].Address[0].NodeAddress[5] = 0xff;
    broadcastAddress.Address[0].Address[0].Socket = SMB_IPX_NAME_SOCKET;

    //
    // Send the name claim packet 5 times, waiting 1/2 second after
    // each send.  If anyone else claims the name, fail.
    //

    interval.QuadPart = Int32x32To64( NAME_CLAIM_INTERVAL, -1*10*1000 );

    for ( i = 0; i < NAME_CLAIM_ATTEMPTS; i++ ) {

        //
        // Send the name claim.
        //

        status = SendNameClaim(
                    Endpoint,
                    NetbiosName,
                    NetbiosName,
                    &broadcastAddress,
                    SMB_IPX_NAME_CLAIM,
                    0,
                    0x14,
                    NULL
                    );
        if ( !NT_SUCCESS(status) ) {
            return status;
        }

        //
        // Wait 1/2 second.  If a response arrives, the datagram
        // handler marks the endpoint, and we quit.
        //

        KeDelayExecutionThread( KernelMode, FALSE, &interval );

        if ( Endpoint->NameInConflict ) {
            return STATUS_DUPLICATE_NAME;
        }

    }

    //
    // We now own the name.
    //

    return STATUS_SUCCESS;

} // SrvIpxClaimServerName


NTSTATUS
SrvIpxNameDatagramHandler (
    IN PVOID TdiEventContext,
    IN int SourceAddressLength,
    IN PVOID SourceAddress,
    IN int OptionsLength,
    IN PVOID Options,
    IN ULONG ReceiveDatagramFlags,
    IN ULONG BytesIndicated,
    IN ULONG BytesAvailable,
    OUT ULONG *BytesTaken,
    IN PVOID Tsdu,
    OUT PIRP *IoRequestPacket
    )

/*++

Routine Description:

    This is the receive datagram event handler for the IPX NetBIOS name
    socket.

Arguments:

    TdiEventContext - Pointer to receiving endpoint

    SourceAddressLength - Length of SourceAddress

    SourceAddress - Address of sender

    OptionsLength - Length of options

    Options - Options for the receive

    ReceiveDatagramFlags - Set of flags indicating the status of the
        received message

    BytesIndicated - Number of bytes in this indication (lookahead)

    BytesAvailable - Number of bytes in the complete TSDU

    BytesTaken - Returns the number of bytes taken by the handler

    Tsdu - Pointer to the Transport Service Data Unit

    IoRequestPacket - Returns a pointer to I/O request packet, if the
        returned status is STATUS_MORE_PROCESSING_REQUIRED.  This IRP is
        made the 'current' Receive for the endpoint.

Return Value:

    NTSTATUS - If STATUS_SUCCESS, the receive handler completely
        processed the request.  If STATUS_MORE_PROCESSING_REQUIRED,
        the Irp parameter points to a formatted Receive request to
        be used to receive the data.  If STATUS_DATA_NOT_ACCEPTED,
        the message is lost.

--*/

{
    PENDPOINT endpoint = (PENDPOINT)TdiEventContext;
    PSMB_IPX_NAME_PACKET packet;

    //
    // We have received a name query or claim request.  Is it for us?
    //

    if( BytesIndicated < sizeof( SMB_IPX_NAME_PACKET ) ) {
        IF_DEBUG( IPXNAMECLAIM ) {
            KdPrint(("NameDatagramHandler: Short packet %u bytes\n", BytesIndicated ));
        }
        return( STATUS_SUCCESS );
    }

    packet = (PSMB_IPX_NAME_PACKET)Tsdu;

    IF_DEBUG(IPXNAMECLAIM) {
        STRING string, srcString;
        string.Buffer = (PSZ)packet->Name;
        string.Length = SMB_IPX_NAME_LENGTH;
        srcString.Buffer = (PSZ)packet->SourceName;
        srcString.Length = SMB_IPX_NAME_LENGTH;
        KdPrint(( "NameDatagramHandler: type: %x, name %z, from %z\n",
                    packet->Operation, (PCSTRING)&string, (PCSTRING)&srcString ));
    }

    if ( SourceAddressLength < sizeof(IPX_ADDRESS_EXTENDED_FLAGS) ) {

        IF_DEBUG(IPXNAMECLAIM) {
            KdPrint(( "SourceAddress too short.  Expecting %d got %d\n",
                sizeof(IPX_ADDRESS_EXTENDED_FLAGS), SourceAddressLength ));
        }
        return(STATUS_SUCCESS);
    }

    if ( !RtlEqualMemory(
            packet->Name,
            endpoint->TransportAddress.Buffer,
            SMB_IPX_NAME_LENGTH) ) {
        IF_DEBUG(IPXNAMECLAIM) KdPrint(( "  not for us\n" ));
        return STATUS_SUCCESS;
    }

    //
    // The packet is for our name.  If we sent it, ignore it.
    //

    if ( RtlEqualMemory(
            &endpoint->LocalAddress,
            &((PTA_IPX_ADDRESS)SourceAddress)->Address[0].Address[0],
            sizeof(TDI_ADDRESS_IPX) ) ) {
        IF_DEBUG(IPXNAMECLAIM) KdPrint(( "  we sent it!\n" ));
        return STATUS_SUCCESS;
    }

    //
    // If it's a query or a claim, send a response.  If it's a 'name
    // recognized' packet, then another server owns our name.
    //

    if ( packet->Operation == SMB_IPX_NAME_FOUND ) {

        //
        // Did we send this ?
        //

        if ( (((PIPX_ADDRESS_EXTENDED_FLAGS)SourceAddress)->Flags &
              IPX_EXTENDED_FLAG_LOCAL) == 0 ) {

            //
            // This came from another station.
            //

            IF_DEBUG(IPXNAMECLAIM) KdPrint(( "  name in conflict!\n" ));
            endpoint->NameInConflict = TRUE;
        }

    } else {

        //
        // This is a name query.  If bit 0x8000 is set, this is from a
        // redir that supports named pipes correctly.
        //

        if ( !SrvEnableWfW311DirectIpx &&
             ((packet->MessageId & 0x8000) == 0)) {

            IF_DEBUG(IPXNAMECLAIM) KdPrint(( "  msg ID high bit not set.\n" ));
            return STATUS_SUCCESS;
        }

        IF_DEBUG(IPXNAMECLAIM) KdPrint(( "  sending name recognized response!\n" ));
        SendNameClaim(
            endpoint,
            endpoint->TransportAddress.Buffer,
            packet->SourceName,
            (PTA_IPX_ADDRESS)SourceAddress,
            SMB_IPX_NAME_FOUND,
            packet->MessageId,
            0x04,
            (PIPX_DATAGRAM_OPTIONS)Options
            );
    }

    return STATUS_SUCCESS;

} // SrvIpxNameDatagramHandler


NTSTATUS
SrvIpxServerDatagramHandlerCommon (
    IN PVOID TdiEventContext,
    IN int SourceAddressLength,
    IN PVOID SourceAddress,
    IN int OptionsLength,
    IN PVOID Options,
    IN ULONG ReceiveDatagramFlags,
    IN ULONG BytesIndicated,
    IN ULONG BytesAvailable,
    OUT ULONG *BytesTaken,
    IN PVOID Tsdu,
    OUT PIRP *IoRequestPacket,
    IN PVOID TransportContext
    )

/*++

Routine Description:

    This is the receive datagram event handler for the IPX server socket.
    It attempts to dequeue a preformatted work item from a list
    anchored in the device object.  If this is successful, it returns
    the IRP associated with the work item to the transport provider to
    be used to receive the data.  Otherwise, the message is dropped.

Arguments:

    TdiEventContext - Pointer to receiving endpoint

    SourceAddressLength - Length of SourceAddress

    SourceAddress - Address of sender

    OptionsLength - Length of options

    Options - Options for the receive

    ReceiveDatagramFlags - Set of flags indicating the status of the
        received message

    BytesIndicated - Number of bytes in this indication (lookahead)

    BytesAvailable - Number of bytes in the complete TSDU

    BytesTaken - Returns the number of bytes taken by the handler

    Tsdu - Pointer to buffer describing the Transport Service Data Unit

    IoRequestPacket - Returns a pointer to I/O request packet, if the
        returned status is STATUS_MORE_PROCESSING_REQUIRED.  This IRP is
        made the 'current' Receive for the endpoint.

    TransportContext - NULL is this is not a chained receive, otherwise this
        is the pointer to the TransportContext when returning the NDIS buffer.

Return Value:

    NTSTATUS - If STATUS_SUCCESS, the receive handler completely
        processed the request.  If STATUS_MORE_PROCESSING_REQUIRED,
        the Irp parameter points to a formatted Receive request to
        be used to receive the data.  If STATUS_DATA_NOT_ACCEPTED,
        the message is lost. If STATUS_PENDING, then TransportContext
        was not NULL and we decided that we are going to keep the NDIS
        buffer and return it later.

--*/

{
    PLIST_ENTRY listEntry;
    PWORK_CONTEXT workContext;
    PENDPOINT endpoint;
    USHORT sid;
    USHORT idIndex;
    USHORT sequenceNumber;
    USHORT nextSequenceNumber;
    USHORT mid;
    PCONNECTION connection;
    PNT_SMB_HEADER header;
    PSMB_PARAMS params;
    ULONG length;
    PTABLE_HEADER tableHeader;
    BOOLEAN resend;
    BOOLEAN firstPacketOfGlom = FALSE;
    PIRP irp;
    PIO_STACK_LOCATION irpSp;
    USHORT error;
    PTDI_REQUEST_KERNEL_RECEIVE parameters;
    PBUFFER requestBuffer;
    PWORK_QUEUE workQueue;

    PREQ_WRITE_MPX request;

    USHORT fid;
    PRFCB rfcb;
    PWRITE_MPX_CONTEXT writeMpx;
    USHORT index;
    KIRQL oldIrql;
    NTSTATUS status = STATUS_SUCCESS;

#if DBG
    workQueue = NULL;
    workContext = NULL;
    connection = NULL;

    if ( TransportContext ) {
        ASSERT( BytesAvailable == BytesIndicated );
    }
#endif

    //
    // Make sure we've received a complete SMB
    //
    if( BytesIndicated < sizeof( SMB_HEADER ) + sizeof( USHORT ) ) {
        //
        // Short SMB.  Eat it.
        //
        return STATUS_SUCCESS;
    }

    //
    // Pull out stuff we'll need later..
    //
    endpoint = (PENDPOINT)TdiEventContext;
    header = (PNT_SMB_HEADER)Tsdu;
    sid = SmbGetUshort( &header->Sid );
    sequenceNumber = SmbGetUshort( &header->SequenceNumber );

    ASSERT( *(PUCHAR)header == 0xff );  // Must be 0xff'SMB'
    ASSERT( endpoint != NULL );

    KeRaiseIrql( DISPATCH_LEVEL, &oldIrql );

    if ( sid == 0 ) {

        //
        // Must be a negotiate
        //
        if( header->Command != SMB_COM_NEGOTIATE ||
            GET_BLOCK_STATE( endpoint ) != BlockStateActive ) {

            KeLowerIrql( oldIrql );
            return STATUS_SUCCESS;
        }

        //
        // Do not accept new clients until the server has completed
        //  registering for PNP notifications
        //
        if( SrvCompletedPNPRegistration == FALSE ) {
            KeLowerIrql( oldIrql );
            return STATUS_SUCCESS;
        }

        //
        // Queue this to the fsp.
        //
        //
        // Save the sender's IPX address.
        //

        workQueue = PROCESSOR_TO_QUEUE();

        ALLOCATE_WORK_CONTEXT( workQueue, &workContext );

        if( workContext != NULL ) {
            workContext->ClientAddress->IpxAddress =
                                *(PTA_IPX_ADDRESS)SourceAddress;
            workContext->ClientAddress->DatagramOptions =
                                *(PIPX_DATAGRAM_OPTIONS)Options;

            irp = workContext->Irp;
            workContext->Endpoint = endpoint;
            workContext->QueueToHead = TRUE;
            workContext->FspRestartRoutine = IpxRestartNegotiate;

            if ( BytesAvailable == BytesIndicated ) {

                TdiCopyLookaheadData(
                    workContext->RequestBuffer->Buffer,
                    Tsdu,
                    BytesIndicated,
                    ReceiveDatagramFlags
                    );

                workContext->RequestBuffer->DataLength = BytesIndicated;

                *BytesTaken = BytesAvailable;
                goto queue_to_fsp;

            } else {

                workContext->FsdRestartRoutine = SrvQueueWorkToFsp;
                goto build_irp;

            }
        }

        //
        // Could not allocate a work context!
        //
        KeLowerIrql( oldIrql );

        InterlockedIncrement( &workQueue->NeedWorkItem );
        return STATUS_SUCCESS;
    }

    //
    // Not a Negotiate, and non-zero SID.
    // Check if the connection is cached.
    //

    idIndex = IPXSID_INDEX( sid );

    ACQUIRE_DPC_SPIN_LOCK(
        &ENDPOINT_SPIN_LOCK(idIndex & ENDPOINT_LOCK_MASK) );

    tableHeader = &endpoint->ConnectionTable;

    if ( (idIndex >= (USHORT)tableHeader->TableSize) ||
         ((connection = tableHeader->Table[idIndex].Owner) == NULL) ||
         (connection->Sid != sid) ||
         (GET_BLOCK_STATE(connection) != BlockStateActive) ) {

        IF_DEBUG(IPX2) {
            KdPrint(( "Bad Sid: " ));
            if ( idIndex >= (USHORT)tableHeader->TableSize ) {
                KdPrint(( "Index >= tableSize (index %d, size %d)\n",
                          idIndex, (USHORT)tableHeader->TableSize ));
            } else if( tableHeader->Table[ idIndex ].Owner == NULL ) {
                KdPrint(( "Owner == NULL\n" ));
            } else if( connection->Sid != sid ) {
                KdPrint(( "connection->Sid = %X, sid = %X\n", connection->Sid, sid ));
            } else {
                KdPrint(( "Connection blk state %X\n", GET_BLOCK_STATE( connection ) ));
            }
        }

        workQueue = PROCESSOR_TO_QUEUE();

        //
        // We have an invalid SID.  It would be nice to silently fail it,
        //  but that causes auto-reconnect on clients take an unnecessarily
        //  long time.
        //
        RELEASE_DPC_SPIN_LOCK( &
            ENDPOINT_SPIN_LOCK(idIndex & ENDPOINT_LOCK_MASK) );

        ALLOCATE_WORK_CONTEXT( workQueue, &workContext );

        if( workContext != NULL ) {
            error = SMB_ERR_BAD_SID;
            resend = FALSE;
            goto respond;
        }

        //
        // Unable to allocate workitem, give up
        //
        KeLowerIrql( oldIrql );

        InterlockedIncrement( &workQueue->NeedWorkItem );

        return STATUS_SUCCESS;

    }

#if MULTIPROCESSOR
    //
    // See if it's time to home this connection to another processor
    //
    if( --(connection->BalanceCount) == 0 ) {
        SrvBalanceLoad( connection );
    }

    workQueue = connection->CurrentWorkQueue;

#else

    workQueue = &SrvWorkQueues[0];

#endif

    //
    // The connection is active.  Record the time that this request
    // arrived.  If the sequence numbers match, handle this as a lost
    // response.
    //

    nextSequenceNumber = connection->SequenceNumber;
    GET_SERVER_TIME( workQueue, &connection->LastRequestTime );

    //
    // If this is a sequenced SMB, it has to have the right sequence
    // number: one greater than the current sequence number (but not 0).
    //

    if ( sequenceNumber != 0 ) {

        if ( nextSequenceNumber != 0 ) {

            ULONG tmpNext = nextSequenceNumber;

            if ( ++nextSequenceNumber == 0 ) nextSequenceNumber++;

            if ( sequenceNumber != nextSequenceNumber ) {

                if ( sequenceNumber == tmpNext ) {
                    goto duplicate_request;
                }

                //
                // Bad sequence number.  Ignore this message.
                //

                IF_DEBUG(IPX) KdPrint(( "SRVIPX: Bad sequence number; ignoring\n" ));

                RELEASE_DPC_SPIN_LOCK( connection->EndpointSpinLock );

                KeLowerIrql( oldIrql );
                return STATUS_SUCCESS;
            }
        }

        //
        // The sequence number is correct. Update the connection's sequence number and
        // indicate that we're processing this message.  (We need to
        // allocate the work item first because we're modifying
        // connection state.)  Then go receive the message.
        //

        ALLOCATE_WORK_CONTEXT( connection->CurrentWorkQueue, &workContext );
        if( workContext != NULL ) {

            IF_DEBUG(IPX) KdPrint(( "SRVIPX: Receiving sequenced request %x\n", sequenceNumber ));

            connection->SequenceNumber = sequenceNumber;
            connection->LastResponseLength = (USHORT)-1;
            connection->IpxDuplicateCount = 0;

            if ( header->Command == SMB_COM_WRITE_MPX ) {
                goto process_writempx;
            } else {
                goto process_not_writempx;
            }
        }

        //
        // Unable to allocate workitem, give up
        //
        RELEASE_DPC_SPIN_LOCK( connection->EndpointSpinLock );
        KeLowerIrql( oldIrql );
        InterlockedIncrement( &connection->CurrentWorkQueue->NeedWorkItem );

        return STATUS_SUCCESS;
    }

    //
    // Unsequenced SMB.  Check to see if it's being processed or is in
    // the queue to be processed.  If it's not, then we can process this
    // message.
    //
    // *** We don't do this check for write MPX because the multiple SMBs
    //     in a write MPX all have the same MID.
    //

    if ( header->Command != SMB_COM_WRITE_MPX ) {

        mid = SmbGetUshort( &header->Mid ); // NOT Aligned

        //
        // We need to receive this message.  Get a work item.
        //

        IF_DEBUG(IPX) {
            KdPrint(( "SRVIPX: Receiving unsequenced request mid=%x\n",
                        SmbGetUshort(&header->Mid) )); // NOT Aligned
        }

        for ( listEntry = connection->InProgressWorkItemList.Flink;
              listEntry != &connection->InProgressWorkItemList;
              listEntry = listEntry->Flink ) {

            PWORK_CONTEXT tmpWorkContext;

            tmpWorkContext = CONTAINING_RECORD(
                                        listEntry,
                                        WORK_CONTEXT,
                                        InProgressListEntry );

            if ( SmbGetAlignedUshort(&tmpWorkContext->RequestHeader->Mid) == mid ) {

                IF_DEBUG(IPX) KdPrint(( "SRVIPX: Duplicate (queued) unsequenced request mid=%x\n", mid ));
                if( connection->IpxDuplicateCount++ < connection->IpxDropDuplicateCount ) {
                    //
                    // We drop every few duplicate requests from the client
                    //
                    RELEASE_DPC_SPIN_LOCK( connection->EndpointSpinLock );
                    KeLowerIrql( oldIrql );
                    return STATUS_SUCCESS;
                }

                RELEASE_DPC_SPIN_LOCK( connection->EndpointSpinLock );
                error = SMB_ERR_WORKING;
                resend = FALSE;
                ALLOCATE_WORK_CONTEXT( connection->CurrentWorkQueue, &workContext );
                if( workContext != NULL ) {

                    connection->IpxDuplicateCount = 0;
                    goto respond;
                }

                //
                // Unable to allocate workitem, give up
                //

                RELEASE_DPC_SPIN_LOCK( connection->EndpointSpinLock );
                KeLowerIrql( oldIrql );
                InterlockedIncrement( &connection->CurrentWorkQueue->NeedWorkItem );
                return STATUS_SUCCESS;
            }
        }

        ALLOCATE_WORK_CONTEXT( connection->CurrentWorkQueue, &workContext );
        if( workContext != NULL ) {
            goto process_not_writempx;
        }

        //
        // Unable to allocate workitem, give up
        //

        RELEASE_DPC_SPIN_LOCK( connection->EndpointSpinLock );
        KeLowerIrql( oldIrql );
        InterlockedIncrement( &connection->CurrentWorkQueue->NeedWorkItem );
        return STATUS_SUCCESS;

    }

    ASSERT( workContext == NULL );

    ALLOCATE_WORK_CONTEXT( connection->CurrentWorkQueue, &workContext );
    if( workContext == NULL ) {
        //
        // Unable to allocate workitem, give up
        //
        RELEASE_DPC_SPIN_LOCK( connection->EndpointSpinLock );
        KeLowerIrql( oldIrql );
        InterlockedIncrement( &connection->CurrentWorkQueue->NeedWorkItem );
        return STATUS_SUCCESS;
    }

    connection->IpxDuplicateCount = 0;

process_writempx:

    //
    // Have we received enough of the message to interpret the request?
    //
    if( BytesIndicated < sizeof( SMB_HEADER ) + FIELD_OFFSET( REQ_WRITE_MPX, Buffer ) ) {
        //
        // Drop this fellow on the floor
        //
        RELEASE_DPC_SPIN_LOCK( connection->EndpointSpinLock );
        KeLowerIrql( oldIrql );
        return STATUS_SUCCESS;
    }

    //
    // Reference the connection so we can release the lock.
    //

    ASSERT( connection != NULL );
    ASSERT( workContext != NULL );
    SrvReferenceConnectionLocked( connection );
    workContext->Connection = connection;

    workContext->Parameters.WriteMpx.TransportContext = NULL;

    //
    // Put the work item on the in-progress list.
    //

    SrvInsertTailList(
        &connection->InProgressWorkItemList,
        &workContext->InProgressListEntry
        );
    connection->InProgressWorkContextCount++;

    //
    // The sequence number is correct.  Ensure that a work item is
    // available, then update the connection's sequence number and
    // indicate that we're processing this message.  (We need to
    // allocate the work item first because we're modifying
    // connection state.)  Then go receive the message.
    //

    ACQUIRE_DPC_SPIN_LOCK( &connection->SpinLock );

    RELEASE_DPC_SPIN_LOCK( connection->EndpointSpinLock );
    
    //
    // This is a Write Mpx request, we need to save some state, in
    // order to prevent unnecessary out-of-order completion of the
    // sequenced part of a Write Mpx, which would lead to unnecessary
    // retransmissions.
    //

    //
    // Find the RFCB associated with this request.
    //
    // *** The following is adapted from SrvVerifyFid2.
    //

    request = (PREQ_WRITE_MPX)(header + 1);
    fid = SmbGetUshort( &request->Fid );

    //
    // See if this is the cached rfcb.
    //

    if ( connection->CachedFid == fid ) {

        rfcb = connection->CachedRfcb;

    } else {

        //
        // Verify that the FID is in range, is in use, and has the
        // correct sequence number.
        //

        index = FID_INDEX( fid );
        tableHeader = &connection->FileTable;

        if ( (index >= (USHORT)tableHeader->TableSize) ||
             ((rfcb = tableHeader->Table[index].Owner) == NULL) ||
             (rfcb->Fid != fid) ) {
            error = ERROR_INVALID_HANDLE;
            goto bad_fid;
        }

        if ( GET_BLOCK_STATE(rfcb) != BlockStateActive ) {
            error = ERROR_INVALID_HANDLE;
            goto bad_fid;
        }

        //
        // Cache the FID.
        //

        connection->CachedRfcb = rfcb;
        connection->CachedFid = (ULONG)fid;

        //
        // If there is a write behind error, return the error to the
        // client.
        //
        // !!! For now, we ignore write behind errors.  Need to
        //     figure out how to translate the saved NT status to a
        //     DOS status...
        //

#if 0
        if ( !NT_SUCCESS(rfcb->SavedError) ) {
            status = rfcb->SavedError;
            rfcb->SavedError = STATUS_SUCCESS;
            goto bad_fid;
        }
#endif

        //
        // The FID is valid within the context of this connection.
        // Verify that the owning tree connect's TID is correct.
        //

        if ( (rfcb->Tid != SmbGetUshort(&header->Tid)) ||
             (rfcb->Uid != SmbGetUshort(&header->Uid)) ) {
            error = ERROR_INVALID_HANDLE;
            goto bad_fid;
        }
    }


    //
    // Mark the rfcb as active
    //

    rfcb->IsActive = TRUE;

    //
    // Since we don't support raw writes on IPX, there had
    // better not be one active.
    //

    ASSERT( rfcb->RawWriteCount == 0 );

    //
    // If the MID in the this packet is the same as the MID we're
    // currently working on, we can accept it.
    //

    writeMpx = &rfcb->WriteMpx;

    mid = SmbGetUshort( &header->Mid ); // NOT Aligned

    if ( mid == writeMpx->Mid ) {
        goto mpx_mid_ok;
    }

    //
    // If this a stale packet, ignore it.  Stale here means that the
    // MID of the packet is equal to the MID of the previous write
    // mux.  Such a packet can be received if a duplicate packet
    // from a previous write mux is delivered after a new write mux
    // starts.
    //
    // If this packet is for a new MID, but we're in the middle of
    // processing the current MID, then something is wrong -- the redir
    // should not send a new MID until we've replied to the old MID.
    // Ignore this packet.
    //

    if ( (mid == writeMpx->PreviousMid) || writeMpx->ReferenceCount ) {
        goto stale_mid;
    }

    //
    // It's not the MID we're currently working on, and it's not the
    // previous MID, and we're not glomming the current MID.  So we
    // have to assume it's a new MID.  If it's the first packet of a
    // write, we can prepare to glom.
    //
    // !!! This is a problem if we receive a delayed packet that is
    //     the first packet of a MID older than the last MID.  We
    //     will then put the file into glom mode for that old MID,
    //     will never be able to make progress on that file.
    //
    // !!! The mask == 1 test is not perfect.  It depends on the
    //     client using 1 in the first packet, which is not
    //     guaranteed by the protocol.
    //

    writeMpx->PreviousMid = writeMpx->Mid;
    writeMpx->Mid = mid;

#if SRVDBG_PERF
    if( GlommingAllowed )
#endif
    if ( (SmbGetUlong( &request->Mask ) == 1) && writeMpx->MpxGlommingAllowed ) {
        writeMpx->GlomPending = TRUE;
        firstPacketOfGlom = TRUE;
    }

mpx_mid_ok:

    //
    // Save the sender's IPX address.
    //

    workContext->Endpoint = endpoint;

    workContext->ClientAddress->IpxAddress = *(PTA_IPX_ADDRESS)SourceAddress;
    workContext->ClientAddress->DatagramOptions =
                                            *(PIPX_DATAGRAM_OPTIONS)Options;

    //
    // Bump the Write Mpx reference count in the RFCB.
    //

    writeMpx->ReferenceCount++;

    //
    // See if we can do indication time write glomming.
    // We will try this if:
    //  we are in the middle of write glomming and
    //  smb is valid    and
    //  we receive all the data  and
    //  smbtrace not active
    //
    if ( writeMpx->Glomming             &&
        ( BytesIndicated == BytesAvailable ) &&
        !SmbTraceActive[SMBTRACE_SERVER] ) {

        UCHAR wordCount;
        USHORT byteCount;
        PSMB_USHORT byteCountPtr;
        ULONG availableSpaceForSmb;

        header = (PNT_SMB_HEADER) Tsdu;
        params = (PVOID)(header + 1);

        wordCount = *((PUCHAR)params);
        byteCountPtr = (PSMB_USHORT)( (PCHAR)params +
                    sizeof(UCHAR) + (12 * sizeof(USHORT)) );
        byteCount =
            SmbGetUshort( (PSMB_USHORT)( (PCHAR)params +
                    sizeof(UCHAR) + (12 * sizeof(USHORT))) );

        availableSpaceForSmb = BytesIndicated - sizeof(SMB_HEADER);

        //
        // Validate the WriteMpx smb.
        //

        if ( (SmbGetUlong((PULONG)header->Protocol) == SMB_HEADER_PROTOCOL)
                &&
             ((CHAR)wordCount == 12)
                &&
             ((PCHAR)byteCountPtr <= (PCHAR)header + BytesIndicated -
                sizeof(USHORT))
                &&
             ((12*sizeof(USHORT) + sizeof(UCHAR) + sizeof(USHORT) +
                byteCount) <= availableSpaceForSmb) ) {

            //
            // The connection SpinLock is released in this routine.
            //

            if ( AddPacketToGlomInIndication(
                                    workContext,
                                    rfcb,
                                    Tsdu,
                                    BytesAvailable,
                                    ReceiveDatagramFlags,
                                    SourceAddress,
                                    Options
                                    ) ) {

                //
                // We need to clean up the connection.
                //

                goto return_connection;
            }

            KeLowerIrql( oldIrql );
            return(STATUS_SUCCESS);
        }
    }

    //
    // The file is active and the TID is valid.  Reference the
    // RFCB.
    //

    rfcb->BlockHeader.ReferenceCount++;
    UPDATE_REFERENCE_HISTORY( rfcb, FALSE );

    RELEASE_DPC_SPIN_LOCK( &connection->SpinLock );

    workContext->Parameters.WriteMpx.FirstPacketOfGlom = firstPacketOfGlom;

    //
    // Save the RFCB address in the work context block.
    //

    ASSERT( workContext->Rfcb == NULL );
    workContext->Rfcb = rfcb;

    //
    // Change the FSP restart routine for the work item to one
    // that's specific to Write Mpx.  This is necessary in order
    // to do proper cleanup if a receive error occurs.
    //

    workContext->FspRestartRoutine = SrvRestartReceiveWriteMpx;
    goto start_receive;

process_not_writempx:

    //
    // Reference the connection and save a pointer to it in the work
    // item.
    //

    ASSERT( connection != NULL );
    ASSERT( workContext != NULL );
    ASSERT( workContext->FsdRestartRoutine == SrvQueueWorkToFspAtDpcLevel );
    SrvReferenceConnectionLocked( connection );

    //
    // Put the work item on the in-progress list.
    //

    SrvInsertTailList(
        &connection->InProgressWorkItemList,
        &workContext->InProgressListEntry
        );
    connection->InProgressWorkContextCount++;

    RELEASE_DPC_SPIN_LOCK( connection->EndpointSpinLock );

    //
    // Save the sender's IPX address.
    //

    workContext->Connection = connection;
    workContext->Endpoint = endpoint;

    workContext->ClientAddress->IpxAddress = *(PTA_IPX_ADDRESS)SourceAddress;
    workContext->ClientAddress->DatagramOptions =
                                            *(PIPX_DATAGRAM_OPTIONS)Options;

    if ( header->Command == SMB_COM_LOCKING_ANDX ) {

        //
        // If this is a Locking&X SMB that includes at least one unlock
        // request, we want to process the request quickly.  So we put
        // it at the head of the work queue.
        //

        PREQ_LOCKING_ANDX request = (PREQ_LOCKING_ANDX)(header + 1);

#if SRVDBG_PERF
        if( UnlocksGoFast )
#endif
        if( (PCHAR)header + BytesIndicated >= (PCHAR)(&request->ByteCount) &&
            SmbGetUshort(&request->NumberOfUnlocks) != 0 ) {
            workContext->QueueToHead = TRUE;
        }

    } else if ( (header->Command == SMB_COM_READ) &&
                (BytesIndicated == BytesAvailable) ) {

        //
        // Copy the indicated data.
        //

        TdiCopyLookaheadData(
            workContext->RequestBuffer->Buffer,
            Tsdu,
            BytesIndicated,
            ReceiveDatagramFlags
            );

        workContext->RequestBuffer->DataLength = BytesIndicated;

        //
        // See if we are all set to do the fast path.
        //

        if ( SetupIpxFastCoreRead( workContext ) ) {

            workContext->FspRestartRoutine = SrvIpxFastRestartRead;
            workContext->ProcessingCount++;
            workQueue->stats.BytesReceived += BytesIndicated;

            //
            // Insert the work item at the tail of the nonblocking
            // work queue.
            //

            SrvInsertWorkQueueTail(
                workQueue,
                (PQUEUEABLE_BLOCK_HEADER)workContext
                );

            KeLowerIrql( oldIrql );
            return STATUS_SUCCESS;
        }

        irp = workContext->Irp;
        goto queue_to_fsp;

    } else if ( (header->Command == SMB_COM_OPEN_ANDX) ||
                (header->Command == SMB_COM_NT_CREATE_ANDX) ) {

        //
        // If this is an attempt to open a file, route the
        // request to a blocking worker thread.  This keeps opens
        // out of the way of handle-based operations.
        //

#if SRVDBG_PERF
        if( OpensGoSlow )
#endif
        {
            workContext->FsdRestartRoutine = SrvQueueWorkToBlockingThread;
            workQueue = &SrvBlockingWorkQueue;
        }

    } else if ( (header->Command == SMB_COM_CLOSE) ||
                (header->Command == SMB_COM_FIND_CLOSE) ||
                (header->Command == SMB_COM_FIND_CLOSE2) ) {
        //
        // Closing things is an operation that (1) releases resources, (2) is usually
        // fast, and (3) can't be repeated indefinately by the client.  Give the client
        // a reward by putting it at the head of the queue.
        //
        workContext->QueueToHead = TRUE;
    }

start_receive:

    //
    // If the SMB is completely within the indicated data, copy it
    // directly into the buffer, avoiding the overhead of passing an IRP
    // down to the transport.
    //

    irp = workContext->Irp;

    if ( BytesIndicated == BytesAvailable ) {

        //
        // If this is a WRITE_MPX, and the buffer is big (how big is BIG?)
        // and there is a TransportContext (indicating that we can take the
        // NDIS buffer, then don't copy the data - just save the buffer
        // address, length and transport context.
        //

        if ( BytesIndicated > SrvMaxCopyLength &&
             header->Command == SMB_COM_WRITE_MPX &&
             TransportContext ) {

            workContext->Parameters.WriteMpx.Buffer = Tsdu;
            workContext->Parameters.WriteMpx.ReceiveDatagramFlags =
                            ReceiveDatagramFlags;
            workContext->Parameters.WriteMpx.TransportContext = TransportContext;

            DEBUG *BytesTaken = BytesIndicated;

            ASSERT( BytesIndicated >= MPX_HEADER_SIZE );

            TdiCopyLookaheadData(
                workContext->RequestBuffer->Buffer,
                Tsdu,
                MPX_HEADER_SIZE,
                ReceiveDatagramFlags
                );

            status = STATUS_PENDING;

        } else {

            TdiCopyLookaheadData(
                workContext->RequestBuffer->Buffer,
                Tsdu,
                BytesIndicated,
                ReceiveDatagramFlags
                );

            // NB: status is set to STATUS_SUCCESS above!
        }

#if SRVDBG_PERF
        if ( Trap512s ) {
            if ( header->Command == SMB_COM_READ ) {
                PREQ_READ request = (PREQ_READ)(header + 1);
                if ( (SmbGetUshort(&request->Count) == 512) &&
                     ((SmbGetUlong(&request->Offset) & 511) == 0) ) {
                    PRESP_READ response;
                    if (Break512s) DbgBreakPoint();
                    Trapped512s++;
                    response = (PRESP_READ)workContext->ResponseParameters;
                    response->WordCount = 5;
                    SmbPutUshort( &response->Count, 512 );
                    RtlZeroMemory( (PVOID)&response->Reserved[0], sizeof(response->Reserved) );
                    SmbPutUshort(
                        &response->ByteCount,
                        (USHORT)(512 + FIELD_OFFSET(RESP_READ,Buffer[0]) -
                                                FIELD_OFFSET(RESP_READ,BufferFormat))
                        );
                    response->BufferFormat = SMB_FORMAT_DATA;
                    SmbPutUshort( &response->DataLength, 512 );
                    workContext->ResponseParameters = NEXT_LOCATION(
                                                        response,
                                                        RESP_READ,
                                                        512
                                                        );
                    SrvFsdSendResponse( workContext );
                    return STATUS_SUCCESS;
                }
            }
        }
#endif // SRVDBG_PERF

queue_to_fsp:

        //
        // Pretend the transport completed an IRP by doing what the
        // restart routine, which is known to be
        // SrvQueueWorkToFspAtDpcLevel, would do.
        //

        irp->IoStatus.Status = STATUS_SUCCESS;
        irp->IoStatus.Information = BytesIndicated;

        irp->Cancel = FALSE;

        //
        // *** THE FOLLOWING IS COPIED FROM SrvQueueWorkToFspAtDpcLevel.
        //
        // Increment the processing count.
        //

        workContext->ProcessingCount++;

        //
        // Insert the work item into the work queue
        //

        if( workContext->QueueToHead ) {

            SrvInsertWorkQueueHead(
                workQueue,
                (PQUEUEABLE_BLOCK_HEADER)workContext
                );

        } else {

            SrvInsertWorkQueueTail(
                workQueue,
                (PQUEUEABLE_BLOCK_HEADER)workContext
                );

        }

        KeLowerIrql( oldIrql );
        return status;

    }

build_irp:

    //
    // We can't copy the indicated data.  Set up the receive IRP.
    //

    ASSERT( workQueue != NULL );

    irp->Tail.Overlay.OriginalFileObject = NULL;
    irp->Tail.Overlay.Thread = workQueue->IrpThread;

    DEBUG irp->RequestorMode = KernelMode;

    //
    // Set up the completion routine.
    //

    IoSetCompletionRoutine(
        irp,
        SrvFsdIoCompletionRoutine,
        workContext,
        TRUE,
        TRUE,
        TRUE
        );

    //
    // Make the next stack location current.  Normally IoCallDriver
    // would do this, but since we're bypassing that, we do it directly.
    // Load the target device object address into the stack location.
    // This especially important because the server likes to reuse IRPs.
    //
    // Get a pointer to the next stack location.  This one is used to
    // hold the parameters for the device I/O control request.
    //

    IoSetNextIrpStackLocation( irp );
    irpSp = IoGetCurrentIrpStackLocation( irp );

    irpSp->MajorFunction = IRP_MJ_INTERNAL_DEVICE_CONTROL;
    irpSp->MinorFunction = (UCHAR)TDI_RECEIVE_DATAGRAM;

    //
    // Copy the caller's parameters to the service-specific portion of the
    // IRP for those parameters that are the same for all three methods.
    //

    requestBuffer = workContext->RequestBuffer;

    parameters = (PTDI_REQUEST_KERNEL_RECEIVE)&irpSp->Parameters;
    parameters->ReceiveLength = requestBuffer->BufferLength;
    parameters->ReceiveFlags = 0;

    irp->MdlAddress = requestBuffer->Mdl;
    irp->AssociatedIrp.SystemBuffer = NULL;

    irpSp->Flags = 0;
    irpSp->DeviceObject = endpoint->DeviceObject;
    irpSp->FileObject = endpoint->FileObject;

    ASSERT( irp->StackCount >= irpSp->DeviceObject->StackSize );

    //
    // Return STATUS_MORE_PROCESSING_REQUIRED so that the transport
    // provider will use our IRP to service the receive.
    //

    *IoRequestPacket = irp;
    *BytesTaken = 0;

    KeLowerIrql( oldIrql );
    return STATUS_MORE_PROCESSING_REQUIRED;

bad_fid:

    //
    // An invalid FID was specified on a Write Mpx request, or there was
    // a saved write behind error in the RFCB.  If this is an
    // unsequenced request, we drop it on the floor.  If it's a
    // sequenced request, we send an error response.
    //

    if ( sequenceNumber == 0 ) {

stale_mid:
        RELEASE_DPC_SPIN_LOCK( &connection->SpinLock );
        goto return_connection;
    }

    RELEASE_DPC_SPIN_LOCK( &connection->SpinLock );

    ASSERT( workContext->Connection != NULL );
    SrvFreeIpxConnectionInIndication( workContext );

    resend = FALSE;
    goto respond;

duplicate_request:

    //
    // This is a duplicate request.  If it's still being processed,
    // indicate that to the client.
    //

    if ( connection->LastResponseLength == (USHORT)-1 ) {

        IF_DEBUG(IPX) KdPrint(( "SRVIPX: request in progress\n" ));

        if( connection->IpxDuplicateCount++ < connection->IpxDropDuplicateCount ) {
            //
            // We drop every few duplicate request from the client
            //
            RELEASE_DPC_SPIN_LOCK( connection->EndpointSpinLock );
            KeLowerIrql( oldIrql );
            return STATUS_SUCCESS;
        }

        RELEASE_DPC_SPIN_LOCK( connection->EndpointSpinLock );
        connection->IpxDuplicateCount = 0;
        error = SMB_ERR_WORKING;
        resend = FALSE;

    } else {

        //
        // The request has already been completed.  Resend the response.
        //

        IF_DEBUG(IPX) KdPrint(( "SRVIPX: resending response\n" ));
        resend = TRUE;
    }

    ALLOCATE_WORK_CONTEXT( connection->CurrentWorkQueue, &workContext );
    if( workContext == NULL ) {

        if( resend == TRUE ) {
            RELEASE_DPC_SPIN_LOCK( connection->EndpointSpinLock );
        }

        KeLowerIrql( oldIrql );
        InterlockedIncrement( &connection->CurrentWorkQueue->NeedWorkItem );
        return STATUS_SUCCESS;
    }


respond:

    ASSERT( workContext != NULL );

    //
    // Copy the received SMB header into the response buffer.
    //

    RtlCopyMemory(
        workContext->ResponseBuffer->Buffer,
        header,
        sizeof(NT_SMB_HEADER)
        );

    header = (PNT_SMB_HEADER)workContext->ResponseBuffer->Buffer;
    params = (PSMB_PARAMS)(header + 1);

    header->Flags |= SMB_FLAGS_SERVER_TO_REDIR;

    //
    // Format the parameters portion of the SMB, and set the status.
    //

    if ( !resend ) {

        SmbPutUshort( &header->Status.DosError.Error, error );
        header->Status.DosError.ErrorClass = SMB_ERR_CLASS_SERVER;
        header->Status.DosError.Reserved = 0;
        params->WordCount = 0;
        SmbPutUshort( &params->ByteCount, 0 );
        length = sizeof(NT_SMB_HEADER) + sizeof(SMB_PARAMS);

    } else {

        //
        // Copy the saved response data into the response.
        //

        SmbPutUlong( &header->Status.NtStatus, connection->LastResponseStatus );

        SmbPutUshort( &header->Tid, connection->LastTid);
        SmbPutUshort( &header->Uid, connection->LastUid);

        RtlCopyMemory(
            (PVOID)params,
            connection->LastResponse,
            connection->LastResponseLength
            );
        length = sizeof(NT_SMB_HEADER) + connection->LastResponseLength;
        RELEASE_DPC_SPIN_LOCK( connection->EndpointSpinLock );
    }

    workContext->ResponseBuffer->DataLength = length;
    workContext->ResponseBuffer->Mdl->ByteCount = length;

    //
    // Format the destination address.
    //

    workContext->ClientAddress->IpxAddress = *(PTA_IPX_ADDRESS)SourceAddress;
    workContext->ClientAddress->DatagramOptions =
                                            *(PIPX_DATAGRAM_OPTIONS)Options;

    //
    // Send the packet.
    //

    workContext->Endpoint = endpoint;
    DEBUG workContext->FsdRestartRoutine = NULL;

    StartSendNoConnection( workContext, FALSE, TRUE );

    KeLowerIrql( oldIrql );
    return STATUS_SUCCESS;

return_connection:

    SrvFreeIpxConnectionInIndication( workContext );
    KeLowerIrql( oldIrql );

    workContext->BlockHeader.ReferenceCount = 0;
    RETURN_FREE_WORKITEM( workContext );

    return STATUS_SUCCESS;

} // SrvIpxServerDatagramHandlerCommon


NTSTATUS
SrvIpxServerDatagramHandler (
    IN PVOID TdiEventContext,
    IN int SourceAddressLength,
    IN PVOID SourceAddress,
    IN int OptionsLength,
    IN PVOID Options,
    IN ULONG ReceiveDatagramFlags,
    IN ULONG BytesIndicated,
    IN ULONG BytesAvailable,
    OUT ULONG *BytesTaken,
    IN PVOID Tsdu,
    OUT PIRP *IoRequestPacket
    )

/*++

Routine Description:

    This is the receive datagram event handler for the IPX server socket.
    It attempts to dequeue a preformatted work item from a list
    anchored in the device object.  If this is successful, it returns
    the IRP associated with the work item to the transport provider to
    be used to receive the data.  Otherwise, the message is dropped.

Arguments:

    TdiEventContext - Pointer to receiving endpoint

    SourceAddressLength - Length of SourceAddress

    SourceAddress - Address of sender

    OptionsLength - Length of options

    Options - Options for the receive

    ReceiveDatagramFlags - Set of flags indicating the status of the
        received message

    BytesIndicated - Number of bytes in this indication (lookahead)

    BytesAvailable - Number of bytes in the complete TSDU

    BytesTaken - Returns the number of bytes taken by the handler

    Tsdu - Pointer to buffer describing the Transport Service Data Unit

    IoRequestPacket - Returns a pointer to I/O request packet, if the
        returned status is STATUS_MORE_PROCESSING_REQUIRED.  This IRP is
        made the 'current' Receive for the endpoint.

Return Value:

    NTSTATUS - If STATUS_SUCCESS, the receive handler completely
        processed the request.  If STATUS_MORE_PROCESSING_REQUIRED,
        the Irp parameter points to a formatted Receive request to
        be used to receive the data.  If STATUS_DATA_NOT_ACCEPTED,
        the message is lost.

--*/

{
    NTSTATUS status;

    status = SrvIpxServerDatagramHandlerCommon(
                    TdiEventContext,
                    SourceAddressLength,
                    SourceAddress,
                    OptionsLength,
                    Options,
                    ReceiveDatagramFlags,
                    BytesIndicated,
                    BytesAvailable,
                    BytesTaken,
                    Tsdu,
                    IoRequestPacket,
                    NULL
                    );

    ASSERT( status != STATUS_PENDING );
    return status;

} // SrvIpxServerDatagramHandler


NTSTATUS
SrvIpxServerChainedDatagramHandler (
    IN PVOID TdiEventContext,
    IN int SourceAddressLength,
    IN PVOID SourceAddress,
    IN int OptionsLength,
    IN PVOID Options,
    IN ULONG ReceiveDatagramFlags,
    IN ULONG ReceiveDatagramLength,
    IN ULONG StartingOffset,
    IN PMDL Tsdu,
    IN PVOID TransportContext
    )

/*++

Routine Description:

    This is the receive datagram event handler for the IPX server socket.
    It attempts to dequeue a preformatted work item from a list
    anchored in the device object.  If this is successful, it returns
    the IRP associated with the work item to the transport provider to
    be used to receive the data.  Otherwise, the message is dropped.

Arguments:

    TdiEventContext - Pointer to receiving endpoint

    SourceAddressLength - Length of SourceAddress

    SourceAddress - Address of sender

    OptionsLength - Length of options

    Options - Options for the receive

    ReceiveDatagramFlags - Set of flags indicating the status of the
        received message

    ReceiveDatagramLength - The length in byutes of the client data in the Tsdu

    StartingOffset - Offset, in bytes, from beginning of Tsdu to client's data

    Tsdu - Pointer to an MDL chain describing the received data

    TranportContext - Context to be passed to TdiReturnChainedReceives if
        buffer is taken


Return Value:

    NTSTATUS - If STATUS_SUCCESS, the receive handler completely
        processed the request.  If STATUS_PENDING, the receive buffer was
        taken and it will be returned via TdiReturnChainedReceives. If
        If STATUS_DATA_NOT_ACCEPTED, the message is lost.

--*/

{
    PVOID receiveBuffer;
    ULONG bytesTaken;
    NTSTATUS status;
    PIRP ioRequestPacket = NULL;

    ASSERT( StartingOffset < 512 );
    receiveBuffer = (PCHAR)MmGetSystemAddressForMdl( Tsdu ) + StartingOffset;

    status = SrvIpxServerDatagramHandlerCommon(
                    TdiEventContext,
                    SourceAddressLength,
                    SourceAddress,
                    OptionsLength,
                    Options,
                    ReceiveDatagramFlags,
                    ReceiveDatagramLength,
                    ReceiveDatagramLength,
                    &bytesTaken,
                    receiveBuffer,
                    &ioRequestPacket,
                    TransportContext
                    );

    ASSERT( ioRequestPacket == NULL );

    DEBUG if ( status == STATUS_PENDING ) {
        ASSERT( bytesTaken == ReceiveDatagramLength );
    }

    return status;

} // SrvIpxServerChainedDatagramHandler


VOID
SrvIpxStartSend (
    IN OUT PWORK_CONTEXT WorkContext,
    IN PIO_COMPLETION_ROUTINE SendCompletionRoutine
    )

/*++

Routine Description:

    This function sends an SMB/IPX name claim request or response.  It
    is started as an asynchronous I/O request.  When the Send completes,
    the restart routine preloaded into the work context is called.

Arguments:

    WorkContext - Supplies a pointer to a Work Context block

Return Value:

    None.

--*/

{
    PENDPOINT endpoint;
    PCONNECTION connection;
    PTDI_REQUEST_KERNEL_SENDDG parameters;
    PIO_STACK_LOCATION irpSp;
    PIRP irp;
    PMDL mdl;
    ULONG sendLength;
    USHORT responseLength;
    PDEVICE_OBJECT deviceObject;
    PFILE_OBJECT fileObject;
    PTDI_CONNECTION_INFORMATION destination;
    PNT_SMB_HEADER header;

//    IF_DEBUG(IPX2) SrvPrint0( "SrvIpxStartSend entered\n" );

    //
    // Set ProcessingCount to zero so this send cannot be cancelled.
    // This is used together with setting the cancel flag to false below.
    //
    // WARNING: This still presents us with a tiny window where this
    // send could be cancelled.
    //

    WorkContext->ProcessingCount = 0;

    //
    // Count up the length of the data described by chained MDLs.
    //

    sendLength = WorkContext->ResponseBuffer->DataLength;

    //
    // Get the MDL pointer.
    //

    mdl = WorkContext->ResponseBuffer->Mdl;

    //
    // Build the I/O request packet.
    //
    // *** Note that the connection block is not referenced to account
    //     for this I/O request.  The WorkContext block already has a
    //     referenced pointer to the connection, and this pointer is not
    //     dereferenced until after the I/O completes.
    //

    irp = WorkContext->Irp;

    irp->Tail.Overlay.Thread = WorkContext->CurrentWorkQueue->IrpThread;
    DEBUG irp->RequestorMode = KernelMode;

    //
    // Get a pointer to the next stack location.  This one is used to
    // hold the parameters for the device I/O control request.
    //

    irpSp = IoGetNextIrpStackLocation( irp );

    //
    // Set up the completion routine.
    //

    IoSetCompletionRoutine(
        irp,
        SendCompletionRoutine,
        (PVOID)WorkContext,
        TRUE,
        TRUE,
        TRUE
        );

    destination = &WorkContext->ClientAddress->Descriptor;

    destination->UserDataLength = 0;
    destination->OptionsLength = sizeof(IPX_DATAGRAM_OPTIONS);
    destination->Options = &WorkContext->ClientAddress->DatagramOptions;
    destination->RemoteAddressLength = sizeof(TA_IPX_ADDRESS);
    destination->RemoteAddress = &WorkContext->ClientAddress->IpxAddress;

    parameters = (PTDI_REQUEST_KERNEL_SENDDG)&irpSp->Parameters;
    parameters->SendLength = sendLength;
    parameters->SendDatagramInformation = destination;

    endpoint = WorkContext->Endpoint;

    ASSERT( endpoint->IsConnectionless );

    deviceObject = endpoint->DeviceObject;
    fileObject = endpoint->FileObject;

    ASSERT( irp->StackCount >= deviceObject->StackSize );

    irp->MdlAddress = mdl;
    irp->Tail.Overlay.OriginalFileObject = fileObject;
    irpSp->FileObject = fileObject;

    //
    // If this is a sequenced message, save the response data.
    //

    header = (PNT_SMB_HEADER)WorkContext->ResponseHeader;
    ASSERT( header != NULL );
    connection = WorkContext->Connection;
    ASSERT( connection != NULL );

    if ( SmbGetAlignedUshort(&header->SequenceNumber) != 0 ) {

        IF_DEBUG(IPX) {
            KdPrint(("SRVIPX: Responding to sequenced request %x mid=%x, connection %p\n",
                        SmbGetAlignedUshort(&header->SequenceNumber),
                        SmbGetAlignedUshort(&header->Mid), connection ));
        }
        ASSERT( sendLength - sizeof(SMB_HEADER) < 0x10000 );
        responseLength = (USHORT)(sendLength - sizeof(SMB_HEADER));
        IF_DEBUG(IPX) {
            KdPrint(("SRVIPX: parameters length %x, max=%x\n",
                        responseLength, MAX_SAVED_RESPONSE_LENGTH ));
        }

        if ( responseLength > MAX_SAVED_RESPONSE_LENGTH ) {

            //
            // The response is too large to save.  The client shouldn't
            // be doing this, except on transactions, for which we save
            // a copy of the full response.
            //

            if ( (header->Command == SMB_COM_TRANSACTION) ||
                 (header->Command == SMB_COM_TRANSACTION_SECONDARY) ||
                 (header->Command == SMB_COM_TRANSACTION2) ||
                 (header->Command == SMB_COM_TRANSACTION2_SECONDARY) ) {

                //
                // We need a buffer to hold the response.  If a buffer
                // has already been allocated, and is large enough, use
                // it.  Otherwise, allocate one.
                //

                IF_DEBUG(IPX) {
                    KdPrint(("SRVIPX: transaction; saving long response\n" ));
                }
                if ( (connection->LastResponse == connection->BuiltinSavedResponse) ||
                     (connection->LastResponseBufferLength < responseLength) ) {

                    PVOID resp = ALLOCATE_NONPAGED_POOL( responseLength, BlockTypeDataBuffer );

                    if( resp != NULL ) {
                        if ( connection->LastResponse != connection->BuiltinSavedResponse ) {
                            IF_DEBUG(IPX) {
                                KdPrint(("SRVIPX: deallocating old response buffer %p\n",
                                            connection->LastResponse ));
                            }
                            DEALLOCATE_NONPAGED_POOL( connection->LastResponse );
                        }

                        connection->LastResponse = resp;

                        IF_DEBUG(IPX) {
                            KdPrint(("SRVIPX: new response buffer %p\n",
                                        connection->LastResponse ));
                        }
                        connection->LastResponseBufferLength = responseLength;
                    }
                }

            } else {

                IF_DEBUG(IPX) {
                    KdPrint(("SRVIPX: not a transaction; illegal long response\n" ));
                }
                SmbPutUshort( &header->Status.DosError.Error, SMB_ERR_ERROR );
                header->Status.DosError.ErrorClass = SMB_ERR_CLASS_SERVER;
                header->Status.DosError.Reserved = 0;
                *(PLONG)(header + 1) = 0; // set WCT and BCC to 0

                sendLength = sizeof(SMB_HEADER) + sizeof(SMB_PARAMS);
                responseLength = 3;

                mdl->ByteCount = sendLength;
                parameters->SendLength = sendLength;

                goto small_response;
            }

        } else {

small_response:
            //
            // The response fits in the built-in buffer.
            //

            IF_DEBUG(IPX) {
                KdPrint(("SRVIPX: response fits in builtin response buffer\n" ));
            }
            if ( connection->LastResponse != connection->BuiltinSavedResponse ) {
                IF_DEBUG(IPX) {
                    KdPrint(("SRVIPX: deallocating old response buffer %p\n",
                                connection->LastResponse ));
                }
                DEALLOCATE_NONPAGED_POOL( connection->LastResponse );
                connection->LastResponse = connection->BuiltinSavedResponse;
                connection->LastResponseBufferLength = sizeof( connection->BuiltinSavedResponse );
            }

        }

        //
        // Save the response data in the connection.
        //

        connection->LastResponseStatus = SmbGetUlong( &header->Status.NtStatus );
        connection->LastUid = SmbGetUshort( &header->Uid );
        connection->LastTid = SmbGetUshort( &header->Tid );

        connection->LastResponseLength = MIN( responseLength, connection->LastResponseBufferLength );
        RtlCopyMemory( connection->LastResponse, (header + 1), connection->LastResponseLength );


    } else {

        IF_DEBUG(IPX) {
            KdPrint(("SRVIPX: Responding to unsequenced request mid=%x\n",
                        SmbGetAlignedUshort(&header->Mid) ));
        }
    }

    //
    // If statistics are to be gathered for this work item, do so now.
    //

    UPDATE_STATISTICS(
        WorkContext,
        sendLength,
        WorkContext->ResponseHeader->Command
        );

    //
    // If SmbTrace is active and we're in a context where the SmbTrace
    // shared section isn't accessible, send this off to the FSP.
    //

    if ( SmbTraceActive[SMBTRACE_SERVER] ) {

        if ((KeGetCurrentIrql() == DISPATCH_LEVEL) ||
            (IoGetCurrentProcess() != SrvServerProcess)) {

            irp->AssociatedIrp.SystemBuffer = NULL;
            irp->Flags = (ULONG)IRP_BUFFERED_IO;

            irpSp->MajorFunction = IRP_MJ_INTERNAL_DEVICE_CONTROL;
            irpSp->MinorFunction = TDI_SEND_DATAGRAM;

            WorkContext->Parameters2.StartSend.FspRestartRoutine =
                                            WorkContext->FspRestartRoutine;
            WorkContext->Parameters2.StartSend.SendLength = sendLength;

            WorkContext->FspRestartRoutine = RestartStartSend;
            SrvQueueWorkToFsp( WorkContext );

            return;

        } else {

            SMBTRACE_SRV( mdl );

        }
    }

    //
    // Pass the request to the transport provider.
    //
        
    //
    // Increment the pending operation count
    //
    InterlockedIncrement( &WorkContext->Connection->OperationsPendingOnTransport );

    //
    // Set the cancel flag to FALSE in case this was cancelled by
    // the SrvSmbNtCancel routine.
    //

    if ( endpoint->FastTdiSendDatagram ) {

        INCREMENT_DEBUG_STAT2( SrvDbgStatistics.DirectSendsAttempted );
        DEBUG irpSp->DeviceObject = deviceObject;
        irpSp->MinorFunction = TDI_DIRECT_SEND_DATAGRAM;
        IoSetNextIrpStackLocation( irp );
        irp->Cancel = FALSE;

        endpoint->FastTdiSendDatagram( deviceObject, irp );

    } else {

        irp->AssociatedIrp.SystemBuffer = NULL;
        irp->Flags = (ULONG)IRP_BUFFERED_IO;
        irp->Cancel = FALSE;

        irpSp->MajorFunction = IRP_MJ_INTERNAL_DEVICE_CONTROL;
        irpSp->MinorFunction = TDI_SEND_DATAGRAM;

        (VOID)IoCallDriver( deviceObject, irp );
    }

    return;

} // SrvIpxStartSend


VOID
StartSendNoConnection (
    IN OUT PWORK_CONTEXT WorkContext,
    IN BOOLEAN UseNameSocket,
    IN BOOLEAN LocalTargetValid
    )

/*++

Routine Description:

    This function sends an SMB/IPX name claim request or response.  It
    is started as an asynchronous I/O request.  When the Send completes,
    the restart routine preloaded into the work context is called.

Arguments:

    WorkContext - Supplies a pointer to a Work Context block

    UseNameSocket - Indicates whether the name socket or the server
        socket is to be used.

Return Value:

    None.

--*/

{
    PENDPOINT endpoint;
    PTDI_REQUEST_KERNEL_SENDDG parameters;
    PIO_STACK_LOCATION irpSp;
    PIRP irp;
    ULONG sendLength;
    PDEVICE_OBJECT deviceObject;
    PFILE_OBJECT fileObject;
    PTDI_CONNECTION_INFORMATION destination;

    //
    // Set ProcessingCount to zero so this send cannot be cancelled.
    // This is used together with setting the cancel flag to false below.
    //
    // WARNING: This still presents us with a tiny window where this
    // send could be cancelled.
    //

    WorkContext->ProcessingCount = 0;

    //
    // Count up the length of the data described by chained MDLs.
    //

    sendLength = WorkContext->ResponseBuffer->DataLength;

    //
    // Build the I/O request packet.
    //
    // *** Note that the connection block is not referenced to account
    //     for this I/O request.  The WorkContext block already has a
    //     referenced pointer to the connection, and this pointer is not
    //     dereferenced until after the I/O completes.
    //

    irp = WorkContext->Irp;

    irp->Tail.Overlay.Thread = WorkContext->CurrentWorkQueue->IrpThread;
    DEBUG irp->RequestorMode = KernelMode;

    //
    // Get a pointer to the next stack location.  This one is used to
    // hold the parameters for the device I/O control request.
    //

    irpSp = IoGetNextIrpStackLocation( irp );

    //
    // Set up the completion routine.
    //

    IoSetCompletionRoutine(
        irp,
        RequeueIpxWorkItemAtSendCompletion,
        (PVOID)WorkContext,
        TRUE,
        TRUE,
        TRUE
        );

    destination = &WorkContext->ClientAddress->Descriptor;

    destination->UserDataLength = 0;
    destination->OptionsLength =
            LocalTargetValid ? sizeof(IPX_DATAGRAM_OPTIONS) : sizeof(UCHAR);
    ASSERT( FIELD_OFFSET( IPX_DATAGRAM_OPTIONS, PacketType ) == 0 );
    destination->Options = &WorkContext->ClientAddress->DatagramOptions;
    destination->RemoteAddressLength = sizeof(TA_IPX_ADDRESS);
    destination->RemoteAddress = &WorkContext->ClientAddress->IpxAddress;

    parameters = (PTDI_REQUEST_KERNEL_SENDDG)&irpSp->Parameters;
    parameters->SendLength = sendLength;
    parameters->SendDatagramInformation = destination;

    irp->MdlAddress = WorkContext->ResponseBuffer->Mdl;

    endpoint = WorkContext->Endpoint;

    ASSERT( endpoint->IsConnectionless );

    if ( !UseNameSocket ) {

        deviceObject = endpoint->DeviceObject;
        fileObject = endpoint->FileObject;

    } else {

        deviceObject = endpoint->NameSocketDeviceObject;
        fileObject = endpoint->NameSocketFileObject;

    }

    ASSERT( irp->StackCount >= deviceObject->StackSize );

    irp->Tail.Overlay.OriginalFileObject = fileObject;
    irpSp->FileObject = fileObject;

    //
    // Pass the request to the transport provider.
    //                                                                                 
    
    //
    // Set the cancel flag to FALSE in case this was cancelled by
    // the SrvSmbNtCancel routine.
    //

    irp->Cancel = FALSE;

    if ( endpoint->FastTdiSendDatagram ) {

        INCREMENT_DEBUG_STAT2( SrvDbgStatistics.DirectSendsAttempted );
        DEBUG irpSp->DeviceObject = deviceObject;
        irpSp->MinorFunction = TDI_DIRECT_SEND_DATAGRAM;
        IoSetNextIrpStackLocation( irp );

        endpoint->FastTdiSendDatagram( deviceObject, irp );

    } else {

        irp->AssociatedIrp.SystemBuffer = NULL;
        irp->Flags = (ULONG)IRP_BUFFERED_IO;

        irpSp->MajorFunction = IRP_MJ_INTERNAL_DEVICE_CONTROL;
        irpSp->MinorFunction = TDI_SEND_DATAGRAM;

        (VOID)IoCallDriver( deviceObject, irp );
    }

    return;

} // StartSendNoConnection


VOID SRVFASTCALL
IpxRestartReceive (
    IN OUT PWORK_CONTEXT WorkContext
    )

/*++

Routine Description:

    This is the restart routine for IPX Receive completion.  It does
    some IPX-specific setup work, then calls SrvRestartReceive.

Arguments:

    WorkContext - Supplies a pointer to the work context block
        describing server-specific context for the request.

Return Value:

    None.

--*/

{
    PSMB_HEADER header = (PSMB_HEADER)WorkContext->RequestBuffer->Buffer;

    PAGED_CODE( );

    ASSERT( header->Command == SMB_COM_NEGOTIATE );

    //
    // Get rid of stale connections.
    //

    IF_DEBUG(IPX) KdPrint(( "SRVIPX: processing Negotiate\n" ));
    PurgeIpxConnections( WorkContext->Endpoint );

    //
    // Load the SID from the connection into the request.  Since this
    // is a Negotiate request, we need to return a SID to the client.
    // The easiest way to ensure that happens is to save the SID here.
    //

    SmbPutAlignedUshort( &header->Sid, WorkContext->Connection->Sid );

    //
    // Call the normal SMB processing routine.
    //

    SrvRestartReceive( WorkContext );

    return;

} // IpxRestartReceive


NTSTATUS
RequeueIpxWorkItemAtSendCompletion (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN OUT PWORK_CONTEXT WorkContext
    )

/*++

Routine Description:

    This routine requeues an IPX work item to the free queue.

Arguments:

    DeviceObject - Pointer to target device object for the request.

    Irp - Pointer to I/O request packet

    WorkContext - Caller-specified context parameter associated with IRP.
        This is actually a pointer to a Work Context block.

Return Value:

    STATUS_MORE_PROCESSING_REQUIRED.

--*/

{
    //
    // Check the status of the send completion.
    //

    CHECK_SEND_COMPLETION_STATUS_CONNECTIONLESS( Irp->IoStatus.Status );

    //
    // Reset the IRP cancelled bit.
    //

    Irp->Cancel = FALSE;

    ASSERT( WorkContext->BlockHeader.ReferenceCount == 1 );
    WorkContext->BlockHeader.ReferenceCount = 0;

    ASSERT( WorkContext->Share == NULL );
    ASSERT( WorkContext->Session == NULL );
    ASSERT( WorkContext->TreeConnect == NULL );
    ASSERT( WorkContext->Rfcb == NULL );

    //
    // Set up the restart routine in the work context.
    //

    WorkContext->FsdRestartRoutine = SrvQueueWorkToFspAtDpcLevel;
    WorkContext->FspRestartRoutine = SrvRestartReceive;

    //
    // Make sure the length specified in the MDL is correct -- it may
    // have changed while sending a response to the previous request.
    // Call an I/O subsystem routine to build the I/O request packet.
    //

    WorkContext->RequestBuffer->Mdl->ByteCount =
                            WorkContext->RequestBuffer->BufferLength;

    //
    // Requeue the work item.
    //

    RETURN_FREE_WORKITEM( WorkContext );

    return STATUS_MORE_PROCESSING_REQUIRED;

} // RequeueIpxWorkItemAtSendCompletion


PCONNECTION
GetIpxConnection (
    IN PWORK_CONTEXT WorkContext,
    IN PENDPOINT Endpoint,
    IN PTDI_ADDRESS_IPX ClientAddress,
    IN PUCHAR ClientName
    )
{
    PLIST_ENTRY listEntry;
    PCONNECTION connection;
    PCHAR clientMachineName;
    ULONG length;
    KIRQL oldIrql;
    PWORK_QUEUE queue = PROCESSOR_TO_QUEUE();

    //
    // Take a connection off the endpoint's free connection list.
    //
    // *** Note that all of the modifications done to the connection
    //     block are done with the spin lock held.  This ensures that
    //     closing of the endpoint's connections will work properly if
    //     it happens simultaneously.
    //

    ACQUIRE_GLOBAL_SPIN_LOCK( Fsd, &oldIrql );

    listEntry = RemoveHeadList( &Endpoint->FreeConnectionList );

    if ( listEntry == &Endpoint->FreeConnectionList ) {

        //
        // Unable to get a free connection.
        //

        RELEASE_GLOBAL_SPIN_LOCK( Fsd, oldIrql );
        IF_DEBUG(IPX) KdPrint(( "SRVIPX: no free connections\n" ));
        SrvOutOfFreeConnectionCount++;
        return NULL;
    }

    //
    // We have a connection and a table entry.
    //

    Endpoint->FreeConnectionCount--;

    //
    // Wake up the resource thread to create a new free connection
    // for the endpoint.
    //

    if ( (Endpoint->FreeConnectionCount < SrvFreeConnectionMinimum) &&
         (GET_BLOCK_STATE(Endpoint) == BlockStateActive) ) {
        SrvResourceFreeConnection = TRUE;
        SrvFsdQueueExWorkItem(
            &SrvResourceThreadWorkItem,
            &SrvResourceThreadRunning,
            CriticalWorkQueue
            );
    }

    RELEASE_GLOBAL_SPIN_LOCK( Fsd, oldIrql );

    //
    // Reference the connection to account for its being "open" and
    // for the work item's pointer.
    //

    connection = CONTAINING_RECORD(
                    listEntry,
                    CONNECTION,
                    EndpointFreeListEntry
                    );


    ACQUIRE_SPIN_LOCK( connection->EndpointSpinLock, &oldIrql );

    SrvReferenceConnectionLocked( connection );
    SrvReferenceConnectionLocked( connection );

    //
    // Mark the connection active.
    //

    SET_BLOCK_STATE( connection, BlockStateActive );

    //
    // Initialize IPX protocol fields.
    //

    connection->DirectHostIpx = TRUE;
    connection->IpxAddress = *ClientAddress;
    connection->SequenceNumber = 0;
    connection->LastResponseLength = (USHORT)-1;

    //
    // Set the processor affinity
    //
    connection->PreferredWorkQueue = queue;
    connection->CurrentWorkQueue = queue;

    InterlockedIncrement( &queue->CurrentClients );

    //
    // Set the duplicate drop count.  Start off conservative until
    // we learn what kind of client we're dealing with
    //
    connection->IpxDropDuplicateCount = MIN_IPXDROPDUP;
    connection->IpxDuplicateCount = 0;

#if MULTIPROCESSOR
    //
    // Get this client onto the best possible processor
    //
    SrvBalanceLoad( connection );
#endif

    //
    // Set time stamps.  StartupTime is used by the server to determine
    // whether the connection is old enough to be considered stale and
    // should be closed when another negotiate comes in.  This is used
    // to fix a timing problem where identical negotiates may be
    // queued up the the worker thread and a session setup comes in which
    // gets partially processed in the indication routine.
    //

    SET_SERVER_TIME( connection->CurrentWorkQueue );

    GET_SERVER_TIME( connection->CurrentWorkQueue, &connection->StartupTime );
    connection->LastRequestTime = connection->StartupTime;

    //
    // Put the work item on the in-progress list.
    //

    SrvInsertTailList(
        &connection->InProgressWorkItemList,
        &WorkContext->InProgressListEntry
        );
    connection->InProgressWorkContextCount++;

    RELEASE_SPIN_LOCK( connection->EndpointSpinLock, oldIrql );

    WorkContext->Connection = connection;

    //
    // Copy the oem name at this time.  We convert it to Unicode
    // when we get the Session Setup SMB.
    //

    clientMachineName = connection->OemClientMachineName;

    RtlCopyMemory( clientMachineName, ClientName,  SMB_IPX_NAME_LENGTH );

    clientMachineName[SMB_IPX_NAME_LENGTH] = '\0';

    //
    // Determine the number of characters that aren't blanks.  This
    // is used by the session APIs to simplify their processing.
    //

    for ( length = SMB_IPX_NAME_LENGTH;
          length > 0 &&
             (clientMachineName[length-1] == ' ' ||
              clientMachineName[length-1] == '\0');
          length-- ) ;

    connection->OemClientMachineNameString.Length = (USHORT)length;

    IF_DEBUG(IPX) {
        SrvPrint2( "IpxRestartReceive accepting connection from %z on connection %p\n",
                    (PCSTRING)&connection->OemClientMachineNameString, connection );
    }

    return connection;

} // GetIpxConnection


VOID
PurgeIpxConnections (
    IN PENDPOINT Endpoint
    )
{
    USHORT i,j;
    KIRQL oldIrql;
    PTABLE_HEADER tableHeader;
    PCONNECTION connection;

    IF_DEBUG(IPX2) KdPrint(( "SRVIPX: PurgeIpxConnections entered\n" ));

    ACQUIRE_SPIN_LOCK( &ENDPOINT_SPIN_LOCK(0), &oldIrql );
    for ( j = 1; j < ENDPOINT_LOCK_COUNT; j++ ) {
        ACQUIRE_DPC_SPIN_LOCK( &ENDPOINT_SPIN_LOCK(j) );
    }

    tableHeader = &Endpoint->ConnectionTable;
    for ( i = 0; i < tableHeader->TableSize; i++ ) {

        connection = (PCONNECTION)tableHeader->Table[i].Owner;
        if ( (connection == NULL) ||
             (connection->IpxAddress.Socket != 0) ||
             (GET_BLOCK_STATE(connection) != BlockStateActive) ) {
            IF_DEBUG(IPX2) {
                if ( connection == NULL ) {
                    KdPrint(( "        no connection at table index %x\n", i ));
                } else if ( connection->IpxAddress.Socket != 0 ) {
                    KdPrint(( "        connection %p has socket %x\n", connection, connection->IpxAddress.Socket ));
                } else {
                    KdPrint(( "        connection %p has state %x\n", connection, GET_BLOCK_STATE(connection) ));
                }
            }

            continue;
        }

        SrvReferenceConnectionLocked(connection);
        for ( j = ENDPOINT_LOCK_COUNT-1; j > 0; j-- ) {
            RELEASE_DPC_SPIN_LOCK( &ENDPOINT_SPIN_LOCK(j) );
        }
        RELEASE_SPIN_LOCK( &ENDPOINT_SPIN_LOCK(0), oldIrql );

        IF_DEBUG(IPX) KdPrint(( "SRVIPX: purging connection %p\n", connection ));
        connection->DisconnectReason = DisconnectStaleIPXConnection;
        SrvCloseConnection( connection, FALSE );
        SrvDereferenceConnection( connection );

        ACQUIRE_SPIN_LOCK( &ENDPOINT_SPIN_LOCK(0), &oldIrql );
        for ( j = 1; j < ENDPOINT_LOCK_COUNT; j++ ) {
            ACQUIRE_DPC_SPIN_LOCK( &ENDPOINT_SPIN_LOCK(j) );
        }
        tableHeader = &Endpoint->ConnectionTable;
    }

    for ( j = ENDPOINT_LOCK_COUNT-1; j > 0; j-- ) {
        RELEASE_DPC_SPIN_LOCK( &ENDPOINT_SPIN_LOCK(j) );
    }
    RELEASE_SPIN_LOCK( &ENDPOINT_SPIN_LOCK(0), oldIrql );

    IF_DEBUG(IPX2) KdPrint(( "SRVIPX: PurgeIpxConnections done\n" ));

    return;

} // PurgeIpxConnections

VOID SRVFASTCALL
IpxRestartNegotiate(
    IN OUT PWORK_CONTEXT WorkContext
    )

/*++

Routine Description:

    This routine handles the case where the transport did not
    indicate us all of the data in the negotiate smb.

Arguments:

    WorkContext - Supplies a pointer to the work context block
        describing server-specific context for the request.

        The workcontext block:
        -   has a pointer to the endpoint
        -   has a ref count of 1


Return Value:

    None.

--*/

{
    PENDPOINT endpoint;
    USHORT sid;
    PCONNECTION connection;
    ULONG length;
    PUCHAR clientName;
    PTABLE_HEADER tableHeader;
    USHORT i;
    KIRQL oldIrql;
    BOOLEAN resend;
    USHORT error;
    PLIST_ENTRY listEntry;

    PTA_IPX_ADDRESS sourceAddress;
    PNT_SMB_HEADER header;
    PSMB_PARAMS params;

    ASSERT( WorkContext->Endpoint != NULL );

    IF_DEBUG(IPX) KdPrint(( "SRVIPX: Negotiate received\n" ));

    //
    // If this endpoint is no longer around, ignore this request.
    //  This check covers the possibility that the endpoint has been
    //  removed between the time this request was queued to a worker
    //  thread and a worker thread actually picked up the request.
    //

    ACQUIRE_LOCK( &SrvEndpointLock );

    listEntry = SrvEndpointList.ListHead.Flink;

    while ( listEntry != &SrvEndpointList.ListHead ) {

        endpoint = CONTAINING_RECORD(
                        listEntry,
                        ENDPOINT,
                        GlobalEndpointListEntry
                        );

        if( endpoint == WorkContext->Endpoint &&
            GET_BLOCK_STATE( endpoint ) == BlockStateActive ) {

            //
            // We found the endpoint, and it's still active!  Reference
            //  it so the endpoint will not disappear out from under us.
            //
            endpoint->BlockHeader.ReferenceCount++;

            break;
        }

        listEntry = listEntry->Flink;
    }

    if( listEntry == &SrvEndpointList.ListHead ) {
        //
        // We ran the whole list and did not find the endpoint.  It
        //  must have gone away.  Ignore this WorkItem.
        //
        RELEASE_LOCK( &SrvEndpointLock );
        IF_DEBUG( IPX ) KdPrint(( "SRVIPX: Endpoint gone.  ignoring\n" ));
        goto return_workitem;
    }

    RELEASE_LOCK( &SrvEndpointLock );

    //
    // The endpoint is still valid, and we have referenced it.  The local var
    //  'endpoint' points to it.
    //

    sourceAddress = &WorkContext->ClientAddress->IpxAddress;

    header = (PNT_SMB_HEADER) WorkContext->RequestHeader;
    sid = SmbGetUshort( &header->Sid ); // NOT Aligned
    ASSERT( sid == 0 );

    clientName = (PUCHAR)WorkContext->RequestParameters;
    clientName += 2 * (*clientName) + 1;
    clientName += (*clientName) + 2;

    //
    // Make sure he's really trying to connect to us, and the SMB is well formed
    //

    if ( clientName+16+SMB_IPX_NAME_LENGTH-1 > END_OF_REQUEST_SMB( WorkContext ) ||
         !RtlEqualMemory(
            endpoint->TransportAddress.Buffer,
            clientName + 16,
            SMB_IPX_NAME_LENGTH ) ) {

        IF_DEBUG(IPX) KdPrint(( "SRVIPX: Negotiate sent to wrong name!\n" ));
        error = SMB_ERR_NOT_ME;
        resend = FALSE;
        goto respond;
    }

    //
    // Acquire the endpoint locks
    //

    ACQUIRE_SPIN_LOCK( &ENDPOINT_SPIN_LOCK(0), &oldIrql );
    for ( i = 1; i < ENDPOINT_LOCK_COUNT; i++ ) {
        ACQUIRE_DPC_SPIN_LOCK( &ENDPOINT_SPIN_LOCK(i) );
    }

    tableHeader = &endpoint->ConnectionTable;
    for ( i = 0; i < tableHeader->TableSize; i++ ) {

        connection = (PCONNECTION)tableHeader->Table[i].Owner;
        if ( connection == NULL ) {
            continue;
        }

        //
        // Make sure this connection references an endpoint having
        // the same netbios address that the new client is coming in on
        //
        // This is to allow a single server to be registered as more than
        //  one name on the network.
        //
        if( connection->Endpoint->TransportAddress.Length !=
            endpoint->TransportAddress.Length ||

            !RtlEqualMemory( connection->Endpoint->TransportAddress.Buffer,
                              endpoint->TransportAddress.Buffer,
                              endpoint->TransportAddress.Length ) ) {

            //
            // This connection is for an endpoint having a different network
            //  name than we have.  Ignore it.
            //
            continue;
        }

        //
        // Check the IPX address of the sender against this
        // connection.
        //

        if ( RtlEqualMemory(
                &connection->IpxAddress,
                &sourceAddress->Address[0].Address[0],
                sizeof(TDI_ADDRESS_IPX) ) ) {

            //
            // The IPX addresses match.  Check the machine name.
            //

            if ( !RtlEqualMemory(
                    connection->OemClientMachineName,
                    clientName,
                    SMB_IPX_NAME_LENGTH) ) {

                //
                // The connection is for a different machine name.
                // Mark it as no longer valid.  It will be killed
                // when the Negotiate SMB is processed.
                //
                IF_DEBUG(IPX)KdPrint(("SRVIPX: Found stale connection %p\n", connection ));
                connection->IpxAddress.Socket = 0;
                break;

            } else if ( connection->SequenceNumber != 0 ) {

                ULONG timeNow;

                SET_SERVER_TIME( connection->CurrentWorkQueue );
                GET_SERVER_TIME( connection->CurrentWorkQueue, &timeNow );

                //
                // If the connection was initialized less than 5 seconds ago,
                // then we must be processing a duplicate negotiate request.
                //

                timeNow -= connection->StartupTime;

                if ( timeNow > SrvFiveSecondTickCount ) {

                    //
                    // The connection has been active for more than 5 seconds.
                    // Mark it as no longer valid.  It will be killed when
                    // the Negotiate SMB is processed.
                    //
                    IF_DEBUG(IPX) KdPrint(( "SRVIPX: found stale connection %p\n", connection ));
                    connection->IpxAddress.Socket = 0;
                    break;

                } else {

                    //
                    // Don't bother replying to avoid confusing the client.
                    //

                    for ( i = ENDPOINT_LOCK_COUNT-1; i > 0; i-- ) {
                        RELEASE_DPC_SPIN_LOCK( &ENDPOINT_SPIN_LOCK(i) );
                    }
                    RELEASE_SPIN_LOCK( &ENDPOINT_SPIN_LOCK(0), oldIrql );
                    SrvDereferenceEndpoint( endpoint );
                    goto return_workitem;
                }
            }

            //
            // The connection is still in the initializing state and
            // the names match, so handle this as a lost response.
            //

            IF_DEBUG(IPX) KdPrint(( "SRVIPX: Found initializing connection %p\n", connection ));
            SmbPutUshort( &header->Sid, connection->Sid ); // NOT Aligned
            goto duplicate_request;

        } else {
            IF_DEBUG(IPX) {
                KdPrint(( "        skipping index %x: different address\n", i ));
            }
        }
    }

    //
    // Release the endpoint locks
    //

    for ( i = ENDPOINT_LOCK_COUNT-1; i > 0; i-- ) {
        RELEASE_DPC_SPIN_LOCK( &ENDPOINT_SPIN_LOCK(i) );
    }

    RELEASE_SPIN_LOCK( &ENDPOINT_SPIN_LOCK(0), oldIrql );

    //
    // Get a free connection.  If successful, the workcontext block will
    // reference the connection block.
    //

    connection = GetIpxConnection(
                    WorkContext,
                    endpoint,
                    &sourceAddress->Address[0].Address[0],
                    clientName
                    );

    //
    // Now that we've gotten a connection structure for this endpoint,
    //  we can drop the reference we obtained above.
    //
    SrvDereferenceEndpoint( endpoint );

    if ( connection == NULL ) {

        //
        // Unable to get a free connection.
        //
        goto return_workitem;
    }

    //
    // Modify the FSP restart routine so that we can clean up stale
    // connections.
    //

    IpxRestartReceive(WorkContext);
    return;

duplicate_request:

    //
    // This is a duplicate request.  If it's still being processed,
    // indicate that to the client.
    //

    if ( connection->LastResponseLength == (USHORT)-1 ) {
        IF_DEBUG(IPX) KdPrint(( "SRVIPX: request in progress\n" ));
        for ( i = ENDPOINT_LOCK_COUNT-1; i > 0; i-- ) {
            RELEASE_DPC_SPIN_LOCK( &ENDPOINT_SPIN_LOCK(i) );
        }
        RELEASE_SPIN_LOCK( &ENDPOINT_SPIN_LOCK(0), oldIrql );
        error = SMB_ERR_WORKING;
        resend = FALSE;
        goto respond;
    }

    //
    // The request has already been completed.  Resend the response.
    //

    IF_DEBUG(IPX) KdPrint(( "SRVIPX: resending response\n" ));
    resend = TRUE;

respond:

    params = (PSMB_PARAMS)(header + 1);
    header->Flags |= SMB_FLAGS_SERVER_TO_REDIR;

    //
    // Format the parameters portion of the SMB, and set the status.
    //

    if ( !resend ) {

        SmbPutUshort( &header->Status.DosError.Error, error );
        header->Status.DosError.ErrorClass = SMB_ERR_CLASS_SERVER;
        header->Status.DosError.Reserved = 0;
        params->WordCount = 0;
        SmbPutUshort( &params->ByteCount, 0 );
        length = sizeof(NT_SMB_HEADER) + sizeof(SMB_PARAMS);

    } else {

        //
        // Copy the saved response data into the response.
        //

        SmbPutUlong( &header->Status.NtStatus, connection->LastResponseStatus );
        RtlCopyMemory(
            (PVOID)params,
            connection->LastResponse,
            connection->LastResponseLength
            );
        length = sizeof(NT_SMB_HEADER) + connection->LastResponseLength;
        for ( i = ENDPOINT_LOCK_COUNT-1; i > 0; i-- ) {
            RELEASE_DPC_SPIN_LOCK( &ENDPOINT_SPIN_LOCK(i) );
        }
        RELEASE_SPIN_LOCK( &ENDPOINT_SPIN_LOCK(0), oldIrql );
    }

    WorkContext->ResponseBuffer->DataLength = length;
    WorkContext->ResponseBuffer->Mdl->ByteCount = length;

    //
    // Give up the reference we earlier obtained
    //
    SrvDereferenceEndpoint( endpoint );

    //
    // Send the packet.
    //

    DEBUG WorkContext->FsdRestartRoutine = NULL;

    StartSendNoConnection( WorkContext, FALSE, TRUE );

    return;

return_workitem:

    //
    // Dereference the work item manually.
    //

    ASSERT( WorkContext->BlockHeader.ReferenceCount == 1 );
    WorkContext->BlockHeader.ReferenceCount = 0;

    WorkContext->Endpoint = NULL;
    WorkContext->FsdRestartRoutine = SrvQueueWorkToFspAtDpcLevel;
    WorkContext->FspRestartRoutine = SrvRestartReceive;
    WorkContext->Irp->Cancel = FALSE;
    WorkContext->ProcessingCount = 0;
    RETURN_FREE_WORKITEM( WorkContext );

    return;

} // IpxRestartNegotiate

VOID SRVFASTCALL
SrvIpxFastRestartRead (
    IN OUT PWORK_CONTEXT WorkContext
    )

/*++

Routine Description:

    Implements core read over ipx.

Arguments:

    WorkContext - Supplies a pointer to the work context block
        describing server-specific context for the request.

Return Value:

    None.

--*/

{
    PREQ_READ request;
    PRESP_READ response;

    PRFCB rfcb;
    PLFCB lfcb;
    PCHAR readAddress;
    CLONG readLength;
    LARGE_INTEGER offset;
    ULONG key;
    PSMB_HEADER header;

    PAGED_CODE( );

    request = (PREQ_READ)WorkContext->RequestParameters;
    response = (PRESP_READ)WorkContext->ResponseParameters;

    //
    // Store in the work context block the time at which processing
    // of the request began.  Use the time that the work item was
    // queued to the FSP for this purpose.
    //

    WorkContext->StartTime = WorkContext->Timestamp;


    //
    // Update the server network error count.
    //

    SrvUpdateErrorCount( &SrvNetworkErrorRecord, FALSE );

    //
    // We have received an SMB.
    //

    SMBTRACE_SRV2(
        WorkContext->ResponseBuffer->Buffer,
        WorkContext->ResponseBuffer->DataLength
        );

    rfcb = WorkContext->Rfcb;

    //
    // Form the lock key using the FID and the PID.
    //
    // *** The FID must be included in the key in order to account for
    //     the folding of multiple remote compatibility mode opens into
    //     a single local open.
    //

    key = rfcb->ShiftedFid |
            SmbGetAlignedUshort( &WorkContext->RequestHeader->Pid );

    lfcb = rfcb->Lfcb;

    //
    // See if the direct host IPX smart card can handle this read.  If so,
    //  return immediately, and the card will call our restart routine at
    //  SrvIpxSmartCardReadComplete
    //
    if( rfcb->PagedRfcb->IpxSmartCardContext ) {
        IF_DEBUG( SIPX ) {
            KdPrint(( "SrvIpxFastRestartRead: calling SmartCard Read for context %p\n",
                        WorkContext ));
        }

        WorkContext->Parameters.SmartCardRead.MdlReadComplete = lfcb->MdlReadComplete;
        WorkContext->Parameters.SmartCardRead.DeviceObject = lfcb->DeviceObject;

        if( SrvIpxSmartCard.Read( WorkContext->RequestBuffer->Buffer,
                                  rfcb->PagedRfcb->IpxSmartCardContext,
                                  key,
                                  WorkContext ) == TRUE ) {

            IF_DEBUG( SIPX ) {
                KdPrint(( "  SrvIpxFastRestartRead:  SmartCard Read returns TRUE\n" ));
            }

            return;
        }

        IF_DEBUG( SIPX ) {
            KdPrint(( "  SrvIpxFastRestartRead:  SmartCard Read returns FALSE\n" ));
        }
    }

    IF_SMB_DEBUG(READ_WRITE1) {
        KdPrint(( "Read request; FID 0x%lx, count %ld, offset %ld\n",
            rfcb->Fid, SmbGetUshort( &request->Count ),
            SmbGetUlong( &request->Offset ) ));
    }

    //
    // Initialize the error class and code fields in the header to
    // indicate success.
    //

    header = WorkContext->ResponseHeader;

    SmbPutUlong( &header->ErrorClass, STATUS_SUCCESS );

    //
    // Determine the maximum amount of data we can read.  This is the
    // minimum of the amount requested by the client and the amount of
    // room left in the response buffer.  (Note that even though we may
    // use an MDL read, the read length is still limited to the size of
    // an SMB buffer.)
    //

    readAddress = (PCHAR)response->Buffer;

    readLength = (ULONG)MIN(
                           (CLONG)SmbGetUshort( &request->Count ),
                           WorkContext->ResponseBuffer->BufferLength -
                           (readAddress - (PCHAR)header)
                           );

    //
    // Get the file offset.
    //

    offset.QuadPart = SmbGetUlong( &request->Offset );

    //
    // Try the fast I/O path first.  If that fails, fall through to the
    // normal build-an-IRP path.
    //

    if ( lfcb->FastIoRead != NULL ) {

        INCREMENT_DEBUG_STAT2( SrvDbgStatistics.FastReadsAttempted );

        try {
            if ( lfcb->FastIoRead(
                    lfcb->FileObject,
                    &offset,
                    readLength,
                    TRUE,
                    key,
                    readAddress,
                    &WorkContext->Irp->IoStatus,
                    lfcb->DeviceObject
                    ) ) {
    
                //
                // The fast I/O path worked.  Call the restart routine directly
                // to do postprocessing (including sending the response).
                //
    
                SrvFsdRestartRead( WorkContext );
    
                IF_SMB_DEBUG(READ_WRITE2) KdPrint(( "SrvIpxFastRestartRead complete.\n" ));
                return;
            }
        }
        except( EXCEPTION_EXECUTE_HANDLER ) {
            // Fall through to the slow path on an exception
            NTSTATUS status = GetExceptionCode();
            IF_DEBUG(ERRORS) {
                KdPrint(("FastIoRead threw exception %x\n", status ));
            }
        }


        INCREMENT_DEBUG_STAT2( SrvDbgStatistics.FastReadsFailed );

    }

    //
    // The turbo path failed.  Build the read request, reusing the
    // receive IRP.
    //

    //
    // Note that we never do MDL reads here.  The reasoning behind
    // this is that because the read is going into an SMB buffer, it
    // can't be all that large (by default, no more than 4K bytes),
    // so the difference in cost between copy and MDL is minimal; in
    // fact, copy read is probably faster than MDL read.
    //
    // Build an MDL describing the read buffer.  Note that if the
    // file system can complete the read immediately, the MDL isn't
    // really needed, but if the file system must send the request
    // to its FSP, the MDL _is_ needed.
    //
    // *** Note the assumption that the response buffer already has
    //     a valid full MDL from which a partial MDL can be built.
    //

    IoBuildPartialMdl(
        WorkContext->ResponseBuffer->Mdl,
        WorkContext->ResponseBuffer->PartialMdl,
        readAddress,
        readLength
        );

    //
    // Build the IRP.
    //

    SrvBuildReadOrWriteRequest(
            WorkContext->Irp,           // input IRP address
            lfcb->FileObject,           // target file object address
            WorkContext,                // context
            IRP_MJ_READ,                // major function code
            0,                          // minor function code
            readAddress,                // buffer address
            readLength,                 // buffer length
            WorkContext->ResponseBuffer->PartialMdl, // MDL address
            offset,                     // byte offset
            key                         // lock key
            );

    IF_SMB_DEBUG(READ_WRITE2) {
        KdPrint(( "SrvIpxFastRestartRead: copy read from file 0x%p, offset %ld, length %ld, destination 0x%p\n",
                    lfcb->FileObject, offset.LowPart, readLength,
                    readAddress ));
    }

    //
    // Load the restart routine address and pass the request to the file
    // system.
    //

    WorkContext->FsdRestartRoutine = SrvFsdRestartRead;
    DEBUG WorkContext->FspRestartRoutine = NULL;
    WorkContext->Irp->Cancel = FALSE;

    (VOID)IoCallDriver( lfcb->DeviceObject, WorkContext->Irp );

    //
    // The read has been started.  Control will return to the restart
    // routine when the read completes.
    //

    IF_SMB_DEBUG(READ_WRITE2) KdPrint(( "SrvIpxFastRestartRead complete.\n" ));
    return;

} // SrvIpxFastRestartRead

BOOLEAN
SetupIpxFastCoreRead (
    IN OUT PWORK_CONTEXT WorkContext
    )

/*++

Routine Description:

    Prepares the workitem for the fast restart read by validating the
    smb and verifying the fid.

Arguments:

    WorkContext

Return Value:

    TRUE, if rfcb referenced.
    FALSE, otherwise.

--*/

{
    PREQ_READ request;
    PRESP_READ response;

    NTSTATUS status;
    BOOLEAN validSmb;
    USHORT fid;
    PRFCB rfcb;

    UCHAR wordCount;
    USHORT byteCount;
    PSMB_USHORT byteCountPtr;
    ULONG availableSpaceForSmb;
    ULONG smbLength;
    PSMB_HEADER header;
    PSMB_PARAMS params;
    PCONNECTION connection;

    ASSERT( KeGetCurrentIrql() == DISPATCH_LEVEL );

    request = (PREQ_READ)WorkContext->RequestParameters;
    response = (PRESP_READ)WorkContext->ResponseParameters;

    IF_SMB_DEBUG(READ_WRITE1) {
        KdPrint(( "Read request; FID 0x%lx, count %ld, offset %ld\n",
            SmbGetUshort( &request->Fid ), SmbGetUshort( &request->Count ),
            SmbGetUlong( &request->Offset ) ));
    }

    //
    // Validate this smb.
    //

    header = WorkContext->RequestHeader;
    params = (PVOID)(header + 1);
    smbLength = WorkContext->RequestBuffer->DataLength;

    wordCount = *((PUCHAR)params);
    byteCountPtr = (PSMB_USHORT)( (PCHAR)params +
                    sizeof(UCHAR) + (5 * sizeof(USHORT)) );
    byteCount = SmbGetUshort( (PSMB_USHORT)( (PCHAR)params +
                    sizeof(UCHAR) + (5 * sizeof(USHORT))) );

    availableSpaceForSmb = smbLength - sizeof(SMB_HEADER);

    //
    // Validate the Read smb.
    //

    validSmb = (SmbGetUlong((PULONG)header->Protocol) == SMB_HEADER_PROTOCOL)
                    &&
                ((CHAR)wordCount == 5)
                    &&
                ((PCHAR)byteCountPtr <= (PCHAR)header + smbLength -
                    sizeof(USHORT))
                    &&
                ((5*sizeof(USHORT) + sizeof(UCHAR) + sizeof(USHORT) +
                    byteCount) <= availableSpaceForSmb);

    if ( validSmb ) {

        PTABLE_HEADER tableHeader;
        USHORT index;
        USHORT sequence;

        //
        // Verify the FID.  If verified, the RFCB is referenced and
        // its address is stored in the WorkContext block, and the RFCB
        // address is returned.
        //

        fid = SmbGetUshort( &request->Fid );

        //
        // Initialize local variables:  obtain the connection block address
        // and crack the FID into its components.
        //

        connection = WorkContext->Connection;

        //
        // Acquire the spin lock that guards the connection's file table.
        //

        ACQUIRE_DPC_SPIN_LOCK( &connection->SpinLock );

        //
        // See if this is the cached rfcb
        //

        if ( connection->CachedFid == (ULONG)fid ) {

            rfcb = connection->CachedRfcb;

        } else {

            //
            // Verify that the FID is in range, is in use, and has the correct
            // sequence number.

            index = FID_INDEX( fid );
            sequence = FID_SEQUENCE( fid );
            tableHeader = &connection->FileTable;

            if ( (index >= (USHORT)tableHeader->TableSize) ||
                 (tableHeader->Table[index].Owner == NULL) ||
                 (tableHeader->Table[index].SequenceNumber != sequence) ) {

                goto error_exit_locked;
            }

            rfcb = tableHeader->Table[index].Owner;

            if ( GET_BLOCK_STATE(rfcb) != BlockStateActive ) {

                goto error_exit_locked;
            }

            //
            // If the caller wants to fail when there is a write behind
            // error and the error exists, fill in NtStatus and do not
            // return the RFCB pointer.
            //
            //
            // !!! For now, we ignore write behind errors.  Need to
            //     figure out how to translate the saved NT status to a
            //     DOS status...
            //
#if 0
            if ( !NT_SUCCESS(rfcb->SavedError) ) {
                goto error_exit_locked;
            }
#endif
            //
            // Cache the fid.
            //

            connection->CachedRfcb = rfcb;
            connection->CachedFid = (ULONG)fid;

            //
            // The FID is valid within the context of this connection.  Verify
            // that the owning tree connect's TID is correct.
            //
            // Do not verify the UID for clients that do not understand it.
            //

            if ( (rfcb->Tid != SmbGetAlignedUshort(&header->Tid)) ||
                 (rfcb->Uid != SmbGetAlignedUshort(&header->Uid)) ) {

                goto error_exit_locked;
            }
        }

        //
        // The file is active and the TID is valid.  Reference the
        // RFCB.  Release the spin lock (we don't need it anymore).
        //

        rfcb->BlockHeader.ReferenceCount++;
        UPDATE_REFERENCE_HISTORY( rfcb, FALSE );

        RELEASE_DPC_SPIN_LOCK( &connection->SpinLock );

        //
        // Save the RFCB address in the work context block and
        // return the file address.
        //

        WorkContext->Rfcb = rfcb;

        ASSERT( GET_BLOCK_TYPE( rfcb->Mfcb ) == BlockTypeMfcb );

        //
        // Mark the rfcb as active
        //

        rfcb->IsActive = TRUE;

        //
        // Verify that the client has read access to the file via the
        // specified handle.
        //

        if ( rfcb->ReadAccessGranted ) {

            return(TRUE);

        } else {

            CHECK_PAGING_IO_ACCESS(
                            WorkContext,
                            rfcb->GrantedAccess,
                            &status );

            if ( NT_SUCCESS( status ) ) {
                return(TRUE);
            }
        }
    }

    return(FALSE);

error_exit_locked:

    RELEASE_DPC_SPIN_LOCK( &connection->SpinLock );
    return(FALSE);

} // SetupIpxFastCoreRead

VOID
SrvFreeIpxConnectionInIndication(
    IN PWORK_CONTEXT WorkContext
    )
{
    PCONNECTION connection = WorkContext->Connection;

    ACQUIRE_DPC_SPIN_LOCK( connection->EndpointSpinLock );

    SrvRemoveEntryList(
        &connection->InProgressWorkItemList,
        &WorkContext->InProgressListEntry
        );
    connection->InProgressWorkContextCount--;


    if ( --connection->BlockHeader.ReferenceCount == 0 ) {

        connection->BlockHeader.ReferenceCount++;

        RELEASE_DPC_SPIN_LOCK( connection->EndpointSpinLock );

        //
        // Orphaned.  Send to Boys Town.
        //

        DispatchToOrphanage( (PVOID)connection );

    } else {

        RELEASE_DPC_SPIN_LOCK( connection->EndpointSpinLock );
    }

    WorkContext->Connection = NULL;
    return;

} // SrvFreeIpxConnectionInIndication

VOID
SrvIpxSmartCardReadComplete(
    IN PVOID    Context,
    IN PFILE_OBJECT FileObject,
    IN PMDL Mdl OPTIONAL,
    IN ULONG Length
)
/*++

Routine Description:

    Completes the Read performed by an optional smart card that handles
    direct host IPX clients.

Arguments:

    Context - the WorkContext of the original request
    FileObject - the file being read from
    Mdl - the MDL chain obtained from the cache manager to satisfy the read
    Length - the length of the read

Return Value:

    None

--*/
{
    PWORK_CONTEXT workContext = Context;
    PRFCB rfcb = workContext->Rfcb;
    UCHAR command = workContext->NextCommand;
    LARGE_INTEGER position;
    KIRQL oldIrql;
    NTSTATUS status;

    ASSERT( workContext != NULL );
    ASSERT( FileObject != NULL );
    ASSERT( command == SMB_COM_READ || command == SMB_COM_READ_MPX );

    //
    // Figure out the file position
    //
    if( command == SMB_COM_READ ) {
        PREQ_READ readParms = (PREQ_READ)workContext->RequestParameters;
        position.QuadPart = SmbGetUlong( &readParms->Offset ) + Length;
    } else {
        PREQ_READ_MPX readMpxParms = (PREQ_READ_MPX)workContext->RequestParameters;
        position.QuadPart = SmbGetUlong( &readMpxParms->Offset ) + Length;
    }

    IF_DEBUG( SIPX ) {
        KdPrint(( "SrvIpxSmartCardReadComplete: %s %p Length %u, New Position %u\n",
                  command==SMB_COM_READ ? "SMB_COM_READ" : "SMB_COM_READ_MPX",
                  Context, Length, position.LowPart ));
    }

    //
    // Update the position info in the rfcb
    //
    rfcb->CurrentPosition = position.LowPart;

    UPDATE_READ_STATS( workContext, Length );
    UPDATE_STATISTICS( workContext, Length, command );

    if( ARGUMENT_PRESENT( Mdl ) ) {

        //
        // Give the MDL chain back to the cache manager
        //

        if( workContext->Parameters.SmartCardRead.MdlReadComplete == NULL ||
            workContext->Parameters.SmartCardRead.MdlReadComplete( FileObject,
                Mdl,
                workContext->Parameters.SmartCardRead.DeviceObject ) == FALSE ) {

            //
            // Fast path didn't work -- try the IRP way
            //
            position.QuadPart -= Length;

            status = SrvIssueMdlCompleteRequest( workContext, NULL,
                                                Mdl,
                                                IRP_MJ_READ,
                                                &position,
                                                Length
                                                );

            if( !NT_SUCCESS( status ) ) {
                //
                // This is very bad, what else can we do?
                //
                SrvLogServiceFailure( SRV_SVC_MDL_COMPLETE, status );
            }
        }
    }

    //
    // Finish the cleanup
    //
    if( command ==  SMB_COM_READ ) {
        workContext->Irp->IoStatus.Status = STATUS_SUCCESS;
        SrvFsdRestartSmbAtSendCompletion( NULL, workContext->Irp, workContext );

    } else {
        SrvFsdRestartSmbComplete( workContext );
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\srv\fsdsmb.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    fsdsmb.c

Abstract:

    This module implements SMB processing routines and their support
    routines for the File System Driver of the LAN Manager server.

    *** This module must be nonpageable.

Author:

    Chuck Lenzmeier (chuckl) 19-Mar-1990

Revision History:

--*/

//
//  This module is laid out as follows:
//      Includes
//      Local #defines
//      Local type definitions
//      Forward declarations of local functions
//      SMB processing routines
//      Restart routines and other support routines
//

#include "precomp.h"
#include "fsdsmb.tmh"
#pragma hdrstop

VOID SRVFASTCALL
SrvFspRestartLargeReadAndXComplete(
    IN OUT PWORK_CONTEXT WorkContext
    );

VOID SRVFASTCALL
RestartReadAndXCompressedSendComplete (
    IN OUT PWORK_CONTEXT WorkContext
    );

#if SRVCATCH
VOID
SrvUpdateCatchBuffer (
    IN PWORK_CONTEXT WorkContext,
    IN OUT PBYTE Buffer,
    IN DWORD BufferLength
    );
#endif


#ifdef ALLOC_PRAGMA
//#pragma alloc_text( PAGE8FIL, SrvFsdRestartRead )
#pragma alloc_text( PAGE8FIL, SrvFsdRestartReadAndX )
#pragma alloc_text( PAGE8FIL, SrvFsdRestartReadAndXCompressed )
#pragma alloc_text( PAGE8FIL, SrvFsdRestartWrite )
#pragma alloc_text( PAGE8FIL, SrvFsdRestartWriteAndX )
#pragma alloc_text( PAGE, RestartReadAndXCompressedSendComplete )
#pragma alloc_text( PAGE, SrvFspRestartLargeReadAndXComplete )

#if DBG
#pragma alloc_text( PAGE, SrvValidateCompressedData )
#endif

#if SRVCATCH
#pragma alloc_text( PAGE, SrvUpdateCatchBuffer )
#endif

#endif


VOID SRVFASTCALL
SrvFsdRestartRead (
    IN OUT PWORK_CONTEXT WorkContext
    )

/*++

Routine Description:

    Processes file read completion for a Read SMB.

Arguments:

    WorkContext - Supplies a pointer to the work context block
        describing server-specific context for the request.

Return Value:

    None.

--*/

{
    PREQ_READ request;
    PRESP_READ response;

    NTSTATUS status = STATUS_SUCCESS;
    PRFCB rfcb;
    SHARE_TYPE shareType;
    KIRQL oldIrql;
    USHORT readLength;
    BOOLEAN bNeedTrace = (WorkContext->bAlreadyTrace == FALSE);

    UNLOCKABLE_CODE( 8FIL );

    if (bNeedTrace) {
        if (WorkContext->PreviousSMB == EVENT_TYPE_SMB_LAST_EVENT)
            WorkContext->PreviousSMB = EVENT_TYPE_SMB_READ;
        SrvWmiStartContext(WorkContext);
    }
    else
        WorkContext->bAlreadyTrace = FALSE;

    IF_DEBUG(FSD2) SrvPrint0( " - SrvFsdRestartRead\n" );

    //
    // Get the request and response parameter pointers.
    //

    request = (PREQ_READ)WorkContext->RequestParameters;
    response = (PRESP_READ)WorkContext->ResponseParameters;

    //
    // Get the file pointer.
    //

    rfcb = WorkContext->Rfcb;
    shareType = rfcb->ShareType;
    IF_DEBUG(FSD2) {
        SrvPrint2( "  connection 0x%p, RFCB 0x%p\n",
                    WorkContext->Connection, rfcb );
    }

    //
    // If the read failed, set an error status in the response header.
    // (If we tried to read entirely beyond the end of file, we return a
    // normal response indicating that nothing was read.)
    //

    status = WorkContext->Irp->IoStatus.Status;
    readLength = (USHORT)WorkContext->Irp->IoStatus.Information;

    if ( status == STATUS_BUFFER_OVERFLOW && shareType == ShareTypePipe ) {

        //
        // If this is an named pipe and the error is
        // STATUS_BUFFER_OVERFLOW, set the error in the smb header, but
        // return all the data to the client.
        //

        SrvSetBufferOverflowError( WorkContext );

    } else if ( !NT_SUCCESS(status) ) {

        if ( status != STATUS_END_OF_FILE ) {

            IF_DEBUG(ERRORS) SrvPrint1( "Read failed: %X\n", status );
            if ( KeGetCurrentIrql() >= DISPATCH_LEVEL ) {
                WorkContext->FspRestartRoutine = SrvFsdRestartRead;
                QUEUE_WORK_TO_FSP( WorkContext );
            } else {
                SrvSetSmbError( WorkContext, status );
                SrvFsdSendResponse( WorkContext );
            }
            IF_DEBUG(FSD2) SrvPrint0( "SrvFsdRestartRead complete\n" );

            goto Cleanup;

        } else {
            readLength = 0;
        }
    }

#ifdef SLMDBG
    {
        PRFCB_TRACE entry;
        PCHAR readAddress;
        ACQUIRE_GLOBAL_SPIN_LOCK( Fsd, &oldIrql );
        rfcb->OperationCount++;
        entry = &rfcb->Trace[rfcb->NextTrace];
        if ( ++rfcb->NextTrace == SLMDBG_TRACE_COUNT ) {
            rfcb->NextTrace = 0;
            rfcb->TraceWrapped = TRUE;
        }
        RELEASE_GLOBAL_SPIN_LOCK( Fsd, oldIrql );
        entry->Command = WorkContext->NextCommand;
        KeQuerySystemTime( &entry->Time );
        entry->Data.ReadWrite.Offset = SmbGetUlong( &request->Offset );
        entry->Data.ReadWrite.Length = readLength;
        readAddress = (PCHAR)response->Buffer;
    }
#endif

    //
    // The read completed successfully.  If this is a disk file, update
    // the file position.
    //

    if (shareType == ShareTypeDisk) {

#if SRVCATCH
        if( KeGetCurrentIrql() == 0 &&
            rfcb->SrvCatch &&
            SmbGetUlong( &request->Offset ) == 0 ) {

            SrvUpdateCatchBuffer( WorkContext, (PCHAR)response->Buffer, readLength );
        }
#endif
        rfcb->CurrentPosition = SmbGetUlong( &request->Offset ) + readLength;

    }

    //
    // Save the count of bytes read, to be used to update the server
    // statistics database.
    //

    UPDATE_READ_STATS( WorkContext, readLength );

    //
    // Build the response message.
    //

    response->WordCount = 5;
    SmbPutUshort( &response->Count, readLength );
    RtlZeroMemory( (PVOID)&response->Reserved[0], sizeof(response->Reserved) );
    SmbPutUshort(
        &response->ByteCount,
        (USHORT)(readLength + FIELD_OFFSET(RESP_READ,Buffer[0]) -
                                FIELD_OFFSET(RESP_READ,BufferFormat))
        );
    response->BufferFormat = SMB_FORMAT_DATA;
    SmbPutUshort( &response->DataLength, readLength );

    WorkContext->ResponseParameters = NEXT_LOCATION(
                                        response,
                                        RESP_READ,
                                        readLength
                                        );

    //
    // Processing of the SMB is complete.  Send the response.
    //

    SrvFsdSendResponse( WorkContext );

Cleanup:
    IF_DEBUG(FSD2) SrvPrint0( "SrvFsdRestartRead complete\n" );
    if (bNeedTrace) {
        SrvWmiEndContext(WorkContext);
    }

    return;

} // SrvFsdRestartRead

VOID SRVFASTCALL
RestartReadAndXCompressedSendComplete (
    IN OUT PWORK_CONTEXT WorkContext
    )
/*++

Routine Description:

    Processes the TDI transport send complete for a compressed ReadAndX SMB

Arguments:

    WorkContext - Supplies a pointer to the work context block
        describing server-specific context for the request.

Return Value:

    None.
--*/
{
    PRFCB rfcb = WorkContext->Rfcb;
    PLFCB lfcb = WorkContext->Rfcb->Lfcb;
    NTSTATUS status;
    PMDL mdl = WorkContext->ResponseBuffer->Mdl->Next;

    PAGED_CODE();

    //
    // If we have a cache mdl, give it back to the cache manager
    //

    if( mdl != NULL ) {
        WorkContext->ResponseBuffer->Mdl->Next = NULL;
    }

    if( lfcb->MdlReadCompleteCompressed == NULL ||
        !lfcb->MdlReadCompleteCompressed(   lfcb->FileObject,
                                            mdl,
                                            lfcb->DeviceObject) ) {

        status = SrvIssueMdlCompleteRequest( WorkContext, NULL, mdl, IRP_MJ_READ,
                                    &WorkContext->Parameters.ReadAndXCompressed.ReadOffset,
                                    WorkContext->Parameters.ReadAndXCompressed.ReadLength
                                   );

        if( !NT_SUCCESS( status ) ) {
            SrvLogServiceFailure( SRV_SVC_MDL_COMPLETE, status );
        }
    }

    //
    // Free the work item
    //
    SrvDereferenceWorkItem( WorkContext );
}

#if DBG
VOID
SrvValidateCompressedData(
    PWORK_CONTEXT         WorkContext,
    PMDL                  CompressedDataMdl,
    PCOMPRESSED_DATA_INFO Cdi
)

/*++

    Make sure the compressed buffer that we just got from the filesystem is correct
    We do this by decompressing it!

--*/
{
    ULONG i, compressedDataLength;
    PMDL mdl;
    NTSTATUS status;
    PBYTE compressedBuffer;
    PBYTE uncompressedBuffer;
    ULONG count;
    PBYTE pin;

    PAGED_CODE();

    //
    // We need to copy the compressed data into a flat buffer
    //
    for ( i = compressedDataLength = 0; i < Cdi->NumberOfChunks; i++ ) {
        compressedDataLength += Cdi->CompressedChunkSizes[i];
    }

    if( compressedDataLength && CompressedDataMdl == NULL ) {
        DbgPrint( "SrvValidateCompressedData(wc %X, cdi %X, mdl %X ) -- no MDL!",
                  WorkContext, Cdi, WorkContext->Irp->MdlAddress );
        // DbgBreakPoint();
        return;
    }

    if( compressedDataLength > SrvMaxCompressedDataLength ) {
        DbgPrint( "SrvValidateCompressedData(wc %X, cdi %X) compresseddatalength %u\n",
            WorkContext, Cdi, compressedDataLength );
        DbgBreakPoint();
        return;
    }

    pin = compressedBuffer =
        ALLOCATE_NONPAGED_POOL( compressedDataLength, BlockTypeDataBuffer );
    if( compressedBuffer == NULL ) {
        return;
    }

    for( mdl = CompressedDataMdl; mdl != NULL; mdl = mdl->Next ) {
        i = MmGetMdlByteCount( mdl );

        RtlCopyMemory( pin, MmGetSystemAddressForMdl( mdl ), i );
        pin += i;
    }
    //
    // The largest output chunk is SrvMaxCompressedDataLength
    //
    uncompressedBuffer = ALLOCATE_HEAP_COLD( SrvMaxCompressedDataLength, BlockTypeDataBuffer );
    if( uncompressedBuffer == NULL ) {
        DEALLOCATE_NONPAGED_POOL( compressedBuffer );
        return;
    }

    status = RtlDecompressChunks( uncompressedBuffer, SrvMaxCompressedDataLength,
                         compressedBuffer, compressedDataLength,
                         NULL, 0, Cdi );

    if( !NT_SUCCESS( status ) ) {
        DbgPrint( "\nSrvValidateCompressedData - status %X\n", status );
        DbgPrint( "    WC %X, CDI %X, Irp %X, Mdl %X, InBuffer %X\n",
            WorkContext, Cdi, WorkContext->Irp,
            CompressedDataMdl, uncompressedBuffer
        );
        DbgBreakPoint();
    }

    DEALLOCATE_NONPAGED_POOL( compressedBuffer );
    FREE_HEAP( uncompressedBuffer );
}
#endif

VOID SRVFASTCALL
SrvFsdRestartReadAndXCompressed (
    IN OUT PWORK_CONTEXT WorkContext
    )
/*++

Routine Description:

    Processes file read completion for a compressed ReadAndX SMB

    This routine may be called in the FSD or the FSP.  There can be
     no chained command.

Arguments:

    WorkContext - Supplies a pointer to the work context block
        describing server-specific context for the request.

Return Value:

    None.

--*/

{
    PRFCB rfcb       = WorkContext->Rfcb;
    PIRP irp         = WorkContext->Irp;
    NTSTATUS status  = irp->IoStatus.Status;
    ULONG readLength = (ULONG)irp->IoStatus.Information;    // size of uncompressed data
    ULONG dataLength;                                       // size of compressed data
    ULONG cdiLength;                                        // size of compressedDataInfo
    USHORT flags2;
    PCOMPRESSED_DATA_INFO compressedDataInfo;
    PRESP_READ_ANDX response;
    ULONG i;
    BOOLEAN bNeedTrace = (WorkContext->bAlreadyTrace == FALSE);

    UNLOCKABLE_CODE( 8FIL );
    if (bNeedTrace) {
        if (WorkContext->PreviousSMB == EVENT_TYPE_SMB_LAST_EVENT)
            WorkContext->PreviousSMB = EVENT_TYPE_SMB_READ_AND_X;
        SrvWmiStartContext(WorkContext);
    }
    else
        WorkContext->bAlreadyTrace = FALSE;

    IF_DEBUG( COMPRESSION ) {
        KdPrint(( "SRV: SrvFsdRestartReadAndXCompressed status %X, uncompressed len %u, mdl %p\n",
            status, readLength, irp->MdlAddress ));
    }

    if( NT_SUCCESS( status ) && readLength != 0 ) {
        //
        // Scan the Compression Info structure tallying the sizes of
        // each chunk.
        //
        //
        compressedDataInfo = WorkContext->Parameters.ReadAndXCompressed.Aux.Buffer;

#if DBG
        SrvValidateCompressedData( WorkContext, WorkContext->Irp->MdlAddress,compressedDataInfo );
#endif

        cdiLength = FIELD_OFFSET( COMPRESSED_DATA_INFO, CompressedChunkSizes ) +
                    (sizeof(ULONG) * compressedDataInfo->NumberOfChunks );

        for ( i = dataLength = 0;
              i < compressedDataInfo->NumberOfChunks;
              i++ ) {

            dataLength += compressedDataInfo->CompressedChunkSizes[i];
        }

    } else if( status == STATUS_END_OF_FILE || readLength == 0 ) {

        readLength = dataLength = cdiLength = 0;

    } else {

        //
        // Make sure we are at passive level
        //
        if( KeGetCurrentIrql() >= DISPATCH_LEVEL ) {
            WorkContext->FspRestartRoutine = SrvFsdRestartReadAndXCompressed;
            SrvQueueWorkToFsp( WorkContext );
            goto Cleanup;
        }

        irp->Tail.Overlay.AuxiliaryBuffer = NULL;

        IF_DEBUG( ERRORS ) {
            KdPrint(("SRV: SrvFsdRestartReadAndXCompressed status %X\n", status ));
        }

        if( status != STATUS_INVALID_READ_MODE &&
            status != STATUS_UNSUPPORTED_COMPRESSION &&
            status != STATUS_USER_MAPPED_FILE &&
            status != STATUS_NOT_SUPPORTED &&
            status != STATUS_BAD_COMPRESSION_BUFFER ) {

            //
            // Set the error and get out!
            //
            SrvSetSmbError( WorkContext, status );
            SrvFsdSendResponse( WorkContext );
            goto Cleanup;
        }

        IF_DEBUG( COMPRESSION ) {
            KdPrint(( "    %X: rerouting to SrvSmbReadAndX\n", status ));
        }

        //
        // No more compressed reads for this file!
        //
        rfcb->Mfcb->NonpagedMfcb->OpenFileAttributes &= ~FILE_ATTRIBUTE_COMPRESSED;

        //
        // We now need to turn around and do a regular non-compressed read.  We
        //  can just reroute this back to the original Read&X processor because we
        //  know that we have not changed the original request received from the client.
        //  Also, we have turned off both the FILE_ATTRIBUTE_COMPRESSED flag in the
        //  Mfcb, as well as the SMB_FLAGS2_COMPRESSED bit in the header.  Therefore
        //  we will not loop!
        //
        // We also know that SrvSmbReadAndX will return SmbStatusInProgress, because
        //  all of the error checks have previously passed!
        //
        // This is not a terribly efficient way to handle this error, but it should be
        //  extremely rare.
        //
        SrvStatistics.CompressedReadsFailed++;

        (VOID)SrvSmbReadAndX( WorkContext );

        goto Cleanup;
    }

    irp->Tail.Overlay.AuxiliaryBuffer = NULL;

    //
    // Update the file position
    //
    WorkContext->Rfcb->CurrentPosition =
        WorkContext->Parameters.ReadAndXCompressed.ReadOffset.LowPart + readLength;

    //
    // Build and send the response
    //
    response = (PRESP_READ_ANDX)WorkContext->ResponseParameters;

    SmbPutUshort( &response->Remaining, (USHORT)-1 );
    response->WordCount = 12;
    response->AndXCommand = SMB_COM_NO_ANDX_COMMAND;
    response->AndXReserved = 0;
    SmbPutUshort( &response->AndXOffset, 0 );
    SmbPutUshort( &response->DataCompactionMode, 0 );
    SmbPutUshort( &response->CdiLength, (USHORT)cdiLength );
    SmbPutUshort( &response->DataLength, (USHORT)readLength );
    SmbPutUshort( &response->DataLengthHigh, (USHORT)(readLength >> 16) );
    SmbPutUshort( &response->DataOffset, (USHORT)READX_BUFFER_OFFSET );
    RtlZeroMemory( (PVOID)&response->Reserved3[0], sizeof(response->Reserved3) );
    SmbPutUshort( &response->ByteCount, (USHORT)(cdiLength + dataLength) );

    WorkContext->ResponseHeader->Flags |= SMB_FLAGS_SERVER_TO_REDIR;

    //
    // If we got some data, indicate to the client that we are returning
    //   a compressed response
    //
    if( cdiLength ) {
        //
        // Copy the COMPRESSED_DATA_INFO structure to the Data[] portion of the
        // response.
        //
        RtlCopyMemory( response->Buffer, compressedDataInfo, cdiLength );

        flags2 = SmbGetAlignedUshort( &WorkContext->ResponseHeader->Flags2 );
        flags2 |= SMB_FLAGS2_COMPRESSED;

        SmbPutAlignedUshort( &WorkContext->ResponseHeader->Flags2, flags2 );

        WorkContext->ResponseBuffer->Mdl->Next = irp->MdlAddress;
    }

    WorkContext->ResponseBuffer->Mdl->ByteCount = READX_BUFFER_OFFSET + cdiLength;

    WorkContext->ResponseBuffer->DataLength =
        READX_BUFFER_OFFSET + cdiLength + dataLength;

    WorkContext->FspRestartRoutine = RestartReadAndXCompressedSendComplete;

    irp->Cancel = FALSE;

    SrvStartSend2( WorkContext, SrvQueueWorkToFspAtSendCompletion );

Cleanup:
    if (bNeedTrace) {
        SrvWmiEndContext(WorkContext);
    }
    return;
}


VOID SRVFASTCALL
SrvFsdRestartReadAndX (
    IN OUT PWORK_CONTEXT WorkContext
    )

/*++

Routine Description:

    Processes file read completion for a ReadAndX SMB.

    This routine may be called in the FSD or the FSP.  If the chained
    command is Close, it will be called in the FSP.

    *** This routine cannot look at the original ReadAndX request!
        This is because the read data may have overlaid the request.
        All necessary information from the request must be stored
        in WorkContext->Parameters.ReadAndX.

Arguments:

    WorkContext - Supplies a pointer to the work context block
        describing server-specific context for the request.

Return Value:

    None.

--*/

{
    PRESP_READ_ANDX response;

    NTSTATUS status = STATUS_SUCCESS;
    PRFCB rfcb;
    SHARE_TYPE shareType;
    KIRQL oldIrql;
    PCHAR readAddress;
    CLONG bufferOffset;
    ULONG readLength;
    BOOLEAN bNeedTrace = (WorkContext->bAlreadyTrace == FALSE);

    UNLOCKABLE_CODE( 8FIL );
    if (bNeedTrace) {
        if (WorkContext->PreviousSMB == EVENT_TYPE_SMB_LAST_EVENT)
            WorkContext->PreviousSMB = EVENT_TYPE_SMB_READ_AND_X;
        SrvWmiStartContext(WorkContext);
    }
    else
        WorkContext->bAlreadyTrace = FALSE;

    IF_DEBUG(FSD2) SrvPrint0( " - SrvFsdRestartReadAndX\n" );

    //
    // Get the response parameter pointer.
    //

    response = (PRESP_READ_ANDX)WorkContext->ResponseParameters;

    //
    // Get the file pointer.
    //

    rfcb = WorkContext->Rfcb;
    shareType = rfcb->ShareType;
    IF_DEBUG(FSD2) {
        SrvPrint2( "  connection 0x%p, RFCB 0x%p\n",
                    WorkContext->Connection, rfcb );
    }

    //
    // If the read failed, set an error status in the response header.
    // (If we tried to read entirely beyond the end of file, we return a
    // normal response indicating that nothing was read.)
    //

    status = WorkContext->Irp->IoStatus.Status;
    readLength = (ULONG)WorkContext->Irp->IoStatus.Information;

    if ( status == STATUS_BUFFER_OVERFLOW && shareType == ShareTypePipe ) {

        //
        // If this is an named pipe and the error is
        // STATUS_BUFFER_OVERFLOW, set the error in the smb header, but
        // return all the data to the client.
        //

        SrvSetBufferOverflowError( WorkContext );

    } else if ( !NT_SUCCESS(status) ) {

        if ( status != STATUS_END_OF_FILE ) {

            IF_DEBUG(ERRORS) SrvPrint1( "Read failed: %X\n", status );
            if ( KeGetCurrentIrql() >= DISPATCH_LEVEL ) {
                WorkContext->FspRestartRoutine = SrvFsdRestartReadAndX;
                QUEUE_WORK_TO_FSP( WorkContext );
            } else {
                SrvSetSmbError( WorkContext, status );
                SrvFsdSendResponse( WorkContext );
            }
            IF_DEBUG(FSD2) SrvPrint0("SrvFsdRestartReadAndX complete\n");
            goto Cleanup;
        } else {
            readLength = 0;
        }
    }

    //
    // The read completed successfully.  Generate information about the
    // destination of the read data.  Find out how much was actually
    // read.  If none was read, we don't have to worry about the offset.
    //

    if ( readLength != 0 ) {

        readAddress = WorkContext->Parameters.ReadAndX.ReadAddress;
        bufferOffset = (ULONG)(readAddress - (PCHAR)WorkContext->ResponseHeader);

        //
        // Save the count of bytes read, to be used to update the server
        // statistics database.
        //

        UPDATE_READ_STATS( WorkContext, readLength );

    } else {

        readAddress = (PCHAR)response->Buffer;
        bufferOffset = 0;

    }

#ifdef SLMDBG
    {
        PRFCB_TRACE entry;
        ACQUIRE_GLOBAL_SPIN_LOCK( Fsd, &oldIrql );
        rfcb->OperationCount++;
        entry = &rfcb->Trace[rfcb->NextTrace];
        if ( ++rfcb->NextTrace == SLMDBG_TRACE_COUNT ) {
            rfcb->NextTrace = 0;
            rfcb->TraceWrapped = TRUE;
        }
        RELEASE_GLOBAL_SPIN_LOCK( Fsd, oldIrql );
        entry->Command = WorkContext->NextCommand;
        KeQuerySystemTime( &entry->Time );
        entry->Data.ReadWrite.Offset =
                            WorkContext->Parameters.ReadAndX.ReadOffset.LowPart;
        ASSERT (WorkContext->Parameters.ReadAndX.ReadOffset.HighPart == 0);
        entry->Data.ReadWrite.Length = readLength;
    }
#endif

    if (shareType == ShareTypePipe) {

        //
        // If this is NPFS then, Irp->Overlay.AllocationSize actually
        // contains the number bytes left to read on this side of the named
        // pipe.  Return this information to the client.
        //

        if (WorkContext->Irp->Overlay.AllocationSize.LowPart != 0) {
            SmbPutUshort(
                &response->Remaining,
                (USHORT)(WorkContext->Irp->Overlay.AllocationSize.LowPart - readLength)
                );
        } else {
            SmbPutUshort(
                &response->Remaining,
                0
                );
        }

    } else {

        if ( shareType == ShareTypeDisk ) {

#if SRVCATCH
            if( KeGetCurrentIrql() == 0 &&
                rfcb->SrvCatch &&
                WorkContext->Parameters.ReadAndX.ReadOffset.QuadPart == 0 ) {

                SrvUpdateCatchBuffer( WorkContext, readAddress, readLength );
            }
#endif
            //
            // If this is a disk file, then update the file position.
            //

            rfcb->CurrentPosition =
                WorkContext->Parameters.ReadAndX.ReadOffset.LowPart +
                readLength;
        }

        SmbPutUshort( &response->Remaining, (USHORT)-1 );
    }

    //
    // Build the response message.  (Note that if no data was read, we
    // return a byte count of 0 -- we don't add padding.)
    //
    // *** Note that even though there may have been a chained command,
    //     we make this the last response in the chain.  This is what
    //     the OS/2 server does.  (Sort of -- it doesn't bother to
    //     update the AndX fields of the response.) Since the only legal
    //     chained commands are Close and CloseAndTreeDisc, this seems
    //     like a reasonable thing to do.  It does make life easier --
    //     we don't have to find the end of the read data and write
    //     another response there.  Besides, the read data might have
    //     completely filled the SMB buffer.
    //

    response->WordCount = 12;
    response->AndXCommand = SMB_COM_NO_ANDX_COMMAND;
    response->AndXReserved = 0;
    SmbPutUshort( &response->AndXOffset, 0 );
    SmbPutUshort( &response->DataCompactionMode, 0 );
    SmbPutUshort( &response->Reserved, 0 );
    SmbPutUshort( &response->DataLength, (USHORT)readLength );
    SmbPutUshort( &response->DataOffset, (USHORT)bufferOffset );
    SmbPutUshort( &response->DataLengthHigh, (USHORT)(readLength >> 16) );
    RtlZeroMemory( (PVOID)&response->Reserved3[0], sizeof(response->Reserved3) );
    SmbPutUshort(
        &response->ByteCount,
        (USHORT)(readLength + (readAddress - response->Buffer))
        );

    WorkContext->ResponseParameters = NEXT_LOCATION(
                                        response,
                                        RESP_READ_ANDX,
                                        readLength +
                                            (readAddress - response->Buffer)
                                        );

    //
    // Processing of the SMB is complete, except that the file may still
    // need to be closed.  If not, just send the response.  If this is a
    // ReadAndX and Close, we need to close the file first.
    //
    // *** Note that other chained commands are illegal, but are ignored
    //     -- no error is returned.
    //

    if ( WorkContext->NextCommand != SMB_COM_CLOSE ) {

        //
        // Not a chained Close.  Just send the response.
        //

        SrvFsdSendResponse( WorkContext );

    } else {

        ASSERT( KeGetCurrentIrql() < DISPATCH_LEVEL );

        //
        // Remember the file last write time, to correctly set this on
        // close.
        //

        WorkContext->Parameters.LastWriteTime =
                WorkContext->Parameters.ReadAndX.LastWriteTimeInSeconds;

        //
        // This is a ReadAndX and Close.  Call SrvRestartChainedClose to
        // do the close and send the response.
        //

        SrvRestartChainedClose( WorkContext );

    }
    IF_DEBUG(FSD2) SrvPrint0( "SrvFsdRestartReadAndX complete\n" );

Cleanup:
    if (bNeedTrace) {
        SrvWmiEndContext(WorkContext);
    }
    return;

} // SrvFsdRestartReadAndX

/*
 * This routine is called at final send completion
 */
VOID SRVFASTCALL
SrvFspRestartLargeReadAndXComplete(
    IN OUT PWORK_CONTEXT WorkContext
    )
{
    NTSTATUS status;

    PAGED_CODE();

    if( WorkContext->Parameters.ReadAndX.SavedMdl != NULL ) {

        WorkContext->ResponseBuffer->Mdl = WorkContext->Parameters.ReadAndX.SavedMdl;

        MmPrepareMdlForReuse( WorkContext->ResponseBuffer->PartialMdl );
        WorkContext->ResponseBuffer->PartialMdl->Next = NULL;

    }

    if ( WorkContext->Parameters.ReadAndX.MdlRead == TRUE ) {

        //
        // Call the Cache Manager to release the MDL chain.
        //
        if( WorkContext->Parameters.ReadAndX.CacheMdl ) {
            //
            // Try the fast path first..
            //
            if( WorkContext->Rfcb->Lfcb->MdlReadComplete == NULL ||

                WorkContext->Rfcb->Lfcb->MdlReadComplete(
                    WorkContext->Rfcb->Lfcb->FileObject,
                    WorkContext->Parameters.ReadAndX.CacheMdl,
                    WorkContext->Rfcb->Lfcb->DeviceObject ) == FALSE ) {

                //
                // Fast path didn't work, try an IRP...
                //
                status = SrvIssueMdlCompleteRequest( WorkContext, NULL,
                                            WorkContext->Parameters.ReadAndX.CacheMdl,
                                            IRP_MJ_READ,
                                            &WorkContext->Parameters.ReadAndX.ReadOffset,
                                            WorkContext->Parameters.ReadAndX.ReadLength
                        );

                if( !NT_SUCCESS( status ) ) {
                    //
                    // At this point, all we can do is complain!
                    //
                    SrvLogServiceFailure( SRV_SVC_MDL_COMPLETE, status );
                }
            }
        }

    } else {

        PMDL mdl = (PMDL)(((ULONG_PTR)(WorkContext->Parameters.ReadAndX.ReadAddress) + sizeof(PVOID) - 1) & ~(sizeof(PVOID)-1));

        //
        // We shortened the byte count if the read returned less data than we asked for
        //
        mdl->ByteCount = WorkContext->Parameters.ReadAndX.ReadLength;

        MmUnlockPages( mdl );
        MmPrepareMdlForReuse( mdl );

        FREE_HEAP( WorkContext->Parameters.ReadAndX.Buffer );
    }

    SrvDereferenceWorkItem( WorkContext );
    return;
}

/*
 * This routine is called when the read completes
 */
VOID SRVFASTCALL
SrvFsdRestartLargeReadAndX (
    IN OUT PWORK_CONTEXT WorkContext
    )

/*++

Routine Description:

    Processes file read completion for a ReadAndX SMB which
     is larger than the negotiated buffer size, and is from
     a disk file.

    There is no follow on command.

Arguments:

    WorkContext - Supplies a pointer to the work context block
        describing server-specific context for the request.

Return Value:

    None.

--*/

{
    PRESP_READ_ANDX response = (PRESP_READ_ANDX)WorkContext->ResponseParameters;

    USHORT readLength;
    NTSTATUS status = WorkContext->Irp->IoStatus.Status;
    PRFCB rfcb = WorkContext->Rfcb;
    PIRP irp = WorkContext->Irp;
    BOOLEAN mdlRead = WorkContext->Parameters.ReadAndX.MdlRead;
    BOOLEAN bNeedTrace = (WorkContext->bAlreadyTrace == FALSE);

#ifdef SRVCATCH
    // For the Catch case, make sure we're PASSIVE
    if( (KeGetCurrentIrql() != PASSIVE_LEVEL) && (WorkContext->Rfcb->SrvCatch != 0) ) {
        //
        // Requeue this routine to come back around at passive level.
        //   (inefficient, but should be very rare)
        //
        WorkContext->FspRestartRoutine = SrvFsdRestartLargeReadAndX;
        SrvQueueWorkToFspAtDpcLevel( WorkContext );
        goto Cleanup;
    }
#endif

    UNLOCKABLE_CODE( 8FIL );
    if (bNeedTrace) {
        if (WorkContext->PreviousSMB == EVENT_TYPE_SMB_LAST_EVENT)
            WorkContext->PreviousSMB = EVENT_TYPE_SMB_READ_AND_X;
        SrvWmiStartContext(WorkContext);
    }
    else
        WorkContext->bAlreadyTrace = FALSE;

    // Copy the MDL pointer back out of the IRP.  This is because if the read
    // failed, CC will free the MDL and NULL the pointer.  Not retrieving it in the
    // non-fast-io path will result in us holding (and possibly freeing) a dangling pointer
    if( mdlRead )
    {
        WorkContext->Parameters.ReadAndX.CacheMdl = WorkContext->Irp->MdlAddress;
    }

    if ( !NT_SUCCESS(status) ) {

        if( status != STATUS_END_OF_FILE ) {
            IF_DEBUG(ERRORS) SrvPrint1( "Read failed: %X\n", status );
            //
            // We cannot call SrvSetSmbError() at elevated IRQL.
            //
            if( KeGetCurrentIrql() != 0 ) {
                //
                // Requeue this routine to come back around at passive level.
                //   (inefficient, but should be very rare)
                //
                WorkContext->FspRestartRoutine = SrvFsdRestartLargeReadAndX;
                SrvQueueWorkToFspAtDpcLevel( WorkContext );
                goto Cleanup;
            }
            SrvSetSmbError( WorkContext, status );
        }

        readLength = 0;

    } else if( mdlRead ) {
        //
        // For an MDL read, we have to walk the MDL chain in order to
        // determine how much data was read.  This is because the
        // operation may have happened in multiple steps, with the MDLs
        // being chained together.  For example, part of the read may
        // have been satisfied by the fast path, while the rest was satisfied
        // using an IRP
        //

        PMDL mdl = WorkContext->Irp->MdlAddress;
        readLength = 0;

        while( mdl != NULL ) {
            readLength += (USHORT)MmGetMdlByteCount( mdl );
            mdl = mdl->Next;
        }
    } else {
        //
        // This was a copy read.  The I/O status block has the length.
        //
        readLength = (USHORT)WorkContext->Irp->IoStatus.Information;
    }

    //
    // Build the response message.  (Note that if no data was read, we
    // return a byte count of 0 -- we don't add padding.)
    //
    SmbPutUshort( &response->Remaining, (USHORT)-1 );
    response->WordCount = 12;
    response->AndXCommand = SMB_COM_NO_ANDX_COMMAND;
    response->AndXReserved = 0;
    SmbPutUshort( &response->AndXOffset, 0 );
    SmbPutUshort( &response->DataCompactionMode, 0 );
    SmbPutUshort( &response->Reserved, 0 );
    SmbPutUshort( &response->Reserved2, 0 );
    RtlZeroMemory( (PVOID)&response->Reserved3[0], sizeof(response->Reserved3) );
    SmbPutUshort( &response->DataLength, readLength );


    if( readLength == 0 ) {

        SmbPutUshort( &response->DataOffset, 0 );
        SmbPutUshort( &response->ByteCount, 0 );
        WorkContext->Parameters.ReadAndX.PadCount = 0;

    } else {

        //
        // Update the file position.
        //
        rfcb->CurrentPosition =
                WorkContext->Parameters.ReadAndX.ReadOffset.LowPart +
                readLength;

        //
        // Update statistics
        //
        UPDATE_READ_STATS( WorkContext, readLength );

        SmbPutUshort( &response->DataOffset,
                      (USHORT)(READX_BUFFER_OFFSET + WorkContext->Parameters.ReadAndX.PadCount) );

        SmbPutUshort( &response->ByteCount,
                      (USHORT)( readLength + WorkContext->Parameters.ReadAndX.PadCount ) );

    }

    //
    // We will use two MDLs to describe the packet we're sending -- one
    // for the header and parameters, the other for the data.
    //
    // Handling of the second MDL varies depending on whether we did a copy
    // read or an MDL read.
    //

    //
    // Set the first MDL for just the header + pad
    //
    IoBuildPartialMdl(
        WorkContext->ResponseBuffer->Mdl,
        WorkContext->ResponseBuffer->PartialMdl,
        WorkContext->ResponseBuffer->Buffer,
        READX_BUFFER_OFFSET + WorkContext->Parameters.ReadAndX.PadCount
        );

    WorkContext->ResponseBuffer->PartialMdl->MdlFlags |=
        (WorkContext->ResponseBuffer->Mdl->MdlFlags & MDL_NETWORK_HEADER); // prop flag

    //
    // Set the overall data length to the header + pad + data
    //
    WorkContext->ResponseBuffer->DataLength = READX_BUFFER_OFFSET +
                                              WorkContext->Parameters.ReadAndX.PadCount +
                                              readLength;

    irp->Cancel = FALSE;

    //
    // The second MDL depends on the kind of read which we did
    //
    if( readLength != 0 ) {

        if( mdlRead ) {

            WorkContext->ResponseBuffer->PartialMdl->Next =
                    WorkContext->Irp->MdlAddress;

        } else {

            //
            // This was a copy read.  The MDL describing the data buffer is in the SMB buffer
            //

            PMDL mdl = (PMDL)(((ULONG_PTR)(WorkContext->Parameters.ReadAndX.ReadAddress) + sizeof(PVOID) - 1) & ~(sizeof(PVOID)-1));

            WorkContext->ResponseBuffer->PartialMdl->Next = mdl;
            mdl->ByteCount = readLength;

        }

#ifdef SRVCATCH
        if( rfcb->SrvCatch && WorkContext->ResponseBuffer->PartialMdl->Next && (WorkContext->Parameters.ReadAndX.ReadOffset.QuadPart == 0) )
        {
            PVOID Buffer;

            Buffer = MmGetSystemAddressForMdlSafe( WorkContext->ResponseBuffer->PartialMdl->Next, LowPagePriority );
            if( Buffer )
            {
                SrvUpdateCatchBuffer( WorkContext, Buffer, WorkContext->ResponseBuffer->PartialMdl->Next->ByteCount );
            }
        }
#endif

    }

    //
    // SrvStartSend2 wants to use WorkContext->ResponseBuffer->Mdl, but
    //  we want it to use WorkContext->ResponseBuffer->PartialMdl.  So switch
    //  it!
    //
    WorkContext->Parameters.ReadAndX.SavedMdl = WorkContext->ResponseBuffer->Mdl;
    WorkContext->ResponseBuffer->Mdl = WorkContext->ResponseBuffer->PartialMdl;

    //
    // Send the response!
    //
    WorkContext->ResponseHeader->Flags |= SMB_FLAGS_SERVER_TO_REDIR;
    WorkContext->FspRestartRoutine = SrvFspRestartLargeReadAndXComplete;
    SrvStartSend2( WorkContext, SrvQueueWorkToFspAtSendCompletion );

Cleanup:
    if (bNeedTrace) {
        SrvWmiEndContext(WorkContext);
    }
    return;
}


VOID SRVFASTCALL
SrvFsdRestartWrite (
    IN OUT PWORK_CONTEXT WorkContext
    )

/*++

Routine Description:

    Processes file write completion for a Write SMB.

    This routine is called in the FSP for a write and close SMB so that
    it can free the pageable MFCB and for a write and unlock SMB so that
    it can do the unlock; for other SMBs, it is called in the FSD.

Arguments:

    WorkContext - Supplies a pointer to the work context block
        describing server-specific context for the request.

Return Value:

    None.

--*/

{
    PREQ_WRITE request;
    PRESP_WRITE response;

    NTSTATUS status = STATUS_SUCCESS;
    PRFCB rfcb;
    KIRQL oldIrql;
    USHORT writeLength;
    BOOLEAN bNeedTrace = (WorkContext->bAlreadyTrace == FALSE);

    UNLOCKABLE_CODE( 8FIL );
    if (bNeedTrace) {
        if (WorkContext->PreviousSMB == EVENT_TYPE_SMB_LAST_EVENT)
            WorkContext->PreviousSMB = EVENT_TYPE_SMB_WRITE;
        SrvWmiStartContext(WorkContext);
    }
    else
        WorkContext->bAlreadyTrace = FALSE;

    IF_DEBUG(FSD2) SrvPrint0( " - SrvFsdRestartWrite\n" );

    //
    // Get the request and response parameter pointers.
    //

    request = (PREQ_WRITE)WorkContext->RequestParameters;
    response = (PRESP_WRITE)WorkContext->ResponseParameters;

    //
    // Get the file pointer.
    //

    rfcb = WorkContext->Rfcb;
    IF_DEBUG(FSD2) {
        SrvPrint2( "  connection 0x%p, RFCB 0x%p\n",
                    WorkContext->Connection, rfcb );
    }

    //
    // If the write failed, set an error status in the response header.
    //

    status = WorkContext->Irp->IoStatus.Status;

    if ( !NT_SUCCESS(status) ) {

        IF_DEBUG(ERRORS) SrvPrint1( "Write failed: %X\n", status );
        if ( KeGetCurrentIrql() >= DISPATCH_LEVEL ) {
            WorkContext->FspRestartRoutine = SrvFsdRestartWrite;
            QUEUE_WORK_TO_FSP( WorkContext );
            goto Cleanup;
        }

        SrvSetSmbError( WorkContext, status );

    } else {

        //
        // The write succeeded.
        //

        writeLength = (USHORT)WorkContext->Irp->IoStatus.Information;

        //
        // Save the count of bytes written, to be used to update the
        // server statistics database.
        //

        UPDATE_WRITE_STATS( WorkContext, writeLength );

        if ( rfcb->ShareType == ShareTypeDisk ) {

            //
            // Update the file position.
            //

            rfcb->CurrentPosition = SmbGetUlong( &request->Offset ) + writeLength;

            if ( WorkContext->NextCommand == SMB_COM_WRITE ) {
                response->WordCount = 1;
                SmbPutUshort( &response->Count, writeLength );
                SmbPutUshort( &response->ByteCount, 0 );

                WorkContext->ResponseParameters =
                                         NEXT_LOCATION( response, RESP_WRITE, 0 );

                //
                // Processing of the SMB is complete.  Send the response.
                //

                SrvFsdSendResponse( WorkContext );
                IF_DEBUG(FSD2) SrvPrint0( "SrvFsdRestartWrite complete\n" );
                goto Cleanup;
            }

        } else if ( rfcb->ShareType == ShareTypePrint ) {

            //
            // Update the file position.
            //

            if ( WorkContext->NextCommand == SMB_COM_WRITE_PRINT_FILE ) {
                rfcb->CurrentPosition += writeLength;
            } else {
                rfcb->CurrentPosition =
                            SmbGetUlong( &request->Offset ) + writeLength;
            }
        }

        //
        // If this was a Write and Unlock request, do the unlock.  This
        // is safe because we are restarted in the FSP in this case.
        //
        // Note that if the write failed, the range remains locked.
        //

        if ( WorkContext->NextCommand == SMB_COM_WRITE_AND_UNLOCK ) {

            IF_SMB_DEBUG(READ_WRITE1) {
                SrvPrint0( "SrvFsdRestartWrite: unlock requested -- passing request to FSP\n" );
            }

            SrvRestartWriteAndUnlock( WorkContext );
            goto Cleanup;

        } else if ( WorkContext->NextCommand == SMB_COM_WRITE_AND_CLOSE ) {

            WorkContext->Parameters.LastWriteTime = SmbGetUlong(
                &((PREQ_WRITE_AND_CLOSE)request)->LastWriteTimeInSeconds );

        }

        //
        // If everything worked, build a response message.  (If something
        // failed, an error indication has already been placed in the SMB.)
        //

        if ( WorkContext->NextCommand == SMB_COM_WRITE_PRINT_FILE ) {

            //
            // ByteCount has a different offset for WRITE_PRINT_FILE
            //

            PRESP_WRITE_PRINT_FILE response2;

            response2 = (PRESP_WRITE_PRINT_FILE)WorkContext->ResponseParameters;
            response2->WordCount = 0;
            SmbPutUshort( &response2->ByteCount, 0 );

            WorkContext->ResponseParameters =
                          NEXT_LOCATION( response2, RESP_WRITE_PRINT_FILE, 0 );
        } else {

            response->WordCount = 1;
            SmbPutUshort( &response->Count, writeLength );
            SmbPutUshort( &response->ByteCount, 0 );

            WorkContext->ResponseParameters =
                                     NEXT_LOCATION( response, RESP_WRITE, 0 );
        }
    }

    //
    // If this was a Write and Close request, close the file.  It is
    // safe to close the RFCB here because if this is a Write and Close,
    // we're actually in the FSP, not in the FSD.
    //

    if ( WorkContext->NextCommand == SMB_COM_WRITE_AND_CLOSE ) {

        ASSERT( KeGetCurrentIrql() < DISPATCH_LEVEL );

        SrvRestartChainedClose( WorkContext );
        goto Cleanup;
    }

    //
    // Processing of the SMB is complete.  Send the response.
    //

    SrvFsdSendResponse( WorkContext );
    IF_DEBUG(FSD2) SrvPrint0( "SrvFsdRestartWrite complete\n" );

Cleanup:
    if (bNeedTrace) {
        SrvWmiEndContext(WorkContext);
    }
    return;

} // SrvFsdRestartWrite

VOID SRVFASTCALL
SrvFsdRestartPrepareMdlWriteAndX (
    IN OUT PWORK_CONTEXT WorkContext
    )
/*++

Routine Description:

    Processes the MDL preparation completion for the large WriteAndX SMB.

    This routine initiates the receipt of transport data into the file's MDL,
    and then control resumes at SrvFsdRestartWriteAndX when the transfer of data
    from the transport is complete.

Arguments:

    WorkContext - Supplies a pointer to the work context block
        describing server-specific context for the request.

--*/
{
    PIRP irp = WorkContext->Irp;
    PIO_STACK_LOCATION irpSp;
    PTDI_REQUEST_KERNEL_RECEIVE parameters;

    //
    // Make sure we call SrvFsdRestartWriteAndX at passive level when
    //  the TDI receive completes.
    //
    WorkContext->FsdRestartRoutine = SrvQueueWorkToFspAtDpcLevel;
    WorkContext->FspRestartRoutine = SrvFsdRestartWriteAndX;

    //
    // Make sure that we record the MDL address we're using
    //
    ASSERT( WorkContext->Parameters.WriteAndX.MdlAddress == NULL );
    WorkContext->Parameters.WriteAndX.MdlAddress = irp->MdlAddress;

    if( !NT_SUCCESS( irp->IoStatus.Status ) ) {

        //
        // Something went wrong.  Early-out to SrvFsdRestartWriteAndX.
        //
        if( KeGetCurrentIrql() < DISPATCH_LEVEL ) {
            SrvFsdRestartWriteAndX( WorkContext );
        } else {
            QUEUE_WORK_TO_FSP( WorkContext );
        }

        return;
    }

    ASSERT( irp->MdlAddress != NULL );

    //
    // Fill in the IRP for the TDI receive.  We want to receive the data into
    //  the buffer described by the MDL we've just gotten
    //

    irp->Tail.Overlay.OriginalFileObject = NULL;
    irp->Tail.Overlay.Thread = WorkContext->CurrentWorkQueue->IrpThread;

    irpSp = IoGetNextIrpStackLocation( irp );

    //
    // Set up the completion routine
    //
    IoSetCompletionRoutine(
        irp,
        SrvFsdIoCompletionRoutine,
        WorkContext,
        TRUE,
        TRUE,
        TRUE
        );

    SET_OPERATION_START_TIME( &WorkContext );

    irpSp->MajorFunction = IRP_MJ_INTERNAL_DEVICE_CONTROL;
    irpSp->MinorFunction = (UCHAR)TDI_RECEIVE;
    irpSp->FileObject = WorkContext->Connection->FileObject;
    irpSp->DeviceObject = WorkContext->Connection->DeviceObject;
    irpSp->Flags = 0;

    parameters = (PTDI_REQUEST_KERNEL_RECEIVE)&irpSp->Parameters;
    parameters->ReceiveLength = WorkContext->Parameters.WriteAndX.CurrentWriteLength;
    parameters->ReceiveFlags = 0;

    //
    // Account for the amount we are taking in
    //
    WorkContext->Parameters.WriteAndX.RemainingWriteLength -=
        WorkContext->Parameters.WriteAndX.CurrentWriteLength;

    irp->AssociatedIrp.SystemBuffer = NULL;
    irp->Flags = (ULONG)IRP_BUFFERED_IO;
    irp->IoStatus.Status = 0;

    ASSERT( irp->MdlAddress != NULL );

    (VOID)IoCallDriver( irpSp->DeviceObject, irp );

    //
    // Processing resumes at SrvFsdRestartWriteAndX() when we've received
    //  the data from the transport.  We will be at passive level.
    //
}

VOID SRVFASTCALL
RestartLargeWriteAndX (
    IN OUT PWORK_CONTEXT WorkContext
    )
/*++

Routine Description:

    This is the restart routine that's invoked when we have received more data from
    the transport, and we are not using MDLs to transfer the data into the file.

    This routine initiates the write to the file, and then control resumes at
    SrvFsdRestartWriteAndX when the write to the file is complete.

Arguments:

    WorkContext - Supplies a pointer to the work context block
        describing server-specific context for the request.

--*/
{
    PIRP irp = WorkContext->Irp;
    ULONG length;
    PRFCB rfcb = WorkContext->Rfcb;
    PLFCB lfcb = rfcb->Lfcb;

    //
    // Check if we successfully received more data from the transport
    //

    if( irp->Cancel ||
        (!NT_SUCCESS( irp->IoStatus.Status )
        && irp->IoStatus.Status != STATUS_BUFFER_OVERFLOW) ){

        SrvSetSmbError( WorkContext, irp->IoStatus.Status );
        SrvEndSmbProcessing( WorkContext, SmbStatusSendResponse );
        return;
    }

    //
    // We got more data from the transport.  We need to write it out to the file if we
    //   haven't encountered any errors yet.  The irp at this point holds the results of
    //   reading more data from the transport.
    //
    length = (ULONG)irp->IoStatus.Information;

    //
    // Adjust the parameters in the WorkContext
    //
    WorkContext->Parameters.WriteAndX.RemainingWriteLength -= length;
    WorkContext->Parameters.WriteAndX.CurrentWriteLength = length;

    //
    // If we have picked up an error, we just want to keep reading from
    //  the transport and not write to the file.
    //
    if( WorkContext->Parameters.WriteAndX.FinalStatus ) {

        //
        // Indicate that we didn't write any more data to the file
        //
        WorkContext->Irp->IoStatus.Information = 0;
        WorkContext->Irp->IoStatus.Status = WorkContext->Parameters.WriteAndX.FinalStatus;

        SrvFsdRestartWriteAndX( WorkContext );

        return;
    }

    //
    // Write the data to the file
    //
    if( lfcb->FastIoWrite != NULL ) {

        try {
            if( lfcb->FastIoWrite(
                    lfcb->FileObject,
                    &WorkContext->Parameters.WriteAndX.Offset,
                    WorkContext->Parameters.WriteAndX.CurrentWriteLength,
                    TRUE,
                    WorkContext->Parameters.WriteAndX.Key,
                    WorkContext->Parameters.WriteAndX.WriteAddress,
                    &WorkContext->Irp->IoStatus,
                    lfcb->DeviceObject
                    ) ) {

                //
                // The fast I/O path worked.  Call the restart routine directly
                //  to do postprocessing
                //
                SrvFsdRestartWriteAndX( WorkContext );


                return;
            }
        }
        except( EXCEPTION_EXECUTE_HANDLER ) {
            // Fall through to the slow path on an exception
            NTSTATUS status = GetExceptionCode();
            IF_DEBUG(ERRORS) {
                KdPrint(("FastIoRead threw exception %x\n", status ));
            }
        }
    }

    //
    // The fast path failed, use the IRP to write the data to the file
    //

    IoBuildPartialMdl(
        WorkContext->RequestBuffer->Mdl,
        WorkContext->RequestBuffer->PartialMdl,
        WorkContext->Parameters.WriteAndX.WriteAddress,
        WorkContext->Parameters.WriteAndX.CurrentWriteLength
        );

    //
    // Build the IRP.
    //
    SrvBuildReadOrWriteRequest(
            WorkContext->Irp,               // input IRP address
            lfcb->FileObject,               // target file object address
            WorkContext,                    // context
            IRP_MJ_WRITE,                   // major function code
            0,                              // minor function code
            WorkContext->Parameters.WriteAndX.WriteAddress,
            WorkContext->Parameters.WriteAndX.CurrentWriteLength,
            WorkContext->RequestBuffer->PartialMdl,
            WorkContext->Parameters.WriteAndX.Offset,
            WorkContext->Parameters.WriteAndX.Key
    );

    //
    // Ensure that processing resumes in SrvFsdRestartWriteAndX when the
    //  write has completed.  If this is the first part of a large write,
    //  we want to ensure that SrvFsdRestartWriteAndX is called at passive
    //  level because it might decide to use the cache manager to handle the
    //  rest of the write.
    //
    if ( WorkContext->Parameters.WriteAndX.InitialComplete ) {
        WorkContext->FsdRestartRoutine = SrvFsdRestartWriteAndX;
    } else {
        WorkContext->FsdRestartRoutine = SrvQueueWorkToFspAtDpcLevel;
        WorkContext->FspRestartRoutine = SrvFsdRestartWriteAndX;
    }

    (VOID)IoCallDriver( lfcb->DeviceObject, WorkContext->Irp );

    //
    // Processing resumes at SrvFsdRestartWriteAndX() when the file write
    //  is complete.
    //
}


VOID SRVFASTCALL
SrvFsdRestartWriteAndX (
    IN OUT PWORK_CONTEXT WorkContext
    )

/*++

Routine Description:

    This routine may be called in the FSD or the FSP.  If the chained
    command is Close, it will be called in the FSP.

    If WorkContext->LargeIndication is set, this means we are processing
    the flavor of WriteAndX that exceeds our negotiated buffer size.  There may
    be more data that we need to fetch from the transport.  We may or may not be
    doing MDL writes to the file.

    If there is no more data to be gotten from the transport, we send the response
    to the client.

Arguments:

    WorkContext - Supplies a pointer to the work context block
        describing server-specific context for the request.

--*/

{
    PREQ_WRITE_ANDX request;
    PREQ_NT_WRITE_ANDX ntRequest;
    PRESP_WRITE_ANDX response;

    PRFCB rfcb =        WorkContext->Rfcb;
    PIRP irp =          WorkContext->Irp;
    NTSTATUS status =   irp->IoStatus.Status;
    ULONG writeLength = (ULONG)irp->IoStatus.Information;

    ULONG requestedWriteLength;
    UCHAR nextCommand;
    USHORT nextOffset;
    USHORT reqAndXOffset;
    LARGE_INTEGER position;
    KIRQL oldIrql;
    BOOLEAN bNeedTrace = (WorkContext->bAlreadyTrace == FALSE);

    PREQ_CLOSE closeRequest;

    UNLOCKABLE_CODE( 8FIL );
    if (bNeedTrace) {
        if (WorkContext->PreviousSMB == EVENT_TYPE_SMB_LAST_EVENT)
            WorkContext->PreviousSMB = EVENT_TYPE_SMB_WRITE_AND_X;
        SrvWmiStartContext(WorkContext);
    }
    else
        WorkContext->bAlreadyTrace = FALSE;

    IF_DEBUG(FSD2) SrvPrint0( " - SrvFsdRestartWriteAndX\n" );

    //
    // Get the request and response parameter pointers.
    //
    request = (PREQ_WRITE_ANDX)WorkContext->RequestParameters;
    ntRequest = (PREQ_NT_WRITE_ANDX)WorkContext->RequestParameters;
    response = (PRESP_WRITE_ANDX)WorkContext->ResponseParameters;

    IF_DEBUG(FSD2) {
        SrvPrint2( "  connection 0x%p, RFCB 0x%p\n",
                    WorkContext->Connection, rfcb );
    }

    //
    // If we are using MDL transfers and we have more data to get from the client
    //  then STATUS_BUFFER_OVERFLOW is simply an indication from the transport that
    //  it has more data to give to us.  We consider that a success case for the
    //  purposes of this routine.
    //
    if( status == STATUS_BUFFER_OVERFLOW &&
        WorkContext->LargeIndication &&
        WorkContext->Parameters.WriteAndX.MdlAddress &&
        WorkContext->Parameters.WriteAndX.RemainingWriteLength ) {

        status = STATUS_SUCCESS;
    }

    //
    // Remember where the follow-on request begins, and what the next
    // command is, as we are about to overwrite this information.
    //

    reqAndXOffset = SmbGetUshort( &request->AndXOffset );

    nextCommand = request->AndXCommand;
    WorkContext->NextCommand = nextCommand;
    nextOffset = SmbGetUshort( &request->AndXOffset );

    //
    // If the write failed, set an error status in the response header.
    // We still return a valid parameter block, in case some bytes were
    // written before the error occurred.  Note that we do _not_ process
    // the next command if the write failed.
    //
    // *** OS/2 server behavior.  Note that this is _not_ done for core
    //     Write.
    //

    if ( !NT_SUCCESS(status) ) {

        IF_DEBUG(ERRORS) SrvPrint1( "Write failed: %X\n", status );
        if ( KeGetCurrentIrql() >= DISPATCH_LEVEL ) {
            WorkContext->FspRestartRoutine = SrvFsdRestartWriteAndX;
            QUEUE_WORK_TO_FSP( WorkContext );
            goto Cleanup;
        }

        if( WorkContext->LargeIndication ) {
            //
            // Once this error code is set, we cease writing to the file.  But
            //  we still need to consume the rest of the data that was sent to us
            //  by the client.
            //
            WorkContext->Parameters.WriteAndX.FinalStatus = status;
        }

        SrvSetSmbError( WorkContext, status );
        nextCommand = SMB_COM_NO_ANDX_COMMAND;
    }

    //
    // Update the file position.
    //

    if ( rfcb->ShareType != ShareTypePipe ) {

        //
        // We will ignore the distinction between clients that supply 32-bit
        // and 64-bit file offsets. The reason for doing this is because
        // the only clients that will use CurrentPosition is a 32-bit file
        // offset client. Therefore, the upper 32-bits will never be used
        // anyway.  In addition, the RFCB is per client, so there is no
        // possibility of clients mixing 32-bit and 64-bit file offsets.
        // Therefore, for the 64-bit client, we will only read 32-bits of file
        // offset.
        //

        if ( request->ByteCount == 12 ) {

            //
            // The client supplied a 32-bit file offset.
            //

            rfcb->CurrentPosition = SmbGetUlong( &request->Offset ) + writeLength;

        } else {

            //
            // The client supplied a 64-bit file offset. Only use 32-bits of
            // file offset.
            //

            rfcb->CurrentPosition = SmbGetUlong( &ntRequest->Offset ) + writeLength;

        }
    }

    //
    // Save the count of bytes written, to be used to update the server
    // statistics database.
    //

    UPDATE_WRITE_STATS( WorkContext, writeLength );

    IF_SMB_DEBUG(READ_WRITE1) {
        SrvPrint2( "SrvFsdRestartWriteAndX:  Fid 0x%lx, wrote %ld bytes\n",
                  rfcb->Fid, writeLength );
    }

    //
    // If we are doing large transfers, and there is still more to go, then we
    //  need to keep the cycle going.
    //
    if( WorkContext->LargeIndication &&
        WorkContext->Parameters.WriteAndX.RemainingWriteLength ) {

        PIO_STACK_LOCATION irpSp;
        PTDI_REQUEST_KERNEL_RECEIVE parameters;
        LARGE_INTEGER      PreviousWriteOffset;
        BOOLEAN fAppending = TRUE;

        PreviousWriteOffset = WorkContext->Parameters.WriteAndX.Offset;

        //
        // If we are only appending, do not change the offset
        //
        if( PreviousWriteOffset.QuadPart != 0xFFFFFFFFFFFFFFFF ) {

            WorkContext->Parameters.WriteAndX.Offset.QuadPart += writeLength;
            fAppending = FALSE;
        }

        //
        // If we haven't tried an MDL write yet, or if we are already using
        //   MDLs, then we want to keep using MDLs
        //
        if( NT_SUCCESS( status ) && fAppending == FALSE &&
            ( WorkContext->Parameters.WriteAndX.InitialComplete == FALSE ||
              ( WorkContext->Parameters.WriteAndX.MdlAddress &&
                WorkContext->Parameters.WriteAndX.RemainingWriteLength != 0 )
            ) ) {

            PLFCB lfcb = rfcb->Lfcb;
            NTSTATUS mdlStatus;

            ASSERT( KeGetCurrentIrql() < DISPATCH_LEVEL );

            WorkContext->Parameters.WriteAndX.InitialComplete = TRUE;

            //
            // If we already have an MDL, complete it now since we've already asked
            //  TDI to fill the buffer.
            //
            if( WorkContext->Parameters.WriteAndX.MdlAddress ) {

                irp->MdlAddress = WorkContext->Parameters.WriteAndX.MdlAddress;
                irp->IoStatus.Information = writeLength;

                if( lfcb->MdlWriteComplete == NULL ||

                    lfcb->MdlWriteComplete( lfcb->FileObject,
                                            &PreviousWriteOffset,
                                            WorkContext->Parameters.WriteAndX.MdlAddress,
                                            lfcb->DeviceObject
                                          ) == FALSE ) {

                        mdlStatus = SrvIssueMdlCompleteRequest( WorkContext,
                                             NULL,
                                             WorkContext->Parameters.WriteAndX.MdlAddress,
                                             IRP_MJ_WRITE,
                                             &PreviousWriteOffset,
                                             writeLength
                                            );

                    if( !NT_SUCCESS( mdlStatus ) ) {
                        SrvLogServiceFailure( SRV_SVC_MDL_COMPLETE, mdlStatus );
                        if( NT_SUCCESS( status ) ) {
                            WorkContext->Parameters.WriteAndX.FinalStatus = status = mdlStatus;
                        }
                    }
                }

                //
                // We have disposed of this MDL, get it out of our structures!
                //
                WorkContext->Parameters.WriteAndX.MdlAddress = NULL;
                irp->MdlAddress = NULL;
            }

            //
            // If we have more than 1 buffer's worth remaing, and if the filesystem
            // supports MDL writes, then let's do MDL writes
            //
            if( NT_SUCCESS( status ) &&
                (WorkContext->Parameters.WriteAndX.RemainingWriteLength >
                WorkContext->Parameters.WriteAndX.BufferLength)  &&
                (lfcb->FileObject->Flags & FO_CACHE_SUPPORTED) ) {

                LARGE_INTEGER offset;
                ULONG remainingLength;

                irp->IoStatus.Information = 0;
                irp->UserBuffer = NULL;
                irp->MdlAddress = NULL;

                //
                // Figure out how big we want this MDL attempt to be.  We could
                //  map the whole thing in, but we don't want any single client request
                //  to lock down too much of the cache.
                //
                WorkContext->Parameters.WriteAndX.CurrentWriteLength = MIN (
                           WorkContext->Parameters.WriteAndX.RemainingWriteLength,
                           SrvMaxWriteChunk
                           );

                if( lfcb->PrepareMdlWrite(
                        lfcb->FileObject,
                        &WorkContext->Parameters.WriteAndX.Offset,
                        WorkContext->Parameters.WriteAndX.CurrentWriteLength,
                        WorkContext->Parameters.WriteAndX.Key,
                        &irp->MdlAddress,
                        &irp->IoStatus,
                        lfcb->DeviceObject
                        ) && irp->MdlAddress != NULL ) {

                    //
                    // The fast path worked!
                    //
                    SrvFsdRestartPrepareMdlWriteAndX( WorkContext );
                    goto Cleanup;
                }

                //
                // The fast path failed, build the write request.  The fast path
                //  may have partially succeeded, returning a partial MDL chain.
                //  We need to adjust our write request to account for that.
                //
                offset.QuadPart = WorkContext->Parameters.WriteAndX.Offset.QuadPart;

                //
                // If we are not just appending, adjust the offset
                //
                if( offset.QuadPart != 0xFFFFFFFFFFFFFFFF ) {
                    offset.QuadPart += irp->IoStatus.Information;
                }

                remainingLength = WorkContext->Parameters.WriteAndX.CurrentWriteLength -
                                  (ULONG)irp->IoStatus.Information;

                SrvBuildReadOrWriteRequest(
                        irp,                                // input IRP address
                        lfcb->FileObject,                   // target file object address
                        WorkContext,                        // context
                        IRP_MJ_WRITE,                       // major function code
                        IRP_MN_MDL,                         // minor function code
                        NULL,                               // buffer address (ignored)
                        remainingLength,
                        irp->MdlAddress,
                        offset,
                        WorkContext->Parameters.WriteAndX.Key
                        );

                WorkContext->bAlreadyTrace = TRUE;
                WorkContext->FsdRestartRoutine = SrvFsdRestartPrepareMdlWriteAndX;

                (VOID)IoCallDriver( lfcb->DeviceObject, WorkContext->Irp );
                goto Cleanup;
            }
        }

        //
        // We aren't doing MDL operations, so read the data from the transport into
        //  the SMB buffer.
        //
        WorkContext->Parameters.WriteAndX.CurrentWriteLength = MIN(
            WorkContext->Parameters.WriteAndX.RemainingWriteLength,
            WorkContext->Parameters.WriteAndX.BufferLength
            );

        //
        // Fill in the IRP for the receive
        //
        irp->Tail.Overlay.OriginalFileObject = NULL;
        irp->Tail.Overlay.Thread = WorkContext->CurrentWorkQueue->IrpThread;
        DEBUG irp->RequestorMode = KernelMode;

        //
        // Get a pointer to the next stack location.  This one is used to
        // hold the parameters for the device I/O control request.
        //
        irpSp = IoGetNextIrpStackLocation( irp );

        //
        // Set up the completion routine
        //
        IoSetCompletionRoutine(
            irp,
            SrvFsdIoCompletionRoutine,
            WorkContext,
            TRUE,
            TRUE,
            TRUE
            );

        SET_OPERATION_START_TIME( &WorkContext );

        WorkContext->FsdRestartRoutine = SrvQueueWorkToFspAtDpcLevel;
        WorkContext->FspRestartRoutine = RestartLargeWriteAndX;

        irpSp->MajorFunction = IRP_MJ_INTERNAL_DEVICE_CONTROL;
        irpSp->MinorFunction = (UCHAR)TDI_RECEIVE;
        irpSp->FileObject = WorkContext->Connection->FileObject;
        irpSp->DeviceObject = WorkContext->Connection->DeviceObject;
        irpSp->Flags = 0;

        parameters = (PTDI_REQUEST_KERNEL_RECEIVE)&irpSp->Parameters;
        parameters->ReceiveLength = WorkContext->Parameters.WriteAndX.CurrentWriteLength;
        parameters->ReceiveFlags = 0;

        //
        // Set the buffer's partial mdl to point just after the header for this
        // WriteAndX SMB.  We need to preserve the header to make it easier to send
        // back the response.
        //

        IoBuildPartialMdl(
            WorkContext->RequestBuffer->Mdl,
            WorkContext->RequestBuffer->PartialMdl,
            WorkContext->Parameters.WriteAndX.WriteAddress,
            WorkContext->Parameters.WriteAndX.CurrentWriteLength
        );

        irp->MdlAddress = WorkContext->RequestBuffer->PartialMdl;
        irp->AssociatedIrp.SystemBuffer = NULL;
        irp->Flags = (ULONG)IRP_BUFFERED_IO;        // ???

        (VOID)IoCallDriver( irpSp->DeviceObject, irp );

        goto Cleanup;
    }

    //
    // We have no more data to write to the file.  Clean up
    //  and send a response to the client
    //

    //
    // If we are working on a large write using MDLs,
    //  then we need to clean up the MDL
    //
    if( WorkContext->LargeIndication &&
        WorkContext->Parameters.WriteAndX.MdlAddress ) {

        PLFCB lfcb = rfcb->Lfcb;
        NTSTATUS mdlStatus;

        ASSERT( KeGetCurrentIrql() < DISPATCH_LEVEL );

        irp->MdlAddress = WorkContext->Parameters.WriteAndX.MdlAddress;
        irp->IoStatus.Information = writeLength;

        //
        // Tell the filesystem that we're done with it
        //
        if( lfcb->MdlWriteComplete == NULL ||

            lfcb->MdlWriteComplete( lfcb->FileObject,
                                    &WorkContext->Parameters.WriteAndX.Offset,
                                    WorkContext->Parameters.WriteAndX.MdlAddress,
                                    lfcb->DeviceObject
                                  ) == FALSE ) {

                mdlStatus = SrvIssueMdlCompleteRequest( WorkContext, NULL,
                                                 WorkContext->Parameters.WriteAndX.MdlAddress,
                                                 IRP_MJ_WRITE,
                                                 &WorkContext->Parameters.WriteAndX.Offset,
                                                 writeLength
                    );

            if( !NT_SUCCESS( mdlStatus ) ) {
                SrvLogServiceFailure( SRV_SVC_MDL_COMPLETE, mdlStatus );
                if( NT_SUCCESS( status ) ) {
                    status = mdlStatus;
                }
            }
        }

        irp->MdlAddress = NULL;
    }

    //
    // Build the response message.
    //
    requestedWriteLength = SmbGetUshort( &request->DataLength );

    if( WorkContext->LargeIndication ) {

        requestedWriteLength |= (SmbGetUshort( &ntRequest->DataLengthHigh ) << 16);

        writeLength = requestedWriteLength -
                      WorkContext->Parameters.WriteAndX.RemainingWriteLength;
    }

    SmbPutUlong( &response->Reserved, 0 );
    SmbPutUshort( &response->CountHigh, (USHORT)(writeLength >> 16) );

    response->AndXCommand = nextCommand;
    response->AndXReserved = 0;
    SmbPutUshort(
        &response->AndXOffset,
        GET_ANDX_OFFSET(
            WorkContext->ResponseHeader,
            WorkContext->ResponseParameters,
            RESP_WRITE_ANDX,
            0
            )
        );

    response->WordCount = 6;

    if ( rfcb->ShareType == ShareTypeDisk ||
        WorkContext->Parameters.Transaction == NULL ) {

        SmbPutUshort( &response->Count, (USHORT)writeLength );

    } else {

        SmbPutUshort( &response->Count, (USHORT)requestedWriteLength );
    }

    SmbPutUshort( &response->Remaining, (USHORT)-1 );
    SmbPutUshort( &response->ByteCount, 0 );

    WorkContext->ResponseParameters = (PCHAR)WorkContext->ResponseHeader +
                                        SmbGetUshort( &response->AndXOffset );

    WorkContext->RequestParameters = (PUCHAR)WorkContext->RequestHeader + reqAndXOffset;

    IF_STRESS() {
        // If this was a paging write that failed, log an error
        PNT_SMB_HEADER pHeader = (PNT_SMB_HEADER)WorkContext->RequestHeader;
        if( !NT_SUCCESS(pHeader->Status.NtStatus) && (pHeader->Flags2 & SMB_FLAGS2_PAGING_IO) )
        {
            KdPrint(("Paging Write failure from %z (%x)\n", (PCSTRING)&WorkContext->Connection->OemClientMachineNameString, pHeader->Status.NtStatus ));
        }
    }

    //
    // If this was a raw mode write, queue the work to the FSP for
    // completion.  The FSP routine will handling dispatching of the
    // AndX command.
    //

    if ( rfcb->ShareType != ShareTypeDisk &&
        WorkContext->Parameters.Transaction != NULL ) {

        WorkContext->FspRestartRoutine = SrvRestartWriteAndXRaw;
        SrvQueueWorkToFsp( WorkContext );
        goto Cleanup;
    }

    if( nextCommand == SMB_COM_NO_ANDX_COMMAND ) {
        //
        // No more commands.  Send the response.
        //

        SrvFsdSendResponse( WorkContext );
        goto Cleanup;
    }

    //
    // Make sure the AndX command is still within the received SMB
    //
    if( (PCHAR)WorkContext->RequestHeader + reqAndXOffset >= END_OF_REQUEST_SMB( WorkContext ) ) {

        IF_DEBUG(SMB_ERRORS) {
            KdPrint(( "SrvFsdRestartWriteAndX: Illegal followon offset: %u\n", reqAndXOffset ));
        }

        if ( KeGetCurrentIrql() >= DISPATCH_LEVEL ) {
            WorkContext->Irp->IoStatus.Status = STATUS_INVALID_SMB;
            WorkContext->FspRestartRoutine = SrvBuildAndSendErrorResponse;
            WorkContext->FsdRestartRoutine = SrvFsdRestartSmbComplete; // after response
            QUEUE_WORK_TO_FSP( WorkContext );
        } else {
            SrvSetSmbError( WorkContext, STATUS_INVALID_SMB );
            SrvFsdSendResponse( WorkContext );
        }
        goto Cleanup;
    }

    //
    // Test for a legal followon command, and dispatch as appropriate.
    // Close is handled specially.
    //

    switch ( nextCommand ) {

    case SMB_COM_READ:
    case SMB_COM_READ_ANDX:
    case SMB_COM_LOCK_AND_READ:
    case SMB_COM_WRITE_ANDX:

        //
        // Queue the work item back to the FSP for further processing.
        //

        WorkContext->FspRestartRoutine = SrvRestartSmbReceived;
        SrvQueueWorkToFsp( WorkContext );

        break;

    case SMB_COM_CLOSE:

        //
        // Save the last write time, to correctly set it.  Call
        // SrvRestartChainedClose to close the file and send the response.
        //

        closeRequest = (PREQ_CLOSE)
            ((PUCHAR)WorkContext->RequestHeader + reqAndXOffset);

        //
        // Make sure we stay within the received SMB
        //
        if( (PCHAR)closeRequest + FIELD_OFFSET( REQ_CLOSE, ByteCount)
            <= END_OF_REQUEST_SMB( WorkContext ) ) {

            WorkContext->Parameters.LastWriteTime =
                closeRequest->LastWriteTimeInSeconds;

            SrvRestartChainedClose( WorkContext );
            break;
        }

        /* Falls Through! */

    default:                            // Illegal followon command

        IF_DEBUG(SMB_ERRORS) {
            SrvPrint1( "SrvFsdRestartWriteAndX: Illegal followon "
                        "command: 0x%lx\n", nextCommand );
        }

        if ( KeGetCurrentIrql() >= DISPATCH_LEVEL ) {
            WorkContext->Irp->IoStatus.Status = STATUS_INVALID_SMB;
            WorkContext->FspRestartRoutine = SrvBuildAndSendErrorResponse;
            WorkContext->FsdRestartRoutine = SrvFsdRestartSmbComplete; // after response
            QUEUE_WORK_TO_FSP( WorkContext );
        } else {
            SrvSetSmbError( WorkContext, STATUS_INVALID_SMB );
            SrvFsdSendResponse( WorkContext );
        }

    }

    IF_DEBUG(TRACE2) SrvPrint0( "SrvFsdRestartWriteAndX complete\n" );

Cleanup:
    if (bNeedTrace) {
        SrvWmiEndContext(WorkContext);
    }
    return;

} // SrvFsdRestartWriteAndX

#if SRVCATCH
BYTE CatchPrototype[] = ";UUIDREF=";
VOID
SrvUpdateCatchBuffer (
    IN PWORK_CONTEXT WorkContext,
    IN OUT PBYTE Buffer,
    IN DWORD BufferLength
    )
{
    BYTE idBuffer[ 100 ];
    PBYTE p, ep = idBuffer;
    USHORT bytesRemaining = sizeof( idBuffer );
    UNICODE_STRING userName, domainName;
    OEM_STRING oemString;
    ULONG requiredLength;

    if( BufferLength <= sizeof( CatchPrototype ) ) {
        return;
    }

    if( WorkContext->Session == 0 ) {
        SrvVerifyUid( WorkContext, SmbGetAlignedUshort( &WorkContext->RequestHeader->Uid ) );
    }

    if( WorkContext->Session &&
        NT_SUCCESS( SrvGetUserAndDomainName( WorkContext->Session, &userName, &domainName ) ) ) {

        if( userName.Length && NT_SUCCESS( RtlUnicodeStringToOemString( &oemString, &userName, TRUE ) ) ) {
            if( bytesRemaining >= oemString.Length + 1 ) {
                RtlCopyMemory( ep, oemString.Buffer, oemString.Length );
                ep += oemString.Length;
                *ep++ = '\\';
                bytesRemaining -= (oemString.Length + 1);
                RtlFreeOemString( &oemString );
            }
        }

        if( domainName.Length && NT_SUCCESS( RtlUnicodeStringToOemString( &oemString, &domainName, TRUE ) ) ) {
            if( bytesRemaining >= oemString.Length ) {
                RtlCopyMemory( ep, oemString.Buffer, oemString.Length );
                ep += oemString.Length;
                bytesRemaining -= oemString.Length;
                RtlFreeOemString( &oemString );
            }
        }

        SrvReleaseUserAndDomainName( WorkContext->Session, &userName, &domainName );
    }

    if( WorkContext->Connection && bytesRemaining ) {

        oemString = WorkContext->Connection->OemClientMachineNameString;

        if( oemString.Length && oemString.Length < bytesRemaining + 1 ) {
            *ep++ = ' ';
            RtlCopyMemory( ep, oemString.Buffer, oemString.Length );
            ep += oemString.Length;
            bytesRemaining -= oemString.Length;
        }
    }

    //
    // Insert the CatchPrototype into the output buffer
    //
    if( WorkContext->Rfcb->SrvCatch == 1 )
    {
        RtlCopyMemory( Buffer, CatchPrototype, sizeof( CatchPrototype )-1 );
        Buffer += sizeof( CatchPrototype )-1;
        BufferLength -= (sizeof( CatchPrototype ) - 1);

        //
        // Encode the information
        //
        for( p = idBuffer; BufferLength >= 3 && p < ep; p++, BufferLength =- 2 ) {
            *Buffer++ = SrvHexChars[ ((*p) >> 4) & 0xf ];
            *Buffer++ = SrvHexChars[ (*p) & 0xf ];
        }

        if( BufferLength >= 3 ) {
            *Buffer++ = '\r';
            *Buffer++ = '\n';
            *Buffer++ = ';';
        }
    }
    else if( WorkContext->Rfcb->SrvCatch == 2 )
    {
        PBYTE InnerBuffer;
        ULONG Offset;

        Offset = SrvFindCatchOffset( Buffer, BufferLength );
        if( Offset )
        {
            InnerBuffer = Buffer + Offset;
            BufferLength = 1020;

            RtlCopyMemory( InnerBuffer, CatchPrototype, sizeof( CatchPrototype )-1 );
            InnerBuffer += sizeof( CatchPrototype )-1;
            BufferLength -= (sizeof( CatchPrototype ) - 1);

            //
            // Encode the information
            //
            for( p = idBuffer; BufferLength >= 3 && p < ep; p++, BufferLength =- 2 ) {
                *InnerBuffer++ = SrvHexChars[ ((*p) >> 4) & 0xf ];
                *InnerBuffer++ = SrvHexChars[ (*p) & 0xf ];
            }

            if( BufferLength >= 3 ) {
                *InnerBuffer++ = '\r';
                *InnerBuffer++ = '\n';
                *InnerBuffer++ = ';';
            }

            SrvCorrectCatchBuffer( Buffer, Offset );
        }
    }
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\srv\info.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    info.c

Abstract:

    This module contains various routines for obtaining information such as
    times, dates, etc. that is to be returned by SMBs and for converting
    information that is given by request SMBs.

Author:

    David Treadwell (davidtr) 30-Nov-1989

Revision History:

--*/

#include "precomp.h"
#include "info.tmh"
#pragma hdrstop

#define BugCheckFileId SRV_FILE_INFO

NTSTATUS
BruteForceRewind(
    IN HANDLE DirectoryHandle,
    IN PVOID Buffer,
    IN ULONG BufferLength,
    IN PUNICODE_STRING FileName,
    IN FILE_INFORMATION_CLASS FileInformationClass,
    IN OUT PFILE_DIRECTORY_INFORMATION *CurrentEntry
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text( PAGE, SrvCloseQueryDirectory )
#pragma alloc_text( PAGE, SrvQueryInformationFile )
#pragma alloc_text( PAGE, SrvQueryInformationFileAbbreviated )
#pragma alloc_text( PAGE, SrvQueryNtInformationFile )
#pragma alloc_text( PAGE, SrvQueryDirectoryFile )
#pragma alloc_text( PAGE, BruteForceRewind )
#pragma alloc_text( PAGE, SrvQueryEaFile )
#pragma alloc_text( PAGE, SrvTimeToDosTime )
#pragma alloc_text( PAGE, SrvDosTimeToTime )
#pragma alloc_text( PAGE, SrvGetOs2TimeZone )
#pragma alloc_text( PAGE, SrvQueryBasicAndStandardInformation )
#pragma alloc_text( PAGE, SrvQueryNetworkOpenInformation )
#endif


VOID
SrvCloseQueryDirectory (
    IN PSRV_DIRECTORY_INFORMATION DirectoryInformation
    )

/*++

Routine Description:

    This routine cleans up after a directory search was aborted before
    SrvQueryDirectoryFile is done.  It closes the directory handle.

Arguments:

    DirectoryInformation - pointer to the buffer that is being used for
        SrvQueryDirectoryFile.

Return Value:

    None.

--*/

{
    PAGED_CODE( );

    //
    // Close the directory handle.
    //

    if ( DirectoryInformation->DirectoryHandle != NULL ) {
        SRVDBG_RELEASE_HANDLE( DirectoryInformation->DirectoryHandle, "DID", 8, DirectoryInformation );
        SrvNtClose( DirectoryInformation->DirectoryHandle, TRUE );
    }

    DirectoryInformation->DirectoryHandle = NULL;

} // SrvCloseQueryDirectory



NTSTATUS
SrvQueryInformationFile (
    IN HANDLE FileHandle,
    IN PFILE_OBJECT FileObject OPTIONAL,
    OUT PSRV_FILE_INFORMATION SrvFileInformation,
    IN SHARE_TYPE ShareType,
    IN BOOLEAN QueryEaSize
    )

/*++

Routine Description:

    This routine makes calls to NtQueryInformationFile to get information
    about a file opened by the server.

Arguments:

    FileHandle - a handle of the file to get information about.

    FileInformation - pointer to a structure in which to store the
        information.

    ShareType - The file type.  It will be disk, comm, print, pipe
                or (-1) for don't care.

    QueryEaSize - Try if EA size info is requested.

Return Value:

    A status indicating success or failure of the operation.

--*/

{
    SRV_NETWORK_OPEN_INFORMATION srvNetworkOpenInformation;
    FILE_PIPE_LOCAL_INFORMATION pipeLocalInformation;
    NTSTATUS status;

    PAGED_CODE( );

    //
    // Most query operations will fail on comm devices and print shares.
    // If this is a disk file, etc.  do the queries.  If it is a comm
    // device, fake it with defaults.
    //

    if ( ShareType != ShareTypePrint )
    {

        status = SrvQueryNetworkOpenInformation( FileHandle,
                                                 FileObject,
                                                 &srvNetworkOpenInformation,
                                                 QueryEaSize
                                                );

        if ( !NT_SUCCESS(status) ) {
            INTERNAL_ERROR(
                ERROR_LEVEL_UNEXPECTED,
                "SrvQueryInformationFile: NtQueryInformationFile "
                    " failed: %X",
                status,
                NULL
                );

            SrvLogServiceFailure( SRV_SVC_NT_QUERY_INFO_FILE, status );
            return status;
        }

    } else {
        //
        // Use defaults for comm and print shares.
        //

        RtlZeroMemory( &srvNetworkOpenInformation, sizeof( srvNetworkOpenInformation ) );
    }

    if ( ShareType == ShareTypePipe ) {

        FILE_PIPE_INFORMATION pipeInformation;
        IO_STATUS_BLOCK ioStatusBlock;
        USHORT pipeHandleState;

        status = NtQueryInformationFile(
                     FileHandle,
                     &ioStatusBlock,
                     (PVOID)&pipeInformation,
                     sizeof(pipeInformation),
                     FilePipeInformation
                     );

        if ( !NT_SUCCESS(status) ) {
            INTERNAL_ERROR(
                ERROR_LEVEL_UNEXPECTED,
                "SrvQueryInformationFile: NtQueryInformationFile "
                    "(pipe information) failed: %X",
                 status,
                 NULL
                 );

            SrvLogServiceFailure( SRV_SVC_NT_QUERY_INFO_FILE, status );
            return status;
        }

        status = NtQueryInformationFile(
                     FileHandle,
                     &ioStatusBlock,
                     (PVOID)&pipeLocalInformation,
                     sizeof(pipeLocalInformation),
                     FilePipeLocalInformation
                     );

        if ( !NT_SUCCESS(status) ) {
            INTERNAL_ERROR(
                ERROR_LEVEL_UNEXPECTED,
                "SrvQueryInformationFile: NtQueryInformationFile "
                    "(pipe local information) failed: %X",
                 status,
                 NULL
                 );

            SrvLogServiceFailure( SRV_SVC_NT_QUERY_INFO_FILE, status );
            return status;
        }

        //
        // Fill in the handle state information in SMB format
        //

        pipeHandleState = (USHORT)pipeInformation.CompletionMode
                            << PIPE_COMPLETION_MODE_BITS;
        pipeHandleState |= (USHORT)pipeLocalInformation.NamedPipeEnd
                            << PIPE_PIPE_END_BITS;
        pipeHandleState |= (USHORT)pipeLocalInformation.NamedPipeType
                            << PIPE_PIPE_TYPE_BITS;
        pipeHandleState |= (USHORT)pipeInformation.ReadMode
                            << PIPE_READ_MODE_BITS;
        pipeHandleState |= (USHORT)(pipeLocalInformation.MaximumInstances &
                                    0xFF)
                            << PIPE_MAXIMUM_INSTANCES_BITS;

        SrvFileInformation->HandleState = pipeHandleState;
    } else {

        SrvFileInformation->HandleState = 0;

    }


    //
    // Set up creation time fields.
    //

    {
        LARGE_INTEGER newTime;

        ExSystemTimeToLocalTime(
                        &srvNetworkOpenInformation.LastWriteTime,
                        &newTime
                        );


        //
        // Make sure we round up to two seconds.
        //

        newTime.QuadPart += AlmostTwoSeconds;

        if ( !RtlTimeToSecondsSince1970(
                &newTime,
                &SrvFileInformation->LastWriteTimeInSeconds
                ) ) {

            SrvFileInformation->LastWriteTimeInSeconds = 0;

        } else {

            //
            // Mask off the low bit so we can be consistent with LastWriteTime.
            // (We need to round up to 2 seconds)
            //

            SrvFileInformation->LastWriteTimeInSeconds &= ~1;
        }

    }

    SrvTimeToDosTime(
        &srvNetworkOpenInformation.LastWriteTime,
        &SrvFileInformation->LastWriteDate,
        &SrvFileInformation->LastWriteTime
        );

    if( srvNetworkOpenInformation.CreationTime.QuadPart == srvNetworkOpenInformation.LastWriteTime.QuadPart ) {
        SrvFileInformation->CreationDate = SrvFileInformation->LastWriteDate;
        SrvFileInformation->CreationTime = SrvFileInformation->LastWriteTime;
    } else {
        SrvTimeToDosTime(
            &srvNetworkOpenInformation.CreationTime,
            &SrvFileInformation->CreationDate,
            &SrvFileInformation->CreationTime
            );
    }

    if( srvNetworkOpenInformation.LastAccessTime.QuadPart == srvNetworkOpenInformation.LastWriteTime.QuadPart ) {
        SrvFileInformation->LastAccessDate = SrvFileInformation->LastWriteDate;
        SrvFileInformation->LastAccessTime = SrvFileInformation->LastWriteTime;

    } else {

        SrvTimeToDosTime(
            &srvNetworkOpenInformation.LastAccessTime,
            &SrvFileInformation->LastAccessDate,
            &SrvFileInformation->LastAccessTime
            );
    }

    //
    // Set File Attributes field of structure.
    //

    SRV_NT_ATTRIBUTES_TO_SMB(
        srvNetworkOpenInformation.FileAttributes,
        srvNetworkOpenInformation.FileAttributes & FILE_ATTRIBUTE_DIRECTORY,
        &SrvFileInformation->Attributes
        );

    //
    // Set up allocation and data sizes.
    //
    // *** Note the assumption that the high part of the 64-bit
    //     allocation and EOF size is zero.  If it's not (i.e., the file
    //     is bigger than 4GB), then we're out of luck, because the SMB
    //     protocol can't express that.
    //

    SrvFileInformation->AllocationSize.QuadPart =
                            srvNetworkOpenInformation.AllocationSize.QuadPart;

    SrvFileInformation->DataSize.QuadPart =
                            srvNetworkOpenInformation.EndOfFile.QuadPart;


    //
    // Set the file device type.
    //

    switch( ShareType ) {

    case ShareTypeDisk:

        SrvFileInformation->Type = FileTypeDisk;
        break;

    case ShareTypePipe:

        if (pipeLocalInformation.NamedPipeType == FILE_PIPE_MESSAGE_TYPE) {
            SrvFileInformation->Type = FileTypeMessageModePipe;
        } else {
            SrvFileInformation->Type = FileTypeByteModePipe;
        }
        break;

    case ShareTypePrint:

        SrvFileInformation->Type = FileTypePrinter;
        break;

    default:

        SrvFileInformation->Type = FileTypeUnknown;

    }

    //
    // If the caller wants to know the length of the file's extended
    // attributes, obtain them now.
    //

    if ( QueryEaSize ) {

        //
        // If the file has no EAs, return an FEA size = 4 (that's what OS/2
        // does--it accounts for the size of the cbList field of an
        // FEALIST).
        //

        if ( srvNetworkOpenInformation.EaSize == 0 ) {
            SrvFileInformation->EaSize = 4;
        } else {
            SrvFileInformation->EaSize = srvNetworkOpenInformation.EaSize;
        }

    }

    return STATUS_SUCCESS;

} // SrvQueryInformationFile

NTSTATUS
SrvQueryInformationFileAbbreviated(
    IN HANDLE FileHandle,
    IN PFILE_OBJECT FileObject OPTIONAL,
    OUT PSRV_FILE_INFORMATION_ABBREVIATED SrvFileInformation,
    IN BOOLEAN AdditionalInfo,
    IN SHARE_TYPE ShareType
    )

/*++

Routine Description:

    This routine makes calls to NtQueryInformationFile to get information
    about a file opened by the server.

Arguments:

    FileHandle - a handle of the file to get information about.

    FileInformation - pointer to a structure in which to store the
        information.

    ShareType - The file type.  It will be disk, comm, print, pipe
                or (-1) for don't care.

    QueryEaSize - Try if EA size info is requested.

Return Value:

    A status indicating success or failure of the operation.

--*/

{

    IO_STATUS_BLOCK ioStatusBlock;
    SRV_NETWORK_OPEN_INFORMATION srvNetworkOpenInformation;
    NTSTATUS status;
    LARGE_INTEGER newTime;

    PAGED_CODE( );

    //
    // Most query operations will fail on comm devices and print shares.
    // If this is a disk file, etc.  do the queries.  If it is a comm
    // device, fake it with defaults.
    //

    if ( ShareType != ShareTypePrint ) {

        status = SrvQueryNetworkOpenInformation(
                                                FileHandle,
                                                FileObject,
                                                &srvNetworkOpenInformation,
                                                FALSE
                                                );

        if ( !NT_SUCCESS(status) ) {
            INTERNAL_ERROR(
                ERROR_LEVEL_UNEXPECTED,
                "SrvQueryInformationFile: NtQueryInformationFile "
                    " failed: %X",
                status,
                NULL
                );

            SrvLogServiceFailure( SRV_SVC_NT_QUERY_INFO_FILE, status );
            return status;
        }

    } else {

        //
        // Use defaults for comm and print shares.
        //

        RtlZeroMemory( &srvNetworkOpenInformation, sizeof( srvNetworkOpenInformation ) );
    }

    //
    // Set up creation time fields.
    //
    ExSystemTimeToLocalTime(
                    &srvNetworkOpenInformation.LastWriteTime,
                    &newTime
                    );

    //
    // Make sure we round up to two seconds.
    //

    newTime.QuadPart += AlmostTwoSeconds;

    if ( !RtlTimeToSecondsSince1970(
            &newTime,
            &SrvFileInformation->LastWriteTimeInSeconds
            ) ) {

        SrvFileInformation->LastWriteTimeInSeconds = 0;

    } else {

        //
        // Mask off the low bit so we can be consistent with LastWriteTime.
        // (We need to round up to 2 seconds)
            //

            SrvFileInformation->LastWriteTimeInSeconds &= ~1;
        }

        //
        // Set File Attributes field of structure.
        //

        SRV_NT_ATTRIBUTES_TO_SMB(
            srvNetworkOpenInformation.FileAttributes,
            srvNetworkOpenInformation.FileAttributes & FILE_ATTRIBUTE_DIRECTORY,
            &SrvFileInformation->Attributes
            );

        SrvFileInformation->DataSize.QuadPart =
                            srvNetworkOpenInformation.EndOfFile.QuadPart;

        //
        // Set the file device type.
        //

        switch( ShareType ) {

        case ShareTypeDisk: {

            SrvFileInformation->Type = FileTypeDisk;
            SrvFileInformation->HandleState = 0;

            if( AdditionalInfo ) {

                union {
                    FILE_EA_INFORMATION eaInformation;
                    FILE_STREAM_INFORMATION streamInformation;
                    FILE_ATTRIBUTE_TAG_INFORMATION tagInformation;
                    ULONG buffer[ (sizeof( FILE_STREAM_INFORMATION ) + 14) / sizeof(ULONG) ];
                } u;

                //
                // Find out if this file has EAs
                //
                status = NtQueryInformationFile(
                            FileHandle,
                            &ioStatusBlock,
                            (PVOID)&u.eaInformation,
                            sizeof( u.eaInformation ),
                            FileEaInformation
                         );

                if( !NT_SUCCESS( status ) || u.eaInformation.EaSize == 0 ) {
                    SrvFileInformation->HandleState |= SMB_FSF_NO_EAS;
                }

                //
                // Find out if this file has substreams.
                //
                RtlZeroMemory( &u, sizeof(u) );
                status = NtQueryInformationFile(
                            FileHandle,
                            &ioStatusBlock,
                            (PVOID)&u.streamInformation,
                            sizeof( u.streamInformation ),
                            FileStreamInformation
                        );


                //
                // If the filesystem does not support this call, then there are no substreams.  Or
                //  If the filesystem supports the call but returned exactly no name or returned "::$DATA"
                //  then there are no substreams.
                //
                if( status == STATUS_INVALID_PARAMETER ||
                    status == STATUS_NOT_IMPLEMENTED ||

                    (status == STATUS_SUCCESS &&
                      (u.streamInformation.StreamNameLength == 0 ||
                      (u.streamInformation.StreamNameLength == 14 ))
                    )

                  ) {
                    SrvFileInformation->HandleState |= SMB_FSF_NO_SUBSTREAMS;
                }

                //
                // Find out if this file is a reparse point
                //
                status = NtQueryInformationFile(
                            FileHandle,
                            &ioStatusBlock,
                            (PVOID)&u.tagInformation,
                            sizeof( u.tagInformation ),
                            FileAttributeTagInformation
                        );

                if( !NT_SUCCESS( status ) ||
                    u.tagInformation.ReparseTag == IO_REPARSE_TAG_RESERVED_ZERO ) {
                    SrvFileInformation->HandleState |= SMB_FSF_NO_REPARSETAG;
                }
            }
            break;

        } case ShareTypePipe: {

            FILE_PIPE_INFORMATION pipeInformation;
            FILE_PIPE_LOCAL_INFORMATION pipeLocalInformation;
        USHORT pipeHandleState;

        status = NtQueryInformationFile(
                     FileHandle,
                     &ioStatusBlock,
                     (PVOID)&pipeInformation,
                     sizeof(pipeInformation),
                     FilePipeInformation
                     );

        if ( !NT_SUCCESS(status) ) {
            INTERNAL_ERROR(
                ERROR_LEVEL_UNEXPECTED,
                "SrvQueryInformationFile: NtQueryInformationFile "
                    "(pipe information) failed: %X",
                 status,
                 NULL
                 );

            SrvLogServiceFailure( SRV_SVC_NT_QUERY_INFO_FILE, status );
            return status;
        }

        status = NtQueryInformationFile(
                     FileHandle,
                     &ioStatusBlock,
                     (PVOID)&pipeLocalInformation,
                     sizeof(pipeLocalInformation),
                     FilePipeLocalInformation
                     );

        if ( !NT_SUCCESS(status) ) {
            INTERNAL_ERROR(
                ERROR_LEVEL_UNEXPECTED,
                "SrvQueryInformationFile: NtQueryInformationFile "
                    "(pipe local information) failed: %X",
                 status,
                 NULL
                 );

            SrvLogServiceFailure( SRV_SVC_NT_QUERY_INFO_FILE, status );
            return status;
        }

        //
        // Fill in the handle state information in SMB format
        //

        pipeHandleState = (USHORT)pipeInformation.CompletionMode
                            << PIPE_COMPLETION_MODE_BITS;
        pipeHandleState |= (USHORT)pipeLocalInformation.NamedPipeEnd
                            << PIPE_PIPE_END_BITS;
        pipeHandleState |= (USHORT)pipeLocalInformation.NamedPipeType
                            << PIPE_PIPE_TYPE_BITS;
        pipeHandleState |= (USHORT)pipeInformation.ReadMode
                            << PIPE_READ_MODE_BITS;
        pipeHandleState |= (USHORT)(pipeLocalInformation.MaximumInstances &
                                    0xFF)
                            << PIPE_MAXIMUM_INSTANCES_BITS;

        SrvFileInformation->HandleState = pipeHandleState;

        if (pipeLocalInformation.NamedPipeType == FILE_PIPE_MESSAGE_TYPE) {
            SrvFileInformation->Type = FileTypeMessageModePipe;
        } else {
            SrvFileInformation->Type = FileTypeByteModePipe;
        }
        break;

    } case ShareTypePrint: {

        SrvFileInformation->Type = FileTypePrinter;
        break;

    } default:

        SrvFileInformation->Type = FileTypeUnknown;

    }

    return STATUS_SUCCESS;

} // SrvQueryInformationFileAbbreviated

NTSTATUS
SrvQueryNtInformationFile (
    IN HANDLE FileHandle,
    IN PFILE_OBJECT FileObject OPTIONAL,
    IN SHARE_TYPE ShareType,
    IN BOOLEAN AdditionalInfo,
    IN OUT PSRV_NT_FILE_INFORMATION SrvFileInformation
    )

/*++

Routine Description:

    This routine makes calls to NtQueryInformationFile to get information
    about a file opened by the server.

Arguments:

    FileHandle - a handle of the file to get information about.

    FileInformation - pointer to a structure in which to store the
        information.

Return Value:

    A status indicating success or failure of the operation.

--*/

{

    IO_STATUS_BLOCK ioStatusBlock;
    FILE_PIPE_INFORMATION pipeInformation;
    FILE_PIPE_LOCAL_INFORMATION pipeLocalInformation;
    USHORT pipeHandleState;
    NTSTATUS status;

    PAGED_CODE( );

    status = SrvQueryNetworkOpenInformation( FileHandle,
                                             FileObject,
                                             &SrvFileInformation->NwOpenInfo,
                                             FALSE
                                             );

    if ( !NT_SUCCESS(status) ) {
        if ( ShareType != ShareTypePipe ) {

            INTERNAL_ERROR(
                ERROR_LEVEL_UNEXPECTED,
                "SrvQueryNtInformationFile: NtQueryInformationFile "
                    " failed: %X",
                status,
                NULL
                );

            SrvLogServiceFailure( SRV_SVC_NT_QUERY_INFO_FILE, status );
        }
        return status;
    }

    if ( ShareType == ShareTypePipe ) {

        status = NtQueryInformationFile(
                     FileHandle,
                     &ioStatusBlock,
                     (PVOID)&pipeInformation,
                     sizeof(pipeInformation),
                     FilePipeInformation
                     );

        if ( !NT_SUCCESS(status) ) {
            INTERNAL_ERROR(
                ERROR_LEVEL_UNEXPECTED,
                "SrvNtQueryInformationFile: NtQueryInformationFile "
                    "(pipe information) failed: %X",
                 status,
                 NULL
                 );
            return status;
        }

        status = NtQueryInformationFile(
                     FileHandle,
                     &ioStatusBlock,
                     (PVOID)&pipeLocalInformation,
                     sizeof(pipeLocalInformation),
                     FilePipeLocalInformation
                     );

        if ( !NT_SUCCESS(status) ) {
            INTERNAL_ERROR(
                ERROR_LEVEL_UNEXPECTED,
                "SrvNtQueryInformationFile: NtQueryInformationFile "
                    "(pipe local information) failed: %X",
                 status,
                 NULL
                 );
            return status;
        }

        //
        // Fill in the handle state information in SMB format
        //

        pipeHandleState = (USHORT)pipeInformation.CompletionMode
                            << PIPE_COMPLETION_MODE_BITS;
        pipeHandleState |= (USHORT)pipeLocalInformation.NamedPipeEnd
                            << PIPE_PIPE_END_BITS;
        pipeHandleState |= (USHORT)pipeLocalInformation.NamedPipeType
                            << PIPE_PIPE_TYPE_BITS;
        pipeHandleState |= (USHORT)pipeInformation.ReadMode
                            << PIPE_READ_MODE_BITS;
        pipeHandleState |= (USHORT)(pipeLocalInformation.MaximumInstances &
                                    0xFF)
                            << PIPE_MAXIMUM_INSTANCES_BITS;

        SrvFileInformation->HandleState = pipeHandleState;
    } else {

        SrvFileInformation->HandleState = 0;
        if( AdditionalInfo ) {

            //
            // the buffer is added to the end to ensure that we have enough space on the
            // stack to return a FILE_STREAM_INFORMATION buffer having the ::$DATA substream
            union {
                FILE_EA_INFORMATION eaInformation;
                FILE_STREAM_INFORMATION streamInformation;
                FILE_ATTRIBUTE_TAG_INFORMATION tagInformation;
                ULONG buffer[ (sizeof( FILE_STREAM_INFORMATION ) + 14) / sizeof(ULONG) ];
            } u;

            //
            // Find out if this file has EAs
            //
            status = NtQueryInformationFile(
                        FileHandle,
                        &ioStatusBlock,
                        (PVOID)&u.eaInformation,
                        sizeof( u.eaInformation ),
                        FileEaInformation
                     );
            if( !NT_SUCCESS( status ) || u.eaInformation.EaSize == 0 ) {
                SrvFileInformation->HandleState |= SMB_FSF_NO_EAS;
            }

            //
            // Find out if this file has substreams.
            //
            RtlZeroMemory( &u, sizeof(u) );
            status = NtQueryInformationFile(
                        FileHandle,
                        &ioStatusBlock,
                        (PVOID)&u.streamInformation,
                        sizeof( u ),
                        FileStreamInformation
                    );

            //
            // If the filesystem does not support this call, then there are no substreams.  Or
            //  If the filesystem supports the call but returned exactly no name or returned "::$DATA"
            //  then there are no substreams.
            //
            if( status == STATUS_INVALID_PARAMETER ||
                status == STATUS_NOT_IMPLEMENTED ||

                (status == STATUS_SUCCESS &&
                  (u.streamInformation.StreamNameLength == 0 ||
                  (u.streamInformation.StreamNameLength == 14 ))
                )

              ) {
                SrvFileInformation->HandleState |= SMB_FSF_NO_SUBSTREAMS;
            }

            //
            // Find out if this file is a reparse point
            //
            status = NtQueryInformationFile(
                        FileHandle,
                        &ioStatusBlock,
                        (PVOID)&u.tagInformation,
                        sizeof( u.tagInformation ),
                        FileAttributeTagInformation
                    );

            if( !NT_SUCCESS( status ) ||
                u.tagInformation.ReparseTag == IO_REPARSE_TAG_RESERVED_ZERO ) {
                SrvFileInformation->HandleState |= SMB_FSF_NO_REPARSETAG;
            }
        }

    }

    //
    // Set the file device type.
    //

    switch( ShareType ) {

    case ShareTypeDisk:

        SrvFileInformation->Type = FileTypeDisk;
        break;

    case ShareTypePipe:

        if (pipeLocalInformation.NamedPipeType == FILE_PIPE_MESSAGE_TYPE) {
            SrvFileInformation->Type = FileTypeMessageModePipe;
        } else {
            SrvFileInformation->Type = FileTypeByteModePipe;
        }
        break;

    case ShareTypePrint:

        SrvFileInformation->Type = FileTypePrinter;
        break;

    default:

        SrvFileInformation->Type = FileTypeUnknown;

    }

    return STATUS_SUCCESS;

} // SrvQueryNtInformationFile


NTSTATUS
SrvQueryDirectoryFile (
    IN PWORK_CONTEXT WorkContext,
    IN BOOLEAN IsFirstCall,
    IN BOOLEAN FilterLongNames,
    IN BOOLEAN FindWithBackupIntent,
    IN FILE_INFORMATION_CLASS FileInformationClass,
    IN ULONG SearchStorageType,
    IN PUNICODE_STRING FilePathName,
    IN PULONG ResumeFileIndex OPTIONAL,
    IN USHORT SmbSearchAttributes,
    IN PSRV_DIRECTORY_INFORMATION DirectoryInformation,
    IN CLONG BufferLength
    )

/*++

Routine Description:

    This routine acts as a wrapper for NT LanMan server access to
    NtQueryDirectoryFile.  It allows server routines to obtain information
    about the files in a directory using the kind of information
    passed in an SMB.  This localizes the code for this operation and
    simplifies the writing of SMB processing routines that use wildcards.

    The calling routine is responsible for setting up a quadword-aligned
    buffer in nonpaged pool that may be used by this routine.  A pointer
    to the buffer and the buffer length are passed in as parameters.
    The buffer must be allocated from nonpaged pool because one of
    the things it is used for is as a buffer for NtQueryDirectoryFile,
    a buffered-IO request.  The buffer is also used to hold information
    needed by this routine, such as a handle to the directory in which
    the search is being performed, a pointer to the
    FILE_DIRECTORY_INFORMATION structure that was last returned, and the
    basename (with wildcards) that we're using as a search key.  Since
    all this information must remain valid across calls to this routine,
    the calling routine must ensure that the buffer remains intact until
    this routine returns an unsuccessful status or STATUS_NO_MORE_FILES,
    or SrvCloseQueryDirectory is called.

    SMB processing routines which do not need to make use of the Buffer
    field of the outgoing SMB may use this as a buffer for this routine,
    remembering to leave any pathname information in the buffer field of the
    incoming SMB intact by starting the buffer after the pathname.  SMB
    processing routines that write into the Buffer field of the outgoing SMB,
    such as Search and Find, must allocate space for the buffer from nonpaged
    pool.  The size of the buffer should be approximately 4k.  Smaller
    buffers will work, but more slowly due to the need for more calls
    to NtQueryDirectoryFile.  The minimum buffer size is equal to:

        sizeof(SRV_DIRECTORY_INFORMATION) +
        sizeof(SRV_QUERY_DIRECTORY_INFORMATION) +
        MAXIMUM_FILENAME_LENGTH * sizeof(WCHAR) +
        sizeof(UNICODE_STRING) +
        MAXIMUM_FILENAME_LENGTH * sizeof(WCHAR)

    This ensures that NtQueryDirectoryFile will be able to put at least
    one entry in the buffer.

    On the first call to this routine, it fills up its buffer with
    information from NtQueryDirectoryFile and passes back the name of
    a single file that conforms to the specified name and search
    attributes.  On subsequent calls, the names stored in the buffer are
    used until there are no more files in the directory or another
    call to NtQueryDirectoryFile is needed to again fill the buffer.

    Whenever the caller is done with the search, it must call
    SrvCloseQueryDirectory.  This is required even if this routine
    returns an error.

Arguments:

    WorkContext - pointer to a work context block for the operation.  The
        TreeConnect, Session, and RequestHeader fields are used, and the
        pointer is passed to the SMB error handling function if necessary.

    IsFirstCall - a boolean indicating whether this is the first time
        the calling routine is calling this function.  If it is, then
        the directory for the search is opened and other setup
        operations take place.

    FilterLongNames - a boolean that is TRUE when non-FAT names should be
        filtered out (not returned).  If FALSE, return all filenames,
        regardless of whether or not they could be FAT 8.3 names.

    FindWithBackupIntent - Whether the directory was opened by the use
        for backup intent.

    FileInformationClass - the type of file structures to return.  This
        field can be one of FileDirectoryInformation,
        FileFullDirectoryInformation, FileOleDirectoryInformation, or
        FileBothDirectoryInformation.

    FilePathName - a pointer to a string describing the file path name
        to do directory searches on.  This path is relative to the
        PathName specified in the share block.  This parameter is only
        used on the first call to this routine; subsequent calls ignore it.

    ResumeFileIndex - an optional pointer to a file index which determines
        the file with which to restart the search.  NULL if the search
        should be restarted from the last file returned.

    SmbSearchAttributes - the atttibutes, in SMB format, that files must
        have in order to be found.  The search is inclusive, meaning that
        if several attributes are specified, files having those attributes
        will be found, in addition to normal files.

    DirectoryInformation - a pointer to the buffer to be used by this
        routine to do its work.  This buffer must be quadword-aligned.

    BufferLength - the length of the buffer passed to this routine.

Return Value:

    A status indicating success or failure of the operation, or
    STATUS_NO_MORE_FILES if the files in the directory that match the
    specified parameters have been exausted.

--*/

{
    NTSTATUS status;
    IO_STATUS_BLOCK ioStatusBlock;
    PFILE_DIRECTORY_INFORMATION *currentEntry;
    ULONG inclusiveSearchAttributes;
    ULONG exclusiveSearchAttributes;
    ULONG currentAttributes;
    BOOLEAN returnDirectories;
    BOOLEAN returnDirectoriesOnly;
    BOOLEAN calledQueryDirectory = FALSE;

    OBJECT_ATTRIBUTES objectAttributes;
    PUNICODE_STRING filePathName;
    BOOLEAN FreePathName = FALSE;
    UNICODE_STRING objectNameString;
    UNICODE_STRING baseFileName;
    PSHARE fileShare = NULL;

    PUNICODE_STRING resumeName = NULL;
    BOOLEAN resumeSearch;

    CLONG fileNameOffset;
    ULONG createOptions;

    PAGED_CODE( );

    ASSERT( ( FileInformationClass == FileDirectoryInformation ) ||
            ( FileInformationClass == FileFullDirectoryInformation ) ||
            ( FileInformationClass == FileBothDirectoryInformation ) ||
            ( FileInformationClass == FileIdFullDirectoryInformation ) ||
            ( FileInformationClass == FileIdBothDirectoryInformation ) );

    //
    // Set up the offsets to the fields in FILE_FULL_DIR_INFORMATION in
    // a different place than corresponding fields in
    // FILE_DIRECTORY_INFORMATION.  These allow this routine to
    // efficiently use either structure.
    //

    {
        C_ASSERT( FIELD_OFFSET( FILE_DIRECTORY_INFORMATION, NextEntryOffset ) ==
                  FIELD_OFFSET( FILE_FULL_DIR_INFORMATION, NextEntryOffset ) );
        C_ASSERT( FIELD_OFFSET( FILE_DIRECTORY_INFORMATION, FileIndex ) ==
                  FIELD_OFFSET( FILE_FULL_DIR_INFORMATION, FileIndex ) );
        C_ASSERT( FIELD_OFFSET( FILE_DIRECTORY_INFORMATION, CreationTime ) ==
                  FIELD_OFFSET( FILE_FULL_DIR_INFORMATION, CreationTime ) );
        C_ASSERT( FIELD_OFFSET( FILE_DIRECTORY_INFORMATION, LastAccessTime ) ==
                  FIELD_OFFSET( FILE_FULL_DIR_INFORMATION, LastAccessTime ) );
        C_ASSERT( FIELD_OFFSET( FILE_DIRECTORY_INFORMATION, LastWriteTime ) ==
                  FIELD_OFFSET( FILE_FULL_DIR_INFORMATION, LastWriteTime ) );
        C_ASSERT( FIELD_OFFSET( FILE_DIRECTORY_INFORMATION, ChangeTime ) ==
                  FIELD_OFFSET( FILE_FULL_DIR_INFORMATION, ChangeTime ) );
        C_ASSERT( FIELD_OFFSET( FILE_DIRECTORY_INFORMATION, EndOfFile ) ==
                  FIELD_OFFSET( FILE_FULL_DIR_INFORMATION, EndOfFile ) );
        C_ASSERT( FIELD_OFFSET( FILE_DIRECTORY_INFORMATION, AllocationSize ) ==
                  FIELD_OFFSET( FILE_FULL_DIR_INFORMATION, AllocationSize ) );
        C_ASSERT( FIELD_OFFSET( FILE_DIRECTORY_INFORMATION, FileAttributes ) ==
                  FIELD_OFFSET( FILE_FULL_DIR_INFORMATION, FileAttributes ) );
        C_ASSERT( FIELD_OFFSET( FILE_DIRECTORY_INFORMATION, FileNameLength ) ==
                  FIELD_OFFSET( FILE_FULL_DIR_INFORMATION, FileNameLength ) );
    }

    if ( FileInformationClass == FileFullDirectoryInformation ) {
        fileNameOffset =
            FIELD_OFFSET( FILE_FULL_DIR_INFORMATION, FileName[0] );
    } else if ( FileInformationClass == FileBothDirectoryInformation ) {
        fileNameOffset =
            FIELD_OFFSET( FILE_BOTH_DIR_INFORMATION, FileName[0] );
    } else if ( FileInformationClass == FileIdBothDirectoryInformation ) {
        fileNameOffset =
            FIELD_OFFSET( FILE_ID_BOTH_DIR_INFORMATION, FileName[0] );
    } else if ( FileInformationClass == FileIdFullDirectoryInformation ) {
        fileNameOffset =
            FIELD_OFFSET( FILE_ID_FULL_DIR_INFORMATION, FileName[0] );
    } else {
        fileNameOffset =
            FIELD_OFFSET( FILE_DIRECTORY_INFORMATION, FileName[0] );
    }

    //
    // This macro is used to actually get at the FileName field.  Note
    // that it depends on a local variable.
    //

#define FILE_NAME(a) (PWCH)( (PCHAR)(a) + fileNameOffset )

    //
    // If this is the first call to this routine, we must open the
    // correct directory, thereby obtaining a handle to it to pass to
    // NtQueryDirectoryFile.  The calling routine stores the handle
    // to prevent problems if SrvQueryDirectoryFile is called more
    // than once simultaneously.
    //

    if ( IsFirstCall ) {

        BOOLEAN endsInDot;
        ULONG attributes;

        DirectoryInformation->DirectoryHandle = 0L;
        DirectoryInformation->ErrorOnFileOpen = FALSE;
        DirectoryInformation->OnlySingleEntries = FALSE;

        //
        // We must get the appropriate directory name in which to perform the
        // search.  First, find the basename of the file from the FilePathName.
        //
        // Find out whether there are wildcards in the file name we are
        // searching for.  This information will be used later to
        // know whether we should try to get more files if the buffer
        // is empty--if there were no wildcards and we have emptied the
        // buffer, then we know that we have already returned the one and
        // only file that could be found, so return STATUS_NO_MORE_FILES.
        //

        SrvGetBaseFileName( FilePathName, &baseFileName );
        DirectoryInformation->Wildcards =
                        FsRtlDoesNameContainWildCards( &baseFileName );

        if ( DirectoryInformation->Wildcards &&
             (!IS_NT_DIALECT(WorkContext->Connection->SmbDialect) ) ) {

            //
            // Bogus code to workaround ~* problem
            //

            if ( baseFileName.Buffer[(baseFileName.Length>>1)-1] == (WCHAR)'.' ) {
                endsInDot = TRUE;
                baseFileName.Length -= sizeof( WCHAR );
            } else {
                endsInDot = FALSE;
            }

            //
            // Convert the file name to the new form expected by the file
            // systems.  Special case *.* to * since it is so common.  Otherwise
            // transmogrify the input name according to the following rules:
            //
            // - Change all ? to DOS_QM
            // - Change all . followed by ? or * to DOS_DOT
            // - Change all * followed by a . into DOS_STAR
            //
            // These transmogrifications are all done in place.
            //

            if ( (baseFileName.Length == 6) &&
                 (RtlEqualMemory(baseFileName.Buffer, StrStarDotStar, 6) ) ) {

                baseFileName.Length = 2;

            } else {

                ULONG index;
                WCHAR *nameChar;

                for ( index = 0, nameChar = baseFileName.Buffer;
                      index < baseFileName.Length/sizeof(WCHAR);
                      index += 1, nameChar += 1) {

                    if (index && (*nameChar == L'.') && (*(nameChar - 1) == L'*')) {

                        *(nameChar - 1) = DOS_STAR;
                    }

                    if ((*nameChar == L'?') || (*nameChar == L'*')) {

                        if (*nameChar == L'?') {
                            *nameChar = DOS_QM;
                        }

                        if (index && *(nameChar-1) == L'.') {
                            *(nameChar-1) = DOS_DOT;
                        }
                    }
                }

                if ( endsInDot && *(nameChar - 1) == L'*' ) {
                    *(nameChar-1) = DOS_STAR;
                }
            }
        }

        //
        // Set up the object attributes structure for SrvIoCreateFile.
        //

        objectNameString.Buffer = FilePathName->Buffer;
        objectNameString.Length = SrvGetSubdirectoryLength( FilePathName );
        objectNameString.MaximumLength = objectNameString.Length;

        //
        // !!! If the object system supported relative opens with name
        //     length = 0, this wouldn't be necessary.  Take it out when
        //     the object system is done.
        //


        if ( objectNameString.Length == 0 ) {

            //
            // Since we are opening the root directory, set the attribute
            // to case insensitive since this is how we opened the share
            // point when it was added.
            //

            PSHARE share = WorkContext->TreeConnect->Share;

            status = SrvSnapGetNameString( WorkContext, &filePathName, &FreePathName );
            if( !NT_SUCCESS(status) )
            {
                return status;
            }
            objectNameString = *filePathName;

            DirectoryInformation->Wildcards = TRUE;
            attributes = OBJ_CASE_INSENSITIVE;

        } else {

            fileShare = WorkContext->TreeConnect->Share;
            attributes =
                (WorkContext->RequestHeader->Flags & SMB_FLAGS_CASE_INSENSITIVE ||
                WorkContext->Session->UsingUppercasePaths) ?
                OBJ_CASE_INSENSITIVE : 0L;

        }

        SrvInitializeObjectAttributes_U(
            &objectAttributes,
            &objectNameString,
            attributes,
            NULL,
            NULL
            );

        IF_DEBUG(SEARCH) {
            SrvPrint1( "Opening directory name: %wZ\n", &objectNameString );
        }

        //
        // Attempt to open the directory, using the client's security
        // profile to check access.  (We call SrvIoCreateFile, rather than
        // NtOpenFile, in order to get user-mode access checking.)
        //
        INCREMENT_DEBUG_STAT( SrvDbgStatistics.TotalOpenAttempts );
        INCREMENT_DEBUG_STAT( SrvDbgStatistics.TotalOpensForPathOperations );
        //
        // There's no need to specify FILE_DIRECTORY_FILE; the file systems
        // will open whatever is there and reject later QueryDirectoryFile
        // when the object opened does not support enumeration.
        //

        createOptions = 0;
        if (FindWithBackupIntent) {
            createOptions = FILE_OPEN_FOR_BACKUP_INTENT;
        }

        status = SrvIoCreateFile(
                     WorkContext,
                     &DirectoryInformation->DirectoryHandle,
                     FILE_LIST_DIRECTORY,                   // DesiredAccess
                     &objectAttributes,
                     &ioStatusBlock,
                     NULL,                                  // AllocationSize
                     0,                                     // FileAttributes
                     FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
                     FILE_OPEN,                             // Disposition
                     createOptions,                         // CreateOptions
                     NULL,                                  // EaBuffer
                     0,                                     // EaLength
                     CreateFileTypeNone,                    // File type
                     NULL,                                  // ExtraCreateParameters
                     IO_FORCE_ACCESS_CHECK,                 // Options
                     fileShare
                     );

        //
        // If the user didn't have this permission, update the statistics
        // database.
        //

        if ( status == STATUS_ACCESS_DENIED ) {
            SrvStatistics.AccessPermissionErrors++;
        }

        // Free the path since we won't use it anymore
        if( FreePathName )
        {
            FREE_HEAP( filePathName );
            filePathName = NULL;
        }

        if ( !NT_SUCCESS(status) ) {
            IF_DEBUG(ERRORS) {
                SrvPrint2( "SrvQueryDirectoryFile: SrvIoCreateFile for dir %wZ "
                          "failed: %X\n",
                              &objectNameString, status );
            }
            DirectoryInformation->DirectoryHandle = NULL;
            return status;
        }

        SRVDBG_CLAIM_HANDLE( DirectoryInformation->DirectoryHandle, "DID", 3, DirectoryInformation );
        SrvStatistics.TotalFilesOpened++;

        IF_DEBUG(SEARCH) {
            SrvPrint1( "SrvIoCreateFile succeeded, handle = %p\n",
                          DirectoryInformation->DirectoryHandle );
        }

        //
        // Set up the currentEntry pointer.  This is a pointer to the
        // location where the FILE_DIRECTORY_INFORMATION pointer is
        // stored.  It is not really necessary--
        // DirectoryInformation->CurrentEntry could be substituted for
        // every occurrance of *currentEntry.  Using currentEntry makes
        // the code more compact and simpler.
        //

        currentEntry = &(DirectoryInformation->CurrentEntry);
        *currentEntry = NULL;

        //
        // Store the length of buffer space remaining--this is where IO
        // request information will be stored.
        //

        DirectoryInformation->BufferLength = BufferLength -
                                            sizeof(SRV_DIRECTORY_INFORMATION);

        IF_DEBUG(SEARCH) {
            SrvPrint3( "In BufferLength: %ld, sizeof(): %ld, ->BufferLength: "
                          "%ld\n", BufferLength,
                          sizeof(SRV_DIRECTORY_INFORMATION),
                          DirectoryInformation->BufferLength );
        }

    } else {

        //
        // This is not the first call to this routine, so just set up
        // the currentEntry pointer and have it point to the next entry
        // in the buffer.  If there are no more entries in the buffer at
        // this time (NextEntryOffset == 0), set the currentEntry
        // pointer to NULL so that we will know to get more later.
        //

        currentEntry = &DirectoryInformation->CurrentEntry;

        if ( *currentEntry != NULL ) {

            if ( (*currentEntry)->NextEntryOffset == 0 ) {

                *currentEntry = NULL;

            } else {

                *currentEntry = (PFILE_DIRECTORY_INFORMATION)
                   ( (PCHAR)*currentEntry + (*currentEntry)->NextEntryOffset );
            }
        }
    }

    //
    // The lower byte of SmbSearchAttributes defines "inclusive"
    // search attribute bits, meaning that if the bit is on on the
    // file but not set in the request, the file should be skipped.
    // For example, if HIDDEN is not specified in the request, then
    // files with the HIDDEN bit turned on are not returned.
    //
    // The upper byte of SmbSearchAttributes, as an LM2.1 extension,
    // defines "exclusive" search attributes, which means that a
    // file must have the specified bits set in order to be returned.
    // For example, if the READONLY bit is set in the request, only
    // files with the READONLY bit turned on will be returned to the
    // client.
    //
    // Convert the inclusive and exclusive search bits to NT format.
    //

    SRV_SMB_ATTRIBUTES_TO_NT(
        (USHORT)(SmbSearchAttributes & 0xFF),
        &returnDirectories,
        &inclusiveSearchAttributes
        );

    SRV_SMB_ATTRIBUTES_TO_NT(
        (USHORT)(SmbSearchAttributes >> 8),
        &returnDirectoriesOnly,
        &exclusiveSearchAttributes
        );

    //
    // For the inclusive bits, files with the NORMAL, ARCHIVE, or READONLY
    // bits set should be returned regardless of whether these bits
    // were set in SmbSearchAttributes.
    //

    inclusiveSearchAttributes |= FILE_ATTRIBUTE_NORMAL |
                                     FILE_ATTRIBUTE_ARCHIVE |
                                     FILE_ATTRIBUTE_READONLY;

    //
    // For exclusive bits, the VOLUME bit is meaningless.  It is also not
    // necessary for a file to have the NORMAL bit on, since the NORMAL
    // bit is not defined for the SMB protocol.
    //

    exclusiveSearchAttributes &=
        ~(SMB_FILE_ATTRIBUTE_VOLUME | FILE_ATTRIBUTE_NORMAL);

    //
    // If a resume file index was passed in, this search is a resumption
    // from that file and the name specified in FilePathName.
    //

    if ( ARGUMENT_PRESENT( ResumeFileIndex ) ) {

        resumeSearch = TRUE;
        resumeName = FilePathName;

        IF_DEBUG(SEARCH) {
            SrvPrint3( "Resuming search at file %wZ, length %ld, index %lx\n",
                          resumeName, resumeName->Length,
                          *ResumeFileIndex );
        }

    } else {

        resumeSearch = FALSE;
    }

    //
    // Now we need to find a file to return.  We keep going until we find
    // a file that meets all of our criteria, pointing to the next file
    // if a file fails.  We continue the loop under the following conditions:
    //
    // 1) If *currentEntry == NULL, then we haven't yet filled our buffer
    //    with entries, so get some entries.
    //
    // 2) If there are bits set in the FileAttributes field of the
    //    FILE_DIRECTORY_INFORMATION field that are not set in the
    //    searchAttributes variable, then the file does not meet the
    //    search requirements, and we need to continue looking.
    //
    // 3) If we are not searching for directories and the file is actually
    //    a directory, skip over it.
    //
    // 4) If we are filtering long (non-FAT) filenames AND this file name
    //    is not a legal FAT name AND we have no short name for this file,
    //    skip it.
    //
    // 5) If the file doesn't have attribute bits specified as exclusive
    //    bits, skip it.
    //
    // 6) If the file is not a directory and we're only supposed to return
    //    directories, skip it.
    //
    // When this loop is complete, *currentEntry will point to the
    // FILE_DIRECTORY_INFORMATION structure corresponding to the file we
    // will return.  If no qualifying files are found, return
    // STATUS_NO_MORE_FILES and close the directory.
    //

    if( *currentEntry != NULL ) {
        SRV_NT_ATTRIBUTES_TO_SMB( (*currentEntry)->FileAttributes,0,&currentAttributes);
    }

    while ( ( *currentEntry == NULL )                                   // 1

            ||

            ( (currentAttributes | inclusiveSearchAttributes) !=        // 2
                inclusiveSearchAttributes )

            ||

            ( !returnDirectories &&                                     // 3
              (currentAttributes & FILE_ATTRIBUTE_DIRECTORY))

            ||
                                                                        // 4
            ( FilterLongNames &&
              !SrvIsLegalFatName( FILE_NAME( *currentEntry ),
                                  (*currentEntry)->FileNameLength) &&
              !( FileInformationClass == FileBothDirectoryInformation &&
                 ((PFILE_BOTH_DIR_INFORMATION)*currentEntry)->
                                                        ShortNameLength != 0) )


            ||
                                                                        // 5
            ( (currentAttributes | exclusiveSearchAttributes) !=
                currentAttributes )

            ||

            ( returnDirectoriesOnly &&                                  // 6
              !(currentAttributes & FILE_ATTRIBUTE_DIRECTORY) )

          ) {

        IF_DEBUG(SEARCH) {
            if ( *currentEntry != NULL) {
                UNICODE_STRING name;
                name.Length = (SHORT)(*currentEntry)->FileNameLength;
                name.Buffer = FILE_NAME( *currentEntry );
                SrvPrint4( "Skipped %wZ, FileAttr: %lx, ISA: %lx ESA: %lx ",
                            &name, (*currentEntry)->FileAttributes,
                            inclusiveSearchAttributes,
                            exclusiveSearchAttributes );
                SrvPrint4( "NL=%ld D=%ld RD=%ld RDO=%ld ",
                            (*currentEntry)->FileNameLength,
                            (((*currentEntry)->FileAttributes &
                            FILE_ATTRIBUTE_DIRECTORY) != 0), returnDirectories,
                            returnDirectoriesOnly );
                SrvPrint1( "FLN=%ld\n", FilterLongNames );
            }
        }

        //
        // We need to look for more files under the following conditions:
        //
        //    o we have yet to fill the buffer with entries;
        //
        //    o the NextEntryOffset is zero, indicating that the files in
        //      the buffer have been exausted.
        //

        if ( *currentEntry == NULL ||
             (*currentEntry)->NextEntryOffset == 0 ) {

            PUNICODE_STRING actualString;
            BOOLEAN bruteForceRewind = FALSE;

            //
            // The buffer has no more valid entries in it.  If no
            // wildcards were specified in the file name to search on,
            // then we have already returned the single file and we
            // should just stop now.  Otherwise, we go get more entries.
            //

            if ( !DirectoryInformation->Wildcards &&
                 ( !IsFirstCall || calledQueryDirectory ) ) {

                if ( calledQueryDirectory ) {
                    return STATUS_NO_SUCH_FILE;
                } else {
                    return STATUS_NO_MORE_FILES;
                }
            }

            //
            // Set up the file name that will be passed to
            // SrvIssueQueryDirectoryRequest.  If this is the first
            // call, then pass the file spec given by the user.  If this
            // is a resume search and we haven't yet done a directory
            // query, then use the resume file name and index.
            // Otherwise, pass NULL for these and the file system will
            // continue from where it left off after the last directory
            // query.
            //

            if ( IsFirstCall &&
                 !calledQueryDirectory &&
                 baseFileName.Length != 0 ) {

                actualString = &baseFileName;

            } else if ( resumeSearch && !calledQueryDirectory ) {

                actualString = resumeName;

            } else {

                actualString = NULL;
                ResumeFileIndex = NULL;

            }

            IF_DEBUG(SEARCH) {

                if ( actualString == NULL ) {
                    SrvPrint0( "**** CALLING NTQUERYDIRECTORYFILE, file = NULL, length: 0\n" );
                } else {
                    SrvPrint2( "**** CALLING NTQUERYDIRECTORYFILE, file = %wZ, length: %ld\n",
                                actualString, actualString->Length );
                }

                SrvPrint0( "Reason:  \n" );

                if ( *currentEntry == NULL ) {
                    SrvPrint0( "*currentEntry == NULL\n" );
                } else {
                    SrvPrint1( "(*currentEntry)->NextEntryOffset == %ld\n",
                               (*currentEntry)->NextEntryOffset );
                }
            }

            //
            // Do the directory query operation using a directly-built
            // IRP.  Doing this rather than calling NtQueryDirectoryFile
            // eliminates a buffered I/O copy of the directory
            // information and allows use of a kernel event object.  If
            // this is the first call to NtQueryDirectoryFile, pass it
            // the search file name.  If this is a rewind or resume of a
            // prior search, pass the resume file name and index.
            //
            // The query is performed synchronously, which may be a
            // detriment to performance.  However, it may be the case
            // that routines calling SrvQueryDirectoryFile want to
            // exploit the asynchronous capabilities of the IO system,
            // so keeping this routine synchronous significantly
            // simplifies their job.
            //

            status = SrvIssueQueryDirectoryRequest(
                         DirectoryInformation->DirectoryHandle,
                         (PCHAR)DirectoryInformation->Buffer,
                         DirectoryInformation->BufferLength,
                         FileInformationClass,
                         actualString,
                         ResumeFileIndex,
                         FALSE,
                         DirectoryInformation->OnlySingleEntries
                         );

            calledQueryDirectory = TRUE;

            //
            // If the file system cannot support the rewind request,
            // do a brute force rewind (restart search at beginning
            // of directory).
            //
            // This check is before the check for STATUS_NO_MORE_FILES
            // in case there are no files after the resume file.
            //

            if ( status == STATUS_NOT_IMPLEMENTED ) {

                IF_DEBUG(SEARCH) {
                    SrvPrint0( "Doing brute force rewind!!\n" );
                }

                bruteForceRewind = TRUE;
                DirectoryInformation->OnlySingleEntries = TRUE;

                status = BruteForceRewind(
                             DirectoryInformation->DirectoryHandle,
                             (PCHAR)DirectoryInformation->Buffer,
                             DirectoryInformation->BufferLength,
                             actualString,
                             FileInformationClass,
                             currentEntry
                             );

                //
                //  If BruteForceRewind fails with STATUS_NOT_IMPLEMENTED, it
                //  means that the client requested a rewind from a
                //  non-existant file.   The only time this happens in when
                //  an OS/2 is deleting many files in a directory.  To cope
                //  simple rewind the search to the beginning of the
                //  directory.
                //

                if ( status == STATUS_NOT_IMPLEMENTED ) {

                    bruteForceRewind = FALSE;
                    DirectoryInformation->OnlySingleEntries = FALSE;

                    status = SrvIssueQueryDirectoryRequest(
                                 DirectoryInformation->DirectoryHandle,
                                 (PCHAR)DirectoryInformation->Buffer,
                                 DirectoryInformation->BufferLength,
                                 FileInformationClass,
                                 actualString,
                                 ResumeFileIndex,
                                 TRUE,
                                 FALSE
                                 );
                }
            }

            //
            // If there are no more files to be gotten, then stop.
            //

            if ( status == STATUS_NO_MORE_FILES ) {
                IF_DEBUG(SEARCH) {
                    SrvPrint0( "SrvQueryDirectoryFile: No more files.\n" );
                }
                return status;
            }

            if ( !NT_SUCCESS(status) ) {
                IF_DEBUG(SEARCH) {
                    SrvPrint1( "SrvQueryDirectoryFile: NtQueryDirectoryFile "
                                 "failed: %X.\n", status );
                }
                return status;
            }

            IF_DEBUG(SEARCH) {
                SrvPrint1( "NtQueryDirectoryFile succeeded: %X\n", status );
            }

            //
            // If there wasn't a brute force rewind, which would have
            // set up the CurrentEntry pointer, Set up CurrentEntry
            // pointer to point to the first entry in the buffer.
            //

            if ( !bruteForceRewind ) {
                *currentEntry =
                    (PFILE_DIRECTORY_INFORMATION)DirectoryInformation->Buffer;
            } else {
                bruteForceRewind = FALSE;
            }

            IF_DEBUG(SEARCH) {
                UNICODE_STRING name;
                name.Length = (SHORT)(*currentEntry)->FileNameLength;
                name.Buffer = FILE_NAME( *currentEntry );
                SrvPrint2( "First file name is %wZ, length = %ld\n",
                            &name, (*currentEntry)->FileNameLength );
            }

        } else {

            //
            // The file described by the FILE_DIRECTORY_INFORMATION pointed
            // to by *currentEntry does not meet our requirements, so
            // point to the next file in the buffer.
            //

            *currentEntry = (PFILE_DIRECTORY_INFORMATION)( (PCHAR)*currentEntry
                            + (*currentEntry)->NextEntryOffset );
        }

        if( *currentEntry != NULL ) {
            SRV_NT_ATTRIBUTES_TO_SMB( (*currentEntry)->FileAttributes,0,&currentAttributes);
        }
    }

    return STATUS_SUCCESS;

} // SrvQueryDirectoryFile


STATIC
NTSTATUS
BruteForceRewind(
    IN HANDLE DirectoryHandle,
    IN PVOID Buffer,
    IN ULONG BufferLength,
    IN PUNICODE_STRING FileName,
    IN FILE_INFORMATION_CLASS FileInformationClass,
    IN OUT PFILE_DIRECTORY_INFORMATION *CurrentEntry
    )

/*++

Routine Description:

    This routine manually does a rewind rather than use the file system
    to do it.  It gets starts at the first entry in the directory
    specified by DirectoryHandle and continues until it reaches the end
    of the directory or a match.  If a file is deleted between the
    original search and the rewind, then this mechanism will fail.

    This routine is intended to work in conjunction with
    SrvQueryDirectoryFile.


Arguments:

    DirectoryHandle - handle of directory to search.

    Buffer - Space to hold results.

    BufferLength - length of Buffer.

    FileName - the rewind file name.  The file *after* this one is returned.

    FileInformationClass - one of FileDirectoryInformation,
        FileBothDirInformation, or FileFullDirectoryInformation.
        (The latter of the four if EA sizes are being requested.)

    CurrentEntry - a pointer to receive a pointer to the file after
        FileName in the directory.

Return Value:

    NTSTATUS - result of operation.

--*/

{
    NTSTATUS status;
    UNICODE_STRING checkFileName;
    BOOLEAN matchFound = FALSE;
    BOOLEAN restartScan = TRUE;

    ULONG fileNameOffset;

    PAGED_CODE( );

    checkFileName.Length = 0;
    *CurrentEntry = NULL;

    if ( FileInformationClass == FileFullDirectoryInformation ) {
        fileNameOffset =
            FIELD_OFFSET( FILE_FULL_DIR_INFORMATION, FileName[0] );
    } else if ( FileInformationClass == FileBothDirectoryInformation ) {
        fileNameOffset =
            FIELD_OFFSET( FILE_BOTH_DIR_INFORMATION, FileName[0] );
    } else {
        fileNameOffset =
            FIELD_OFFSET( FILE_DIRECTORY_INFORMATION, FileName[0] );
    }

    while ( TRUE ) {

        if ( *CurrentEntry == NULL ) {

            //
            // Restart the directory search and get a buffer of files.
            //

            status = SrvIssueQueryDirectoryRequest(
                         DirectoryHandle,
                         Buffer,
                         BufferLength,
                         FileInformationClass,
                         NULL,
                         NULL,
                         restartScan,
                         TRUE
                         );

            restartScan = FALSE;

            if ( status == STATUS_NO_MORE_FILES ) {

                if ( matchFound ) {

                    //
                    // The file matched the last one in the directory;
                    // there is no following file.  Return
                    // STATUS_NO_MORE_FILES.
                    //

                    return status;

                } else {

                    //
                    // The file was deleted between when the original search
                    // was done and this rewind.  Return an error.
                    //

                    return STATUS_NOT_IMPLEMENTED;
                }
            }

            if ( !NT_SUCCESS(status) ) {
                return status;
            }

            //
            // Set up the current entry pointer.
            //

            *CurrentEntry = Buffer;
        }

        //
        // If the last file we looked at was the correct resume file,
        // then we want to return this file.
        //

        if ( matchFound ) {
            return STATUS_SUCCESS;
        }

        //
        // Check to see if this file is the resume file.
        //

        checkFileName.Length = (SHORT)(*CurrentEntry)->FileNameLength;
        checkFileName.Buffer = FILE_NAME( *CurrentEntry );
        checkFileName.MaximumLength = checkFileName.Length;

        if ( RtlCompareUnicodeString(
                FileName,
                &checkFileName,
                TRUE
                ) == 0 ) {
            matchFound = TRUE;

        } else if ( FileInformationClass == FileBothDirectoryInformation ) {

            //
            // Compare the short name.
            //

            checkFileName.Length = (SHORT)
                ((PFILE_BOTH_DIR_INFORMATION)*CurrentEntry)->ShortNameLength;
            checkFileName.Buffer =
                ((PFILE_BOTH_DIR_INFORMATION)*CurrentEntry)->ShortName;
            checkFileName.MaximumLength = checkFileName.Length;

            if ( RtlCompareUnicodeString(
                    FileName,
                    &checkFileName,
                    TRUE
                    ) == 0 ) {
                matchFound = TRUE;
            }
        }

        IF_DEBUG(SEARCH) {
            if ( matchFound ) {
                SrvPrint2( "Matched: %wZ and %wZ\n", FileName, &checkFileName );
            } else {
                SrvPrint2( "No match: %wZ and %wZ\n", FileName, &checkFileName );
            }
        }

        //
        // Set up the current entry pointer for the next iteration.
        //

        if ( (*CurrentEntry)->NextEntryOffset == 0 ) {
            *CurrentEntry = NULL;
        } else {
            *CurrentEntry =
                (PFILE_DIRECTORY_INFORMATION)( (PCHAR)(*CurrentEntry) +
                    (*CurrentEntry)->NextEntryOffset );
        }
    }

} // BruteForceRewind



NTSTATUS
SrvQueryEaFile (
    IN BOOLEAN IsFirstCall,
    IN HANDLE FileHandle,
    IN PFILE_GET_EA_INFORMATION EaList OPTIONAL,
    IN ULONG EaListLength,
    IN PSRV_EA_INFORMATION EaInformation,
    IN CLONG BufferLength,
    OUT PULONG EaErrorOffset
    )

/*++

Routine Description:

    This routine acts as a wrapper for NT LanMan server access to
    NtQueryEaFile.  It has basically the same interface as
    SrvQueryDirectoryFile, allowing a routine to be written to deal
    with a single EA at a time while also maintaining performance
    by requesting a large number of EAs from the IO system at a
    time.

    The calling routine is responsible for setting up a quadword-aligned
    buffer in nonpaged pool that may be used by this routine.  A pointer
    to the buffer and the buffer length are passed in as parameters.
    The buffer must be allocated from nonpaged pool because one of
    the things it is used for is as a buffer for NtQueryEaFile,
    a buffered-IO request.  The buffer is also used to hold information
    needed by this routine, such as a pointer to the FILE_EA_INFORMATION
    structure that was last returned.  Since all this information must
    remain valid across calls to this routine, the calling routine
    must ensure that the buffer remains intact until this routine
    returns an unsuccessful status or STATUS_NO_MORE_EAS.

    Routines that make use of this routine should set up a buffer
    large enough to hold at least a single EA.  Since this can be
    over 64k, it is a good idea to call NtQueryInformationFile to
    get the EA size, then allocate a buffer of this size, unless
    it is greater than the maximum size of an EA.  In this case,
    the maximum size of an EA should be allocated as the buffer.

    On the first call to this routine, it fills up its buffer with
    information from NtQueryEaFile and passes back a single EA.  On
    subsequent calls, the names stored in the buffer are used until
    there are no more files in the directory or another call to
    NtQueryEaFile is needed to again fill the buffer.

Arguments:

    IsFirstCall - a boolean indicating whether this is the first time
        the calling routine is calling this function.  If it is, then
        setup operations take place.

    FileHandle - a handle to a file open with FILE_READ_EA.

    EaList - an optional pointer to an NT-style get EA list.  Only those
        EAs listed in this structure are returned.

    EaListLength - length in bytes of ths get EA list.

    EaInformation - a pointer to the buffer to be used by this routine
        to do its work.  This buffer must be quadword-aligned.

    BufferLength - the length of the buffer passed to this routine.

    EaErrorOffset - the offset into EaList of an invalid EA, if any.

Return Value:

    A status indicating success or failure of the operation, or
    STATUS_NO_MORE_EAS if all the EAs have been returned.

--*/

{
    NTSTATUS status;
    PFILE_GET_EA_INFORMATION useEaList = NULL;
    PFILE_FULL_EA_INFORMATION *currentEntry;

    PAGED_CODE( );

    //
    // If this is the first call, do the necessary setup.
    //

    if ( IsFirstCall ) {

        //
        // Set up the currentEntry pointer.  This is a pointer to the
        // location where the FILE_EA_INFORMATION pointer is stored.
        // It is not really necessary--EaInformation->CurrentEntry
        // could be substituted for every occurrance of *currentEntry.
        // Using currentEntry makes the code more compact and simpler.
        //

        currentEntry = &(EaInformation->CurrentEntry);
        *currentEntry = NULL;

        //
        // Store the length of buffer space remaining--this is where IO
        // request information will be stored.
        //

        EaInformation->BufferLength = BufferLength - sizeof(SRV_EA_INFORMATION);
        EaInformation->GetEaListOffset = 0;

        IF_DEBUG(SEARCH) {
            SrvPrint3( "In BufferLength: %ld, sizeof(): %ld, ->BufferLength: "
                          "%ld\n", BufferLength, sizeof(SRV_EA_INFORMATION),
                          EaInformation->BufferLength );
        }

    } else {

        //
        // This is not the first call to this routine, so just set up
        // the currentEntry pointer and have it point to the next entry
        // in the buffer.  If there are no more entries in the buffer at
        // this time (NextEntryOffset == 0), set the currentEntry
        // pointer to NULL so that we will know to get more later.
        //

        currentEntry = &EaInformation->CurrentEntry;

        if ( *currentEntry != NULL ) {

            if ( (*currentEntry)->NextEntryOffset == 0 ) {

                *currentEntry = NULL;

            } else {

                *currentEntry = (PFILE_FULL_EA_INFORMATION)
                   ( (PCHAR)*currentEntry + (*currentEntry)->NextEntryOffset );
            }
        }
    }

    //
    // If the buffer has no valid entries in it, get some.
    //

    if ( *currentEntry == NULL ) {

        //
        // If all the EAs in a get EA list were returned last time,
        // return now.
        //

        if ( ARGUMENT_PRESENT(EaList) &&
                 EaInformation->GetEaListOffset == 0xFFFFFFFF ) {

            return STATUS_NO_MORE_EAS;
        }

        //
        // The buffer has no more valid entries in it, so get more.
        //

        IF_DEBUG(SEARCH) SrvPrint0( "**** CALLING NTQUERYEAFILE\n" );

        //
        // Set up the proper get EA list if one was specified on input.
        //

        if ( ARGUMENT_PRESENT(EaList) ) {
            useEaList = (PFILE_GET_EA_INFORMATION)( (PCHAR)EaList +
                            EaInformation->GetEaListOffset );
            EaListLength -= EaInformation->GetEaListOffset;
        }

        //
        // Do the EA query operation using a directly-build IRP.  Doing
        // this rather than calling NtQueryEaFile eliminates a buffered I/O
        // copy of the EAs and allows use of a kernel event object.
        //
        // The query is performed synchronously, which may be a
        // detriment to performance.  However, it may be the case that
        // routines calling SrvQueryEaFile want to exploit the
        // asynchronous capabilities of the IO system, so keeping this
        // routine synchronous significantly simplifies their job.
        //

        status = SrvIssueQueryEaRequest(
                    FileHandle,
                    (PCHAR)EaInformation->Buffer,
                    EaInformation->BufferLength,
                    useEaList,
                    EaListLength,
                    IsFirstCall,
                    EaErrorOffset
                    );

        //
        // If there are no more EAs to be gotten, then stop.
        //

        if ( status == STATUS_NO_MORE_EAS ||
             status == STATUS_NONEXISTENT_EA_ENTRY ||
             status == STATUS_NO_EAS_ON_FILE ) {

            IF_DEBUG(SEARCH) {
                SrvPrint0( "SrvQueryEaFile: No more EAs (or file has no EAs).\n" );
            }

            return STATUS_NO_MORE_EAS;
        }

        if ( !NT_SUCCESS(status) ) {
            return status;
        }

        IF_DEBUG(SEARCH) {
            SrvPrint1( "NtQueryEaFile succeeded: %X\n", status );
        }

        //
        // Set up the offset into the get EA list by counting how many
        // full EAs were returned, then walking that far into the get
        // EA list.
        //
        // If all the requested EAs were returned, set the offset to
        // 0xFFFFFFFF so that we know to return STATUS_NO_MORE_EAS.
        //

        if ( ARGUMENT_PRESENT(EaList) ) {

            CLONG numberOfGetEas;
            CLONG numberOfFullEas;

            numberOfGetEas = SrvGetNumberOfEasInList( useEaList );
            numberOfFullEas = SrvGetNumberOfEasInList( EaInformation->Buffer );

            ASSERT( numberOfGetEas >= numberOfFullEas );

            if ( numberOfGetEas == numberOfFullEas ) {

                EaInformation->GetEaListOffset = 0xFFFFFFFF;

            } else {

                CLONG i;

                //
                // Walk the get EA list until we have passed the number
                // of EAs that were returned.  This assumes that we got
                // back at least one EA--if not even one EA would fit in
                // the buffer, SrvIssueQueryEaRequest should have
                // returned STATUS_BUFFER_OVERFLOW.
                //

                for ( i = 0; i < numberOfFullEas; i++ ) {
                    useEaList = (PFILE_GET_EA_INFORMATION)(
                                    (PCHAR)useEaList +
                                    useEaList->NextEntryOffset );
                }

                EaInformation->GetEaListOffset = (ULONG)((PCHAR)useEaList -
                                                         (PCHAR)EaList);
            }
        }

        //
        // Set up CurrentEntry pointer to point to the first entry in the
        // buffer.
        //

        *currentEntry = (PFILE_FULL_EA_INFORMATION)EaInformation->Buffer;

        IF_DEBUG(SEARCH) {
            ANSI_STRING name;
            name.Length = (*currentEntry)->EaNameLength;
            name.Buffer = (*currentEntry)->EaName;
            SrvPrint2( "First EA name is %z, length = %ld\n",
                        (PCSTRING)&name, (*currentEntry)->EaNameLength );
        }
    }

    return STATUS_SUCCESS;

} // SrvQueryEaFile



VOID
SrvTimeToDosTime (
    IN PLARGE_INTEGER SystemTime,
    OUT PSMB_DATE DosDate,
    OUT PSMB_TIME DosTime
    )

/*++

Routine Description:

    This function converts a time in NT format to the format used by
    MS-DOS.

Arguments:

    SystemTime - a pointer to an NT time to convert.

    DosDate - a pointer to a location in which to store the date in DOS format.

    DosTime - a pointer to a location in which to store the time in DOS format.

Return Value:

    None.

--*/

{
    TIME_FIELDS timeFields;
    LARGE_INTEGER localTime;

    PAGED_CODE( );

    if ( SystemTime->QuadPart == 0 ) {
        goto zerotime;
    }

    //
    // Add almost two seconds to round up to the nearest double second.
    // We need to do this to be compatible with the NT rdr and NT FAT
    // filesystem.
    //

    SystemTime->QuadPart += AlmostTwoSeconds;

    //
    // Convert System time (UTC) to local NT time
    //

    ExSystemTimeToLocalTime( SystemTime, &localTime );

    RtlTimeToTimeFields(
        &localTime,
        &timeFields
        );

    DosDate->Struct.Day = timeFields.Day;
    DosDate->Struct.Month = timeFields.Month;
    DosDate->Struct.Year = (SHORT)(timeFields.Year - 1980);

    DosTime->Struct.TwoSeconds = (SHORT)(timeFields.Second / 2);
    DosTime->Struct.Minutes = timeFields.Minute;
    DosTime->Struct.Hours = timeFields.Hour;

    return;

zerotime:

    DosDate->Struct.Day = 0;
    DosDate->Struct.Month = 0;
    DosDate->Struct.Year = 0;

    DosTime->Struct.TwoSeconds = 0;
    DosTime->Struct.Minutes = 0;
    DosTime->Struct.Hours = 0;

    return;
} // SrvTimeToDosTime


VOID
SrvDosTimeToTime (
    OUT PLARGE_INTEGER SystemTime,
    IN SMB_DATE DosDate,
    IN SMB_TIME DosTime
    )

/*++

Routine Description:

    This function converts a time in NT format to the format used by
    MS-DOS.

Arguments:

    Time - a pointer to a location in which to store the NT time.

    DosDate - a pointer the date in DOS format.

    DosDate - a pointer the date in DOS format.

Return Value:

    None.

--*/

{

    TIME_FIELDS timeFields;
    LARGE_INTEGER localTime;

    PAGED_CODE( );

    timeFields.Day = DosDate.Struct.Day;
    timeFields.Month = DosDate.Struct.Month;
    timeFields.Year = (SHORT)(DosDate.Struct.Year + 1980);

    timeFields.Milliseconds = 0;
    timeFields.Second = (SHORT)(DosTime.Struct.TwoSeconds * 2);
    timeFields.Minute = DosTime.Struct.Minutes;
    timeFields.Hour = DosTime.Struct.Hours;

    if ( !RtlTimeFieldsToTime( &timeFields, &localTime ) ) {
        goto zerotime;
    }

    ExLocalTimeToSystemTime( &localTime, SystemTime );
    return;

zerotime:

    SystemTime->QuadPart = 0;
    return;

} // SrvDosTimeToTime


USHORT
SrvGetOs2TimeZone(
    IN PLARGE_INTEGER SystemTime
    )

/*++

Routine Description:

    This function gets the timezone bias.

Arguments:

    SystemTime - The current UTC time expressed.

Return Value:

    The time zone bias in minutes from GMT.

--*/

{
    LARGE_INTEGER zeroTime;
    LARGE_INTEGER timeZoneBias;

    PAGED_CODE( );

    zeroTime.QuadPart = 0;

    //
    // Specifying a zero local time will give you the time zone bias.
    //

    ExLocalTimeToSystemTime( &zeroTime, &timeZoneBias );

    //
    // Convert the bias unit from 100ns to minutes.  The maximum value
    // for the bias is 720 minutes so a USHORT is big enough to contain
    // it.
    //

    return (SHORT)(timeZoneBias.QuadPart / (10*1000*1000*60));

} // SrvGetOs2TimeZone

NTSTATUS
SrvQueryBasicAndStandardInformation(
    HANDLE FileHandle,
    PFILE_OBJECT FileObject OPTIONAL,
    PFILE_BASIC_INFORMATION FileBasicInfo,
    PFILE_STANDARD_INFORMATION FileStandardInfo OPTIONAL
    )
{
    NTSTATUS status;
    PFILE_OBJECT fileObject;
    PDEVICE_OBJECT deviceObject;
    PFAST_IO_DISPATCH fastIoDispatch;
    PFAST_IO_QUERY_BASIC_INFO fastQueryBasicInfo;
    PFAST_IO_QUERY_STANDARD_INFO fastQueryStandardInfo;
    IO_STATUS_BLOCK ioStatus;

    PAGED_CODE( );

    ASSERT( FileBasicInfo != NULL );

    //
    // Get a pointer to the file object, so that we can directly
    // access the fast IO routines, if they exists.
    //

    if ( !ARGUMENT_PRESENT( FileObject ) ) {

        status = ObReferenceObjectByHandle(
                    FileHandle,
                    0,
                    NULL,
                    KernelMode,
                    (PVOID *)&fileObject,
                    NULL
                    );

        if ( !NT_SUCCESS(status) ) {

            SrvLogServiceFailure( SRV_SVC_OB_REF_BY_HANDLE, status );

            //
            // This internal error bugchecks the system.
            //

            INTERNAL_ERROR(
                ERROR_LEVEL_IMPOSSIBLE,
                "CompleteOpen: unable to reference file handle 0x%lx",
                FileHandle,
                NULL
                );

            return(status);

        }

    } else {
        fileObject = FileObject;
    }

    deviceObject = IoGetRelatedDeviceObject( fileObject );
    fastIoDispatch = deviceObject->DriverObject->FastIoDispatch;

    if ( fastIoDispatch ) {
        fastQueryBasicInfo = fastIoDispatch->FastIoQueryBasicInfo;
        fastQueryStandardInfo = fastIoDispatch->FastIoQueryStandardInfo;
    } else {
        fastQueryBasicInfo = NULL;
        fastQueryStandardInfo = NULL;
    }

    if ( fastQueryBasicInfo &&
         fastQueryBasicInfo(
                         fileObject,
                         TRUE,
                         FileBasicInfo,
                         &ioStatus,
                         deviceObject
                         ) ) {

        status = ioStatus.Status;

    } else {

        status = NtQueryInformationFile(
                         FileHandle,
                         &ioStatus,
                         (PVOID)FileBasicInfo,
                         sizeof(FILE_BASIC_INFORMATION),
                         FileBasicInformation
                         );
    }

    //
    // If we're done if there was a failure, return
    //

    if ( ARGUMENT_PRESENT( FileStandardInfo ) && NT_SUCCESS(status) ) {

        //
        // Get the standard info
        //

        if ( fastQueryStandardInfo &&
             fastQueryStandardInfo(
                             fileObject,
                             TRUE,
                             FileStandardInfo,
                             &ioStatus,
                             deviceObject
                             ) ) {

            status = ioStatus.Status;

        } else {

            status = NtQueryInformationFile(
                         FileHandle,
                         &ioStatus,
                         (PVOID)FileStandardInfo,
                         sizeof(FILE_STANDARD_INFORMATION),
                         FileStandardInformation
                         );
        }
    }

    if ( !ARGUMENT_PRESENT( FileObject ) ) {
        ObDereferenceObject( fileObject );
    }
    return(status);

} // SrvQueryBasicAndStandardInformation

NTSTATUS
SrvQueryNetworkOpenInformation(
    HANDLE FileHandle,
    PFILE_OBJECT FileObject OPTIONAL,
    PSRV_NETWORK_OPEN_INFORMATION SrvNetworkOpenInformation,
    BOOLEAN QueryEaSize
    )
{
    NTSTATUS status;
    PFILE_OBJECT fileObject;
    PDEVICE_OBJECT deviceObject;
    PFAST_IO_DISPATCH fastIoDispatch;
    PFAST_IO_QUERY_NETWORK_OPEN_INFO fastQueryNetworkOpenInfo;
    FILE_BASIC_INFORMATION FileBasicInfo;
    FILE_STANDARD_INFORMATION FileStandardInfo;
    IO_STATUS_BLOCK ioStatus;

    PAGED_CODE( );

    //
    // Get a pointer to the file object, so that we can directly
    // access the fast IO routines, if they exist.
    //
    if ( !ARGUMENT_PRESENT( FileObject ) ) {

        status = ObReferenceObjectByHandle(
                    FileHandle,
                    0,
                    NULL,
                    KernelMode,
                    (PVOID *)&fileObject,
                    NULL
                    );

        if ( !NT_SUCCESS(status) ) {

            SrvLogServiceFailure( SRV_SVC_OB_REF_BY_HANDLE, status );

            //
            // This internal error bugchecks the system.
            //

            INTERNAL_ERROR(
                ERROR_LEVEL_IMPOSSIBLE,
                "CompleteOpen: unable to reference file handle 0x%lx",
                FileHandle,
                NULL
                );

            return(status);

        }

    } else {
        fileObject = FileObject;
    }

    deviceObject = IoGetRelatedDeviceObject( fileObject );
    fastIoDispatch = deviceObject->DriverObject->FastIoDispatch;

    if(  !QueryEaSize &&
         fastIoDispatch &&
         fastIoDispatch->SizeOfFastIoDispatch > FIELD_OFFSET(FAST_IO_DISPATCH,FastIoQueryNetworkOpenInfo)) {

        fastQueryNetworkOpenInfo = fastIoDispatch->FastIoQueryNetworkOpenInfo;

        if( fastQueryNetworkOpenInfo &&

            fastQueryNetworkOpenInfo(
                fileObject,
                TRUE,
                (PFILE_NETWORK_OPEN_INFORMATION)SrvNetworkOpenInformation,
                &ioStatus,
                deviceObject ) ) {

            status = ioStatus.Status;

            if ( !ARGUMENT_PRESENT( FileObject ) ) {
                ObDereferenceObject( fileObject );
            }

            return status;
        }
    }

    //
    // The fast path didn't work.  Do it the slow way
    //
    status = SrvQueryBasicAndStandardInformation(
                FileHandle,
                fileObject,
                &FileBasicInfo,
                &FileStandardInfo
             );

    if ( !ARGUMENT_PRESENT( FileObject ) ) {
        ObDereferenceObject( fileObject );
    }

    if( !NT_SUCCESS( status ) ) {
        return status;
    }

    SrvNetworkOpenInformation->CreationTime   = FileBasicInfo.CreationTime;
    SrvNetworkOpenInformation->LastAccessTime = FileBasicInfo.LastAccessTime;
    SrvNetworkOpenInformation->LastWriteTime  = FileBasicInfo.LastWriteTime;
    SrvNetworkOpenInformation->ChangeTime     = FileBasicInfo.ChangeTime;
    SrvNetworkOpenInformation->AllocationSize = FileStandardInfo.AllocationSize;
    SrvNetworkOpenInformation->EndOfFile      = FileStandardInfo.EndOfFile;
    SrvNetworkOpenInformation->FileAttributes = FileBasicInfo.FileAttributes;

    if ( QueryEaSize ) {

            FILE_EA_INFORMATION fileEaInformation;

            status = NtQueryInformationFile(
                         FileHandle,
                         &ioStatus,
                         (PVOID)&fileEaInformation,
                         sizeof(FILE_EA_INFORMATION),
                         FileEaInformation
                         );

            if ( !NT_SUCCESS(status) ) {
                INTERNAL_ERROR(
                    ERROR_LEVEL_UNEXPECTED,
                    "SrvQueryInformationFile: NtQueryInformationFile "
                        "(EA information) failed: %X",
                     status,
                     NULL
                     );

                SrvLogServiceFailure( SRV_SVC_NT_QUERY_INFO_FILE, status );
                return status;
            }

            SrvNetworkOpenInformation->EaSize = fileEaInformation.EaSize;
    }

    return(status);

} // SrvQueryNetworkOpenInformation
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\srv\lock.h ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    lock.h

Abstract:

    This module defines types and functions for the LAN Manager server
    FSP's lock package.  This package began as a modification and
    streamlining of the executive resource package -- it allowed
    recursive acquisition, but didn't provide shared locks.  Later,
    debugging support in the form of level checking was added.

    Coming full circle, the package now serves as a wrapper around the
    real resource package.  It simply provides debugging support.  The
    reasons for reverting to using resources include:

    1) The resource package now supports recursive acquisition.

    2) There are a couple of places in the server where shared access
       is desirable.

    3) The resource package has a "no-wait" option that disables waiting
       for a lock when someone else owns it.  This feature is useful to
       the server FSD.

Author:

    Chuck Lenzmeier (chuckl) 29-Nov-1989
        A modification of Gary Kimura's resource package.  See lock.c.
    David Treadwell (davidtr)

    Chuck Lenzmeier (chuckl)  5-Apr-1991
        Revert to using resource package.

Environment:

    Kernel mode only, LAN Manager server FSP and FSD.

Revision History:

--*/

#ifndef _LOCK_
#define _LOCK_

//#include <ntos.h>

//
// Structure containing global spin locks.  Used to isolate each spin
// lock into its own cache line.
//

typedef struct _SRV_GLOBAL_SPIN_LOCKS {
    ULONG Reserved1[7];
    KSPIN_LOCK Fsd;
    ULONG Reserved2[7];
    struct {
        KSPIN_LOCK Lock;
        ULONG Reserved3[7];
    } Endpoint[ENDPOINT_LOCK_COUNT];
    KSPIN_LOCK Statistics;
    ULONG Reserved4[7];
    KSPIN_LOCK Timer;
    ULONG Reserved5[7];
#if SRVDBG || SRVDBG_HANDLES
    KSPIN_LOCK Debug;
    ULONG Reserved6[7];
#endif
} SRV_GLOBAL_SPIN_LOCKS, *PSRV_GLOBAL_SPIN_LOCKS;

//
// Macros for accessing spin locks.
//

#define ACQUIRE_SPIN_LOCK(lock,irql) {          \
    PAGED_CODE_CHECK();                         \
    ExAcquireSpinLock( (lock), (irql) );        \
    }
#define RELEASE_SPIN_LOCK(lock,irql) {          \
    PAGED_CODE_CHECK();                         \
    ExReleaseSpinLock( (lock), (irql) );        \
    }
#define ACQUIRE_DPC_SPIN_LOCK(lock) {           \
    PAGED_CODE_CHECK();                         \
    ExAcquireSpinLockAtDpcLevel( (lock) );      \
    }
#define RELEASE_DPC_SPIN_LOCK(lock) {           \
    PAGED_CODE_CHECK();                         \
    ExReleaseSpinLockFromDpcLevel( (lock) );    \
    }

#define INITIALIZE_SPIN_LOCK(lock) KeInitializeSpinLock( lock );

#define GLOBAL_SPIN_LOCK(lock) SrvGlobalSpinLocks.lock
#define ENDPOINT_SPIN_LOCK(index) SrvGlobalSpinLocks.Endpoint[index].Lock

#define INITIALIZE_GLOBAL_SPIN_LOCK(lock) INITIALIZE_SPIN_LOCK( &GLOBAL_SPIN_LOCK(lock) )

#define ACQUIRE_GLOBAL_SPIN_LOCK(lock,irql) ACQUIRE_SPIN_LOCK( &GLOBAL_SPIN_LOCK(lock), (irql) )
#define RELEASE_GLOBAL_SPIN_LOCK(lock,irql) RELEASE_SPIN_LOCK( &GLOBAL_SPIN_LOCK(lock), (irql) )
#define ACQUIRE_DPC_GLOBAL_SPIN_LOCK(lock)  ACQUIRE_DPC_SPIN_LOCK( &GLOBAL_SPIN_LOCK(lock) )
#define RELEASE_DPC_GLOBAL_SPIN_LOCK(lock)  RELEASE_DPC_SPIN_LOCK( &GLOBAL_SPIN_LOCK(lock) )

//
// Macros for initializing, deleting, acquiring, and releasing locks.
//

#if !SRVDBG_LOCK

//
// When debugging is disabled, the lock macros simply equate to calls to
// the corresponding resource package functions.
//

#define INITIALIZE_LOCK( lock, level, name ) ExInitializeResourceLite( (lock) )
#define DELETE_LOCK( lock ) ExDeleteResourceLite( (lock) )

#define ACQUIRE_LOCK( lock ) \
                    ExAcquireResourceExclusiveLite( (lock), TRUE )
#define ACQUIRE_LOCK_NO_WAIT( lock ) \
                    ExAcquireResourceExclusiveLite( (lock), FALSE )

#define ACQUIRE_LOCK_SHARED( lock ) \
                    ExAcquireResourceSharedLite( (lock), TRUE )
#define ACQUIRE_LOCK_SHARED_NO_WAIT( lock ) \
                    ExAcquireResourceSharedLite( (lock), FALSE )

#define RELEASE_LOCK(lock) ExReleaseResourceLite( (lock) )

#define LOCK_NUMBER_OF_ACTIVE( lock ) ((lock)->ActiveCount)

#else // !SRVDBG_LOCK

//
// When debugging is enabled, the lock macros equate to calls to
// functions in the server.  These functions are implemented in lock.c.
//

#define INITIALIZE_LOCK( lock, level, name ) \
                    SrvInitializeLock( (lock), (level), (name) )
#define DELETE_LOCK( lock ) SrvDeleteLock( (lock) )

#define ACQUIRE_LOCK( lock ) \
                    SrvAcquireLock( (lock), TRUE, TRUE )
#define ACQUIRE_LOCK_NO_WAIT( lock ) \
                    SrvAcquireLock( (lock), FALSE, TRUE )

#define ACQUIRE_LOCK_SHARED( lock ) \
                    SrvAcquireLock( (lock), TRUE, FALSE )
#define ACQUIRE_LOCK_SHARED_NO_WAIT( lock ) \
                    SrvAcquireLock( (lock), FALSE, FALSE )

#define RELEASE_LOCK( lock ) SrvReleaseLock( (lock) )

#define LOCK_NUMBER_OF_ACTIVE( lock ) ((lock)->Resource.ActiveCount)

#define LOCK_NAME( lock ) ((lock)->Header.LockName)
#define LOCK_LEVEL( lock ) ((lock)->Header.LockLevel)
#define LOCK_THREAD_LIST( lock ) (&((lock)->Header.ThreadListEntry))

#endif // else !SRVDBG_LOCK


#if !SRVDBG_LOCK

//
// When debugging is disabled, a server lock is identical to an
// executive resource.
//

typedef ERESOURCE SRV_LOCK, *PSRV_LOCK;

#define RESOURCE_OF(_l_) (_l_)

#else // !SRVDBG_LOCK

//
// SRV_LOCK_HEADER is a structure that contains debugging information
// used by the server lock package.  Server locks contain a
// SRV_LOCK_HEADER.
//

typedef struct _SRV_LOCK_HEADER {

    //
    // To prevent deadlocks, locks are assigned level numbers.  If a
    // thread holds a lock with level N, it may only acquire new locks
    // with a level greater then N.  Level numbers are assigned during
    // lock initialization.
    //
    // *** Due to the problems involved in retaining the information
    //     necessary to do level checking for shared locks, the lock
    //     package only does level checking for exclusive locks.
    //

    ULONG LockLevel;

    //
    // A doubly-linked list of all the locks owned by a thread is stored
    // in a thread's TEB.  The list is in order of lock level (from
    // highest to lowest), which is also, by definition of lock levels,
    // the order in which the thread acquired the locks.  This allows
    // the thread to release the locks in any order while maintaining
    // easy access to the highest-level lock that the thread owns,
    // thereby providing a mechanism for ensuring that locks are
    // acquired in increasing order.
    //

    LIST_ENTRY ThreadListEntry;

    //
    // The symbolic name of the lock is used in DbgPrint calls.
    //

    PSZ LockName;

} SRV_LOCK_HEADER, *PSRV_LOCK_HEADER;

//
// When debugging is enabled, a server lock is a wrapper around an
// executive resource.
//

typedef struct _SRV_LOCK {

    //
    // The SRV_LOCK_HEADER must appear first!
    //

    SRV_LOCK_HEADER Header;

    //
    // The actual "lock" is maintained by the resource package.
    //

    ERESOURCE Resource;

} SRV_LOCK, *PSRV_LOCK;

#define RESOURCE_OF(_sl_) (_sl_).Resource

//
// Lock functions used when debugging.
//

VOID
SrvInitializeLock(
    IN PSRV_LOCK Lock,
    IN ULONG LockLevel,
    IN PSZ LockName
    );

VOID
SrvDeleteLock (
    IN PSRV_LOCK Lock
    );

BOOLEAN
SrvAcquireLock(
    IN PSRV_LOCK Lock,
    IN BOOLEAN Wait,
    IN BOOLEAN Exclusive
    );

VOID
SrvReleaseLock(
    IN PSRV_LOCK Lock
    );

//
// Macros that define locations in the UserReserved field of the TEB
// where lock level information is stored.
//

#define SRV_TEB_LOCK_LIST 0
#define SRV_TEB_LOCK_INIT 2
#define SRV_TEB_USER_SIZE (3 * sizeof(ULONG))

//
// Max value for lock levels is 0x7FFFFFFF.
//
// Levels for locks used in the server.  The following must be true:
//
// EndpointLock must be lower than ConnectionLock (really
// connection->Lock) because SrvCloseConnectionsFromClient holds
// EndpointLock when it acquires ConnectionLock to check a connection's
// client name, and because a number of callers hold EndpointLock when
// they call SrvCloseConnection, which acquires ConnectionLock.  Note
// also that SrvDeleteServedNet and TerminateServer hold EndpointLock
// when they call SrvCloseEndpoint; any attempt to change
// SrvCloseEndpoint must take this into account.
// ExamineAndProcessConnections also depends on this ordering.
//
// EndpointLock must be lower than MfcbListLock and MfcbLock because
// EndpointLock is held while stopping the server and closing
// connections, thereby closing files on the connections.
//
// ShareLock must be lower than ConnectionLock because
// SrvCloseTreeConnectsOnShare holds ShareLock when it calls
// SrvCloseTreeConnect.  Note that SrvSmbTreeConnect and
// SrvSmbTreeConnectAndX depend on this ordering, because they take out
// both locks concurrently.
//
// Similarly, ShareLock must be lower than MfcbListLock and MfcbLock
// because SrvCloseTreeConnectsOnShare holds ShareLock when it calls
// SrvCloseRfcbsOnTree.
//
// MfcbListLock must be lower than MfcbLock (really mfcb->Lock) because
// SrvMoveFile and DoDelete hold MfcbListLock to find an MFCB, then take
// MfcbLock before releasing MfcbListLock.
//
// MfcbLock must be lower than OrderedListLock and ConnectionLock
// because CompleteOpen acquires these locks while holding the MfcbLock.
//
// OrderedListLock must be lower than ConnectionLock because
// SrvFindEntryInOrderedList holds the ordered list lock when in calls
// the check-and-reference routine for sessions and tree connects.  For
// other ordered lists, this is not a problem, because the other lists
// are either protected the same locks that the check-and-reference
// routine uses (endpoints, connections, and shares), or the
// check-and-reference routine uses a spin lock (files).  Note also that
// OrderedListLock and ConnectionLock are acquired concurrently and in
// the proper order in SrvSmbSessionSetupAndX, SrvSmbTreeConnect, and
// CompleteOpen.
//
// *** WARNING:  If the ordered RFCB list (SrvRfcbList) or the ordered
//     session list (SrvSessionList) are changed to use a lock other
//     than SrvOrderedListLock, the above requirement may change, and
//     the routines listed above may need to change.  Changing other
//     ordered lists that currently use some other global lock also may
//     change the requirements.
//
// DebugLock must be higher than MfcbLock because CompleteOpen holds
// the MfcbLock when it allocates the LFCB and RFCB.  The DebugLock
// is held for all memory allocations.  Note that because of the
// way DebugLock is currently used, it is impossible to acquire other
// locks while holding DebugLock.
//
// ConnectionLock must be higher than SearchLock because the scavenger
// thread holds the search lock while walking the search list looking
// for search blocks to time out, and if a block to time out is found it
// closes the search which acquires the the connection lock in order to
// dereference the session in by the search block.
//
// EndpointLock must be higher than SearchLock because in the above
// scenario, SrvDereferenceSession may call SrvDereferenceConnection
// which acquires the endpoint lock.
//
// SearchLock must be at a higher level than ShareLock because
// SrvCloseShare gets the ShareLock, but SrvCloseSessionsOnTreeConnect
// aquires the SearchLock.
//
// CommDeviceLock must be higher than MfcbLock because DoCommDeviceOpen
// acquires the CommDeviceLock while holding MfcbLock.
//
// OplockListLock needs to be lower than ShareLock as the server may
// need to call SrvDereferenceRfcb while holding the OplockListLock.
// This routine may call SrvDereferenceLfcb which may call
// SrvDereferenceShare which acquires the ShareLock.
//
// This is a summary of the above (the top lock is acquired first and
// therefore must have a lower level):
//
//  endp  endp   endp  share  share  share  mfcbl  mfcb  mfcb  order  mfcb
//  conn  mfcbl  mfcb  conn   mfcbl  mfcb   mfcb   order conn  conn   debug
//
//  search  search  share    oplock  oplock
//  conn    endp    search   mfcb    share
//
// Merging this, we find the following "threads" of requirements:
//
//    share   mfcb   mfcb   oplock
//    search  debug  comm   share
//    endp
//    mfcbl
//    mfcb
//    order
//    conn
//
// The following locks are not affected by the above requirements:
//
//    configuration
//    smbbufferlist
//    Connection->LicenseLock
//
// The levels of all of these locks are made equal and high in an
// attempt to find level requirements not listed above.
//

#define OPLOCK_LIST_LOCK_LEVEL                  (ULONG)0x00000800
#define SHARE_LOCK_LEVEL                        (ULONG)0x00000900
#define SEARCH_LOCK_LEVEL                       (ULONG)0x00001000
#define ENDPOINT_LOCK_LEVEL                     (ULONG)0x00002000
#define MFCB_LIST_LOCK_LEVEL                    (ULONG)0x00003000
#define MFCB_LOCK_LEVEL                         (ULONG)0x00004000
#define COMM_DEVICE_LOCK_LEVEL                  (ULONG)0x00005000
#define ORDERED_LIST_LOCK_LEVEL                 (ULONG)0x00006000
#define CONNECTION_LOCK_LEVEL                   (ULONG)0x00007000
#define CONFIGURATION_LOCK_LEVEL                (ULONG)0x00010000
#define UNLOCKABLE_CODE_LOCK_LEVEL              (ULONG)0x00010000
#define STARTUPSHUTDOWN_LOCK_LEVEL              (ULONG)0x00020000
#define DEBUG_LOCK_LEVEL                        (ULONG)0x00050000
#define LICENSE_LOCK_LEVEL                      (ULONG)0x00100000
#define FCBLIST_LOCK_LEVEL                      (ULONG)0x00200000

#endif // else !SRVDBG_LOCK

#endif // ndef _LOCK_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\srv\lock.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    lock.c

Abstract:

    This module implements functions for the LAN Manager server FSP's
    lock package.  This package began as a modification and streamlining
    of the executive resource package -- it allowed recursive
    acquisition, but didn't provide shared locks.  Later, debugging
    support in the form of level checking was added.

    Coming full circle, the package now serves as a wrapper around the
    real resource package.  It simply provides debugging support.  The
    reasons for reverting to using resources include:

    1) The resource package now supports recursive acquisition.

    2) There are a couple of places in the server where shared access
       is desirable.

    3) The resource package has a "no-wait" option that disables waiting
       for a lock when someone else owns it.  This feature is useful to
       the server FSD.

Author:

    Chuck Lenzmeier (chuckl) 29-Nov-1989
        A modification of Gary Kimura's resource.c.  This version does
        not support shared ownership, only exclusive ownership.  Support
        for recursive ownership has been added.
    David Treadwell (davidtr)

    Chuck Lenzmeier (chuckl)  5-Apr-1991
        Revert to using resource package.

Environment:

    Kernel mode only, LAN Manager server FSP and FSD.

Revision History:

--*/

#include "precomp.h"
#include "lock.tmh"
#pragma hdrstop

#if SRVDBG_LOCK

#define BugCheckFileId SRV_FILE_LOCK

//
// *** This entire module is conditionalized away when SRVDBG_LOCK is off.
//

#ifdef ALLOC_PRAGMA
#pragma alloc_text( PAGE, SrvInitializeLock )
#pragma alloc_text( PAGE, SrvDeleteLock )
#pragma alloc_text( PAGE, SrvReleaseLock )
#endif
#if 0
NOT PAGEABLE -- SrvAcquireLock
NOT PAGEABLE -- SrvCheckListIntegrity
NOT PAGEABLE -- SrvIsEntryInList
NOT PAGEABLE -- SrvIsEntryNotInList
#endif

//
// Lock Level Semantics:
//
// Lock levels are used for server lock debugging as an aid in
// preventing deadlocks.  A deadlock may occur if two (or more) threads
// attempt to acquire two (or more) locks in a different order.  For
// example, suppose that there are two threads, 0 and 1, and two locks,
// A and B.  Then suppose the following happens:
//
// - thread 0 acquires lock A
// - thread 1 acquires lock B
// - thread 0 attempts to acquire lock B, gets blocked
// - thread 1 attempts to acquire lock A, gets blocked.
//
// This results in deadlock, where all threads are blocked and cannot
// become unblocked.  To prevent it, all threads must acquire locks in
// the same order.  In the above example, if we had the rule that lock A
// must be acquired before lock B, then thread 1 would have blocked
// while attempting to acquire lock A, but thread 0 would have been able
// to acquire lock B and completed its work.
//
// This rule is implemented generally in the server by lock levels.  The
// lock levels are set up such that lower-level locks are acquired
// first, then higher level locks.  An attempt to acquire locks out of
// order will be caught during debugging.  The rules are as follows:
//
// - A lock's level is assigned during initialization.
//
// - A thread may acquire any lock with a level greater than the level
//   of the highest held exclusive lock, but an attempt to acquire a
//   lock with a level equal to less than the highest lock will fail.
//   Note that full level checking is _not_ done for shared locks,
//   because of the difficulty of trying to retain information about the
//   number of times multiple threads have obtained a given lock for
//   shared access.
//
// - Recursive acquisitions of locks are legal, even if there are
//   intervening lock acquisitions.  For example, this is legal:
//       thread acquires lock A
//       thread acquires lock B
//       thread recursively acquires lock A
//
// - Locks may be released in any order.
//
// Lock debugging is active only when debugging is turned on.
//

#define HAS_TEB(_teb) ((BOOLEAN)(((ULONG)(_teb) <= MM_HIGHEST_USER_ADDRESS) ? FALSE : MmIsNonPagedSystemAddressValid(_teb)))

#define SrvCurrentTeb( ) ((PTEB)(KeGetCurrentThread( )->Teb))

#define SrvTebLockList( ) \
    ((PLIST_ENTRY)&(SrvCurrentTeb( )->UserReserved[SRV_TEB_LOCK_LIST]))

#define SrvThreadLockAddress( )                                               \
    ( IsListEmpty( SrvTebLockList( ) ) ? 0 : CONTAINING_RECORD(               \
                                                 SrvTebLockList( )->Flink,    \
                                                 SRV_LOCK,                    \
                                                 Header.ThreadListEntry       \
                                                 ) )

#define SrvThreadLockLevel( )                                                 \
    ( IsListEmpty( SrvTebLockList( ) ) ? 0 : CONTAINING_RECORD(               \
                                                 SrvTebLockList( )->Flink,    \
                                                 SRV_LOCK,                    \
                                                 Header.ThreadListEntry       \
                                                 )->Header.LockLevel )

#define SrvThreadLockName( )                                                  \
    ( IsListEmpty( SrvTebLockList( ) ) ? "none" : CONTAINING_RECORD(          \
                                                 SrvTebLockList( )->Flink,    \
                                                 SRV_LOCK,                    \
                                                 Header.ThreadListEntry       \
                                                 )->Header.LockName )

KSPIN_LOCK LockSpinLock = {0};
BOOLEAN LockSpinLockInitialized = FALSE;

//
// Forward declarations.
//

#define MAX_LOCKS_HELD 15


VOID
SrvInitializeLock(
    IN PSRV_LOCK Lock,
    IN ULONG LockLevel,
    IN PSZ LockName
    )

/*++

Routine Description:

    This routine initializes the input lock variable.

Arguments:

    Lock - Supplies the lock variable being initialized

    LockLevel - Supplies the level of the lock

    LockName - Supplies the name of the lock

Return Value:

    None.

--*/

{
    PAGED_CODE( );

    if ( !LockSpinLockInitialized ) {
        LockSpinLockInitialized = TRUE;
        INITIALIZE_SPIN_LOCK( LockSpinLock );
    }

    //
    // Initialize the executive resource.
    //

    ExInitializeResource( &Lock->Resource );

    //
    // Initialize the lock level.  This is used to determine whether a
    // thread may acquire the lock.  Save the lock name.
    //

    LOCK_LEVEL( Lock ) = LockLevel;

    LOCK_NAME( Lock ) = LockName;

    IF_DEBUG(LOCKS) {
        SrvPrint3( "Initialized %s(%lx, L%lx)\n",
                    LOCK_NAME( Lock ), Lock, LOCK_LEVEL( Lock ) );
    }

    return;

} // SrvInitializeLock


VOID
SrvDeleteLock (
    IN PSRV_LOCK Lock
    )

/*++

Routine Description:

    This routine deletes (i.e., uninitializes) a lock variable.

Arguments:

    Lock - Supplies the lock variable being deleted

Return Value:

    None.

--*/

{
    PAGED_CODE( );

    //
    // Make sure the lock is unowned.
    //

    if ( LOCK_NUMBER_OF_ACTIVE( Lock ) != 0 ) {

        IF_DEBUG(ERRORS) {
            SrvPrint1( "SrvDeleteLock: Thread %d\n", KeGetCurrentThread( ) );
        }

        //
        // This internal error bugchecks the system.
        //

        INTERNAL_ERROR(
            ERROR_LEVEL_IMPOSSIBLE,
            "SrvDeleteLock: Attempt to delete owned lock %s(%lx)",
            LOCK_NAME( Lock ),
            Lock
            );

    }

    //
    // Delete the resource.
    //

    ExDeleteResource( &Lock->Resource );

    return;

} // SrvDeleteLock


BOOLEAN
SrvAcquireLock(
    IN PSRV_LOCK Lock,
    IN BOOLEAN Wait,
    IN BOOLEAN Exclusive
    )

/*++

Routine Description:

    The routine acquires a lock.

Arguments:

    Lock - Supplies the lock to acquire

    Wait - Indicates whether the caller wants to wait for the resource
        if it is already owned

    Exclusive - Indicates whether exlusive or shared access is desired

Return Value:

    BOOLEAN - Indicates whether the lock was acquired.  This will always
        be TRUE if Wait is TRUE.

--*/

{
    PKTHREAD currentThread;
    PTEB currentTeb;
    BOOLEAN hasTeb;
    ULONG threadLockLevel;
    BOOLEAN lockAcquired;
    KIRQL oldIrql;

    currentThread = (PKTHREAD)ExGetCurrentResourceThread( );
    currentTeb = SrvCurrentTeb( );
    hasTeb = HAS_TEB(currentTeb);

    //
    // Make sure that we are at an IRQL lower than DISPATCH_LEVEL, if
    // Wait is TRUE.  We cannot wait to acquire a lock at that IRQL or
    // above.
    //

    ASSERT( !Wait || (KeGetCurrentIrql( ) < DISPATCH_LEVEL) );

    //
    // If this thread does not have a nonpaged TEB, do not do lock-level
    // debugging.  (We might be at DPC level, so we can't take page
    // faults.)
    //

    if ( hasTeb ) {

        //
        // Make sure that this thread has been initialized for lock
        // debugging.  If not, initialize it.
        //

        ACQUIRE_SPIN_LOCK( LockSpinLock, &oldIrql );
        if ( (ULONG)currentTeb->UserReserved[SRV_TEB_LOCK_INIT] !=
                                                        0xbabababa ) {
            PLIST_ENTRY tebLockList = SrvTebLockList( );
            InitializeListHead( tebLockList );
            currentTeb->UserReserved[SRV_TEB_LOCK_INIT] = (PVOID)0xbabababa;
        }
        RELEASE_SPIN_LOCK( LockSpinLock, oldIrql );

        //
        // Make sure that the list of locks in the TEB is consistent.
        //

        SrvCheckListIntegrity( SrvTebLockList( ), MAX_LOCKS_HELD );

        //
        // The "lock level" of this thread is the highest level of the
        // locks currently held exclusively.  If this thread holds no
        // locks, the lock level of the thread is 0 and it can acquire
        // any lock.
        //

        threadLockLevel = SrvThreadLockLevel( );

        //
        // Make sure that the lock the thread is attempting to acquire
        // has a higher level than the last-acquired exclusive lock.
        // Note that a recursive exclusive acquisition of a lock should
        // succeed, even if a different, higher-level lock has been
        // acquired since the lock was originally acquired.  Shared
        // acquisition of a lock that is already held exclusively must
        // fail.
        //
        // *** We do NOT make this check if the caller isn't going to
        //     wait for the lock, because no-wait acquisitions cannot
        //     actually induce deadlock.  The server FSD does this at
        //     DPC level, potentially having interrupted a server FSP
        //     thread that holds a higher-level lock.
        //

        if ( Wait &&
             (LOCK_LEVEL( Lock ) <= threadLockLevel) &&
             (!Exclusive ||
              !ExIsResourceAcquiredExclusive( &Lock->Resource )) ) {

            SrvPrint4( "Thread %lx, last lock %s(%lx, L%lx) attempted to ",
                        currentThread,
                        SrvThreadLockName( ), SrvThreadLockAddress( ),
                        threadLockLevel );
            SrvPrint4( "acquire %s(%lx, L%lx) for %s access.\n",
                        LOCK_NAME( Lock ), Lock, LOCK_LEVEL( Lock ),
                        Exclusive ? "exclusive" : "shared" );
            DbgBreakPoint( );

        }

    }

    //
    // Acquire the lock.
    //

    if ( Exclusive ) {
        lockAcquired = ExAcquireResourceExclusive( &Lock->Resource, Wait );
    } else {
        lockAcquired = ExAcquireResourceShared( &Lock->Resource, Wait );
    }

    //
    // If the lock could not be acquired (Wait == FALSE), print a debug
    // message.
    //

    if ( !lockAcquired ) {

        IF_DEBUG(LOCKS) {
            SrvPrint4( "%s(%lx, L%lx) no-wait %s acquistion ",
                        LOCK_NAME( Lock ), Lock, LOCK_LEVEL( Lock ),
                        Exclusive ? "exclusive" : "shared" );
            SrvPrint1( "by thread %lx failed\n", currentThread );
        }

    } else if ( !Exclusive ) {

        //
        // For shared locks, we don't retain any information about
        // the fact that they're owned by this thread.
        //

        IF_DEBUG(LOCKS) {
            PSZ name = hasTeb ? SrvThreadLockName( ) : "n/a";
            PVOID address = hasTeb ? SrvThreadLockAddress( ) : 0;
            ULONG level = hasTeb ? threadLockLevel : (ULONG)-1;
            SrvPrint4( "%s(%lx, L%lx) acquired shared by thread %lx, ",
                        LOCK_NAME( Lock ), Lock, LOCK_LEVEL( Lock ),
                        currentThread );
            SrvPrint3( "last lock %s(%lx L%lx)\n", name, address, level );
        }

    } else {

        //
        // The thread acquired the lock for exclusive access.
        //

        if ( LOCK_NUMBER_OF_ACTIVE( Lock ) == 1 ) {

            //
            // This is the first time the thread acquired the lock for
            // exclusive access.  Update the thread's lock state.
            //

            IF_DEBUG(LOCKS) {
                PSZ name = hasTeb ? SrvThreadLockName( ) : "n/a";
                PVOID address = hasTeb ? SrvThreadLockAddress( ) : 0;
                ULONG level = hasTeb ? threadLockLevel : (ULONG)-1;
                SrvPrint4( "%s(%lx, L%lx) acquired exclusive by thread %lx, ",
                            LOCK_NAME( Lock ), Lock, LOCK_LEVEL( Lock ),
                            currentThread );
                SrvPrint3( "last lock %s(%lx L%lx)\n", name, address, level );
            }

            if ( hasTeb ) {

                //
                // Insert the lock on the thread's list of locks.
                //

                ExInterlockedInsertHeadList(
                    SrvTebLockList( ),
                    LOCK_THREAD_LIST( Lock ),
                    &LockSpinLock
                    );

            }

        } else {

            //
            // This is a recursive acquisition of the lock.
            //

            IF_DEBUG(LOCKS) {
                SrvPrint4( "%s(%lx, L%lx) reacquired by thread %lx; ",
                            LOCK_NAME( Lock ), Lock, LOCK_LEVEL( Lock ),
                            currentThread );
                SrvPrint1( "count %ld\n", LOCK_NUMBER_OF_ACTIVE( Lock ) );
            }

        }

    }

    return lockAcquired;

} // SrvAcquireLock


VOID
SrvReleaseLock(
    IN PSRV_LOCK Lock
    )

/*++

Routine Description:

    This routine releases a lock.

Arguments:

    Lock - Supplies the lock to release

Return Value:

    None.

--*/

{
    PKTHREAD currentThread;
    PTEB currentTeb;
    BOOLEAN hasTeb;

    PAGED_CODE( );

    currentThread = (PKTHREAD)ExGetCurrentResourceThread( );
    currentTeb = SrvCurrentTeb( );
    hasTeb = HAS_TEB(currentTeb);

    //
    // Make sure the lock is really owned by the current thread.
    //

    if ( LOCK_NUMBER_OF_ACTIVE( Lock ) == 0 ) {

        // !!! Should crash server on internal error here.

        SrvPrint3( "Thread %lx releasing unowned lock %s(%lx)\n",
                    currentThread, LOCK_NAME( Lock ), Lock );
        DbgBreakPoint( );

    } else if ( (Lock->Resource.Flag & ResourceOwnedExclusive) &&
                !ExIsResourceAcquiredExclusive(&Lock->Resource) ) {

        // !!! Should crash server on internal error here.

        SrvPrint4( "Thread %lx releasing lock %s(%lx) owned by "
                    "thread %lx\n",
                    currentThread, LOCK_NAME( Lock ), Lock,
                    Lock->Resource.InitialOwnerThreads[0] );
        DbgBreakPoint( );

    } else if ( !(Lock->Resource.Flag & ResourceOwnedExclusive) ) {

        //
        // The thread is releasing shared access to the lock.
        //

        IF_DEBUG(LOCKS) {
            SrvPrint4( "%s(%lx, L%lx) released shared by thread %lx\n",
                          LOCK_NAME( Lock ), Lock, LOCK_LEVEL( Lock ),
                          currentThread );
        }

    } else if ( LOCK_NUMBER_OF_ACTIVE( Lock ) == 1 ) {

        //
        // The thread is fully releasing exclusive access to the lock.
        //

        if ( hasTeb ) {

            //
            // Remove the lock from the list of locks held by this
            // thread.
            //

            ExInterlockedRemoveHeadList(
                LOCK_THREAD_LIST( Lock )->Blink,
                &LockSpinLock
                );
            LOCK_THREAD_LIST( Lock )->Flink = NULL;
            LOCK_THREAD_LIST( Lock )->Blink = NULL;

            //
            // Make sure that the list of locks in the TEB is consistent.
            //

            SrvCheckListIntegrity( SrvTebLockList( ), MAX_LOCKS_HELD );

        }

        IF_DEBUG(LOCKS) {
            PSZ name = hasTeb ? SrvThreadLockName( ) : "n/a";
            PVOID address = hasTeb ? SrvThreadLockAddress( ) : 0;
            ULONG level = hasTeb ? SrvThreadLockLevel( ) : (ULONG)-1;
            SrvPrint4( "%s(%lx, L%lx) released by thread %lx, ",
                          LOCK_NAME( Lock ), Lock, LOCK_LEVEL( Lock ),
                          currentThread );
            SrvPrint3( "new last lock %s(%lx L%lx)\n", name, address, level );
        }

    } else {

        //
        // The thread is partially releasing exclusive access to the
        // lock.
        //

        IF_DEBUG(LOCKS) {
            SrvPrint4( "%s(%lx, L%lx) semireleased by thread %lx; ",
                        LOCK_NAME( Lock ), Lock, LOCK_LEVEL( Lock ),
                        currentThread );
            SrvPrint1( "new count %ld\n", LOCK_NUMBER_OF_ACTIVE( Lock ) - 1 );
        }

    }

    //
    // Now actually do the release.
    //

    ExReleaseResource( &Lock->Resource );

    return;

} // SrvReleaseLock

#endif // SRVDBG_LIST


#if SRVDBG_LIST || SRVDBG_LOCK

ULONG
SrvCheckListIntegrity (
    IN PLIST_ENTRY ListHead,
    IN ULONG MaxEntries
    )

/*++

Routine Description:

    This debug routine checks the integrity of a doubly-linked list by
    walking the list forward and backward.  If the number of elements is
    different in either direction, or there are too many entries in the
    list, execution is stopped.

    *** It is the responsibility of the calling routine to do any
        necessary synchronization.

Arguments:

    ListHead - a pointer to the head of the list.

    MaxEntries - if the number of entries in the list exceeds this
        number, breakpoint.

Return Value:

    ULONG - the number of entries in the list.

--*/

{
    PLIST_ENTRY current;
    ULONG entriesSoFar;
    ULONG flinkEntries;

    for ( current = ListHead->Flink, entriesSoFar = 0;
          current != ListHead;
          current = current->Flink ) {

        if ( ++entriesSoFar >= MaxEntries ) {
            SrvPrint2( "Seen %ld entries in list at %lx\n",
                        entriesSoFar, ListHead );
            DbgBreakPoint( );
        }
    }

    flinkEntries = entriesSoFar;

    for ( current = ListHead->Blink, entriesSoFar = 0;
          current != ListHead;
          current = current->Blink ) {

        if ( ++entriesSoFar >= MaxEntries ) {
            SrvPrint2( "Seen %ld entries in list at %lx\n",
                        entriesSoFar, ListHead );
            DbgBreakPoint( );
        }
    }

    if ( flinkEntries != entriesSoFar ) {
        SrvPrint3( "In list %lx, Flink entries: %ld, Blink entries: %lx\n",
                      ListHead, flinkEntries, entriesSoFar );
        DbgBreakPoint( );
    }

    return entriesSoFar;

} // SrvCheckListIntegrity

#endif // SRVDBG_LIST || SRVDBG_LOCK


#if SRVDBG_LIST

VOID
SrvIsEntryInList (
    IN PLIST_ENTRY ListHead,
    IN PLIST_ENTRY ListEntry
    )

/*++

Routine Description:

    This debug routine determines whether the specified list entry is
    contained within the list.  If not, execution is stopped.  This is
    meant to be called before removing an entry from a list.

    *** It is the responsibility of the calling routine to do any
        necessary synchronization.

Arguments:

    ListHead - a pointer to the head of the list.

    ListEntry - a pointer to the entry to check.

Return Value:

    None.

--*/

{
    PLIST_ENTRY checkEntry;

    //
    // Walk the list.  If we find the entry we're looking for, quit.
    //

    for ( checkEntry = ListHead->Flink;
          checkEntry != ListHead;
          checkEntry = checkEntry->Flink ) {

        if ( checkEntry == ListEntry ) {
            return;
        }

        if ( checkEntry == ListEntry ) {
            SrvPrint2( "Entry at %lx supposedly in list at %lx but list is "
                      "circular.", ListEntry, ListHead );
        }
    }

    //
    // If we got here without returning, then the entry is not in the
    // list and something has gone wrong.
    //

    SrvPrint2( "SrvIsEntryInList: entry at %lx not found in list at %lx\n",
                  ListEntry, ListHead );
    DbgBreakPoint( );

    return;

} // SrvIsEntryInList


VOID
SrvIsEntryNotInList (
    IN PLIST_ENTRY ListHead,
    IN PLIST_ENTRY ListEntry
    )

/*++

Routine Description:

    This debug routine determines whether the specified list entry is
    contained within the list.  If it is, execution is stopped.  This is
    meant to be called before inserting an entry in a list.

    *** It is the responsibility of the calling routine to do any
        necessary synchronization.

Arguments:

    ListHead - a pointer to the head of the list.

    ListEntry - a pointer to the entry to check.

Return Value:

    None.

--*/

{
    PLIST_ENTRY checkEntry;

    //
    // Walk the list.  If we find the entry we're looking for, break.
    //

    for ( checkEntry = ListHead->Flink;
          checkEntry != ListHead;
          checkEntry = checkEntry->Flink ) {

        if ( checkEntry == ListEntry ) {

            SrvPrint2( "SrvIsEntryNotInList: entry at %lx found in list "
                        "at %lx\n", ListEntry, ListHead );
            DbgBreakPoint( );

        }

    }

    //
    // If we got here without returning, then the entry is not in the
    // list, so we can return.
    //

    return;

} // SrvIsEntryNotInList

#endif // SRVDBG_LIST
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\srv\lockcode.c ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    lockcode.c

Abstract:

Author:

    Chuck Lenzmeier (chuckl) 30-Jan-1994

Revision History:

--*/

#include "precomp.h"
#include "lockcode.tmh"
#pragma hdrstop

#define BugCheckFileId SRV_FILE_LOCKCODE

#ifdef ALLOC_PRAGMA
#pragma alloc_text( PAGE, SrvReferenceUnlockableCodeSection )
#pragma alloc_text( PAGE, SrvDereferenceUnlockableCodeSection )
#endif


VOID
SrvReferenceUnlockableCodeSection (
    IN ULONG CodeSection
    )
{
    PSECTION_DESCRIPTOR section = &SrvSectionInfo[CodeSection];
    ULONG oldCount;

    //
    // Lock the lockable code database.
    //

    ACQUIRE_LOCK( &SrvUnlockableCodeLock );

    //
    // Increment the reference count for the section.
    //

    oldCount = section->ReferenceCount++;

    if ( oldCount == 0 ) {

        //
        // This is the first reference to the section.  Lock it.
        //

        ASSERT( section->Handle == NULL );
        section->Handle = MmLockPagableCodeSection( section->Base );

    } else {

        //
        // This is not the first reference to the section.  The section
        // had better be locked!
        //

        ASSERT( section->Handle != NULL );

    }

    RELEASE_LOCK( &SrvUnlockableCodeLock );

    return;

} // SrvReferenceUnlockableCodeSection


VOID
SrvDereferenceUnlockableCodeSection (
    IN ULONG CodeSection
    )
{
    PSECTION_DESCRIPTOR section = &SrvSectionInfo[CodeSection];
    ULONG newCount;

    //
    // Lock the lockable code database.
    //

    ACQUIRE_LOCK( &SrvUnlockableCodeLock );

    ASSERT( section->Handle != NULL );

    //
    // Decrement the reference count for the section.
    //

    newCount = --section->ReferenceCount;

    if ( newCount == 0 ) {

        //
        // This is the last reference to the section.  Unlock it.
        //

        MmUnlockPagableImageSection( section->Handle );
        section->Handle = NULL;

    }

    RELEASE_LOCK( &SrvUnlockableCodeLock );

    return;

} // SrvDereferenceUnlockableCodeSection
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\srv\ipx.h ===
#define IPXSID_INDEX(id) (USHORT)( (id) & 0x0FFF )
#define IPXSID_SEQUENCE(id) (USHORT)( (id) >> 12 )
#define MAKE_IPXSID(index, sequence) (USHORT)( ((sequence) << 12) | (index) )
#define INCREMENT_IPXSID_SEQUENCE(id) (id) = (USHORT)(( (id) + 1 ) & 0xF);

//
// Name claim routine
//

NTSTATUS
SrvIpxClaimServerName (
    IN PENDPOINT Endpoint,
    IN PVOID NetbiosName
    );

//
// Transport Receive Datagram indication handlers
//

NTSTATUS
SrvIpxServerDatagramHandler (
    IN PVOID TdiEventContext,
    IN int SourceAddressLength,
    IN PVOID SourceAddress,
    IN int OptionsLength,
    IN PVOID Options,
    IN ULONG ReceiveDatagramFlags,
    IN ULONG BytesIndicated,
    IN ULONG BytesAvailable,
    OUT ULONG *BytesTaken,
    IN PVOID Tsdu,
    OUT PIRP *IoRequestPacket
    );

NTSTATUS
SrvIpxServerChainedDatagramHandler (
    IN PVOID TdiEventContext,
    IN int SourceAddressLength,
    IN PVOID SourceAddress,
    IN int OptionsLength,
    IN PVOID Options,
    IN ULONG ReceiveDatagramFlags,
    IN ULONG ReceiveDatagramLength,
    IN ULONG StartingOffset,
    IN PMDL Tsdu,
    IN PVOID TransportContext
    );

NTSTATUS
SrvIpxNameDatagramHandler (
    IN PVOID TdiEventContext,
    IN int SourceAddressLength,
    IN PVOID SourceAddress,
    IN int OptionsLength,
    IN PVOID Options,
    IN ULONG ReceiveDatagramFlags,
    IN ULONG BytesIndicated,
    IN ULONG BytesAvailable,
    OUT ULONG *BytesTaken,
    IN PVOID Tsdu,
    OUT PIRP *IoRequestPacket
    );

//
// Datagram send routine
//

VOID
SrvIpxStartSend (
    IN OUT PWORK_CONTEXT WorkContext,
    IN PIO_COMPLETION_ROUTINE SendCompletionRoutine
    );

//
// Routine called by IPX smart accelerator card when a read is complete
//
VOID
SrvIpxSmartCardReadComplete(
    IN PVOID    Context,
    IN PFILE_OBJECT FileObject,
    IN PMDL Mdl OPTIONAL,
    IN ULONG Length
);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\srv\network.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    network.c

Abstract:

    This module contains routines for interfacing the LAN Manager server
    to the network.

Author:

    Chuck Lenzmeier (chuckl)    7-Oct-1989

Environment:

    File System Process, kernel mode only

Revision History:

--*/

#include "precomp.h"
#include "network.tmh"
#pragma hdrstop

#include    <ntddip.h>
#include    <ntddtcp.h>
#include    <ipfltdrv.h>
#include    <tcpinfo.h>
#include    <tdiinfo.h>
#include    <nbtioctl.h>

#define BugCheckFileId SRV_FILE_NETWORK

//
// Local declarations
//

NTSTATUS
GetNetworkAddress (
    IN PENDPOINT Endpoint
    );

NTSTATUS
OpenEndpoint (
    OUT PENDPOINT *Endpoint,
    IN PUNICODE_STRING NetworkName,
    IN PUNICODE_STRING TransportName,
    IN PANSI_STRING TransportAddress,
    IN PUNICODE_STRING DomainName,
    IN ULONG         TransportAddFlags,
    IN BOOLEAN       AlternateEndpoint
    );

NTSTATUS
OpenNetbiosAddress (
    IN OUT PENDPOINT Endpoint,
    IN PVOID DeviceName,
    IN PVOID NetbiosName
    );

NTSTATUS
OpenNetbiosExAddress (
    IN OUT PENDPOINT Endpoint,
    IN PVOID DeviceName,
    IN PVOID NetbiosName
    );

NTSTATUS
OpenNonNetbiosAddress (
    IN OUT PENDPOINT Endpoint,
    IN PVOID DeviceName,
    IN PVOID NetbiosName
    );

NTSTATUS
OpenIpxSocket (
    OUT PHANDLE Handle,
    OUT PFILE_OBJECT *FileObject,
    OUT PDEVICE_OBJECT *DeviceObject,
    IN PVOID DeviceName,
    IN USHORT Socket
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text( PAGE, SrvAddServedNet )
#pragma alloc_text( PAGE, SrvDeleteServedNet )
#pragma alloc_text( PAGE, SrvDoDisconnect )
#pragma alloc_text( PAGE, GetNetworkAddress )
#pragma alloc_text( PAGE, OpenEndpoint )
#pragma alloc_text( PAGE, OpenNetbiosAddress )
#pragma alloc_text( PAGE, OpenNonNetbiosAddress )
#pragma alloc_text( PAGE, OpenIpxSocket )
#pragma alloc_text( PAGE, SrvRestartAccept )
#pragma alloc_text( PAGE, RestartStartSend )
#pragma alloc_text( PAGE, GetIpxMaxBufferSize )

#endif
#if 0
NOT PAGEABLE -- SrvOpenConnection
NOT PAGEABLE -- SrvPrepareReceiveWorkItem
NOT PAGEABLE -- SrvStartSend
NOT PAGEABLE -- SrvStartSend2
#endif


NTSTATUS
SrvAddServedNet(
    IN PUNICODE_STRING NetworkName,
    IN PUNICODE_STRING TransportName,
    IN PANSI_STRING TransportAddress,
    IN PUNICODE_STRING DomainName,
    IN ULONG         TransportAddFlags,
    IN DWORD            PasswordLength,
    IN PBYTE            Password
    )

/*++

Routine Description:

    This function initializes the server on a network.  This
    involves making the server known by creating a transport endpoint,
    posting a Listen request, and setting up event handlers.

Arguments:

    NetworkName - The administrative name of the network (e.g., NET1)

    TransportName - The fully qualified name of the transport device.
        For example, "\Device\Nbf".

    TransportAddress - The fully qualified address (or name ) of the
        server's endpoint.  This name is used exactly as specified.  For
        NETBIOS-compatible networks, the caller must upcase and
        blank-fill the name.  For example, "NTSERVERbbbbbbbb".

    DomainName - The name of the domain to service

    Password/PasswordLength - used for mutual authentication (optional)

Return Value:

    NTSTATUS - Indicates whether the network was successfully started.

--*/
{
    NTSTATUS status;
    PENDPOINT endpoint;

    PAGED_CODE( );

    IF_DEBUG(TRACE1) KdPrint(( "SrvAddServedNet entered\n" ));

    //
    // Call OpenEndpoint to open the transport provider, bind to the
    // server address, and register the FSD receive event handler.
    //

    status = OpenEndpoint(
                &endpoint,
                NetworkName,
                TransportName,
                TransportAddress,
                DomainName,
                TransportAddFlags,
                FALSE);              // primary endpoint

    if ( !NT_SUCCESS(status) ) {

        IF_DEBUG(ERRORS) {
            KdPrint(( "SrvAddServedNet: unable to open endpoint %wZ for addr %z, status %X\n", TransportName, (PCSTRING)TransportAddress, status ));
        }

        return status;
    }

    //
    // Dereference the endpoint.  (When it was created, the reference
    // count was incremented to account for our pointer.)
    //
    SrvDereferenceEndpoint( endpoint );

    //
    // Call OpenEndpoint to open the transport provider, bind to the
    // server address, and register the FSD receive event handler. This is
    // the auxillary endpoint registration in the new TDI address format. Since
    // this is not supported by all the transports it cannot be deemed an error.
    //
    //
    status = OpenEndpoint(
                   &endpoint,
                   NetworkName,
                   TransportName,
                   TransportAddress,
                   DomainName,
                   TransportAddFlags,
                   TRUE);              // Alternate endpoint

    if ( NT_SUCCESS( status ) ) {
        SrvDereferenceEndpoint( endpoint );
    }

    if( PasswordLength ) {
        SrvAddSecurityCredentials( TransportAddress, DomainName, PasswordLength, Password );
    }

    return STATUS_SUCCESS;

} // SrvAddServedNet


NTSTATUS
SrvDeleteServedNet(
    IN PUNICODE_STRING TransportName,
    IN PANSI_STRING TransportAddress
    )

/*++

Routine Description:

    This function causes the server to stop listening to a network.

Arguments:

    TransportAddress - the transport address (e.g. \Device\Nbf\POPCORN
        of the endpoint to delete.

Return Value:

    NTSTATUS - Indicates whether the network was successfully stopped.

--*/

{
    PLIST_ENTRY listEntry;
    PENDPOINT endpoint;
    BOOLEAN match;
    NTSTATUS status = STATUS_NONEXISTENT_NET_NAME;

    PAGED_CODE( );
    IF_DEBUG(TRACE1) KdPrint(( "SrvDeleteServedNet entered\n" ));

    //
    // Find the endpoint block with the specified name.
    //

top:
    ACQUIRE_LOCK( &SrvEndpointLock );

    listEntry = SrvEndpointList.ListHead.Flink;

    while ( listEntry != &SrvEndpointList.ListHead ) {

        endpoint = CONTAINING_RECORD(
                        listEntry,
                        ENDPOINT,
                        GlobalEndpointListEntry
                        );

        if( GET_BLOCK_STATE(endpoint) == BlockStateActive ) {

            //
            // We have a match if the transport name is correct and we either
            //  haven't specified a transport address, or if the transport
            //  address matches
            //
            match = (BOOLEAN)(
                        RtlEqualUnicodeString(
                            TransportName,
                            &endpoint->TransportName,
                            TRUE                    // case insensitive compare
                            )
                        &&
                        (
                        TransportAddress->Length == 0 ||

                        RtlEqualString(
                            (PSTRING)TransportAddress,
                            (PSTRING)&endpoint->TransportAddress,
                            TRUE                    // case insensitive compare
                            )
                        )

                        );

            if ( match ) {

                //
                // The specified network name (endpoint) exists.  Close the
                // endpoint.  This releases the endpoint lock.
                //

                SrvCloseEndpoint( endpoint );

                status = STATUS_SUCCESS;

                //
                // Restart this loop, since this endpoint may have vaporized and
                //  the list might have changed because we dropped SrvEndpointLock.
                //
                // SrvCloseEndpoint will have marked this endpoint as BlockStateClosing,
                //  so we will not be in an infinite loop!
                //
                goto top;

            }
        }

        //
        // Go to the next one.
        //

        listEntry = listEntry->Flink;

    }

    //
    // We are done.  If we successfully matched an endpoint, we return STATUS_SUCCESS
    //

    RELEASE_LOCK( &SrvEndpointLock );

    return status;

} // SrvDeleteServedNet


NTSTATUS
SrvDoDisconnect (
    IN OUT PCONNECTION Connection
    )

/*++

Routine Description:

    This function issues a Disconnect request on a network.  The request
    is performed synchronously -- control is not returned to the caller
    until the request completes.

Arguments:

    Connection - Supplies a pointer to an Connection Block

Return Value:

    NTSTATUS - Indicates whether the disconnect was successful.

--*/

{
    NTSTATUS status;

    PAGED_CODE( );

    IF_DEBUG(TRACE2) KdPrint(( "SrvDoDisconnect entered\n" ));
#if SRVDBG29
    UpdateConnectionHistory( "SDSC", Connection->Endpoint, Connection );
#endif

    ASSERT( !Connection->Endpoint->IsConnectionless );

    //
    // Issue the disconnect request.
    //

    status = SrvIssueDisconnectRequest(
                Connection->FileObject,
                &Connection->DeviceObject,
                TDI_DISCONNECT_ABORT
                );

    if ( !NT_SUCCESS(status) ) {
        INTERNAL_ERROR(
            ERROR_LEVEL_EXPECTED,
            "SrvDoDisconnect: NtDeviceIoControlFile failed: %X",
             status,
             NULL
             );

#if SRVDBG29
        if (status != STATUS_LINK_FAILED && status != STATUS_REMOTE_DISCONNECT) {
            KdPrint(( "SRV: SrvDoDisconnect: SrvIssueDisconnectRequest failed\n" ));
            DbgBreakPoint();
        }
#endif
        //
        // Mark the connection as not reusable, because the transport
        // probably still thinks it's active.
        //

        Connection->NotReusable = TRUE;

        SrvLogServiceFailure( SRV_SVC_NT_IOCTL_FILE, status );

    }

    //
    // Return the status of the I/O operation.
    //

    return status;

} // SrvDoDisconnect


NTSTATUS
SrvOpenConnection (
    IN PENDPOINT Endpoint
    )

/*++

Routine Description:

    This function opens a connection for an endpoint and queues it to
    the endpoint's free connection list.

Arguments:

    Endpoint - Supplies a pointer to an Endpoint Block

Return Value:

    NTSTATUS - Indicates whether the connection was successfully opened.

--*/

{
    NTSTATUS status;
    PCONNECTION connection;
    PPAGED_CONNECTION pagedConnection;
    CHAR eaBuffer[sizeof(FILE_FULL_EA_INFORMATION) - 1 +
                  TDI_CONNECTION_CONTEXT_LENGTH + 1 +
                  sizeof(CONNECTION_CONTEXT)];
    PFILE_FULL_EA_INFORMATION ea;
    CONNECTION_CONTEXT UNALIGNED *ctx;
    OBJECT_ATTRIBUTES objectAttributes;
    IO_STATUS_BLOCK iosb;
    KIRQL oldIrql;
    PTABLE_HEADER tableHeader;
    SHORT sidIndex;
    USHORT i;
    PTABLE_ENTRY entry = NULL;
    TDI_PROVIDER_INFO providerInfo;

    //
    // Allocate a connection block.
    //

    SrvAllocateConnection( &connection );

    if ( connection == NULL ) {
        return STATUS_INSUFF_SERVER_RESOURCES;
    }

    pagedConnection = connection->PagedConnection;

    //
    // Allocate an entry in the endpoint's connection table.
    //

    ACQUIRE_SPIN_LOCK( &ENDPOINT_SPIN_LOCK(0), &oldIrql );
    for ( i = 1; i < ENDPOINT_LOCK_COUNT ; i++ ) {
        ACQUIRE_DPC_SPIN_LOCK( &ENDPOINT_SPIN_LOCK(i) );
    }

    tableHeader = &Endpoint->ConnectionTable;

    if ( tableHeader->FirstFreeEntry == -1 &&
         SrvGrowTable(
            tableHeader,
            8,
            0x7fff,
            NULL ) == FALSE ) {

        for ( i = ENDPOINT_LOCK_COUNT-1 ; i > 0  ; i-- ) {
            RELEASE_DPC_SPIN_LOCK( &ENDPOINT_SPIN_LOCK(i) );
        }
        RELEASE_SPIN_LOCK( &ENDPOINT_SPIN_LOCK(0), oldIrql );
        status = STATUS_INSUFF_SERVER_RESOURCES;
        goto cleanup;
    }

    sidIndex = tableHeader->FirstFreeEntry;
    entry = &tableHeader->Table[sidIndex];
    tableHeader->FirstFreeEntry = entry->NextFreeEntry;
    DEBUG entry->NextFreeEntry = -2;
    if ( tableHeader->LastFreeEntry == sidIndex ) {
        tableHeader->LastFreeEntry = -1;
    }

    for ( i = ENDPOINT_LOCK_COUNT-1 ; i > 0  ; i-- ) {
        RELEASE_DPC_SPIN_LOCK( &ENDPOINT_SPIN_LOCK(i) );
    }
    RELEASE_SPIN_LOCK( &ENDPOINT_SPIN_LOCK(0), oldIrql );

    if ( !Endpoint->IsConnectionless ) {

        //
        // Create the EA for the connection context.
        //

        ea = (PFILE_FULL_EA_INFORMATION)eaBuffer;
        ea->NextEntryOffset = 0;
        ea->Flags = 0;
        ea->EaNameLength = TDI_CONNECTION_CONTEXT_LENGTH;
        ea->EaValueLength = sizeof(CONNECTION_CONTEXT);

        RtlCopyMemory( ea->EaName, StrConnectionContext, ea->EaNameLength + 1 );

        ctx = (CONNECTION_CONTEXT UNALIGNED *)&ea->EaName[ea->EaNameLength + 1];
        *ctx = connection;

        //
        // Create the connection file object.
        //

        SrvInitializeObjectAttributes_U(
            &objectAttributes,
            &Endpoint->TransportName,
            OBJ_CASE_INSENSITIVE,
            NULL,
            NULL
            );

        status = NtCreateFile(
                    &pagedConnection->ConnectionHandle,
                    0,
                    &objectAttributes,
                    &iosb,
                    NULL,
                    0,
                    0,
                    0,
                    0,
                    eaBuffer,
                    FIELD_OFFSET( FILE_FULL_EA_INFORMATION, EaName[0] ) +
                                ea->EaNameLength + 1 + ea->EaValueLength
                    );

        if ( !NT_SUCCESS(status) ) {
            IF_DEBUG(ERRORS) {
                KdPrint(( "SrvOpenConnection: NtCreateFile failed: %X\n", status ));
            }
            goto cleanup;
        }
        SRVDBG_CLAIM_HANDLE( pagedConnection->ConnectionHandle, "CON", 7, connection );

        //
        // Obtain a referenced pointer to the file object.
        //

        status = ObReferenceObjectByHandle(
                    pagedConnection->ConnectionHandle,
                    0,
                    (POBJECT_TYPE) NULL,
                    KernelMode,
                    (PVOID *)&connection->FileObject,
                    NULL
                    );

        if ( !NT_SUCCESS(status) ) {

            SrvLogServiceFailure( SRV_SVC_OB_REF_BY_HANDLE, status );

            //
            // This internal error bugchecks the system.
            //

            INTERNAL_ERROR(
                ERROR_LEVEL_IMPOSSIBLE,
                "SrvOpenConnection: ObReferenceObjectByHandle failed: %X",
                status,
                NULL
                );

            goto cleanup;

        }

        //
        // Get the address of the device object for the endpoint.
        //

        connection->DeviceObject = IoGetRelatedDeviceObject(
                                        connection->FileObject
                                        );

        //
        // Associate the connection with the endpoint's address.
        //

        status = SrvIssueAssociateRequest(
                    connection->FileObject,
                    &connection->DeviceObject,
                    Endpoint->EndpointHandle
                    );
        if ( !NT_SUCCESS(status) ) {
            INTERNAL_ERROR(
                ERROR_LEVEL_UNEXPECTED,
                "SrvOpenConnection: SrvIssueAssociateRequest failed: %X",
                status,
                NULL
                );

            SrvLogServiceFailure( SRV_SVC_NT_IOCTL_FILE, status );
            goto cleanup;
        }

        IF_DEBUG(NET1) {
            KdPrint(( "SrvOpenConnection: Connection on %p %z opened; handle %p, pointer %p\n", Endpoint,
                        (PCSTRING)&Endpoint->TransportAddress,
                        connection->PagedConnection->ConnectionHandle,
                        connection->FileObject ));
        }

        //
        // Initialize the MaximumSendSize for the transport that we're using
        //

        status = SrvIssueTdiQuery(
                    connection->FileObject,
                    &connection->DeviceObject,
                    (PCHAR)&providerInfo,
                    sizeof(providerInfo),
                    TDI_QUERY_PROVIDER_INFO
                    );

        //
        // If we got the provider info, make sure the maximum send size is at
        // least 1K-1. If we have no provider info, then maximum send size is 64KB.
        //

        if ( NT_SUCCESS(status) ) {
            connection->MaximumSendSize = providerInfo.MaxSendSize;
            if ( connection->MaximumSendSize < MIN_SEND_SIZE ) {
                connection->MaximumSendSize = MIN_SEND_SIZE;
            }
        } else {
            connection->MaximumSendSize = MAX_PARTIAL_BUFFER_SIZE;
        }


    } else { // if ( Endpoint->IsConnectionless )
        if (sidIndex > 0xfff) {
            // The IPXSID index can only span 12 bits
            // Code needs to be added to ensure that we can try to locate
            // an index less than 0xfff
            status = STATUS_INSUFF_SERVER_RESOURCES;
            goto cleanup;
        }

        // Give this the default initialization
        connection->MaximumSendSize = MAX_PARTIAL_BUFFER_SIZE;
    }
    //
    // Set the reference count on the connection to zero, in order to
    // put it on the free list.  (SrvAllocateConnection initialized the
    // count to two.)
    //

    connection->BlockHeader.ReferenceCount = 0;

    UPDATE_REFERENCE_HISTORY( connection, TRUE );
    UPDATE_REFERENCE_HISTORY( connection, TRUE );

    //
    // Reference the endpoint and link the connection into the
    // endpoint's free connection list.
    //

    connection->Endpoint = Endpoint;
    connection->EndpointSpinLock =
        &ENDPOINT_SPIN_LOCK(sidIndex & ENDPOINT_LOCK_MASK);

    ACQUIRE_LOCK( &SrvEndpointLock );

    SrvReferenceEndpoint( Endpoint );

    ACQUIRE_SPIN_LOCK( connection->EndpointSpinLock, &oldIrql );
    INCREMENT_IPXSID_SEQUENCE( entry->SequenceNumber );
    if ( sidIndex == 0 && entry->SequenceNumber == 0 ) {
        INCREMENT_IPXSID_SEQUENCE( entry->SequenceNumber );
    }

    connection->Sid = MAKE_IPXSID( sidIndex, entry->SequenceNumber );
    connection->SidIndex = sidIndex;

    entry->Owner = connection;
    RELEASE_SPIN_LOCK( connection->EndpointSpinLock, oldIrql );

    ACQUIRE_GLOBAL_SPIN_LOCK( Fsd, &oldIrql );
    SrvInsertTailList(
        &Endpoint->FreeConnectionList,
        &connection->EndpointFreeListEntry
        );
#if SRVDBG29
    UpdateConnectionHistory( "OPEN", Endpoint, connection );
#endif
    Endpoint->FreeConnectionCount++;
    Endpoint->TotalConnectionCount++;

    RELEASE_GLOBAL_SPIN_LOCK( Fsd, oldIrql );

    IF_DEBUG(TDI) {
        KdPrint(( "SrvOpenConnection created connection %p for endpoint %p; free %ld, total %ld\n", connection, Endpoint,
                    Endpoint->FreeConnectionCount,
                    Endpoint->TotalConnectionCount ));
    }

    RELEASE_LOCK( &SrvEndpointLock );

    //
    // The connection open was successful.
    //

    IF_DEBUG(TRACE1) {
        KdPrint(( "SrvOpenConnection complete: %X\n", STATUS_SUCCESS ));
    }

    return STATUS_SUCCESS;

    //
    // Out-of-line error cleanup.
    //

cleanup:

    //
    // Something failed.  Clean up as appropriate.
    //

    if ( !Endpoint->IsConnectionless ) {
        if ( connection->FileObject != NULL ) {
            ObDereferenceObject( connection->FileObject );
        }
        if ( pagedConnection->ConnectionHandle != NULL ) {
            SRVDBG_RELEASE_HANDLE( pagedConnection->ConnectionHandle, "CON", 12, connection );
            SrvNtClose( pagedConnection->ConnectionHandle, FALSE );
        }
    }

    if ( entry != NULL ) {
        SrvRemoveEntryTable( tableHeader, sidIndex );
    }

    SrvFreeConnection( connection );

    return status;

} // SrvOpenConnection


NTSTATUS
GetNetworkAddress (
    IN PENDPOINT Endpoint
    )

{
    NTSTATUS status;
    PCHAR adapterStatus;
    PCHAR adapterAddress;
    ANSI_STRING ansiString;
    CHAR addressData[12+1];
    ULONG i;

    struct {
        ULONG ActivityCount;
        TA_IPX_ADDRESS LocalAddress;
    } addressInfo;

    PAGED_CODE( );

    if ( !Endpoint->IsConnectionless ) {

        //
        // Allocate a buffer to receive adapter information.
        //
        // *** We want to get the ADAPTER_STATUS structure, but it is
        //     defined in the windows header file sdk\inc\nb30.h.
        //     Rather than including all the windows header files, just
        //     allocate about a page, which should always be enough for
        //     that structure.
        //

        adapterStatus = ALLOCATE_NONPAGED_POOL( 4080, BlockTypeAdapterStatus );
        if ( adapterStatus == NULL ) {
            return STATUS_INSUFF_SERVER_RESOURCES;
        }

        status = SrvIssueTdiQuery(
                    Endpoint->FileObject,
                    &Endpoint->DeviceObject,
                    adapterStatus,
                    4080,
                    TDI_QUERY_ADAPTER_STATUS
                    );

        if ( !NT_SUCCESS(status) ) {
            INTERNAL_ERROR(
                ERROR_LEVEL_UNEXPECTED,
                "GetNetworkAddress: SrvIssueTdiQuery failed: %X\n",
                status,
                NULL
                );
            SrvLogServiceFailure( SRV_SVC_NT_IOCTL_FILE, status );
            DEALLOCATE_NONPAGED_POOL( adapterStatus );
            return status;
        }

        adapterAddress = adapterStatus;

    } else {

        status = SrvIssueTdiQuery(
                    Endpoint->NameSocketFileObject,
                    &Endpoint->NameSocketDeviceObject,
                    (PCHAR)&addressInfo,
                    sizeof(addressInfo),
                    TDI_QUERY_ADDRESS_INFO
                    );
        if ( !NT_SUCCESS(status) ) {
            INTERNAL_ERROR(
                ERROR_LEVEL_UNEXPECTED,
                "GetNetworkAddress: SrvIssueTdiQuery failed: %X\n",
                status,
                NULL
                );
            SrvLogServiceFailure( SRV_SVC_NT_IOCTL_FILE, status );
            return status;
        }

        Endpoint->LocalAddress = addressInfo.LocalAddress.Address[0].Address[0];

        adapterAddress = addressInfo.LocalAddress.Address[0].Address[0].NodeAddress;

    }

    //
    // Get an ANSI string that contains the adapter address.
    //

    ansiString.Buffer = addressData;
    ansiString.Length = 12;
    ansiString.MaximumLength = 13;

#define tohexdigit(a) ((CHAR)( (a) > 9 ? ((a) + 'a' - 0xA) : ((a) + '0') ))

    for ( i = 0; i < 6; i++ ) {
        addressData[2*i] = tohexdigit( (adapterAddress[i] >> 4) & 0x0F );
        addressData[2*i+1] = tohexdigit( adapterAddress[i] & 0x0F );
    }

    addressData[12] = '\0';

    //
    // Convert the address string to Unicode.
    //

    status = RtlAnsiStringToUnicodeString(
                &Endpoint->NetworkAddress,
                &ansiString,
                FALSE
                );
    ASSERT( NT_SUCCESS(status) );

    if ( !Endpoint->IsConnectionless ) {
        DEALLOCATE_NONPAGED_POOL( adapterStatus );
    }

    return STATUS_SUCCESS;

} // GetNetworkAddress


NTSTATUS
OpenEndpoint (
    OUT PENDPOINT *Endpoint,
    IN PUNICODE_STRING NetworkName,
    IN PUNICODE_STRING TransportName,
    IN PANSI_STRING TransportAddress,
    IN PUNICODE_STRING DomainName,
    IN DWORD         TransportAddFlags,
    IN BOOLEAN       AlternateEndpoint
    )

/*++

Routine Description:

    This function opens a transport provider, simultaneously binding the
    server's address to the transport endpoint, and registers a Receive
    event handler for the endpoint.

Arguments:

    Endpoint - Returns a pointer to an Endpoint Block

    NetworkName - Supplies the administrative name of the network (e.g.,
        NET1).

    TransportName - The fully qualified name of the transport device.
        For example, "\Device\Nbf".

    TransportAddress - The exact name of the server to be used on the
        specified transport.  For NETBIOS-compatible networks, the
        caller must upcase and blank-fill the name.  For example,
        "NTSERVERbbbbbbbb".

    DomainName - name of domain to serve

Return Value:

    NTSTATUS - Indicates whether the network was successfully opened.

--*/

{
    NTSTATUS status = STATUS_SUCCESS;
    PENDPOINT endpoint = NULL;            // local copy of Endpoint

    PAGED_CODE( );

    IF_DEBUG(TRACE1) KdPrint(( "OpenEndpoint %wZ entered\n", TransportName ));

    //
    // Allocate an endpoint block.
    //

    SrvAllocateEndpoint(
        &endpoint,
        NetworkName,
        TransportName,
        TransportAddress,
        DomainName
        );

    if ( endpoint == NULL ) {
        IF_DEBUG(ERRORS) {
            KdPrint(( "OpenEndpoint complete: %X\n",
                        STATUS_INSUFF_SERVER_RESOURCES ));
        }
        return STATUS_INSUFF_SERVER_RESOURCES;
    }

    if( TransportAddFlags & SRP_XADD_PRIMARY_MACHINE ) {

        endpoint->IsPrimaryName = 1;

        if( SrvComputerName.Buffer == NULL ) {

            status = RtlAnsiStringToUnicodeString( &SrvComputerName, TransportAddress, TRUE );

            if( NT_SUCCESS( status ) ) {

                //
                // Trim off the trailing spaces
                //

                while( SrvComputerName.Buffer[(SrvComputerName.Length-sizeof(WCHAR))/sizeof(WCHAR)]
                    == L' ' ) {
                    SrvComputerName.Length -= sizeof(WCHAR);
                }
            }
        }
    }

    if( NT_SUCCESS( status ) ) {

       if( TransportAddFlags & SRP_XADD_REMAP_PIPE_NAMES ) {
           endpoint->RemapPipeNames = 1;
       }

       if (AlternateEndpoint) {

           status = OpenNetbiosExAddress(
                        endpoint,
                        TransportName,
                        TransportAddress->Buffer);

           endpoint->AlternateAddressFormat = TRUE;

       } else {

           endpoint->AlternateAddressFormat = FALSE;

          //
          // Assume that the transport is a NetBIOS provider, and try to
          // open the server's address using the NetBIOS name.
          //

          status = OpenNetbiosAddress(
                      endpoint,
                      TransportName,
                      TransportAddress->Buffer
                      );

          //
          // We could not open the transport as a NetBIOS provider.  We will now try
          //  to see if it is a direct host IPX provider. However, if we have been
          //  configured to use Security Signatures, do not attempt direct host IPX since
          //  security signatures are not supported for direct host IPX transports
          //
          if ( !NT_SUCCESS(status) && SrvSmbSecuritySignaturesRequired == FALSE ) {

              BOOLEAN isDuplicate = FALSE;
              PLIST_ENTRY listEntry;

              //
              // Apparently the transport is not a NetBIOS provider.  We can
              //  not open multiple connectionless providers through the same
              //  TransportName.
              //

              ACQUIRE_LOCK( &SrvEndpointLock );

              for( listEntry = SrvEndpointList.ListHead.Flink;
                   listEntry != &SrvEndpointList.ListHead;
                   listEntry = listEntry->Flink ) {

                  PENDPOINT tmpEndpoint;

                  tmpEndpoint = CONTAINING_RECORD( listEntry, ENDPOINT, GlobalEndpointListEntry );

                  if( GET_BLOCK_STATE( tmpEndpoint ) == BlockStateActive &&
                      tmpEndpoint->IsConnectionless &&
                      RtlCompareUnicodeString( &tmpEndpoint->TransportName, TransportName, TRUE ) == 0 ) {

                      IF_DEBUG(ERRORS) {
                          KdPrint(( "OpenEndpoint: Only one connectionless endpoint on %wZ allowed!\n",
                                    TransportName ));
                      }

                      isDuplicate = TRUE;
                      status = STATUS_TOO_MANY_NODES;
                      break;
                  }
              }

              RELEASE_LOCK( &SrvEndpointLock );

              //
              // Try to open it as a connectionless provider.
              //
              if( isDuplicate == FALSE ) {
                  NTSTATUS status2;

                  status2 = OpenNonNetbiosAddress(
                            endpoint,
                            TransportName,
                            TransportAddress->Buffer
                            );

                  if( NT_SUCCESS( status2 ) ) {
                    status = status2;
                  }
               }
            }
        }
    }

    if ( !NT_SUCCESS(status) ) {

        //
        // We couldn't open the provider as either a NetBIOS provider
        // or as a connectionless provider.
        //

        IF_DEBUG(ERRORS) {
            KdPrint(( "OpenEndpoint: OpenAddress failed: %X\n", status ));
        }

        //
        // Close all free connections.
        //

        EmptyFreeConnectionList( endpoint );

        SrvFreeEndpoint( endpoint );

        ACQUIRE_LOCK( &SrvEndpointLock );
        SrvEndpointCount--;
        RELEASE_LOCK( &SrvEndpointLock );

        return status;
    }

    //
    // Query the provider for the send entry point
    //

    SrvQuerySendEntryPoint(
                   endpoint->FileObject,
                   &endpoint->DeviceObject,
                   IOCTL_TDI_QUERY_DIRECT_SEND_HANDLER,
                   (PVOID*)&endpoint->FastTdiSend
                   );

    //
    // Query the provider for the send entry point
    //

    SrvQuerySendEntryPoint(
                   endpoint->FileObject,
                   &endpoint->DeviceObject,
                   IOCTL_TDI_QUERY_DIRECT_SENDDG_HANDLER,
                   (PVOID*)&endpoint->FastTdiSendDatagram
                   );

    //
    // The network open was successful.  Link the new endpoint into the
    // list of active endpoints.  Return with a success status.  (We
    // don't dereference the endpoint because we're returning a pointer
    // to the endpoint.)
    //

    SrvInsertEntryOrderedList( &SrvEndpointList, endpoint );

    *Endpoint = endpoint;

    IF_DEBUG(TRACE1) {
        KdPrint(( "OpenEndpoint complete: %wZ %X\n", TransportName, STATUS_SUCCESS ));
    }

    return STATUS_SUCCESS;

} // OpenEndpoint

NTSTATUS
SetupConnectionEndpointHandlers(
   IN OUT PENDPOINT Endpoint)
{
   NTSTATUS status;
   ULONG    i;

   Endpoint->IsConnectionless = FALSE;

   status = SrvVerifyDeviceStackSize(
                               Endpoint->EndpointHandle,
                               TRUE,
                               &Endpoint->FileObject,
                               &Endpoint->DeviceObject,
                               NULL
                               );

   if ( !NT_SUCCESS( status ) ) {

       INTERNAL_ERROR(
           ERROR_LEVEL_EXPECTED,
           "OpenNetbiosAddress: Verify Device Stack Size failed: %X\n",
           status,
           NULL
           );

       goto cleanup;
   }

   //
   // Find the network address of the adapter used by corresponding to
   // this endpoint.
   //

   GetNetworkAddress( Endpoint );

   //
   // Register the server's Receive event handler.
   //

   status = SrvIssueSetEventHandlerRequest(
               Endpoint->FileObject,
               &Endpoint->DeviceObject,
               TDI_EVENT_RECEIVE,
               (PVOID)SrvFsdTdiReceiveHandler,
               Endpoint
               );

   if ( !NT_SUCCESS(status) ) {
       INTERNAL_ERROR(
           ERROR_LEVEL_EXPECTED,
           "OpenNetbiosAddress: set receive event handler failed: %X",
           status,
           NULL
           );

       SrvLogServiceFailure( SRV_SVC_NT_IOCTL_FILE, status );
       goto cleanup;
   }

   //
   // Register the server's Disconnect event handler.
   //

   status = SrvIssueSetEventHandlerRequest(
               Endpoint->FileObject,
               &Endpoint->DeviceObject,
               TDI_EVENT_DISCONNECT,
               (PVOID)SrvFsdTdiDisconnectHandler,
               Endpoint
               );

   if ( !NT_SUCCESS(status) ) {
       INTERNAL_ERROR(
           ERROR_LEVEL_UNEXPECTED,
           "OpenNetbiosAddress: set disconnect event handler failed: %X",
           status,
           NULL
           );

       SrvLogServiceFailure( SRV_SVC_NT_IOCTL_FILE, status );
       goto cleanup;
   }

   //
   // Create a number of free connections for the endpoint.  These
   // connections will be used to service Connect events.
   //
   // *** If we fail in an attempt to create a connection, but we can
   //     successfully create at least one, we keep the endpoint.  The
   //     cleanup code below depends on this behavior.
   //

   for ( i = 0; i < SrvFreeConnectionMinimum; i++ ) {

       status = SrvOpenConnection( Endpoint );
       if ( !NT_SUCCESS(status) ) {
           INTERNAL_ERROR(
               ERROR_LEVEL_EXPECTED,
               "OpenNetbiosAddress: SrvOpenConnection failed: %X",
               status,
               NULL
               );
           if ( i == 0 ) {
               goto cleanup;
           } else {
               break;
           }
       }

   }

   //
   // Register the server's Connect event handler.
   //
   // *** Note that Connect events can be delivered IMMEDIATELY upon
   //     completion of this request!
   //

   status = SrvIssueSetEventHandlerRequest(
               Endpoint->FileObject,
               &Endpoint->DeviceObject,
               TDI_EVENT_CONNECT,
               (PVOID)SrvFsdTdiConnectHandler,
               Endpoint
               );

   if ( !NT_SUCCESS(status) ) {
       INTERNAL_ERROR(
           ERROR_LEVEL_UNEXPECTED,
           "OpenNetbiosAddress: set connect event handler failed: %X",
           status,
           NULL
           );

       SrvLogServiceFailure( SRV_SVC_NT_IOCTL_FILE, status );
       goto cleanup;
   }

   return STATUS_SUCCESS;

   //
   // Out-of-line error cleanup.
   //

cleanup:

   //
   // Something failed.  Clean up as appropriate.
   //

   if ( Endpoint->FileObject != NULL ) {
       ObDereferenceObject( Endpoint->FileObject );
       Endpoint->FileObject = NULL;
   }
   if ( Endpoint->EndpointHandle != NULL ) {
       SRVDBG_RELEASE_HANDLE( Endpoint->EndpointHandle, "END", 14, Endpoint );
       SrvNtClose( Endpoint->EndpointHandle, FALSE );
       Endpoint->EndpointHandle = NULL;
   }

   return status;
}


NTSTATUS
OpenNetbiosAddress (
    IN OUT PENDPOINT Endpoint,
    IN PVOID DeviceName,
    IN PVOID NetbiosName
    )
{
    NTSTATUS status;
    ULONG i;

    CHAR eaBuffer[sizeof(FILE_FULL_EA_INFORMATION) +
                  TDI_TRANSPORT_ADDRESS_LENGTH + 1 +
                  sizeof(TA_NETBIOS_ADDRESS)];

    PAGED_CODE( );

    status = TdiOpenNetbiosAddress(
                &Endpoint->EndpointHandle,
                eaBuffer,
                DeviceName,
                NetbiosName
                );

    if ( !NT_SUCCESS(status) ) {
        IF_DEBUG( ERRORS ) {
            KdPrint(( "TdiOpenNetbiosAddress( %wZ ) status %X\n", DeviceName, status ));
        }
        return status;
    }

    status = SetupConnectionEndpointHandlers(Endpoint);

    return status;
} // OpenNetbiosAddress

NTSTATUS
OpenNetbiosExAddress(
    IN OUT PENDPOINT Endpoint,
    IN PVOID DeviceName,
    IN PVOID NetbiosName
    )
{
   NTSTATUS status;

   PFILE_FULL_EA_INFORMATION ea;
   OBJECT_ATTRIBUTES         objectAttributes;
   IO_STATUS_BLOCK           iosb;

   ULONG length;
   CHAR  buffer[sizeof(FILE_FULL_EA_INFORMATION) +
                 TDI_TRANSPORT_ADDRESS_LENGTH + 1 +
                 sizeof(TA_NETBIOS_EX_ADDRESS)];

   TA_NETBIOS_EX_ADDRESS     NetbiosExAddress;
   PTDI_ADDRESS_NETBIOS_EX   pTdiNetbiosExAddress;
   PTDI_ADDRESS_NETBIOS      pNetbiosAddress;

   ULONG NetbiosExAddressLength;

   PAGED_CODE( );

   //
   // Build the NETBIOS Extended address.
   //

   NetbiosExAddress.TAAddressCount = 1;
   NetbiosExAddress.Address[0].AddressLength = TDI_ADDRESS_LENGTH_NETBIOS_EX;
   NetbiosExAddress.Address[0].AddressType = TDI_ADDRESS_TYPE_NETBIOS_EX;

   pTdiNetbiosExAddress = NetbiosExAddress.Address[0].Address;
   pNetbiosAddress = &pTdiNetbiosExAddress->NetbiosAddress;
   pNetbiosAddress->NetbiosNameType = TDI_ADDRESS_NETBIOS_TYPE_UNIQUE;

   NetbiosExAddressLength =   FIELD_OFFSET(TRANSPORT_ADDRESS,Address)
                        + FIELD_OFFSET(TA_ADDRESS,Address)
                        + FIELD_OFFSET(TDI_ADDRESS_NETBIOS_EX,NetbiosAddress)
                        + TDI_ADDRESS_LENGTH_NETBIOS;

   RtlCopyMemory(
         pNetbiosAddress->NetbiosName,
         NetbiosName,
         NETBIOS_NAME_LEN);

   // Copy the default endpoint name onto the NETBIOS Extended address.
   RtlCopyMemory(
         pTdiNetbiosExAddress->EndpointName,
         SMBSERVER_LOCAL_ENDPOINT_NAME,
         NETBIOS_NAME_LEN);

   length = FIELD_OFFSET( FILE_FULL_EA_INFORMATION, EaName[0] ) +
                               TDI_TRANSPORT_ADDRESS_LENGTH + 1 +
                               NetbiosExAddressLength;
   ea = (PFILE_FULL_EA_INFORMATION)buffer;

   ea->NextEntryOffset = 0;
   ea->Flags = 0;
   ea->EaNameLength = TDI_TRANSPORT_ADDRESS_LENGTH;
   ea->EaValueLength = (USHORT)NetbiosExAddressLength;

   RtlCopyMemory( ea->EaName, StrTransportAddress, ea->EaNameLength + 1 );

   RtlCopyMemory(
       &ea->EaName[ea->EaNameLength + 1],
       &NetbiosExAddress,
       NetbiosExAddressLength
       );

   InitializeObjectAttributes( &objectAttributes, DeviceName, OBJ_CASE_INSENSITIVE, NULL, NULL );

   status = NtCreateFile (
                &Endpoint->EndpointHandle,
                FILE_READ_ATTRIBUTES | FILE_WRITE_ATTRIBUTES, // desired access
                &objectAttributes,     // object attributes
                &iosb,                 // returned status information
                NULL,                  // block size (unused)
                0,                     // file attributes
                FILE_SHARE_READ | FILE_SHARE_WRITE, // share access
                FILE_CREATE,           // create disposition
                0,                     // create options
                buffer,                // EA buffer
                length                 // EA length
                );

   if ( !NT_SUCCESS(status) ) {

      IF_DEBUG( ERRORS ) {
          KdPrint(("NtCreateFile %wZ NETBIOS_EX address status %X\n", DeviceName, status ));
       }

       return status;
   }

   Endpoint->IsNoNetBios = TRUE;
   status = SetupConnectionEndpointHandlers(Endpoint);

   IF_DEBUG( ERRORS ) {
     if( !NT_SUCCESS( status ) ) {
        KdPrint(("SetupConnectionEndpointHandlers failed, status %X\n", status ));
     }
   }

   return status;
}


NTSTATUS
OpenNonNetbiosAddress (
    IN OUT PENDPOINT Endpoint,
    IN PVOID DeviceName,
    IN PVOID NetbiosName
    )
{
    NTSTATUS status;
    ULONG i;
    ULONG numAdapters;
    PULONG maxPktArray = NULL;
    UCHAR buffer[sizeof(NWLINK_ACTION) + sizeof(IPX_ADDRESS_DATA) - 1];
    PNWLINK_ACTION action;
    PIPX_ADDRESS_DATA ipxAddressData;

    PAGED_CODE( );

    //
    // Open the NetBIOS name socket.
    //

    status = OpenIpxSocket(
                &Endpoint->NameSocketHandle,
                &Endpoint->NameSocketFileObject,
                &Endpoint->NameSocketDeviceObject,
                DeviceName,
                SMB_IPX_NAME_SOCKET
                );
    if ( !NT_SUCCESS(status) ) {
        goto cleanup;
    }

    Endpoint->IsConnectionless = TRUE;
    action = (PNWLINK_ACTION)buffer;

    //
    // Put the endpoint in broadcast reception mode.
    //

    action->Header.TransportId = 'XPIM'; // "MIPX"
    action->Header.ActionCode = 0;
    action->Header.Reserved = 0;
    action->OptionType = NWLINK_OPTION_ADDRESS;
    action->BufferLength = sizeof(action->Option);
    action->Option = MIPX_RCVBCAST;

    status = SrvIssueTdiAction(
                Endpoint->NameSocketFileObject,
                &Endpoint->NameSocketDeviceObject,
                (PCHAR)action,
                sizeof(NWLINK_ACTION)
                );
    if ( !NT_SUCCESS(status) ) {
        goto cleanup;
    }

    //
    // Tell the transport to give you the extended receive info
    //

    action->Header.TransportId = 'XPIM'; // "MIPX"
    action->Header.ActionCode = 0;
    action->Header.Reserved = 0;
    action->OptionType = NWLINK_OPTION_ADDRESS;
    action->BufferLength = sizeof(action->Option);
    action->Option = MIPX_SETRCVFLAGS;

    status = SrvIssueTdiAction(
                Endpoint->NameSocketFileObject,
                &Endpoint->NameSocketDeviceObject,
                (PCHAR)action,
                sizeof(NWLINK_ACTION)
                );
    if ( !NT_SUCCESS(status) ) {
        goto cleanup;
    }

    //
    // Get the max adapter number
    //

    action->Header.TransportId = 'XPIM'; // "MIPX"
    action->Header.ActionCode = 0;
    action->Header.Reserved = 0;
    action->OptionType = NWLINK_OPTION_ADDRESS;
    action->BufferLength = sizeof(action->Option) + sizeof(ULONG);
    action->Option = MIPX_ADAPTERNUM2;

    status = SrvIssueTdiAction(
                Endpoint->NameSocketFileObject,
                &Endpoint->NameSocketDeviceObject,
                (PCHAR)action,
                sizeof(NWLINK_ACTION) + sizeof(ULONG) - 1
                );
    if ( !NT_SUCCESS(status) ) {
        goto cleanup;
    }

    numAdapters = *((PULONG)action->Data);

    //
    // Allocate an array to store the max pkt size for each adapter
    //

    maxPktArray = ALLOCATE_HEAP( numAdapters * sizeof(ULONG), BlockTypeBuffer );

    if ( maxPktArray == NULL ) {
        status = STATUS_INSUFF_SERVER_RESOURCES;
        goto cleanup;
    }

    Endpoint->IpxMaxPacketSizeArray = maxPktArray;
    Endpoint->MaxAdapters = numAdapters;

    //
    // Query the max pkt size for each adapter
    //

    action->Header.TransportId = 'XPIM'; // "MIPX"
    action->Header.ActionCode = 0;
    action->Header.Reserved = 0;
    action->OptionType = NWLINK_OPTION_ADDRESS;
    action->BufferLength = sizeof(action->Option) + sizeof(IPX_ADDRESS_DATA);
    action->Option = MIPX_GETCARDINFO2;
    ipxAddressData = (PIPX_ADDRESS_DATA)action->Data;

    for ( i = 0; i < numAdapters; i++ ) {

        ipxAddressData->adapternum = i;

        status = SrvIssueTdiAction(
                    Endpoint->NameSocketFileObject,
                    &Endpoint->NameSocketDeviceObject,
                    (PCHAR)action,
                    sizeof(NWLINK_ACTION) + sizeof(IPX_ADDRESS_DATA) - 1
                    );

        if ( !NT_SUCCESS(status) ) {
            goto cleanup;
        }

        //
        // If this is a wan link, then we need to query the length each
        // time we get a connection.
        //

        if ( ipxAddressData->wan ) {
            maxPktArray[i] = 0;
        } else {
            maxPktArray[i] = ipxAddressData->maxpkt;
        }
    }

    //
    // Find the network address of the adapter used by corresponding to
    // this endpoint.
    //

    GetNetworkAddress( Endpoint );

    //
    // Register the name claim Receive Datagram event handler.
    //

    status = SrvIssueSetEventHandlerRequest(
                Endpoint->NameSocketFileObject,
                &Endpoint->NameSocketDeviceObject,
                TDI_EVENT_RECEIVE_DATAGRAM,
                (PVOID)SrvIpxNameDatagramHandler,
                Endpoint
                );
    if ( !NT_SUCCESS(status) ) {
        INTERNAL_ERROR(
            ERROR_LEVEL_EXPECTED,
            "OpenNonNetbiosAddress: set receive datagram event handler failed: %X",
            status,
            NULL
            );
        SrvLogServiceFailure( SRV_SVC_NT_IOCTL_FILE, status );
        goto cleanup;
    }

    //
    // Claim the server name.
    //

    status = SrvIpxClaimServerName( Endpoint, NetbiosName );
    if ( !NT_SUCCESS(status) ) {
        goto cleanup;
    }

    //
    // Open the server socket.
    //

    status = OpenIpxSocket(
                &Endpoint->EndpointHandle,
                &Endpoint->FileObject,
                &Endpoint->DeviceObject,
                DeviceName,
                SMB_IPX_SERVER_SOCKET
                );
    if ( !NT_SUCCESS(status) ) {
        goto cleanup;
    }

    //
    // Create a number of free connections for the endpoint.  These
    // connections will be used to service Connect events.
    //
    // *** If we fail in an attempt to create a connection, but we can
    //     successfully create at least one, we keep the endpoint.  The
    //     cleanup code below depends on this behavior.
    //

    for ( i = 0; i < SrvFreeConnectionMinimum; i++ ) {

        status = SrvOpenConnection( Endpoint );
        if ( !NT_SUCCESS(status) ) {
            INTERNAL_ERROR(
                ERROR_LEVEL_EXPECTED,
                "OpenNonNetbiosAddress: SrvOpenConnection failed: %X",
                status,
                NULL
                );
            if ( i == 0 ) {
                goto cleanup;
            } else {
                break;
            }
        }

    }

    //
    // Register the server Receive Datagram event handler.
    //

    status = SrvIssueSetEventHandlerRequest(
                Endpoint->FileObject,
                &Endpoint->DeviceObject,
                TDI_EVENT_RECEIVE_DATAGRAM,
                (PVOID)SrvIpxServerDatagramHandler,
                Endpoint
                );
    if ( !NT_SUCCESS(status) ) {
        INTERNAL_ERROR(
            ERROR_LEVEL_EXPECTED,
            "OpenNonNetbiosAddress: set receive datagram event handler failed: %X",
            status,
            NULL
            );
        SrvLogServiceFailure( SRV_SVC_NT_IOCTL_FILE, status );
        goto cleanup;
    }

    //
    // Register the server Chained Receive Datagram event handler.
    //

    status = SrvIssueSetEventHandlerRequest(
                Endpoint->FileObject,
                &Endpoint->DeviceObject,
                TDI_EVENT_CHAINED_RECEIVE_DATAGRAM,
                (PVOID)SrvIpxServerChainedDatagramHandler,
                Endpoint
                );
    if ( !NT_SUCCESS(status) ) {
        INTERNAL_ERROR(
            ERROR_LEVEL_EXPECTED,
            "OpenNonNetbiosAddress: set chained receive datagram event handler failed: %X",
            status,
            NULL
            );
        SrvLogServiceFailure( SRV_SVC_NT_IOCTL_FILE, status );
        goto cleanup;
    }

    return STATUS_SUCCESS;

    //
    // Out-of-line error cleanup.
    //

cleanup:

    //
    // Something failed.  Clean up as appropriate.
    //

    if ( maxPktArray != NULL ) {
        Endpoint->IpxMaxPacketSizeArray = NULL;
        FREE_HEAP( maxPktArray );
    }
    if ( Endpoint->FileObject != NULL ) {
        ObDereferenceObject( Endpoint->FileObject );
        Endpoint->FileObject = NULL;
    }
    if ( Endpoint->EndpointHandle != NULL ) {
        SRVDBG_RELEASE_HANDLE( Endpoint->EndpointHandle, "END", 14, Endpoint );
        SrvNtClose( Endpoint->EndpointHandle, FALSE );
        Endpoint->FileObject = NULL;
    }

    if ( Endpoint->NameSocketFileObject != NULL ) {
        ObDereferenceObject( Endpoint->NameSocketFileObject );
        Endpoint->NameSocketFileObject = NULL;
    }
    if ( Endpoint->NameSocketHandle != NULL ) {
        SRVDBG_RELEASE_HANDLE( Endpoint->NameSocketHandle, "END", 14, Endpoint );
        SrvNtClose( Endpoint->NameSocketHandle, FALSE );
        Endpoint->NameSocketHandle = NULL;
    }

    return status;

} // OpenNonNetbiosAddress


NTSTATUS
OpenIpxSocket (
    OUT PHANDLE Handle,
    OUT PFILE_OBJECT *FileObject,
    OUT PDEVICE_OBJECT *DeviceObject,
    IN PVOID DeviceName,
    IN USHORT Socket
    )
{
    NTSTATUS status;
    ULONG length;
    PFILE_FULL_EA_INFORMATION ea;
    TA_IPX_ADDRESS ipxAddress;
    OBJECT_ATTRIBUTES objectAttributes;
    IO_STATUS_BLOCK iosb;

    CHAR buffer[sizeof(FILE_FULL_EA_INFORMATION) +
                  TDI_TRANSPORT_ADDRESS_LENGTH + 1 +
                  sizeof(TA_IPX_ADDRESS)];

    PAGED_CODE( );

    //
    // Build the IPX socket address.
    //

    length = FIELD_OFFSET( FILE_FULL_EA_INFORMATION, EaName[0] ) +
                                TDI_TRANSPORT_ADDRESS_LENGTH + 1 +
                                sizeof(TA_IPX_ADDRESS);
    ea = (PFILE_FULL_EA_INFORMATION)buffer;

    ea->NextEntryOffset = 0;
    ea->Flags = 0;
    ea->EaNameLength = TDI_TRANSPORT_ADDRESS_LENGTH;
    ea->EaValueLength = sizeof (TA_IPX_ADDRESS);

    RtlCopyMemory( ea->EaName, StrTransportAddress, ea->EaNameLength + 1 );

    //
    // Create a copy of the NETBIOS address descriptor in a local
    // first, in order to avoid alignment problems.
    //

    ipxAddress.TAAddressCount = 1;
    ipxAddress.Address[0].AddressType = TDI_ADDRESS_TYPE_IPX;
    ipxAddress.Address[0].AddressLength = sizeof (TDI_ADDRESS_IPX);
    ipxAddress.Address[0].Address[0].Socket = Socket;

    RtlCopyMemory(
        &ea->EaName[ea->EaNameLength + 1],
        &ipxAddress,
        sizeof(TA_IPX_ADDRESS)
        );

    InitializeObjectAttributes( &objectAttributes, DeviceName, 0, NULL, NULL );

    status = NtCreateFile (
                 Handle,
                 FILE_READ_ATTRIBUTES | FILE_WRITE_ATTRIBUTES, // desired access
                 &objectAttributes,     // object attributes
                 &iosb,                 // returned status information
                 NULL,                  // block size (unused)
                 0,                     // file attributes
                 FILE_SHARE_READ | FILE_SHARE_WRITE, // share access
                 FILE_CREATE,           // create disposition
                 0,                     // create options
                 buffer,                // EA buffer
                 length                 // EA length
                 );

    if ( !NT_SUCCESS(status) ) {
        return status;
    }

    status = SrvVerifyDeviceStackSize(
                *Handle,
                TRUE,
                FileObject,
                DeviceObject,
                NULL
                );

    if ( !NT_SUCCESS( status ) ) {
        INTERNAL_ERROR(
            ERROR_LEVEL_EXPECTED,
            "OpenIpxSocket: Verify Device Stack Size failed: %X\n",
            status,
            NULL
            );
        return status;
    }

    return STATUS_SUCCESS;

} // OpenIpxSocket


VOID
SrvPrepareReceiveWorkItem (
    IN OUT PWORK_CONTEXT WorkContext,
    IN BOOLEAN QueueItemToFreeList
    )

/*++

Routine Description:

    This routine initializes a Receive work item and optionally queues
    it to a list anchored in the server FSD device object.  The
    transport receive event handler in the FSD dequeues work items from
    this list and passes their associated IRPS to the transport
    provider.

Arguments:

    WorkContext - Supplies a pointer to the preallocated work context
        block that represents the work item.

    QueueItemToFreeList - If TRUE queue this work item on the receive
        free queue.

Return Value:

    None.

--*/

{
    PSMB_HEADER header;

    IF_DEBUG(TRACE2) KdPrint(( "SrvPrepareReceiveWorkItem entered\n" ));

    //
    // Set up pointers to the SMB header and parameters for the request
    // and the response.  Note that we currently write the response over
    // the request.  SMB processors must be able to handle this.  We
    // maintain separate request and response pointers so that we can
    // use a separate buffer if necessary.  Maintaining separate request
    // and response parameter pointers also allows us to process AndX
    // SMBs without having to pack the AndX commands as we go.
    //

    WorkContext->ResponseBuffer = WorkContext->RequestBuffer;

    header = (PSMB_HEADER)WorkContext->RequestBuffer->Buffer;

    WorkContext->RequestHeader = header;
    WorkContext->RequestParameters = (PVOID)(header + 1);

    WorkContext->ResponseHeader = header;
    WorkContext->ResponseParameters = (PVOID)(header + 1);

    //
    // Set up the restart routine in the work context.
    //

    WorkContext->FsdRestartRoutine = SrvQueueWorkToFspAtDpcLevel;
    WorkContext->FspRestartRoutine = SrvRestartReceive;

    if ( QueueItemToFreeList ) {

        //
        // Queue the prepared receive work item to the FSD list.
        //

        GET_SERVER_TIME( WorkContext->CurrentWorkQueue, &WorkContext->Timestamp );
        RETURN_FREE_WORKITEM( WorkContext );

    } else {

        //
        // Make the work item look like it's in use by setting its
        // reference count to 1.
        //

        ASSERT( WorkContext->BlockHeader.ReferenceCount == 0 );
        WorkContext->BlockHeader.ReferenceCount = 1;

    }

    return;

} // SrvPrepareReceiveWorkItem


VOID SRVFASTCALL
SrvRestartAccept (
    IN OUT PWORK_CONTEXT WorkContext
    )

/*++

Routine Description:

    This function is the worker thread restart routine for Accept
    requests.  If the endpoint on which the connection was established
    is no longer active, this routine disconnects the connection.  This
    is necessary because the connect indication handler cannot
    atomically verify that the endpoint is active and install the active
    connection.  (This is because the handler runs at DPC level.)

    This routine also checks the status of the TdiAccept.  In case of
    an error, it frees the connection.

    If all is well, but the endpoint is short of free connections, a new
    one is created.

Arguments:

    WorkContext - Supplies a pointer to the work context block describing
        server-specific context for the request.

Return Value:

    None.

--*/

{
    PCONNECTION connection;
    PENDPOINT endpoint;
    PIRP irp;
    NTSTATUS status;

    PAGED_CODE( );

    IF_DEBUG(WORKER1) KdPrint(( " - SrvRestartAccept\n" ));

    connection = WorkContext->Connection;
    endpoint = WorkContext->Endpoint;
    irp = WorkContext->Irp;
    IF_DEBUG(TRACE2) {
        KdPrint(( "  connection %p, endpoint %p, IRP %p\n",
                    connection, endpoint, irp ));
    }

    //
    // If the I/O request failed or was canceled, or if the endpoint
    // block is closing, clean up.
    //

    ACQUIRE_LOCK( &SrvEndpointLock );

    if ( irp->Cancel ||
         !NT_SUCCESS(irp->IoStatus.Status) ||
         (GET_BLOCK_STATE(endpoint) != BlockStateActive) ) {

        RELEASE_LOCK( &SrvEndpointLock );

        DEBUG {
            KdPrint(( "SrvRestartAccept:  Accept failed!" ));
            if ( irp->Cancel ) {
                KdPrint(( "  I/O canceled\n" ));
            } else if ( !NT_SUCCESS(irp->IoStatus.Status) ) {
                KdPrint(( "  I/O failed: %X\n", irp->IoStatus.Status ));
            } else {
                KdPrint(( "  Endpoint no longer active\n" ));
            }
        }

        //
        // Close the connection.  If the Accept succeeded, we need to
        // issue a Disconnect.
        //

#if SRVDBG29
        if (irp->Cancel) {
            UpdateConnectionHistory( "ACC1", endpoint, connection );
        } else if (!NT_SUCCESS(irp->IoStatus.Status)) {
            UpdateConnectionHistory( "ACC2", endpoint, connection );
        } else {
            UpdateConnectionHistory( "ACC3", endpoint, connection );
        }
#endif

        connection->DisconnectReason = DisconnectAcceptFailedOrCancelled;
        SrvCloseConnection(
            connection,
            (BOOLEAN)(irp->Cancel || !NT_SUCCESS(irp->IoStatus.Status) ?
                        TRUE : FALSE)       // RemoteDisconnect
            );

    } else {

        PNBT_ADDRESS_PAIR_INFO AddressPairInfo;
        UNICODE_STRING clientMachineName;

        //
        // The Accept worked, and the endpoint is still active.  Create
        // a new free connection, if necessary.
        //

        if ( endpoint->FreeConnectionCount < SrvFreeConnectionMinimum ) {
            (VOID)SrvOpenConnection( endpoint );
        }

        RELEASE_LOCK( &SrvEndpointLock );

        //
        // Get the IP address of the client (if it has one)
        //
        AddressPairInfo = WorkContext->RequestBuffer->Buffer;
        AddressPairInfo = (PNBT_ADDRESS_PAIR_INFO)(((ULONG_PTR)AddressPairInfo + 7) & ~7);

        //
        // Get the IP address of the client, if appropriate
        //
        status = SrvIssueTdiQuery(  connection->FileObject,
                                    &connection->DeviceObject,
                                    (PCHAR)AddressPairInfo, sizeof( *AddressPairInfo ),
                                    TDI_QUERY_ADDRESS_INFO
                                 );

        if( NT_SUCCESS( status ) &&
            AddressPairInfo->AddressPair.TAAddressCount == 2 &&
            AddressPairInfo->AddressPair.AddressIP.AddressType == TDI_ADDRESS_TYPE_IP ) {

            PTCP_REQUEST_SET_INFORMATION_EX tcpSetInfo;
            struct TCPKeepalive *keepAlive;
            IO_STATUS_BLOCK iosb;

            connection->ClientIPAddress = AddressPairInfo->AddressPair.AddressIP.Address.in_addr;

            //
            // We have an IP client.  Set a reasonable keepalive interval.
            //
            tcpSetInfo = ALLOCATE_HEAP( sizeof(*tcpSetInfo) + sizeof( *keepAlive ), BlockTypeMisc );

            if( tcpSetInfo != NULL ) {

                RtlZeroMemory( tcpSetInfo, sizeof( *tcpSetInfo ) + sizeof( *keepAlive ) );

                tcpSetInfo->ID.toi_entity.tei_entity = CO_TL_ENTITY;
                tcpSetInfo->ID.toi_class = INFO_CLASS_PROTOCOL;
                tcpSetInfo->ID.toi_type = INFO_TYPE_CONNECTION;
                tcpSetInfo->ID.toi_id = TCP_SOCKET_KEEPALIVE_VALS;

                tcpSetInfo->BufferSize = sizeof( *keepAlive );
                keepAlive = (TCPKeepalive *)(&tcpSetInfo->Buffer[0]);

                keepAlive->onoff = TRUE;     // turn on keepalives

                //
                // keepalive time is the time to first keepalive transmission, by default it
                // is 2 hours (7,200,000 milliseconds) for TCP. If there is no data transfer between
                // client and server for keepalive time, the server will send first keepalive
                // probe. Successive probes are determined by keepalive interval. If there is any
                // data transfer, timer is reset to keepalive time.
                //
                // keepalive interval is the interval in milliseconds between keepalive transmissions
                // until a response is received, by default it is 1000.  Server sends a total of 10
                // keepalive probes, keepalive interval apart, and if there is no response from the
                // client, the connection is terminated.
                //
                keepAlive->keepalivetime =  2 * (60 * 1000);    // 2 minutes
                keepAlive->keepaliveinterval = 2 * 1000;        // 2 seconds

                //
                // Set the keepalive values
                //
                (VOID)NtDeviceIoControlFile(
                                        connection->PagedConnection->ConnectionHandle,
                                        0,
                                        NULL,
                                        NULL,
                                        &iosb,
                                        IOCTL_NETBT_SET_TCP_CONNECTION_INFO,
                                        tcpSetInfo, sizeof( *tcpSetInfo ) + sizeof( *keepAlive ),
                                        NULL, 0
                                    );

                FREE_HEAP( tcpSetInfo );
            }

        } else {

            connection->ClientIPAddress = 0;
        }

        //
        // Convert the client machine name to unicode
        //

        clientMachineName.Buffer = connection->PagedConnection->ClientMachineName;
        clientMachineName.MaximumLength =
                        (USHORT)(COMPUTER_NAME_LENGTH+1)*sizeof(WCHAR);

        (VOID)RtlOemStringToUnicodeString(
                        &clientMachineName,
                        &connection->OemClientMachineNameString,
                        FALSE
                        );

        //
        // Add the double backslashes to the length
        //

        connection->PagedConnection->ClientMachineNameString.Length =
                        (USHORT)(clientMachineName.Length + 2*sizeof(WCHAR));

    }

    SrvDereferenceWorkItem( WorkContext );

    IF_DEBUG(TRACE2) KdPrint(( "SrvRestartAccept complete\n" ));
    return;

} // SrvRestartAccept


VOID
SrvStartSend (
    IN OUT PWORK_CONTEXT WorkContext,
    IN PIO_COMPLETION_ROUTINE SendCompletionRoutine,
    IN PMDL Mdl OPTIONAL,
    IN ULONG SendOptions
    )

/*++

Routine Description:

    This function starts a Send request.  It is started as an
    asynchronous I/O request.  When the Send completes, it is delivered
    via the I/O completion routine to the server FSD, which routes it to
    the specified FsdRestartRoutine.  (This may be
    SrvQueueWorkToFspAtDpcLevel, which queues the work item to the FSP
    at the FspRestartRoutine.)

    Partial sends and chained sends are supported.  A partial send is one
    that is not the last segment of a "message" or "record".  A chained
    send is one made up of multiple virtually discontiguous buffers.

Arguments:

    WorkContext - Supplies a pointer to a Work Context block.  The
        following fields of this structure must be valid:

            TdiRequest
            Irp (optional; actual address copied here)
            Endpoint
                Endpoint->FileObject
                Endpoint->DeviceObject
            Connection
                Connection->ConnectionId

    Mdl - Supplies a pointer to the first (or only) MDL describing the
        data that is to be sent.  To effect a chained send, the Next
        pointer of each MDL in the chain must point to the next MDL;
        the end of the chain is indicated by the NULL Next pointer.

        The total length of the send is calculated by summing the
        ByteCount fields of each MDL in the chain.

        This parameter is optional.  If it is omitted, a zero-length
        message is sent.

    SendOptions - Supplied TDI send options, which indicate whether this
        send is the last (or only) in a "chain" of partial sends.

Return Value:

    None.

--*/

{
    PTDI_REQUEST_KERNEL_SEND parameters;
    PIO_STACK_LOCATION irpSp;
    PIRP irp;
    ULONG sendLength;
    PDEVICE_OBJECT deviceObject;
    PFILE_OBJECT fileObject;

    IF_DEBUG(TRACE2) KdPrint(( "SrvStartSend entered\n" ));

    ASSERT( !WorkContext->Endpoint->IsConnectionless );

    //
    // Set ProcessingCount to zero so this send cannot be cancelled.
    // This is used together with setting the cancel flag to false below.
    //
    // WARNING: This still presents us with a tiny window where this
    // send could be cancelled.
    //

    WorkContext->ProcessingCount = 0;

    //
    // Get the irp, device, and file objects
    //

    irp = WorkContext->Irp;
    deviceObject = WorkContext->Connection->DeviceObject;
    fileObject = WorkContext->Connection->FileObject;

    CHECKIRP( irp );

    if( irp->AssociatedIrp.SystemBuffer &&
        (irp->Flags & IRP_DEALLOCATE_BUFFER) ) {

        ExFreePool( irp->AssociatedIrp.SystemBuffer );
        irp->Flags &= ~IRP_DEALLOCATE_BUFFER;
    }

    sendLength = WorkContext->ResponseBuffer->DataLength;

    //
    // Build the I/O request packet.
    //
    // *** Note that the connection block is not referenced to account
    //     for this I/O request.  The WorkContext block already has a
    //     referenced pointer to the connection, and this pointer is not
    //     dereferenced until after the I/O completes.
    //

    ASSERT( irp->StackCount >= deviceObject->StackSize );

    irp->Tail.Overlay.OriginalFileObject = fileObject;
    irp->Tail.Overlay.Thread = WorkContext->CurrentWorkQueue->IrpThread;
    DEBUG irp->RequestorMode = KernelMode;
    //
    // Get a pointer to the next stack location.  This one is used to
    // hold the parameters for the device I/O control request.
    //

    irpSp = IoGetNextIrpStackLocation( irp );

    //
    // Set up the completion routine.
    //

    IoSetCompletionRoutine(
        irp,
        SendCompletionRoutine,
        (PVOID)WorkContext,
        TRUE,
        TRUE,
        TRUE
        );


    irpSp->FileObject = fileObject;

    parameters = (PTDI_REQUEST_KERNEL_SEND)&irpSp->Parameters;
    parameters->SendFlags = SendOptions;
    parameters->SendLength = sendLength;

    //
    // For these two cases, InputBuffer is the buffered I/O "system
    // buffer".  Build an MDL for either read or write access,
    // depending on the method, for the output buffer.
    //

    irp->MdlAddress = Mdl;

    //
    // If statistics are to be gathered for this work item, do so now.
    //

    UPDATE_STATISTICS(
        WorkContext,
        sendLength,
        WorkContext->ResponseHeader->Command
        );

#if DBG
    if( sendLength >= sizeof( SMB_HEADER ) && sendLength <= 0xffff && Mdl ) {

        PSMB_HEADER Smb = MmGetSystemAddressForMdl( Mdl );

        if ( SmbGetAlignedUlong( (PULONG)Smb->Protocol ) == SMB_HEADER_PROTOCOL ) {

            ULONG len;
            PMDL tmpMdl;

            //
            // For debugging purposes, put extra data in the response smb. This will help us figure
            // out what went wrong if the client detects an SMB format error
            //

            //
            // Put the send length in PidHigh
            //
            SmbPutUshort( &Smb->PidHigh, (USHORT)sendLength );

            //
            // Put the overall MDL length in Pid.  The transport is only supposed to transmit SendLength -- so
            //  this will help us figure out if the transport is sending too much data.
            //
            for( len = 0, tmpMdl = Mdl; tmpMdl != NULL; tmpMdl = tmpMdl->Next ) {
                len += MmGetMdlByteCount( tmpMdl );
            }

            SmbPutUshort( &Smb->Pid, (USHORT)len );
        }
    }
#endif

    //
    // If we are doing security signatures, we need to sign this packet
    //
    if( sendLength &&
        WorkContext->Connection &&
        WorkContext->Connection->SmbSecuritySignatureActive == TRUE &&
        WorkContext->NoResponseSmbSecuritySignature == FALSE ) {

        SrvAddSmbSecuritySignature( WorkContext, Mdl, sendLength );
    }

    //
    // Pass the request to the transport provider.
    //
    IF_DEBUG(TRACE2) {
        KdPrint(( "SrvStartSend posting Send IRP %p\n", irp ));
    }

    //
    // If SmbTrace is active and we're in a context where the SmbTrace
    // shared section isn't accessible, send this off to the FSP.
    //

    WorkContext->Irp->Cancel = FALSE;

    if ( SmbTraceActive[SMBTRACE_SERVER] ) {

        if ((KeGetCurrentIrql() == DISPATCH_LEVEL) ||
            (IoGetCurrentProcess() != SrvServerProcess) ) {

            irpSp->MajorFunction = IRP_MJ_INTERNAL_DEVICE_CONTROL;
            irpSp->MinorFunction = TDI_SEND;
            irp->AssociatedIrp.SystemBuffer = NULL;
            irp->Flags = (ULONG)IRP_BUFFERED_IO;

            WorkContext->Parameters2.StartSend.FspRestartRoutine =
                                            WorkContext->FspRestartRoutine;
            WorkContext->Parameters2.StartSend.SendLength = sendLength;

            WorkContext->FspRestartRoutine = RestartStartSend;
            SrvQueueWorkToFsp( WorkContext );

            return;

        } else {

            SMBTRACE_SRV( Mdl );

        }
    }

    //
    // Increment the pending operation count
    //
    InterlockedIncrement( &WorkContext->Connection->OperationsPendingOnTransport );

    //
    // Set the cancel flag to FALSE in case this was cancelled by
    // the SrvSmbNtCancel routine.
    //

    if ( WorkContext->Endpoint->FastTdiSend ) {

        INCREMENT_DEBUG_STAT2( SrvDbgStatistics.DirectSendsAttempted );
        irpSp->MinorFunction = TDI_DIRECT_SEND;
        DEBUG irpSp->DeviceObject = deviceObject;
        IoSetNextIrpStackLocation( irp );
        WorkContext->Endpoint->FastTdiSend( deviceObject, irp );

    } else {

        irpSp->MajorFunction = IRP_MJ_INTERNAL_DEVICE_CONTROL;
        irpSp->MinorFunction = TDI_SEND;
        irp->AssociatedIrp.SystemBuffer = NULL;
        irp->Flags = (ULONG)IRP_BUFFERED_IO;

        (VOID)IoCallDriver( deviceObject, irp );
    }

    IF_DEBUG(TRACE2) KdPrint(( "SrvStartSend complete\n" ));
    return;

} // SrvStartSend

VOID
SrvStartSend2 (
    IN OUT PWORK_CONTEXT WorkContext,
    IN PIO_COMPLETION_ROUTINE SendCompletionRoutine
    )

/*++

Routine Description:

    This function starts a Send request.  It is started as an
    asynchronous I/O request.  When the Send completes, it is delivered
    via the I/O completion routine to the server FSD, which routes it to
    the specified FsdRestartRoutine.  (This may be
    SrvQueueWorkToFspAtDpcLevel, which queues the work item to the FSP
    at the FspRestartRoutine.)

    Partial sends and chained sends are supported.  A partial send is one
    that is not the last segment of a "message" or "record".  A chained
    send is one made up of multiple virtually discontiguous buffers.

    ** This is identical to SrvStartSend except that the parameter mdl
    is assumed to be ResponseBuffer->Mdl and sendOptions is assumed to be
    0 **

Arguments:

    WorkContext - Supplies a pointer to a Work Context block.  The
        following fields of this structure must be valid:

            TdiRequest
            Irp (optional; actual address copied here)
            Endpoint
                Endpoint->FileObject
                Endpoint->DeviceObject
            Connection
                Connection->ConnectionId

Return Value:

    None.

--*/

{
    PTDI_REQUEST_KERNEL_SEND parameters;
    PIO_STACK_LOCATION irpSp;
    PIRP irp;
    PDEVICE_OBJECT deviceObject;
    PFILE_OBJECT fileObject;

    PMDL mdl = WorkContext->ResponseBuffer->Mdl;
    ULONG sendLength = WorkContext->ResponseBuffer->DataLength;

    IF_DEBUG(TRACE2) KdPrint(( "SrvStartSend2 entered\n" ));

    ASSERT( !WorkContext->Endpoint->IsConnectionless );

    //
    // Set ProcessingCount to zero so this send cannot be cancelled.
    // This is used together with setting the cancel flag to false below.
    //
    // WARNING: This still presents us with a tiny window where this
    // send could be cancelled.
    //

    WorkContext->ProcessingCount = 0;

    //
    // Get the irp, device, and file objects
    //

    irp = WorkContext->Irp;
    deviceObject = WorkContext->Connection->DeviceObject;
    fileObject = WorkContext->Connection->FileObject;

    CHECKIRP( irp );

    if( irp->AssociatedIrp.SystemBuffer &&
        (irp->Flags & IRP_DEALLOCATE_BUFFER) ) {

        ExFreePool( irp->AssociatedIrp.SystemBuffer );
        irp->Flags &= ~IRP_DEALLOCATE_BUFFER;
    }

    //
    // Build the I/O request packet.
    //
    // *** Note that the connection block is not referenced to account
    //     for this I/O request.  The WorkContext block already has a
    //     referenced pointer to the connection, and this pointer is not
    //     dereferenced until after the I/O completes.
    //

    ASSERT( irp->StackCount >= deviceObject->StackSize );

    irp->Tail.Overlay.OriginalFileObject = fileObject;
    irp->Tail.Overlay.Thread = WorkContext->CurrentWorkQueue->IrpThread;
    DEBUG irp->RequestorMode = KernelMode;

    //
    // Get a pointer to the next stack location.  This one is used to
    // hold the parameters for the device I/O control request.
    //

    irpSp = IoGetNextIrpStackLocation( irp );

    //
    // Set up the completion routine.
    //

    IoSetCompletionRoutine(
        irp,
        SendCompletionRoutine,
        (PVOID)WorkContext,
        TRUE,
        TRUE,
        TRUE
        );

    irpSp->FileObject = fileObject;

    parameters = (PTDI_REQUEST_KERNEL_SEND)&irpSp->Parameters;
    parameters->SendFlags = 0;
    parameters->SendLength = sendLength;

    //
    // For these two cases, InputBuffer is the buffered I/O "system
    // buffer".  Build an MDL for either read or write access,
    // depending on the method, for the output buffer.
    //

    irp->MdlAddress = mdl;

    //
    // If statistics are to be gathered for this work item, do so now.
    //

    UPDATE_STATISTICS(
        WorkContext,
        sendLength,
        WorkContext->ResponseHeader->Command
        );

#if DBG
    if( sendLength >= sizeof( SMB_HEADER ) && sendLength <= 0xffff && mdl ) {

        PSMB_HEADER Smb = MmGetSystemAddressForMdl( mdl );

        if ( SmbGetAlignedUlong( (PULONG)Smb->Protocol ) == SMB_HEADER_PROTOCOL ) {

            ULONG len;
            PMDL tmpMdl;

            //
            // For debugging purposes, put extra data in the response smb. This
            // will help us figure out what went wrong if the client detects an
            // SMB format error
            //

            //
            // Put the send length in PidHigh
            //
            SmbPutUshort( &Smb->PidHigh, (USHORT)sendLength );

            //
            // Put the overall MDL length in Pid.  The transport is only supposed
            // to transmit SendLength -- so this will help us figure out if the
            // transport is sending too much data.
            //
            for( len = 0, tmpMdl = mdl; tmpMdl != NULL; tmpMdl = tmpMdl->Next ) {
                len += MmGetMdlByteCount( tmpMdl );
            }

            SmbPutUshort( &Smb->Pid, (USHORT)len );
        }
    }
#endif

    //
    // If we are doing security signatures, we need to sign this packet
    //
    if( sendLength &&
        WorkContext->Connection &&
        WorkContext->Connection->SmbSecuritySignatureActive == TRUE &&
        WorkContext->NoResponseSmbSecuritySignature == FALSE ) {

        SrvAddSmbSecuritySignature( WorkContext, mdl, sendLength );
    }

    //
    // Pass the request to the transport provider.
    //

    IF_DEBUG(TRACE2) {
        KdPrint(( "SrvStartSend2 posting Send IRP %p\n", irp ));
    }

    //
    // If SmbTrace is active and we're in a context where the SmbTrace
    // shared section isn't accessible, send this off to the FSP.
    //

    WorkContext->Irp->Cancel = FALSE;

    if ( SmbTraceActive[SMBTRACE_SERVER] ) {

        if ((KeGetCurrentIrql() == DISPATCH_LEVEL) ||
            (IoGetCurrentProcess() != SrvServerProcess) ) {

            irpSp->MajorFunction = IRP_MJ_INTERNAL_DEVICE_CONTROL;
            irpSp->MinorFunction = TDI_SEND;
            irp->AssociatedIrp.SystemBuffer = NULL;
            irp->Flags = (ULONG)IRP_BUFFERED_IO;

            WorkContext->Parameters2.StartSend.FspRestartRoutine =
                                            WorkContext->FspRestartRoutine;
            WorkContext->Parameters2.StartSend.SendLength = sendLength;

            WorkContext->FspRestartRoutine = RestartStartSend;
            SrvQueueWorkToFsp( WorkContext );

            return;

        } else {

            SMBTRACE_SRV( mdl );

        }
    }

    //
    // Increment the pending operation count
    //
    InterlockedIncrement( &WorkContext->Connection->OperationsPendingOnTransport );

    //
    // Set the cancel flag to FALSE in case this was cancelled by
    // the SrvSmbNtCancel routine.
    //

    if ( WorkContext->Endpoint->FastTdiSend ) {

        INCREMENT_DEBUG_STAT2( SrvDbgStatistics.DirectSendsAttempted );
        irpSp->MinorFunction = TDI_DIRECT_SEND;
        DEBUG irpSp->DeviceObject = deviceObject;
        IoSetNextIrpStackLocation( irp );
        WorkContext->Endpoint->FastTdiSend( deviceObject, irp );

    } else {

        irpSp->MajorFunction = IRP_MJ_INTERNAL_DEVICE_CONTROL;
        irpSp->MinorFunction = TDI_SEND;
        irp->AssociatedIrp.SystemBuffer = NULL;
        irp->Flags = (ULONG)IRP_BUFFERED_IO;

        (VOID)IoCallDriver( deviceObject, irp );
    }

    IF_DEBUG(TRACE2) KdPrint(( "SrvStartSend2 complete\n" ));
    return;

} // SrvStartSend2


VOID SRVFASTCALL
RestartStartSend (
    IN OUT PWORK_CONTEXT WorkContext
    )

/*++

Routine Description:

Arguments:

    WorkContext - Supplies a pointer to a Work Context block.

Return Value:

    None.

--*/

{
    PAGED_CODE( );

    WorkContext->FspRestartRoutine =
                        WorkContext->Parameters2.StartSend.FspRestartRoutine;

    SMBTRACE_SRV( WorkContext->Irp->MdlAddress );
        
    //
    // Increment the pending operation count
    //
    InterlockedIncrement( &WorkContext->Connection->OperationsPendingOnTransport );

    //
    // Set the cancel flag to FALSE in case this was cancelled by
    // the SrvSmbNtCancel routine.
    //

    WorkContext->Irp->Cancel = FALSE;
    (VOID)IoCallDriver(
              IoGetNextIrpStackLocation( WorkContext->Irp )->DeviceObject,
              WorkContext->Irp
              );

    IF_DEBUG(TRACE2) KdPrint(( "SrvRestartStartSend complete\n" ));
    return;

} // RestartStartSend

ULONG
GetIpxMaxBufferSize(
    PENDPOINT Endpoint,
    ULONG AdapterNumber,
    ULONG DefaultMaxBufferSize
    )

/*++

Routine Description:

    This routine computes the max buffer size the server negotiates
    with the client.  It takes the smaller of DefaultMaxBufferSize
    and the max packet length returned by the ipx transport.

Arguments:

    Endpoint - pointer to the endpoint corresponding to the ipx transport
    AdapterNumber - the adapter number for which the max buffer size is to
        be computed for.
    DefaultMaxBufferSize - the maximum size that can be returned by this
        routine.

Return Value:

    The max buffer size to be negotiated by the server.

--*/

{
    NTSTATUS status;
    ULONG maxBufferSize;
    PNWLINK_ACTION action;
    PIPX_ADDRESS_DATA ipxAddressData;
    UCHAR buffer[sizeof(NWLINK_ACTION) + sizeof(IPX_ADDRESS_DATA) - 1];

    PAGED_CODE( );

    action = (PNWLINK_ACTION)buffer;

    //
    // Verify that the adapter number is within bounds
    //

    if ( AdapterNumber > Endpoint->MaxAdapters ) {
        return DefaultMaxBufferSize;
    }

    //
    // If value in array is non-zero, then this is not a wan link.
    // Use that value.
    //

    if ( Endpoint->IpxMaxPacketSizeArray[AdapterNumber-1] != 0 ) {

        maxBufferSize = MIN(
            Endpoint->IpxMaxPacketSizeArray[AdapterNumber-1],
            DefaultMaxBufferSize
            );

        return (maxBufferSize & ~3);
    }

    //
    // This is a wan link, query the max packet size.
    //

    action->Header.TransportId = 'XPIM'; // "MIPX"
    action->Header.ActionCode = 0;
    action->Header.Reserved = 0;
    action->OptionType = NWLINK_OPTION_ADDRESS;
    action->BufferLength = sizeof(action->Option) + sizeof(IPX_ADDRESS_DATA);
    action->Option = MIPX_GETCARDINFO2;
    ipxAddressData = (PIPX_ADDRESS_DATA)action->Data;

    ipxAddressData->adapternum = AdapterNumber - 1;

    status = SrvIssueTdiAction(
                Endpoint->NameSocketFileObject,
                &Endpoint->NameSocketDeviceObject,
                (PCHAR)action,
                sizeof(NWLINK_ACTION) + sizeof(IPX_ADDRESS_DATA) - 1
                );

    if ( !NT_SUCCESS(status) ) {
        return DefaultMaxBufferSize;
    }

    ASSERT( ipxAddressData->wan );

    maxBufferSize = MIN(
        (ULONG)ipxAddressData->maxpkt,
        DefaultMaxBufferSize
        );

    return (maxBufferSize & ~3);

} // GetMaxIpxPacketSize


VOID
SrvpNotifyChangesToNetBt(
    IN TDI_PNP_OPCODE   PnPOpcode,
    IN PUNICODE_STRING  DeviceName,
    IN PWSTR            MultiSZBindList)

/*++

Routine Description:

    This routine should not be part of srv. It has been introduced into this
    component to overcome current limitations in NetBt. The NetBt transport
    exposes two  kinds of devices -- the traditional NetBt device and the
    new non Netbios device which make use of the NetBt framing code without the
    name resolution aspects of it. The current implementation in NetBt exposes
    the former devices on a per adapter basis while the second category of device
    is exposed on a global basis ( one for all the adapters ). This poses
    problems in disabling/enabling srv on a given adapter.

    The correct solution is to expose the second category of devices on a per
    adapter basis. Till it is done this workaround is reqd. With this workaround
    whenever the server is notified of any changes to the binding string it turns
    around and notifies the NetBt transport about these changes.

    This routine is based upon the following assumptions ...

        1) The notification from TDI is not done at raised IRQL.

        2) The thread on which this notification occurs has enough access rights.

        3) The notification to NetBt is done asynchronously with srv's reaction
        to the change. The srv handles the PNP notification by passing it off to
        user mode and have it come through the server service.

Arguments:

    PNPOpcode - the PNP opcode

    DeviceName - the transport for which this opcode is intended

    MultiSZBindList - the binding list

Return Value:

    None.

--*/
{
    NTSTATUS          Status;
    OBJECT_ATTRIBUTES ObjectAttributes;
    HANDLE            NetbioslessSmbHandle;
    IO_STATUS_BLOCK   IoStatusBlock;
    UNICODE_STRING    NetbioslessSmbName = {36,36, L"\\device\\NetbiosSmb"};

    InitializeObjectAttributes(
        &ObjectAttributes,
        &NetbioslessSmbName,
        OBJ_CASE_INSENSITIVE,
        NULL,
        NULL );

    Status = ZwCreateFile (
                 &NetbioslessSmbHandle,
                 FILE_READ_ATTRIBUTES | FILE_WRITE_ATTRIBUTES, // desired access
                 &ObjectAttributes,     // object attributes
                 &IoStatusBlock,        // returned status information
                 NULL,                  // block size (unused)
                 0,                     // file attributes
                 FILE_SHARE_READ | FILE_SHARE_WRITE, // share access
                 FILE_CREATE,           // create disposition
                 0,                     // create options
                 NULL,                  // EA buffer
                 0                      // EA length
                 );

    if ( NT_SUCCESS(Status) ) {
        NETBT_SMB_BIND_REQUEST      NetBtNotificationParameters;

        NetBtNotificationParameters.RequestType = SMB_SERVER;
        NetBtNotificationParameters.PnPOpCode   = PnPOpcode;
        NetBtNotificationParameters.pDeviceName = DeviceName;
        NetBtNotificationParameters.MultiSZBindList = MultiSZBindList;

        Status = ZwDeviceIoControlFile(
                     NetbioslessSmbHandle,
                     NULL,
                     NULL,
                     NULL,
                     &IoStatusBlock,
                     IOCTL_NETBT_SET_SMBDEVICE_BIND_INFO,
                     &NetBtNotificationParameters,
                     sizeof(NetBtNotificationParameters),
                     NULL,
                     0);

        IF_DEBUG( ERRORS ) {
            KdPrint(("NtFsControlFile %wZ in SrvpNotifyChangesToNetBt status %X\n", &NetbioslessSmbName, Status ));
        }

        Status = ZwClose(NetbioslessSmbHandle);

        IF_DEBUG( ERRORS ) {
            KdPrint(("NtCloseFile %wZ in SrvpNotifyChangesToNetBt status %X\n", &NetbioslessSmbName, Status ));
        }
    } else {
        IF_DEBUG( ERRORS ) {
            KdPrint(("NtCreateFile %wZ in SrvpNotifyChangesToNetBt status %X\n", &NetbioslessSmbName, Status ));
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\srv\open.c ===
/*++

Copyright (c) 1989  Microsoft Corporation


Module Name:

    open.c

Abstract:

    This module contains the routine called by processing routines for
    the various flavors of Open SMBs (SrvCreateFile) and its
    subroutines.

    !!! Need to use SrvEnableFcbOpens to determine whether to fold FCB
        opens together.

Author:

    David Treadwell (davidtr) 23-Nov-1989
    Chuck Lenzmeier (chuckl)
    Manny Weiser (mannyw)

Revision History:

--*/

#include "precomp.h"
#include "open.tmh"
#pragma hdrstop

#define BugCheckFileId SRV_FILE_OPEN

//
// Local functions
//

NTSTATUS
DoNormalOpen(
    OUT PRFCB *Rfcb,
    IN PMFCB Mfcb,
    IN OUT PWORK_CONTEXT WorkContext,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    IN USHORT SmbDesiredAccess,
    IN USHORT SmbFileAttributes,
    IN USHORT SmbOpenFunction,
    IN ULONG SmbAllocationSize,
    IN PUNICODE_STRING RelativeName,
    IN PVOID EaBuffer OPTIONAL,
    IN ULONG EaLength,
    OUT PULONG EaErrorOffset OPTIONAL,
    OUT PBOOLEAN LfcbAddedToMfcbList,
    IN OPLOCK_TYPE RequestedOplockType
    );

NTSTATUS
DoCompatibilityOpen(
    OUT PRFCB *Rfcb,
    IN PMFCB Mfcb,
    IN OUT PWORK_CONTEXT WorkContext,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    IN USHORT SmbDesiredAccess,
    IN USHORT SmbFileAttributes,
    IN USHORT SmbOpenFunction,
    IN ULONG SmbAllocationSize,
    IN PUNICODE_STRING RelativeName,
    IN PVOID EaBuffer OPTIONAL,
    IN ULONG EaLength,
    OUT PULONG EaErrorOffset OPTIONAL,
    OUT PBOOLEAN LfcbAddedToMfcbList,
    IN OPLOCK_TYPE RequestedOplockType
    );


NTSTATUS
DoFcbOpen(
    OUT PRFCB *Rfcb,
    IN PMFCB Mfcb,
    IN OUT PWORK_CONTEXT WorkContext,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    IN USHORT SmbFileAttributes,
    IN USHORT SmbOpenFunction,
    IN ULONG SmbAllocationSize,
    IN PUNICODE_STRING RelativeName,
    IN PVOID EaBuffer OPTIONAL,
    IN ULONG EaLength,
    OUT PULONG EaErrorOffset OPTIONAL,
    OUT PBOOLEAN LfcbAddedToMfcbList
    );

NTSTATUS
DoCommDeviceOpen (
    IN OUT PWORK_CONTEXT WorkContext,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    IN USHORT SmbDesiredAccess,
    IN USHORT SmbOpenFunction,
    OUT PRFCB *Rfcb,
    IN PMFCB Mfcb,
    OUT PBOOLEAN LfcbAddedToMfcbList
    );

PTABLE_ENTRY
FindAndClaimFileTableEntry (
    IN PCONNECTION Connection,
    OUT PSHORT FidIndex
    );

NTSTATUS
CompleteOpen(
    OUT PRFCB *Rfcb,
    IN PMFCB Mfcb,
    IN OUT PWORK_CONTEXT WorkContext,
    IN PLFCB ExistingLfcb OPTIONAL,
    IN HANDLE FileHandle OPTIONAL,
    IN PACCESS_MASK RemoteGrantedAccess OPTIONAL,
    IN ULONG ShareAccess,
    IN ULONG FileMode,
    IN BOOLEAN CompatibilityOpen,
    IN BOOLEAN FcbOpen,
    OUT PBOOLEAN LfcbAddedToMfcbList
    );

BOOLEAN SRVFASTCALL
MapCompatibilityOpen(
    IN PUNICODE_STRING FileName,
    IN OUT PUSHORT SmbDesiredAccess
    );

NTSTATUS SRVFASTCALL
MapDesiredAccess(
    IN USHORT SmbDesiredAccess,
    OUT PACCESS_MASK NtDesiredAccess
    );

NTSTATUS SRVFASTCALL
MapOpenFunction(
    IN USHORT SmbOpenFunction,
    OUT PULONG CreateDisposition
    );

NTSTATUS SRVFASTCALL
MapShareAccess(
    IN USHORT SmbDesiredAccess,
    OUT PULONG NtShareAccess
    );

NTSTATUS SRVFASTCALL
MapCacheHints(
    IN USHORT SmbDesiredAccess,
    IN OUT PULONG NtCreateFlags
    );

BOOLEAN
SetDefaultPipeMode (
    IN HANDLE FileHandle
    );

NTSTATUS
RemapPipeName(
    IN PANSI_STRING AnsiServerName OPTIONAL,
    IN PUNICODE_STRING ServerName OPTIONAL,
    IN OUT PUNICODE_STRING NewRelativeName,
    OUT PBOOLEAN Remapped
    );

BOOLEAN
SrvFailMdlReadDev (
    IN PFILE_OBJECT FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN ULONG Length,
    IN ULONG LockKey,
    OUT PMDL *MdlChain,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject
    );

BOOLEAN
SrvFailPrepareMdlWriteDev(
    IN PFILE_OBJECT FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN ULONG Length,
    IN ULONG LockKey,
    OUT PMDL *MdlChain,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text( PAGE, RemapPipeName )
#pragma alloc_text( PAGE, SrvCreateFile )
#pragma alloc_text( PAGE, DoNormalOpen )
#pragma alloc_text( PAGE, DoCompatibilityOpen )
#pragma alloc_text( PAGE, DoFcbOpen )
#pragma alloc_text( PAGE, CompleteOpen )
#pragma alloc_text( PAGE, MapCompatibilityOpen )
#pragma alloc_text( PAGE, MapDesiredAccess )
#pragma alloc_text( PAGE, MapOpenFunction )
#pragma alloc_text( PAGE, MapCacheHints )
#pragma alloc_text( PAGE, MapShareAccess )
#pragma alloc_text( PAGE, SrvNtCreateFile )
#pragma alloc_text( PAGE, SetDefaultPipeMode )
#pragma alloc_text( PAGE8FIL, FindAndClaimFileTableEntry )
#pragma alloc_text( PAGE, SrvFailMdlReadDev )
#pragma alloc_text( PAGE, SrvFailPrepareMdlWriteDev )
#endif


NTSTATUS
RemapPipeName(
    IN PANSI_STRING AnsiServerName,
    IN PUNICODE_STRING UnicodeName,
    IN OUT PUNICODE_STRING NewRelativeName,
    OUT PBOOLEAN Remapped
    )

/*++

Routine Description:

    Remaps a pipe name by prepending "$$\<AnsiServerName>\" to the
    relative pipe name (without the trailing spaces in AnsiServerName).

Arguments:

    AnsiServerName - NetBIOS server name, or
    UnicodeName - UNICODE server name

    NewRelativeName - pointer to pipe name; on successful return,
    points to newly allocated memory for remapped pipe name.
    This memory must be freed by the caller.

    Remapped - set to TRUE if the name was remapped

Return Value:

    NTSTATUS - Indicates what occurred.

--*/

{
    UNICODE_STRING OldRelativeName;
    UNICODE_STRING UnicodeServerName;
    ULONG nameLength;
    PWCH nextLocation;
    NTSTATUS status;
    int i;

    PAGED_CODE();

    *Remapped = FALSE;

    //
    // Do not remap  the pipe name if it is in our SrvNoRemapPipeNames list
    //
    ACQUIRE_LOCK_SHARED( &SrvConfigurationLock );

    for ( i = 0; SrvNoRemapPipeNames[i] != NULL ; i++ ) {

        UNICODE_STRING NoRemap;

        RtlInitUnicodeString( &NoRemap, SrvNoRemapPipeNames[i] );

        if( RtlCompareUnicodeString( &NoRemap, NewRelativeName, TRUE ) == 0 ) {

            //
            // This is a pipe name that we are not supposed to remap.  We
            //  return STATUS_SUCCESS, but indicate to our caller that we did
            //  not remap the pipe name
            //
            RELEASE_LOCK( &SrvConfigurationLock );
            return STATUS_SUCCESS;
        }
    }

    RELEASE_LOCK( &SrvConfigurationLock );

    //
    // Save RelativeName before changing it to point to new memory.
    //

    OldRelativeName = *NewRelativeName;

    //
    // Trim the trailing spaces from the server name.
    // We know that the last character is a space,
    // because server name is a netbios name.
    //

    if( !ARGUMENT_PRESENT( UnicodeName ) ) {

        USHORT SavedLength;

        ASSERT(AnsiServerName->Length == 16);
        ASSERT(AnsiServerName->Buffer[AnsiServerName->Length - 1] == ' ');

        SavedLength = AnsiServerName->Length;

        while (AnsiServerName->Length > 0 &&
           AnsiServerName->Buffer[AnsiServerName->Length - 1] == ' ') {

            AnsiServerName->Length--;
        }

        //
        // Convert the server name from ANSI to Unicode.
        //
        status = RtlAnsiStringToUnicodeString(
                        &UnicodeServerName,
                        AnsiServerName,
                        TRUE);

        AnsiServerName->Length = SavedLength;

        if (! NT_SUCCESS(status)) {
            return status;
        }

    } else {

        UnicodeServerName = *UnicodeName;

    }

    //
    // Allocate space for new relative name ("$$\server\oldrelative").
    // Start by calculating the string length, and then add one more WCHAR
    // for zero-termination.
    //

    nameLength =  (sizeof(L'$') +
                   sizeof(L'$') +
                   sizeof(L'\\') +
                   UnicodeServerName.Length +
                   sizeof(L'\\') +
                   OldRelativeName.Length);

    NewRelativeName->Length = (USHORT)nameLength;

    if( NewRelativeName->Length != nameLength ) {

        //
        // Oh no -- string length overflow!
        //

        if( !ARGUMENT_PRESENT( UnicodeName ) ) {
            RtlFreeUnicodeString(&UnicodeServerName);
        }

        return STATUS_INVALID_PARAMETER;
    }

    NewRelativeName->MaximumLength =
    NewRelativeName->Length + sizeof(L'\0');

    NewRelativeName->Buffer =
        ALLOCATE_HEAP_COLD(NewRelativeName->MaximumLength, BlockTypeDataBuffer);

    if (NewRelativeName->Buffer == NULL) {

        if( !ARGUMENT_PRESENT( UnicodeName ) ) {
            RtlFreeUnicodeString(&UnicodeServerName);
        }

        return STATUS_INSUFF_SERVER_RESOURCES;
    }

    RtlZeroMemory(NewRelativeName->Buffer, NewRelativeName->MaximumLength);

    nextLocation = NewRelativeName->Buffer;

    //
    // Copy strings and characters to new relative name.
    //
    *nextLocation++ = L'$';
    *nextLocation++ = L'$';
    *nextLocation++ = L'\\';

    RtlCopyMemory(
        nextLocation,
        UnicodeServerName.Buffer,
        UnicodeServerName.Length
        );

    nextLocation += (UnicodeServerName.Length / sizeof(WCHAR));

    *nextLocation++ = L'\\';

    RtlCopyMemory(
        nextLocation,
        OldRelativeName.Buffer,
        OldRelativeName.Length
        );

    if( !ARGUMENT_PRESENT( UnicodeName ) ) {
        //
        // Free UnicodeServerName.
        //
        RtlFreeUnicodeString(&UnicodeServerName);
    }

    *Remapped = TRUE;

    return STATUS_SUCCESS;
}

NTSTATUS
SrvCreateFile(
    IN OUT PWORK_CONTEXT WorkContext,
    IN USHORT SmbDesiredAccess,
    IN USHORT SmbFileAttributes,
    IN USHORT SmbOpenFunction,
    IN ULONG SmbAllocationSize,
    IN PCHAR SmbFileName,
    IN PCHAR EndOfSmbFileName,
    IN PVOID EaBuffer OPTIONAL,
    IN ULONG EaLength,
    OUT PULONG EaErrorOffset OPTIONAL,
    IN OPLOCK_TYPE RequestedOplockType,
    IN PRESTART_ROUTINE RestartRoutine
    )

/*++

Routine Description:

    Does most of the operations necessary to open or create a file.
    First the UID and TID are verified and the corresponding session and
    tree connect blocks located.  The input file name name is
    canonicalized, and a fully qualified name is formed.  An appropriate
    subroutine is called to do the open, based on whether this is a
    normal, compatibility mode, or FCB open.

Arguments:

    WorkContext - Work context block for the operation.

    SmbDesiredAccess - The desired access in SMB protocol format.

    SmbFileAttributes - File attributes in SMB protocol format.

    SmbOpenFunction - Open function in SMB protocol format.

    SmbAllocationSize - Allocation size for new files.

    SmbFileName - A pointer to the zero-terminated file name in the
        request SMB.  NOTE:  This pointer should NOT point to the ASCII
        format indicator (\004) present in some SMBs!

    EndOfSmbFileName - a pointer to the last possible character that
        the file name can be in.  If the name extands beyond this location
        without a zero terminator, SrvCanonicalizePathName will fail.

    EaBuffer - Optional pointer to a full EA list to pass to SrvIoCreateFile.

    EaLength - Length of the EA buffer.

    EaErrorOffset - Optional pointer to the location in which to write
        the offset to the EA that caused an error.

Return Value:

    NTSTATUS - Indicates what occurred.

--*/

{
    NTSTATUS status;

    PMFCB mfcb;
    PNONPAGED_MFCB nonpagedMfcb;
    PRFCB rfcb;

    PSESSION session;
    PTREE_CONNECT treeConnect;

    UNICODE_STRING relativeName;
    UNICODE_STRING pipeRelativeName;
    BOOLEAN pipeRelativeNameAllocated = FALSE;
    UNICODE_STRING fullName;
    SHARE_TYPE shareType;

    ULONG error;
    ULONG jobId;

    ULONG hashValue;

    ULONG attributes;
    ULONG openRetries;
    BOOLEAN isUnicode;
    BOOLEAN caseInsensitive;

    PSRV_LOCK mfcbLock;

    //
    // NOTE ON MFCB REFERENCE COUNT HANDLING
    //
    // After finding or creating an MFCB for a file, we increment the
    // MFCB reference count an extra time to simplify our
    // synchronization logic. We hold the MfcbListLock lock while
    // finding/creating the MFCB, but release it after acquiring the the
    // per-MFCB lock.  We then call one of the DoXxxOpen routines, which
    // may need to queue an LFCB to the MFCB and thus need to increment
    // the count.  But they can't, because the MFCB list lock may not be
    // acquired while the per-MFCB lock is held because of deadlock
    // potential.  The boolean LfcbAddedToMfcbList returned from the
    // routines indicates whether they actually queued an LFCB to the
    // MFCB.  If they didn't, we need to release the extra reference.
    //
    // Note that it isn't often that we actually have to dereference the
    // MFCB.  This only occurs when 1) the open fails, or 2) a
    // compatibility mode or FCB open succeeds when the client already
    // has the file open.
    //

    BOOLEAN lfcbAddedToMfcbList;

    PAGED_CODE( );

    //
    // Assume we won't need a temporary open.
    //

    WorkContext->Parameters2.Open.TemporaryOpen = FALSE;

    //
    // If a session block has not already been assigned to the current
    // work context, verify the UID.  If verified, the address of the
    // session block corresponding to this user is stored in the
    // WorkContext block and the session block is referenced.
    //
    // Find the tree connect corresponding to the given TID if a tree
    // connect pointer has not already been put in the WorkContext block
    // by an AndX command or a previous call to SrvCreateFile.
    //

    status = SrvVerifyUidAndTid(
                WorkContext,
                &session,
                &treeConnect,
                ShareTypeWild
                );

    if ( !NT_SUCCESS(status) ) {
        IF_DEBUG(SMB_ERRORS) {
            KdPrint(( "SrvCreateFile: Invalid UID or TID\n" ));
        }
        return status;
    }

    //
    // If the session has expired, return that info
    //
    if( session->IsSessionExpired )
    {
        return SESSION_EXPIRED_STATUS_CODE;
    }

    //
    // Decide if we're case sensitive or not
    //
    caseInsensitive = (WorkContext->RequestHeader->Flags & SMB_FLAGS_CASE_INSENSITIVE) ||
                          session->UsingUppercasePaths;

    //
    // Here we begin share type specific processing.
    //

    shareType = treeConnect->Share->ShareType;

    //
    // If this operation may block, and we are running short of
    // free work items, fail this SMB with an out of resources error.
    // Note that a disk open will block if the file is currently oplocked.
    //

    if ( shareType == ShareTypeDisk && !WorkContext->BlockingOperation ) {

        if ( SrvReceiveBufferShortage( ) ) {

            SrvStatistics.BlockingSmbsRejected++;
            SrvSetSmbError( WorkContext, STATUS_INSUFF_SERVER_RESOURCES );
            return STATUS_INSUFF_SERVER_RESOURCES;

        } else {

            //
            // SrvBlockingOpsInProgress has already been incremented.
            // Flag this work item as a blocking operation.
            //

            WorkContext->BlockingOperation = TRUE;

        }

    }

    isUnicode = SMB_IS_UNICODE( WorkContext );

    switch ( shareType ) {

    case ShareTypePrint:

        //
        // Allocate space to hold the file name we're going to open.
        //

        fullName.MaximumLength = MAXIMUM_FILENAME_LENGTH * sizeof(WCHAR);
        fullName.Buffer = ALLOCATE_HEAP_COLD(
                                  fullName.MaximumLength,
                                  BlockTypeDataBuffer
                                  );
        if ( fullName.Buffer == NULL ) {
            return STATUS_INSUFF_SERVER_RESOURCES;
        }

        //
        // Get a print file name to use for spooling the request.
        // We open this as a disk file, use normal writes to get the
        // data, then call ScheduleJob( ) in XACTSRV to start the
        // actual printing process.
        //

        status = SrvAddPrintJob(
                     WorkContext,
                     WorkContext->TreeConnect->Share->Type.hPrinter,
                     &fullName,
                     &jobId,
                     &error
                     );

        if ( !NT_SUCCESS(status) ) {
            IF_DEBUG(SMB_ERRORS) {
                KdPrint(( "SrvCreateFile: SrvAddPrintJob failed: %lx (%ld)\n",
                              status, error ));
            }
            FREE_HEAP( fullName.Buffer );
            if ( error != NO_ERROR ) {
                ASSERT( SrvErrorCode(error) == error );
                status = (NTSTATUS)(SRV_WIN32_STATUS | error);
            }
            return status;
        }

        //
        // Scan the Master File Table to see if the named file is already
        // open.
        //
        mfcb = SrvFindMfcb( &fullName, caseInsensitive, &mfcbLock, &hashValue, WorkContext );

        if ( mfcb == NULL ) {

            //
            // There is no MFCB for this file.  Create one.
            //

            mfcb = SrvCreateMfcb( &fullName, WorkContext, hashValue );

            if ( mfcb == NULL ) {

                //
                // Failure to add open file instance to MFT.
                //

                if( mfcbLock ) {
                    RELEASE_LOCK( mfcbLock );
                }

                IF_DEBUG(ERRORS) {
                    KdPrint(( "SrvCreateFile: Unable to allocate MFCB\n" ));
                }

                FREE_HEAP( fullName.Buffer );

                //
                // Free up the Job ID.
                //

                SrvSchedulePrintJob(
                    WorkContext->TreeConnect->Share->Type.hPrinter,
                    jobId
                    );

                return STATUS_INSUFF_SERVER_RESOURCES;
            }

        }


        //
        // Increment the MFCB reference count. See the note at the beginning of this routine.
        //

        mfcb->BlockHeader.ReferenceCount++;
        UPDATE_REFERENCE_HISTORY( mfcb, FALSE );

        //
        // Grab the MFCB-based lock to serialize opens of the same file
        // and release the MFCB list lock.
        //

        nonpagedMfcb = mfcb->NonpagedMfcb;
        RELEASE_LOCK( mfcbLock );
        ACQUIRE_LOCK( &nonpagedMfcb->Lock );

        //
        // Set up the share access and desired access in SMB terms.
        // We will only write to the file, so just request write
        // as the desired access.  As an optimization, the spooler
        // may read from the file before we finish writing to it,
        // so allow other readers.
        //

        SmbDesiredAccess = SMB_DA_ACCESS_WRITE | SMB_DA_SHARE_DENY_WRITE | SMB_LR_SEQUENTIAL;

        //
        // Set up the open function to create the file it it doesn't
        // exist and to truncate it if it does exist.  There shouldn't
        // be preexisting data in the file, hence the truncation.
        //
        // !!! The spooler may change to create the file for us, in which
        //     case this should change to only truncate.

        SmbOpenFunction = SMB_OFUN_CREATE_CREATE | SMB_OFUN_OPEN_TRUNCATE;

        //
        // This is a normal sharing mode open.  Do the actual open
        // of the disk file.
        //

        status = DoNormalOpen(
                    &rfcb,
                    mfcb,
                    WorkContext,
                    &WorkContext->Irp->IoStatus,
                    SmbDesiredAccess,
                    SmbFileAttributes,
                    SmbOpenFunction,
                    SmbAllocationSize,
                    &fullName,
                    NULL,
                    0,
                    0,
                    &lfcbAddedToMfcbList,
                    RequestedOplockType
                    );

        //
        // If the open worked, set up the Job ID in the LFCB.
        //

        if ( NT_SUCCESS(status) ) {

            rfcb->Lfcb->JobId = jobId;

        } else {

            //
            // Free up the Job ID if the open failed.
            //

            SrvSchedulePrintJob(
                WorkContext->TreeConnect->Share->Type.hPrinter,
                jobId
                );
        }

        //
        // Release the Open serialization lock and dereference the MFCB.
        //

        RELEASE_LOCK( &nonpagedMfcb->Lock );

        //
        // If DoNormalOpen didn't queue an LFCB to the MFCB, release the
        // extra reference that we added.
        //

        if ( !lfcbAddedToMfcbList ) {
            SrvDereferenceMfcb( mfcb );
        }

        SrvDereferenceMfcb( mfcb );

        //
        // Deallocate the full path name buffer.
        //

        FREE_HEAP( fullName.Buffer );

        break;

    case ShareTypeDisk:
    case ShareTypePipe:

        //
        // Canonicalize the path name so that it conforms to NT
        // standards.
        //
        // *** Note that this operation allocates space for the name.
        //     This space is deallocated after the DoXxxOpen routine
        //     returns.
        //

        status = SrvCanonicalizePathName(
                WorkContext,
                treeConnect->Share,
                NULL,
                SmbFileName,
                EndOfSmbFileName,
                TRUE,
                isUnicode,
                &relativeName
                );

        if( !NT_SUCCESS( status ) ) {

            //
            // The path tried to do ..\ to get beyond the share it has
            // accessed.
            //

            IF_DEBUG(ERRORS) {
                KdPrint(( "SrvCreateFile: Invalid pathname: %s\n",
                            SmbFileName ));
            }

            return status;

        }

        //
        // Form the fully qualified name of the file.
        //
        // *** Note that this operation allocates space for the name.
        //     This space is deallocated after the DoXxxOpen routine
        //     returns.
        //

        if ( shareType == ShareTypeDisk ) {

#ifdef SLMDBG
            if ( SrvIsSlmStatus( &relativeName ) &&
                 SrvIsSlmAccessDisallowed(
                    &relativeName,
                    treeConnect->Share->RootDirectoryHandle
                    ) ) {
                return STATUS_ACCESS_DENIED;
            }
#endif

            SrvAllocateAndBuildPathName(
                &treeConnect->Share->DosPathName,
                &relativeName,
                NULL,
                &fullName
                );

        } else {

            UNICODE_STRING pipePrefix;

            RtlInitUnicodeString( &pipePrefix, StrSlashPipeSlash );

            //
            // Check for PIPE pathname prefix.
            //

            if ( !RtlPrefixUnicodeString(
                    &SrvCanonicalNamedPipePrefix,
                    &relativeName,
                    TRUE
                    ) ) {
                IF_DEBUG(SMB_ERRORS) {
                    KdPrint(( "SrvCreateFile: Invalid pipe pathname: %s\n",
                        SmbFileName ));
                }

                if ( !isUnicode ) {
                    RtlFreeUnicodeString( &relativeName );
                }

                return STATUS_OBJECT_PATH_SYNTAX_BAD;
            }

            //
            // Delete PIPE\ prefix from file path
            //

            pipeRelativeName.Buffer = (PWSTR)( (PCHAR)relativeName.Buffer +
                SrvCanonicalNamedPipePrefix.Length );
            pipeRelativeName.Length = relativeName.Length -
                SrvCanonicalNamedPipePrefix.Length;
            pipeRelativeName.MaximumLength = pipeRelativeName.Length;

            if( WorkContext->Endpoint->RemapPipeNames || treeConnect->RemapPipeNames ) {

                //
                // The RemapPipeNames flag is set, so remap the pipe name
                //  to "$$\<server>\<pipe name>".
                //
                // Note: this operation allocates space for pipeRelativeName.
                //
                status = RemapPipeName(
                            &WorkContext->Endpoint->TransportAddress,
                            treeConnect->RemapPipeNames ? &treeConnect->ServerName : NULL ,
                            &pipeRelativeName,
                            &pipeRelativeNameAllocated
                         );

                if( !NT_SUCCESS( status ) ) {
                    if ( !isUnicode ) {
                        RtlFreeUnicodeString( &relativeName );
                    }
                    return status;
                }
            }

            SrvAllocateAndBuildPathName(
                &pipePrefix,
                &pipeRelativeName,
                NULL,
                &fullName
                );

            //
            // If this is a compatibility mode or FCB mode open, map
            // it to a normal non-shared open.
            //

            if ( SmbDesiredAccess == SMB_DA_FCB_MASK  ||
                 (SmbDesiredAccess & SMB_DA_SHARE_MASK) ==
                                            SMB_DA_SHARE_COMPATIBILITY ) {

                SmbDesiredAccess = SMB_DA_ACCESS_READ_WRITE |
                                   SMB_DA_SHARE_EXCLUSIVE;
            }

        }

        if ( fullName.Buffer == NULL ) {

            //
            // Unable to allocate heap for the full name.
            //

            IF_DEBUG(ERRORS) {
                KdPrint(( "SrvCreateFile: Unable to allocate heap for "
                            "full path name\n" ));
            }

            if ( !isUnicode ) {
                RtlFreeUnicodeString( &relativeName );
            }

            if( pipeRelativeNameAllocated ) {
                FREE_HEAP( pipeRelativeName.Buffer );
            }

            return STATUS_INSUFF_SERVER_RESOURCES;
        }

        attributes = caseInsensitive ? OBJ_CASE_INSENSITIVE : 0;

        if ( WorkContext->ProcessingCount == 2) {

            HANDLE fileHandle;
            OBJECT_ATTRIBUTES objectAttributes;
            IO_STATUS_BLOCK ioStatusBlock;

            //
            // This is the second time through, so we must be in a blocking
            // thread.  Do a blocking open of the file to force an oplock
            // break.  Then close the handle and fall through to the normal
            // open path.
            //
            // We must do the blocking open without holding the MFCB
            // lock, because this lock can be acquired during oplock
            // break, resulting in deadlock.
            //

            SrvInitializeObjectAttributes_U(
                &objectAttributes,
                &relativeName,
                attributes,
                NULL,
                NULL
                );

            status = SrvIoCreateFile(
                         WorkContext,
                         &fileHandle,
                         GENERIC_READ,
                         &objectAttributes,
                         &ioStatusBlock,
                         NULL,
                         0,
                         FILE_SHARE_VALID_FLAGS,
                         FILE_OPEN,
                         0,
                         NULL,
                         0,
                         CreateFileTypeNone,
                         NULL,                    // ExtraCreateParameters
                         0,
                         WorkContext->TreeConnect->Share
                         );

            if ( NT_SUCCESS( status ) ) {
                SRVDBG_CLAIM_HANDLE( fileHandle, "FIL", 9, 0 );
                SRVDBG_RELEASE_HANDLE( fileHandle, "FIL", 16, 0 );
                SrvNtClose( fileHandle, TRUE );
            }

        }

        //
        // Scan the Master File Table to see if the named file is already
        // open.  We can do the scan with a shared lock, but we must have an
        // exclusive lock to modify the table.  Start out shared, assuming the
        // file is already open.
        //

        mfcb = SrvFindMfcb( &fullName, caseInsensitive, &mfcbLock, &hashValue, WorkContext );

        if ( mfcb == NULL ) {

            //
            // There is no MFCB for this file.  Create one.
            //

            mfcb = SrvCreateMfcb( &fullName, WorkContext, hashValue );

            if ( mfcb == NULL ) {

                //
                // Failure to add open file instance to MFT.
                //

                if( mfcbLock ) {
                    RELEASE_LOCK( mfcbLock );
                }

                IF_DEBUG(ERRORS) {
                    KdPrint(( "SrvCreateFile: Unable to allocate MFCB\n" ));
                }

                FREE_HEAP( fullName.Buffer );

                if ( !isUnicode ) {
                    RtlFreeUnicodeString( &relativeName );
                }

                if( pipeRelativeNameAllocated ) {
                    FREE_HEAP( pipeRelativeName.Buffer );
                }

                return STATUS_INSUFF_SERVER_RESOURCES;
            }
        }

        //
        // Increment the MFCB reference count. See the note at the beginning of this routine.
        //
        mfcb->BlockHeader.ReferenceCount++;
        UPDATE_REFERENCE_HISTORY( mfcb, FALSE );

        //
        // Grab the MFCB-based lock to serialize opens of the same file
        // and release the MFCB list lock.
        //
        nonpagedMfcb = mfcb->NonpagedMfcb;
        RELEASE_LOCK( mfcbLock );
        ACQUIRE_LOCK( &nonpagedMfcb->Lock );

        //
        // Call an appropriate routine to actually do the open.
        //

        openRetries = SrvSharingViolationRetryCount;

start_retry:

        if ( SmbDesiredAccess == SMB_DA_FCB_MASK ) {

            //
            // This is an FCB open.
            //

            status = DoFcbOpen(
                        &rfcb,
                        mfcb,
                        WorkContext,
                        &WorkContext->Irp->IoStatus,
                        SmbFileAttributes,
                        SmbOpenFunction,
                        SmbAllocationSize,
                        &relativeName,
                        EaBuffer,
                        EaLength,
                        EaErrorOffset,
                        &lfcbAddedToMfcbList
                        );

        } else if ( (SmbDesiredAccess & SMB_DA_SHARE_MASK) ==
                                                SMB_DA_SHARE_COMPATIBILITY ) {

            //
            // This is a compatibility mode open.
            //

            status = DoCompatibilityOpen(
                        &rfcb,
                        mfcb,
                        WorkContext,
                        &WorkContext->Irp->IoStatus,
                        SmbDesiredAccess,
                        SmbFileAttributes,
                        SmbOpenFunction,
                        SmbAllocationSize,
                        &relativeName,
                        EaBuffer,
                        EaLength,
                        EaErrorOffset,
                        &lfcbAddedToMfcbList,
                        RequestedOplockType
                        );

        } else {

            //
            // This is a normal sharing mode open.
            //

            status = DoNormalOpen(
                        &rfcb,
                        mfcb,
                        WorkContext,
                        &WorkContext->Irp->IoStatus,
                        SmbDesiredAccess,
                        SmbFileAttributes,
                        SmbOpenFunction,
                        SmbAllocationSize,
                        shareType == ShareTypePipe ?
                            &pipeRelativeName : &relativeName,
                        EaBuffer,
                        EaLength,
                        EaErrorOffset,
                        &lfcbAddedToMfcbList,
                        RequestedOplockType
                        );

        }

        //
        // Retry if sharing violation and we are in the blocking thread.
        //

        if ( (WorkContext->ProcessingCount == 2) &&
             (status == STATUS_SHARING_VIOLATION) &&
             (shareType == ShareTypeDisk) &&
             (openRetries-- > 0) ) {

            //
            // Release the mfcb lock so that a close might slip through.
            //

            RELEASE_LOCK( &nonpagedMfcb->Lock );

            (VOID) KeDelayExecutionThread(
                                    KernelMode,
                                    FALSE,
                                    &SrvSharingViolationDelay
                                    );

            ACQUIRE_LOCK( &nonpagedMfcb->Lock );
            goto start_retry;
        }

        //
        // Release the Open serialization lock and dereference the MFCB.
        //

        RELEASE_LOCK( &nonpagedMfcb->Lock );

        //
        // If DoXxxOpen didn't queue an LFCB to the MFCB, release the
        // extra reference that we added.
        //

        if ( !lfcbAddedToMfcbList ) {
            SrvDereferenceMfcb( mfcb );
        }

        SrvDereferenceMfcb( mfcb );

        //
        // Deallocate the full path name buffer.
        //

        FREE_HEAP( fullName.Buffer );

        if ( !isUnicode ) {
            RtlFreeUnicodeString( &relativeName );
        }

        break;

    //
    //  Default case, illegal device type.  This should never happen.
    //

    default:

        // !!! Is this an appropriate error return code?  Probably no.
        status = STATUS_INVALID_PARAMETER;
        rfcb = NULL;

    }

    //
    // Update the statistics database if the open was successful.
    //

    if ( NT_SUCCESS(status) ) {
        SrvStatistics.TotalFilesOpened++;
    }

    //
    // Make a pointer to the RFCB accessible to the caller.
    //

    WorkContext->Parameters2.Open.Rfcb = rfcb;

    //
    // If there is an oplock break in progress, wait for the oplock
    // break to complete.
    //

    if ( status == STATUS_OPLOCK_BREAK_IN_PROGRESS ) {

        NTSTATUS startStatus;

        //
        // Save the Information from the open, so it doesn't
        //  get lost when we re-use the WorkContext->Irp for the
        //  oplock processing.
        //
        WorkContext->Parameters2.Open.IosbInformation = WorkContext->Irp->IoStatus.Information;

        startStatus = SrvStartWaitForOplockBreak(
                        WorkContext,
                        RestartRoutine,
                        0,
                        rfcb->Lfcb->FileObject
                        );

        if (!NT_SUCCESS( startStatus ) ) {

            //
            // The file is oplocked, and we cannot wait for the oplock
            // break to complete.  Just close the file, and return the
            // error.
            //

            SrvCloseRfcb( rfcb );
            status = startStatus;

        }

    }

    if( pipeRelativeNameAllocated ) {
        FREE_HEAP( pipeRelativeName.Buffer );
    }

    //
    // Return the open status.
    //

    return status;

} // SrvCreateFile


NTSTATUS
DoNormalOpen(
    OUT PRFCB *Rfcb,
    IN PMFCB Mfcb,
    IN OUT PWORK_CONTEXT WorkContext,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    IN USHORT SmbDesiredAccess,
    IN USHORT SmbFileAttributes,
    IN USHORT SmbOpenFunction,
    IN ULONG SmbAllocationSize,
    IN PUNICODE_STRING RelativeName,
    IN PVOID EaBuffer OPTIONAL,
    IN ULONG EaLength,
    OUT PULONG EaErrorOffset OPTIONAL,
    OUT PBOOLEAN LfcbAddedToMfcbList,
    IN OPLOCK_TYPE RequestedOplockType
    )

/*++

Routine Description:

    Processes a normal sharing mode open.

    *** The MFCB lock must be held on entry to this routine; the lock
        remains held on exit.

Arguments:

    Rfcb - A pointer to a pointer to an RFCB that will point to the
        newly-created RFCB.

    Mfcb - A pointer to the MFCB for this file.

    WorkContext - Work context block for the operation.

    IoStatusBlock - A pointer to an IO status block.

    SmbDesiredAccess - The desired access in SMB protocol format.

    SmbFileAttributes - File attributes in SMB protocol format.

    SmbOpenFunction - Open function in SMB protocol format.

    SmbAllocationSize - Allocation size for new files.

    RelativeName - The share-relative name of the file being opened.

    EaBuffer - Optional pointer to a full EA list to pass to SrvIoCreateFile.

    EaLength - Length of the EA buffer.

    EaErrorOffset - Optional pointer to the location in which to write
        the offset to the EA that caused an error.

    LfcbAddedToMfcbList - Pointer to a boolean that will be set to TRUE if
        an lfcb is added to the mfcb list of lfcbs.  FALSE, otherwise.

Return Value:

    NTSTATUS - Indicates what occurred.

--*/

{
    NTSTATUS status;
    NTSTATUS completionStatus;

    HANDLE fileHandle;

    OBJECT_ATTRIBUTES objectAttributes;
    ULONG attributes;

    LARGE_INTEGER allocationSize;
    ULONG fileAttributes;
    BOOLEAN directory;
    ULONG shareAccess;
    ULONG createDisposition;
    ULONG createOptions;
    ACCESS_MASK desiredAccess;
    PSHARE fileShare = NULL;

    UCHAR errorClass = SMB_ERR_CLASS_DOS;
    USHORT error = 0;

    PAGED_CODE( );

    *LfcbAddedToMfcbList = FALSE;

    //
    // Map the desired access from SMB terms to NT terms.
    //

    status = MapDesiredAccess( SmbDesiredAccess, &desiredAccess );
    if ( !NT_SUCCESS(status) ) {
        return status;
    }
#ifdef SLMDBG
    if ( SrvIsSlmStatus( RelativeName ) ||
         SrvIsTempSlmStatus( RelativeName ) ) {
        desiredAccess |= GENERIC_READ;
    }
#endif

    //
    // Map the share mode from SMB terms to NT terms.
    //

    status = MapShareAccess( SmbDesiredAccess, &shareAccess );
    if ( !NT_SUCCESS(status) ) {
        return status;
    }

    //
    // We're going to open this file relative to the root directory
    // of the share.  Load up the necessary fields in the object
    // attributes structure.
    //

    if ( WorkContext->RequestHeader->Flags & SMB_FLAGS_CASE_INSENSITIVE ) {
        attributes = OBJ_CASE_INSENSITIVE;
    } else if ( WorkContext->Session->UsingUppercasePaths ) {
        attributes = OBJ_CASE_INSENSITIVE;
    } else {
        attributes = 0L;
    }

    if ( WorkContext->TreeConnect->Share->ShareType == ShareTypePipe ) {
        SrvInitializeObjectAttributes_U(
            &objectAttributes,
            RelativeName,
            attributes,
            SrvNamedPipeHandle,
            NULL
            );
    } else {

        fileShare = WorkContext->TreeConnect->Share;

        SrvInitializeObjectAttributes_U(
            &objectAttributes,
            RelativeName,
            attributes,
            NULL,
            NULL
            );
    }

    //
    // Set block size according to the AllocationSize in the request SMB.
    //

    allocationSize.QuadPart = SmbAllocationSize;

    //
    // Get the value for fileAttributes.
    //

    SRV_SMB_ATTRIBUTES_TO_NT(
        SmbFileAttributes,
        &directory,
        &fileAttributes
        );

    //
    // Set createDisposition parameter from OpenFunction.
    //

    status = MapOpenFunction( SmbOpenFunction, &createDisposition );

    //
    // OS/2 expects that if it creates a file with an allocation size,
    // the end of file pointer will be the same as that allocation size.
    // Therefore, the server is expected to set EOF to the allocation
    // size on creating a file.  However, this requires write access,
    // so if the client is creating a file with an allocation size, give
    // him write access.  Only do this if creating a file; if this is
    // a "create or open" operation, don't do this, as it could cause
    // an extraneuos audit.
    //

    if ( SmbAllocationSize != 0 && createDisposition == FILE_CREATE ) {
        desiredAccess |= GENERIC_WRITE;
    }

    //
    // Set createOptions parameter.
    //

    if ( SmbDesiredAccess & SMB_DA_WRITE_THROUGH ) {
        createOptions = FILE_WRITE_THROUGH | FILE_NON_DIRECTORY_FILE;
    } else {
        createOptions = FILE_NON_DIRECTORY_FILE;
    }

    if ( (SmbGetAlignedUshort( &WorkContext->RequestHeader->Flags2 ) &
                 SMB_FLAGS2_KNOWS_EAS) == 0) {

        //
        // This guy does not know eas
        //

        createOptions |= FILE_NO_EA_KNOWLEDGE;
    }

    //
    // Set the caching hints flags.
    //

    status = MapCacheHints( SmbDesiredAccess, &createOptions );

    //
    // Check to see if there is a cached handle for the file.
    //

    if ( (createDisposition == FILE_OPEN) ||
         (createDisposition == FILE_CREATE) ||
         (createDisposition == FILE_OPEN_IF) ) {

        ASSERT( *LfcbAddedToMfcbList == FALSE );

        IF_DEBUG(FILE_CACHE) {
            KdPrint(( "SrvCreateFile: checking for cached rfcb for %wZ\n", RelativeName ));
        }
        if ( SrvFindCachedRfcb(
                WorkContext,
                Mfcb,
                desiredAccess,
                shareAccess,
                createDisposition,
                createOptions,
                RequestedOplockType,
                &status ) ) {

            IF_DEBUG(FILE_CACHE) {
                KdPrint(( "SrvCreateFile: FindCachedRfcb = TRUE, status = %x, rfcb = %p\n",
                            status, WorkContext->Rfcb ));
            }

            IoStatusBlock->Information = FILE_OPENED;

            return status;
        }

        IF_DEBUG(FILE_CACHE) {
            KdPrint(( "SrvCreateFile: FindCachedRfcb = FALSE; do it the slow way\n" ));
        }
    }

    //
    // Call SrvIoCreateFile to create or open the file.  (We call
    // SrvIoCreateFile, rather than NtOpenFile, in order to get user-mode
    // access checking.)
    //

    IF_SMB_DEBUG(OPEN_CLOSE2) {
        KdPrint(( "DoNormalOpen: Opening file %wZ\n", RelativeName ));
    }

    INCREMENT_DEBUG_STAT( SrvDbgStatistics.TotalOpenAttempts );

    //
    // Ensure the EaBuffer is correctly formatted.  Since we are a kernel mode
    //  component, the Io subsystem does not check it for us.
    //
    if( ARGUMENT_PRESENT( EaBuffer ) ) {
        status = IoCheckEaBufferValidity( (PFILE_FULL_EA_INFORMATION)EaBuffer, EaLength, EaErrorOffset );
    } else {
        status = STATUS_SUCCESS;
    }

    if( NT_SUCCESS( status ) ) {

        createOptions |= FILE_COMPLETE_IF_OPLOCKED;

        status = SrvIoCreateFile(
                     WorkContext,
                     &fileHandle,
                     desiredAccess,
                     &objectAttributes,
                     IoStatusBlock,
                     &allocationSize,
                     fileAttributes,
                     shareAccess,
                     createDisposition,
                     createOptions,
                     EaBuffer,
                     EaLength,
                     CreateFileTypeNone,
                     NULL,                    // ExtraCreateParameters
                     IO_FORCE_ACCESS_CHECK,
                     fileShare
                     );
    }

    //
    // If we got sharing violation and this is a disk file, and this is
    // the first open attempt, setup for a blocking open attempt.  If the
    // file is batch oplocked, the non-blocking open would fail, and the
    // oplock will not break.
    //

    if ( status == STATUS_SHARING_VIOLATION &&
         WorkContext->ProcessingCount == 1 &&
         WorkContext->TreeConnect->Share->ShareType == ShareTypeDisk ) {

        WorkContext->Parameters2.Open.TemporaryOpen = TRUE;
    }

    //
    // If the user didn't have this permission, update the statistics
    // database.
    //

    if ( status == STATUS_ACCESS_DENIED ) {
        SrvStatistics.AccessPermissionErrors++;
    }

    if ( !NT_SUCCESS(status) ) {

        //
        // The open failed.
        //

        IF_DEBUG(ERRORS) {
            KdPrint(( "DoNormalOpen: SrvIoCreateFile failed, file = %wZ, status = %X, Info = 0x%p\n",
                        objectAttributes.ObjectName,
                        status, (PVOID)IoStatusBlock->Information ));
        }

        //
        // Set the error offset if needed.
        //

        if ( ARGUMENT_PRESENT(EaErrorOffset) &&
                                status == STATUS_INVALID_EA_NAME ) {
            *EaErrorOffset = (ULONG)IoStatusBlock->Information;
            IoStatusBlock->Information = 0;
        }

        return status;

    }

    SRVDBG_CLAIM_HANDLE( fileHandle, "FIL", 10, 0 );

    //
    // The open was successful.  Attempt to allocate structures to
    // represent the open.  If any errors occur, CompleteOpen does full
    // cleanup, including closing the file.
    //

    IF_SMB_DEBUG(OPEN_CLOSE2) {
        KdPrint(( "DoNormalOpen: Open of %wZ succeeded, file handle: 0x%p\n",
                    RelativeName, fileHandle ));
    }

    completionStatus = CompleteOpen(
                           Rfcb,
                           Mfcb,
                           WorkContext,
                           NULL,
                           fileHandle,
                           NULL,
                           shareAccess,
                           createOptions,
                           FALSE,
                           FALSE,
                           LfcbAddedToMfcbList
                           );

    //
    // Return the "interesting" status code.  If CompleteOpen() succeeds
    // return the open status.  If it fails, it will clean up the open
    // file, and we return a failure status.
    //

    if ( !NT_SUCCESS( completionStatus ) ) {
        return completionStatus;
    } else {
        return status;
    }

} // DoNormalOpen


NTSTATUS
DoCompatibilityOpen(
    OUT PRFCB *Rfcb,
    IN PMFCB Mfcb,
    IN OUT PWORK_CONTEXT WorkContext,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    IN USHORT SmbDesiredAccess,
    IN USHORT SmbFileAttributes,
    IN USHORT SmbOpenFunction,
    IN ULONG SmbAllocationSize,
    IN PUNICODE_STRING RelativeName,
    IN PVOID EaBuffer OPTIONAL,
    IN ULONG EaLength,
    OUT PULONG EaErrorOffset OPTIONAL,
    OUT PBOOLEAN LfcbAddedToMfcbList,
    IN OPLOCK_TYPE RequestedOplockType
    )

/*++

Routine Description:

    Processes a compatibility mode open.

    *** The MFCB lock must be held on entry to this routine; the lock
        remains held on exit.

Arguments:

    Rfcb - A pointer to a pointer to an RFCB that will point to the
        newly-created RFCB.

    Mfcb - A pointer to the MFCB for this file.

    WorkContext - Work context block for the operation.

    IoStatusBlock - A pointer to an IO status block.

    SmbDesiredAccess - The desired access in SMB protocol format.

    SmbFileAttributes - File attributes in SMB protocol format.

    SmbOpenFunction - Open function in SMB protocol format.

    SmbAllocationSize - Allocation size for new files.

    RelativeName - The share-relative name of the file being opened.

    EaBuffer - Optional pointer to a full EA list to pass to SrvIoCreateFile.

    EaLength - Length of the EA buffer.

    EaErrorOffset - Optional pointer to the location in which to write
        the offset to the EA that caused an error.

    LfcbAddedToMfcbList - Pointer to a boolean that will be set to TRUE if
        an lfcb is added to the mfcb list of lfcbs.

Return Value:

    NTSTATUS - Indicates what occurred.

--*/

{
    NTSTATUS status;
    NTSTATUS completionStatus;

    PLFCB lfcb;

    HANDLE fileHandle;

    OBJECT_ATTRIBUTES objectAttributes;
    ULONG attributes;

    LARGE_INTEGER allocationSize;
    ULONG fileAttributes;
    BOOLEAN directory;
    ULONG createDisposition;
    ULONG createOptions;
    ACCESS_MASK desiredAccess;
    USHORT smbOpenMode;

    PAGED_CODE( );

    *LfcbAddedToMfcbList = FALSE;

    //
    // Map the desired access from SMB terms to NT terms.
    //

    status = MapDesiredAccess( SmbDesiredAccess, &desiredAccess );
    if ( !NT_SUCCESS(status) ) {
        return status;
    }

    //
    // Set createDisposition parameter from OpenFunction.
    //

    status = MapOpenFunction( SmbOpenFunction, &createDisposition );

    if ( !NT_SUCCESS(status) ) {
        return status;
    }

    //
    // Set createOptions parameter.
    //

    if ( SmbDesiredAccess & SMB_DA_WRITE_THROUGH ) {
        createOptions = FILE_WRITE_THROUGH | FILE_NON_DIRECTORY_FILE;
    } else {
        createOptions = FILE_NON_DIRECTORY_FILE;
    }

    if ( (SmbGetAlignedUshort( &WorkContext->RequestHeader->Flags2 ) &
                 SMB_FLAGS2_KNOWS_EAS) == 0) {

        //
        // This guy does not know eas
        //

        createOptions |= FILE_NO_EA_KNOWLEDGE;
    }

    //
    // We're going to open this file relative to the root directory
    // of the share.  Load up the necessary fields in the object
    // attributes structure.
    //

    if ( WorkContext->RequestHeader->Flags & SMB_FLAGS_CASE_INSENSITIVE ) {
        attributes = OBJ_CASE_INSENSITIVE;
    } else if ( WorkContext->Session->UsingUppercasePaths ) {
        attributes = OBJ_CASE_INSENSITIVE;
    } else {
        attributes = 0L;
    }

    SrvInitializeObjectAttributes_U(
        &objectAttributes,
        RelativeName,
        attributes,
        NULL,
        NULL
        );

    if ( Mfcb->ActiveRfcbCount > 0 ) {

        //
        // The named file is already opened by the server.  If the client
        // specified that it didn't want to open an existing file,
        // reject this open.
        //

        if ( createDisposition == FILE_CREATE ) {

            IF_SMB_DEBUG(OPEN_CLOSE2) {
                KdPrint(( "DoCompatibilityOpen: Compatibility open of %wZ rejected; wants to create\n", RelativeName ));
            }

            return STATUS_OBJECT_NAME_COLLISION;
        }

        //
        // If the existing open is not a compatibility mode open, then
        // we try to map the new open into a normal sharing mode.  If
        // that works, we attempt a normal open.  If it doesn't work, we
        // reject the new open.  If the existing open is a compatibility
        // mode open by this session, we just add a new RFCB.  If it's a
        // compatibility mode open by a different session, we reject
        // this open.
        //

        if ( !Mfcb->CompatibilityOpen ) {

            //
            // The named file is open, but not in compatibility mode.
            // Determine whether this should be mapped from a
            // compatibility mode open to a normal sharing mode open.
            //

            smbOpenMode = SmbDesiredAccess;

            if ( MapCompatibilityOpen( RelativeName, &smbOpenMode ) ) {

                //
                // The open has been mapped to a normal sharing mode.
                //

                IF_SMB_DEBUG(OPEN_CLOSE2) {
                    KdPrint(( "DoCompatibilityOpen: Mapped compatibility open of %wZ to normal open\n", RelativeName ));
                }

                return DoNormalOpen(
                            Rfcb,
                            Mfcb,
                            WorkContext,
                            IoStatusBlock,
                            smbOpenMode,
                            SmbFileAttributes,
                            SmbOpenFunction,
                            SmbAllocationSize,
                            RelativeName,
                            EaBuffer,
                            EaLength,
                            EaErrorOffset,
                            LfcbAddedToMfcbList,
                            RequestedOplockType
                            );

            }

            //
            // The open was not mapped away from compatibility mode.
            // Because the file is already open for normal sharing, this
            // open request must be rejected.
            //

            IF_SMB_DEBUG(OPEN_CLOSE2) {
                KdPrint(( "DoCompatibilityOpen: Compatibility open of %wZ rejected; already open in normal mode\n",
                            RelativeName ));
            }

            status = STATUS_SHARING_VIOLATION;
            goto sharing_violation;

        } // if ( !Mfcb->CompatibilityOpen )

        //
        // The named file is open in compatibility mode.  Get a pointer
        // to the LFCB for the open.  Determine whether the requesting
        // session is the one that did the original open.
        //
        // Normally there will only be one LFCB linked to a
        // compatibility mode MFCB.  However, it is possible for there
        // to briefly be multiple LFCBs.  When an LFCB is in the process
        // of closing, the ActiveRfcbCount will be 0, so a new open will
        // be treated as the first open of the MFCB, and there will be
        // two LFCBs linked to the MFCB.  There can actually be more
        // than two LFCBs linked if the rundown of the closing LFCBs
        // takes some time.  So the find "the" LFCB for the open, we go
        // to the tail of the MFCB's list.
        //

        lfcb = CONTAINING_RECORD( Mfcb->LfcbList.Blink, LFCB, MfcbListEntry );

        if ( lfcb->Session != WorkContext->Session ) {

            //
            // A different session has the file open in compatibility
            // mode.  Reject this open request.
            //

            IF_SMB_DEBUG(OPEN_CLOSE2) {
                KdPrint(( "DoCompatibilityOpen: Compatibility open of %wZ rejected; already open in compatibility mode\n",
                            RelativeName ));
            }

            status = STATUS_SHARING_VIOLATION;
            goto sharing_violation;
        }

        //
        // If this request is asking for more access than could be
        // obtained when the file was originally opened, reject this
        // open.
        //

        if ( !NT_SUCCESS(IoCheckDesiredAccess(
                          &desiredAccess,
                          lfcb->GrantedAccess )) ) {

            IF_SMB_DEBUG(OPEN_CLOSE2) {
                KdPrint(( "DoCompatibilityOpen: Duplicate compatibility open of %wZ rejected; access denied\n", RelativeName ));
            }

            return STATUS_ACCESS_DENIED;
        }

        //
        // The client has access.  Allocate a new RFCB and link it into
        // the existing LFCB.  If any errors occur, CompleteOpen does
        // full cleanup.
        //

        IF_SMB_DEBUG(OPEN_CLOSE2) {
            KdPrint(( "DoCompatibilityOpen: Duplicate compatibility open of %wZ accepted", RelativeName ));
        }

        IoStatusBlock->Information = FILE_OPENED;

        status = CompleteOpen(
                    Rfcb,
                    Mfcb,
                    WorkContext,
                    lfcb,
                    NULL,
                    &desiredAccess,
                    0,                  // ShareAccess
                    createOptions,
                    TRUE,
                    FALSE,
                    LfcbAddedToMfcbList
                    );

        if( NT_SUCCESS( status ) &&
            ( createDisposition == FILE_OVERWRITE ||
              createDisposition == FILE_OVERWRITE_IF)
        ) {
            //
            // The file was successfully opened, and the client wants it
            //  truncated. We need to do it here by hand since we
            //  didn't actually call the filesystem to open the file and it
            //  therefore never had a chance to truncate the file if the
            //  open modes requested it.
            //
            LARGE_INTEGER zero;
            IO_STATUS_BLOCK ioStatusBlock;

            zero.QuadPart = 0;
            NtSetInformationFile( lfcb->FileHandle,
                                  &ioStatusBlock,
                                  &zero,
                                  sizeof( zero ),
                                  FileEndOfFileInformation
                                 );
        }

        return status;

    } // if ( mfcb->ActiveRfcbCount > 0 )

    //
    // The file is not already open (by the server, at least).
    // Determine whether this should be mapped from a compatibility mode
    // open to a normal sharing mode open.
    //

    smbOpenMode = SmbDesiredAccess;

    if ( MapCompatibilityOpen( RelativeName, &smbOpenMode ) ) {

        //
        // The open has been mapped to a normal sharing mode.
        //

        return DoNormalOpen(
                    Rfcb,
                    Mfcb,
                    WorkContext,
                    IoStatusBlock,
                    smbOpenMode,
                    SmbFileAttributes,
                    SmbOpenFunction,
                    SmbAllocationSize,
                    RelativeName,
                    EaBuffer,
                    EaLength,
                    EaErrorOffset,
                    LfcbAddedToMfcbList,
                    RequestedOplockType
                    );

    }

    //
    // The open was not mapped away from compatibility mode.  Attempt to
    // open the file for exclusive access.
    //
    // *** We try to open the file for the most access we'll ever need.
    //     This is because we fold multiple compatibility opens by the
    //     same client into a single local open.  The client may open
    //     the file first for readonly access, then for read/write
    //     access.  Because the local open is exclusive, we can't open
    //     again on the second remote open.  We try to get Delete
    //     access, in case the client tries to delete the file while
    //     it's open.
    //

    //
    // Set block size according to the AllocationSize in the request SMB.
    //

    allocationSize.QuadPart = SmbAllocationSize;

    IF_SMB_DEBUG(OPEN_CLOSE2) {
        KdPrint(( "DoCompatibilityOpen: Opening file %wZ\n", RelativeName ));
    }

    //
    // Get the value for fileAttributes.
    //

    SRV_SMB_ATTRIBUTES_TO_NT(
        SmbFileAttributes,
        &directory,
        &fileAttributes
        );

    //
    // Try to open the file for Read/Write/Delete access.
    //

    INCREMENT_DEBUG_STAT( SrvDbgStatistics.TotalOpenAttempts );

    //
    // Ensure the EaBuffer is correctly formatted.  Since we are a kernel mode
    //  component, the Io subsystem does not check it for us.
    //
    if( ARGUMENT_PRESENT( EaBuffer ) ) {
        status = IoCheckEaBufferValidity( (PFILE_FULL_EA_INFORMATION)EaBuffer, EaLength, EaErrorOffset );
    } else {
        status = STATUS_SUCCESS;
    }

    if( NT_SUCCESS( status ) ) {

        createOptions |= FILE_COMPLETE_IF_OPLOCKED;

        status = SrvIoCreateFile(
                     WorkContext,
                     &fileHandle,
                     GENERIC_READ | GENERIC_WRITE | DELETE,      // DesiredAccess
                     &objectAttributes,
                     IoStatusBlock,
                     &allocationSize,
                     fileAttributes,
                     0L,                                         // ShareAccess
                     createDisposition,
                     createOptions,
                     EaBuffer,
                     EaLength,
                     CreateFileTypeNone,
                     NULL,                                       // ExtraCreateParameters
                     IO_FORCE_ACCESS_CHECK,
                     WorkContext->TreeConnect->Share
                     );
    }


    if ( status == STATUS_ACCESS_DENIED ) {

        //
        // The client doesn't have Read/Write/Delete access to the file.
        // Try for Read/Write access.
        //

        IF_SMB_DEBUG(OPEN_CLOSE2) {
            KdPrint(( "DoCompatibilityOpen: r/w/d access denied.\n" ));
        }

        INCREMENT_DEBUG_STAT( SrvDbgStatistics.TotalOpenAttempts );

        status = SrvIoCreateFile(
                     WorkContext,
                     &fileHandle,
                     GENERIC_READ | GENERIC_WRITE,           // DesiredAccess
                     &objectAttributes,
                     IoStatusBlock,
                     &allocationSize,
                     fileAttributes,
                     0L,                                     // ShareAccess
                     createDisposition,
                     createOptions,
                     EaBuffer,
                     EaLength,
                     CreateFileTypeNone,
                     NULL,                                   // ExtraPipeCreateParameters
                     IO_FORCE_ACCESS_CHECK,
                     WorkContext->TreeConnect->Share
                     );


        if ( status == STATUS_ACCESS_DENIED ) {

            //
            // The client doesn't have Read/Write access to the file.
            // Try Read or Write access, as appropriate.
            //

            IF_SMB_DEBUG(OPEN_CLOSE2) {
                KdPrint(( "DoCompatibilityOpen: r/w access denied.\n" ));
            }

            if ( (SmbDesiredAccess & SMB_DA_ACCESS_MASK) ==
                                                    SMB_DA_ACCESS_READ ) {

                //
                // !!! Should this be mapped to a normal sharing mode?
                //     Note that we already tried to map into normal
                //     mode once, but that failed.  (With the current
                //     mapping algorithm, we can't get here unless soft
                //     compatibility is disabled.)
                //

                INCREMENT_DEBUG_STAT( SrvDbgStatistics.TotalOpenAttempts );

                status = SrvIoCreateFile(
                             WorkContext,
                             &fileHandle,
                             GENERIC_READ,                   // DesiredAccess
                             &objectAttributes,
                             IoStatusBlock,
                             &allocationSize,
                             fileAttributes,
                             0L,                             // ShareAccess
                             createDisposition,
                             createOptions,
                             EaBuffer,
                             EaLength,
                             CreateFileTypeNone,
                             NULL,                           // ExtraCreateParameters
                             IO_FORCE_ACCESS_CHECK,
                             WorkContext->TreeConnect->Share
                             );

            } else if ( (SmbDesiredAccess & SMB_DA_ACCESS_MASK) ==
                                                    SMB_DA_ACCESS_WRITE ) {

                INCREMENT_DEBUG_STAT( SrvDbgStatistics.TotalOpenAttempts );

                status = SrvIoCreateFile(
                             WorkContext,
                             &fileHandle,
                             GENERIC_WRITE,                  // DesiredAccess
                             &objectAttributes,
                             IoStatusBlock,
                             &allocationSize,
                             fileAttributes,
                             0L,                             // ShareAccess
                             createDisposition,
                             createOptions,
                             EaBuffer,
                             EaLength,
                             CreateFileTypeNone,
                             NULL,                           // NamedPipeCreateParameters
                             IO_FORCE_ACCESS_CHECK,
                             WorkContext->TreeConnect->Share
                             );

            }

            //
            // If the user didn't have this permission, update the
            // statistics database.
            //

            if ( status == STATUS_ACCESS_DENIED ) {
                SrvStatistics.AccessPermissionErrors++;
            }

        }

    }

    //
    // If we got sharing violation, just get a handle so that we can wait
    // for an oplock break.
    //

sharing_violation:
    //
    // If we got sharing violation and this is a disk file, and this is
    // the first open attempt, setup for a blocking open attempt.  If the
    // file is batch oplocked, the non-blocking open would fail, and the
    // oplock will not break.
    //

    if ( status == STATUS_SHARING_VIOLATION &&
         WorkContext->ProcessingCount == 1 &&
         WorkContext->TreeConnect->Share->ShareType == ShareTypeDisk ) {

        WorkContext->Parameters2.Open.TemporaryOpen = TRUE;
    }

    if ( !NT_SUCCESS(status) ) {

        //
        // All of the open attempts failed.
        //

        IF_SMB_DEBUG(OPEN_CLOSE2) {
            KdPrint(( "DoCompatibilityOpen: all opens failed; status = %X\n",
                        status ));
        }

        //
        // Set the error offset if needed.
        //

        if ( ARGUMENT_PRESENT(EaErrorOffset) &&
                                         status == STATUS_INVALID_EA_NAME ) {
            *EaErrorOffset = (ULONG)IoStatusBlock->Information;
            IoStatusBlock->Information = 0;
        }

        return status;
    }

    SRVDBG_CLAIM_HANDLE( fileHandle, "FIL", 11, 0 );

    //
    // The file has been successfully opened for exclusive access, with
    // at least as much desired access as requested by the client.
    // Attempt to allocate structures to represent the open.  If any
    // errors occur, CompleteOpen does full cleanup, including closing
    // the file.
    //

    IF_SMB_DEBUG(OPEN_CLOSE2) {
        KdPrint(( "DoCompatibilityOpen: Open of %wZ succeeded, file handle: 0x%p\n", RelativeName, fileHandle ));
    }

    completionStatus = CompleteOpen(
                           Rfcb,
                           Mfcb,
                           WorkContext,
                           NULL,
                           fileHandle,
                           &desiredAccess,
                           0,               // ShareAccess
                           createOptions,
                           TRUE,
                           FALSE,
                           LfcbAddedToMfcbList
                           );

    //
    // Return the "interesting" status code.  If CompleteOpen() succeeds
    // return the open status.  If it fails, it will clean up the open
    // file, and we return a failure status.
    //

    if ( !NT_SUCCESS( completionStatus ) ) {
        return completionStatus;
    } else {
        return status;
    }

} // DoCompatibilityOpen


NTSTATUS
DoFcbOpen(
    OUT PRFCB *Rfcb,
    IN PMFCB Mfcb,
    IN OUT PWORK_CONTEXT WorkContext,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    IN USHORT SmbFileAttributes,
    IN USHORT SmbOpenFunction,
    IN ULONG SmbAllocationSize,
    IN PUNICODE_STRING RelativeName,
    IN PVOID EaBuffer OPTIONAL,
    IN ULONG EaLength,
    OUT PULONG EaErrorOffset OPTIONAL,
    OUT PBOOLEAN LfcbAddedToMfcbList
    )

/*++

Routine Description:

    Processes an FCB open.

    *** The MFCB lock must be held on entry to this routine; the lock
        remains held on exit.

Arguments:

    Rfcb - A pointer to a pointer to an RFCB that will point to the
        newly-created RFCB.

    Mfcb - A pointer to the MFCB for this file

    WorkContext - Work context block for the operation.

    IoStatusBlock - A pointer to an IO status block.

    SmbFileAttributes - File attributes in SMB protocol format.

    SmbOpenFunction - Open function in SMB protocol format.

    SmbAllocationSize - Allocation size for new files.

    RelativeName - The share-relative name of the file being opened.

    EaBuffer - Optional pointer to a full EA list to pass to SrvIoCreateFile.

    EaLength - Length of the EA buffer.

    EaErrorOffset - Optional pointer to the location in which to write
        the offset to the EA that caused an error.

    LfcbAddedToMfcbList - Pointer to a boolean that will be set to TRUE if
        an lfcb is added to the mfcb list of lfcbs.

Return Value:

    NTSTATUS - Indicates what occurred.

--*/

{
    NTSTATUS status;
    NTSTATUS completionStatus;

    PLIST_ENTRY lfcbEntry;
    PLIST_ENTRY rfcbEntry;

    PRFCB rfcb;
    PPAGED_RFCB pagedRfcb;
    PLFCB lfcb;

    HANDLE fileHandle;

    OBJECT_ATTRIBUTES objectAttributes;
    ULONG attributes;

    LARGE_INTEGER allocationSize;
    ULONG fileAttributes;
    BOOLEAN directory;
    ULONG createOptions;
    ULONG createDisposition;
    ULONG shareAccess;
    BOOLEAN compatibilityOpen;

    PAGED_CODE( );

    *LfcbAddedToMfcbList = FALSE;

    //
    // Set createDisposition parameter from OpenFunction.
    //

    status = MapOpenFunction( SmbOpenFunction, &createDisposition );

    if ( !NT_SUCCESS(status) ) {
        return status;
    }

    //
    // Set createOptions parameter.
    //

    if ( (SmbGetAlignedUshort( &WorkContext->RequestHeader->Flags2 ) &
                 SMB_FLAGS2_KNOWS_EAS) == 0) {

        //
        // This guy does not know eas
        //

        createOptions = FILE_NON_DIRECTORY_FILE |
                        FILE_NO_EA_KNOWLEDGE;
    } else {

        createOptions = FILE_NON_DIRECTORY_FILE;
    }

    //
    // We're going to open this file relative to the root directory
    // of the share.  Load up the necessary fields in the object
    // attributes structure.
    //

    if ( WorkContext->RequestHeader->Flags & SMB_FLAGS_CASE_INSENSITIVE ) {
        attributes = OBJ_CASE_INSENSITIVE;
    } else if ( WorkContext->Session->UsingUppercasePaths ) {
        attributes = OBJ_CASE_INSENSITIVE;
    } else {
        attributes = 0L;
    }

    SrvInitializeObjectAttributes_U(
        &objectAttributes,
        RelativeName,
        attributes,
        NULL,
        NULL
        );

    createOptions |= FILE_COMPLETE_IF_OPLOCKED;

    if ( Mfcb->ActiveRfcbCount > 0 ) {

        //
        // The named file is already open by the server.  If the client
        // specified that it didn't want to open an existing file,
        // reject this open.
        //

        if ( createDisposition == FILE_CREATE ) {

            IF_SMB_DEBUG(OPEN_CLOSE2) {
                KdPrint(( "DoFcbOpen: FCB open of %wZ rejected; wants to create\n", RelativeName ));
            }

            return STATUS_OBJECT_NAME_COLLISION;
        }

        //
        // If the requesting session already has the file open in FCB
        // mode, fold this open into the existing open by returning a
        // pointer to the existing RFCB.
        //
        // *** Multiple FCB opens are folded together because the client
        //     may send only one close; that single close closes all FCB
        //     opens by the client.
        //

        for ( lfcbEntry = Mfcb->LfcbList.Flink;
              lfcbEntry != &Mfcb->LfcbList;
              lfcbEntry = lfcbEntry->Flink ) {

            lfcb = CONTAINING_RECORD( lfcbEntry, LFCB, MfcbListEntry );

            if ( lfcb->Session == WorkContext->Session ) {

                //
                // This LFCB is owned by the requesting session.  Check
                // for RFCBs opened in FCB mode.
                //

                for ( rfcbEntry = lfcb->RfcbList.Flink;
                      rfcbEntry != &lfcb->RfcbList;
                      rfcbEntry = rfcbEntry->Flink ) {

                    pagedRfcb = CONTAINING_RECORD(
                                            rfcbEntry,
                                            PAGED_RFCB,
                                            LfcbListEntry
                                            );

                    rfcb = pagedRfcb->PagedHeader.NonPagedBlock;
                    if ( (pagedRfcb->FcbOpenCount != 0) &&
                         (GET_BLOCK_STATE(rfcb) == BlockStateActive) ) {

                        //
                        // The requesting session already has the file
                        // open in FCB mode.  Rather than reopening the
                        // file, or even linking a new RFCB off the
                        // LFCB, we just return a pointer to the
                        // existing RFCB.
                        //

                        IF_SMB_DEBUG(OPEN_CLOSE2) {
                            KdPrint(( "DoFcbOpen: FCB open of %wZ accepted; duplicates FCB open\n", RelativeName ));
                        }

                        SrvReferenceRfcb( rfcb );

                        pagedRfcb->FcbOpenCount++;

                        IoStatusBlock->Information = FILE_OPENED;

                        WorkContext->Rfcb = rfcb;
                        *Rfcb = rfcb;

                        return STATUS_SUCCESS;

                    } // if ( rfcb->FcbOpenCount != 0 )

                } // for ( rfcbEntry = lfcb->RfcbList.Flink; ...

            } // if ( lfcb->Session == WorkContext->Session )

        } // for ( lfcbEntry = mfcb->LfcbList.Flink; ...

        //
        // The server has the file open, but the requesting session
        // doesn't already have an FCB open for the file.  If the
        // existing open is a compatibility mode open open by this
        // session, we just add a new RFCB.  If it's a compatibility
        // mode open by a different session, we reject this open.
        //

        if ( Mfcb->CompatibilityOpen ) {

            //
            // The named file is open in compatibility mode.  Get a
            // pointer to the LFCB for the open.  Determine whether the
            // requesting session is the one that did the original open.
            //
            // Normally there will only be one LFCB linked to a
            // compatibility mode MFCB.  However, it is possible for
            // there to briefly be multiple LFCBs.  When an LFCB is in
            // the process of closing, the ActiveRfcbCount will be 0, so
            // a new open will be treated as the first open of the MFCB,
            // and there will be two LFCBs linked to the MFCB.  There
            // can actually be more than two LFCBs linked if the rundown
            // of the closing LFCBs takes some time.  So the find "the"
            // LFCB for the open, we go to the tail of the MFCB's list.
            //

            lfcb = CONTAINING_RECORD( Mfcb->LfcbList.Blink, LFCB, MfcbListEntry );

            if ( lfcb->Session != WorkContext->Session ) {

                //
                // A different session has the file open in
                // compatibility mode.  Reject this open request.
                //

                IF_SMB_DEBUG(OPEN_CLOSE2) {
                    KdPrint(( "DoFcbOpen: FCB open of %wZ rejected; already open in compatibility mode\n",
                                RelativeName ));
                }

                return STATUS_SHARING_VIOLATION;
            }

            //
            // The same client has the file open in compatibility mode.
            // Allocate a new RFCB and link it into the existing LFCB.
            // If any errors occur, CompleteOpen does full cleanup.
            //

            IF_SMB_DEBUG(OPEN_CLOSE2) {
                KdPrint(( "DoFcbOpen: FCB open of %wZ accepted; duplicates compatibility open\n", RelativeName ));
            }

            IoStatusBlock->Information = FILE_OPENED;

            status = CompleteOpen(
                        Rfcb,
                        Mfcb,
                        WorkContext,
                        lfcb,
                        NULL,
                        NULL,
                        0,          // ShareAccess
                        0,
                        TRUE,
                        TRUE,
                        LfcbAddedToMfcbList
                        );

            return status;

        } // if ( mfcb->CompatibilityOpen )

    } // if ( mfcb->ActiveRfcbCount > 0 )

    //
    // Either the file is not already open by the server, or it's open
    // for normal sharing, and not in FCB mode by this session.  Because
    // we're supposed to give the client maximum access to the file, we
    // do the following:
    //
    // 1) Try to open the file for read/write/delete, exclusive access.
    //    Obviously this will fail if the file is already open.  But
    //    what we're really trying to find out is what access the client
    //    has to the file.  If this attempt fails with a sharing
    //    violation, then we know the client has write/delete access,
    //    but someone else has it open.  So we can't get compatibility
    //    mode.  Therefore, we reject the open.  On the other hand, if
    //    we get an access denied error, then we know the client can't
    //    write/delete the file, so we try again with write access.  Of
    //    course, this first open could succeed, in which case the
    //    client has the file open for read/write in compatibility mode.
    //
    // 2) Try to open the file for read/write, exclusive access.  As
    //    above, if it fails with a sharing violation, then we know the
    //    client has write access, but someone else has it open.  So we
    //    can't get compatibility mode, and we reject the open.  If we
    //    get an access denied error, then we know the client can't
    //    write the file, so we try again with readonly access.  If this
    //    open succeeds, the client has the file open for read/write in
    //    compatibility mode.
    //
    // 3) If we get here, we know the client can't write to the file,
    //    so we try to open the file for readonly, shared access.  This
    //    no longer a compatibility mode open.  If we get any kind of a
    //    failure here, we're just out of luck.
    //

    compatibilityOpen = TRUE;

    //
    // Set block size according to the AllocationSize in the request SMB.
    //

    allocationSize.QuadPart = SmbAllocationSize;

    IF_SMB_DEBUG(OPEN_CLOSE2) {
        KdPrint(( "DoFcbOpen: Opening file %wZ\n", RelativeName ));
    }

    //
    // Get the value for fileAttributes.
    //

    SRV_SMB_ATTRIBUTES_TO_NT(
        SmbFileAttributes,
        &directory,
        &fileAttributes
        );

    //
    // Try to open the file for Read/Write/Delete access.
    //

    INCREMENT_DEBUG_STAT( SrvDbgStatistics.TotalOpenAttempts );

    //
    // Ensure the EaBuffer is correctly formatted.  Since we are a kernel mode
    //  component, the Io subsystem does not check it for us.
    //
    if( ARGUMENT_PRESENT( EaBuffer ) ) {
        status = IoCheckEaBufferValidity( (PFILE_FULL_EA_INFORMATION)EaBuffer, EaLength, EaErrorOffset );
    } else {
        status = STATUS_SUCCESS;
    }

    if( NT_SUCCESS( status ) ) {
        status = SrvIoCreateFile(
                     WorkContext,
                     &fileHandle,
                     GENERIC_READ | GENERIC_WRITE | DELETE,      // DesiredAccess
                     &objectAttributes,
                     IoStatusBlock,
                     &allocationSize,
                     fileAttributes,
                     0L,                                         // ShareAccess
                     createDisposition,
                     createOptions,
                     EaBuffer,
                     EaLength,
                     CreateFileTypeNone,
                     NULL,                                       // ExtraCreateParameters
                     IO_FORCE_ACCESS_CHECK,
                     WorkContext->TreeConnect->Share
                     );
    }


    if ( status == STATUS_ACCESS_DENIED ) {

        //
        // The client doesn't have Read/Write/Delete access to the file.
        // Try for Read/Write access.
        //

        IF_SMB_DEBUG(OPEN_CLOSE2) {
            KdPrint(( "DoFcbOpen: r/w/d access denied.\n" ));
        }

        INCREMENT_DEBUG_STAT( SrvDbgStatistics.TotalOpenAttempts );

        status = SrvIoCreateFile(
                     WorkContext,
                     &fileHandle,
                     GENERIC_READ | GENERIC_WRITE,           // DesiredAccess
                     &objectAttributes,
                     IoStatusBlock,
                     &allocationSize,
                     fileAttributes,
                     0L,                                     // ShareAccess
                     createDisposition,
                     createOptions,
                     EaBuffer,
                     EaLength,
                     CreateFileTypeNone,
                     NULL,                                   // ExtraCreateParameters
                     IO_FORCE_ACCESS_CHECK,
                     WorkContext->TreeConnect->Share
                     );


        if ( status == STATUS_ACCESS_DENIED ) {

            //
            // The client doesn't have Read/Write access to the file.
            // Try Read access.  If soft compatibility mapping is
            // enabled, use SHARE=READ and don't call this a
            // compatibility mode open.
            //

            IF_SMB_DEBUG(OPEN_CLOSE2) {
                KdPrint(( "DoFcbOpen: r/w access denied.\n" ));
            }

            shareAccess = 0;
            if ( SrvEnableSoftCompatibility ) {
                IF_SMB_DEBUG(OPEN_CLOSE2) {
                    KdPrint(( "DoFcbOpen: FCB open of %wZ mapped to normal open\n", RelativeName ));
                }
                shareAccess = FILE_SHARE_READ;
                compatibilityOpen = FALSE;
            }

            INCREMENT_DEBUG_STAT( SrvDbgStatistics.TotalOpenAttempts );

            status = SrvIoCreateFile(
                         WorkContext,
                         &fileHandle,
                         GENERIC_READ,                       // DesiredAccess
                         &objectAttributes,
                         IoStatusBlock,
                         &allocationSize,
                         fileAttributes,
                         shareAccess,
                         createDisposition,
                         createOptions,
                         EaBuffer,
                         EaLength,
                         CreateFileTypeNone,
                         NULL,                               // ExtraCreateParameters
                         IO_FORCE_ACCESS_CHECK,
                         WorkContext->TreeConnect->Share
                         );


            //
            // If the user didn't have this permission, update the
            // statistics database.
            //

            if ( status == STATUS_ACCESS_DENIED ) {
                SrvStatistics.AccessPermissionErrors++;
            }

        }

    }

    //
    // If we got sharing violation and this is a disk file, and this is
    // the first open attempt, setup for a blocking open attempt.  If the
    // file is batch oplocked, the non-blocking open would fail, and the
    // oplock will not break.
    //

    if ( status == STATUS_SHARING_VIOLATION &&
         WorkContext->ProcessingCount == 1 &&
         WorkContext->TreeConnect->Share->ShareType == ShareTypeDisk ) {

        WorkContext->Parameters2.Open.TemporaryOpen = TRUE;
    }

    if ( !NT_SUCCESS(status) ) {

        //
        // All of the open attempts failed.
        //

        IF_SMB_DEBUG(OPEN_CLOSE2) {
            KdPrint(( "DoFcbOpen: all opens failed; status = %X\n",
                        status ));
        }

        //
        // Set the error offset if needed.
        //

        if ( ARGUMENT_PRESENT(EaErrorOffset) ) {
            *EaErrorOffset = (ULONG)IoStatusBlock->Information;
        }

        return status;
    }

    SRVDBG_CLAIM_HANDLE( fileHandle, "FIL", 12, 0 );

    //
    // The file has been successfully opened.  Attempt to allocate
    // structures to represent the open.  If any errors occur,
    // CompleteOpen does full cleanup, including closing the file.
    //

    IF_SMB_DEBUG(OPEN_CLOSE2) {
        KdPrint(( "DoFcbOpen: Open of %wZ succeeded, file handle: 0x%p\n", RelativeName, fileHandle ));
    }

    completionStatus = CompleteOpen(
                           Rfcb,
                           Mfcb,
                           WorkContext,
                           NULL,
                           fileHandle,
                           NULL,
                           0,           // ShareAccess
                           0,
                           compatibilityOpen,
                           TRUE,
                           LfcbAddedToMfcbList
                           );

    //
    // Return the "interesting" status code.  If CompleteOpen() succeeds
    // return the open status.  If it fails, it will clean up the open
    // file, and we return a failure status.
    //

    if ( !NT_SUCCESS( completionStatus ) ) {
        return completionStatus;
    } else {
        return status;
    }

} // DoFcbOpen


PTABLE_ENTRY
FindAndClaimFileTableEntry (
    IN PCONNECTION Connection,
    OUT PSHORT FidIndex
    )
{
    PTABLE_HEADER tableHeader;
    SHORT fidIndex;
    PTABLE_ENTRY entry;
    KIRQL oldIrql;

    UNLOCKABLE_CODE( 8FIL );

    tableHeader = &Connection->FileTable;

    ACQUIRE_SPIN_LOCK( &Connection->SpinLock, &oldIrql );

    if ( tableHeader->FirstFreeEntry == -1
         &&
         SrvGrowTable(
             tableHeader,
             SrvInitialFileTableSize,
             SrvMaxFileTableSize,
             NULL ) == FALSE
       ) {

        RELEASE_SPIN_LOCK( &Connection->SpinLock, oldIrql );

        return NULL;
    }

    //
    // Remove the FID slot from the free list, but don't set its owner
    // and sequence number yet.
    //

    fidIndex = tableHeader->FirstFreeEntry;

    entry = &tableHeader->Table[fidIndex];

    tableHeader->FirstFreeEntry = entry->NextFreeEntry;
    DEBUG entry->NextFreeEntry = -2;
    if ( tableHeader->LastFreeEntry == fidIndex ) {
        tableHeader->LastFreeEntry = -1;
    }

    RELEASE_SPIN_LOCK( &Connection->SpinLock, oldIrql );

    *FidIndex = fidIndex;
    return entry;

} // FindAndClaimFileTableEntry


NTSTATUS
CompleteOpen (
    OUT PRFCB *Rfcb,
    IN PMFCB Mfcb,
    IN OUT PWORK_CONTEXT WorkContext,
    IN PLFCB ExistingLfcb OPTIONAL,
    IN HANDLE FileHandle OPTIONAL,
    IN PACCESS_MASK RemoteGrantedAccess OPTIONAL,
    IN ULONG ShareAccess,
    IN ULONG FileMode,
    IN BOOLEAN CompatibilityOpen,
    IN BOOLEAN FcbOpen,
    OUT PBOOLEAN LfcbAddedToMfcbList
    )

/*++

Routine Description:

    Completes structure allocation, initialization, and linking after
    a successful open.  Updates Master File Table as appropriate.
    Adds entry to connection's file table.

    *** The MFCB lock must be held on entry to this routine; the lock
        remains held on exit.

Arguments:

    Rfcb - A pointer to a pointer to an RFCB that will point to the
        newly-created RFCB.

    Mfcb - A pointer to the MFCB for this file.

    WorkContext - Work context block for the operation.

    ExistingLfcb - Optional address of an existing Local File Control
        Block.  Specified when folding a duplicate compatibility mode
        open into a single local open.

    FileHandle - Optional file handle obtained from SrvIoCreateFile.
        Ignored when ExistingLfcb is specified.

    RemoteGrantedAccess - Optional granted access to be stored in new
        RFCB.  If not specified, granted access from LFCB (i.e., access
        obtained on local open) is used.

    FileMode - Same value specified as CreateOptions on SrvIoCreateFile
        call.  Indicates whether client wants writethrough mode.

    CompatibilityOpen - TRUE if this is a compatibility mode open.

    FcbOpen - TRUE if this is an FCB open.

    LfcbAddedToMfcbList - Pointer to a boolean that will be set to TRUE if
        an lfcb is added to the mfcb list of lfcbs.

Return Value:

    NTSTATUS - Indicates what occurred.

--*/

{
    NTSTATUS status;

    PRFCB rfcb;
    PPAGED_RFCB pagedRfcb;
    PLFCB newLfcb;
    PLFCB lfcb;
    BOOLEAN rfcbLinkedToLfcb;

    PFILE_OBJECT fileObject;

    OBJECT_HANDLE_INFORMATION handleInformation;

    PCONNECTION connection;
    PTABLE_ENTRY entry;
    SHORT fidIndex;

    ULONG pid;

    PAGED_CODE( );

    //
    // Initialize various fields for the error handler.
    //

    rfcb = NULL;
    newLfcb = NULL;
    rfcbLinkedToLfcb = FALSE;
    fileObject = NULL;
    *LfcbAddedToMfcbList = FALSE;

    //
    // Allocate an RFCB.
    //

    SrvAllocateRfcb( &rfcb, WorkContext );

    if ( rfcb == NULL ) {

        ULONG length = sizeof( RFCB );

        //
        // Unable to allocate RFCB.  Return an error to the client.
        //

        IF_DEBUG(ERRORS) {
            KdPrint(( "CompleteOpen: Unable to allocate RFCB\n" ));
        }

        status = STATUS_INSUFF_SERVER_RESOURCES;
        goto error_exit;

    }

    pagedRfcb = rfcb->PagedRfcb;

    //
    // If no existing LFCB address was passed in (i.e., if this is not a
    // duplicate compatibility mode open), allocate and initialize a new
    // LFCB.
    //

    if ( ARGUMENT_PRESENT( ExistingLfcb ) ) {

        ASSERT( CompatibilityOpen );
        ASSERT( ExistingLfcb->CompatibilityOpen );

        lfcb = ExistingLfcb;

    } else {

        PFAST_IO_DISPATCH fastIoDispatch;

        SrvAllocateLfcb( &newLfcb, WorkContext );

        if ( newLfcb == NULL ) {

            //
            // Unable to allocate LFCB.  Return an error to the client.
            //

            IF_DEBUG(ERRORS) {
                KdPrint(( "CompleteOpen: Unable to allocate LFCB\n" ));
            }

            status = STATUS_INSUFF_SERVER_RESOURCES;
            goto error_exit;

        }

        lfcb = newLfcb;

        //
        // Get a pointer to the file object, so that we can directly
        // build IRPs for asynchronous operations (read and write).
        // Also, get the granted access mask, so that we can prevent the
        // client from doing things that it isn't allowed to do.
        //
        // *** Note that the granted access on the local open may allow
        //     more access than was requested on the remote open.
        //     That's why the RFCB has its own granted access field.
        //

        status = ObReferenceObjectByHandle(
                    FileHandle,
                    0,
                    NULL,
                    KernelMode,
                    (PVOID *)&fileObject,
                    &handleInformation
                    );

        if ( !NT_SUCCESS(status) ) {

            SrvLogServiceFailure( SRV_SVC_OB_REF_BY_HANDLE, status );

            //
            // This internal error bugchecks the system.
            //

            INTERNAL_ERROR(
                ERROR_LEVEL_IMPOSSIBLE,
                "CompleteOpen: unable to reference file handle 0x%lx",
                FileHandle,
                NULL
                );

            goto error_exit;

        }

        //
        // Initialize the new LFCB.
        //

        lfcb->FileHandle = FileHandle;
        lfcb->FileObject = fileObject;

        lfcb->GrantedAccess = handleInformation.GrantedAccess;
        lfcb->DeviceObject = IoGetRelatedDeviceObject( fileObject );

        fastIoDispatch = lfcb->DeviceObject->DriverObject->FastIoDispatch;
        if ( fastIoDispatch != NULL ) {
            lfcb->FastIoRead = fastIoDispatch->FastIoRead;
            lfcb->FastIoWrite = fastIoDispatch->FastIoWrite;
            lfcb->FastIoLock = fastIoDispatch->FastIoLock;
            lfcb->FastIoUnlockSingle = fastIoDispatch->FastIoUnlockSingle;

            //
            //  Fill in Mdl calls.  If the file system's vector is large enough,
            //  we still need to check if one of the routines is specified.  But
            //  if one is specified they all must be.
            //
            if ((fastIoDispatch->SizeOfFastIoDispatch > FIELD_OFFSET(FAST_IO_DISPATCH, MdlWriteComplete)) &&
                (fastIoDispatch->MdlRead != NULL)) {

                lfcb->MdlRead = fastIoDispatch->MdlRead;
                lfcb->MdlReadComplete = fastIoDispatch->MdlReadComplete;
                lfcb->PrepareMdlWrite = fastIoDispatch->PrepareMdlWrite;
                lfcb->MdlWriteComplete = fastIoDispatch->MdlWriteComplete;


            } else if( IoGetBaseFileSystemDeviceObject( fileObject ) == lfcb->DeviceObject ) {
                //
                //  Otherwise default to the original FsRtl routines if we are right atop
                //   a filesystem.
                //
                lfcb->MdlRead = FsRtlMdlReadDev;
                lfcb->MdlReadComplete = FsRtlMdlReadCompleteDev;
                lfcb->PrepareMdlWrite = FsRtlPrepareMdlWriteDev;
                lfcb->MdlWriteComplete = FsRtlMdlWriteCompleteDev;
            } else {
                //
                // Otherwise, make them fail!
                //
                lfcb->MdlRead = SrvFailMdlReadDev;
                lfcb->PrepareMdlWrite = SrvFailPrepareMdlWriteDev;
            }

            //
            //  Fill in Mdl calls, if the file system vector is long enough.
            //  For now we will just copy all six compressed routines over,
            //  whether they are actually supplied or not (NULL).  There are
            //  no default routines for these, they are either supported or not.
            //

            if ((fastIoDispatch->SizeOfFastIoDispatch > FIELD_OFFSET(FAST_IO_DISPATCH, MdlWriteCompleteCompressed))) {

                lfcb->FastIoReadCompressed = fastIoDispatch->FastIoReadCompressed;
                lfcb->FastIoWriteCompressed = fastIoDispatch->FastIoWriteCompressed;
                lfcb->MdlReadCompleteCompressed = fastIoDispatch->MdlReadCompleteCompressed;
                lfcb->MdlWriteCompleteCompressed = fastIoDispatch->MdlWriteCompleteCompressed;
            }
        }

        lfcb->FileMode = FileMode & ~FILE_COMPLETE_IF_OPLOCKED;
        lfcb->CompatibilityOpen = CompatibilityOpen;
    }

    //
    // Initialize the RFCB.
    //

    if ( ARGUMENT_PRESENT( RemoteGrantedAccess ) ) {
        rfcb->GrantedAccess = *RemoteGrantedAccess;
        IoCheckDesiredAccess( &rfcb->GrantedAccess, lfcb->GrantedAccess );
    } else {
        rfcb->GrantedAccess = lfcb->GrantedAccess;
    }

    rfcb->ShareAccess = ShareAccess;
    rfcb->FileMode = lfcb->FileMode;
    rfcb->Mfcb = Mfcb;
#ifdef SRVCATCH
    rfcb->SrvCatch = Mfcb->SrvCatch;
#endif

    //
    // If delete on close was specified, don't attempt to cache this rfcb.
    //

    if ( (FileMode & FILE_DELETE_ON_CLOSE) != 0 ) {
        rfcb->IsCacheable = FALSE;
    }

    //
    // Check for granted access
    //

    //
    // Locks
    //

    CHECK_FUNCTION_ACCESS(
        rfcb->GrantedAccess,
        IRP_MJ_LOCK_CONTROL,
        IRP_MN_LOCK,
        0,
        &status
        );

    if ( NT_SUCCESS(status) ) {
        rfcb->LockAccessGranted = TRUE;
    } else {
        IF_DEBUG(ERRORS) {
            KdPrint(( "CompleteOpen: Lock IoCheckFunctionAccess failed: "
                        "0x%X, GrantedAccess: %lx\n",
                        status, rfcb->GrantedAccess ));
        }
    }

    //
    // Unlocks
    //

    CHECK_FUNCTION_ACCESS(
        rfcb->GrantedAccess,
        IRP_MJ_LOCK_CONTROL,
        IRP_MN_UNLOCK_SINGLE,
        0,
        &status
        );

    if ( NT_SUCCESS(status) ) {
        rfcb->UnlockAccessGranted = TRUE;
    } else {
        IF_DEBUG(ERRORS) {
            KdPrint(( "CompleteOpen: Unlock IoCheckFunctionAccess failed: "
                        "0x%X, GrantedAccess: %lx\n",
                        status, rfcb->GrantedAccess ));
        }
    }

    //
    // Reads
    //

    CHECK_FUNCTION_ACCESS(
        rfcb->GrantedAccess,
        IRP_MJ_READ,
        0, 0, &status );

    if ( NT_SUCCESS(status) ) {
        rfcb->ReadAccessGranted = TRUE;
    } else {
        IF_DEBUG(ERRORS) {
            KdPrint(( "CompleteOpen: Read IoCheckFunctionAccess failed: "
                        "0x%X, GrantedAccess: %lx\n",
                        status, rfcb->GrantedAccess ));
        }
    }

    //
    // Writes
    //

    if( rfcb->GrantedAccess & FILE_WRITE_DATA ) {
        rfcb->WriteAccessGranted = TRUE;
    }
    if( rfcb->GrantedAccess & FILE_APPEND_DATA ) {
        rfcb->AppendAccessGranted = TRUE;

        //
        // This hack is required for now.  The problem is that clients, given an
        //  oplock, will write whole pages to the server.  The offset of the page
        //  will likely cover the last part of the file, and the server will reject
        //  the write.  Code needs to be added to the server to ignore the
        //  first part of the page.  Or we could just not give the client an oplock
        //  if append access is granted.  For now, we revert to prior NT4 behavior.
        //
        rfcb->WriteAccessGranted = TRUE;
    }

    //
    // Copy the TID from the tree connect into the RFCB.  We do this to
    // reduce the number of indirections we have to take.  Save the PID
    // of the remote process that's opening the file.  We'll need this
    // if we get a Process Exit SMB.
    //

    rfcb->Tid = WorkContext->TreeConnect->Tid;
    rfcb->Pid = SmbGetAlignedUshort( &WorkContext->RequestHeader->Pid );
    pid = rfcb->Pid;
    rfcb->Uid = WorkContext->Session->Uid;

    if ( FcbOpen ) {
        pagedRfcb->FcbOpenCount = 1;
    }

    if ( WorkContext->Endpoint->IsConnectionless ) {
        rfcb->WriteMpx.FileObject = lfcb->FileObject;
        rfcb->WriteMpx.MpxGlommingAllowed =
            (BOOLEAN)((lfcb->FileObject->Flags & FO_CACHE_SUPPORTED) != 0);
    }

    //
    // If this is a named pipe, fill in the named pipe specific
    // information.  The default mode on open is always byte mode,
    // blocking.
    //

    rfcb->ShareType = WorkContext->TreeConnect->Share->ShareType;

    if ( rfcb->ShareType == ShareTypePipe ) {
        rfcb->BlockingModePipe = TRUE;
        rfcb->ByteModePipe = TRUE;
    }

    //
    // Link the RFCB into the LFCB.
    //

    SrvInsertTailList( &lfcb->RfcbList, &pagedRfcb->LfcbListEntry );
    rfcb->Lfcb = lfcb;
    lfcb->BlockHeader.ReferenceCount++;
    UPDATE_REFERENCE_HISTORY( lfcb, FALSE );
    lfcb->HandleCount++;
    rfcbLinkedToLfcb = TRUE;

    //
    // Making a new RFCB visible is a multi-step operation.  It must be
    // inserted in the global ordered file list and the containing
    // connection's file table.  If the LFCB is not new, it must be
    // inserted in the MFCB's list of LFCBs, and the connection, the
    // session, and the tree connect must all be referenced.  We need to
    // make these operations appear atomic, so that the RFCB cannot be
    // accessed elsewhere before we're done setting it up.  In order to
    // do this, we hold all necessary locks the entire time we're doing
    // the operations.  The locks that are required are:
    //
    //  1) the MFCB lock (which protects the MFCB's LFCB list),
    //
    //  2) the global ordered list lock (which protects the ordered file
    //     list),
    //
    //  3) the connection lock (which prevents closing of the
    //     connection, the session, and the tree connect), and
    //
    // These locks are taken out in the order listed above, as dictated
    // by lock levels (see lock.h).  Note that the MFCB lock is already
    // held on entry to this routine.
    //

    connection = WorkContext->Connection;

    ASSERT( ExIsResourceAcquiredExclusiveLite(&RESOURCE_OF(Mfcb->NonpagedMfcb->Lock)) );
    ASSERT( SrvRfcbList.Lock == &SrvOrderedListLock );
    ACQUIRE_LOCK( SrvRfcbList.Lock );
    ACQUIRE_LOCK( &connection->Lock );

    //
    // We first check all conditions to make sure that we can actually
    // insert this RFCB.
    //
    // Make sure that the tree connect isn't closing.
    //

    if ( GET_BLOCK_STATE(WorkContext->TreeConnect) != BlockStateActive ) {

        //
        // The tree connect is closing.  Reject the request.
        //

        IF_DEBUG(ERRORS) {
            KdPrint(( "CompleteOpen: Tree connect is closing\n" ));
        }

        status = STATUS_INVALID_PARAMETER;
        goto cant_insert;

    }

    //
    // Make sure that the session isn't closing.
    //

    if ( GET_BLOCK_STATE(WorkContext->Session) != BlockStateActive ) {

        //
        // The session is closing.  Reject the request.
        //

        IF_DEBUG(ERRORS) {
            KdPrint(( "CompleteOpen: Session is closing\n" ));
        }

        status = STATUS_INVALID_PARAMETER;
        goto cant_insert;

    }

    //
    // Make sure that the connection isn't closing.
    //

    connection = WorkContext->Connection;

    if ( GET_BLOCK_STATE(connection) != BlockStateActive ) {

        //
        // The connection is closing.  Reject the request.
        //

        IF_DEBUG(ERRORS) {
            KdPrint(( "CompleteOpen: Connection closing\n" ));
        }

        status = STATUS_INVALID_PARAMETER;
        goto cant_insert;
    }

    //
    // Find and claim a FID that can be used for this file.
    //

    entry = FindAndClaimFileTableEntry( connection, &fidIndex );
    if ( entry == NULL ) {

        //
        // No free entries in the file table.  Reject the request.
        //

        IF_DEBUG(ERRORS) {
            KdPrint(( "CompleteOpen: No more FIDs available.\n" ));
        }

        SrvLogTableFullError( SRV_TABLE_FILE );

        status = STATUS_OS2_TOO_MANY_OPEN_FILES;
        goto cant_insert;
    }

    //
    // All conditions have been satisfied.  We can now do the things
    // necessary to make the file visible.
    //
    // If this isn't a duplicate open, add this open file instance to
    // the Master File Table.
    //

    if ( !ARGUMENT_PRESENT( ExistingLfcb ) ) {

        //
        // Add the new LFCB to the master file's list of open instances.
        // We set LfcbAddedToMfcbList to tell the calling routine that
        // an LFCB has been queued to the MFCB and that the reference
        // count that was previously incremented should not be
        // decremented.
        //

        *LfcbAddedToMfcbList = TRUE;
        Mfcb->CompatibilityOpen = lfcb->CompatibilityOpen;
        SrvInsertTailList( &Mfcb->LfcbList, &lfcb->MfcbListEntry );
        lfcb->Mfcb = Mfcb;

        //
        // Point the LFCB to the connection, session, and tree connect,
        // referencing them to account for the open file and therefore
        // prevent deletion.
        //

        SrvReferenceConnection( connection );
        lfcb->Connection = connection;

        SrvReferenceSession( WorkContext->Session );
        lfcb->Session = WorkContext->Session;

        SrvReferenceTreeConnect( WorkContext->TreeConnect );
        lfcb->TreeConnect = WorkContext->TreeConnect;

        //
        // Increment the count of open files in the session and tree
        // connect.  These counts prevent autodisconnecting a session
        // that has open files and are used by server APIs.
        //

        WorkContext->Session->CurrentFileOpenCount++;
        WorkContext->TreeConnect->CurrentFileOpenCount++;

    }

    //
    // Capture the connection pointer in the nonpaged RFCB so that we
    // can find the connection at DPC level.
    //

    rfcb->Connection = lfcb->Connection;

    //
    // Insert the RFCB on the global ordered list.
    //

    SrvInsertEntryOrderedList( &SrvRfcbList, rfcb );

    //
    // Set the owner and sequence number of the file table slot.  Create
    // a FID for the file.
    //

    entry->Owner = rfcb;

    INCREMENT_FID_SEQUENCE( entry->SequenceNumber );
    if ( fidIndex == 0 && entry->SequenceNumber == 0 ) {
        INCREMENT_FID_SEQUENCE( entry->SequenceNumber );
    }

    rfcb->Fid = MAKE_FID( fidIndex, entry->SequenceNumber );
    rfcb->ShiftedFid = rfcb->Fid << 16;

    IF_SMB_DEBUG(OPEN_CLOSE2) {
        KdPrint(( "CompleteOpen: Found FID. Index = 0x%lx, sequence = 0x%lx\n",
                    FID_INDEX( rfcb->Fid ), FID_SEQUENCE( rfcb->Fid ) ));
    }

    //
    // Release the locks used to make this operation appear atomic.
    //
    // Note that our caller expects us to keep the MFCB lock held.
    //

    RELEASE_LOCK( &connection->Lock );
    RELEASE_LOCK( SrvRfcbList.Lock );

    //
    // File successfully opened.  Save in the WorkContext block for
    // the followon SMB, if any. Cache the Rfcb.
    //

    WorkContext->Rfcb = rfcb;
    *Rfcb = rfcb;

    //
    // Update the MFCB active count.
    //

    ++Mfcb->ActiveRfcbCount;

    //
    // If this is a pipe, set the client ID for the pipe.  If it is a
    // message type named pipe, set the read mode to message mode.
    //

    if ( rfcb->ShareType == ShareTypePipe ) {

        //
        // NT clients put the high part of the PID in a reserved
        // location in the SMB header.
        //

        if ( IS_NT_DIALECT( WorkContext->Connection->SmbDialect ) ) {
            pid = (SmbGetUshort( &WorkContext->RequestHeader->PidHigh )
                    << 16) | pid;
        }

        (VOID)SrvIssueSetClientProcessRequest(
                lfcb->FileObject,
                &lfcb->DeviceObject,
                connection,
                WorkContext->Session,
                LongToPtr( pid )
                );

        //
        // Set the read mode.
        //

        rfcb->ByteModePipe = !SetDefaultPipeMode( FileHandle );

    }

    return STATUS_SUCCESS;

cant_insert:

    //
    // Release the locks.
    //
    // Note that our caller expects us to keep the MFCB lock held.
    //

    RELEASE_LOCK( &connection->Lock );
    RELEASE_LOCK( SrvRfcbList.Lock );

error_exit:

    //
    // Error cleanup.  Put things back into their initial state.
    //
    // If the new RFCB was associated with an LFCB, unlink it now.
    //

    if ( rfcbLinkedToLfcb ) {
        SrvRemoveEntryList(
                &rfcb->Lfcb->RfcbList,
                &pagedRfcb->LfcbListEntry
                );

        lfcb->BlockHeader.ReferenceCount--;
        UPDATE_REFERENCE_HISTORY( lfcb, TRUE );
        lfcb->HandleCount--;
    }

    //
    // If the file object was referenced, dereference it.
    //

    if ( fileObject != NULL ) {
        ObDereferenceObject( fileObject );
    }

    //
    // If a new LFCB was allocated, free it.
    //

    if ( newLfcb != NULL ) {
        SrvFreeLfcb( newLfcb, WorkContext->CurrentWorkQueue );
    }

    //
    // If a new RFCB was allocated, free it.
    //

    if ( rfcb != NULL ) {
        SrvFreeRfcb( rfcb, WorkContext->CurrentWorkQueue );
    }

    //
    // If this not a folded compatibility mode open, close the file.
    //

    if ( !ARGUMENT_PRESENT( ExistingLfcb ) ) {
        SRVDBG_RELEASE_HANDLE( FileHandle, "FIL", 17, 0 );
        SrvNtClose( FileHandle, TRUE );
    }

    //
    // Indicate failure.
    //

    *Rfcb = NULL;

    return status;

} // CompleteOpen


BOOLEAN SRVFASTCALL
MapCompatibilityOpen(
    IN PUNICODE_STRING FileName,
    IN OUT PUSHORT SmbDesiredAccess
    )

/*++

Routine Description:

    Determines whether a compatibility mode open can be mapped into
    normal sharing mode.

Arguments:

    FileName - The name of the file being accessed

    SmbDesiredAccess - On input, the desired access specified in the
        received SMB.  On output, the share mode portion of this field
        is updated if the open is mapped to normal sharing.

Return Value:

    BOOLEAN - TRUE if the open has been mapped to normal sharing.

--*/

{
    PAGED_CODE( );

    //
    // If soft compatibility is not enabled then reject the mapping
    //
    if( !SrvEnableSoftCompatibility ) {

        IF_SMB_DEBUG( OPEN_CLOSE2 ) {
            KdPrint(( "MapCompatibilityOpen: "
                      "SrvEnableSoftCompatibility is FALSE\n" ));
        }

        return FALSE;
    }

    //
    // If the client is opening one of the following reserved suffixes, be lenient
    //
    if( FileName->Length > 4 * sizeof( WCHAR ) ) {

        LPWSTR periodp;

        periodp = FileName->Buffer + (FileName->Length / sizeof( WCHAR ) ) - 4;

        if( (*periodp++ == L'.') &&
            (_wcsicmp( periodp, L"EXE" ) == 0  ||
             _wcsicmp( periodp, L"DLL" ) == 0  ||
             _wcsicmp( periodp, L"SYM" ) == 0  ||
             _wcsicmp( periodp, L"COM" ) == 0 )  ) {

            //
            // This is a readonly open of one of the above file types.
            //  Map to DENY_NONE
            //

            IF_SMB_DEBUG( OPEN_CLOSE2 ) {
                KdPrint(( "MapCompatibilityOpen: %wZ mapped to DENY_NONE\n", FileName ));
            }

            *SmbDesiredAccess |= SMB_DA_SHARE_DENY_NONE;
            return TRUE;
        }
    }

    //
    // The filename does not end in one of the special suffixes -- map
    // it to DENY_WRITE if the client is asking for just read permissions.
    //
    if( (*SmbDesiredAccess & SMB_DA_ACCESS_MASK) == SMB_DA_ACCESS_READ) {
        IF_SMB_DEBUG( OPEN_CLOSE2 ) {
                KdPrint(( "MapCompatibilityOpen: %wZ mapped to DENY_WRITE\n", FileName ));
        }
        *SmbDesiredAccess |= SMB_DA_SHARE_DENY_WRITE;
        return TRUE;
    }

    IF_SMB_DEBUG( OPEN_CLOSE2 ) {
        KdPrint(( "MapCompatibilityOpen: %wZ not mapped, DesiredAccess %X\n", FileName, *SmbDesiredAccess ));
    }

    return FALSE;
} // MapCompatibilityOpen


NTSTATUS SRVFASTCALL
MapDesiredAccess(
    IN USHORT SmbDesiredAccess,
    OUT PACCESS_MASK NtDesiredAccess
    )

/*++

Routine Description:

    Maps a desired access specification from SMB form to NT form.

Arguments:

    SmbDesiredAccess - The desired access specified in the received SMB.
        (This includes desired access, share access, and other mode
        bits.)

    NtDesiredAccess - Returns the NT equivalent of the desired access
        part of SmbDesiredAccess.

Return Value:

    NTSTATUS - Indicates whether SmbDesiredAccess is valid.

--*/

{
    PAGED_CODE( );

    switch ( SmbDesiredAccess & SMB_DA_ACCESS_MASK ) {

    case SMB_DA_ACCESS_READ:

        *NtDesiredAccess = GENERIC_READ;
        break;

    case SMB_DA_ACCESS_WRITE:

        //
        // Having read attributes is implicit in having the file open in
        // the SMB protocol, so request FILE_READ_ATTRIBUTES in addition
        // to GENERIC_WRITE.
        //

        *NtDesiredAccess = GENERIC_WRITE | FILE_READ_ATTRIBUTES;
        break;

    case SMB_DA_ACCESS_READ_WRITE:

        *NtDesiredAccess = GENERIC_READ | GENERIC_WRITE;
        break;

    case SMB_DA_ACCESS_EXECUTE:

        // !!! is this right?
        *NtDesiredAccess = GENERIC_READ | GENERIC_EXECUTE;
        break;

    default:

        IF_DEBUG(SMB_ERRORS) {
            KdPrint(( "MapDesiredAccess: Invalid desired access: 0x%lx\n",
                        SmbDesiredAccess ));
        }

        return STATUS_OS2_INVALID_ACCESS;
    }

    return STATUS_SUCCESS;

} // MapDesiredAccess


NTSTATUS SRVFASTCALL
MapOpenFunction(
    IN USHORT SmbOpenFunction,
    OUT PULONG NtCreateDisposition
    )

/*++

Routine Description:

    Maps an open function specification from SMB form to NT form.

Arguments:

    WorkContext - Work context block for the operation.

    SmbOpenFunction - The open function specified in the received SMB.

    NtDesiredAccess - Returns the NT equivalent of SmbOpenFunction.

Return Value:

    NTSTATUS - Indicates whether SmbOpenFunction is valid.

--*/

{
    PAGED_CODE( );

    // The OpenFunction bit mapping:
    //
    //     rrrr rrrr rrrC rrOO
    //
    //   where:
    //
    //     C - Create (action to be taken if the file does not exist)
    //       0 -- Fail
    //       1 -- Create file
    //
    //     O - Open (action to be taken if the file exists)
    //       0 - Fail
    //       1 - Open file
    //       2 - Truncate file
    //

    switch ( SmbOpenFunction & (SMB_OFUN_OPEN_MASK | SMB_OFUN_CREATE_MASK) ) {

    case SMB_OFUN_CREATE_FAIL | SMB_OFUN_OPEN_OPEN:

        *NtCreateDisposition = FILE_OPEN;
        break;

    case SMB_OFUN_CREATE_CREATE | SMB_OFUN_OPEN_FAIL:

        *NtCreateDisposition = FILE_CREATE;
        break;

    case SMB_OFUN_CREATE_CREATE | SMB_OFUN_OPEN_OPEN:

        *NtCreateDisposition = FILE_OPEN_IF;
        break;

    case SMB_OFUN_CREATE_CREATE | SMB_OFUN_OPEN_TRUNCATE:

        *NtCreateDisposition = FILE_OVERWRITE_IF;
        break;

    case SMB_OFUN_CREATE_FAIL | SMB_OFUN_OPEN_TRUNCATE:

        *NtCreateDisposition = FILE_OVERWRITE;
        break;

    //case 0x00:
    //case 0x03:
    //case 0x13:
    default:

        IF_DEBUG(SMB_ERRORS) {
            KdPrint(( "MapOpenFunction: Invalid open function: 0x%lx\n",
                        SmbOpenFunction ));
        }

        return STATUS_OS2_INVALID_ACCESS;
    }

    return STATUS_SUCCESS;

} // MapOpenFunction


NTSTATUS SRVFASTCALL
MapCacheHints(
    IN USHORT SmbDesiredAccess,
    IN OUT PULONG NtCreateFlags
    )

/*++

Routine Description:

    This function maps the SMB cache mode hints to the NT format.  The
    NtCreateFlags are updated.

Arguments:

    WorkContext - Work context block for the operation.

    SmbOpenFunction - The open function specified in the received SMB.

    NtCreateFlags - The NT file creation flags

Return Value:

    NTSTATUS - Indicates whether SmbOpenFunction is valid.

--*/

{
    PAGED_CODE( );

    // The DesiredAccess bit mapping:
    //
    //      xxxC xLLL xxxx xxxx
    //
    //   where:
    //
    //     C - Cache mode
    //       0 -- Normal file
    //       1 -- Do not cache the file
    //
    //     LLL - Locality of reference
    //       000 - Unknown
    //       001 - Mainly sequential access
    //       010 - Mainly random access
    //       011 - Random with some locality
    //       1xx - Undefined
    //

    //
    // If the client doesn't want us to use the cache, we can't give that, but we
    // can at least get the data written immediately.
    //

    if ( SmbDesiredAccess & SMB_DO_NOT_CACHE ) {
        *NtCreateFlags |= FILE_WRITE_THROUGH;
    }

    switch ( SmbDesiredAccess & SMB_LR_MASK ) {

    case SMB_LR_UNKNOWN:
        break;

    case SMB_LR_SEQUENTIAL:
        *NtCreateFlags |= FILE_SEQUENTIAL_ONLY;
        break;

    case SMB_LR_RANDOM:
    case SMB_LR_RANDOM_WITH_LOCALITY:
        *NtCreateFlags |= FILE_RANDOM_ACCESS;
        break;

    default:

        IF_DEBUG(SMB_ERRORS) {
            KdPrint(( "MapCacheHints: Invalid cache hint: 0x%lx\n",
                       SmbDesiredAccess ));
        }

        return STATUS_OS2_INVALID_ACCESS;
    }

    return STATUS_SUCCESS;

} // MapCacheHints


NTSTATUS SRVFASTCALL
MapShareAccess(
    IN USHORT SmbDesiredAccess,
    OUT PULONG NtShareAccess
    )

/*++

Routine Description:

    Maps a share access specification from SMB form to NT form.

Arguments:

    SmbDesiredAccess - The desired access specified in the received SMB.
        (This includes desired access, share access, and other mode
        bits.)

    NtShareAccess - Returns the NT equivalent of the share access part
        of SmbDesiredAccess.

Return Value:

    NTSTATUS - Indicates whether SmbDesiredAccess is valid.

--*/

{
    PAGED_CODE( );

    switch ( SmbDesiredAccess & SMB_DA_SHARE_MASK ) {

    case SMB_DA_SHARE_EXCLUSIVE:

        //
        // Deny read and write.
        //

        *NtShareAccess = 0L;
        break;

    case SMB_DA_SHARE_DENY_WRITE:

        //
        // Deny write but allow read.
        //

        *NtShareAccess = FILE_SHARE_READ;
        break;

    case SMB_DA_SHARE_DENY_READ:

        //
        // Deny read but allow write.
        //

        *NtShareAccess = FILE_SHARE_WRITE;
        break;

    case SMB_DA_SHARE_DENY_NONE:

        //
        // Deny none -- allow other processes to read or write the file.
        //

        *NtShareAccess = FILE_SHARE_READ | FILE_SHARE_WRITE;
        break;

    default:

        IF_DEBUG(SMB_ERRORS) {
            KdPrint(( "MapShareAccess: Invalid share access: 0x%lx\n",
                        SmbDesiredAccess ));
        }

        return STATUS_OS2_INVALID_ACCESS;
    }

    return STATUS_SUCCESS;

} // MapShareAccess


NTSTATUS
SrvNtCreateFile(
    IN OUT PWORK_CONTEXT WorkContext,
    IN ULONG RootDirectoryFid,
    IN ACCESS_MASK DesiredAccess,
    IN LARGE_INTEGER AllocationSize,
    IN ULONG FileAttributes,
    IN ULONG ShareAccess,
    IN ULONG CreateDisposition,
    IN ULONG CreateOptions,
    IN PVOID SecurityDescriptorBuffer OPTIONAL,
    IN PUNICODE_STRING FileName,
    IN PVOID EaBuffer OPTIONAL,
    IN ULONG EaLength,
    OUT PULONG EaErrorOffset OPTIONAL,
    IN ULONG OptionFlags,
    PSECURITY_QUALITY_OF_SERVICE QualityOfService,
    IN OPLOCK_TYPE RequestedOplockType,
    IN PRESTART_ROUTINE RestartRoutine
    )

/*++

Routine Description:

    Does most of the operations necessary to open or create a file.
    First the UID and TID are verified and the corresponding session and
    tree connect blocks located.  The input file name name is
    canonicalized, and a fully qualified name is formed.  The file
    is opened and the appropriate data structures are created.

Arguments:

    WorkContext - Work context block for the operation.

    RootDirectoryFid - The FID of an open root directory.  The file is opened
       relative to this directory.

    DesiredAccess - The access type requested by the client.

    AllocationSize - The initialize allocation size of the file.  It is
       only used if the file is created, overwritten, or superseded.

    FileAttributes - Specified the file attributes.

    ShareAccess -  Specifies the type of share access requested by the
        client.

    CreateDisposition - Specifies the action to be taken if the file does
        or does not exist.

    CreateOptions - Specifies the options to use when creating the file.

    SecurityDescriptorBuffer - The SD to set on the file.

    FileName - The name of the file to open.

    EaBuffer - The EAs to set on the file.

    EaLength - Length, in bytes, of the EA buffer.

    EaErrorOffset - Returns the offset, in bytes, in the EA buffer of
       the EA error.

    OptionFlags - The option flags for creating the file

    QualityOfService - The security quality of service for the file

    RestartRoutine - The restart routine for the caller.

Return Value:

    NTSTATUS - Indicates what occurred.

--*/

{
    NTSTATUS status;
    NTSTATUS completionStatus;

    PMFCB mfcb;
    PNONPAGED_MFCB nonpagedMfcb;
    PRFCB rfcb;

    PSESSION session;
    PTREE_CONNECT treeConnect;

    UNICODE_STRING relativeName;
    UNICODE_STRING fullName;
    BOOLEAN nameAllocated;
    BOOLEAN relativeNameAllocated = FALSE;
    SHARE_TYPE shareType;
    PRFCB rootDirRfcb = NULL;
    PLFCB rootDirLfcb;
    BOOLEAN success;
    ULONG attributes;
    ULONG openRetries;
    OBJECT_ATTRIBUTES objectAttributes;
    HANDLE fileHandle;
    IO_STATUS_BLOCK ioStatusBlock;
    ULONG ioCreateFlags;
    PSHARE fileShare = NULL;
    BOOLEAN caseInsensitive;
    ULONG hashValue;

    PSRV_LOCK mfcbLock;

    //
    // NOTE ON MFCB REFERENCE COUNT HANDLING
    //
    // After finding or creating an MFCB for a file, we increment the
    // MFCB reference count an extra time to simplify our
    // synchronization logic.   We hold MfcbListLock lock while
    // finding/creating the MFCB, but release it after acquiring the the
    // per-MFCB lock.  After opening the file, we call CompleteOpen,
    // which may need to queue an LFCB to the MFCB and thus need to
    // increment the count.  But it can't, because the MFCB list lock may
    // not be acquired while the per-MFCB lock is held because of
    // deadlock potential.  The boolean LfcbAddedToMfcbList returned
    // from CompleteOpen indicates whether it actually queued an LFCB to
    // the MFCB.  If it didn't, we need to release the extra reference.
    //
    // Note that it isn't often that we actually have to dereference the
    // MFCB.  This only occurs when the open fails.
    //

    BOOLEAN lfcbAddedToMfcbList;

    PAGED_CODE( );

    //
    // Assume we won't need a temporary open.
    //

    WorkContext->Parameters2.Open.TemporaryOpen = FALSE;

    //
    // If a session block has not already been assigned to the current
    // work context, verify the UID.  If verified, the address of the
    // session block corresponding to this user is stored in the
    // WorkContext block and the session block is referenced.
    //
    // Find the tree connect corresponding to the given TID if a tree
    // connect pointer has not already been put in the WorkContext block
    // by an AndX command or a previous call to SrvCreateFile.
    //

    status = SrvVerifyUidAndTid(
                WorkContext,
                &session,
                &treeConnect,
                ShareTypeWild
                );

    if ( !NT_SUCCESS(status) ) {
        IF_DEBUG(SMB_ERRORS) {
            KdPrint(( "SrvNtCreateFile: Invalid UID or TID\n" ));
        }
        return status;
    }

    //
    // If the session has expired, return that info
    //
    if( session->IsSessionExpired )
    {
        return SESSION_EXPIRED_STATUS_CODE;
    }

    if ( RootDirectoryFid != 0 ) {

        rootDirRfcb = SrvVerifyFid(
                            WorkContext,
                            (USHORT)RootDirectoryFid,
                            FALSE,
                            NULL,  // don't serialize with raw write
                            &status
                            );

        if ( rootDirRfcb == SRV_INVALID_RFCB_POINTER ) {

            IF_DEBUG(ERRORS) {
                KdPrint(( "SrvNtCreateFile: Invalid Root Dir FID: 0x%lx\n",
                           RootDirectoryFid ));
            }

            return status;

        } else {

            //
            // Remove the redundant copy of the RFCB to prevent a redundant
            // dereference of this RFCB.
            //

            WorkContext->Rfcb = NULL;

        }

        rootDirLfcb = rootDirRfcb->Lfcb;

    }

    //
    // Here we begin share type specific processing.
    //

    shareType = treeConnect->Share->ShareType;

    //
    // If this operation may block, and we are running short of
    // free work items, fail this SMB with an out of resources error.
    // Note that a disk open will block if the file is currently oplocked.
    //

    if ( shareType == ShareTypeDisk && !WorkContext->BlockingOperation ) {

        if ( SrvReceiveBufferShortage( ) ) {

            if ( rootDirRfcb != NULL ) {
                SrvDereferenceRfcb( rootDirRfcb );
            }

            SrvStatistics.BlockingSmbsRejected++;

            return STATUS_INSUFF_SERVER_RESOURCES;

        } else {

            //
            // SrvBlockingOpsInProgress has already been incremented.
            // Flag this work item as a blocking operation.
            //

            WorkContext->BlockingOperation = TRUE;

        }

    }

    //
    // Assume we won't need a temporary open.
    //

    switch ( shareType ) {

    case ShareTypeDisk:
    case ShareTypePipe:

        //
        // Canonicalize the path name so that it conforms to NT
        // standards.
        //
        // *** Note that this operation allocates space for the name.
        //

        status = SrvCanonicalizePathName(
                     WorkContext,
                     treeConnect->Share,
                     RootDirectoryFid != 0 ? &rootDirLfcb->Mfcb->FileName : NULL,
                     FileName->Buffer,
                     ((PCHAR)FileName->Buffer +
                        FileName->Length - sizeof(WCHAR)),
                     TRUE,              // Strip trailing "."s
                     TRUE,              // Name is always unicode
                     &relativeName
                     );

        if ( !NT_SUCCESS( status ) ) {

            //
            // The path tried to do ..\ to get beyond the share it has
            // accessed.
            //

            IF_DEBUG(ERRORS) {
                KdPrint(( "SrvNtCreateFile: Invalid pathname: "
                           "%wZ\n", FileName ));
            }

            if ( rootDirRfcb != NULL ) {
                SrvDereferenceRfcb( rootDirRfcb );
            }
            return status;

        }

        //
        // Form the fully qualified name of the file.
        //
        // *** Note that this operation allocates space for the name.
        //     This space is deallocated after the DoXxxOpen routine
        //     returns.
        //

        if ( shareType == ShareTypeDisk ) {

            if ( RootDirectoryFid != 0 ) {
                SrvAllocateAndBuildPathName(
                    &rootDirLfcb->Mfcb->FileName,
                    &relativeName,
                    NULL,
                    &fullName
                    );
            } else {
                SrvAllocateAndBuildPathName(
                    &treeConnect->Share->DosPathName,
                    &relativeName,
                    NULL,
                    &fullName
                    );
            }

        } else {

            UNICODE_STRING pipePrefix;

            if( !WorkContext->Session->IsNullSession &&
                WorkContext->Session->IsLSNotified == FALSE ) {

                //
                // We have a pipe open request, not a NULL session, and
                //  we haven't gotten clearance from the license server yet.
                //  If this pipe requires clearance, get a license.
                //

                ULONG i;
                BOOLEAN matchFound = FALSE;

                ACQUIRE_LOCK_SHARED( &SrvConfigurationLock );

                for ( i = 0; SrvPipesNeedLicense[i] != NULL ; i++ ) {

                    if ( _wcsicmp(
                            SrvPipesNeedLicense[i],
                            relativeName.Buffer
                            ) == 0 ) {
                        matchFound = TRUE;
                        break;
                    }
                }

                RELEASE_LOCK( &SrvConfigurationLock );

                if( matchFound == TRUE ) {
                    status = SrvXsLSOperation( WorkContext->Session,
                                               XACTSRV_MESSAGE_LSREQUEST );

                    if( !NT_SUCCESS( status ) ) {
                        if( rootDirRfcb != NULL ) {
                            SrvDereferenceRfcb( rootDirRfcb );
                        }
                        return status;
                    }
                }
            }

            RtlInitUnicodeString( &pipePrefix, StrSlashPipeSlash );

            if( WorkContext->Endpoint->RemapPipeNames || treeConnect->RemapPipeNames ) {

                //
                // The RemapPipeNames flag is set, so remap the pipe name
                //  to "$$\<server>\<pipe name>".
                //
                // Note: this operation allocates space for pipeRelativeName.
                //

                status = RemapPipeName(
                            &WorkContext->Endpoint->TransportAddress,
                            treeConnect->RemapPipeNames ? &treeConnect->ServerName : NULL,
                            &relativeName,
                            &relativeNameAllocated
                         );

                if( !NT_SUCCESS( status ) ) {

                    if( rootDirRfcb != NULL ) {
                        SrvDereferenceRfcb( rootDirRfcb );
                    }

                    return status;
                }
            }
            SrvAllocateAndBuildPathName(
                &pipePrefix,
                &relativeName,
                NULL,
                &fullName
                );

        }

        if ( fullName.Buffer == NULL ) {

            //
            // Unable to allocate heap for the full name.
            //

            IF_DEBUG(ERRORS) {
                KdPrint(( "SrvNtCreateFile: Unable to allocate heap for "
                            "full path name\n" ));
            }

            if ( rootDirRfcb != NULL ) {
                SrvDereferenceRfcb( rootDirRfcb );
            }

            if( relativeNameAllocated ) {
                FREE_HEAP( relativeName.Buffer );
            }

            return STATUS_INSUFF_SERVER_RESOURCES;

        }

        //
        // Indicate that we must free the file name buffers on exit.
        //

        nameAllocated = TRUE;

        break;

    //
    //  Default case, illegal device type.  This should never happen.
    //

    default:

        // !!! Is this an appropriate error return code?  Probably no.
        return STATUS_INVALID_PARAMETER;

    }

    //
    // Determine whether or not the path name is case sensitive.
    //

    if ( (WorkContext->RequestHeader->Flags & SMB_FLAGS_CASE_INSENSITIVE) ||
          WorkContext->Session->UsingUppercasePaths )
    {

        attributes = OBJ_CASE_INSENSITIVE;
        caseInsensitive = TRUE;

    } else {
        attributes = 0L;
        caseInsensitive = FALSE;
    }

    if ( RootDirectoryFid != 0 ) {

        SrvInitializeObjectAttributes_U(
            &objectAttributes,
            &relativeName,
            attributes,
            rootDirLfcb->FileHandle,
            NULL
            );

    } else if ( WorkContext->TreeConnect->Share->ShareType == ShareTypePipe ) {
        SrvInitializeObjectAttributes_U(
            &objectAttributes,
            &relativeName,
            attributes,
            SrvNamedPipeHandle,
            NULL
            );
    } else {

        fileShare = treeConnect->Share;

        SrvInitializeObjectAttributes_U(
            &objectAttributes,
            &relativeName,
            attributes,
            NULL,
            NULL
            );
    }

    if ( SecurityDescriptorBuffer != NULL) {
        objectAttributes.SecurityDescriptor = SecurityDescriptorBuffer;
    }

    //
    // Always add read attributes since we need to query file info after
    // the open.
    //

    DesiredAccess |= FILE_READ_ATTRIBUTES;

    //
    // Interpret the io create flags
    //

    ioCreateFlags = IO_CHECK_CREATE_PARAMETERS | IO_FORCE_ACCESS_CHECK;

    if ( OptionFlags & NT_CREATE_OPEN_TARGET_DIR ) {
        ioCreateFlags |= IO_OPEN_TARGET_DIRECTORY;
    }

    //
    // Override the default server quality of service, with the QOS request
    // by the client.
    //

    objectAttributes.SecurityQualityOfService = QualityOfService;

    if ( WorkContext->ProcessingCount == 2 ) {

        HANDLE fileHandle;
        OBJECT_ATTRIBUTES objectAttributes;
        IO_STATUS_BLOCK ioStatusBlock;

        //
        // This is the second time through, so we must be in a blocking
        // thread.  Do a blocking open of the file to force an oplock
        // break.  Then close the handle and fall through to the normal
        // open path.
        //
        // We must do the blocking open without holding the MFCB
        // lock, because this lock can be acquired during oplock
        // break, resulting in deadlock.
        //

        SrvInitializeObjectAttributes_U(
            &objectAttributes,
            &relativeName,
            attributes,
            0,
            NULL
            );

        status = SrvIoCreateFile(
                     WorkContext,
                     &fileHandle,
                     GENERIC_READ,
                     &objectAttributes,
                     &ioStatusBlock,
                     NULL,
                     0,
                     FILE_SHARE_VALID_FLAGS,
                     FILE_OPEN,
                     0,
                     NULL,
                     0,
                     CreateFileTypeNone,
                     NULL,                    // ExtraCreateParameters
                     0,
                     WorkContext->TreeConnect->Share
                     );

        if ( NT_SUCCESS( status ) ) {
            SRVDBG_CLAIM_HANDLE( fileHandle, "FIL", 13, 0 );
            SRVDBG_RELEASE_HANDLE( fileHandle, "FIL", 18, 0 );
            SrvNtClose( fileHandle, TRUE );
        }
    }

    //
    // Scan the Master File Table to see if the named file is already
    // open.
    //

    mfcb = SrvFindMfcb( &fullName, caseInsensitive, &mfcbLock, &hashValue, WorkContext );

    if ( mfcb == NULL ) {
        //
        // There is no MFCB for this file.  Create one.
        //

        mfcb = SrvCreateMfcb( &fullName, WorkContext, hashValue );

        if ( mfcb == NULL ) {

            //
            // Failure to add open file instance to MFT.
            //

            if( mfcbLock ) {
                RELEASE_LOCK( mfcbLock );
            }

            IF_DEBUG(ERRORS) {
                KdPrint(( "SrvNtCreateFile: Unable to allocate MFCB\n" ));
            }

            if ( nameAllocated ) {
                FREE_HEAP( fullName.Buffer );
            }

            if( relativeNameAllocated ) {
                FREE_HEAP( relativeName.Buffer );
            }

            if ( rootDirRfcb != NULL ) {
                SrvDereferenceRfcb( rootDirRfcb );
            }

            return STATUS_INSUFF_SERVER_RESOURCES;
        }
    }


    //
    // Increment the MFCB reference count.  See the note at the beginning of this routine.
    //
    mfcb->BlockHeader.ReferenceCount++;
    UPDATE_REFERENCE_HISTORY( mfcb, FALSE );

    //
    // Grab the MFCB-based lock to serialize opens of the same file
    // and release the MFCB list lock.
    //

    nonpagedMfcb = mfcb->NonpagedMfcb;
    RELEASE_LOCK( mfcbLock );
    ACQUIRE_LOCK( &nonpagedMfcb->Lock );

    openRetries = SrvSharingViolationRetryCount;

start_retry:

    //
    // If the client asked for FILE_NO_INTERMEDIATE_BUFFERING, turn that
    // flag off and turn FILE_WRITE_THROUGH on instead.  We cannot give
    // the client the true meaning of NO_INTERMEDIATE_BUFFERING, but we
    // can at least get the data out to disk right away.
    //

    if ( (CreateOptions & FILE_NO_INTERMEDIATE_BUFFERING) != 0 ) {
        CreateOptions |= FILE_WRITE_THROUGH;
        CreateOptions &= ~FILE_NO_INTERMEDIATE_BUFFERING;
    }

    //
    // Check to see if there is a cached handle for the file.
    //

    if ( (CreateDisposition == FILE_OPEN) ||
         (CreateDisposition == FILE_CREATE) ||
         (CreateDisposition == FILE_OPEN_IF) ) {

        IF_DEBUG(FILE_CACHE) {
            KdPrint(( "SrvNtCreateFile: checking for cached rfcb for %wZ\n", &fullName ));
        }
        if ( SrvFindCachedRfcb(
                WorkContext,
                mfcb,
                DesiredAccess,
                ShareAccess,
                CreateDisposition,
                CreateOptions,
                RequestedOplockType,
                &status ) ) {

            IF_DEBUG(FILE_CACHE) {
                KdPrint(( "SrvNtCreateFile: FindCachedRfcb = TRUE, status = %x, rfcb = %p\n",
                            status, WorkContext->Rfcb ));
            }

            RELEASE_LOCK( &nonpagedMfcb->Lock );

            //
            // We incremented the MFCB reference count in anticipation of
            // the possibility that an LFCB might be queued to the MFCB.
            // This path precludes that possibility.
            //

            SrvDereferenceMfcb( mfcb );

            //
            // This second dereference is for the reference done by
            // SrvFindMfcb/SrvCreateMfcb.
            //

            SrvDereferenceMfcb( mfcb );

            if ( nameAllocated ) {
                FREE_HEAP( fullName.Buffer );
            }

            if( relativeNameAllocated ) {
                FREE_HEAP( relativeName.Buffer );
            }

            if ( rootDirRfcb != NULL ) {
                SrvDereferenceRfcb( rootDirRfcb );
            }

            return status;
        }

        IF_DEBUG(FILE_CACHE) {
            KdPrint(( "SrvNtCreateFile: FindCachedRfcb = FALSE; do it the slow way\n" ));
        }
    }

    //
    // Call SrvIoCreateFile to create or open the file.  (We call
    // SrvIoCreateFile, rather than NtOpenFile, in order to get user-mode
    // access checking.)
    //

    IF_SMB_DEBUG(OPEN_CLOSE2) {
        KdPrint(( "SrvCreateFile: Opening file %wZ\n", &fullName ));
    }

    CreateOptions |= FILE_COMPLETE_IF_OPLOCKED;

    INCREMENT_DEBUG_STAT( SrvDbgStatistics.TotalOpenAttempts );

    //
    // Ensure the EaBuffer is correctly formatted.  Since we are a kernel mode
    //  component, the Io subsystem does not check it for us.
    //
    if( ARGUMENT_PRESENT( EaBuffer ) ) {
        status = IoCheckEaBufferValidity( (PFILE_FULL_EA_INFORMATION)EaBuffer, EaLength, EaErrorOffset );
    } else {
        status = STATUS_SUCCESS;
    }

    if( NT_SUCCESS( status ) ) {

        status = SrvIoCreateFile(
                     WorkContext,
                     &fileHandle,
                     DesiredAccess,
                     &objectAttributes,
                     &ioStatusBlock,
                     &AllocationSize,
                     FileAttributes,
                     ShareAccess,
                     CreateDisposition,
                     CreateOptions,
                     EaBuffer,
                     EaLength,
                     CreateFileTypeNone,
                     NULL,                    // ExtraCreateParameters
                     ioCreateFlags,
                     fileShare
                     );
    }

    //
    // If we got sharing violation and this is a disk file.
    // If this is the first open attempt, setup for a blocking open attempt.
    //   If the file is batch oplocked, the non-blocking open would fail,
    //   and the oplock will not break.
    //
    // If this is the second open attempt, we can assume that we are in
    //   the blocking thread.  Retry the open.
    //

    if ( status == STATUS_SHARING_VIOLATION &&
         WorkContext->TreeConnect->Share->ShareType == ShareTypeDisk ) {

        if ( WorkContext->ProcessingCount == 1 ) {

            WorkContext->Parameters2.Open.TemporaryOpen = TRUE;

        } else if ( (WorkContext->ProcessingCount == 2) &&
                    (openRetries-- > 0) ) {

            //
            // We are in the blocking thread.
            //

            //
            // Release the mfcb lock so that a close might slip through.
            //

            RELEASE_LOCK( &nonpagedMfcb->Lock );

            (VOID) KeDelayExecutionThread(
                                    KernelMode,
                                    FALSE,
                                    &SrvSharingViolationDelay
                                    );

            ACQUIRE_LOCK( &nonpagedMfcb->Lock );
            goto start_retry;
        }
    }

    //
    // Save the open information where the SMB processor can find it.
    //

    WorkContext->Irp->IoStatus.Information = ioStatusBlock.Information;

    //
    // If the user didn't have this permission, update the statistics
    // database.
    //

    if ( status == STATUS_ACCESS_DENIED ) {
        SrvStatistics.AccessPermissionErrors++;
    }

    if ( !NT_SUCCESS(status) ) {

        //
        // The open failed.
        //

        IF_DEBUG(ERRORS) {
            KdPrint(( "SrvNtCreateFile: SrvIoCreateFile failed, file = %wZ, "
                        "status = %X, Info = 0x%p\n",
                        objectAttributes.ObjectName,
                        status, (PVOID)ioStatusBlock.Information ));
        }

        //
        // Set the error offset if needed.
        //

        if ( ARGUMENT_PRESENT(EaErrorOffset) &&
                                status == STATUS_INVALID_EA_NAME ) {
            *EaErrorOffset = (ULONG)ioStatusBlock.Information;
            ioStatusBlock.Information = 0;
        }

        //
        // Cleanup allocated memory and return with a failure status.
        //

        RELEASE_LOCK( &nonpagedMfcb->Lock );

        //
        // We incremented the MFCB reference count in anticipation of
        // the possibility that an LFCB might be queued to the MFCB.
        // This error path precludes that possibility.
        //

        SrvDereferenceMfcb( mfcb );

        //
        // This second dereference is for the reference done by
        // SrvFindMfcb/SrvCreateMfcb.
        //

        SrvDereferenceMfcb( mfcb );

        if ( nameAllocated ) {
            FREE_HEAP( fullName.Buffer );
        }

        if( relativeNameAllocated ) {
            FREE_HEAP( relativeName.Buffer );
        }

        if ( rootDirRfcb != NULL ) {
            SrvDereferenceRfcb( rootDirRfcb );
        }
        return status;

    }

    SRVDBG_CLAIM_HANDLE( fileHandle, "FIL", 14, 0 );

    //
    // The open was successful.  Attempt to allocate structures to
    // represent the open.  If any errors occur, CompleteOpen does full
    // cleanup, including closing the file.
    //

    IF_SMB_DEBUG(OPEN_CLOSE2) {
        KdPrint(( "SrvNtCreateFile: Open of %wZ succeeded, file handle: 0x%p\n", &fullName, fileHandle ));
    }

    completionStatus = CompleteOpen(
                           &rfcb,
                           mfcb,
                           WorkContext,
                           NULL,
                           fileHandle,
                           NULL,
                           ShareAccess,
                           CreateOptions,
                           FALSE,
                           FALSE,
                           &lfcbAddedToMfcbList
                           );

    //
    // Remember the "interesting" status code.  If CompleteOpen() succeeds
    // return the open status.  If it fails, it will clean up the open
    // file, and we return a failure status.
    //

    if ( !NT_SUCCESS( completionStatus ) ) {
        status = completionStatus;
    }

    //
    // Release the Open serialization lock and dereference the MFCB.
    //

    RELEASE_LOCK( &nonpagedMfcb->Lock );

    //
    // If CompleteOpen didn't queue an LFCB to the MFCB, release the
    // extra reference that we added.
    //

    if ( !lfcbAddedToMfcbList ) {
        SrvDereferenceMfcb( mfcb );
    }

    SrvDereferenceMfcb( mfcb );

    //
    // Deallocate the full path name buffer.
    //

    if ( nameAllocated ) {
        FREE_HEAP( fullName.Buffer );
    }

    //
    // Deallocate the relative path name buffer.
    //
    if( relativeNameAllocated ) {
        FREE_HEAP( relativeName.Buffer );
    }

    //
    // Release our reference to the root directory RFCB
    //

    if ( rootDirRfcb != NULL ) {
        SrvDereferenceRfcb( rootDirRfcb );
    }

    //
    // If this is a temporary file, don't attempt to cache it.
    //

    if ( rfcb != NULL && (FileAttributes & FILE_ATTRIBUTE_TEMPORARY) != 0 ) {

        rfcb->IsCacheable = FALSE;
    }

    //
    // Update the statistics database if the open was successful.
    //

    if ( NT_SUCCESS(status) ) {
        SrvStatistics.TotalFilesOpened++;
    }

    //
    // Make a pointer to the RFCB accessible to the caller.
    //

    WorkContext->Parameters2.Open.Rfcb = rfcb;

    //
    // If there is an oplock break in progress, wait for the oplock
    // break to complete.
    //

    if ( status == STATUS_OPLOCK_BREAK_IN_PROGRESS ) {

        NTSTATUS startStatus;

        //
        // Save the Information from the open, so it doesn't
        //  get lost when we re-use the WorkContext->Irp for the
        //  oplock processing.
        //
        WorkContext->Parameters2.Open.IosbInformation = WorkContext->Irp->IoStatus.Information;

        startStatus = SrvStartWaitForOplockBreak(
                        WorkContext,
                        RestartRoutine,
                        0,
                        rfcb->Lfcb->FileObject
                        );

        if (!NT_SUCCESS( startStatus ) ) {

            //
            // The file is oplocked, and we cannot wait for the oplock
            // break to complete.  Just close the file, and return the
            // error.
            //

            SrvCloseRfcb( rfcb );
            status = startStatus;

        }

    }

    return status;

} // SrvNtCreateFile

BOOLEAN
SetDefaultPipeMode (
    IN HANDLE FileHandle
    )

/*++

Routine Description:

    This function set the read mode of a newly opened named pipe.  If
    the pipe type is message mode, the read mode is set the message
    mode.

Arguments:

    FileHandle - The client side handle to the named pipe.

Return Value:

    FALSE - Pipe mode is byte mode.
    TRUE  - Pipe mode has been set to message mode.

--*/

{
    NTSTATUS status;
    IO_STATUS_BLOCK ioStatusBlock;
    FILE_PIPE_INFORMATION pipeInformation;
    FILE_PIPE_LOCAL_INFORMATION pipeLocalInformation;

    PAGED_CODE( );

    status = NtQueryInformationFile(
                 FileHandle,
                 &ioStatusBlock,
                 (PVOID)&pipeLocalInformation,
                 sizeof(pipeLocalInformation),
                 FilePipeLocalInformation
                 );

    if ( !NT_SUCCESS( status )) {
        return FALSE;
    }

    if ( pipeLocalInformation.NamedPipeType != FILE_PIPE_MESSAGE_TYPE ) {
        return FALSE;
    }

    pipeInformation.ReadMode = FILE_PIPE_MESSAGE_MODE;
    pipeInformation.CompletionMode = FILE_PIPE_QUEUE_OPERATION;

    //
    // ???: is it ok to ignore the return status for this call?
    //

    NtSetInformationFile(
        FileHandle,
        &ioStatusBlock,
        (PVOID)&pipeInformation,
        sizeof(pipeInformation),
        FilePipeInformation
        );

    return TRUE;

}  // SetDefaultPipeMode

BOOLEAN
SrvFailMdlReadDev (
    IN PFILE_OBJECT FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN ULONG Length,
    IN ULONG LockKey,
    OUT PMDL *MdlChain,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject
    )
{
    return FALSE;
}

BOOLEAN
SrvFailPrepareMdlWriteDev (
    IN PFILE_OBJECT FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN ULONG Length,
    IN ULONG LockKey,
    OUT PMDL *MdlChain,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject
    )
{
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\srv\oplock.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    oplock.c

Abstract:

    This module contains the routines used to support oppurtunistic
    locking in the server.

Details:

    Oplock activity is controlled by information contained in the
    connection block.  In particular oplocks must be synchronized
    with the read block raw SMB, since the oplock request SMB is
    indistinguishable from raw data.

    RawReadsInProgress -
        Is incremented when a read raw request is accepted.  It is
        decremented after the raw data has been sent.  An oplock break
        request is never sent when RawReadsInProgress is nonzero.

    OplockBreaksInProgess -
        Is incremented when the server determines that it must send
        an oplock break SMB.  It is decremented when the oplock break
        response arrives.

    OplockBreakRequestsPending -
        Is the number of oplock break requests that could not be sent
        due the lack of a WCBs.  It is incremented when WCB allocation
        fails.  It is decremented when the WCB is successfully allocated
        and the oplock break request is sent.

    OplockWorkItemList -
        Is a list of oplock context blocks for oplock break that could
        not be sent due to (1) a read raw in progress or (2) a resource
        shortage.

    It is possible for an oplock break request from the server and a
    read raw request from the client to "cross on the wire".  In this
    case the client is expected to examine the raw data.  If the data
    may be an oplock break request, the client must break the oplock
    then reissue the read request.

    If the server receives the read raw request after having sent an
    oplock break request (but before the reply arrives), it must return
    zero bytes read, since the oplock break request may have completed
    the raw request, and the client is unprepared to receives a larger
    than negotiated size response.

Author:

    Manny Weiser (mannyw)  16-Apr-1991

Revision History:

--*/

#include "precomp.h"
#include "oplock.tmh"
#pragma hdrstop

#define BugCheckFileId SRV_FILE_OPLOCK

//
// Local definitions
//

PWORK_CONTEXT
GenerateOplockBreakRequest(
    IN PRFCB Rfcb
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text( PAGE, SrvFillOplockBreakRequest )
#pragma alloc_text( PAGE, SrvRestartOplockBreakSend )
#pragma alloc_text( PAGE, SrvAllocateWaitForOplockBreak )
#pragma alloc_text( PAGE, SrvDereferenceWaitForOplockBreak )
#pragma alloc_text( PAGE, SrvFreeWaitForOplockBreak )
#pragma alloc_text( PAGE, SrvGetOplockBreakTimeout )
#pragma alloc_text( PAGE, SrvRequestOplock )
#pragma alloc_text( PAGE, SrvStartWaitForOplockBreak )
#pragma alloc_text( PAGE, SrvWaitForOplockBreak )
#pragma alloc_text( PAGE, SrvCheckOplockWaitState )
#pragma alloc_text( PAGE8FIL, SrvOplockBreakNotification )
#pragma alloc_text( PAGE8FIL, GenerateOplockBreakRequest )
#pragma alloc_text( PAGE8FIL, SrvSendOplockRequest )
#pragma alloc_text( PAGE8FIL, SrvCheckDeferredOpenOplockBreak )
#endif
#if 0
#pragma alloc_text( PAGECONN, SrvSendDelayedOplockBreak )
#endif

#if    SRVDBG

//
// Unfortunately, when KdPrint is given a %wZ conversion, it calls a
//    pageable Rtl routine to convert.  This is bad if we're calling
//    KdPrint from DPC level, as we are below.  So we've introduced
//    SrvPrintwZ() here to get around the problem.  This is only for
//    debugging anyway....
//

#ifdef ALLOC_PRAGMA
#pragma alloc_text( PAGE8FIL, SrvCheckDeferredOpenOplockBreak )
#endif

#define SrvPrintwZ( x ) if( KeGetCurrentIrql() == 0 ){ DbgPrint( "%wZ", x ); } else { DbgPrint( "??" ); }

#else

#define    SrvPrintwZ( x )

#endif

VOID
DereferenceRfcbInternal (
    IN PRFCB Rfcb,
    IN KIRQL OldIrql
    );


VOID SRVFASTCALL
SrvOplockBreakNotification(
    IN PWORK_CONTEXT WorkContext
    )

/*++

Routine Description:

    This function receives the oplock break notification from a file
    system.  It must send the oplock break SMB to the oplock owner.

Arguments:

    OplockContext - A pointer to the oplock context for this oplock break.
Return Value:

--*/

{
    ULONG information;
    NTSTATUS status;
    PCONNECTION connection;
    KIRQL oldIrql;
    PRFCB Rfcb = (PRFCB)WorkContext;
    PPAGED_RFCB pagedRfcb = Rfcb->PagedRfcb;

    UNLOCKABLE_CODE( 8FIL );

    //
    // Check the status of the oplock request.
    //

    UpdateRfcbHistory( Rfcb, 'tnpo' );

    status = Rfcb->Irp->IoStatus.Status;

    information = (ULONG)Rfcb->Irp->IoStatus.Information;
    connection = Rfcb->Connection;

    IF_DEBUG( OPLOCK ) {

        KdPrint(( "SrvOplockBreakNotification: Received notification for " ));
        SrvPrintwZ( &Rfcb->Mfcb->FileName );
        KdPrint(( "\n" ));
        KdPrint(( "  status 0x%x, information %X, connection %p\n",
                     status, information, connection ));
        KdPrint(( "  Rfcb->OplockState = %X\n", Rfcb->OplockState ));
    }

    //
    // Check the oplock break request.
    //
    ACQUIRE_SPIN_LOCK( &connection->SpinLock, &oldIrql );

    //
    // Mark this rfcb as not cacheable since the oplock has been broken.
    // This is to close a timing window where the client closes the file
    // just as we are preparing to send an oplock break.  We won't send the
    // break because the rfcb is closing and we will cache the file if
    // it was an opbatch.  This results in the oplock never being broken.
    //

    Rfcb->IsCacheable = FALSE;

    if ( !NT_SUCCESS(status) ||
         Rfcb->OplockState == OplockStateNone ||
         ((GET_BLOCK_STATE( Rfcb ) == BlockStateClosing) &&
          (Rfcb->OplockState != OplockStateOwnServerBatch)) ) {

        IF_DEBUG( SMB_ERRORS ) {
            if( status == STATUS_INVALID_OPLOCK_PROTOCOL ) {
                if ( GET_BLOCK_STATE( Rfcb ) != BlockStateClosing ) {
                    KdPrint(( "BUG: SrvOplockBreakNotification: " ));
                    SrvPrintwZ( &Rfcb->Mfcb->FileName );
                    KdPrint(( " is not closing.\n" ));
                }
            }
        }

        //
        // One of the following is true:
        //  (1) The oplock request failed.
        //  (2) Our oplock break to none has succeeded.
        //  (3) We are in the process of closing the file.
        //
        // Note that if a level I oplock request fails when a retry at
        // level II is desired, SrvFsdOplockCompletionRoutine handles
        // setting the retry event and we do not get here at all.
        //

        IF_DEBUG( OPLOCK ) {
            KdPrint(( "SrvOplockBreakNotification: Breaking to none\n"));
        }

        UpdateRfcbHistory( Rfcb, 'nnso' );

        Rfcb->OplockState = OplockStateNone;

        if( Rfcb->CachedOpen ) {
            //
            // SrvCloseCachedRfcb releases the spinlock
            //
            SrvCloseCachedRfcb( Rfcb, oldIrql );

        } else {

            RELEASE_SPIN_LOCK( &connection->SpinLock, oldIrql );
        }

        //
        // Free the IRP we used to the oplock request.
        //

        UpdateRfcbHistory( Rfcb, 'prif' );

        IoFreeIrp( Rfcb->Irp );
        Rfcb->Irp = NULL;

        //
        // Dereference the rfcb.
        //

        SrvDereferenceRfcb( Rfcb );

    } else if ( Rfcb->OplockState == OplockStateOwnServerBatch ) {

        //
        // We are losing a server-initiated batch oplock.  Don't send
        // anything to the client.  If the client still has the file
        // open, just release the oplock.  If the client has closed the
        // file, we have to close the file now.
        //

        IF_DEBUG(FILE_CACHE) {
            KdPrint(( "SrvOplockBreakNotification: server oplock broken for %p, file %wZ\n", Rfcb, &Rfcb->Mfcb->FileName ));
        }

        if ( !Rfcb->CachedOpen ) {

            IF_DEBUG(FILE_CACHE) {
                KdPrint(( "SrvOplockBreakNotification: ack close pending for " ));
                SrvPrintwZ( &Rfcb->Mfcb->FileName );
                KdPrint(( "\n" ));
            }
            UpdateRfcbHistory( Rfcb, 'pcao' );

            Rfcb->OplockState = OplockStateNone;
            RELEASE_SPIN_LOCK( &connection->SpinLock, oldIrql );

            Rfcb->RetryOplockRequest = NULL;
            SrvBuildIoControlRequest(
                Rfcb->Irp,
                Rfcb->Lfcb->FileObject,
                Rfcb,
                IRP_MJ_FILE_SYSTEM_CONTROL,
                FSCTL_OPLOCK_BREAK_ACK_NO_2,
                NULL,                        // Main buffer
                0,                           // Input buffer length
                NULL,                        // Auxiliary buffer
                0,                           // Output buffer length
                NULL,                        // MDL
                SrvFsdOplockCompletionRoutine
                );

            IoCallDriver( Rfcb->Lfcb->DeviceObject, Rfcb->Irp );

        } else {

            //
            // SrvCloseCachedRfcb releases the spin lock.
            //

            IF_DEBUG(FILE_CACHE) {
                KdPrint(( "SrvOplockBreakNotification: closing cached rfcb for "));
                SrvPrintwZ( &Rfcb->Mfcb->FileName );
                KdPrint(( "\n" ));
            }
            UpdateRfcbHistory( Rfcb, '$bpo' );

            SrvCloseCachedRfcb( Rfcb, oldIrql );
            SrvDereferenceRfcb( Rfcb );

        }

    } else {

        RELEASE_SPIN_LOCK( &connection->SpinLock, oldIrql );

        //
        // We have an oplock to break.
        //

        IF_DEBUG( OPLOCK ) {
            if (information == FILE_OPLOCK_BROKEN_TO_LEVEL_2) {
                KdPrint(( "SrvOplockBreakNotification: Breaking to level 2\n"));
            } else if (information == FILE_OPLOCK_BROKEN_TO_NONE) {
                KdPrint(( "SrvOplockBreakNotification: Breaking to level none\n"));
            } else {
                INTERNAL_ERROR(
                    ERROR_LEVEL_UNEXPECTED,
                    "SrvOplockBreakNotification:  Unknown oplock type %d",
                    information,
                    NULL
                    );

            }
        }

        //
        // Save the new oplock level, in case this oplock break is deferrred.
        //

        if ( information == FILE_OPLOCK_BROKEN_TO_LEVEL_2 &&
                CLIENT_CAPABLE_OF( LEVEL_II_OPLOCKS, Rfcb->Connection ) ) {

            Rfcb->NewOplockLevel = OPLOCK_BROKEN_TO_II;
        } else {

            Rfcb->NewOplockLevel = OPLOCK_BROKEN_TO_NONE;
        }

        //
        // Do not send the oplock break notification if a read raw is
        // in progress (and the client is expecting raw data on the VC).
        //
        // The oplock break notification will be sent after the raw
        // data.
        //

        ACQUIRE_SPIN_LOCK( connection->EndpointSpinLock, &oldIrql );

        //
        // Do not send the oplock break if we have not yet sent the
        // open response (i.e. the client does not yet know that it
        // owns the oplock).
        //

        if ( !Rfcb->OpenResponseSent ) {

            Rfcb->DeferredOplockBreak = TRUE;
            RELEASE_SPIN_LOCK( connection->EndpointSpinLock, oldIrql );

        } else {

            //
            // EndpointSpinLock will be released in this routine.
            //

            SrvSendOplockRequest( connection, Rfcb, oldIrql );
        }
    }

    return;

} // SrvOplockBreakNotification


PWORK_CONTEXT
GenerateOplockBreakRequest(
    IN PRFCB Rfcb
    )

/*++

Routine Description:

    This function creates an oplock break request SMB.

Arguments:

    Rfcb - A pointer to the RFCB.  Rfcb->NewOplockLevel contains
            the oplock level to break to.

Return Value:

    None.

--*/

{
    PWORK_CONTEXT workContext;
    PCONNECTION connection = Rfcb->Connection;
    BOOLEAN success;
    KIRQL oldIrql;

    UNLOCKABLE_CODE( 8FIL );

    //
    // Attempt to allocate a work context block for the oplock break.
    //

    ALLOCATE_WORK_CONTEXT( connection->CurrentWorkQueue, &workContext );

    if ( workContext == NULL ) {

        INTERNAL_ERROR(
            ERROR_LEVEL_EXPECTED,
            "GenerateOplockBreakRequest: no receive work items available",
            NULL,
            NULL
            );

        //
        // If the rfcb is closing, forget about the oplock break.
        // Acquire the lock that guards the RFCB's state field.
        //

        if ( GET_BLOCK_STATE( Rfcb ) == BlockStateClosing ) {
            ACQUIRE_SPIN_LOCK( connection->EndpointSpinLock, &oldIrql );
            connection->OplockBreaksInProgress--;
            RELEASE_SPIN_LOCK( connection->EndpointSpinLock, oldIrql );
            SrvDereferenceRfcb( Rfcb );
            return NULL;
        }

        //
        // Mark this connection as waiting to send an oplock break.
        //

        success = SrvAddToNeedResourceQueue(
                    connection,
                    OplockSendPending,
                    Rfcb
                    );

        if ( !success ) {

            //
            // Failed to queue the RFCB, so the connection must be going
            // away.  Simply dereference the RFCB and forget about the
            // oplock break.
            //

            SrvDereferenceRfcb( Rfcb );

        }

        return NULL;

    }

    //
    // If the rfcb is closing, forget about the oplock break.
    // Acquire the lock that guards the RFCB's state field.
    //

    ACQUIRE_SPIN_LOCK( connection->EndpointSpinLock, &oldIrql );

    if ( GET_BLOCK_STATE( Rfcb ) == BlockStateClosing ) {
        connection->OplockBreaksInProgress--;
        RELEASE_SPIN_LOCK( connection->EndpointSpinLock, oldIrql );
        SrvDereferenceRfcb( Rfcb );
        workContext->BlockHeader.ReferenceCount = 0;
        RETURN_FREE_WORKITEM( workContext );
        return NULL;
    }

    //
    // Put the work item on the in-progress list.
    //

    SrvInsertTailList(
        &connection->InProgressWorkItemList,
        &workContext->InProgressListEntry
        );
    connection->InProgressWorkContextCount++;

    RELEASE_SPIN_LOCK( connection->EndpointSpinLock, oldIrql );

    //
    // Return a pointer to the work context block to the caller.
    //

    return workContext;

} // GenerateOplockBreakRequest


VOID
SrvFillOplockBreakRequest (
    IN PWORK_CONTEXT WorkContext,
    IN PRFCB Rfcb
    )

/*++

Routine Description:

    This function fills the request buffer of a work context block with
    an oplock break request for the file specified by the RFCB.

Arguments:

    WorkContext - The work context block to fill

    Rfcb - The file whose oplock is being broken. Rfcb->NewOplockLevel contains
           the level to break to.

Return Value:

    None.

--*/

{
    PNT_SMB_HEADER requestHeader;
    PREQ_LOCKING_ANDX requestParameters;
    ULONG sendLength;

    PAGED_CODE( );

    requestHeader = (PNT_SMB_HEADER)WorkContext->RequestBuffer->Buffer;
    requestParameters = (PREQ_LOCKING_ANDX)(requestHeader + 1);

    //
    // Fill in the SMB header.
    // Zero the unused part of the header for safety.
    //

    RtlZeroMemory(
        (PVOID)&requestHeader->Status,
        FIELD_OFFSET(SMB_HEADER, Mid) - FIELD_OFFSET(NT_SMB_HEADER, Status)
        );

    *(PULONG)requestHeader->Protocol = SMB_HEADER_PROTOCOL;
    requestHeader->Command = SMB_COM_LOCKING_ANDX;

    SmbPutAlignedUshort( &requestHeader->Tid, Rfcb->Tid );
    SmbPutAlignedUshort( &requestHeader->Mid, 0xFFFF );
    SmbPutAlignedUshort( &requestHeader->Pid, 0xFFFF );

    //
    // Fill in the SMB parameters.
    //

    requestParameters->WordCount = 8;
    requestParameters->AndXCommand = 0xFF;
    requestParameters->AndXReserved = 0;
    SmbPutUshort( &requestParameters->AndXOffset, 0 );
    SmbPutUshort( &requestParameters->Fid, Rfcb->Fid );
    requestParameters->LockType = LOCKING_ANDX_OPLOCK_RELEASE;
    requestParameters->OplockLevel = Rfcb->NewOplockLevel;
    SmbPutUlong ( &requestParameters->Timeout, 0 );
    SmbPutUshort( &requestParameters->NumberOfUnlocks, 0 );
    SmbPutUshort( &requestParameters->NumberOfLocks, 0 );
    SmbPutUshort( &requestParameters->ByteCount, 0 );

    sendLength = LOCK_BROKEN_SIZE;
    WorkContext->RequestBuffer->DataLength = sendLength;

    return;

} // SrvFillOplockBreakRequest

VOID SRVFASTCALL
SrvRestartOplockBreakSend(
    IN PWORK_CONTEXT WorkContext
    )
/*++

Routine Description:

    This routine is used to send the break request smb during servicing
    of the need resource queue if SrvFsdServiceNeedResourceQueue is called
    at Dpc.

Arguments:

    WorkContext - A pointer to the work context block.

Return Value:

    None.

--*/

{

    //
    // The rfcb is being referenced by the work item.
    //

    PRFCB rfcb = WorkContext->Rfcb;
    PPAGED_RFCB pagedRfcb = rfcb->PagedRfcb;

    PAGED_CODE( );

    IF_DEBUG(OPLOCK) {
        KdPrint(("SrvRestartOplockBreakSend entered.\n"));
    }

    pagedRfcb->OplockBreakTimeoutTime =
                    SrvGetOplockBreakTimeout( WorkContext );

    WorkContext->ResponseHeader =
                        WorkContext->ResponseBuffer->Buffer;

    //
    // Generate the oplock break request SMB.
    //

    SrvFillOplockBreakRequest( WorkContext, rfcb );

    //
    // If this is a break from level 2 to none, send the
    // oplock break but don't queue this.  No response from the
    // client is expected.
    //

    if ( rfcb->NewOplockLevel == OPLOCK_BROKEN_TO_NONE &&
         rfcb->OplockState == OplockStateOwnLevelII ) {

        IF_DEBUG(OPLOCK) {
            KdPrint(("SrvRestartOplockBreakSend: Oplock break from "
                     " II to none sent.\n"));
        }

        rfcb->OplockState = OplockStateNone;

    } else {

        //
        // Reference the RFCB so it cannot be freed while it is on
        // the list.
        //

        SrvReferenceRfcb( rfcb );

        //
        // Insert the RFCB on the list of oplock breaks in progress.
        //

        ACQUIRE_LOCK( &SrvOplockBreakListLock );

        //
        // Check if the rfcb is closing.
        //

        if ( GET_BLOCK_STATE( rfcb ) == BlockStateClosing ) {

            //
            // The file is closing, forget about this break.
            // Cleanup and exit.
            //

            RELEASE_LOCK( &SrvOplockBreakListLock );

            IF_DEBUG(OPLOCK) {
                KdPrint(("SrvRestartOplockBreakSend: Rfcb %p closing.\n",
                        rfcb));
            }

            ExInterlockedAddUlong(
                &WorkContext->Connection->OplockBreaksInProgress,
                (ULONG)-1,
                WorkContext->Connection->EndpointSpinLock
                );


            //
            // Remove the queue reference.
            //

            SrvDereferenceRfcb( rfcb );

            //
            // Remove the pointer reference here since we know we are
            // not in the fsd.  The rfcb may be cleaned up safely here.
            //

            SrvDereferenceRfcb( rfcb );
            WorkContext->Rfcb = NULL;

            SrvRestartFsdComplete( WorkContext );
            return;
        }

        SrvInsertTailList( &SrvOplockBreaksInProgressList, &rfcb->ListEntry );

        rfcb->OnOplockBreaksInProgressList = TRUE;
        RELEASE_LOCK( &SrvOplockBreakListLock );

        IF_DEBUG(OPLOCK) {
            KdPrint(("SrvRestartOplockBreakSend: Oplock sent.\n"));
        }

    }

    //
    // Since this is an out-of-order transmission to the client, we do not
    //  stamp a security signatue on it.
    //
    WorkContext->NoResponseSmbSecuritySignature = TRUE;

    //
    // Update statistics for the broken oplock.
    //

    INCREMENT_DEBUG_STAT( SrvDbgStatistics.TotalOplocksBroken );

    SRV_START_SEND_2(
        WorkContext,
        (rfcb->OplockState == OplockStateNone) ?
                            SrvFsdRestartSendOplockIItoNone :
                            SrvFsdRestartSmbAtSendCompletion,
        NULL,
        NULL
        );


} // SrvRestartOplockBreakSend

VOID
SrvAllocateWaitForOplockBreak (
    OUT PWAIT_FOR_OPLOCK_BREAK *WaitForOplockBreak
    )

/*++

Routine Description:

    This routine allocates an wait for oplock break item.  It also
    allocates extra space for a kernel timer and a kernel DPC object.

Arguments:

    WaitForOplockBreak - Returns a pointer to the wait for oplock break
        item, or NULL if no space was available.  The oplock context
        block has a pointer to the IRP.

Return Value:

    None.

--*/

{
    PAGED_CODE( );

    //
    // Attempt to allocate the memory.
    //

    *WaitForOplockBreak = (PWAIT_FOR_OPLOCK_BREAK)ALLOCATE_NONPAGED_POOL(
                                sizeof(WAIT_FOR_OPLOCK_BREAK),
                                BlockTypeWaitForOplockBreak
                                );

    if ( *WaitForOplockBreak == NULL ) {

        INTERNAL_ERROR(
            ERROR_LEVEL_EXPECTED,
            "SrvAllocateWaitForOplockBreak: Unable to allocate %d bytes "
                "from paged pool.",
            sizeof(WAIT_FOR_OPLOCK_BREAK),
            NULL
            );

        *WaitForOplockBreak = NULL;
        return;

    }

    //
    // Zero the item.
    //

    RtlZeroMemory( (PVOID)*WaitForOplockBreak, sizeof(WAIT_FOR_OPLOCK_BREAK) );

    //
    // Initialize the header
    //

    SET_BLOCK_TYPE_STATE_SIZE( *WaitForOplockBreak,
                               BlockTypeWaitForOplockBreak,
                               BlockStateActive,
                               sizeof( WAIT_FOR_OPLOCK_BREAK ));

    //
    // Set the reference count to 2 to account for the workcontext
    // and the oplock wait for oplock break list reference to the structure.
    //

    (*WaitForOplockBreak)->BlockHeader.ReferenceCount = 2;

    INITIALIZE_REFERENCE_HISTORY( *WaitForOplockBreak );

    //
    // Return a pointer to the wait for oplock break item
    //

    INCREMENT_DEBUG_STAT( SrvDbgStatistics.WaitForOplockBreakInfo.Allocations );

    return;

} // SrvAllocateWaitForOplockBreak


VOID
SrvDereferenceWaitForOplockBreak (
    IN PWAIT_FOR_OPLOCK_BREAK WaitForOplockBreak
    )

/*++

Routine Description:

    This routine dereferences an wait for oplock break item.

Arguments:

    WaitForOplockBreak - A pointer to the item to dereference.

Return Value:

    None.

--*/

{
    ULONG oldCount;

    PAGED_CODE( );

    ASSERT( GET_BLOCK_TYPE( WaitForOplockBreak ) == BlockTypeWaitForOplockBreak );
    ASSERT( (LONG)WaitForOplockBreak->BlockHeader.ReferenceCount > 0 );
    UPDATE_REFERENCE_HISTORY( WaitForOplockBreak, TRUE );

    oldCount = ExInterlockedAddUlong(
                   &WaitForOplockBreak->BlockHeader.ReferenceCount,
                   (ULONG)-1,
                   &GLOBAL_SPIN_LOCK(Fsd)
                   );

    IF_DEBUG(REFCNT) {
        KdPrint(( "Dereferencing WaitForOplockBreak %p; old refcnt %lx\n",
                  WaitForOplockBreak, oldCount ));
    }

    if ( oldCount == 1 ) {

        //
        // The new reference count is 0.  Delete the block.
        //

        SrvFreeWaitForOplockBreak( WaitForOplockBreak );
    }

    return;

} // SrvDereferenceWaitForOplockBreak


VOID
SrvFreeWaitForOplockBreak (
    IN PWAIT_FOR_OPLOCK_BREAK WaitForOplockBreak
    )

/*++

Routine Description:

    This routine deallocates an wait for oplock break item.

Arguments:

    WaitForOplockBreak - A pointer to the item to free.

Return Value:

    None.

--*/

{
    PAGED_CODE( );

    TERMINATE_REFERENCE_HISTORY( WaitForOplockBreak );

    DEALLOCATE_NONPAGED_POOL( WaitForOplockBreak );

    INCREMENT_DEBUG_STAT( SrvDbgStatistics.WaitForOplockBreakInfo.Frees );

    return;

} // SrvFreeWaitForOplockBreak


BOOLEAN
SrvRequestOplock (
    IN PWORK_CONTEXT WorkContext,
    IN POPLOCK_TYPE OplockType,
    IN BOOLEAN RequestIIOnFailure
    )

/*++

Routine Description:

    This function will attempt to request an oplock if the oplock was
    requested.

Arguments:

    WorkContext - Pointer to the workitem containing the rfcb.
    OplockType - Pointer to the oplock type being requested.  If the
        request was successful, this will contain the type of oplock
        that was obtained.
    RequestIIOfFailure - If TRUE, a level II oplock will be requested in
        case the original request was denied.

Return Value:

    TRUE - The oplock was obtained.
    FALSE - The oplock was not obtained.

--*/


{
    NTSTATUS status;
    ULONG ioControlCode;
    PRFCB rfcb;
    PLFCB lfcb;
    PPAGED_RFCB pagedRfcb;
    KEVENT oplockRetryEvent;
    UNICODE_STRING fileName;

    PAGED_CODE( );

    if ( !SrvEnableOplocks && (*OplockType != OplockTypeServerBatch) ) {
        return FALSE;
    }

    rfcb = WorkContext->Rfcb;
    pagedRfcb = rfcb->PagedRfcb;
    lfcb = rfcb->Lfcb;

    //
    // If this is an FCB open, return TRUE if the RFCB already owns an
    // oplock, FALSE otherwise.  Since we're folding multiple FCB opens
    // into a single FID, they are logically one open.  Hence, the oplock
    // state of all open instances is identical.
    //

    if ( pagedRfcb->FcbOpenCount > 1 ) {
        return (BOOLEAN)(rfcb->OplockState != OplockStateNone);
    }

    //
    // If we already have an oplock, because this is a reclaiming of a
    // cached open, then we don't need to request one now.
    //

    if ( rfcb->OplockState != OplockStateNone ) {
        UpdateRfcbHistory( rfcb, 'poer' );
        IF_DEBUG(FILE_CACHE) {
            KdPrint(( "SrvRequestOplock: already own server oplock for "));
            SrvPrintwZ( &rfcb->Mfcb->FileName );
            KdPrint(( "\n" ));
        }
        ASSERT( ((rfcb->OplockState == OplockStateOwnBatch) &&
                 (*OplockType == OplockTypeBatch)) ||
                ((rfcb->OplockState == OplockStateOwnServerBatch) &&
                 (*OplockType == OplockTypeServerBatch)) );
        return (BOOLEAN)(*OplockType != OplockTypeServerBatch);
    }

    //
    // Check to see if connection is reliable. If not, reject oplock request.
    //

    SrvUpdateVcQualityOfService( WorkContext->Connection, NULL );

    if ( !WorkContext->Connection->EnableOplocks &&
         (*OplockType != OplockTypeServerBatch) ) {
        return FALSE;
    }

    //
    // Do not give oplocks to system files, otherwise deadlock can occur.  This
    //  can happen, for instance, if the LSA is needing to open a system file to handle
    //  an AcceptSecurityContext request.  If a client has this system file open, we may
    //  need to send a break to the client, which may require us to take a resource already
    //  held during this open operation.
    //
    // Another way to look at it is to assert that we can't allow operation of the local
    //  operating system to depend on timely interactions with clients on the network.
    //
    if( WorkContext->TreeConnect != NULL &&
        WorkContext->TreeConnect->Share->PotentialSystemFile == TRUE &&
        rfcb->Mfcb->FileName.Length > SrvSystemRoot.Length ) {

        UNICODE_STRING  tmpString;

        tmpString = rfcb->Mfcb->FileName;
        tmpString.Length = SrvSystemRoot.Length;

        if( RtlCompareUnicodeString( &SrvSystemRoot, &tmpString, TRUE ) == 0 &&
            tmpString.Buffer[ tmpString.Length / sizeof( WCHAR ) ] == OBJ_NAME_PATH_SEPARATOR ) {

            IF_DEBUG( OPLOCK ) {
                KdPrint(("Oplock request REJECTED for system file: <%wZ>!\n",
                        &rfcb->Mfcb->FileName ));
            }

            return FALSE;
        }
    }

    //
    // Do not give batch oplocks on substreams of files
    //
    if( *OplockType == OplockTypeBatch || *OplockType == OplockTypeServerBatch ) {
        PWCHAR s, es;

        SrvGetBaseFileName( &rfcb->Mfcb->FileName, &fileName );

        for( s = fileName.Buffer; fileName.Length; s++, fileName.Length -= sizeof(WCHAR) ) {
            if( *s == L':' ) {
                IF_DEBUG( OPLOCK ) {
                    KdPrint(("Oplock request REJECTED for substream: <%wZ>!\n",
                            &rfcb->Mfcb->FileName ));
                }
                return FALSE;
            }
        }
    }

    IF_DEBUG(OPLOCK) {
        KdPrint(("SrvRequestOplock: Attempting to obtain oplock for RFCB %p ", rfcb ));
        SrvPrintwZ( &rfcb->Mfcb->FileName );
        KdPrint(( "\n" ));
    }

    //
    // Set the RFCB oplock to the type of oplock we are requesting.
    //

    if ( *OplockType == OplockTypeExclusive ) {

        rfcb->OplockState = OplockStateOwnExclusive;
        ioControlCode = FSCTL_REQUEST_OPLOCK_LEVEL_1;

    } else if ( *OplockType == OplockTypeBatch ) {

        rfcb->OplockState = OplockStateOwnBatch;
        ioControlCode = FSCTL_REQUEST_BATCH_OPLOCK;

    } else if ( *OplockType == OplockTypeServerBatch ) {

        IF_DEBUG(FILE_CACHE) {
            KdPrint(( "SrvRequestOplock: requesting server oplock for " ));
            SrvPrintwZ( &rfcb->Mfcb->FileName );
            KdPrint(( "\n" ));
        }
        UpdateRfcbHistory( rfcb, 'osqr' );

        rfcb->OplockState = OplockStateOwnServerBatch;
        ioControlCode = FSCTL_REQUEST_BATCH_OPLOCK;

    } else {
        ASSERT(0);
        return(FALSE);
    }

    //
    // Generate and issue the oplock request IRP.
    //

    if (rfcb->Irp != NULL) {

        //DbgPrint( "ACK! Would have allocated second IRP for RFCB %x\n", rfcb );
        UpdateRfcbHistory( rfcb, '2pri' );

        //
        // This RFCB previously owned an oplock, and that oplock has been broken, but
        // the rundown of the oplock is not yet complete.  We can't start a new one,
        // because then there would be two oplock IRPs associated with the RFCB, and
        // the RFCB could be queued twice to the work queue.  (Even if it didn't get
        // queued twice, the completion of the first one would clear Rfcb->Irp.)
        //
        // We could come up with some delay scheme to wait for the previous oplock to
        // rundown, but since the oplock has been broken, it doesn't seem like we want
        // to try again anyway.
        //

        return FALSE;
    }

    UpdateRfcbHistory( rfcb, 'pria' );

    //
    // Reference the RFCB to account for the IRP we are about to submit.
    //

    SrvReferenceRfcb( rfcb );

    rfcb->Irp = SrvBuildIoControlRequest(
                    NULL,
                    lfcb->FileObject,
                    rfcb,
                    IRP_MJ_FILE_SYSTEM_CONTROL,
                    ioControlCode,
                    NULL,                        // Main buffer
                    0,                           // Input buffer length
                    NULL,                        // Auxiliary buffer
                    0,                           // Output buffer length
                    NULL,                        // MDL
                    SrvFsdOplockCompletionRoutine
                    );

    if ( rfcb->Irp == NULL ) {
        IF_DEBUG(OPLOCK) {
            KdPrint(("SrvRequestOplock: oplock attempt failed, could not allocate IRP" ));
        }
        rfcb->OplockState = OplockStateNone;

        SrvDereferenceRfcb( rfcb );

        return FALSE;
    }

    //
    // Clear this flag to indicate that this has not caused an oplock
    // break to occur.
    //

    rfcb->DeferredOplockBreak = FALSE;

    //
    // Initialize this event that we use to do an oplock request retry
    // in case the original request fails.  This will prevent the completion
    // routine from cleaning up the irp.
    //

    if ( RequestIIOnFailure ) {
        KeInitializeEvent( &oplockRetryEvent, SynchronizationEvent, FALSE );
        rfcb->RetryOplockRequest = &oplockRetryEvent;
    } else {
        rfcb->RetryOplockRequest = NULL;
    }

    //
    // Make the actual request.
    //

    status = IoCallDriver(
                 lfcb->DeviceObject,
                 rfcb->Irp
                 );

    //
    // If the driver returns STATUS_PENDING, the oplock was granted.
    // The IRP will complete when (1) The driver wants to break to
    // oplock or (2) The file is being closed.
    //

    if ( status == STATUS_PENDING ) {

        //
        // Remember that this work item caused us to generate an oplock
        // request.
        //

        WorkContext->OplockOpen = TRUE;

        IF_DEBUG(OPLOCK) {
            KdPrint(("RequestOplock: oplock attempt successful\n" ));
        }
        UpdateRfcbHistory( rfcb, 'rgpo' );

        return (BOOLEAN)(*OplockType != OplockTypeServerBatch);

    } else if ( RequestIIOnFailure ) {

        //
        // The caller wants us to attempt a level II oplock request.
        //

        ASSERT( *OplockType != OplockTypeServerBatch );

        IF_DEBUG(OPLOCK) {
            KdPrint(("SrvRequestOplock: Oplock request failed. "
                      "OplockII being attempted.\n" ));
        }

        //
        // Wait for the completion routine to be run.  It will set
        // an event that will signal us to go on.
        //

        KeWaitForSingleObject(
            &oplockRetryEvent,
            WaitAny,
            KernelMode, // don't let stack be paged -- event is on stack!
            FALSE,
            NULL
            );

        //
        // The Oplock Retry event was signaled. Proceed with the retry.
        //

        IF_DEBUG(OPLOCK) {
            KdPrint(("SrvRequestOplock: Oplock retry event signalled.\n"));
        }

        //
        // Generate and issue the wait for oplock IRP.  Clear the
        // Retry event pointer so that the completion routine can clean up
        // the irp in case of failure.
        //

        rfcb->RetryOplockRequest = NULL;

        (VOID) SrvBuildIoControlRequest(
                        rfcb->Irp,
                        lfcb->FileObject,
                        rfcb,
                        IRP_MJ_FILE_SYSTEM_CONTROL,
                        FSCTL_REQUEST_OPLOCK_LEVEL_2,
                        NULL,                        // Main buffer
                        0,                           // Input buffer length
                        NULL,                        // Auxiliary buffer
                        0,                           // Output buffer length
                        NULL,                        // MDL
                        SrvFsdOplockCompletionRoutine
                        );


        //
        // Set the RFCB oplock to the type of oplock we are requesting.
        //

        rfcb->OplockState = OplockStateOwnLevelII;

        status = IoCallDriver(
                     lfcb->DeviceObject,
                     rfcb->Irp
                     );

        //
        // If the driver returns STATUS_PENDING, the oplock was granted.
        // The IRP will complete when (1) The driver wants to break to
        // oplock or (2) The file is being closed.
        //

        if ( status == STATUS_PENDING ) {

            //
            // Remember that this work item caused us to generate an oplock
            // request.
            //

            WorkContext->OplockOpen = TRUE;

            IF_DEBUG(OPLOCK) {
                KdPrint(("SrvRequestOplock: OplockII attempt successful\n" ));
            }

            *OplockType = OplockTypeShareRead;
            return TRUE;

        }

    } else {
        UpdateRfcbHistory( rfcb, 'gnpo' );
    }

    IF_DEBUG(OPLOCK) {
        KdPrint(("SrvRequestOplock: oplock attempt unsuccessful\n" ));
    }

    //
    // Oplock was denied.
    //

    return FALSE;

} // SrvRequestOplock


NTSTATUS
SrvStartWaitForOplockBreak (
    IN PWORK_CONTEXT WorkContext,
    IN PRESTART_ROUTINE RestartRoutine,
    IN HANDLE Handle OPTIONAL,
    IN PFILE_OBJECT FileObject OPTIONAL
    )

/*++

Routine Description:

    This function builds and issues an oplock break notify file system
    control IRP.

Arguments:

    WorkContext - A pointer to the work context block for this request.

    RestartRoutine - The restart routine for this IRP.

    Additional one of the following must be supplied:

    Handle - A handle to the oplocked file.
    FileObject - A pointer to the file object of the oplocked file.

Return Value:

    NTSTATUS.

--*/

{
    PFILE_OBJECT fileObject;
    NTSTATUS status;

    PWAIT_FOR_OPLOCK_BREAK waitForOplockBreak;

    PAGED_CODE( );

    //
    // Allocate memory, so that we can track this wait for oplock break.
    //

    SrvAllocateWaitForOplockBreak( &waitForOplockBreak );

    if (waitForOplockBreak == NULL) {
        return STATUS_INSUFF_SERVER_RESOURCES;
    }


    IF_DEBUG( OPLOCK ) {
        KdPrint(("Starting wait for oplock break.  Context = %p\n", waitForOplockBreak));
    }

    //
    // Get a pointer to the file object, so that we can directly
    // build a wait for oplock IRP for asynchronous operations.
    //

    if (ARGUMENT_PRESENT( FileObject ) ) {

        fileObject = FileObject;

    } else {

        status = ObReferenceObjectByHandle(
                    Handle,
                    0,
                    NULL,
                    KernelMode,
                    (PVOID *)&fileObject,
                    NULL                     // handle information
                    );

        if ( !NT_SUCCESS(status) ) {

            SrvLogServiceFailure( SRV_SVC_OB_REF_BY_HANDLE, status );

            //
            // This internal error bugchecks the system.
            //

            INTERNAL_ERROR(
                ERROR_LEVEL_IMPOSSIBLE,
                "SrvStartWaitForOplock: unable to reference file handle 0x%lx",
                Handle,
                NULL
                );

            return STATUS_UNSUCCESSFUL;

        }

    }

    //
    // Set the restart routine.
    //

    WorkContext->FsdRestartRoutine = SrvQueueWorkToFspAtDpcLevel;
    WorkContext->FspRestartRoutine = RestartRoutine;

    //
    // Generate and send the wait for oplock break IRP.
    //

    SrvBuildIoControlRequest(
        WorkContext->Irp,
        fileObject,
        WorkContext,
        IRP_MJ_FILE_SYSTEM_CONTROL,
        FSCTL_OPLOCK_BREAK_NOTIFY,
        NULL,                       // Main buffer
        0,                          // Input buffer length
        NULL,                       // Auxiliary buffer
        0,                          // Output buffer length
        NULL,                       // MDL
        NULL
        );

    //
    // Set the timeout time for the oplock wait to complete.
    //

    WorkContext->WaitForOplockBreak = waitForOplockBreak;

    waitForOplockBreak->WaitState = WaitStateWaitForOplockBreak;
    waitForOplockBreak->Irp = WorkContext->Irp;

    KeQuerySystemTime( (PLARGE_INTEGER)&waitForOplockBreak->TimeoutTime );

    waitForOplockBreak->TimeoutTime.QuadPart += SrvWaitForOplockBreakTime.QuadPart;

    ACQUIRE_LOCK( &SrvOplockBreakListLock );

    SrvInsertTailList(
        &SrvWaitForOplockBreakList,
        &waitForOplockBreak->ListEntry
        );

    RELEASE_LOCK( &SrvOplockBreakListLock );

    //
    // Submit the IRP.
    //

    (VOID)IoCallDriver(
              IoGetRelatedDeviceObject( fileObject ),
              WorkContext->Irp
              );

    //
    // We no longer need a reference to the file object.  Dereference
    // it now.
    //

    if ( !ARGUMENT_PRESENT( FileObject ) ) {
        ObDereferenceObject( fileObject );
    }

    return STATUS_SUCCESS;

} // SrvStartWaitForOplockBreak


NTSTATUS
SrvWaitForOplockBreak (
    IN PWORK_CONTEXT WorkContext,
    IN HANDLE FileHandle
    )

/*++

Routine Description:

    This function waits synchrounsly for an oplock to be broken.

    !!!  When cancel is available.  This function will also start timer.
         If the timer expires before the oplock is broken, the wait is
         cancelled.

Arguments:

    FileHandle - A handle to an oplocked file.

Return Value:

    NTSTATUS - The status of the wait for oplock break.

--*/

{
    PWAIT_FOR_OPLOCK_BREAK waitForOplockBreak;

    PAGED_CODE( );

    //
    // Allocate memory, so that we can track this wait for oplock break.
    //

    SrvAllocateWaitForOplockBreak( &waitForOplockBreak );

    if (waitForOplockBreak == NULL) {
        return STATUS_INSUFF_SERVER_RESOURCES;
    }

    IF_DEBUG( OPLOCK ) {
        KdPrint(("Starting wait for oplock break.  Context = %p\n", waitForOplockBreak));
    }

    //
    // Set the timeout time for the oplock wait to complete.
    //

    waitForOplockBreak->WaitState = WaitStateWaitForOplockBreak;
    waitForOplockBreak->Irp = NULL;

    KeQuerySystemTime( (PLARGE_INTEGER)&waitForOplockBreak->TimeoutTime );

    waitForOplockBreak->TimeoutTime.QuadPart += SrvWaitForOplockBreakTime.QuadPart;

    //
    // SrvIssueWaitForOplockBreakRequest will queue the waitForOplockBreak
    // structure on the global list of oplock breaks.
    //

    return SrvIssueWaitForOplockBreak(
               FileHandle,
               waitForOplockBreak
               );

} // SrvWaitForOplockBreak


VOID
SrvSendDelayedOplockBreak (
    IN PCONNECTION Connection
    )

/*++

Routine Description:

    This function sends outstanding oplock breaks on a connection that
    were held back because a read raw operation was in progress.

Arguments:

    Connection - A pointer to the connection block that has completed
                 a read raw operation.

Return Value:

    None

--*/

{
    KIRQL oldIrql;
    PLIST_ENTRY listEntry;
    PWORK_CONTEXT workContext;
    PRFCB rfcb;
#if SRVDBG
    ULONG oplockBreaksSent = 0;
#endif

    //UNLOCKABLE_CODE( CONN );

    //
    // Acquire the lock that protects the connection's oplock list and
    // raw read status.
    //

    ACQUIRE_SPIN_LOCK( Connection->EndpointSpinLock, &oldIrql );

    //
    // Indicate that the read raw operation is complete.  If the count
    // goes to zero, oplock breaks can proceed.
    //

    Connection->RawReadsInProgress--;

    while ( (Connection->RawReadsInProgress == 0) &&
            !IsListEmpty( &Connection->OplockWorkList ) ) {

        //
        // There is an outstanding oplock break request.  Send
        // the request now.
        //

        listEntry = Connection->OplockWorkList.Flink;

        RemoveHeadList( &Connection->OplockWorkList );

        //
        // Note that releasing the spin lock here is safe.  If a new
        // raw read request comes in, it will be rejected, because the
        // OplockBreaksInProgress count is not zero.  Also, if the
        // oplock break count manages to go to zero, and a raw read
        // comes in, we'll catch this back at the top of the loop.
        //

        RELEASE_SPIN_LOCK( Connection->EndpointSpinLock, oldIrql );

        rfcb = (PRFCB)CONTAINING_RECORD( listEntry, RFCB, ListEntry );

#if DBG
        rfcb->ListEntry.Flink = rfcb->ListEntry.Blink = NULL;
#endif

        workContext = GenerateOplockBreakRequest( rfcb );

        if ( workContext != NULL ) {

            //
            // Copy the RFCB reference to the work context block.
            //

            workContext->Rfcb = rfcb;

            //
            // !!! Is the init of share, session, tree connect
            //     necessary?
            //

            workContext->Share = NULL;
            workContext->Session = NULL;
            workContext->TreeConnect = NULL;

            workContext->Connection = rfcb->Connection;
            SrvReferenceConnection( workContext->Connection );

            workContext->Endpoint = workContext->Connection->Endpoint;

            SrvRestartOplockBreakSend( workContext );
#if SRVDBG
            oplockBreaksSent++;
#endif

        } else {

            //
            // We are out of resources.  GenerateOplockRequest, has
            // added this connection to the needs resource queue. The
            // scavenger will finish processing the remainder of the
            // oplock break requests when resources become available.
            //

#if SRVDBG
            IF_DEBUG(OPLOCK) {
                KdPrint(("SrvSendDelayedOplockBreak: sent %d\n", oplockBreaksSent ));
            }
#endif
            return;

        }

        ACQUIRE_SPIN_LOCK( Connection->EndpointSpinLock, &oldIrql );

    }

    //
    // We have stopped trying to send oplock break requests. The
    // scavenger will attempt to send the rest.
    //

#if SRVDBG
    IF_DEBUG(OPLOCK) {
        KdPrint(("SrvSendDelayedOplockBreak: sent %d\n", oplockBreaksSent ));
    }
#endif

    RELEASE_SPIN_LOCK( Connection->EndpointSpinLock, oldIrql );

    return;

} // SrvSendDelayedOplockBreak


NTSTATUS
SrvCheckOplockWaitState (
    IN PWAIT_FOR_OPLOCK_BREAK WaitForOplockBreak
    )

/*++

Routine Description:

    This function checks the state of a wait for oplock break, and
    takes action.

Arguments:

    WaitForOplockBreak

Return Value:

    NTSTATUS -
        STATUS_SUCCESS - The oplock was successfully broken.
        STATUS_SHARING_VIOLATION - The oplock could not be broken.
--*/

{
    PAGED_CODE( );

    if ( WaitForOplockBreak == NULL ) {
        return STATUS_SUCCESS;
    }

    ACQUIRE_LOCK( &SrvOplockBreakListLock );

    if ( WaitForOplockBreak->WaitState == WaitStateOplockWaitTimedOut ) {

        IF_DEBUG( OPLOCK ) {
            KdPrint(("SrvCheckOplockWaitState: Oplock wait timed out\n"));
        }

        RELEASE_LOCK( &SrvOplockBreakListLock );
        return STATUS_SHARING_VIOLATION;

    } else {

        IF_DEBUG( OPLOCK ) {
            KdPrint(("SrvCheckOplockWaitState: Oplock wait succeeded\n"));
        }

        WaitForOplockBreak->WaitState = WaitStateOplockWaitSucceeded;

        SrvRemoveEntryList(
            &SrvWaitForOplockBreakList,
            &WaitForOplockBreak->ListEntry
            );

        RELEASE_LOCK( &SrvOplockBreakListLock );

        //
        // The WaitForOplockBreak has been taken off of the wait for oplock
        // break list.  Decrement the reference count.
        //

        SrvDereferenceWaitForOplockBreak( WaitForOplockBreak );

        return STATUS_SUCCESS;

    }

} // SrvCheckOplockWaitState

LARGE_INTEGER
SrvGetOplockBreakTimeout (
    IN PWORK_CONTEXT WorkContext
    )

/*++

Routine Description:

    This function computes the timeout to wait for an oplock break response
    from the client.  This is based on the formula:

        new timeout = current time + default timeout +
                      link delay + requestSize / throughput +
                      link delay + responseSize / thoughput

Arguments:

    WorkContext - Pointer to the work context block that points to the
        connection that owns this oplock.

Return Value:

    The timeout value.

--*/

{
    LARGE_INTEGER timeoutTime;
    LARGE_INTEGER currentTime;
    LARGE_INTEGER throughput;
    LARGE_INTEGER additionalTimeoutTime;
    LARGE_INTEGER propagationDelay;
    PCONNECTION connection = WorkContext->Connection;

    PAGED_CODE( );

    //
    // Get current time.
    //

    KeQuerySystemTime( &currentTime );

    //
    // Add default timeout
    //

    timeoutTime.QuadPart = currentTime.QuadPart +
                                SrvWaitForOplockBreakRequestTime.QuadPart;

    //
    // Update link QOS.
    //

    SrvUpdateVcQualityOfService(
        connection,
        &currentTime
        );

    //
    // Access connection QOS fields using a spin lock.
    //

    ACQUIRE_LOCK( &connection->Lock );
    throughput = connection->PagedConnection->Throughput;
    additionalTimeoutTime = connection->PagedConnection->Delay;
    RELEASE_LOCK( &connection->Lock );

    //
    // Calculate the actual timeout.
    //

    if ( throughput.QuadPart == 0 ) {
        throughput = SrvMinLinkThroughput;
    }

    //
    // Add link delay + link delay to account for round trip.
    //

    additionalTimeoutTime.QuadPart *= 2;

    if ( throughput.QuadPart != 0 ) {

        //
        // Compute the propagation delay.  Convert throughput from bytes/s
        // to bytes/100ns.
        //

        propagationDelay.QuadPart =
            Int32x32To64( SRV_PROPAGATION_DELAY_SIZE, 10*1000*1000 );

        propagationDelay.QuadPart /= throughput.QuadPart;

        additionalTimeoutTime.QuadPart += propagationDelay.QuadPart;

    }

    timeoutTime.QuadPart += additionalTimeoutTime.QuadPart;

    return timeoutTime;

} // SrvGetOplockBreakTimeout

VOID
SrvSendOplockRequest(
    IN PCONNECTION Connection,
    IN PRFCB Rfcb,
    IN KIRQL OldIrql
    )
/*++

Routine Description:

    This function tries to send an oplock break request to the owner of
    an oplock.

    *** Must be called with the EndpointSpinLock held. Released on exit ***

Arguments:

    Connection - The connection on which to send the oplock break.

    Rfcb - The RFCB of the oplocked file.  Rfcb->NewOplockLevel contains the
           oplock level to break to.  The rfcb has an extra reference
           from the irp used to make the oplock request.

    OldIrql - The previous IRQL value obtained when the spin lock was
        acquired.

Return Value:

    None.

--*/
{
    PWORK_CONTEXT workContext;

    UNLOCKABLE_CODE( 8FIL );

    //
    // Indicate that we are about to send an oplock break request
    // and queue this request to the oplocks in progress list.
    //

    Connection->OplockBreaksInProgress++;

    //
    // If there is a read raw in progress we will defer the oplock
    // break request and send it only after the read raw has
    // completed.
    //

    if ( Connection->RawReadsInProgress != 0 ) {

        IF_DEBUG( OPLOCK ) {
            KdPrint(( "SrvOplockBreakNotification: Read raw in progress; "
                       "oplock break deferred\n"));
        }

        //
        // if the connection is closing, forget about this.
        //

        if ( GET_BLOCK_STATE(Connection) != BlockStateActive ) {

            Connection->OplockBreaksInProgress--;

            //
            // Dereference the rfcb.
            //

            RELEASE_SPIN_LOCK( Connection->EndpointSpinLock, OldIrql );

            SrvDereferenceRfcb( Rfcb );

        } else {

            //
            // Save the RFCB on the list for this connection.  It will be
            // used when the read raw has completed.
            //

            InsertTailList( &Connection->OplockWorkList, &Rfcb->ListEntry );

            RELEASE_SPIN_LOCK( Connection->EndpointSpinLock, OldIrql );
        }

        return;
    }

    RELEASE_SPIN_LOCK( Connection->EndpointSpinLock, OldIrql );

    workContext = GenerateOplockBreakRequest( Rfcb );

    //
    // If we were able to generate the oplock break request SMB
    // prepare and send it.  Otherwise this connection has
    // been inserted in the need resource queue and the
    // scavenger will have to send the SMB.
    //

    if ( workContext != NULL ) {

        //
        // Copy the RFCB reference to the work context block.
        // Do not re-reference the RFCB.
        //

        workContext->Rfcb = Rfcb;

        //
        // !!! Is the init of share, session, tree connect
        //     necessary?
        //

        workContext->Share = NULL;
        workContext->Session = NULL;
        workContext->TreeConnect = NULL;

        workContext->Connection = Connection;
        SrvReferenceConnection( Connection );

        workContext->Endpoint = Connection->Endpoint;

        SrvRestartOplockBreakSend( workContext );

    }

} // SrvSendOplockRequest

VOID SRVFASTCALL
SrvCheckDeferredOpenOplockBreak(
    IN PWORK_CONTEXT WorkContext
    )

/*++

Routine Description:

    This routine checks to see if there an oplock break was deferred
    pending the completion of the open request.  If there is, try to
    send it.

Arguments:

    WorkContext - Pointer to the work item that contains the rfcb
        and the connection block of the open request that just finished.

Return Value:

    None.

--*/

{

    KIRQL oldIrql;
    PRFCB rfcb;
    PCONNECTION connection;

    UNLOCKABLE_CODE( 8FIL );

    //
    // This work item contained an open and oplock request.  Now that
    // the response has been sent, see if there is a deferred oplock
    // break request to send.
    //

    rfcb = WorkContext->Rfcb;
    connection = WorkContext->Connection;

    ASSERT( rfcb != NULL );

    ACQUIRE_SPIN_LOCK( connection->EndpointSpinLock, &oldIrql );

    rfcb->OpenResponseSent = TRUE;

    if ( rfcb->DeferredOplockBreak ) {

        //
        // EndpointSpinLock will be released in this routine.
        //

        SrvSendOplockRequest( connection, rfcb, oldIrql );

    } else {

        RELEASE_SPIN_LOCK( connection->EndpointSpinLock, oldIrql );

    }

    return;

} // SrvCheckDeferredOpenOplockBreak
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\srv\move.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    move.c

Abstract:

    This module contains the routine to rename or copy a file.  This
    routine is used by the routines SrvSmbRenameFile,
    SrvSmbRenameFileExtended, and SrvSmbCopyFile.

Author:

    David Treadwell (davidtr) 22-Jan-1990

Revision History:

--*/

#include "precomp.h"
#include "move.tmh"
#pragma hdrstop

#define BugCheckFileId SRV_FILE_MOVE

NTSTATUS
DoCopy (
    IN PWORK_CONTEXT WorkContext,
    IN PUNICODE_STRING Source,
    IN HANDLE SourceHandle,
    IN PUNICODE_STRING Target,
    IN PSHARE TargetShare,
    IN USHORT SmbOpenFunction,
    IN PUSHORT SmbFlags
    );

NTSTATUS
DoRename (
    IN PWORK_CONTEXT WorkContext,
    IN PUNICODE_STRING Source,
    IN HANDLE SourceHandle,
    IN PUNICODE_STRING Target,
    IN PSHARE TargetShare,
    IN USHORT SmbOpenFunction,
    IN PUSHORT SmbFlags,
    IN BOOLEAN FailIfTargetIsDirectory,
    IN USHORT InformationLevel,
    IN ULONG ClusterCount
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text( PAGE, SrvMoveFile )
#pragma alloc_text( PAGE, DoCopy )
#pragma alloc_text( PAGE, DoRename )
#endif


NTSTATUS
SrvMoveFile(
    IN PWORK_CONTEXT WorkContext,
    IN PSHARE TargetShare,
    IN USHORT SmbOpenFunction,
    IN OUT PUSHORT SmbFlags,
    IN USHORT SmbSearchAttributes,
    IN BOOLEAN FailIfTargetIsDirectory,
    IN USHORT InformationLevel,
    IN ULONG ClusterCount,
    IN PUNICODE_STRING Source,
    IN OUT PUNICODE_STRING Target
    )

/*++

Routine Description:

    This routine moves a file, which may be a copy or a rename.

Arguments:

    WorkContext - a pointer to the work context block for the operation.  The
        Session, TreeConnect, and RequestHeader fields are used.

    TargetShare - a pointer to the share on which the target should
        be.  The RootDirectoryHandle field is used to do relative opens.

    SmbOpenFunction - the "OpenFunction" field of the request SMB.  This
        parameter is used to determine what should be done if the target
        file does or does not exist.

    SmbFlags - a pointer to the "Flags" field of the request SMB.  This
        parameter is used to determine whether we know that the target
        is supposed to be a file or directory.  In addition, if this has
        no information about the target, it is set to reflect whether
        the target was a directory or file.  This is useful when doing
        multiple renames or copies as a result of wildcards--move a*.* b
        might call this routine many times, and if b is a directory,
        this routine will set this parameter appropiately such that if
        does not have to reopen the directory for each move.

    SmbSearchAttributes - the search attributes specified in the request
        SMB.  The attributes on the source file are checked against
        these to make sure that the move can be done.

    FailIfTargetIsDirectory - if TRUE and the target already exists as
        a directory, fail the operation.  Otherwise, rename the file
        into the directory.

    InformationLevel - Move/Rename/CopyOnWrite/Link/MoveCluster

    ClusterCount - MoveCluster count

    Source - a pointer to a string describing the name of the source file
        relative to the share directory in which it is located.

    Target - a pathname to the target file.  This may contain directory
        information--it should be the raw information from the SMB,
        unadulterated by the SMB processing routine except for
        canonicalization.  This name may end in a directory name, in
        which case the source name is used as the filename.

Return Value:

    Status.

--*/

{
    NTSTATUS status;
    HANDLE sourceHandle;
    BOOLEAN isCompatibilityOpen;
    PMFCB mfcb;
    PNONPAGED_MFCB nonpagedMfcb;
    PLFCB lfcb;

    OBJECT_ATTRIBUTES sourceObjectAttributes;
    IO_STATUS_BLOCK ioStatusBlock;
    ULONG sourceAccess = 0;
    BOOLEAN isNtRename;
    ULONG hashValue;

    PSESSION session;
    PSHARE sourceShare;

    PSRV_LOCK mfcbLock;

    PAGED_CODE( );

    IF_SMB_DEBUG(FILE_CONTROL2) SrvPrint0( "SrvMoveFile entered.\n" );

    //
    // Set handles and pointers to NULL so we know how to clean up on
    // exit.
    //

    sourceHandle = NULL;
    isCompatibilityOpen = FALSE;
    lfcb = NULL;
    //mfcb = NULL;     // not really necessary--SrvFindMfcb sets it correctly

    //
    // Set up the block pointers that will be needed.
    //

    session = WorkContext->Session;
    sourceShare = WorkContext->TreeConnect->Share;

    isNtRename = (BOOLEAN)(WorkContext->RequestHeader->Command == SMB_COM_NT_RENAME);

    //
    // See if we already have this file open in compatibility mode.  If
    // we do, and this session owns it, then we must use that open
    // handle and, if this is a rename, close all the handles when we
    // are done.
    //
    // *** SrvFindMfcb references the MFCB--remember to dereference it.
    //

    if ( (WorkContext->RequestHeader->Flags & SMB_FLAGS_CASE_INSENSITIVE) ||
         WorkContext->Session->UsingUppercasePaths ) {
        mfcb = SrvFindMfcb( Source, TRUE, &mfcbLock, &hashValue, WorkContext );
    } else {
        mfcb = SrvFindMfcb( Source, FALSE, &mfcbLock, &hashValue, WorkContext );
    }

    if ( mfcb != NULL ) {
        nonpagedMfcb = mfcb->NonpagedMfcb;
        ACQUIRE_LOCK( &nonpagedMfcb->Lock );
    }

    if( mfcbLock ) {
        RELEASE_LOCK( mfcbLock );
    }

    if ( mfcb == NULL || !mfcb->CompatibilityOpen ) {

        //
        // Either the file wasn't opened by the server or it was not
        // a compatibility/FCB open, so open it here.
        //
        // Release the open lock--we don't need it any more.
        //

        if ( mfcb != NULL ) {
            RELEASE_LOCK( &nonpagedMfcb->Lock );
        }

        //
        // Use DELETE access for a rename, and the appropriate copy access
        // for Copy/Link/Move/MoveCluster.
        //

        switch (InformationLevel) {
        case SMB_NT_RENAME_RENAME_FILE:
            sourceAccess = DELETE;
            break;

        case SMB_NT_RENAME_MOVE_CLUSTER_INFO:
            sourceAccess = SRV_COPY_TARGET_ACCESS & ~(WRITE_DAC | WRITE_OWNER);
            break;

        case SMB_NT_RENAME_SET_LINK_INFO:
        case SMB_NT_RENAME_MOVE_FILE:
            sourceAccess = SRV_COPY_SOURCE_ACCESS;
            break;

        default:
            ASSERT(FALSE);
        }

        SrvInitializeObjectAttributes_U(
            &sourceObjectAttributes,
            Source,
            (WorkContext->RequestHeader->Flags & SMB_FLAGS_CASE_INSENSITIVE ||
                session->UsingUppercasePaths) ? OBJ_CASE_INSENSITIVE : 0L,
            NULL,
            NULL
            );

        IF_SMB_DEBUG(FILE_CONTROL2) {
            SrvPrint1( "Opening source: %wZ\n",
                          sourceObjectAttributes.ObjectName );
        }

        //
        // Open the source file.  We allow read access for other processes.
        //

        INCREMENT_DEBUG_STAT( SrvDbgStatistics.TotalOpenAttempts );
        INCREMENT_DEBUG_STAT( SrvDbgStatistics.TotalOpensForPathOperations );

#ifdef SLMDBG
        if ( SrvIsSlmStatus( Target ) ) {
            sourceAccess |= GENERIC_READ;
        }
#endif
        //
        // !!! Currently we can't specify complete if oplocked, because
        //     this won't break a batch oplock.  Unfortunately this also
        //     means that we can't timeout the open (if the oplock break
        //     takes too long) and fail this SMB gracefully.
        //

        status = SrvIoCreateFile(
                     WorkContext,
                     &sourceHandle,
                     sourceAccess | SYNCHRONIZE,            // DesiredAccess
                     &sourceObjectAttributes,
                     &ioStatusBlock,
                     NULL,                                  // AllocationSize
                     0,                                     // FileAttributes
                     FILE_SHARE_READ,                       // ShareAccess
                     FILE_OPEN,                             // Disposition
                     FILE_SYNCHRONOUS_IO_NONALERT           // CreateOptions
                        | FILE_OPEN_REPARSE_POINT,
                     NULL,                                  // EaBuffer
                     0,                                     // EaLength
                     CreateFileTypeNone,                    // File type
                     NULL,                                  // ExtraCreateParameters
                     IO_FORCE_ACCESS_CHECK,                 // Options
                     WorkContext->TreeConnect->Share
                     );

        if( status == STATUS_INVALID_PARAMETER ) {
            status = SrvIoCreateFile(
                         WorkContext,
                         &sourceHandle,
                         sourceAccess | SYNCHRONIZE,            // DesiredAccess
                         &sourceObjectAttributes,
                         &ioStatusBlock,
                         NULL,                                  // AllocationSize
                         0,                                     // FileAttributes
                         FILE_SHARE_READ,                       // ShareAccess
                         FILE_OPEN,                             // Disposition
                         FILE_SYNCHRONOUS_IO_NONALERT,          // CreateOptions
                         NULL,                                  // EaBuffer
                         0,                                     // EaLength
                         CreateFileTypeNone,                    // File type
                         NULL,                                  // ExtraCreateParameters
                         IO_FORCE_ACCESS_CHECK,                 // Options
                         WorkContext->TreeConnect->Share
                         );
        }

        if ( NT_SUCCESS(status) ) {

            SRVDBG_CLAIM_HANDLE( sourceHandle, "MOV", 4, 0 );

        } else if ( status == STATUS_ACCESS_DENIED ) {

            //
            // If the user didn't have this permission, update the statistics
            // database.
            //
            SrvStatistics.AccessPermissionErrors++;
        }

        ASSERT( status != STATUS_OPLOCK_BREAK_IN_PROGRESS );

        if ( !NT_SUCCESS(status) ) {

            IF_DEBUG(ERRORS) {
                SrvPrint1( "SrvMoveFile: SrvIoCreateFile failed (source): %X\n",
                              status );
            }

            goto exit;
        }

        IF_SMB_DEBUG(FILE_CONTROL2) {
            SrvPrint1( "SrvIoCreateFile succeeded (source), handle = 0x%p\n",
                          sourceHandle );
        }

        SrvStatistics.TotalFilesOpened++;

    } else {

        //
        // The file was opened by the server in compatibility mode or as
        // an FCB open.
        //

        lfcb = CONTAINING_RECORD( mfcb->LfcbList.Blink, LFCB, MfcbListEntry );

        //
        // Make sure that the session which sent this request is the
        // same as the one which has the file open.
        //

        if ( lfcb->Session != session ) {

            //
            // A different session has the file open in compatibility
            // mode, so reject the request.
            //

            status = STATUS_ACCESS_DENIED;
            RELEASE_LOCK( &nonpagedMfcb->Lock );

            goto exit;
        }

        //
        // Set isCompatibilityOpen so that we'll know on exit to close
        // all the open instances of this file.
        //

        isCompatibilityOpen = TRUE;

        sourceHandle = lfcb->FileHandle;
        sourceAccess = lfcb->GrantedAccess;

    }

    //
    // Make sure that the search attributes jive with the attributes
    // on the file.
    //

    status = SrvCheckSearchAttributesForHandle( sourceHandle, SmbSearchAttributes );

    if ( !NT_SUCCESS(status) ) {
        goto exit;
    }

    //
    // If the target has length 0, then it is the share root, which must
    // be a directory.  If the target is supposed to be a file, fail,
    // otherwise indicate that the target is a directory.
    //

    if ( Target->Length == 0 ) {

        if ( *SmbFlags & SMB_TARGET_IS_FILE ) {
            status = STATUS_INVALID_PARAMETER;
            goto exit;
        }

        *SmbFlags |= SMB_TARGET_IS_DIRECTORY;
    }

    //
    // We now have the source file open.  Call the appropriate routine
    // to rename or copy the file.
    //

    if (InformationLevel != SMB_NT_RENAME_MOVE_FILE) {

#ifdef SLMDBG
        if (InformationLevel == SMB_NT_RENAME_RENAME_FILE &&
            SrvIsSlmStatus( Source ) || SrvIsSlmStatus( Target ) ) {

            ULONG offset;

            status = SrvValidateSlmStatus(
                        sourceHandle,
                        WorkContext,
                        &offset
                        );

            if ( !NT_SUCCESS(status) ) {
                SrvReportCorruptSlmStatus(
                    Source,
                    status,
                    offset,
                    SLMDBG_RENAME,
                    WorkContext->Session
                    );
                SrvDisallowSlmAccess(
                    Source,
                    WorkContext->TreeConnect->Share->RootDirectoryHandle
                    );
                status = STATUS_DISK_CORRUPT_ERROR;
                goto exit;
            }

        }
#endif

        status = DoRename(
                     WorkContext,
                     Source,
                     sourceHandle,
                     Target,
                     TargetShare,
                     SmbOpenFunction,
                     SmbFlags,
                     FailIfTargetIsDirectory,
                     InformationLevel,
                     ClusterCount
                     );

    } else {

        FILE_BASIC_INFORMATION fileBasicInformation;

        //
        // Check whether this is a tree copy request.  If so, allow it only if
        // this is a single file copy operation.
        //

        if ( (*SmbFlags & SMB_COPY_TREE) != 0 ) {

            //
            // Get the attributes on the file.
            //

            status = SrvQueryBasicAndStandardInformation(
                                                    sourceHandle,
                                                    NULL,
                                                    &fileBasicInformation,
                                                    NULL
                                                    );

            if ( !NT_SUCCESS(status) ) {
                INTERNAL_ERROR(
                    ERROR_LEVEL_UNEXPECTED,
                    "SrvMoveFile: NtQueryInformationFile (basic "
                        "information) returned %X",
                    NULL,
                    NULL
                    );

                SrvLogServiceFailure( SRV_SVC_NT_QUERY_INFO_FILE, status );
                goto exit;
            }

            if ( ( fileBasicInformation.FileAttributes &
                   FILE_ATTRIBUTE_DIRECTORY ) != 0 ) {

                //
                // Fail this copy.
                //

                INTERNAL_ERROR(
                    ERROR_LEVEL_EXPECTED,
                    "Tree copy not implemented.",
                    NULL,
                    NULL
                    );
                status = STATUS_NOT_IMPLEMENTED;
                goto exit;
            }

        }

        status = DoCopy(
                     WorkContext,
                     Source,
                     sourceHandle,
                     Target,
                     TargetShare,
                     SmbOpenFunction,
                     SmbFlags
                     );
    }

exit:

    if ( sourceHandle != NULL && !isCompatibilityOpen ) {
        SRVDBG_RELEASE_HANDLE( sourceHandle, "MOV", 9, 0 );
        SrvNtClose( sourceHandle, TRUE );
    } else if (isCompatibilityOpen &&
               InformationLevel == SMB_NT_RENAME_RENAME_FILE) {
        SrvCloseRfcbsOnLfcb( lfcb );
    }

    //
    // If the file is open in compatibility mode, then we have held the
    // MFCB lock all along.  Release it now.
    //

    if ( isCompatibilityOpen ) {
        RELEASE_LOCK( &nonpagedMfcb->Lock );
    }

    if ( mfcb != NULL ) {
        SrvDereferenceMfcb( mfcb );
    }

    return status;

} // SrvMoveFile


NTSTATUS
DoCopy (
    IN PWORK_CONTEXT WorkContext,
    IN PUNICODE_STRING Source,
    IN HANDLE SourceHandle,
    IN PUNICODE_STRING Target,
    IN PSHARE TargetShare,
    IN USHORT SmbOpenFunction,
    IN PUSHORT SmbFlags
    )

/*++

Routine Description:

    This routine sets up for a call to SrvCopyFile.  It opens the target,
    determining, if necessary, whether the target is a file or directory.
    If this information is unknown, it writes it into the SmbFlags
    location.

Arguments:

    WorkContext - a pointer to the work context block for the operation.
        The session pointer is used, and the block itself is used for
        an impersonation.

    Source - the name of the source file relative to its share.

    SourceHandle - the handle to the source file.

    Target - the name of the target file relative to its share.

    TargetShare - the share of the target file.  The RootDirectoryHandle
        field is used for a relative rename.

    SmbOpenFunction - describes whether we are allowed to overwrite an
        existing file, or we should append to existing files.

    SmbFlags - can tell if the target is a file, directory, or unknown.
        This routine writes the true information into the location if
        it is unknown.

Return Value:

    Status.

--*/

{
    NTSTATUS status;
    IO_STATUS_BLOCK ioStatusBlock;
    ULONG createDisposition;
    UNICODE_STRING sourceBaseName;
    BOOLEAN create;

    HANDLE targetHandle = NULL;
    OBJECT_ATTRIBUTES targetObjectAttributes;
    UNICODE_STRING targetName;

    PAGED_CODE( );

    //
    // Set the buffer field of targetName to NULL so that we'll know
    // if we have to deallocate it at the end.
    //

    targetName.Buffer = NULL;

    //
    // Open the target file.  If we know that it is a directory, generate
    // the full file name.  Otherwise, open the target as a file.
    //

    SrvInitializeObjectAttributes_U(
        &targetObjectAttributes,
        Target,
        (WorkContext->RequestHeader->Flags & SMB_FLAGS_CASE_INSENSITIVE ||
         WorkContext->Session->UsingUppercasePaths) ? OBJ_CASE_INSENSITIVE : 0L,
        NULL,
        NULL
        );

    //
    // Determine the create disposition from the open function.
    //

    create = SmbOfunCreate( SmbOpenFunction );

    if ( SmbOfunTruncate( SmbOpenFunction ) ) {
        createDisposition = create ? FILE_OVERWRITE_IF : FILE_OVERWRITE;
    } else if ( SmbOfunAppend( SmbOpenFunction ) ) {
        createDisposition = create ? FILE_OPEN_IF : FILE_OPEN;
    } else {
        createDisposition = FILE_CREATE;
    }

    //
    // If we know that the target is a directory, generate the real target
    // name.
    //

    if ( *SmbFlags & SMB_TARGET_IS_DIRECTORY ) {

        SrvGetBaseFileName( Source, &sourceBaseName );

        SrvAllocateAndBuildPathName(
            Target,
            &sourceBaseName,
            NULL,
            &targetName
            );

        if ( targetName.Buffer == NULL ) {
            status = STATUS_INSUFF_SERVER_RESOURCES;
            goto copy_done;
        }

        targetObjectAttributes.ObjectName = &targetName;
    }

    IF_SMB_DEBUG(FILE_CONTROL2) {
        SrvPrint1( "Opening target: %wZ\n", targetObjectAttributes.ObjectName );
    }

    INCREMENT_DEBUG_STAT( SrvDbgStatistics.TotalOpenAttempts );
    INCREMENT_DEBUG_STAT( SrvDbgStatistics.TotalOpensForPathOperations );

    //
    // !!! Currently we can't specify complete if oplocked, because
    //     this won't break a batch oplock.  Unfortunately this also
    //     means that we can't timeout the open (if the oplock break
    //     takes too long) and fail this SMB gracefully.
    //

    status = SrvIoCreateFile(
                 WorkContext,
                 &targetHandle,
                 SRV_COPY_TARGET_ACCESS | SYNCHRONIZE,  // DesiredAccess
                 &targetObjectAttributes,
                 &ioStatusBlock,
                 NULL,                                  // AllocationSize
                 0,                                     // FileAttributes
                 FILE_SHARE_READ,                       // ShareAccess
                 createDisposition,
                 FILE_NON_DIRECTORY_FILE |              // CreateOptions
                    FILE_OPEN_REPARSE_POINT |
                    FILE_SYNCHRONOUS_IO_NONALERT,
                    // | FILE_COMPLETE_IF_OPLOCKED,
                 NULL,                                  // EaBuffer
                 0,                                     // EaLength
                 CreateFileTypeNone,                    // File type
                 NULL,                                  // ExtraCreateParameters
                 IO_FORCE_ACCESS_CHECK,                 // Options
                 TargetShare
                 );

    if( status == STATUS_INVALID_PARAMETER ) {
        status = SrvIoCreateFile(
                     WorkContext,
                     &targetHandle,
                     SRV_COPY_TARGET_ACCESS | SYNCHRONIZE,  // DesiredAccess
                     &targetObjectAttributes,
                     &ioStatusBlock,
                     NULL,                                  // AllocationSize
                     0,                                     // FileAttributes
                     FILE_SHARE_READ,                       // ShareAccess
                     createDisposition,
                     FILE_NON_DIRECTORY_FILE |              // CreateOptions
                        FILE_SYNCHRONOUS_IO_NONALERT,
                        // | FILE_COMPLETE_IF_OPLOCKED,
                     NULL,                                  // EaBuffer
                     0,                                     // EaLength
                     CreateFileTypeNone,                    // File type
                     NULL,                                  // ExtraCreateParameters
                     IO_FORCE_ACCESS_CHECK,                 // Options
                     TargetShare
                     );
    }


    //
    // If the open failed because the target is a directory, and we didn't
    // know that it was supposed to be a file, then concatenate the
    // source base name to the target and retry the open.
    //
    // !!! NOT THE CORRECT STATUS CODE.  It should be something like
    //     STATUS_FILE_IS_DIRECTORY.

    if ( status == STATUS_INVALID_PARAMETER &&
         !( *SmbFlags & SMB_TARGET_IS_FILE ) &&
         !( *SmbFlags & SMB_TARGET_IS_DIRECTORY ) ) {

        //
        // Set the flags so that future calls to this routine will do
        // the right thing first time around.
        //

        *SmbFlags |= SMB_TARGET_IS_DIRECTORY;

        SrvGetBaseFileName( Source, &sourceBaseName );

        SrvAllocateAndBuildPathName(
            Target,
            &sourceBaseName,
            NULL,
            &targetName
            );

        if ( targetName.Buffer == NULL ) {
            status = STATUS_INSUFF_SERVER_RESOURCES;
            goto copy_done;
        }

        targetObjectAttributes.ObjectName = &targetName;

        IF_SMB_DEBUG(FILE_CONTROL2) {
            SrvPrint1( "Opening target: %wZ\n", targetObjectAttributes.ObjectName );
        }

        INCREMENT_DEBUG_STAT( SrvDbgStatistics.TotalOpenAttempts );
        INCREMENT_DEBUG_STAT( SrvDbgStatistics.TotalOpensForPathOperations );

        //
        // !!! Currently we can't specify complete if oplocked, because
        //     this won't break a batch oplock.  Unfortunately this also
        //     means that we can't timeout the open (if the oplock break
        //     takes too long) and fail this SMB gracefully.
        //

        status = SrvIoCreateFile(
                     WorkContext,
                     &targetHandle,
                     SRV_COPY_TARGET_ACCESS | SYNCHRONIZE,  // DesiredAccess
                     &targetObjectAttributes,
                     &ioStatusBlock,
                     NULL,                                  // AllocationSize
                     0,                                     // FileAttributes
                     FILE_SHARE_READ,                       // ShareAccess
                     createDisposition,
                     FILE_NON_DIRECTORY_FILE |              // CreateOptions
                        FILE_OPEN_REPARSE_POINT |
                        FILE_SYNCHRONOUS_IO_NONALERT,
                     NULL,                                  // EaBuffer
                     0,                                     // EaLength
                     CreateFileTypeNone,                    // File Type
                     NULL,                                  // ExtraCreateParameters
                     IO_FORCE_ACCESS_CHECK,                 // Options
                     TargetShare
                     );

        if( status == STATUS_INVALID_PARAMETER ) {
            status = SrvIoCreateFile(
                         WorkContext,
                         &targetHandle,
                         SRV_COPY_TARGET_ACCESS | SYNCHRONIZE,  // DesiredAccess
                         &targetObjectAttributes,
                         &ioStatusBlock,
                         NULL,                                  // AllocationSize
                         0,                                     // FileAttributes
                         FILE_SHARE_READ,                       // ShareAccess
                         createDisposition,
                         FILE_NON_DIRECTORY_FILE |              // CreateOptions
                            FILE_SYNCHRONOUS_IO_NONALERT,
                         NULL,                                  // EaBuffer
                         0,                                     // EaLength
                         CreateFileTypeNone,                    // File Type
                         NULL,                                  // ExtraCreateParameters
                         IO_FORCE_ACCESS_CHECK,                 // Options
                         TargetShare
                         );
        }

    }

    if ( targetHandle != NULL ) {
        SRVDBG_CLAIM_HANDLE( targetHandle, "CPY", 5, 0 );
    }

    //
    // Is the target is a directory, and the copy move is append if exists,
    // create if the file does not exist, fail the request.  We must do
    // this, because we have no way of knowing whether the original request
    // expects us append to the file, or truncate it.
    //

    if ( (*SmbFlags & SMB_TARGET_IS_DIRECTORY) &&
         ((SmbOpenFunction & SMB_OFUN_OPEN_MASK) == SMB_OFUN_OPEN_OPEN) &&
         ((SmbOpenFunction & SMB_OFUN_CREATE_MASK) == SMB_OFUN_CREATE_CREATE)) {

        status = STATUS_OS2_CANNOT_COPY;
        goto copy_done;

    }

    //
    // If the user didn't have this permission, update the statistics
    // database.
    //

    if ( status == STATUS_ACCESS_DENIED ) {
        SrvStatistics.AccessPermissionErrors++;
    }

    ASSERT( status != STATUS_OPLOCK_BREAK_IN_PROGRESS );

    if ( !NT_SUCCESS(status) ) {

        IF_DEBUG(ERRORS) {
            SrvPrint1( "Unable to open target: %X\n", status );
        }

        goto copy_done;
    }

    SrvStatistics.TotalFilesOpened++;

    //
    // Copy the source to the target handle just opened.
    //

    status = SrvCopyFile(
                 SourceHandle,
                 targetHandle,
                 SmbOpenFunction,
                 *SmbFlags,
                 (ULONG)ioStatusBlock.Information          // TargetOpenAction
                 );

    if ( !NT_SUCCESS(status) ) {
        IF_DEBUG(ERRORS) {
            SrvPrint1( "SrvCopyFile failed, status = %X\n", status );
        }
    }

copy_done:

    if ( targetName.Buffer != NULL ) {
        FREE_HEAP( targetName.Buffer );
    }

    if ( targetHandle != NULL ) {
        SRVDBG_RELEASE_HANDLE( targetHandle, "CPY", 10, 0 );
        SrvNtClose( targetHandle, TRUE );
    }

    return status;

} // DoCopy


NTSTATUS
DoRename (
    IN PWORK_CONTEXT WorkContext,
    IN PUNICODE_STRING Source,
    IN HANDLE SourceHandle,
    IN PUNICODE_STRING Target,
    IN PSHARE TargetShare,
    IN USHORT SmbOpenFunction,
    IN OUT PUSHORT SmbFlags,
    IN BOOLEAN FailIfTargetIsDirectory,
    IN USHORT InformationLevel,
    IN ULONG ClusterCount
    )

/*++

Routine Description:

    This routine does the actual rename of an open file.  The target may
    be a file or directory, but is bound by the constraints of SmbFlags.
    If SmbFlags does not indicate what the target is, then it is first
    assumed to be a file; if this fails, then the rename if performed
    again with the target as the original target string plus the source
    base name.

    *** If the source and target are on different volumes, then this
        routine will fail.  We could make this work by doing a copy
        then delete, but this seems to be of limited usefulness and
        possibly incorrect due to the fact that a big file would take
        a long time, something the user would not expect.

Arguments:

    WorkContext - a pointer to the work context block for this operation
        used for an impersonation.

    Source - the name of the source file relative to its share.

    SourceHandle - the handle to the source file.

    Target - the name of the target file relative to its share.

    TargetShare - the share of the target file.  The RootDirectoryHandle
        field is used for a relative rename.

    SmbOpenFunction - describes whether we are allowed to overwrite an
        existing file.

    SmbFlags - can tell if the target is a file, directory, or unknown.
        This routine writes the true information into the location if
        it is unknown.

    FailIfTargetIsDirectory - if TRUE and the target already exists as
        a directory, fail the operation.  Otherwise, rename the file
        into the directory.

    InformationLevel - Rename/CopyOnWrite/Link/MoveCluster

    ClusterCount - MoveCluster count

Return Value:

    Status.

--*/

{
    NTSTATUS status;
    IO_STATUS_BLOCK ioStatusBlock;
    PFILE_RENAME_INFORMATION fileRenameInformation;
    ULONG renameBlockSize;
    USHORT NtInformationLevel;
    UNICODE_STRING sourceBaseName;
    UNICODE_STRING targetBaseName;
    PWCH s, es;

    PAGED_CODE( );

    //
    // Allocate enough heap to hold a FILE_RENAME_INFORMATION block and
    // the target file name.  Allocate enough extra to hold the source
    // name in case the target turns out to be a directory and we have
    // to concatenate the source and target.
    //

    renameBlockSize = sizeof(FILE_RENAME_INFORMATION) + Target->Length +
                          Source->Length;

    fileRenameInformation = ALLOCATE_HEAP_COLD(
                                renameBlockSize,
                                BlockTypeDataBuffer
                                );

    if ( fileRenameInformation == NULL ) {

        IF_DEBUG(ERRORS) {
            SrvPrint0( "SrvMoveFile: Unable to allocate heap.\n" );
        }

        return STATUS_INSUFF_SERVER_RESOURCES;

    }

    //
    // Get the Share root handle.
    //

    status = SrvGetShareRootHandle( TargetShare );

    if ( !NT_SUCCESS(status) ) {

        IF_DEBUG(ERRORS) {
            SrvPrint1( "DoRename: SrvGetShareRootHandle failed. %X\n", status );
        }

        FREE_HEAP( fileRenameInformation );
        return(status);
    }

    //
    // Set up the rename block.
    //

    if (InformationLevel == SMB_NT_RENAME_MOVE_CLUSTER_INFO) {
        ((FILE_MOVE_CLUSTER_INFORMATION *)fileRenameInformation)->ClusterCount =
            ClusterCount;
    } else {
        fileRenameInformation->ReplaceIfExists =
            SmbOfunTruncate( SmbOpenFunction );
    }

    fileRenameInformation->RootDirectory = TargetShare->RootDirectoryHandle;

    //
    // If the target file has wildcards, expand name.
    //

    if ( FsRtlDoesNameContainWildCards( Target ) ) {

        ULONG tempUlong;
        UNICODE_STRING newTargetBaseName;

        if (InformationLevel != SMB_NT_RENAME_RENAME_FILE) {
            return(STATUS_OBJECT_PATH_SYNTAX_BAD);
        }

        //
        // Get source and target filenames.  The target filename is to be
        // used as a template for wildcard expansion.
        //

        SrvGetBaseFileName( Source, &sourceBaseName );
        SrvGetBaseFileName( Target, &targetBaseName );

        tempUlong = sourceBaseName.Length + targetBaseName.Length;
        newTargetBaseName.Length = (USHORT)tempUlong;
        newTargetBaseName.MaximumLength = (USHORT)tempUlong;
        newTargetBaseName.Buffer = ALLOCATE_NONPAGED_POOL(
                                            tempUlong,
                                            BlockTypeDataBuffer
                                            );

        if ( newTargetBaseName.Buffer == NULL ) {

            INTERNAL_ERROR(
                ERROR_LEVEL_EXPECTED,
                "DoRename: Unable to allocate %d bytes from nonpaged pool.\n",
                tempUlong,
                NULL
                );

            //
            // Release the share root handle if device is removable
            //

            SrvReleaseShareRootHandle( TargetShare );

            FREE_HEAP( fileRenameInformation );
            return STATUS_INSUFF_SERVER_RESOURCES;

        }

        //
        // Get expanded filename
        //

        status = SrvWildcardRename(
                    &targetBaseName,
                    &sourceBaseName,
                    &newTargetBaseName
                    );

        if ( !NT_SUCCESS( status ) ) {

            //
            // Release the share root handle if device is removable
            //

            SrvReleaseShareRootHandle( TargetShare );

            DEALLOCATE_NONPAGED_POOL( newTargetBaseName.Buffer );
            FREE_HEAP( fileRenameInformation );
            return STATUS_OBJECT_NAME_INVALID;

        }

        //
        // tempUlong is equal to the directory path without this filename
        // but including the last delimeter.
        //

        tempUlong = Target->Length - targetBaseName.Length;

        //
        // Copy the directory path (including the delimeter.
        //

        RtlCopyMemory(
            fileRenameInformation->FileName,
            Target->Buffer,
            tempUlong
            );

        s = (PWCH) ((PCHAR)fileRenameInformation->FileName + tempUlong);

        //
        // Copy the expanded file name
        //

        RtlCopyMemory(
            s,
            newTargetBaseName.Buffer,
            newTargetBaseName.Length
            );


        fileRenameInformation->FileNameLength = tempUlong +
                                                newTargetBaseName.Length;

        DEALLOCATE_NONPAGED_POOL( newTargetBaseName.Buffer );

    } else {

        fileRenameInformation->FileNameLength = Target->Length;

        RtlCopyMemory(
            fileRenameInformation->FileName,
            Target->Buffer,
            Target->Length
            );

        // Check if we can do a fast rename if they are in the same path (which is usually the case)
        SrvGetBaseFileName( Source, &sourceBaseName );
        SrvGetBaseFileName( Target, &targetBaseName );


       if ((Source->Length - sourceBaseName.Length) == (Target->Length - targetBaseName.Length)) {
          ULONG i;
          PWCH sptr,tptr;

          i = Source->Length - sourceBaseName.Length;
          i=i>>1;

          sptr = &Source->Buffer[i-1];
          tptr = &Target->Buffer[i-1];

          while ( i > 0) {
             if (*sptr-- != *tptr--) {
                goto no_match;
             }
             i--;
          }

          // If the names matched, we're set for a quick rename (where the directory is not needed,
          // since they are in the same path)
          fileRenameInformation->RootDirectory = NULL;

          fileRenameInformation->FileNameLength = targetBaseName.Length;

          RtlCopyMemory(
              fileRenameInformation->FileName,
              targetBaseName.Buffer,
              targetBaseName.Length
              );
       }
    }

no_match:

    //
    // If we know that the target is a directory, then concatenate the
    // source base name to the end of the target name.
    //

    if ( *SmbFlags & SMB_TARGET_IS_DIRECTORY ) {

        SrvGetBaseFileName( Source, &sourceBaseName );

        s = (PWCH)((PCHAR)fileRenameInformation->FileName +
                                    fileRenameInformation->FileNameLength);

        //
        // Only add in a directory separator if the target had some path
        // information.  This avoids having a new name like "\NAME", which
        // is illegal with a relative rename (there should be no
        // leading backslash).
        //

        if ( Target->Length > 0 ) {
            *s++ = DIRECTORY_SEPARATOR_CHAR;
        }

        RtlCopyMemory( s, sourceBaseName.Buffer, sourceBaseName.Length );

        fileRenameInformation->FileNameLength +=
                                sizeof(WCHAR) + sourceBaseName.Length;
    }

    //
    // Call NtSetInformationFile to actually rename the file.
    //

    IF_SMB_DEBUG(FILE_CONTROL2) {
        UNICODE_STRING name;
        name.Length = (USHORT)fileRenameInformation->FileNameLength;
        name.Buffer = fileRenameInformation->FileName;
        SrvPrint2( "Renaming %wZ to %wZ\n", Source, &name );
    }
    switch (InformationLevel) {
    case SMB_NT_RENAME_RENAME_FILE:
        NtInformationLevel = FileRenameInformation;

        //
        // If we are renaming a substream, we do not supply
        //  fileRenameInformation->RootDirectory
        //
        es = fileRenameInformation->FileName +
                fileRenameInformation->FileNameLength / sizeof( WCHAR );

        for( s = fileRenameInformation->FileName; s < es; s++ ) {
            if( *s == L':' ) {
                fileRenameInformation->RootDirectory = 0;
                break;
            }
        }
        break;

    case SMB_NT_RENAME_MOVE_CLUSTER_INFO:
        NtInformationLevel = FileMoveClusterInformation;
        break;

    case SMB_NT_RENAME_SET_LINK_INFO:
        NtInformationLevel = FileLinkInformation;
        break;

    default:
        ASSERT(FALSE);
    }

    status = IMPERSONATE( WorkContext );

    if( NT_SUCCESS( status ) ) {
        status = NtSetInformationFile(
                     SourceHandle,
                     &ioStatusBlock,
                     fileRenameInformation,
                     renameBlockSize,
                     NtInformationLevel
                     );

        //
        // If the media was changed and we can come up with a new share root handle,
        //  then we should retry the operation
        //
        if( SrvRetryDueToDismount( TargetShare, status ) ) {

            fileRenameInformation->RootDirectory = TargetShare->RootDirectoryHandle;

            status = NtSetInformationFile(
                     SourceHandle,
                     &ioStatusBlock,
                     fileRenameInformation,
                     renameBlockSize,
                     NtInformationLevel
                     );
        }

        REVERT( );
    }

    if ( NT_SUCCESS(status) ) {
        status = ioStatusBlock.Status;
        SrvRemoveCachedDirectoryName( WorkContext, Source );
    }

    //
    // If the status was STATUS_OBJECT_NAME_COLLISION then the target
    // already existed as a directory.  Unless the target name was
    // supposed to indicate a file or we have already tried used the
    // source name, retry by concatenating the source base name to the
    // target.
    //

    if ( status == STATUS_OBJECT_NAME_COLLISION &&
         !FailIfTargetIsDirectory &&
         !( *SmbFlags & SMB_TARGET_IS_FILE ) &&
         !( *SmbFlags & SMB_TARGET_IS_DIRECTORY ) ) {

        IF_SMB_DEBUG(FILE_CONTROL2) {
            SrvPrint0( "Retrying rename with source name.\n" );
        }

        //
        // Set the flags so that future calls to this routine will do
        // the right thing first time around.
        //

        *SmbFlags |= SMB_TARGET_IS_DIRECTORY;

        //
        // Generate the new target name.
        //

        SrvGetBaseFileName( Source, &sourceBaseName );

        s = (PWCH)((PCHAR)fileRenameInformation->FileName +
                                    fileRenameInformation->FileNameLength);

        *s++ = DIRECTORY_SEPARATOR_CHAR;

        RtlCopyMemory( s, sourceBaseName.Buffer, sourceBaseName.Length );

        fileRenameInformation->FileNameLength +=
                                sizeof(WCHAR) + sourceBaseName.Length;

        //
        // Do the rename again.  If it fails this time, too bad.
        //
        // *** Note that it may fail because the source and target
        //     exist on different volumes.  This could potentially
        //     cause confusion for DOS clients in the presence of
        //     links.

        IF_SMB_DEBUG(FILE_CONTROL2) {
            UNICODE_STRING name;
            name.Length = (USHORT)fileRenameInformation->FileNameLength;
            name.Buffer = fileRenameInformation->FileName;
            SrvPrint2( "Renaming %wZ to %wZ\n", Source, &name );
        }

        status = IMPERSONATE( WorkContext );

        if( NT_SUCCESS( status ) ) {
            status = NtSetInformationFile(
                         SourceHandle,
                         &ioStatusBlock,
                         fileRenameInformation,
                         renameBlockSize,
                         NtInformationLevel
                         );

            //
            // If the media was changed and we can come up with a new share root handle,
            //  then we should retry the operation
            //
            if( SrvRetryDueToDismount( TargetShare, status ) ) {

                fileRenameInformation->RootDirectory = TargetShare->RootDirectoryHandle;

                status = NtSetInformationFile(
                             SourceHandle,
                             &ioStatusBlock,
                             fileRenameInformation,
                             renameBlockSize,
                             NtInformationLevel
                             );
            }

            REVERT( );
        }

        if ( NT_SUCCESS(status) ) {
            status = ioStatusBlock.Status;
        }
    }

    //
    // Release the share root handle if device is removable
    //

    SrvReleaseShareRootHandle( TargetShare );

    FREE_HEAP( fileRenameInformation );

    if ( !NT_SUCCESS(status) ) {

        IF_DEBUG(ERRORS) {
            SrvPrint1( "DoRename: NtSetInformationFile failed, status = %X\n",
                          status );
        }
    }

    return status;

} // DoRename
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\srv\persist.h ===
/*++ BUILD Version: 0003    // Increment this if a change has global effects

Copyright (c) 1989  Microsoft Corporation

Module Name:

    persist.h

Abstract:

    This module defines the header for data blocks maintained by the
    SMB server in it's persistent handle state file that is associated with
    persistent-handle enabled shares.

Author:

    Andy Herron (andyhe) 3-Nov-1999

Revision History:

--*/

#ifndef _SRVPERSIST_
#define _SRVPERSIST_

typedef enum _PERSISTENT_OPERATION {
    PersistentFreeSpace,
    PersistentConnection,
    PersistentSession,
    PersistentUserName,
    PersistentFileOpen,
    PersistentByteLock
} PERSISTENT_OPERATION, *PPERSISTENT_OPERATION;

typedef enum _PERSISTENT_STATE {
    PersistentStateFreed,
    PersistentStateActive,
    PersistentStateInError,
    PersistentStateClosed
} PERSISTENT_STATE, *PPERSISTENT_STATE;

//
//  Types of blocks that are saved in the persistent state file are as follows:
//
//  Share block    - single one at offset 0 in the file
//  Connection     - one per connection that has persistent handles
//  Session        - one per session that has persistent handles
//  PersistentFile - one per file that is opened persistently
//  ByteRangeLock  - one per byte range lock that is held on persistent file
//

typedef struct _PERSISTENT_FILE_HEADER {

    ULONG   ConsistencyCheck;
    ULONG   FileSize;
    ULONG   HeaderSize;
    ULONG   RecordSize;
    ULONG   NumberOfRecords;

    LARGE_INTEGER   ServerStartTime;
    LARGE_INTEGER   CreateTime;
    LARGE_INTEGER   TimeClosed;
    BOOLEAN         ClosedCleanly;

} PERSISTENT_FILE_HEADER, *PPERSISTENT_FILE_HEADER;

//
//  The following structures map out the specific types of persistent records
//  we have in the state file.  We lay them out this way rather than just
//  as sub-structures within the PERSISTENT_RECORD structure so that we can
//  accurately guage how big the largest substructure is for the SID records.
//

typedef struct _PERSISTENT_CONNECTION {

    ULONG           ClientId;               // shared with client
    PCONNECTION     Connection;             // actual pointer back to our connection

    BOOLEAN         DirectHostIpx;

    union {
        ULONG ClientIPAddress;
        TDI_ADDRESS_IPX IpxAddress;
    };

    CHAR OemClientMachineName[COMPUTER_NAME_LENGTH+1];
};

typedef struct _PERSISTENT_SESSION {

    ULONG           ClientId;
    PSESSION        Session;

    ULONG           SessionNumber;         // sent to client during session setup
    LARGE_INTEGER   CreateTime;            // ditto
    USHORT          Uid;                   // ditto

    LARGE_INTEGER   LogOffTime;            // for forced logoff
    LARGE_INTEGER   KickOffTime;           // for forced logoff

    ULONG           UserNameRecord;        // offset to record for this user's name
};

typedef struct _PERSISTENT_OPEN {

    ULONG           ClientId;
    ULONG           SessionNumber;

    PRFCB           Rfcb;
    ULONG           PersistentFileId;

    LARGE_INTEGER   FileReferenceNumber;    // instead of file name
    LARGE_INTEGER   UsnValue;               // ensure correct file

    BOOLEAN         CompatibilityOpen;      // from MFCB
    ULONG           OpenFileAttributes;     // from MFCB

    ULONG           FileMode;               // from LFCB
    ULONG           JobId;                  // from LFCB

    CLONG           FcbOpenCount;           // from RFCB
    USHORT          Fid;                    // from RFCB
    USHORT          Pid;                    // from RFCB
    USHORT          Tid;                    // tree ID for this open
    ACCESS_MASK     GrantedAccess;          // from RFCB
    ULONG           ShareAccess;            // from RFCB
    OPLOCK_STATE    OplockState;            // from RFCB
};

typedef struct _PERSISTENT_BYTELOCK {

    ULONG           ClientId;
    PBYTELOCK       ByteLock;

    ULONG           PersistentFileId;
    LARGE_INTEGER   LockOffset;
    LARGE_INTEGER   LockLength;
    BOOLEAN         Exclusive;
};

#define LARGEST_PERSISTENT_RECORD _PERSISTENT_OPEN

#define PERSISTENT_USER_NAME_BUFFER_LENGTH ( sizeof( struct LARGEST_PERSISTENT_RECORD ) - (3 * sizeof(ULONG)) )

typedef struct _PERSISTENT_USER_NAME {
    //
    //  we store the user's name and domain name in a series of records,
    //  though typically it should fit in one.
    //

    ULONG   RecordLength;               // number of valid bytes in Buffer
    ULONG   ContinuationRecord;         // offset within file to next part of SID, 0 if at end

    UCHAR   Buffer[ PERSISTENT_USER_NAME_BUFFER_LENGTH ];
};

//
//  These are the records we log to the state file.  They're all the same
//  length to make processing more efficient.
//

typedef struct _PERSISTENT_RECORD {

    ULONG                   PersistConsistencyCheck;    // must be first dword
    ULONG                   PersistIndex;
    PERSISTENT_STATE        PersistState;
    PERSISTENT_OPERATION    PersistOperation;

    union {
        struct _PERSISTENT_CONNECTION Connection;

        struct _PERSISTENT_SESSION Session;

        struct _PERSISTENT_OPEN FileOpen;

        struct _PERSISTENT_BYTELOCK ByteLock;

        struct _PERSISTENT_USER_NAME UserName;
    };

} PERSISTENT_RECORD, *PPERSISTENT_RECORD;

#endif // #ifndef _SRVPERSIST
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\srv\persist.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    persist.c

Abstract:

    This module contains routines for handling the state file for persistent
    file handles.

Author:

    Andy Herron (andyhe) 17-Nov-1999

Revision History:

--*/

#include "precomp.h"
#include "persist.tmh"
#pragma hdrstop

//
//  structures specific to this module only.
//

#ifdef INCLUDE_SMB_PERSISTENT

typedef enum _FLUSH_STATE {
    FlushStateNotPosted,
    FlushStatePosted,
    FlushStateCompleted,
    FlushStateInError
} FLUSH_STATE, *PFLUSH_STATE;

typedef struct _PERSISTENT_RECORD_LIST_ENTRY {

    LIST_ENTRY      PendingListEntry;
    ULONG           FileOffset;
    FLUSH_STATE     FlushState;
    PWORK_CONTEXT   WorkContext;
    PERSISTENT_RECORD;

} PERSISTENT_RECORD_LIST_ENTRY, *PPERSISTENT_RECORD_LIST_ENTRY;

#define INITIAL_BITMAP_LENGTH   512

typedef struct _PERSISTENT_SHARE_INFO {

    PSHARE          Share;

    LIST_ENTRY      UpdatesPendingList;

    UNICODE_STRING  StateFileName;

    HANDLE          FileHandle;

    RTL_BITMAP      BitMap;
    ULONG           TotalEntries;
    ULONG           FreeEntries;
    ULONG           HintIndex;

    ULONG           LastIdAccepted;
    ULONG           LastIdCommitted;

    SRV_LOCK        Lock;

    ULONG           FirstRecord;

    WCHAR           NameBuffer[1];

} PERSISTENT_SHARE_INFO, *PPERSISTENT_SHARE_INFO;

#define BITMAP_TO_STATE_FILE_INDEX( _shareInfo, _index ) \
    ( (_shareInfo)->FirstRecord + ((_index) * sizeof( PERSISTENT_RECORD )))

PPERSISTENT_RECORD_LIST_ENTRY
SrvGetPersistentRecord (
    IN PWORK_CONTEXT WorkContext
    );

VOID
SrvFreePersistentRecord (
    PPERSISTENT_RECORD_LIST_ENTRY Record
    );

NTSTATUS
SrvPostPersistentRecord (
    IN PWORK_CONTEXT WorkContext,
    IN PPERSISTENT_RECORD_LIST_ENTRY PersistentState,
    OUT PULONG  TransactionId
    );

NTSTATUS
SrvFlushPersistentRecords (
    IN PWORK_CONTEXT WorkContext,
    IN ULONG  TransactionId
    );

NTSTATUS
SrvPersistSession(
    IN PWORK_CONTEXT     WorkContext,
    PPERSISTENT_RECORD_LIST_ENTRY    PersistentState,
    ULONG               *SessionId,
    ULONG               *ClientId
    );

NTSTATUS
SrvPersistConnection(
    IN PWORK_CONTEXT     WorkContext,
    PPERSISTENT_RECORD_LIST_ENTRY    PersistentState,
    ULONG               *ClientId
    );

unsigned long
Crc32(
    IN unsigned long cbBuffer,
    IN unsigned char *pbBuffer
    );

#if 0
VOID
Crc32(  unsigned long dwCrc,
        unsigned long cbBuffer,
        LPVOID pvBuffer,
        unsigned long *pNewCrc);
#endif

#ifdef ALLOC_PRAGMA
#pragma alloc_text( PAGE, SrvPostPersistentOpen )
#pragma alloc_text( PAGE, SrvPersistSession )
#pragma alloc_text( PAGE, SrvPersistConnection )
#pragma alloc_text( PAGE, SrvGetPersistentRecord )
#pragma alloc_text( PAGE, SrvPostPersistentRecord )
#pragma alloc_text( PAGE, SrvFlushPersistentRecords )
#pragma alloc_text( PAGE, SrvSetupPersistentShare )
#pragma alloc_text( PAGE, SrvClosePersistentShare )
#pragma alloc_text( PAGE, Crc32 )
#endif


SMB_STATUS
SrvPostPersistentOpen (
    IN OUT PWORK_CONTEXT WorkContext,
    IN SMB_STATUS SmbStatus
    )

/*++

Routine Description:

    Writes an open for the given RFCB to the state file.

Arguments:

    WorkContext - has the RFCB

    SmbStatus   - status that the calling routine wants to pass back to
                  SrvProcessSmb et al.

Return Value:

    Return value to pass back to SrvProcessSmb et al.

--*/

{
    PPERSISTENT_RECORD_LIST_ENTRY persistentRecord = NULL;
    ULONG   clientId;
    ULONG   sessionId;
    NTSTATUS status;
    PRFCB rfcb = WorkContext->Rfcb;
    PLFCB lfcb = rfcb->Lfcb;
    PMFCB mfcb = lfcb->Mfcb;
    ULONG  transactionId;

    PAGED_CODE( );

    if (WorkContext->Session == NULL ||
        WorkContext->Session->PersistentId == 0 ||
        lfcb->TreeConnect->Share->PersistentState == PersistentStateInError) {

        IF_DEBUG(PERSISTENT) {
            KdPrint(( "SrvPostPersistOpen: session 0x%x doesn't support persistent handles.\n", WorkContext->Session ));
        }

        return SmbStatus;
    }

    persistentRecord = SrvGetPersistentRecord( WorkContext );

    if (persistentRecord == NULL) {

        IF_DEBUG(PERSISTENT) {
            KdPrint(( "SrvPostPersistOpen: Unable to allocate record for 0x%lx\n", WorkContext ));
        }
        return SmbStatus;
    }

    IF_DEBUG(PERSISTENT) {
        KdPrint(( "SrvPostPersistOpen: Post persistent open wc=0x%lx, record 0x%lx\n",
                    WorkContext, persistentRecord ));
    }

    status = SrvPersistSession( WorkContext,
                                persistentRecord,
                                &sessionId,
                                &clientId
                                );

    if (!NT_SUCCESS(status)) {

        IF_DEBUG(PERSISTENT) {
            KdPrint(( "SrvPostPersistOpen: failed to persist sess, status 0x%lx\n", status ));
        }
        SrvFreePersistentRecord( persistentRecord );

        return SmbStatus;
    }

    ASSERT( clientId != 0 );
    ASSERT( sessionId != 0 );
    ASSERT( rfcb != NULL );

    if (rfcb->PagedRfcb->PersistentId == 0) {

        ACQUIRE_LOCK( &rfcb->Lfcb->Mfcb->NonpagedMfcb->Lock );

        if (rfcb->PagedRfcb->PersistentId == 0) {

            LONG uniqueId = 0;

            while (uniqueId == 0) {
                uniqueId = InterlockedIncrement( &SrvGlobalPersistentRfcbId );
            }

            rfcb->PagedRfcb->PersistentId = uniqueId;
            rfcb->PagedRfcb->PersistentState = PersistentStateActive;
        }
        RELEASE_LOCK( &rfcb->Lfcb->Mfcb->NonpagedMfcb->Lock );
    }

    //
    //  now setup the persistent record as it should exist on disk for this
    //  file open.
    //

    persistentRecord->PersistState              = PersistentStateActive;
    persistentRecord->PersistOperation          = PersistentFileOpen;

    persistentRecord->FileOpen.ClientId         = clientId;
    persistentRecord->FileOpen.SessionNumber    = sessionId;

    persistentRecord->FileOpen.Rfcb             = rfcb;
    persistentRecord->FileOpen.PersistentFileId = rfcb->PagedRfcb->PersistentId;

    persistentRecord->FileOpen.FileMode         = lfcb->FileMode;
    persistentRecord->FileOpen.JobId            = lfcb->JobId;

    persistentRecord->FileOpen.FcbOpenCount     = rfcb->PagedRfcb->FcbOpenCount;
    persistentRecord->FileOpen.Fid              = rfcb->Fid;
    persistentRecord->FileOpen.Pid              = rfcb->Pid;
    persistentRecord->FileOpen.Tid              = rfcb->Tid;
    persistentRecord->FileOpen.GrantedAccess    = rfcb->GrantedAccess;
    persistentRecord->FileOpen.ShareAccess      = rfcb->ShareAccess;
    persistentRecord->FileOpen.OplockState      = rfcb->OplockState;

    persistentRecord->FileOpen.CompatibilityOpen = mfcb->CompatibilityOpen;
    persistentRecord->FileOpen.OpenFileAttributes= mfcb->NonpagedMfcb->OpenFileAttributes;

    status = SrvIssueQueryUsnInfoRequest( rfcb,
                                          FALSE,
                                          &persistentRecord->FileOpen.UsnValue,
                                          &persistentRecord->FileOpen.FileReferenceNumber );

    //
    //  Save off the current state of the workcontext within the workcontext.
    //

    WorkContext->Parameters.MakePersistent.ResumeSmbStatus = SmbStatus;
    WorkContext->Parameters.MakePersistent.FspRestartRoutine = WorkContext->FspRestartRoutine;
    WorkContext->Parameters.MakePersistent.FsdRestartRoutine = WorkContext->FsdRestartRoutine;

    WorkContext->FsdRestartRoutine = SrvQueueWorkToFspAtDpcLevel;
//  WorkContext->FspRestartRoutine = SrvRestartWritePersistentOpen;

    status = SrvPostPersistentRecord(   WorkContext,
                                        persistentRecord,
                                        &transactionId
                                        );

    if (NT_SUCCESS(status)) {

        status = SrvFlushPersistentRecords( WorkContext, transactionId );

        if (NT_SUCCESS(status)) {

            return SmbStatusInProgress;

        } else {
            IF_DEBUG(PERSISTENT) {
                KdPrint(( "SrvPostPersistOpen: failed to flush record, status 0x%lx\n", status ));
            }
        }
    } else {
        IF_DEBUG(PERSISTENT) {
            KdPrint(( "SrvPostPersistOpen: failed to post record, status 0x%lx\n", status ));
        }
    }

    WorkContext->FsdRestartRoutine = WorkContext->Parameters.MakePersistent.FsdRestartRoutine;
    WorkContext->FspRestartRoutine = WorkContext->Parameters.MakePersistent.FspRestartRoutine;

    // whoops, something didn't go right.  clean up.

    SrvFreePersistentRecord( persistentRecord );

    return SmbStatus;

} // SrvPostPersistentOpen

NTSTATUS
SrvPersistSession(
    IN PWORK_CONTEXT        WorkContext,
    PPERSISTENT_RECORD_LIST_ENTRY PersistentState,
    ULONG                   *SessionId,
    ULONG                   *ClientId
    )
{
    PPERSISTENT_RECORD_LIST_ENTRY persistentRecord = NULL;
    ULONG   sessionId;
    NTSTATUS status;
    PSESSION session = WorkContext->Session;
    PCONNECTION connection = WorkContext->Connection;
    BOOLEAN createRecord = FALSE;
    PAGED_CODE( );

    ASSERT(session != NULL);
    ASSERT(session->PersistentId != 0);

    if (session->PersistentState == PersistentStateFreed) {

        ACQUIRE_LOCK( &connection->Lock );

        if (session->PersistentState == PersistentStateFreed) {

            session->PersistentState = PersistentStateActive;
            createRecord = TRUE;
        }
        RELEASE_LOCK( &connection->Lock );
    }

    //
    //  if there's not already a record for this session, create one now
    //

    if (createRecord) {

        persistentRecord = SrvGetPersistentRecord( WorkContext );

        if (persistentRecord == NULL) {

            IF_DEBUG(PERSISTENT) {
                KdPrint(( "SrvPersistSession: Unable to allocate record for 0x%lx\n", WorkContext ));
            }
            status = STATUS_INSUFF_SERVER_RESOURCES;
            goto exitPersistSession;
        }

        IF_DEBUG(PERSISTENT) {
            KdPrint(( "SrvPersistSession: persistent sess 0x%lx, record 0x%lx\n",
                        session, persistentRecord ));
        }

        status = SrvPersistConnection(  WorkContext,
                                        PersistentState,
                                        ClientId
                                        );

        if (!NT_SUCCESS(status)) {

            IF_DEBUG(PERSISTENT) {
                KdPrint(( "SrvPersistSession: failed to persist conn, status 0x%lx\n", status ));
            }
            goto exitPersistSession;
        }

        //
        //  now setup the persistent record as it should exist on disk for this
        //  file open.
        //

        persistentRecord->PersistState              = PersistentStateActive;
        persistentRecord->PersistOperation          = PersistentSession;

        persistentRecord->Session.ClientId          = *ClientId;
        persistentRecord->Session.Session           = session;

        persistentRecord->Session.SessionNumber     = session->PersistentId;
        persistentRecord->Session.Uid               = session->Uid;

        persistentRecord->Session.CreateTime.QuadPart = session->StartTime.QuadPart;

        persistentRecord->Session.LogOffTime.QuadPart = session->LogOffTime.QuadPart;
        persistentRecord->Session.KickOffTime.QuadPart = session->KickOffTime.QuadPart;


        //
        //  now we add this record onto the list of pending state file updates.
        //

        InsertTailList( &PersistentState->PendingListEntry,
                        &persistentRecord->PendingListEntry );

        // now it's time to copy the user's name and domain name to the
        // entries going out to the state file.

        {
            ULONG   totalLength;
            ULONG   lengthNameCopiedSoFar = 0;
            ULONG   lengthCopiedSoFar = 0;

            totalLength = session->NtUserName.Length +
                          session->NtUserDomain.Length +
                          sizeof(WCHAR) ;

            while (lengthCopiedSoFar < totalLength) {

                PPERSISTENT_RECORD_LIST_ENTRY persistentName;
                ULONG      bufferRemaining;
                PWCHAR     nextAvailable;

                persistentName = SrvGetPersistentRecord( WorkContext );

                if (persistentName == NULL) {

                    IF_DEBUG(PERSISTENT) {
                        KdPrint(( "SrvPersistSession: Unable to allocate name record for 0x%lx\n", WorkContext ));
                    }
                    status = STATUS_INSUFF_SERVER_RESOURCES;
                    goto exitPersistSession;
                }

                persistentName->PersistState          = PersistentStateActive;
                persistentName->PersistOperation      = PersistentUserName;

                persistentName->UserName.ContinuationRecord = (ULONG) -1;

                persistentName->UserName.RecordLength = totalLength - lengthCopiedSoFar;

                if (persistentName->UserName.RecordLength > PERSISTENT_USER_NAME_BUFFER_LENGTH) {

                    persistentName->UserName.RecordLength = PERSISTENT_USER_NAME_BUFFER_LENGTH;
                }

                bufferRemaining = persistentName->UserName.RecordLength;
                nextAvailable = (WCHAR *) &(persistentName->UserName.Buffer[0]);

                //
                //  first we copy in the user's domain name
                //

                if (lengthCopiedSoFar < session->NtUserDomain.Length) {

                    ULONG bytesToCopy = session->NtUserDomain.Length - lengthCopiedSoFar;

                    if (bytesToCopy > PERSISTENT_USER_NAME_BUFFER_LENGTH) {

                        bytesToCopy = PERSISTENT_USER_NAME_BUFFER_LENGTH;
                    }

                    RtlCopyMemory( nextAvailable,
                                   session->NtUserDomain.Buffer +
                                        ( lengthCopiedSoFar / sizeof(WCHAR) ),
                                   bytesToCopy );

                    nextAvailable += bytesToCopy / sizeof(WCHAR);
                    bufferRemaining -= bytesToCopy;
                    lengthCopiedSoFar += bytesToCopy;
                }

                //
                //  we separate the domain name and user name with a backslash
                //

                if (lengthCopiedSoFar == session->NtUserDomain.Length &&
                    bufferRemaining > 0) {

                    bufferRemaining -= sizeof(WCHAR);
                    *nextAvailable = L'\\';
                    nextAvailable++;
                    lengthCopiedSoFar += sizeof(WCHAR);
                }

                //
                //  lastly we copy in the user's user name
                //

                if (lengthNameCopiedSoFar < session->NtUserName.Length &&
                    bufferRemaining > 0) {

                    ULONG bytesToCopy = session->NtUserName.Length - lengthNameCopiedSoFar;

                    if (bytesToCopy > PERSISTENT_USER_NAME_BUFFER_LENGTH) {

                        bytesToCopy = PERSISTENT_USER_NAME_BUFFER_LENGTH;
                    }

                    RtlCopyMemory( nextAvailable,
                                   session->NtUserName.Buffer +
                                        ( lengthNameCopiedSoFar / sizeof(WCHAR) ),
                                   bytesToCopy );

                    lengthNameCopiedSoFar += bytesToCopy;
                    lengthCopiedSoFar += bytesToCopy;
                }

                InsertTailList( &PersistentState->PendingListEntry,
                                &persistentName->PendingListEntry );
            }
        }
    }

    *SessionId = session->PersistentId;
    *ClientId  = connection->PagedConnection->PersistentId;
    status = STATUS_SUCCESS;

exitPersistSession:

    if (status != STATUS_SUCCESS) {

        // whoops, something didn't go right.  clean up.

        *SessionId = 0;
        *ClientId  = 0;
    }
    return status;
}

NTSTATUS
SrvPersistConnection(
    IN PWORK_CONTEXT        WorkContext,
    PPERSISTENT_RECORD_LIST_ENTRY PersistentState,
    ULONG                   *ClientId
    )
{
    PPERSISTENT_RECORD_LIST_ENTRY persistentRecord = NULL;
    ULONG   clientId;
    NTSTATUS status;
    PCONNECTION connection = WorkContext->Connection;
    BOOLEAN createRecord = FALSE;

    PAGED_CODE( );

    ASSERT(connection != NULL);

    if (connection->PagedConnection->PersistentId == 0) {

        ACQUIRE_LOCK( &connection->Lock );

        if (connection->PagedConnection->PersistentId == 0) {

            LONG uniqueId = 0;

            while (uniqueId == 0) {
                uniqueId = InterlockedIncrement( &SrvGlobalPersistentSessionId );
            }

            connection->PagedConnection->PersistentId = uniqueId;
            connection->PagedConnection->PersistentState = PersistentStateActive;
            createRecord = TRUE;
        }
        RELEASE_LOCK( &connection->Lock );
    }

    //
    //  if there's not already a record for this connection, create one now
    //

    if (createRecord) {

        persistentRecord = SrvGetPersistentRecord( WorkContext );

        if (persistentRecord == NULL) {

            IF_DEBUG(PERSISTENT) {
                KdPrint(( "SrvPersistConnection: Unable to allocate record for 0x%lx\n", WorkContext ));
            }
            status = STATUS_INSUFF_SERVER_RESOURCES;
            goto exitPersistConnection;
        }

        IF_DEBUG(PERSISTENT) {
            KdPrint(( "SrvPersistConnection: persistent conn 0x%lx, record 0x%lx\n",
                        connection, persistentRecord ));
        }

        //
        //  now setup the persistent record as it should exist on disk for this
        //  file open.
        //

        persistentRecord->PersistState              = PersistentStateActive;
        persistentRecord->PersistOperation          = PersistentConnection;

        persistentRecord->Connection.ClientId       = *ClientId;
        persistentRecord->Connection.Connection     = connection;

        persistentRecord->Connection.DirectHostIpx  = connection->DirectHostIpx;

        RtlCopyMemory( persistentRecord->Connection.OemClientMachineName,
                       connection->OemClientMachineName,
                       COMPUTER_NAME_LENGTH+1
                       );

        if (connection->DirectHostIpx) {

            RtlCopyMemory( &persistentRecord->Connection.IpxAddress,
                           &connection->IpxAddress,
                           sizeof( TDI_ADDRESS_IPX )
                           );
        } else {

            persistentRecord->Connection.ClientIPAddress = connection->ClientIPAddress;
        }

        InsertTailList( &PersistentState->PendingListEntry,
                        &persistentRecord->PendingListEntry );
    }

    *ClientId  = connection->PagedConnection->PersistentId;
    return STATUS_SUCCESS;

exitPersistConnection:
    // whoops, something didn't go right.  clean up.

    *ClientId  = 0;

    if (persistentRecord) {
        SrvFreePersistentRecord( persistentRecord );
    }

    return status;
}

PPERSISTENT_RECORD_LIST_ENTRY
SrvGetPersistentRecord (
    IN PWORK_CONTEXT WorkContext
    )
//
//  This allocates persistent state buffers that we write out to the persistent
//  state file.  Free them with SrvFreePersistentRecord.
//
{
    PPERSISTENT_RECORD_LIST_ENTRY record;

    PAGED_CODE( );

    record = ALLOCATE_HEAP( sizeof( PERSISTENT_RECORD_LIST_ENTRY ), BlockTypePersistentState );

    if (record == NULL) {

        IF_DEBUG(PERSISTENT) {
            KdPrint(( "SrvGetPersistentRecord: failed to alloc record for wc= 0x%lx\n", WorkContext ));
        }
        return NULL;
    }

    RtlZeroMemory( record, sizeof( PERSISTENT_RECORD_LIST_ENTRY ));

    InitializeListHead( &record->PendingListEntry );
    record->FileOffset = (ULONG) -1;
    record->FlushState = FlushStateNotPosted;
    record->WorkContext = WorkContext;

    IF_DEBUG(PERSISTENT) {
        KdPrint(( "SrvGetPersistentRecord: allocated record at 0x%x for wc= 0x%lx\n", record, WorkContext ));
    }

    return record;
}

VOID
SrvFreePersistentRecord (
    PPERSISTENT_RECORD_LIST_ENTRY Record
    )
{
    PPERSISTENT_RECORD_LIST_ENTRY subRecord;
    PLIST_ENTRY listEntry = Record->PendingListEntry.Flink;

    PAGED_CODE( );

    while (listEntry != &Record->PendingListEntry) {

        subRecord = CONTAINING_RECORD( listEntry, PERSISTENT_RECORD_LIST_ENTRY, PendingListEntry );

        listEntry = listEntry->Flink;

        IF_DEBUG(PERSISTENT) {
            KdPrint(( "SrvGetPersistentRecord: freed record (1) at 0x%x\n", subRecord ));
        }

        FREE_HEAP( subRecord );
    }

    IF_DEBUG(PERSISTENT) {
        KdPrint(( "SrvGetPersistentRecord: freed record (2) at 0x%x\n", Record ));
    }

    FREE_HEAP( Record );
    return;
}

NTSTATUS
SrvPostPersistentRecord (
    IN PWORK_CONTEXT WorkContext,
    IN PPERSISTENT_RECORD_LIST_ENTRY PersistentState,
    OUT PULONG  TransactionId
    )
{
    PPERSISTENT_RECORD_LIST_ENTRY record;
    ULONG numberRecordsRequired = 1;
    PLIST_ENTRY listEntry;
    PSHARE share = WorkContext->Share;
    PPERSISTENT_SHARE_INFO shareInfo;
    NTSTATUS status;
    ULONG   bitMapIndex;
    PPERSISTENT_RECORD_LIST_ENTRY firstUserNameRecord = NULL;
    PPERSISTENT_RECORD_LIST_ENTRY lastUserNameRecord = NULL;
    PPERSISTENT_RECORD_LIST_ENTRY sessionRecord = NULL;

    PAGED_CODE( );

    if (share == NULL) {

        ASSERT(WorkContext->Rfcb != NULL);
        share = WorkContext->Rfcb->Lfcb->TreeConnect->Share;
    }

    ASSERT(share != NULL);

    //
    //  determine how many records we need to write.
    //

    listEntry = PersistentState->PendingListEntry.Flink;

    while (listEntry != &PersistentState->PendingListEntry) {

        record = CONTAINING_RECORD( listEntry, PERSISTENT_RECORD_LIST_ENTRY, PendingListEntry );

        if (record->FileOffset == (ULONG) -1) {

            numberRecordsRequired++;
        }
        listEntry = listEntry->Flink;
    }

    //
    //  if the persistent state file on the share isn't set up, do so now.
    //

    if (share->PersistentStateFile == NULL) {

        status = SrvSetupPersistentShare( share, FALSE );

        if (! NT_SUCCESS(status)) {

            IF_DEBUG(PERSISTENT) {
                KdPrint(( "SrvPostPersistentRecord: error 0x%x for share 0x%x\n", status, share ));
            }

            // need to log an error here

            share->PersistentState = PersistentStateInError;
            return status;
        }

        ASSERT( share->PersistentStateFile );
    }

    shareInfo = (PPERSISTENT_SHARE_INFO) (share->PersistentStateFile);

    //
    //  if the bitmap is too small, try to double it's size.
    //

    ACQUIRE_LOCK( &shareInfo->Lock );

    if (shareInfo->FreeEntries <= numberRecordsRequired) {

        PULONG  newBuffer;
        ULONG   newSize;
        ULONG   newBits;

        //
        //  looks like our bitmap isn't big enough, let's expand it by two
        //

        if (shareInfo->BitMap.SizeOfBitMap == 0) {
            newSize = INITIAL_BITMAP_LENGTH;
        } else {
            newSize = shareInfo->BitMap.SizeOfBitMap * 2;
        }

        newBuffer = ALLOCATE_HEAP( newSize, BlockTypePersistentBitMap );

        if (newBuffer == NULL) {

            IF_DEBUG(PERSISTENT) {
                KdPrint(( "SrvGetPersistentRecord: failed to alloc record for wc= 0x%lx\n", WorkContext ));
            }
            RELEASE_LOCK( &shareInfo->Lock );
            return STATUS_INSUFF_SERVER_RESOURCES;
        }

        // optimize by only zeroing the second half of bitmap before copy.

        RtlZeroMemory( newBuffer, newSize );

        if (shareInfo->BitMap.Buffer != NULL) {

            RtlCopyMemory( newBuffer,
                           shareInfo->BitMap.Buffer,
                           shareInfo->BitMap.SizeOfBitMap
                            );
            FREE_HEAP( shareInfo->BitMap.Buffer );

            newBits = ( newSize - shareInfo->BitMap.SizeOfBitMap ) * 8;
            shareInfo->BitMap.Buffer = newBuffer;
            shareInfo->BitMap.SizeOfBitMap = newSize;

        } else {

            newBits = newSize * 8;
            RtlInitializeBitMap( &shareInfo->BitMap, newBuffer, newSize );
        }

        IF_DEBUG(PERSISTENT) {
            KdPrint(( "SrvGetPersistentRecord: new bitmap 0x%x for share 0x%lx\n",
                            newBuffer, share ));
        }

        shareInfo->FreeEntries += newBits;
        shareInfo->TotalEntries += newBits;
    }

    //
    //  for each record we need to post, find a slot in the bitmap and map it
    //  to a file index
    //

    listEntry = &PersistentState->PendingListEntry; // start at the head of the
                                                    // list which is on the first entry

    while (numberRecordsRequired > 0) {

        ULONG numberEntries = numberRecordsRequired;

        bitMapIndex = (ULONG) -1;

        while (bitMapIndex == (ULONG) -1) {

            bitMapIndex = RtlFindClearBitsAndSet( &shareInfo->BitMap,
                                                  numberEntries,
                                                  shareInfo->HintIndex );

            if (bitMapIndex == (ULONG) -1) {

                numberEntries = RtlFindLongestRunClear( &shareInfo->BitMap,
                                                        &shareInfo->HintIndex );

                if (numberEntries == 0 || numberEntries == (ULONG) -1) {

                    shareInfo->FreeEntries = 0;
                    IF_DEBUG(PERSISTENT) {
                        KdPrint(( "SrvGetPersistentRecord: bitmap is full for share 0x%lx\n", share ));
                    }
                    RELEASE_LOCK( &shareInfo->Lock );
                    return STATUS_INSUFF_SERVER_RESOURCES;
                }
            } else {
                shareInfo->HintIndex = bitMapIndex;
            }
        }

        numberRecordsRequired -= numberEntries;

        while (numberEntries > 0) {

            record = CONTAINING_RECORD( listEntry, PERSISTENT_RECORD_LIST_ENTRY, PendingListEntry );

            if (record->FileOffset == (ULONG) -1) {

                record->FileOffset = BITMAP_TO_STATE_FILE_INDEX( shareInfo, bitMapIndex );
            }
            record->PersistIndex = record->FileOffset;

            //
            //  track the file indexes in records that need to refer to
            //  other records.
            //

            if (record->PersistOperation == PersistentSession) {

                sessionRecord = record;

            } else if (record->PersistOperation == PersistentUserName) {

                //
                //  chain up the user name records into a list
                //

                if (firstUserNameRecord == NULL) {

                    firstUserNameRecord = record;

                } else {

                    lastUserNameRecord->UserName.ContinuationRecord = record->FileOffset;
                }
                lastUserNameRecord = record;
            }

            //
            //  on to next concurrent record, reduce number remaining, etc
            //

            bitMapIndex++;
            numberEntries--;
            listEntry = listEntry->Flink;
        }
    }

    //
    //  fix up the file indexes in records that need to refer to other records
    //

    if (sessionRecord != NULL) {

        sessionRecord->Session.UserNameRecord = (firstUserNameRecord != NULL) ?
                firstUserNameRecord->FileOffset  : (ULONG) -1;
    }

    //
    //  with the records now well formed, complete them by calculating the CRC
    //  values and putting them on the pending write list for the share.
    //
    //  this is a do..while since we need to be sure to pick up the first record
    //  which is also the head of the list.

    listEntry = &PersistentState->PendingListEntry;

    do {
        record = CONTAINING_RECORD( listEntry, PERSISTENT_RECORD_LIST_ENTRY, PendingListEntry );

        //  Warning :
        //  We calculate the CRC on the rest of the record excluding the CRC
        //  value itself.  If the CRC value is not stored in the first dword,
        //  this breaks!
        //
        record->PersistConsistencyCheck = Crc32(
                sizeof( PERSISTENT_RECORD_LIST_ENTRY ) - sizeof(ULONG),
                (PUCHAR)((PUCHAR)record+sizeof(ULONG)) );

        listEntry = listEntry->Flink;

        //
        //  we can add it to the updatesPending list without removing it
        //  from the linked list it's in because we're destroying the list
        //  safely as we traverse it.
        //
        InsertTailList( &shareInfo->UpdatesPendingList,
                        &record->PendingListEntry );

    } while (listEntry != &PersistentState->PendingListEntry);

    *TransactionId = ++(shareInfo->LastIdAccepted);
    RELEASE_LOCK( &shareInfo->Lock );

    return STATUS_SUCCESS;
}

NTSTATUS
SrvFlushPersistentRecords (
    IN PWORK_CONTEXT WorkContext,
    IN ULONG  TransactionId
    )
{



    return STATUS_INSUFF_SERVER_RESOURCES;
}

NTSTATUS
SrvSetupPersistentShare (
    IN OUT PSHARE Share,
    IN BOOLEAN Restore
    )
{
    ULONG bytesRequired;
    PPERSISTENT_SHARE_INFO shareInfo;
    PWCHAR destString;
    HANDLE h;
    NTSTATUS status;
    OBJECT_ATTRIBUTES objectAttributes;
    IO_STATUS_BLOCK iosb;
    LARGE_INTEGER allocationSize;

    PAGED_CODE( );

    ACQUIRE_LOCK( &SrvShareLock );

    if ( ! Share->AllowPersistentHandles ) {

        IF_DEBUG(PERSISTENT) {
            KdPrint(( "SrvSetupPersistentShare: share %ws not configured for persistent handles\n", Share->ShareName.Buffer ));
        }
        RELEASE_LOCK( &SrvShareLock );
        return STATUS_INVALID_SERVER_STATE;
    }

    if ( Share->PersistentStateFile != NULL ) {

        RELEASE_LOCK( &SrvShareLock );
        return STATUS_SUCCESS;
    }

    bytesRequired = sizeof( PERSISTENT_SHARE_INFO ) + sizeof( WCHAR ) +
                    Share->NtPathName.Length + sizeof( WCHAR ) +
                    Share->ShareName.Length + sizeof( WCHAR );

    shareInfo = ALLOCATE_HEAP( bytesRequired, BlockTypePersistShareState );

    if (shareInfo == NULL) {

        IF_DEBUG(PERSISTENT) {
            KdPrint(( "SrvSetupPersistentShare: failed to alloc block for share %ws\n", Share->ShareName.Buffer ));
        }
        RELEASE_LOCK( &SrvShareLock );
        return STATUS_INSUFF_SERVER_RESOURCES;
    }

    RtlZeroMemory( shareInfo, bytesRequired );

    shareInfo->Share = Share;
    InitializeListHead( &shareInfo->UpdatesPendingList );

    shareInfo->LastIdAccepted = 1;
    shareInfo->LastIdCommitted = 1;
    shareInfo->FirstRecord = sizeof( PERSISTENT_FILE_HEADER );

    INITIALIZE_LOCK( &shareInfo->Lock, SHARE_LOCK_LEVEL, "PersistentShareLock" );

    destString = &shareInfo->NameBuffer[0];

    RtlCopyMemory( destString,
                   Share->NtPathName.Buffer,
                   Share->NtPathName.Length
                   );
    destString +=  (Share->NtPathName.Length / sizeof(WCHAR));

    *destString = L':';         // form up stream name
    destString++;
    *destString = L'$';
    destString++;

    RtlCopyMemory( destString,
                   Share->ShareName.Buffer,
                   Share->ShareName.Length
                   );
    destString +=  (Share->ShareName.Length / sizeof(WCHAR));

    *destString = L'\0';

    RtlInitUnicodeString(   &shareInfo->StateFileName,
                            &shareInfo->NameBuffer[0] );

    Share->PersistentStateFile = shareInfo;
    Share->PersistentState = PersistentStateActive;

    RELEASE_LOCK( &SrvShareLock );

    SrvInitializeObjectAttributes_U(
        &objectAttributes,
        &shareInfo->StateFileName,
        OBJ_CASE_INSENSITIVE,
        NULL,
        NULL
        );

    allocationSize.QuadPart = shareInfo->FirstRecord +
                    ( INITIAL_BITMAP_LENGTH * sizeof( PERSISTENT_RECORD ) );

    status = IoCreateFile(  &h,
                            GENERIC_READ | GENERIC_WRITE,
                            &objectAttributes,
                            &iosb,
                            &allocationSize,
                            0,
                            0,          // no sharing for this file
                            FILE_OPEN_IF,
                            FILE_NO_COMPRESSION,
                            NULL,
                            0,
                            CreateFileTypeNone,
                            NULL,
                            0 );

    if ( NT_SUCCESS( status ) ) {
        status = iosb.Status;
    }
    if ( NT_SUCCESS( status ) ) {

        shareInfo->FileHandle = h;

        if (Restore) {

            // restore settings from file here.

        }

        // write out the header record


    } else {

        //
        //  the create failed.  hmmm.  looks like we can't support persistent
        //  handles on this share.
        //

        Share->PersistentState = PersistentStateInError;
    }
    return status;
}

NTSTATUS
SrvClosePersistentShare (
    IN OUT PSHARE Share,
    IN BOOLEAN ClearState
    )
{

    PAGED_CODE( );


    return 0;
}

//
// This code comes from Dr. Dobbs Journal, May 1992
//

unsigned long SrvCRCTable[256] = {
    0x00000000, 0x77073096, 0xEE0E612C, 0x990951BA, 0x076DC419, 0x706AF48F,
    0xE963A535, 0x9E6495A3, 0x0EDB8832, 0x79DCB8A4, 0xE0D5E91E, 0x97D2D988,
    0x09B64C2B, 0x7EB17CBD, 0xE7B82D07, 0x90BF1D91, 0x1DB71064, 0x6AB020F2,
    0xF3B97148, 0x84BE41DE, 0x1ADAD47D, 0x6DDDE4EB, 0xF4D4B551, 0x83D385C7,
    0x136C9856, 0x646BA8C0, 0xFD62F97A, 0x8A65C9EC, 0x14015C4F, 0x63066CD9,
    0xFA0F3D63, 0x8D080DF5, 0x3B6E20C8, 0x4C69105E, 0xD56041E4, 0xA2677172,
    0x3C03E4D1, 0x4B04D447, 0xD20D85FD, 0xA50AB56B, 0x35B5A8FA, 0x42B2986C,
    0xDBBBC9D6, 0xACBCF940, 0x32D86CE3, 0x45DF5C75, 0xDCD60DCF, 0xABD13D59,
    0x26D930AC, 0x51DE003A, 0xC8D75180, 0xBFD06116, 0x21B4F4B5, 0x56B3C423,
    0xCFBA9599, 0xB8BDA50F, 0x2802B89E, 0x5F058808, 0xC60CD9B2, 0xB10BE924,
    0x2F6F7C87, 0x58684C11, 0xC1611DAB, 0xB6662D3D, 0x76DC4190, 0x01DB7106,
    0x98D220BC, 0xEFD5102A, 0x71B18589, 0x06B6B51F, 0x9FBFE4A5, 0xE8B8D433,
    0x7807C9A2, 0x0F00F934, 0x9609A88E, 0xE10E9818, 0x7F6A0DBB, 0x086D3D2D,
    0x91646C97, 0xE6635C01, 0x6B6B51F4, 0x1C6C6162, 0x856530D8, 0xF262004E,
    0x6C0695ED, 0x1B01A57B, 0x8208F4C1, 0xF50FC457, 0x65B0D9C6, 0x12B7E950,
    0x8BBEB8EA, 0xFCB9887C, 0x62DD1DDF, 0x15DA2D49, 0x8CD37CF3, 0xFBD44C65,
    0x4DB26158, 0x3AB551CE, 0xA3BC0074, 0xD4BB30E2, 0x4ADFA541, 0x3DD895D7,
    0xA4D1C46D, 0xD3D6F4FB, 0x4369E96A, 0x346ED9FC, 0xAD678846, 0xDA60B8D0,
    0x44042D73, 0x33031DE5, 0xAA0A4C5F, 0xDD0D7CC9, 0x5005713C, 0x270241AA,
    0xBE0B1010, 0xC90C2086, 0x5768B525, 0x206F85B3, 0xB966D409, 0xCE61E49F,
    0x5EDEF90E, 0x29D9C998, 0xB0D09822, 0xC7D7A8B4, 0x59B33D17, 0x2EB40D81,
    0xB7BD5C3B, 0xC0BA6CAD, 0xEDB88320, 0x9ABFB3B6, 0x03B6E20C, 0x74B1D29A,
    0xEAD54739, 0x9DD277AF, 0x04DB2615, 0x73DC1683, 0xE3630B12, 0x94643B84,
    0x0D6D6A3E, 0x7A6A5AA8, 0xE40ECF0B, 0x9309FF9D, 0x0A00AE27, 0x7D079EB1,
    0xF00F9344, 0x8708A3D2, 0x1E01F268, 0x6906C2FE, 0xF762575D, 0x806567CB,
    0x196C3671, 0x6E6B06E7, 0xFED41B76, 0x89D32BE0, 0x10DA7A5A, 0x67DD4ACC,
    0xF9B9DF6F, 0x8EBEEFF9, 0x17B7BE43, 0x60B08ED5, 0xD6D6A3E8, 0xA1D1937E,
    0x38D8C2C4, 0x4FDFF252, 0xD1BB67F1, 0xA6BC5767, 0x3FB506DD, 0x48B2364B,
    0xD80D2BDA, 0xAF0A1B4C, 0x36034AF6, 0x41047A60, 0xDF60EFC3, 0xA867DF55,
    0x316E8EEF, 0x4669BE79, 0xCB61B38C, 0xBC66831A, 0x256FD2A0, 0x5268E236,
    0xCC0C7795, 0xBB0B4703, 0x220216B9, 0x5505262F, 0xC5BA3BBE, 0xB2BD0B28,
    0x2BB45A92, 0x5CB36A04, 0xC2D7FFA7, 0xB5D0CF31, 0x2CD99E8B, 0x5BDEAE1D,
    0x9B64C2B0, 0xEC63F226, 0x756AA39C, 0x026D930A, 0x9C0906A9, 0xEB0E363F,
    0x72076785, 0x05005713, 0x95BF4A82, 0xE2B87A14, 0x7BB12BAE, 0x0CB61B38,
    0x92D28E9B, 0xE5D5BE0D, 0x7CDCEFB7, 0x0BDBDF21, 0x86D3D2D4, 0xF1D4E242,
    0x68DDB3F8, 0x1FDA836E, 0x81BE16CD, 0xF6B9265B, 0x6FB077E1, 0x18B74777,
    0x88085AE6, 0xFF0F6A70, 0x66063BCA, 0x11010B5C, 0x8F659EFF, 0xF862AE69,
    0x616BFFD3, 0x166CCF45, 0xA00AE278, 0xD70DD2EE, 0x4E048354, 0x3903B3C2,
    0xA7672661, 0xD06016F7, 0x4969474D, 0x3E6E77DB, 0xAED16A4A, 0xD9D65ADC,
    0x40DF0B66, 0x37D83BF0, 0xA9BCAE53, 0xDEBB9EC5, 0x47B2CF7F, 0x30B5FFE9,
    0xBDBDF21C, 0xCABAC28A, 0x53B39330, 0x24B4A3A6, 0xBAD03605, 0xCDD70693,
    0x54DE5729, 0x23D967BF, 0xB3667A2E, 0xC4614AB8, 0x5D681B02, 0x2A6F2B94,
    0xB40BBE37, 0xC30C8EA1, 0x5A05DF1B, 0x2D02EF8D };

//
//  Since we never need to have a "rolling crc" across records, we have
//  simplified the crc routine abit by always assuming the starting CRC is
//  -1 and we return the crc value rather than stuff it into passed arguement.
//

unsigned long
Crc32(
    IN unsigned long cbBuffer,
    IN unsigned char *pbBuffer
    )
{
    unsigned long dwCrc = (unsigned long) -1;

    PAGED_CODE( );

    while (cbBuffer-- != 0)
    {
        dwCrc = (dwCrc >> 8) ^ SrvCRCTable[(unsigned char) dwCrc ^ *pbBuffer++];
    }
    return dwCrc;
}

#if 0

//  here's the original, in case anyone needs to refer to it.

VOID
Crc32(  unsigned long dwCrc,
        unsigned long cbBuffer,
        LPVOID pvBuffer,
        unsigned long *pNewCrc)
{
    unsigned char * pbBuffer = (unsigned char *) pvBuffer;

    while (cbBuffer-- != 0)
    {
        dwCrc = (dwCrc >> 8) ^ SrvCRCTable[(unsigned char) dwCrc ^ *pbBuffer++];
    }
    *pNewCrc = dwCrc;
}
#endif

#endif   // def INCLUDE_SMB_PERSISTENT
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\srv\pipe.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    smbpipe.c

Abstract:

    This module contains the code for handling named pipe based transact
    SMB's.

    Functions that are handled are:
        SrvCallNamedPipe
        SrvWaitNamedPipe
        SrvQueryInfoNamedPipe
        SrvQueryStateNamedPipe
        SrvSetStateNamedPipe
        SrvPeekNamedPipe
        SrvTransactNamedPipe

Author:

    Manny Weiser (9-18-90)

Revision History:

--*/

#include "precomp.h"
#include "pipe.tmh"
#pragma hdrstop

#define BugCheckFileId SRV_FILE_PIPE

STATIC
VOID SRVFASTCALL
RestartCallNamedPipe (
    IN OUT PWORK_CONTEXT WorkContext
    );

STATIC
VOID SRVFASTCALL
RestartWaitNamedPipe (
    IN OUT PWORK_CONTEXT WorkContext
    );

STATIC
VOID SRVFASTCALL
RestartPeekNamedPipe (
    IN OUT PWORK_CONTEXT WorkContext
    );

VOID SRVFASTCALL
RestartRawWriteNamedPipe (
    IN OUT PWORK_CONTEXT WorkContext
    );

STATIC
VOID SRVFASTCALL
RestartTransactNamedPipe (
    IN OUT PWORK_CONTEXT WorkContext
    );

NTSTATUS
RestartFastTransactNamedPipe (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN OUT PWORK_CONTEXT WorkContext
    );

VOID SRVFASTCALL
RestartFastTransactNamedPipe2 (
    IN OUT PWORK_CONTEXT WorkContext
    );

VOID SRVFASTCALL
RestartReadNamedPipe (
    IN OUT PWORK_CONTEXT WorkContext
    );

VOID SRVFASTCALL
RestartWriteNamedPipe (
    IN OUT PWORK_CONTEXT WorkContext
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text( PAGE, SrvCallNamedPipe )
#pragma alloc_text( PAGE, SrvWaitNamedPipe )
#pragma alloc_text( PAGE, SrvQueryStateNamedPipe )
#pragma alloc_text( PAGE, SrvQueryInformationNamedPipe )
#pragma alloc_text( PAGE, SrvSetStateNamedPipe )
#pragma alloc_text( PAGE, SrvPeekNamedPipe )
#pragma alloc_text( PAGE, SrvTransactNamedPipe )
#pragma alloc_text( PAGE, SrvFastTransactNamedPipe )
#pragma alloc_text( PAGE, SrvRawWriteNamedPipe )
#pragma alloc_text( PAGE, SrvReadNamedPipe )
#pragma alloc_text( PAGE, SrvWriteNamedPipe )
#pragma alloc_text( PAGE, RestartCallNamedPipe )
#pragma alloc_text( PAGE, RestartWaitNamedPipe )
#pragma alloc_text( PAGE, RestartPeekNamedPipe )
#pragma alloc_text( PAGE, RestartReadNamedPipe )
#pragma alloc_text( PAGE, RestartTransactNamedPipe )
#pragma alloc_text( PAGE, RestartRawWriteNamedPipe )
#pragma alloc_text( PAGE, RestartFastTransactNamedPipe2 )
#pragma alloc_text( PAGE, RestartWriteNamedPipe )
#pragma alloc_text( PAGE8FIL, RestartFastTransactNamedPipe )
#endif


SMB_TRANS_STATUS
SrvCallNamedPipe (
    IN OUT PWORK_CONTEXT WorkContext
    )

/*++

Routine Description:

    This function processes a Call Named pipe request from a
    Transaction SMB.  This call is handled asynchronously and
    is completed in RestartCallNamedPipe.

Arguments:

    WorkContext - A pointer to a WORK_CONTEXT block.

Return Value:

    SMB_TRANS_STATUS - Indicates whether an error occurred.  See
        smbtypes.h for a more complete description.

--*/

{
    HANDLE fileHandle;
    IO_STATUS_BLOCK ioStatusBlock;
    OBJECT_ATTRIBUTES objectAttributes;
    PFILE_OBJECT fileObject;
    OBJECT_HANDLE_INFORMATION handleInformation;
    PTRANSACTION transaction;
    NTSTATUS status;
    UNICODE_STRING pipePath;
    UNICODE_STRING fullName;
    FILE_PIPE_INFORMATION pipeInformation;
    PIRP                  irp = WorkContext->Irp;
    PIO_STACK_LOCATION    irpSp;

    PAGED_CODE( );

    //
    //  Strip "\PIPE\" prefix from the path string.
    //

    pipePath = WorkContext->Parameters.Transaction->TransactionName;

    if ( pipePath.Length <=
                (UNICODE_SMB_PIPE_PREFIX_LENGTH + sizeof(WCHAR)) ) {

        SrvSetSmbError( WorkContext, STATUS_INVALID_SMB );
        return SmbTransStatusErrorWithoutData;

    }

    pipePath.Buffer +=
        (UNICODE_SMB_PIPE_PREFIX_LENGTH / sizeof(WCHAR)) + 1;
    pipePath.Length -= UNICODE_SMB_PIPE_PREFIX_LENGTH + sizeof(WCHAR);

    //
    // Attempt to open the named pipe.
    //

    SrvAllocateAndBuildPathName(
        &SrvNamedPipeRootDirectory,
        &pipePath,
        NULL,
        &fullName
        );

    if ( fullName.Buffer == NULL ) {

        //
        // Unable to allocate heap for the full name.
        //

        IF_DEBUG(ERRORS) {
            SrvPrint0( "SrvCallNamedPipe: Unable to allocate heap for full path name\n" );
        }

        SrvSetSmbError (WorkContext, STATUS_INSUFF_SERVER_RESOURCES);
        IF_DEBUG(TRACE2) SrvPrint0( "SrvCallNamedPipe complete\n" );
        return SmbTransStatusErrorWithoutData;
    }

    SrvInitializeObjectAttributes_U(
        &objectAttributes,
        &fullName,
        OBJ_CASE_INSENSITIVE,
        NULL,
        NULL
        );

    INCREMENT_DEBUG_STAT( SrvDbgStatistics.TotalOpenAttempts );

    status = SrvIoCreateFile(
                 WorkContext,
                 &fileHandle,
                 GENERIC_READ | GENERIC_WRITE,
                 &objectAttributes,
                 &ioStatusBlock,
                 NULL,
                 FILE_ATTRIBUTE_NORMAL,
                 FILE_SHARE_READ | FILE_SHARE_WRITE,
                 FILE_OPEN,
                 0,                      // Create Options
                 NULL,                   // EA Buffer
                 0,                      // EA Length
                 CreateFileTypeNone,
                 (PVOID)NULL,            // Create parameters
                 IO_FORCE_ACCESS_CHECK,
                 NULL
                 );

    FREE_HEAP( fullName.Buffer );

    //
    // If the user didn't have this permission, update the statistics
    // database.
    //

    if ( status == STATUS_ACCESS_DENIED ) {
        SrvStatistics.AccessPermissionErrors++;
    }

    if (!NT_SUCCESS(status)) {

        //
        // The server could not open the requested name pipe,
        // return the error.
        //

        IF_SMB_DEBUG(OPEN_CLOSE1) {
            SrvPrint2( "SrvCallNamedPipe: Failed to open %ws, err=%x\n",
                WorkContext->Parameters.Transaction->TransactionName.Buffer, status );
        }
        SrvSetSmbError (WorkContext, status);
        IF_DEBUG(TRACE2) SrvPrint0( "SrvCallNamedPipe complete\n" );
        return SmbTransStatusErrorWithoutData;
    }

    SRVDBG_CLAIM_HANDLE( fileHandle, "FIL", 15, 0 );
    SrvStatistics.TotalFilesOpened++;

    //
    // Get a pointer to the file object, so that we can directly
    // build IRPs for asynchronous operations (read and write).
    // Also, get the granted access mask, so that we can prevent the
    // client from doing things that it isn't allowed to do.
    //

    status = ObReferenceObjectByHandle(
                fileHandle,
                0,
                NULL,
                KernelMode,
                (PVOID *)&fileObject,
                &handleInformation
                );

    if ( !NT_SUCCESS(status) ) {

        SrvLogServiceFailure( SRV_SVC_OB_REF_BY_HANDLE, status );

        //
        // This internal error bugchecks the system.
        //

        INTERNAL_ERROR(
            ERROR_LEVEL_IMPOSSIBLE,
            "SrvCallNamedPipe: unable to reference file handle 0x%lx",
            fileHandle,
            NULL
            );

        SrvSetSmbError( WorkContext, status );
        IF_DEBUG(TRACE2) SrvPrint0( "SrvCallNamedPipe complete\n" );
        return SmbTransStatusErrorWithoutData;

    }

    //
    // Save file handle for the completion routine.
    //

    transaction = WorkContext->Parameters.Transaction;
    transaction->FileHandle = fileHandle;
    transaction->FileObject = fileObject;

    //
    // Set the pipe to message mode, so that we can preform a transceive
    //

    pipeInformation.CompletionMode = FILE_PIPE_QUEUE_OPERATION;
    pipeInformation.ReadMode = FILE_PIPE_MESSAGE_MODE;

    status = NtSetInformationFile (
                fileHandle,
                &ioStatusBlock,
                (PVOID)&pipeInformation,
                sizeof(pipeInformation),
                FilePipeInformation
                );

    if ( !NT_SUCCESS(status) ) {
        INTERNAL_ERROR(
            ERROR_LEVEL_UNEXPECTED,
            "SrvCallNamedPipe: NtSetInformationFile (pipe information) "
                "returned %X",
            status,
            NULL
            );

        SrvLogServiceFailure( SRV_SVC_NT_SET_INFO_FILE, status );

        SrvSetSmbError( WorkContext, status );
        IF_DEBUG(TRACE2) SrvPrint0( "SrvCallNamedPipe complete\n" );
        return SmbTransStatusErrorWithoutData;
    }

    //
    // Set the Restart Routine addresses in the work context block.
    //

    WorkContext->FsdRestartRoutine = SrvQueueWorkToFspAtDpcLevel;
    WorkContext->FspRestartRoutine = RestartCallNamedPipe;

    transaction = WorkContext->Parameters.Transaction;

    //
    // Build the IRP to start a pipe transceive.
    // Pass this request to NPFS.
    //

    //
    // Inline SrvBuildIoControlRequest
    //

    {

        //
        // Get a pointer to the next stack location.  This one is used to
        // hold the parameters for the device I/O control request.
        //

        irpSp = IoGetNextIrpStackLocation( irp );

        //
        // Set up the completion routine.
        //

        IoSetCompletionRoutine(
            irp,
            SrvFsdIoCompletionRoutine,
            (PVOID)WorkContext,
            TRUE,
            TRUE,
            TRUE
            );

        irpSp->MajorFunction = IRP_MJ_FILE_SYSTEM_CONTROL;
        irpSp->MinorFunction = 0;

        irpSp->DeviceObject = IoGetRelatedDeviceObject(fileObject);
        irpSp->FileObject = fileObject;

        irp->Tail.Overlay.OriginalFileObject = irpSp->FileObject;
        irp->Tail.Overlay.Thread = WorkContext->CurrentWorkQueue->IrpThread;
        DEBUG irp->RequestorMode = KernelMode;

        irp->MdlAddress = NULL;
        irp->AssociatedIrp.SystemBuffer = transaction->OutData;
        irpSp->Parameters.DeviceIoControl.Type3InputBuffer =
                                                    transaction->InData;

        //
        // Copy the caller's parameters to the service-specific portion of the
        // IRP for those parameters that are the same for all three methods.
        //

        irpSp->Parameters.FileSystemControl.OutputBufferLength =
                                                    transaction->MaxDataCount;
        irpSp->Parameters.FileSystemControl.InputBufferLength =
                                                    transaction->DataCount;
        irpSp->Parameters.FileSystemControl.FsControlCode =
                                                FSCTL_PIPE_INTERNAL_TRANSCEIVE;

    }

    (VOID)IoCallDriver(
                irpSp->DeviceObject,
                irp
                );

    //
    // The tranceive was successfully started.  Return the InProgress
    // status to the caller, indicating that the caller should do
    // nothing further with the SMB/WorkContext at the present time.
    //

    IF_DEBUG(TRACE2) SrvPrint0( "SrvCallNamedPipe complete\n" );
    return SmbTransStatusInProgress;

} // SrvCallNamedPipe


SMB_TRANS_STATUS
SrvWaitNamedPipe (
    IN OUT PWORK_CONTEXT WorkContext
    )

/*++

Routine Description:

    This function processes a Wait named pipe transaction SMB.
    It issues an asynchronous call to NPFS.  The function
    completetion is handled by RestartWaitNamedPipe().

Arguments:

    WorkContext - A pointer to a WORK_CONTEXT block.

Return Value:

    SMB_TRANS_STATUS - Indicates whether an error occurred.  See
        smbtypes.h for a more complete description.

--*/

{
    PFILE_PIPE_WAIT_FOR_BUFFER pipeWaitBuffer;
    PREQ_TRANSACTION request;
    PTRANSACTION transaction;
    UNICODE_STRING pipePath;
    CLONG nameLength;

    PAGED_CODE( );

    request = (PREQ_TRANSACTION)WorkContext->RequestParameters;
    transaction = WorkContext->Parameters.Transaction;

    //
    // Allocate and fill in FILE_PIPE_WAIT_FOR_BUFFER structure.
    //

    pipePath = transaction->TransactionName;

    if ( pipePath.Length <= (UNICODE_SMB_PIPE_PREFIX_LENGTH + sizeof(WCHAR)) ) {

        //
        // The transaction name does not include a pipe name.  It's
        // either \PIPE or \PIPE\, or it doesn't even have \PIPE.
        //

        SrvSetSmbError( WorkContext, STATUS_INVALID_SMB );
        return SmbTransStatusErrorWithoutData;

    }

    nameLength = pipePath.Length -
                    (UNICODE_SMB_PIPE_PREFIX_LENGTH + sizeof(WCHAR)) +
                    sizeof(WCHAR);

    pipeWaitBuffer = ALLOCATE_NONPAGED_POOL(
                        sizeof(FILE_PIPE_WAIT_FOR_BUFFER) + nameLength,
                        BlockTypeDataBuffer
                        );

    if ( pipeWaitBuffer == NULL ) {

        //
        // We could not allocate space for the buffer to issue the
        // pipe wait.  Fail the request.
        //

        SrvSetSmbError( WorkContext, STATUS_INSUFF_SERVER_RESOURCES );
        IF_DEBUG(TRACE2) SrvPrint0( "SrvWaitNamedPipe complete\n" );
        return SmbTransStatusErrorWithoutData;

    }

    //
    // Copy the pipe name not including "\PIPE\" to the pipe wait for
    // buffer.
    //

    pipeWaitBuffer->NameLength = nameLength - sizeof(WCHAR);

    RtlCopyMemory(
        pipeWaitBuffer->Name,
        (PUCHAR)pipePath.Buffer + UNICODE_SMB_PIPE_PREFIX_LENGTH + sizeof(WCHAR),
        nameLength
        );

    //
    // Fill in the pipe timeout value if necessary.
    //

    if ( SmbGetUlong( &request->Timeout ) == 0 ) {
        pipeWaitBuffer->TimeoutSpecified = FALSE;
    } else {
        pipeWaitBuffer->TimeoutSpecified = TRUE;

        //
        // Convert timeout time from milliseconds to NT relative time.
        //

        pipeWaitBuffer->Timeout.QuadPart = -1 *
            UInt32x32To64( SmbGetUlong( &request->Timeout ), 10*1000 );
    }

    //
    // Set the Restart Routine addresses in the work context block.
    //

    WorkContext->FsdRestartRoutine = SrvQueueWorkToFspAtDpcLevel;
    WorkContext->FspRestartRoutine = RestartWaitNamedPipe;

    //
    // Build a Wait named pipe IRP and pass the request to NPFS.
    //

    SrvBuildIoControlRequest(
        WorkContext->Irp,
        SrvNamedPipeFileObject,
        WorkContext,
        IRP_MJ_FILE_SYSTEM_CONTROL,
        FSCTL_PIPE_WAIT,
        pipeWaitBuffer,
        sizeof(*pipeWaitBuffer) + nameLength,
        NULL,
        0,
        NULL,
        NULL
        );

    (VOID)IoCallDriver( SrvNamedPipeDeviceObject, WorkContext->Irp );

    //
    // The tranceive was successfully started.  Return the InProgress
    // status to the caller, indicating that the caller should do
    // nothing further with the SMB/WorkContext at the present time.
    //

    IF_DEBUG(TRACE2) SrvPrint0( "SrvWaitNamedPipe complete\n" );
    return SmbTransStatusInProgress;

} // SrvWaitNamedPipe


SMB_TRANS_STATUS
SrvQueryStateNamedPipe (
    IN OUT PWORK_CONTEXT WorkContext
    )

/*++

Routine Description:

    This function processes a Query Named pipe transaction SMB.
    Since this call cannot block it is handled synchronously.

Arguments:

    WorkContext - A pointer to a WORK_CONTEXT block.

Return Value:

    SMB_TRANS_STATUS - Indicates whether an error occurred.  See
        smbtypes.h for a more complete description.

--*/

{
    PREQ_TRANSACTION request;
    PTRANSACTION transaction;
    HANDLE pipeHandle;
    IO_STATUS_BLOCK ioStatusBlock;
    USHORT pipeHandleState;
    FILE_PIPE_INFORMATION pipeInformation;
    FILE_PIPE_LOCAL_INFORMATION pipeLocalInformation;
    NTSTATUS status;
    USHORT fid;
    PRFCB rfcb;

    PAGED_CODE( );

    request = (PREQ_TRANSACTION)WorkContext->RequestParameters;
    transaction = WorkContext->Parameters.Transaction;

    //
    // Get the FID from the second setup word and use it to generate a
    // pointer to the RFCB.
    //
    // SrvVerifyFid will fill in WorkContext->Rfcb.
    //

    fid = SmbGetUshort( &transaction->InSetup[1] );

    rfcb = SrvVerifyFid(
                WorkContext,
                fid,
                FALSE,
                NULL,  // don't serialize with raw write
                &status
                );

    if ( rfcb == SRV_INVALID_RFCB_POINTER ) {

        //
        // Invalid file ID.  Reject the request.
        //

        IF_DEBUG(SMB_ERRORS) {
            SrvPrint1( "SrvQueryStateNamedPipe: Invalid FID: 0x%lx\n", fid );
        }

        SrvSetSmbError( WorkContext, STATUS_INVALID_HANDLE );
        IF_DEBUG(TRACE2) SrvPrint0( "SrvQueryStateNamedPipe complete\n" );
        return SmbTransStatusErrorWithoutData;

    }

    pipeHandle = rfcb->Lfcb->FileHandle;

    status = NtQueryInformationFile (
                pipeHandle,
                &ioStatusBlock,
                (PVOID)&pipeInformation,
                sizeof(pipeInformation),
                FilePipeInformation
                );

    if (!NT_SUCCESS(status)) {
        INTERNAL_ERROR(
            ERROR_LEVEL_UNEXPECTED,
            "SrvQueryStateNamedPipe:  NtQueryInformationFile (pipe "
                "information) returned %X",
            status,
            NULL
            );

        SrvLogServiceFailure( SRV_SVC_NT_QUERY_INFO_FILE, status );

        SrvSetSmbError( WorkContext, status );
        IF_DEBUG(TRACE2) SrvPrint0( "SrvQueryStateNamedPipe complete\n" );
        return SmbTransStatusErrorWithoutData;
    }

    status = NtQueryInformationFile (
                pipeHandle,
                &ioStatusBlock,
                (PVOID)&pipeLocalInformation,
                sizeof(pipeLocalInformation),
                FilePipeLocalInformation
                );

    if (!NT_SUCCESS(status)) {
        INTERNAL_ERROR(
            ERROR_LEVEL_UNEXPECTED,
            "SrvQueryStateNamedPipe:  NtQueryInformationFile (pipe local "
                "information) returned %X",
            status,
            NULL
            );

        SrvLogServiceFailure( SRV_SVC_NT_QUERY_INFO_FILE, status );

        SrvSetSmbError( WorkContext, status );
        IF_DEBUG(TRACE2) SrvPrint0( "SrvQueryStateNamedPipe complete\n" );
        return SmbTransStatusErrorWithoutData;
    }

    //
    // Query succeeded generate response
    //

    pipeHandleState = (USHORT)pipeInformation.CompletionMode
                        << PIPE_COMPLETION_MODE_BITS;
    pipeHandleState |= (USHORT)pipeLocalInformation.NamedPipeEnd
                        << PIPE_PIPE_END_BITS;
    pipeHandleState |= (USHORT)pipeLocalInformation.NamedPipeType
                        << PIPE_PIPE_TYPE_BITS;
    pipeHandleState |= (USHORT)pipeInformation.ReadMode
                        << PIPE_READ_MODE_BITS;
    pipeHandleState |= (USHORT)((pipeLocalInformation.MaximumInstances
                        << PIPE_MAXIMUM_INSTANCES_BITS)
                            & SMB_PIPE_UNLIMITED_INSTANCES);

    SmbPutUshort(
        (PSMB_USHORT)WorkContext->Parameters.Transaction->OutParameters,
        pipeHandleState
        );

    transaction->SetupCount = 0;
    transaction->ParameterCount = sizeof(pipeHandleState);
    transaction->DataCount = 0;

    IF_DEBUG(TRACE2) SrvPrint0( "SrvQueryStateNamedPipe complete\n" );
    return SmbTransStatusSuccess;
} // SrvQueryStateNamedPipe


SMB_TRANS_STATUS
SrvQueryInformationNamedPipe (
    IN OUT PWORK_CONTEXT WorkContext
    )

/*++

Routine Description:

    This function process a Query named pipe information transaction
    SMB.  This call is handled synchronously.

Arguments:

    WorkContext - A pointer to a WORK_CONTEXT block.

Return Value:

    SMB_TRANS_STATUS - Indicates whether an error occurred.  See
        smbtypes.h for a more complete description.

--*/

{
    PREQ_TRANSACTION request;
    PTRANSACTION transaction;
    HANDLE pipeHandle;
    IO_STATUS_BLOCK ioStatusBlock;
    FILE_PIPE_LOCAL_INFORMATION pipeLocalInformation;
    PNAMED_PIPE_INFORMATION_1 namedPipeInfo;
    NTSTATUS status;
    USHORT fid;
    PRFCB rfcb;
    PLFCB lfcb;
    USHORT level;
    CLONG smbPathLength;
    PUNICODE_STRING pipeName;
    CLONG actualDataSize;
    BOOLEAN returnPipeName;
    BOOLEAN isUnicode;

    PAGED_CODE( );

    request = (PREQ_TRANSACTION)WorkContext->RequestParameters;
    transaction = WorkContext->Parameters.Transaction;

    //
    // Get the FID from the second setup word and use it to generate a
    // pointer to the RFCB.
    //
    // SrvVerifyFid will fill in WorkContext->Rfcb.
    //

    fid = SmbGetUshort( &transaction->InSetup[1] );
    rfcb = SrvVerifyFid(
                WorkContext,
                fid,
                FALSE,
                NULL,  // don't serialize with raw write
                &status
                );

    if ( rfcb == SRV_INVALID_RFCB_POINTER ) {

        //
        // Invalid file ID.  Reject the request.
        //

        IF_DEBUG(SMB_ERRORS) {
            SrvPrint1( "SrvQueryStateNamedPipe: Invalid FID: 0x%lx\n", fid );
        }

        SrvSetSmbError( WorkContext, STATUS_INVALID_HANDLE );
        IF_DEBUG(TRACE2) SrvPrint0( "SrvQueryInfoNamedPipe complete\n" );
        return SmbTransStatusErrorWithoutData;

    }

    lfcb = rfcb->Lfcb;
    pipeHandle = lfcb->FileHandle;

    //
    // The information level is stored in paramter byte one.
    // Verify that is set correctly.
    //

    level = SmbGetUshort( (PSMB_USHORT)transaction->InParameters );

    if ( level != 1 ) {
        SrvSetSmbError( WorkContext, STATUS_INVALID_PARAMETER );
        IF_DEBUG(TRACE2) SrvPrint0( "SrvQueryInfoNamedPipe complete\n" );
        return SmbTransStatusErrorWithoutData;
    }

    //
    // Now check that the response will fit.  If everything expect for
    // the pipe name fits, return STATUS_BUFFER_OVERFLOW with the
    // fixed size portion of the data.
    //
    // *** Note that Unicode strings must be aligned in the SMB.
    //

    pipeName = &lfcb->Mfcb->FileName;

    actualDataSize = sizeof(NAMED_PIPE_INFORMATION_1) - sizeof(UCHAR);

    isUnicode = SMB_IS_UNICODE( WorkContext );
    if ( isUnicode ) {

        ASSERT( sizeof(WCHAR) == 2 );
        actualDataSize = (actualDataSize + 1) & ~1; // align to SHORT
        smbPathLength = (CLONG)(pipeName->Length) + sizeof(WCHAR);

    } else {

        smbPathLength = (CLONG)(RtlUnicodeStringToOemSize( pipeName ));

    }

    actualDataSize += smbPathLength;


    if ( transaction->MaxDataCount <
            FIELD_OFFSET(NAMED_PIPE_INFORMATION_1, PipeName ) ) {
        SrvSetSmbError( WorkContext, STATUS_BUFFER_TOO_SMALL );
        IF_DEBUG(TRACE2) SrvPrint0( "SrvQueryInfoNamedPipe complete\n" );
        return SmbTransStatusErrorWithoutData;
    }

    if ( (transaction->MaxDataCount < actualDataSize) ||
         (smbPathLength >= MAXIMUM_FILENAME_LENGTH) ) {

        //
        // Do not return the pipe name.  It won't fit in the return buffer.
        //

        returnPipeName = FALSE;
    } else {
        returnPipeName = TRUE;
    }


    //
    // Everything is correct, ask NPFS for the information.
    //

    status = NtQueryInformationFile (
                pipeHandle,
                &ioStatusBlock,
                (PVOID)&pipeLocalInformation,
                sizeof(pipeLocalInformation),
                FilePipeLocalInformation
                );

    if (!NT_SUCCESS(status)) {
        INTERNAL_ERROR(
            ERROR_LEVEL_UNEXPECTED,
            "SrvQueryInformationNamedPipe: NtQueryInformationFile (pipe "
                "information) returned %X",
            status,
            NULL
            );

        SrvLogServiceFailure( SRV_SVC_NT_QUERY_INFO_FILE, status );

        SrvSetSmbError( WorkContext, status );
        IF_DEBUG(TRACE2) SrvPrint0( "SrvQueryInfoNamedPipe complete\n" );
        return SmbTransStatusErrorWithoutData;
    }

    //
    // Query succeeded format the response data into the buffer pointed
    // at by transaction->OutData
    //

    namedPipeInfo = (PNAMED_PIPE_INFORMATION_1)transaction->OutData;

    if ((pipeLocalInformation.OutboundQuota & 0xffff0000) != 0) {
        SmbPutAlignedUshort(
            &namedPipeInfo->OutputBufferSize,
            (USHORT)0xFFFF
            );
    } else {
        SmbPutAlignedUshort(
            &namedPipeInfo->OutputBufferSize,
            (USHORT)pipeLocalInformation.OutboundQuota
            );
    }

    if ((pipeLocalInformation.InboundQuota & 0xffff0000) != 0) {
        SmbPutAlignedUshort(
            &namedPipeInfo->InputBufferSize,
            (USHORT)0xFFFF
            );
    } else {
        SmbPutAlignedUshort(
            &namedPipeInfo->InputBufferSize,
            (USHORT)pipeLocalInformation.InboundQuota
            );
    }

    if ((pipeLocalInformation.MaximumInstances & 0xffffff00) != 0) {
        namedPipeInfo->MaximumInstances = (UCHAR)0xFF;
    } else {
        namedPipeInfo->MaximumInstances =
                            (UCHAR)pipeLocalInformation.MaximumInstances;
    }

    if ((pipeLocalInformation.CurrentInstances & 0xffffff00) != 0) {
        namedPipeInfo->CurrentInstances = (UCHAR)0xFF;
    } else {
        namedPipeInfo->CurrentInstances =
                            (UCHAR)pipeLocalInformation.CurrentInstances;
    }

    if ( returnPipeName ) {

        //
        // Copy full pipe path name to the output buffer, appending a NUL.
        //
        // *** Note that Unicode pipe names must be aligned in the SMB.
        //

        namedPipeInfo->PipeNameLength = (UCHAR)smbPathLength;

        if ( isUnicode ) {

            PVOID buffer = ALIGN_SMB_WSTR( namedPipeInfo->PipeName );

            RtlCopyMemory( buffer, pipeName->Buffer, smbPathLength );

        } else {

            UNICODE_STRING source;
            OEM_STRING destination;

            source.Buffer = pipeName->Buffer;
            source.Length = pipeName->Length;
            source.MaximumLength = source.Length;

            destination.Buffer = (PCHAR) namedPipeInfo->PipeName;
            destination.MaximumLength = (USHORT)smbPathLength;

            RtlUnicodeStringToOemString(
                &destination,
                &source,
                FALSE
                );

        }

        transaction->DataCount = actualDataSize;

    } else {

        SrvSetSmbError2( WorkContext, STATUS_BUFFER_OVERFLOW, TRUE );
        transaction->DataCount =
            FIELD_OFFSET( NAMED_PIPE_INFORMATION_1, PipeName );

    }

    //
    // Set up to send success response
    //

    transaction->SetupCount = 0;
    transaction->ParameterCount = 0;

    IF_DEBUG(TRACE2) SrvPrint0( "SrvQueryInfoNamedPipe complete\n" );

    if ( returnPipeName) {
        return SmbTransStatusSuccess;
    } else {
        return SmbTransStatusErrorWithData;
    }

} // SrvQueryInformationNamedPipe


SMB_TRANS_STATUS
SrvSetStateNamedPipe (
    IN OUT PWORK_CONTEXT WorkContext
    )

/*++

Routine Description:

    This function processes a set named pipe handle state transaction
    SMB.  The call is issued synchronously.

Arguments:

    WorkContext - A pointer to a WORK_CONTEXT block.

Return Value:

    SMB_TRANS_STATUS - Indicates whether an error occurred.  See
        smbtypes.h for a more complete description.

--*/

{
    PREQ_TRANSACTION request;
    PTRANSACTION transaction;
    HANDLE pipeHandle;
    IO_STATUS_BLOCK ioStatusBlock;
    USHORT pipeHandleState;
    FILE_PIPE_INFORMATION pipeInformation;
    NTSTATUS status;
    USHORT fid;
    PRFCB rfcb;

    PAGED_CODE( );

    request = (PREQ_TRANSACTION)WorkContext->RequestParameters;
    transaction = WorkContext->Parameters.Transaction;

    //
    // Get the FID from the second setup word and use it to generate a
    // pointer to the RFCB.
    //
    // SrvVerifyFid will fill in WorkContext->Rfcb.
    //

    fid = SmbGetUshort( &transaction->InSetup[1] );
    rfcb = SrvVerifyFid(
                WorkContext,
                fid,
                FALSE,
                NULL,  // don't serialize with raw write
                &status
                );

    if ( rfcb == SRV_INVALID_RFCB_POINTER ) {

        //
        // Invalid file ID.  Reject the request.
        //

        IF_DEBUG(SMB_ERRORS) {
            SrvPrint1( "SrvSetStateNamedPipe: Invalid FID: 0x%lx\n", fid );
        }

        SrvSetSmbError( WorkContext, STATUS_INVALID_HANDLE );
        IF_DEBUG(TRACE2) SrvPrint0( "SrvSetStateNamedPipe complete\n" );
        return SmbTransStatusErrorWithoutData;

    }

    pipeHandle = rfcb->Lfcb->FileHandle;

    //
    // The SMB contains 2 parameter bytes.  Translate these to
    // NT format, then attempt to set the named pipe handle state.
    //

    pipeHandleState = SmbGetUshort(
                         (PSMB_USHORT)
                           WorkContext->Parameters.Transaction->InParameters
                         );

    pipeInformation.CompletionMode =
        ((ULONG)pipeHandleState >> PIPE_COMPLETION_MODE_BITS) & 1;
    pipeInformation.ReadMode =
        ((ULONG)pipeHandleState >> PIPE_READ_MODE_BITS) & 1;


    status = NtSetInformationFile (
                pipeHandle,
                &ioStatusBlock,
                (PVOID)&pipeInformation,
                sizeof(pipeInformation),
                FilePipeInformation
                );

    if (NT_SUCCESS(status) ) {
        status = ioStatusBlock.Status;
    }

    if (!NT_SUCCESS(status)) {
        INTERNAL_ERROR(
            ERROR_LEVEL_UNEXPECTED,
            "SrvSetStateNamedPipe: NetSetInformationFile (pipe information) "
                "returned %X",
            status,
            NULL
            );

        SrvLogServiceFailure( SRV_SVC_NT_SET_INFO_FILE, status );

        SrvSetSmbError( WorkContext, status );
        IF_DEBUG(TRACE2) SrvPrint0( "SrvSetStateNamedPipe complete\n" );
        return SmbTransStatusErrorWithoutData;
    }

    //
    // Success.  Update our internal pipe handle state.
    //

    rfcb->BlockingModePipe =
        (BOOLEAN)(pipeInformation.CompletionMode ==
                                                FILE_PIPE_QUEUE_OPERATION);
    rfcb->ByteModePipe =
        (BOOLEAN)(pipeInformation.ReadMode == FILE_PIPE_BYTE_STREAM_MODE);

    //
    // Now set up for the success response.
    //

    transaction->SetupCount = 0;
    transaction->ParameterCount = 0;
    transaction->DataCount = 0;

    IF_DEBUG(TRACE2) SrvPrint0( "SrvSetStateNamedPipe complete\n" );
    return SmbTransStatusSuccess;

} // SrvSetStateNamedPipe


SMB_TRANS_STATUS
SrvPeekNamedPipe (
    IN OUT PWORK_CONTEXT WorkContext
    )

/*++

Routine Description:

    This function handles a peek named pipe transaction SMB.  The
    call is issued asynchrously and is completed by RestartPeekNamedPipe().

Arguments:

    WorkContext - A pointer to a WORK_CONTEXT block.

Return Value:

    status - The result of the operation.

--*/

{
    PTRANSACTION transaction;
    USHORT fid;
    PRFCB rfcb;
    PLFCB lfcb;
    NTSTATUS status;

    PAGED_CODE( );

    transaction = WorkContext->Parameters.Transaction;

    //
    // Get the FID from the second setup word and use it to generate a
    // pointer to the RFCB.
    //
    // SrvVerifyFid will fill in WorkContext->Rfcb.
    //

    fid = SmbGetUshort( &transaction->InSetup[1] );
    rfcb = SrvVerifyFid(
                WorkContext,
                fid,
                FALSE,
                SrvRestartExecuteTransaction,   // serialize with raw write
                &status
                );

    if ( rfcb == SRV_INVALID_RFCB_POINTER ) {

        if ( !NT_SUCCESS( status ) ) {

            //
            // Invalid file ID.  Reject the request.
            //

            IF_DEBUG(SMB_ERRORS) {
                SrvPrint1( "SrvPeekNamedPipe: Invalid FID: 0x%lx\n", fid );
            }

            SrvSetSmbError( WorkContext, STATUS_INVALID_HANDLE );
            IF_DEBUG(TRACE2) SrvPrint0( "SrvPeekNamedPipe complete\n" );
            return SmbTransStatusErrorWithoutData;

        }


        //
        // The work item has been queued because a raw write is in
        // progress.
        //

        return SmbTransStatusInProgress;

    }

    //
    // Set the Restart Routine addresses in the work context block.
    //

    WorkContext->FsdRestartRoutine = SrvQueueWorkToFspAtDpcLevel;
    WorkContext->FspRestartRoutine = RestartPeekNamedPipe;

    //
    // Issue the request to NPFS.  We expect both parameters and
    // data to be returned.  The buffer which we offer is contiguous
    // and large enough to contain both.
    //

    transaction = WorkContext->Parameters.Transaction;
    lfcb = rfcb->Lfcb;

    SrvBuildIoControlRequest(
        WorkContext->Irp,
        lfcb->FileObject,
        WorkContext,
        IRP_MJ_FILE_SYSTEM_CONTROL,
        FSCTL_PIPE_PEEK,
        transaction->OutParameters,
        0,
        NULL,
        transaction->MaxParameterCount + transaction->MaxDataCount,
        NULL,
        NULL
        );

    //
    // Pass the request to NPFS.
    //

    (VOID)IoCallDriver( lfcb->DeviceObject, WorkContext->Irp );

    //
    // The peek was successfully started.  Return the InProgress
    // status to the caller, indicating that the caller should do
    // nothing further with the SMB/WorkContext at the present time.
    //

    IF_DEBUG(TRACE2) SrvPrint0( "SrvPeekNamedPipe complete\n" );
    return SmbTransStatusInProgress;

} // SrvPeekNamedPipe


SMB_TRANS_STATUS
SrvTransactNamedPipe (
    IN OUT PWORK_CONTEXT WorkContext
    )

/*++

Routine Description:

    This function handles the transact named pipe transaction SMB.
    The call to NPFS is issued asynchronously and is completed by
    RestartTransactNamedPipe()

Arguments:

    WorkContext - A pointer to a WORK_CONTEXT block.

Return Value:

    SMB_TRANS_STATUS - Indicates whether an error occurred.  See
        smbtypes.h for a more complete description.

--*/

{
    PTRANSACTION transaction;
    USHORT fid;
    PRFCB rfcb;
    NTSTATUS status;
    PIO_STACK_LOCATION irpSp;
    PIRP irp = WorkContext->Irp;

    PAGED_CODE( );

    transaction = WorkContext->Parameters.Transaction;

    //
    // Get the FID from the second setup word and use it to generate a
    // pointer to the RFCB.
    //
    // SrvVerifyFid will fill in WorkContext->Rfcb.
    //

    fid = SmbGetUshort( &transaction->InSetup[1] );

    rfcb = SrvVerifyFid(
                WorkContext,
                fid,
                FALSE,
                SrvRestartExecuteTransaction,   // serialize with raw write
                &status
                );

    if ( rfcb == SRV_INVALID_RFCB_POINTER ) {

        if ( !NT_SUCCESS( status ) ) {

            //
            // Invalid file ID.  Reject the request.
            //

            IF_DEBUG(SMB_ERRORS) {
                SrvPrint1( "SrvTransactStateNamedPipe: Invalid FID: 0x%lx\n",
                          fid );
            }

            SrvSetSmbError( WorkContext, STATUS_INVALID_HANDLE );
            IF_DEBUG(TRACE2) SrvPrint0( "SrvTransactNamedPipe complete\n" );
            return SmbTransStatusErrorWithoutData;

        }

        //
        // The work item has been queued because a raw write is in
        // progress.
        //

        return SmbTransStatusInProgress;

    }

    //
    // Set the Restart Routine addresses in the work context block.
    //

    WorkContext->FsdRestartRoutine = SrvQueueWorkToFspAtDpcLevel;
    WorkContext->FspRestartRoutine = RestartTransactNamedPipe;

    transaction = WorkContext->Parameters.Transaction;

    //
    // Inline SrvBuildIoControlRequest
    //

    {

        //
        // Get a pointer to the next stack location.  This one is used to
        // hold the parameters for the device I/O control request.
        //

        irpSp = IoGetNextIrpStackLocation( irp );

        //
        // Set up the completion routine.
        //

        IoSetCompletionRoutine(
            irp,
            SrvFsdIoCompletionRoutine,
            (PVOID)WorkContext,
            TRUE,
            TRUE,
            TRUE
            );

        irpSp->MajorFunction = IRP_MJ_FILE_SYSTEM_CONTROL;
        irpSp->MinorFunction = 0;

        irpSp->DeviceObject = rfcb->Lfcb->DeviceObject;
        irpSp->FileObject = rfcb->Lfcb->FileObject;

        irp->Tail.Overlay.OriginalFileObject = irpSp->FileObject;
        irp->Tail.Overlay.Thread = WorkContext->CurrentWorkQueue->IrpThread;
        DEBUG irp->RequestorMode = KernelMode;

        irp->MdlAddress = NULL;
        irp->AssociatedIrp.SystemBuffer = transaction->OutData;
        irpSp->Parameters.DeviceIoControl.Type3InputBuffer =
                                                    transaction->InData;

        //
        // Copy the caller's parameters to the service-specific portion of the
        // IRP for those parameters that are the same for all three methods.
        //

        irpSp->Parameters.FileSystemControl.OutputBufferLength =
                                                    transaction->MaxDataCount;
        irpSp->Parameters.FileSystemControl.InputBufferLength =
                                                    transaction->DataCount;
        irpSp->Parameters.FileSystemControl.FsControlCode =
                                                FSCTL_PIPE_INTERNAL_TRANSCEIVE;

    }

    //
    // Pass the request to NPFS.
    //

    (VOID)IoCallDriver( irpSp->DeviceObject, irp );

    //
    // The tranceive was successfully started.  Return the InProgress
    // status to the caller, indicating that the caller should do
    // nothing further with the SMB/WorkContext at the present time.
    //

    IF_DEBUG(TRACE2) SrvPrint0( "SrvTransactNamedPipe complete\n" );
    return SmbTransStatusInProgress;

} // SrvTransactNamedPipe

BOOLEAN
SrvFastTransactNamedPipe (
    IN OUT PWORK_CONTEXT WorkContext,
    OUT SMB_STATUS * SmbStatus
    )

/*++

Routine Description:

    This function handles the special case of a single buffer transact
    named pipe transaction SMB.  The call to NPFS is issued asynchronously
    and is completed by RestartFastTransactNamedPipe()

Arguments:

    WorkContext - A pointer to a WORK_CONTEXT block.
    SmbStatus - Status of the transaction.

Return Value:

    TRUE, if fastpath succeeded,
    FALSE, otherwise.  Server must take long path.

--*/

{
    USHORT fid;
    PRFCB rfcb;
    PSESSION session;
    NTSTATUS status;
    PIO_STACK_LOCATION irpSp;
    PIRP irp = WorkContext->Irp;
    CLONG outputBufferSize;
    CLONG maxParameterCount;
    CLONG maxDataCount;

    PSMB_USHORT inSetup;
    PSMB_USHORT outSetup;
    PCHAR outParam;
    PCHAR outData;
    CLONG offset;
    CLONG setupOffset;

    PREQ_TRANSACTION request;
    PRESP_TRANSACTION response;
    PSMB_HEADER header;

    PAGED_CODE( );

    header = WorkContext->ResponseHeader;
    request = (PREQ_TRANSACTION)WorkContext->RequestParameters;
    response = (PRESP_TRANSACTION)WorkContext->ResponseParameters;

    //
    // Get the FID from the second setup word and use it to generate a
    // pointer to the RFCB.
    //
    // SrvVerifyFid will fill in WorkContext->Rfcb.
    //

    setupOffset = (CLONG)((CLONG_PTR)(request->Buffer) - (CLONG_PTR)header);
    inSetup = (PSMB_USHORT)( (PCHAR)header + setupOffset );

    fid = SmbGetUshort( &inSetup[1] );
    rfcb = SrvVerifyFid(
                WorkContext,
                fid,
                FALSE,
                SrvRestartSmbReceived,   // serialize with raw write
                &status
                );

    if ( rfcb == SRV_INVALID_RFCB_POINTER ) {

        if ( !NT_SUCCESS( status ) ) {

            //
            // Invalid file ID.  Reject the request.
            //

            IF_DEBUG(SMB_ERRORS) {
                SrvPrint1( "SrvTransactStateNamedPipe: Invalid FID: 0x%lx\n",
                          fid );
            }

            SrvSetSmbError( WorkContext, STATUS_INVALID_HANDLE );
            IF_DEBUG(TRACE2) SrvPrint0( "SrvTransactNamedPipe complete\n" );
            *SmbStatus = SmbStatusSendResponse;
            return TRUE;

        }

        //
        // The work item has been queued because a raw write is in
        // progress.
        //

        *SmbStatus = SmbStatusInProgress;
        return TRUE;

    }

    //
    // See and see if all the data will fit into the response buffer.
    // Reject the long path if not the case.
    // The "+1" on the MaxSetupCount calculation below accounts for the
    // USHORT byte count in the buffer.
    //

    maxParameterCount = SmbGetUshort( &request->MaxParameterCount );
    maxDataCount = SmbGetUshort( &request->MaxDataCount );
    session = rfcb->Lfcb->Session;
    outputBufferSize = ((maxParameterCount * sizeof(CHAR) + 3) & ~3) +
                       ((maxDataCount * sizeof(CHAR) + 3) & ~3) +
                       (((request->MaxSetupCount + 1) * sizeof(USHORT) + 3) & ~3);

    if ( sizeof(SMB_HEADER) +
            sizeof (RESP_TRANSACTION) +
            outputBufferSize
                    > (ULONG)session->MaxBufferSize) {

        //
        // This won't fit.  Use the long path.
        //

        return(FALSE);
    }

    //
    // If this operation may block, and we are running short of
    // free work items, fail this SMB with an out of resources error.
    //

    if ( SrvReceiveBufferShortage( ) ) {

        SrvStatistics.BlockingSmbsRejected++;

        SrvSetSmbError(
            WorkContext,
            STATUS_INSUFF_SERVER_RESOURCES
            );

        *SmbStatus = SmbStatusSendResponse;
        return TRUE;

    } else {

        //
        // SrvBlockingOpsInProgress has already been incremented.
        // Flag this work item as a blocking operation.
        //

        WorkContext->BlockingOperation = TRUE;

    }

    //
    // Set the Restart Routine addresses in the work context block.
    //

    DEBUG WorkContext->FsdRestartRoutine = NULL;

    //
    // Setup pointers and locals.
    //

    outSetup = (PSMB_USHORT)response->Buffer;

    //
    // The "+1" on the end of the following calculation is to account
    // for the USHORT byte count, which could overwrite data in certain
    // cases should the MaxSetupCount be 0.
    //

    outParam = (PCHAR)(outSetup + (request->MaxSetupCount + 1));
    offset = (CLONG)((outParam - (PCHAR)header + 3) & ~3);
    outParam = (PCHAR)header + offset;

    outData = outParam + maxParameterCount;
    offset = (CLONG)((outData - (PCHAR)header + 3) & ~3);
    outData = (PCHAR)header + offset;

    //
    // Fill in the work context parameters.
    //

    WorkContext->Parameters.FastTransactNamedPipe.OutSetup = outSetup;
    WorkContext->Parameters.FastTransactNamedPipe.OutParam = outParam;
    WorkContext->Parameters.FastTransactNamedPipe.OutData = outData;

    //
    // Inline SrvBuildIoControlRequest
    //

    {
        //
        // Get a pointer to the next stack location.  This one is used to
        // hold the parameters for the device I/O control request.
        //

        irpSp = IoGetNextIrpStackLocation( irp );

        //
        // Set up the completion routine.
        //

        IoSetCompletionRoutine(
            irp,
            RestartFastTransactNamedPipe,
            (PVOID)WorkContext,
            TRUE,
            TRUE,
            TRUE
            );

        irpSp->MajorFunction = IRP_MJ_FILE_SYSTEM_CONTROL;
        irpSp->MinorFunction = 0;

        irpSp->DeviceObject = rfcb->Lfcb->DeviceObject;
        irpSp->FileObject = rfcb->Lfcb->FileObject;

        irp->Tail.Overlay.OriginalFileObject = irpSp->FileObject;
        irp->Tail.Overlay.Thread = WorkContext->CurrentWorkQueue->IrpThread;
        DEBUG irp->RequestorMode = KernelMode;

        irp->MdlAddress = NULL;
        irp->AssociatedIrp.SystemBuffer = outData;
        irpSp->Parameters.DeviceIoControl.Type3InputBuffer =
                    (PCHAR)header + SmbGetUshort( &request->DataOffset );

        //
        // Copy the caller's parameters to the service-specific portion of the
        // IRP for those parameters that are the same for all three methods.
        //

        irpSp->Parameters.FileSystemControl.OutputBufferLength = maxDataCount;
        irpSp->Parameters.FileSystemControl.InputBufferLength =
                                    SmbGetUshort( &request->DataCount );
        irpSp->Parameters.FileSystemControl.FsControlCode =
                                                FSCTL_PIPE_INTERNAL_TRANSCEIVE;

    }

    //
    // Pass the request to NPFS.
    //

    (VOID)IoCallDriver( irpSp->DeviceObject, irp );

    //
    // The tranceive was successfully started.  Return the InProgress
    // status to the caller, indicating that the caller should do
    // nothing further with the SMB/WorkContext at the present time.
    //

    IF_DEBUG(TRACE2) SrvPrint0( "SrvTransactNamedPipe complete\n" );
    *SmbStatus = SmbStatusInProgress;
    return TRUE;

} // SrvFastTransactNamedPipe


SMB_TRANS_STATUS
SrvRawWriteNamedPipe (
    IN OUT PWORK_CONTEXT WorkContext
    )

/*++

Routine Description:

    This function handles the raw write named pipe transaction SMB.
    The call to NPFS is issued asynchronously and is completed by
    RestartRawWriteNamedPipe().

Arguments:

    WorkContext - A pointer to a WORK_CONTEXT block.

Return Value:

    SMB_TRANS_STATUS - Indicates whether an error occurred.  See
        smbtypes.h for a more complete description.

--*/

{
    PTRANSACTION transaction;
    USHORT fid;
    PRFCB rfcb;
    NTSTATUS status;

    PAGED_CODE( );

    transaction = WorkContext->Parameters.Transaction;

    //
    // Get the FID from the second setup word and use it to generate a
    // pointer to the RFCB.
    //
    // SrvVerifyFid will fill in WorkContext->Rfcb.
    //

    fid = SmbGetUshort( &transaction->InSetup[1] );

    rfcb = SrvVerifyFid(
                WorkContext,
                fid,
                FALSE,
                SrvRestartExecuteTransaction,   // serialize with raw write
                &status
                );

    if ( rfcb == SRV_INVALID_RFCB_POINTER ) {

        if ( !NT_SUCCESS( status ) ) {

            //
            // Invalid file ID.  Reject the request.
            //

            IF_DEBUG(SMB_ERRORS) {
                SrvPrint1( "SrvRawWriteStateNamedPipe: Invalid FID: 0x%lx\n",
                          fid );
            }

            SrvSetSmbError( WorkContext, STATUS_INVALID_HANDLE );
            IF_DEBUG(TRACE2) SrvPrint0( "SrvRawWriteNamedPipe complete\n" );
            return SmbTransStatusErrorWithoutData;

        }

        //
        // The work item has been queued because a raw write is in
        // progress.
        //

        return SmbTransStatusInProgress;

    }

    //
    // We only allow the special 0 bytes message mode write.  Otherwise
    // reject the request.
    //

    if ( transaction->DataCount != 2 ||
         transaction->InData[0] != 0 ||
         transaction->InData[1] != 0 ||
         rfcb->ByteModePipe ) {

        SrvSetSmbError( WorkContext, STATUS_INVALID_PARAMETER );
        return SmbTransStatusErrorWithoutData;

    }

    //
    // Set the Restart Routine addresses in the work context block.
    //

    WorkContext->FsdRestartRoutine = SrvQueueWorkToFspAtDpcLevel;
    WorkContext->FspRestartRoutine = RestartRawWriteNamedPipe;

    SrvBuildIoControlRequest(
        WorkContext->Irp,
        rfcb->Lfcb->FileObject,
        WorkContext,
        IRP_MJ_FILE_SYSTEM_CONTROL,
        FSCTL_PIPE_INTERNAL_WRITE,
        transaction->InData,
        0,
        NULL,
        0,
        NULL,
        NULL
        );

    //
    // Pass the request to NPFS.
    //

    IoCallDriver( rfcb->Lfcb->DeviceObject, WorkContext->Irp );

    //
    // The write was successfully started.  Return the InProgress
    // status to the caller, indicating that the caller should do
    // nothing further with the SMB/WorkContext at the present time.
    //

    IF_DEBUG(TRACE2) SrvPrint0( "SrvRawWriteNamedPipe complete\n" );
    return SmbTransStatusInProgress;

} // SrvRawWriteNamedPipe


VOID SRVFASTCALL
RestartCallNamedPipe (
    IN OUT PWORK_CONTEXT WorkContext
    )

/*++

Routine Description:

    This is the completion routine for SrvCallNamedPipe

Arguments:

    WorkContext - A pointer to a WORK_CONTEXT block.

Return Value:

    None.

--*/

{
    NTSTATUS status;
    PTRANSACTION transaction;

    PAGED_CODE( );

    //
    // If the transceive request failed, set an error status in the response
    // header.
    //

    status = WorkContext->Irp->IoStatus.Status;
    transaction = WorkContext->Parameters.Transaction;

    if ( status == STATUS_BUFFER_OVERFLOW ) {

        //
        // Down level clients, expect us to return STATUS_SUCCESS.
        //

        if ( !IS_NT_DIALECT( WorkContext->Connection->SmbDialect ) ) {
            status = STATUS_SUCCESS;

        } else {

            //
            // The buffer we supplied is not big enough.  Set the
            // error fields in the SMB, but continue so that we send
            // all the information.
            //

            SrvSetSmbError2( WorkContext, STATUS_BUFFER_OVERFLOW, TRUE );

        }

    } else if ( !NT_SUCCESS(status) ) {

        IF_DEBUG(ERRORS) {
            SrvPrint1( "RestartCallNamedPipe:  Pipe transceive failed: %X\n",
                        status );
        }
        SrvSetSmbError( WorkContext, status );

    } else {

        //
        // Success.  Prepare to generate and send the response.
        //

        transaction->SetupCount = 0;
        transaction->ParameterCount = 0;
        transaction->DataCount = (ULONG)WorkContext->Irp->IoStatus.Information;

    }

    //
    // Close the open pipe handle.
    //

    SRVDBG_RELEASE_HANDLE( transaction->FileHandle, "FIL", 19, transaction );
    SrvNtClose( transaction->FileHandle, TRUE );
    ObDereferenceObject( transaction->FileObject );

    //
    // Respond to the client
    //

    if ( NT_SUCCESS(status) ) {
        SrvCompleteExecuteTransaction(WorkContext, SmbTransStatusSuccess);
    } else if ( status == STATUS_BUFFER_OVERFLOW ) {
        SrvCompleteExecuteTransaction(WorkContext, SmbTransStatusErrorWithData);
    } else {
        IF_DEBUG(ERRORS) SrvPrint1( "Pipe call failed: %X\n", status );
        SrvSetSmbError( WorkContext, status );
        SrvCompleteExecuteTransaction(
                        WorkContext,
                        SmbTransStatusErrorWithoutData
                        );
    }

    IF_DEBUG(TRACE2) SrvPrint0( "RestartCallNamedPipe complete\n" );
    return;

} // RestartCallNamedPipe


VOID SRVFASTCALL
RestartWaitNamedPipe (
    IN OUT PWORK_CONTEXT WorkContext
    )

/*++

Routine Description:

    This is the completion routine for SrvWaitNamedPipe

Arguments:

    WorkContext - A pointer to a WORK_CONTEXT block.

Return Value:

    None.

--*/

{
    PTRANSACTION transaction;
    NTSTATUS status;

    PAGED_CODE( );

    //
    // Deallocate the wait buffer.
    //

    DEALLOCATE_NONPAGED_POOL( WorkContext->Irp->AssociatedIrp.SystemBuffer );

    //
    // If the wait request failed, set an error status in the response
    // header.
    //

    status = WorkContext->Irp->IoStatus.Status;

    if ( !NT_SUCCESS(status) ) {
        IF_DEBUG(ERRORS) SrvPrint1( "Pipe wait failed: %X\n", status );
        SrvSetSmbError( WorkContext, status );
        SrvCompleteExecuteTransaction(
                        WorkContext,
                        SmbTransStatusErrorWithoutData
                        );
        IF_DEBUG(TRACE2) SrvPrint0( "RestartWaitNamedPipe complete\n" );
        return;
    }

    //
    // Success.  Prepare to generate and send the response.
    //

    transaction = WorkContext->Parameters.Transaction;

    transaction->SetupCount = 0;
    transaction->ParameterCount = 0;
    transaction->DataCount = 0;

    //
    // Generate and send the response.
    //

    SrvCompleteExecuteTransaction(WorkContext, SmbTransStatusSuccess);
    IF_DEBUG(TRACE2) SrvPrint0( "RestartWaitNamedPipe complete\n" );
    return;

} // RestartWaitNamedPipe


VOID SRVFASTCALL
RestartPeekNamedPipe (
    IN OUT PWORK_CONTEXT WorkContext
    )

/*++

Routine Description:

    This is the completion routine for PeekNamedPipe

Arguments:

    WorkContext - A pointer to a WORK_CONTEXT block.

Return Value:

    None.

--*/

{
    NTSTATUS status;
    PFILE_PIPE_PEEK_BUFFER pipePeekBuffer;
    PRESP_PEEK_NMPIPE respPeekNmPipe;
    USHORT readDataAvailable, messageLength, namedPipeState;
    PTRANSACTION transaction;

    PAGED_CODE( );

    //
    // If the peek request failed, set an error status in the response
    // header.
    //

    status = WorkContext->Irp->IoStatus.Status;

    if ( status == STATUS_BUFFER_OVERFLOW ) {

        //
        // Down level clients, expect us to return STATUS_SUCCESS.
        //

        if ( !IS_NT_DIALECT( WorkContext->Connection->SmbDialect ) ) {
            status = STATUS_SUCCESS;

        } else {

            //
            // The buffer we supplied is not big enough.  Set the
            // error fields in the SMB, but continue so that we send
            // all the information.
            //

            SrvSetSmbError2( WorkContext, STATUS_BUFFER_OVERFLOW, TRUE );

        }

    } else if ( !NT_SUCCESS(status) ) {

        IF_DEBUG(ERRORS) SrvPrint1( "Pipe peek failed: %X\n", status );

        SrvSetSmbError( WorkContext, status );
        SrvCompleteExecuteTransaction(
                        WorkContext,
                        SmbTransStatusErrorWithoutData
                        );
        IF_DEBUG(TRACE2) SrvPrint0( "RestartPeekNamedPipe complete\n" );
        return;
    }

    //
    // Success.  Generate and send the response.
    //
    // The parameter bytes are currently in the format returned by NT.
    // we will reformat them, and leave the extra space between the
    // parameter and data bytes as extra pad.
    //

    //
    // Since the NT and SMB formats overlap
    //   First read all the parameters into locals...
    //

    transaction = WorkContext->Parameters.Transaction;
    pipePeekBuffer = (PFILE_PIPE_PEEK_BUFFER)transaction->OutParameters;

    readDataAvailable = (USHORT)pipePeekBuffer->ReadDataAvailable;
    messageLength = (USHORT)pipePeekBuffer->MessageLength;
    namedPipeState = (USHORT)pipePeekBuffer->NamedPipeState;

    //
    // ... then copy them back in the new format.
    //

    respPeekNmPipe = (PRESP_PEEK_NMPIPE)pipePeekBuffer;
    SmbPutAlignedUshort(
        &respPeekNmPipe->ReadDataAvailable,
        readDataAvailable
        );
    SmbPutAlignedUshort(
        &respPeekNmPipe->MessageLength,
        messageLength
        );
    SmbPutAlignedUshort(
        &respPeekNmPipe->NamedPipeState,
        namedPipeState
        );

    //
    // Send the response.  Set the output counts.
    //
    // NT return to us 4 ULONGS of parameter bytes, followed by data.
    // We return to the client 6 parameter bytes.
    //

    transaction->SetupCount = 0;
    transaction->ParameterCount = 6;
    transaction->DataCount = (ULONG)WorkContext->Irp->IoStatus.Information -
                                        (4 * sizeof(ULONG));

    if (NT_SUCCESS(status)) {
        SrvCompleteExecuteTransaction(WorkContext, SmbTransStatusSuccess);
    } else {
        SrvCompleteExecuteTransaction(WorkContext, SmbTransStatusErrorWithData);
    }
    IF_DEBUG(TRACE2) SrvPrint0( "RestartPeekNamedPipe complete\n" );
    return;

} // RestartPeekNamedPipe


VOID SRVFASTCALL
RestartTransactNamedPipe (
    IN OUT PWORK_CONTEXT WorkContext
    )

/*++

Routine Description:

    This is the completion routine for SrvTransactNamedPipe

Arguments:

    WorkContext - A pointer to a WORK_CONTEXT block.

Return Value:

    None.

--*/

{
    NTSTATUS status;
    PTRANSACTION transaction;

    PAGED_CODE( );

    //
    // If the transceive request failed, set an error status in the response
    // header.
    //

    status = WorkContext->Irp->IoStatus.Status;

    if ( status == STATUS_BUFFER_OVERFLOW ) {

#if 0
        //
        // Down level clients, expect us to return STATUS_SUCCESS.
        //

        if ( !IS_NT_DIALECT( WorkContext->Connection->SmbDialect ) ) {
            status = STATUS_SUCCESS;

        } else {

            //
            // The buffer we supplied is not big enough.  Set the
            // error fields in the SMB, but continue so that we send
            // all the information.
            //

            SrvSetSmbError2( WorkContext, STATUS_BUFFER_OVERFLOW, TRUE );

        }
#else

        //
        // os/2 returns ERROR_MORE_DATA in this case, why we convert
        // this to NO_ERROR is a mystery.
        //

        SrvSetSmbError2( WorkContext, STATUS_BUFFER_OVERFLOW, TRUE );
#endif

    } else if ( !NT_SUCCESS(status) ) {

        IF_DEBUG(ERRORS) SrvPrint1( "Pipe transceive failed: %X\n", status );

        SrvSetSmbError(WorkContext, status);
        SrvCompleteExecuteTransaction(
                        WorkContext,
                        SmbTransStatusErrorWithoutData
                        );
        IF_DEBUG(TRACE2) SrvPrint0( "RestartTransactNamedPipe complete\n" );
        return;
    }

    //
    // Success.  Generate and send the response.
    //

    transaction = WorkContext->Parameters.Transaction;

    transaction->SetupCount = 0;
    transaction->ParameterCount = 0;
    transaction->DataCount = (ULONG)WorkContext->Irp->IoStatus.Information;

    if ( NT_SUCCESS(status) ) {
        SrvCompleteExecuteTransaction(WorkContext, SmbTransStatusSuccess);
    } else {
        SrvCompleteExecuteTransaction(WorkContext, SmbTransStatusErrorWithData);
    }

    IF_DEBUG(TRACE2) SrvPrint0( "RestartTransactNamedPipe complete\n" );
    return;

} // RestartTransactNamedpipe


NTSTATUS
RestartFastTransactNamedPipe (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN OUT PWORK_CONTEXT WorkContext
    )

/*++

Routine Description:

    This is the completion routine for SrvFastTransactNamedPipe

Arguments:

    DeviceObject - Pointer to target device object for the request.

    Irp - Pointer to I/O request packet

    WorkContext - A pointer to a WORK_CONTEXT block.

Return Value:

    STATUS_MORE_PROCESSING_REQUIRED.

--*/

{
    NTSTATUS status;
    PSMB_HEADER header;
    PRESP_TRANSACTION response;

    PSMB_USHORT byteCountPtr;
    PCHAR paramPtr;
    CLONG paramOffset;
    PCHAR dataPtr;
    CLONG dataOffset;
    CLONG dataLength;
    CLONG sendLength;

    UNLOCKABLE_CODE( 8FIL );

    //
    // Reset the IRP cancelled bit.
    //

    Irp->Cancel = FALSE;

    //
    // If the transceive request failed, set an error status in the response
    // header.
    //

    status = WorkContext->Irp->IoStatus.Status;

    if ( status == STATUS_BUFFER_OVERFLOW ) {

        //
        // os/2 returns ERROR_MORE_DATA in this case, why we convert
        // this to NO_ERROR is a mystery.
        //

        SrvSetBufferOverflowError( WorkContext );

    } else if ( !NT_SUCCESS(status) ) {

        IF_DEBUG(ERRORS) SrvPrint1( "Pipe transceive failed: %X\n", status );

        if ( KeGetCurrentIrql() >= DISPATCH_LEVEL ) {
            WorkContext->FspRestartRoutine = RestartFastTransactNamedPipe2;
            QUEUE_WORK_TO_FSP( WorkContext );
            return STATUS_MORE_PROCESSING_REQUIRED;
        }

        RestartFastTransactNamedPipe2( WorkContext );
        goto error_no_data;
    }

    //
    // Success.  Generate and send the response.
    //

    dataLength = (CLONG)WorkContext->Irp->IoStatus.Information;

    header = WorkContext->ResponseHeader;

    //
    // Save a pointer to the byte count field.
    //
    // If the output data and parameters are not already in the SMB
    // buffer we must calculate how much of the parameters and data can
    // be sent in this response.  The maximum amount we can send is
    // minimum of the size of our buffer and the size of the client's
    // buffer.
    //
    // The parameter and data byte blocks are aligned on longword
    // boundaries in the message.
    //

    byteCountPtr = WorkContext->Parameters.FastTransactNamedPipe.OutSetup;

    //
    // The data and paramter are already in the SMB buffer.  The entire
    // response will fit in one response buffer and there is no copying
    // to do.
    //

    paramPtr = WorkContext->Parameters.FastTransactNamedPipe.OutParam;
    paramOffset = (CLONG)(paramPtr - (PCHAR)header);

    dataPtr = WorkContext->Parameters.FastTransactNamedPipe.OutData;
    dataOffset = (CLONG)(dataPtr - (PCHAR)header);

    //
    // The client wants a response.  Build the first (and possibly only)
    // response.  The last received SMB of the transaction request was
    // retained for this purpose.
    //

    response = (PRESP_TRANSACTION)WorkContext->ResponseParameters;

    //
    // Build the parameters portion of the response.
    //

    response->WordCount = (UCHAR)10;
    SmbPutUshort( &response->TotalParameterCount,
                  (USHORT)0
                  );
    SmbPutUshort( &response->TotalDataCount,
                  (USHORT)dataLength
                  );
    SmbPutUshort( &response->Reserved, 0 );
    response->SetupCount = (UCHAR)0;
    response->Reserved2 = 0;

    //
    // We need to be sure we're not sending uninitialized kernel memory
    // back to the client with the response, so zero out the range between
    // byteCountPtr and dataPtr.
    //

    RtlZeroMemory(byteCountPtr,(ULONG)(dataPtr - (PCHAR)byteCountPtr));

    //
    // Finish filling in the response parameters.
    //

    SmbPutUshort( &response->ParameterCount, (USHORT)0 );
    SmbPutUshort( &response->ParameterOffset, (USHORT)paramOffset );
    SmbPutUshort( &response->ParameterDisplacement, 0 );

    SmbPutUshort( &response->DataCount, (USHORT)dataLength );
    SmbPutUshort( &response->DataOffset, (USHORT)dataOffset );
    SmbPutUshort( &response->DataDisplacement, 0 );

    SmbPutUshort(
        byteCountPtr,
        (USHORT)(dataPtr - (PCHAR)(byteCountPtr + 1) + dataLength)
        );

    //
    // Calculate the length of the response message.
    //

    sendLength = (CLONG)( dataPtr + dataLength -
                                (PCHAR)WorkContext->ResponseHeader );

    WorkContext->ResponseBuffer->DataLength = sendLength;

    //
    // Set the bit in the SMB that indicates this is a response from the
    // server.
    //

    WorkContext->ResponseHeader->Flags |= SMB_FLAGS_SERVER_TO_REDIR;

    //
    // Send the response.
    //

    SRV_START_SEND_2(
        WorkContext,
        SrvFsdRestartSmbAtSendCompletion,
        NULL,
        NULL
        );

error_no_data:

    //
    // The response send is in progress.  The caller will assume
    // the we will handle send completion.
    //
    // Return STATUS_MORE_PROCESSING_REQUIRED so that IoCompleteRequest
    // will stop working on the IRP.
    //

    IF_DEBUG(TRACE2) SrvPrint0( "RestartTransactNamedPipe complete\n" );
    return STATUS_MORE_PROCESSING_REQUIRED;

} // RestartFastTransactNamedPipe


VOID SRVFASTCALL
RestartFastTransactNamedPipe2 (
    IN OUT PWORK_CONTEXT WorkContext
    )

/*++

Routine Description:

    This is the completion routine for SrvFastTransactNamedPipe

Arguments:

    WorkContext - A pointer to a WORK_CONTEXT block.

Return Value:

    None.

--*/

{
    PAGED_CODE( );

    //
    // The transceive request failed.  Set an error status in the response
    // header.
    //

    SrvSetSmbError( WorkContext, WorkContext->Irp->IoStatus.Status );

    //
    // An error occurred, so no transaction-specific response data
    // will be returned.
    //
    // Calculate the length of the response message.
    //


    WorkContext->ResponseBuffer->DataLength =
                 (CLONG)( (PCHAR)WorkContext->ResponseParameters -
                            (PCHAR)WorkContext->ResponseHeader );

    //
    // Send the response.
    //

    SRV_START_SEND_2(
        WorkContext,
        SrvFsdRestartSmbAtSendCompletion,
        NULL,
        NULL
        );

    return;

} // RestartFastTransactNamedPipe2


VOID SRVFASTCALL
RestartRawWriteNamedPipe (
    IN OUT PWORK_CONTEXT WorkContext
    )

/*++

Routine Description:

    This is the completion routine for SrvRawWriteNamedPipe

Arguments:

    WorkContext - A pointer to a WORK_CONTEXT block.

Return Value:

    None.

--*/

{
    NTSTATUS status;
    PTRANSACTION transaction;

    PAGED_CODE( );

    //
    // If the write request failed, set an error status in the response
    // header.
    //

    status = WorkContext->Irp->IoStatus.Status;

    if ( !NT_SUCCESS(status) ) {

        IF_DEBUG(ERRORS) SrvPrint1( "Pipe raw write failed: %X\n", status );

        SrvSetSmbError( WorkContext, status );
        SrvCompleteExecuteTransaction(
            WorkContext,
            SmbTransStatusErrorWithoutData
            );
        IF_DEBUG(TRACE2) SrvPrint0( "RestartRawWriteNamedPipe complete\n" );
        return;

    }

    //
    // Success.  Generate and send the response.
    //

    transaction = WorkContext->Parameters.Transaction;

    transaction->SetupCount = 0;
    transaction->ParameterCount = 2;
    transaction->DataCount = 0;

    SmbPutUshort( (PSMB_USHORT)transaction->OutParameters, 2 );

    SrvCompleteExecuteTransaction(WorkContext, SmbTransStatusSuccess);

    IF_DEBUG(TRACE2) SrvPrint0( "RestartRawWriteNamedPipe complete\n" );
    return;

} // RestartRawWriteNamedpipe


SMB_TRANS_STATUS
SrvWriteNamedPipe (
    IN OUT PWORK_CONTEXT WorkContext
    )

/*++

Routine Description:

    This function handles the raw write named pipe transaction SMB.
    The call to NPFS is issued asynchronously and is completed by
    RestartRawWriteNamedPipe().

Arguments:

    WorkContext - A pointer to a WORK_CONTEXT block.

Return Value:

    SMB_TRANS_STATUS - Indicates whether an error occurred.  See
        smbtypes.h for a more complete description.

--*/

{
    PTRANSACTION transaction;
    USHORT fid;
    PRFCB rfcb;
    PLFCB lfcb;
    NTSTATUS status;
    LARGE_INTEGER offset;
    ULONG key = 0;
    PCHAR writeAddress;
    CLONG writeLength;

    PAGED_CODE( );

    transaction = WorkContext->Parameters.Transaction;

    //
    // Get the FID from the second setup word and use it to generate a
    // pointer to the RFCB.
    //
    // SrvVerifyFid will fill in WorkContext->Rfcb.
    //

    fid = SmbGetUshort( &transaction->InSetup[1] );

    IF_DEBUG(IPX_PIPES) {
        KdPrint(("SrvWriteNamedPipe: fid = %x length = %d\n",
                fid, transaction->DataCount));
    }

    rfcb = SrvVerifyFid(
                WorkContext,
                fid,
                FALSE,
                SrvRestartExecuteTransaction,   // serialize with raw write
                &status
                );

    if ( rfcb == SRV_INVALID_RFCB_POINTER ) {

        if ( !NT_SUCCESS( status ) ) {

            //
            // Invalid file ID.  Reject the request.
            //

            IF_DEBUG(SMB_ERRORS) {
                SrvPrint1( "SrvWriteNamedPipe: Invalid FID: 0x%lx\n",
                          fid );
            }

            SrvSetSmbError( WorkContext, STATUS_INVALID_HANDLE );
            IF_DEBUG(TRACE2) SrvPrint0( "SrvWriteNamedPipe complete\n" );
            return SmbTransStatusErrorWithoutData;

        }

        //
        // The work item has been queued because a raw write is in
        // progress.
        //

        return SmbTransStatusInProgress;

    }

    lfcb = rfcb->Lfcb;
    writeLength = transaction->DataCount;
    writeAddress = transaction->InData;

    //
    // Try the fast I/O path first.  If that fails, fall through to the
    // normal build-an-IRP path.
    //

    if ( lfcb->FastIoWrite != NULL ) {

        INCREMENT_DEBUG_STAT2( SrvDbgStatistics.FastWritesAttempted );

        try {
            if ( lfcb->FastIoWrite(
                    lfcb->FileObject,
                    &offset,
                    writeLength,
                    TRUE,
                    key,
                    writeAddress,
                    &WorkContext->Irp->IoStatus,
                    lfcb->DeviceObject
                    ) ) {
    
                //
                // The fast I/O path worked.  Call the restart routine directly
                // to do postprocessing (including sending the response).
                //
    
                RestartWriteNamedPipe( WorkContext );
    
                IF_DEBUG(IPX_PIPES) SrvPrint0( "SrvWriteNamedPipe complete.\n" );
                return SmbTransStatusInProgress;
            }
        }
        except( EXCEPTION_EXECUTE_HANDLER ) {
            // Fall through to the slow path on an exception
            NTSTATUS status = GetExceptionCode();
            IF_DEBUG(ERRORS) {
                KdPrint(("FastIoRead threw exception %x\n", status ));
            }
        }        

        INCREMENT_DEBUG_STAT2( SrvDbgStatistics.FastWritesFailed );

    }

    IF_DEBUG(IPX_PIPES) {
        KdPrint(("SrvWriteNamedPipe: Using slow path.\n"));
    }

    //
    // The turbo path failed.  Build the write request, reusing the
    // receive IRP.
    //
    // Build the PIPE_INTERNAL_WRITE IRP.
    //

    SrvBuildIoControlRequest(
        WorkContext->Irp,
        lfcb->FileObject,
        WorkContext,
        IRP_MJ_FILE_SYSTEM_CONTROL,
        FSCTL_PIPE_INTERNAL_WRITE,
        writeAddress,
        writeLength,
        NULL,
        0,
        NULL,
        NULL
        );

    //
    // Pass the request to the file system.
    //

    WorkContext->FsdRestartRoutine = SrvQueueWorkToFspAtDpcLevel;
    WorkContext->FspRestartRoutine = RestartWriteNamedPipe;

    (VOID)IoCallDriver( lfcb->DeviceObject, WorkContext->Irp );

    //
    // The write has been started.  Control will return to
    // RestartWriteNamedPipe when the write completes.
    //

    IF_DEBUG(TRACE2) SrvPrint0( "SrvWriteNamedPipe complete\n" );
    return SmbTransStatusInProgress;

} // SrvWriteNamedPipe

VOID SRVFASTCALL
RestartWriteNamedPipe (
    IN OUT PWORK_CONTEXT WorkContext
    )

/*++

Routine Description:

    This is the completion routine for SrvRawWriteNamedPipe

Arguments:

    WorkContext - A pointer to a WORK_CONTEXT block.

Return Value:

    None.

--*/

{
    NTSTATUS status;
    PIO_STATUS_BLOCK iosb;
    PTRANSACTION transaction;

    PAGED_CODE( );

    //
    // If the write request failed, set an error status in the response
    // header.
    //

    iosb = &WorkContext->Irp->IoStatus;
    status = iosb->Status;

    IF_DEBUG(IPX_PIPES) {
        KdPrint(("RestartWriteNamedPipe: Status = %x\n", status));
    }

    if ( !NT_SUCCESS(status) ) {

        IF_DEBUG(ERRORS) SrvPrint1( " pipe write failed: %X\n", status );

        SrvSetSmbError( WorkContext, status );
        SrvCompleteExecuteTransaction(
            WorkContext,
            SmbTransStatusErrorWithoutData
            );
        IF_DEBUG(TRACE2) SrvPrint0( "RestartWriteNamedPipe complete\n" );
        return;

    }

    //
    // Success.  Generate and send the response.
    //

    transaction = WorkContext->Parameters.Transaction;

    transaction->SetupCount = 0;
    transaction->ParameterCount = 2;
    transaction->DataCount = 0;

    SmbPutUshort( (PSMB_USHORT)transaction->OutParameters,
                    (USHORT)iosb->Information
                    );

    SrvCompleteExecuteTransaction(WorkContext, SmbTransStatusSuccess);

    IF_DEBUG(TRACE2) SrvPrint0( "RestartWriteNamedPipe complete\n" );
    return;

} // RestartWriteNamedPipe

SMB_TRANS_STATUS
SrvReadNamedPipe (
    IN OUT PWORK_CONTEXT WorkContext
    )

/*++

Routine Description:

    This function handles the raw Read named pipe transaction SMB.
    The call to NPFS is issued asynchronously and is completed by
    RestartRawReadNamedPipe().

Arguments:

    WorkContext - A pointer to a WORK_CONTEXT block.

Return Value:

    SMB_TRANS_STATUS - Indicates whether an error occurred.  See
        smbtypes.h for a more complete description.

--*/

{
    PTRANSACTION transaction;
    USHORT fid;
    PRFCB rfcb;
    PLFCB lfcb;
    NTSTATUS status;
    LARGE_INTEGER offset;
    ULONG key = 0;
    PCHAR readAddress;
    CLONG readLength;

    PAGED_CODE( );

    transaction = WorkContext->Parameters.Transaction;

    //
    // Get the FID from the second setup word and use it to generate a
    // pointer to the RFCB.
    //
    // SrvVerifyFid will fill in WorkContext->Rfcb.
    //

    fid = SmbGetUshort( &transaction->InSetup[1] );

    IF_DEBUG(IPX_PIPES) {
        KdPrint(("SrvReadNamedPipe: fid = %x length = %d\n",
                fid, transaction->MaxDataCount));
    }

    rfcb = SrvVerifyFid(
                WorkContext,
                fid,
                FALSE,
                SrvRestartExecuteTransaction,   // serialize with raw Read
                &status
                );

    if ( rfcb == SRV_INVALID_RFCB_POINTER ) {

        if ( !NT_SUCCESS( status ) ) {

            //
            // Invalid file ID.  Reject the request.
            //

            IF_DEBUG(SMB_ERRORS) {
                SrvPrint1( "SrvReadNamedPipe: Invalid FID: 0x%lx\n",
                          fid );
            }

            SrvSetSmbError( WorkContext, STATUS_INVALID_HANDLE );
            IF_DEBUG(TRACE2) SrvPrint0( "SrvReadNamedPipe complete\n" );
            return SmbTransStatusErrorWithoutData;

        }

        //
        // The work item has been queued because a raw Read is in
        // progress.
        //

        return SmbTransStatusInProgress;

    }

    lfcb = rfcb->Lfcb;
    readLength = transaction->MaxDataCount;
    readAddress = transaction->OutData;

    //
    // Try the fast I/O path first.  If that fails, fall through to the
    // normal build-an-IRP path.
    //

    if ( lfcb->FastIoRead != NULL ) {
            
        INCREMENT_DEBUG_STAT2( SrvDbgStatistics.FastReadsAttempted );

        try {            
            if ( lfcb->FastIoRead(
                    lfcb->FileObject,
                    &offset,
                    readLength,
                    TRUE,
                    key,
                    readAddress,
                    &WorkContext->Irp->IoStatus,
                    lfcb->DeviceObject
                    ) ) {
    
                //
                // The fast I/O path worked.  Call the restart routine directly
                // to do postprocessing (including sending the response).
                //
    
                RestartReadNamedPipe( WorkContext );
    
                IF_SMB_DEBUG(READ_WRITE2) SrvPrint0( "SrvReadNamedPipe complete.\n" );
                return SmbTransStatusInProgress;
            }
        }
        except( EXCEPTION_EXECUTE_HANDLER ) {
            // Fall through to the slow path on an exception
            NTSTATUS status = GetExceptionCode();
            IF_DEBUG(ERRORS) {
                KdPrint(("FastIoRead threw exception %x\n", status ));
            }
        }

        INCREMENT_DEBUG_STAT2( SrvDbgStatistics.FastReadsFailed );

    }

    //
    // The turbo path failed.  Build the Read request, reusing the
    // receive IRP.
    //
    // Build the PIPE_INTERNAL_READ IRP.
    //

    SrvBuildIoControlRequest(
        WorkContext->Irp,
        lfcb->FileObject,
        WorkContext,
        IRP_MJ_FILE_SYSTEM_CONTROL,
        FSCTL_PIPE_INTERNAL_READ,
        readAddress,
        0,
        NULL,
        readLength,
        NULL,
        NULL
        );

    //
    // Pass the request to the file system.
    //

    WorkContext->FsdRestartRoutine = SrvQueueWorkToFspAtDpcLevel;
    WorkContext->FspRestartRoutine = RestartReadNamedPipe;

    (VOID)IoCallDriver( lfcb->DeviceObject, WorkContext->Irp );

    //
    // The Read has been started.  Control will return to
    // SrvFsdRestartRead when the Read completes.
    //

    IF_DEBUG(TRACE2) SrvPrint0( "SrvReadNamedPipe complete\n" );
    return SmbTransStatusInProgress;

} // SrvReadNamedPipe


VOID SRVFASTCALL
RestartReadNamedPipe (
    IN OUT PWORK_CONTEXT WorkContext
    )

/*++

Routine Description:

    This is the completion routine for SrvRawReadNamedPipe

Arguments:

    WorkContext - A pointer to a WORK_CONTEXT block.

Return Value:

    None.

--*/

{
    NTSTATUS status;
    PTRANSACTION transaction;

    PAGED_CODE( );

    //
    // If the transceive request failed, set an error status in the response
    // header.
    //

    status = WorkContext->Irp->IoStatus.Status;

    if ( status == STATUS_BUFFER_OVERFLOW ) {

        SrvSetSmbError2( WorkContext, STATUS_BUFFER_OVERFLOW, TRUE );

    } else if ( !NT_SUCCESS(status) ) {

        IF_DEBUG(ERRORS) SrvPrint1( "Pipe transceive failed: %X\n", status );

        SrvSetSmbError(WorkContext, status);
        SrvCompleteExecuteTransaction(
                        WorkContext,
                        SmbTransStatusErrorWithoutData
                        );
        IF_DEBUG(TRACE2) SrvPrint0( "RestartReadNamedPipe complete\n" );
        return;
    }

    //
    // Success.  Generate and send the response.
    //

    transaction = WorkContext->Parameters.Transaction;

    transaction->SetupCount = 0;
    transaction->ParameterCount = 0;
    transaction->DataCount = (ULONG)WorkContext->Irp->IoStatus.Information;

    if ( NT_SUCCESS(status) ) {
        SrvCompleteExecuteTransaction(WorkContext, SmbTransStatusSuccess);
    } else {
        SrvCompleteExecuteTransaction(WorkContext, SmbTransStatusErrorWithData);
    }

    IF_DEBUG(TRACE2) SrvPrint0( "RestartReadNamedPipe complete\n" );
    return;

} // RestartReadNamedPipe
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\srv\rawmpx.h ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    rawmpx.h

Abstract:

    This module defines structures and routines common to raw and
    multiplexed mode processing.

Author:

    Chuck Lenzmeier (chuckl) 30-Sep-1990

Revision History:

--*/

#ifndef _RAWMPX_
#define _RAWMPX_

//#include <ntos.h>

//#include <smb.h>
//#include "smbtypes.h"
//#include "srvblock.h"

//
// Common (raw and mpx) routines, callable from both FSD and FSP.
// Implemented in fsdraw.c.
//
// SrvFsdBuildWriteCompleteResponse can be called from a DISPATCH_LEVEL
// only if Status == STATUS_SUCCESS.
//

VOID
SrvFsdBuildWriteCompleteResponse (
    IN OUT PWORK_CONTEXT WorkContext,
    IN NTSTATUS Status,
    IN ULONG BytesWritten
    );

VOID SRVFASTCALL
RestartMdlReadRawResponse (
    IN OUT PWORK_CONTEXT WorkContext
    );

//
// Raw mode routines callable from both FSD and FSP.  Implemented in
// fsdraw.c.
//

VOID SRVFASTCALL
SrvFsdRestartPrepareRawMdlWrite (
    IN OUT PWORK_CONTEXT WorkContext
    );

VOID SRVFASTCALL
SrvFsdRestartWriteRaw (
    IN OUT PWORK_CONTEXT WorkContext
    );

//
// Raw mode routines called only in FSD, but referenced in FSP.
// Implemented in fsdraw.c.
//

VOID SRVFASTCALL
SrvFsdRestartReadRaw (
    IN OUT PWORK_CONTEXT WorkContext
    );

//
// Raw mode routines called only in FSP, but referenced in FSD, or in
// modules other than smbraw.c.  Implemented in smbraw.c.
//

VOID SRVFASTCALL
SrvBuildAndSendWriteCompleteResponse (
    IN OUT PWORK_CONTEXT WorkContext
    );

VOID SRVFASTCALL
SrvDecrementRawWriteCount (
    IN PRFCB Rfcb
    );

VOID SRVFASTCALL
SrvRestartRawReceive (
    IN OUT PWORK_CONTEXT WorkContext
    );

VOID SRVFASTCALL
SrvRestartReadRawComplete (
    IN OUT PWORK_CONTEXT WorkContext
    );

VOID SRVFASTCALL
SrvRestartWriteCompleteResponse (
    IN OUT PWORK_CONTEXT WorkContext
    );

//
// Special receive restart routine for Write Mpx.
//

VOID SRVFASTCALL
SrvRestartReceiveWriteMpx (
    IN OUT PWORK_CONTEXT WorkContext
    );

//
// Write glomming during indication
//

BOOLEAN
AddPacketToGlomInIndication (
    IN PWORK_CONTEXT WorkContext,
    IN OUT PRFCB Rfcb,
    IN PVOID Tsdu,
    IN ULONG BytesAvailable,
    IN ULONG ReceiveDatagamFlags,
    IN PVOID SourceAddress,
    IN PVOID Options
    );

#endif // def _RAWMPX_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\srv\precomp.h ===
#if defined(SRVKD)

#include <ntos.h>
#include <ntlsa.h>
#include <ntmsv1_0.h>
#include <ntiolog.h>
#include <ntiologc.h>
#include <ntddnfs.h>
#include <ntddser.h>
#include <ntmsv1_0.h>
#include <nturtl.h>
#include <zwapi.h>
#include <fsrtl.h>

#else

#include <ntifs.h>
#include <ntddser.h>

#endif

//  if you include persistent handle code, it's required that you also
//  add in the "IfModified" open code.

#ifdef INCLUDE_SMB_PERSISTENT
#define INCLUDE_SMB_IFMODIFIED
#endif

// header file for WMI event tracing
//
#define _NTDDK_
#include "wmistr.h"
#include "evntrace.h"
#if !defined (SRVKD)
#include "stdarg.h"
#include "wmikm.h"
#endif //#if !defined (SRVKD)
#undef _NTDDK_

#include <windef.h>
#include <winerror.h>

#include <netevent.h>

#include <lm.h>

#include <xactsrv2.h>
#include <alertmsg.h>
#include <msgtext.h>

#include <tstr.h>
#include <stdlib.h>

#include <string.h>

#include <wsnwlink.h>
#include <tdi.h>
#include <tdikrnl.h>
#include <isnkrnl.h>
#include <nbtioctl.h>

#include <protocol.h>

#include <lmcons.h>

#ifndef SECURITY_KERNEL
#define SECURITY_KERNEL
#endif // SECURITY_KERNEL

#ifndef SECURITY_NTLM
#define SECURITY_NTLM
#endif // SECURITY_NTLM

#ifndef SECURITY_KERBEROS
#define SECURITY_KERBEROS
#endif // SECURITY_KERBEROS
#include <security.h>
#include <secint.h>

// #define INCLUDE_SMB_CAIRO
#define INCLUDE_SMB_ALL

#include <smbtypes.h>
#include <smbmacro.h>
#include <smbgtpt.h>
#include <smb.h>
#include <smbtrans.h>
#include <smbipx.h>

//
// Network include files.
//

#include <status.h>
#define INCLUDE_SRV_IPX_SMART_CARD_INTERFACE 1
#include <srvfsctl.h>

//
// Local, independent include files
//

//
// Determine if we are building for a multiprocessor target
//
#if !defined( NT_UP ) || NT_UP == 0
#define MULTIPROCESSOR 1
#else
#define MULTIPROCESSOR 0
#endif

#define DBG_STUCK 1

#include "srvdebug.h"

#if SRVDBG
#define PAGED_DBG 1
#endif
#ifdef PAGED_DBG
#undef PAGED_CODE
#define PAGED_CODE() \
    struct { ULONG bogus; } ThisCodeCantBePaged; \
    ThisCodeCantBePaged; \
    if (KeGetCurrentIrql() > APC_LEVEL) { \
        DbgPrint( "EX: Pageable code called at IRQL %d\n", KeGetCurrentIrql() ); \
        ASSERT(FALSE); \
        DbgBreakPoint(); \
        }
#define PAGED_CODE_CHECK() if (ThisCodeCantBePaged) ;
extern ULONG ThisCodeCantBePaged;
#else
#undef PAGED_CODE
#define PAGED_CODE()
#define PAGED_CODE_CHECK()
#endif


#include "srvconst.h"

#include "lock.h"

#include <smbtrsup.h>

#include "srvstrng.h"

#include <md5.h>
#include <crypt.h>

//
// The following include files are dependent on each other; be careful
// when changing the order in which they appear.
//
#include "srvtypes.h"
#include "srvblock.h"

#if !defined( SRVKD )

#include "srvfsp.h"
#include "srvio.h"
#include "srvfsd.h"
#include "smbprocs.h"
#include "smbctrl.h"
#include "srvsvc.h"
#include "srvdata.h"
#include "srvnet.h"
#include "srvstamp.h"
#include "srvsupp.h"
#include "srvmacro.h"
#include "srvconfg.h"
#include "errorlog.h"
#include "rawmpx.h"
#include "ipx.h"
#include "srvsnap.h"

#ifdef INCLUDE_SMB_PERSISTENT
#include "persist.h"
#endif

#if DBG
#undef ASSERT
#define ASSERT( x ) \
    if( !(x) ) { \
        DbgPrint( "SRV: Assertion Failed at line %u in %s\n", __LINE__, __FILE__ ); \
        DbgBreakPoint(); \
    }
#endif

#if SLMDBG
#undef  ALLOC_PRAGMA
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\srv\scavengr.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    scavengr.c

Abstract:

    This module implements the LAN Manager server FSP resource and
    scavenger threads.

Author:

    Chuck Lenzmeier (chuckl) 30-Dec-1989
    David Treadwell (davidtr)

Environment:

    Kernel mode

Revision History:

--*/

#include "precomp.h"
#include <ntdddisk.h>
#include "scavengr.tmh"
#pragma hdrstop

#define BugCheckFileId SRV_FILE_SCAVENGR

//
// Local data
//

ULONG LastNonPagedPoolLimitHitCount = 0;
ULONG LastNonPagedPoolFailureCount = 0;
ULONG LastPagedPoolLimitHitCount = 0;
ULONG LastPagedPoolFailureCount = 0;

ULONG SrvScavengerCheckRfcbActive = 5;
LONG ScavengerUpdateQosCount = 0;
LONG ScavengerCheckRfcbActive = 0;
LONG FailedWorkItemAllocations = 0;

BOOLEAN EventSwitch = TRUE;

LARGE_INTEGER NextScavengeTime = {0};
LARGE_INTEGER NextAlertTime = {0};

//
// Fields used during shutdown to synchronize with EX worker threads.  We
// need to make sure that no worker thread is running server code before
// we can declare shutdown to be complete -- otherwise the code may be
// unloaded while it's running!
//

BOOLEAN ScavengerInitialized = FALSE;
PKEVENT ScavengerTimerTerminationEvent = NULL;
PKEVENT ScavengerThreadTerminationEvent = NULL;
PKEVENT ResourceThreadTerminationEvent = NULL;

//
// Timer, DPC, and work item used to run the scavenger thread.
//

KTIMER ScavengerTimer = {0};
KDPC ScavengerDpc = {0};

PIO_WORKITEM ScavengerWorkItem = NULL;

BOOLEAN ScavengerRunning = FALSE;

KSPIN_LOCK ScavengerSpinLock = {0};

//
// Flags indicating which scavenger algorithms need to run.
//

BOOLEAN RunShortTermAlgorithm = FALSE;
BOOLEAN RunScavengerAlgorithm = FALSE;
BOOLEAN RunAlerterAlgorithm = FALSE;
BOOLEAN RunSuspectConnectionAlgorithm = FALSE;

//
// Base scavenger timeout.  A timer DPC runs each interval.  It
// schedules EX worker thread work when other longer intervals expire.
//

LARGE_INTEGER ScavengerBaseTimeout = { (ULONG)(-1*10*1000*1000*10), -1 };

#define SRV_MAX_DOS_ATTACK_EVENT_LOGS 10

//
//  Defined somewhere else.
//

LARGE_INTEGER
SecondsToTime (
    IN ULONG Seconds,
    IN BOOLEAN MakeNegative
    );

PIRP
BuildCoreOfSyncIoRequest (
    IN HANDLE FileHandle,
    IN PFILE_OBJECT FileObject OPTIONAL,
    IN PKEVENT Event,
    IN PIO_STATUS_BLOCK IoStatusBlock,
    IN OUT PDEVICE_OBJECT *DeviceObject
    );

NTSTATUS
StartIoAndWait (
    IN PIRP Irp,
    IN PDEVICE_OBJECT DeviceObject,
    IN PKEVENT Event,
    IN PIO_STATUS_BLOCK IoStatusBlock
    );

//
// Local declarations
//

VOID
ScavengerTimerRoutine (
    IN PKDPC Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemArgument1,
    IN PVOID SystemArgument2
    );

VOID
SrvResourceThread (
    IN PVOID Parameter
    );

VOID
ScavengerThread (
    IN PDEVICE_OBJECT DeviceObject,
    IN PVOID Parameter
    );

VOID
ScavengerAlgorithm (
    VOID
    );

VOID
AlerterAlgorithm (
    VOID
    );

VOID
CloseIdleConnection (
    IN PCONNECTION Connection,
    IN PLARGE_INTEGER CurrentTime,
    IN PLARGE_INTEGER DisconnectTime,
    IN PLARGE_INTEGER PastExpirationTime,
    IN PLARGE_INTEGER TwoMinuteWarningTime,
    IN PLARGE_INTEGER FiveMinuteWarningTime
    );

VOID
CreateConnections (
    VOID
    );

VOID
GeneratePeriodicEvents (
    VOID
    );

VOID
ProcessConnectionDisconnects (
    VOID
    );

VOID
ProcessOrphanedBlocks (
    VOID
    );

VOID
TimeoutSessions (
    IN PLARGE_INTEGER CurrentTime
    );

VOID
TimeoutWaitingOpens (
    IN PLARGE_INTEGER CurrentTime
    );

VOID
TimeoutStuckOplockBreaks (
    IN PLARGE_INTEGER CurrentTime
    );

VOID
UpdateConnectionQos (
    IN PLARGE_INTEGER currentTime
    );

VOID
UpdateSessionLastUseTime(
    IN PLARGE_INTEGER CurrentTime
    );

VOID
LazyFreeQueueDataStructures (
    PWORK_QUEUE queue
    );

VOID
SrvUserAlertRaise (
    IN ULONG Message,
    IN ULONG NumberOfStrings,
    IN PUNICODE_STRING String1 OPTIONAL,
    IN PUNICODE_STRING String2 OPTIONAL,
    IN PUNICODE_STRING ComputerName
    );

VOID
SrvAdminAlertRaise (
    IN ULONG Message,
    IN ULONG NumberOfStrings,
    IN PUNICODE_STRING String1 OPTIONAL,
    IN PUNICODE_STRING String2 OPTIONAL,
    IN PUNICODE_STRING String3 OPTIONAL
    );

NTSTATUS
TimeToTimeString (
    IN PLARGE_INTEGER Time,
    OUT PUNICODE_STRING TimeString
    );

ULONG
CalculateErrorSlot (
    PSRV_ERROR_RECORD ErrorRecord
    );

VOID
CheckErrorCount (
    PSRV_ERROR_RECORD ErrorRecord,
    BOOLEAN UseRatio
    );

VOID
CheckDiskSpace (
    VOID
    );

NTSTATUS
OpenAlerter (
    OUT PHANDLE AlerterHandle
    );

VOID
RecalcCoreSearchTimeout(
    VOID
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text( PAGE, SrvInitializeScavenger )
#pragma alloc_text( PAGE, ScavengerAlgorithm )
#pragma alloc_text( PAGE, AlerterAlgorithm )
#pragma alloc_text( PAGE, CloseIdleConnection )
#pragma alloc_text( PAGE, CreateConnections )
#pragma alloc_text( PAGE, GeneratePeriodicEvents )
#pragma alloc_text( PAGE, TimeoutSessions )
#pragma alloc_text( PAGE, TimeoutWaitingOpens )
#pragma alloc_text( PAGE, TimeoutStuckOplockBreaks )
#pragma alloc_text( PAGE, UpdateConnectionQos )
#pragma alloc_text( PAGE, UpdateSessionLastUseTime )
#pragma alloc_text( PAGE, SrvUserAlertRaise )
#pragma alloc_text( PAGE, SrvAdminAlertRaise )
#pragma alloc_text( PAGE, TimeToTimeString )
#pragma alloc_text( PAGE, CheckErrorCount )
#pragma alloc_text( PAGE, CheckDiskSpace )
#pragma alloc_text( PAGE, OpenAlerter )
#pragma alloc_text( PAGE, ProcessOrphanedBlocks )
#pragma alloc_text( PAGE, RecalcCoreSearchTimeout )
#endif
#if 0
NOT PAGEABLE -- SrvTerminateScavenger
NOT PAGEABLE -- ScavengerTimerRoutine
NOT PAGEABLE -- SrvResourceThread
NOT PAGEABLE -- ScavengerThread
NOT PAGEABLE -- ProcessConnectionDisconnects
NOT PAGEABLE -- SrvServiceWorkItemShortage
NOT PAGEABLE -- LazyFreeQueueDataStructures
NOT PAGEABLE -- SrvUpdateStatisticsFromQueues
#endif


NTSTATUS
SrvInitializeScavenger (
    VOID
    )

/*++

Routine Description:

    This function creates the scavenger thread for the LAN Manager
    server FSP.

Arguments:

    None.

Return Value:

    NTSTATUS - Status of thread creation

--*/

{
    LARGE_INTEGER currentTime;

    PAGED_CODE( );

    //
    // Initialize the scavenger spin lock.
    //

    INITIALIZE_SPIN_LOCK( &ScavengerSpinLock );

    //
    // When this count is zero, we will update the QOS information for
    // each active connection.
    //

    ScavengerUpdateQosCount = SrvScavengerUpdateQosCount;

    //
    // When this count is zero, we will check the rfcb active status.
    //

    ScavengerCheckRfcbActive = SrvScavengerCheckRfcbActive;

    //
    // Get the current time and calculate the next time the scavenge and
    // alert algorithms need to run.
    //

    KeQuerySystemTime( &currentTime );
    NextScavengeTime.QuadPart = currentTime.QuadPart + SrvScavengerTimeout.QuadPart;
    NextAlertTime.QuadPart = currentTime.QuadPart + SrvAlertSchedule.QuadPart;

    ScavengerWorkItem = IoAllocateWorkItem( SrvDeviceObject );
    if( !ScavengerWorkItem )
    {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    // Initialize the scavenger DPC, which will queue the work item.
    //

    KeInitializeDpc( &ScavengerDpc, ScavengerTimerRoutine, NULL );

    //
    // Start the scavenger timer.  When the timer expires, the DPC will
    // run and will queue the work item.
    //

    KeInitializeTimer( &ScavengerTimer );
    ScavengerInitialized = TRUE;
    KeSetTimer( &ScavengerTimer, ScavengerBaseTimeout, &ScavengerDpc );

    return STATUS_SUCCESS;

} // SrvInitializeScavenger


VOID
SrvTerminateScavenger (
    VOID
    )
{
    KEVENT scavengerTimerTerminationEvent;
    KEVENT scavengerThreadTerminationEvent;
    KEVENT resourceThreadTerminationEvent;
    BOOLEAN waitForResourceThread;
    BOOLEAN waitForScavengerThread;
    KIRQL oldIrql;

    if ( ScavengerInitialized ) {

        //
        // Initialize shutdown events before marking the scavenger as
        // shutting down.
        //

        KeInitializeEvent(
            &scavengerTimerTerminationEvent,
            NotificationEvent,
            FALSE
            );
        ScavengerTimerTerminationEvent = &scavengerTimerTerminationEvent;

        KeInitializeEvent(
            &scavengerThreadTerminationEvent,
            NotificationEvent,
            FALSE
            );
        ScavengerThreadTerminationEvent = &scavengerThreadTerminationEvent;

        KeInitializeEvent(
            &resourceThreadTerminationEvent,
            NotificationEvent,
            FALSE
            );
        ResourceThreadTerminationEvent = &resourceThreadTerminationEvent;

        //
        // Lock the scavenger, then indicate that we're shutting down.
        // Also, notice whether the resource and scavenger threads are
        // running.  Then release the lock.  We must notice whether the
        // threads are running while holding the lock so that we can
        // know whether to expect the threads to set their termination
        // events.  (We don't have to do this with the scavenger timer
        // because it's always running.)
        //

        ACQUIRE_SPIN_LOCK( &ScavengerSpinLock, &oldIrql );

        waitForScavengerThread = ScavengerRunning;
        waitForResourceThread = SrvResourceThreadRunning;
        ScavengerInitialized = FALSE;

        RELEASE_SPIN_LOCK( &ScavengerSpinLock, oldIrql );

        //
        // Cancel the scavenger timer.  If this works, then we know that
        // the timer DPC code is not running.  Otherwise, it is running
        // or queued to run, and we need to wait it to finish.
        //

        if ( !KeCancelTimer( &ScavengerTimer ) ) {
            KeWaitForSingleObject(
                &scavengerTimerTerminationEvent,
                Executive,
                KernelMode, // don't let stack be paged -- event on stack!
                FALSE,
                NULL
                );
        }

        //
        // If the scavenger thread was running when we marked the
        // shutdown, wait for it to finish.  (If it wasn't running
        // before, we know that it can't be running now, because timer
        // DPC wouldn't have started it once we marked the shutdown.)
        //

        if ( waitForScavengerThread ) {
            KeWaitForSingleObject(
                &scavengerThreadTerminationEvent,
                Executive,
                KernelMode, // don't let stack be paged -- event on stack!
                FALSE,
                NULL
                );
        }
        else
        {
            IoFreeWorkItem( ScavengerWorkItem );
        }

        //
        // If the resource thread was running when we marked the
        // shutdown, wait for it to finish.  (We know that it can't be
        // started because no other part of the server is running.)
        //

        if ( waitForResourceThread ) {
            KeWaitForSingleObject(
                &resourceThreadTerminationEvent,
                Executive,
                KernelMode, // don't let stack be paged -- event on stack!
                FALSE,
                NULL
                );
        }

    }

    //
    // At this point, no part of the scavenger is running.
    //

    return;

} // SrvTerminateScavenger


VOID
SrvResourceThread (
    IN PVOID Parameter
    )

/*++

Routine Description:

    Main routine for the resource thread.  Is called via an executive
    work item when resource work is needed.

Arguments:

    None.

Return Value:

    None.

--*/

{
    BOOLEAN runAgain = TRUE;
    PWORK_CONTEXT workContext;
    KIRQL oldIrql;

    do {

        //
        // The resource event was signaled.  This can indicate a number
        // of different things.  Currently, this event is signaled for
        // the following reasons:
        //
        // 1.  The TDI disconnect event handler was called.  The
        //     disconnected connection was marked.  It is up to the
        //     scavenger shutdown the connection.
        //
        // 2.  A connection has been accepted.
        //

        IF_DEBUG(SCAV1) {
            KdPrint(( "SrvResourceThread: Resource event signaled!\n" ));
        }

        //
        // Service endpoints that need connections.
        //

        if ( SrvResourceFreeConnection ) {
            SrvResourceFreeConnection = FALSE;
            CreateConnections( );
        }

        //
        // Service pending disconnects.
        //

        if ( SrvResourceDisconnectPending ) {
            SrvResourceDisconnectPending = FALSE;
            ProcessConnectionDisconnects( );
        }

        //
        // Service orphaned connections.
        //

        if ( SrvResourceOrphanedBlocks ) {
            ProcessOrphanedBlocks( );
        }

        //
        // At the end of the loop, check to see whether we need to run
        // the loop again.
        //

        ACQUIRE_GLOBAL_SPIN_LOCK( Fsd, &oldIrql );

        if ( !SrvResourceDisconnectPending &&
             !SrvResourceOrphanedBlocks &&
             !SrvResourceFreeConnection ) {

            //
            // No more work to do.  If the server is shutting down,
            // set the event that tells SrvTerminateScavenger that the
            // resource thread is done running.
            //

            SrvResourceThreadRunning = FALSE;
            runAgain = FALSE;

            if ( !ScavengerInitialized ) {
                KeSetEvent( ResourceThreadTerminationEvent, 0, FALSE );
            }

        }

        RELEASE_GLOBAL_SPIN_LOCK( Fsd, oldIrql );

    } while ( runAgain );

    ObDereferenceObject( SrvDeviceObject );

    return;

} // SrvResourceThread


VOID
ScavengerTimerRoutine (
    IN PKDPC Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemArgument1,
    IN PVOID SystemArgument2
    )
{
    BOOLEAN runShortTerm;
    BOOLEAN runScavenger;
    BOOLEAN runAlerter;
    BOOLEAN start;

    LARGE_INTEGER currentTime;

    Dpc, DeferredContext;   // prevent compiler warnings

    //
    // Query the system time (in ticks).
    //

    SET_SERVER_TIME( SrvWorkQueues );

    //
    // Capture the current time (in 100ns units).
    //

    currentTime.LowPart = PtrToUlong(SystemArgument1);
    currentTime.HighPart = PtrToUlong(SystemArgument2);

    //
    // Determine which algorithms (if any) need to run.
    //

    start = FALSE;

    if ( !IsListEmpty( &SrvOplockBreaksInProgressList ) ) {
        runShortTerm = TRUE;
        start = TRUE;
    } else {
        runShortTerm = FALSE;
    }

    if ( currentTime.QuadPart >= NextScavengeTime.QuadPart ) {
        runScavenger = TRUE;
        start = TRUE;
    } else {
        runScavenger = FALSE;
    }

    if ( currentTime.QuadPart >= NextAlertTime.QuadPart ) {
        runAlerter = TRUE;
        start = TRUE;
    } else {
        runAlerter = FALSE;
    }

    //
    // If necessary, start the scavenger thread.  Don't do this if
    // the server is shutting down.
    //

    ACQUIRE_DPC_SPIN_LOCK( &ScavengerSpinLock );

    if ( !ScavengerInitialized ) {

        KeSetEvent( ScavengerTimerTerminationEvent, 0, FALSE );

    } else {

        if ( start ) {

            if ( runShortTerm ) {
                RunShortTermAlgorithm = TRUE;
            }

            if ( runScavenger ) {
                RunScavengerAlgorithm = TRUE;
                NextScavengeTime.QuadPart += SrvScavengerTimeout.QuadPart;
            }
            if ( runAlerter ) {
                RunAlerterAlgorithm = TRUE;
                NextAlertTime.QuadPart += SrvAlertSchedule.QuadPart;
            }

            if( !ScavengerRunning )
            {
                ScavengerRunning = TRUE;
                IoQueueWorkItem( ScavengerWorkItem, ScavengerThread, CriticalWorkQueue, NULL );
            }
        }

        //
        // Restart the timer.
        //

        KeSetTimer( &ScavengerTimer, ScavengerBaseTimeout, &ScavengerDpc );

    }

    RELEASE_DPC_SPIN_LOCK( &ScavengerSpinLock );

    return;

} // ScavengerTimerRoutine

#if DBG_STUCK

//
// This keeps a record of the operation which has taken the longest time
// in the server
//
struct {
    ULONG   Seconds;
    UCHAR   Command;
    UCHAR   ClientName[ 16 ];
} SrvMostStuck;

VOID
SrvLookForStuckOperations()
{
    USHORT index;
    PLIST_ENTRY listEntry;
    PLIST_ENTRY connectionListEntry;
    PENDPOINT endpoint;
    PCONNECTION connection;
    KIRQL oldIrql;
    BOOLEAN printed = FALSE;
    ULONG stuckCount = 0;

    //
    // Look at all of the InProgress work items and chatter about any
    //  which look stuck
    //

    ACQUIRE_LOCK( &SrvEndpointLock );

    listEntry = SrvEndpointList.ListHead.Flink;

    while ( listEntry != &SrvEndpointList.ListHead ) {

        endpoint = CONTAINING_RECORD(
                        listEntry,
                        ENDPOINT,
                        GlobalEndpointListEntry
                        );

        //
        // If this endpoint is closing, skip to the next one.
        // Otherwise, reference the endpoint so that it can't go away.
        //

        if ( GET_BLOCK_STATE(endpoint) != BlockStateActive ) {
            listEntry = listEntry->Flink;
            continue;
        }

        SrvReferenceEndpoint( endpoint );

        index = (USHORT)-1;

        while ( TRUE ) {

            PLIST_ENTRY wlistEntry, wlistHead;
            KIRQL oldIrql;
            LARGE_INTEGER now;

            //
            // Get the next active connection in the table.  If no more
            // are available, WalkConnectionTable returns NULL.
            // Otherwise, it returns a referenced pointer to a
            // connection.
            //

            connection = WalkConnectionTable( endpoint, &index );
            if ( connection == NULL ) {
                break;
            }

            //
            // Now walk the InProgressWorkItemList to see if any work items
            //  look stuck
            //
            wlistHead = &connection->InProgressWorkItemList;
            wlistEntry = wlistHead;

            KeQuerySystemTime( &now );

            ACQUIRE_SPIN_LOCK( connection->EndpointSpinLock, &oldIrql )

            while ( wlistEntry->Flink != wlistHead ) {

                PWORK_CONTEXT workContext;
                PSMB_HEADER header;
                LARGE_INTEGER interval;

                wlistEntry = wlistEntry->Flink;

                workContext = CONTAINING_RECORD(
                                             wlistEntry,
                                             WORK_CONTEXT,
                                             InProgressListEntry
                                             );

                interval.QuadPart = now.QuadPart - workContext->OpStartTime.QuadPart;

                //
                // Any operation over 45 seconds is VERY stuck....
                //

                if( workContext->IsNotStuck || interval.LowPart < 45 * 10000000 ) {
                    continue;
                }

                header = workContext->RequestHeader;

                if ( (workContext->BlockHeader.ReferenceCount != 0) &&
                     (workContext->ProcessingCount != 0) &&
                     header != NULL ) {

                    //
                    // Convert to seconds
                    //
                    interval.LowPart /= 10000000;

                    if( !printed ) {
                        IF_STRESS() KdPrint(( "--- Potential stuck SRV.SYS Operations ---\n" ));
                        printed = TRUE;
                    }

                    if( interval.LowPart > SrvMostStuck.Seconds ) {
                        SrvMostStuck.Seconds = interval.LowPart;
                        RtlCopyMemory( SrvMostStuck.ClientName,
                                       connection->OemClientMachineNameString.Buffer,
                                       MIN( 16, connection->OemClientMachineNameString.Length )),
                        SrvMostStuck.ClientName[ MIN( 15, connection->OemClientMachineNameString.Length ) ] = 0;
                        SrvMostStuck.Command = header->Command;
                    }

                    if( stuckCount++ < 5 ) {
                        IF_STRESS() KdPrint(( "Client %s, %u secs, Context %p",
                                   connection->OemClientMachineNameString.Buffer,
                                   interval.LowPart, workContext ));

                        switch( header->Command ) {
                        case SMB_COM_NT_CREATE_ANDX:
                            IF_STRESS() KdPrint(( " NT_CREATE_ANDX\n" ));
                            break;
                        case SMB_COM_OPEN_PRINT_FILE:
                            IF_STRESS() KdPrint(( " OPEN_PRINT_FILE\n" ));
                            break;
                        case SMB_COM_CLOSE_PRINT_FILE:
                            IF_STRESS() KdPrint(( " CLOSE_PRINT_FILE\n" ));
                            break;
                        case SMB_COM_CLOSE:
                            IF_STRESS() KdPrint(( " CLOSE\n" ));
                            break;
                        case SMB_COM_SESSION_SETUP_ANDX:
                            IF_STRESS() KdPrint(( " SESSION_SETUP\n" ));
                            break;
                        case SMB_COM_OPEN_ANDX:
                            IF_STRESS() KdPrint(( " OPEN_ANDX\n" ));
                            break;
                        case SMB_COM_NT_TRANSACT:
                        case SMB_COM_NT_TRANSACT_SECONDARY:
                            IF_STRESS() KdPrint(( " NT_TRANSACT\n" ));
                            break;
                        case SMB_COM_TRANSACTION2:
                        case SMB_COM_TRANSACTION2_SECONDARY:
                            IF_STRESS() KdPrint(( " TRANSACTION2\n" ));
                            break;
                        case SMB_COM_TRANSACTION:
                        case SMB_COM_TRANSACTION_SECONDARY:
                            IF_STRESS() KdPrint(( " TRANSACTION\n" ));
                            break;
                        default:
                            IF_STRESS() KdPrint(( " Cmd %X\n", header->Command ));
                            break;
                        }
                    }
                }
            }

            RELEASE_SPIN_LOCK( connection->EndpointSpinLock, oldIrql );

            SrvDereferenceConnection( connection );

        } // walk connection list

        //
        // Capture a pointer to the next endpoint in the list (that one
        // can't go away because we hold the endpoint list), then
        // dereference the current endpoint.
        //

        listEntry = listEntry->Flink;
        SrvDereferenceEndpoint( endpoint );

    } // walk endpoint list

    if( printed && SrvMostStuck.Seconds ) {
        IF_STRESS() KdPrint(( "Longest so far: %s, %u secs, cmd %u\n", SrvMostStuck.ClientName, SrvMostStuck.Seconds, SrvMostStuck.Command ));
    }

    if( stuckCount ) {
        //DbgBreakPoint();
    }

    RELEASE_LOCK( &SrvEndpointLock );
}
#endif


VOID
ScavengerThread (
    IN PDEVICE_OBJECT DeviceObject,
    IN PVOID Parameter
    )

/*++

Routine Description:

    Main routine for the FSP scavenger thread.  Is called via an
    executive work item when scavenger work is needed.

Arguments:

    None.

Return Value:

    None.

--*/

{
    BOOLEAN runAgain = TRUE;
    BOOLEAN oldPopupStatus;
    BOOLEAN finalExecution = FALSE;
    KIRQL oldIrql;

    Parameter;  // prevent compiler warnings

    IF_DEBUG(SCAV1) KdPrint(( "ScavengerThread entered\n" ));

    //
    // Make sure that the thread does not generate pop-ups.  We need to do
    // this because the scavenger might be called by an Ex worker thread,
    // which unlike the srv worker threads, don't have popups disabled.
    //

    oldPopupStatus = IoSetThreadHardErrorMode( FALSE );

    //
    // Main loop, executed until no scavenger events are set.
    //

    do {

#if DBG_STUCK
        IF_STRESS() SrvLookForStuckOperations();
#endif

        //
        // If the short-term timer expired, run that algorithm now.
        //

        if ( RunShortTermAlgorithm ) {

            LARGE_INTEGER currentTime;

            RunShortTermAlgorithm = FALSE;

            KeQuerySystemTime( &currentTime );

            //
            // Time out oplock break requests.
            //

            TimeoutStuckOplockBreaks( &currentTime );
        }

        //
        // If the scavenger timer expired, run that algorithm now.
        //

        if ( RunScavengerAlgorithm ) {
            //KePrintSpinLockCounts( 0 );
            RunScavengerAlgorithm = FALSE;
            ScavengerAlgorithm( );
        }

        //
        // If the short-term timer expired, run that algorithm now.
        // Note that we check the short-term timer twice in the loop
        // in order to get more timely processing of the algorithm.
        //

        //if ( RunShortTermAlgorithm ) {
        //    RunShortTermAlgorithm = FALSE;
        //    ShortTermAlgorithm( );
        //}

        //
        // If the alerter timer expired, run that algorithm now.
        //

        if ( RunAlerterAlgorithm ) {
            RunAlerterAlgorithm = FALSE;
            AlerterAlgorithm( );
        }

        //
        // At the end of the loop, check to see whether we need to run
        // the loop again.
        //

        ACQUIRE_SPIN_LOCK( &ScavengerSpinLock, &oldIrql );

        if ( !RunShortTermAlgorithm &&
             !RunScavengerAlgorithm &&
             !RunAlerterAlgorithm ) {

            //
            // No more work to do.  If the server is shutting down,
            // set the event that tells SrvTerminateScavenger that the
            // scavenger thread is done running.
            //

            ScavengerRunning = FALSE;
            runAgain = FALSE;

            if ( !ScavengerInitialized ) {
                // The server was stopped while the scavenger was queued,
                // so we need to delete the WorkItem ourselves.
                finalExecution = TRUE;
                KeSetEvent( ScavengerThreadTerminationEvent, 0, FALSE );
            }

        }

        RELEASE_SPIN_LOCK( &ScavengerSpinLock, oldIrql );

    } while ( runAgain );

    //
    // reset popup status.
    //

    IoSetThreadHardErrorMode( oldPopupStatus );

    if( finalExecution )
    {
        IoFreeWorkItem( ScavengerWorkItem );
        ScavengerWorkItem = NULL;
    }

    return;

} // ScavengerThread

VOID
DestroySuspectConnections(
    VOID
    )
{
    USHORT index;
    PLIST_ENTRY listEntry;
    PLIST_ENTRY connectionListEntry;
    PENDPOINT endpoint;
    PCONNECTION connection;
    KIRQL oldIrql;
    BOOLEAN printed = FALSE;
    ULONG stuckCount = 0;

    IF_DEBUG( SCAV1 ) {
        KdPrint(( "Looking for Suspect Connections.\n" ));
    }

    //
    // Look at all of the InProgress work items and chatter about any
    //  which look stuck
    //

    ACQUIRE_LOCK( &SrvEndpointLock );

    listEntry = SrvEndpointList.ListHead.Flink;

    while ( listEntry != &SrvEndpointList.ListHead ) {

        endpoint = CONTAINING_RECORD(
                        listEntry,
                        ENDPOINT,
                        GlobalEndpointListEntry
                        );

        //
        // If this endpoint is closing, skip to the next one.
        // Otherwise, reference the endpoint so that it can't go away.
        //

        if ( GET_BLOCK_STATE(endpoint) != BlockStateActive ) {
            listEntry = listEntry->Flink;
            continue;
        }

        SrvReferenceEndpoint( endpoint );

        index = (USHORT)-1;

        while ( TRUE ) {

            PLIST_ENTRY wlistEntry, wlistHead;
            KIRQL oldIrql;
            LARGE_INTEGER now;

            //
            // Get the next active connection in the table.  If no more
            // are available, WalkConnectionTable returns NULL.
            // Otherwise, it returns a referenced pointer to a
            // connection.
            //

            connection = WalkConnectionTable( endpoint, &index );
            if ( connection == NULL ) {
                break;
            }

            if( connection->IsConnectionSuspect )
            {
                // Prevent us from flooding the eventlog by only logging X DOS attacks every 24 hours.
                LARGE_INTEGER CurrentTime;
                KeQuerySystemTime( &CurrentTime );
                if( CurrentTime.QuadPart > SrvLastDosAttackTime.QuadPart + SRV_ONE_DAY )
                {
                    // reset the counter every 24 hours
                    SrvDOSAttacks = 0;
                    SrvLastDosAttackTime.QuadPart = CurrentTime.QuadPart;
                    SrvLogEventOnDOS = TRUE;
                }

                IF_DEBUG( ERRORS )
                {
                    KdPrint(( "Disconnected suspected DoS attack (%z)\n", (PCSTRING)&connection->OemClientMachineNameString ));
                }

                RELEASE_LOCK( &SrvEndpointLock );

                // Log an event if we need to
                if( SrvLogEventOnDOS )
                {
                    SrvLogError(
                        SrvDeviceObject,
                        EVENT_SRV_DOS_ATTACK_DETECTED,
                        STATUS_ACCESS_DENIED,
                        NULL,
                        0,
                        &connection->PagedConnection->ClientMachineNameString,
                        1
                        );

                    SrvDOSAttacks++;
                    if( SrvDOSAttacks > SRV_MAX_DOS_ATTACK_EVENT_LOGS )
                    {
                        SrvLogEventOnDOS = FALSE;

                        SrvLogError(
                            SrvDeviceObject,
                            EVENT_SRV_TOO_MANY_DOS,
                            STATUS_ACCESS_DENIED,
                            NULL,
                            0,
                            NULL,
                            0
                            );
                    }
                }

                connection->DisconnectReason = DisconnectSuspectedDOSConnection;
                SrvCloseConnection( connection, FALSE );

                ACQUIRE_LOCK( &SrvEndpointLock );
            }

            SrvDereferenceConnection( connection );

        } // walk connection list

        //
        // Capture a pointer to the next endpoint in the list (that one
        // can't go away because we hold the endpoint list), then
        // dereference the current endpoint.
        //

        listEntry = listEntry->Flink;
        SrvDereferenceEndpoint( endpoint );

    } // walk endpoint list

    RELEASE_LOCK( &SrvEndpointLock );

    RunSuspectConnectionAlgorithm = FALSE;
}


VOID
ScavengerAlgorithm (
    VOID
    )
{
    LARGE_INTEGER currentTime;
    ULONG currentTick;
    UNICODE_STRING insertionString[2];
    WCHAR secondsBuffer[20];
    WCHAR shortageBuffer[20];
    BOOLEAN logError = FALSE;
    PWORK_QUEUE queue;

    PAGED_CODE( );

    IF_DEBUG(SCAV1) KdPrint(( "ScavengerAlgorithm entered\n" ));

    KeQuerySystemTime( &currentTime );
    GET_SERVER_TIME( SrvWorkQueues, &currentTick );

    //
    // EventSwitch is used to schedule parts of the scavenger algorithm
    // to run every other iteration.
    //

    EventSwitch = !EventSwitch;

    //
    // Time out opens that are waiting too long for the other
    // opener to break the oplock.
    //

    TimeoutWaitingOpens( &currentTime );

    //
    // Time out oplock break requests.
    //

    TimeoutStuckOplockBreaks( &currentTime );

    //
    // Check for malicious attacks
    //
    if( RunSuspectConnectionAlgorithm )
    {
        DestroySuspectConnections( );
    }

    //
    // See if we can free some work items at this time.
    //

    for( queue = SrvWorkQueues; queue < eSrvWorkQueues; queue++ ) {
        LazyFreeQueueDataStructures( queue );
    }

    //
    // See if we need to update QOS information.
    //

    if ( --ScavengerUpdateQosCount < 0 ) {
        UpdateConnectionQos( &currentTime );
        ScavengerUpdateQosCount = SrvScavengerUpdateQosCount;
    }

    //
    // See if we need to walk the rfcb list to update the session
    // last use time.
    //

    if ( --ScavengerCheckRfcbActive < 0 ) {
        UpdateSessionLastUseTime( &currentTime );
        ScavengerCheckRfcbActive = SrvScavengerCheckRfcbActive;
    }

    //
    // See if we need to log an error for resource shortages
    //

    if ( FailedWorkItemAllocations > 0      ||
         SrvOutOfFreeConnectionCount > 0    ||
         SrvOutOfRawWorkItemCount > 0       ||
         SrvFailedBlockingIoCount > 0 ) {

        //
        // Setup the strings for use in logging work item allocation failures.
        //

        insertionString[0].Buffer = shortageBuffer;
        insertionString[0].MaximumLength = sizeof(shortageBuffer);
        insertionString[1].Buffer = secondsBuffer;
        insertionString[1].MaximumLength = sizeof(secondsBuffer);

        (VOID) RtlIntegerToUnicodeString(
                        SrvScavengerTimeoutInSeconds * 2,
                        10,
                        &insertionString[1]
                        );

        logError = TRUE;
    }

    if ( EventSwitch ) {
        ULONG FailedCount;

        //
        // If we were unable to allocate any work items during
        // the last two scavenger intervals, log an error.
        //

        FailedCount = InterlockedExchange( &FailedWorkItemAllocations, 0 );

        if ( FailedCount != 0 ) {

            (VOID) RtlIntegerToUnicodeString(
                                FailedCount,
                                10,
                                &insertionString[0]
                                );

            SrvLogError(
                SrvDeviceObject,
                EVENT_SRV_NO_WORK_ITEM,
                STATUS_INSUFFICIENT_RESOURCES,
                NULL,
                0,
                insertionString,
                2
                );
        }

        //
        // Generate periodic events and alerts (for events that
        // could happen very quickly, so we don't flood the event
        // log).
        //

        GeneratePeriodicEvents( );

    } else {

        if ( logError ) {

            //
            // If we failed to find free connections during
            // the last two scavenger intervals, log an error.
            //

            if ( SrvOutOfFreeConnectionCount > 0 ) {

                (VOID) RtlIntegerToUnicodeString(
                                    SrvOutOfFreeConnectionCount,
                                    10,
                                    &insertionString[0]
                                    );

                SrvLogError(
                    SrvDeviceObject,
                    EVENT_SRV_NO_FREE_CONNECTIONS,
                    STATUS_INSUFFICIENT_RESOURCES,
                    NULL,
                    0,
                    insertionString,
                    2
                    );

                SrvOutOfFreeConnectionCount = 0;
            }

            //
            // If we failed to find free raw work items during
            // the last two scavenger intervals, log an error.
            //

            if ( SrvOutOfRawWorkItemCount > 0 ) {

                (VOID) RtlIntegerToUnicodeString(
                                    SrvOutOfRawWorkItemCount,
                                    10,
                                    &insertionString[0]
                                    );

                SrvLogError(
                    SrvDeviceObject,
                    EVENT_SRV_NO_FREE_RAW_WORK_ITEM,
                    STATUS_INSUFFICIENT_RESOURCES,
                    NULL,
                    0,
                    insertionString,
                    2
                    );

                SrvOutOfRawWorkItemCount = 0;
            }

            //
            // If we failed a blocking io due to resource shortages during
            // the last two scavenger intervals, log an error.
            //

            if ( SrvFailedBlockingIoCount > 0 ) {

                (VOID) RtlIntegerToUnicodeString(
                                    SrvFailedBlockingIoCount,
                                    10,
                                    &insertionString[0]
                                    );

                SrvLogError(
                    SrvDeviceObject,
                    EVENT_SRV_NO_BLOCKING_IO,
                    STATUS_INSUFFICIENT_RESOURCES,
                    NULL,
                    0,
                    insertionString,
                    2
                    );

                SrvFailedBlockingIoCount = 0;
            }

        } // if ( logError )

        //
        // Recalculate the core search timeout time.
        //

        RecalcCoreSearchTimeout( );

        //
        // Time out users/connections that have been idle too long
        // (autodisconnect).
        //

        TimeoutSessions( &currentTime );

        //
        // Update the statistics from the the queues
        //

        SrvUpdateStatisticsFromQueues( NULL );

    }

    // Update the DoS variables as necessary for rundown.  This reduces the percentage
    // of work-items we free up whenever we detect a DoS by running out of work items
    if( SrvDoSRundownIncreased && !SrvDoSRundownDetector )
    {
        // We've increased the percentage at some time, but no DoS has been detected since
        // the last execution of the scavenger, so we can reduce our tear down amount
        SRV_DOS_DECREASE_TEARDOWN();
    }
    SrvDoSRundownDetector = FALSE;

    return;

} // ScavengerAlgorithm


VOID
AlerterAlgorithm (
    VOID
    )

/*++

Routine Description:

    The other scavenger thread.  This routine checks the server for
    alert conditions, and if necessary raises alerts.

Arguments:

    None.

Return Value:

    None.

--*/

{
    PAGED_CODE( );

    IF_DEBUG(SCAV1) KdPrint(( "AlerterAlgorithm entered\n" ));

    CheckErrorCount( &SrvErrorRecord, FALSE );
    CheckErrorCount( &SrvNetworkErrorRecord, TRUE );
    CheckDiskSpace();

    return;

} // AlerterAlgorithm


VOID
CloseIdleConnection (
    IN PCONNECTION Connection,
    IN PLARGE_INTEGER CurrentTime,
    IN PLARGE_INTEGER DisconnectTime,
    IN PLARGE_INTEGER PastExpirationTime,
    IN PLARGE_INTEGER TwoMinuteWarningTime,
    IN PLARGE_INTEGER FiveMinuteWarningTime
    )

/*++

Routine Description:

    The routine checks to see if some sessions need to be closed becaused
    it has been idle too long or has exceeded its logon hours.

    Endpoint lock assumed held.

Arguments:

    Connection - The connection whose sessions we are currently looking at.
    CurrentTime - The currest system time.
    DisconnectTime - The time beyond which the session will be autodisconnected.
    PastExpirationTime - Time when the past expiration message will be sent.
    TwoMinuteWarningTime - Time when the 2 min warning will be sent.
    FiveMinuteWarningTime - Time when the 5 min warning will be sent.

Return Value:

    None.

--*/

{
    PTABLE_HEADER tableHeader;
    NTSTATUS status;
    BOOLEAN sessionClosed = FALSE;
    PPAGED_CONNECTION pagedConnection = Connection->PagedConnection;
    LONG i;
    ULONG AllSessionsIdle = TRUE;
    ULONG HasSessions = FALSE;

    PAGED_CODE( );

    //
    // Is this is a connectionless connection (IPX), check first to see
    // if it's been too long since we heard from the client.  The client
    // is supposed to send Echo SMBs every few minutes if nothing else
    // is going on.
    //

    if ( Connection->Endpoint->IsConnectionless ) {

        //
        // Calculate the number of clock ticks that have happened since
        // we last heard from the client.  If that's more than we allow,
        // kill the connection.
        //

        GET_SERVER_TIME( Connection->CurrentWorkQueue, (PULONG)&i );
        i -= Connection->LastRequestTime;
        if ( i > 0 && (ULONG)i > SrvIpxAutodisconnectTimeout ) {
            IF_DEBUG( IPX2 ) {
                KdPrint(("CloseIdleConnection: closing IPX conn %p, idle %u\n", Connection, i ));
            }
            Connection->DisconnectReason = DisconnectIdleConnection;
            SrvCloseConnection( Connection, FALSE );
            return;
        }
    }

    //
    // Walk the active connection list, looking for connections that
    // are idle.
    //

    tableHeader = &pagedConnection->SessionTable;

    ACQUIRE_LOCK( &Connection->Lock );

    for ( i = 0; i < tableHeader->TableSize; i++ ) {

        PSESSION session = (PSESSION)tableHeader->Table[i].Owner;

        if( session == NULL ) {
            continue;
        }

        HasSessions = TRUE;

        if ( GET_BLOCK_STATE( session ) == BlockStateActive ) {

            SrvReferenceSession( session );
            RELEASE_LOCK( &Connection->Lock );

            //
            // Test whether the session has been idle too long, and whether
            // there are any files open on the session.  If there are open
            // files, we must not close the session, as this would seriously
            // confuse the client.  For purposes of autodisconnect, "open
            // files" referes to open searches and blocking comm device
            // requests as well as files actually opened.
            //

            if ( AllSessionsIdle == TRUE &&
                 (session->LastUseTime.QuadPart >= DisconnectTime->QuadPart ||
                  session->CurrentFileOpenCount != 0 ||
                  session->CurrentSearchOpenCount != 0 )
               ) {

                AllSessionsIdle = FALSE;
            }

            // Check if the session has expired
            if( session->LogOffTime.QuadPart < CurrentTime->QuadPart )
            {
                session->IsSessionExpired = TRUE;
                KdPrint(( "Marking session as expired (scavenger)\n" ));
            }

            // Look for forced log-offs
            if ( !SrvEnableForcedLogoff &&
                        !session->LogonSequenceInProgress &&
                        !session->LogoffAlertSent &&
                        PastExpirationTime->QuadPart <
                               session->LastExpirationMessage.QuadPart ) {

                //
                // Checks for forced logoff.  If the client is beyond his logon
                // hours, force him off.  If the end of logon hours is
                // approaching, send a warning message.  Forced logoff occurs
                // regardless of whether the client has open files or searches.
                //

                UNICODE_STRING timeString;

                status = TimeToTimeString( &session->KickOffTime, &timeString );

                if ( NT_SUCCESS(status) ) {

                    //
                    // Only the scavenger thread sets this, so no mutual
                    // exclusion is necessary.
                    //

                    session->LastExpirationMessage = *CurrentTime;

                    SrvUserAlertRaise(
                        MTXT_Past_Expiration_Message,
                        2,
                        &session->Connection->Endpoint->DomainName,
                        &timeString,
                        &pagedConnection->ClientMachineNameString
                        );

                    RtlFreeUnicodeString( &timeString );
                }

                // !!! need to raise an admin alert in this case?

            } else if ( !session->LogoffAlertSent &&
                        !session->LogonSequenceInProgress &&
                        session->KickOffTime.QuadPart < CurrentTime->QuadPart ) {

                session->LogoffAlertSent = TRUE;

                SrvUserAlertRaise(
                    MTXT_Expiration_Message,
                    1,
                    &session->Connection->Endpoint->DomainName,
                    NULL,
                    &pagedConnection->ClientMachineNameString
                    );

                //
                // If real forced logoff is not enabled, all we do is send an
                // alert, don't actually close the session/connection.
                //

                if ( SrvEnableForcedLogoff ) {

                    //
                    // Increment the count of sessions that have been
                    // forced to logoff.
                    //

                    SrvStatistics.SessionsForcedLogOff++;

                    SrvCloseSession( session );
                    sessionClosed = TRUE;
                }

            } else if ( SrvEnableForcedLogoff &&
                        !session->LogonSequenceInProgress &&
                        !session->TwoMinuteWarningSent &&
                        session->KickOffTime.QuadPart <
                                        TwoMinuteWarningTime->QuadPart ) {

                UNICODE_STRING timeString;

                status = TimeToTimeString( &session->KickOffTime, &timeString );

                if ( NT_SUCCESS(status) ) {

                    //
                    // We only send a two-minute warning if "real" forced logoff
                    // is enabled.  If it is not enabled, the client doesn't
                    // actually get kicked off, so the extra messages are not
                    // necessary.
                    //

                    session->TwoMinuteWarningSent = TRUE;

                    //
                    // Send a different alert message based on whether the client
                    // has open files and/or searches.
                    //

                    if ( session->CurrentFileOpenCount != 0 ||
                             session->CurrentSearchOpenCount != 0 ) {

                        SrvUserAlertRaise(
                            MTXT_Immediate_Kickoff_Warning,
                            1,
                            &timeString,
                            NULL,
                            &pagedConnection->ClientMachineNameString
                            );

                    } else {

                        SrvUserAlertRaise(
                            MTXT_Kickoff_Warning,
                            1,
                            &session->Connection->Endpoint->DomainName,
                            NULL,
                            &pagedConnection->ClientMachineNameString
                            );
                    }

                    RtlFreeUnicodeString( &timeString );
                }

            } else if ( !session->FiveMinuteWarningSent &&
                        !session->LogonSequenceInProgress &&
                        session->KickOffTime.QuadPart <
                                        FiveMinuteWarningTime->QuadPart ) {

                UNICODE_STRING timeString;

                status = TimeToTimeString( &session->KickOffTime, &timeString );

                if ( NT_SUCCESS(status) ) {

                    session->FiveMinuteWarningSent = TRUE;

                    SrvUserAlertRaise(
                        MTXT_Expiration_Warning,
                        2,
                        &session->Connection->Endpoint->DomainName,
                        &timeString,
                        &pagedConnection->ClientMachineNameString
                        );

                    RtlFreeUnicodeString( &timeString );
                }
            }

            SrvDereferenceSession( session );
            ACQUIRE_LOCK( &Connection->Lock );

        } // if GET_BLOCK_STATE(session) == BlockStateActive

    } // for

    //
    // Nuke the connection if no sessions are active, and we have not heard
    //  from the client for one minute, drop the connection
    //
    if( HasSessions == FALSE ) {

        RELEASE_LOCK( &Connection->Lock );

        GET_SERVER_TIME( Connection->CurrentWorkQueue, (PULONG)&i );
        i -= Connection->LastRequestTime;

        if ( i > 0 && (ULONG)i > SrvConnectionNoSessionsTimeout ) {
#if SRVDBG29
            UpdateConnectionHistory( "IDLE", Connection->Endpoint, Connection );
#endif
            Connection->DisconnectReason = DisconnectIdleConnection;
            SrvCloseConnection( Connection, FALSE );
        }

    } else if ( (sessionClosed && (pagedConnection->CurrentNumberOfSessions == 0)) ||
         (HasSessions == TRUE && AllSessionsIdle == TRUE) ) {

        //
        // Update the statistics for the 'AllSessionsIdle' case
        //
        SrvStatistics.SessionsTimedOut += pagedConnection->CurrentNumberOfSessions;

        RELEASE_LOCK( &Connection->Lock );
#if SRVDBG29
        UpdateConnectionHistory( "IDLE", Connection->Endpoint, Connection );
#endif
        Connection->DisconnectReason = DisconnectIdleConnection;
        SrvCloseConnection( Connection, FALSE );

    } else {

        //
        // If this connection has more than 20 core searches, we go in and
        // try to remove dups.  20 is an arbitrary number.
        //


        if ( (pagedConnection->CurrentNumberOfCoreSearches > 20) &&
             SrvRemoveDuplicateSearches ) {

            RemoveDuplicateCoreSearches( pagedConnection );
        }

        RELEASE_LOCK( &Connection->Lock );
    }

} // CloseIdleConnection


VOID
CreateConnections (
    VOID
    )

/*++

Routine Description:

    This function attempts to service all endpoints that do not have
    free connections available.

Arguments:

    None.

Return Value:

    None.

--*/

{
    ULONG count;
    PLIST_ENTRY listEntry;
    PENDPOINT endpoint;

    PAGED_CODE( );

    ACQUIRE_LOCK( &SrvEndpointLock );

    //
    // Walk the endpoint list, looking for endpoints that need
    // connections.  Note that we hold the endpoint lock for the
    // duration of this routine.  This keeps the endpoint list from
    // changing.
    //
    // Note that we add connections based on level of need, so that
    // if we are unable to create as many as we'd like, we at least
    // take care of the most needy endpoints first.
    //

    for ( count = 0 ; count < SrvFreeConnectionMinimum; count++ ) {

        listEntry = SrvEndpointList.ListHead.Flink;

        while ( listEntry != &SrvEndpointList.ListHead ) {

            endpoint = CONTAINING_RECORD(
                            listEntry,
                            ENDPOINT,
                            GlobalEndpointListEntry
                            );

            //
            // If the endpoint's free connection count is at or below
            // our current level, try to create a connection now.
            //

            if ( (endpoint->FreeConnectionCount <= count) &&
                 (GET_BLOCK_STATE(endpoint) == BlockStateActive) ) {

                //
                // Try to create a connection.  If this fails, leave.
                //

                if ( !NT_SUCCESS(SrvOpenConnection( endpoint )) ) {
                    RELEASE_LOCK( &SrvEndpointLock );
                    return;
                }

            }

            listEntry = listEntry->Flink;

        } // walk endpoint list

    } // 0 <= count < SrvFreeConnectionMinimum

    RELEASE_LOCK( &SrvEndpointLock );

    return;

} // CreateConnections


VOID
GeneratePeriodicEvents (
    VOID
    )

/*++

Routine Description:

    This function is called when the scavenger timeout occurs.  It
    generates events for things that have happened in the previous
    period for which we did not want to immediately generate an event,
    for fear of flooding the event log.  An example of such an event is
    being unable to allocate pool.

Arguments:

    None.

Return Value:

    None.

--*/

{
    ULONG capturedNonPagedFailureCount;
    ULONG capturedPagedFailureCount;
    ULONG capturedNonPagedLimitHitCount;
    ULONG capturedPagedLimitHitCount;

    ULONG nonPagedFailureCount;
    ULONG pagedFailureCount;
    ULONG nonPagedLimitHitCount;
    ULONG pagedLimitHitCount;

    PAGED_CODE( );

    //
    // Capture pool allocation failure statistics.
    //

    capturedNonPagedLimitHitCount = SrvNonPagedPoolLimitHitCount;
    capturedNonPagedFailureCount = SrvStatistics.NonPagedPoolFailures;
    capturedPagedLimitHitCount = SrvPagedPoolLimitHitCount;
    capturedPagedFailureCount = SrvStatistics.PagedPoolFailures;

    //
    // Compute failure counts for the last period.  The FailureCount
    // fields in the statistics structure count both hitting the
    // server's configuration limit and hitting the system's limit.  The
    // local versions of FailureCount include only system failures.
    //

    nonPagedLimitHitCount =
        capturedNonPagedLimitHitCount - LastNonPagedPoolLimitHitCount;
    nonPagedFailureCount =
        capturedNonPagedFailureCount - LastNonPagedPoolFailureCount -
        nonPagedLimitHitCount;
    pagedLimitHitCount =
        capturedPagedLimitHitCount - LastPagedPoolLimitHitCount;
    pagedFailureCount =
        capturedPagedFailureCount - LastPagedPoolFailureCount -
        pagedLimitHitCount;

    //
    // Saved the current failure counts for next time.
    //

    LastNonPagedPoolLimitHitCount = capturedNonPagedLimitHitCount;
    LastNonPagedPoolFailureCount = capturedNonPagedFailureCount;
    LastPagedPoolLimitHitCount = capturedPagedLimitHitCount;
    LastPagedPoolFailureCount = capturedPagedFailureCount;

    //
    // If we hit the nonpaged pool limit at least once in the last
    // period, generate an event.
    //

    if ( nonPagedLimitHitCount != 0 ) {
        SrvLogError(
            SrvDeviceObject,
            EVENT_SRV_NONPAGED_POOL_LIMIT,
            STATUS_INSUFFICIENT_RESOURCES,
            &nonPagedLimitHitCount,
            sizeof( nonPagedLimitHitCount ),
            NULL,
            0
            );
    }

    //
    // If we had any nonpaged pool allocations failures in the last
    // period, generate an event.
    //

    if ( nonPagedFailureCount != 0 ) {
        SrvLogError(
            SrvDeviceObject,
            EVENT_SRV_NO_NONPAGED_POOL,
            STATUS_INSUFFICIENT_RESOURCES,
            &nonPagedFailureCount,
            sizeof( nonPagedFailureCount ),
            NULL,
            0
            );
    }

    //
    // If we hit the paged pool limit at least once in the last period,
    // generate an event.
    //

    if ( pagedLimitHitCount != 0 ) {
        SrvLogError(
            SrvDeviceObject,
            EVENT_SRV_PAGED_POOL_LIMIT,
            STATUS_INSUFFICIENT_RESOURCES,
            &pagedLimitHitCount,
            sizeof( pagedLimitHitCount ),
            NULL,
            0
            );
    }

    //
    // If we had any paged pool allocations failures in the last period,
    // generate an event.
    //

    if ( pagedFailureCount != 0 ) {
        SrvLogError(
            SrvDeviceObject,
            EVENT_SRV_NO_PAGED_POOL,
            STATUS_INSUFFICIENT_RESOURCES,
            &pagedFailureCount,
            sizeof( pagedFailureCount ),
            NULL,
            0
            );
    }

    return;

} // GeneratePeriodicEvents


VOID
ProcessConnectionDisconnects (
    VOID
    )

/*++

Routine Description:

    This function processes connection disconnects.

Arguments:

    None.

Return Value:

    None.

--*/

{
    PLIST_ENTRY listEntry;
    PCONNECTION connection;
    KIRQL oldIrql;

    //
    // Run through the list of connection with pending disconnects.
    // Do the work necessary to shut the disconnection connection
    // down.
    //

    ACQUIRE_GLOBAL_SPIN_LOCK( Fsd, &oldIrql );

    while ( !IsListEmpty( &SrvDisconnectQueue ) ) {

        //
        // This thread already owns the disconnect queue spin lock
        // and there is at least one entry on the queue.  Proceed.
        //

        listEntry = RemoveHeadList( &SrvDisconnectQueue );

        connection = CONTAINING_RECORD(
            listEntry,
            CONNECTION,
            ListEntry
            );

        ASSERT( connection->DisconnectPending );
        connection->DisconnectPending = FALSE;

        RELEASE_GLOBAL_SPIN_LOCK( Fsd, oldIrql );

        IF_STRESS() {
            if( connection->InProgressWorkContextCount > 0 )
            {
                KdPrint(("Abortive Disconnect for %z while work-in-progress (reason %d)\n", (PCSTRING)&connection->OemClientMachineNameString, connection->DisconnectReason ));
            }
        }

        //
        // Do the disconnection processing.  Dereference the connection
        // an extra time to account for the reference made when it was
        // put on the disconnect queue.
        //

#if SRVDBG29
        UpdateConnectionHistory( "PDSC", connection->Endpoint, connection );
#endif
        SrvCloseConnection( connection, TRUE );
        SrvDereferenceConnection( connection );

        //
        // We are about to go through the loop again, reacquire
        // the disconnect queue spin lock first.
        //

        ACQUIRE_GLOBAL_SPIN_LOCK( Fsd, &oldIrql );

    }

    RELEASE_GLOBAL_SPIN_LOCK( Fsd, oldIrql );
    return;

} // ProcessConnectionDisconnects


VOID SRVFASTCALL
SrvServiceWorkItemShortage (
    IN PWORK_CONTEXT workContext
    )
{
    PLIST_ENTRY listEntry;
    PCONNECTION connection;
    KIRQL oldIrql;
    BOOLEAN moreWork;
    PWORK_QUEUE queue;

    ASSERT( workContext );

    queue = workContext->CurrentWorkQueue;

    IF_DEBUG( WORKITEMS ) {
        KdPrint(("SrvServiceWorkItemShortage: Processor %p\n",
                 (PVOID)(queue - SrvWorkQueues) ));
    }

    workContext->FspRestartRoutine = SrvRestartReceive;

    ASSERT( queue >= SrvWorkQueues && queue < eSrvWorkQueues );

    //
    // If we got called, it's likely that we're running short of WorkItems.
    //  Allocate more if it makes sense.
    //

    do {
        PWORK_CONTEXT NewWorkContext;

        SrvAllocateNormalWorkItem( &NewWorkContext, queue );
        if ( NewWorkContext != NULL ) {

            IF_DEBUG( WORKITEMS ) {
                KdPrint(( "SrvServiceWorkItemShortage:  Created new work context "
                        "block\n" ));
            }

            SrvPrepareReceiveWorkItem( NewWorkContext, TRUE );

        } else {
            InterlockedIncrement( &FailedWorkItemAllocations );
            break;
        }

    } while ( queue->FreeWorkItems < queue->MinFreeWorkItems );

    if( GET_BLOCK_TYPE(workContext) == BlockTypeWorkContextSpecial ) {
        //
        // We've been called with a special workitem telling us to allocate
        // more standby WorkContext structures. Since our passed-in workContext
        // is not a "standard one", we can't use it for any further work
        // on starved connections.  Just release this workContext and return.
        //
        ACQUIRE_SPIN_LOCK( &queue->SpinLock, &oldIrql );
        SET_BLOCK_TYPE( workContext, BlockTypeGarbage );
        RELEASE_SPIN_LOCK( &queue->SpinLock, oldIrql );
        return;
    }

    ACQUIRE_GLOBAL_SPIN_LOCK( Fsd, &oldIrql );

    //
    // Run through the list of queued connections and find one that
    // we can service with this workContext.  This will ignore processor
    // affinity, but we're in exceptional times.  The workContext will
    // be freed back to the correct queue when done.
    //

    while( !IsListEmpty( &SrvNeedResourceQueue ) ) {

        connection = CONTAINING_RECORD( SrvNeedResourceQueue.Flink, CONNECTION, ListEntry );

        IF_DEBUG( WORKITEMS ) {
             KdPrint(("SrvServiceWorkItemShortage: Processing connection %p.\n",
                       connection ));
        }

        ASSERT( connection->OnNeedResourceQueue );
        ASSERT( connection->BlockHeader.ReferenceCount > 0 );

        if( GET_BLOCK_STATE( connection ) != BlockStateActive ) {

                IF_DEBUG( WORKITEMS ) {
                    KdPrint(("SrvServiceWorkItemShortage: Connection %p closing.\n", connection ));
                }

                //
                // Take it off the queue
                //
                SrvRemoveEntryList(
                    &SrvNeedResourceQueue,
                    &connection->ListEntry
                );
                connection->OnNeedResourceQueue = FALSE;

                RELEASE_GLOBAL_SPIN_LOCK( Fsd, oldIrql );

                //
                // Remove the queue reference
                //
                SrvDereferenceConnection( connection );

                ACQUIRE_GLOBAL_SPIN_LOCK( Fsd, &oldIrql );
                continue;
        }

        //
        // Reference this connection so no one can delete this from under us.
        //
        ACQUIRE_DPC_SPIN_LOCK( connection->EndpointSpinLock );
        SrvReferenceConnectionLocked( connection );

        //
        // Service the connection
        //
        do {

            if( IsListEmpty( &connection->OplockWorkList ) && !connection->ReceivePending )
                break;

            IF_DEBUG( WORKITEMS ) {
                KdPrint(("Work to do on connection %p\n", connection ));
            }

            INITIALIZE_WORK_CONTEXT( queue, workContext );

            //
            // Reference connection here.
            //
            workContext->Connection = connection;
            SrvReferenceConnectionLocked( connection );
            workContext->Endpoint = connection->Endpoint;

            //
            // Service this connection.
            //
            SrvFsdServiceNeedResourceQueue( &workContext, &oldIrql );

            moreWork = (BOOLEAN) (    workContext != NULL &&
                                      (!IsListEmpty(&connection->OplockWorkList) ||
                                      connection->ReceivePending) &&
                                      connection->OnNeedResourceQueue);

        } while( moreWork );

        //
        // Is it now off the queue?
        //
        if ( !connection->OnNeedResourceQueue ) {

            IF_DEBUG( WORKITEMS ) {
                KdPrint(("SrvServiceWorkItemShortage: connection %p removed by another thread.\n", connection ));
            }

            RELEASE_DPC_SPIN_LOCK( connection->EndpointSpinLock );
            RELEASE_GLOBAL_SPIN_LOCK( Fsd, oldIrql );

            //
            // Remove this routine's reference.
            //

            SrvDereferenceConnection( connection );

            if( workContext == NULL ) {
                IF_DEBUG( WORKITEMS ) {
                    KdPrint(("SrvServiceWorkItemShortage:  DONE at %d\n", __LINE__ ));
                }
                return;
            }

            ACQUIRE_GLOBAL_SPIN_LOCK( Fsd, &oldIrql );
            continue;
        }

        RELEASE_DPC_SPIN_LOCK( connection->EndpointSpinLock );

        //
        // The connection is still on the queue.  Keep it on the queue if there is more
        //  work to be done for it.
        //
        if( !IsListEmpty(&connection->OplockWorkList) || connection->ReceivePending ) {

            RELEASE_GLOBAL_SPIN_LOCK( Fsd, oldIrql );

            if( workContext ) {
                RETURN_FREE_WORKITEM( workContext );
            }

            //
            // Remove this routine's reference.
            //
            SrvDereferenceConnection( connection );

            IF_DEBUG( WORKITEMS ) {
                KdPrint(("SrvServiceWorkItemShortage:  More to do for %p.  LATER\n", connection ));
            }

            return;
        }

        //
        // All the work has been done for this connection.  Get it off the resource queue
        //
        IF_DEBUG( WORKITEMS ) {
            KdPrint(("SrvServiceWorkItemShortage:  Take %p off resource queue\n", connection ));
        }

        SrvRemoveEntryList(
            &SrvNeedResourceQueue,
            &connection->ListEntry
            );

        connection->OnNeedResourceQueue = FALSE;

        RELEASE_GLOBAL_SPIN_LOCK( Fsd, oldIrql );

        //
        // Remove queue reference
        //
        SrvDereferenceConnection( connection );

        //
        // Remove this routine's reference.
        //

        SrvDereferenceConnection( connection );

        IF_DEBUG( WORKITEMS ) {
            KdPrint(("SrvServiceWorkItemShortage: Connection %p removed from queue.\n", connection ));
        }

        if( workContext == NULL ) {
            IF_DEBUG( WORKITEMS ) {
                KdPrint(("SrvServiceWorkItemShortage: DONE at %d\n", __LINE__ ));
            }
            return;
        }

        ACQUIRE_GLOBAL_SPIN_LOCK( Fsd, &oldIrql );
    }

    RELEASE_GLOBAL_SPIN_LOCK( Fsd, oldIrql );

    //
    // See if we need to free the workContext
    //

    if ( workContext != NULL ) {

        IF_DEBUG( WORKITEMS ) {
            KdPrint(("SrvServiceWorkItemShortage: Freeing WorkContext block %p\n",
                     workContext ));
        }
        workContext->BlockHeader.ReferenceCount = 0;
        RETURN_FREE_WORKITEM( workContext );
    }

    IF_DEBUG(WORKITEMS) KdPrint(( "SrvServiceWorkItemShortage DONE at %d\n", __LINE__ ));

} // SrvServiceWorkItemShortage

VOID SRVFASTCALL
SrvServiceDoSTearDown (
    IN PWORK_CONTEXT WorkContext
    )

/*++

Routine Description:

    This routine is called when we perceive a DoS attack against us.  It results
    in us tearing down connections randomly who have WorkItems trapped in the
    transports to help prevent the DoS.

Arguments:

    WorkContext - The special work item used to trigger this routine

Return Value:

    None

--*/

{
    USHORT index;
    PLIST_ENTRY listEntry;
    PLIST_ENTRY connectionListEntry;
    PENDPOINT endpoint;
    PCONNECTION connection;
    KIRQL oldIrql;
    BOOLEAN printed = FALSE;
    LONG TearDownAmount = SRV_DOS_GET_TEARDOWN();

    ASSERT( GET_BLOCK_TYPE(WorkContext) == BlockTypeWorkContextSpecial );
    ASSERT( KeGetCurrentIrql() < DISPATCH_LEVEL );

    SRV_DOS_INCREASE_TEARDOWN();
    SrvDoSRundownDetector = TRUE;

    // Tear down some connections.  Look for ones with operations pending in the transport

    ACQUIRE_LOCK( &SrvEndpointLock );

    listEntry = SrvEndpointList.ListHead.Flink;

    while ( (TearDownAmount > 0) && (listEntry != &SrvEndpointList.ListHead) ) {

        endpoint = CONTAINING_RECORD(
                        listEntry,
                        ENDPOINT,
                        GlobalEndpointListEntry
                        );

        //
        // If this endpoint is closing, skip to the next one.
        // Otherwise, reference the endpoint so that it can't go away.
        //

        if ( GET_BLOCK_STATE(endpoint) != BlockStateActive ) {
            listEntry = listEntry->Flink;
            continue;
        }

        SrvReferenceEndpoint( endpoint );

        index = (USHORT)-1;

        while ( TearDownAmount > 0 ) {

            PLIST_ENTRY wlistEntry, wlistHead;
            KIRQL oldIrql;
            LARGE_INTEGER now;

            //
            // Get the next active connection in the table.  If no more
            // are available, WalkConnectionTable returns NULL.
            // Otherwise, it returns a referenced pointer to a
            // connection.
            //

            connection = WalkConnectionTable( endpoint, &index );
            if ( connection == NULL ) {
                break;
            }

            //
            // To determine if we should tear this connection down, we require that there be work waiting on
            // the transport, since that is the way anonymous users can attack us.  If there is, we use a
            // random method based on the timestamp of the last time this was ran.  We cycle through the connections
            // and use the index to determine if a teardown is issued (for a psuedo-random result)
            //
            if( (GET_BLOCK_STATE(connection) == BlockStateActive) && (connection->OperationsPendingOnTransport > 0) )
            {
                RELEASE_LOCK( &SrvEndpointLock );

                KdPrint(( "Disconnected suspected DoS attacker by WorkItem shortage (%z)\n", (PCSTRING)&connection->OemClientMachineNameString ));
                TearDownAmount -= connection->InProgressWorkContextCount;
                SrvCloseConnection( connection, FALSE );

                ACQUIRE_LOCK( &SrvEndpointLock );
            }

            SrvDereferenceConnection( connection );

        } // walk connection list

        index = (USHORT)-1;

        while ( TearDownAmount > 0 ) {

            PLIST_ENTRY wlistEntry, wlistHead;
            KIRQL oldIrql;
            LARGE_INTEGER now;

            //
            // Get the next active connection in the table.  If no more
            // are available, WalkConnectionTable returns NULL.
            // Otherwise, it returns a referenced pointer to a
            // connection.
            //

            connection = WalkConnectionTable( endpoint, &index );
            if ( connection == NULL ) {
                break;
            }

            //
            // To determine if we should tear this connection down, we require that there be work waiting on
            // the transport, since that is the way anonymous users can attack us.  If there is, we use a
            // random method based on the timestamp of the last time this was ran.  We cycle through the connections
            // and use the index to determine if a teardown is issued (for a psuedo-random result)
            //
            if( (GET_BLOCK_STATE(connection) == BlockStateActive) && (connection->InProgressWorkContextCount > 0) )
            {
                RELEASE_LOCK( &SrvEndpointLock );

                KdPrint(( "Disconnected suspected DoS attack triggered by WorkItem shortage\n" ));
                TearDownAmount -= connection->InProgressWorkContextCount;
                SrvCloseConnection( connection, FALSE );

                ACQUIRE_LOCK( &SrvEndpointLock );
            }

            SrvDereferenceConnection( connection );

        } // walk connection list

        //
        // Capture a pointer to the next endpoint in the list (that one
        // can't go away because we hold the endpoint list), then
        // dereference the current endpoint.
        //

        listEntry = listEntry->Flink;
        SrvDereferenceEndpoint( endpoint );

    } // walk endpoint list

    RELEASE_LOCK( &SrvEndpointLock );


    // This is the special work item for tearing down connections to free WORK_ITEMS.  We're done, so release it
    SET_BLOCK_TYPE( WorkContext, BlockTypeGarbage );
    SRV_DOS_COMPLETE_TEARDOWN();

    return;
}


VOID
TimeoutSessions (
    IN PLARGE_INTEGER CurrentTime
    )

/*++

Routine Description:

    This routine walks the ordered list of sessions and closes those
    that have been idle too long, sends warning messages to those
    that are about to be forced closed due to logon hours expiring,
    and closes those whose logon hours have expired.

Arguments:

    CurrentTime - the current system time.

Return Value:

    None

--*/

{
    USHORT index;
    LARGE_INTEGER oldestTime;
    LARGE_INTEGER pastExpirationTime;
    LARGE_INTEGER twoMinuteWarningTime;
    LARGE_INTEGER fiveMinuteWarningTime;
    LARGE_INTEGER time;
    LARGE_INTEGER searchCutoffTime;
    PLIST_ENTRY listEntry;
    PENDPOINT endpoint;
    PCONNECTION connection;

    PAGED_CODE( );

    ACQUIRE_LOCK( &SrvConfigurationLock );

    //
    // If autodisconnect is turned off (the timeout == 0) set the oldest
    // last use time to zero so that we and don't attempt to
    // autodisconnect sessions.
    //

    if ( SrvAutodisconnectTimeout.QuadPart == 0 ) {

        oldestTime.QuadPart = 0;

    } else {

        //
        // Determine the oldest last use time a session can have and not
        // be closed.
        //

        oldestTime.QuadPart = CurrentTime->QuadPart -
                                        SrvAutodisconnectTimeout.QuadPart;
    }

    searchCutoffTime.QuadPart = (*CurrentTime).QuadPart - SrvSearchMaxTimeout.QuadPart;

    RELEASE_LOCK( &SrvConfigurationLock );

    //
    // Set up the warning times.  If a client's kick-off time is sooner
    // than one of these times, an appropriate warning message is sent
    // to the client.
    //

    time.QuadPart = 10*1000*1000*60*2;               // two minutes
    twoMinuteWarningTime.QuadPart = CurrentTime->QuadPart + time.QuadPart;

    time.QuadPart = (ULONG)10*1000*1000*60*5;        // five minutes
    fiveMinuteWarningTime.QuadPart = CurrentTime->QuadPart + time.QuadPart;
    pastExpirationTime.QuadPart = CurrentTime->QuadPart - time.QuadPart;

    //
    // Walk each connection and determine if we should close it.
    //

    ACQUIRE_LOCK( &SrvEndpointLock );

    listEntry = SrvEndpointList.ListHead.Flink;

    while ( listEntry != &SrvEndpointList.ListHead ) {

        endpoint = CONTAINING_RECORD(
                        listEntry,
                        ENDPOINT,
                        GlobalEndpointListEntry
                        );

        //
        // If this endpoint is closing, skip to the next one.
        // Otherwise, reference the endpoint so that it can't go away.
        //

        if ( GET_BLOCK_STATE(endpoint) != BlockStateActive ) {
            listEntry = listEntry->Flink;
            continue;
        }

        SrvReferenceEndpoint( endpoint );

        //
        // Walk the endpoint's connection table.
        //

        index = (USHORT)-1;

        while ( TRUE ) {

            //
            // Get the next active connection in the table.  If no more
            // are available, WalkConnectionTable returns NULL.
            // Otherwise, it returns a referenced pointer to a
            // connection.
            //

            connection = WalkConnectionTable( endpoint, &index );
            if ( connection == NULL ) {
                break;
            }

            RELEASE_LOCK( &SrvEndpointLock );

            CloseIdleConnection(
                            connection,
                            CurrentTime,
                            &oldestTime,
                            &pastExpirationTime,
                            &twoMinuteWarningTime,
                            &fiveMinuteWarningTime
                            );

            //
            // Time out old core search blocks.
            //

            if ( GET_BLOCK_STATE(connection) == BlockStateActive ) {
                (VOID)SrvTimeoutSearches(
                          &searchCutoffTime,
                          connection,
                          FALSE
                          );
            }

            ACQUIRE_LOCK( &SrvEndpointLock );

            SrvDereferenceConnection( connection );

        } // walk connection table

        //
        // Capture a pointer to the next endpoint in the list (that one
        // can't go away because we hold the endpoint list), then
        // dereference the current endpoint.
        //

        listEntry = listEntry->Flink;
        SrvDereferenceEndpoint( endpoint );

    } // walk endpoint list

    RELEASE_LOCK( &SrvEndpointLock );

} // TimeoutSessions


VOID
TimeoutWaitingOpens (
    IN PLARGE_INTEGER CurrentTime
    )

/*++

Routine Description:

    This function times out opens that are waiting for another client
    or local process to release its oplock.  This opener's wait for
    oplock break IRP is cancelled, causing the opener to return the
    failure to the client.

Arguments:

    CurrentTime - pointer to the current system time.

Return Value:

    None.

--*/

{
    PLIST_ENTRY listEntry;
    PWAIT_FOR_OPLOCK_BREAK waitForOplockBreak;

    PAGED_CODE( );

    //
    // Entries in wait for oplock break list are chronological, i.e. the
    // oldest entries are closest to the head of the list.
    //

    ACQUIRE_LOCK( &SrvOplockBreakListLock );

    while ( !IsListEmpty( &SrvWaitForOplockBreakList ) ) {

        listEntry = SrvWaitForOplockBreakList.Flink;
        waitForOplockBreak = CONTAINING_RECORD( listEntry,
                                                WAIT_FOR_OPLOCK_BREAK,
                                                ListEntry
                                              );

        if ( waitForOplockBreak->TimeoutTime.QuadPart > CurrentTime->QuadPart ) {

            //
            // No more wait for oplock breaks to timeout
            //

            break;

        }

        IF_DEBUG( OPLOCK ) {
            KdPrint(( "srv!TimeoutWaitingOpens: Failing stuck open, "
                       "cancelling wait IRP %p\n", waitForOplockBreak->Irp ));
            KdPrint(( "Timeout time = %08lx.%08lx, current time = %08lx.%08lx\n",
                       waitForOplockBreak->TimeoutTime.HighPart,
                       waitForOplockBreak->TimeoutTime.LowPart,
                       CurrentTime->HighPart,
                       CurrentTime->LowPart ));

        }

        //
        // Timeout this wait for oplock break
        //

        RemoveHeadList( &SrvWaitForOplockBreakList );

        IoCancelIrp( waitForOplockBreak->Irp );
        waitForOplockBreak->WaitState = WaitStateOplockWaitTimedOut;

        SrvDereferenceWaitForOplockBreak( waitForOplockBreak );
    }

    RELEASE_LOCK( &SrvOplockBreakListLock );

} // TimeoutWaitingOpens


VOID
TimeoutStuckOplockBreaks (
    IN PLARGE_INTEGER CurrentTime
    )

/*++

Routine Description:

    This function times out blocked oplock breaks.

Arguments:

    None.

Return Value:

    None.

--*/

{
    PLIST_ENTRY listEntry;
    PRFCB rfcb;
    PPAGED_RFCB pagedRfcb;

    PAGED_CODE( );

    //
    // Entries in wait for oplock break list are chronological, i.e. the
    // oldest entries are closest to the head of the list.
    //

    ACQUIRE_LOCK( &SrvOplockBreakListLock );

    while ( !IsListEmpty( &SrvOplockBreaksInProgressList ) ) {

        listEntry = SrvOplockBreaksInProgressList.Flink;
        rfcb = CONTAINING_RECORD( listEntry, RFCB, ListEntry );

        pagedRfcb = rfcb->PagedRfcb;
        if ( pagedRfcb->OplockBreakTimeoutTime.QuadPart > CurrentTime->QuadPart ) {

            //
            // No more wait for oplock break requests to timeout
            //

            break;

        }

        IF_DEBUG( ERRORS ) {
            KdPrint(( "srv!TimeoutStuckOplockBreaks: Failing stuck oplock, "
                       "break request.  Closing %wZ\n",
                       &rfcb->Mfcb->FileName ));
        }

        IF_DEBUG( STUCK_OPLOCK ) {
            KdPrint(( "srv!TimeoutStuckOplockBreaks: Failing stuck oplock, "
                       "break request.  Closing %wZ\n",
                       &rfcb->Mfcb->FileName ));

            KdPrint(( "Rfcb %p\n", rfcb ));

            KdPrint(( "Timeout time = %08lx.%08lx, current time = %08lx.%08lx\n",
                       pagedRfcb->OplockBreakTimeoutTime.HighPart,
                       pagedRfcb->OplockBreakTimeoutTime.LowPart,
                       CurrentTime->HighPart,
                       CurrentTime->LowPart ));

            DbgBreakPoint();
        }

        //
        // We have been waiting too long for an oplock break response.
        // Unilaterally acknowledge the oplock break, on the assumption
        // that the client is dead.
        //

        rfcb->NewOplockLevel = NO_OPLOCK_BREAK_IN_PROGRESS;
        rfcb->OnOplockBreaksInProgressList = FALSE;

        //
        // Remove the RFCB from the Oplock breaks in progress list, and
        // release the RFCB reference.
        //

        SrvRemoveEntryList( &SrvOplockBreaksInProgressList, &rfcb->ListEntry );
#if DBG
        rfcb->ListEntry.Flink = rfcb->ListEntry.Blink = NULL;
#endif
        RELEASE_LOCK( &SrvOplockBreakListLock );

        SrvAcknowledgeOplockBreak( rfcb, 0 );

        ExInterlockedAddUlong(
            &rfcb->Connection->OplockBreaksInProgress,
            (ULONG)-1,
            rfcb->Connection->EndpointSpinLock
            );

        SrvDereferenceRfcb( rfcb );

        ACQUIRE_LOCK( &SrvOplockBreakListLock );
    }

    RELEASE_LOCK( &SrvOplockBreakListLock );

} // TimeoutStuckOplockBreaks


VOID
UpdateConnectionQos (
    IN PLARGE_INTEGER CurrentTime
    )

/*++

Routine Description:

    This function updates the qos information for each connection.

Arguments:

    CurrentTime - the current system time.

Return Value:

    None.

--*/

{
    USHORT index;
    PENDPOINT endpoint;
    PLIST_ENTRY listEntry;
    PCONNECTION connection;

    PAGED_CODE( );

    //
    // Go through each connection of each endpoint and update the qos
    // information.
    //

    ACQUIRE_LOCK( &SrvEndpointLock );

    listEntry = SrvEndpointList.ListHead.Flink;

    while ( listEntry != &SrvEndpointList.ListHead ) {

        endpoint = CONTAINING_RECORD(
                        listEntry,
                        ENDPOINT,
                        GlobalEndpointListEntry
                        );

        //
        // If this endpoint is closing, or is a connectionless (IPX)
        // endpoint, skip to the next one.  Otherwise, reference the
        // endpoint so that it can't go away.
        //

        if ( (GET_BLOCK_STATE(endpoint) != BlockStateActive) ||
             endpoint->IsConnectionless ) {
            listEntry = listEntry->Flink;
            continue;
        }

        SrvReferenceEndpoint( endpoint );

        //
        // Walk the endpoint's connection table.
        //

        index = (USHORT)-1;

        while ( TRUE ) {

            //
            // Get the next active connection in the table.  If no more
            // are available, WalkConnectionTable returns NULL.
            // Otherwise, it returns a referenced pointer to a
            // connection.
            //

            connection = WalkConnectionTable( endpoint, &index );
            if ( connection == NULL ) {
                break;
            }

            RELEASE_LOCK( &SrvEndpointLock );

            SrvUpdateVcQualityOfService( connection, CurrentTime );

            ACQUIRE_LOCK( &SrvEndpointLock );

            SrvDereferenceConnection( connection );

        }

        //
        // Capture a pointer to the next endpoint in the list (that one
        // can't go away because we hold the endpoint list), then
        // dereference the current endpoint.
        //

        listEntry = listEntry->Flink;
        SrvDereferenceEndpoint( endpoint );

    }

    RELEASE_LOCK( &SrvEndpointLock );

    return;

} // UpdateConnectionQos

VOID
LazyFreeQueueDataStructures (
    PWORK_QUEUE queue
    )

/*++

Routine Description:

    This function frees work context blocks and other per-queue data
    structures that are held on linked lists when otherwise free.  It
    only frees a few at a time, to allow a slow ramp-down.

Arguments:

    CurrentTime - the current system time.

Return Value:

    None.

--*/

{
    PSINGLE_LIST_ENTRY listEntry;
    KIRQL oldIrql;
    ULONG i;
    PWORK_CONTEXT workContext;

    //
    // Clean out the queue->FreeContext
    //
    workContext = NULL;
    workContext = (PWORK_CONTEXT)InterlockedExchangePointer( &queue->FreeContext, workContext );

    if( workContext != NULL ) {
        ExInterlockedPushEntrySList( workContext->FreeList,
                                     &workContext->SingleListEntry,
                                     &queue->SpinLock
                                   );
        InterlockedIncrement( &queue->FreeWorkItems );
    }

    //
    // Free 1 normal work item, if appropriate
    //
    if( queue->FreeWorkItems > queue->MinFreeWorkItems ) {


        listEntry = ExInterlockedPopEntrySList( &queue->NormalWorkItemList,
                                                &queue->SpinLock );

        if( listEntry != NULL ) {
            PWORK_CONTEXT workContext;

            InterlockedDecrement( &queue->FreeWorkItems );

            workContext = CONTAINING_RECORD( listEntry, WORK_CONTEXT, SingleListEntry );

            SrvFreeNormalWorkItem( workContext );
        }
    }

    //
    // Free 1 raw mode work item, if appropriate
    //

    if( (ULONG)queue->AllocatedRawModeWorkItems > SrvMaxRawModeWorkItemCount / SrvNumberOfProcessors ) {

        PWORK_CONTEXT workContext;

        listEntry = ExInterlockedPopEntrySList( &queue->RawModeWorkItemList, &queue->SpinLock );

        if( listEntry != NULL ) {
            InterlockedDecrement( &queue->FreeRawModeWorkItems );
            ASSERT( queue->FreeRawModeWorkItems >= 0 );
            workContext = CONTAINING_RECORD( listEntry, WORK_CONTEXT, SingleListEntry );
            SrvFreeRawModeWorkItem( workContext );
        }

    }

    //
    // Free 1 rfcb off the list
    //
    {
        PRFCB rfcb = NULL;

        rfcb = (PRFCB)InterlockedExchangePointer( &queue->CachedFreeRfcb, rfcb );

        if( rfcb != NULL ) {
            ExInterlockedPushEntrySList( &queue->RfcbFreeList,
                                         &rfcb->SingleListEntry,
                                         &queue->SpinLock
                                       );
            InterlockedIncrement( &queue->FreeRfcbs );
        }

        listEntry = ExInterlockedPopEntrySList( &queue->RfcbFreeList,
                                                &queue->SpinLock );

        if( listEntry ) {
            InterlockedDecrement( &queue->FreeRfcbs );
            rfcb = CONTAINING_RECORD( listEntry, RFCB, SingleListEntry );
            INCREMENT_DEBUG_STAT( SrvDbgStatistics.RfcbInfo.Frees );
            FREE_HEAP( rfcb->PagedRfcb );
            DEALLOCATE_NONPAGED_POOL( rfcb );
        }
    }

    //
    // Free 1 Mfcb off the list
    //
    {

        PNONPAGED_MFCB nonpagedMfcb = NULL;

        nonpagedMfcb = (PNONPAGED_MFCB)InterlockedExchangePointer(&queue->CachedFreeMfcb,
                                                                  nonpagedMfcb);

        if( nonpagedMfcb != NULL ) {
            ExInterlockedPushEntrySList( &queue->MfcbFreeList,
                                         &nonpagedMfcb->SingleListEntry,
                                         &queue->SpinLock
                                       );
            InterlockedIncrement( &queue->FreeMfcbs );
        }

        listEntry = ExInterlockedPopEntrySList( &queue->MfcbFreeList,
                                                &queue->SpinLock );
        if( listEntry ) {
            InterlockedDecrement( &queue->FreeMfcbs );
            nonpagedMfcb = CONTAINING_RECORD( listEntry, NONPAGED_MFCB, SingleListEntry );
            DEALLOCATE_NONPAGED_POOL( nonpagedMfcb );
        }
    }

    //
    // Free memory in the per-queue pool free lists
    //
    {
        //
        // Free the paged pool chunks
        //
        SrvClearLookAsideList( &queue->PagedPoolLookAsideList, SrvFreePagedPool );

        //
        // Free the non paged pool chunks
        //
        SrvClearLookAsideList( &queue->NonPagedPoolLookAsideList, SrvFreeNonPagedPool );
    }

} // LazyFreeQueueDataStructures

VOID
SrvUserAlertRaise (
    IN ULONG Message,
    IN ULONG NumberOfStrings,
    IN PUNICODE_STRING String1 OPTIONAL,
    IN PUNICODE_STRING String2 OPTIONAL,
    IN PUNICODE_STRING ComputerName
    )
{
    NTSTATUS status;
    IO_STATUS_BLOCK ioStatusBlock;
    PSTD_ALERT alert;
    PUSER_OTHER_INFO user;
    LARGE_INTEGER currentTime;
    ULONG mailslotLength;
    ULONG string1Length = 0;
    ULONG string2Length = 0;
    PCHAR variableInfo;
    UNICODE_STRING computerName;
    HANDLE alerterHandle;

    PAGED_CODE( );

    ASSERT( (NumberOfStrings == 2 && String1 != NULL && String2 != NULL) ||
            (NumberOfStrings == 1 && String1 != NULL) ||
            (NumberOfStrings == 0) );

    //
    // Open a handle to the alerter service's mailslot.
    //

    status = OpenAlerter( &alerterHandle );
    if ( !NT_SUCCESS(status) ) {
        return;
    }

    //
    // Get rid of the leading backslashes from the computer name.
    //

    computerName.Buffer = ComputerName->Buffer + 2;
    computerName.Length = (USHORT)(ComputerName->Length - 2*sizeof(WCHAR));
    computerName.MaximumLength =
        (USHORT)(ComputerName->MaximumLength - 2*sizeof(WCHAR));

    //
    // Allocate a buffer to hold the mailslot we're going to send to the
    // alerter.
    //

    if ( String1 != NULL ) {
        string1Length = String1->Length + sizeof(WCHAR);
    }

    if ( String2 != NULL ) {
        string2Length = String2->Length + sizeof(WCHAR);
    }

    mailslotLength = sizeof(STD_ALERT) + sizeof(USER_OTHER_INFO) +
                         string1Length + string2Length +
                         sizeof(WCHAR) +
                         ComputerName->Length + sizeof(WCHAR);

    alert = ALLOCATE_HEAP_COLD( mailslotLength, BlockTypeDataBuffer );
    if ( alert == NULL ) {
        SRVDBG_RELEASE_HANDLE( alerterHandle, "ALR", 20, 0 );
        SrvNtClose( alerterHandle, FALSE );
        return;
    }

    //
    // Set up the standard alert structure.
    //

    KeQuerySystemTime( &currentTime );
    RtlTimeToSecondsSince1970( &currentTime, &alert->alrt_timestamp );

    STRCPY( alert->alrt_eventname, StrUserAlertEventName );
    STRCPY( alert->alrt_servicename, SrvAlertServiceName );

    //
    // Set up the user info in the alert.
    //

    user = (PUSER_OTHER_INFO)ALERT_OTHER_INFO(alert);

    user->alrtus_errcode = Message;

    user->alrtus_numstrings = NumberOfStrings;

    //
    // Set up the variable portion of the message.
    //

    variableInfo = ALERT_VAR_DATA(user);

    if ( String1 != NULL ) {
        RtlCopyMemory(
            variableInfo,
            String1->Buffer,
            String1->Length
            );
        *(PWCH)(variableInfo + String1->Length) = UNICODE_NULL;
        variableInfo += String1->Length + sizeof(WCHAR);
    }

    if ( String2 != NULL ) {
        RtlCopyMemory(
            variableInfo,
            String2->Buffer,
            String2->Length
            );
        *(PWCH)(variableInfo + String2->Length) = UNICODE_NULL;
        variableInfo += String2->Length + sizeof(WCHAR);
    }

    *(PWCH)variableInfo = UNICODE_NULL;
    variableInfo += sizeof(WCHAR);

    RtlCopyMemory(
        variableInfo,
        ComputerName->Buffer,
        ComputerName->Length
        );
    *(PWCH)(variableInfo + ComputerName->Length) = UNICODE_NULL;
    variableInfo += ComputerName->Length + sizeof(WCHAR);

    status = NtWriteFile(
                 alerterHandle,
                 NULL,                       // Event
                 NULL,                       // ApcRoutine
                 NULL,                       // ApcContext
                 &ioStatusBlock,
                 alert,
                 mailslotLength,
                 NULL,                       // ByteOffset
                 NULL                        // Key
                 );

    if ( !NT_SUCCESS(status) ) {

        INTERNAL_ERROR(
            ERROR_LEVEL_UNEXPECTED,
            "SrvUserAlertRaise: NtWriteFile failed: %X\n",
            status,
            NULL
            );

        SrvLogServiceFailure( SRV_SVC_NT_WRITE_FILE, status );

    }

    FREE_HEAP( alert );
    SRVDBG_RELEASE_HANDLE( alerterHandle, "ALR", 21, 0 );
    SrvNtClose( alerterHandle, FALSE );

    return;

} // SrvUserAlertRaise


VOID
SrvAdminAlertRaise (
    IN ULONG Message,
    IN ULONG NumberOfStrings,
    IN PUNICODE_STRING String1 OPTIONAL,
    IN PUNICODE_STRING String2 OPTIONAL,
    IN PUNICODE_STRING String3 OPTIONAL
    )
{
    NTSTATUS status;
    IO_STATUS_BLOCK ioStatusBlock;
    PSTD_ALERT alert;
    PADMIN_OTHER_INFO admin;
    LARGE_INTEGER currentTime;
    ULONG mailslotLength;
    ULONG string1Length = 0;
    ULONG string2Length = 0;
    ULONG string3Length = 0;
    PCHAR variableInfo;
    HANDLE alerterHandle;

    PAGED_CODE( );

    ASSERT( (NumberOfStrings == 3 && String1 != NULL && String2 != NULL && String3 != NULL ) ||
            (NumberOfStrings == 2 && String1 != NULL && String2 != NULL && String3 == NULL ) ||
            (NumberOfStrings == 1 && String1 != NULL && String2 == NULL && String3 == NULL ) ||
            (NumberOfStrings == 0 && String1 == NULL && String2 == NULL && String3 == NULL ) );

    //
    // Open a handle to the alerter service's mailslot.
    //

    status = OpenAlerter( &alerterHandle );
    if ( !NT_SUCCESS(status) ) {
        return;
    }

    //
    // Allocate a buffer to hold the mailslot we're going to send to the
    // alerter.
    //

    if ( String1 != NULL ) {
        string1Length = String1->Length + sizeof(WCHAR);
    }

    if ( String2 != NULL ) {
        string2Length = String2->Length + sizeof(WCHAR);
    }

    if ( String3 != NULL ) {
        string3Length = String3->Length + sizeof(WCHAR);
    }

    mailslotLength = sizeof(STD_ALERT) + sizeof(ADMIN_OTHER_INFO) +
                         string1Length + string2Length + string3Length;

    alert = ALLOCATE_HEAP_COLD( mailslotLength, BlockTypeDataBuffer );
    if ( alert == NULL ) {
        SRVDBG_RELEASE_HANDLE( alerterHandle, "ALR", 22, 0 );
        SrvNtClose( alerterHandle, FALSE );
        return;
    }

    //
    // Set up the standard alert structure.
    //

    KeQuerySystemTime( &currentTime );
    RtlTimeToSecondsSince1970( &currentTime, &alert->alrt_timestamp );

    STRCPY( alert->alrt_eventname, StrAdminAlertEventName );
    STRCPY( alert->alrt_servicename, SrvAlertServiceName );

    //
    // Set up the user info in the alert.
    //

    admin = (PADMIN_OTHER_INFO)ALERT_OTHER_INFO(alert);

    admin->alrtad_errcode = Message;
    admin->alrtad_numstrings = NumberOfStrings;

    //
    // Set up the variable portion of the message.
    //

    variableInfo = ALERT_VAR_DATA(admin);

    if ( String1 != NULL ) {
        RtlCopyMemory(
            variableInfo,
            String1->Buffer,
            String1->Length
            );
        *(PWCH)(variableInfo + String1->Length) = UNICODE_NULL;
        variableInfo += string1Length;
    }

    if ( String2 != NULL ) {
        RtlCopyMemory(
            variableInfo,
            String2->Buffer,
            String2->Length
            );
        *(PWCH)(variableInfo + String2->Length) = UNICODE_NULL;
        variableInfo += string2Length;
    }

    if ( String3 != NULL ){
        RtlCopyMemory(
            variableInfo,
            String3->Buffer,
            String3->Length
            );
        *(PWCH)(variableInfo + String3->Length) = UNICODE_NULL;
    }

    status = NtWriteFile(
                 alerterHandle,
                 NULL,                       // Event
                 NULL,                       // ApcRoutine
                 NULL,                       // ApcContext
                 &ioStatusBlock,
                 alert,
                 mailslotLength,
                 NULL,                       // ByteOffset
                 NULL                        // Key
                 );

    if ( !NT_SUCCESS(status) ) {
        INTERNAL_ERROR(
            ERROR_LEVEL_UNEXPECTED,
            "SrvAdminAlertRaise: NtWriteFile failed: %X\n",
            status,
            NULL
            );

        SrvLogServiceFailure( SRV_SVC_NT_WRITE_FILE, status );
    }

    FREE_HEAP( alert );
    SRVDBG_RELEASE_HANDLE( alerterHandle, "ALR", 23, 0 );
    SrvNtClose( alerterHandle, FALSE );

    return;

} // SrvAdminAlertRaise


NTSTATUS
TimeToTimeString (
    IN PLARGE_INTEGER Time,
    OUT PUNICODE_STRING TimeString
    )
{
    TIME_FIELDS timeFields;
    UCHAR buffer[6];
    ANSI_STRING ansiTimeString;
    LARGE_INTEGER localTime;

    PAGED_CODE( );

    // !!! need a better, internationalizable way to do this.

    //
    // Convert Time To Local Time
    //

    ExSystemTimeToLocalTime(
                        Time,
                        &localTime
                        );


    RtlTimeToTimeFields( &localTime, &timeFields );

    buffer[0] = (UCHAR)( (timeFields.Hour / 10) + '0' );
    buffer[1] = (UCHAR)( (timeFields.Hour % 10) + '0' );
    buffer[2] = ':';
    buffer[3] = (UCHAR)( (timeFields.Minute / 10) + '0' );
    buffer[4] = (UCHAR)( (timeFields.Minute % 10) + '0' );
    buffer[5] = '\0';

    RtlInitString( &ansiTimeString, buffer );

    return RtlAnsiStringToUnicodeString( TimeString, &ansiTimeString, TRUE );

} // TimeToTimeString


VOID
CheckErrorCount (
    PSRV_ERROR_RECORD ErrorRecord,
    BOOLEAN UseRatio
    )
/*++

Routine Description:

    This routine checks the record of server operations and adds up the
    count of successes to failures.

Arguments:

    ErrorRecord - Points to an SRV_ERROR_RECORD structure

    UseRatio - If TRUE, look at count of errors,
               If FALSE, look at ratio of error to total.

Return Value:

    None.

--*/
{
    ULONG totalOperations;
    ULONG failedOperations;

    UNICODE_STRING string1, string2;
    WCHAR buffer1[20], buffer2[20];
    NTSTATUS status;

    PAGED_CODE( );

    failedOperations = ErrorRecord->FailedOperations;
    totalOperations = failedOperations + ErrorRecord->SuccessfulOperations;

    //
    // Zero out the counters
    //

    ErrorRecord->SuccessfulOperations = 0;
    ErrorRecord->FailedOperations = 0;

    if ( (UseRatio &&
          ( totalOperations != 0 &&
           ((failedOperations * 100 / totalOperations) >
                         ErrorRecord->ErrorThreshold)))
               ||

         (!UseRatio &&
           failedOperations > ErrorRecord->ErrorThreshold) ) {

        //
        // Raise an alert
        //

        string1.Buffer = buffer1;
        string1.Length = string1.MaximumLength = sizeof(buffer1);

        string2.Buffer = buffer2;
        string2.Length = string2.MaximumLength = sizeof(buffer2);

        status = RtlIntegerToUnicodeString( failedOperations, 10, &string1 );
        ASSERT( NT_SUCCESS( status ) );

        status = RtlIntegerToUnicodeString( SrvAlertMinutes, 10, &string2 );
        ASSERT( NT_SUCCESS( status ) );

        if ( ErrorRecord->AlertNumber == ALERT_NetIO) {

            //
            // We need a third string for the network name.
            //
            // This allocation is unfortunate.  We need to maintain
            // per xport error count so we can print out the actual
            // xport name.
            //

            UNICODE_STRING string3;
            RtlInitUnicodeString(
                            &string3,
                            StrNoNameTransport
                            );


            //
            // We need a third string for the network name
            //

            SrvAdminAlertRaise(
                ErrorRecord->AlertNumber,
                3,
                &string1,
                &string2,
                &string3
                );

        } else {

            SrvAdminAlertRaise(
                ErrorRecord->AlertNumber,
                2,
                &string1,
                &string2,
                NULL
                );
        }

    }

    return;

} // CheckErrorCount


VOID
CheckDiskSpace (
    VOID
    )
/*++

Routine Description:

    This routine check disk space on local drives.  If a drive
    is low on space, an alert is raised.

Arguments:

    None.

Return Value:

    None.

--*/

{
    ULONG diskMask;
    UNICODE_STRING insert1, insert2;
    WCHAR buffer2[20];
    UNICODE_STRING pathName;
    WCHAR dosPathPrefix[] = L"\\DosDevices\\A:\\";
    NTSTATUS status;
    OBJECT_ATTRIBUTES objectAttributes;
    IO_STATUS_BLOCK iosb;
    FILE_FS_SIZE_INFORMATION sizeInformation;
    FILE_FS_DEVICE_INFORMATION deviceInformation;
    HANDLE handle;
    ULONG percentFree;
    PWCH currentDrive;
    DWORD diskconfiguration;

    PAGED_CODE( );

    if( SrvFreeDiskSpaceThreshold == 0 ) {
        return;
    }

    diskMask = 0x80000000;  // Start at A:

    pathName.Buffer = dosPathPrefix;
    pathName.MaximumLength = 32;
    pathName.Length = 28;           // skip last backslash!

    currentDrive = &dosPathPrefix[12];
    insert1.Buffer = &dosPathPrefix[12];
    insert1.Length = 4;

    //
    // SrvDiskConfiguration is a bitmask of drives that are
    // administratively shared.  It is updated by NetShareAdd and
    // NetShareDel.
    //
    diskconfiguration = SrvDiskConfiguration;

    for ( ; diskMask >= 0x40; diskMask >>= 1, dosPathPrefix[12]++ ) {

        if ( !(diskconfiguration & diskMask) ) {
            continue;
        }

        //
        // Check disk space on this disk
        //

        SrvInitializeObjectAttributes_U(
            &objectAttributes,
            &pathName,
            OBJ_CASE_INSENSITIVE,
            NULL,
            NULL
            );

        status = NtOpenFile(
                    &handle,
                    FILE_READ_ATTRIBUTES,
                    &objectAttributes,
                    &iosb,
                    FILE_SHARE_READ | FILE_SHARE_WRITE,
                    FILE_NON_DIRECTORY_FILE
                    );
        if ( !NT_SUCCESS( status) ) {
            continue;
        }
        SRVDBG_CLAIM_HANDLE( handle, "DSK", 16, 0 );

        status = NtQueryVolumeInformationFile(
                     handle,
                     &iosb,
                     &deviceInformation,
                     sizeof( FILE_FS_DEVICE_INFORMATION ),
                     FileFsDeviceInformation
                     );
        if ( NT_SUCCESS(status) ) {
            status = iosb.Status;
        }
        SRVDBG_RELEASE_HANDLE( handle, "DSK", 24, 0 );
        if ( !NT_SUCCESS( status ) ||
             (deviceInformation.Characteristics &
                (FILE_FLOPPY_DISKETTE | FILE_READ_ONLY_DEVICE | FILE_WRITE_ONCE_MEDIA)) ||
             !(deviceInformation.Characteristics &
                FILE_DEVICE_IS_MOUNTED) ) {
            SrvNtClose( handle, FALSE );
            continue;
        }

        // Validate its write-able
        if( deviceInformation.Characteristics & FILE_REMOVABLE_MEDIA )
        {
            PIRP Irp;
            PIO_STACK_LOCATION IrpSp;
            KEVENT CompletionEvent;
            PDEVICE_OBJECT DeviceObject;

            // Create the IRP
            KeInitializeEvent( &CompletionEvent, SynchronizationEvent, FALSE );
            Irp = BuildCoreOfSyncIoRequest(
                                handle,
                                NULL,
                                &CompletionEvent,
                                &iosb,
                                &DeviceObject );
            if( !Irp )
            {
                // If we are out of memory, don't log an entry
                goto skip_volume;
            }

            // Initialize the other IRP fields
            IrpSp = IoGetNextIrpStackLocation( Irp );
            IrpSp->MajorFunction = IRP_MJ_DEVICE_CONTROL;
            IrpSp->MinorFunction = 0;
            IrpSp->Parameters.DeviceIoControl.OutputBufferLength = 0;
            IrpSp->Parameters.DeviceIoControl.InputBufferLength = 0;
            IrpSp->Parameters.DeviceIoControl.IoControlCode = IOCTL_DISK_IS_WRITABLE;
            IrpSp->Parameters.DeviceIoControl.Type3InputBuffer = NULL;

            // Issue the IO
            status = StartIoAndWait( Irp, DeviceObject, &CompletionEvent, &iosb );

            if( !NT_SUCCESS(status) )
            {
skip_volume:
                SrvNtClose( handle, FALSE );
                continue;
            }
        }

        SrvNtClose( handle, FALSE );

        pathName.Length += 2;   // include last backslash
        status = NtOpenFile(
                    &handle,
                    FILE_READ_ATTRIBUTES,
                    &objectAttributes,
                    &iosb,
                    FILE_SHARE_READ | FILE_SHARE_WRITE,
                    FILE_DIRECTORY_FILE
                    );
        pathName.Length -= 2;   // skip last backslash
        if ( !NT_SUCCESS( status) ) {
            continue;
        }
        SRVDBG_CLAIM_HANDLE( handle, "DSK", 17, 0 );

        status = NtQueryVolumeInformationFile(
                     handle,
                     &iosb,
                     &sizeInformation,
                     sizeof( FILE_FS_SIZE_INFORMATION ),
                     FileFsSizeInformation
                     );
        if ( NT_SUCCESS(status) ) {
            status = iosb.Status;
        }
        SRVDBG_RELEASE_HANDLE( handle, "DSK", 25, 0 );
        SrvNtClose( handle, FALSE );
        if ( !NT_SUCCESS( status) ) {
            continue;
        }

        //
        // Calculate % space available = AvailableSpace * 100 / TotalSpace
        //

        if( sizeInformation.TotalAllocationUnits.QuadPart > 0 )
        {
            LARGE_INTEGER mbFree;
            LARGE_INTEGER mbTotal;


            percentFree = (ULONG)(sizeInformation.AvailableAllocationUnits.QuadPart
                        * 100 / sizeInformation.TotalAllocationUnits.QuadPart);

            mbFree.QuadPart = (ULONG)
                                (sizeInformation.AvailableAllocationUnits.QuadPart*
                                 sizeInformation.SectorsPerAllocationUnit*
                                 sizeInformation.BytesPerSector/
                                    (1024*1024));

            ASSERT( percentFree <= 100 );

            //
            // If space is low raise, and we have already raised an alert,
            // then raise the alert.
            //
            // If space is not low, then clear the alert flag so the we will
            // raise an alert if diskspace falls again.
            //

            if ( percentFree < SrvFreeDiskSpaceThreshold ) {
               // If a ceiling is specified, make sure we have exceeded it
               if( SrvFreeDiskSpaceCeiling &&
                   ((mbFree.LowPart > SrvFreeDiskSpaceCeiling) ||
                    (mbFree.HighPart != 0))
                 )
               {
                    goto abort_error;
               }

               if ( !SrvDiskAlertRaised[ *currentDrive - L'A' ] ) {

                    ULONGLONG FreeSpace;

                    SrvLogError(
                        SrvDeviceObject,
                        EVENT_SRV_DISK_FULL,
                        status,
                        NULL,
                        0,
                        &insert1,
                        1
                        );

                    //
                    //  Raise alert
                    //

                    insert2.Buffer = buffer2;
                    insert2.Length = insert2.MaximumLength = sizeof(buffer2);

                    FreeSpace = (ULONGLONG)(sizeInformation.AvailableAllocationUnits.QuadPart
                                          * sizeInformation.SectorsPerAllocationUnit
                                          * sizeInformation.BytesPerSector);


                    status = RtlInt64ToUnicodeString(
                                FreeSpace,
                                10,
                                &insert2
                                );

                    ASSERT( NT_SUCCESS( status ) );

                    SrvAdminAlertRaise(
                        ALERT_Disk_Full,
                        2,
                        &insert1,
                        &insert2,
                        NULL
                        );

                    SrvDiskAlertRaised[ *currentDrive - L'A' ] = TRUE;
                }

            } else { // if ( percentFree < SrvFreeDiskSpaceThreshold )

abort_error:
                SrvDiskAlertRaised[ *currentDrive - L'A' ] = FALSE;

            }
        }
    } // for ( ; diskMask >= 0x40; ... )

    return;

} // CheckDiskSpace


NTSTATUS
OpenAlerter (
    OUT PHANDLE AlerterHandle
    )

/*++

Routine Description:

    This routine opens the alerter server's mailslot.

Arguments:

    AlerterHandle - returns a handle to the mailslot.

Return Value:

    NTSTATUS - Indicates whether the mailslot was opened.

--*/

{
    NTSTATUS status;
    IO_STATUS_BLOCK iosb;
    UNICODE_STRING alerterName;
    OBJECT_ATTRIBUTES objectAttributes;

    PAGED_CODE( );

    //
    // Open a handle to the alerter service's mailslot.
    //
    // !!! use a #define for the name!
    //

    RtlInitUnicodeString( &alerterName, StrAlerterMailslot );

    SrvInitializeObjectAttributes_U(
        &objectAttributes,
        &alerterName,
        0,
        NULL,
        NULL
        );

    status = IoCreateFile(
                AlerterHandle,
                GENERIC_READ | GENERIC_WRITE | SYNCHRONIZE,
                &objectAttributes,
                &iosb,
                NULL,
                FILE_ATTRIBUTE_NORMAL,
                FILE_SHARE_READ | FILE_SHARE_WRITE,
                FILE_OPEN,
                FILE_SYNCHRONOUS_IO_NONALERT,  // Create Options
                NULL,                          // EA Buffer
                0,                             // EA Length
                CreateFileTypeNone,            // File type
                NULL,                          // ExtraCreateParameters
                0                              // Options
                );

    if ( !NT_SUCCESS(status) ) {
        KdPrint(( "OpenAlerter: failed to open alerter mailslot: %X, "
                   "an alert was lost.\n", status ));
    } else {
        SRVDBG_CLAIM_HANDLE( AlerterHandle, "ALR", 18, 0 );
    }

    return status;

} // OpenAlerter

VOID
RecalcCoreSearchTimeout(
    VOID
    )
{
    ULONG factor;
    ULONG newTimeout;

    PAGED_CODE( );

    //
    // we reduce the timeout time by 2**factor
    //

    factor = SrvStatistics.CurrentNumberOfOpenSearches >> 9;

    //
    // Minimum is 30 secs.
    //

    ACQUIRE_LOCK( &SrvConfigurationLock );
    newTimeout = MAX(30, SrvCoreSearchTimeout >> factor);
    SrvSearchMaxTimeout = SecondsToTime( newTimeout, FALSE );
    RELEASE_LOCK( &SrvConfigurationLock );

    return;

} // RecalcCoreSearchTimeout

VOID
SrvCaptureScavengerTimeout (
    IN PLARGE_INTEGER ScavengerTimeout,
    IN PLARGE_INTEGER AlerterTimeout
    )
{
    KIRQL oldIrql;

    ACQUIRE_SPIN_LOCK( &ScavengerSpinLock, &oldIrql );

    SrvScavengerTimeout = *ScavengerTimeout;
    SrvAlertSchedule = *AlerterTimeout;

    RELEASE_SPIN_LOCK( &ScavengerSpinLock, oldIrql );

    return;

} // SrvCaptureScavengerTimeout


#if SRVDBG_PERF
extern ULONG Trapped512s;
#endif

VOID
SrvUpdateStatisticsFromQueues (
    OUT PSRV_STATISTICS CapturedSrvStatistics OPTIONAL
    )
{
    KIRQL oldIrql;
    PWORK_QUEUE queue;

    ACQUIRE_GLOBAL_SPIN_LOCK( Statistics, &oldIrql );

    SrvStatistics.TotalBytesSent.QuadPart = 0;
    SrvStatistics.TotalBytesReceived.QuadPart = 0;
    SrvStatistics.TotalWorkContextBlocksQueued.Time.QuadPart = 0;
    SrvStatistics.TotalWorkContextBlocksQueued.Count = 0;

    //
    // Get the nonblocking statistics
    //

    for( queue = SrvWorkQueues; queue < eSrvWorkQueues; queue++ ) {

        SrvStatistics.TotalBytesSent.QuadPart += queue->stats.BytesSent;
        SrvStatistics.TotalBytesReceived.QuadPart += queue->stats.BytesReceived;

        SrvStatistics.TotalWorkContextBlocksQueued.Count +=
            queue->stats.WorkItemsQueued.Count * STATISTICS_SMB_INTERVAL;

        SrvStatistics.TotalWorkContextBlocksQueued.Time.QuadPart +=
            queue->stats.WorkItemsQueued.Time.QuadPart;
    }

#if SRVDBG_PERF
    SrvStatistics.TotalWorkContextBlocksQueued.Count += Trapped512s;
    Trapped512s = 0;
#endif

    if ( ARGUMENT_PRESENT(CapturedSrvStatistics) ) {
        *CapturedSrvStatistics = SrvStatistics;
    }

    RELEASE_GLOBAL_SPIN_LOCK( Statistics, oldIrql );

    ACQUIRE_SPIN_LOCK( (PKSPIN_LOCK)IoStatisticsLock, &oldIrql );

    for( queue = SrvWorkQueues; queue < eSrvWorkQueues; queue++ ) {

        **(PULONG *)&IoReadOperationCount += (ULONG)(queue->stats.ReadOperations - queue->saved.ReadOperations );
        queue->saved.ReadOperations = queue->stats.ReadOperations;

        **(PLONGLONG *)&IoReadTransferCount += (queue->stats.BytesRead - queue->saved.BytesRead );
        queue->saved.BytesRead = queue->stats.BytesRead;

        **(PULONG *)&IoWriteOperationCount += (ULONG)(queue->stats.WriteOperations - queue->saved.WriteOperations );
        queue->saved.WriteOperations = queue->stats.WriteOperations;

        **(PLONGLONG *)&IoWriteTransferCount += (queue->stats.BytesWritten - queue->saved.BytesWritten );
        queue->saved.BytesWritten = queue->stats.BytesWritten;
    }

    RELEASE_SPIN_LOCK( (PKSPIN_LOCK)IoStatisticsLock, oldIrql );

    return;

} // SrvUpdateStatisticsFromQueues

VOID
ProcessOrphanedBlocks (
    VOID
    )

/*++

Routine Description:

    Orphaned connections are connections with ref counts of 1 but
    with no workitem, etc associated with it.  They need to be cleaned
    up by a dereference.

Arguments:

    None.

Return Value:

    None.

--*/

{
    PSINGLE_LIST_ENTRY listEntry;
    PQUEUEABLE_BLOCK_HEADER block;

    PAGED_CODE( );

    //
    // Run through the list of connection with pending disconnects.
    // Do the work necessary to shut the disconnection connection
    // down.
    //

    while ( TRUE ) {

        listEntry = ExInterlockedPopEntrySList(
                                &SrvBlockOrphanage,
                                &GLOBAL_SPIN_LOCK(Fsd)
                                );

        if( listEntry == NULL ) {
            break;
        }

        InterlockedDecrement( &SrvResourceOrphanedBlocks );

        block = CONTAINING_RECORD(
                            listEntry,
                            QUEUEABLE_BLOCK_HEADER,
                            SingleListEntry
                            );

        if ( GET_BLOCK_TYPE(block) == BlockTypeConnection ) {

            SrvDereferenceConnection( (PCONNECTION)block );

        } else if ( GET_BLOCK_TYPE(block) == BlockTypeRfcb ) {

            SrvDereferenceRfcb( (PRFCB)block );

        } else {
            ASSERT(0);
        }
    }

    return;

} // ProcessOrphanedBlocks

VOID
UpdateSessionLastUseTime(
    IN PLARGE_INTEGER CurrentTime
    )

/*++

Routine Description:

    This routine walks the rfcb list and if it is found to be marked active,
    the session LastUseTime is updated with the current time.

Arguments:

    CurrentTime - the current system time.

Return Value:

    None.

--*/

{
    ULONG listEntryOffset = SrvRfcbList.ListEntryOffset;
    PLIST_ENTRY listEntry;
    PRFCB rfcb;

    PAGED_CODE( );

    //
    // Acquire the lock that protects the SrvRfcbList
    //

    ACQUIRE_LOCK( SrvRfcbList.Lock );

    //
    // Walk the list of blocks until we find one with a resume handle
    // greater than or equal to the specified resume handle.
    //

    for (
        listEntry = SrvRfcbList.ListHead.Flink;
        listEntry != &SrvRfcbList.ListHead;
        listEntry = listEntry->Flink ) {

        //
        // Get a pointer to the actual block.
        //

        rfcb = (PRFCB)((PCHAR)listEntry - listEntryOffset);

        //
        // Check the state of the block and if it is active,
        // reference it.  This must be done as an atomic operation
        // order to prevent the block from being deleted.
        //

        if ( rfcb->IsActive ) {

            rfcb->Lfcb->Session->LastUseTime = *CurrentTime;
            rfcb->IsActive = FALSE;
        }

    } // walk list

    RELEASE_LOCK( SrvRfcbList.Lock );
    return;

} // UpdateSessionLastUseTime
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\srv\prnsupp.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    prnsupp.c

Abstract:

    This module contains routines for supporting printing in the NT
    server.  Many of these routines are wrappers that send the request
    off to XACTSRV through LPC in order to issue a user-mode API.

Author:

    David Treadwell (davidtr) 05-Nov-1991

Revision History:

--*/

#include "precomp.h"
#include "prnsupp.tmh"
#pragma hdrstop

#ifdef ALLOC_PRAGMA
#pragma alloc_text( PAGE, SrvOpenPrinter )
#pragma alloc_text( PAGE, SrvAddPrintJob )
#pragma alloc_text( PAGE, SrvSchedulePrintJob )
#pragma alloc_text( PAGE, SrvClosePrinter )
#endif


NTSTATUS
SrvOpenPrinter(
    IN PWCH PrinterName,
    OUT PHANDLE phPrinter,
    OUT PULONG Error
    )

/*++

Routine Description:

    This routine is a kernel-mode wrapper for the the user-mode API
    OpenPrinter( ).  This packages up a call and sends it off to
    Xactsrv, which makes the actual API call.

Arguments:

    Printer - a pointer to a Unicode string of the printer to open

    Handle - receives a handle, valid only in XACTSRV, that corresponds to
        the Printer open.

    Error - a Win32 error if one occurred, or NO_ERROR if the operation
        was successful.

Return Value:

    NTSTATUS - result of operation.

--*/

{
    NTSTATUS status;
    XACTSRV_REQUEST_MESSAGE requestMessage;
    XACTSRV_REPLY_MESSAGE replyMessage;
    PSZ printerName;
    ULONG printerNameLength;

    PAGED_CODE( );

    printerNameLength = wcslen( PrinterName ) * sizeof(WCHAR) + sizeof(WCHAR);

    printerName = SrvXsAllocateHeap( printerNameLength, &status );

    if ( printerName == NULL ) {
        *Error = RtlNtStatusToDosErrorNoTeb( status );
        return status;
    }

    //
    // SrvXsResource is held at this point
    //

    //
    // Copy over the printer name to the new memory.
    //

    RtlCopyMemory( printerName, PrinterName, printerNameLength );

    //
    // Set up the message to send over the port.
    //

    requestMessage.PortMessage.u1.s1.DataLength =
        sizeof(requestMessage) - sizeof(PORT_MESSAGE);
    requestMessage.PortMessage.u1.s1.TotalLength = sizeof(requestMessage);
    requestMessage.PortMessage.u2.ZeroInit = 0;
    requestMessage.PortMessage.u2.s2.Type = LPC_KERNELMODE_MESSAGE;
    requestMessage.MessageType = XACTSRV_MESSAGE_OPEN_PRINTER;
    requestMessage.Message.OpenPrinter.PrinterName =
        (PCHAR)printerName + SrvXsPortMemoryDelta;

    //
    // Send the message to XACTSRV so it can call OpenPrinter( ).
    //
    // !!! We may want to put a timeout on this.

    IF_DEBUG(XACTSRV) {
        SrvPrint2( "SrvOpenPrinter: sending message at %p PrinterName %s\n",
                       &requestMessage,
                       (PCHAR)requestMessage.Message.OpenPrinter.PrinterName );
    }

    status = NtRequestWaitReplyPort(
                 SrvXsPortHandle,
                (PPORT_MESSAGE)&requestMessage,
                 (PPORT_MESSAGE)&replyMessage
                 );

    if ( !NT_SUCCESS(status) ) {
        IF_DEBUG(ERRORS) {
            SrvPrint1( "SrvOpenPrinter: NtRequestWaitReplyPort failed: %X\n",
                          status );
        }

        SrvLogServiceFailure( SRV_SVC_NT_REQ_WAIT_REPLY_PORT, status );
        *Error = ERROR_UNEXP_NET_ERR;
        goto exit;
    }

    IF_DEBUG(XACTSRV) {
        SrvPrint1( "SrvOpenPrinter: received response at %p\n", &replyMessage );
    }

    *phPrinter = replyMessage.Message.OpenPrinter.hPrinter;
    *Error = replyMessage.Message.OpenPrinter.Error;

exit:

    SrvXsFreeHeap( printerName );

    return status;

} // SrvOpenPrinter


NTSTATUS
SrvAddPrintJob (
    IN PWORK_CONTEXT WorkContext,
    IN HANDLE Handle,
    OUT PUNICODE_STRING FileName,
    OUT PULONG JobId,
    OUT PULONG Error
    )

/*++

Routine Description:

    This routine is a kernel-mode wrapper for the user-mode API AddJob(  ).
    This API returns a filename to use as a disk spool file and a
    Job ID to identify the print job to the spooler subsystem.

Arguments:

    Handle - the Printer handle.

    FileName - filled in with the Unicode name of the file to open as
        a spool filed.  The MaximumLength and Buffer fields should
        be valid on input and are not changed.  Length is changed to
        indicate the length of the NT path name of the file.

    JobId - filled in with the Job ID of the print job.  This value
        is used to call ScheduleJob( ) when the writing of the spool
        file is complete and printing should begin.

    Error - if AddJob failed in XACTSRV, this is the error code.

Return Value:

    NTSTATUS - result of operation.  If AddJob( ) failed, NTSTATUS =
        STATUS_UNSUCCESSFUL and Error contains the real error code.

--*/

{
    NTSTATUS status;
    XACTSRV_REQUEST_MESSAGE requestMessage;
    XACTSRV_REPLY_MESSAGE replyMessage;
    ANSI_STRING fileName;
    PCONNECTION connection = WorkContext->Connection;
    PWCH destPtr, sourcePtr, sourceEndPtr;

    PAGED_CODE( );

    *Error = NO_ERROR;
    fileName.Buffer = NULL;

    //
    // Allocate space to hold the buffer for the file name that will be
    // returned.
    //

    fileName.Buffer = SrvXsAllocateHeap(
                           MAXIMUM_FILENAME_LENGTH * sizeof(WCHAR),
                           &status
                           );

    if ( fileName.Buffer == NULL ) {
        *Error = RtlNtStatusToDosErrorNoTeb( status );
        return(status);
    }

    //
    // SrvXsResource is held at this point
    //

    //
    // Set up the message to send over the port.
    //

    requestMessage.PortMessage.u1.s1.DataLength =
        sizeof(requestMessage) - sizeof(PORT_MESSAGE);
    requestMessage.PortMessage.u1.s1.TotalLength = sizeof(requestMessage);
    requestMessage.PortMessage.u2.ZeroInit = 0;
    requestMessage.PortMessage.u2.s2.Type = LPC_KERNELMODE_MESSAGE;
    requestMessage.MessageType = XACTSRV_MESSAGE_ADD_JOB_PRINTER;
    requestMessage.Message.AddPrintJob.hPrinter = Handle;
    requestMessage.Message.AddPrintJob.Buffer =
                          fileName.Buffer + SrvXsPortMemoryDelta;
    requestMessage.Message.AddPrintJob.BufferLength = MAXIMUM_FILENAME_LENGTH;

    // Add client machine name for notification
    //
    // Copy the client machine name for XACTSRV, skipping over the
    // initial "\\", and deleting trailing spaces.
    //

    destPtr = requestMessage.Message.AddPrintJob.ClientMachineName;
    sourcePtr =
        connection->PagedConnection->ClientMachineNameString.Buffer + 2;
    sourceEndPtr = sourcePtr
        + min( connection->PagedConnection->ClientMachineNameString.Length,
               sizeof(requestMessage.Message.AddPrintJob.ClientMachineName) /
               sizeof(WCHAR) - 1 );

    while ( sourcePtr < sourceEndPtr && *sourcePtr != UNICODE_NULL ) {
        *destPtr++ = *sourcePtr++;
    }

    *destPtr-- = UNICODE_NULL;

    while ( destPtr >= requestMessage.Message.AddPrintJob.ClientMachineName
            &&
            *destPtr == L' ' ) {
        *destPtr-- = UNICODE_NULL;
    }


    //
    // Send the message to XACTSRV so it can call AddJob( ).
    //
    // !!! We may want to put a timeout on this.

    IF_DEBUG(XACTSRV) {
        SrvPrint1( "SrvAddPrintJob: sending message at %p", &requestMessage );
    }

    status = IMPERSONATE( WorkContext );

    if( NT_SUCCESS( status ) ) {
        status = NtRequestWaitReplyPort(
                     SrvXsPortHandle,
                     (PPORT_MESSAGE)&requestMessage,
                     (PPORT_MESSAGE)&replyMessage
                     );

        REVERT( );
    }

    if ( !NT_SUCCESS(status) ) {
        IF_DEBUG(ERRORS) {
            SrvPrint1( "SrvAddPrintJob: NtRequestWaitReplyPort failed: %X\n",
                          status );
        }

        SrvLogServiceFailure( SRV_SVC_NT_REQ_WAIT_REPLY_PORT, status );

        *Error = ERROR_UNEXP_NET_ERR;
        goto exit;
    }

    IF_DEBUG(XACTSRV) {
        SrvPrint1( "SrvAddPrintJob: received response at %p\n", &replyMessage );
    }

    if ( replyMessage.Message.AddPrintJob.Error != NO_ERROR ) {
        *Error = replyMessage.Message.AddPrintJob.Error;
        status = STATUS_UNSUCCESSFUL;
        goto exit;
    }

    //
    // Set up return information.
    //

    *JobId = replyMessage.Message.AddPrintJob.JobId;
    FileName->Length = replyMessage.Message.AddPrintJob.BufferLength;
    RtlCopyMemory( FileName->Buffer, fileName.Buffer, FileName->Length );

exit:

    SrvXsFreeHeap( fileName.Buffer );

    return status;

} // SrvAddPrintJob


NTSTATUS
SrvSchedulePrintJob (
    IN HANDLE PrinterHandle,
    IN ULONG JobId
    )

/*++

Routine Description:

    This routine is a kernel-mode wrapper for the the user-mode API
    ScheduleJob( ).

Arguments:

    PrinterHandle - a handle to a printer returned by OpenPrinter( ).

    JobId - the job ID returned to AddJob( ) that identifies this print
        job.

    Error - if ScheduleJob failed in XACTSRV, this is the error code.

Return Value:

    NTSTATUS - result of operation.  If ScheduleJob( ) failed, NTSTATUS =
        STATUS_UNSUCCESSFUL and Error contains the real error code.

--*/

{
    NTSTATUS status;
    XACTSRV_REQUEST_MESSAGE requestMessage;
    XACTSRV_REPLY_MESSAGE replyMessage;

    PAGED_CODE( );

    //
    // Grab the XsResource
    //

    (VOID) SrvXsAllocateHeap( 0, &status );

    if ( !NT_SUCCESS(status) ) {
        return status;
    }

    //
    // Set up the message to send over the port.
    //

    requestMessage.PortMessage.u1.s1.DataLength =
        sizeof(requestMessage) - sizeof(PORT_MESSAGE);
    requestMessage.PortMessage.u1.s1.TotalLength = sizeof(requestMessage);
    requestMessage.PortMessage.u2.ZeroInit = 0;
    requestMessage.PortMessage.u2.s2.Type = LPC_KERNELMODE_MESSAGE;
    requestMessage.MessageType = XACTSRV_MESSAGE_SCHD_JOB_PRINTER;
    requestMessage.Message.SchedulePrintJob.hPrinter = PrinterHandle;
    requestMessage.Message.SchedulePrintJob.JobId = JobId;

    //
    // Send the message to XACTSRV so it can call ScheduleJob( ).
    //
    // !!! We may want to put a timeout on this.

    IF_DEBUG(XACTSRV) {
        SrvPrint1( "SrvSchedulePrintJob: sending message at %p", &requestMessage );
    }

    status = NtRequestWaitReplyPort(
                 SrvXsPortHandle,
                 (PPORT_MESSAGE)&requestMessage,
                 (PPORT_MESSAGE)&replyMessage
                 );

    if ( !NT_SUCCESS(status) ) {
        IF_DEBUG(ERRORS) {
            SrvPrint1( "SrvSchedulePrintJob: NtRequestWaitReplyPort failed: %X\n",
                          status );
        }

        SrvLogServiceFailure( SRV_SVC_NT_REQ_WAIT_REPLY_PORT, status );
        goto exit;
    }

    IF_DEBUG(XACTSRV) {
        SrvPrint1( "SrvSchedulePrintJob: received response at %p\n",
                       &replyMessage );
    }

exit:

    //
    // release the lock
    //

    SrvXsFreeHeap( NULL );

    return status;

} // SrvSchedulePrintJob


NTSTATUS
SrvClosePrinter (
    IN HANDLE Handle
    )

/*++

Routine Description:

    This routine is a kernel-mode wrapper for the the user-mode API
    ClosePrinter( ).

Arguments:

    Handle - the Printer handle to close.

Return Value:

    NTSTATUS - result of operation.

--*/

{
    NTSTATUS status;
    XACTSRV_REQUEST_MESSAGE requestMessage;
    XACTSRV_REPLY_MESSAGE replyMessage;

    PAGED_CODE( );

    //
    // Grab the XsResource
    //

    (VOID) SrvXsAllocateHeap( 0, &status );

    if ( !NT_SUCCESS(status) ) {
        return status;
    }

    //
    // SrvXsResource is held at this point
    //


    //
    // Set up the message to send over the port.
    //

    requestMessage.PortMessage.u1.s1.DataLength =
        sizeof(requestMessage) - sizeof(PORT_MESSAGE);
    requestMessage.PortMessage.u1.s1.TotalLength = sizeof(requestMessage);
    requestMessage.PortMessage.u2.ZeroInit = 0;
    requestMessage.PortMessage.u2.s2.Type = LPC_KERNELMODE_MESSAGE;
    requestMessage.MessageType = XACTSRV_MESSAGE_CLOSE_PRINTER;
    requestMessage.Message.ClosePrinter.hPrinter = Handle;

    //
    // Send the message to XACTSRV so it can call ClosePrinter( ).
    //
    // !!! We may want to put a timeout on this.

    IF_DEBUG(XACTSRV) {
        SrvPrint1( "SrvClosePrinter: sending message at %p", &requestMessage );
    }

    status = NtRequestWaitReplyPort(
                 SrvXsPortHandle,
                 (PPORT_MESSAGE)&requestMessage,
                 (PPORT_MESSAGE)&replyMessage
                 );

    if ( !NT_SUCCESS(status) ) {
        IF_DEBUG(ERRORS) {
            SrvPrint1( "SrvClosePrinter: NtRequestWaitReplyPort failed: %X\n",
                          status );
        }

        SrvLogServiceFailure( SRV_SVC_NT_REQ_WAIT_REPLY_PORT, status );
        goto exit;
    }

    IF_DEBUG(XACTSRV) {
        SrvPrint1( "SrvClosePrinter: received response at %p\n", &replyMessage );
    }

exit:

    //
    // release the lock
    //

    SrvXsFreeHeap( NULL );

    return status;

} // SrvClosePrinter
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\srv\smbadmin.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    smbadmin.c

Abstract:

    This module contains routines for processing the administrative SMBs:
    negotiate, session setup, tree connect, and logoff.

Author:

    David Treadwell (davidtr)    30-Oct-1989

Revision History:

--*/

#include "precomp.h"
#include "smbadmin.tmh"
#pragma hdrstop

#define ENCRYPT_TEXT_LENGTH 20

VOID
GetEncryptionKey (
    OUT CHAR EncryptionKey[MSV1_0_CHALLENGE_LENGTH]
    );

VOID SRVFASTCALL
BlockingSessionSetupAndX (
    IN OUT PWORK_CONTEXT WorkContext
    );

NTSTATUS
GetNtSecurityParameters(
    IN PWORK_CONTEXT WorkContext,
    OUT PCHAR *CasesensitivePassword,
    OUT PULONG CasesensitivePasswordLength,
    OUT PCHAR *CaseInsensitivePassword,
    OUT PULONG CaseInsensitivePasswordLength,
    OUT PUNICODE_STRING UserName,
    OUT PUNICODE_STRING DomainName,
    OUT PCHAR *RestOfDataBuffer,
    OUT PULONG RestOfDataLength );

VOID
BuildSessionSetupAndXResponse(
    IN PWORK_CONTEXT WorkContext,
    IN UCHAR NextCommand,
    IN USHORT Action,
    IN BOOLEAN IsUnicode);

NTSTATUS
GetExtendedSecurityParameters(
    IN PWORK_CONTEXT WorkContext,
    OUT PUCHAR *SecurityBuffer,
    OUT PULONG SecurityBufferLength,
    OUT PCHAR  *RestOfDataBuffer,
    OUT PULONG RestOfDataLength );

VOID
BuildExtendedSessionSetupAndXResponse(
    IN PWORK_CONTEXT WorkContext,
    IN ULONG SecurityBlobLength,
    IN NTSTATUS Status,
    IN UCHAR NextCommand,
    IN BOOLEAN IsUnicode);

VOID
InsertNativeOSAndType(
    IN BOOLEAN IsUnicode,
    OUT PCHAR Buffer,
    OUT PUSHORT ByteCount);

//
// EncryptionKeyCount is a monotonically increasing count of the number
// of times GetEncryptionKey has been called.  This number is added to
// the system time to ensure that we do not use the same seed twice in
// generating a random challenge.
//

STATIC
ULONG EncryptionKeyCount = 0;

ULONG SrvKsecValidErrors = 0;

#ifdef ALLOC_PRAGMA
#pragma alloc_text( PAGE, SrvSmbNegotiate )
#pragma alloc_text( PAGE, SrvSmbProcessExit )
#pragma alloc_text( PAGE, SrvSmbSessionSetupAndX )
#pragma alloc_text( PAGE, BlockingSessionSetupAndX )
#pragma alloc_text( PAGE, SrvSmbLogoffAndX )
#pragma alloc_text( PAGE, GetEncryptionKey )
#pragma alloc_text( PAGE, GetNtSecurityParameters )
#pragma alloc_text( PAGE, BuildSessionSetupAndXResponse )
#pragma alloc_text( PAGE, GetExtendedSecurityParameters )
#pragma alloc_text( PAGE, BuildExtendedSessionSetupAndXResponse )
#pragma alloc_text( PAGE, InsertNativeOSAndType )

#endif


SMB_PROCESSOR_RETURN_TYPE
SrvSmbNegotiate (
    SMB_PROCESSOR_PARAMETERS
    )

/*++

Routine Description:

    Processes a negotiate SMB.

Arguments:

    SMB_PROCESSOR_PARAMETERS - See smbprocs.h for a description
        of the parameters to SMB processor routines.

Return Value:

    SMB_PROCESSOR_RETURN_TYPE - See smbprocs.h

--*/

{
    PREQ_NEGOTIATE request;
    PRESP_NT_NEGOTIATE ntResponse;
    PRESP_NEGOTIATE response;
    PRESP_OLD_NEGOTIATE respOldNegotiate;
    PCONNECTION connection;
    PENDPOINT endpoint;
    PPAGED_CONNECTION pagedConnection;
    USHORT byteCount;
    USHORT flags2;
    PSMB_HEADER smbHeader;

    PSZ s, es;
    SMB_DIALECT bestDialect, serverDialect, firstDialect;
    USHORT consumerDialectChosen, consumerDialect;
    LARGE_INTEGER serverTime;
    SMB_DATE date;
    SMB_TIME time;
    ULONG capabilities;
    NTSTATUS   status    = STATUS_SUCCESS;
    SMB_STATUS SmbStatus = SmbStatusInProgress;

    PAGED_CODE( );
    if (WorkContext->PreviousSMB == EVENT_TYPE_SMB_LAST_EVENT)
        WorkContext->PreviousSMB = EVENT_TYPE_SMB_NEGOTIATE;
    SrvWmiStartContext(WorkContext);

    IF_SMB_DEBUG(ADMIN1) {
        SrvPrint2( "Negotiate request header at 0x%p, response header at 0x%p\n",
                    WorkContext->RequestHeader, WorkContext->ResponseHeader );
        SrvPrint2( "Negotiate request parameters at 0x%p, response parameters at 0x%p\n",
                    WorkContext->RequestParameters,
                    WorkContext->ResponseParameters );
    }

    //
    // Set up input and output buffers for parameters.
    //

    request = (PREQ_NEGOTIATE)WorkContext->RequestParameters;
    response = (PRESP_NEGOTIATE)WorkContext->ResponseParameters;
    ntResponse = (PRESP_NT_NEGOTIATE)WorkContext->ResponseParameters;
    smbHeader = WorkContext->RequestHeader;

    //
    // Make sure that this is the first negotiate command sent.
    // SrvStartListen() sets the dialect to illegal, so if it has changed
    // then a negotiate SMB has already been sent.
    //

    connection = WorkContext->Connection;
    pagedConnection = connection->PagedConnection;
    endpoint = connection->Endpoint;
    if ( connection->SmbDialect != SmbDialectIllegal ) {

        IF_DEBUG(SMB_ERRORS) {
            SrvPrint0( "SrvSmbNegotiate: Command already sent.\n" );
        }

        SrvSetSmbError( WorkContext, STATUS_INVALID_SMB );
        status    = STATUS_INVALID_SMB;
        SmbStatus = SmbStatusSendResponse;
        goto Cleanup;
    }

    //
    // We don't know anything about the version number of this client yet.
    //
    pagedConnection->ClientBuildNumber = 0;

#if SRVNTVERCHK
    pagedConnection->ClientTooOld = FALSE;
#endif

    //
    // Find out which (if any) of the sent dialect strings matches the
    // dialect strings known by this server.  The ByteCount is verified
    // to be legitimate in SrvProcessSmb, so it is not possible to walk
    // off the end of the SMB here.
    //

    bestDialect = SmbDialectIllegal;
    consumerDialectChosen = (USHORT)0xFFFF;
    es = END_OF_REQUEST_SMB( WorkContext );

    if( endpoint->IsPrimaryName ) {
        firstDialect = FIRST_DIALECT;
    } else {
        firstDialect = FIRST_DIALECT_EMULATED;
    }

    for ( s = (PSZ)request->Buffer, consumerDialect = 0;
          s <= es && s < SmbGetUshort( &request->ByteCount ) + (PSZ)request->Buffer;
          consumerDialect++ ) {

        if ( *s++ != SMB_FORMAT_DIALECT ) {

            IF_DEBUG(SMB_ERRORS) {
                SrvPrint0( "SrvSmbNegotiate: Invalid dialect format code.\n" );
            }

            SrvLogInvalidSmb( WorkContext );

            SrvSetSmbError( WorkContext, STATUS_INVALID_SMB );
            status    = STATUS_INVALID_SMB;
            SmbStatus = SmbStatusSendResponse;
            goto Cleanup;
        }

        for ( serverDialect = firstDialect;
             serverDialect < bestDialect;
             serverDialect++ ) {

            if ( !strcmp( s, StrDialects[serverDialect] ) ) {
                IF_SMB_DEBUG(ADMIN2) {
                    SrvPrint2( "Matched: %s and %s\n",
                                StrDialects[serverDialect], s );
                }

                bestDialect = serverDialect;
                consumerDialectChosen = consumerDialect;
            }
        }

        //
        // Go to the next dialect string
        //
        for( ; *s && s < es; s++ )
            ;

        //
        // We are now at the end of the buffer, or are pointing to the NULL.
        // Advance the pointer.  If we are at the end of the buffer, the test in
        // the loop will terminate.
        //
        s++;
    }

    connection->SmbDialect = bestDialect;

    if( bestDialect <= SmbDialectNtLanMan ) {
        connection->IpxDropDuplicateCount = MIN_IPXDROPDUP;
    } else {
        connection->IpxDropDuplicateCount = MAX_IPXDROPDUP;
    }

    IF_SMB_DEBUG(ADMIN1) {
        SrvPrint2( "Choosing dialect #%ld, string = %s\n",
                    consumerDialectChosen, StrDialects[bestDialect] );
    }

    //
    //  Determine the current system time on the server.  We use this
    //  to determine the time zone of the server and to tell the client
    //  the current time of day on the server.
    //

    KeQuerySystemTime( &serverTime );

    //
    // If the consumer only knows the core protocol, return short (old)
    // form of the negotiate response.  Also, if no dialect is acceptable,
    // return 0xFFFF as the selected dialect.
    //

    if ( bestDialect == SmbDialectPcNet10 ||
         consumerDialectChosen == (USHORT)0xFFFF ) {

        respOldNegotiate = (PRESP_OLD_NEGOTIATE)response;
        respOldNegotiate->WordCount = 1;
        SmbPutUshort( &respOldNegotiate->DialectIndex, consumerDialectChosen );
        SmbPutUshort( &respOldNegotiate->ByteCount, 0 );
        WorkContext->ResponseParameters = NEXT_LOCATION(
                                            respOldNegotiate,
                                            RESP_OLD_NEGOTIATE,
                                            0
                                            );

    }

    else if ( bestDialect > SmbDialectNtLanMan ) {

        USHORT securityMode;

        //
        // Send the OS/2 LAN Man SMB response.
        //

        WorkContext->ResponseHeader->Flags =
            (UCHAR)(WorkContext->RequestHeader->Flags | SMB_FLAGS_LOCK_AND_READ_OK);

        response->WordCount = 13;
        SmbPutUshort( &response->DialectIndex, consumerDialectChosen );

        //
        // Indicate that we're user-level security and that we
        // want encrypted passwords.
        //

        securityMode = NEGOTIATE_USER_SECURITY | NEGOTIATE_ENCRYPT_PASSWORDS;

        SmbPutUshort(
            &response->SecurityMode,
            securityMode
            );

        //
        // Get an encryption key for this connection.
        //

        GetEncryptionKey( pagedConnection->EncryptionKey );

        SmbPutUshort( &response->EncryptionKeyLength, MSV1_0_CHALLENGE_LENGTH );
        SmbPutUshort( &response->Reserved, 0 );
        byteCount = MSV1_0_CHALLENGE_LENGTH;

        RtlCopyMemory(
            response->Buffer,
            pagedConnection->EncryptionKey,
            MSV1_0_CHALLENGE_LENGTH
            );

        if ( endpoint->IsConnectionless ) {

            ULONG adapterNumber;
            ULONG maxBufferSize;

            //
            // Our server max buffer size is the smaller of the
            // server receive buffer size and the ipx transport
            // indicated max packet size.
            //

            adapterNumber =
                WorkContext->ClientAddress->DatagramOptions.LocalTarget.NicId;

            maxBufferSize = GetIpxMaxBufferSize(
                                        endpoint,
                                        adapterNumber,
                                        SrvReceiveBufferLength
                                        );

            SmbPutUshort(
                &response->MaxBufferSize,
                (USHORT)maxBufferSize
                );

        } else {

            SmbPutUshort(
                &response->MaxBufferSize,
                (USHORT)SrvReceiveBufferLength
                );
        }

        SmbPutUshort( &response->MaxMpxCount, MIN(125, SrvMaxMpxCount) );   // Only send max of 125 to Win9x machines since they'll not connect if higher
        SmbPutUshort( &response->MaxNumberVcs, (USHORT)SrvMaxNumberVcs );
        SmbPutUlong( &response->SessionKey, 0 );

        //
        // If this is an MS-NET 1.03 client or before, then tell him that we
        // don't support raw writes.  MS-NET 1.03 does different things with
        // raw writes that are more trouble than they're worth, and since
        // raw is simply a performance issue, we don't support it.
        //

        if ( bestDialect >= SmbDialectMsNet103 ) {

            SmbPutUshort(
                &response->RawMode,
                (USHORT)(SrvEnableRawMode ?
                        NEGOTIATE_READ_RAW_SUPPORTED :
                        0)
                );

        } else {

            SmbPutUshort(
                &response->RawMode,
                (USHORT)(SrvEnableRawMode ?
                        NEGOTIATE_READ_RAW_SUPPORTED |
                        NEGOTIATE_WRITE_RAW_SUPPORTED :
                        0)
                );
        }

        SmbPutUlong( &response->SessionKey, 0 );

        SrvTimeToDosTime( &serverTime, &date, &time );

        SmbPutDate( &response->ServerDate, date );
        SmbPutTime( &response->ServerTime, time );

        //
        // Get time zone bias.  We compute this during session
        // setup  rather than once during server startup because
        // we might switch from daylight time to standard time
        // or vice versa during normal server operation.
        //

        SmbPutUshort( &response->ServerTimeZone,
                      SrvGetOs2TimeZone(&serverTime) );

        if ( bestDialect == SmbDialectLanMan21 ||
             bestDialect == SmbDialectDosLanMan21 ) {

            //
            // Append the domain to the SMB.
            //

            RtlCopyMemory(
                response->Buffer + byteCount,
                endpoint->OemDomainName.Buffer,
                endpoint->OemDomainName.Length + sizeof(CHAR)
                );

            byteCount += endpoint->OemDomainName.Length + sizeof(CHAR);

        }

        SmbPutUshort( &response->ByteCount, byteCount );
        WorkContext->ResponseParameters = NEXT_LOCATION(
                                              response,
                                              RESP_NEGOTIATE,
                                              byteCount
                                              );

    } else {

        //
        // NT or better protocol has been negotiated.
        //

        flags2 = SmbGetAlignedUshort( &smbHeader->Flags2 );

        //
        // We are going to attempt to validate this user with one of the listed
        // security packages at the end of the smb.  Currently the smb will
        // simply contain the output of EnumerateSecurityPackages.
        //

        if ( flags2 & SMB_FLAGS2_EXTENDED_SECURITY ) {

            if (!WorkContext->UsingExtraSmbBuffer) {
                status = SrvAllocateExtraSmbBuffer(WorkContext);
                if (!NT_SUCCESS(status)) {
                    SrvSetSmbError(WorkContext, status);
                    SmbStatus = SmbStatusSendResponse;
                    goto Cleanup;
                }

                RtlCopyMemory(
                    WorkContext->ResponseHeader,
                    WorkContext->RequestHeader,
                    sizeof( SMB_HEADER )
                    );
            }
            ntResponse = (PRESP_NT_NEGOTIATE)WorkContext->ResponseParameters;
            capabilities = CAP_EXTENDED_SECURITY;
        } else {
            capabilities = 0;
        }
#ifdef INCLUDE_SMB_PERSISTENT
        if ( bestDialect == SmbDialectNtLanMan2 ) {

            capabilities |= CAP_PERSISTENT_HANDLES;

            SrvPrint1( "SrvSmbNegotiate: persistent handles for conn 0x%x.\n",
                        WorkContext->Connection );
        }
#endif
        ntResponse->WordCount = 17;
        SmbPutUshort( &ntResponse->DialectIndex, consumerDialectChosen );

        // !!! This says that we don't want encrypted passwords.

        // If this is negotiating NtLanMan, but not UNICODE, we know its not a Win9x client
        // so it can handle MaxMpx larger than 125
        if( flags2 & SMB_FLAGS2_UNICODE )
        {
            SmbPutUshort( &ntResponse->MaxMpxCount, SrvMaxMpxCount );
        }
        else
        {
            // Again, for the Win9x problems we need to minimize the Mpx count.
            SmbPutUshort( &ntResponse->MaxMpxCount, MIN(125,SrvMaxMpxCount) );
        }
        SmbPutUshort( &ntResponse->MaxNumberVcs, (USHORT)SrvMaxNumberVcs );
        SmbPutUlong( &ntResponse->MaxRawSize, 64 * 1024 ); // !!!
        SmbPutUlong( &ntResponse->SessionKey, 0 );

        capabilities |= CAP_RAW_MODE            |
                       CAP_UNICODE              |
                       CAP_LARGE_FILES          |
                       CAP_NT_SMBS              |
                       CAP_NT_FIND              |
                       CAP_RPC_REMOTE_APIS      |
                       CAP_NT_STATUS            |
                       CAP_LEVEL_II_OPLOCKS     |
                       CAP_INFOLEVEL_PASSTHRU   |
                       CAP_LOCK_AND_READ;

        //
        // If we're supporting Dfs operations, let the client know about it.
        //
        if( SrvDfsFastIoDeviceControl ) {
            capabilities |= CAP_DFS;
        }

        if ( endpoint->IsConnectionless ) {

            ULONG adapterNumber;
            ULONG maxBufferSize;

            capabilities |= CAP_MPX_MODE;
            capabilities &= ~CAP_RAW_MODE;

            //
            // Our server max buffer size is the smaller of the
            // server receive buffer size and the ipx transport
            // indicated max packet size.
            //

            adapterNumber =
                WorkContext->ClientAddress->DatagramOptions.LocalTarget.NicId;

            maxBufferSize = GetIpxMaxBufferSize(
                                        endpoint,
                                        adapterNumber,
                                        SrvReceiveBufferLength
                                        );

            SmbPutUlong(
                &ntResponse->MaxBufferSize,
                maxBufferSize
                );

        } else {

            SmbPutUlong(
                &ntResponse->MaxBufferSize,
                SrvReceiveBufferLength
                );

            capabilities |= CAP_LARGE_READX;

            //
            // Unfortunately, NetBT is the only protocol that reliably supports
            //  transfers exceeding the negotiated buffer size.  So disable the
            //  other protocols for now (hopefully)
            //
            if( connection->ClientIPAddress ) {
                capabilities |= CAP_LARGE_WRITEX;

                if( SrvSupportsCompression ) {
                    capabilities |= CAP_COMPRESSED_DATA;
                }
            }
        }

        SmbPutUlong( &ntResponse->Capabilities, capabilities );

        //
        // Stick the servers system time and timezone in the negotiate
        // response.
        //

        SmbPutUlong( &ntResponse->SystemTimeLow, serverTime.LowPart );
        SmbPutUlong( &ntResponse->SystemTimeHigh, serverTime.HighPart );

        SmbPutUshort( &ntResponse->ServerTimeZone,
                      SrvGetOs2TimeZone(&serverTime) );

        //
        // Indicate that we're user-level security and that we
        // want encrypted passwords.
        //

        ntResponse->SecurityMode =
                NEGOTIATE_USER_SECURITY | NEGOTIATE_ENCRYPT_PASSWORDS;

        //
        // There is a bug in some W9x clients that preclude the use of security
        //  signatures.  We have produced a fix for vredir.vxd for this, but we
        //  can not tell whether or not we are working with one of these fixed
        //  clients.  The only way i can think of to tell the difference between
        //  a W9x client and a properly functioning NT client is to look to see
        //  if the client understands NT status codes.
        //
        if( SrvSmbSecuritySignaturesEnabled &&

            ( SrvEnableW9xSecuritySignatures == TRUE ||
              (flags2 & SMB_FLAGS2_NT_STATUS) ) ) {

            ntResponse->SecurityMode |= NEGOTIATE_SECURITY_SIGNATURES_ENABLED;

            if( SrvSmbSecuritySignaturesRequired ) {
                ntResponse->SecurityMode |= NEGOTIATE_SECURITY_SIGNATURES_REQUIRED;
            }
        }

        //
        // Get an encryption key for this connection.
        //

        if ((capabilities & CAP_EXTENDED_SECURITY) == 0) {
            GetEncryptionKey( pagedConnection->EncryptionKey );

            RtlCopyMemory(
                ntResponse->Buffer,
                pagedConnection->EncryptionKey,
                MSV1_0_CHALLENGE_LENGTH
                );

            ASSERT ( MSV1_0_CHALLENGE_LENGTH <= 0xff ) ;

            ntResponse->EncryptionKeyLength = MSV1_0_CHALLENGE_LENGTH;

            byteCount = MSV1_0_CHALLENGE_LENGTH;

            {
                USHORT domainLength;
                PWCH buffer = (PWCHAR)( ntResponse->Buffer+byteCount );
                PWCH ptr;

                domainLength = endpoint->DomainName.Length +
                                      sizeof(UNICODE_NULL);
                ptr = endpoint->DomainName.Buffer;

                RtlCopyMemory(
                    buffer,
                    ptr,
                    domainLength
                    );

                byteCount += domainLength;

                //
                // Append the server name to the response.
                //
                if( SrvComputerName.Buffer ) {

                    buffer = (PWCHAR)((LPSTR)buffer + domainLength);

                    RtlCopyMemory( buffer,
                                   SrvComputerName.Buffer,
                                   SrvComputerName.Length
                                 );

                    SmbPutUshort( &buffer[ SrvComputerName.Length / 2 ], UNICODE_NULL );

                    byteCount += SrvComputerName.Length + sizeof( UNICODE_NULL );
                }

            }

            SmbPutUshort( &ntResponse->ByteCount, byteCount );

            WorkContext->ResponseParameters = NEXT_LOCATION(
                                                  ntResponse,
                                                  RESP_NT_NEGOTIATE,
                                                  byteCount
                                                  );

        } // if !(capabilities & CAP_EXTENDED_SECURITY)
        else {
            CtxtHandle negotiateHandle;
            USHORT bufferLength;
            PCHAR buffer;

            //
            // Reserved if extended security negotiated (MBZ!)
            //

            ntResponse->EncryptionKeyLength = 0;

            //
            // SrvGetExtensibleSecurityNegotiateBuffer will fill in the
            // securityblob field and return the length of that information.
            //

            RtlCopyMemory(&ntResponse->Buffer, &ServerGuid, sizeof(ServerGuid) );
            byteCount = sizeof(ServerGuid);

            buffer = ntResponse->Buffer + byteCount;

            status = SrvGetExtensibleSecurityNegotiateBuffer(
                                    &negotiateHandle,
                                    buffer,
                                    &bufferLength
                                    );


            if (!NT_SUCCESS(status)) {
                SrvSetSmbError(WorkContext, STATUS_ACCESS_DENIED);
                status    = STATUS_ACCESS_DENIED;
                SmbStatus = SmbStatusSendResponse;
                goto Cleanup;
            }

            //
            // Grab the session locks here...
            //

            ACQUIRE_LOCK( &connection->Lock );

            connection->NegotiateHandle = negotiateHandle;

            RELEASE_LOCK( &connection->Lock );

            byteCount += bufferLength;

            SmbPutUshort( &ntResponse->ByteCount, byteCount );

            WorkContext->ResponseParameters = NEXT_LOCATION(
                                                  ntResponse,
                                                  RESP_NT_NEGOTIATE,
                                                  byteCount
                                                  );
        }
    } // else (NT protocol has been negotiated).

    SmbStatus = SmbStatusSendResponse;

    IF_DEBUG(TRACE2) SrvPrint0( "SrvSmbNegotiate complete.\n" );

Cleanup:
    SrvWmiEndContext(WorkContext);
    return SmbStatus;

} // SrvSmbNegotiate


SMB_PROCESSOR_RETURN_TYPE
SrvSmbProcessExit (
    SMB_PROCESSOR_PARAMETERS
    )

/*++

Routine Description:

    Processes a Process Exit SMB.

Arguments:

    SMB_PROCESSOR_PARAMETERS - See smbprocs.h for a description
        of the parameters to SMB processor routines.

Return Value:

    SMB_PROCESSOR_RETURN_TYPE - See smbprocs.h

--*/

{

    PREQ_PROCESS_EXIT request;
    PRESP_PROCESS_EXIT response;

    PSESSION session;
    USHORT pid;
    NTSTATUS status = STATUS_SUCCESS;

    PAGED_CODE( );
    if (WorkContext->PreviousSMB == EVENT_TYPE_SMB_LAST_EVENT)
        WorkContext->PreviousSMB = EVENT_TYPE_SMB_PROCESS_EXIT;
    SrvWmiStartContext(WorkContext);

    IF_SMB_DEBUG(ADMIN1) {
        SrvPrint2( "Process exit request header at 0x%p, response header at 0x%p\n",
                    WorkContext->RequestHeader,
                    WorkContext->ResponseHeader );
        SrvPrint2( "Process exit request parameters at 0x%p, response parameters at 0x%p\n",
                    WorkContext->RequestParameters,
                    WorkContext->ResponseParameters );
    }

    //
    // Set up parameters.
    //

    request = (PREQ_PROCESS_EXIT)(WorkContext->RequestParameters);
    response = (PRESP_PROCESS_EXIT)(WorkContext->ResponseParameters);

    //
    // If a session block has not already been assigned to the current
    // work context, verify the UID.  If verified, the address of the
    // session block corresponding to this user is stored in the
    // WorkContext block and the session block is referenced.
    //

    session = SrvVerifyUid(
                  WorkContext,
                  SmbGetAlignedUshort( &WorkContext->RequestHeader->Uid )
                  );

    if ( session == NULL ) {

        IF_DEBUG(SMB_ERRORS) {
            SrvPrint1( "SrvSmbProcessExit: Invalid UID: 0x%lx\n",
                SmbGetAlignedUshort( &WorkContext->RequestHeader->Uid ) );
        }

        SrvSetSmbError( WorkContext, STATUS_SMB_BAD_UID );
        status = STATUS_SMB_BAD_UID;
        goto Cleanup;
    }

    //
    // Close all files with the same PID as in the header for this request.
    //

    pid = SmbGetAlignedUshort( &WorkContext->RequestHeader->Pid );

    IF_SMB_DEBUG(ADMIN1) SrvPrint1( "Closing files with PID = %lx\n", pid );

    SrvCloseRfcbsOnSessionOrPid( session, &pid );

    //
    // Close all searches with the same PID as in the header for this request.
    //

    IF_SMB_DEBUG(ADMIN1) SrvPrint1( "Closing searches with PID = %lx\n", pid );

    SrvCloseSearches(
            session->Connection,
            (PSEARCH_FILTER_ROUTINE)SrvSearchOnPid,
            (PVOID) pid,
            NULL
            );

    //
    // Close any cached directories for this client
    //
    SrvCloseCachedDirectoryEntries( session->Connection );

    //
    // Build the response SMB.
    //

    response->WordCount = 0;
    SmbPutUshort( &response->ByteCount, 0 );

    WorkContext->ResponseParameters = NEXT_LOCATION(
                                          response,
                                          RESP_PROCESS_EXIT,
                                          0
                                          );

Cleanup:
    SrvWmiEndContext(WorkContext);
    return SmbStatusSendResponse;

} // SrvSmbProcessExit


SMB_PROCESSOR_RETURN_TYPE
SrvSmbSessionSetupAndX(
    SMB_PROCESSOR_PARAMETERS
    )

/*++

Routine Description:

    Processes a session setup and X SMB.

Arguments:

    SMB_PROCESSOR_PARAMETERS - See smbprocs.h for a description
        of the parameters to SMB processor routines.

Return Value:

    SMB_PROCESSOR_RETURN_TYPE - See smbprocs.h

--*/

{
    PAGED_CODE();
    if (WorkContext->PreviousSMB == EVENT_TYPE_SMB_LAST_EVENT)
        WorkContext->PreviousSMB = EVENT_TYPE_SMB_SESSION_SETUP_AND_X;
    SrvWmiStartContext(WorkContext);

    //
    // This SMB must be processed in a blocking thread.
    //

    WorkContext->FspRestartRoutine = BlockingSessionSetupAndX;
    SrvQueueWorkToBlockingThread( WorkContext );
    SrvWmiEndContext(WorkContext);
    return SmbStatusInProgress;

} // SrvSmbSessionSetupAndX


VOID SRVFASTCALL
BlockingSessionSetupAndX(
    IN OUT PWORK_CONTEXT WorkContext
    )

/*++

Routine Description:

    Processes a session setup and X SMB.

Arguments:

    SMB_PROCESSOR_PARAMETERS - See smbprocs.h for a description
        of the parameters to SMB processor routines.

Return Value:

    SMB_PROCESSOR_RETURN_TYPE - See smbprocs.h

--*/

{
    PREQ_SESSION_SETUP_ANDX request;
    PREQ_NT_SESSION_SETUP_ANDX ntRequest;
    PREQ_NT_EXTENDED_SESSION_SETUP_ANDX ntExtendedRequest;
    PRESP_SESSION_SETUP_ANDX response;

    NTSTATUS SecStatus ;
    NTSTATUS status = STATUS_SUCCESS;
    SMB_STATUS SmbStatus = SmbStatusInProgress;
    PSESSION session;
    PCONNECTION connection;
    PENDPOINT endpoint;
    PPAGED_CONNECTION pagedConnection;
    PTABLE_ENTRY entry;
    LUID logonId;
    SHORT uidIndex;
    USHORT reqAndXOffset;
    UCHAR nextCommand;
    PCHAR smbInformation;
    ULONG smbInformationLength;
    ULONG returnBufferLength = 0;
#ifdef INCLUDE_SMB_PERSISTENT
    ULONG persistentSessionId = 0;
#endif
    UNICODE_STRING nameString;
    UNICODE_STRING domainString;
    USHORT action = 0;
    USHORT byteCount;
    BOOLEAN locksHeld;
    BOOLEAN isUnicode, isExtendedSecurity;
    BOOLEAN smbSecuritySignatureRequired = FALSE;
    BOOLEAN previousSecuritySignatureState;

    PAGED_CODE();
    if (WorkContext->PreviousSMB == EVENT_TYPE_SMB_LAST_EVENT)
        WorkContext->PreviousSMB = EVENT_TYPE_SMB_SESSION_SETUP_AND_X;
    SrvWmiStartContext(WorkContext);

    //
    // If the connection has closed (timed out), abort.
    //

    connection = WorkContext->Connection;

    if ( GET_BLOCK_STATE(connection) != BlockStateActive ) {

        IF_DEBUG(ERRORS) {
            SrvPrint0( "SrvSmbSessionSetupAndX: Connection closing\n" );
        }

        SrvEndSmbProcessing( WorkContext, SmbStatusNoResponse );
        SmbStatus = SmbStatusNoResponse;
        goto Cleanup;

    }

    IF_SMB_DEBUG(ADMIN1) {
        SrvPrint2( "Session setup request header at 0x%p, response header at 0x%p\n",
                    WorkContext->RequestHeader, WorkContext->ResponseHeader );
        SrvPrint2( "Session setup request parameters at 0x%p, response parameters at 0x%p\n",
                    WorkContext->RequestParameters,
                    WorkContext->ResponseParameters );
    }

    //
    // Initialize local variables for error cleanup.
    //

    nameString.Buffer = NULL;
    domainString.Buffer = NULL;
    session = NULL;
    locksHeld = FALSE;
    isExtendedSecurity = FALSE;

    //
    // Set up parameters.
    //

    request = (PREQ_SESSION_SETUP_ANDX)(WorkContext->RequestParameters);
    ntRequest = (PREQ_NT_SESSION_SETUP_ANDX)(WorkContext->RequestParameters);
    ntExtendedRequest = (PREQ_NT_EXTENDED_SESSION_SETUP_ANDX)(WorkContext->RequestParameters);
    response = (PRESP_SESSION_SETUP_ANDX)(WorkContext->ResponseParameters);

    connection = WorkContext->Connection;
    pagedConnection = connection->PagedConnection;

    previousSecuritySignatureState = connection->SmbSecuritySignatureActive;

    //
    // First verify that the SMB format is correct.
    //

    if ( (connection->SmbDialect <= SmbDialectNtLanMan &&
         (!((request->WordCount == 13) ||
            ((request->WordCount == 12) &&
             ((ntExtendedRequest->Capabilities & CAP_EXTENDED_SECURITY) != 0))))) ||
         (connection->SmbDialect > SmbDialectNtLanMan &&
                                          request->WordCount != 10 )   ||
         (connection->SmbDialect == SmbDialectIllegal ) ) {

        //
        // The SMB word count is invalid.
        //

        IF_DEBUG(SMB_ERRORS) {

            if ( connection->SmbDialect == SmbDialectIllegal ) {

                SrvPrint1("BlockingSessionSetupAndX: Client %z is using an "
                "illegal dialect.\n", (PCSTRING)&connection->OemClientMachineNameString );
            }
        }
        status = STATUS_INVALID_SMB;
        goto error_exit1;
    }

    //
    // Convert the client name to unicode
    //

    if ( pagedConnection->ClientMachineNameString.Length == 0 ) {

        UNICODE_STRING clientMachineName;
        clientMachineName.Buffer = pagedConnection->ClientMachineName;
        clientMachineName.MaximumLength =
                        (USHORT)(COMPUTER_NAME_LENGTH+1)*sizeof(WCHAR);

        (VOID)RtlOemStringToUnicodeString(
                        &clientMachineName,
                        &connection->OemClientMachineNameString,
                        FALSE
                        );

        //
        // Add the double backslashes to the length
        //

        pagedConnection->ClientMachineNameString.Length =
                        (USHORT)(clientMachineName.Length + 2*sizeof(WCHAR));

    }

    //
    // If this is LanMan 2.1 or better, the session setup response may
    // be longer than the request.  Allocate an extra SMB buffer.  The
    // buffer is freed after we have finished sending the SMB response.
    //
    // !!! Try to be smarter before grabbing the extra buffer.
    //

    if ( connection->SmbDialect <= SmbDialectDosLanMan21 &&
                                    !WorkContext->UsingExtraSmbBuffer) {

        status = SrvAllocateExtraSmbBuffer( WorkContext );
        if ( !NT_SUCCESS(status) ) {
            goto error_exit;
        }

        response = (PRESP_SESSION_SETUP_ANDX)(WorkContext->ResponseParameters);

        RtlCopyMemory(
            WorkContext->ResponseHeader,
            WorkContext->RequestHeader,
            sizeof( SMB_HEADER )
            );
    }

    //
    // Get the client capabilities
    //

    if ( connection->SmbDialect <= SmbDialectNtLanMan ) {

        if (ntRequest->WordCount == 13) {

            connection->ClientCapabilities =
                SmbGetUlong( &ntRequest->Capabilities ) &
                                        ( CAP_UNICODE |
                                          CAP_LARGE_FILES |
                                          CAP_NT_SMBS |
                                          CAP_NT_FIND |
                                          CAP_NT_STATUS |
                                          CAP_DYNAMIC_REAUTH |
                                          CAP_EXTENDED_SECURITY |
#ifdef INCLUDE_SMB_PERSISTENT
                                          CAP_PERSISTENT_HANDLES |
#endif
                                          CAP_LEVEL_II_OPLOCKS );

        } else {

            connection->ClientCapabilities =
                SmbGetUlong( &ntExtendedRequest->Capabilities ) &
                                        ( CAP_UNICODE |
                                          CAP_LARGE_FILES |
                                          CAP_NT_SMBS |
                                          CAP_NT_FIND |
                                          CAP_NT_STATUS |
                                          CAP_DYNAMIC_REAUTH |
                                          CAP_EXTENDED_SECURITY |
#ifdef INCLUDE_SMB_PERSISTENT
                                          CAP_PERSISTENT_HANDLES |
#endif
                                          CAP_LEVEL_II_OPLOCKS );

        }

        if ( connection->ClientCapabilities & CAP_NT_SMBS ) {
            connection->ClientCapabilities |= CAP_NT_FIND;
        }

#ifdef INCLUDE_SMB_PERSISTENT
        if ( connection->SmbDialect <= SmbDialectNtLanMan2 ) {

            //
            //  do we need to restore a previous lost connection?
            //

            if (connection->ClientCapabilities & CAP_PERSISTENT_HANDLES) {

                while ( persistentSessionId == 0 ) {
                    persistentSessionId = InterlockedIncrement( &SrvGlobalPersistentSessionId );
                }
            }
        } else {

            connection->ClientCapabilities &= ~CAP_PERSISTENT_HANDLES;
        }
#endif
    }

    //
    // See if the client is requesting the use of SMB security signatures
    //
    if( SrvSmbSecuritySignaturesEnabled == TRUE &&
        connection->Endpoint->IsConnectionless == FALSE &&
        connection->SmbSecuritySignatureActive == FALSE &&
        ( SrvSmbSecuritySignaturesRequired == TRUE ||
        (WorkContext->RequestHeader->Flags2 & SMB_FLAGS2_SMB_SECURITY_SIGNATURE)) ) {

        smbSecuritySignatureRequired = TRUE;

    } else {

        smbSecuritySignatureRequired = FALSE;

    }

    //
    // Figure out what kind of security to use, use it to validate the
    // session setup request, and construct the session if request checks out.
    //

    isExtendedSecurity = CLIENT_CAPABLE_OF( EXTENDED_SECURITY, connection );

    if( isExtendedSecurity ) {
        USHORT flags2;

        flags2 = SmbGetAlignedUshort( &WorkContext->RequestHeader->Flags2 );
        isExtendedSecurity = ((flags2 & SMB_FLAGS2_EXTENDED_SECURITY) != 0);
    }

    isUnicode = SMB_IS_UNICODE( WorkContext );

    if ((connection->SmbDialect <= SmbDialectNtLanMan) && isExtendedSecurity) {
        //
        // We are validating a client using extended security.  This meansthat
        //  there may be multiple round-trips necessary for the SessionSetup&X
        //  SMB.  Each request and response carries a "security blob", which is
        //  fed into the security system.  The security system may generate
        //  a new blob which is transmitted to the other end.  This exchange
        //  may require an arbitrary number of round trips.
        //

        PUCHAR securityBuffer;
        ULONG securityBufferLength;

        PRESP_NT_EXTENDED_SESSION_SETUP_ANDX ntExtendedResponse =
                (PRESP_NT_EXTENDED_SESSION_SETUP_ANDX)( WorkContext->ResponseParameters );

        //
        // No AndX is permitted with extended security logons
        //
        if( request->AndXCommand != SMB_COM_NO_ANDX_COMMAND ) {

            IF_DEBUG(SMB_ERRORS) {
                KdPrint(( "No follow-on command allowed for extended SS&X\n" ));
            }

            status = STATUS_INVALID_SMB;

        } else {

            //
            // Clean up old dead connections from this client
            //
            if( SmbGetUshort( &ntRequest->VcNumber ) == 0 ) {
                SrvCloseConnectionsFromClient( connection, FALSE );
            }

            status = GetExtendedSecurityParameters(
                        WorkContext,
                        &securityBuffer,
                        &securityBufferLength,
                        &smbInformation,
                        &smbInformationLength );
        }

        if (NT_SUCCESS(status)) {

            USHORT Uid = SmbGetAlignedUshort(&WorkContext->RequestHeader->Uid);

            //
            // Let's see if we have a session with this UID already around.
            //
            if( Uid ) {

                session = SrvVerifyUid ( WorkContext, Uid );

                if( session != NULL ) {
                    //
                    // This is an attempt to either refresh the UID, or we are
                    // in the middle of an extended security negotiation.
                    //

                    ACQUIRE_LOCK( &connection->Lock );

                    if( session->LogonSequenceInProgress == FALSE ) {
                        //
                        // We are just beginning to start the refresh
                        // of the UID.
                        //
                        session->LogonSequenceInProgress = TRUE;
                        session->IsAdmin = FALSE;
                        session->IsSessionExpired = TRUE;
                        status = SrvFreeSecurityContexts( session );

                        //
                        // Reduce the session count, as it will be incremented if authentication succeeds
                        //
                        ExInterlockedAddUlong(
                              &SrvStatistics.CurrentNumberOfSessions,
                              -1,
                              &GLOBAL_SPIN_LOCK(Statistics)
                              );
                    }

                    RELEASE_LOCK( &connection->Lock );

                } else {
                    //
                    // We don't know anything about the UID which
                    //  the client gave to us.
                    //
                    status = STATUS_SMB_BAD_UID;
                }

            } else {
                //
                // This is the first SS&X for this user id
                //
                SrvAllocateSession( &session, NULL, NULL );
                if( session == NULL ) {
                    status = STATUS_INSUFF_SERVER_RESOURCES;
                }
            }

            if( session != NULL ) {
                //
                // Validate the security buffer sent from the client.  Note that
                //  this may change the UserHandle value, so we need to own
                //  the connection lock.
                //
                ACQUIRE_LOCK( &connection->Lock );

                //
                // Try to authenticate this user.  If we get NT_SUCCESS(), then
                //  the user is fully authenticated. If we get
                //  STATUS_NOT_MORE_PROCESSING_REQUIRED, then things are going well,
                //  but we need to do some more exchanges with the client before
                //  authentication is complete. Anything else is an error
                //

                returnBufferLength = WorkContext->ResponseBuffer->BufferLength -
                                     PTR_DIFF(ntExtendedResponse->Buffer,
                                              WorkContext->ResponseBuffer->Buffer);

                status = SrvValidateSecurityBuffer(
                            WorkContext->Connection,
                            &session->UserHandle,
                            session,
                            securityBuffer,
                            securityBufferLength,
                            smbSecuritySignatureRequired,
                            ntExtendedResponse->Buffer,
                            &returnBufferLength,
                            &session->LogOffTime,
                            session->NtUserSessionKey,
                            &session->LogonId,
                            &session->GuestLogon
                            );

                SecStatus = KSecValidateBuffer(
                                ntExtendedResponse->Buffer,
                                returnBufferLength );

                if ( !NT_SUCCESS( SecStatus ) ) {
#if DBG
                    KdPrint(( "SRV: invalid buffer from KsecDD: %p,%lx\n",
                        ntExtendedResponse->Buffer, returnBufferLength ));
#endif
                    SrvKsecValidErrors++;
                }

                RELEASE_LOCK( &connection->Lock );

                if( NT_SUCCESS(status) ) {
                    //
                    // This client is now fully authenticated!
                    //
                    session->IsAdmin = SrvIsAdmin( session->UserHandle );
                    session->IsNullSession = SrvIsNullSession( session->UserHandle );
                    session->KickOffTime.QuadPart = 0x7FFFFFFFFFFFFFFF;
                    session->EncryptedLogon = TRUE;
                    session->LogonSequenceInProgress = FALSE;
                    session->IsSessionExpired = FALSE;

                    if( session->IsNullSession ) {
                        session->LogOffTime.QuadPart = 0x7FFFFFFFFFFFFFFF;
                    }

#ifdef INCLUDE_SMB_PERSISTENT
                    session->PersistentId = persistentSessionId;
                    session->PersistentFileOffset = 0;
                    session->PersistentState = PersistentStateFreed;
#endif

#if SRVNTVERCHK
                    //
                    // If we are restricting the domains of our clients, grab the
                    //  domain string of this client and compare against the list.
                    //  If the client is in the list, set the flag that disallows
                    //  access to disk shares.
                    //
                    if( SrvInvalidDomainNames != NULL ) {
                        if( domainString.Buffer == NULL ) {
                            SrvGetUserAndDomainName( session, NULL, &domainString );
                        }

                        ACQUIRE_LOCK_SHARED( &SrvConfigurationLock );
                        if( SrvInvalidDomainNames != NULL && domainString.Buffer != NULL ) {
                            int i;
                            for( i = 0; SrvInvalidDomainNames[i]; i++ ) {
                                if( _wcsicmp( SrvInvalidDomainNames[i],
                                              domainString.Buffer
                                            ) == 0 ) {

                                    session->ClientBadDomain = TRUE;
                                    break;
                                }
                            }
                        }
                        RELEASE_LOCK( &SrvConfigurationLock );
                    }
#endif
                } else {
                    if( status == STATUS_MORE_PROCESSING_REQUIRED ) {
                        session->LogonSequenceInProgress = TRUE;
                    }
                }
            }
        }

    } else {

        PCHAR caseInsensitivePassword;
        CLONG caseInsensitivePasswordLength;
        PCHAR caseSensitivePassword;
        CLONG caseSensitivePasswordLength;

        status = GetNtSecurityParameters(
                    WorkContext,
                    &caseSensitivePassword,
                    &caseSensitivePasswordLength,
                    &caseInsensitivePassword,
                    &caseInsensitivePasswordLength,
                    &nameString,
                    &domainString,
                    &smbInformation,
                    &smbInformationLength );

        if (NT_SUCCESS(status)) {

            SrvAllocateSession( &session, &nameString, &domainString );

            if( session != NULL ) {

                status = SrvValidateUser(
                                    &session->UserHandle,
                                    session,
                                    WorkContext->Connection,
                                    &nameString,
                                    caseInsensitivePassword,
                                    caseInsensitivePasswordLength,
                                    caseSensitivePassword,
                                    caseSensitivePasswordLength,
                                    smbSecuritySignatureRequired,
                                    &action
                                    );
            } else {
                status = STATUS_INSUFF_SERVER_RESOURCES;
            }
        }
    }

    //
    // Done with the name strings - they were captured into the session
    // structure if needed.
    //

    if (!isUnicode || isExtendedSecurity) {

        if (nameString.Buffer != NULL) {
            RtlFreeUnicodeString( &nameString );
            nameString.Buffer = NULL;
        }

        if (domainString.Buffer != NULL) {
            RtlFreeUnicodeString( &domainString );
            domainString.Buffer = NULL;
        }
    }

    //
    // If a bad name/password combination was sent, return an error.
    //
    if ( !NT_SUCCESS(status) && status != STATUS_MORE_PROCESSING_REQUIRED ) {

        IF_DEBUG(ERRORS) {
            SrvPrint0( "BlockingSessionSetupAndX: Bad user/password combination.\n" );
        }

        SrvStatistics.LogonErrors++;

        goto error_exit;

    }

    if( previousSecuritySignatureState == FALSE &&
        connection->SmbSecuritySignatureActive == TRUE ) {

        //
        // We have 'turned on' SMB security signatures.  Make sure that the
        //  signature for the Session Setup & X is correct
        //

        //
        // The client's index was 0
        //
        WorkContext->SmbSecuritySignatureIndex = 0;

        //
        // Our response index is 1
        //
        WorkContext->ResponseSmbSecuritySignatureIndex = 1;

        //
        // And the next request should be index 2
        //
        connection->SmbSecuritySignatureIndex = 2;
    }

    //
    // If we have a new session, fill in the remaining required information.  We
    //  may be operating on an already existing session if we are in the middle
    //  of a multi-round-trip extended security blob exchange, or if we are
    //  renewing a session.
    //
    if ( WorkContext->Session == NULL ) {

         if( connection->SmbDialect <= SmbDialectDosLanMan21 ) {

            ACQUIRE_LOCK( &connection->Lock );

            if ( connection->ClientOSType.Buffer == NULL ) {

                ULONG length;
                PWCH infoBuffer;

                //
                // If the SMB buffer is ANSI, adjust the size of the buffer we
                // are allocating to Unicode size.
                //

                if ( isUnicode ) {
                    smbInformation = ALIGN_SMB_WSTR(smbInformation);
                }

                length = isUnicode ? smbInformationLength : smbInformationLength * sizeof( WCHAR );
                infoBuffer = ALLOCATE_NONPAGED_POOL(
                                length,
                                BlockTypeDataBuffer );

                if ( infoBuffer == NULL ) {
                    RELEASE_LOCK( &connection->Lock );
                    status = STATUS_INSUFF_SERVER_RESOURCES;
                    goto error_exit;
                }

                connection->ClientOSType.Buffer = (PWCH)infoBuffer;
                connection->ClientOSType.MaximumLength = (USHORT)length;

                //
                // Copy the client OS type to the new buffer.
                //

                length = SrvGetString(
                             &connection->ClientOSType,
                             smbInformation,
                             END_OF_REQUEST_SMB( WorkContext ),
                             isUnicode
                             );

                if ( length == (USHORT)-1) {
                    connection->ClientOSType.Buffer = NULL;
                    RELEASE_LOCK( &connection->Lock );
                    DEALLOCATE_NONPAGED_POOL( infoBuffer );
                    status =  STATUS_INVALID_SMB;
                    goto error_exit;
                }

                smbInformation += length + sizeof( WCHAR );

                connection->ClientLanManType.Buffer = (PWCH)(
                                (PCHAR)connection->ClientOSType.Buffer +
                                connection->ClientOSType.Length +
                                sizeof( WCHAR ) );

                connection->ClientLanManType.MaximumLength =
                                    connection->ClientOSType.MaximumLength -
                                    connection->ClientOSType.Length -
                                    sizeof( WCHAR );

                //
                // Copy the client LAN Manager type to the new buffer.
                //

                length = SrvGetString(
                             &connection->ClientLanManType,
                             smbInformation,
                             END_OF_REQUEST_SMB( WorkContext ),
                             isUnicode
                             );

                if ( length == (USHORT)-1) {
                    connection->ClientOSType.Buffer = NULL;
                    RELEASE_LOCK( &connection->Lock );
                    DEALLOCATE_NONPAGED_POOL( infoBuffer );
                    status = STATUS_INVALID_SMB;
                    goto error_exit;
                }

                //
                // If we have an NT5 or later client, grab the build number from the
                //   OS version string.
                //
                if( isExtendedSecurity &&
                    connection->ClientOSType.Length &&
                    connection->PagedConnection->ClientBuildNumber == 0 ) {

                    PWCHAR pdigit = connection->ClientOSType.Buffer;
                    PWCHAR epdigit = pdigit + connection->ClientOSType.Length/sizeof(WCHAR);
                    ULONG clientBuildNumber = 0;

                    //
                    // Scan the ClientOSType string to find the last number, and
                    //  convert to a ULONG.  It should be the build number
                    //
                    while( 1 ) {
                        //
                        // Scan the string until we find a number.
                        //
                        for( ; pdigit < epdigit; pdigit++ ) {
                            if( *pdigit >= L'0' && *pdigit <= L'9' ) {
                                break;
                            }
                        }

                        //
                        // If we've hit the end of the string, we are done
                        //
                        if( pdigit == epdigit ) {
                            break;
                        }

                        clientBuildNumber = 0;

                        //
                        // Convert the number to a ULONG, assuming it is the build number
                        //
                        while( pdigit < epdigit && *pdigit >= L'0' && *pdigit <= '9' ) {
                            clientBuildNumber *= 10;
                            clientBuildNumber += (*pdigit++ - L'0');
                        }
                    }

                    connection->PagedConnection->ClientBuildNumber = clientBuildNumber;

#if SRVNTVERCHK
                    if( SrvMinNT5Client > 0 ) {

                        BOOLEAN allowThisClient = FALSE;
                        DWORD i;

                        //
                        // See if we should allow this client, because it is a well-known
                        // IP address.  This is to allow the build lab to more slowly upgrade
                        // than the rest of us.
                        //
                        if( connection->ClientIPAddress != 0 &&
                            connection->Endpoint->IsConnectionless == FALSE ) {

                            for( i = 0; SrvAllowIPAddress[i]; i++ ) {
                                if( SrvAllowIPAddress[i] == connection->ClientIPAddress ) {
                                    allowThisClient = TRUE;
                                    break;
                                }
                            }
                        }

                        if( allowThisClient == FALSE &&
                            connection->PagedConnection->ClientBuildNumber < SrvMinNT5Client ) {
                                connection->PagedConnection->ClientTooOld = TRUE;
                        }
                    }
#endif
                }
            }
            RELEASE_LOCK( &connection->Lock );
        }

        //
        // If using uppercase pathnames, indicate in the session block.  DOS
        // always uses uppercase paths.
        //

        if ( (WorkContext->RequestHeader->Flags &
                  SMB_FLAGS_CANONICALIZED_PATHS) != 0 ||
                                IS_DOS_DIALECT( connection->SmbDialect ) ) {
            session->UsingUppercasePaths = TRUE;
        } else {
            session->UsingUppercasePaths = FALSE;
        }

        //
        // Enter data from request SMB into the session block.  If MaxMpx is 1
        // disable oplocks on this connection.
        //

        endpoint = connection->Endpoint;
        if ( endpoint->IsConnectionless ) {

            ULONG adapterNumber;

            //
            // Our session max buffer size is the smaller of the
            // client buffer size and the ipx transport
            // indicated max packet size.
            //

            adapterNumber =
                WorkContext->ClientAddress->DatagramOptions.LocalTarget.NicId;

            session->MaxBufferSize =
                    (USHORT)GetIpxMaxBufferSize(
                                        endpoint,
                                        adapterNumber,
                                        (ULONG)SmbGetUshort(&request->MaxBufferSize)
                                        );

        } else {

            session->MaxBufferSize = SmbGetUshort( &request->MaxBufferSize );
        }

        //
        // Make sure the MaxBufferSize is correctly sized
        //
        session->MaxBufferSize &= ~03;

        if( session->MaxBufferSize < SrvMinClientBufferSize ) {
            //
            // Client asked for a buffer size that is too small!
            //
            IF_DEBUG(ERRORS) {
                KdPrint(( "BlockingSessionSetupAndX: Bad Client Buffer Size: %u\n",
                    session->MaxBufferSize ));
            }
            status = STATUS_INVALID_SMB;
            goto error_exit;
        }

        session->MaxMpxCount = SmbGetUshort( &request->MaxMpxCount );

        if ( session->MaxMpxCount < 2 ) {
            connection->OplocksAlwaysDisabled = TRUE;
        }
    }

    //
    // If we have completely authenticated the client, and the client thinks
    // that it is the first user on this connection, get rid of other
    // connections (may be due to rebooting of client).  Also get rid of other
    // sessions on this connection with the same user name--this handles a
    // DOS "weirdness" where it sends multiple session setups if a tree connect
    // fails.
    //
    // *** If VcNumber is non-zero, we do nothing special.  This is the
    //     case even though the SrvMaxVcNumber configurable variable
    //     should always be equal to one.  If a second VC is established
    //     between machines, a new session must also be established.
    //     This duplicates the LM 2.0 server's behavior.
    //

    if( isExtendedSecurity == FALSE &&
        NT_SUCCESS( status ) &&
        SmbGetUshort( &request->VcNumber ) == 0 ) {

        UNICODE_STRING userName;

        SrvCloseConnectionsFromClient( connection, FALSE );

        //
        // If a client is smart enough to use extended security, then it
        //  is presumably smart enough to know what it wants to do with
        //  its sessions.  So don't just blow off sessions from this client.
        //
        SrvGetUserAndDomainName( session, &userName, NULL );

        if( userName.Buffer ) {
            SrvCloseSessionsOnConnection( connection, &userName );
            SrvReleaseUserAndDomainName( session, &userName, NULL );
        }
    }

    if( WorkContext->Session == NULL ) {

        //
        // Making a new session visible is a multiple-step operation.  It
        // must be inserted in the global ordered tree connect list and the
        // containing connection's session table, and the connection must be
        // referenced.  We need to make these operations appear atomic, so
        // that the session cannot be accessed elsewhere before we're done
        // setting it up.  In order to do this, we hold all necessary locks
        // the entire time we're doing the operations.  The first operation
        // is protected by the global ordered list lock
        // (SrvOrderedListLock), while the other operations are protected by
        // the per-connection lock.  We take out the ordered list lock
        // first, then the connection lock.  This ordering is required by
        // lock levels (see lock.h).
        //

        ASSERT( SrvSessionList.Lock == &SrvOrderedListLock );
        ACQUIRE_LOCK( SrvSessionList.Lock );

        ACQUIRE_LOCK( &connection->Lock );

        locksHeld = TRUE;

        //
        // Ready to try to find a UID for the session.  Check to see if the
        // connection is being closed, and if so, terminate this operation.
        //

        if ( GET_BLOCK_STATE(connection) != BlockStateActive ) {

            IF_DEBUG(ERRORS) {
                SrvPrint0( "BlockingSessionSetupAndX: Connection closing\n" );
            }

            status = STATUS_INVALID_PARAMETER;
            goto error_exit;

        }

        //
        // If this client speaks a dialect above LM 1.0, find a UID that can
        // be used for this session.  Otherwise, just use location 0 of the
        // table because those clients will not send a UID in SMBs and they
        // can have only one session.
        //

        if ( connection->SmbDialect < SmbDialectLanMan10 ) {
            NTSTATUS TableStatus;

            if ( pagedConnection->SessionTable.FirstFreeEntry == -1
                 &&
                 SrvGrowTable(
                     &pagedConnection->SessionTable,
                     SrvInitialSessionTableSize,
                     SrvMaxSessionTableSize,
                     &TableStatus ) == FALSE
               ) {

                //
                // No free entries in the user table.  Reject the request.
                //

                IF_DEBUG(ERRORS) {
                    SrvPrint0( "BlockingSessionSetupAndX: No more UIDs available.\n" );
                }

                if( TableStatus == STATUS_INSUFF_SERVER_RESOURCES )
                {
                    // The table size is being exceeded, log an error
                    SrvLogTableFullError( SRV_TABLE_SESSION );
                    status = STATUS_SMB_TOO_MANY_UIDS;
                }
                else
                {
                    // Memory allocation error, report it
                    status = TableStatus;
                }

                goto error_exit;

            }

            uidIndex = pagedConnection->SessionTable.FirstFreeEntry;

        } else {          // if ( dialect < SmbDialectLanMan10 )

            //
            // If this client already has a session at this server, abort.
            // The session should have been closed by the call to
            // SrvCloseSessionsOnConnection above.  (We could try to work
            // around the existence of the session by closing it, but that
            // would involve releasing the locks, closing the session, and
            // retrying.  This case shouldn't happen.)
            //

            if ( pagedConnection->SessionTable.Table[0].Owner != NULL ) {

                IF_DEBUG(ERRORS) {
                    SrvPrint0( "BlockingSessionSetupAndX: Core client already has session.\n" );
                }

                status = STATUS_SMB_TOO_MANY_UIDS;
                goto error_exit;
            }

            //
            // Use location 0 of the session table.
            //

            IF_SMB_DEBUG(ADMIN2) {
                SrvPrint0( "Client LM 1.0 or before--using location 0 of session table.\n" );
            }

            uidIndex = 0;

        }

        //
        // Remove the UID slot from the free list and set its owner and
        // sequence number.  Create a UID for the session.  Increment count
        // of sessions.
        //

        entry = &pagedConnection->SessionTable.Table[uidIndex];

        pagedConnection->SessionTable.FirstFreeEntry = entry->NextFreeEntry;
        DEBUG entry->NextFreeEntry = -2;
        if ( pagedConnection->SessionTable.LastFreeEntry == uidIndex ) {
            pagedConnection->SessionTable.LastFreeEntry = -1;
        }

        INCREMENT_UID_SEQUENCE( entry->SequenceNumber );
        if ( uidIndex == 0 && entry->SequenceNumber == 0 ) {
            INCREMENT_UID_SEQUENCE( entry->SequenceNumber );
        }
        session->Uid = MAKE_UID( uidIndex, entry->SequenceNumber );

        entry->Owner = session;

        pagedConnection->CurrentNumberOfSessions++;

        IF_SMB_DEBUG(ADMIN1) {
            SrvPrint2( "Found UID.  Index = 0x%lx, sequence = 0x%lx\n",
                        UID_INDEX( session->Uid ),
                        UID_SEQUENCE( session->Uid ) );
        }

        //
        // Insert the session on the global session list.
        //

        SrvInsertEntryOrderedList( &SrvSessionList, session );

        //
        // Reference the connection block to account for the new session.
        //

        SrvReferenceConnection( connection );
        session->Connection = connection;

        RELEASE_LOCK( &connection->Lock );
        RELEASE_LOCK( SrvSessionList.Lock );

        //
        // Session successfully created.  Insert the session in the global
        // list of active sessions.  Remember its address in the work
        // context block.
        //
        // *** Note that the reference count on the session block is
        //     initially set to 2, to allow for the active status on the
        //     block and the pointer that we're maintaining.  In other
        //     words, this is a referenced pointer, and the pointer must be
        //     dereferenced when processing of this SMB is complete.
        //

        WorkContext->Session = session;
    }

    //
    // Build response SMB, making sure to save request fields first in
    // case the response overwrites the request.  Save the
    // newly-assigned UID in both the request SMB and the response SMB
    // so that subsequent command processors and the client,
    // respectively, can see it.
    //

    nextCommand = request->AndXCommand;

    reqAndXOffset = SmbGetUshort( &request->AndXOffset );

    SmbPutAlignedUshort( &WorkContext->RequestHeader->Uid, session->Uid );
    SmbPutAlignedUshort( &WorkContext->ResponseHeader->Uid, session->Uid );

    if (isExtendedSecurity) {

        BuildExtendedSessionSetupAndXResponse(
            WorkContext,
            returnBufferLength,
            status,
            nextCommand,
            isUnicode);

    } else {

        BuildSessionSetupAndXResponse(
            WorkContext,
            nextCommand,
            action,
            isUnicode);

    }

    WorkContext->ResponseParameters = (PCHAR)WorkContext->ResponseHeader +
                                        SmbGetUshort( &response->AndXOffset );

    //
    // Test for legal followon command.
    //

    switch ( nextCommand ) {
    case SMB_COM_NO_ANDX_COMMAND:
        break;

    case SMB_COM_TREE_CONNECT_ANDX:
    case SMB_COM_OPEN:
    case SMB_COM_OPEN_ANDX:
    case SMB_COM_CREATE:
    case SMB_COM_CREATE_NEW:
    case SMB_COM_CREATE_DIRECTORY:
    case SMB_COM_DELETE:
    case SMB_COM_DELETE_DIRECTORY:
    case SMB_COM_FIND:
    case SMB_COM_FIND_UNIQUE:
    case SMB_COM_COPY:
    case SMB_COM_RENAME:
    case SMB_COM_NT_RENAME:
    case SMB_COM_CHECK_DIRECTORY:
    case SMB_COM_QUERY_INFORMATION:
    case SMB_COM_SET_INFORMATION:
    case SMB_COM_QUERY_INFORMATION_SRV:
    case SMB_COM_OPEN_PRINT_FILE:
    case SMB_COM_GET_PRINT_QUEUE:
    case SMB_COM_TRANSACTION:
        //
        // Make sure the AndX command is still within the received SMB
        //
        if( (PCHAR)WorkContext->RequestHeader + reqAndXOffset <=
            END_OF_REQUEST_SMB( WorkContext ) ) {
            break;
        }

        /* Falls Through */

    default:                            // Illegal followon command

        IF_DEBUG(SMB_ERRORS) {
            SrvPrint1( "BlockingSessionSetupAndX: Illegal followon command: "
                        "0x%lx\n", nextCommand );
        }

        status = STATUS_INVALID_SMB;
        goto error_exit1;
    }

    //
    // If there is an AndX command, set up to process it.  Otherwise,
    // indicate completion to the caller.
    //

    if ( nextCommand != SMB_COM_NO_ANDX_COMMAND ) {

        WorkContext->NextCommand = nextCommand;

        WorkContext->RequestParameters = (PCHAR)WorkContext->RequestHeader +
                                            reqAndXOffset;

        SrvProcessSmb( WorkContext );
        SmbStatus = SmbStatusNoResponse;
        goto Cleanup;

    }

    IF_DEBUG(TRACE2) SrvPrint0( "BlockingSessionSetupAndX complete.\n" );
    goto normal_exit;

error_exit:

    if ( locksHeld ) {
        RELEASE_LOCK( &connection->Lock );
        RELEASE_LOCK( SrvSessionList.Lock );
    }

    if ( session != NULL ) {
        if( WorkContext->Session ) {
            //
            // A re-validation of the session failed, or the extended exchange
            //  of security blobs failed.  Get rid of this user.
            //

            SrvCloseSession( session );

            SrvStatistics.SessionsLoggedOff++;

            //
            // Dereference the session, since it's no longer valid
            //
            SrvDereferenceSession( session );

            WorkContext->Session = NULL;

        } else {

            SrvFreeSession( session );
        }
    }

    if ( !isUnicode ) {
        if ( domainString.Buffer != NULL ) {
            RtlFreeUnicodeString( &domainString );
        }
        if ( nameString.Buffer != NULL ) {
            RtlFreeUnicodeString( &nameString );
        }
    }

error_exit1:

    SrvSetSmbError( WorkContext, status );

normal_exit:
    SrvEndSmbProcessing( WorkContext, SmbStatusSendResponse );
    SmbStatus = SmbStatusSendResponse;

Cleanup:
    SrvWmiEndContext(WorkContext);
    return;

} // BlockingSessionSetupAndX


NTSTATUS
GetExtendedSecurityParameters(
    IN PWORK_CONTEXT WorkContext,
    OUT PUCHAR *SecurityBuffer,
    OUT PULONG SecurityBufferLength,
    OUT PCHAR  *RestOfDataBuffer,
    OUT PULONG RestOfDataLength)

/*++

Routine Description:

    Extracts the extensible security parameters from an extended session
    setup and X SMB.

Arguments:

    WorkContext - Context of the SMB

    SecurityBuffer - On return, points to the security buffer inside the
        extended session setup and X SMB

    SecurityBufferLength - On return, size in bytes of SecurityBuffer.

    RestOfDataBuffer - On return, points just past the security buffer

    ResetOfDataLength - On return, size in bytes of *RestOfDataBuffer

Return Value:

    STATUS_SUCCESS - This routine merely returns pointers within an SMB

--*/


{
    NTSTATUS status;
    PCONNECTION connection;
    PREQ_NT_EXTENDED_SESSION_SETUP_ANDX ntExtendedRequest;
    ULONG maxlength;

    connection = WorkContext->Connection;
    ASSERT( connection->SmbDialect <= SmbDialectNtLanMan );

    ntExtendedRequest = (PREQ_NT_EXTENDED_SESSION_SETUP_ANDX)
                            (WorkContext->RequestParameters);

    maxlength = (ULONG)(WorkContext->RequestBuffer->DataLength + sizeof( USHORT ) -
                        ((ULONG_PTR)ntExtendedRequest->Buffer -
                         (ULONG_PTR)WorkContext->RequestBuffer->Buffer));


    //
    // Get the extended security buffer
    //

    *SecurityBuffer = (PUCHAR) ntExtendedRequest->Buffer;
    *SecurityBufferLength = ntExtendedRequest->SecurityBlobLength;

    *RestOfDataBuffer = ntExtendedRequest->Buffer +
                            ntExtendedRequest->SecurityBlobLength;

    *RestOfDataLength = (USHORT)( (PUCHAR)ntExtendedRequest->Buffer +
                                  sizeof(USHORT) +
                                  SmbGetUshort( &ntExtendedRequest->ByteCount) -
                                  (*RestOfDataBuffer)
                                );

    if( *SecurityBufferLength > maxlength ||
        *RestOfDataLength > maxlength - *SecurityBufferLength ) {

        IF_DEBUG(SMB_ERRORS) {
            KdPrint(( "GetExtendedSecurityParameters: Invalid security buffer\n" ));
        }

        return STATUS_INVALID_SMB;
    }

    return( STATUS_SUCCESS );
}


NTSTATUS
GetNtSecurityParameters(
    IN PWORK_CONTEXT WorkContext,
    OUT PCHAR *CaseSensitivePassword,
    OUT PULONG CaseSensitivePasswordLength,
    OUT PCHAR *CaseInsensitivePassword,
    OUT PULONG CaseInsensitivePasswordLength,
    OUT PUNICODE_STRING UserName,
    OUT PUNICODE_STRING DomainName,
    OUT PCHAR *RestOfDataBuffer,
    OUT PULONG RestOfDataLength)
{

    NTSTATUS status = STATUS_SUCCESS;
    PCONNECTION connection;
    PREQ_NT_SESSION_SETUP_ANDX ntRequest;
    PREQ_SESSION_SETUP_ANDX request;
    PSZ userName;
    USHORT nameLength;
    BOOLEAN isUnicode;

    connection = WorkContext->Connection;

    ntRequest = (PREQ_NT_SESSION_SETUP_ANDX)(WorkContext->RequestParameters);
    request = (PREQ_SESSION_SETUP_ANDX)(WorkContext->RequestParameters);

    //
    // Get the account name, and additional information from the SMB buffer.
    //

    if ( connection->SmbDialect <= SmbDialectNtLanMan) {

        //
        // The NT-NT SMB protocol passes both case sensitive (Unicode,
        // mixed case) and case insensitive (ANSI, uppercased) passwords.
        // Get pointers to them to pass to SrvValidateUser.
        //

        *CaseInsensitivePasswordLength =
            (CLONG)SmbGetUshort(&ntRequest->CaseInsensitivePasswordLength);
        *CaseInsensitivePassword = (PCHAR)(ntRequest->Buffer);
        *CaseSensitivePasswordLength =
            (CLONG)SmbGetUshort( &ntRequest->CaseSensitivePasswordLength );
        *CaseSensitivePassword =
           *CaseInsensitivePassword + *CaseInsensitivePasswordLength;
        userName = (PSZ)(*CaseSensitivePassword +
                                            *CaseSensitivePasswordLength);

    } else {

        //
        // Downlevel clients do not pass the case sensitive password;
        // just get the case insensitive password and use NULL as the
        // case sensitive password.  LSA will do the right thing with
        // it.
        //

        *CaseInsensitivePasswordLength =
            (CLONG)SmbGetUshort( &request->PasswordLength );
        *CaseInsensitivePassword = (PCHAR)request->Buffer;
        *CaseSensitivePasswordLength = 0;
        *CaseSensitivePassword = NULL;
        userName = (PSZ)(request->Buffer + *CaseInsensitivePasswordLength);
    }

    if( (*CaseInsensitivePassword) != NULL &&
        (*CaseInsensitivePassword) + (*CaseInsensitivePasswordLength) >
        END_OF_REQUEST_SMB( WorkContext ) ) {

        status = STATUS_INVALID_SMB;
        goto error_exit;
    }

    if( (*CaseSensitivePassword) != NULL &&
        (*CaseSensitivePassword) + (*CaseSensitivePasswordLength) >
        END_OF_REQUEST_SMB( WorkContext ) ) {

        status = STATUS_INVALID_SMB;
        goto error_exit;
    }

    isUnicode = SMB_IS_UNICODE( WorkContext );
    if ( isUnicode ) {
        userName = ALIGN_SMB_WSTR( userName );
    }

    nameLength = SrvGetStringLength(
                     userName,
                     END_OF_REQUEST_SMB( WorkContext ),
                     isUnicode,
                     FALSE      // don't include null terminator
                     );

    if ( nameLength == (USHORT)-1 ) {
        status = STATUS_INVALID_SMB;
        goto error_exit;
    }

    status = SrvMakeUnicodeString(
                 isUnicode,
                 UserName,
                 userName,
                 &nameLength );

    if ( !NT_SUCCESS( status ) ) {
        goto error_exit;
    }

    //
    // If client information strings exists, extract the information
    // from the SMB buffer.
    //

    if ( connection->SmbDialect <= SmbDialectDosLanMan21) {

        PCHAR smbInformation;
        USHORT length;
        PWCH infoBuffer;

        smbInformation = userName + nameLength +
                                    ( isUnicode ? sizeof( WCHAR ) : 1 );

        //
        // Now copy the strings to the allocated buffer.
        //

        if ( isUnicode ) {
            smbInformation = ALIGN_SMB_WSTR( smbInformation );
        }

        length = SrvGetStringLength(
                     smbInformation,
                     END_OF_REQUEST_SMB( WorkContext ),
                     isUnicode,
                     FALSE      // don't include null terminator
                     );

        if ( length == (USHORT)-1) {
            status = STATUS_INVALID_SMB;
            goto error_exit;
        }

        //
        // DOS clients send an empty domain name if they don't know
        // their domain name (e.g., during logon).  OS/2 clients send
        // a name of "?".  This confuses the LSA.  Convert such a name
        // to an empty name.
        //

        if ( isUnicode ) {
            if ( (length == sizeof(WCHAR)) &&
                 (*(PWCH)smbInformation == '?') ) {
                length = 0;
            }
        } else {
            if ( (length == 1) && (*smbInformation == '?') ) {
                length = 0;
            }
        }

        status = SrvMakeUnicodeString(
                     isUnicode,
                     DomainName,
                     smbInformation,
                     &length
                     );

        if ( !NT_SUCCESS( status ) ) {
            goto error_exit;
        }

        smbInformation += length + ( isUnicode ? sizeof(WCHAR) : 1 );

        *RestOfDataBuffer = smbInformation;

        if (connection->SmbDialect <= SmbDialectNtLanMan) {

            *RestOfDataLength = (USHORT) ( (PUCHAR)&ntRequest->ByteCount +
                                            sizeof(USHORT) +
                                            SmbGetUshort(&ntRequest->ByteCount) -
                                            smbInformation
                                         );
        } else {

            PREQ_SESSION_SETUP_ANDX request;

            request = (PREQ_SESSION_SETUP_ANDX)(WorkContext->RequestParameters);

            *RestOfDataLength = (USHORT) ( (PUCHAR)&request->ByteCount +
                                            sizeof(USHORT) +
                                            SmbGetUshort(&request->ByteCount) -
                                            smbInformation
                                         );

        }

    } else {

        DomainName->Length = 0;

        *RestOfDataBuffer = NULL;

        *RestOfDataLength = 0;

    }

error_exit:

    return( status );

}


VOID
BuildExtendedSessionSetupAndXResponse(
    IN PWORK_CONTEXT WorkContext,
    IN ULONG ReturnBufferLength,
    IN NTSTATUS Status,
    IN UCHAR NextCommand,
    IN BOOLEAN IsUnicode)
{
    PRESP_NT_EXTENDED_SESSION_SETUP_ANDX ntExtendedResponse;
    PCHAR buffer;
    USHORT byteCount;

    ntExtendedResponse = (PRESP_NT_EXTENDED_SESSION_SETUP_ANDX)
                            (WorkContext->ResponseParameters);

    ntExtendedResponse->WordCount = 4;
    ntExtendedResponse->AndXCommand = NextCommand;
    ntExtendedResponse->AndXReserved = 0;

    if( WorkContext->Session && WorkContext->Session->GuestLogon ) {
        SmbPutUshort( &ntExtendedResponse->Action, SMB_SETUP_GUEST );
    } else {
        SmbPutUshort( &ntExtendedResponse->Action, 0 );
    }

    SmbPutUshort( &ntExtendedResponse->SecurityBlobLength,(USHORT)ReturnBufferLength );

    buffer = ntExtendedResponse->Buffer + ReturnBufferLength;

    if (IsUnicode)
        buffer = ALIGN_SMB_WSTR( buffer );

    InsertNativeOSAndType( IsUnicode, buffer, &byteCount );

    byteCount += (USHORT)ReturnBufferLength;

    SmbPutUshort( &ntExtendedResponse->ByteCount, byteCount );

    SmbPutUshort( &ntExtendedResponse->AndXOffset, GET_ANDX_OFFSET(
                                             WorkContext->ResponseHeader,
                                             WorkContext->ResponseParameters,
                                             RESP_NT_EXTENDED_SESSION_SETUP_ANDX,
                                             byteCount
                                             ) );

    //
    // Make sure we return the error status here, as the client uses it to
    //  determine if extra round trips are necessary
    //
    SrvSetSmbError2 ( WorkContext, Status, TRUE );
}


VOID
BuildSessionSetupAndXResponse(
    IN PWORK_CONTEXT WorkContext,
    IN UCHAR NextCommand,
    IN USHORT Action,
    IN BOOLEAN IsUnicode)
{

    PRESP_SESSION_SETUP_ANDX response;
    PCONNECTION connection;
    PENDPOINT endpoint;
    PCHAR buffer;
    USHORT byteCount;

    response = (PRESP_SESSION_SETUP_ANDX) (WorkContext->ResponseParameters);

    connection = WorkContext->Connection;

    endpoint = connection->Endpoint;

    response->WordCount = 3;
    response->AndXCommand = NextCommand;
    response->AndXReserved = 0;

    if (connection->SmbDialect <= SmbDialectDosLanMan21) {

        buffer = response->Buffer;

        if (IsUnicode)
            buffer = ALIGN_SMB_WSTR( buffer );

        InsertNativeOSAndType( IsUnicode, buffer, &byteCount );

        buffer = buffer + byteCount;

        if (connection->SmbDialect <= SmbDialectNtLanMan) {

            USHORT stringLength;

            if ( IsUnicode ) {

                buffer = ALIGN_SMB_WSTR( buffer );

                stringLength = endpoint->DomainName.Length + sizeof(UNICODE_NULL);

                RtlCopyMemory(
                    buffer,
                    endpoint->DomainName.Buffer,
                    stringLength
                    );

                byteCount += (USHORT)stringLength;

            } else {

                stringLength = endpoint->OemDomainName.Length + sizeof(CHAR);

                RtlCopyMemory(
                    (PVOID) buffer,
                    endpoint->OemDomainName.Buffer,
                    stringLength
                    );

                byteCount += (USHORT)stringLength;

            }

        }

    } else {

        byteCount = 0;
    }

    SmbPutUshort( &response->ByteCount, byteCount );

    //
    // Normally, turning on bit 0 of Action indicates that the user was
    // logged on as GUEST.  However, NT does not have automatic guest
    // logon--a user ID and password are required for every single logon
    // (though the password may have null length).  Therefore, the
    // server need not concern itself with what kind of account the
    // client gets.
    //
    // Bit 1 tells the client that the user was logged on
    // using the lm session key instead of the user session key.
    //

    SmbPutUshort( &response->Action, Action );

    SmbPutUshort( &response->AndXOffset, GET_ANDX_OFFSET(
                                             WorkContext->ResponseHeader,
                                             WorkContext->ResponseParameters,
                                             RESP_SESSION_SETUP_ANDX,
                                             byteCount
                                             ) );


}


VOID
InsertNativeOSAndType(
    IN BOOLEAN IsUnicode,
    OUT PCHAR Buffer,
    OUT PUSHORT ByteCount)
{
    USHORT stringLength;

    if ( IsUnicode ) {

        stringLength = (USHORT)(SrvNativeOS.Length + sizeof(UNICODE_NULL));

        RtlCopyMemory(
            Buffer,
            SrvNativeOS.Buffer,
            stringLength
            );

        *ByteCount = stringLength;

        stringLength = SrvNativeLanMan.Length + sizeof(UNICODE_NULL);

        RtlCopyMemory(
            (PCHAR)Buffer + *ByteCount,
            SrvNativeLanMan.Buffer,
            stringLength
            );

        *ByteCount += (USHORT)stringLength;

    } else {

        stringLength = SrvOemNativeOS.Length + sizeof(CHAR);

        RtlCopyMemory(
            Buffer,
            SrvOemNativeOS.Buffer,
            stringLength
            );

        *ByteCount = stringLength;

        stringLength = SrvOemNativeLanMan.Length + sizeof(CHAR);

        RtlCopyMemory(
            (PCHAR)Buffer + *ByteCount,
            SrvOemNativeLanMan.Buffer,
            stringLength
            );

        *ByteCount += (USHORT)stringLength;

    }

}



SMB_PROCESSOR_RETURN_TYPE
SrvSmbLogoffAndX (
    SMB_PROCESSOR_PARAMETERS
    )

/*++

Routine Description:

    Processes a Logoff and X SMB.

Arguments:

    SMB_PROCESSOR_PARAMETERS - See smbprocs.h for a description
        of the parameters to SMB processor routines.

Return Value:

    SMB_PROCESSOR_RETURN_TYPE - See smbprocs.h

--*/

{
    PREQ_LOGOFF_ANDX request;
    PRESP_LOGOFF_ANDX response;

    PSESSION session;
    USHORT reqAndXOffset;
    UCHAR nextCommand;

    NTSTATUS   status    = STATUS_SUCCESS;
    SMB_STATUS SmbStatus = SmbStatusInProgress;

    PAGED_CODE( );
    if (WorkContext->PreviousSMB == EVENT_TYPE_SMB_LAST_EVENT)
        WorkContext->PreviousSMB = EVENT_TYPE_SMB_LOGOFF_AND_X;
    SrvWmiStartContext(WorkContext);

    IF_SMB_DEBUG(ADMIN1) {
        SrvPrint2( "Logoff request header at 0x%p, response header at 0x%p\n",
                    WorkContext->RequestHeader, WorkContext->ResponseHeader );
        SrvPrint2( "Logoff request parameters at 0x%p, response parameters at 0x%p\n",
                    WorkContext->RequestParameters,
                    WorkContext->ResponseParameters );
    }

    //
    // Set up parameters.
    //

    request = (PREQ_LOGOFF_ANDX)(WorkContext->RequestParameters);
    response = (PRESP_LOGOFF_ANDX)(WorkContext->ResponseParameters);

    //
    // If a session block has not already been assigned to the current
    // work context, verify the UID.  If verified, the address of the
    // session block corresponding to this user is stored in the
    // WorkContext block and the session block is referenced.
    //

    session = SrvVerifyUid(
                  WorkContext,
                  SmbGetAlignedUshort( &WorkContext->RequestHeader->Uid )
                  );

    if ( session == NULL ) {

        IF_DEBUG(SMB_ERRORS) {
            SrvPrint1( "SrvSmbLogoffAndX: Invalid UID: 0x%lx\n",
                SmbGetAlignedUshort( &WorkContext->RequestHeader->Uid ) );
        }

        SrvSetSmbError( WorkContext, STATUS_SMB_BAD_UID );
        status    = STATUS_SMB_BAD_UID;
        SmbStatus = SmbStatusSendResponse;
        goto Cleanup;
    }

    //
    // If we need to visit the license server, get over to a blocking
    // thread to ensure that we don't consume the nonblocking threads
    //
    if( WorkContext->UsingBlockingThread == 0 &&
        session->IsLSNotified == TRUE ) {
            //
            // Insert the work item at the tail of the blocking work queue
            //
            SrvInsertWorkQueueTail(
                &SrvBlockingWorkQueue,
                (PQUEUEABLE_BLOCK_HEADER)WorkContext
            );

            SmbStatus = SmbStatusInProgress;
            goto Cleanup;
    }

    //
    // Do the actual logoff.
    //

    SrvCloseSession( session );

    SrvStatistics.SessionsLoggedOff++;

    //
    // Dereference the session, since it's no longer valid, but we may
    // end up processing a chained command.  Clear the session pointer
    // in the work context block to indicate that we've done this.
    //

    SrvDereferenceSession( session );

    WorkContext->Session = NULL;

    //
    // Build the response SMB, making sure to save request fields first
    // in case the response overwrites the request.
    //

    reqAndXOffset = SmbGetUshort( &request->AndXOffset );
    nextCommand = request->AndXCommand;

    response->WordCount = 2;
    response->AndXCommand = request->AndXCommand;
    response->AndXReserved = 0;
    SmbPutUshort( &response->AndXOffset, GET_ANDX_OFFSET(
                                            WorkContext->ResponseHeader,
                                            WorkContext->ResponseParameters,
                                            RESP_LOGOFF_ANDX,
                                            0
                                            ) );
    SmbPutUshort( &response->ByteCount, 0 );

    WorkContext->ResponseParameters = (PCHAR)WorkContext->ResponseHeader +
                                        SmbGetUshort( &response->AndXOffset );

    //
    // Test for legal followon command.
    //

    switch ( nextCommand ) {

    case SMB_COM_NO_ANDX_COMMAND:
        break;

    case SMB_COM_SESSION_SETUP_ANDX:
        //
        // Make sure the AndX command is still within the received SMB
        //
        if( (PCHAR)WorkContext->RequestHeader + reqAndXOffset <=
            END_OF_REQUEST_SMB( WorkContext ) ) {
            break;
        }

        /* Falls Through */

    default:

        IF_DEBUG(SMB_ERRORS) {
            SrvPrint1( "SrvSmbLogoffAndX: Illegal followon command: 0x%lx\n",
                        nextCommand );
        }

        SrvSetSmbError( WorkContext, STATUS_INVALID_SMB );
        status    = STATUS_INVALID_SMB;
        SmbStatus = SmbStatusSendResponse;
        goto Cleanup;
    }

    //
    // If there is an AndX command, set up to process it.  Otherwise,
    // indicate completion to the caller.
    //

    if ( nextCommand != SMB_COM_NO_ANDX_COMMAND ) {

        WorkContext->NextCommand = nextCommand;

        WorkContext->RequestParameters = (PCHAR)WorkContext->RequestHeader +
                                            reqAndXOffset;

        SmbStatus = SmbStatusMoreCommands;
        goto Cleanup;
    }
    SmbStatus = SmbStatusSendResponse;
    IF_DEBUG(TRACE2) SrvPrint0( "SrvSmbLogoffAndX complete.\n" );

Cleanup:
    SrvWmiEndContext(WorkContext);
    return SmbStatus;

} // SrvSmbLogoffAndX


STATIC
VOID
GetEncryptionKey (
    OUT CHAR EncryptionKey[MSV1_0_CHALLENGE_LENGTH]
    )

/*++

Routine Description:

    Creates an encryption key to use as a challenge for a logon.

    *** Although the MSV1_0 authentication package has a function that
        returns an encryption key, we do not use that function in order
        to avoid a trip through LPC and into LSA.

Arguments:

    EncryptionKey - a pointer to a buffer which receives the encryption
        key.

Return Value:

    NTSTATUS - result of operation.

--*/

{
    union {
        LARGE_INTEGER time;
        UCHAR bytes[8];
    } u;
    ULONG seed;
    ULONG challenge[2];
    ULONG result3;

    //
    // Create a pseudo-random 8-byte number by munging the system time
    // for use as a random number seed.
    //
    // Start by getting the system time.
    //

    ASSERT( MSV1_0_CHALLENGE_LENGTH == 2 * sizeof(ULONG) );

    KeQuerySystemTime( &u.time );

    //
    // To ensure that we don't use the same system time twice, add in the
    // count of the number of times this routine has been called.  Then
    // increment the counter.
    //
    // *** Since we don't use the low byte of the system time (it doesn't
    //     take on enough different values, because of the timer
    //     resolution), we increment the counter by 0x100.
    //
    // *** We don't interlock the counter because we don't really care
    //     if it's not 100% accurate.
    //

    u.time.LowPart += EncryptionKeyCount;

    EncryptionKeyCount += 0x100;

    //
    // Now use parts of the system time as a seed for the random
    // number generator.
    //
    // *** Because the middle two bytes of the low part of the system
    //     time change most rapidly, we use those in forming the seed.
    //

    seed = ((u.bytes[1] + 1) <<  0) |
           ((u.bytes[2] + 0) <<  8) |
           ((u.bytes[2] - 1) << 16) |
           ((u.bytes[1] + 0) << 24);

    //
    // Now get two random numbers.  RtlRandom does not return negative
    // numbers, so we pseudo-randomly negate them.
    //

    challenge[0] = RtlRandom( &seed );
    challenge[1] = RtlRandom( &seed );
    result3 = RtlRandom( &seed );

    if ( (result3 & 0x1) != 0 ) {
        challenge[0] |= 0x80000000;
    }
    if ( (result3 & 0x2) != 0 ) {
        challenge[1] |= 0x80000000;
    }

    //
    // Return the challenge.
    //

    RtlCopyMemory( EncryptionKey, challenge, MSV1_0_CHALLENGE_LENGTH );

} // GetEncryptionKey
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\srv\share.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    share.c

Abstract:

    This module contains routines for adding, deleting, and enumerating
    shared resources.

Author:

    David Treadwell (davidtr) 15-Nov-1989

Revision History:

--*/

#include "precomp.h"
#include "share.tmh"
#pragma hdrstop

#ifdef ALLOC_PRAGMA
#pragma alloc_text( PAGE, SrvVerifyShare )
#pragma alloc_text( PAGE, SrvFindShare )
#pragma alloc_text( PAGE, SrvRemoveShare )
#pragma alloc_text( PAGE, SrvAddShare )
#pragma alloc_text( PAGE, SrvShareEnumApiHandler )
#endif


PSHARE
SrvVerifyShare (
    IN PWORK_CONTEXT WorkContext,
    IN PSZ ShareName,
    IN PSZ ShareTypeString,
    IN BOOLEAN ShareNameIsUnicode,
    IN BOOLEAN IsNullSession,
    OUT PNTSTATUS Status,
    OUT PUNICODE_STRING ServerName OPTIONAL
    )

/*++

Routine Description:

    Attempts to find a share that matches a given name and share type.

Arguments:

    ShareName - name of share to verify, including the server name.
        (I.e., of the form "\\server\share", as received in the SMB.)

    ShareTypeString - type of the share (A:, LPT1:, COMM, IPC, or ?????).

    ShareNameIsUnicode - if TRUE, the share name is Unicode.

    IsNullSession - Is this the NULL session?

    Status - Reason why this call failed.  Not used if a share is returned.

    ServerName - The servername part of the requested resource.

Return Value:

    A pointer to a share matching the given name and share type, or NULL
    if none exists.

--*/

{
    PSHARE share;
    BOOLEAN anyShareType = FALSE;
    SHARE_TYPE shareType;
    PWCH nameOnly;
    UNICODE_STRING nameOnlyString;
    UNICODE_STRING shareName;

    PAGED_CODE( );

    if( ARGUMENT_PRESENT( ServerName ) ) {
        ServerName->Buffer = NULL;
        ServerName->MaximumLength = ServerName->Length = 0;
    }

    //
    // If the client passed in a malformed type string, then bail out
    //
    if( SrvGetStringLength( ShareTypeString,
                            END_OF_REQUEST_SMB( WorkContext ),
                            FALSE, TRUE ) == (USHORT)-1 ) {

        IF_DEBUG(ERRORS) {
            KdPrint(( "SrvVerifyShare: Invalid share type length!\n" ));
        }

        *Status = STATUS_BAD_DEVICE_TYPE;
        return NULL;
    }

    if( SrvGetStringLength( ShareName,
                            END_OF_REQUEST_SMB( WorkContext ),
                            ShareNameIsUnicode, TRUE ) == (USHORT)-1 ) {

        IF_DEBUG(ERRORS) {
            KdPrint(( "SrvVerifyShare: Invalid share name!\n" ));
        }

        *Status = STATUS_BAD_NETWORK_NAME;
        return NULL;
    }

    //
    // First ensure that the share type string is valid.
    //

    if ( _stricmp( StrShareTypeNames[ShareTypeDisk], ShareTypeString ) == 0 ) {
        shareType = ShareTypeDisk;
    } else if ( _stricmp( StrShareTypeNames[ShareTypePipe], ShareTypeString ) == 0 ) {
        shareType = ShareTypePipe;
    } else if ( _stricmp( StrShareTypeNames[ShareTypePrint], ShareTypeString ) == 0 ) {
        shareType = ShareTypePrint;
    } else if ( _stricmp( StrShareTypeNames[ShareTypeWild], ShareTypeString ) == 0 ) {
        anyShareType = TRUE;
    } else {
        IF_DEBUG(ERRORS) {
            SrvPrint1( "SrvVerifyShare: Invalid share type: %s\n",
                        ShareTypeString );
        }
        *Status = STATUS_BAD_DEVICE_TYPE;
        return NULL;
    }

    //
    // If the passed-in server\share combination is not Unicode, convert
    // it to Unicode.
    //

    if ( ShareNameIsUnicode ) {
        ShareName = ALIGN_SMB_WSTR( ShareName );
    }

    if ( !NT_SUCCESS(SrvMakeUnicodeString(
                        ShareNameIsUnicode,
                        &shareName,
                        ShareName,
                        NULL
                        )) ) {
        IF_DEBUG(ERRORS) {
            SrvPrint0( "SrvVerifyShare: Unable to allocate heap for Unicode share name string\n" );
        }
        *Status = STATUS_INSUFF_SERVER_RESOURCES;
        return NULL;
    }

    //
    // Skip past the "\\server\" part of the input string.  If there is
    // no leading "\\", assume that the input string contains the share
    // name only.  If there is a "\\", but no subsequent "\", assume
    // that the input string contains just a server name, and points to
    // the end of that name, thus fabricating a null share name.
    //

    nameOnly = shareName.Buffer;


    if ( (*nameOnly == DIRECTORY_SEPARATOR_CHAR) &&
         (*(nameOnly+1) == DIRECTORY_SEPARATOR_CHAR) ) {

        PWSTR nextSlash;


        nameOnly += 2;
        nextSlash = wcschr( nameOnly, DIRECTORY_SEPARATOR_CHAR );

        if( ShareNameIsUnicode && ARGUMENT_PRESENT( ServerName ) ) {
            ServerName->Buffer = nameOnly;
            ServerName->MaximumLength = ServerName->Length = (USHORT)((nextSlash - nameOnly) * sizeof( WCHAR ));
        }

        if ( nextSlash == NULL ) {
            nameOnly = NULL;
        } else {
            nameOnly = nextSlash + 1;
        }
    }

    RtlInitUnicodeString( &nameOnlyString, nameOnly );

    //
    // Try to match share name against available share names.
    //

    ACQUIRE_LOCK( &SrvShareLock );

    share = SrvFindShare( &nameOnlyString );

    if ( share == NULL ) {

        RELEASE_LOCK( &SrvShareLock );

        //
        // Perhaps the client is DFS aware.  In this case, see if the DFS
        //  driver can help us out.
        //


        if( ( shareType == ShareTypeDisk || anyShareType == TRUE ) &&
            SMB_CONTAINS_DFS_NAME( WorkContext )) {

            *Status = DfsFindShareName( &nameOnlyString );

        } else {

            *Status = STATUS_BAD_NETWORK_NAME;

        }

        IF_DEBUG(ERRORS) {
            SrvPrint1( "SrvVerifyShare: Unknown share name: %ws\n",
                        nameOnly );
        }

        if ( !ShareNameIsUnicode ) {
            RtlFreeUnicodeString( &shareName );
        }

        return NULL;
    }

#if SRVNTVERCHK
    //
    // If we are watching out for old client versions or bad domains, do not allow
    //  it to connect to this share if it is a disk share
    //
    if( WorkContext->Connection &&
        (share->ShareType == ShareTypeDisk || SrvMinNT5ClientIPCToo) &&
        (WorkContext->Connection->PagedConnection->ClientTooOld ||
         (WorkContext->Session && WorkContext->Session->ClientBadDomain) )) {

        //
        // This client may not connect to this share!
        //
        RELEASE_LOCK( &SrvShareLock );

        if ( !ShareNameIsUnicode ) {
            RtlFreeUnicodeString( &shareName );
        }

        *Status = WorkContext->Connection->PagedConnection->ClientTooOld ?
                    STATUS_REVISION_MISMATCH : STATUS_ACCOUNT_RESTRICTION;

        return NULL;
    }
#endif

    //
    // If this is the null session, allow it to connect only to IPC$ or
    // to shares specified in the NullSessionShares list.
    //

    if ( IsNullSession &&
         SrvRestrictNullSessionAccess &&
         ( share->ShareType != ShareTypePipe ) ) {

        BOOLEAN matchFound = FALSE;
        ULONG i;

        ACQUIRE_LOCK_SHARED( &SrvConfigurationLock );

        for ( i = 0; SrvNullSessionShares[i] != NULL ; i++ ) {

            if ( _wcsicmp(
                    SrvNullSessionShares[i],
                    nameOnlyString.Buffer
                    ) == 0 ) {

                matchFound = TRUE;
                break;
            }
        }

        RELEASE_LOCK( &SrvConfigurationLock );

        if ( !matchFound ) {

            RELEASE_LOCK( &SrvShareLock );

            IF_DEBUG(ERRORS) {
                SrvPrint0( "SrvVerifyShare: Illegal null session access.\n");
            }

            if ( !ShareNameIsUnicode ) {
                RtlFreeUnicodeString( &shareName );
            }

            *Status = STATUS_ACCESS_DENIED;
            return(NULL);
        }
    }

    if ( !ShareNameIsUnicode ) {
        RtlFreeUnicodeString( &shareName );
    }

    if ( anyShareType || (share->ShareType == shareType) ) {

        //
        // Put share in work context block and reference it.
        //

        SrvReferenceShare( share );

        RELEASE_LOCK( &SrvShareLock );

        WorkContext->Share = share;
        return share;

    } else {

        RELEASE_LOCK( &SrvShareLock );

        IF_DEBUG(ERRORS) {
            SrvPrint1( "SrvVerifyShare: incorrect share type: %s\n",
                        ShareTypeString );
        }

        *Status = STATUS_BAD_DEVICE_TYPE;
        return NULL;

    }

} // SrvVerifyShare


PSHARE
SrvFindShare (
    IN PUNICODE_STRING ShareName
    )

/*++

Routine Description:

    Attempts to find a share that matches a given name.

    *** This routine must be called with the share lock (SrvShareLock)
        held.

Arguments:

    ShareName - name of share to Find.

Return Value:

    A pointer to a share matching the given name, or NULL if none exists.

--*/

{
    PSHARE share;
    PLIST_ENTRY listEntryRoot, listEntry;
    ULONG hashValue;

    PAGED_CODE( );

    //
    // Try to match share name against available share names.
    //

    COMPUTE_STRING_HASH( ShareName, &hashValue );
    listEntryRoot = &SrvShareHashTable[ HASH_TO_SHARE_INDEX( hashValue ) ];

    for( listEntry = listEntryRoot->Flink;
         listEntry != listEntryRoot;
         listEntry = listEntry->Flink ) {

        share = CONTAINING_RECORD( listEntry, SHARE, GlobalShareList );

        if( share->ShareNameHashValue == hashValue &&
            RtlCompareUnicodeString(
                &share->ShareName,
                ShareName,
                TRUE
                ) == 0 ) {

            //
            // Found a matching share.  If it is active return its
            // address.
            //

            if ( GET_BLOCK_STATE( share ) == BlockStateActive ) {
                return share;
            }
        }
    }

    //
    // Couldn't find a matching share that was active.
    //

    return NULL;

} // SrvFindShare

VOID
SrvRemoveShare(
    PSHARE Share
)
{
    PAGED_CODE();

    RemoveEntryList( &Share->GlobalShareList );
}

VOID
SrvAddShare(
    PSHARE Share
)
{
    PLIST_ENTRY listEntryRoot, listEntry;
    ULONG hashValue;

    PAGED_CODE();

    COMPUTE_STRING_HASH( &Share->ShareName, &hashValue );
    Share->ShareNameHashValue = hashValue;
    listEntryRoot = &SrvShareHashTable[ HASH_TO_SHARE_INDEX( hashValue ) ];

    InsertTailList( listEntryRoot, &Share->GlobalShareList );
}

NTSTATUS
SrvShareEnumApiHandler (
    IN PSERVER_REQUEST_PACKET Srp,
    IN PVOID OutputBuffer,
    IN ULONG BufferLength,
    IN PENUM_FILTER_ROUTINE FilterRoutine,
    IN PENUM_SIZE_ROUTINE SizeRoutine,
    IN PENUM_FILL_ROUTINE FillRoutine
    )

/*++

Routine Description:

    All share Enum and GetInfo APIs are handled by this routine in the server
    FSD.  It takes the ResumeHandle in the SRP to find the first
    appropriate share, then calls the passed-in filter routine to check
    if the share should be filled in.  If it should, we call the filter
    routine, then try to get another shar.  This continues until the
    entire list has been walked.

Arguments:

    Srp - a pointer to the SRP for the operation.

    OutputBuffer - the buffer in which to fill output information.

    BufferLength - the length of the buffer.

    FilterRoutine - a pointer to a function that will check a share entry
        against information in the SRP to determine whether the
        information in the share should be placed in the output
        buffer.

    SizeRoutine - a pointer to a function that will find the total size
        a single share will take up in the output buffer.  This routine
        is used to check whether we should bother to call the fill
        routine.

    FillRoutine - a pointer to a function that will fill in the output
        buffer with information from a share.

Return Value:

    NTSTATUS - results of operation.

--*/

{
    PSHARE share;
    ULONG totalEntries;
    ULONG entriesRead;
    ULONG bytesRequired;

    PCHAR fixedStructurePointer;
    PCHAR variableData;
    ULONG blockSize;

    BOOLEAN bufferOverflow = FALSE;
    BOOLEAN entryReturned = FALSE;

    PLIST_ENTRY listEntryRoot, listEntry;
    ULONG oldSkipCount;
    ULONG newResumeKey;

    PAGED_CODE( );

    //
    // Set up local variables.
    //

    fixedStructurePointer = OutputBuffer;
    variableData = fixedStructurePointer + BufferLength;
    variableData = (PCHAR)((ULONG_PTR)variableData & ~1);

    entriesRead = 0;
    totalEntries = 0;
    bytesRequired = 0;

    listEntryRoot = &SrvShareHashTable[ HASH_TO_SHARE_INDEX( Srp->Parameters.Get.ResumeHandle >> 16 ) ];
    oldSkipCount = Srp->Parameters.Get.ResumeHandle & 0xff;

    ACQUIRE_LOCK_SHARED( &SrvShareLock );

    for( ;
         listEntryRoot < &SrvShareHashTable[ NSHARE_HASH_TABLE ];
         listEntryRoot++, newResumeKey = 0 ) {

        newResumeKey = (ULONG)((listEntryRoot - SrvShareHashTable) << 16);

        for( listEntry = listEntryRoot->Flink;
             listEntry != listEntryRoot;
             listEntry = listEntry->Flink, newResumeKey++ ) {

            if( oldSkipCount ) {
                --oldSkipCount;
                ++newResumeKey;
                continue;
            }

            share = CONTAINING_RECORD( listEntry, SHARE, GlobalShareList );

            //
            // Call the filter routine to determine whether we should
            // return this share.
            //

            if ( FilterRoutine( Srp, share ) ) {

                blockSize = SizeRoutine( Srp, share );

                totalEntries++;
                bytesRequired += blockSize;

                //
                // If all the information in the share will fit in the
                // output buffer, write it.  Otherwise, indicate that there
                // was an overflow.  As soon as an entry doesn't fit, stop
                // putting them in the buffer.  This ensures that the resume
                // mechanism will work--retuning partial entries would make
                // it nearly impossible to use the resumability of the APIs,
                // since the caller would have to resume from an imcomplete
                // entry.
                //

                if ( (ULONG_PTR)fixedStructurePointer + blockSize <=
                         (ULONG_PTR)variableData && !bufferOverflow ) {

                    FillRoutine(
                        Srp,
                        share,
                        (PVOID *)&fixedStructurePointer,
                        (LPWSTR *)&variableData
                        );

                    entriesRead++;
                    newResumeKey++;

                } else {

                    bufferOverflow = TRUE;
                }
            }
        }
    }

    RELEASE_LOCK( &SrvShareLock );

    //
    // Set the information to pass back to the server service.
    //

    Srp->Parameters.Get.EntriesRead = entriesRead;
    Srp->Parameters.Get.TotalEntries = totalEntries;
    Srp->Parameters.Get.TotalBytesNeeded = bytesRequired;

    //
    // Return appropriate status.
    //

    if ( entriesRead == 0 && totalEntries > 0 ) {

        //
        // Not even a single entry fit.
        //

        Srp->ErrorCode = NERR_BufTooSmall;
        return STATUS_SUCCESS;

    } else if ( bufferOverflow ) {

        //
        // At least one entry fit, but not all of them.
        //

        Srp->ErrorCode = ERROR_MORE_DATA;
        Srp->Parameters.Get.ResumeHandle = newResumeKey;
        return STATUS_SUCCESS;

    } else {

        //
        // All entries fit.
        //

        Srp->ErrorCode = NO_ERROR;
        Srp->Parameters.Get.ResumeHandle = 0;
        return STATUS_SUCCESS;
    }

} // SrvEnumApiHandler
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\srv\smbattr.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    smbattr.c

Abstract:

    This module contains routines for processing the following SMBs:

        Query Information
        Set Information
        Query Information2
        Set Information2
        Query Path Information
        Set Path Information
        Query File Information
        Set File Information

Author:

    David Treadwell (davidtr) 27-Dec-1989
    Chuck Lenzmeier (chuckl)

Revision History:

--*/

#include "precomp.h"
#include "smbattr.tmh"
#pragma hdrstop

#define BugCheckFileId SRV_FILE_SMBATTR

#pragma pack(1)

typedef struct _FILESTATUS {
    SMB_DATE CreationDate;
    SMB_TIME CreationTime;
    SMB_DATE LastAccessDate;
    SMB_TIME LastAccessTime;
    SMB_DATE LastWriteDate;
    SMB_TIME LastWriteTime;
    _ULONG( DataSize );
    _ULONG( AllocationSize );
    _USHORT( Attributes );
    _ULONG( EaSize );           // this field intentionally misaligned!
} FILESTATUS, *PFILESTATUS;

#pragma pack()

STATIC
ULONG QueryFileInformation[] = {
         SMB_QUERY_FILE_BASIC_INFO,// Base level
         FileBasicInformation,     // Mapping for base level
         FileStandardInformation,
         FileEaInformation,
         FileNameInformation,
         FileAllocationInformation,
         FileEndOfFileInformation,
         0,                        // FileAllInformation
         FileAlternateNameInformation,
         FileStreamInformation,
         0,                        //Used to be FileOleAllInformation -- OBSOLETE
         FileCompressionInformation
};

STATIC
ULONG QueryFileInformationSize[] = {
        SMB_QUERY_FILE_BASIC_INFO,// Base level
        FileBasicInformation,     // Mapping for base level
        sizeof( FILE_BASIC_INFORMATION),
        sizeof( FILE_STANDARD_INFORMATION ),
        sizeof( FILE_EA_INFORMATION ),
        sizeof( FILE_NAME_INFORMATION ),
        sizeof( FILE_ALLOCATION_INFORMATION ),
        sizeof( FILE_END_OF_FILE_INFORMATION ),
        sizeof( FILE_ALL_INFORMATION ),
        sizeof( FILE_NAME_INFORMATION ),
        sizeof( FILE_STREAM_INFORMATION ),
        0,                      // Used to be sizeof( FILE_OLE_ALL_INFORMATION )
        sizeof( FILE_COMPRESSION_INFORMATION )
};

STATIC
ULONG SetFileInformation[] = {
         SMB_SET_FILE_BASIC_INFO,  // Base level
         FileBasicInformation,     // Mapping for base level
         FileDispositionInformation,
         FileAllocationInformation,
         FileEndOfFileInformation
};

STATIC
ULONG SetFileInformationSize[] = {
        SMB_SET_FILE_BASIC_INFO, // Base level
        FileBasicInformation,    // Mapping for base level
        sizeof( FILE_BASIC_INFORMATION ),
        sizeof( FILE_DISPOSITION_INFORMATION ),
        sizeof( FILE_ALLOCATION_INFORMATION ),
        sizeof( FILE_END_OF_FILE_INFORMATION )
};

STATIC
NTSTATUS
QueryPathOrFileInformation (
    IN PWORK_CONTEXT WorkContext,
    IN PTRANSACTION Transaction,
    IN USHORT InformationLevel,
    IN HANDLE FileHandle,
    OUT PRESP_QUERY_PATH_INFORMATION Response
    );

STATIC
NTSTATUS
SetPathOrFileInformation (
    IN PWORK_CONTEXT WorkContext,
    IN PTRANSACTION Transaction,
    IN USHORT InformationLevel,
    IN HANDLE FileHandle,
    OUT PRESP_SET_PATH_INFORMATION Response
    );

SMB_TRANS_STATUS
GenerateQueryPathInfoResponse (
    IN PWORK_CONTEXT WorkContext,
    IN NTSTATUS OpenStatus
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text( PAGE, SrvSmbQueryInformation )
#pragma alloc_text( PAGE, SrvSmbSetInformation )
#pragma alloc_text( PAGE, SrvSmbQueryInformation2 )
#pragma alloc_text( PAGE, SrvSmbSetInformation2 )
#pragma alloc_text( PAGE, QueryPathOrFileInformation )
#pragma alloc_text( PAGE, SrvSmbQueryFileInformation )
#pragma alloc_text( PAGE, SrvSmbQueryPathInformation )
#pragma alloc_text( PAGE, GenerateQueryPathInfoResponse )
#pragma alloc_text( PAGE, SetPathOrFileInformation )
#pragma alloc_text( PAGE, SrvSmbSetFileInformation )
#pragma alloc_text( PAGE, SrvSmbSetPathInformation )
#endif


SMB_PROCESSOR_RETURN_TYPE
SrvSmbQueryInformation (
    SMB_PROCESSOR_PARAMETERS
    )

/*++

Routine Description:

    Processes the QueryInformation SMB.

Arguments:

    SMB_PROCESSOR_PARAMETERS - See smbtypes.h for a description
        of the parameters to SMB processor routines.

Return Value:

    SMB_PROCESSOR_RETURN_TYPE - See smbtypes.h

--*/

{
    PREQ_QUERY_INFORMATION request;
    PRESP_QUERY_INFORMATION response;

    NTSTATUS   status    = STATUS_SUCCESS;
    SMB_STATUS SmbStatus = SmbStatusInProgress;
    PSESSION session;
    PTREE_CONNECT treeConnect;
    OBJECT_ATTRIBUTES objectAttributes;
    UNICODE_STRING objectName;
    IO_STATUS_BLOCK ioStatusBlock;
    BOOLEAN isUnicode;
    FILE_NETWORK_OPEN_INFORMATION fileInformation;

    PAGED_CODE( );

    if (WorkContext->PreviousSMB == EVENT_TYPE_SMB_LAST_EVENT)
        WorkContext->PreviousSMB = EVENT_TYPE_SMB_QUERY_INFORMATION;
    SrvWmiStartContext(WorkContext);
    IF_SMB_DEBUG(QUERY_SET1) {
        KdPrint(( "QueryInformation request header at 0x%p, response header at 0x%p\n",
                    WorkContext->RequestHeader,
                    WorkContext->ResponseHeader ));
        KdPrint(( "QueryInformation request parameters at 0x%p, response parameters at 0x%p\n",
                    WorkContext->RequestParameters,
                    WorkContext->ResponseParameters ));
    }

    request = (PREQ_QUERY_INFORMATION)WorkContext->RequestParameters;
    response = (PRESP_QUERY_INFORMATION)WorkContext->ResponseParameters;

    //
    // If a session block has not already been assigned to the current
    // work context, verify the UID.  If verified, the address of the
    // session block corresponding to this user is stored in the WorkContext
    // block and the session block is referenced.
    //
    // Find tree connect corresponding to given TID if a tree connect
    // pointer has not already been put in the WorkContext block by an
    // AndX command.
    //

    status = SrvVerifyUidAndTid(
                WorkContext,
                &session,
                &treeConnect,
                ShareTypeDisk
                );

    if ( !NT_SUCCESS(status) ) {
        IF_DEBUG(SMB_ERRORS) {
            KdPrint(( "SrvSmbQueryInformation: Invalid UID or TID\n" ));
        }
        SrvSetSmbError( WorkContext, status );
        SmbStatus = SmbStatusSendResponse;
        goto Cleanup;
    }

    //
    // If the session has expired, return that info
    //
    if( session->IsSessionExpired )
    {
        status =  SESSION_EXPIRED_STATUS_CODE;
        SmbStatus = SmbStatusSendResponse;
        SrvSetSmbError( WorkContext, status );
        goto Cleanup;
    }

    //
    // Get the path name of the file to open relative to the share.
    //

    isUnicode = SMB_IS_UNICODE( WorkContext );

    status = SrvCanonicalizePathName(
            WorkContext,
            treeConnect->Share,
            NULL,
            (PVOID)(request->Buffer + 1),
            END_OF_REQUEST_SMB( WorkContext ),
            TRUE,
            isUnicode,
            &objectName
            );

    if( !NT_SUCCESS( status ) ) {

        IF_DEBUG(SMB_ERRORS) {
            KdPrint(( "SrvSmbQueryInformation: bad path name: %s\n",
                        (PSZ)request->Buffer + 1 ));
        }

        SrvSetSmbError( WorkContext, status );
        SmbStatus = SmbStatusSendResponse;
        goto Cleanup;
    }

    //
    // Initialize the object attributes structure.
    //

    SrvInitializeObjectAttributes_U(
        &objectAttributes,
        &objectName,
        (WorkContext->RequestHeader->Flags & SMB_FLAGS_CASE_INSENSITIVE ||
         session->UsingUppercasePaths) ? OBJ_CASE_INSENSITIVE : 0L,
        NULL,
        NULL
        );


    //
    // "Be the client" for access checking
    //
    status = IMPERSONATE( WorkContext );

    if( NT_SUCCESS( status ) ) {

        status = SrvGetShareRootHandle( treeConnect->Share );

        if( NT_SUCCESS( status ) ) {
            //
            // The file name is always relative to the share root
            //
            status = SrvSnapGetRootHandle( WorkContext, &objectAttributes.RootDirectory );
            if( !NT_SUCCESS( status ) )
            {
                goto SnapError;
            }

            //
            // Get the information
            //
            if( IoFastQueryNetworkAttributes(
                &objectAttributes,
                FILE_READ_ATTRIBUTES,
                0,
                &ioStatusBlock,
                &fileInformation
                ) == FALSE ) {

                    SrvLogServiceFailure( SRV_SVC_IO_FAST_QUERY_NW_ATTRS, 0 );
                    ioStatusBlock.Status = STATUS_OBJECT_PATH_NOT_FOUND;
            }

            status = ioStatusBlock.Status;

            //
            // If the media was changed and we can come up with a new share root handle,
            //  then we should retry the operation
            //
            if( SrvRetryDueToDismount( treeConnect->Share, status ) ) {

                status = SrvSnapGetRootHandle( WorkContext, &objectAttributes.RootDirectory );
                if( !NT_SUCCESS( status ) )
                {
                    goto SnapError;
                }

                if( IoFastQueryNetworkAttributes(
                    &objectAttributes,
                    FILE_READ_ATTRIBUTES,
                    0,
                    &ioStatusBlock,
                    &fileInformation
                    ) == FALSE ) {

                        SrvLogServiceFailure( SRV_SVC_IO_FAST_QUERY_NW_ATTRS, 0 );
                        ioStatusBlock.Status = STATUS_OBJECT_PATH_NOT_FOUND;
                }

                status = ioStatusBlock.Status;

            }

SnapError:
            SrvReleaseShareRootHandle( treeConnect->Share );
        }

        REVERT();
    }

    if ( !isUnicode ) {
        RtlFreeUnicodeString( &objectName );
    }

    //
    // Build the response SMB.
    //

    if ( !NT_SUCCESS(status) ) {

        if ( status == STATUS_ACCESS_DENIED ) {
            SrvStatistics.AccessPermissionErrors++;
        }

        IF_DEBUG(ERRORS) {
            KdPrint(( "SrvSmbQueryInformation: "
                        "SrvQueryInformationFileAbbreviated failed: %X\n", status ));
        }

        SrvSetSmbError( WorkContext, status );

    } else {

        USHORT smbFileAttributes;
        LARGE_INTEGER newTime;

        response->WordCount = 10;

        SRV_NT_ATTRIBUTES_TO_SMB(
            fileInformation.FileAttributes,
            fileInformation.FileAttributes & FILE_ATTRIBUTE_DIRECTORY,
            &smbFileAttributes
        );

        SmbPutUshort( &response->FileAttributes, smbFileAttributes );

        //
        // Convert the time to that which the SMB protocol needs
        //
        ExSystemTimeToLocalTime( &fileInformation.LastWriteTime, &newTime );
        newTime.QuadPart += AlmostTwoSeconds;

        if ( !RtlTimeToSecondsSince1970( &newTime, &fileInformation.LastWriteTime.LowPart ) ) {
            fileInformation.LastWriteTime.LowPart = 0;
        }

        //
        // Round to 2 seconds
        //
        fileInformation.LastWriteTime.LowPart &= ~1;

        SmbPutUlong(
            &response->LastWriteTimeInSeconds,
            fileInformation.LastWriteTime.LowPart
            );

        SmbPutUlong( &response->FileSize, fileInformation.EndOfFile.LowPart );
        RtlZeroMemory( (PVOID)&response->Reserved[0], sizeof(response->Reserved) );
        SmbPutUshort( &response->ByteCount, 0 );

        WorkContext->ResponseParameters = NEXT_LOCATION(
                                            response,
                                            RESP_QUERY_INFORMATION,
                                            0
                                            );
    }

    SmbStatus = SmbStatusSendResponse;

Cleanup:
    SrvWmiEndContext(WorkContext);
    return SmbStatus;

} // SrvSmbQueryInformation


SMB_PROCESSOR_RETURN_TYPE
SrvSmbSetInformation (
    SMB_PROCESSOR_PARAMETERS
    )

/*++

Routine Description:

    Processes the SetInformation SMB.

Arguments:

    SMB_PROCESSOR_PARAMETERS - See smbtypes.h for a description
        of the parameters to SMB processor routines.

Return Value:

    SMB_PROCESSOR_RETURN_TYPE - See smbtypes.h

--*/

{
    PREQ_SET_INFORMATION request;
    PRESP_SET_INFORMATION response;

    NTSTATUS   status    = STATUS_SUCCESS;
    SMB_STATUS SmbStatus = SmbStatusInProgress;
    PSESSION session;
    PTREE_CONNECT treeConnect;
    HANDLE fileHandle;
    OBJECT_ATTRIBUTES objectAttributes;
    UNICODE_STRING objectName;
    IO_STATUS_BLOCK ioStatusBlock;
    BOOLEAN isUnicode;
    FILE_BASIC_INFORMATION fileBasicInformation;
    ULONG lastWriteTimeInSeconds;

    PAGED_CODE( );

    if (WorkContext->PreviousSMB == EVENT_TYPE_SMB_LAST_EVENT)
        WorkContext->PreviousSMB = EVENT_TYPE_SMB_SET_INFORMATION;
    SrvWmiStartContext(WorkContext);
    IF_SMB_DEBUG(QUERY_SET1) {
        KdPrint(( "SetInformation request header at 0x%p, response header at 0x%p\n",
                    WorkContext->RequestHeader,
                    WorkContext->ResponseHeader ));
        KdPrint(( "SetInformation request parameters at 0x%p, response parameters at 0x%p\n",
                    WorkContext->RequestParameters,
                    WorkContext->ResponseParameters ));
    }

    request = (PREQ_SET_INFORMATION)WorkContext->RequestParameters;
    response = (PRESP_SET_INFORMATION)WorkContext->ResponseParameters;

    //
    // If a session block has not already been assigned to the current
    // work context, verify the UID.  If verified, the address of the
    // session block corresponding to this user is stored in the WorkContext
    // block and the session block is referenced.
    //
    // Find tree connect corresponding to given TID if a tree connect
    // pointer has not already been put in the WorkContext block by an
    // AndX command.
    //

    status = SrvVerifyUidAndTid(
                  WorkContext,
                  &session,
                  &treeConnect,
                  ShareTypeDisk
                  );

    if ( !NT_SUCCESS(status) ) {
        IF_DEBUG(SMB_ERRORS) {
            KdPrint(( "SrvSmbSetInformation: Invalid UID and TID\n" ));
        }
        SrvSetSmbError( WorkContext, status );
        SmbStatus = SmbStatusSendResponse;
        goto Cleanup;
    }

    //
    // If the session has expired, return that info
    //
    if( session->IsSessionExpired )
    {
        status =  SESSION_EXPIRED_STATUS_CODE;
        SmbStatus = SmbStatusSendResponse;
        SrvSetSmbError( WorkContext, status );
        goto Cleanup;
    }

    if ( treeConnect == NULL ) {

        IF_DEBUG(SMB_ERRORS) {
            KdPrint(( "SrvSmbSetInformation: Invalid TID: 0x%lx\n",
                SmbGetAlignedUshort( &WorkContext->RequestHeader->Tid ) ));
        }

        SrvSetSmbError( WorkContext, STATUS_SMB_BAD_TID );
        SmbStatus = SmbStatusSendResponse;
        goto Cleanup;
    }

    //
    // Concatenate PathName from the share block and PathName from the
    // incoming SMB to generate the full path name to the file.
    //

    isUnicode = SMB_IS_UNICODE( WorkContext );

    status = SrvCanonicalizePathName(
            WorkContext,
            treeConnect->Share,
            NULL,
            (PVOID)(request->Buffer + 1),
            END_OF_REQUEST_SMB( WorkContext ),
            TRUE,
            isUnicode,
            &objectName
            );

    if( !NT_SUCCESS( status ) ) {

        IF_DEBUG(SMB_ERRORS) {
            KdPrint(( "SrvSmbSetInformation: bad path name: %s\n",
                        (PSZ)request->Buffer + 1 ));
        }

        SrvSetSmbError( WorkContext, status );
        SmbStatus = SmbStatusSendResponse;
        goto Cleanup;
    }

    //
    // If the client is trying to delete the root of the share, reject
    // the request.
    //

    if ( objectName.Length < sizeof(WCHAR) ) {

        IF_DEBUG(SMB_ERRORS) {
            KdPrint(( "SrvSmbSetInformation: attempting to set info on "
                          "share root\n" ));
        }

        if (!SMB_IS_UNICODE( WorkContext )) {
            RtlFreeUnicodeString( &objectName );
        }
        SrvSetSmbError( WorkContext, STATUS_ACCESS_DENIED );
        SmbStatus = SmbStatusSendResponse;
        goto Cleanup;
    }

    //
    // Initialize the object attributes structure.
    //

    SrvInitializeObjectAttributes_U(
        &objectAttributes,
        &objectName,
        (WorkContext->RequestHeader->Flags & SMB_FLAGS_CASE_INSENSITIVE ||
         session->UsingUppercasePaths) ? OBJ_CASE_INSENSITIVE : 0L,
        NULL,
        NULL
        );

    IF_SMB_DEBUG(QUERY_SET2) KdPrint(( "Opening file %wZ\n", &objectName ));

    //
    // Open the file--must be opened in order to have a handle to pass
    // to NtSetInformationFile.  We will close it after setting the
    // necessary information.
    //
    INCREMENT_DEBUG_STAT( SrvDbgStatistics.TotalOpenAttempts );
    INCREMENT_DEBUG_STAT( SrvDbgStatistics.TotalOpensForPathOperations );

    //
    // *** FILE_WRITE_ATTRIBUTES does not cause oplock breaks!
    //

    status = SrvIoCreateFile(
                 WorkContext,
                 &fileHandle,
                 FILE_WRITE_ATTRIBUTES,                     // DesiredAccess
                 &objectAttributes,
                 &ioStatusBlock,
                 NULL,                                      // AllocationSize
                 0,                                         // FileAttributes
                 FILE_SHARE_READ | FILE_SHARE_WRITE |
                    FILE_SHARE_DELETE,                      // ShareAccess
                 FILE_OPEN,                                 // Disposition
                 FILE_OPEN_REPARSE_POINT,                   // CreateOptions
                 NULL,                                      // EaBuffer
                 0,                                         // EaLength
                 CreateFileTypeNone,
                 NULL,                                      // ExtraCreateParameters
                 IO_FORCE_ACCESS_CHECK,                     // Options
                 treeConnect->Share
                 );

    if( status == STATUS_INVALID_PARAMETER ) {
        status = SrvIoCreateFile(
                     WorkContext,
                     &fileHandle,
                     FILE_WRITE_ATTRIBUTES,                     // DesiredAccess
                     &objectAttributes,
                     &ioStatusBlock,
                     NULL,                                      // AllocationSize
                     0,                                         // FileAttributes
                     FILE_SHARE_READ | FILE_SHARE_WRITE |
                        FILE_SHARE_DELETE,                      // ShareAccess
                     FILE_OPEN,                                 // Disposition
                     0,                                         // CreateOptions
                     NULL,                                      // EaBuffer
                     0,                                         // EaLength
                     CreateFileTypeNone,
                     NULL,                                      // ExtraCreateParameters
                     IO_FORCE_ACCESS_CHECK,                     // Options
                     treeConnect->Share
                     );
    }

    ASSERT( status != STATUS_OPLOCK_BREAK_IN_PROGRESS );

    if ( !isUnicode ) {
        RtlFreeUnicodeString( &objectName );
    }

    if ( NT_SUCCESS(status) ) {

        SRVDBG_CLAIM_HANDLE( fileHandle, "FIL", 20, 0 );

        //
        // Ensure this client's RFCB cache is empty.  This covers the case
        //  where a client opened a file for writing, closed it, set the
        //  attributes to readonly, and then tried to reopen the file for
        //  writing.  This sequence should fail, but it will succeed if the
        //  file was in the RFCB cache.
        //
        SrvCloseCachedRfcbsOnConnection( WorkContext->Connection );

    } else {

        if ( status == STATUS_ACCESS_DENIED ) {
            SrvStatistics.AccessPermissionErrors++;
        }

        IF_DEBUG(ERRORS) {
            KdPrint(( "SrvSmbSetInformation: SrvIoCreateFile "
                        "failed: %X\n", status ));
        }

        SrvSetSmbError( WorkContext, status );
        SmbStatus = SmbStatusSendResponse;
        goto Cleanup;
    }

    IF_SMB_DEBUG(QUERY_SET2) {
        KdPrint(( "SrvIoCreateFile succeeded, handle = 0x%p\n", fileHandle ));
    }

    //
    // Set fields of fileBasicInformation to pass to NtSetInformationFile.
    // Note that we zero the creation, last access, and change times so
    // that they are not actually changed.
    //

    RtlZeroMemory( &fileBasicInformation, sizeof(fileBasicInformation) );

    lastWriteTimeInSeconds = SmbGetUlong( &request->LastWriteTimeInSeconds );
    if ( lastWriteTimeInSeconds != 0 ) {
        RtlSecondsSince1970ToTime(
            lastWriteTimeInSeconds,
            &fileBasicInformation.LastWriteTime
            );

        ExLocalTimeToSystemTime(
            &fileBasicInformation.LastWriteTime,
            &fileBasicInformation.LastWriteTime
            );

    }

    //
    // Set the new file attributes.  Note that we don't return an error
    // if the client tries to set the Directory or Volume bits -- we
    // assume that the remote redirector filters such requests.
    //

    SRV_SMB_ATTRIBUTES_TO_NT(
        SmbGetUshort( &request->FileAttributes ),
        NULL,
        &fileBasicInformation.FileAttributes
        );

    //
    // Set the new file information.
    //

    status = NtSetInformationFile(
                 fileHandle,
                 &ioStatusBlock,
                 &fileBasicInformation,
                 sizeof(FILE_BASIC_INFORMATION),
                 FileBasicInformation
                 );

    //
    // Close the file--it was only opened to set the attributes.
    //

    SRVDBG_RELEASE_HANDLE( fileHandle, "FIL", 30, 0 );
    SrvNtClose( fileHandle, TRUE );

    if ( !NT_SUCCESS(status) ) {

        INTERNAL_ERROR(
            ERROR_LEVEL_UNEXPECTED,
            "SrvSmbSetInformation: NtSetInformationFile returned %X",
            status,
            NULL
            );

        SrvLogServiceFailure( SRV_SVC_NT_SET_INFO_FILE, status );

        SrvSetSmbError( WorkContext, status );
        SmbStatus = SmbStatusSendResponse;
        goto Cleanup;
    }

    //
    // Build the response SMB.
    //

    response->WordCount = 0;
    SmbPutUshort( &response->ByteCount, 0 );

    WorkContext->ResponseParameters = NEXT_LOCATION(
                                        response,
                                        RESP_SET_INFORMATION,
                                        0
                                        );

    IF_DEBUG(TRACE2) KdPrint(( "SrvSmbSetInformation complete.\n" ));
    SmbStatus = SmbStatusSendResponse;

Cleanup:
    SrvWmiEndContext(WorkContext);
    return SmbStatus;
} // SrvSmbSetInformation


SMB_PROCESSOR_RETURN_TYPE
SrvSmbQueryInformation2 (
    SMB_PROCESSOR_PARAMETERS
    )

/*++

Routine Description:

    Processes the QueryInformation2 SMB.

Arguments:

    SMB_PROCESSOR_PARAMETERS - See smbtypes.h for a description
        of the parameters to SMB processor routines.

Return Value:

    SMB_PROCESSOR_RETURN_TYPE - See smbtypes.h

--*/

{
    PREQ_QUERY_INFORMATION2 request;
    PRESP_QUERY_INFORMATION2 response;

    NTSTATUS   status    = STATUS_SUCCESS;
    SMB_STATUS SmbStatus = SmbStatusInProgress;
    PRFCB rfcb;
    SRV_FILE_INFORMATION fileInformation;

    PAGED_CODE( );
    if (WorkContext->PreviousSMB == EVENT_TYPE_SMB_LAST_EVENT)
        WorkContext->PreviousSMB = EVENT_TYPE_SMB_QUERY_INFORMATION2;
    SrvWmiStartContext(WorkContext);

    IF_SMB_DEBUG(QUERY_SET1) {
        KdPrint(( "QueryInformation2 request header at 0x%p, response header at 0x%p\n",
                    WorkContext->RequestHeader,
                    WorkContext->ResponseHeader ));
        KdPrint(( "QueryInformation2 request parameters at 0x%p, response parameters at 0x%p\n",
                    WorkContext->RequestParameters,
                    WorkContext->ResponseParameters ));
    }

    request = (PREQ_QUERY_INFORMATION2)WorkContext->RequestParameters;
    response = (PRESP_QUERY_INFORMATION2)WorkContext->ResponseParameters;

    //
    // Verify the FID.  If verified, the RFCB block is referenced
    // and its addresses is stored in the WorkContext block, and the
    // RFCB address is returned.
    //

    rfcb = SrvVerifyFid(
                WorkContext,
                SmbGetUshort( &request->Fid ),
                TRUE,
                SrvRestartSmbReceived,   // serialize with raw write
                &status
                );

    if ( rfcb == SRV_INVALID_RFCB_POINTER ) {

        if ( !NT_SUCCESS( status ) ) {

            //
            // Invalid file ID or write behind error.  Reject the request.
            //

            IF_DEBUG(ERRORS) {
                KdPrint((
                    "SrvSmbQueryInformation2: Status %X on fid 0x%lx\n",
                    status,
                    SmbGetUshort( &request->Fid )
                    ));
            }

            SrvSetSmbError( WorkContext, status );
            SmbStatus = SmbStatusSendResponse;
            goto Cleanup;
        }

        //
        // The work item has been queued because a raw write is in
        // progress.
        //

        SmbStatus = SmbStatusInProgress;
        goto Cleanup;
    }

    if( rfcb->Lfcb->Session->IsSessionExpired )
    {
        status = SESSION_EXPIRED_STATUS_CODE;
        SrvSetSmbError( WorkContext, status );
        SmbStatus = SmbStatusSendResponse;
        goto Cleanup;
    }

    //
    // Verify that the client has read attributes access to the file via
    // the specified handle.
    //

    CHECK_FILE_INFORMATION_ACCESS(
        rfcb->GrantedAccess,
        IRP_MJ_QUERY_INFORMATION,
        FileBasicInformation,
        &status
        );

    if ( !NT_SUCCESS(status) ) {

        SrvStatistics.GrantedAccessErrors++;

        IF_DEBUG(ERRORS) {
            KdPrint(( "SrvSmbQueryInformation2: IoCheckFunctionAccess failed: "
                        "0x%X, GrantedAccess: %lx\n",
                        status, rfcb->GrantedAccess ));
        }

        SrvSetSmbError( WorkContext, status );
        SmbStatus = SmbStatusSendResponse;
        goto Cleanup;
    }

    //
    // Get the necessary information about the file.
    //

    status = SrvQueryInformationFile(
                rfcb->Lfcb->FileHandle,
                rfcb->Lfcb->FileObject,
                &fileInformation,
                (SHARE_TYPE) -1,
                FALSE
                );

    if ( !NT_SUCCESS(status) ) {

        INTERNAL_ERROR(
            ERROR_LEVEL_UNEXPECTED,
            "SrvSmbQueryInformation2: SrvQueryInformationFile returned %X",
            status,
            NULL
            );

        SrvLogServiceFailure( SRV_SVC_NT_QUERY_INFO_FILE, status );

        SrvSetSmbError( WorkContext, status );
        SmbStatus = SmbStatusSendResponse;
        goto Cleanup;
    }

    //
    // Build the response SMB.
    //

    response->WordCount = 11;
    SmbPutDate( &response->CreationDate, fileInformation.CreationDate );
    SmbPutTime( &response->CreationTime, fileInformation.CreationTime );
    SmbPutDate( &response->LastAccessDate, fileInformation.LastAccessDate );
    SmbPutTime( &response->LastAccessTime, fileInformation.LastAccessTime );
    SmbPutDate( &response->LastWriteDate, fileInformation.LastWriteDate );
    SmbPutTime( &response->LastWriteTime, fileInformation.LastWriteTime );
    SmbPutUlong( &response->FileDataSize, fileInformation.DataSize.LowPart );
    SmbPutUlong(
        &response->FileAllocationSize,
        fileInformation.AllocationSize.LowPart
        );
    SmbPutUshort( &response->FileAttributes, fileInformation.Attributes );
    SmbPutUshort( &response->ByteCount, 0 );

    WorkContext->ResponseParameters = NEXT_LOCATION(
                                        response,
                                        RESP_QUERY_INFORMATION2,
                                        0
                                        );
    SmbStatus = SmbStatusSendResponse;
    IF_DEBUG(TRACE2) KdPrint(( "SrvSmbQueryInformation2 complete.\n" ));

Cleanup:
    SrvWmiEndContext(WorkContext);
    return SmbStatus;

} // SrvSmbQueryInformation2


SMB_PROCESSOR_RETURN_TYPE
SrvSmbSetInformation2 (
    SMB_PROCESSOR_PARAMETERS
    )

/*++

Routine Description:

    Processes the Set Information2 SMB.

Arguments:

    SMB_PROCESSOR_PARAMETERS - See smbtypes.h for a description
        of the parameters to SMB processor routines.

Return Value:

    SMB_PROCESSOR_RETURN_TYPE - See smbtypes.h

--*/

{
    PREQ_SET_INFORMATION2 request;
    PRESP_SET_INFORMATION2 response;

    NTSTATUS   status    = STATUS_SUCCESS;
    SMB_STATUS SmbStatus = SmbStatusInProgress;
    PRFCB rfcb;
    FILE_BASIC_INFORMATION fileBasicInformation;
    IO_STATUS_BLOCK ioStatusBlock;
    SMB_DATE date;
    SMB_TIME time;

    PAGED_CODE( );
    if (WorkContext->PreviousSMB == EVENT_TYPE_SMB_LAST_EVENT)
        WorkContext->PreviousSMB = EVENT_TYPE_SMB_SET_INFORMATION2;
    SrvWmiStartContext(WorkContext);

    IF_SMB_DEBUG(QUERY_SET1) {
        KdPrint(( "SetInformation2 request header at 0x%p, response header at 0x%p\n",
                    WorkContext->RequestHeader,
                    WorkContext->ResponseHeader ));
        KdPrint(( "SetInformation2 request parameters at 0x%p, response parameters at 0x%p\n",
                    WorkContext->RequestParameters,
                    WorkContext->ResponseParameters ));
    }

    request = (PREQ_SET_INFORMATION2)WorkContext->RequestParameters;
    response = (PRESP_SET_INFORMATION2)WorkContext->ResponseParameters;

    //
    // Verify the FID.  If verified, the RFCB block is referenced
    // and its addresses is stored in the WorkContext block, and the
    // RFCB address is returned.
    //

    rfcb = SrvVerifyFid(
                WorkContext,
                SmbGetUshort( &request->Fid ),
                TRUE,
                SrvRestartSmbReceived,   // serialize with raw write
                &status
                );

    if ( rfcb == SRV_INVALID_RFCB_POINTER ) {

        if ( !NT_SUCCESS( status ) ) {

            //
            // Invalid file ID or write behind error.  Reject the request.
            //

            IF_DEBUG(ERRORS) {
                KdPrint((
                    "SrvSmbSetInformation2: Status %X on fid 0x%lx\n",
                    status,
                    SmbGetUshort( &request->Fid )
                    ));
            }

            SrvSetSmbError( WorkContext, status );
            SmbStatus = SmbStatusSendResponse;
            goto Cleanup;
        }

        //
        // The work item has been queued because a raw write is in
        // progress.
        //

        SmbStatus = SmbStatusInProgress;
        goto Cleanup;
    }

    if( rfcb->Lfcb->Session->IsSessionExpired )
    {
        status = SESSION_EXPIRED_STATUS_CODE;
        SrvSetSmbError( WorkContext, status );
        SmbStatus = SmbStatusSendResponse;
        goto Cleanup;
    }

    //
    // Verify that the client has write attributes access to the file
    // via the specified handle.
    //

    CHECK_FILE_INFORMATION_ACCESS(
        rfcb->GrantedAccess,
        IRP_MJ_SET_INFORMATION,
        FileBasicInformation,
        &status
        );

    if ( !NT_SUCCESS(status) ) {

        SrvStatistics.GrantedAccessErrors++;

        IF_DEBUG(ERRORS) {
            KdPrint(( "SrvSmbSetInformation2: IoCheckFunctionAccess failed: "
                        "0x%X, GrantedAccess: %lx\n",
                        status, rfcb->GrantedAccess ));
        }

        SrvSetSmbError( WorkContext, status );
        SmbStatus = SmbStatusSendResponse;
        goto Cleanup;
    }

    //
    // Convert the DOS dates and times passed in the SMB to NT TIMEs
    // to pass to NtSetInformationFile.  Note that we zero the rest
    // of the fileBasicInformation structure so that the corresponding
    // fields are not changed.
    //

    RtlZeroMemory( &fileBasicInformation, sizeof(fileBasicInformation) );

    SmbMoveDate( &date, &request->CreationDate );
    SmbMoveTime( &time, &request->CreationTime );
    if ( !SmbIsDateZero(&date) || !SmbIsTimeZero(&time) ) {
        SrvDosTimeToTime( &fileBasicInformation.CreationTime, date, time );
    }

    SmbMoveDate( &date, &request->LastAccessDate );
    SmbMoveTime( &time, &request->LastAccessTime );
    if ( !SmbIsDateZero(&date) || !SmbIsTimeZero(&time) ) {
        SrvDosTimeToTime( &fileBasicInformation.LastAccessTime, date, time );
    }

    SmbMoveDate( &date, &request->LastWriteDate );
    SmbMoveTime( &time, &request->LastWriteTime );
    if ( !SmbIsDateZero(&date) || !SmbIsTimeZero(&time) ) {
        SrvDosTimeToTime( &fileBasicInformation.LastWriteTime, date, time );
    }

    //
    // Call NtSetInformationFile to set the information from the SMB.
    //


    status = NtSetInformationFile(
                 rfcb->Lfcb->FileHandle,
                 &ioStatusBlock,
                 &fileBasicInformation,
                 sizeof(FILE_BASIC_INFORMATION),
                 FileBasicInformation
                 );

    if ( !NT_SUCCESS(status) ) {

        INTERNAL_ERROR(
            ERROR_LEVEL_UNEXPECTED,
            "SrvSmbSetInformation2: NtSetInformationFile failed: %X",
            status,
            NULL
            );

        SrvLogServiceFailure( SRV_SVC_NT_SET_INFO_FILE, status );

        SrvSetSmbError( WorkContext, status );
        SmbStatus = SmbStatusSendResponse;
        goto Cleanup;
    }

#ifdef INCLUDE_SMB_IFMODIFIED
    rfcb->Lfcb->FileUpdated = TRUE;
#endif

    //
    // reset the WrittenTo flag.  This will allow this rfcb to be cached.
    //

    rfcb->WrittenTo = FALSE;

    //
    // Build the response SMB.
    //

    response->WordCount = 0;
    SmbPutUshort( &response->ByteCount, 0 );

    WorkContext->ResponseParameters = NEXT_LOCATION(
                                        response,
                                        RESP_SET_INFORMATION2,
                                        0
                                        );
    SmbStatus = SmbStatusSendResponse;
    IF_DEBUG(TRACE2) KdPrint(( "SrvSmbSetInformation2 complete.\n" ));

Cleanup:
    SrvWmiEndContext(WorkContext);
    return SmbStatus;

} // SrvSmbSetInformation2


STATIC
NTSTATUS
QueryPathOrFileInformation (
    IN PWORK_CONTEXT WorkContext,
    IN PTRANSACTION Transaction,
    IN USHORT InformationLevel,
    IN HANDLE FileHandle,
    OUT PRESP_QUERY_PATH_INFORMATION Response
    )

{
    NTSTATUS status;
    IO_STATUS_BLOCK ioStatusBlock;
    SRV_FILE_INFORMATION fileInformation;
    BOOLEAN queryEaSize;
    USHORT eaErrorOffset;
    PFILE_ALL_INFORMATION fileAllInformation;
    ULONG nameInformationSize;
    PVOID currentLocation;
    ULONG dataSize;

    PUNICODE_STRING pathName;
    ULONG inputBufferLength;
    PPATHNAME_BUFFER inputBuffer;

    PFILE_NAME_INFORMATION nameInfoBuffer;
    PSHARE share;

    PAGED_CODE( );

    Transaction->SetupCount = 0;
    Transaction->ParameterCount = 0;

    if( InformationLevel < SMB_INFO_PASSTHROUGH ) {
        switch ( InformationLevel ) {
        case SMB_INFO_STANDARD:
        case SMB_INFO_QUERY_EA_SIZE:

            //
            // Information level is either STANDARD or QUERY_EA_SIZE.  Both
            // return normal file information; the latter also returns the
            // length of the file's EAs.
            //

            queryEaSize = (BOOLEAN)(InformationLevel == SMB_INFO_QUERY_EA_SIZE);

            status = SrvQueryInformationFile(
                        FileHandle,
                        NULL,
                        &fileInformation,
                        (SHARE_TYPE) -1, // Don't care
                        queryEaSize
                        );

            if ( NT_SUCCESS(status) ) {

                //
                // Build the output parameter and data structures.
                //

                PFILESTATUS fileStatus = (PFILESTATUS)Transaction->OutData;

                Transaction->ParameterCount = sizeof( RESP_QUERY_FILE_INFORMATION );
                SmbPutUshort( &Response->EaErrorOffset, 0 );
                Transaction->DataCount = queryEaSize ? 26 : 22;

                SmbPutDate(
                    &fileStatus->CreationDate,
                    fileInformation.CreationDate
                    );
                SmbPutTime(
                    &fileStatus->CreationTime,
                    fileInformation.CreationTime
                    );

                SmbPutDate(
                    &fileStatus->LastAccessDate,
                    fileInformation.LastAccessDate
                    );
                SmbPutTime(
                    &fileStatus->LastAccessTime,
                    fileInformation.LastAccessTime
                    );

                SmbPutDate(
                    &fileStatus->LastWriteDate,
                    fileInformation.LastWriteDate
                    );
                SmbPutTime(
                    &fileStatus->LastWriteTime,
                    fileInformation.LastWriteTime
                    );

                SmbPutUlong( &fileStatus->DataSize, fileInformation.DataSize.LowPart );
                SmbPutUlong(
                    &fileStatus->AllocationSize,
                    fileInformation.AllocationSize.LowPart
                    );

                SmbPutUshort(
                    &fileStatus->Attributes,
                    fileInformation.Attributes
                    );

                if ( queryEaSize ) {
                    SmbPutUlong( &fileStatus->EaSize, fileInformation.EaSize );
                }

            } else {

                //
                // Set the data count to zero so that no data is returned to the
                // client.
                //

                Transaction->DataCount = 0;

                INTERNAL_ERROR(
                    ERROR_LEVEL_UNEXPECTED,
                    "QueryPathOrFileInformation: SrvQueryInformationFile"
                        "returned %X",
                    status,
                    NULL
                    );

                SrvLogServiceFailure( SRV_SVC_NT_QUERY_INFO_FILE, status );

            }

            break;

        case SMB_INFO_QUERY_EAS_FROM_LIST:
        case SMB_INFO_QUERY_ALL_EAS:

            //
            // The request is for EAs, either all of them or a subset.
            //

            status = SrvQueryOs2FeaList(
                         FileHandle,
                         InformationLevel == SMB_INFO_QUERY_EAS_FROM_LIST ?
                             (PGEALIST)Transaction->InData : NULL,
                         NULL,
                         Transaction->DataCount,
                         (PFEALIST)Transaction->OutData,
                         Transaction->MaxDataCount,
                         &eaErrorOffset
                         );

            if ( NT_SUCCESS(status) ) {

                //
                // The first longword of the OutData buffer holds the length
                // of the remaining data written (the cbList field of the
                // FEALIST).  Add four (the longword itself) to get the number
                // of data bytes written.
                //

                Transaction->DataCount =
                       SmbGetAlignedUlong( (PULONG)Transaction->OutData );

#if     0
                //
                // If there were no EAs, convert the error to
                // STATUS_NO_EAS_ON_FILE.  OS/2 clients expect STATUS_SUCCESS.
                //

                if ( (Transaction->DataCount == 4) &&
                     IS_NT_DIALECT( Transaction->Connection->SmbDialect ) ) {

                    status = STATUS_NO_EAS_ON_FILE;
                }
#endif
            } else {

                IF_DEBUG(ERRORS) {
                    KdPrint(( "QueryPathOrFileInformation: "
                                "SrvQueryOs2FeaList failed: %X\n", status ));
                }

                Transaction->DataCount = 0;
            }

            //
            // Build the output parameter and data structures.
            //

            Transaction->ParameterCount = sizeof( RESP_QUERY_FILE_INFORMATION );
            SmbPutUshort( &Response->EaErrorOffset, eaErrorOffset );

            break;

        case SMB_INFO_IS_NAME_VALID:
            status = STATUS_SUCCESS;
            Transaction->DataCount = 0;

            break;

        case SMB_QUERY_FILE_BASIC_INFO:
        case SMB_QUERY_FILE_STANDARD_INFO:
        case SMB_QUERY_FILE_EA_INFO:
        case SMB_QUERY_FILE_ALT_NAME_INFO:
        case SMB_QUERY_FILE_STREAM_INFO:
        case SMB_QUERY_FILE_COMPRESSION_INFO:

            //
            // Pass the data buffer directly to the file system as it
            // is already in NT format.
            //

            if( Transaction->MaxDataCount <
                MAP_SMB_INFO_TO_MIN_NT_SIZE(QueryFileInformationSize, InformationLevel ) ) {

                //
                // The buffer is too small.  Return an error.
                //
                status = STATUS_INFO_LENGTH_MISMATCH;

            } else {

                status = NtQueryInformationFile(
                             FileHandle,
                             &ioStatusBlock,
                             Transaction->OutData,
                             Transaction->MaxDataCount,
                             MAP_SMB_INFO_TYPE_TO_NT(
                                 QueryFileInformation,
                                 InformationLevel
                                 )
                             );
            }

            SmbPutUshort( &Response->EaErrorOffset, 0 );

            Transaction->ParameterCount = sizeof( RESP_QUERY_FILE_INFORMATION );

            if (NT_SUCCESS( status) || (status == STATUS_BUFFER_OVERFLOW)) {
                Transaction->DataCount = (ULONG)ioStatusBlock.Information;
            } else {
                Transaction->DataCount = 0;
            }

            break;

        case SMB_QUERY_FILE_NAME_INFO:

DoFileNameInfo:
            share = Transaction->TreeConnect->Share;

            nameInfoBuffer = (PFILE_NAME_INFORMATION)Transaction->OutData;

            if ( Transaction->MaxDataCount < FIELD_OFFSET(FILE_NAME_INFORMATION,FileName) ) {

                //
                // The buffer is too small to fit even the fixed part.
                // Return an error.
                //

                status = STATUS_INFO_LENGTH_MISMATCH;
                Transaction->DataCount = 0;

            } else if ( share->ShareType != ShareTypeDisk ) {

                //
                // This is not a disk share.  Pass the request straight to
                // the file system.
                //

                status = NtQueryInformationFile(
                             FileHandle,
                             &ioStatusBlock,
                             nameInfoBuffer,
                             Transaction->MaxDataCount,
                             FileNameInformation
                             );

                Transaction->DataCount = (ULONG)ioStatusBlock.Information;

            } else {

                //
                // We need a temporary buffer since the file system will
                // return the share path together with the file name.  The
                // total length might be larger than the max data allowed
                // in the transaction, though the actual name might fit.
                //

                PFILE_NAME_INFORMATION tempBuffer;
                ULONG tempBufferLength;

                ASSERT( share->QueryNamePrefixLength >= 0 );

                tempBufferLength = Transaction->MaxDataCount + share->QueryNamePrefixLength;

                tempBuffer = ALLOCATE_HEAP( tempBufferLength, BlockTypeBuffer );

                if ( tempBuffer == NULL ) {
                    status = STATUS_INSUFF_SERVER_RESOURCES;
                } else {
                    status = NtQueryInformationFile(
                                 FileHandle,
                                 &ioStatusBlock,
                                 tempBuffer,
                                 tempBufferLength,
                                 FileNameInformation
                                 );
                }

                //
                // remove the share part
                //

                if ( (status == STATUS_SUCCESS) || (status == STATUS_BUFFER_OVERFLOW) ) {

                    LONG bytesToMove;
                    PWCHAR source;
                    WCHAR slash = L'\\';

                    //
                    // Calculate how long the name string is, not including the root prefix.
                    //

                    bytesToMove = (LONG)(tempBuffer->FileNameLength - share->QueryNamePrefixLength);

                    if ( bytesToMove <= 0 ) {

                        //
                        // bytesToMove will be zero if this is the root of
                        // the share.  Return just a \ for this case.
                        //

                        bytesToMove = sizeof(WCHAR);
                        source = &slash;

                    } else {

                        source = tempBuffer->FileName + share->QueryNamePrefixLength/sizeof(WCHAR);

                    }

                    //
                    // Store the actual file name length.
                    //

                    SmbPutUlong( &nameInfoBuffer->FileNameLength, bytesToMove );

                    //
                    // If the buffer isn't big enough, return an error and
                    // reduce the amount to be copied.
                    //

                    if ( (ULONG)bytesToMove >
                         (Transaction->MaxDataCount -
                            FIELD_OFFSET(FILE_NAME_INFORMATION,FileName)) ) {

                        status = STATUS_BUFFER_OVERFLOW;
                        bytesToMove = Transaction->MaxDataCount -
                                    FIELD_OFFSET(FILE_NAME_INFORMATION,FileName);

                    } else {
                        status = STATUS_SUCCESS;
                    }

                    //
                    // Copy all but the prefix.
                    //

                    RtlCopyMemory(
                        nameInfoBuffer->FileName,
                        source,
                        bytesToMove
                        );

                    Transaction->DataCount =
                        FIELD_OFFSET(FILE_NAME_INFORMATION,FileName) + bytesToMove;

                } else {
                    Transaction->DataCount = 0;
                }

                if ( tempBuffer != NULL ) {
                    FREE_HEAP( tempBuffer );
                }

            }

            SmbPutUshort( &Response->EaErrorOffset, 0 );
            Transaction->ParameterCount = sizeof( RESP_QUERY_FILE_INFORMATION );

            break;

        case SMB_QUERY_FILE_ALL_INFO:

DoFileAllInfo:
            //
            // Setup early for the response in case the call to the file
            // system fails.
            //

            SmbPutUshort( &Response->EaErrorOffset, 0 );

            Transaction->ParameterCount = sizeof( RESP_QUERY_FILE_INFORMATION );

            //
            // Allocate a buffer large enough to return all the information.
            // The buffer size we request is the size requested by the client
            // plus room for the extra information returned by the file system
            // that the server doesn't return to the client.
            //

            dataSize = Transaction->MaxDataCount +
                           sizeof( FILE_ALL_INFORMATION )
                           - sizeof( FILE_BASIC_INFORMATION )
                           - sizeof( FILE_STANDARD_INFORMATION )
                           - sizeof( FILE_EA_INFORMATION )
                           - FIELD_OFFSET( FILE_NAME_INFORMATION, FileName );

            fileAllInformation = ALLOCATE_HEAP_COLD( dataSize, BlockTypeDataBuffer );

            if ( fileAllInformation == NULL ) {
                status = STATUS_INSUFFICIENT_RESOURCES;
                break;
            }

            status = NtQueryInformationFile(
                         FileHandle,
                         &ioStatusBlock,
                         fileAllInformation,
                         dataSize,
                         FileAllInformation
                         );

            if ( NT_SUCCESS( status ) ) {

                //
                // Calculate the size of data we will return.  We do not
                // return the entire buffer, just specific fields.
                //

                nameInformationSize =
                    FIELD_OFFSET( FILE_NAME_INFORMATION, FileName ) +
                    fileAllInformation->NameInformation.FileNameLength;

                Transaction->DataCount =
                    sizeof( FILE_BASIC_INFORMATION ) +
                    sizeof( FILE_STANDARD_INFORMATION ) +
                    sizeof( FILE_EA_INFORMATION ) +
                    nameInformationSize;

                //
                // Now copy the data into the transaction buffer.  Start with
                // the fixed sized fields.
                //

                currentLocation = Transaction->OutData;

                *((PFILE_BASIC_INFORMATION)currentLocation)++ =
                     fileAllInformation->BasicInformation;
                *((PFILE_STANDARD_INFORMATION)currentLocation)++ =
                     fileAllInformation->StandardInformation;
                *((PFILE_EA_INFORMATION)currentLocation)++ =
                     fileAllInformation->EaInformation;

                RtlCopyMemory(
                    currentLocation,
                    &fileAllInformation->NameInformation,
                    nameInformationSize
                    );

            } else {
                Transaction->DataCount = 0;
            }

            FREE_HEAP( fileAllInformation );

            break;

        default:
            IF_DEBUG(SMB_ERRORS) {
                KdPrint(( "QueryPathOrFileInformation: bad info level %d\n",
                           InformationLevel ));
            }

            status = STATUS_INVALID_SMB;

            break;
        }

    } else {

        InformationLevel -= SMB_INFO_PASSTHROUGH;

        if( InformationLevel == FileNameInformation ) {
            goto DoFileNameInfo;
        } else if( InformationLevel == FileAllInformation ) {
            goto DoFileAllInfo;
        }

        //
        // See if the supplied parameters are correct.
        //
        status = IoCheckQuerySetFileInformation( InformationLevel,
                                                 Transaction->MaxDataCount,
                                                 FALSE );

        if( NT_SUCCESS( status ) ) {

            //
            // Some information levels require us to impersonate the client.  Do it for all.
            //
            status = IMPERSONATE( WorkContext );

            if( NT_SUCCESS( status ) ) {

                status = NtQueryInformationFile(
                                 FileHandle,
                                 &ioStatusBlock,
                                 Transaction->OutData,
                                 Transaction->MaxDataCount,
                                 InformationLevel
                                 );
                REVERT();
            }
        }

        SmbPutUshort( &Response->EaErrorOffset, 0 );

        Transaction->ParameterCount = sizeof( RESP_QUERY_FILE_INFORMATION );

        if (NT_SUCCESS( status) || (status == STATUS_BUFFER_OVERFLOW)) {
            Transaction->DataCount = (ULONG)ioStatusBlock.Information;
        } else {
            Transaction->DataCount = 0;
        }
    }

    return status;

} // QueryPathOrFileInformation


SMB_TRANS_STATUS
SrvSmbQueryFileInformation (
    IN OUT PWORK_CONTEXT WorkContext
    )

/*++

Routine Description:

    Processes the Query File Information request.  This request arrives
    in a Transaction2 SMB.  Query File Information corresponds to the
    OS/2 DosQFileInfo service.

Arguments:

    WorkContext - Supplies the address of a Work Context Block
        describing the current request.  See smbtypes.h for a more
        complete description of the valid fields.

Return Value:

    SMB_TRANS_STATUS - Indicates whether an error occurred, and, if so,
        whether data should be returned to the client.  See smbtypes.h
        for a more complete description.

--*/

{
    PREQ_QUERY_FILE_INFORMATION request;
    PRESP_QUERY_FILE_INFORMATION response;

    NTSTATUS         status    = STATUS_SUCCESS;
    SMB_TRANS_STATUS SmbStatus = SmbTransStatusInProgress;
    PTRANSACTION transaction;
    PRFCB rfcb;
    USHORT informationLevel;
    ACCESS_MASK grantedAccess;

    PAGED_CODE( );
    if (WorkContext->PreviousSMB == EVENT_TYPE_SMB_LAST_EVENT)
        WorkContext->PreviousSMB = EVENT_TYPE_SMB_QUERY_FILE_INFORMATION;
    SrvWmiStartContext(WorkContext);

    transaction = WorkContext->Parameters.Transaction;
    IF_SMB_DEBUG(QUERY_SET1) {
        KdPrint(( "Query File Information entered; transaction 0x%p\n",
                    transaction ));
    }

    request = (PREQ_QUERY_FILE_INFORMATION)transaction->InParameters;
    response = (PRESP_QUERY_FILE_INFORMATION)transaction->OutParameters;

    //
    // Verify that enough parameter bytes were sent and that we're allowed
    // to return enough parameter bytes.
    //

    if ( (transaction->ParameterCount <
            sizeof(REQ_QUERY_FILE_INFORMATION)) ||
         (transaction->MaxParameterCount <
            sizeof(RESP_QUERY_FILE_INFORMATION)) ) {

        //
        // Not enough parameter bytes were sent.
        //

        IF_SMB_DEBUG(QUERY_SET1) {
            KdPrint(( "SrvSmbQueryFileInformation: bad parameter byte counts: "
                        "%ld %ld\n",
                        transaction->ParameterCount,
                        transaction->MaxParameterCount ));
        }

        SrvSetSmbError( WorkContext, STATUS_INVALID_SMB );
        status    = STATUS_INVALID_SMB;
        SmbStatus = SmbTransStatusErrorWithoutData;
        goto Cleanup;
    }

    //
    // Verify the FID.  If verified, the RFCB block is referenced
    // and its addresses is stored in the WorkContext block, and the
    // RFCB address is returned.
    //

    rfcb = SrvVerifyFid(
                WorkContext,
                SmbGetUshort( &request->Fid ),
                TRUE,
                SrvRestartExecuteTransaction,   // serialize with raw write
                &status
                );

    if ( rfcb == SRV_INVALID_RFCB_POINTER ) {

        if ( !NT_SUCCESS( status ) ) {

            //
            // Invalid file ID or write behind error.  Reject the request.
            //

            IF_DEBUG(ERRORS) {
                KdPrint((
                    "SrvSmbQueryFileInformation: Status %X on FID: 0x%lx\n",
                    status,
                    SmbGetUshort( &request->Fid )
                    ));
            }

            SrvSetSmbError( WorkContext, status );
            SmbStatus = SmbTransStatusErrorWithoutData;
            goto Cleanup;
        }

        //
        // The work item has been queued because a raw write is in
        // progress.
        //

        SmbStatus = SmbTransStatusInProgress;
        goto Cleanup;
    }

    //
    //
    // Verify the information level and the number of input and output
    // data bytes available.
    //

    informationLevel = SmbGetUshort( &request->InformationLevel );
    grantedAccess = rfcb->GrantedAccess;

    status = STATUS_SUCCESS;

    if( informationLevel < SMB_INFO_PASSTHROUGH ) {

        switch ( informationLevel ) {

        case SMB_INFO_STANDARD:

            if ( transaction->MaxDataCount < 22 ) {
                IF_DEBUG(SMB_ERRORS) {
                    KdPrint(( "SrvSmbQueryFileInformation: invalid MaxDataCount "
                                "%ld\n", transaction->MaxDataCount ));
                }
                status = STATUS_INVALID_SMB;
                break;
            }

            //
            // Verify that the client has read attributes access to the file
            // via the specified handle.
            //

            CHECK_FILE_INFORMATION_ACCESS(
                grantedAccess,
                IRP_MJ_QUERY_INFORMATION,
                FileBasicInformation,
                &status
                );

            IF_DEBUG(ERRORS) {
                if ( !NT_SUCCESS(status) ) {
                    KdPrint(( "SrvSmbQueryFileInformation: IoCheckFunctionAccess "
                                "failed: 0x%X, GrantedAccess: %lx\n",
                                status, grantedAccess ));
                }
            }

            break;

        case SMB_INFO_QUERY_EA_SIZE:

            if ( transaction->MaxDataCount < 26 ) {
                IF_DEBUG(SMB_ERRORS) {
                    KdPrint(( "SrvSmbQueryFileInformation: invalid MaxDataCount "
                                "%ld\n", transaction->MaxDataCount ));
                }
                status = STATUS_INVALID_SMB;
                break;
            }

            //
            // Verify that the client has read EA access to the file via the
            // specified handle.
            //

            CHECK_FILE_INFORMATION_ACCESS(
                grantedAccess,
                IRP_MJ_QUERY_INFORMATION,
                FileEaInformation,
                &status
                );

            IF_DEBUG(SMB_ERRORS) {
                if ( !NT_SUCCESS(status) ) {
                    KdPrint(( "SrvSmbQueryFileInformation: IoCheckFunctionAccess "
                                "failed: 0x%X, GrantedAccess: %lx\n",
                                status, grantedAccess ));
                }
            }

            break;

        case SMB_INFO_QUERY_EAS_FROM_LIST:
        case SMB_INFO_QUERY_ALL_EAS:


            //
            // Verify that the client has read EA access to the file via the
            // specified handle.
            //

            CHECK_FUNCTION_ACCESS(
                grantedAccess,
                IRP_MJ_QUERY_EA,
                0,
                0,
                &status
                );

            IF_DEBUG(ERRORS) {
                if ( !NT_SUCCESS(status) ) {
                    KdPrint(( "SrvSmbQueryFileInformation: IoCheckFunctionAccess "
                                "failed: 0x%X, GrantedAccess: %lx\n",
                                status, grantedAccess ));
                }
            }

            break;


        case SMB_QUERY_FILE_BASIC_INFO:

            CHECK_FILE_INFORMATION_ACCESS(
                grantedAccess,
                IRP_MJ_QUERY_INFORMATION,
                FileBasicInformation,
                &status
                );

            IF_DEBUG(ERRORS) {
                if ( !NT_SUCCESS(status) ) {
                    KdPrint(( "SrvSmbQueryFileInformation: IoCheckFunctionAccess "
                                "failed: 0x%X, GrantedAccess: %lx\n",
                                status, grantedAccess ));
                }
            }

            break;

        case SMB_QUERY_FILE_STANDARD_INFO:

            CHECK_FILE_INFORMATION_ACCESS(
                grantedAccess,
                IRP_MJ_QUERY_INFORMATION,
                FileStandardInformation,
                &status
                );

            IF_DEBUG(ERRORS) {
                if ( !NT_SUCCESS(status) ) {
                    KdPrint(( "SrvSmbQueryFileInformation: IoCheckFunctionAccess "
                                "failed: 0x%X, GrantedAccess: %lx\n",
                                status, grantedAccess ));
                }
            }

            break;

        case SMB_QUERY_FILE_EA_INFO:

            CHECK_FILE_INFORMATION_ACCESS(
                grantedAccess,
                IRP_MJ_QUERY_INFORMATION,
                FileEaInformation,
                &status
                );

            IF_DEBUG(ERRORS) {
                if ( !NT_SUCCESS(status) ) {
                    KdPrint(( "SrvSmbQueryFileInformation: IoCheckFunctionAccess "
                                "failed: 0x%X, GrantedAccess: %lx\n",
                                status, grantedAccess ));
                }
            }

            break;

        case SMB_QUERY_FILE_NAME_INFO:

            CHECK_FILE_INFORMATION_ACCESS(
                grantedAccess,
                IRP_MJ_QUERY_INFORMATION,
                FileNameInformation,
                &status
                );

            IF_DEBUG(ERRORS) {
                if ( !NT_SUCCESS(status) ) {
                    KdPrint(( "SrvSmbQueryFileInformation: IoCheckFunctionAccess "
                                "failed: 0x%X, GrantedAccess: %lx\n",
                                status, grantedAccess ));
                }
            }

            break;

        case SMB_QUERY_FILE_ALL_INFO:

            CHECK_FILE_INFORMATION_ACCESS(
                grantedAccess,
                IRP_MJ_QUERY_INFORMATION,
                FileAllInformation,
                &status
                );

            IF_DEBUG(ERRORS) {
                if ( !NT_SUCCESS(status) ) {
                    KdPrint(( "SrvSmbQueryFileInformation: IoCheckFunctionAccess "
                                "failed: 0x%X, GrantedAccess: %lx\n",
                                status, grantedAccess ));
                }
            }

            break;

        case SMB_QUERY_FILE_ALT_NAME_INFO:

            CHECK_FILE_INFORMATION_ACCESS(
                grantedAccess,
                IRP_MJ_QUERY_INFORMATION,
                FileAlternateNameInformation,
                &status
                );

            IF_DEBUG(ERRORS) {
                if ( !NT_SUCCESS(status) ) {
                    KdPrint(( "SrvSmbQueryFileInformation: IoCheckFunctionAccess "
                                "failed: 0x%X, GrantedAccess: %lx\n",
                                status, grantedAccess ));
                }
            }

            break;

        case SMB_QUERY_FILE_STREAM_INFO:

            CHECK_FILE_INFORMATION_ACCESS(
                grantedAccess,
                IRP_MJ_QUERY_INFORMATION,
                FileStreamInformation,
                &status
                );

            IF_DEBUG(ERRORS) {
                if ( !NT_SUCCESS(status) ) {
                    KdPrint(( "SrvSmbQueryFileInformation: IoCheckFunctionAccess "
                                "failed: 0x%X, GrantedAccess: %lx\n",
                                status, grantedAccess ));
                }
            }

            break;

        case SMB_QUERY_FILE_COMPRESSION_INFO:

            CHECK_FILE_INFORMATION_ACCESS(
                grantedAccess,
                IRP_MJ_QUERY_INFORMATION,
                FileCompressionInformation,
                &status
                );

            IF_DEBUG(ERRORS) {
                if ( !NT_SUCCESS(status) ) {
                    KdPrint(( "SrvSmbQueryFileInformation: IoCheckFunctionAccess "
                                "failed: 0x%X, GrantedAccess: %lx\n",
                                status, grantedAccess ));
                }
            }

            break;

        default:

            IF_DEBUG(SMB_ERRORS) {
                KdPrint(( "SrvSmbQueryFileInformation: invalid info level %ld\n",
                            informationLevel ));
            }

            status = STATUS_OS2_INVALID_LEVEL;
            break;
        }

    } else {

        if( informationLevel - SMB_INFO_PASSTHROUGH >= FileMaximumInformation ) {
            status = STATUS_INVALID_INFO_CLASS;
        }

        if( NT_SUCCESS( status ) ) {
            status = IoCheckQuerySetFileInformation( informationLevel - SMB_INFO_PASSTHROUGH,
                                                 0xFFFFFFFF,
                                                 FALSE
                                                );
        }

        if( NT_SUCCESS( status ) ) {
            CHECK_FILE_INFORMATION_ACCESS(
                grantedAccess,
                IRP_MJ_QUERY_INFORMATION,
                informationLevel - SMB_INFO_PASSTHROUGH,
                &status
            );
        }
    }

    if ( !NT_SUCCESS(status) ) {

        SrvSetSmbError( WorkContext, status );
        SmbStatus = SmbTransStatusErrorWithoutData;
        goto Cleanup;
    }

    //
    // Get the necessary information about the file.
    //

    status = QueryPathOrFileInformation(
                 WorkContext,
                 transaction,
                 informationLevel,
                 rfcb->Lfcb->FileHandle,
                 (PRESP_QUERY_PATH_INFORMATION)response
                 );

    //
    // Map STATUS_BUFFER_OVERFLOW for OS/2 clients.
    //

    if ( status == STATUS_BUFFER_OVERFLOW &&
         !IS_NT_DIALECT( WorkContext->Connection->SmbDialect ) ) {

        status = STATUS_BUFFER_TOO_SMALL;

    }

    //
    // If an error occurred, return an appropriate response.
    //

    if ( !NT_SUCCESS(status) ) {

        //
        // QueryPathOrFileInformation already filled in the response
        // information, so just set the error and return.
        //

        SrvSetSmbError2( WorkContext, status, TRUE );
        SmbStatus = SmbTransStatusErrorWithData;
        goto Cleanup;
    }
    SmbStatus = SmbTransStatusSuccess;
    IF_DEBUG(TRACE2) KdPrint(( "SrvSmbQueryFileInformation complete.\n" ));

Cleanup:
    SrvWmiEndContext(WorkContext);
    return SmbStatus;

} // SrvSmbQueryFileInformation


SMB_TRANS_STATUS
SrvSmbQueryPathInformation (
    IN OUT PWORK_CONTEXT WorkContext
    )
/*++

Routine Description:

    Processes the Query Path Information request.  This request arrives
    in a Transaction2 SMB.  Query Path Information corresponds to the
    OS/2 DosQPathInfo service.

Arguments:

    WorkContext - Supplies the address of a Work Context Block
        describing the current request.  See smbtypes.h for a more
        complete description of the valid fields.

Return Value:

    SMB_TRANS_STATUS - Indicates whether an error occurred, and, if so,
        whether data should be returned to the client.  See smbtypes.h
        for a more complete description.

--*/
{
    PTRANSACTION transaction;
    PREQ_QUERY_PATH_INFORMATION request;
    PRESP_QUERY_PATH_INFORMATION response;
    USHORT informationLevel;
    NTSTATUS         status    = STATUS_SUCCESS;
    HANDLE fileHandle;
    IO_STATUS_BLOCK ioStatusBlock;
    OBJECT_ATTRIBUTES objectAttributes;
    UNICODE_STRING objectName;
    BOOLEAN isUnicode;

    SMB_TRANS_STATUS smbStatus = SmbTransStatusInProgress;
    ACCESS_MASK desiredAccess;

    PAGED_CODE( );
    if (WorkContext->PreviousSMB == EVENT_TYPE_SMB_LAST_EVENT)
        WorkContext->PreviousSMB = EVENT_TYPE_SMB_QUERY_PATH_INFORMATION;
    SrvWmiStartContext(WorkContext);

    transaction = WorkContext->Parameters.Transaction;

    IF_SMB_DEBUG(QUERY_SET1) {
        KdPrint(( "Query Path Information entered; transaction 0x%p\n",
                    transaction ));
    }

    //
    // Verify that enough parameter bytes were sent and that we're allowed
    // to return enough parameter bytes.
    //
    if ( (transaction->ParameterCount <
            sizeof(REQ_QUERY_PATH_INFORMATION)) ||
         (transaction->MaxParameterCount <
            sizeof(RESP_QUERY_PATH_INFORMATION)) ) {

        //
        // Not enough parameter bytes were sent.
        //

        IF_DEBUG(SMB_ERRORS) {
            KdPrint(( "SrvSmbQueryPathInformation: bad parameter byte "
                        "counts: %ld %ld\n",
                        transaction->ParameterCount,
                        transaction->MaxParameterCount ));
        }

        SrvSetSmbError( WorkContext, STATUS_INVALID_SMB );
        status    = STATUS_INVALID_SMB;
        smbStatus = SmbTransStatusErrorWithoutData;
        goto Cleanup;
    }

    request = (PREQ_QUERY_PATH_INFORMATION)transaction->InParameters;
    informationLevel = SmbGetUshort( &request->InformationLevel );

    //
    // The response formats for Query Path and Query File and identical,
    // so just use the RESP_QUERY_PATH_INFORMATION structure for both.
    // The request formats differ, so conditionalize access to them.
    //
    response = (PRESP_QUERY_PATH_INFORMATION)transaction->OutParameters;

    switch( informationLevel ) {
    case SMB_INFO_QUERY_EA_SIZE:
    case SMB_INFO_QUERY_EAS_FROM_LIST:
    case SMB_INFO_QUERY_ALL_EAS:

        //
        // For these info levels, we must be in a blocking thread because we
        // might end up waiting for an oplock break.
        //
        if( WorkContext->UsingBlockingThread == 0 ) {
            WorkContext->FspRestartRoutine = SrvRestartExecuteTransaction;
            SrvQueueWorkToBlockingThread( WorkContext );
            smbStatus = SmbTransStatusInProgress;
            goto Cleanup;
        }
        desiredAccess = FILE_READ_EA;
        break;

    default:
        desiredAccess = FILE_READ_ATTRIBUTES;
        break;
    }

    //
    // Make sure the client is allowed to do this, if we have an Admin share
    //
    status = SrvIsAllowedOnAdminShare( WorkContext, WorkContext->TreeConnect->Share );
    if( !NT_SUCCESS( status ) ) {
        SrvSetSmbError( WorkContext, status );
        smbStatus = SmbTransStatusErrorWithoutData;
        goto Cleanup;
    }

    //
    // Get the path name of the file to open relative to the share.
    //

    isUnicode = SMB_IS_UNICODE( WorkContext );

    status = SrvCanonicalizePathName(
            WorkContext,
            WorkContext->TreeConnect->Share,
            NULL,
            request->Buffer,
            END_OF_TRANSACTION_PARAMETERS( transaction ),
            TRUE,
            isUnicode,
            &objectName
            );

    if( !NT_SUCCESS( status ) ) {

        IF_DEBUG(SMB_ERRORS) {
            KdPrint(( "SrvSmbQueryPathInformation: bad path name: %s\n",
                        request->Buffer ));
        }

        SrvSetSmbError( WorkContext, status );
        smbStatus = SmbTransStatusErrorWithoutData;
        goto Cleanup;
    }

    //
    // Special case: If this is the IS_PATH_VALID information level, then
    // the user just wants to know if the path syntax is correct.  Do not
    // attempt to open the file.
    //

    informationLevel = SmbGetUshort( &request->InformationLevel );

    if ( informationLevel == SMB_INFO_IS_NAME_VALID ) {

        transaction->InData = (PVOID)&objectName;

        //
        // Get the Share root handle.
        //
        smbStatus = SrvGetShareRootHandle( WorkContext->TreeConnect->Share );

        if ( !NT_SUCCESS(smbStatus) ) {

            IF_DEBUG(ERRORS) {
                KdPrint(( "SrvSmbQueryPathInformation: SrvGetShareRootHandle failed %x.\n",
                            smbStatus ));
            }

            if (!isUnicode) {
                RtlFreeUnicodeString( &objectName );
            }

            SrvSetSmbError( WorkContext, smbStatus );
            status    = smbStatus;
            smbStatus = SmbTransStatusErrorWithoutData;
            goto Cleanup;
        }

        status = SrvSnapGetRootHandle( WorkContext, &WorkContext->Parameters2.FileInformation.FileHandle );
        if( !NT_SUCCESS(status) )
        {
            SrvSetSmbError( WorkContext, status );
            smbStatus = SmbTransStatusErrorWithoutData;
            goto Cleanup;
        }


        smbStatus = GenerateQueryPathInfoResponse(
                       WorkContext,
                       SmbTransStatusSuccess
                       );

        //
        // Release the root handle for removable devices
        //

        SrvReleaseShareRootHandle( WorkContext->TreeConnect->Share );

        if ( !isUnicode ) {
            RtlFreeUnicodeString( &objectName );
        }
        goto Cleanup;
    }

    //
    // Initialize the object attributes structure.
    //

    SrvInitializeObjectAttributes_U(
        &objectAttributes,
        &objectName,
        (WorkContext->RequestHeader->Flags & SMB_FLAGS_CASE_INSENSITIVE ||
         transaction->Session->UsingUppercasePaths) ?
            OBJ_CASE_INSENSITIVE : 0L,
        NULL,
        NULL
        );

    //
    // Take the fast path for this if we can
    //
    if( informationLevel == SMB_QUERY_FILE_BASIC_INFO ) {

        FILE_NETWORK_OPEN_INFORMATION fileInformation;
        UNALIGNED FILE_BASIC_INFORMATION *pbInfo = (PFILE_BASIC_INFORMATION)transaction->OutData;

        if( transaction->MaxDataCount < sizeof( FILE_BASIC_INFORMATION ) ) {
            SrvSetSmbError( WorkContext, STATUS_INFO_LENGTH_MISMATCH );
            status    = STATUS_INFO_LENGTH_MISMATCH;
            smbStatus = SmbTransStatusErrorWithoutData;
            goto Cleanup;
        }

        status = IMPERSONATE( WorkContext );

        if( NT_SUCCESS( status ) ) {

            status = SrvGetShareRootHandle( transaction->TreeConnect->Share );

            if( NT_SUCCESS( status ) ) {

                //
                // The file name is always relative to the share root
                //
                status = SrvSnapGetRootHandle( WorkContext, &objectAttributes.RootDirectory );
                if( !NT_SUCCESS(status) )
                {
                    goto SnapError;
                }

                //
                // Get the information
                //
                if( IoFastQueryNetworkAttributes(
                        &objectAttributes,
                        FILE_READ_ATTRIBUTES,
                        0,
                        &ioStatusBlock,
                        &fileInformation
                        ) == FALSE ) {

                    SrvLogServiceFailure( SRV_SVC_IO_FAST_QUERY_NW_ATTRS, 0 );
                    ioStatusBlock.Status = STATUS_OBJECT_PATH_NOT_FOUND;
                }

                status = ioStatusBlock.Status;

                //
                // If the media was changed and we can come up with a new share root handle,
                //  then we should retry the operation
                //
                if( SrvRetryDueToDismount( transaction->TreeConnect->Share, status ) ) {

                    status = SrvSnapGetRootHandle( WorkContext, &objectAttributes.RootDirectory );
                    if( !NT_SUCCESS(status) )
                    {
                        goto SnapError;
                    }

                    //
                    // Get the information
                    //
                    if( IoFastQueryNetworkAttributes(
                            &objectAttributes,
                            FILE_READ_ATTRIBUTES,
                            0,
                            &ioStatusBlock,
                            &fileInformation
                            ) == FALSE ) {

                        SrvLogServiceFailure( SRV_SVC_IO_FAST_QUERY_NW_ATTRS, 0 );
                        ioStatusBlock.Status = STATUS_OBJECT_PATH_NOT_FOUND;
                    }

                    status = ioStatusBlock.Status;
                }

SnapError:

                SrvReleaseShareRootHandle( transaction->TreeConnect->Share );
            }

            REVERT();
        }

        if( status == STATUS_BUFFER_OVERFLOW ) {
            goto hard_way;
        }

        if ( !isUnicode ) {
            RtlFreeUnicodeString( &objectName );
        }

        if ( !NT_SUCCESS( status ) ) {
            if ( status == STATUS_ACCESS_DENIED ) {
                SrvStatistics.AccessPermissionErrors++;
            }

            IF_DEBUG(ERRORS) {
                KdPrint(( "SrvSmbQueryPathInformation: IoFastQueryNetworkAttributes "
                    "failed: %X\n", status ));
            }

            SrvSetSmbError( WorkContext, status );
            smbStatus = SmbTransStatusErrorWithoutData;
            goto Cleanup;
        }

        // FORMULATE THE RESPONSE

        transaction->SetupCount = 0;
        transaction->DataCount = sizeof( *pbInfo );
        transaction->ParameterCount = sizeof( RESP_QUERY_FILE_INFORMATION );

        SmbPutUshort( &response->EaErrorOffset, 0 );

        pbInfo->CreationTime =   fileInformation.CreationTime;
        pbInfo->LastAccessTime = fileInformation.LastAccessTime;
        pbInfo->LastWriteTime =  fileInformation.LastWriteTime;
        pbInfo->ChangeTime =     fileInformation.ChangeTime;
        pbInfo->FileAttributes = fileInformation.FileAttributes;

        smbStatus = SmbTransStatusSuccess;
        goto Cleanup;
    }

hard_way:

    IF_SMB_DEBUG(QUERY_SET2) KdPrint(( "Opening file %wZ\n", &objectName ));

    //
    // Open the file -- must be opened in order to have a handle to pass
    // to NtQueryInformationFile.  We will close it after getting the
    // necessary information.
    //
    INCREMENT_DEBUG_STAT( SrvDbgStatistics.TotalOpenAttempts );
    INCREMENT_DEBUG_STAT( SrvDbgStatistics.TotalOpensForPathOperations );

    //
    // !!! We may block if the file is oplocked.  We must do this, because
    //     it is required to get the FS to break a batch oplock.
    //     We should figure out a way to do this without blocking.
    //

    status = SrvIoCreateFile(
                 WorkContext,
                 &fileHandle,
                 desiredAccess,
                 &objectAttributes,
                 &ioStatusBlock,
                 NULL,                                      // AllocationSize
                 0,                                         // FileAttributes
                 FILE_SHARE_READ | FILE_SHARE_WRITE |
                    FILE_SHARE_DELETE,                      // ShareAccess
                 FILE_OPEN,                                 // Disposition
                 FILE_OPEN_REPARSE_POINT,                   // CreateOptions
                 NULL,                                      // EaBuffer
                 0,                                         // EaLength
                 CreateFileTypeNone,
                 NULL,                                      // ExtraCreateParameters
                 IO_FORCE_ACCESS_CHECK,                     // Options
                 transaction->TreeConnect->Share
                 );

    if( status == STATUS_INVALID_PARAMETER ) {
        status = SrvIoCreateFile(
                     WorkContext,
                     &fileHandle,
                     desiredAccess,
                     &objectAttributes,
                     &ioStatusBlock,
                     NULL,                                      // AllocationSize
                     0,                                         // FileAttributes
                     FILE_SHARE_READ | FILE_SHARE_WRITE |
                        FILE_SHARE_DELETE,                      // ShareAccess
                     FILE_OPEN,                                 // Disposition
                     0,                                         // CreateOptions
                     NULL,                                      // EaBuffer
                     0,                                         // EaLength
                     CreateFileTypeNone,
                     NULL,                                      // ExtraCreateParameters
                     IO_FORCE_ACCESS_CHECK,                     // Options
                     transaction->TreeConnect->Share
                     );
    }

    if ( NT_SUCCESS(status) ) {
        SRVDBG_CLAIM_HANDLE( fileHandle, "FIL", 21, 0 );
    }
    else {
        SrvSetSmbError( WorkContext, status );
        smbStatus = SmbTransStatusErrorWithoutData;
        goto Cleanup;
    }

    if ( !isUnicode ) {
        RtlFreeUnicodeString( &objectName );
    }

    //
    // Save a copy of the file handle for the restart routine.
    //

    WorkContext->Parameters2.FileInformation.FileHandle = fileHandle;

    ASSERT( status != STATUS_OPLOCK_BREAK_IN_PROGRESS );

    smbStatus = GenerateQueryPathInfoResponse( WorkContext, status );

Cleanup:
    SrvWmiEndContext(WorkContext);
    return smbStatus;

} // SrvSmbQueryPathInformation


SMB_TRANS_STATUS
GenerateQueryPathInfoResponse (
    IN PWORK_CONTEXT WorkContext,
    IN NTSTATUS OpenStatus
    )

/*++

Routine Description:

    This function completes processing for and generates a response to a
    query path information response SMB.

Arguments:

    WorkContext - A pointer to the work context block for this SMB
    OpenStatus - The completion status of the open.

Return Value:

    The status of the SMB processing.

--*/

{
    PREQ_QUERY_PATH_INFORMATION request;
    PRESP_QUERY_PATH_INFORMATION response;
    PTRANSACTION transaction;

    NTSTATUS status;
    BOOLEAN error;
    HANDLE fileHandle;
    USHORT informationLevel;

    PFILE_OBJECT fileObject;
    OBJECT_HANDLE_INFORMATION handleInformation;

    PAGED_CODE( );

    transaction = WorkContext->Parameters.Transaction;
    IF_SMB_DEBUG(QUERY_SET1) {
        KdPrint(( "Query Path Information entered; transaction 0x%p\n",
                    transaction ));
    }

    request = (PREQ_QUERY_PATH_INFORMATION)transaction->InParameters;
    response = (PRESP_QUERY_PATH_INFORMATION)transaction->OutParameters;

    fileHandle = WorkContext->Parameters2.FileInformation.FileHandle;

    //
    // If the user didn't have this permission, update the
    // statistics database.
    //

    if ( OpenStatus == STATUS_ACCESS_DENIED ) {
        SrvStatistics.AccessPermissionErrors++;
    }

    if ( !NT_SUCCESS( OpenStatus ) ) {

        IF_DEBUG(ERRORS) {
            KdPrint(( "GenerateQueryPathInfoResponse: SrvIoCreateFile failed: %X\n", OpenStatus ));
        }

        SrvSetSmbError( WorkContext, OpenStatus );

        return SmbTransStatusErrorWithoutData;
    }

    IF_SMB_DEBUG(QUERY_SET2) {
        KdPrint(( "SrvIoCreateFile succeeded, handle = 0x%p\n", fileHandle ));
    }

    //
    // Find out the access the user has.
    //

    status = ObReferenceObjectByHandle(
                fileHandle,
                0,
                NULL,
                KernelMode,
                (PVOID *)&fileObject,
                &handleInformation
                );

    if ( !NT_SUCCESS(status) ) {

        SrvLogServiceFailure( SRV_SVC_OB_REF_BY_HANDLE, status );

        //
        // This internal error bugchecks the system.
        //

        INTERNAL_ERROR(
            ERROR_LEVEL_IMPOSSIBLE,
            "GenerateQueryPathInfoResponse: unable to reference file handle 0x%lx",
            fileHandle,
            NULL
            );

        SrvSetSmbError( WorkContext, OpenStatus );
        return SmbTransStatusErrorWithoutData;

    }

    ObDereferenceObject( fileObject );

    //
    // Verify the information level and the number of input and output
    // data bytes available.
    //

    informationLevel = SmbGetUshort( &request->InformationLevel );

    error = FALSE;

    if( informationLevel < SMB_INFO_PASSTHROUGH ) {

        switch ( informationLevel ) {

        case SMB_INFO_STANDARD:
            if ( transaction->MaxDataCount < 22 ) {
                IF_SMB_DEBUG(QUERY_SET1) {
                    KdPrint(( "GenerateQueryPathInfoResponse: invalid "
                                "MaxDataCount %ld\n", transaction->MaxDataCount ));
                }
                error = TRUE;
            }
            break;

        case SMB_INFO_QUERY_EA_SIZE:
            if ( transaction->MaxDataCount < 26 ) {
                IF_DEBUG(SMB_ERRORS) {
                    KdPrint(( "GenerateQueryPathInfoResponse: invalid "
                                "MaxDataCount %ld\n", transaction->MaxDataCount ));
                }
                error = TRUE;
            }
            break;

        case SMB_INFO_QUERY_EAS_FROM_LIST:
        case SMB_INFO_QUERY_ALL_EAS:
            if ( transaction->MaxDataCount < 4 ) {
                IF_DEBUG(SMB_ERRORS) {
                    KdPrint(( "GenerateQueryPathInfoResponse: invalid "
                                "MaxDataCount %ld\n", transaction->MaxDataCount ));
                }
                error = TRUE;
            }
            break;

        case SMB_INFO_IS_NAME_VALID:
            break;

        case SMB_QUERY_FILE_BASIC_INFO:

            CHECK_FILE_INFORMATION_ACCESS(
                handleInformation.GrantedAccess,
                IRP_MJ_QUERY_INFORMATION,
                FileBasicInformation,
                &status
                );

            IF_DEBUG(ERRORS) {
                if ( !NT_SUCCESS(status) ) {
                    KdPrint(( "SrvSmbQueryFileInformation: IoCheckFunctionAccess "
                                "failed: 0x%X, GrantedAccess: %lx\n",
                                status, handleInformation.GrantedAccess ));
                }
            }

            break;

        case SMB_QUERY_FILE_STANDARD_INFO:

            CHECK_FILE_INFORMATION_ACCESS(
                handleInformation.GrantedAccess,
                IRP_MJ_QUERY_INFORMATION,
                FileStandardInformation,
                &status
                );

            IF_DEBUG(ERRORS) {
                if ( !NT_SUCCESS(status) ) {
                    KdPrint(( "SrvSmbQueryFileInformation: IoCheckFunctionAccess "
                                "failed: 0x%X, GrantedAccess: %lx\n",
                                status, handleInformation.GrantedAccess ));
                }
            }

            break;

        case SMB_QUERY_FILE_EA_INFO:

            CHECK_FILE_INFORMATION_ACCESS(
                handleInformation.GrantedAccess,
                IRP_MJ_QUERY_INFORMATION,
                FileEaInformation,
                &status
                );

            IF_DEBUG(ERRORS) {
                if ( !NT_SUCCESS(status) ) {
                    KdPrint(( "SrvSmbQueryFileInformation: IoCheckFunctionAccess "
                                "failed: 0x%X, GrantedAccess: %lx\n",
                                status, handleInformation.GrantedAccess ));
                }
            }

            break;

        case SMB_QUERY_FILE_NAME_INFO:

            CHECK_FILE_INFORMATION_ACCESS(
                handleInformation.GrantedAccess,
                IRP_MJ_QUERY_INFORMATION,
                FileNameInformation,
                &status
                );

            IF_DEBUG(ERRORS) {
                if ( !NT_SUCCESS(status) ) {
                    KdPrint(( "SrvSmbQueryFileInformation: IoCheckFunctionAccess "
                                "failed: 0x%X, GrantedAccess: %lx\n",
                                status, handleInformation.GrantedAccess ));
                }
            }

            break;

        case SMB_QUERY_FILE_ALL_INFO:

            CHECK_FILE_INFORMATION_ACCESS(
                handleInformation.GrantedAccess,
                IRP_MJ_QUERY_INFORMATION,
                FileAllInformation,
                &status
                );

            IF_DEBUG(ERRORS) {
                if ( !NT_SUCCESS(status) ) {
                    KdPrint(( "SrvSmbQueryFileInformation: IoCheckFunctionAccess "
                                "failed: 0x%X, GrantedAccess: %lx\n",
                                status, handleInformation.GrantedAccess ));
                }
            }

            break;

        case SMB_QUERY_FILE_ALT_NAME_INFO:

            CHECK_FILE_INFORMATION_ACCESS(
                handleInformation.GrantedAccess,
                IRP_MJ_QUERY_INFORMATION,
                FileAlternateNameInformation,
                &status
                );

            IF_DEBUG(ERRORS) {
                if ( !NT_SUCCESS(status) ) {
                    KdPrint(( "SrvSmbQueryFileInformation: IoCheckFunctionAccess "
                                "failed: 0x%X, GrantedAccess: %lx\n",
                                status, handleInformation.GrantedAccess ));
                }
            }

            break;

        case SMB_QUERY_FILE_STREAM_INFO:

            CHECK_FILE_INFORMATION_ACCESS(
                handleInformation.GrantedAccess,
                IRP_MJ_QUERY_INFORMATION,
                FileStreamInformation,
                &status
                );

            IF_DEBUG(ERRORS) {
                if ( !NT_SUCCESS(status) ) {
                    KdPrint(( "SrvSmbQueryFileInformation: IoCheckFunctionAccess "
                                "failed: 0x%X, GrantedAccess: %lx\n",
                                status, handleInformation.GrantedAccess ));
                }
            }

            break;

        case SMB_QUERY_FILE_COMPRESSION_INFO:

            CHECK_FILE_INFORMATION_ACCESS(
                handleInformation.GrantedAccess,
                IRP_MJ_QUERY_INFORMATION,
                FileCompressionInformation,
                &status
                );

            IF_DEBUG(ERRORS) {
                if ( !NT_SUCCESS(status) ) {
                    KdPrint(( "SrvSmbQueryFileInformation: IoCheckFunctionAccess "
                                "failed: 0x%X, GrantedAccess: %lx\n",
                                status, handleInformation.GrantedAccess ));
                }
            }

            break;

        default:
            IF_DEBUG(SMB_ERRORS) {
                KdPrint(( "GenerateQueryPathInfoResponse: invalid info level"
                          "%ld\n", informationLevel ));
            }
            error = TRUE;
            break;
        }

    } else {

        if( informationLevel - SMB_INFO_PASSTHROUGH >= FileMaximumInformation ) {
            status = STATUS_INVALID_INFO_CLASS;
        }

        if( NT_SUCCESS( status ) ) {
            status = IoCheckQuerySetFileInformation( informationLevel - SMB_INFO_PASSTHROUGH,
                                                 0xFFFFFFFF,
                                                 FALSE
                                                );
        }

        if( NT_SUCCESS( status ) ) {
            CHECK_FILE_INFORMATION_ACCESS(
                handleInformation.GrantedAccess,
                IRP_MJ_QUERY_INFORMATION,
                informationLevel - SMB_INFO_PASSTHROUGH,
                &status
            );

        } else {

            error = TRUE;

        }
    }

    if ( error ) {

        SRVDBG_RELEASE_HANDLE( fileHandle, "FIL", 32, 0 );
        SrvNtClose( fileHandle, TRUE );
        SrvSetSmbError( WorkContext, STATUS_OS2_INVALID_LEVEL );
        return SmbTransStatusErrorWithoutData;
    }

    //
    // Get the necessary information about the file.
    //

    status = QueryPathOrFileInformation(
                 WorkContext,
                 transaction,
                 informationLevel,
                 fileHandle,
                 (PRESP_QUERY_PATH_INFORMATION)response
                 );

    //
    // Map STATUS_BUFFER_OVERFLOW for OS/2 clients.
    //

    if ( status == STATUS_BUFFER_OVERFLOW &&
         !IS_NT_DIALECT( WorkContext->Connection->SmbDialect ) ) {

        status = STATUS_BUFFER_TOO_SMALL;

    }

    //
    // Close the file--it was only opened to read the attributes.
    //

    if ( informationLevel != SMB_INFO_IS_NAME_VALID ) {
        SRVDBG_RELEASE_HANDLE( fileHandle, "FIL", 33, 0 );
        SrvNtClose( fileHandle, TRUE );
    }

    //
    // If an error occurred, return an appropriate response.
    //

    if ( !NT_SUCCESS(status) ) {

        //
        // QueryPathOrFileInformation already set the response parameters,
        // so just return an error condition.
        //

        SrvSetSmbError2( WorkContext, status, TRUE );
        return SmbTransStatusErrorWithData;
    }

    IF_DEBUG(TRACE2) KdPrint(( "GenerateQueryPathInfoResponse complete.\n" ));
    return SmbTransStatusSuccess;

} // GenerateQueryPathInfoResponse


STATIC
NTSTATUS
SetPathOrFileInformation (
    IN PWORK_CONTEXT WorkContext,
    IN PTRANSACTION Transaction,
    IN USHORT InformationLevel,
    IN HANDLE FileHandle,
    OUT PRESP_SET_PATH_INFORMATION Response
    )

{
    NTSTATUS status = STATUS_SUCCESS;
    IO_STATUS_BLOCK ioStatusBlock;
    SMB_DATE date;
    SMB_TIME time;
    PWCHAR p, ep;

    PFILESTATUS fileStatus = (PFILESTATUS)Transaction->InData;
    FILE_BASIC_INFORMATION fileBasicInformation;

    USHORT eaErrorOffset;

    PAGED_CODE( );

    if( InformationLevel < SMB_INFO_PASSTHROUGH ) {
        switch( InformationLevel ) {

        case SMB_INFO_STANDARD:

            //
            // Information level is STANDARD.  Set normal file information.
            // Convert the DOS dates and times passed in the SMB to NT TIMEs
            // to pass to NtSetInformationFile.  Note that we zero the rest
            // of the fileBasicInformation structure so that the corresponding
            // fields are not changed.  Note also that the file attributes
            // are not changed.
            //

            RtlZeroMemory( &fileBasicInformation, sizeof(fileBasicInformation) );

            if ( !SmbIsDateZero(&fileStatus->CreationDate) ||
                 !SmbIsTimeZero(&fileStatus->CreationTime) ) {

                SmbMoveDate( &date, &fileStatus->CreationDate );
                SmbMoveTime( &time, &fileStatus->CreationTime );

                SrvDosTimeToTime( &fileBasicInformation.CreationTime, date, time );
            }

            if ( !SmbIsDateZero(&fileStatus->LastAccessDate) ||
                 !SmbIsTimeZero(&fileStatus->LastAccessTime) ) {

                SmbMoveDate( &date, &fileStatus->LastAccessDate );
                SmbMoveTime( &time, &fileStatus->LastAccessTime );

                SrvDosTimeToTime( &fileBasicInformation.LastAccessTime, date, time );
            }

            if ( !SmbIsDateZero(&fileStatus->LastWriteDate) ||
                 !SmbIsTimeZero(&fileStatus->LastWriteTime) ) {

                SmbMoveDate( &date, &fileStatus->LastWriteDate );
                SmbMoveTime( &time, &fileStatus->LastWriteTime );

                SrvDosTimeToTime( &fileBasicInformation.LastWriteTime, date, time );
            }

            //
            // Call NtSetInformationFile to set the information from the SMB.
            //

            status = NtSetInformationFile(
                         FileHandle,
                         &ioStatusBlock,
                         &fileBasicInformation,
                         sizeof(FILE_BASIC_INFORMATION),
                         FileBasicInformation
                         );

            if ( !NT_SUCCESS(status) ) {
                INTERNAL_ERROR(
                    ERROR_LEVEL_UNEXPECTED,
                    "SetPathOrFileInformation: SrvSetInformationFile returned: %X",
                    status,
                    NULL
                    );

                SrvLogServiceFailure( SRV_SVC_NT_SET_INFO_FILE, status );
            }

            //
            // No EAs to deal with.  Set EA error offset to zero.
            //

            SmbPutUshort( &Response->EaErrorOffset, 0 );

            break;

        case SMB_INFO_QUERY_EA_SIZE:

            //
            // The request is to set the file's EAs.
            //

            status = SrvSetOs2FeaList(
                         FileHandle,
                         (PFEALIST)Transaction->InData,
                         Transaction->DataCount,
                         &eaErrorOffset
                         );

            if ( !NT_SUCCESS(status) ) {
                IF_DEBUG(ERRORS) {
                    KdPrint(( "SetPathOrFileInformation: SrvSetOs2FeaList "
                                "failed: %X\n", status ));
                }
            }

            //
            // Return the EA error offset in the response.
            //

            SmbPutUshort( &Response->EaErrorOffset, eaErrorOffset );

            break;


        case SMB_SET_FILE_BASIC_INFO:
        case SMB_SET_FILE_DISPOSITION_INFO:
        case SMB_SET_FILE_ALLOCATION_INFO:
        case SMB_SET_FILE_END_OF_FILE_INFO:

            //
            // The data buffer is in NT format.  Pass it directly to the
            // filesystem.
            //
            if( Transaction->DataCount <
                MAP_SMB_INFO_TO_MIN_NT_SIZE(SetFileInformationSize, InformationLevel ) ) {

                //
                // The buffer is too small.  Return an error.
                //
                status = STATUS_INFO_LENGTH_MISMATCH;

            } else {

                status = NtSetInformationFile(
                             FileHandle,
                             &ioStatusBlock,
                             Transaction->InData,
                             Transaction->DataCount,
                             MAP_SMB_INFO_TYPE_TO_NT(
                                 SetFileInformation,
                                 InformationLevel
                                 )
                             );

            }

            //
            // No EAs to deal with.  Set EA error offset to zero.
            //

            SmbPutUshort( &Response->EaErrorOffset, 0 );

            break;

        default:
            status = STATUS_OS2_INVALID_LEVEL;
            break;
        }

    } else {
        PFILE_RENAME_INFORMATION setInfo = NULL;
        ULONG setInfoLength;
#ifdef _WIN64
        PFILE_RENAME_INFORMATION32 pRemoteInfo;
#endif

        InformationLevel -= SMB_INFO_PASSTHROUGH;

        setInfo = (PFILE_RENAME_INFORMATION)Transaction->InData;
        setInfoLength = Transaction->DataCount;

        //
        // There are some info levels which we do not allow in this path.  Unless we
        // put in special handling, we can not allow any that pass handles.  And we
        // would need to be careful on any that allow renaming or linking (to prevent
        // escaping the share).  These are the ones we restrict or disallow,
        // which the I/O subsystem may otherwise allow:
        //
        switch( InformationLevel ) {
        case FileLinkInformation:
        case FileMoveClusterInformation:
        case FileTrackingInformation:
        case FileCompletionInformation:
        case FileMailslotSetInformation:
            status = STATUS_NOT_SUPPORTED;
            break;

        case FileRenameInformation: {

            PWCHAR s, es;

#ifdef _WIN64
            pRemoteInfo = (PFILE_RENAME_INFORMATION32)Transaction->InData;
            setInfoLength = Transaction->DataCount + sizeof(PVOID)-sizeof(ULONG);
            setInfo = (PFILE_RENAME_INFORMATION)ALLOCATE_NONPAGED_POOL( setInfoLength, BlockTypeMisc );
            if( !setInfo )
            {
                status = STATUS_INSUFFICIENT_RESOURCES;
                break;
            }
            // Thunk most of the structure but wait to copy until we validate the file
            // name length is correct
            setInfo->ReplaceIfExists = pRemoteInfo->ReplaceIfExists;
            setInfo->RootDirectory = UlongToHandle( pRemoteInfo->RootDirectory );
            setInfo->FileNameLength = pRemoteInfo->FileNameLength;
#endif

            //
            // See if the structure is internally consistent
            //
            if( setInfoLength < sizeof( FILE_RENAME_INFORMATION ) ||
                setInfo->RootDirectory != NULL ||
                setInfo->FileNameLength > setInfoLength ||
                (setInfo->FileNameLength & (sizeof(WCHAR)-1)) ||
                setInfo->FileNameLength +
                    FIELD_OFFSET( FILE_RENAME_INFORMATION, FileName ) >
                    setInfoLength ) {

                status = STATUS_INVALID_PARAMETER;
                break;
            }

#ifdef _WIN64
            // We've validated the original buffer, so lets copy the filename
            RtlCopyMemory( setInfo->FileName, pRemoteInfo->FileName, setInfo->FileNameLength );
#endif

            //
            // If there are any path separaters in the name, then we do not support
            //   this operation.
            //
            es = &setInfo->FileName[ setInfo->FileNameLength / sizeof( WCHAR ) ];
            for( s = setInfo->FileName; s < es; s++ ) {
                if( IS_UNICODE_PATH_SEPARATOR( *s ) ) {
                    status = STATUS_NOT_SUPPORTED;
                    break;
                }
            }
        }

        }

        if( NT_SUCCESS( status ) ) {

            //
            // See if the supplied parameters are correct.
            //
            status = IoCheckQuerySetFileInformation( InformationLevel,
                                                     setInfoLength,
                                                     TRUE
                                                    );
            if( NT_SUCCESS( status ) ) {

                //
                // Some information levels require us to impersonate the client.
                //
                status = IMPERSONATE( WorkContext );

                if( NT_SUCCESS( status ) ) {
                    status = NtSetInformationFile(
                                                 FileHandle,
                                                 &ioStatusBlock,
                                                 setInfo,
                                                 setInfoLength,
                                                 InformationLevel
                                                 );
                    REVERT();

                    //
                    // No EAs to deal with.  Set EA error offset to zero.
                    //
                    SmbPutUshort( &Response->EaErrorOffset, 0 );
                }
            }
        }

#ifdef _WIN64
        if( (FileRenameInformation == InformationLevel) && setInfo )
        {
            DEALLOCATE_NONPAGED_POOL( setInfo );
            setInfo = NULL;
        }
#endif

    }

    //
    // Build the output parameter and data structures.  It is basically
    // the same for all info levels reguardless of the completion status.
    //

    Transaction->SetupCount = 0;
    Transaction->ParameterCount = 2;
    Transaction->DataCount = 0;

    return status;

} // SetPathOrFileInformation


SMB_TRANS_STATUS
SrvSmbSetFileInformation (
    IN OUT PWORK_CONTEXT WorkContext
    )

/*++

Routine Description:

    Processes the Set File Information request.  This request arrives
    in a Transaction2 SMB.  Set File Information corresponds to the
    OS/2 DosSetFileInfo service.

Arguments:

    WorkContext - Supplies the address of a Work Context Block
        describing the current request.  See smbtypes.h for a more
        complete description of the valid fields.

Return Value:

    SMB_TRANS_STATUS - Indicates whether an error occurred, and, if so,
        whether data should be returned to the client.  See smbtypes.h
        for a more complete description.

--*/

{
    PREQ_SET_FILE_INFORMATION request;
    PRESP_SET_FILE_INFORMATION response;

    NTSTATUS         status    = STATUS_SUCCESS;
    SMB_TRANS_STATUS SmbStatus = SmbTransStatusInProgress;
    PTRANSACTION transaction;
    PRFCB rfcb;
    USHORT informationLevel;
    USHORT NtInformationLevel;
    ACCESS_MASK grantedAccess;

    PAGED_CODE( );
    if (WorkContext->PreviousSMB == EVENT_TYPE_SMB_LAST_EVENT)
        WorkContext->PreviousSMB = EVENT_TYPE_SMB_SET_FILE_INFORMATION;
    SrvWmiStartContext(WorkContext);

    transaction = WorkContext->Parameters.Transaction;
    IF_SMB_DEBUG(QUERY_SET1) {
        KdPrint(( "Set File Information entered; transaction 0x%p\n",
                    transaction ));
    }

    request = (PREQ_SET_FILE_INFORMATION)transaction->InParameters;
    response = (PRESP_SET_FILE_INFORMATION)transaction->OutParameters;

    //
    // Verify that enough parameter bytes were sent and that we're allowed
    // to return enough parameter bytes.
    //

    if ( (transaction->ParameterCount <
            sizeof(REQ_SET_FILE_INFORMATION)) ||
         (transaction->MaxParameterCount <
            sizeof(RESP_SET_FILE_INFORMATION)) ) {

        //
        // Not enough parameter bytes were sent.
        //

        IF_DEBUG(SMB_ERRORS) {
            KdPrint(( "SrvSmbSetFileInformation: bad parameter byte counts: "
                        "%ld %ld\n",
                        transaction->ParameterCount,
                        transaction->MaxParameterCount ));
        }

        SrvSetSmbError( WorkContext, STATUS_INVALID_SMB );
        status    = STATUS_INVALID_SMB;
        SmbStatus = SmbTransStatusErrorWithoutData;
        goto Cleanup;
    }

    //
    // Verify the FID.  If verified, the RFCB block is referenced
    // and its addresses is stored in the WorkContext block, and the
    // RFCB address is returned.
    //

    rfcb = SrvVerifyFid(
                WorkContext,
                SmbGetUshort( &request->Fid ),
                TRUE,
                SrvRestartExecuteTransaction,   // serialize with raw write
                &status
                );

    if ( rfcb == SRV_INVALID_RFCB_POINTER ) {

        if ( !NT_SUCCESS( status ) ) {

            //
            // Invalid file ID or write behind error.  Reject the request.
            //

            IF_DEBUG(ERRORS) {
                KdPrint((
                    "SrvSmbSetFileInformation: Status %X on FID: 0x%lx\n",
                    status,
                    SmbGetUshort( &request->Fid )
                    ));
            }

            SrvSetSmbError( WorkContext, status );
            SmbStatus = SmbTransStatusErrorWithoutData;
            goto Cleanup;
        }

        //
        // The work item has been queued because a raw write is in
        // progress.
        //

        SmbStatus = SmbTransStatusInProgress;
        goto Cleanup;
    }

    //
    // Verify the information level and the number of input and output
    // data bytes available.
    //

    informationLevel = SmbGetUshort( &request->InformationLevel );
    grantedAccess = rfcb->GrantedAccess;

    status = STATUS_SUCCESS;

    if( informationLevel < SMB_INFO_PASSTHROUGH ) {
        switch ( informationLevel ) {

        case SMB_INFO_STANDARD:

            if ( transaction->DataCount < 22 ) {
                IF_DEBUG(SMB_ERRORS) {
                    KdPrint(( "SrvSmbSetFileInformation: invalid DataCount %ld\n",
                                transaction->DataCount ));
                }
                status = STATUS_INVALID_SMB;
            }

            //
            // Verify that the client has write attributes access to the
            // file via the specified handle.
            //

            CHECK_FILE_INFORMATION_ACCESS(
                grantedAccess,
                IRP_MJ_SET_INFORMATION,
                FileBasicInformation,
                &status
                );

            IF_DEBUG(ERRORS) {
                if ( !NT_SUCCESS(status) ) {
                    KdPrint(( "SrvSmbSetFileInformation: IoCheckFunctionAccess "
                                "failed: 0x%X, GrantedAccess: %lx\n",
                                status, grantedAccess ));
                }
            }

            break;

        case SMB_INFO_QUERY_EA_SIZE:

            if ( transaction->DataCount < 4 ) {
                IF_DEBUG(SMB_ERRORS) {
                    KdPrint(( "SrvSmbSetFileInformation: invalid DataCount %ld\n",
                                transaction->MaxParameterCount ));
                }
                status = STATUS_INVALID_SMB;
            }

            //
            // Verify that the client has write EA access to the file via
            // the specified handle.
            //

            CHECK_FUNCTION_ACCESS(
                grantedAccess,
                IRP_MJ_SET_EA,
                0,
                0,
                &status
                );

            IF_DEBUG(ERRORS) {
                if ( !NT_SUCCESS(status) ) {
                    KdPrint(( "SrvSmbSetFileInformation: IoCheckFunctionAccess "
                                "failed: 0x%X, GrantedAccess: %lx\n",
                                status, grantedAccess ));
                }
            }

            break;

        case SMB_SET_FILE_BASIC_INFO:

            if ( transaction->DataCount != sizeof( FILE_BASIC_INFORMATION ) ) {
                IF_DEBUG(SMB_ERRORS) {
                    KdPrint(( "SrvSmbSetFileInformation: invalid DataCount %ld\n",
                                transaction->DataCount ));
                }
                status = STATUS_INVALID_SMB;
            }

            //
            // Verify that the client has write attributes access to the
            // file via the specified handle.
            //

            CHECK_FILE_INFORMATION_ACCESS(
                grantedAccess,
                IRP_MJ_SET_INFORMATION,
                FileBasicInformation,
                &status
                );

            IF_DEBUG(ERRORS) {
                if ( !NT_SUCCESS(status) ) {
                    KdPrint(( "SrvSmbSetFileInformation: IoCheckFunctionAccess "
                                "failed: 0x%X, GrantedAccess: %lx\n",
                                status, grantedAccess ));
                }
            }

            break;

#if     0 // No longer supported
        case SMB_SET_FILE_RENAME_INFO:

            //
            // The data must contain rename information plus a non-zero
            // length name.
            //

            if ( transaction->DataCount <=
                        FIELD_OFFSET( FILE_RENAME_INFORMATION, FileName  ) ) {
                IF_DEBUG(SMB_ERRORS) {
                    KdPrint(( "SrvSmbSetFileInformation: invalid DataCount %ld\n",
                                transaction->DataCount ));
                }
                status = STATUS_INVALID_SMB;
            }

            //
            // Verify that the client has write attributes access to the
            // file via the specified handle.
            //

            CHECK_FILE_INFORMATION_ACCESS(
                grantedAccess,
                IRP_MJ_SET_INFORMATION,
                FileRenameInformation,
                &status
                );

            IF_DEBUG(ERRORS) {
                if ( !NT_SUCCESS(status) ) {
                    KdPrint(( "SrvSmbSetFileInformation: IoCheckFunctionAccess "
                                "failed: 0x%X, GrantedAccess: %lx\n",
                                status, grantedAccess ));
                }
            }

            break;
#endif

        case SMB_SET_FILE_DISPOSITION_INFO:

            if ( transaction->DataCount !=
                            sizeof( FILE_DISPOSITION_INFORMATION ) ){
                IF_DEBUG(SMB_ERRORS) {
                    KdPrint(( "SrvSmbSetFileInformation: invalid DataCount %ld\n",
                                transaction->DataCount ));
                }
                status = STATUS_INVALID_SMB;
            }

            //
            // Verify that the client has write attributes access to the
            // file via the specified handle.
            //

            CHECK_FILE_INFORMATION_ACCESS(
                grantedAccess,
                IRP_MJ_SET_INFORMATION,
                FileDispositionInformation,
                &status
                );

            IF_DEBUG(ERRORS) {
                if ( !NT_SUCCESS(status) ) {
                    KdPrint(( "SrvSmbSetFileInformation: IoCheckFunctionAccess "
                                "failed: 0x%X, GrantedAccess: %lx\n",
                                status, grantedAccess ));
                }
            }

            break;

        case SMB_SET_FILE_ALLOCATION_INFO:

            if ( transaction->DataCount !=
                            sizeof( FILE_ALLOCATION_INFORMATION ) ){
                IF_DEBUG(SMB_ERRORS) {
                    KdPrint(( "SrvSmbSetFileInformation: invalid DataCount %ld\n",
                                transaction->DataCount ));
                }
                status = STATUS_INVALID_SMB;
            }

            //
            // Verify that the client has write attributes access to the
            // file via the specified handle.
            //

            CHECK_FILE_INFORMATION_ACCESS(
                grantedAccess,
                IRP_MJ_SET_INFORMATION,
                FileAllocationInformation,
                &status
                );

            IF_DEBUG(ERRORS) {
                if ( !NT_SUCCESS(status) ) {
                    KdPrint(( "SrvSmbSetFileInformation: IoCheckFunctionAccess "
                                "failed: 0x%X, GrantedAccess: %lx\n",
                                status, grantedAccess ));
                }
            }

            break;

        case SMB_SET_FILE_END_OF_FILE_INFO:

            if ( transaction->DataCount !=
                            sizeof( FILE_END_OF_FILE_INFORMATION ) ){
                IF_DEBUG(SMB_ERRORS) {
                    KdPrint(( "SrvSmbSetFileInformation: invalid DataCount %ld\n",
                                transaction->DataCount ));
                }
                status = STATUS_INVALID_SMB;
            }

            //
            // Verify that the client has write attributes access to the
            // file via the specified handle.
            //

            CHECK_FILE_INFORMATION_ACCESS(
                grantedAccess,
                IRP_MJ_SET_INFORMATION,
                FileEndOfFileInformation,
                &status
                );

            IF_DEBUG(ERRORS) {
                if ( !NT_SUCCESS(status) ) {
                    KdPrint(( "SrvSmbSetFileInformation: IoCheckFunctionAccess "
                                "failed: 0x%X, GrantedAccess: %lx\n",
                                status, grantedAccess ));
                }
            }

            break;

        default:

            IF_DEBUG(SMB_ERRORS) {
                KdPrint(( "SrvSmbSetFileInformation: invalid info level %ld\n",
                            informationLevel ));
            }
            status = STATUS_OS2_INVALID_LEVEL;

        }

    } else {

        if( informationLevel - SMB_INFO_PASSTHROUGH >= FileMaximumInformation ) {
            status = STATUS_INVALID_INFO_CLASS;

        } else {

            CHECK_FILE_INFORMATION_ACCESS(
                grantedAccess,
                IRP_MJ_SET_INFORMATION,
                informationLevel - SMB_INFO_PASSTHROUGH,
                &status
            );
        }

        IF_DEBUG(ERRORS) {
            if ( !NT_SUCCESS(status) ) {
                KdPrint(( "SrvSmbSetFileInformation level %u: IoCheckFunctionAccess "
                            "failed: 0x%X, GrantedAccess: %lx\n",
                            informationLevel, status, grantedAccess ));
            }
        }
    }

    if ( !NT_SUCCESS(status) ) {

        SrvSetSmbError( WorkContext, status );
        SmbStatus = SmbTransStatusErrorWithoutData;
        goto Cleanup;
    }

    //
    // Set the appropriate information about the file.
    //

    status = SetPathOrFileInformation(
                 WorkContext,
                 transaction,
                 informationLevel,
                 rfcb->Lfcb->FileHandle,
                 (PRESP_SET_PATH_INFORMATION)response
                 );

    //
    // If an error occurred, return an appropriate response.
    //

    if ( !NT_SUCCESS(status) ) {

        //
        // SetPathOrFileInformation already set the response parameters,
        // so just return an error condition.
        //

        SrvSetSmbError2( WorkContext, status, TRUE );
        SmbStatus = SmbTransStatusErrorWithData;
        goto Cleanup;
    }

#ifdef INCLUDE_SMB_IFMODIFIED
    rfcb->Lfcb->FileUpdated = TRUE;
#endif

    //
    // reset this boolean so that the rfcb will not be cached after client close
    //
    rfcb->IsCacheable = FALSE;
    SmbStatus = SmbTransStatusSuccess;
    IF_DEBUG(TRACE2) KdPrint(( "SrvSmbSetFileInformation complete.\n" ));

Cleanup:
    SrvWmiEndContext(WorkContext);
    return SmbStatus;

} // SrvSmbSetFileInformation


SMB_TRANS_STATUS
SrvSmbSetPathInformation (
    IN OUT PWORK_CONTEXT WorkContext
    )

/*++

Routine Description:

    Processes the Set Path Information request.  This request arrives
    in a Transaction2 SMB.  Set Path Information corresponds to the
    OS/2 DosSetPathInfo service.

Arguments:

    WorkContext - Supplies the address of a Work Context Block
        describing the current request.  See smbtypes.h for a more
        complete description of the valid fields.

Return Value:

    SMB_TRANS_STATUS - Indicates whether an error occurred, and, if so,
        whether data should be returned to the client.  See smbtypes.h
        for a more complete description.

--*/

{
    PTRANSACTION transaction;
    PREQ_SET_PATH_INFORMATION request;
    USHORT informationLevel;
    NTSTATUS         status    = STATUS_SUCCESS;
    SMB_TRANS_STATUS SmbStatus = SmbTransStatusInProgress;
    IO_STATUS_BLOCK ioStatusBlock;
    HANDLE fileHandle;
    OBJECT_ATTRIBUTES objectAttributes;
    UNICODE_STRING objectName;
    BOOLEAN isUnicode;
    ACCESS_MASK desiredAccess;

    PAGED_CODE( );
    if (WorkContext->PreviousSMB == EVENT_TYPE_SMB_LAST_EVENT)
        WorkContext->PreviousSMB = EVENT_TYPE_SMB_SET_PATH_INFORMATION;
    SrvWmiStartContext(WorkContext);

    transaction = WorkContext->Parameters.Transaction;

    IF_SMB_DEBUG(QUERY_SET1) {
        KdPrint(( "SrvSmbSetPathInformation entered; transaction 0x%p\n",
                    transaction ));
    }

    request = (PREQ_SET_PATH_INFORMATION)transaction->InParameters;
    informationLevel = SmbGetUshort( &request->InformationLevel );

    switch( informationLevel ) {
    case SMB_SET_FILE_ALLOCATION_INFO:
    case SMB_SET_FILE_END_OF_FILE_INFO:
        desiredAccess = FILE_WRITE_DATA;
        break;

    case SMB_SET_FILE_DISPOSITION_INFO:
        desiredAccess = DELETE;
        break;

    case SMB_INFO_SET_EAS:
        desiredAccess = FILE_WRITE_EA;
        break;

    default:
        desiredAccess = FILE_WRITE_ATTRIBUTES;
        break;
    }

    if( desiredAccess != FILE_WRITE_ATTRIBUTES &&
        WorkContext->UsingBlockingThread == 0 ) {

        //
        // We can't process the SMB in a nonblocking thread because this
        // info level requires opening the file, which may be oplocked, so
        // the open operation may block.
        //

        WorkContext->FspRestartRoutine = SrvRestartExecuteTransaction;
        SrvQueueWorkToBlockingThread( WorkContext );
        SmbStatus = SmbTransStatusInProgress;
        goto Cleanup;
    }

    //
    // Verify that enough parameter bytes were sent and that we're allowed
    // to return enough parameter bytes.
    //

    request = (PREQ_SET_PATH_INFORMATION)transaction->InParameters;

    if ( (transaction->ParameterCount <
            sizeof(REQ_SET_PATH_INFORMATION)) ||
         (transaction->MaxParameterCount <
            sizeof(RESP_SET_PATH_INFORMATION)) ) {

        //
        // Not enough parameter bytes were sent.
        //

        IF_DEBUG(SMB_ERRORS) {
            KdPrint(( "SrvSmbSetPathInformation: bad parameter byte "
                        "counts: %ld %ld\n",
                        transaction->ParameterCount,
                        transaction->MaxParameterCount ));
        }

        SrvSetSmbError( WorkContext, STATUS_INVALID_SMB );
        status    = STATUS_INVALID_SMB;
        SmbStatus = SmbTransStatusErrorWithoutData;
        goto Cleanup;
    }

    //
    // Make sure the client is allowed to do this, if we have an Admin share
    //
    status = SrvIsAllowedOnAdminShare( WorkContext, transaction->TreeConnect->Share );
    if( !NT_SUCCESS( status ) ) {
        SrvSetSmbError( WorkContext, status );
        SmbStatus = SmbTransStatusErrorWithoutData;
        goto Cleanup;
    }

    //
    // Get the path name of the file to open relative to the share.
    //

    isUnicode = SMB_IS_UNICODE( WorkContext );

    status = SrvCanonicalizePathName(
            WorkContext,
            transaction->TreeConnect->Share,
            NULL,
            request->Buffer,
            END_OF_TRANSACTION_PARAMETERS( transaction ),
            TRUE,
            isUnicode,
            &objectName
            );

    if( !NT_SUCCESS( status ) ) {

        IF_DEBUG(SMB_ERRORS) {
            KdPrint(( "SrvSmbSetPathInformation: bad path name: %s\n",
                        request->Buffer ));
        }

        SrvSetSmbError( WorkContext, status );
        SmbStatus = SmbTransStatusErrorWithoutData;
        goto Cleanup;
    }

    //
    // If the client is trying to operate on the root of the share, reject
    // the request.
    //

    if ( objectName.Length < sizeof(WCHAR) ) {

        IF_DEBUG(SMB_ERRORS) {
            KdPrint(( "SrvSmbSetPathInformation: attempting to set info on "
                          "share root\n" ));
        }

        SrvSetSmbError( WorkContext, STATUS_ACCESS_DENIED );
        status = STATUS_ACCESS_DENIED;
        if ( !isUnicode ) {
            RtlFreeUnicodeString( &objectName );
        }
        SmbStatus = SmbStatusSendResponse;
        goto Cleanup;
    }

    //
    // Initialize the object attributes structure.
    //

    SrvInitializeObjectAttributes_U(
        &objectAttributes,
        &objectName,
        (WorkContext->RequestHeader->Flags & SMB_FLAGS_CASE_INSENSITIVE ||
         transaction->Session->UsingUppercasePaths) ?
            OBJ_CASE_INSENSITIVE : 0L,
        NULL,
        NULL
        );

    IF_SMB_DEBUG(QUERY_SET2) {
        KdPrint(( "Opening file %wZ\n", &objectName ));
    }

    //
    // Open the file -- must be opened in order to have a handle to pass
    // to NtSetInformationFile.  We will close it after getting the
    // necessary information.
    //
    // The DosQPathInfo API insures that EAs are written directly to
    // the disk rather than cached, so if EAs are being written, open
    // with FILE_WRITE_THROUGH.  See OS/2 1.2 DCR 581 for more
    // information.
    //
    INCREMENT_DEBUG_STAT( SrvDbgStatistics.TotalOpenAttempts );
    INCREMENT_DEBUG_STAT( SrvDbgStatistics.TotalOpensForPathOperations );

    status = SrvIoCreateFile(
                 WorkContext,
                 &fileHandle,
                 desiredAccess,
                 &objectAttributes,
                 &ioStatusBlock,
                 NULL,                                      // AllocationSize
                 0,                                         // FileAttributes
                 FILE_SHARE_READ | FILE_SHARE_WRITE |
                     FILE_SHARE_DELETE,                     // ShareAccess
                 FILE_OPEN,                                 // Disposition
                 FILE_OPEN_REPARSE_POINT,                   // CreateOptions
                 NULL,                                      // EaBuffer
                 0,                                         // EaLength
                 CreateFileTypeNone,
                 NULL,                                      // ExtraCreateParameters
                 IO_FORCE_ACCESS_CHECK,                     // Options
                 transaction->TreeConnect->Share
                 );

    if( status == STATUS_INVALID_PARAMETER ) {
        status = SrvIoCreateFile(
                     WorkContext,
                     &fileHandle,
                     desiredAccess,
                     &objectAttributes,
                     &ioStatusBlock,
                     NULL,                                      // AllocationSize
                     0,                                         // FileAttributes
                     FILE_SHARE_READ | FILE_SHARE_WRITE |
                         FILE_SHARE_DELETE,                     // ShareAccess
                     FILE_OPEN,                                 // Disposition
                     0,                                         // CreateOptions
                     NULL,                                      // EaBuffer
                     0,                                         // EaLength
                     CreateFileTypeNone,
                     NULL,                                      // ExtraCreateParameters
                     IO_FORCE_ACCESS_CHECK,                     // Options
                     transaction->TreeConnect->Share
                     );
    }

    ASSERT( status != STATUS_OPLOCK_BREAK_IN_PROGRESS );

    if ( NT_SUCCESS(status) ) {
        SRVDBG_CLAIM_HANDLE( fileHandle, "FIL", 22, 0 );
    }

    if ( !isUnicode ) {
        RtlFreeUnicodeString( &objectName );
    }

    if ( !NT_SUCCESS( status ) ) {

        //
        // If the user didn't have this permission, update the
        // statistics database.
        //
        if ( status == STATUS_ACCESS_DENIED ) {
            SrvStatistics.AccessPermissionErrors++;
        }

        IF_DEBUG(ERRORS) {
            KdPrint(( "SrvSmbSetPathInformation: SrvIoCreateFile failed: "
                        "%X\n", status ));
        }

        SrvSetSmbError( WorkContext, status );
        SmbStatus = SmbTransStatusErrorWithoutData;
        goto Cleanup;
    }

    IF_SMB_DEBUG(QUERY_SET2) {
        KdPrint(( "SrvIoCreateFile succeeded, handle = 0x%p\n", fileHandle ));
    }

    if( informationLevel < SMB_INFO_PASSTHROUGH ) {

        //
        // Verify the information level and the number of input and output
        // data bytes available.
        //

        BOOLEAN error = FALSE;

        switch ( informationLevel ) {

        case SMB_INFO_STANDARD:
            if ( transaction->DataCount < 22 ) {
                IF_DEBUG(SMB_ERRORS) {
                    KdPrint(( "SrvSmbSetPathInformation: invalid DataCount %ld\n",
                                transaction->DataCount ));
                }
                error = TRUE;
            }
            break;

        case SMB_INFO_QUERY_EA_SIZE:
        case SMB_INFO_QUERY_ALL_EAS:
            if ( transaction->DataCount < 4 ) {
                IF_DEBUG(SMB_ERRORS) {
                    KdPrint(( "SrvSmbSetPathInformation: invalid DataCount %ld\n",
                                transaction->MaxParameterCount ));
                }
                error = TRUE;
            }
            break;

        default:
            IF_DEBUG(SMB_ERRORS) {
                KdPrint(( "SrvSmbSetPathInformation: invalid info level %ld\n",
                            informationLevel ));
            }
            error = TRUE;

        }

        if ( error ) {

            //
            // Just return an error condition.
            //

            SrvSetSmbError2( WorkContext, STATUS_OS2_INVALID_LEVEL, TRUE );
            status    = STATUS_OS2_INVALID_LEVEL;
            SmbStatus = SmbTransStatusErrorWithoutData;
            goto Cleanup;
        }
    }

    //
    // Set the appropriate information about the file.
    //

    status = SetPathOrFileInformation(
                 WorkContext,
                 transaction,
                 informationLevel,
                 fileHandle,
                 (PRESP_SET_PATH_INFORMATION)transaction->OutParameters
                 );

    //
    // Close the file--it was only opened to write the attributes.
    //

    SRVDBG_RELEASE_HANDLE( fileHandle, "FIL", 35, 0 );
    SrvNtClose( fileHandle, TRUE );

    //
    // If an error occurred, return an appropriate response.
    //

    if ( !NT_SUCCESS(status) ) {

        //
        // SetPathOrFileInformation already set the response parameters,
        // so just return an error condition.
        //

        SrvSetSmbError2( WorkContext, status, TRUE );
        SmbStatus = SmbTransStatusErrorWithData;
        goto Cleanup;
    }
    SmbStatus = SmbTransStatusSuccess;
    IF_DEBUG(TRACE2) KdPrint(( "SrvSmbSetPathInformation complete.\n" ));

Cleanup:
    SrvWmiEndContext(WorkContext);
    return SmbStatus;

} // SrvSmbSetPathInformation
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\srv\smbctrl.h ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    smbctrl.h

Abstract:

    This module defines control functions for SMB processing.

Author:

    Chuck Lenzmeier (chuckl) 1-Dec-1989

Revision History:

--*/

#ifndef _SMBCTRL_
#define _SMBCTRL_

//#include <ntos.h>

//#include "srvblock.h"
//#include "smbtypes.h"

//
// Control routines for SMB processing.
//

VOID SRVFASTCALL
SrvProcessSmb (
    IN OUT PWORK_CONTEXT WorkContext
    );

VOID
SrvEndSmbProcessing (
    IN OUT PWORK_CONTEXT WorkContext,
    IN SMB_STATUS SmbStatus
    );

//
// Restart routines.
//
VOID SRVFASTCALL
SrvRestartChainedClose (
    IN OUT PWORK_CONTEXT WorkContext
    );

VOID SRVFASTCALL
SrvRestartFsdComplete (
    IN OUT PWORK_CONTEXT WorkContext
    );

VOID SRVFASTCALL
SrvRestartSmbReceived (
    IN OUT PWORK_CONTEXT WorkContext
    );

VOID SRVFASTCALL
SrvRestartReceive (
    IN OUT PWORK_CONTEXT WorkContext
    );

VOID SRVFASTCALL
SrvRestartWriteAndUnlock (
    IN OUT PWORK_CONTEXT WorkContext
    );

VOID SRVFASTCALL
SrvRestartWriteAndXRaw (
    IN PWORK_CONTEXT WorkContext
    );

VOID SRVFASTCALL
SrvBuildAndSendErrorResponse (
    IN PWORK_CONTEXT WorkContext
    );

VOID SRVFASTCALL
RestartLargeWriteAndX (
    IN PWORK_CONTEXT WorkContext
    );

//
// SMB Processing routines.
//

SMB_PROCESSOR_RETURN_TYPE SRVFASTCALL
SrvSmbIllegalCommand (
    IN PWORK_CONTEXT WorkContext
    );

#endif // def _SMBCTRL_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\srv\slmcheck.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    slmcheck.c

Abstract:

    This source file defines a single function that will check the
    consistency of a SLM Status file.

--*/

#include "precomp.h"
#include "slmcheck.tmh"
#pragma hdrstop

#ifdef SLMDBG

//
// This is terrible
//
NTSTATUS
NtCreateEvent (
    OUT PHANDLE EventHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes OPTIONAL,
    IN EVENT_TYPE EventType,
    IN BOOLEAN InitialState
);

//
// So is this
//
NTSTATUS
NtWaitForSingleObject(
    IN HANDLE Handle,
    IN BOOLEAN Alertable,
    IN PLARGE_INTEGER Timeout OPTIONAL
    );

BOOLEAN SrvDisallowSlmAccessEnabled = FALSE;
BOOLEAN SrvSlmFailed = FALSE;

#define toupper(c) ( (c >= 'a' && c <= 'z') ? c - ('a' - 'A') : c )


NTSTATUS
SrvpValidateStatusFile(
    IN PVOID StatusFileData,
    IN ULONG StatusFileLength,
    OUT PULONG FileOffsetOfInvalidData
    );

VOID
SrvReportCorruptSlmStatus (
    IN PUNICODE_STRING StatusFile,
    IN NTSTATUS Status,
    IN ULONG Offset,
    IN ULONG Operation,
    IN PSESSION Session
    )
{
    NTSTATUS status;
    ANSI_STRING ansiStatusFile;
    TIME time;
    TIME_FIELDS timeFields;
    ULONG i, j;
    UNICODE_STRING userName;

    if( SrvSlmFailed ) {
        return;
    }

    status = RtlUnicodeStringToAnsiString( &ansiStatusFile, StatusFile, TRUE );
    ASSERT( NT_SUCCESS(status) );

    KeQuerySystemTime( &time );
    RtlTimeToTimeFields( &time, &timeFields );

    SrvGetUserAndDomainName ( Session, &userName, NULL );

    KdPrint(( "\n*** CORRUPT STATUS FILE DETECTED ***\n"
                "      File: %Z\n"
                "      Status: 0x%lx, Offset: 0x%lx, detected on %s\n",
                &ansiStatusFile, Status, Offset,
                Operation == SLMDBG_CLOSE ? "close" : "rename" ));
    KdPrint(( "      Workstation: %wZ, User: %wZ, OS: %d\n",
                &Session->Connection->PagedConnection->ClientMachineNameString,
                &userName,
                &SrvClientTypes[Session->Connection->SmbDialect] ));
    KdPrint(( "      Current time: %d-%d-%d ",
                timeFields.Month, timeFields.Day, timeFields.Year ));
    KdPrint(( "%d:%d:%d\n",
                timeFields.Hour, timeFields.Minute, timeFields.Second ));

    SrvReleaseUserAndDomainName( Session, &userName, NULL );

#if 0
    //
    // Send a broadcast message.
    //
    SrvSendSecondClassMailslot( ansiStatusFile.Buffer, StatusFile->Length + 1,
                            "BLUBBER", "BLUBBER" );
#endif

    RtlFreeAnsiString( &ansiStatusFile );

} // SrvReportCorruptSlmStatus

VOID
SrvReportSlmStatusOperations (
    IN PRFCB Rfcb,
    IN BOOLEAN Force
    )
{
    ULONG first, last, i;
    PRFCB_TRACE trace;
    TIME_FIELDS timeFields;
    PSZ command;
    BOOLEAN oplockBreak;

    if( !Force && SrvSlmFailed ) {
        return;
    }

    KdPrint((   "      Number of operations: %d, number of writes: %d\n",
                Rfcb->OperationCount, Rfcb->WriteCount ));

    if( Rfcb->Connection && GET_BLOCK_STATE(Rfcb->Connection) != BlockStateActive ) {
        KdPrint(( "        Connection State = %u\n", GET_BLOCK_STATE( Rfcb->Connection )));
    }

    if ( Rfcb->TraceWrapped || (Rfcb->NextTrace != 0) ) {

        first = Rfcb->TraceWrapped ? Rfcb->NextTrace : 0;
        last = Rfcb->NextTrace == 0 ? SLMDBG_TRACE_COUNT - 1 :
                                      Rfcb->NextTrace - 1;

        i = first;

        while ( TRUE ) {

            trace = &Rfcb->Trace[i];

            RtlTimeToTimeFields( &trace->Time, &timeFields );
            KdPrint(( "      %s%d: ", i < 10 ? "0" : "", i ));
            KdPrint(( "%d-%d-%d ",
                timeFields.Month, timeFields.Day, timeFields.Year ));
            KdPrint(( "%s%d:%s%d:",
                timeFields.Hour < 10 ? "0" : "", timeFields.Hour,
                timeFields.Minute < 10 ? "0" : "", timeFields.Minute ));
            KdPrint(( "%s%d: ",
                timeFields.Second < 10 ? "0" : "", timeFields.Second ));

            oplockBreak = FALSE;

            switch ( trace->Command ) {

            case SMB_COM_READ:
            case SMB_COM_WRITE:
            case SMB_COM_READ_ANDX:
            case SMB_COM_WRITE_ANDX:
            case SMB_COM_LOCK_AND_READ:
            case SMB_COM_WRITE_AND_UNLOCK:
            case SMB_COM_WRITE_AND_CLOSE:
            case SMB_COM_READ_RAW:
            case SMB_COM_WRITE_RAW:
            case SMB_COM_LOCK_BYTE_RANGE:
            case SMB_COM_UNLOCK_BYTE_RANGE:
            case SMB_COM_LOCKING_ANDX:

                switch ( trace->Command ) {

                case SMB_COM_READ:
                    command = "Read";
                    break;

                case SMB_COM_WRITE:
                    command = "Write";
                    break;

                case SMB_COM_READ_ANDX:
                    command = "Read And X";
                    break;

                case SMB_COM_WRITE_ANDX:
                    command = "Write And X";
                    break;

                case SMB_COM_LOCK_AND_READ:
                    command = "Lock And Read";
                    break;

                case SMB_COM_WRITE_AND_UNLOCK:
                    command = "Write And Unlock";
                    break;

                case SMB_COM_WRITE_AND_CLOSE:
                    command = "Write And Close";
                    break;

                case SMB_COM_READ_RAW:
                    if ( (trace->Flags & 1) == 0 ) {
                        command = "Read Raw (copy)";
                    } else {
                        command = "Read Raw (MDL)";
                    }
                    break;

                case SMB_COM_WRITE_RAW:
                    if ( (trace->Flags & 2) == 0 ) {
                        if ( (trace->Flags & 1) == 0 ) {
                            command = "Write Raw (copy, no immed)";
                        } else {
                            command = "Write Raw (MDL, no immed)";
                        }
                    } else {
                        if ( (trace->Flags & 1) == 0 ) {
                            command = "Write Raw (copy, immed)";
                        } else {
                            command = "Write Raw (MDL, immed)";
                        }
                    }
                    break;

                case SMB_COM_LOCK_BYTE_RANGE:
                    command = "Lock Byte Range";
                    break;

                case SMB_COM_UNLOCK_BYTE_RANGE:
                    command = "Unlock Byte Range";
                    break;

                case SMB_COM_LOCKING_ANDX:
                    if ( trace->Flags == 0 ) {
                        command = "Locking And X (lock)";
                    } else if ( trace->Flags == 1 ) {
                        command = "Locking And X (unlock)";
                    } else {
                        command = "Locking And X (release oplock)";
                        oplockBreak = TRUE;
                    }
                    break;

                }

                if ( !oplockBreak ) {
                    KdPrint(( "%s, offset = 0x%lx, len = 0x%lx\n",
                                command, trace->Data.ReadWrite.Offset,
                                trace->Data.ReadWrite.Length ));
                } else {
                    KdPrint(( "%s\n", command ));
                }

                break;

            default:
                KdPrint(( "command = 0x%lx, flags = 0x%lx\n",
                            trace->Command, trace->Flags ));

            }

        if ( i == last ) break;

            if ( ++i == SLMDBG_TRACE_COUNT ) i = 0;

        }

    }

    SrvSendSecondClassMailslot( "SLM CORRUPTION", 15, "BLUBBER", "BLUBBER" );

    return;

} // SrvReportSlmStatusOperations

VOID
SrvCreateMagicSlmName (
    IN PUNICODE_STRING StatusFile,
    OUT PUNICODE_STRING MagicFile
    )
{
    LONG fileLength;
    ULONG dirLength;
    PCHAR magicName = "\\status.nfw";
    PCHAR src;
    PWCH dest;

    fileLength = (strlen( magicName ) + 1) * sizeof(WCHAR);
    dirLength = SrvGetSubdirectoryLength( StatusFile );
    MagicFile->MaximumLength = (USHORT)(dirLength + fileLength);
    MagicFile->Length = (USHORT)(MagicFile->MaximumLength - sizeof(WCHAR));
    MagicFile->Buffer = ExAllocatePool( PagedPool, MagicFile->MaximumLength );
    ASSERT( MagicFile->Buffer != NULL );

    RtlCopyMemory( MagicFile->Buffer, StatusFile->Buffer, dirLength );
    src = magicName;
    dest = (PWCH)((PCHAR)MagicFile->Buffer + dirLength);
    for ( fileLength = strlen(magicName); fileLength >= 0; fileLength-- ) {
        *dest++ = *src++;
    }

    return;

} // SrvCreateMagicSlmName

VOID
SrvDisallowSlmAccess (
    IN PUNICODE_STRING StatusFile,
    IN HANDLE RootDirectory
    )
{
    NTSTATUS status;
    UNICODE_STRING file;
    OBJECT_ATTRIBUTES objectAttributes;
    HANDLE fileHandle;
    IO_STATUS_BLOCK iosb;

    if( SrvSlmFailed ) {
        return;
    }

    SrvSlmFailed = TRUE;

    if( SrvDisallowSlmAccessEnabled == FALSE ) {
        return;
    }

    SrvCreateMagicSlmName( StatusFile, &file );

    InitializeObjectAttributes(
        &objectAttributes,
        &file,
        OBJ_CASE_INSENSITIVE,
        RootDirectory,
        NULL
        );

    KdPrint(( "Disallowing access to SLM directory %wZ\n", &file ));

    status = IoCreateFile(
                 &fileHandle,
                 GENERIC_READ,
                 &objectAttributes,
                 &iosb,
                 NULL,
                 0,
                 FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
                 FILE_OPEN_IF,
                 FILE_NON_DIRECTORY_FILE,
                 NULL,
                 0,
                 CreateFileTypeNone,
                 NULL,
                 0
                 );

    ExFreePool( file.Buffer );

    if ( NT_SUCCESS(status) ) {
        status = iosb.Status;
    }
    if ( NT_SUCCESS(status) ) {
        NtClose( fileHandle );
    } else {
        KdPrint(( "Attempt to disallow SLM access failed: 0x%lx\n", status ));
    }

    return;

} // SrvDisallowSlmAccess

BOOLEAN
SrvIsSlmAccessDisallowed (
    IN PUNICODE_STRING StatusFile,
    IN HANDLE RootDirectory
    )
{
    NTSTATUS status;
    UNICODE_STRING file;
    OBJECT_ATTRIBUTES objectAttributes;
    HANDLE fileHandle;
    IO_STATUS_BLOCK iosb;

    if ( !SrvDisallowSlmAccessEnabled ) {
        return FALSE;
    }

    SrvCreateMagicSlmName( StatusFile, &file );

    InitializeObjectAttributes(
        &objectAttributes,
        &file,
        OBJ_CASE_INSENSITIVE,
        RootDirectory,
        NULL
        );

    status = IoCreateFile(
                 &fileHandle,
                 GENERIC_READ,
                 &objectAttributes,
                 &iosb,
                 NULL,
                 0,
                 FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
                 FILE_OPEN,
                 FILE_NON_DIRECTORY_FILE,
                 NULL,
                 0,
                 CreateFileTypeNone,
                 NULL,
                 0
                 );

    ExFreePool( file.Buffer );

    if ( NT_SUCCESS(status) ) {
        status = iosb.Status;
    }
    if ( NT_SUCCESS(status) ) {
        NtClose( fileHandle );
        return TRUE;
    } else {
        return FALSE;
    }

} // SrvIsSlmAccessDisallowed

BOOLEAN
SrvIsEtcFile (
    IN PUNICODE_STRING FileName
    )
{
    if ( ((RtlUnicodeStringToAnsiSize( FileName ) - 1) >= 4) &&
         (toupper(FileName->Buffer[0]) == 'E') &&
         (toupper(FileName->Buffer[1]) == 'T') &&
         (toupper(FileName->Buffer[2]) == 'C') &&
         (        FileName->Buffer[3]  == '\\') ) {

        return TRUE;

    } else {

        LONG i;

        for ( i = 0;
              i < (LONG)RtlUnicodeStringToAnsiSize( FileName ) - 1 - 4;
              i++ ) {

            if ( (        FileName->Buffer[i]    == '\\') &&
                 (toupper(FileName->Buffer[i+1]) == 'E' ) &&
                 (toupper(FileName->Buffer[i+2]) == 'T' ) &&
                 (toupper(FileName->Buffer[i+3]) == 'C' ) &&
                 (        FileName->Buffer[i+4]  == '\\') ) {

                return TRUE;

            }

        }

    }

    return FALSE;

} // SrvIsEtcFile

BOOLEAN
SrvIsSlmStatus (
    IN PUNICODE_STRING StatusFile
    )
{
    UNICODE_STRING baseName;

    if ( !SrvIsEtcFile( StatusFile ) ) {
        return FALSE;
    }

    SrvGetBaseFileName( StatusFile, &baseName );

    if ( ((RtlUnicodeStringToAnsiSize( &baseName ) - 1) == 10) &&
         (toupper(baseName.Buffer[0]) == 'S') &&
         (toupper(baseName.Buffer[1]) == 'T') &&
         (toupper(baseName.Buffer[2]) == 'A') &&
         (toupper(baseName.Buffer[3]) == 'T') &&
         (toupper(baseName.Buffer[4]) == 'U') &&
         (toupper(baseName.Buffer[5]) == 'S') &&
         (        baseName.Buffer[6]  == '.') &&
         (toupper(baseName.Buffer[7]) == 'S') &&
         (toupper(baseName.Buffer[8]) == 'L') &&
         (toupper(baseName.Buffer[9]) == 'M') ) {
        return TRUE;
    }

    return FALSE;

} // SrvIsSlmStatus

BOOLEAN
SrvIsTempSlmStatus (
    IN PUNICODE_STRING StatusFile
    )
{
    UNICODE_STRING baseName;

    if ( !SrvIsEtcFile( StatusFile ) ) {
        return FALSE;
    }

    SrvGetBaseFileName( StatusFile, &baseName );

    if ( ((RtlUnicodeStringToAnsiSize( &baseName ) - 1) == 5) &&
         (toupper(baseName.Buffer[0]) == 'T') &&
         (        baseName.Buffer[1]  == '0') ) {
        return TRUE;
    }

    return FALSE;

} // SrvIsTempSlmStatus

NTSTATUS
SrvValidateSlmStatus(
    IN HANDLE StatusFile,
    IN PWORK_CONTEXT WorkContext,
    OUT PULONG FileOffsetOfInvalidData
    )
{
    NTSTATUS Status;
    IO_STATUS_BLOCK IoStatus;
    PULONG buffer, p, ep, s;
    LARGE_INTEGER offset;
    ULONG previousRun = 0;
    HANDLE eventHandle;
    OBJECT_ATTRIBUTES obja;
    ULONG key;

#define ZERORUNLEN  2048

#define SLMREADSIZE (10 * 4096)

    if( SrvSlmFailed ) {
        return STATUS_SUCCESS;
    }

    buffer = ExAllocatePoolWithTag( NonPagedPool, SLMREADSIZE, BlockTypeDataBuffer );
    if( buffer == NULL ) {
        return STATUS_SUCCESS;
    }

    *FileOffsetOfInvalidData = 0;
    offset.QuadPart = 0;

    InitializeObjectAttributes( &obja, NULL, OBJ_CASE_INSENSITIVE, NULL, NULL );
    
    Status = NtCreateEvent( &eventHandle,
                   EVENT_ALL_ACCESS,
                   &obja,
                   SynchronizationEvent,
                   FALSE
                 );

    if( !NT_SUCCESS( Status ) ) {
        return STATUS_SUCCESS;
    }

    if( ARGUMENT_PRESENT( WorkContext ) ) {
        key = WorkContext->Rfcb->ShiftedFid |
              SmbGetAlignedUshort( &WorkContext->RequestHeader->Pid );
    }

    //
    // Scan through the file, looking for a run of zeros
    //
    while( 1 ) {

        RtlZeroMemory( &IoStatus, sizeof( IoStatus ) );

        Status = NtReadFile( StatusFile,
                             eventHandle,
                             NULL,
                             NULL,
                             &IoStatus,
                             buffer,
                             SLMREADSIZE,
                             &offset,
                             ARGUMENT_PRESENT( WorkContext ) ? &key : NULL
                           );

        if( Status == STATUS_PENDING ) {
            NtWaitForSingleObject( eventHandle, FALSE, NULL );
        }

        Status = IoStatus.Status;

        if( Status == STATUS_END_OF_FILE ) {
            break;
        }

        if( Status != STATUS_SUCCESS ) {
            NtClose( eventHandle );
            ExFreePool( buffer );
            return Status;
        }
                    
        if( IoStatus.Information == 0 ) {
            break;
        }

        ep = (PULONG)((ULONG)buffer + IoStatus.Information);

        for( p = buffer; p < ep; p++ ) {
            if( *p == 0 ) {
                for( s = p; s < ep && *s == 0; s++ )
                    ;

                if( (ULONG)s - (ULONG)p >= ZERORUNLEN ) {

                    *FileOffsetOfInvalidData = offset.LowPart + ((ULONG)p - (ULONG)buffer);

                    KdPrint(( "SRV: Run of %u zeros in SLM file at offset %u decimal!\n",
                        (ULONG)s - (ULONG)p, *FileOffsetOfInvalidData ));

                    ExFreePool( buffer );
                    NtClose( eventHandle );
                    return STATUS_UNSUCCESSFUL;
                }

                p = s;

            }
        }

        offset.QuadPart += IoStatus.Information;
    }

    NtClose( eventHandle );
    ExFreePool( buffer );

    return( STATUS_SUCCESS );
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\srv\smbclose.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    smbclose.c

Abstract:

    This module contains routines for processing the following SMBs:

        Close

Author:

    David Treadwell (davidtr) 16-Nov-1989

Revision History:

--*/

#include "precomp.h"
#include "smbclose.tmh"
#pragma hdrstop

#ifdef ALLOC_PRAGMA
#pragma alloc_text( PAGE, SrvSmbClose )
#endif

SMB_PROCESSOR_RETURN_TYPE
SrvSmbClose (
    SMB_PROCESSOR_PARAMETERS
    )

/*++

Routine Description:

    Processes a Close SMB.

Arguments:

    SMB_PROCESSOR_PARAMETERS - See smbprocs.h for a description
        of the parameters to SMB processor routines.

Return Value:

    SMB_PROCESSOR_RETURN_TYPE - See smbprocs.h

--*/

{
    PREQ_CLOSE request;
    PRESP_CLOSE response;
    NTSTATUS status = STATUS_SUCCESS;
#ifdef INCLUDE_SMB_IFMODIFIED
    BOOLEAN extendedInfo = FALSE;
    SRV_NETWORK_OPEN_INFORMATION fileNetInfo;
    ULONG flags;
    USN usnValue;
    ULONGLONG fileRefNumber;
#endif

    PSESSION   session;
    PRFCB      rfcb;
    SMB_STATUS SmbStatus = SmbStatusInProgress;

    PAGED_CODE( );

    if (WorkContext->PreviousSMB == EVENT_TYPE_SMB_LAST_EVENT)
        WorkContext->PreviousSMB = EVENT_TYPE_SMB_CLOSE;
    SrvWmiStartContext(WorkContext);

    IF_SMB_DEBUG(OPEN_CLOSE1) {
        KdPrint(( "Close file request header at 0x%p, response header at 0x%p\n",
                    WorkContext->RequestHeader,
                    WorkContext->ResponseHeader ));
        KdPrint(( "Close file request parameters at 0x%p, response parameters at 0x%p\n",
                    WorkContext->RequestParameters,
                    WorkContext->ResponseParameters ));
    }

    //
    // Set up parameters.
    //

    request = (PREQ_CLOSE)(WorkContext->RequestParameters);
    response = (PRESP_CLOSE)(WorkContext->ResponseParameters);

    //
    // If a session block has not already been assigned to the current
    // work context, verify the UID.  If verified, the address of the
    // session block corresponding to this user is stored in the
    // WorkContext block and the session block is referenced.
    //

    session = SrvVerifyUid(
                  WorkContext,
                  SmbGetAlignedUshort( &WorkContext->RequestHeader->Uid )
                  );

    if ( session == NULL ) {

        IF_DEBUG(SMB_ERRORS) {
            KdPrint(( "SrvSmbClose: Invalid UID: 0x%lx\n",
                SmbGetAlignedUshort( &WorkContext->RequestHeader->Uid ) ));
        }

        SrvSetSmbError( WorkContext, STATUS_SMB_BAD_UID );
        SmbStatus = SmbStatusSendResponse;
        goto Cleanup;
    }

    //
    // First, verify the FID.  If verified, the RFCB and the TreeConnect
    // block are referenced and their addresses are stored in the
    // WorkContext block, and the RFCB address is returned.
    //
    // Call SrvVerifyFid, but do not fail (return NULL) if there
    // is a saved write behind error for this rfcb.  The rfcb is
    // needed in order to process the close.
    //

    rfcb = SrvVerifyFid(
                WorkContext,
                SmbGetUshort( &request->Fid ),
                FALSE,
                SrvRestartSmbReceived,   // serialize with raw write
                &status
                );

    if ( rfcb == SRV_INVALID_RFCB_POINTER ) {

        if ( !NT_SUCCESS( status ) ) {

            //
            // Invalid file ID.  Reject the request.
            //

            IF_DEBUG(SMB_ERRORS) {
                KdPrint(( "SrvSmbClose: Invalid FID: 0x%lx\n",
                            SmbGetUshort( &request->Fid ) ));
            }

            SrvSetSmbError( WorkContext, STATUS_INVALID_HANDLE );
            SmbStatus = SmbStatusSendResponse;
            goto Cleanup;
        }

        //
        // The work item has been queued because a raw write is in
        // progress.
        //

        SmbStatus = SmbStatusInProgress;
        goto Cleanup;

    } else if( rfcb->ShareType == ShareTypePrint &&
        WorkContext->UsingBlockingThread == 0 ) {

        //
        // Closing this file will result in the scheduling of a print
        //  job.  This means we will have to talk with srvsvc, a lengthy
        //  operation.  Shift this close over to a blocking thread.
        //
        SrvQueueWorkToBlockingThread( WorkContext );
        SmbStatus = SmbStatusInProgress;
        goto Cleanup;

    } else if ( !NT_SUCCESS( rfcb->SavedError ) ) {

        //
        // Check the saved error.
        //

        (VOID) SrvCheckForSavedError( WorkContext, rfcb );

    }

    //
    // Set the last write time on the file from the time specified in
    // the SMB.  Even though the SMB spec says that this is optional,
    // we must support it for the following reasons:
    //
    //     1) The only way to set a file time in DOS is through a
    //        handle-based API which the DOS redir never sees; the API
    //        just sets the time in DOS's FCB, and the redir is expected
    //        set the time when it closes the file.  Therefore, if we
    //        didn't do this, there would be no way t set a file time
    //        from DOS.
    //
    //     2) It is better for a file to have a redirector's version
    //        of a time than the server's.  This keeps the time
    //        consistent for apps running on the client.  Setting
    //        the file time on close keeps the file time consistent
    //        with the time on the client.
    //
    // !!! should we do anything with the return code from this routine?

    if( rfcb->WriteAccessGranted ||
#ifdef INCLUDE_SMB_IFMODIFIED
        rfcb->WrittenTo ||
#endif
        rfcb->AppendAccessGranted ) {

#ifdef INCLUDE_SMB_IFMODIFIED
        (VOID)SrvSetLastWriteTime(
                  rfcb,
                  SmbGetUlong( &request->LastWriteTimeInSeconds ),
                  rfcb->GrantedAccess,
                  TRUE
                  );
#else
        (VOID)SrvSetLastWriteTime(
                  rfcb,
                  SmbGetUlong( &request->LastWriteTimeInSeconds ),
                  rfcb->GrantedAccess
                  );
#endif
    }

    //
    // Now proceed to do the actual close file, even if there was
    // a write behind error.
    //

#ifdef SLMDBG
    if ( SrvIsSlmStatus( &rfcb->Mfcb->FileName ) &&
         (rfcb->GrantedAccess & FILE_WRITE_DATA) ) {

        ULONG offset;

        status = SrvValidateSlmStatus(
                    rfcb->Lfcb->FileHandle,
                    WorkContext,
                    &offset
                    );

        if ( !NT_SUCCESS(status) ) {
            SrvReportCorruptSlmStatus(
                &rfcb->Mfcb->FileName,
                status,
                offset,
                SLMDBG_CLOSE,
                rfcb->Lfcb->Session
                );
            SrvReportSlmStatusOperations( rfcb, FALSE );
            SrvDisallowSlmAccess(
                &rfcb->Lfcb->FileObject->FileName,
                rfcb->Lfcb->TreeConnect->Share->RootDirectoryHandle
                );
            SrvSetSmbError( WorkContext, STATUS_DISK_CORRUPT_ERROR );
        }

    }
#endif

#ifdef INCLUDE_SMB_IFMODIFIED
    if (request->WordCount == 5 && rfcb->ShareType == ShareTypeDisk) {

        //
        //  This is an extended close request, fill in all the new fields
        //
        status = SrvQueryNetworkOpenInformation(
                    rfcb->Lfcb->FileHandle,
                    rfcb->Lfcb->FileObject,
                    &fileNetInfo,
                    FALSE
                    );

        if ( NT_SUCCESS(status) ) {

            PREQ_EXTENDED_CLOSE extendedRequest = (PREQ_EXTENDED_CLOSE) request;
            LARGE_INTEGER ourUsnValue;
            LARGE_INTEGER ourFileRefNumber;
            BOOLEAN writeClose;

            flags = SmbGetUlong( &extendedRequest->Flags );

            extendedInfo = TRUE;
            usnValue = 0;
            fileRefNumber = 0;

            if (rfcb->Lfcb->FileUpdated) {

                //
                //  the file has been updated, let's close out the current
                //  usn journal entry so that we can get an accurate USN
                //  number (rather than have the entry generated at close).
                //

                rfcb->Lfcb->FileUpdated = FALSE;

                writeClose = TRUE;

            } else {

                writeClose = FALSE;
            }

            //
            //  get the current USN number for this file.
            //

            status = SrvIssueQueryUsnInfoRequest( rfcb,
                                                  writeClose,
                                                  &ourUsnValue,
                                                  &ourFileRefNumber );

            if (NT_SUCCESS(status)) {
                usnValue = ourUsnValue.QuadPart;
                fileRefNumber = ourFileRefNumber.QuadPart;
            } else {
                IF_DEBUG(ERRORS) {
                    KdPrint(( "SrvSmbClose: Query USN info failed: 0x%X for handle %u\n",
                                status, rfcb->Lfcb->FileObject ));
                }
            }
        } else {

            IF_DEBUG(SMB_ERRORS) {
                KdPrint(( "SrvSmbClose: NtGetFileInfo returned 0x%lx\n", status ));
            }
        }
    }
#endif

    SrvCloseRfcb( rfcb );

    //
    // Dereference the RFCB immediately, rather than waiting for normal
    // work context cleanup after the response send completes.  This
    // gets the xFCB structures cleaned up in a more timely manner.
    //
    // *** The specific motivation for this change was to fix a problem
    //     where a compatibility mode open was closed, the response was
    //     sent, and a Delete SMB was received before the send
    //     completion was processed.  This resulted in the MFCB and LFCB
    //     still being present, which caused the delete processing to
    //     try to use the file handle in the LFCB, which we just closed
    //     here.
    //

    SrvDereferenceRfcb( rfcb );
    WorkContext->Rfcb = NULL;
    WorkContext->OplockOpen = FALSE;

#if 0
    //
    // If this is a CloseAndTreeDisc SMB, do the tree disconnect.
    //

    if ( WorkContext->RequestHeader->Command == SMB_COM_CLOSE_AND_TREE_DISC ) {

        IF_SMB_DEBUG(OPEN_CLOSE1) {
            KdPrint(( "Disconnecting tree 0x%lx\n", WorkContext->TreeConnect ));
        }

        SrvCloseTreeConnect( WorkContext->TreeConnect );
    }
#endif

    //
    // Build the response SMB.
    //

#ifdef INCLUDE_SMB_IFMODIFIED
    if ( ! extendedInfo ) {
#endif
        response->WordCount = 0;
        SmbPutUshort( &response->ByteCount, 0 );

        WorkContext->ResponseParameters = NEXT_LOCATION(
                                            response,
                                            RESP_CLOSE,
                                            0
                                            );
#ifdef INCLUDE_SMB_IFMODIFIED
    } else {

        PRESP_EXTENDED_CLOSE extendedResponse = (PRESP_EXTENDED_CLOSE) response;
        LARGE_INTEGER usnToLarge;

        extendedResponse->WordCount = SMB_RESP_EXTENDED_CLOSE_WORK_COUNT;
        SmbPutUshort( &extendedResponse->ByteCount, 0 );
        SmbPutUlong( &extendedResponse->Flags, flags );

        SmbPutUlong(
            &extendedResponse->CreationTime.HighPart,
            fileNetInfo.CreationTime.HighPart
            );
        SmbPutUlong(
            &extendedResponse->CreationTime.LowPart,
            fileNetInfo.CreationTime.LowPart
            );
        SmbPutUlong(
            &extendedResponse->LastWriteTime.HighPart,
            fileNetInfo.LastWriteTime.HighPart
            );
        SmbPutUlong(
            &extendedResponse->LastWriteTime.LowPart,
            fileNetInfo.LastWriteTime.LowPart
            );
        SmbPutUlong(
            &extendedResponse->ChangeTime.HighPart,
            fileNetInfo.ChangeTime.HighPart
            );
        SmbPutUlong(
            &extendedResponse->ChangeTime.LowPart,
            fileNetInfo.ChangeTime.LowPart
            );
        SmbPutUlong(
            &extendedResponse->AllocationSize.HighPart,
            fileNetInfo.AllocationSize.HighPart
            );
        SmbPutUlong(
            &extendedResponse->AllocationSize.LowPart,
            fileNetInfo.AllocationSize.LowPart
            );
        SmbPutUlong(
            &extendedResponse->EndOfFile.HighPart,
            fileNetInfo.EndOfFile.HighPart
            );
        SmbPutUlong(
            &extendedResponse->EndOfFile.LowPart,
            fileNetInfo.EndOfFile.LowPart
            );

        usnToLarge.QuadPart = usnValue;

        SmbPutUlong(
            &extendedResponse->UsnValue.HighPart,
            usnToLarge.HighPart
            );
        SmbPutUlong(
            &extendedResponse->UsnValue.LowPart,
            usnToLarge.LowPart
            );

        usnToLarge.QuadPart = fileRefNumber;

        SmbPutUlong(
            &extendedResponse->FileReferenceNumber.HighPart,
            usnToLarge.HighPart
            );
        SmbPutUlong(
            &extendedResponse->FileReferenceNumber.LowPart,
            usnToLarge.LowPart
            );

        SmbPutUlong( &extendedResponse->FileAttributes, fileNetInfo.FileAttributes );

        WorkContext->ResponseParameters = NEXT_LOCATION(
                                            extendedResponse,
                                            RESP_EXTENDED_CLOSE,
                                            0
                                            );
    }
#endif
    SmbStatus = SmbStatusSendResponse;

Cleanup:
    SrvWmiEndContext(WorkContext);
    return SmbStatus;

} // SrvSmbClose
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\srv\smbfile.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    smbfile.c

Abstract:

    This module implements file-control SMB processors:

        Flush
        Delete
        Rename
        Move
        Copy

Author:

    David Treadwell (davidtr) 15-Dec-1989

Revision History:

--*/

#include "precomp.h"
#include "smbfile.tmh"
#pragma hdrstop

#define BugCheckFileId SRV_FILE_SMBFILE

//
// Forward declarations
//

VOID SRVFASTCALL
BlockingDelete (
    IN OUT PWORK_CONTEXT WorkContext
    );

VOID SRVFASTCALL
BlockingMove (
    IN OUT PWORK_CONTEXT WorkContext
    );

VOID SRVFASTCALL
BlockingRename (
    IN OUT PWORK_CONTEXT WorkContext
    );

NTSTATUS
DoDelete (
    IN PUNICODE_STRING FullFileName,
    IN PUNICODE_STRING RelativeFileName,
    IN PWORK_CONTEXT WorkContext,
    IN USHORT SmbSearchAttributes,
    IN PSHARE Share
    );

NTSTATUS
FindAndFlushFile (
    IN PWORK_CONTEXT WorkContext
    );

VOID SRVFASTCALL
RestartFlush (
    IN OUT PWORK_CONTEXT WorkContext
    );

NTSTATUS
StartFlush (
    IN PWORK_CONTEXT WorkContext,
    IN PRFCB Rfcb
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text( PAGE, SrvSmbFlush )
#pragma alloc_text( PAGE, RestartFlush )
#pragma alloc_text( PAGE, StartFlush )
#pragma alloc_text( PAGE, SrvSmbDelete )
#pragma alloc_text( PAGE, BlockingDelete )
#pragma alloc_text( PAGE, DoDelete )
#pragma alloc_text( PAGE, SrvSmbRename )
#pragma alloc_text( PAGE, BlockingRename )
#pragma alloc_text( PAGE, SrvSmbMove )
#pragma alloc_text( PAGE, BlockingMove )
#pragma alloc_text( PAGE, SrvSmbNtRename )
#endif
#if 0
#pragma alloc_text( PAGECONN, FindAndFlushFile )
#endif


SMB_PROCESSOR_RETURN_TYPE
SrvSmbFlush (
    SMB_PROCESSOR_PARAMETERS
    )

/*++

Routine Description:

    This routine processes the Flush SMB.  It ensures that all data and
    allocation information for the specified file has been written out
    before the response is sent.

Arguments:

    SMB_PROCESSOR_PARAMETERS - See smbtypes.h for a description
        of the parameters to SMB processor routines.

Return Value:

    SMB_PROCESSOR_RETURN_TYPE - See smbtypes.h

--*/

{
    PREQ_FLUSH request;
    PRESP_FLUSH response;

    NTSTATUS   status    = STATUS_SUCCESS;
    SMB_STATUS SmbStatus = SmbStatusInProgress;

    PRFCB rfcb;

    PAGED_CODE( );

    if (WorkContext->PreviousSMB == EVENT_TYPE_SMB_LAST_EVENT)
        WorkContext->PreviousSMB = EVENT_TYPE_SMB_FLUSH;
    SrvWmiStartContext(WorkContext);

    request = (PREQ_FLUSH)WorkContext->RequestParameters;
    response = (PRESP_FLUSH)WorkContext->ResponseParameters;

    IF_SMB_DEBUG(FILE_CONTROL1) {
        KdPrint(( "Flush request; FID 0x%lx\n",
                    SmbGetUshort( &request->Fid ) ));
    }

    //
    // If a FID was specified, flush just that file.  If FID == -1,
    // then flush all files corresponding to the PID passed in the
    // SMB header.
    //

    if ( SmbGetUshort( &request->Fid ) == (USHORT)0xFFFF ) {

        //
        // Find a single file to flush and flush it.  We'll start one
        // flush here, then RestartFlush will handle flushing the rest
        // of the files.
        //

        WorkContext->Parameters.CurrentTableIndex = 0;
        status = FindAndFlushFile( WorkContext );

        if ( status == STATUS_NO_MORE_FILES ) {

            //
            // There were no files that needed to be flushed.  Build and
            // send a response SMB.
            //

            response->WordCount = 0;
            SmbPutUshort( &response->ByteCount, 0 );

            WorkContext->ResponseParameters =
                NEXT_LOCATION( response, RESP_FLUSH, 0 );

            SmbStatus = SmbStatusSendResponse;
            goto Cleanup;
        }

        SmbStatus = SmbStatusInProgress;
        goto Cleanup;
    }

    //
    // Flush of a specific file.  Verify the FID.  If verified, the
    // RFCB block is referenced and its address is stored in the
    // WorkContext block, and the RFCB address is returned.
    //

    rfcb = SrvVerifyFid(
               WorkContext,
               SmbGetUshort( &request->Fid ),
               TRUE,
               SrvRestartSmbReceived,   // serialize with raw write
               &status
               );

    if ( rfcb == SRV_INVALID_RFCB_POINTER ) {

        if ( !NT_SUCCESS( status ) ) {

            //
            // Invalid file ID or write behind error.  Reject the request.
            //

            IF_DEBUG(ERRORS) {
                KdPrint((
                    "SrvSmbFlush: Status %X on FID: 0x%lx\n",
                    status,
                    SmbGetUshort( &request->Fid )
                    ));
            }

            SrvSetSmbError( WorkContext, status );
            SmbStatus = SmbStatusSendResponse;
            goto Cleanup;
        }


        //
        // The work item has been queued because a raw write is in
        // progress.
        //

        SmbStatus = SmbStatusInProgress;
        goto Cleanup;
    }

    //
    // Set the CurrentTableIndex field of the work context block to
    // NULL so that the restart routine will know that only a single
    // file is to be flushed.
    //

    WorkContext->Parameters.CurrentTableIndex = -1;

    IF_SMB_DEBUG(FILE_CONTROL2) {
        KdPrint(( "Flushing buffers for FID %lx, RFCB %p\n", rfcb->Fid, rfcb ));
    }

    //
    // Start the flush operation on the file corresponding to the RFCB.
    //

    status = StartFlush( WorkContext, rfcb );

    if ( !NT_SUCCESS(status) ) {

        //
        // Unable to start the I/O.  Clean up the I/O request.  Return
        // an error to the client.
        //

        SrvSetSmbError( WorkContext, status );
        SmbStatus = SmbStatusSendResponse;
        goto Cleanup;
    }

    //
    // The flush request was successfully started.  Return the InProgress
    // status to the caller, indicating that the caller should do
    // nothing further with the SMB/WorkContext at the present time.
    //
    SmbStatus = SmbStatusInProgress;
    IF_DEBUG(TRACE2) KdPrint(( "SrvSmbFlush complete\n" ));

Cleanup:
    SrvWmiEndContext(WorkContext);
    return SmbStatus;
} // SrvSmbFlush


NTSTATUS
FindAndFlushFile (
    IN PWORK_CONTEXT WorkContext
    )

{
    NTSTATUS status;
    LONG currentTableIndex;
    PRFCB rfcb;
    USHORT pid = SmbGetAlignedUshort( &WorkContext->RequestHeader->Pid );
    PCONNECTION connection = WorkContext->Connection;
    PTABLE_HEADER tableHeader;
    KIRQL oldIrql;

    //UNLOCKABLE_CODE( CONN );

    IF_SMB_DEBUG(FILE_CONTROL1) {
        KdPrint(( "Flush FID == -1; flush all files for PID %lx\n", pid ));
    }

    //
    // Walk the connection's file table, looking an RFCB with a PID
    // equal to the PID passed in the SMB header.
    //
    // Acquire the lock that protects the connection's file table.
    // This prevents an RFCB from going away between when we find a
    // pointer to it and when we reference it.
    //

    tableHeader = &connection->FileTable;
    ACQUIRE_SPIN_LOCK( &connection->SpinLock, &oldIrql );

    for ( currentTableIndex = WorkContext->Parameters.CurrentTableIndex;
          currentTableIndex < (LONG)tableHeader->TableSize;
          currentTableIndex++ ) {

        rfcb = tableHeader->Table[currentTableIndex].Owner;

        IF_SMB_DEBUG(FILE_CONTROL1) {
            KdPrint(( "Looking at RFCB %p, PID %lx, FID %lx\n",
                          rfcb, rfcb != NULL ? rfcb->Pid : 0,
                          rfcb != NULL ? rfcb->Fid : 0 ));
        }

        if ( rfcb == NULL || rfcb->Pid != pid ) {
            continue;
        }

        //
        // Reference the rfcb if it is active.
        //

        if ( GET_BLOCK_STATE(rfcb) != BlockStateActive ) {
            continue;
        }
        rfcb->BlockHeader.ReferenceCount++;

        //
        // Now that the RFCB has been referenced, we can safely
        // release the lock that protects the connection's file
        // table.
        //

        RELEASE_SPIN_LOCK( &connection->SpinLock, oldIrql );

        WorkContext->Rfcb = rfcb;

        //
        // Mark the rfcb as active
        //

        rfcb->IsActive = TRUE;

        //
        // Set the CurrentTableIndex field of the work context
        // block so that the restart routine knows where to
        // continue looking for RFCBs to flush.
        //

        WorkContext->Parameters.CurrentTableIndex = currentTableIndex;

        IF_SMB_DEBUG(FILE_CONTROL2) {
            KdPrint(( "Flushing buffers for FID %lx, RFCB %p\n",
                          rfcb->Fid, rfcb ));
        }

        //
        // Start the I/O to flush the file.
        //

        status = StartFlush( WorkContext, rfcb );

        //
        // If there was an access violation or some other error,
        // simply continue walking through the file table.
        // We ignore these errors for flush with FID=-1.
        //
        // Note that StartFlush only returns an error if the IO
        // operation *was*not* started.  If the operation was
        // started, then errors will be processed in this routine
        // when it is called later by IoCompleteRequest.
        //

        if ( status != STATUS_PENDING ) {
            SrvDereferenceRfcb( rfcb );
            WorkContext->Rfcb = NULL;
            ACQUIRE_SPIN_LOCK( &connection->SpinLock, &oldIrql );
            continue;
        }

        //
        // The flush request has been started.
        //

        IF_DEBUG(TRACE2) KdPrint(( "RestartFlush complete\n" ));
        return STATUS_SUCCESS;

    } // for ( ; ; )   (walk file table)

    RELEASE_SPIN_LOCK( &connection->SpinLock, oldIrql );

    return STATUS_NO_MORE_FILES;

} // FindAndFlushFile


VOID SRVFASTCALL
RestartFlush (
    IN OUT PWORK_CONTEXT WorkContext
    )

/*++

Routine Description:

    Processes flush completion.

Arguments:

    WorkContext - Supplies a pointer to the work context block
        describing server-specific context for the request.

Return Value:

    None.

--*/

{
    NTSTATUS status = STATUS_SUCCESS;
    PRESP_FLUSH response;

    PAGED_CODE( );
    if (WorkContext->PreviousSMB == EVENT_TYPE_SMB_LAST_EVENT)
        WorkContext->PreviousSMB = EVENT_TYPE_SMB_FLUSH;
    SrvWmiStartContext(WorkContext);

    IF_DEBUG(WORKER1) KdPrint(( " - RestartFlush\n" ));

    response = (PRESP_FLUSH)WorkContext->ResponseParameters;

    //
    // If the flush request failed, set an error status in the response
    // header.
    //

    status = WorkContext->Irp->IoStatus.Status;

    //
    // If an error occurred during processing of the flush, return the
    // error to the client.  No more further files will be flushed.
    //
    // *** This should be very rare.  STATUS_DISK_FULL is probably the
    //     main culprit.

    if ( !NT_SUCCESS(status) ) {
        IF_DEBUG(ERRORS) KdPrint(( "Flush failed: %X\n", status ));
        SrvSetSmbError( WorkContext, status );
        SrvEndSmbProcessing( WorkContext, SmbStatusSendResponse );
        IF_DEBUG(TRACE2) KdPrint(( "RestartFlush complete\n" ));
        return;
    }

    IF_SMB_DEBUG(FILE_CONTROL1) {
        KdPrint(( "Flush operation for RFCB %p was successful.\n",
                      WorkContext->Rfcb ));
    }

    //
    // If the FID in the original request was -1, look for more files
    // to flush.
    //

    if ( WorkContext->Parameters.CurrentTableIndex != -1 ) {

        //
        // Dereference the RFCB that was stored in the work context block,
        // and set the pointer to NULL so that it isn't accidentally
        // dereferenced again later.
        //

        SrvDereferenceRfcb( WorkContext->Rfcb );
        WorkContext->Rfcb = NULL;

        //
        // Find a file to flush and flush it.
        //

        WorkContext->Parameters.CurrentTableIndex++;

        status = FindAndFlushFile( WorkContext );

        //
        // If a file was found and IO operation started, then return.  If
        // all the appropriate files have been flushed, send a response SMB.
        //

        if ( status != STATUS_NO_MORE_FILES ) {
            return;
        }

    } // if ( WorkContext->Parameters.CurrentTableIndex != -1 )

    //
    // All files have been flushed.  Build the response SMB.
    //

    response->WordCount = 0;
    SmbPutUshort( &response->ByteCount, 0 );

    WorkContext->ResponseParameters = NEXT_LOCATION( response, RESP_FLUSH, 0 );

    //
    // Processing of the SMB is complete.  Call SrvEndSmbProcessing to
    // send the response.
    //

    SrvEndSmbProcessing( WorkContext, SmbStatusSendResponse );

    IF_DEBUG(TRACE2) KdPrint(( "SrvSmbFlush complete.\n" ));
    SrvWmiEndContext(WorkContext);
    return;

} // RestartFlush


NTSTATUS
StartFlush (
    IN PWORK_CONTEXT WorkContext,
    IN PRFCB Rfcb
    )

/*++

Routine Description:

    Processes the actual file flush.

Arguments:

    WorkContext - Supplies a pointer to the work context block
        describing server-specific context for the request.

    Rfcb - a pointer to the RFCB corresponding to the file to flush.

Return Value:

    STATUS_PENDING if the IO operation was started, or an error from
        CHECK_FUNCTION_ACCESS (STATUS_ACCESS_DENIED, for example).

--*/

{
    NTSTATUS status;

    PAGED_CODE( );

    //
    // Verify that the client has write access to the file via the
    // specified handle.
    //

    CHECK_FUNCTION_ACCESS(
        Rfcb->GrantedAccess,
        IRP_MJ_FLUSH_BUFFERS,
        0,
        0,
        &status
        );

    if ( !NT_SUCCESS(status) ) {

        IF_DEBUG(ERRORS) {
            KdPrint(( "StartFlush: IoCheckFunctionAccess failed: "
              "0x%X, GrantedAccess: %lx.  Access granted anyway.\n",
              status, Rfcb->GrantedAccess ));
        }

        //
        // Some dumb apps flush files opened for r/o.  If this happens,
        // assume the flush worked.  OS/2 let's the
        // flush through and we should do the same.
        //

        WorkContext->Irp->IoStatus.Status = STATUS_SUCCESS;
        RestartFlush( WorkContext );
        return(STATUS_PENDING);
    }

    //
    // Flush the file's buffers.
    //

    SrvBuildFlushRequest(
        WorkContext->Irp,                // input IRP address
        Rfcb->Lfcb->FileObject,          // target file object address
        WorkContext                      // context
        );

    //
    // Pass the request to the file system.
    //

    WorkContext->FsdRestartRoutine = SrvQueueWorkToFspAtDpcLevel;
    WorkContext->FspRestartRoutine = RestartFlush;

    (VOID)IoCallDriver( Rfcb->Lfcb->DeviceObject, WorkContext->Irp );

    return STATUS_PENDING;

} // StartFlush


SMB_PROCESSOR_RETURN_TYPE
SrvSmbDelete (
    SMB_PROCESSOR_PARAMETERS
    )

/*++

Routine Description:

    Processes the Delete SMB.

Arguments:

    SMB_PROCESSOR_PARAMETERS - See smbprocs.h for a description
        of the parameters to SMB processor routines.

Return Value:

    SMB_PROCESSOR_RETURN_TYPE - See smbprocs.h

--*/

{
    PAGED_CODE();

    //
    // This SMB must be processed in a blocking thread.
    //

    if( !WorkContext->UsingBlockingThread ) {
        WorkContext->FspRestartRoutine = BlockingDelete;
        SrvQueueWorkToBlockingThread( WorkContext );
    } else {
        BlockingDelete( WorkContext );
    }

    return SmbStatusInProgress;

} // SrvSmbDelete


VOID SRVFASTCALL
BlockingDelete (
    IN OUT PWORK_CONTEXT WorkContext
    )

/*++

Routine Description:

    This routine processes the Delete SMB.

Arguments:

    SMB_PROCESSOR_PARAMETERS - See smbtypes.h for a description
        of the parameters to SMB processor routines.

Return Value:

    SMB_PROCESSOR_RETURN_TYPE - See smbtypes.h

--*/

{
    PREQ_DELETE request;
    PRESP_DELETE response;

    NTSTATUS status = STATUS_SUCCESS;

    UNICODE_STRING filePathName;
    UNICODE_STRING fullPathName;

    PTREE_CONNECT treeConnect;
    PSESSION session;
    PSHARE share;
    BOOLEAN isUnicode;
    ULONG deleteRetries;
    PSRV_DIRECTORY_INFORMATION directoryInformation;

    PAGED_CODE( );
    if (WorkContext->PreviousSMB == EVENT_TYPE_SMB_LAST_EVENT)
        WorkContext->PreviousSMB = EVENT_TYPE_SMB_DELETE;
    SrvWmiStartContext(WorkContext);

    IF_SMB_DEBUG(FILE_CONTROL1) {
        KdPrint(( "Delete file request header at 0x%p, response header at 0x%p\n",
                    WorkContext->RequestHeader,
                    WorkContext->ResponseHeader ));
        KdPrint(( "Delete file request parameters at 0x%p, response parameters at 0x%p\n",
                    WorkContext->RequestParameters,
                    WorkContext->ResponseParameters ));
    }

    request = (PREQ_DELETE)WorkContext->RequestParameters;
    response = (PRESP_DELETE)WorkContext->ResponseParameters;

    //
    // If a session block has not already been assigned to the current
    // work context , verify the UID.  If verified, the address of the
    // session block corresponding to this user is stored in the
    // WorkContext block and the session block is referenced.
    //
    // Find tree connect corresponding to given TID if a tree connect
    // pointer has not already been put in the WorkContext block by an
    // AndX command.
    //

    status = SrvVerifyUidAndTid(
                WorkContext,
                &session,
                &treeConnect,
                ShareTypeDisk
                );

    if ( !NT_SUCCESS(status) ) {
        IF_DEBUG(SMB_ERRORS) {
            KdPrint(( "SrvSmbDelete: Invalid UID or TID\n" ));
        }
        goto error_exit;
    }

    //
    // If the session has expired, return that info
    //
    if( session->IsSessionExpired )
    {
        status =  SESSION_EXPIRED_STATUS_CODE;
        goto error_exit;
    }

    //
    // Get the share block from the tree connect block.  This doesn't need
    // to be a referenced pointer becsue the tree connect has it referenced,
    // and we just referenced the tree connect.
    //

    share = treeConnect->Share;

    //
    // Initialize the string containing the path name.  The +1 is to account
    // for the ASCII token in the Buffer field of the request SMB.
    //

    isUnicode = SMB_IS_UNICODE( WorkContext );

    status = SrvCanonicalizePathName(
            WorkContext,
            share,
            NULL,
            (PVOID)(request->Buffer + 1),
            END_OF_REQUEST_SMB( WorkContext ),
            TRUE,
            isUnicode,
            &filePathName
            );

    if( !NT_SUCCESS( status ) ) {

        IF_DEBUG(SMB_ERRORS) {
            KdPrint(( "SrvSmbDelete: illegal path name: %s\n",
                        (PSZ)request->Buffer + 1 ));
        }

        goto error_exit;
    }

    //
    // Find out whether there are wildcards in the file name.  If so,
    // then call SrvQueryDirectoryFile to expand the wildcards; if not,
    // just delete the file directly.
    //

    if ( !FsRtlDoesNameContainWildCards( &filePathName ) ) {

        //
        // Build a full pathname to the file.
        //

        SrvAllocateAndBuildPathName(
            &treeConnect->Share->DosPathName,
            &filePathName,
            NULL,
            &fullPathName
            );

        if ( fullPathName.Buffer == NULL ) {

            IF_DEBUG(ERRORS) {
                KdPrint(( "SrvSmbDelete: SrvAllocateAndBuildPathName failed\n" ));
            }

            if ( !isUnicode ) {
                RtlFreeUnicodeString( &filePathName );
            }

            status = STATUS_INSUFF_SERVER_RESOURCES;
            goto error_exit;
        }

        IF_SMB_DEBUG(FILE_CONTROL2) {
            KdPrint(( "Full path name to file is %wZ\n", &fullPathName ));
        }

        //
        // Perform the actual delete operation on this filename.
        //

        deleteRetries = SrvSharingViolationRetryCount;

start_retry1:

        status = DoDelete(
                     &fullPathName,
                     &filePathName,
                     WorkContext,
                     SmbGetUshort( &request->SearchAttributes ),
                     treeConnect->Share
                     );

        if ( (status == STATUS_SHARING_VIOLATION) &&
             (deleteRetries-- > 0) ) {

            (VOID) KeDelayExecutionThread(
                                    KernelMode,
                                    FALSE,
                                    &SrvSharingViolationDelay
                                    );

            goto start_retry1;
        }

        FREE_HEAP( fullPathName.Buffer );

        if ( !isUnicode ) {
            RtlFreeUnicodeString( &filePathName );
        }

        if ( !NT_SUCCESS(status) ) {
            goto error_exit;
        }

    } else {

        BOOLEAN firstCall = TRUE;
        CLONG bufferLength;
        UNICODE_STRING subdirInfo;
        BOOLEAN filterLongNames;

        //
        // A buffer of non-paged pool is required for
        // SrvQueryDirectoryFile.  Since this routine does not use any
        // of the SMB buffer after the pathname of the file to delete,
        // we can use this.  The buffer should be quadword-aligned.
        //

        directoryInformation =
            (PSRV_DIRECTORY_INFORMATION)( (ULONG_PTR)((PCHAR)request->Buffer +
            SmbGetUshort( &request->ByteCount ) + 7) & ~7 );

        bufferLength = WorkContext->RequestBuffer->BufferLength -
                       PTR_DIFF(directoryInformation,
                                WorkContext->RequestBuffer->Buffer);

        //
        // We need the full path name of each file that is returned by
        // SrvQueryDirectoryFile, so we need to find the part of the
        // passed filename that contains subdirectory information (e.g.
        // for a\b\c\*.*, we want a string that indicates a\b\c).
        //

        subdirInfo.Buffer = filePathName.Buffer;
        subdirInfo.Length = SrvGetSubdirectoryLength( &filePathName );
        subdirInfo.MaximumLength = subdirInfo.Length;

        IF_SMB_DEBUG(FILE_CONTROL2) {
            KdPrint(( "Subdirectory info is %wZ\n", &subdirInfo ));
        }

        //
        // Determine whether long filenames (non-8.3) should be filtered out
        // or processed.
        //

        if ( (SmbGetAlignedUshort( &WorkContext->RequestHeader->Flags2 ) &
                                        SMB_FLAGS2_KNOWS_LONG_NAMES) != 0 ) {
            filterLongNames = FALSE;
        } else {
            filterLongNames = TRUE;
        }

        //
        // When we call SrvQueryDirectoryFile, it will open the file for
        // us, so all we have to do is delete it with
        // NtSetInformationFile.
        //
        // *** We ask for FileBothDirectoryInformation so that we will
        //     pick up long names on NTFS that have short name
        //     equivalents.  Without this, DOS clients will not be able
        //     to delete long names on NTFS volumes.
        //

        while ( ( status = SrvQueryDirectoryFile(
                               WorkContext,
                               firstCall,
                               filterLongNames,
                               FALSE,
                               FileBothDirectoryInformation,
                               0,
                               &filePathName,
                               NULL,
                               SmbGetUshort( &request->SearchAttributes ),
                               directoryInformation,
                               bufferLength
                               ) ) != STATUS_NO_MORE_FILES ) {

            PFILE_BOTH_DIR_INFORMATION bothDirInfo;
            UNICODE_STRING name;
            UNICODE_STRING relativeName;

            if ( !NT_SUCCESS(status) ) {

                IF_DEBUG(ERRORS) {
                    KdPrint(( "SrvSmbDelete: SrvQueryDirectoryFile failed: "
                                "%X\n", status ));
                }

                if ( !isUnicode ) {
                    RtlFreeUnicodeString( &filePathName );
                }

                goto error_exit1;
            }

            bothDirInfo =
                (PFILE_BOTH_DIR_INFORMATION)directoryInformation->CurrentEntry;

            //
            // Note that we use the standard name to do the delete, even
            // though we may have matched on the NTFS short name.  The
            // client doesn't care which name we use to do the delete.
            //

            name.Length = (SHORT)bothDirInfo->FileNameLength;
            name.MaximumLength = name.Length;
            name.Buffer = bothDirInfo->FileName;

            IF_SMB_DEBUG(FILE_CONTROL2) {
                KdPrint(( "SrvQueryDirectoryFile--name %wZ, length = %ld, "
                            "status = %X\n",
                            &name,
                            directoryInformation->CurrentEntry->FileNameLength,
                            status ));
            }

            firstCall = FALSE;

            //
            // Build a full pathname to the file.
            //

            SrvAllocateAndBuildPathName(
                &treeConnect->Share->DosPathName,
                &subdirInfo,
                &name,
                &fullPathName
                );

            if ( fullPathName.Buffer == NULL ) {

                IF_DEBUG(ERRORS) {
                    KdPrint(( "SrvSmbDelete: SrvAllocateAndBuildPathName "
                                "failed\n" ));
                }

                if ( !isUnicode ) {
                    RtlFreeUnicodeString( &filePathName );
                }

                status = STATUS_INSUFFICIENT_RESOURCES;
                goto error_exit1;
            }

            IF_SMB_DEBUG(FILE_CONTROL2) {
                KdPrint(( "Full path name to file is %wZ\n", &fullPathName ));
            }

            //
            // Build the relative path name to the file.
            //

            SrvAllocateAndBuildPathName(
                &subdirInfo,
                &name,
                NULL,
                &relativeName
                );

            if ( relativeName.Buffer == NULL ) {

                IF_DEBUG(ERRORS) {
                    KdPrint(( "SrvSmbDelete: SrvAllocateAndBuildPathName failed\n" ));
                }

                FREE_HEAP( fullPathName.Buffer );

                if ( !isUnicode ) {
                    RtlFreeUnicodeString( &filePathName );
                }

                status = STATUS_INSUFF_SERVER_RESOURCES;
                goto error_exit1;
            }

            IF_SMB_DEBUG(FILE_CONTROL2) {
                KdPrint(( "Full path name to file is %wZ\n", &fullPathName ));
            }

            //
            // Perform the actual delete operation on this filename.
            //
            // *** SrvQueryDirectoryFile has already filtered based on
            //     the search attributes, so tell DoDelete that files
            //     with the system and hidden bits are OK.  This will
            //     prevent the call to NtQueryDirectoryFile performed
            //     in SrvCheckSearchAttributesForHandle.

            deleteRetries = SrvSharingViolationRetryCount;

start_retry2:

            status = DoDelete(
                         &fullPathName,
                         &relativeName,
                         WorkContext,
                         (USHORT)(FILE_ATTRIBUTE_SYSTEM | FILE_ATTRIBUTE_HIDDEN),
                         treeConnect->Share
                         );

            if ( (status == STATUS_SHARING_VIOLATION) &&
                 (deleteRetries-- > 0) ) {

                (VOID) KeDelayExecutionThread(
                                        KernelMode,
                                        FALSE,
                                        &SrvSharingViolationDelay
                                        );

                goto start_retry2;
            }

            FREE_HEAP( relativeName.Buffer );
            FREE_HEAP( fullPathName.Buffer );

            if ( !NT_SUCCESS(status) ) {

                if ( !isUnicode ) {
                    RtlFreeUnicodeString( &filePathName );
                }

                goto error_exit1;
            }
        }

        //
        // Close the directory search.
        //

        if ( !isUnicode ) {
            RtlFreeUnicodeString( &filePathName );
        }

        SrvCloseQueryDirectory( directoryInformation );

        //
        // If no files were found, return an error to the client.
        //

        if ( firstCall ) {
            status = STATUS_NO_SUCH_FILE;
            goto error_exit;
        }

    }

    //
    // Build the response SMB.
    //

    response->WordCount = 0;
    SmbPutUshort( &response->ByteCount, 0 );

    WorkContext->ResponseParameters = NEXT_LOCATION(
                                        response,
                                        RESP_DELETE,
                                        0
                                        );

    IF_DEBUG(TRACE2) KdPrint(( "SrvSmbDelete complete.\n" ));
    goto normal_exit;

error_exit1:

    SrvCloseQueryDirectory( directoryInformation );

error_exit:

    SrvSetSmbError( WorkContext, status );

normal_exit:

    SrvEndSmbProcessing( WorkContext, SmbStatusSendResponse );
    SrvWmiEndContext(WorkContext);
    return;

} // BlockingDelete


NTSTATUS
DoDelete (
    IN PUNICODE_STRING FullFileName,
    IN PUNICODE_STRING RelativeFileName,
    IN PWORK_CONTEXT WorkContext,
    IN USHORT SmbSearchAttributes,
    IN PSHARE Share
    )

/*++

Routine Description:

    This routine performs the core of a file delete.

Arguments:

    FileName - a full path name, from the system name space root, to the
        file to delete.

    RelativeFileName - the name of the file relative to the share root.

    WorkContext - context block for the operation.  The RequestHeader and
        Session fields are used.

    SmbSearchAttributes - the search attributes passed in the request
        SMB.  The actual file attributes are verified against these to
        make sure that the operation is legitimate.

Return Value:

    NTSTATUS - indicates result of operation.

--*/

{
    NTSTATUS status;
    PMFCB mfcb;
    PNONPAGED_MFCB nonpagedMfcb;
    FILE_DISPOSITION_INFORMATION fileDispositionInformation;
    HANDLE fileHandle = NULL;
    ULONG caseInsensitive;
    IO_STATUS_BLOCK ioStatusBlock;
    PSRV_LOCK mfcbLock;
    ULONG hashValue;

    PAGED_CODE( );

    //
    // See if that file is already open.  If it is open in
    // compatibility mode or is an FCB open, we have to close all of
    // that client's opens.
    //
    // *** SrvFindMfcb references the MFCB--remember to dereference it.
    //

    if ( (WorkContext->RequestHeader->Flags & SMB_FLAGS_CASE_INSENSITIVE) ||
         WorkContext->Session->UsingUppercasePaths ) {
        caseInsensitive = OBJ_CASE_INSENSITIVE;
        mfcb = SrvFindMfcb( FullFileName, TRUE, &mfcbLock, &hashValue, WorkContext );
    } else {
        caseInsensitive = 0;
        mfcb = SrvFindMfcb( FullFileName, FALSE, &mfcbLock, &hashValue, WorkContext );
    }

    if ( mfcb != NULL ) {
        nonpagedMfcb = mfcb->NonpagedMfcb;
        ACQUIRE_LOCK( &nonpagedMfcb->Lock );
    }

    if( mfcbLock ) {
        RELEASE_LOCK( mfcbLock );
    }

    if ( mfcb == NULL || !mfcb->CompatibilityOpen ) {

        ACCESS_MASK deleteAccess = DELETE;
        OBJECT_ATTRIBUTES objectAttributes;

        //
        // Either the file wasn't opened by the server or it was not
        // a compatibility/FCB open, so open it here for the delete.
        //

del_no_file_handle:

        //
        // If there was an MFCB for this file, we now hold its lock and a
        // referenced pointer.  Undo both.
        //

        if ( mfcb != NULL ) {
            RELEASE_LOCK( &nonpagedMfcb->Lock );
            SrvDereferenceMfcb( mfcb );
        }

        SrvInitializeObjectAttributes_U(
            &objectAttributes,
            RelativeFileName,
            caseInsensitive,
            NULL,
            NULL
            );

        INCREMENT_DEBUG_STAT( SrvDbgStatistics.TotalOpenAttempts );
        INCREMENT_DEBUG_STAT( SrvDbgStatistics.TotalOpensForPathOperations );

        //
        // !!! Currently we can't specify complete if oplocked, because
        //     this won't break a batch oplock.  Unfortunately this also
        //     means that we can't timeout the open (if the oplock break
        //     takes too long) and fail this SMB gracefully.
        //

        status = SrvIoCreateFile(
                     WorkContext,
                     &fileHandle,
                     DELETE,                            // DesiredAccess
                     &objectAttributes,
                     &ioStatusBlock,
                     NULL,                              // AllocationSize
                     0L,                                // FileAttributes
                     0L,                                // ShareAccess
                     FILE_OPEN,                         // Disposition
                     FILE_NON_DIRECTORY_FILE | FILE_OPEN_REPARSE_POINT, // CreateOptions
                     NULL,                              // EaBuffer
                     0L,                                // EaLength
                     CreateFileTypeNone,
                     NULL,                              // ExtraCreateParameters
                     IO_FORCE_ACCESS_CHECK,             // Options
                     WorkContext->TreeConnect->Share
                     );

        if( status == STATUS_INVALID_PARAMETER ) {
            status = SrvIoCreateFile(
                         WorkContext,
                         &fileHandle,
                         DELETE,                            // DesiredAccess
                         &objectAttributes,
                         &ioStatusBlock,
                         NULL,                              // AllocationSize
                         0L,                                // FileAttributes
                         0L,                                // ShareAccess
                         FILE_OPEN,                         // Disposition
                         FILE_NON_DIRECTORY_FILE,           // CreateOptions
                         NULL,                              // EaBuffer
                         0L,                                // EaLength
                         CreateFileTypeNone,
                         NULL,                              // ExtraCreateParameters
                         IO_FORCE_ACCESS_CHECK,             // Options
                         WorkContext->TreeConnect->Share
                         );
        }

        if ( NT_SUCCESS(status) ) {
            SRVDBG_CLAIM_HANDLE( fileHandle, "FIL", 27, 0 );
        }

        ASSERT( status != STATUS_OPLOCK_BREAK_IN_PROGRESS );

        if ( !NT_SUCCESS(status) ) {

            IF_DEBUG(ERRORS) {
                KdPrint(( "SrvSmbDelete: SrvIoCreateFile failed: %X\n",
                            status ));
            }

            //
            // If the user didn't have this permission, update the
            // statistics database.
            //

            if ( status == STATUS_ACCESS_DENIED ) {
                SrvStatistics.AccessPermissionErrors++;
            }

            if ( fileHandle != NULL ) {
                SRVDBG_RELEASE_HANDLE( fileHandle, "FIL", 41, 0 );
                SrvNtClose( fileHandle, TRUE );
            }
            return status;
        }

        //
        // Make sure that the search attributes jive with the attributes
        // on the file.
        //

        status = SrvCheckSearchAttributesForHandle( fileHandle, SmbSearchAttributes );

        if ( !NT_SUCCESS(status) ) {
            SRVDBG_RELEASE_HANDLE( fileHandle, "FIL", 42, 0 );
            SrvNtClose( fileHandle, TRUE );
            return status;
        }

        //
        // Now that the file has been opened, delete it with
        // NtSetInformationFile.
        //

        SrvStatistics.TotalFilesOpened++;

        fileDispositionInformation.DeleteFile = TRUE;

        status = NtSetInformationFile(
                     fileHandle,
                     &ioStatusBlock,
                     &fileDispositionInformation,
                     sizeof(FILE_DISPOSITION_INFORMATION),
                     FileDispositionInformation
                     );

        if ( !NT_SUCCESS(status) ) {

            INTERNAL_ERROR(
                ERROR_LEVEL_UNEXPECTED,
                "SrvSmbDelete: NtSetInformationFile (file disposition) "
                    "returned %X",
                status,
                NULL
                );

            SrvLogServiceFailure( SRV_SVC_NT_SET_INFO_FILE, status );

            SRVDBG_RELEASE_HANDLE( fileHandle, "FIL", 43, 0 );
            SrvNtClose( fileHandle, TRUE );
            return status;
        }

        IF_SMB_DEBUG(FILE_CONTROL2) {
            if( NT_SUCCESS( status ) ) {
                KdPrint(( "SrvSmbDelete: %wZ successfully deleted.\n", FullFileName ));
            }
        }

        //
        // Close the opened file so that it can be deleted.  This will
        // happen automatically, since the FCB_STATE_FLAG_DELETE_ON_CLOSE
        // flag of the FCB has been set by NtSetInformationFile.
        //

        SRVDBG_RELEASE_HANDLE( fileHandle, "FIL", 44, 0 );
        SrvNtClose( fileHandle, TRUE );

    } else {

        FILE_DISPOSITION_INFORMATION fileDispositionInformation;
        HANDLE fileHandle = NULL;

        //
        // The file was opened by the server in compatibility mode
        // or as an FCB open.  Check the granted access to make sure
        // that the file can be deleted.
        //

        ACCESS_MASK deleteAccess = DELETE;
        PLFCB lfcb = CONTAINING_RECORD( mfcb->LfcbList.Blink, LFCB, MfcbListEntry );

        //
        // If this file has been closed.  Go back to no mfcb case.
        //
        // *** The specific motivation for this change was to fix a problem
        //     where a compatibility mode open was closed, the response was
        //     sent, and a Delete SMB was received before the mfcb was
        //     completely cleaned up.  This resulted in the MFCB and LFCB
        //     still being present, which caused the delete processing to
        //     try to use the file handle in the LFCB.
        //

        if ( lfcb->FileHandle == 0 ) {
            goto del_no_file_handle;
        }

        //
        // Make sure that the session which sent this request is the
        // same as the one which has the file open.
        //

        if ( lfcb->Session != WorkContext->Session ) {

            //
            // A different session has the file open in compatibility
            // mode, so reject the request.
            //

            RELEASE_LOCK( &nonpagedMfcb->Lock );
            SrvDereferenceMfcb( mfcb );

            return STATUS_SHARING_