SG
    DECLARE_MESSAGE_MAP()

};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_OPTIONS_H_INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\appverif\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by appverif.rc
//

#include "LogEvents.h"

#define IDM_ABOUTBOX                    0x0010

#define IDS_ABOUTBOX                    1201
#define IDS_APPTITLE                    1202
#define IDS_CANNOT_LOAD_APP_TITLE       1203
#define IDS_NOT_ENOUGH_MEMORY           1204
#define IDS_DELETE_ALL_SETTINGS         1205
#define IDS_TASKP_NEXT_DESCR_STANDARD   1206
#define IDS_TASKP_NEXT_DESCR_DELETE     1208
#define IDS_TASKP_NEXT_DESCR_LOGO       1209
#define IDS_SELECT_AT_LEAST_ONE_APP     1210
#define IDS_SELAPP_FINISH_DESCR         1211
#define IDS_FILE_NAME                   1212
#define IDS_FILE_VERSION                1213
#define IDS_COMPANY                     1214
#define IDS_PRODUCT_NAME                1215
#define IDS_TOO_MANY_FILES_SELECTED     1216
#define IDS_CANNOT_OPEN_FILES           1217
#define IDS_APP_IS_ALREADY_IN_LIST      1218
#define IDS_UNKNOWN                     1219
#define IDS_ACCESS_IS_DENIED            1220
#define IDS_REGOPENKEYEX_FAILED         1221
#define IDS_REGENUMKEYEX_FAILED         1222
#define IDS_INCORRECT_VALUE_TYPE        1223
#define IDS_REGQUERYVALUEEX_FAILED      1224
#define IDS_REGSETVALUEEX_FAILED        1225
#define IDS_REGCREATEKEYEX_FAILED       1226
#define IDS_SETTINGS_SAVED              1227
#define IDR_MAINFRAME                   1228
#define IDS_NO_SETTINGS_CHANGED         1229
#define IDS_SETTINGS_DELETED            1230
#define IDS_VERIFY_LOCKS_CHECKS         1231
#define IDS_VERIFY_HANDLE_CHECKS        1232
#define IDS_PAGE_HEAP                   1233
#define IDS_VERIFY_STACK_CHECKS         1234
#define IDS_ENABLED_QUESTION            1235
#define IDS_TEST_TYPE                   1236
#define IDS_SELBITS_NEXT_DESCR          1237
#define IDS_CANNOT_INITIALIZE_DATA      1242
#define IDS_VERIFY_APPCOMPAT_CHECKS     1243
#define IDS_READLOG_FAILED              1244
#define IDS_NO_SHIMDBC                  1245
#define IDS_PAGEHEAP_CMD_LINE           1246
#define IDS_LOCKS_CMD_LINE              1247
#define IDS_HANDLES_CMD_LINE            1248
#define IDS_STACKS_CMD_LINE             1249
#define IDS_APPCOMPAT_CMD_LINE          1250
#define IDS_HELP_LINE1                  1251
#define IDS_HELP_LINE3                  1252
#define IDS_HELP_LINE4                  1253
#define IDS_HELP_LINE5                  1254
#define IDS_HELP_LINE6                  1255
#define IDS_HELP_LINE7                  1256
#define IDS_HELP_LINE8                  1257
#define IDS_HELP_LINE9                  1258
#define IDS_HELP_LINE10                 1259
#define IDS_HELP_CMDLINE_SWITCH         1260
#define IDS_QUERYSETT_CMDLINE_SWITCH    1261
#define IDS_RESET_CMDLINE_SWITCH        1262
#define IDS_TESTS                       1263
#define IDS_NO_APPS_VERIFIED            1264
#define IDS_HELP_LINE11                 1265
#define IDS_HELP_LINE12                 1266
#define IDS_VIEWSETT_NEXT_DESCR         1280
#define IDS_ENABLED                     1281
#define IDS_DISABLED                    1282
#define IDS_VERIFIED_APPS               1283
#define IDS_TASKP_NEXT_DESCR_VIEW       1284
#define IDS_YES                         1285
#define IDS_NO                          1286
#define IDS_CHOOSEEXE_NEXTDESCR_OPTIONS_STATIC  1287
#define IDS_CHOOSEEXE_NEXTDESCR_RUNEXE_STATIC   1288
#define IDS_RUNAPP_NEXTDESCR_STATIC     1289
#define IDS_OPTIONS_NEXTDESCR_STATIC    1290


#define IDD_APPLICATION_PAGE            2002
#define IDD_TASK_PAGE                   2003
#define IDD_CHOOSEEXE_PAGE              2004
#define IDD_OPTIONS_PAGE                2005
#define IDD_STARTAPP_PAGE               2006
#define IDD_VIEWLOG_PAGE                2007
#define IDD_VIEWSETT_PAGE               2008

#define IDC_SELECTAPPS_LIST             1005
#define IDC_SELECTAPPS_ADD_BUTTON       1006
#define IDC_SELECTAPPS_REMOVE_BUTTON    1007
#define IDC_SELECTAPPS_NEXTDESCR_STATIC 1008
#define IDC_EXE_NAME                    1011
#define IDC_BROWSE                      1012
#define IDC_CRASHDUMP_FILE              1013
#define IDC_DEBUGOUTPUT_STATIC          1014
#define IDC_CREATE_CRASHDUMP_FILE       1015
#define IDC_ISSUE_DESCRIPTION           1016
#define IDC_ISSUES                      1017
#define IDC_RUNAPP                      1018
#define IDC_OUTPUT                      1019
#define IDC_BROWSE_CRASHDUMP            1020
#define IDC_STANDARD_SETTINGS           1021
#define IDC_ADVANCED_SETTINGS           1022
#define IDC_VIEWSETT_APPS_LIST          1030
#define IDC_VIEWSETT_NEXTDESCR_STATIC   1031
#define IDC_VIEWSETT_UPPER_STATIC       1032
#define IDC_VIEWSETT_BITS_LIST          1033
#define IDC_TASKP_STANDARD_RADIO        1040
#define IDC_TASKP_VIEWSETT_RADIO        1041
#define IDC_TASKP_DELETESETT_RADIO      1042
#define IDC_TASKP_LOGO_RADIO            1043
#define IDC_TASKP_NEXTDESCR_STATIC      1045
#define IDC_CHOOSEEXE_NEXTDESCR_STATIC  1046
#define IDC_RUNAPP_NEXTDESCR_STATIC     1047
#define IDC_OPTIONS_NEXTDESCR_STATIC    1048


// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        3000
#define _APS_NEXT_COMMAND_VALUE         30000
#define _APS_NEXT_CONTROL_VALUE         3000
#define _APS_NEXT_SYMED_VALUE           3000
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\appverif\setting.cpp ===
//                                          
// Application Verifier UI
// Copyright (c) Microsoft Corporation, 2001
//
//
//
// module: Setting.cpp
// author: DMihai
// created: 02/22/2001
//
// Description:
//  
//

#include "stdafx.h"
#include "appverif.h"

#include "Setting.h"
#include "AVUtil.h"
#include "DBSupport.h"
#include "AVGlobal.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
//
// Global data:

/////////////////////////////////////////////////////////////////////////////
//
// New app verifier settings
//

CAVSettings g_NewSettings;

//
// Current settings bits - used as temporary variable
// to store custom settings bits between the settings bits
// page and the app selection page.
//

DWORD g_dwNewSettingBits;

/////////////////////////////////////////////////////////////////////////////
//
// Changed settings? If yes, the program will exit with AV_EXIT_CODE_RESTART
//

BOOL g_bChangedSettings = FALSE;

/////////////////////////////////////////////////////////////////////////////
CAppAndBitsArray g_aAppsAndBitsFromRegistry;

/////////////////////////////////////////////////////////////////////////////
//
// Registry keys/values names
//

const TCHAR g_szImageOptionsKeyName[] = _T( "Software\\Microsoft\\Windows NT\\CurrentVersion\\Image File Execution Options" );
const TCHAR g_szGlobalFlagValueName[] = _T( "GlobalFlag" );
const TCHAR g_szVerifierFlagsValueName[] = _T( "VerifierFlags" );

/////////////////////////////////////////////////////////////////////////////
//
// Bit names
//

BIT_LISTNAME_CMDLINESWITCH g_AllNamesAndBits[ 5 ] = 
{
    {
        IDS_PAGEHEAP_CMD_LINE,
        IDS_PAGE_HEAP,
        RTL_VRF_FLG_FULL_PAGE_HEAP
    },
    {
        IDS_LOCKS_CMD_LINE,
        IDS_VERIFY_LOCKS_CHECKS,
        RTL_VRF_FLG_LOCK_CHECKS
    },
    {
        IDS_HANDLES_CMD_LINE,
        IDS_VERIFY_HANDLE_CHECKS,
        RTL_VRF_FLG_HANDLE_CHECKS
    },
    {
        IDS_STACKS_CMD_LINE,
        IDS_VERIFY_STACK_CHECKS,
        RTL_VRF_FLG_STACK_CHECKS
    },
    {
        IDS_APPCOMPAT_CMD_LINE,
        IDS_VERIFY_APPCOMPAT_CHECKS,
        RTL_VRF_FLG_APPCOMPAT_CHECKS
    },
};

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
//
// CApplicationData class
//

CApplicationData::CApplicationData( LPCTSTR szFileName,
                                    LPCTSTR szFullPath,
                                    ULONG uSettingsBits )
{
    m_strExeFileName = szFileName;
    m_uCustomFlags = uSettingsBits;

    m_bSaved = FALSE;
    
    LoadAppVersionData( szFullPath );
}

/////////////////////////////////////////////////////////////////////////////
//
// This version of the constructor will not try to load version info
//

CApplicationData::CApplicationData( LPCTSTR szFileName,
                                    ULONG uSettingsBits )
{
    ASSERT( FALSE != g_bCommandLineMode );

    m_strExeFileName = szFileName;
    m_uCustomFlags = uSettingsBits;

    m_bSaved = FALSE;
}

/////////////////////////////////////////////////////////////////////////////
VOID CApplicationData::LoadAppVersionData( LPCTSTR szFileName )
{
    BOOL bResult;
    PVOID pWholeVerBlock;
    PVOID pTranslationInfoBuffer;
    LPCTSTR szVariableValue;
    LPTSTR szAppFullPath;
    DWORD dwWholeBlockSize;
    DWORD dwDummyHandle;
    UINT uInfoLengthInTChars;
    TCHAR szLocale[ 32 ];
    TCHAR szBlockName[ 64 ];
    CString strAppFullPath;

    bResult = FALSE;

    //
    // Get the size of the file info block
    //
    // GetFileVersionInfoSize doesn't know about 
    // const pointers so we need to GetBuffer here :-(
    //

    strAppFullPath = szFileName;

    szAppFullPath = strAppFullPath.GetBuffer( strAppFullPath.GetLength() + 1 );

    if( NULL == szAppFullPath )
    {
        goto InitializeWithDefaults;
    }

    dwWholeBlockSize = GetFileVersionInfoSize( szAppFullPath,
                                               &dwDummyHandle );

    strAppFullPath.ReleaseBuffer();

    if( dwWholeBlockSize == 0 )
    {
        //
        // Couldn't read version information
        //

        goto InitializeWithDefaults;
    }

    //
    // Allocate the buffer for the version information
    //

    pWholeVerBlock = malloc( dwWholeBlockSize );

    if( pWholeVerBlock == NULL )
    {
        goto InitializeWithDefaults;
    }

    //
    // Get the version information
    //
    // GetFileVersionInfo doesn't know about 
    // const pointers so we need to GetBuffer here :-(
    //

    szAppFullPath = strAppFullPath.GetBuffer( strAppFullPath.GetLength() + 1 );

    if( NULL == szAppFullPath )
    {
        free( pWholeVerBlock );

        goto InitializeWithDefaults;
    }

    bResult = GetFileVersionInfo(
        szAppFullPath,
        dwDummyHandle,
        dwWholeBlockSize,
        pWholeVerBlock );

    strAppFullPath.ReleaseBuffer();

    if( bResult != TRUE )
    {
        free( pWholeVerBlock );

        goto InitializeWithDefaults;
    }

    //
    // Get the locale info
    //

    bResult = VerQueryValue(
        pWholeVerBlock,
        _T( "\\VarFileInfo\\Translation" ),
        &pTranslationInfoBuffer,
        &uInfoLengthInTChars );

    if( TRUE != bResult || NULL == pTranslationInfoBuffer )
    {
        free( pWholeVerBlock );

        goto InitializeWithDefaults;
    }

    //
    // Locale info comes back as two little endian words.
    // Flip 'em, 'cause we need them big endian for our calls.
    //

    _stprintf(
        szLocale,
        _T( "%02X%02X%02X%02X" ),
		HIBYTE( LOWORD ( * (LPDWORD) pTranslationInfoBuffer) ),
		LOBYTE( LOWORD ( * (LPDWORD) pTranslationInfoBuffer) ),
		HIBYTE( HIWORD ( * (LPDWORD) pTranslationInfoBuffer) ),
		LOBYTE( HIWORD ( * (LPDWORD) pTranslationInfoBuffer) ) );

    //
    // Get the file version
    //

    _stprintf(
        szBlockName,
        _T( "\\StringFileInfo\\%s\\FileVersion" ),
        szLocale );

    bResult = VerQueryValue(
        pWholeVerBlock,
        szBlockName,
        (PVOID*) &szVariableValue,
        &uInfoLengthInTChars );

    if( TRUE != bResult || 0 == uInfoLengthInTChars )
    {
        //
        // Couldn't find the version
        //

        VERIFY( m_strFileVersion.LoadString( IDS_UNKNOWN ) );
    }
    else
    {
        //
        // Found the version
        //

        m_strFileVersion = szVariableValue;
    }

    //
    // Get the company name
    //

    _stprintf(
        szBlockName,
        _T( "\\StringFileInfo\\%s\\CompanyName" ),
        szLocale );

    bResult = VerQueryValue(
        pWholeVerBlock,
        szBlockName,
        (PVOID*) &szVariableValue,
        &uInfoLengthInTChars );

    if( TRUE != bResult || uInfoLengthInTChars == 0 )
    {
        //
        // Coudln't find the company name
        //

        m_strCompanyName.LoadString( IDS_UNKNOWN );
    }
    else
    {
        m_strCompanyName = szVariableValue;
    }

    //
    // Get the ProductName
    //

    _stprintf(
        szBlockName,
        _T( "\\StringFileInfo\\%s\\ProductName" ),
        szLocale );

    bResult = VerQueryValue(
        pWholeVerBlock,
        szBlockName,
        (PVOID*) &szVariableValue,
        &uInfoLengthInTChars );

    if( TRUE != bResult || uInfoLengthInTChars == 0 )
    {
        //
        // Coudln't find the ProductName
        //

        m_strProductName.LoadString( IDS_UNKNOWN );
    }
    else
    {
        m_strProductName = szVariableValue;
    }

    //
    // clean-up
    //

    free( pWholeVerBlock );

    goto Done;

InitializeWithDefaults:
    
    m_strCompanyName.LoadString( IDS_UNKNOWN );
    m_strFileVersion.LoadString( IDS_UNKNOWN );
    m_strProductName.LoadString( IDS_UNKNOWN );

Done:

    NOTHING;
}

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
//
// CApplicationDataArray class
//

CApplicationDataArray::~CApplicationDataArray()
{
    DeleteAll();
}

/////////////////////////////////////////////////////////////////////////////
CApplicationData *CApplicationDataArray::GetAt( INT_PTR nIndex )
{
    CApplicationData *pRetValue = (CApplicationData *)CObArray::GetAt( nIndex );
    
    ASSERT_VALID( pRetValue );
    
    return pRetValue;
}

/////////////////////////////////////////////////////////////////////////////
VOID CApplicationDataArray::DeleteAll()
{
    INT_PTR nArraySize;
    CApplicationData *pCrtAppData;

    nArraySize = GetSize();

    while( nArraySize > 0 )
    {
        nArraySize -= 1;

        pCrtAppData = GetAt( nArraySize );

        ASSERT_VALID( pCrtAppData );

        delete pCrtAppData;
    }

    RemoveAll();
}

/////////////////////////////////////////////////////////////////////////////
VOID CApplicationDataArray::DeleteAt( INT_PTR nIndex )
{
    CApplicationData *pCrtAppData;

    pCrtAppData = GetAt( nIndex );

    ASSERT_VALID( pCrtAppData );

    delete pCrtAppData;

    RemoveAt( nIndex );
}

/////////////////////////////////////////////////////////////////////////////
BOOL CApplicationDataArray::IsFileNameInList( LPCTSTR szFileName )
{
    INT_PTR nCrtElement;
    INT_PTR nSize;
    BOOL bFound;
    CApplicationData *pCrtAppData;

    bFound = FALSE;

    nSize = GetSize();

    for( nCrtElement = 0; nCrtElement < nSize; nCrtElement += 1 )
    {
        pCrtAppData = GetAt( nCrtElement );

        ASSERT_VALID( pCrtAppData );

        if( 0 == pCrtAppData->m_strExeFileName.CompareNoCase( szFileName ) )
        {
            bFound = TRUE;
            break;
        }
    }

    return bFound;
}

/////////////////////////////////////////////////////////////////////////////
INT_PTR CApplicationDataArray::FileNameIndex( LPCTSTR szFileName )
{
    INT_PTR nCrtElement;
    INT_PTR nSize;
    BOOL bFound;
    CApplicationData *pCrtAppData;

    bFound = FALSE;

    nSize = GetSize();

    for( nCrtElement = 0; nCrtElement < nSize; nCrtElement += 1 )
    {
        pCrtAppData = GetAt( nCrtElement );

        ASSERT_VALID( pCrtAppData );

        if( 0 == pCrtAppData->m_strExeFileName.CompareNoCase( szFileName ) )
        {
            bFound = TRUE;
            break;
        }
    }

    if( FALSE == bFound )
    {
        nCrtElement = -1;
    }

    return nCrtElement;
}

/////////////////////////////////////////////////////////////////////////////
INT_PTR CApplicationDataArray::AddNewAppData( LPCTSTR szFileName,
                                              LPCTSTR szFullPath,
                                              ULONG uSettingsBits )
{
    INT_PTR nIndexInArray;
    CApplicationData *pNewAppData;

    nIndexInArray = -1;

    pNewAppData = new CApplicationData( szFileName,
                                        szFullPath,
                                        uSettingsBits );

    if( NULL != pNewAppData )
    {
        nIndexInArray = Add( pNewAppData );
    }

    return nIndexInArray;
}

/////////////////////////////////////////////////////////////////////////////
INT_PTR CApplicationDataArray::AddNewAppDataConsoleMode( LPCTSTR szFileName,
                                                         ULONG uSettingsBits )
{
    INT_PTR nIndexInArray;
    CApplicationData *pNewAppData;

    ASSERT( FALSE != g_bCommandLineMode );

    nIndexInArray = -1;

    //
    // This version of the constructor will not try to load version info
    //

    pNewAppData = new CApplicationData( szFileName,
                                        uSettingsBits );

    if( NULL != pNewAppData )
    {
        nIndexInArray = Add( pNewAppData );
    }

    return nIndexInArray;
}

/////////////////////////////////////////////////////////////////////////////
VOID CApplicationDataArray::SetAllSaved( BOOL bSaved )
{
    INT_PTR nCrtElement;
    INT_PTR nSize;
    CApplicationData *pCrtAppData;

    nSize = GetSize();

    for( nCrtElement = 0; nCrtElement < nSize; nCrtElement += 1 )
    {
        pCrtAppData = GetAt( nCrtElement );

        ASSERT_VALID( pCrtAppData );

        pCrtAppData->m_bSaved = bSaved;
    }
}


/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
//
// CAVSettings class
//

CAVSettings::CAVSettings()
{
    m_SettingsType = AVSettingsTypeUnknown;
}

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
//
// CAppAndBits class
//

CAppAndBits::CAppAndBits( LPCTSTR szAppName, DWORD dwEnabledBits )
            : m_strAppName( szAppName ),
              m_dwEnabledBits( dwEnabledBits )
{
    NOTHING;
}

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
//
// CAppAndBitsArray class
//

CAppAndBitsArray::~CAppAndBitsArray()
{
    DeleteAll();
}

/////////////////////////////////////////////////////////////////////////////
CAppAndBits *CAppAndBitsArray::GetAt( INT_PTR nIndex )
{
    CAppAndBits *pRetValue = (CAppAndBits *)CObArray::GetAt( nIndex );
    
    ASSERT_VALID( pRetValue );
    
    return pRetValue;
}

/////////////////////////////////////////////////////////////////////////////
VOID CAppAndBitsArray::DeleteAll()
{  
    INT_PTR nArraySize;
    CAppAndBits *pCrtElem;

    nArraySize = GetSize();

    while( nArraySize > 0 )
    {
        nArraySize -= 1;

        pCrtElem = GetAt( nArraySize );

        ASSERT_VALID( pCrtElem );

        delete pCrtElem;
    }

    RemoveAll();
}

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
//
// Helper functions
//

BOOL AVSetVerifierFlags( HKEY hKey,
                         DWORD dwNewVerifierFlags,
                         BOOL bTryReadingOldValues,
                         BOOL *pbValuesChanged,
                         BOOL bDeleteOtherSettings )
{
    BOOL bSuccess;
    LONG lResult;
    DWORD dwOldVerifierFlags;
    DWORD dwDataSize;
    DWORD dwType;
        
    bSuccess = TRUE;

    if( FALSE != bTryReadingOldValues )
    {
        //
        // Read the existing app verifier flags
        //

        dwDataSize = sizeof( dwOldVerifierFlags );

        lResult = RegQueryValueEx( hKey,
                                   g_szVerifierFlagsValueName,
                                   NULL,
                                   &dwType,
                                   (LPBYTE) &dwOldVerifierFlags,
                                   &dwDataSize );

        if( lResult != ERROR_SUCCESS )
        {
            switch( lResult )
            {
            case ERROR_FILE_NOT_FOUND:
                //
                // No VerifierFlags for this image currently
                //

                dwOldVerifierFlags = 0;

                break;

            case ERROR_ACCESS_DENIED:
                AVErrorResourceFormat( IDS_ACCESS_IS_DENIED );

                bSuccess = FALSE;

                goto Done;

            default:
                AVErrorResourceFormat( IDS_REGQUERYVALUEEX_FAILED,
                                       g_szVerifierFlagsValueName,
                                       (DWORD)lResult);

                bSuccess = FALSE;

                goto Done;
            }
        }
        else
        {
            if( REG_DWORD != dwType )
            {
                AVErrorResourceFormat( IDS_INCORRECT_VALUE_TYPE,
                                       g_szVerifierFlagsValueName,
                                       dwType );

                bSuccess = FALSE;

                goto Done;
            }
        }
    }
    else
    {
        //
        // We know this is a new regkey so we don't have any verifier flags yet
        //

        dwOldVerifierFlags = 0;
    }

    //
    // New app verifier flags
    //

    if( dwNewVerifierFlags != dwOldVerifierFlags || dwNewVerifierFlags == 0 )
    {
        lResult = RegSetValueEx( hKey,
                                 g_szVerifierFlagsValueName,
                                 0,
                                 REG_DWORD,
                                 (PBYTE) &dwNewVerifierFlags,
                                 sizeof( dwNewVerifierFlags ) );

        if( lResult != ERROR_SUCCESS )
        {
            if( ERROR_ACCESS_DENIED == lResult )
            {
                AVErrorResourceFormat( IDS_ACCESS_IS_DENIED );
            }
            else
            {
                AVErrorResourceFormat( IDS_REGSETVALUEEX_FAILED,
                                       g_szVerifierFlagsValueName,
                                       (DWORD)lResult);
            }

            bSuccess = FALSE;
        }
        else
        {
            *pbValuesChanged = TRUE;
        }
    }

Done:
    return bSuccess;
}

/////////////////////////////////////////////////////////////////////////////
BOOL AVSetVerifierFlagsForExe( LPCTSTR szExeName, 
                               DWORD dwNewVerifierFlags )
{
    LONG  lResult;
    HKEY  hImageOptionsKey = NULL, hSubKey = NULL;
    BOOL  bValuesChanged;
    BOOL  bSuccess;
    DWORD dwValueType;
    DWORD dwGlobalFlagValueBufferSize;
    TCHAR szOldGlobalFlagValue[ 32 ];
    
    //
    // Open the Image File Execution Options regkey
    //

    lResult = RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                            g_szImageOptionsKeyName,
                            0,
                            KEY_CREATE_SUB_KEY | KEY_ENUMERATE_SUB_KEYS,
                            &hImageOptionsKey );
    
    if( lResult != ERROR_SUCCESS )
    {
        return FALSE;
    }
    
    lResult = RegCreateKeyEx( hImageOptionsKey,
                              szExeName,
                              0,
                              NULL,
                              REG_OPTION_NON_VOLATILE,
                              KEY_QUERY_VALUE | KEY_SET_VALUE,
                              NULL,
                              &hSubKey,
                              NULL );

    if( lResult == ERROR_SUCCESS )
    {
        dwGlobalFlagValueBufferSize = sizeof( szOldGlobalFlagValue );

        lResult = RegQueryValueEx( hSubKey,
                                   g_szGlobalFlagValueName,
                                   NULL,
                                   &dwValueType,
                                   (LPBYTE) &szOldGlobalFlagValue[ 0 ],
                                   &dwGlobalFlagValueBufferSize );
        
        if( lResult == ERROR_FILE_NOT_FOUND ) 
        {
            szOldGlobalFlagValue[ 0 ] = (TCHAR)0;
            lResult = ERROR_SUCCESS;
        }
        
        if( lResult == ERROR_SUCCESS )
        {
            DWORD dwGlobalFlags;
            BOOL  bSuccesfullyConverted;
            
            bSuccesfullyConverted = AVRtlCharToInteger( szOldGlobalFlagValue,
                                                        0,
                                                        &dwGlobalFlags );

            if( !bSuccesfullyConverted )
            {
                dwGlobalFlags = 0;
            }

            if ( dwNewVerifierFlags == 0)
            {
                dwGlobalFlags &= ~FLG_APPLICATION_VERIFIER;
            }
            else
            {
                dwGlobalFlags |= FLG_APPLICATION_VERIFIER;
            }
            
            bSuccess = AVWriteStringHexValueToRegistry( hSubKey,
                                                        g_szGlobalFlagValueName,
                                                        dwGlobalFlags );
            
            bSuccess = bSuccess && AVSetVerifierFlags( hSubKey, 
                                                       dwNewVerifierFlags, 
                                                       FALSE, 
                                                       &bValuesChanged,
                                                       TRUE );
        }
    }
    
    if ( hSubKey != NULL )
    {
        VERIFY( ERROR_SUCCESS == RegCloseKey( hSubKey ) );
    }
    
    if ( hImageOptionsKey != NULL )
    {
        VERIFY( ERROR_SUCCESS == RegCloseKey( hImageOptionsKey ) );
    }
    
    return bSuccess;
}


/////////////////////////////////////////////////////////////////////////////
BOOL AVCreateAppSettings( HKEY hKey,
                          BOOL bTryReadingOldValues,
                          LPCTSTR szOldGlobalFlagValue,
                          CApplicationData *pCrtAppData,
                          PBOOL pbValuesChanged,
                          CStringArray &astrAppCompatTestedExes,
                          BOOL bDeleteOtherSettings )
{
    BOOL bSuccess;
    BOOL bSuccesfullyConverted;
    DWORD dwOldGlobalFlags;
    DWORD dwNewGlobalFlags;
    DWORD dwNewVerifierFlags;

    bSuccess = TRUE;

    *pbValuesChanged = FALSE;

    if( NULL != pCrtAppData )
    {
        ASSERT_VALID( pCrtAppData );
    }

    if( FALSE != bTryReadingOldValues )
    {
        //
        // Convert the REG_SZ GlobalFlag value to a DWORD
        //

        bSuccesfullyConverted = AVRtlCharToInteger( szOldGlobalFlagValue,
                                                    0,
                                                    &dwOldGlobalFlags );
                                 
        if( FALSE == bSuccesfullyConverted )
        {
            dwOldGlobalFlags = 0;
        }
    }
    else
    {
        //
        // This is a new regkey so we know we don't have any GlobalFlag yet
        //

        dwOldGlobalFlags = 0;
    }

    if( 0 != (FLG_APPLICATION_VERIFIER & dwOldGlobalFlags) )
    {
        //
        // This app used to have the verifier enabled
        //

        if( NULL == pCrtAppData || 
            ( AVSettingsTypeCustom == g_NewSettings.m_SettingsType &&
              0 == pCrtAppData->m_uCustomFlags ) )
        {
            //
            // The user didn't specify this app to verified
            //

            if( FALSE != bDeleteOtherSettings )
            {
                //
                // This app will not have the verifier enabled from now on
                //

                dwNewGlobalFlags = dwOldGlobalFlags & ~FLG_APPLICATION_VERIFIER;
            }
            else
            {
                //
                // Even if the user didn't specify this app
                // she actually wants to keep the existing settings for this app.
                //

                goto Done;
            }
        }
        else
        {
            //
            // This app will continue to have the verifier enabled from now on.
            // Set the new verifier flags though.
            //

            if( AVSettingsTypeStandard == g_NewSettings.m_SettingsType )
            {
                dwNewVerifierFlags = AV_ALL_STANDARD_VERIFIER_FLAGS;
            }
            else
            {
                dwNewVerifierFlags = pCrtAppData->m_uCustomFlags;
            }

            bSuccess = AVSetVerifierFlags( hKey,
                                           dwNewVerifierFlags,
                                           bTryReadingOldValues,
                                           pbValuesChanged,
                                           bDeleteOtherSettings );

            if( FALSE != bSuccess && 
                ( dwNewVerifierFlags & RTL_VRF_FLG_APPCOMPAT_CHECKS ) != 0  )
            {
                //
                // This app has app compat checks enabled
                //

                astrAppCompatTestedExes.Add( pCrtAppData->m_strExeFileName );
            }

            goto Done;
        }
    }
    else
    {
        //
        // This app didn't have the app verifier enabled until now
        //

        if( NULL == pCrtAppData || 
            ( AVSettingsTypeCustom == g_NewSettings.m_SettingsType &&
              0 == pCrtAppData->m_uCustomFlags ) )
        {
            //
            // This app will NOT have the verifier enabled from now on.
            // Nothing to change.
            //

            goto Done;
        }
        else 
        {
            //
            // This app will have the verifier enabled from now on.
            //

            dwNewGlobalFlags = dwOldGlobalFlags | FLG_APPLICATION_VERIFIER;
        }
    }

    ASSERT( dwNewGlobalFlags != dwOldGlobalFlags );

    //
    // Write the new global flags for this app
    //

    bSuccess = AVWriteStringHexValueToRegistry( hKey,
                                                g_szGlobalFlagValueName,
                                                dwNewGlobalFlags );
    if( FALSE != bSuccess )
    {
        *pbValuesChanged = TRUE;

        //
        // Set the new verifier flags
        //

        if( AVSettingsTypeStandard == g_NewSettings.m_SettingsType )
        {
            dwNewVerifierFlags = AV_ALL_STANDARD_VERIFIER_FLAGS;
        }
        else
        {
            if( NULL != pCrtAppData )
            {
                dwNewVerifierFlags = pCrtAppData->m_uCustomFlags;
            }
            else
            {
                dwNewVerifierFlags = 0;
            }
        }

        bSuccess = AVSetVerifierFlags( hKey,
                                       dwNewVerifierFlags,
                                       bTryReadingOldValues,
                                       pbValuesChanged,
                                       bDeleteOtherSettings );

        if( FALSE != bSuccess && 
            NULL != pCrtAppData &&
            ( dwNewVerifierFlags & RTL_VRF_FLG_APPCOMPAT_CHECKS ) != 0  )
        {
            //
            // This app has app compat checks enabled
            //

            astrAppCompatTestedExes.Add( pCrtAppData->m_strExeFileName );
        }
    }



Done:

    return bSuccess;
}

/////////////////////////////////////////////////////////////////////////////
//
// Save the new app verifier settings for one image
//

BOOL AVSaveAppNewSettings( HKEY hKey,
                           BOOL bTryReadingOldValues,
                           LPCTSTR szAppName,
                           PBOOL pbAnythingChanged,
                           CStringArray &astrAppCompatTestedExes,
                           BOOL bDeleteOtherSettings )
{
    BOOL bSuccess;
    BOOL bValuesChanged;
    INT_PTR nIndexInArray;
    LONG lResult;
    DWORD dwGlobalFlagValueBufferSize;
    DWORD dwValueType;
    CApplicationData *pCrtAppData;
    TCHAR szOldGlobalFlagValue[ 32 ];

    bSuccess = TRUE;

    if( FALSE != bTryReadingOldValues )
    {
        //
        // See if the app verifier flag is currently enabled for this app
        //

        dwGlobalFlagValueBufferSize = sizeof( szOldGlobalFlagValue );

        lResult = RegQueryValueEx( hKey,
                                   g_szGlobalFlagValueName,
                                   NULL,
                                   &dwValueType,
                                   (LPBYTE) &szOldGlobalFlagValue[ 0 ],
                                   &dwGlobalFlagValueBufferSize );

        if( lResult != ERROR_SUCCESS ) 
        {
            switch( lResult )
            {
            case ERROR_FILE_NOT_FOUND:
                //
                // No GlobalFlag for this image currently
                //

                szOldGlobalFlagValue[ 0 ] = (TCHAR)0;
                break;

            case ERROR_ACCESS_DENIED:
                AVErrorResourceFormat( IDS_ACCESS_IS_DENIED );

                bSuccess = FALSE;

                goto Done;

            default:
                AVErrorResourceFormat( IDS_REGQUERYVALUEEX_FAILED,
                                       g_szGlobalFlagValueName,
                                       (DWORD)lResult);

                bSuccess = FALSE;

                goto Done;
            }
        }
        else 
        {
            if( REG_SZ != dwValueType )
            {
                AVErrorResourceFormat( IDS_INCORRECT_VALUE_TYPE,
                                       g_szGlobalFlagValueName,
                                       dwValueType );

                bSuccess = FALSE;

                goto Done;
            }
        }
    }
    else
    {
        //
        // This is a new subkey so we don't have any GlobalFlag yet
        //

        szOldGlobalFlagValue[ 0 ] = (TCHAR)0;
    }

    nIndexInArray = g_NewSettings.m_aApplicationData.FileNameIndex( szAppName );

    if( nIndexInArray >= 0 )
    {
        //
        // This app will be verified from now on.
        //

        pCrtAppData = g_NewSettings.m_aApplicationData.GetAt( nIndexInArray );

        ASSERT_VALID( pCrtAppData );
    }
    else
    {
        //
        // This app will not be verified from now on.
        //

        pCrtAppData = NULL;
    }

    bSuccess = AVCreateAppSettings( hKey,
                                    bTryReadingOldValues,
                                    szOldGlobalFlagValue,
                                    pCrtAppData,
                                    &bValuesChanged,
                                    astrAppCompatTestedExes,
                                    bDeleteOtherSettings );

    if( FALSE != bSuccess )
    {
        if( NULL != pCrtAppData )
        {
            pCrtAppData->m_bSaved = TRUE;
        }

        *pbAnythingChanged = *pbAnythingChanged || bValuesChanged;
    }

Done:

    return bSuccess;
}

/////////////////////////////////////////////////////////////////////////////
//
// Save the new app verifier settings for all images
//

BOOL AVSaveNewSettings( BOOL bDeleteOtherSettings /*= TRUE*/ )
{
    BOOL bSuccess;
    LONG lResult;
    DWORD dwSubkeyIndex;
    DWORD dwKeyNameBufferLen;
    HKEY hImageOptionsKey;
    HKEY hSubKey;
    INT_PTR nAppsToVerify;
    INT_PTR nCrtAppToVerify;
    FILETIME LastWriteTime;
    CApplicationData *pCrtAppData;
    CStringArray astrAppCompatTestedExes;
    TCHAR szKeyNameBuffer[ 256 ];

    g_bChangedSettings = FALSE;

    bSuccess = FALSE;

    g_NewSettings.m_aApplicationData.SetAllSaved( FALSE );

    //
    // Open the Image File Execution Options regkey
    //

    lResult = RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                            g_szImageOptionsKeyName,
                            0,
                            KEY_CREATE_SUB_KEY | KEY_ENUMERATE_SUB_KEYS,
                            &hImageOptionsKey );

    if( lResult != ERROR_SUCCESS ) 
    {
        if( lResult == ERROR_ACCESS_DENIED ) 
        {
            AVErrorResourceFormat(
                IDS_ACCESS_IS_DENIED );
        }
        else 
        {
            AVErrorResourceFormat(
                IDS_REGOPENKEYEX_FAILED,
                g_szImageOptionsKeyName,
                (DWORD)lResult);
        }

        goto Done;
    }

    //
    // Enumerate all the existing subkeys for app execution options
    //

    for( dwSubkeyIndex = 0; TRUE; dwSubkeyIndex += 1 )
    {
        dwKeyNameBufferLen = ARRAY_LENGTH( szKeyNameBuffer );

        lResult = RegEnumKeyEx( hImageOptionsKey,
                                dwSubkeyIndex,
                                szKeyNameBuffer,
                                &dwKeyNameBufferLen,
                                NULL,
                                NULL,
                                NULL,
                                &LastWriteTime );

        if( lResult != ERROR_SUCCESS ) 
        {
            if( lResult == ERROR_NO_MORE_ITEMS )
            {
                //
                // We finished looking at all the existing subkeys
                //

                break;
            }
            else 
            {
                if( lResult == ERROR_ACCESS_DENIED ) 
                {
                    AVErrorResourceFormat(
                        IDS_ACCESS_IS_DENIED );
                }
                else 
                {
                    AVErrorResourceFormat(
                        IDS_REGENUMKEYEX_FAILED,
                        g_szImageOptionsKeyName,
                        (DWORD)lResult);
                }

                goto CleanUpAndDone;
            }
        }

        //
        // Open the subkey
        //

        lResult = RegOpenKeyEx( hImageOptionsKey,
                                szKeyNameBuffer,
                                0,
                                KEY_QUERY_VALUE | KEY_SET_VALUE,
                                &hSubKey );

        if( lResult != ERROR_SUCCESS ) 
        {
            if( lResult == ERROR_ACCESS_DENIED ) 
            {
                AVErrorResourceFormat(
                    IDS_ACCESS_IS_DENIED );
            }
            else 
            {
                AVErrorResourceFormat(
                    IDS_REGOPENKEYEX_FAILED,
                    szKeyNameBuffer,
                    (DWORD)lResult);
            }

            goto CleanUpAndDone;
        }

        bSuccess = AVSaveAppNewSettings( hSubKey, 
                                         TRUE,
                                         szKeyNameBuffer,
                                         &g_bChangedSettings,
                                         astrAppCompatTestedExes,
                                         bDeleteOtherSettings ) ;

        VERIFY( ERROR_SUCCESS == RegCloseKey( hSubKey ) );
    }

    //
    // Add any new image execution options keys necessary
    //

    nAppsToVerify = g_NewSettings.m_aApplicationData.GetSize();

    for( nCrtAppToVerify = 0; nCrtAppToVerify < nAppsToVerify; nCrtAppToVerify += 1 )
    {
        pCrtAppData = g_NewSettings.m_aApplicationData.GetAt( nCrtAppToVerify );

        ASSERT_VALID( pCrtAppData );

        if( FALSE == pCrtAppData->m_bSaved )
        {
            lResult = RegCreateKeyEx( hImageOptionsKey,
                                      (LPCTSTR) pCrtAppData->m_strExeFileName,
                                      0,
                                      NULL,
                                      REG_OPTION_NON_VOLATILE,
                                      KEY_QUERY_VALUE | KEY_SET_VALUE,
                                      NULL,
                                      &hSubKey,
                                      NULL );

            if( STATUS_SUCCESS != lResult )
            {
                if( lResult == ERROR_ACCESS_DENIED ) 
                {
                    AVErrorResourceFormat(
                        IDS_ACCESS_IS_DENIED );
                }
                else 
                {
                    AVErrorResourceFormat(
                        IDS_REGCREATEKEYEX_FAILED,
                        (LPCTSTR) pCrtAppData->m_strExeFileName,
                        (DWORD)lResult);
                }

                goto CleanUpAndDone;
            }
            
            //
            // Create the app verifier settings for this app
            //

            bSuccess = AVSaveAppNewSettings( hSubKey, 
                                             FALSE,
                                             (LPCTSTR) pCrtAppData->m_strExeFileName,
                                             &g_bChangedSettings,
                                             astrAppCompatTestedExes,
                                             FALSE ) ;

            VERIFY( ERROR_SUCCESS == RegCloseKey( hSubKey ) );
        }
    }

    //
    // Update the app compat settings
    //

    if( FALSE != bSuccess && FALSE != g_bChangedSettings )
    {
        AppCompatSaveSettings( astrAppCompatTestedExes );
    }

    //
    // Let the user know if we have changed any settings
    //

    if( FALSE != g_bChangedSettings )
    {
        if( 0 < nAppsToVerify )
        {
            AVMesssageFromResource( IDS_SETTINGS_SAVED );
        }
        else
        {
            AVMesssageFromResource( IDS_SETTINGS_DELETED );
        }
    }
    else
    {
        AVMesssageFromResource( IDS_NO_SETTINGS_CHANGED );
    }

CleanUpAndDone:

    VERIFY( ERROR_SUCCESS == RegCloseKey( hImageOptionsKey ) );

Done:

    return bSuccess;
}

/////////////////////////////////////////////////////////////////////////////
//
// Dump the current registry settings to the console
//

VOID AVDumpRegistrySettingsToConsole()
{
    INT_PTR nCrtFlag;
    INT_PTR nAppsNo;
    INT_PTR nCrtApp;
    BOOL bDisplayedThisApp;
    CAppAndBits *pCrtElem;
    TCHAR szBitName[ 64 ];

    //
    // Read the current registry settings
    //

    AVReadCrtRegistrySettings();

    nAppsNo = g_aAppsAndBitsFromRegistry.GetSize();

    if( nAppsNo > 0 )
    {
        AVPrintStringFromResources( IDS_VERIFIED_APPS );
    }

    //
    // Parse all the elements and print out the enabled flags
    //

    for( nCrtApp = 0; nCrtApp < nAppsNo; nCrtApp += 1 )
    {
        pCrtElem = g_aAppsAndBitsFromRegistry.GetAt( nCrtApp );
        
        ASSERT_VALID( pCrtElem );
        ASSERT( 0 != pCrtElem->m_dwEnabledBits );

        bDisplayedThisApp = FALSE;

        for( nCrtFlag = 0; nCrtFlag < ARRAY_LENGTH( g_AllNamesAndBits ); nCrtFlag += 1 )
        {
            if( (pCrtElem->m_dwEnabledBits & g_AllNamesAndBits[ nCrtFlag ].m_dwBit) != 0 )
            {
                //
                // This verifier bit is enabled.
                // Display the app name, if not displayed already, then the bit name.
                //

                if( FALSE == bDisplayedThisApp )
                {
                    _putts( _T( " "  ) );
                    _putts( (LPCTSTR)pCrtElem->m_strAppName );
                    _putts( _T( " "  ) );
                    AVPrintStringFromResources( IDS_TESTS );
                    _putts( _T( " "  ) );

                    bDisplayedThisApp = TRUE;
                }

                VERIFY( AVLoadString( g_AllNamesAndBits[ nCrtFlag ].m_uNameStringId,
                                      szBitName,
                                      ARRAY_LENGTH( szBitName ) ) );

                _putts( szBitName );
            }
        }

        _putts( _T( " "  ) );
    }

    if( nAppsNo == 0 )
    {
        AVPrintStringFromResources( IDS_NO_APPS_VERIFIED );
    }
}

/////////////////////////////////////////////////////////////////////////////
//
// Read the current registry settings 
//

VOID AVReadCrtRegistrySettings()
{
    HKEY hImageOptionsKey;
    HKEY hSubKey;
    DWORD dwSubkeyIndex;
    DWORD dwDataSize;
    DWORD dwValueType;
    DWORD dwFlags;
    LONG lResult;
    BOOL bSuccesfullyConverted;
    FILETIME LastWriteTime;
    CAppAndBits *pNewElem;
    TCHAR szOldGlobalFlagValue[ 32 ];
    TCHAR szKeyNameBuffer[ 256 ];

    g_aAppsAndBitsFromRegistry.DeleteAll();

    //
    // Open the Image File Execution Options regkey
    //

    lResult = RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                            g_szImageOptionsKeyName,
                            0,
                            KEY_CREATE_SUB_KEY | KEY_ENUMERATE_SUB_KEYS,
                            &hImageOptionsKey );

    if( lResult != ERROR_SUCCESS ) 
    {
        if( lResult == ERROR_ACCESS_DENIED ) 
        {
            AVErrorResourceFormat(
                IDS_ACCESS_IS_DENIED );
        }
        else 
        {
            AVErrorResourceFormat(
                IDS_REGOPENKEYEX_FAILED,
                g_szImageOptionsKeyName,
                (DWORD)lResult);
        }

        goto Done;
    }

    //
    // Enumerate all the existing subkeys for app execution options
    //

    for( dwSubkeyIndex = 0; TRUE; dwSubkeyIndex += 1 )
    {
        dwDataSize = ARRAY_LENGTH( szKeyNameBuffer );

        lResult = RegEnumKeyEx( hImageOptionsKey,
                                dwSubkeyIndex,
                                szKeyNameBuffer,
                                &dwDataSize,
                                NULL,
                                NULL,
                                NULL,
                                &LastWriteTime );

        if( lResult != ERROR_SUCCESS ) 
        {
            if( lResult == ERROR_NO_MORE_ITEMS )
            {
                //
                // We finished looking at all the existing subkeys
                //

                break;
            }
            else 
            {
                if( lResult == ERROR_ACCESS_DENIED ) 
                {
                    AVErrorResourceFormat(
                        IDS_ACCESS_IS_DENIED );
                }
                else 
                {
                    AVErrorResourceFormat(
                        IDS_REGENUMKEYEX_FAILED,
                        g_szImageOptionsKeyName,
                        (DWORD)lResult);
                }

                goto CleanUpAndDone;
            }
        }

        //
        // Open the subkey
        //

        lResult = RegOpenKeyEx( hImageOptionsKey,
                                szKeyNameBuffer,
                                0,
                                KEY_QUERY_VALUE | KEY_SET_VALUE,
                                &hSubKey );

        if( lResult != ERROR_SUCCESS ) 
        {
            if( lResult == ERROR_ACCESS_DENIED ) 
            {
                AVErrorResourceFormat(
                    IDS_ACCESS_IS_DENIED );
            }
            else 
            {
                AVErrorResourceFormat(
                    IDS_REGOPENKEYEX_FAILED,
                    szKeyNameBuffer,
                    (DWORD)lResult);
            }

            goto CleanUpAndDone;
        }

        //
        // Read the GlobalFlag value
        //

        dwDataSize = sizeof( szOldGlobalFlagValue );

        lResult = RegQueryValueEx( hSubKey,
                                   g_szGlobalFlagValueName,
                                   NULL,
                                   &dwValueType,
                                   (LPBYTE) &szOldGlobalFlagValue[ 0 ],
                                   &dwDataSize );

        if( ERROR_SUCCESS == lResult )
        {
            bSuccesfullyConverted = AVRtlCharToInteger( szOldGlobalFlagValue,
                                                        0,
                                                        &dwFlags );

            if( ( FALSE != bSuccesfullyConverted ) && 
                ( ( dwFlags & FLG_APPLICATION_VERIFIER ) != 0 ) )
            {
                //
                // App verifier is enabled for this app - read the verifier flags
                //

                dwDataSize = sizeof( dwFlags );

                lResult = RegQueryValueEx( hSubKey,
                                           g_szVerifierFlagsValueName,
                                           NULL,
                                           &dwValueType,
                                           (LPBYTE) &dwFlags,
                                           &dwDataSize );

                if( ERROR_SUCCESS == lResult && REG_DWORD == dwValueType && 0 != dwFlags )
                {
                    //
                    // Add this app top our global array
                    //

                    pNewElem = new CAppAndBits( szKeyNameBuffer,
                                                dwFlags );

                    if( NULL != pNewElem )
                    {
                        g_aAppsAndBitsFromRegistry.Add( pNewElem );
                    }
                }
            }
        }

        VERIFY( ERROR_SUCCESS == RegCloseKey( hSubKey ) );
    }

CleanUpAndDone:

    VERIFY( ERROR_SUCCESS == RegCloseKey( hImageOptionsKey ) );

Done:

    NOTHING;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\appverif\setting.h ===
//                                          
// Application Verifier UI
// Copyright (c) Microsoft Corporation, 2001
//
//
//
// module: Setting.h
// author: DMihai
// created: 02/22/2001
//
// Description:
//  
//

#ifndef __APP_VERIFIER_SETTINGS_H__
#define __APP_VERIFIER_SETTINGS_H__

////////////////////////////////////////////////////
//
// Standard app verifier flags
//

#define AV_ALL_STANDARD_VERIFIER_FLAGS ( RTL_VRF_FLG_FULL_PAGE_HEAP |   \
                                         RTL_VRF_FLG_LOCK_CHECKS    |   \
                                         RTL_VRF_FLG_HANDLE_CHECKS  |   \
                                         RTL_VRF_FLG_STACK_CHECKS   |   \
                                         RTL_VRF_FLG_APPCOMPAT_CHECKS )

////////////////////////////////////////////////////
//
// Type of settings (standard, custom)
//

typedef enum
{
    AVSettingsTypeUnknown,
    AVSettingsTypeStandard,
    AVSettingsTypeCustom
} AVSettingsType;

////////////////////////////////////////////////////
class CApplicationData : public CObject
{
public:
    CApplicationData( LPCTSTR szFileName,
                      LPCTSTR szFullPath,
                      ULONG uSettingsBits );

    CApplicationData( LPCTSTR szFileName,
                      ULONG uSettingsBits );

public:
    //
    // Data
    //

    CString m_strExeFileName;
    CString m_strFileVersion;
    CString m_strCompanyName;
    CString m_strProductName;

    DWORD   m_uCustomFlags;
    BOOL    m_bSaved;

protected:
    VOID LoadAppVersionData( LPCTSTR szFileName );
};

////////////////////////////////////////////////////
class CApplicationDataArray : public CObArray
{
public:
    ~CApplicationDataArray();

public:
    CApplicationData *GetAt( INT_PTR nIndex );

    VOID DeleteAll();
    VOID DeleteAt( INT_PTR nIndex );

    BOOL IsFileNameInList( LPCTSTR szFileName );
    INT_PTR FileNameIndex( LPCTSTR szFileName );

    INT_PTR AddNewAppData( LPCTSTR szFileName,
                           LPCTSTR szFullPath,
                           ULONG uSettingsBits );

    INT_PTR AddNewAppDataConsoleMode( LPCTSTR szFileName,
                                      ULONG uSettingsBits );

    VOID SetAllSaved( BOOL bSaved );
};

////////////////////////////////////////////////////
//
// App verifier settings
//

class CAVSettings : public CObject
{
public:
    CAVSettings();

public:
    //
    // Data
    //

    AVSettingsType          m_SettingsType;

    CApplicationDataArray   m_aApplicationData;
};

/////////////////////////////////////////////////////////////////////////////
//
// Name and bit pair structure
//

typedef struct _BIT_LISTNAME_CMDLINESWITCH
{
    ULONG   m_uCmdLineStringId;
    ULONG   m_uNameStringId;
    DWORD   m_dwBit;
} BIT_LISTNAME_CMDLINESWITCH, *PBIT_LISTNAME_CMDLINESWITCH;

/////////////////////////////////////////////////////////////////////////////
//
// App name and enabled bits pair class
//

class CAppAndBits : public CObject
{
public:
    //
    // Construction
    //

    CAppAndBits( LPCTSTR szAppName, DWORD dwEnabledBits );

public:
    //
    // Data
    //
    
    CString m_strAppName;
    DWORD   m_dwEnabledBits;
};

/////////////////////////////////////////////////////////////////////////////
//
// App name and enabled bits pair array class
//

class CAppAndBitsArray : public CObArray
{
public:
    ~CAppAndBitsArray();

public:
    CAppAndBits *GetAt( INT_PTR nIndex );
    VOID DeleteAll();
};

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
//
// Global data:

/////////////////////////////////////////////////////////////////////////////
//
// New app verifier settings
//

extern CAVSettings g_NewSettings;

/////////////////////////////////////////////////////////////////////////////
//
// Current settings bits - used as temporary variable
// to store custom settings bits between the settings bits
// page and the app selection page.
//

extern DWORD g_dwNewSettingBits;

/////////////////////////////////////////////////////////////////////////////
//
// Bit names and cmd line switch
//

extern BIT_LISTNAME_CMDLINESWITCH g_AllNamesAndBits[ 5 ];

/////////////////////////////////////////////////////////////////////////////
//
// Changed settings? If yes, the program will exit with AV_EXIT_CODE_RESTART
//

extern BOOL g_bChangedSettings;

/////////////////////////////////////////////////////////////////////////////
extern CAppAndBitsArray g_aAppsAndBitsFromRegistry;

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
//
// Helper functions
//

/////////////////////////////////////////////////////////////////////////////
//
// Save the new app verifier settings for all images
//

BOOL AVSaveNewSettings( BOOL bDeleteOtherSettings = TRUE );

/////////////////////////////////////////////////////////////////////////////
//
// Save the new app verifier settings for only one image
//

BOOL AVSetVerifierFlagsForExe( LPCTSTR szExeName, DWORD dwNewVerifierFlags );

/////////////////////////////////////////////////////////////////////////////
//
// Dump the current registry settings to the console
//

VOID AVDumpRegistrySettingsToConsole();

/////////////////////////////////////////////////////////////////////////////
//
// Read the current registry settings 
//

VOID AVReadCrtRegistrySettings();

#endif //#ifndef __APP_VERIFIER_SETTINGS_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\appverif\startapp.h ===
//                                          
// Application Verifier UI
// Copyright (c) Microsoft Corporation, 2001
//
//
//
// module: ChooseExe.h
// author: CLupu
// created: 04/13/2001
//
// Description:
//  
// "Choose an executable to run" wizard page class.
//

#if !defined(AFX_STARTAPP_H_INCLUDED_)
#define AFX_STARTAPP_H_INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "AVPage.h"

#define VERIFIER_FILE_LOG_NAME  _T("AppVerifier.log")
#define APPVERIFIER_LAYER_NAME  _T("#AppVerifierLayer")


/////////////////////////////////////////////////////////////////////////////
// CStartAppPage dialog

class CStartAppPage : public CAppverifPage
{
    DECLARE_DYNCREATE(CStartAppPage)

// Construction
public:
    CStartAppPage();
    ~CStartAppPage();

protected:

    //
    // Overrides
    //

    //
    // All the property pages derived from this class should 
    // provide this method.
    //

    virtual ULONG GetDialogId() const;

    //
    // ClassWizard generate virtual function overrides
    //

    //{{AFX_VIRTUAL(CStartAppPage)
    public:
    virtual BOOL OnSetActive();
    virtual LRESULT OnWizardNext();
    protected:
    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
    //}}AFX_VIRTUAL

    BOOL RunProgram();

protected:
    // Dialog Data
    //{{AFX_DATA(CStartAppPage)
    enum { IDD = IDD_STARTAPP_PAGE };
    CStatic     m_ExeName;
	CStatic	    m_NextDescription;
    //}}AFX_DATA

    int  m_nIssues;
    BOOL m_bAppRun;

protected:
    //
    // Generated message map functions
    //

    //{{AFX_MSG(CStartAppPage)
    virtual BOOL OnInitDialog();
    afx_msg LONG OnHelp( WPARAM wParam, LPARAM lParam );
    afx_msg void OnContextMenu(CWnd* pWnd, CPoint point);
	afx_msg void OnRunApp();
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()

};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STARTAPP_H_INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\appverif\stdafx.h ===
// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#if !defined(AFX_STDAFX_H__3F6B9F71_E398_4BA2_B04E_CABEB92BE4EE__INCLUDED_)
#define AFX_STDAFX_H__3F6B9F71_E398_4BA2_B04E_CABEB92BE4EE__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#define VC_EXTRALEAN		// Exclude rarely-used stuff from Windows headers

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

//
// Use MFC ASSERT macro
//

#ifdef ASSERT
#undef ASSERT
#endif

#include <afxwin.h>         // MFC core and standard components
#include <afxext.h>         // MFC extensions
#include <afxdisp.h>        // MFC Automation classes
#include <afxdtctl.h>		// MFC support for Internet Explorer 4 Common Controls
#ifndef _AFX_NO_AFXCMN_SUPPORT
#include <afxcmn.h>			// MFC support for Windows Common Controls
#endif // _AFX_NO_AFXCMN_SUPPORT

#include <Cderr.h>
#include <locale.h>
#include <ntverp.h>
#include <common.ver>

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__3F6B9F71_E398_4BA2_B04E_CABEB92BE4EE__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\appverif\taskpage.cpp ===
//                                          
// Application Verifier UI
// Copyright (c) Microsoft Corporation, 2001
//
//
//
// module: TaskPage.cpp
// author: DMihai
// created: 02/22/2001
//
// Description:
//  
// "Select a task" wizard page class.
//

#include "stdafx.h"
#include "appverif.h"

#include "TaskPage.h"
#include "Setting.h"
#include "AVUtil.h"
#include "AVGlobal.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


//
// Change this if you add/remove/change order 
// of radio buttons on this page
//

#define FIRST_RADIO_BUTTON_ID   IDC_TASKP_STANDARD_RADIO

//
// Help IDs
//

static DWORD MyHelpIds[] =
{
    0, 0
};

/////////////////////////////////////////////////////////////////////////////
// CTaskPage property page

IMPLEMENT_DYNCREATE(CTaskPage, CAppverifPage)

CTaskPage::CTaskPage() : CAppverifPage(CTaskPage::IDD)
{
    //{{AFX_DATA_INIT(CTaskPage)
    m_nCrtRadio = -1;
    //}}AFX_DATA_INIT
}

CTaskPage::~CTaskPage()
{
}

void CTaskPage::DoDataExchange(CDataExchange* pDX)
{
    CAppverifPage::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CTaskPage)
    DDX_Control(pDX, IDC_TASKP_NEXTDESCR_STATIC, m_NextDescription);
    DDX_Radio(pDX, IDC_TASKP_STANDARD_RADIO, m_nCrtRadio);
    //}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CTaskPage, CAppverifPage)
    //{{AFX_MSG_MAP(CTaskPage)
    ON_BN_CLICKED(IDC_TASKP_STANDARD_RADIO, OnStandardRadio)
    ON_BN_CLICKED(IDC_TASKP_VIEWSETT_RADIO, OnViewSettRadio)
    ON_BN_CLICKED(IDC_TASKP_DELETESETT_RADIO, OnDeletesettRadio)
    ON_BN_CLICKED(IDC_TASKP_LOGO_RADIO, OnLogoRadio)
    ON_WM_CONTEXTMENU()
    ON_MESSAGE( WM_HELP, OnHelp )
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
ULONG CTaskPage::GetDialogId() const
{
    return IDD_TASK_PAGE;
}

/////////////////////////////////////////////////////////////////////////////
LRESULT CTaskPage::OnWizardNext() 
{
    LRESULT lNextPageId;

    lNextPageId = -1;

    if( UpdateData() == TRUE )
    {
        switch( m_nCrtRadio )
        {
        case IDC_TASKP_STANDARD_RADIO - FIRST_RADIO_BUTTON_ID:
            g_NewSettings.m_SettingsType = AVSettingsTypeStandard;
            lNextPageId = IDD_APPLICATION_PAGE;
            break;

        case IDC_TASKP_VIEWSETT_RADIO - FIRST_RADIO_BUTTON_ID:
            lNextPageId = IDD_VIEWSETT_PAGE;
            break;

        case IDC_TASKP_LOGO_RADIO - FIRST_RADIO_BUTTON_ID:
            lNextPageId = IDD_CHOOSEEXE_PAGE;
            break;

        case IDC_TASKP_DELETESETT_RADIO - FIRST_RADIO_BUTTON_ID:
        default:
            //
            // Oops. how did we get here?
            //

            ASSERT( FALSE );
        }
    }

    //
    // Go to the next page
    //

    GoingToNextPageNotify( lNextPageId );

    return lNextPageId;
}

/////////////////////////////////////////////////////////////////////////////
BOOL CTaskPage::OnSetActive() 
{
    ASSERT_VALID( m_pParentSheet );

    m_pParentSheet->SetWizardButtons(
        PSWIZB_NEXT );

    return CAppverifPage::OnSetActive();
}

/////////////////////////////////////////////////////////////////////////////
BOOL CTaskPage::OnWizardFinish() 
{
    BOOL bFinish;
    INT nResponse;

    bFinish = FALSE;

    if( TRUE == UpdateData( TRUE ) )
    {
        //
        // This must have been the "delete settings" selection
        // if we had a "Finish" button.
        //

        ASSERT( IDC_TASKP_DELETESETT_RADIO - FIRST_RADIO_BUTTON_ID == m_nCrtRadio );

        nResponse = AfxMessageBox( IDS_DELETE_ALL_SETTINGS,
                                   MB_YESNO );
        
        if( IDYES == nResponse )
        {
            g_NewSettings.m_aApplicationData.DeleteAll();

            bFinish = AVSaveNewSettings() && CAppverifPage::OnWizardFinish();
        }
    }
    
    return bFinish;
}

/////////////////////////////////////////////////////////////////////////////
BOOL CTaskPage::OnInitDialog() 
{
    //
    // Always start with standard settings
    //

    m_nCrtRadio = IDC_TASKP_STANDARD_RADIO - FIRST_RADIO_BUTTON_ID;

    CAppverifPage::OnInitDialog();

    AVSetWindowText( m_NextDescription, IDS_TASKP_NEXT_DESCR_STANDARD );
        
    return TRUE;  // return TRUE unless you set the focus to a control
                  // EXCEPTION: OCX Property Pages should return FALSE
}

/////////////////////////////////////////////////////////////////////////////
// CTaskPage message handlers

void CTaskPage::OnStandardRadio() 
{
    ASSERT_VALID( m_pParentSheet );

    m_pParentSheet->SetWizardButtons(
        PSWIZB_NEXT );

    AVSetWindowText( m_NextDescription, IDS_TASKP_NEXT_DESCR_STANDARD );
}

void CTaskPage::OnViewSettRadio() 
{
    ASSERT_VALID( m_pParentSheet );

    m_pParentSheet->SetWizardButtons(
        PSWIZB_NEXT );

    AVSetWindowText( m_NextDescription, IDS_TASKP_NEXT_DESCR_VIEW );
}

void CTaskPage::OnDeletesettRadio() 
{
    ASSERT_VALID( m_pParentSheet );

    m_pParentSheet->SetWizardButtons(
        PSWIZB_FINISH );

    AVSetWindowText( m_NextDescription, IDS_TASKP_NEXT_DESCR_DELETE );
}

void CTaskPage::OnLogoRadio() 
{
    ASSERT_VALID( m_pParentSheet );

    m_pParentSheet->SetWizardButtons(
        PSWIZB_NEXT );

    AVSetWindowText( m_NextDescription, IDS_TASKP_NEXT_DESCR_LOGO );
}

/////////////////////////////////////////////////////////////
LONG CTaskPage::OnHelp( WPARAM wParam, LPARAM lParam )
{
    LONG lResult = 0;
    LPHELPINFO lpHelpInfo = (LPHELPINFO)lParam;

    ::WinHelp( 
        (HWND) lpHelpInfo->hItemHandle,
        g_szAVHelpFile,
        HELP_WM_HELP,
        (DWORD_PTR) MyHelpIds );

    return lResult;
}

/////////////////////////////////////////////////////////////////////////////
void CTaskPage::OnContextMenu(CWnd* pWnd, CPoint point) 
{
    ::WinHelp( 
        pWnd->m_hWnd,
        g_szAVHelpFile,
        HELP_CONTEXTMENU,
        (DWORD_PTR) MyHelpIds );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\appverif\taskpage.h ===
//                                          
// Application Verifier UI
// Copyright (c) Microsoft Corporation, 2001
//
//
//
// module: TaskPage.h
// author: DMihai
// created: 02/22/2001
//
// Description:
//  
// "Select a task" wizard page class.
//

#if !defined(AFX_TASKPAGE_H__152A3D61_041C_4B49_8E81_455CA0641598__INCLUDED_)
#define AFX_TASKPAGE_H__152A3D61_041C_4B49_8E81_455CA0641598__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// TaskPage.h : header file
//

#include "AVPage.h"

/////////////////////////////////////////////////////////////////////////////
// CTaskPage dialog

class CTaskPage : public CAppverifPage
{
	DECLARE_DYNCREATE(CTaskPage)

// Construction
public:
	CTaskPage();
	~CTaskPage();


protected:
    //
    // Overrides
    //

    //
    // All the property pages derived from this class should 
    // provide this method.
    //

    virtual ULONG GetDialogId() const;

    //
	// ClassWizard generate virtual function overrides
    //

	//{{AFX_VIRTUAL(CTaskPage)
	public:
	virtual LRESULT OnWizardNext();
	virtual BOOL OnSetActive();
    virtual BOOL OnWizardFinish();
    protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

    //
    // Dialog Data
    //

	//{{AFX_DATA(CTaskPage)
	enum { IDD = IDD_TASK_PAGE };
	CStatic	m_NextDescription;
	int		m_nCrtRadio;
	//}}AFX_DATA

protected:
    //
    // Generated message map functions
    //

    //{{AFX_MSG(CTaskPage)
    afx_msg void OnViewSettRadio();
    afx_msg void OnDeletesettRadio();
    afx_msg void OnLogoRadio();
    afx_msg void OnStandardRadio();
    virtual BOOL OnInitDialog();
    afx_msg LONG OnHelp( WPARAM wParam, LPARAM lParam );
    afx_msg void OnContextMenu(CWnd* pWnd, CPoint point);
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_TASKPAGE_H__152A3D61_041C_4B49_8E81_455CA0641598__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\appverif\userdump.cpp ===
/*++

    Copyright (c) 1989-2000  Microsoft Corporation

    Module Name:

        UserDump.cpp

    Abstract:

        This module implements the code for generating a user mode dump.

    Author:

        clupu     created     01/31/2001

    Revision History:

--*/

#include "stdafx.h"

#include <crash.h>

#include "Debugger.h"
#include "UserDumpp.h"

#define MEM_SIZE (64*1024)


//
// Private data structure used for communcating
// crash dump data to the callback function.
//
typedef struct _CRASH_DUMP_INFO
{
    PPROCESS_INFO               pProcess;
    EXCEPTION_DEBUG_INFO*       ExceptionInfo;
    DWORD                       MemoryCount;
    DWORD_PTR                   Address;
    PUCHAR                      MemoryData;
    MEMORY_BASIC_INFORMATION    mbi;
    SIZE_T                      MbiOffset;
    SIZE_T                      MbiRemaining;
    PTHREAD_INFO                pCurrentThread;
    IMAGEHLP_MODULE             mi;
    PCRASH_MODULE               CrashModule;
} CRASH_DUMP_INFO, *PCRASH_DUMP_INFO;

//
// Local function prototypes
//

DWORD_PTR GetTeb( HANDLE hThread )
{
    NTSTATUS                   Status;
    THREAD_BASIC_INFORMATION   ThreadBasicInfo;
    DWORD_PTR                  Address = 0;

    Status = NtQueryInformationThread( hThread,
                                       ThreadBasicInformation,
                                       &ThreadBasicInfo,
                                       sizeof( ThreadBasicInfo ),
                                       NULL );
    if ( NT_SUCCESS(Status) )
    {
        Address = (DWORD_PTR)ThreadBasicInfo.TebBaseAddress;
    }

    return Address;
}



BOOL
CrashDumpCallback(
    IN     DWORD   DataType,        // requested data type
    OUT    PVOID*  DumpData,        // pointer to a pointer to the data
    OUT    LPDWORD DumpDataLength,  // pointer to the data length
    IN OUT PVOID   cdi              // private data
    )
/*++
    Return: TRUE on success, FALSE otherwise.
    
    Desc:   This function is the callback used by crashlib.
            Its purpose is to provide data to CreateUserDump()
            for writting to the crashdump file.
--*/

{
    PCRASH_DUMP_INFO CrashdumpInfo = (PCRASH_DUMP_INFO)cdi;

    switch ( DataType )
    {
    case DMP_DEBUG_EVENT:
        *DumpData = &CrashdumpInfo->pProcess->DebugEvent;
        *DumpDataLength = sizeof(DEBUG_EVENT);
        break;

    case DMP_THREAD_STATE:
        {
            static CRASH_THREAD CrashThread;
            PTHREAD_INFO        pCurrentThread;

            *DumpData = &CrashThread;

            if ( CrashdumpInfo->pCurrentThread == NULL )
            {
                pCurrentThread = CrashdumpInfo->pProcess->pFirstThreadInfo;
            }
            else
            {
                pCurrentThread = CrashdumpInfo->pCurrentThread->pNext;
            }

            CrashdumpInfo->pCurrentThread = pCurrentThread;

            if ( pCurrentThread == NULL )
            {
                return FALSE;
            }

            ZeroMemory(&CrashThread, sizeof(CrashThread));

            CrashThread.ThreadId = pCurrentThread->dwThreadId;
            CrashThread.SuspendCount = SuspendThread(pCurrentThread->hThread);

            if ( CrashThread.SuspendCount != (DWORD)-1 )
            {
                ResumeThread(pCurrentThread->hThread);
            }

            CrashThread.PriorityClass = GetPriorityClass(CrashdumpInfo->pProcess->hProcess);
            CrashThread.Priority = GetThreadPriority(pCurrentThread->hThread);
            CrashThread.Teb = GetTeb(pCurrentThread->hThread);

            *DumpDataLength = sizeof(CRASH_THREAD);
            break;
        }

    case DMP_MEMORY_BASIC_INFORMATION:
        while ( TRUE )
        {
            CrashdumpInfo->Address += CrashdumpInfo->mbi.RegionSize;

            if ( !VirtualQueryEx(CrashdumpInfo->pProcess->hProcess,
                                 (LPVOID)CrashdumpInfo->Address,
                                 &CrashdumpInfo->mbi,
                                 sizeof(MEMORY_BASIC_INFORMATION)) )
            {
                return FALSE;
            }

            if ( (CrashdumpInfo->mbi.Protect & PAGE_GUARD) ||
                 (CrashdumpInfo->mbi.Protect & PAGE_NOACCESS) )
            {
                continue;
            }

            if ( (CrashdumpInfo->mbi.State & MEM_FREE) ||
                 (CrashdumpInfo->mbi.State & MEM_RESERVE) )
            {
                continue;
            }

            break;
        }

        *DumpData = &CrashdumpInfo->mbi;
        *DumpDataLength = sizeof(MEMORY_BASIC_INFORMATION);
        break;

    case DMP_THREAD_CONTEXT:
        {
            PTHREAD_INFO pCurrentThread;

            if ( CrashdumpInfo->pCurrentThread == NULL )
            {
                pCurrentThread = CrashdumpInfo->pProcess->pFirstThreadInfo;
            }
            else
            {
                pCurrentThread = CrashdumpInfo->pCurrentThread->pNext;
            }

            CrashdumpInfo->pCurrentThread = pCurrentThread;

            if ( pCurrentThread == NULL )
            {
                return FALSE;
            }

            *DumpData = &CrashdumpInfo->pCurrentThread->Context;
            *DumpDataLength = sizeof(CONTEXT);
            break;
        }

    case DMP_MODULE:
        if ( CrashdumpInfo->mi.BaseOfImage == 0 )
        {
            return FALSE;
        }

        CrashdumpInfo->CrashModule->BaseOfImage = CrashdumpInfo->mi.BaseOfImage;
        CrashdumpInfo->CrashModule->SizeOfImage = CrashdumpInfo->mi.ImageSize;
        CrashdumpInfo->CrashModule->ImageNameLength = strlen(CrashdumpInfo->mi.ImageName) + 1;
        strcpy( CrashdumpInfo->CrashModule->ImageName, CrashdumpInfo->mi.ImageName );

        *DumpData = CrashdumpInfo->CrashModule;
        *DumpDataLength = sizeof(CRASH_MODULE) + CrashdumpInfo->CrashModule->ImageNameLength;

        if ( !SymGetModuleInfo(CrashdumpInfo->pProcess->hProcess,
                               (DWORD_PTR)-1,
                               &CrashdumpInfo->mi) )
        {
            CrashdumpInfo->mi.BaseOfImage = 0;
        }
        break;

    case DMP_MEMORY_DATA:
        if ( !CrashdumpInfo->MemoryCount )
        {

            CrashdumpInfo->Address = 0;
            CrashdumpInfo->MbiOffset = 0;
            CrashdumpInfo->MbiRemaining = 0;

            ZeroMemory( &CrashdumpInfo->mbi, sizeof(MEMORY_BASIC_INFORMATION) );

            CrashdumpInfo->MemoryData = (PUCHAR)VirtualAlloc(NULL,
                                                             MEM_SIZE,
                                                             MEM_COMMIT,
                                                             PAGE_READWRITE);
        }

        if ( !CrashdumpInfo->MbiRemaining )
        {
            while ( TRUE )
            {
                CrashdumpInfo->Address += CrashdumpInfo->mbi.RegionSize;

                if ( !VirtualQueryEx(CrashdumpInfo->pProcess->hProcess,
                                     (LPVOID)CrashdumpInfo->Address,
                                     &CrashdumpInfo->mbi,
                                     sizeof(MEMORY_BASIC_INFORMATION)) )
                {

                    if ( CrashdumpInfo->MemoryData )
                    {
                        VirtualFree(CrashdumpInfo->MemoryData, MEM_SIZE, MEM_RELEASE);
                    }

                    return FALSE;
                }

                if ( (CrashdumpInfo->mbi.Protect & PAGE_GUARD) ||
                     (CrashdumpInfo->mbi.Protect & PAGE_NOACCESS) )
                {
                    continue;
                }

                if ( (CrashdumpInfo->mbi.State & MEM_FREE) ||
                     (CrashdumpInfo->mbi.State & MEM_RESERVE) )
                {
                    continue;
                }

                CrashdumpInfo->MbiOffset = 0;
                CrashdumpInfo->MbiRemaining = CrashdumpInfo->mbi.RegionSize;
                CrashdumpInfo->MemoryCount += 1;
                break;
            }
        }

        *DumpDataLength = (DWORD)__min( CrashdumpInfo->MbiRemaining, MEM_SIZE );
        CrashdumpInfo->MbiRemaining -= *DumpDataLength;

        ReadProcessMemory(CrashdumpInfo->pProcess->hProcess,
                          (PUCHAR)((DWORD_PTR)CrashdumpInfo->mbi.BaseAddress + CrashdumpInfo->MbiOffset),
                          CrashdumpInfo->MemoryData,
                          *DumpDataLength,
                          NULL);

        *DumpData = CrashdumpInfo->MemoryData;
        CrashdumpInfo->MbiOffset += *DumpDataLength;
        break;
    }

    return TRUE;
}

BOOL
CreateUserDump(
    IN  LPTSTR                             pszFileName,
    IN  PDBGHELP_CREATE_USER_DUMP_CALLBACK DmpCallback,
    IN  PVOID                              lpv
    )

/*++
    Return: TRUE on success, FALSE otherwise.

    Desc:   Creates the dump file.
--*/
{
    OSVERSIONINFOW              OsVersion = {0};
    USERMODE_CRASHDUMP_HEADER   DumpHeader = {0};
    DWORD                       cb;
    HANDLE                      hFile = INVALID_HANDLE_VALUE;
    BOOL                        rval;
    PVOID                       DumpData;
    DWORD                       DumpDataLength;
    SECURITY_ATTRIBUTES         SecAttrib;
    SECURITY_DESCRIPTOR         SecDescript;

    //
    // Create a DACL that allows all access to the directory.
    //
    SecAttrib.nLength               = sizeof(SECURITY_ATTRIBUTES);
    SecAttrib.lpSecurityDescriptor  = &SecDescript;
    SecAttrib.bInheritHandle        = FALSE;

    InitializeSecurityDescriptor(&SecDescript, SECURITY_DESCRIPTOR_REVISION);
    SetSecurityDescriptorDacl(&SecDescript, TRUE, NULL, FALSE);

    hFile = CreateFile(pszFileName,
                       GENERIC_READ | GENERIC_WRITE,
                       0,
                       &SecAttrib,
                       CREATE_ALWAYS,
                       FILE_ATTRIBUTE_NORMAL,
                       NULL);

    if ( hFile == NULL || hFile == INVALID_HANDLE_VALUE )
    {
        return FALSE;
    }

    //
    // Write out an empty header.
    //
    if ( !WriteFile(hFile, &DumpHeader, sizeof(DumpHeader), &cb, NULL) )
    {
        goto bad_file;
    }

    //
    // Write the debug event.
    //
    DumpHeader.DebugEventOffset = SetFilePointer(hFile, 0, NULL, FILE_CURRENT);

    DmpCallback(DMP_DEBUG_EVENT, &DumpData, &DumpDataLength, lpv);

    if ( !WriteFile(hFile, DumpData, sizeof(DEBUG_EVENT), &cb, NULL) )
    {
        goto bad_file;
    }

    //
    // Write the memory map.
    //
    DumpHeader.MemoryRegionOffset = SetFilePointer(hFile, 0, NULL, FILE_CURRENT);

    do
    {
        __try {
            rval = DmpCallback(DMP_MEMORY_BASIC_INFORMATION,
                               &DumpData,
                               &DumpDataLength,
                               lpv);

        } __except (EXCEPTION_EXECUTE_HANDLER) {
            rval = FALSE;
        }

        if ( rval )
        {
            DumpHeader.MemoryRegionCount += 1;

            if ( !WriteFile(hFile, DumpData, sizeof(MEMORY_BASIC_INFORMATION), &cb, NULL) )
            {
                goto bad_file;
            }
        }
    } while ( rval );

    //
    // Write the thread contexts.
    //
    DumpHeader.ThreadOffset = SetFilePointer(hFile, 0, NULL, FILE_CURRENT);

    do
    {
        __try {
            rval = DmpCallback(DMP_THREAD_CONTEXT,
                               &DumpData,
                               &DumpDataLength,
                               lpv);

        } __except (EXCEPTION_EXECUTE_HANDLER) {
            rval = FALSE;
        }

        if ( rval )
        {
            if ( !WriteFile(hFile, DumpData, DumpDataLength, &cb, NULL) )
            {
                goto bad_file;
            }

            DumpHeader.ThreadCount += 1;
        }

    } while ( rval );

    //
    // Write the thread states.
    //
    DumpHeader.ThreadStateOffset = SetFilePointer(hFile, 0, NULL, FILE_CURRENT);

    do
    {
        __try {
            rval = DmpCallback(DMP_THREAD_STATE,
                               &DumpData,
                               &DumpDataLength,
                               lpv);

        } __except (EXCEPTION_EXECUTE_HANDLER) {
            rval = FALSE;
        }

        if ( rval )
        {
            if ( !WriteFile(hFile, DumpData, sizeof(CRASH_THREAD), &cb, NULL) )
            {
                goto bad_file;
            }
        }

    } while ( rval );

    //
    // Write the module table.
    //
    DumpHeader.ModuleOffset = SetFilePointer(hFile, 0, NULL, FILE_CURRENT);

    do
    {
        __try {
            rval = DmpCallback(DMP_MODULE,
                               &DumpData,
                               &DumpDataLength,
                               lpv);

        } __except (EXCEPTION_EXECUTE_HANDLER) {
            rval = FALSE;
        }

        if ( rval )
        {
            if ( !WriteFile(hFile,
                            DumpData,
                            sizeof(CRASH_MODULE) + ((PCRASH_MODULE)DumpData)->ImageNameLength,
                            &cb,
                            NULL) )
            {
                goto bad_file;
            }

            DumpHeader.ModuleCount += 1;
        }
    } while ( rval );

    //
    // Write the virtual memory
    //
    DumpHeader.DataOffset = SetFilePointer(hFile, 0, NULL, FILE_CURRENT);

    do
    {
        __try {
            rval = DmpCallback(DMP_MEMORY_DATA,
                               &DumpData,
                               &DumpDataLength,
                               lpv);

        } __except (EXCEPTION_EXECUTE_HANDLER) {
            rval = FALSE;
        }

        if ( rval )
        {
            if ( !WriteFile(hFile, DumpData, DumpDataLength, &cb, NULL) )
            {
                goto bad_file;
            }
        }
    } while ( rval );

    //
    // The VersionInfo is optional.
    //
    DumpHeader.VersionInfoOffset = SetFilePointer(hFile, 0, NULL, FILE_CURRENT);

    //
    // re-write the dump header with some valid data.
    //
    GetVersionEx(&OsVersion);

    DumpHeader.Signature        = USERMODE_CRASHDUMP_SIGNATURE;
    DumpHeader.MajorVersion     = OsVersion.dwMajorVersion;
    DumpHeader.MinorVersion     = OsVersion.dwMinorVersion;
#ifdef _X86_
    DumpHeader.MachineImageType = IMAGE_FILE_MACHINE_I386;
    DumpHeader.ValidDump        = USERMODE_CRASHDUMP_VALID_DUMP32;
#else
    DumpHeader.MachineImageType = IMAGE_FILE_MACHINE_IA64;
    DumpHeader.ValidDump        = USERMODE_CRASHDUMP_VALID_DUMP64;
#endif

    SetFilePointer(hFile, 0, 0, FILE_BEGIN);

    if ( !WriteFile(hFile, &DumpHeader, sizeof(DumpHeader), &cb, NULL) )
    {
        goto bad_file;
    }

    CloseHandle(hFile);

    return TRUE;

    bad_file:

    CloseHandle(hFile);

    DeleteFile(pszFileName);

    return FALSE;
}



BOOL
GenerateUserModeDump(
    LPTSTR                  pszFileName,
    PPROCESS_INFO           pProcess,
    LPEXCEPTION_DEBUG_INFO  ed
    )
{
    CRASH_DUMP_INFO CrashdumpInfo = {0};
    BOOL            bRet;
    PTHREAD_INFO    pThread;

    CrashdumpInfo.mi.SizeOfStruct = sizeof(CrashdumpInfo.mi);
    CrashdumpInfo.pProcess        = pProcess;
    CrashdumpInfo.ExceptionInfo   = ed;

    //
    // Get the thread context for all the threads.
    //
    pThread = pProcess->pFirstThreadInfo;

    while ( pThread != NULL )
    {
        pThread->Context.ContextFlags = CONTEXT_FULL;
        GetThreadContext(pThread->hThread, &pThread->Context);
        pThread = pThread->pNext;
    }

    //
    // Get first entry in the module list.
    //
    if ( !SymInitialize(pProcess->hProcess, NULL, FALSE) )
    {
        return FALSE;
    }

    if ( !SymGetModuleInfo(pProcess->hProcess, 0, &CrashdumpInfo.mi) )
    {
        return FALSE;
    }

    CrashdumpInfo.CrashModule = (PCRASH_MODULE)LocalAlloc(LPTR, 4096);

    bRet = CreateUserDump(pszFileName, CrashDumpCallback, &CrashdumpInfo);

    LocalFree(CrashdumpInfo.CrashModule);

    return bRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\appverif\startapp.cpp ===
//                                          
// Application Verifier UI
// Copyright (c) Microsoft Corporation, 2001
//
//
//
// module: ChooseExe.cpp
// author: CLupu
// created: 04/13/2001
//
// Description:
//  
// "Launch the application to be verified" wizard page class.
//

#include "stdafx.h"
#include "appverif.h"

#include "StartApp.h"
#include "AVUtil.h"
#include "AVGlobal.h"
#include "Log.h"
#include "Debugger.h"
#include "ChooseExe.h"

#ifdef _DEBUG
    #define new DEBUG_NEW
    #undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif



HWND g_hWndOutput;
BOOL g_bDebuggeeExited = TRUE;

//
// Help IDs
//

static DWORD MyHelpIds[] =
{
    0, 0
};


/////////////////////////////////////////////////////////////////////////////
// CStartAppPage property page

IMPLEMENT_DYNCREATE(CStartAppPage, CAppverifPage)

CStartAppPage::CStartAppPage() : CAppverifPage(CStartAppPage::IDD)
{
    //{{AFX_DATA_INIT(CStartAppPage)
    // NOTE: the ClassWizard will add member initialization here
    //}}AFX_DATA_INIT

    m_nIssues = 0;
    m_bAppRun = FALSE;
}

CStartAppPage::~CStartAppPage()
{
}

void CStartAppPage::DoDataExchange(CDataExchange* pDX)
{
    CAppverifPage::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CStartAppPage)
    DDX_Control(pDX, IDC_EXE_NAME, m_ExeName);
    DDX_Control(pDX, IDC_RUNAPP_NEXTDESCR_STATIC, m_NextDescription);
    //}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CStartAppPage, CAppverifPage)
//{{AFX_MSG_MAP(CStartAppPage)
ON_MESSAGE( WM_HELP, OnHelp )
ON_WM_CONTEXTMENU()
ON_BN_CLICKED(IDC_RUNAPP, OnRunApp)
//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
ULONG CStartAppPage::GetDialogId() const
{
    return IDD_STARTAPP_PAGE;
}

/////////////////////////////////////////////////////////////////////////////

int    g_nMessages = 0;
TCHAR  g_szMsg[1024];

void _cdecl LogMessage( MSGLEVEL mlevel, LPTSTR pszFmt, ... )
{
    va_list arglist;
    int     off = 0;

    switch ( mlevel )
    {
    case LOG_ERROR:
        lstrcpy( g_szMsg, _T("ERR: ") );
        off = sizeof( _T("ERR: ") ) / sizeof( TCHAR ) - 1;
        break;

    case LOG_WARNING:
        lstrcpy( g_szMsg, _T("WRN: ") );
        off = sizeof( _T("ERR: ") ) / sizeof( TCHAR ) - 1;
        break;

    case LOG_INFO:
        break;
    }

    va_start( arglist, pszFmt );
    _vsntprintf( g_szMsg + off, 1023 - off, pszFmt, arglist );
    g_szMsg[1023] = 0;   // ensure null termination
    va_end( arglist );

    TCHAR* psz = g_szMsg + lstrlen(g_szMsg) - 1;

    while ( *psz == _T('\n') || *psz == _T('\r') )
    {
        *psz = 0;
        psz--;
    }

    if ( g_hWndOutput != NULL )
    {
        SendMessage(g_hWndOutput, LB_ADDSTRING, 0, (LPARAM)g_szMsg);
        SendMessage(g_hWndOutput, LB_SETCURSEL, g_nMessages, 0);
        SendMessage(g_hWndOutput, LB_SETTOPINDEX, g_nMessages++, 0);
    }

    lstrcat( g_szMsg, _T("\r\n") );

    OutputDebugString( g_szMsg );
}



BOOL GetShortName( LPCTSTR lpszCmd, LPTSTR lpszShortName )
{
    LPCTSTR psz = lpszCmd;
    LPCTSTR pszStart = lpszCmd;
    LPCTSTR pszEnd;
    BOOL    bBraket = FALSE;

    //
    // Skip over spaces...
    //
    while ( *psz == _T(' ') || *psz == _T('\t') )
    {
        psz++;
    }

    if ( *psz == _T('\"') )
    {
        bBraket = TRUE;
        psz++;
        pszStart = psz;
    }

    while ( *psz != 0 )
    {
        if ( *psz == _T('\"') )
        {
            pszEnd = psz;
            break;
        }
        else if ( *psz == _T('\\') )
        {
            pszStart = psz + 1;
        }
        else if ( *psz == _T(' ') && !bBraket )
        {
            pszEnd = psz;
            break;
        }

        psz++;
    }

    if ( *psz == 0 )
    {
        pszEnd = psz;
    }

    RtlCopyMemory( lpszShortName, pszStart, (pszEnd - pszStart) * sizeof(TCHAR) );

    lpszShortName[pszEnd - pszStart] = 0;

    return TRUE;
}

BOOL CStartAppPage::RunProgram()
{
    HANDLE hThread;
    DWORD  dwThreadId;
    LPARAM lParam;

    SetEnvironmentVariable( _T("VERIFIER_FILE_LOG"), VERIFIER_FILE_LOG_NAME );

    if ( g_dwRegFlags & RTL_VRF_FLG_APPCOMPAT_CHECKS )
    {
        SetEnvironmentVariable( _T("__COMPAT_LAYER"), APPVERIFIER_LAYER_NAME );

#if DBG
        SetEnvironmentVariable( _T("SHIM_FILE_LOG"), _T("dbg_av.txt") );
        SetEnvironmentVariable( _T("SHIM_DEBUG_LEVEL"), _T("2") );
#endif // DBG
    }

    //
    // Get the short name.
    //

    GetShortName( g_szAppFullPath, g_szAppShortName );

    if ( g_szAppShortName[0] == 0 )
    {
        LogMessage( LOG_ERROR, _T("[RunProgram] No app is selected to run.") );
        return FALSE;
    }

    InitFileLogSupport( VERIFIER_FILE_LOG_NAME );

    //
    // Create the debugger thread.
    //
    lParam = (LPARAM)g_dwRegFlags;

    hThread = CreateThread( NULL, 0, ExecuteAppThread, (LPVOID)lParam, 0, &dwThreadId );

    if ( hThread == NULL )
    {
        LogMessage( LOG_ERROR, _T("[RunProgram] Failed to create the debugger thread.") );
        return FALSE;
    }

    while ( 1 )
    {
        MSG   msg;
        DWORD dwRes;

        dwRes = MsgWaitForMultipleObjects( 1, &hThread, FALSE, INFINITE, QS_ALLINPUT );

        if ( dwRes == WAIT_OBJECT_0 )
        {
            break;

        }
        else if ( dwRes == WAIT_OBJECT_0 + 1 )
        {
            //
            // There are some messages in message queue.
            //
            while ( PeekMessageA(&msg, NULL, 0, 0, PM_REMOVE) )
            {
                DispatchMessageA(&msg);
            }
        }
        else
        {
            break;
        }
    }

    CloseHandle( hThread );

    m_bAppRun = TRUE;

    SetEnvironmentVariable( _T("__COMPAT_LAYER"), NULL );

    return TRUE;
}



/////////////////////////////////////////////////////////////////////////////
// CStartAppPage message handlers

/////////////////////////////////////////////////////////////
LONG CStartAppPage::OnHelp( WPARAM wParam, LPARAM lParam )
{
    LONG lResult = 0;
    LPHELPINFO lpHelpInfo = (LPHELPINFO)lParam;

    ::WinHelp(
             (HWND) lpHelpInfo->hItemHandle,
             g_szAVHelpFile,
             HELP_WM_HELP,
             (DWORD_PTR) MyHelpIds );

    return lResult;
}


/////////////////////////////////////////////////////////////////////////////
void CStartAppPage::OnContextMenu(CWnd* pWnd, CPoint point) 
{
    ::WinHelp(
             pWnd->m_hWnd,
             g_szAVHelpFile,
             HELP_CONTEXTMENU,
             (DWORD_PTR) MyHelpIds );
}

void CStartAppPage::OnRunApp() 
{
    m_pParentSheet->EnableWindow(FALSE);

    RunProgram();

    m_pParentSheet->EnableWindow(TRUE);

    m_pParentSheet->SetWizardButtons( PSWIZB_BACK | PSWIZB_NEXT );
}

/////////////////////////////////////////////////////////////////////////////
LRESULT CStartAppPage::OnWizardNext() 
{
    GoingToNextPageNotify( IDD_VIEWLOG_PAGE );

    return IDD_VIEWLOG_PAGE;
}

/////////////////////////////////////////////////////////////////////////////
BOOL CStartAppPage::OnSetActive() 
{
    ASSERT_VALID( m_pParentSheet );

    if ( m_bAppRun )
    {
        m_pParentSheet->SetWizardButtons( PSWIZB_BACK | PSWIZB_NEXT );
    }
    else
    {
        m_pParentSheet->SetWizardButtons( PSWIZB_BACK );
    }


    m_ExeName.SetWindowText(g_szAppFullPath);

    return CAppverifPage::OnSetActive();
}

/////////////////////////////////////////////////////////////////////////////
BOOL CStartAppPage::OnInitDialog() 
{
    CAppverifPage::OnInitDialog();

    g_hWndOutput = GetDlgItem(IDC_OUTPUT)->m_hWnd;

    AVSetWindowText( m_NextDescription, IDS_RUNAPP_NEXTDESCR_STATIC );
    
    return TRUE;  // return TRUE unless you set the focus to a control
                  // EXCEPTION: OCX Property Pages should return FALSE
}

/////////////////////////////////////////////////////////////////////////////
// CStartAppPage message handlers
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\appverif\userdump.h ===
#ifndef __APPVERIFIER_USERDUMP_H_
#define __APPVERIFIER_USERDUMP_H_

BOOL
GenerateUserModeDump(
    LPTSTR                  lpszFileName,
    PPROCESS_INFO           pProcess,
    LPEXCEPTION_DEBUG_INFO  ed
    );


#endif // __APPVERIFIER_USERDUMP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\appverif\userdumpp.h ===
/*++

Copyright (c) 1993  Microsoft Corporation

Module Name:

    drwatson.h

Abstract:

    Common header file for drwatson data structures.

Author:

    Wesley Witt (wesw) 1-May-1993

Environment:

    User Mode

--*/

#include <tchar.h>
#include <windows.h>
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

#include <dbghelp.h>

// Implemented in crashlib
PWSTR AsiToUnicode(PSTR);
PSTR UnicodeToAnsi(PWSTR);

typedef enum _CrashDumpType {
    FullDump  = 0,
    MiniDump  = 1,
    FullMiniDump = 2,
} CrashDumpType;

typedef struct _tagOPTIONS {
    _TCHAR                      szLogPath[MAX_PATH];
    _TCHAR                      szWaveFile[MAX_PATH];
    _TCHAR                      szCrashDump[MAX_PATH];
    BOOL                        fDumpSymbols;
    BOOL                        fDumpAllThreads;
    BOOL                        fAppendToLogFile;
    BOOL                        fVisual;
    BOOL                        fSound;
    BOOL                        fCrash;
    // true: Generate user dump name in the range from fname000.dmp to fname999.dmp
    // false: standard behavior, always overwrite fname.dmp when generating a new
    //      dump file.
    BOOL                        fUseSequentialNaming;
    // If TRUE use long file names when sequentially naming the dumps
    // If FALSE use 8.3 file names when sequentially naming the dumps
    //      causes the 'n' of characters to be removed from the end of the
    //      file name to make it fit in the 8.3 format. ie longuser.dmp -> longus00.dmp
    BOOL                        fUseLongFileNames;
    int                         nNextDumpSequence;
    DWORD                       dwInstructions;
    DWORD                       dwMaxCrashes;
    CrashDumpType               dwType;
} OPTIONS, *POPTIONS;

typedef struct _tagCRASHES {
    _TCHAR                      szAppName[256];
    _TCHAR                      szFunction[256];
    SYSTEMTIME                  time;
    DWORD                       dwExceptionCode;
    DWORD_PTR                   dwAddress;
} CRASHES, *PCRASHES;

typedef struct _tagCRASHINFO {
    HWND       hList;
    CRASHES    crash;
    HDC        hdc;
    DWORD      cxExtent;
    DWORD      dwIndex;
    DWORD      dwIndexDesired;
    BYTE      *pCrashData;
    DWORD      dwCrashDataSize;
} CRASHINFO, *PCRASHINFO;

typedef struct _tagTHREADCONTEXT {
    LIST_ENTRY                   ThreadList;
    HANDLE                       hThread;
    DWORD                        dwThreadId;
    DWORD_PTR                    pc;
    DWORD_PTR                    frame;
    DWORD_PTR                    stack;
    CONTEXT                      context;
    DWORD_PTR                    stackBase;
    DWORD_PTR                    stackRA;
    BOOL                         fFaultingContext;
} THREADCONTEXT, *PTHREADCONTEXT;


typedef BOOL (CALLBACK* CRASHESENUMPROC)(PCRASHINFO);

//
// process list structure returned from GetSystemProcessList()
//
typedef struct _PROCESS_LIST {
    DWORD       dwProcessId;
    _TCHAR      ProcessName[MAX_PATH];
} PROCESS_LIST, *PPROCESS_LIST;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\appverif\viewsett.cpp ===
//                                          
// Application Verifier UI
// Copyright (c) Microsoft Corporation, 2001
//
//
//
// module: ViewSett.cpp
// author: DMihai
// created: 02/22/2001
//
// Description:
//  
// "View current registry settings" wizard page class.
//

#include "stdafx.h"
#include "appverif.h"

#include "ViewSett.h"
#include "AVUtil.h"
#include "Setting.h"
#include "AVGlobal.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

//
// Help IDs
//

static DWORD MyHelpIds[] =
{
    0,                              0
};


/////////////////////////////////////////////////////////////////////////////
// CViewSettPage property page

IMPLEMENT_DYNCREATE(CViewSettPage, CAppverifPage)

CViewSettPage::CViewSettPage() : CAppverifPage(CViewSettPage::IDD)
{
	//{{AFX_DATA_INIT(CViewSettPage)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT
}

CViewSettPage::~CViewSettPage()
{
}

void CViewSettPage::DoDataExchange(CDataExchange* pDX)
{
	CAppverifPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CViewSettPage)
	DDX_Control(pDX, IDC_VIEWSETT_UPPER_STATIC, m_UpperStatic);
	DDX_Control(pDX, IDC_VIEWSETT_NEXTDESCR_STATIC, m_NextDescription);
	DDX_Control(pDX, IDC_VIEWSETT_BITS_LIST, m_BitsList);
	DDX_Control(pDX, IDC_VIEWSETT_APPS_LIST, m_AppsList);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CViewSettPage, CAppverifPage)
	//{{AFX_MSG_MAP(CViewSettPage)
    ON_MESSAGE( WM_HELP, OnHelp )
    ON_WM_CONTEXTMENU()
	ON_NOTIFY(LVN_ITEMCHANGED, IDC_VIEWSETT_APPS_LIST, OnItemchangedAppsList)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
ULONG CViewSettPage::GetDialogId() const
{
    return IDD_VIEWSETT_PAGE;
}

/////////////////////////////////////////////////////////////////////////////
VOID CViewSettPage::SetupListHeaderApps()
{
    CString strTitle;
    CRect rectWnd;

    LVCOLUMN lvColumn;

    //
    // The list's rectangle 
    //

    m_AppsList.GetClientRect( &rectWnd );

    ZeroMemory( &lvColumn, 
                sizeof( lvColumn ) );

    lvColumn.mask = LVCF_FMT | LVCF_SUBITEM | LVCF_TEXT | LVCF_WIDTH;
    lvColumn.fmt = LVCFMT_LEFT;

    //
    // Column 0 - enabled or not
    //

    VERIFY( strTitle.LoadString( IDS_FILE_NAME ) );

    lvColumn.pszText = strTitle.GetBuffer( strTitle.GetLength() + 1 );

    if( NULL == lvColumn.pszText )
    {
        goto Done;
    }

    lvColumn.iSubItem = 0;
    lvColumn.cx = (int)( rectWnd.Width() * 0.98 );
    VERIFY( m_AppsList.InsertColumn( 0, &lvColumn ) != -1 );
    strTitle.ReleaseBuffer();

Done:
    NOTHING;
}

/////////////////////////////////////////////////////////////////////////////
VOID CViewSettPage::SetupListHeaderBits()
{
    CString strTitle;
    CRect rectWnd;

    LVCOLUMN lvColumn;

    //
    // The list's rectangle 
    //

    m_BitsList.GetClientRect( &rectWnd );

    ZeroMemory( &lvColumn, 
                sizeof( lvColumn ) );

    lvColumn.mask = LVCF_FMT | LVCF_SUBITEM | LVCF_TEXT | LVCF_WIDTH;
    lvColumn.fmt = LVCFMT_LEFT;

    //
    // Column 0 - Bit name
    //

    VERIFY( strTitle.LoadString( IDS_TEST_TYPE ) );

    lvColumn.pszText = strTitle.GetBuffer( strTitle.GetLength() + 1 );

    if( NULL == lvColumn.pszText )
    {
        goto Done;
    }

    lvColumn.iSubItem = 0;
    lvColumn.cx = (int)( rectWnd.Width() * 0.70 );
    VERIFY( m_BitsList.InsertColumn( 0, &lvColumn ) != -1 );
    strTitle.ReleaseBuffer();

    //
    // Column 0 - Enabled?
    //

    VERIFY( strTitle.LoadString( IDS_ENABLED_QUESTION ) );

    lvColumn.pszText = strTitle.GetBuffer( strTitle.GetLength() + 1 );

    if( NULL == lvColumn.pszText )
    {
        goto Done;
    }

    lvColumn.iSubItem = 1;
    lvColumn.cx = (int)( rectWnd.Width() * 0.29 );
    VERIFY( m_BitsList.InsertColumn( 1, &lvColumn ) != -1 );
    strTitle.ReleaseBuffer();

Done:
    NOTHING;
}

/////////////////////////////////////////////////////////////////////////////
VOID CViewSettPage::FillTheLists()
{
    INT_PTR nAppsNo;
    INT_PTR nCrtAppAppsIndex;
    CAppAndBits *pCrtPair;

    m_AppsList.DeleteAllItems();

    nAppsNo = g_aAppsAndBitsFromRegistry.GetSize();

    if( 0 == nAppsNo )
    {
        //
        /// No apps are verified
        //

        m_BitsList.DeleteAllItems();

        AVSetWindowText( m_UpperStatic, IDS_NO_APPS_VERIFIED );
    }
    else
    {
        AVSetWindowText( m_UpperStatic, IDS_VERIFIED_APPS );
    }

    for( nCrtAppAppsIndex = 0; nCrtAppAppsIndex < nAppsNo; nCrtAppAppsIndex += 1 )
    {
        pCrtPair = g_aAppsAndBitsFromRegistry.GetAt( nCrtAppAppsIndex );

        ASSERT_VALID( pCrtPair );

        AddListItemApps( pCrtPair,
                         nCrtAppAppsIndex );
    }

    if( nAppsNo > 0 )
    {
        m_AppsList.SetItemState( 0,
                                 LVIS_FOCUSED | LVIS_SELECTED,
                                 LVIS_FOCUSED | LVIS_SELECTED );
    }
}

/////////////////////////////////////////////////////////////////////////////
VOID CViewSettPage::UpdateBitsList( CAppAndBits *pCrtPair )
{
    INT nItemsInList;
    INT nCrtItem;

    ASSERT_VALID( pCrtPair );

    nItemsInList = m_BitsList.GetItemCount();

    if( nItemsInList != ARRAY_LENGTH( g_AllNamesAndBits ) )
    {
        //
        // The bits list is empty - fill it out first
        //

        if( FillBitsList() != TRUE )
        {
            //
            // Could not fill the list?!?
            //

            goto Done;
        }
    }

    for( nCrtItem = 0; nCrtItem < ARRAY_LENGTH( g_AllNamesAndBits ); nCrtItem += 1)
    {
        UpdateListItemBits( pCrtPair,
                            nCrtItem );
    }

Done:

    NOTHING;
}

/////////////////////////////////////////////////////////////////////////////
VOID CViewSettPage::UpdateListItemBits( CAppAndBits *pCrtPair,
                                        INT nCrtItem )
{
    LVITEM lvItem;
    CString strEnabled;

    ZeroMemory( &lvItem, sizeof( lvItem ) );

    ASSERT( nCrtItem >= 0 && nCrtItem < ARRAY_LENGTH( g_AllNamesAndBits ) );
    ASSERT( nCrtItem < m_BitsList.GetItemCount() );

    if( ( pCrtPair->m_dwEnabledBits & g_AllNamesAndBits[ nCrtItem ].m_dwBit ) != 0 )
    {
        //
        // This bit is enabled
        //

        VERIFY( AVLoadString( IDS_YES,
                              strEnabled ) );
    }
    else
    {
        //
        // This bit is disabled
        //

        VERIFY( AVLoadString( IDS_NO,
                              strEnabled ) );
    }

    //
    // Sub-item 1 - enabled/disabled
    //

    lvItem.pszText = strEnabled.GetBuffer( strEnabled.GetLength() + 1 );

    if( NULL == lvItem.pszText )
    {
        goto Done;
    }

    lvItem.mask = LVIF_TEXT;
    lvItem.iItem = nCrtItem;
    lvItem.iSubItem = 1;

    VERIFY( m_BitsList.SetItem( &lvItem ) );

    strEnabled.ReleaseBuffer();

Done:
    NOTHING;
}

/////////////////////////////////////////////////////////////////////////////
VOID CViewSettPage::UpdateBitsListFromSelectedApp()
{
    INT nItems;
    INT nCrtItem;
    INT_PTR nCrtAppIndex;
    BOOL bUpdated;
    CAppAndBits *pCrtPair;

    bUpdated = FALSE;

    nItems = m_AppsList.GetItemCount();

    for( nCrtItem = 0; nCrtItem < nItems; nCrtItem += 1 )
    {
        if( m_AppsList.GetItemState( nCrtItem, LVIS_SELECTED ) & LVIS_SELECTED )
        {
            nCrtAppIndex = (INT_PTR) m_AppsList.GetItemData( nCrtItem );

            pCrtPair = g_aAppsAndBitsFromRegistry.GetAt( nCrtAppIndex );

            ASSERT_VALID( pCrtPair );
            
            UpdateBitsList( pCrtPair );

            bUpdated = TRUE;

            break;
        }
    }

    if( FALSE == bUpdated )
    {
        m_BitsList.DeleteAllItems();
    }
}

/////////////////////////////////////////////////////////////////////////////
BOOL CViewSettPage::FillBitsList()
{
    BOOL bSuccess;
    INT_PTR nCrtBitIndex;
    INT nActualItemIndex;
    LVITEM lvItem;
    TCHAR szBitName[ 64 ];

    bSuccess = FALSE;

    ZeroMemory( &lvItem, sizeof( lvItem ) );

    m_BitsList.DeleteAllItems();

    for( nCrtBitIndex = 0; nCrtBitIndex < ARRAY_LENGTH( g_AllNamesAndBits ); nCrtBitIndex += 1 )
    {
        if( AVLoadString( g_AllNamesAndBits[ nCrtBitIndex ].m_uNameStringId,
                          szBitName,
                          ARRAY_LENGTH( szBitName ) ) != TRUE )
        {
            goto Done;
        }

        lvItem.pszText = szBitName;
        lvItem.mask = LVIF_TEXT;
        lvItem.iItem = m_BitsList.GetItemCount();

        nActualItemIndex = m_BitsList.InsertItem( &lvItem );

        if( nActualItemIndex != lvItem.iItem )
        {
            //
            // Could not insert the item?!?
            //

            m_BitsList.DeleteAllItems();

            goto Done;
        }
    }

    bSuccess = TRUE;

Done:
    return bSuccess;
}

/////////////////////////////////////////////////////////////////////////////
INT CViewSettPage::AddListItemApps( CAppAndBits *pCrtPair,
                                    INT_PTR nIndexInArray )
{
    INT nActualIndex;
    LVITEM lvItem;

    nActualIndex = -1;

    ZeroMemory( &lvItem, sizeof( lvItem ) );

    //
    // LVITEM's member pszText is not a const pointer 
    // so we need to GetBuffer here :-(
    //

    //
    // Sub-item 0 - the name of the app
    //

    lvItem.pszText = pCrtPair->m_strAppName.GetBuffer( pCrtPair->m_strAppName.GetLength() + 1 );

    if( NULL == lvItem.pszText )
    {
        goto Done;
    }

    lvItem.mask = LVIF_TEXT | LVIF_PARAM;
    lvItem.lParam = nIndexInArray;
    lvItem.iItem = m_BitsList.GetItemCount();

    nActualIndex = m_AppsList.InsertItem( &lvItem );

    pCrtPair->m_strAppName.ReleaseBuffer();

Done:
    //
    // All done
    //

    return nActualIndex;
}

/////////////////////////////////////////////////////////////////////////////
// CViewSettPage message handlers

/////////////////////////////////////////////////////////////
LONG CViewSettPage::OnHelp( WPARAM wParam, LPARAM lParam )
{
    LONG lResult = 0;
    LPHELPINFO lpHelpInfo = (LPHELPINFO)lParam;

    ::WinHelp( 
        (HWND) lpHelpInfo->hItemHandle,
        g_szAVHelpFile,
        HELP_WM_HELP,
        (DWORD_PTR) MyHelpIds );

    return lResult;
}

/////////////////////////////////////////////////////////////////////////////
void CViewSettPage::OnContextMenu(CWnd* pWnd, CPoint point) 
{
    ::WinHelp( 
        pWnd->m_hWnd,
        g_szAVHelpFile,
        HELP_CONTEXTMENU,
        (DWORD_PTR) MyHelpIds );
}

/////////////////////////////////////////////////////////////////////////////
BOOL CViewSettPage::OnSetActive() 
{
    ASSERT_VALID( m_pParentSheet );

    m_pParentSheet->SetWizardButtons(
        PSWIZB_BACK | PSWIZB_FINISH );

    //
    // Read the current registry settings and fille out the lists
    //

    AVReadCrtRegistrySettings();
    FillTheLists();

    return CAppverifPage::OnSetActive();
}

/////////////////////////////////////////////////////////////////////////////
BOOL CViewSettPage::OnInitDialog() 
{
    CAppverifPage::OnInitDialog();

    m_BitsList.SetExtendedStyle( 
        LVS_EX_FULLROWSELECT );
    m_AppsList.SetExtendedStyle( 
        LVS_EX_FULLROWSELECT );

    //
    // Setup our list and fill it out if we already have something in the app names array
    //

    SetupListHeaderApps();
    SetupListHeaderBits();

    //
    // Display the description of the next step
    //

    AVSetWindowText( m_NextDescription, IDS_VIEWSETT_NEXT_DESCR );
		
	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

/////////////////////////////////////////////////////////////////////////////
void CViewSettPage::OnItemchangedAppsList(NMHDR* pNMHDR, LRESULT* pResult) 
{
	NM_LISTVIEW* pNMListView = (NM_LISTVIEW*)pNMHDR;

    if( ( pNMListView->uChanged & LVIF_STATE ) != 0 &&
        ( pNMListView->uNewState & LVIS_SELECTED) != ( pNMListView->uOldState & LVIS_SELECTED) )
    {
        UpdateBitsListFromSelectedApp();
    }
	
	*pResult = 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\appverif\viewsett.h ===
//                                          
// Application Verifier UI
// Copyright (c) Microsoft Corporation, 2001
//
//
//
// module: ViewSett.h
// author: DMihai
// created: 02/22/2001
//
// Description:
//  
// "View current registry settings" wizard page class.
//

#if !defined(AFX_VIEWSETT_H__C2472BD0_7D7B_4539_BBB3_B52C52919EDF__INCLUDED_)
#define AFX_VIEWSETT_H__C2472BD0_7D7B_4539_BBB3_B52C52919EDF__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "AVPage.h"

//
// Forward declarations
//

class CAppAndBits;

/////////////////////////////////////////////////////////////////////////////
// CViewSettPage dialog

class CViewSettPage : public CAppverifPage
{
	DECLARE_DYNCREATE(CViewSettPage)

// Construction
public:
	CViewSettPage();
	~CViewSettPage();

protected:

    VOID SetupListHeaderApps();
    VOID SetupListHeaderBits();

    VOID FillTheLists();
    BOOL FillBitsList();

    INT  AddListItemApps( CAppAndBits *pCrtPair,
                          INT_PTR nIndexInArray );
    
    VOID UpdateBitsList( CAppAndBits *pCrtPair );
    VOID UpdateListItemBits( CAppAndBits *pCrtPair,
                             INT nCrtItem );

    VOID UpdateBitsListFromSelectedApp();

    //
    // Overrides
    //

    //
    // All the property pages derived from this class should 
    // provide this method.
    //

    virtual ULONG GetDialogId() const;

    //
	// ClassWizard generate virtual function overrides
    //

	//{{AFX_VIRTUAL(CViewSettPage)
	public:
	virtual BOOL OnSetActive();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

protected:
    // Dialog Data
	//{{AFX_DATA(CViewSettPage)
	enum { IDD = IDD_VIEWSETT_PAGE };
	CStatic	m_UpperStatic;
	CStatic	m_NextDescription;
	CListCtrl	m_BitsList;
	CListCtrl	m_AppsList;
	//}}AFX_DATA

protected:
    //
	// Generated message map functions
    //

    //{{AFX_MSG(CViewSettPage)
	virtual BOOL OnInitDialog();
    afx_msg LONG OnHelp( WPARAM wParam, LPARAM lParam );
	afx_msg void OnContextMenu(CWnd* pWnd, CPoint point);
	afx_msg void OnItemchangedAppsList(NMHDR* pNMHDR, LRESULT* pResult);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_VIEWSETT_H__C2472BD0_7D7B_4539_BBB3_B52C52919EDF__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\appverif\viewlog.h ===
//                                          
// Application Verifier UI
// Copyright (c) Microsoft Corporation, 2001
//
//
//
// module: ChooseExe.h
// author: CLupu
// created: 04/13/2001
//
// Description:
//  
// "Choose an executable to run" wizard page class.
//

#if !defined(AFX_VIEWLOG_H_INCLUDED_)
#define AFX_VIEWLOG_H_INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "AVPage.h"

#define COLUMN_NUMBER       0
#define COLUMN_TIMES        1
#define COLUMN_DESCRIPTION  2


/////////////////////////////////////////////////////////////////////////////
// CViewLogPage dialog

class CViewLogPage : public CAppverifPage
{
    DECLARE_DYNCREATE(CViewLogPage)

// Construction
public:
    CViewLogPage();
    ~CViewLogPage();

protected:

    //
    // Overrides
    //

    //
    // All the property pages derived from this class should 
    // provide this method.
    //

    virtual ULONG GetDialogId() const;
    
    void HandleSelectionChanged( int nSel );
    
    void InsertIssue( DWORD dwIssueId, DWORD dwOccurenceCount );
    
    BOOL ReadLog();

    //
    // ClassWizard generate virtual function overrides
    //

    //{{AFX_VIRTUAL(CViewLogPage)
    public:
    virtual BOOL OnSetActive();
    protected:
    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
    //}}AFX_VIRTUAL


protected:
    // Dialog Data
    //{{AFX_DATA(CViewLogPage)
    enum { IDD = IDD_VIEWLOG_PAGE };
    CListCtrl        m_IssuesList;
    //}}AFX_DATA

    int   m_nIssues;
    DWORD m_dwSelectedIssue;

protected:
    //
    // Generated message map functions
    //

    //{{AFX_MSG(CViewLogPage)
    virtual BOOL OnInitDialog();
    afx_msg LONG OnHelp( WPARAM wParam, LPARAM lParam );
    afx_msg void OnContextMenu( CWnd* pWnd, CPoint point );
	afx_msg void OnClickIssue( NMHDR* pNMHDR, LRESULT* pResult );
	afx_msg void OnClickURL( NMHDR* pNMHDR, LRESULT* pResult );
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()

};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_VIEWLOG_H_INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\asn1\asn1all\defs.h ===
/* Copyright (C) Boris Nikolaus, Germany, 1996-1997. All rights reserved. */

extern int linedirective;
extern int lineno;
extern char filename[];
extern char outfilename[];
extern char incfilename[];
extern FILE *fout, *finc;
extern char *startsym;
extern char *prefix;
typedef struct item_s {
    int isnonterm;
    int isexternal;
    char *tag;
    char *identifier;
    char *altidentifier;
    char **args;
    struct item_s **items;
    int empty;
    int checked;
} item_t;
extern item_t symbols[];
extern int nsymbols;
extern item_t *items[];
extern int nitems;

struct bounds_s {
	unsigned lower;   /* 0 for no lower bound */
	unsigned upper;   /* 0 for no upper bound */
};
struct rhs_s {
	enum { eCCode, eItem, eSequence, eNode, eBounded, eAlternative } type;
	union {
		struct {
			char *ccode;
			int line;
			int column;
			char *file;
		} ccode;
		struct {
			char *identifier;
			char *args;
		} item;
		struct {
			struct rhs_s *element;
			struct rhs_s *next;
		} sequence, alternative;
		struct {
			struct rhs_s *left;
			struct rhs_s *right;
		} node;
		struct {
			struct bounds_s bounds;
			struct rhs_s *items;
		} bounded;
	} u;
};
struct token_s {
	char *identifier;
	char *altidentifier;
};
struct nterm_s {
	char *identifier;
	char **tags;
};
struct lhs_s {
	char *identifier;
	char *args;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\asn1\asn1all\all.c ===
/* Copyright (C) Boris Nikolaus, Germany, 1996-1997. All rights reserved. */

#include <stdio.h>
#include <stdlib.h>
#include <ctype.h>
#include <stdarg.h>
#include <string.h>
#include "defs.h"
#include "parser.h"

int linedirective = 1;
int constargs = 0;
char *conststr = "";
char *ll = "ll";
char *LL = "LL";
int outline = 1;
char outfilename[256];
char incfilename[256];
FILE *fout, *finc;
char *startsym = NULL;
char *prefix = "";
item_t symbols[4096];
int nsymbols = 0;
item_t *items[32768];
int nitems = 0;
char *tags[256];
int ntags = 0;
item_t *check[4096];
int ncheck = 0;
int expected_lr = 0;
int found_lr = 0;
int optimizer = 0;
char *usetypes = NULL;
char *USETYPES = NULL;

/* list for checking for left-recursions */
typedef struct rhslst_s {
    struct rhslst_s *next;
    struct rhs_s *rhs;
} rhslst_t;

item_t *get_symbol(char *identifier);
char *convert(char *ccode);
int output_rhs2(char *identifier, struct rhs_s *rhs, int *number, int depth, int *count, int *nextcount);
void add_rules2(item_t **istk, int istkp, rhslst_t *c);
void check_lr(item_t *symbol);

#ifndef HAS_GETOPT
extern int getopt(int argc, char **argv, const char *opts);
extern char *optarg;
extern int optind;
#endif

void open_file(char *file);

/* print an error message */
void
error(LLPOS *pos, char *fmt, ...)
{
    va_list args;
    va_start(args, fmt);
    llverror(stderr, pos, fmt, args);
    va_end(args);
}

/* error function required by parser generator */
void
llverror(FILE *f, LLPOS *pos, char *fmt, va_list args)
{
    if (pos && pos->line && pos->file)
    fprintf(f, "Error at line %d of \"%s\": ", pos->line,
        pos->file);
    vfprintf(f, fmt, args);
    putc('\n', f);
    exit(1);
}

/* write to c file, count lines for #line directive */
void
output(char *fmt, ...)
{
    char buf[32768];
    char *p;
    va_list args;

    va_start(args, fmt);
    vsprintf(buf, fmt, args);
    fputs(buf, fout);
#if 1
    fflush(fout);
#endif
    for (p = buf; (p = strchr(p, '\n')); ) {
        outline++;
    p++;
    }
    va_end(args);
}

/* emit #line directive for lines of generated file */
void
output_line()
{
    fprintf(fout, "#line %d \"%s\"\n", ++outline, outfilename);
}

/* write to h file */
void
incput(char *fmt, ...)
{
    va_list args;

    va_start(args, fmt);
    vfprintf(finc, fmt, args);
#if 1
    fflush(fout);
#endif
    va_end(args);
}

/* emit a call for one item into c file */
void
output_call(int number, item_t *item, char *args)
{
    char *ident;
    char *pre;

    /* get identifier of item */
    if (item->altidentifier)
    ident = item->altidentifier;
    else
    ident = item->identifier;

    /* terminal symbol? then use llterm(), otherwise name of non-terminal */
    if (!item->isnonterm) {

    /* if identifier is a single character, then use these character as */
    /* token value, otherwise add prefix to get the name of the #define */
    if (*ident == '\'')
        pre = "";
    else
        pre = prefix;

    /* call llterm to check the next token; */
    /* if item has a tag, use an LLSTYPE argument to get the item's val */
    if (item->tag) {
        output("%sterm(%s%s, &%slval, &%sstate_%d, &%sstate_%d)",
        ll, pre, ident, ll, ll, number - 1, ll, number);
    } else {
        output("%sterm(%s%s, (%sSTYPE *)0, &%sstate_%d, &%sstate_%d)",
        ll, pre, ident, LL, ll, number - 1, ll, number);
    }
    } else {

    /* call non-terminal function for parsing the non-terminal; */
    /* if item has a tag, use an tagtyped argument to get the item's val; */
    /* if item has arguments, add this argument list */
    if (item->tag) {
        if (*args)
        output("%s_%s(&%satt_%d, &%sstate_%d, &%sstate_%d, %s)",
            ll, ident, ll, number, ll, number - 1, ll, number, args);
        else
        output("%s_%s(&%satt_%d, &%sstate_%d, &%sstate_%d)",
            ll, ident, ll, number, ll, number - 1, ll, number);
    } else {
        if (*args)
        output("%s_%s(&%sstate_%d, &%sstate_%d, %s)",
            ll, ident, ll, number - 1, ll, number, args);
        else
        output("%s_%s(&%sstate_%d, &%sstate_%d)",
            ll, ident, ll, number - 1, ll, number);
    }
    }
}

/* emit all actions needed for parsing a rhs */
void
output_rhs(char *identifier, struct rhs_s *rhs)
{
    int count[32], nextcount = 2;
    int i, number = 1;
    count[1] = 1;

    /* we need a state and some debugs when entering */
    output("%sSTATE %sstate_0;\n", LL, ll);
    output("%sDEBUG_ENTER(\"%s\");\n", LL, identifier);
    output("\n%sstate_0 = *%sin;\n", ll, ll);

    /* one define for the LLFAILED() macro */
    output("#undef failed\n#define failed failed1\n");

    /* output rhs parsing actions */
    i = output_rhs2(identifier, rhs, &number, 1, count, &nextcount);

    /* print needed closing braces */
    if (i) {
    for (; i > 0; i--)
        output("}");
    output("\n");
    }

    /* leave (successful) this parsing function */
    output("%sDEBUG_LEAVE(\"%s\", 1);\n", LL, identifier);
    output("return 1;\n");

    /* leave unsuccessful this parsing function */
    output("failed1: %sDEBUG_LEAVE(\"%s\", 0);\n", LL, identifier);
    output("return 0;\n");
}

/* emit actions needed for parsing a rhs */
int
output_rhs2(char *identifier, struct rhs_s *rhs, int *number, int depth, int *count, int *nextcount)
{
    int i, j, n;
    item_t *item;
    struct rhs_s *r;

    /* empty rule? then completed */
    if (!rhs) {
    output("*%sout = %sstate_%d;\n", ll, ll, *number - 1);
    return 0;
    }

    /* check type of rhs */
    switch (rhs->type) {
    case eCCode:

    /* some C code statements shall be inserted: */
    /* prefixed by #line directive if desired, dump the code, and */
    /* use another #line directive to reference the generated file again */
    /* return 1 brace which need to be closed */
    if (linedirective)
        output("#line %d \"%s\"\n", rhs->u.ccode.line, rhs->u.ccode.file);
    output("{%s\n", convert(rhs->u.ccode.ccode));
    if (linedirective)
        output_line();
    return 1;

    case eItem:

    /* one item shall be parsed: */
    /* get vars for a new state and for the item's value (if needed), */
    /* dump the call for parsing the item, branch to the corresponding */
    /* failed label if the parsing failed, copy the item's value if */
    /* there's any and increment the number of the items */
    /* return 1 brace which need to be closed */
    output("{%sSTATE %sstate_%d;", LL, ll, *number);
    item = get_symbol(rhs->u.item.identifier);
    if (item->tag)
        output("%s %satt_%d;", item->tag, ll, *number);
    output("\nif (!");
    output_call(*number, item, rhs->u.item.args);
    output(") goto failed%d;\n", count[depth]);
    if (!item->isnonterm && item->tag) {
        for (i = 0; i < ntags; i++)
        if (!strcmp(tags[i], item->tag))
            break;
        if (i >= ntags)
        output("%satt_%d = %slval;\n", ll, *number, ll);
        else
        output("%satt_%d = %slval._%s;\n", ll, *number, ll, item->tag);
    }
    (*number)++;
    return 1;

    case eSequence:

    /* a sequence of items shall be parsed: */
    /* output all items of this sequence and return the counted number of */
    /* braces to be closed */
    /* dump copy of last output state before last ccode or at end */
    i = j = 0;
    for (; rhs; rhs = rhs->u.sequence.next) {
        if (!j) {
        for (r = rhs; r; r = r->u.sequence.next) {
            if (r->u.sequence.element->type != eCCode)
            break;
        }
        if (!r) {
            output("*%sout = %sstate_%d;\n", ll, ll, *number - 1);
            j = 1;
        }
        }
        i += output_rhs2(identifier, rhs->u.sequence.element, number,
        depth, count, nextcount);
    }
    if (!j)
        output("*%sout = %sstate_%d;\n", ll, ll, *number - 1);
    return i;

    case eAlternative:

    /* a list of alternatives shall be parsed: */
    /* if there's only one alternative, parse this one alternative */
    /* otherwise we need to emit some backtracking code: */
    /* - a define for the LLFAILED macro */
    /* - a current position into the input stream, */
    /* - a current stack position for the backtracking, */
    /* - a stack check (and resize if required), */
    /* - a switch statement for the alternatives, */
    /* - a case entry for each alternative, */
    /* - a debug statement for each alternative, */
    /* - the actions of each alternative, */
    /* - closing braces for the actions */
    /* - a default case in the switch statement for failure of parsing */
    /*   by any alternative */
    /* - a failed label for start of backtracking */
    /* - code for backtracking (resetting the position into the input */
    /*   stream, resetting the stack position */
    /* - two braces later be closed */
    if (!rhs->u.alternative.next)
        return output_rhs2(identifier, rhs->u.alternative.element, number,
        depth, count, nextcount);
    count[depth + 1] = (*nextcount)++;
    output("#undef failed\n#define failed failed%d\n",
        count[depth + 1]);
    output("{unsigned %spos%d = %scpos, %sstp%d = %scstp;\n",
        ll, depth, ll, ll, depth, ll);
    output("%sCHECKSTK;\n", LL);
    output("for (;;) {\n");
    output("switch (%sstk[%scstp++]) {\n", ll, ll);
    n = *number;
    j = 1;
    for (; rhs; rhs = rhs->u.alternative.next) {
        output("case %d: case -%d:\n", j, j);
        output("%sDEBUG_ALTERNATIVE(\"%s\", %d);\n", LL, identifier, j);
        i = output_rhs2(identifier, rhs->u.alternative.element, number,
        depth + 1, count, nextcount);
        output("break;\n");
        if (i) {
        for (; i > 0; i--)
            output("}");
        output("\n");
        }
        *number = n;
        j++;
    }
    output("default:\n");
    output("%sstk[--%scstp] = 1;\n", ll, ll);
    output("goto failed%d;\n", count[depth]);
    output("failed%d:\n", count[depth + 1]);
    output("%sDEBUG_BACKTRACKING(\"%s\");\n", LL, identifier);
    output("if (%sstk[--%scstp] < 0) %sstk[%scstp] = 0; else %sstk[%scstp]++;\n", ll, ll, ll, ll, ll, ll);
    output("%scpos = %spos%d; %scstp = %sstp%d;\n", ll, ll, depth, ll, ll, depth);
    output("continue;\n");
    output("} break;\n");
    return 2;

#if 0
    case eBounded:

    /* this code does not work due to a design bug I wanted to parse */
    /* EBNF repetions; will fix it when I've time or need */
    count[depth + 1] = (*nextcount)++;
    output("#undef failed\n#define failed failed%d\n",
        count[depth + 1]);
    output("{unsigned %spos%d = %scpos, %sstp%d = %scstp;\n",
        ll, depth, ll, ll, depth, ll);
    output("int %sm, %sn, %ss, %sl = %d, %su = ",
        ll, ll, ll, ll, rhs->u.bounded.bounds.lower, ll);
    if (rhs->u.bounded.bounds.upper)
        output("%d;\n", rhs->u.bounded.bounds.upper);
    else
        output("INT_MAX - 1;\n");
    if (rhs->u.bounded.items->type == eNode)
        output("int %sf = 1;\n", ll);
    output("%sCHECKSTK;\n", LL);
    output("%ss = (%sstk[%scstp] > 0 ? 1 : -1);\n", ll, ll, ll);
    output("if (!(%sn = %sstk[%scstp++]) || %sn * %ss > %su - %sl + 1) {\n",
        ll, ll, ll, ll, ll, ll, ll);
    output("%sstk[--%scstp] = 1; %scpos = %spos%d; %scstp = %sstp%d; goto failed%d; }\n",
        ll, ll, ll, ll, depth, ll, ll, depth, count[depth]);
    output("for (%sm = %sn = %su + 1 - %sn * %ss; %sn; %sn--) {\n",
        ll, ll, ll, ll, ll, ll, ll);
    output("%sDEBUG_ITERATION(\"%s\", %sm - %sn + 1);\n",
        LL, identifier, ll, ll);
    n = *number;
    if (rhs->u.bounded.items->type == eNode) {
        output("if (!%sf) {\n", ll);
        i = output_rhs2(identifier, rhs->u.bounded.items->u.node.left,
        number, depth + 1, count, nextcount) + 1;
        output("%sf = 1;\n", ll);
        if (i) {
        for (; i > 0; i--)
            output("}");
        output("\n");
        }
        i = output_rhs2(identifier, rhs->u.bounded.items->u.node.right,
        number, depth + 1, count, nextcount);
        if (i) {
        for (; i > 0; i--)
            output("}");
        output("\n");
        }
        output("%sf = 0;\n", ll);
    } else {
        i = output_rhs2(identifier, rhs->u.bounded.items, number,
        depth + 1, count, nextcount);
        if (i) {
        for (; i > 0; i--)
            output("}");
        output("\n");
        }
    }
    *number = n;
    output("} failed%d:\n", count[depth + 1]);
    if (rhs->u.bounded.items->type == eNode) {
        output("if (%sf || %sm - %sn < %sl || (%sstk[%sstp%d] < 0 && %sn)) {\n",
        ll, ll, ll, ll, ll, ll, depth, ll);
    } else {
        output("if (%sm - %sn < %sl || (%sstk[%sstp%d] < 0 && %sn)) {\n",
        ll, ll, ll, ll, ll, depth, ll);
    }
    output("%sstk[%sstp%d] = 1; %scpos = %spos%d; %scstp = %sstp%d; goto failed%d; }\n",
        ll, ll, depth, ll, ll, depth, ll, ll, depth, count[depth]);
    output("%sstk[%sstp%d] = (%su - %sm + %sn + 1) * %ss;\n",
        ll, ll, depth, ll, ll, ll, ll);
    return 1;
#endif
    }
    abort();
    /*NOTREACHED*/
}

/* save the name of the start symbol */
void
set_start(char *startstr)
{
    startsym = startstr;
}

/* save the prefix to be used for the #defines of the terminals */
void
set_prefix(char *prefixstr)
{
    prefix = prefixstr;
}

/* save the prefix to be used for the generated functions, macros and types */
void
set_module(char *modulestr)
{
    char *p;

    ll = strdup(modulestr);
    for (p = ll; *p; p++)
    *p = (char)tolower(*p);
    LL = strdup(modulestr);
    for (p = LL; *p; p++)
    *p = (char)toupper(*p);
}

/* find the tag in the list of tag declarations or add it if it's new */
char *
find_tag(char *tag)
{
    int i;

    for (i = 0; i < ntags; i++)
    if (!strcmp(tags[i], tag))
        return tags[i];
    return tags[ntags++] = tag;
}

/* create an lhs symbol or an terminal symbol */
item_t *
create_symbol(int isnonterm, int isexternal, char *tag, char *identifier, char *altidentifier,
    char **args)
{
    symbols[nsymbols].isnonterm = isnonterm;
    symbols[nsymbols].isexternal = isexternal;
    symbols[nsymbols].tag = tag;
    symbols[nsymbols].identifier = identifier;
    symbols[nsymbols].altidentifier = altidentifier;
    symbols[nsymbols].args = args;
    symbols[nsymbols].items = NULL;
    symbols[nsymbols].empty = 0;
    return symbols + nsymbols++;
}

/* search a symbol */
item_t *
find_symbol(char *identifier)
{
    int i;

    for (i = 0; i < nsymbols; i++) {
    if (!strcmp(symbols[i].identifier, identifier))
        return symbols + i;
    }
    return NULL;
}

/* search a symbol or add it if it's new */
item_t *
get_symbol(char *identifier)
{
    item_t *item;
    char *ident;

    item = find_symbol(identifier);
    if (!item) {
    if (*identifier == '\"') {
        ident = strdup(identifier + 1);
        ident[strlen(ident) - 1] = 0;
        item = create_symbol(0, 0, NULL, identifier, ident, NULL);
    } else {
        item = create_symbol(*identifier != '\'', 0, NULL, identifier, NULL,
        NULL);
    }
    }
    return item;
}

/* start the definition of the rhs of a symbol */
void
start_rule(item_t *symbol)
{
    if (!symbol->isnonterm)
    error(NULL, "symbol %s is a terminal\n", symbol->identifier);
    if (symbol->items)
    error(NULL, "symbol %s twice defined\n", symbol->identifier);
    symbol->items = items + nitems;
}

/* add rhs items of one alternative to current definition */
void
add_items(item_t **i, int n)
{
    if (nitems + n + 1 > sizeof(items) / sizeof(*items))
    error(NULL, "out of item space\n");
    while (n--)
    items[nitems++] = *i++;
    items[nitems++] = (item_t *)1; /* end-of-alternative */
}

/* finish current definition */
void
end_rule(item_t *item)
{
    if (nitems >= sizeof(items) / sizeof(*items))
    error(NULL, "out of item space\n");
    items[nitems++] = NULL; /* end-of-definition */
}

/* save the rules for lr-recursion search */
void
add_rules(item_t *item, struct rhs_s *rhs)
{
    item_t *istk[64];
    rhslst_t l;

    start_rule(item);
    l.next = NULL;
    l.rhs = rhs;
    add_rules2(istk, 0, &l);
    end_rule(item);
}

/* save the rules for lr-recursion search */
void
add_rules2(item_t **istk, int istkp, rhslst_t *c)
{
    struct rhs_s *rhs;
    item_t *item;
    rhslst_t l, ll;

    if (!c) {
    add_items(istk, istkp);
    return;
    }
    rhs = c->rhs;
    c = c->next;
    if (!rhs) {
    add_rules2(istk, istkp, c);
    return;
    }
    switch (rhs->type) {
    case eCCode:
    add_rules2(istk, istkp, c);
    break;
    case eItem:
    item = get_symbol(rhs->u.item.identifier);
    istk[istkp++] = item;
    add_rules2(istk, istkp, c);
    break;
    case eSequence:
    if (rhs->u.sequence.next) {
        l.next = c;
        l.rhs = rhs->u.sequence.next;
        ll.next = &l;
        ll.rhs = rhs->u.sequence.element;
        add_rules2(istk, istkp, &ll);
    } else {
        l.next = c;
        l.rhs = rhs->u.sequence.element;
        add_rules2(istk, istkp, &l);
    }
    break;
    case eAlternative:
    l.next = c;
    l.rhs = rhs->u.alternative.element;
    add_rules2(istk, istkp, &l);
    if (rhs->u.alternative.next) {
        l.rhs = rhs->u.alternative.next;
        add_rules2(istk, istkp, &l);
    }
    break;
#if 0
    case eBounded:
    if (rhs->u.bounded.items->type == eNode) {
        if (!rhs->u.bounded.bounds.lower)
        add_rules2(istk, istkp, c);
        if (rhs->u.bounded.bounds.lower <= 1 &&
            (rhs->u.bounded.bounds.upper >= 1 ||
        !rhs->u.bounded.bounds.upper)) {
        l.next = c;
        l.rhs = rhs->u.bounded.items->u.node.right;
        add_rules2(istk, istkp, &l);
        }
        if (rhs->u.bounded.bounds.lower <= 2 &&
        (rhs->u.bounded.bounds.upper >= 2 ||
        !rhs->u.bounded.bounds.upper)) {
        l.next = c;
        l.rhs = rhs->u.bounded.items->u.node.right;
        ll.next = &l;
        ll.rhs = rhs->u.bounded.items->u.node.left;
        lll.next = &ll;
        lll.rhs = rhs->u.bounded.items->u.node.right;
        add_rules2(istk, istkp, &lll);
        }
    } else {
        if (!rhs->u.bounded.bounds.lower)
        add_rules2(istk, istkp, c);
        if (rhs->u.bounded.bounds.lower <= 1 &&
            (rhs->u.bounded.bounds.upper >= 1 ||
        !rhs->u.bounded.bounds.upper)) {
        l.next = c;
        l.rhs = rhs->u.bounded.items;
        add_rules2(istk, istkp, &l);
        }
    }
    break;
    case eNode:
    abort();
#endif
    }
}

/* convert some C code containing special vars ($1..$n, $$, $<1..$<n, $<<, */
/* $>1..$>n, $>>, @1..@n, @@) into real C code */
char *
convert(char *ccode)
{
    static char buffer[4096];
    char *p = buffer;

    while (*ccode) {
    if (*ccode == '$') {
        if (ccode[1] == '$') {
        sprintf(p, "(*%sret)", ll);
        p += strlen(p);
        ccode += 2;
        continue;
        } else if (ccode[1] == '<') {
            if (ccode[2] == '<') {
            sprintf(p, "(*%sin)", ll);
            p += strlen(p);
            ccode += 3;
            continue;
        } else if (isdigit(ccode[2])) {
            sprintf(p, "%sstate_%d",
            ll, strtol(ccode + 2, &ccode, 10) - 1);
            p += strlen(p);
            continue;
        }
        } else if (ccode[1] == '>') {
            if (ccode[2] == '>') {
            sprintf(p, "(*%sout)", ll);
            p += strlen(p);
            ccode += 3;
            continue;
        } else if (isdigit(ccode[2])) {
            sprintf(p, "%sstate_%d", ll, strtol(ccode + 2, &ccode, 10));
            p += strlen(p);
            continue;
        }
        } else if (isdigit(ccode[1])) {
        sprintf(p, "%satt_%d", ll, strtol(ccode + 1, &ccode, 10));
        p += strlen(p);
        continue;
        } else {
        ccode++;
        sprintf(p, "%sarg_", ll);
        p += strlen(p);
        }
    } else if (*ccode == '@') {
        if (ccode[1] == '@') {
        sprintf(p, "%sstate_0.pos", ll);
        p += strlen(p);
        ccode += 2;
        continue;
        } else if (isdigit(ccode[1])) {
        sprintf(p, "%sstate_%d.pos", ll, strtol(ccode + 1, &ccode, 10));
        p += strlen(p);
        continue;
        }
    }
    *p++ = *ccode++;
    }
    *p = 0;
    return strdup(buffer);
}

/* create start of include file */
void
create_inc()
{
    int i, termnr;

    if (usetypes) {
    incput("typedef %sSTYPE %sSTYPE;\n", USETYPES, LL);
    incput("typedef %sTERM %sTERM;\n", USETYPES, LL);
    } else {
    incput("typedef union %sSTYPE{\n", LL);
    for (i = 0; i < ntags; i++)
        incput("\t%s _%s;\n", tags[i], tags[i]);
    incput("} %sSTYPE;\n", LL);
    incput("typedef struct %sTERM {\n", LL);
    incput("\tint token;\n");
    incput("\t%sSTYPE lval;\n", LL);
    incput("\t%sPOS pos;\n", LL);
    incput("} %sTERM;\n", LL);
    }
    incput("void %sscanner(%sTERM **tokens, unsigned *ntokens);\n", ll, LL);
    incput("int %sparser(%sTERM *tokens, unsigned ntokens, %s%sSTATE *%sin, %sSTATE *llout);\n",
    ll, LL, conststr, LL, ll, LL);
    incput("void %sprinterror(FILE *f);\n", ll);
    incput("void %sverror(FILE *f, %sPOS *pos, char *fmt, va_list args);\n",
    ll, LL);
    incput("void %serror(FILE *f, %sPOS *pos, char *fmt, ...);\n", ll, LL);
    incput("int %sgettoken(int *token, %sSTYPE *lval, %sPOS *pos);\n",
    ll, LL, LL);
    incput("#if %sDEBUG > 0\n", LL);
    incput("void %sdebug_init();\n", ll);
    incput("#endif\n");
    if (!usetypes) {
    termnr = 257;
    for (i = 0; i < nsymbols; i++) {
        if (!symbols[i].isnonterm && *symbols[i].identifier != '\'')
        incput("#define %s%s %d\n", prefix,
            symbols[i].altidentifier ? symbols[i].altidentifier :
            symbols[i].identifier, termnr++);
    }
    }
}

/* create start of c file */
void
create_vardefs()
{
    output("#include <stdio.h>\n");
    output("#include <stdlib.h>\n");
    output("#include <stdarg.h>\n");
    output("#include <limits.h>\n");
    output("#include \"%s\"\n\n", incfilename);
    output("int %scpos;\n", ll);
    output("int *%sstk;\n", ll);
    output("unsigned %sstksize;\n", ll);
    output("unsigned %scstp = 1;\n", ll);
    output("%sTERM *%stokens;\n", LL, ll);
    output("int %sntokens;\n", ll);
    output("char %serrormsg[256];\n", ll);
    output("%sPOS %serrorpos;\n", LL, ll);
    output("int %sepos;\n", ll);
    output("%sSTYPE %slval;\n", LL, ll);
    output("\n");
    output("int %sterm(int token, %sSTYPE *lval, %s%sSTATE *%sin, %sSTATE *%sout);\n", ll, LL, conststr, LL, ll, LL, ll);
    output("void %sfailed(%sPOS *pos, char *fmt, ...);\n", ll, LL);
    output("void %sresizestk();\n", ll);
    output("#define %sCHECKSTK do{if (%scstp + 1 >= %sstksize) %sresizestk();}while(/*CONSTCOND*/0)\n", LL, ll, ll, ll);
    output("#define %sFAILED(_err) do{%sfailed _err; goto failed;}while(/*CONSTCOND*/0)\n", LL, ll);
    output("#define %sCUTOFF do{unsigned i; for (i = %sstp; i < %scstp; i++) if (%sstk[i] > 0) %sstk[i] = -%sstk[i];}while(/*CONSTCOND*/0)\n", LL, ll, ll, ll, ll, ll);
    output("#define %sCUTTHIS do{if (%sstk[%sstp] > 0) %sstk[%sstp] = -%sstk[%sstp];}while(/*CONSTCOND*/0)\n", LL, ll, ll, ll, ll, ll, ll);
    output("#define %sCUTALL do{unsigned i; for (i = 0; i < %scstp; i++) if (%sstk[i] > 0) %sstk[i] = -%sstk[i];}while(/*CONSTCOND*/0)\n", LL, ll, ll, ll, ll);
    output("\n");
    output("#if %sDEBUG > 0\n", LL);
    output("int %sdebug;\n", ll);
    output("int last_linenr;\n");
    output("char *last_file = \"\";\n");
    output("#define %sDEBUG_ENTER(_ident) %sdebug_enter(_ident)\n", LL, ll);
    output("#define %sDEBUG_LEAVE(_ident,_succ) %sdebug_leave(_ident,_succ)\n", LL, ll);
    output("#define %sDEBUG_ALTERNATIVE(_ident,_alt) %sdebug_alternative(_ident,_alt)\n", LL, ll);
    output("#define %sDEBUG_ITERATION(_ident,_num) %sdebug_iteration(_ident,_num)\n", LL, ll);
    output("#define %sDEBUG_TOKEN(_exp,_pos) %sdebug_token(_exp,_pos)\n", LL, ll);
    output("#define %sDEBUG_ANYTOKEN(_pos) %sdebug_anytoken(_pos)\n", LL, ll);
    output("#define %sDEBUG_BACKTRACKING(_ident) %sdebug_backtracking(_ident)\n", LL, ll);
    output("void %sdebug_init();\n", ll);
    output("void %sdebug_enter(char *ident);\n", ll);
    output("void %sdebug_leave(char *ident, int succ);\n", ll);
    output("void %sdebug_alternative(char *ident, int alt);\n", ll);
    output("void %sdebug_token(int expected, unsigned pos);\n", ll);
    output("void %sdebug_anytoken(unsigned pos);\n", ll);
    output("void %sdebug_backtracking(char *ident);\n", ll);
    output("void %sprinttoken(%sTERM *token, char *identifier, FILE *f);\n", ll, LL);
    output("#else\n");
    output("#define %sDEBUG_ENTER(_ident)\n", LL);
    output("#define %sDEBUG_LEAVE(_ident,_succ)\n", LL);
    output("#define %sDEBUG_ALTERNATIVE(_ident,_alt)\n", LL);
    output("#define %sDEBUG_ITERATION(_ident,_num)\n", LL);
    output("#define %sDEBUG_TOKEN(_exp,_pos)\n", LL);
    output("#define %sDEBUG_ANYTOKEN(_pos)\n", LL);
    output("#define %sDEBUG_BACKTRACKING(_ident)\n", LL);
    output("#endif\n");
    output("\n");
}

/* create end of c file */
void
create_trailer()
{
    int i, j;
    char *p, *q;
    char buffer[256];

    if (startsym) {
    output("int\n");
    output("%sparser(%sTERM *tokens, unsigned ntokens, %s%sSTATE *%sin, %sSTATE *%sout)\n", ll, LL, conststr, LL, ll, LL, ll);
    output("{\n");
    output("unsigned i;\n");
    output("%sDEBUG_ENTER(\"%sparser\");\n", LL, ll);
    output("%stokens = tokens; %sntokens = ntokens;\n", ll, ll);
    output("for (i = 0; i < %sstksize; i++) %sstk[i] = 1;\n", ll, ll);
    output("%scstp = 1; %scpos = 0; %sepos = 0; *%serrormsg = 0;\n",
        ll, ll, ll, ll);
    output("#if %sDEBUG > 0\n", LL);
    output("last_linenr = 0; last_file = \"\";\n");
    output("#endif\n");
    output("{unsigned %spos1 = %scpos, %sstp1 = %scstp;\n", ll, ll, ll, ll);
    output("%sCHECKSTK;\n", LL);
    output("for (;;) {\n");
    output("switch (%sstk[%scstp++]) {\n", ll, ll);
    output("case 1: case -1:\n");
    output("if (!%s_%s(%sin, %sout)) goto failed2;\n",
        ll, startsym, ll, ll);
    output("if (%scpos != %sntokens) goto failed2;\n", ll, ll);
    output("break;\n");
    output("default:\n");
    output("%sstk[--%scstp] = 1;\n", ll, ll);
    output("goto failed1;\n");
    output("failed2:\n");
    output("%sDEBUG_BACKTRACKING(\"%sparser\");\n", LL, ll);
    output("if (%sstk[--%scstp] < 0) %sstk[%scstp] = 0; else %sstk[%scstp]++;\n", ll, ll, ll, ll, ll, ll);
    output("%scpos = %spos1; %scstp = %sstp1;\n", ll, ll, ll, ll);
    output("continue;\n");
    output("} break;\n");
    output("}}\n");
    output("%sDEBUG_LEAVE(\"%sparser\", 1);\n", LL, ll);
    output("return 1;\n");
    output("failed1:\n");
    output("%sDEBUG_LEAVE(\"%sparser\", 0);\n", LL, ll);
    output("return 0;\n");
    output("}\n");
    output("\n");
    }
    output("int\n");
    output("%sterm(int token, %sSTYPE *lval, %s%sSTATE *%sin, %sSTATE *%sout)\n", ll, LL, conststr, LL, ll, LL, ll);
    output("{\n");
    output("#if %sDEBUG > 0\n", LL);
    output("\tif (%sdebug > 0 && (%stokens[%scpos].pos.line > last_linenr || strcmp(%stokens[%scpos].pos.file, last_file))) {\n", ll, ll, ll, ll, ll);
    output("\tfprintf(stderr, \"File \\\"%%s\\\", Line %%5d                    \\r\",\n");
    output("\t\t%stokens[%scpos].pos.file, %stokens[%scpos].pos.line);\n", ll, ll, ll, ll);
    output("\tlast_linenr = %stokens[%scpos].pos.line / 10 * 10 + 9;\n", ll, ll);
    output("\tlast_file = %stokens[%scpos].pos.file;\n", ll, ll);
    output("\t}\n");
    output("#endif\n");
    output("\tif (%sstk[%scstp] != 1 && %sstk[%scstp] != -1) {\n", ll, ll, ll, ll);
    output("\t\t%sDEBUG_BACKTRACKING(\"%sterm\");\n", LL, ll);
    output("\t\t%sstk[%scstp] = 1;\n", ll, ll);
    output("\t\treturn 0;\n");
    output("\t}\n");
    output("\t%sDEBUG_TOKEN(token, %scpos);\n", LL, ll);
    output("\tif (%scpos < %sntokens && %stokens[%scpos].token == token) {\n", ll, ll, ll, ll);
    output("\t\tif (lval)\n");
    output("\t\t\t*lval = %stokens[%scpos].lval;\n", ll, ll);
    output("\t\t*%sout = *%sin;\n", ll, ll);
    output("\t\t%sout->pos = %stokens[%scpos].pos;\n", ll, ll, ll);
    output("\t\t%scpos++;\n", ll);
    output("\t\t%sCHECKSTK;\n", LL);
    output("\t\t%scstp++;\n", ll);
    output("\t\treturn 1;\n");
    output("\t}\n");
    output("\t%sfailed(&%stokens[%scpos].pos, NULL);\n", ll, ll, ll);
    output("\t%sstk[%scstp] = 1;\n", ll, ll);
    output("\treturn 0;\n");
    output("}\n");
    output("\n");
    output("int\n");
    output("%sanyterm(%sSTYPE *lval, %s%sSTATE *%sin, %sSTATE *%sout)\n", ll, LL, conststr, LL, ll, LL, ll);
    output("{\n");
    output("#if %sDEBUG > 0\n", LL);
    output("\tif (%sdebug > 0 && (%stokens[%scpos].pos.line > last_linenr || strcmp(%stokens[%scpos].pos.file, last_file))) {\n", ll, ll, ll, ll, ll);
    output("\tfprintf(stderr, \"File \\\"%%s\\\", Line %%5d                    \\r\",\n");
    output("\t\t%stokens[%scpos].pos.file, %stokens[%scpos].pos.line);\n", ll, ll, ll, ll);
    output("\tlast_linenr = %stokens[%scpos].pos.line / 10 * 10 + 9;\n", ll, ll);
    output("\tlast_file = %stokens[%scpos].pos.file;\n", ll, ll);
    output("\t}\n");
    output("#endif\n");
    output("\tif (%sstk[%scstp] != 1 && %sstk[%scstp] != -1) {\n", ll, ll, ll, ll);
    output("\t\t%sDEBUG_BACKTRACKING(\"%sanyterm\");\n", LL, ll);
    output("\t\t%sstk[%scstp] = 1;\n", ll, ll);
    output("\t\treturn 0;\n");
    output("\t}\n");
    output("\t%sDEBUG_ANYTOKEN(%scpos);\n", LL, ll);
    output("\tif (%scpos < %sntokens) {\n", ll, ll);
    output("\t\tif (lval)\n");
    output("\t\t\t*lval = %stokens[%scpos].lval;\n", ll, ll);
    output("\t\t*%sout = *%sin;\n", ll, ll);
    output("\t\t%sout->pos = %stokens[%scpos].pos;\n", ll, ll, ll);
    output("\t\t%scpos++;\n", ll);
    output("\t\t%sCHECKSTK;\n", LL);
    output("\t\t%scstp++;\n", ll);
    output("\t\treturn 1;\n");
    output("\t}\n");
    output("\t%sfailed(&%stokens[%scpos].pos, NULL);\n", ll, ll, ll);
    output("\t%sstk[%scstp] = 1;\n", ll, ll);
    output("\treturn 0;\n");
    output("}\n");
    output("void\n");
    output("%sscanner(%sTERM **tokens, unsigned *ntokens)\n", ll, LL);
    output("{\n");
    output("\tunsigned i = 0;\n");
    output("#if %sDEBUG > 0\n", LL);
    output("\tint line = -1;\n");
    output("#endif\n");
    output("\n");
    output("\t*ntokens = 1024;\n");
    output("\t*tokens = (%sTERM *)malloc(*ntokens * sizeof(%sTERM));\n", LL, LL);
    output("\twhile (%sgettoken(&(*tokens)[i].token, &(*tokens)[i].lval, &(*tokens)[i].pos)) {\n", ll);
    output("#if %sDEBUG > 0\n", LL);
    output("\t\tif (%sdebug > 0 && (*tokens)[i].pos.line > line) {\n", ll);
    output("\t\t\tline = (*tokens)[i].pos.line / 10 * 10 + 9;\n");
    output("\t\t\tfprintf(stderr, \"File \\\"%%s\\\", Line %%5d                    \\r\",\n");
    output("\t\t\t\t(*tokens)[i].pos.file, (*tokens)[i].pos.line);\n");
    output("\t\t}\n");
    output("#endif\n");
    output("\t\tif (++i >= *ntokens) {\n");
    output("\t\t\t*ntokens *= 2;\n");
    output("\t\t\t*tokens = (%sTERM *)realloc(*tokens, *ntokens * sizeof(%sTERM));\n", LL, LL);
    output("\t\t}\n");
    output("\t}\n");
    output("\t(*tokens)[i].token = 0;\n");
    output("\t*ntokens = i;\n");
    output("#if %sDEBUG > 0\n", LL);
    output("\t%sdebug_init();\n", ll);
    output("#endif\n");
    output("\t%sresizestk();\n", ll);
    output("}\n");
    output("\n");
    output("void\n");
    output("%sfailed(%sPOS *pos, char *fmt, ...)\n", ll, LL);
    output("{\n");
    output("\tva_list args;\n");
    output("\n");
    output("\tva_start(args, fmt);\n");
    output("\tif (%scpos > %sepos || %scpos == %sepos && !*%serrormsg) {\n", ll, ll, ll, ll, ll);
    output("\t\t%sepos = %scpos;\n", ll, ll);
    output("\t\tif (fmt)\n");
    output("\t\t\tvsprintf(%serrormsg, fmt, args);\n", ll);
    output("\t\telse\n");
    output("\t\t\t*%serrormsg = 0;\n", ll);
    output("\t\t%serrorpos = *pos;\n", ll);
    output("\t}\n");
    output("\tva_end(args);\n");
    output("}\n");
    output("\n");
    output("void\n");
    output("%sprinterror(FILE *f)\n", ll);
    output("{\n");
    output("#if %sDEBUG > 0\n", LL);
    output("\tfputs(\"                                \\r\", stderr);\n");
    output("#endif\n");
    output("\tif (*%serrormsg)\n", ll);
    output("\t\t%serror(f, &%serrorpos, %serrormsg);\n", ll, ll, ll);
    output("\telse\n");
    output("\t\t%serror(f, &%serrorpos, \"Syntax error\");\n", ll, ll);
    output("}\n");
    output("\n");
    output("void\n");
    output("%serror(FILE *f, %sPOS *pos, char *fmt, ...)\n", ll, LL);
    output("{\n");
    output("\tva_list args;\n");
    output("\tva_start(args, fmt);\n");
    output("\t%sverror(f, pos, fmt, args);\n", ll);
    output("\tva_end(args);\n");
    output("}\n");
    output("\n");
    output("void\n");
    output("%sresizestk()\n", ll);
    output("{\n");
    output("\tunsigned i;\n");
    output("\n");
    output("\tif (%scstp + 1 >= %sstksize) {\n", ll, ll);
    output("\t\ti = %sstksize;\n", ll);
    output("\t\tif (!%sstksize)\n", ll);
    output("\t\t\t%sstk = (int *)malloc((%sstksize = 4096) * sizeof(int));\n", ll, ll);
    output("\t\telse\n");
    output("\t\t\t%sstk = (int *)realloc(%sstk, (%sstksize *= 2) * sizeof(int));\n", ll, ll, ll);
    output("\t\tfor (; i < %sstksize; i++)\n", ll);
    output("\t\t\t%sstk[i] = 1;\n", ll);
    output("\t}\n");
    output("}\n");
    output("\n");
    output("#if %sDEBUG > 0\n", LL);
    output("int %sdepth;\n", ll);
    output("char *%stokentab[] = {\n", ll);
    for (i = 0; i < 257; i++) {
    if (i == 0)
        output("\"EOF\"");
    else if (i == '\\' || i == '\"')
        output(",\"'\\%c'\"", i);
    else if (i >= 32 && i < 127)
        output(",\"'%c'\"", i);
    else if (i < 257)
        output(",\"#%d\"", i);
    if ((i % 8) == 7)
        output("\n");
    }
    for (j = 0; j < nsymbols; j++) {
    if (!symbols[j].isnonterm && *symbols[j].identifier != '\'') {
        for (p = symbols[j].identifier, q = buffer; *p; p++) {
        if (*p == '\"' || *p == '\\')
            *q++ = '\\';
        *q++ = *p;
        }
        *q = 0;
        output(",\"%s\"", buffer);
        if ((i++ % 8) == 7)
        output("\n");
    }
    }
    if (i % 8)
    output("\n");
    output("};\n");
    output("\n");
    output("void\n");
    output("%sdebug_init()\n", ll);
    output("{\n");
    output("\tchar *p;\n");
    output("\tp = getenv(\"%sDEBUG\");\n", LL);
    output("\tif (p)\n");
    output("\t\t%sdebug = atoi(p);\n", ll);
    output("}\n");
    output("\n");
    output("void\n");
    output("%sdebug_enter(char *ident)\n", ll);
    output("{\n");
    output("\tint i;\n");
    output("\n");
    output("\tif (%sdebug < 2)\n", ll);
    output("\t\treturn;\n");
    output("\tfor (i = 0; i < %sdepth; i++)\n", ll);
    output("\t\tfputs(\"| \", stdout);\n");
    output("\tprintf(\"/--- trying rule %%s\\n\", ident);\n");
    output("\t%sdepth++;\n", ll);
    output("}\n");
    output("\n");
    output("void\n");
    output("%sdebug_leave(char *ident, int succ)\n", ll);
    output("{\n");
    output("\tint i;\n");
    output("\n");
    output("\tif (%sdebug < 2)\n", ll);
    output("\t\treturn;\n");
    output("\t%sdepth--;\n", ll);
    output("\tfor (i = 0; i < %sdepth; i++)\n", ll);
    output("\t\tfputs(\"| \", stdout);\n");
    output("\tif (succ)\n");
    output("\t\tprintf(\"\\\\--- succeeded to apply rule %%s\\n\", ident);\n");
    output("\telse\n");
    output("\t\tprintf(\"\\\\--- failed to apply rule %%s\\n\", ident);\n");
    output("}\n");
    output("\n");
    output("void\n");
    output("%sdebug_alternative(char *ident, int alt)\n", ll);
    output("{\n");
    output("\tint i;\n");
    output("\n");
    output("\tif (%sdebug < 2)\n", ll);
    output("\t\treturn;\n");
    output("\tfor (i = 0; i < %sdepth - 1; i++)\n", ll);
    output("\t\tfputs(\"| \", stdout);\n");
    output("\tprintf(\">--- trying alternative %%d for rule %%s\\n\", alt, ident);\n");
    output("}\n");
    output("\n");
    output("%sdebug_iteration(char *ident, int num)\n", ll);
    output("{\n");
    output("\tint i;\n");
    output("\n");
    output("\tif (%sdebug < 2)\n", ll);
    output("\t\treturn;\n");
    output("\tfor (i = 0; i < %sdepth - 1; i++)\n", ll);
    output("\t\tfputs(\"| \", stdout);\n");
    output("\tprintf(\">--- trying iteration %%d for rule %%s\\n\", num, ident);\n");
    output("}\n");
    output("\n");
    output("void\n");
    output("%sdebug_token(int expected, unsigned pos)\n", ll);
    output("{\n");
    output("\tint i;\n");
    output("\n");
    output("\tif (%sdebug < 2)\n", ll);
    output("\t\treturn;\n");
    output("\tfor (i = 0; i < %sdepth; i++)\n", ll);
    output("\t\tfputs(\"| \", stdout);\n");
    output("\tif (pos < %sntokens && expected == %stokens[pos].token)\n", ll, ll);
    output("\t\tprintf(\"   found token \");\n");
    output("\telse\n");
    output("\t\tprintf(\"   expected token %%s, found token \", %stokentab[expected]);\n", ll);
    output("\tif (pos >= %sntokens)\n", ll);
    output("\t\tprintf(\"<EOF>\");\n");
    output("\telse\n");
    output("\t\t%sprinttoken(%stokens + pos, %stokentab[%stokens[pos].token], stdout);\n", ll, ll, ll, ll);
    output("\tputchar('\\n');\n");
    output("}\n");
    output("\n");
    output("void\n");
    output("%sdebug_anytoken(unsigned pos)\n", ll);
    output("{\n");
    output("\tint i;\n");
    output("\n");
    output("\tif (%sdebug < 2)\n", ll);
    output("\t\treturn;\n");
    output("\tfor (i = 0; i < %sdepth; i++)\n", ll);
    output("\t\tfputs(\"| \", stdout);\n");
    output("\tprintf(\"   found token \");\n");
    output("\tif (pos >= %sntokens)\n", ll);
    output("\t\tprintf(\"<EOF>\");\n");
    output("\telse\n");
    output("\t\t%sprinttoken(%stokens + pos, %stokentab[%stokens[pos].token], stdout);\n", ll, ll, ll, ll);
    output("\tputchar('\\n');\n");
    output("}\n");
    output("\n");
    output("void\n");
    output("%sdebug_backtracking(char *ident)\n", ll);
    output("{\n");
    output("\tint i;\n");
    output("\n");
    output("\tif (%sdebug < 2)\n", ll);
    output("\t\treturn;\n");
    output("\tfor (i = 0; i < %sdepth; i++)\n", ll);
    output("\t\tfputs(\"| \", stdout);\n");
    output("\tprintf(\"   backtracking rule %%s\\n\", ident);\n");
    output("}\n");
    output("\n");
    output("#endif\n");
}

/* search for left recursion and complain about if they are unexpected */
void
search_leftrecursion()
{
    int i;
    item_t **item;
    int done;
    int empty;

    /* check for missing rules */
    for (i = 0; i < nsymbols; i++) {
    if (symbols[i].isnonterm && !symbols[i].isexternal && !symbols[i].items)
        error(NULL, "missing rule for symbol %s\n", symbols[i].identifier);
    }

    /* mark rules that may be empty */
    do {
    done = 1;
    for (i = 0; i < nsymbols; i++) {
        if (symbols[i].empty || !symbols[i].isnonterm ||
        symbols[i].isexternal)
        continue;
        item = symbols[i].items;
        do {
        empty = 1;
        for (; *item != (item_t *)1; item++) {
            if (!(*item)->empty)
            empty = 0;
        }
        item++;
        if (empty) {
            symbols[i].empty = 1;
            done = 0;
        }
        } while (*item);
    }
    } while (!done);

    /* check every rule for left recursion */
    for (i = 0; i < nsymbols; i++)
    symbols[i].checked = 0;
    for (i = 0; i < nsymbols; i++) {
    if (!symbols[i].checked)
        check_lr(symbols + i);
    }
    if (found_lr > expected_lr) {
    fprintf(stderr, "Found %d left recursions, exiting\n", found_lr);
    exit(1);
    }
}

/* check one rule for left recursion */
void
check_lr(item_t *symbol)
{
    int i;
    item_t **item;
    int try_flag;

    if (!symbol->isnonterm || symbol->isexternal)
    return;
    for (i = 0; i < ncheck; i++) {
    if (check[i] == symbol) {
        if (++found_lr > expected_lr) {
        fprintf(stderr, "Error: found left recursion: ");
        for (; i < ncheck; i++)
            fprintf(stderr, "%s->", check[i]->identifier);
        fprintf(stderr, "%s\n", symbol->identifier);
        }
        return;
    }
    }
    check[ncheck++] = symbol;
    item = symbol->items;
    do {
    try_flag = 1;
    for (; *item != (item_t *)1; item++) {
        if (try_flag)
        check_lr(*item);
        try_flag = try_flag && (*item)->empty;
    }
    item++;
    } while (*item);
    ncheck--;
}

/* main program */
int
__cdecl main(int argc, char **argv)
{
    extern int optind;
    int c;
    LLSTATE in, out;
    LLTERM *tokens;
    unsigned ntokens;
    char *p;

    /* parse option args */
    while ((c = getopt(argc, argv, "i:Olt:c")) != EOF) {
        switch (c) {
    case 'i':
        expected_lr = atoi(optarg);
        break;
    case 'l':
        linedirective = 0;
        break;
    case 'O':
        optimizer = 1;
        break;
    case 't':
        usetypes = strdup(optarg);
        for (p = usetypes; *p; p++)
        *p = (char)tolower(*p);
        USETYPES = strdup(optarg);
        for (p = USETYPES; *p; p++)
        *p = (char)toupper(*p);
        break;
    case 'c':
        constargs = 1;
        conststr = "const ";
        break;
    default:
    usage:
        fprintf(stderr, "Usage: %s [-i #ignore_lr] [-l] [-c] [-t from_prefix] filename.ll\n", argv[0]);
        exit(1);
    }
    }
    if (argc != optind + 1)
        goto usage;

    /* open input file and output files */
    open_file(argv[optind]);
    strcpy(outfilename, argv[optind]);
    if (strlen(outfilename) > 3 &&
    !strcmp(outfilename + strlen(outfilename) - 3, ".ll"))
    outfilename[strlen(outfilename) - 3] = 0;
    strcat(outfilename, ".c");
    fout = fopen(outfilename, "w");
    if (!fout) {
    perror(outfilename);
    exit(1);
    }
    fprintf(fout, "/* Copyright (C) Boris Nikolaus, Germany, 1996-1997. All rights reserved. */\n\n");
    strcpy(incfilename, argv[optind]);
    if (strlen(incfilename) > 3 &&
    !strcmp(incfilename + strlen(incfilename) - 3, ".ll"))
    incfilename[strlen(incfilename) - 3] = 0;
    strcat(incfilename, ".h");
    finc = fopen(incfilename, "w");
    if (!finc) {
    perror(incfilename);
    exit(1);
    }
    fprintf(finc, "/* Copyright (C) Boris Nikolaus, Germany, 1996-1997. All rights reserved. */\n\n");

    /* scan and parse the parser description */
    llscanner(&tokens, &ntokens);
    if (!llparser(tokens, ntokens, &in, &out))
    llprinterror(stderr);

    /* check for left recursions */
    search_leftrecursion();

    /* optimize */
    if (optimizer)
    /*create_firstsets()*/ ;

    /* create end of c file and header file */
    create_trailer();
    create_inc();

    /* finished! */
    fclose(fout);
    fclose(finc);
    return 0;
}

/* why is this function not in MS libc? */
#ifndef HAS_GETOPT
char *optarg;
int optind = 1;
static int optpos = 1;

int getopt(int argc, char **argv, const char *options) {
    char *p, *q;

    optarg = NULL;

    /* find start of next option */
    do {
        if (optind >= argc)
        return EOF;
        if (*argv[optind] != '-' && *argv[optind] != '/')
            return EOF;
        p = argv[optind] + optpos++;
    if (!*p) {
        optind++;
        optpos = 1;
    }
    } while (!*p);

    /* find option in option string */
    q = strchr(options, *p);
    if (!q)
    return '?';

    /* set optarg for parameterized option and adjust optind and optpos for next call */
    if (q[1] == ':') {
    if (p[1]) {
        optarg = p + 1;
        optind++;
        optpos = 1;
    } else if (++optind < argc) {
        optarg = argv[optind];
        optind++;
        optpos = 1;
    } else {
        return '?';
    }
    }

    /* return found option */
    return *p;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\appverif\viewlog.cpp ===
//                                          
// Application Verifier UI
// Copyright (c) Microsoft Corporation, 2001
//
//
//
// module: ChooseExe.cpp
// author: CLupu
// created: 04/13/2001
//
// Description:
//  
// "Select individual tests" wizard page class.
//

#include "stdafx.h"
#include "appverif.h"

#include "ViewLog.h"
#include "AVUtil.h"
#include "AVGlobal.h"
#include "Log.h"

#ifdef _DEBUG
    #define new DEBUG_NEW
    #undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


//
// Help IDs
//

static DWORD MyHelpIds[] =
{
    0, 0
};


/////////////////////////////////////////////////////////////////////////////
// CViewLogPage property page

IMPLEMENT_DYNCREATE(CViewLogPage, CAppverifPage)

CViewLogPage::CViewLogPage() : CAppverifPage(CViewLogPage::IDD)
{
    //{{AFX_DATA_INIT(CViewLogPage)
    // NOTE: the ClassWizard will add member initialization here
    //}}AFX_DATA_INIT

    m_nIssues = 0;
}

CViewLogPage::~CViewLogPage()
{
}

void CViewLogPage::DoDataExchange(CDataExchange* pDX)
{
    CAppverifPage::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CViewLogPage)
    DDX_Control(pDX, IDC_ISSUES, m_IssuesList);
    //}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CViewLogPage, CAppverifPage)
//{{AFX_MSG_MAP(CViewLogPage)
ON_MESSAGE( WM_HELP, OnHelp )
ON_WM_CONTEXTMENU()
ON_NOTIFY( NM_CLICK, IDC_ISSUES, OnClickIssue )
ON_NOTIFY( NM_CLICK, IDC_ISSUE_DESCRIPTION, OnClickURL )
//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
ULONG CViewLogPage::GetDialogId() const
{
    return IDD_VIEWLOG_PAGE;
}

/////////////////////////////////////////////////////////////////////////////

void CViewLogPage::InsertIssue( DWORD dwIssueId, DWORD dwOccurenceCount )
{
    LVITEM   lvi;
    TCHAR    szBuffer[32];
    TCHAR    szIssue[256];

    wsprintf(szBuffer, _T("%d."), m_nIssues + 1);

    VERIFY( AVLoadString( dwIssueId, szIssue, 256) );

    lvi.mask      = LVIF_TEXT | LVIF_PARAM;
    lvi.pszText   = szBuffer;
    lvi.iItem     = m_nIssues;
    lvi.iSubItem  = 0;
    lvi.lParam    = dwIssueId;

    m_IssuesList.InsertItem(&lvi);

    wsprintf(szBuffer, _T("%d"), dwOccurenceCount);

    m_IssuesList.SetItemText(m_nIssues, COLUMN_TIMES, szBuffer);
    m_IssuesList.SetItemText(m_nIssues, COLUMN_DESCRIPTION, szIssue);

    m_nIssues++;

    return;
}

BOOL CViewLogPage::ReadLog()
{
    HANDLE      hFile = INVALID_HANDLE_VALUE;
    HANDLE      hMap = NULL;
    PBYTE       pMap = NULL;
    BOOL        bReturn = FALSE;
    PISSUEREC   pRecord;
    int         i;

    hFile = CreateFile( g_szFileLog,
                        GENERIC_READ,
                        0,
                        NULL,
                        OPEN_EXISTING,
                        FILE_ATTRIBUTE_NORMAL | FILE_FLAG_RANDOM_ACCESS,
                        NULL );

    if ( hFile == INVALID_HANDLE_VALUE )
    {
        goto CleanupAndFail;
    }

    hMap = CreateFileMapping( hFile,
                              NULL,
                              PAGE_READONLY,
                              0,
                              LOGFILESIZE,
                              NULL );

    if ( hMap == NULL )
    {
        goto CleanupAndFail;
    }

    pMap = (PBYTE)MapViewOfFile( hMap, FILE_MAP_READ, 0, 0, LOGFILESIZE );

    if ( pMap == NULL )
    {
        goto CleanupAndFail;
    }

    pRecord = (PISSUEREC)(pMap + sizeof(LOGFILEHEADER));

    for ( i = 0; i < MAX_ISSUES_COUNT; i++ )
    {
        if ( pRecord->dwOccurenceCount > 0 )
        {
            InsertIssue( EVENT_FROM_IND( i ), pRecord->dwOccurenceCount ); 
        }
        pRecord++;
    }

    bReturn = TRUE;

    CleanupAndFail:

    if ( !bReturn )
    {
        AVErrorResourceFormat( IDS_READLOG_FAILED );
    }

    if ( pMap != NULL )
    {
        UnmapViewOfFile( pMap );
    }

    if ( hMap != NULL )
    {
        CloseHandle( hMap );
    }

    if ( hFile != INVALID_HANDLE_VALUE )
    {
        CloseHandle( hFile );
    }

    return bReturn;
}


/////////////////////////////////////////////////////////////////////////////
// CViewLogPage message handlers

/////////////////////////////////////////////////////////////
LONG CViewLogPage::OnHelp( WPARAM wParam, LPARAM lParam )
{
    LONG lResult = 0;
    LPHELPINFO lpHelpInfo = (LPHELPINFO)lParam;

    ::WinHelp(
             (HWND) lpHelpInfo->hItemHandle,
             g_szAVHelpFile,
             HELP_WM_HELP,
             (DWORD_PTR) MyHelpIds );

    return lResult;
}

void CViewLogPage::HandleSelectionChanged( int nSel )
{
    if (nSel == -1)
    {
        return;
    }

    LVITEM lvi;
    TCHAR  szRemedy[512];

    lvi.iItem    = nSel;
    lvi.iSubItem = 0;
    lvi.mask     = LVIF_PARAM;

    m_IssuesList.GetItem( &lvi );

    VERIFY( AVLoadString( (UINT)(lvi.lParam + 1), szRemedy, 512 ) );

    m_dwSelectedIssue = (DWORD)lvi.lParam;

    SetDlgItemText( IDC_ISSUE_DESCRIPTION, szRemedy );
}


void CViewLogPage::OnClickIssue( NMHDR* pNMHDR, LRESULT* pResult ) 
{
    NM_LISTVIEW* pNMListView = (NM_LISTVIEW*)pNMHDR;

    LVHITTESTINFO ht;
    int           nSel;

    ::GetCursorPos(&ht.pt);

    m_IssuesList.ScreenToClient( &ht.pt );

    nSel = m_IssuesList.SubItemHitTest( &ht );

    if (nSel != -1)
    {
        m_IssuesList.SetItemState( nSel,
                                   LVIS_SELECTED | LVIS_FOCUSED,
                                   LVIS_SELECTED | LVIS_FOCUSED );
    }

    HandleSelectionChanged( nSel );
}

void CViewLogPage::OnClickURL( NMHDR* pNMHDR, LRESULT* pResult ) 
{
    NM_LISTVIEW* pNMListView = (NM_LISTVIEW*)pNMHDR;

    SHELLEXECUTEINFO sei = { 0};
    TCHAR            szURL[256] = _T("");

    VERIFY( AVLoadString( m_dwSelectedIssue + 2, szURL, 256 ) );

    if (szURL[0] == 0)
    {
        return;
    }

    sei.cbSize = sizeof(SHELLEXECUTEINFO);
    sei.fMask  = SEE_MASK_DOENVSUBST;
    sei.hwnd   = m_hWnd;
    sei.nShow  = SW_SHOWNORMAL;
    sei.lpFile = szURL;

    ShellExecuteEx(&sei);
}


/////////////////////////////////////////////////////////////////////////////
void CViewLogPage::OnContextMenu(CWnd* pWnd, CPoint point) 
{
    ::WinHelp(
             pWnd->m_hWnd,
             g_szAVHelpFile,
             HELP_CONTEXTMENU,
             (DWORD_PTR) MyHelpIds );
}


/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
BOOL CViewLogPage::OnSetActive() 
{
    ASSERT_VALID( m_pParentSheet );

    m_pParentSheet->SetWizardButtons( PSWIZB_BACK | PSWIZB_FINISH );

    return CAppverifPage::OnSetActive();
}



/////////////////////////////////////////////////////////////////////////////
BOOL CViewLogPage::OnInitDialog() 
{
    CAppverifPage::OnInitDialog();

    m_IssuesList.SetExtendedStyle( LVS_EX_FULLROWSELECT | m_IssuesList.GetExtendedStyle() );

    m_IssuesList.InsertColumn( COLUMN_NUMBER, _T("No."), LVCFMT_LEFT, 40 );
    m_IssuesList.InsertColumn( COLUMN_TIMES, _T("Times"), LVCFMT_LEFT, 80 );
    m_IssuesList.InsertColumn( COLUMN_DESCRIPTION, _T("Issue description"), LVCFMT_LEFT, 250 );

    ReadLog();

    return TRUE;  // return TRUE unless you set the focus to a control
                  // EXCEPTION: OCX Property Pages should return FALSE
}

/////////////////////////////////////////////////////////////////////////////
// CViewLogPage message handlers
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\asn1\asn1all\parser.h ===
/* Copyright (C) Boris Nikolaus, Germany, 1996-1997. All rights reserved. */

typedef char *string;
typedef char **strings;
typedef int integer;
typedef char *ccode;
typedef struct bounds_s bounds;
typedef struct rhs_s *rhs;
typedef struct token_s token;
typedef struct nterm_s nterm;
typedef struct lhs_s lhs;
typedef struct LLPOS {
	int line;
	int column;
	char *file;
} LLPOS;
typedef struct LLSTATE {
	LLPOS pos;
} LLSTATE;
int ll_main(LLSTATE *llin, LLSTATE *llout);
int ll_declsect(LLSTATE *llin, LLSTATE *llout);
int ll_decl(LLSTATE *llin, LLSTATE *llout);
int ll_tokens(LLSTATE *llin, LLSTATE *llout, string llarg_tag);
int ll_tokens2(LLSTATE *llin, LLSTATE *llout, string llarg_tag);
int ll_token(token *llret, LLSTATE *llin, LLSTATE *llout, string llarg_tag);
int ll_nterms(LLSTATE *llin, LLSTATE *llout, string llarg_tag, integer llarg_ext);
int ll_nterms2(LLSTATE *llin, LLSTATE *llout, string llarg_tag, integer llarg_ext);
int ll_nterm(nterm *llret, LLSTATE *llin, LLSTATE *llout, string llarg_tag);
int ll_tags(strings *llret, LLSTATE *llin, LLSTATE *llout);
int ll_tag(string *llret, LLSTATE *llin, LLSTATE *llout);
int ll_union(LLSTATE *llin, LLSTATE *llout);
int ll_state(LLSTATE *llin, LLSTATE *llout);
int ll_state1(LLSTATE *llin, LLSTATE *llout);
int ll_rulesect(LLSTATE *llin, LLSTATE *llout);
int ll_rule(LLSTATE *llin, LLSTATE *llout);
int ll_lhs(lhs *llret, LLSTATE *llin, LLSTATE *llout);
int ll_rhss(rhs *llret, LLSTATE *llin, LLSTATE *llout);
int ll_rhss2(rhs *llret, LLSTATE *llin, LLSTATE *llout);
int ll_items(rhs *llret, LLSTATE *llin, LLSTATE *llout);
int ll_item(rhs *llret, LLSTATE *llin, LLSTATE *llout);
int ll_extension(bounds *llret, LLSTATE *llin, LLSTATE *llout);
int ll_lhsargs(string *llret, LLSTATE *llin, LLSTATE *llout, string llarg_ide);
int ll_lhsarglist(string *llret, LLSTATE *llin, LLSTATE *llout, strings llarg_tags, string llarg_ide);
int ll_args(string *llret, LLSTATE *llin, LLSTATE *llout);
int ll_arglist(string *llret, LLSTATE *llin, LLSTATE *llout);
int ll_csect(LLSTATE *llin, LLSTATE *llout);
typedef union LLSTYPE{
	string _string;
	ccode _ccode;
	token _token;
	integer _integer;
	nterm _nterm;
	strings _strings;
	lhs _lhs;
	rhs _rhs;
	bounds _bounds;
} LLSTYPE;
typedef struct LLTERM {
	int token;
	LLSTYPE lval;
	LLPOS pos;
} LLTERM;
void llscanner(LLTERM **tokens, unsigned *ntokens);
int llparser(LLTERM *tokens, unsigned ntokens, LLSTATE *llin, LLSTATE *llout);
void llprinterror(FILE *f);
void llverror(FILE *f, LLPOS *pos, char *fmt, va_list args);
void llerror(FILE *f, LLPOS *pos, char *fmt, ...);
int llgettoken(int *token, LLSTYPE *lval, LLPOS *pos);
#if LLDEBUG > 0
void lldebug_init();
#endif
#define IDENTIFIER 257
#define ARG 258
#define CCODE 259
#define TAGDEF 260
#define PERCENT_PERCENT 261
#define PERCENT_TOKEN 262
#define PERCENT_TYPE 263
#define PERCENT_EXTERNAL 264
#define PERCENT_UNION 265
#define PERCENT_STATE 266
#define PERCENT_START 267
#define PERCENT_PREFIX 268
#define PERCENT_MODULE 269
#define PERCENT_LBRACE 270
#define PERCENT_RBRACE 271
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\asn1\asn1all\parser.c ===
/* Copyright (C) Boris Nikolaus, Germany, 1996-1997. All rights reserved. */

#line 4 "parser.ll"
#include <stdio.h>
#include <string.h>
#include "defs.h"

#define MAXTAGS 16

extern char *find_tag(char *);
extern item_t *find_symbol(char *);
extern item_t *get_symbol(char *);
extern char *convert(char *);
extern item_t *create_symbol(int isnonterm, int isexternal, char *tag, char *identifier, char *altidentifier, char **args);
extern char *conststr;
extern char *ll;
extern char *LL;
extern char *usetypes;
extern char *USETYPES;

void output(char *fmt, ...);
void output_line();
void output_rhs(char *identifier, struct rhs_s *rhs);
void incput(char *fmt, ...);
void create_vardefs();
void set_start(char *startstr);
void set_prefix(char *prefixstr);
void set_module(char *modulestr);
void add_rules(item_t *item, struct rhs_s *rhs);

#line 30 "parser.c"


#include <stdio.h>
#include <stdlib.h>
#include <stdarg.h>
#include <limits.h>
#include "parser.h"

int llcpos;
int *llstk;
unsigned llstksize;
unsigned llcstp = 1;
LLTERM *lltokens;
int llntokens;
char llerrormsg[256];
LLPOS llerrorpos;
int llepos;
LLSTYPE lllval;

int llterm(int token, LLSTYPE *lval, LLSTATE *llin, LLSTATE *llout);
void llfailed(LLPOS *pos, char *fmt, ...);
void llresizestk();
#define LLCHECKSTK do{if (llcstp + 1 >= llstksize) llresizestk();}while(/*CONSTCOND*/0)
#define LLFAILED(_err) do{llfailed _err; goto failed;}while(/*CONSTCOND*/0)
#define LLCUTOFF do{unsigned i; for (i = llstp; i < llcstp; i++) if (llstk[i] > 0) llstk[i] = -llstk[i];}while(/*CONSTCOND*/0)
#define LLCUTTHIS do{if (llstk[llstp] > 0) llstk[llstp] = -llstk[llstp];}while(/*CONSTCOND*/0)
#define LLCUTALL do{unsigned i; for (i = 0; i < llcstp; i++) if (llstk[i] > 0) llstk[i] = -llstk[i];}while(/*CONSTCOND*/0)

#if LLDEBUG > 0
int lldebug;
int last_linenr;
char *last_file = "";
#define LLDEBUG_ENTER(_ident) lldebug_enter(_ident)
#define LLDEBUG_LEAVE(_ident,_succ) lldebug_leave(_ident,_succ)
#define LLDEBUG_ALTERNATIVE(_ident,_alt) lldebug_alternative(_ident,_alt)
#define LLDEBUG_ITERATION(_ident,_num) lldebug_iteration(_ident,_num)
#define LLDEBUG_TOKEN(_exp,_pos) lldebug_token(_exp,_pos)
#define LLDEBUG_ANYTOKEN(_pos) lldebug_anytoken(_pos)
#define LLDEBUG_BACKTRACKING(_ident) lldebug_backtracking(_ident)
void lldebug_init();
void lldebug_enter(char *ident);
void lldebug_leave(char *ident, int succ);
void lldebug_alternative(char *ident, int alt);
void lldebug_token(int expected, unsigned pos);
void lldebug_anytoken(unsigned pos);
void lldebug_backtracking(char *ident);
void llprinttoken(LLTERM *token, char *identifier, FILE *f);
#else
#define LLDEBUG_ENTER(_ident)
#define LLDEBUG_LEAVE(_ident,_succ)
#define LLDEBUG_ALTERNATIVE(_ident,_alt)
#define LLDEBUG_ITERATION(_ident,_num)
#define LLDEBUG_TOKEN(_exp,_pos)
#define LLDEBUG_ANYTOKEN(_pos)
#define LLDEBUG_BACKTRACKING(_ident)
#endif

int ll_main(LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("main");

llstate_0 = *llin;
#undef failed
#define failed failed1
{LLSTATE llstate_1;
if (!ll_declsect(&llstate_0, &llstate_1)) goto failed1;
{LLSTATE llstate_2;
if (!llterm(PERCENT_PERCENT, (LLSTYPE *)0, &llstate_1, &llstate_2)) goto failed1;
{LLSTATE llstate_3;
if (!ll_rulesect(&llstate_2, &llstate_3)) goto failed1;
{LLSTATE llstate_4;
if (!llterm(PERCENT_PERCENT, (LLSTYPE *)0, &llstate_3, &llstate_4)) goto failed1;
{LLSTATE llstate_5;
if (!ll_csect(&llstate_4, &llstate_5)) goto failed1;
*llout = llstate_5;
}}}}}
LLDEBUG_LEAVE("main", 1);
return 1;
failed1: LLDEBUG_LEAVE("main", 0);
return 0;
}

int ll_declsect(LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("declsect");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("declsect", 1);
{LLSTATE llstate_1;
if (!ll_decl(&llstate_0, &llstate_1)) goto failed2;
{LLSTATE llstate_2;
if (!ll_declsect(&llstate_1, &llstate_2)) goto failed2;
*llout = llstate_2;
break;
}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("declsect", 2);
*llout = llstate_0;
#line 94 "parser.ll"
{create_vardefs(); 
#line 144 "parser.c"
break;
}
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("declsect");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("declsect", 1);
return 1;
failed1: LLDEBUG_LEAVE("declsect", 0);
return 0;
}

int ll_decl(LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("decl");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("decl", 1);
{LLSTATE llstate_1;
if (!llterm(PERCENT_TOKEN, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
{LLSTATE llstate_2;
if (!ll_tokens(&llstate_1, &llstate_2, NULL)) goto failed2;
*llout = llstate_2;
break;
}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("decl", 2);
{LLSTATE llstate_1;
if (!llterm(PERCENT_TOKEN, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
{LLSTATE llstate_2;string llatt_2;
if (!ll_tag(&llatt_2, &llstate_1, &llstate_2)) goto failed2;
{LLSTATE llstate_3;
if (!ll_tokens(&llstate_2, &llstate_3, llatt_2)) goto failed2;
*llout = llstate_3;
break;
}}}
case 3: case -3:
LLDEBUG_ALTERNATIVE("decl", 3);
{LLSTATE llstate_1;
if (!llterm(PERCENT_TYPE, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
{LLSTATE llstate_2;
if (!ll_nterms(&llstate_1, &llstate_2, NULL, 0)) goto failed2;
*llout = llstate_2;
break;
}}
case 4: case -4:
LLDEBUG_ALTERNATIVE("decl", 4);
{LLSTATE llstate_1;
if (!llterm(PERCENT_TYPE, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
{LLSTATE llstate_2;string llatt_2;
if (!ll_tag(&llatt_2, &llstate_1, &llstate_2)) goto failed2;
{LLSTATE llstate_3;
if (!ll_nterms(&llstate_2, &llstate_3, llatt_2, 0)) goto failed2;
*llout = llstate_3;
break;
}}}
case 5: case -5:
LLDEBUG_ALTERNATIVE("decl", 5);
{LLSTATE llstate_1;
if (!llterm(PERCENT_EXTERNAL, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
{LLSTATE llstate_2;
if (!ll_nterms(&llstate_1, &llstate_2, NULL, 1)) goto failed2;
*llout = llstate_2;
break;
}}
case 6: case -6:
LLDEBUG_ALTERNATIVE("decl", 6);
{LLSTATE llstate_1;
if (!llterm(PERCENT_EXTERNAL, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
{LLSTATE llstate_2;string llatt_2;
if (!ll_tag(&llatt_2, &llstate_1, &llstate_2)) goto failed2;
{LLSTATE llstate_3;
if (!ll_nterms(&llstate_2, &llstate_3, llatt_2, 1)) goto failed2;
*llout = llstate_3;
break;
}}}
case 7: case -7:
LLDEBUG_ALTERNATIVE("decl", 7);
{LLSTATE llstate_1;
if (!llterm(PERCENT_UNION, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
{LLSTATE llstate_2;
if (!llterm('{', (LLSTYPE *)0, &llstate_1, &llstate_2)) goto failed2;
{LLSTATE llstate_3;
if (!ll_union(&llstate_2, &llstate_3)) goto failed2;
{LLSTATE llstate_4;
if (!llterm('}', (LLSTYPE *)0, &llstate_3, &llstate_4)) goto failed2;
*llout = llstate_4;
#line 104 "parser.ll"
{output("\n"); 
#line 251 "parser.c"
break;
}}}}}
case 8: case -8:
LLDEBUG_ALTERNATIVE("decl", 8);
{LLSTATE llstate_1;
if (!llterm(PERCENT_STATE, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
{LLSTATE llstate_2;
if (!llterm('{', (LLSTYPE *)0, &llstate_1, &llstate_2)) goto failed2;
{LLSTATE llstate_3;
if (!ll_state(&llstate_2, &llstate_3)) goto failed2;
{LLSTATE llstate_4;
if (!llterm('}', (LLSTYPE *)0, &llstate_3, &llstate_4)) goto failed2;
*llout = llstate_4;
#line 106 "parser.ll"
{output("\n"); 
#line 267 "parser.c"
break;
}}}}}
case 9: case -9:
LLDEBUG_ALTERNATIVE("decl", 9);
{LLSTATE llstate_1;
if (!llterm(PERCENT_PREFIX, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
{LLSTATE llstate_2;string llatt_2;
if (!llterm(IDENTIFIER, &lllval, &llstate_1, &llstate_2)) goto failed2;
llatt_2 = lllval._string;
*llout = llstate_2;
#line 108 "parser.ll"
{set_prefix(llatt_2); 
#line 280 "parser.c"
break;
}}}
case 10: case -10:
LLDEBUG_ALTERNATIVE("decl", 10);
{LLSTATE llstate_1;
if (!llterm(PERCENT_MODULE, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
{LLSTATE llstate_2;string llatt_2;
if (!llterm(IDENTIFIER, &lllval, &llstate_1, &llstate_2)) goto failed2;
llatt_2 = lllval._string;
*llout = llstate_2;
#line 110 "parser.ll"
{set_module(llatt_2); 
#line 293 "parser.c"
break;
}}}
case 11: case -11:
LLDEBUG_ALTERNATIVE("decl", 11);
{LLSTATE llstate_1;
if (!llterm(PERCENT_LBRACE, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
{LLSTATE llstate_2;ccode llatt_2;
if (!llterm(CCODE, &lllval, &llstate_1, &llstate_2)) goto failed2;
llatt_2 = lllval._ccode;
{LLSTATE llstate_3;
if (!llterm(PERCENT_RBRACE, (LLSTYPE *)0, &llstate_2, &llstate_3)) goto failed2;
*llout = llstate_3;
#line 112 "parser.ll"
{if (linedirective)
			output("#line %d \"%s\"\n", llstate_2.pos.line, llstate_2.pos.file);
		    output("%s", llatt_2);
		    if (linedirective)
			output_line();
		
#line 313 "parser.c"
break;
}}}}
case 12: case -12:
LLDEBUG_ALTERNATIVE("decl", 12);
{LLSTATE llstate_1;
if (!llterm(PERCENT_START, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
{LLSTATE llstate_2;string llatt_2;
if (!llterm(IDENTIFIER, &lllval, &llstate_1, &llstate_2)) goto failed2;
llatt_2 = lllval._string;
*llout = llstate_2;
#line 119 "parser.ll"
{set_start(llatt_2); 
#line 326 "parser.c"
break;
}}}
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("decl");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("decl", 1);
return 1;
failed1: LLDEBUG_LEAVE("decl", 0);
return 0;
}

int ll_tokens(LLSTATE *llin, LLSTATE *llout, string llarg_tag)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("tokens");

llstate_0 = *llin;
#undef failed
#define failed failed1
{LLSTATE llstate_1;token llatt_1;
if (!ll_token(&llatt_1, &llstate_0, &llstate_1, llarg_tag)) goto failed1;
{LLSTATE llstate_2;
if (!ll_tokens2(&llstate_1, &llstate_2, llarg_tag)) goto failed1;
*llout = llstate_2;
#line 123 "parser.ll"
{create_symbol(0, 0, llarg_tag, llatt_1.identifier, llatt_1.altidentifier,
			NULL);
		
#line 363 "parser.c"
}}}
LLDEBUG_LEAVE("tokens", 1);
return 1;
failed1: LLDEBUG_LEAVE("tokens", 0);
return 0;
}

int ll_tokens2(LLSTATE *llin, LLSTATE *llout, string llarg_tag)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("tokens2");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("tokens2", 1);
{LLSTATE llstate_1;token llatt_1;
if (!ll_token(&llatt_1, &llstate_0, &llstate_1, llarg_tag)) goto failed2;
{LLSTATE llstate_2;
if (!ll_tokens2(&llstate_1, &llstate_2, llarg_tag)) goto failed2;
*llout = llstate_2;
#line 129 "parser.ll"
{create_symbol(0, 0, llarg_tag, llatt_1.identifier, llatt_1.altidentifier,
			NULL);
		
#line 397 "parser.c"
break;
}}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("tokens2", 2);
*llout = llstate_0;
break;
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("tokens2");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("tokens2", 1);
return 1;
failed1: LLDEBUG_LEAVE("tokens2", 0);
return 0;
}

int ll_token(token *llret, LLSTATE *llin, LLSTATE *llout, string llarg_tag)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("token");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("token", 1);
{LLSTATE llstate_1;string llatt_1;
if (!llterm(IDENTIFIER, &lllval, &llstate_0, &llstate_1)) goto failed2;
llatt_1 = lllval._string;
{LLSTATE llstate_2;
if (!llterm('=', (LLSTYPE *)0, &llstate_1, &llstate_2)) goto failed2;
{LLSTATE llstate_3;string llatt_3;
if (!llterm(IDENTIFIER, &lllval, &llstate_2, &llstate_3)) goto failed2;
llatt_3 = lllval._string;
*llout = llstate_3;
#line 136 "parser.ll"
{(*llret).identifier = llatt_1; (*llret).altidentifier = llatt_3; 
#line 448 "parser.c"
break;
}}}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("token", 2);
{LLSTATE llstate_1;string llatt_1;
if (!llterm(IDENTIFIER, &lllval, &llstate_0, &llstate_1)) goto failed2;
llatt_1 = lllval._string;
*llout = llstate_1;
#line 138 "parser.ll"
{(*llret).identifier = llatt_1; (*llret).altidentifier = NULL; 
#line 459 "parser.c"
break;
}}
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("token");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("token", 1);
return 1;
failed1: LLDEBUG_LEAVE("token", 0);
return 0;
}

int ll_nterms(LLSTATE *llin, LLSTATE *llout, string llarg_tag, integer llarg_ext)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("nterms");

llstate_0 = *llin;
#undef failed
#define failed failed1
{LLSTATE llstate_1;nterm llatt_1;
if (!ll_nterm(&llatt_1, &llstate_0, &llstate_1, llarg_tag)) goto failed1;
{LLSTATE llstate_2;
if (!ll_nterms2(&llstate_1, &llstate_2, llarg_tag, llarg_ext)) goto failed1;
*llout = llstate_2;
#line 142 "parser.ll"
{create_symbol(1, llarg_ext, llarg_tag, llatt_1.identifier, NULL, llatt_1.tags);
#line 494 "parser.c"
}}}
LLDEBUG_LEAVE("nterms", 1);
return 1;
failed1: LLDEBUG_LEAVE("nterms", 0);
return 0;
}

int ll_nterms2(LLSTATE *llin, LLSTATE *llout, string llarg_tag, integer llarg_ext)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("nterms2");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("nterms2", 1);
{LLSTATE llstate_1;nterm llatt_1;
if (!ll_nterm(&llatt_1, &llstate_0, &llstate_1, llarg_tag)) goto failed2;
{LLSTATE llstate_2;
if (!ll_nterms2(&llstate_1, &llstate_2, llarg_tag, llarg_ext)) goto failed2;
*llout = llstate_2;
#line 146 "parser.ll"
{create_symbol(1, llarg_ext, llarg_tag, llatt_1.identifier, NULL, llatt_1.tags);
#line 526 "parser.c"
break;
}}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("nterms2", 2);
*llout = llstate_0;
break;
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("nterms2");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("nterms2", 1);
return 1;
failed1: LLDEBUG_LEAVE("nterms2", 0);
return 0;
}

int ll_nterm(nterm *llret, LLSTATE *llin, LLSTATE *llout, string llarg_tag)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("nterm");

llstate_0 = *llin;
#undef failed
#define failed failed1
{LLSTATE llstate_1;string llatt_1;
if (!llterm(IDENTIFIER, &lllval, &llstate_0, &llstate_1)) goto failed1;
llatt_1 = lllval._string;
{LLSTATE llstate_2;strings llatt_2;
if (!ll_tags(&llatt_2, &llstate_1, &llstate_2)) goto failed1;
*llout = llstate_2;
#line 151 "parser.ll"
{(*llret).identifier = llatt_1; (*llret).tags = llatt_2; 
#line 566 "parser.c"
}}}
LLDEBUG_LEAVE("nterm", 1);
return 1;
failed1: LLDEBUG_LEAVE("nterm", 0);
return 0;
}

int ll_tags(strings *llret, LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("tags");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("tags", 1);
{LLSTATE llstate_1;string llatt_1;
if (!ll_tag(&llatt_1, &llstate_0, &llstate_1)) goto failed2;
{LLSTATE llstate_2;strings llatt_2;
if (!ll_tags(&llatt_2, &llstate_1, &llstate_2)) goto failed2;
*llout = llstate_2;
#line 155 "parser.ll"
{(*llret) = llatt_2;
		    memmove((*llret) + 1, (*llret),
			(MAXTAGS - 1) * sizeof(char *));
		    (*llret)[0] = llatt_1;
		
#line 602 "parser.c"
break;
}}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("tags", 2);
*llout = llstate_0;
#line 161 "parser.ll"
{(*llret) = (char **)malloc(MAXTAGS * sizeof(char *));
		    memset((*llret), 0, MAXTAGS * sizeof(char *));
		
#line 612 "parser.c"
break;
}
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("tags");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("tags", 1);
return 1;
failed1: LLDEBUG_LEAVE("tags", 0);
return 0;
}

int ll_tag(string *llret, LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("tag");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("tag", 1);
{LLSTATE llstate_1;
if (!llterm('<', (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
{LLSTATE llstate_2;string llatt_2;
if (!llterm(IDENTIFIER, &lllval, &llstate_1, &llstate_2)) goto failed2;
llatt_2 = lllval._string;
{LLSTATE llstate_3;
if (!llterm('>', (LLSTYPE *)0, &llstate_2, &llstate_3)) goto failed2;
*llout = llstate_3;
#line 167 "parser.ll"
{(*llret) = find_tag(llatt_2); 
#line 658 "parser.c"
break;
}}}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("tag", 2);
{LLSTATE llstate_1;
if (!llterm('<', (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
{LLSTATE llstate_2;
if (!llterm('>', (LLSTYPE *)0, &llstate_1, &llstate_2)) goto failed2;
*llout = llstate_2;
#line 169 "parser.ll"
{(*llret) = (char *)malloc(strlen(LL) + 6);
		    sprintf((*llret), "%sSTYPE", LL);
		
#line 672 "parser.c"
break;
}}}
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("tag");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("tag", 1);
return 1;
failed1: LLDEBUG_LEAVE("tag", 0);
return 0;
}

int ll_union(LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("union");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("union", 1);
{LLSTATE llstate_1;string llatt_1;
if (!llterm(TAGDEF, &lllval, &llstate_0, &llstate_1)) goto failed2;
llatt_1 = lllval._string;
{LLSTATE llstate_2;
if (!llterm(';', (LLSTYPE *)0, &llstate_1, &llstate_2)) goto failed2;
#line 175 "parser.ll"
{if (!usetypes) incput("typedef %s;\n", llatt_1); 
#line 715 "parser.c"
{LLSTATE llstate_3;
if (!ll_union(&llstate_2, &llstate_3)) goto failed2;
*llout = llstate_3;
break;
}}}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("union", 2);
*llout = llstate_0;
break;
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("union");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("union", 1);
return 1;
failed1: LLDEBUG_LEAVE("union", 0);
return 0;
}

int ll_state(LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("state");

llstate_0 = *llin;
#undef failed
#define failed failed1
#line 181 "parser.ll"
{if (usetypes) {
			incput("typedef %sPOS %sPOS;\n", USETYPES, LL);
			incput("typedef %sSTATE %sSTATE;\n", USETYPES, LL);
		    } else {
			incput("typedef struct %sPOS {\n", LL);
			incput("\tint line;\n");
			incput("\tint column;\n");
			incput("\tchar *file;\n");
			incput("} %sPOS;\n", LL);
			incput("typedef struct %sSTATE {\n", LL);
			incput("\t%sPOS pos;\n", LL);
		    }
		
#line 764 "parser.c"
{LLSTATE llstate_1;
if (!ll_state1(&llstate_0, &llstate_1)) goto failed1;
*llout = llstate_1;
#line 195 "parser.ll"
{if (!usetypes) incput("} %sSTATE;\n", LL); 
#line 770 "parser.c"
}}}
LLDEBUG_LEAVE("state", 1);
return 1;
failed1: LLDEBUG_LEAVE("state", 0);
return 0;
}

int ll_state1(LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("state1");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("state1", 1);
{LLSTATE llstate_1;string llatt_1;
if (!llterm(TAGDEF, &lllval, &llstate_0, &llstate_1)) goto failed2;
llatt_1 = lllval._string;
{LLSTATE llstate_2;
if (!llterm(';', (LLSTYPE *)0, &llstate_1, &llstate_2)) goto failed2;
#line 199 "parser.ll"
{if (!usetypes) incput("\t%s;\n", llatt_1); 
#line 802 "parser.c"
{LLSTATE llstate_3;
if (!ll_state1(&llstate_2, &llstate_3)) goto failed2;
*llout = llstate_3;
break;
}}}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("state1", 2);
*llout = llstate_0;
break;
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("state1");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("state1", 1);
return 1;
failed1: LLDEBUG_LEAVE("state1", 0);
return 0;
}

int ll_rulesect(LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("rulesect");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("rulesect", 1);
{LLSTATE llstate_1;
if (!ll_rule(&llstate_0, &llstate_1)) goto failed2;
{LLSTATE llstate_2;
if (!ll_rulesect(&llstate_1, &llstate_2)) goto failed2;
*llout = llstate_2;
break;
}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("rulesect", 2);
*llout = llstate_0;
break;
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("rulesect");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("rulesect", 1);
return 1;
failed1: LLDEBUG_LEAVE("rulesect", 0);
return 0;
}

int ll_rule(LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("rule");

llstate_0 = *llin;
#undef failed
#define failed failed1
{LLSTATE llstate_1;lhs llatt_1;
if (!ll_lhs(&llatt_1, &llstate_0, &llstate_1)) goto failed1;
{LLSTATE llstate_2;rhs llatt_2;
if (!ll_rhss(&llatt_2, &llstate_1, &llstate_2)) goto failed1;
{LLSTATE llstate_3;
if (!llterm(';', (LLSTYPE *)0, &llstate_2, &llstate_3)) goto failed1;
*llout = llstate_3;
#line 211 "parser.ll"
{item_t *item = find_symbol(llatt_1.identifier);
		    /* XXX check llatt_1.args against item */
		    if (!item)
			item = create_symbol(1, 0, NULL, llatt_1.identifier,
			    NULL, NULL);
		    if (item->tag) {
			if (llatt_1.args) {
			    output("int %s_%s(%s *%sret, %s%sSTATE *%sin, %sSTATE *%sout, %s)\n",
			    	ll, llatt_1.identifier, item->tag, ll, conststr, LL,
				ll, LL, ll, llatt_1.args);
			    incput("int %s_%s(%s *%sret, %s%sSTATE *%sin, %sSTATE *%sout, %s);\n",
			    	ll, llatt_1.identifier, item->tag, ll, conststr, LL,
				ll, LL, ll, llatt_1.args);
			} else {
			    output("int %s_%s(%s *%sret, %s%sSTATE *%sin, %sSTATE *%sout)\n",
			    	ll, llatt_1.identifier, item->tag, ll, conststr, LL,
				ll, LL, ll);
			    incput("int %s_%s(%s *%sret, %s%sSTATE *%sin, %sSTATE *%sout);\n",
			    	ll, llatt_1.identifier, item->tag, ll, conststr, LL,
				ll, LL, ll);
			}
		    } else {
			if (llatt_1.args) {
			    output("int %s_%s(%s%sSTATE *%sin, %sSTATE *%sout, %s)\n",
			    	ll, llatt_1.identifier, conststr, LL,
				ll, LL, ll, llatt_1.args);
			    incput("int %s_%s(%s%sSTATE *%sin, %sSTATE *%sout, %s);\n",
			    	ll, llatt_1.identifier, conststr, LL,
				ll, LL, ll, llatt_1.args);
			} else {
			    output("int %s_%s(%s%sSTATE *%sin, %sSTATE *%sout)\n",
			    	ll, llatt_1.identifier, conststr, LL,
				ll, LL, ll);
			    incput("int %s_%s(%s%sSTATE *%sin, %sSTATE *%sout);\n",
			    	ll, llatt_1.identifier, conststr, LL,
				ll, LL, ll);
			}
		    }
		    output("{\n");
		    output("unsigned %sstp = %scstp;\n", ll, ll);
		    output_rhs(llatt_1.identifier, llatt_2);
		    output("}\n");
		    output("\n");
		    add_rules(item, llatt_2);
		
#line 934 "parser.c"
}}}}
LLDEBUG_LEAVE("rule", 1);
return 1;
failed1: LLDEBUG_LEAVE("rule", 0);
return 0;
}

int ll_lhs(lhs *llret, LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("lhs");

llstate_0 = *llin;
#undef failed
#define failed failed1
{LLSTATE llstate_1;string llatt_1;
if (!llterm(IDENTIFIER, &lllval, &llstate_0, &llstate_1)) goto failed1;
llatt_1 = lllval._string;
{LLSTATE llstate_2;string llatt_2;
if (!ll_lhsargs(&llatt_2, &llstate_1, &llstate_2, llatt_1)) goto failed1;
{LLSTATE llstate_3;
if (!llterm(':', (LLSTYPE *)0, &llstate_2, &llstate_3)) goto failed1;
*llout = llstate_3;
#line 259 "parser.ll"
{(*llret).identifier = llatt_1; (*llret).args = llatt_2; 
#line 961 "parser.c"
}}}}
LLDEBUG_LEAVE("lhs", 1);
return 1;
failed1: LLDEBUG_LEAVE("lhs", 0);
return 0;
}

int ll_rhss(rhs *llret, LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("rhss");

llstate_0 = *llin;
#undef failed
#define failed failed1
{LLSTATE llstate_1;rhs llatt_1;
if (!ll_items(&llatt_1, &llstate_0, &llstate_1)) goto failed1;
{LLSTATE llstate_2;rhs llatt_2;
if (!ll_rhss2(&llatt_2, &llstate_1, &llstate_2)) goto failed1;
*llout = llstate_2;
#line 263 "parser.ll"
{(*llret) = (struct rhs_s *)malloc(sizeof(struct rhs_s));
		    (*llret)->type = eAlternative;
		    (*llret)->u.alternative.element = llatt_1;
		    (*llret)->u.alternative.next = llatt_2;
		
#line 989 "parser.c"
}}}
LLDEBUG_LEAVE("rhss", 1);
return 1;
failed1: LLDEBUG_LEAVE("rhss", 0);
return 0;
}

int ll_rhss2(rhs *llret, LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("rhss2");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("rhss2", 1);
{LLSTATE llstate_1;
if (!llterm('|', (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
{LLSTATE llstate_2;rhs llatt_2;
if (!ll_items(&llatt_2, &llstate_1, &llstate_2)) goto failed2;
{LLSTATE llstate_3;rhs llatt_3;
if (!ll_rhss2(&llatt_3, &llstate_2, &llstate_3)) goto failed2;
*llout = llstate_3;
#line 271 "parser.ll"
{(*llret) = (struct rhs_s *)malloc(sizeof(struct rhs_s));
		    (*llret)->type = eAlternative;
		    (*llret)->u.alternative.element = llatt_2;
		    (*llret)->u.alternative.next = llatt_3;
		
#line 1027 "parser.c"
break;
}}}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("rhss2", 2);
*llout = llstate_0;
#line 277 "parser.ll"
{(*llret) = NULL; 
#line 1035 "parser.c"
break;
}
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("rhss2");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("rhss2", 1);
return 1;
failed1: LLDEBUG_LEAVE("rhss2", 0);
return 0;
}

int ll_items(rhs *llret, LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("items");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("items", 1);
{LLSTATE llstate_1;rhs llatt_1;
if (!ll_item(&llatt_1, &llstate_0, &llstate_1)) goto failed2;
{LLSTATE llstate_2;bounds llatt_2;
if (!ll_extension(&llatt_2, &llstate_1, &llstate_2)) goto failed2;
{LLSTATE llstate_3;rhs llatt_3;
if (!ll_items(&llatt_3, &llstate_2, &llstate_3)) goto failed2;
*llout = llstate_3;
#line 281 "parser.ll"
{(*llret) = (struct rhs_s *)malloc(sizeof(struct rhs_s));
		    (*llret)->type = eSequence;
		    if (llatt_2.lower != 1 || llatt_2.upper != 1) {
			(*llret)->u.sequence.element =
			    (struct rhs_s *)malloc(sizeof(struct rhs_s));
			(*llret)->u.sequence.element->type = eBounded;
			(*llret)->u.sequence.element->u.bounded.items = llatt_1;
			(*llret)->u.sequence.element->u.bounded.bounds = llatt_2;
		    } else {
			(*llret)->u.sequence.element = llatt_1;
		    }
		    (*llret)->u.sequence.next = llatt_3;
		
#line 1092 "parser.c"
break;
}}}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("items", 2);
*llout = llstate_0;
#line 295 "parser.ll"
{(*llret) = NULL; 
#line 1100 "parser.c"
break;
}
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("items");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("items", 1);
return 1;
failed1: LLDEBUG_LEAVE("items", 0);
return 0;
}

int ll_item(rhs *llret, LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("item");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("item", 1);
{LLSTATE llstate_1;string llatt_1;
if (!llterm(IDENTIFIER, &lllval, &llstate_0, &llstate_1)) goto failed2;
llatt_1 = lllval._string;
{LLSTATE llstate_2;string llatt_2;
if (!ll_args(&llatt_2, &llstate_1, &llstate_2)) goto failed2;
*llout = llstate_2;
#line 299 "parser.ll"
{(*llret) = (struct rhs_s *)malloc(sizeof(struct rhs_s));
		    (*llret)->type = eItem;
		    (*llret)->u.item.identifier = llatt_1;
		    (*llret)->u.item.args = llatt_2;
		
#line 1148 "parser.c"
break;
}}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("item", 2);
{LLSTATE llstate_1;
if (!llterm('[', (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
{LLSTATE llstate_2;rhs llatt_2;
if (!ll_rhss(&llatt_2, &llstate_1, &llstate_2)) goto failed2;
{LLSTATE llstate_3;
if (!llterm(']', (LLSTYPE *)0, &llstate_2, &llstate_3)) goto failed2;
*llout = llstate_3;
#line 305 "parser.ll"
{(*llret) = llatt_2;
		
#line 1163 "parser.c"
break;
}}}}
case 3: case -3:
LLDEBUG_ALTERNATIVE("item", 3);
{LLSTATE llstate_1;
if (!llterm('[', (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
{LLSTATE llstate_2;rhs llatt_2;
if (!ll_rhss(&llatt_2, &llstate_1, &llstate_2)) goto failed2;
{LLSTATE llstate_3;
if (!llterm(':', (LLSTYPE *)0, &llstate_2, &llstate_3)) goto failed2;
{LLSTATE llstate_4;rhs llatt_4;
if (!ll_rhss(&llatt_4, &llstate_3, &llstate_4)) goto failed2;
{LLSTATE llstate_5;
if (!llterm(']', (LLSTYPE *)0, &llstate_4, &llstate_5)) goto failed2;
*llout = llstate_5;
#line 308 "parser.ll"
{(*llret) = (struct rhs_s *)malloc(sizeof(struct rhs_s));
		    (*llret)->type = eNode;
		    (*llret)->u.node.left = llatt_2;
		    (*llret)->u.node.right = llatt_4;
		
#line 1185 "parser.c"
break;
}}}}}}
case 4: case -4:
LLDEBUG_ALTERNATIVE("item", 4);
{LLSTATE llstate_1;
if (!llterm('{', (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
{LLSTATE llstate_2;ccode llatt_2;
if (!llterm(CCODE, &lllval, &llstate_1, &llstate_2)) goto failed2;
llatt_2 = lllval._ccode;
{LLSTATE llstate_3;
if (!llterm('}', (LLSTYPE *)0, &llstate_2, &llstate_3)) goto failed2;
*llout = llstate_3;
#line 314 "parser.ll"
{(*llret) = (struct rhs_s *)malloc(sizeof(struct rhs_s));
		    (*llret)->type = eCCode;
		    (*llret)->u.ccode.ccode = llatt_2;
		    (*llret)->u.ccode.line = llstate_2.pos.line;
		    (*llret)->u.ccode.column = llstate_2.pos.column;
		    (*llret)->u.ccode.file = llstate_2.pos.file;
		
#line 1206 "parser.c"
break;
}}}}
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("item");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("item", 1);
return 1;
failed1: LLDEBUG_LEAVE("item", 0);
return 0;
}

int ll_extension(bounds *llret, LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("extension");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("extension", 1);
{LLSTATE llstate_1;
if (!llterm('+', (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
#line 324 "parser.ll"
{(*llret).lower = 1;
		    (*llret).upper = 0;
		
#line 1249 "parser.c"
break;
}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("extension", 2);
{LLSTATE llstate_1;
if (!llterm('*', (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
#line 328 "parser.ll"
{(*llret).lower = 0;
		    (*llret).upper = 0;
		
#line 1261 "parser.c"
break;
}}
case 3: case -3:
LLDEBUG_ALTERNATIVE("extension", 3);
{LLSTATE llstate_1;
if (!llterm('?', (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
#line 332 "parser.ll"
{(*llret).lower = 0;
		    (*llret).upper = 1;
		
#line 1273 "parser.c"
break;
}}
case 4: case -4:
LLDEBUG_ALTERNATIVE("extension", 4);
*llout = llstate_0;
#line 336 "parser.ll"
{(*llret).lower = 1;
		    (*llret).upper = 1;
		
#line 1283 "parser.c"
break;
}
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("extension");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("extension", 1);
return 1;
failed1: LLDEBUG_LEAVE("extension", 0);
return 0;
}

int ll_lhsargs(string *llret, LLSTATE *llin, LLSTATE *llout, string llarg_ide)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("lhsargs");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("lhsargs", 1);
{LLSTATE llstate_1;
if (!llterm('(', (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
#line 342 "parser.ll"
{item_t *item;
		    item = find_symbol(llarg_ide);
		    if (!item || !item->args || !*item->args) {
			fprintf(stderr,
			    "%s has not been declared to have arguments\n",
			    llarg_ide);
			exit(1);
		    }
		
#line 1331 "parser.c"
{LLSTATE llstate_2;string llatt_2;
if (!ll_lhsarglist(&llatt_2, &llstate_1, &llstate_2, item->args, llarg_ide)) goto failed2;
{LLSTATE llstate_3;
if (!llterm(')', (LLSTYPE *)0, &llstate_2, &llstate_3)) goto failed2;
*llout = llstate_3;
#line 352 "parser.ll"
{(*llret) = llatt_2; 
#line 1339 "parser.c"
break;
}}}}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("lhsargs", 2);
*llout = llstate_0;
#line 354 "parser.ll"
{item_t *item;
		    item = find_symbol(llarg_ide);
		    if (item && item->args && *item->args) {
			fprintf(stderr,
			    "%s has not been declared to have no arguments\n",
			    llarg_ide);
			exit(1);
		    }
		    (*llret) = NULL;
		
#line 1356 "parser.c"
break;
}
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("lhsargs");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("lhsargs", 1);
return 1;
failed1: LLDEBUG_LEAVE("lhsargs", 0);
return 0;
}

int ll_lhsarglist(string *llret, LLSTATE *llin, LLSTATE *llout, strings llarg_tags, string llarg_ide)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("lhsarglist");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("lhsarglist", 1);
{LLSTATE llstate_1;string llatt_1;
if (!llterm(ARG, &lllval, &llstate_0, &llstate_1)) goto failed2;
llatt_1 = lllval._string;
{LLSTATE llstate_2;
if (!llterm(',', (LLSTYPE *)0, &llstate_1, &llstate_2)) goto failed2;
{LLSTATE llstate_3;string llatt_3;
if (!ll_lhsarglist(&llatt_3, &llstate_2, &llstate_3, llarg_tags+1, llarg_ide)) goto failed2;
*llout = llstate_3;
#line 367 "parser.ll"
{if (!*llarg_tags) {
			fprintf(stderr,
			    "%s has not been declared to have so much arguments\n",
			    llarg_ide);
			exit(1);
		    }
		    (*llret) = (char *)malloc(strlen(llatt_1) + strlen(llatt_3) +
			strlen(*llarg_tags) + strlen(conststr) + 10);
		    sprintf((*llret), "%s%s %sarg_%s, %s",
			conststr, *llarg_tags, ll, llatt_1, llatt_3);
		
#line 1412 "parser.c"
break;
}}}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("lhsarglist", 2);
{LLSTATE llstate_1;string llatt_1;
if (!llterm(ARG, &lllval, &llstate_0, &llstate_1)) goto failed2;
llatt_1 = lllval._string;
*llout = llstate_1;
#line 379 "parser.ll"
{if (!*llarg_tags) {
			fprintf(stderr,
			    "%s has not been declared to have so much arguments\n",
			    llarg_ide);
			exit(1);
		    }
		    if (llarg_tags[1]) {
			fprintf(stderr,
			    "%s has not been declared to have so less arguments\n",
			    llarg_ide);
			exit(1);
		    }
		    (*llret) = (char *)malloc(strlen(llatt_1) + strlen(*llarg_tags) +
		    	strlen(conststr) + 8);
		    sprintf((*llret), "%s%s %sarg_%s", conststr, *llarg_tags, ll, llatt_1);
		
#line 1438 "parser.c"
break;
}}
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("lhsarglist");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("lhsarglist", 1);
return 1;
failed1: LLDEBUG_LEAVE("lhsarglist", 0);
return 0;
}

int ll_args(string *llret, LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("args");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("args", 1);
{LLSTATE llstate_1;
if (!llterm('(', (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
{LLSTATE llstate_2;string llatt_2;
if (!ll_arglist(&llatt_2, &llstate_1, &llstate_2)) goto failed2;
{LLSTATE llstate_3;
if (!llterm(')', (LLSTYPE *)0, &llstate_2, &llstate_3)) goto failed2;
*llout = llstate_3;
#line 398 "parser.ll"
{(*llret) = llatt_2; 
#line 1483 "parser.c"
break;
}}}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("args", 2);
*llout = llstate_0;
#line 400 "parser.ll"
{(*llret) = ""; 
#line 1491 "parser.c"
break;
}
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("args");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("args", 1);
return 1;
failed1: LLDEBUG_LEAVE("args", 0);
return 0;
}

int ll_arglist(string *llret, LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("arglist");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("arglist", 1);
{LLSTATE llstate_1;string llatt_1;
if (!llterm(ARG, &lllval, &llstate_0, &llstate_1)) goto failed2;
llatt_1 = lllval._string;
{LLSTATE llstate_2;
if (!llterm(',', (LLSTYPE *)0, &llstate_1, &llstate_2)) goto failed2;
{LLSTATE llstate_3;string llatt_3;
if (!ll_arglist(&llatt_3, &llstate_2, &llstate_3)) goto failed2;
*llout = llstate_3;
#line 404 "parser.ll"
{char *p = convert(llatt_1);
		    (*llret) = (char *)malloc(strlen(p) + strlen(llatt_3) + 3);
		    strcpy((*llret), p);
		    strcat((*llret), ", ");
		    strcat((*llret), llatt_3);
		
#line 1542 "parser.c"
break;
}}}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("arglist", 2);
{LLSTATE llstate_1;string llatt_1;
if (!llterm(ARG, &lllval, &llstate_0, &llstate_1)) goto failed2;
llatt_1 = lllval._string;
*llout = llstate_1;
#line 411 "parser.ll"
{(*llret) = convert(llatt_1); 
#line 1553 "parser.c"
break;
}}
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("arglist");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("arglist", 1);
return 1;
failed1: LLDEBUG_LEAVE("arglist", 0);
return 0;
}

int ll_csect(LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("csect");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("csect", 1);
{LLSTATE llstate_1;ccode llatt_1;
if (!llterm(CCODE, &lllval, &llstate_0, &llstate_1)) goto failed2;
llatt_1 = lllval._ccode;
*llout = llstate_1;
#line 417 "parser.ll"
{if (linedirective)
			output("#line %d \"%s\"\n", llstate_1.pos.line, llstate_1.pos.file);
		    output("%s\n", llatt_1);
		    if (linedirective)
			output_line();
		
#line 1600 "parser.c"
break;
}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("csect", 2);
*llout = llstate_0;
break;
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("csect");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("csect", 1);
return 1;
failed1: LLDEBUG_LEAVE("csect", 0);
return 0;
}

#line 426 "parser.ll"

#line 1625 "parser.c"
int
llparser(LLTERM *tokens, unsigned ntokens, LLSTATE *llin, LLSTATE *llout)
{
unsigned i;
LLDEBUG_ENTER("llparser");
lltokens = tokens; llntokens = ntokens;
for (i = 0; i < llstksize; i++) llstk[i] = 1;
llcstp = 1; llcpos = 0; llepos = 0; *llerrormsg = 0;
#if LLDEBUG > 0
last_linenr = 0; last_file = "";
#endif
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
if (!ll_main(llin, llout)) goto failed2;
if (llcpos != llntokens) goto failed2;
break;
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("llparser");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("llparser", 1);
return 1;
failed1:
LLDEBUG_LEAVE("llparser", 0);
return 0;
}

int
llterm(int token, LLSTYPE *lval, LLSTATE *llin, LLSTATE *llout)
{
#if LLDEBUG > 0
	if (lldebug > 0 && (lltokens[llcpos].pos.line > last_linenr || strcmp(lltokens[llcpos].pos.file, last_file))) {
	fprintf(stderr, "File \"%s\", Line %5d                    \r",
		lltokens[llcpos].pos.file, lltokens[llcpos].pos.line);
	last_linenr = lltokens[llcpos].pos.line / 10 * 10 + 9;
	last_file = lltokens[llcpos].pos.file;
	}
#endif
	if (llstk[llcstp] != 1 && llstk[llcstp] != -1) {
		LLDEBUG_BACKTRACKING("llterm");
		llstk[llcstp] = 1;
		return 0;
	}
	LLDEBUG_TOKEN(token, llcpos);
	if (llcpos < llntokens && lltokens[llcpos].token == token) {
		if (lval)
			*lval = lltokens[llcpos].lval;
		*llout = *llin;
		llout->pos = lltokens[llcpos].pos;
		llcpos++;
		LLCHECKSTK;
		llcstp++;
		return 1;
	}
	llfailed(&lltokens[llcpos].pos, NULL);
	llstk[llcstp] = 1;
	return 0;
}

int
llanyterm(LLSTYPE *lval, LLSTATE *llin, LLSTATE *llout)
{
#if LLDEBUG > 0
	if (lldebug > 0 && (lltokens[llcpos].pos.line > last_linenr || strcmp(lltokens[llcpos].pos.file, last_file))) {
	fprintf(stderr, "File \"%s\", Line %5d                    \r",
		lltokens[llcpos].pos.file, lltokens[llcpos].pos.line);
	last_linenr = lltokens[llcpos].pos.line / 10 * 10 + 9;
	last_file = lltokens[llcpos].pos.file;
	}
#endif
	if (llstk[llcstp] != 1 && llstk[llcstp] != -1) {
		LLDEBUG_BACKTRACKING("llanyterm");
		llstk[llcstp] = 1;
		return 0;
	}
	LLDEBUG_ANYTOKEN(llcpos);
	if (llcpos < llntokens) {
		if (lval)
			*lval = lltokens[llcpos].lval;
		*llout = *llin;
		llout->pos = lltokens[llcpos].pos;
		llcpos++;
		LLCHECKSTK;
		llcstp++;
		return 1;
	}
	llfailed(&lltokens[llcpos].pos, NULL);
	llstk[llcstp] = 1;
	return 0;
}
void
llscanner(LLTERM **tokens, unsigned *ntokens)
{
	unsigned i = 0;
#if LLDEBUG > 0
	int line = -1;
#endif

	*ntokens = 1024;
	*tokens = (LLTERM *)malloc(*ntokens * sizeof(LLTERM));
	while (llgettoken(&(*tokens)[i].token, &(*tokens)[i].lval, &(*tokens)[i].pos)) {
#if LLDEBUG > 0
		if (lldebug > 0 && (*tokens)[i].pos.line > line) {
			line = (*tokens)[i].pos.line / 10 * 10 + 9;
			fprintf(stderr, "File \"%s\", Line %5d                    \r",
				(*tokens)[i].pos.file, (*tokens)[i].pos.line);
		}
#endif
		if (++i >= *ntokens) {
			*ntokens *= 2;
			*tokens = (LLTERM *)realloc(*tokens, *ntokens * sizeof(LLTERM));
		}
	}
	(*tokens)[i].token = 0;
	*ntokens = i;
#if LLDEBUG > 0
	lldebug_init();
#endif
	llresizestk();
}

void
llfailed(LLPOS *pos, char *fmt, ...)
{
	va_list args;

	va_start(args, fmt);
	if (llcpos > llepos || llcpos == llepos && !*llerrormsg) {
		llepos = llcpos;
		if (fmt)
			vsprintf(llerrormsg, fmt, args);
		else
			*llerrormsg = 0;
		llerrorpos = *pos;
	}
	va_end(args);
}

void
llprinterror(FILE *f)
{
#if LLDEBUG > 0
	fputs("                                \r", stderr);
#endif
	if (*llerrormsg)
		llerror(f, &llerrorpos, llerrormsg);
	else
		llerror(f, &llerrorpos, "Syntax error");
}

void
llerror(FILE *f, LLPOS *pos, char *fmt, ...)
{
	va_list args;
	va_start(args, fmt);
	llverror(f, pos, fmt, args);
	va_end(args);
}

void
llresizestk()
{
	unsigned i;

	if (llcstp + 1 >= llstksize) {
		i = llstksize;
		if (!llstksize)
			llstk = (int *)malloc((llstksize = 4096) * sizeof(int));
		else
			llstk = (int *)realloc(llstk, (llstksize *= 2) * sizeof(int));
		for (; i < llstksize; i++)
			llstk[i] = 1;
	}
}

#if LLDEBUG > 0
int lldepth;
char *lltokentab[] = {
"EOF","#1","#2","#3","#4","#5","#6","#7"
,"#8","#9","#10","#11","#12","#13","#14","#15"
,"#16","#17","#18","#19","#20","#21","#22","#23"
,"#24","#25","#26","#27","#28","#29","#30","#31"
,"' '","'!'","'\"'","'#'","'$'","'%'","'&'","'''"
,"'('","')'","'*'","'+'","','","'-'","'.'","'/'"
,"'0'","'1'","'2'","'3'","'4'","'5'","'6'","'7'"
,"'8'","'9'","':'","';'","'<'","'='","'>'","'?'"
,"'@'","'A'","'B'","'C'","'D'","'E'","'F'","'G'"
,"'H'","'I'","'J'","'K'","'L'","'M'","'N'","'O'"
,"'P'","'Q'","'R'","'S'","'T'","'U'","'V'","'W'"
,"'X'","'Y'","'Z'","'['","'\\'","']'","'^'","'_'"
,"'`'","'a'","'b'","'c'","'d'","'e'","'f'","'g'"
,"'h'","'i'","'j'","'k'","'l'","'m'","'n'","'o'"
,"'p'","'q'","'r'","'s'","'t'","'u'","'v'","'w'"
,"'x'","'y'","'z'","'{'","'|'","'}'","'~'","#127"
,"#128","#129","#130","#131","#132","#133","#134","#135"
,"#136","#137","#138","#139","#140","#141","#142","#143"
,"#144","#145","#146","#147","#148","#149","#150","#151"
,"#152","#153","#154","#155","#156","#157","#158","#159"
,"#160","#161","#162","#163","#164","#165","#166","#167"
,"#168","#169","#170","#171","#172","#173","#174","#175"
,"#176","#177","#178","#179","#180","#181","#182","#183"
,"#184","#185","#186","#187","#188","#189","#190","#191"
,"#192","#193","#194","#195","#196","#197","#198","#199"
,"#200","#201","#202","#203","#204","#205","#206","#207"
,"#208","#209","#210","#211","#212","#213","#214","#215"
,"#216","#217","#218","#219","#220","#221","#222","#223"
,"#224","#225","#226","#227","#228","#229","#230","#231"
,"#232","#233","#234","#235","#236","#237","#238","#239"
,"#240","#241","#242","#243","#244","#245","#246","#247"
,"#248","#249","#250","#251","#252","#253","#254","#255"
,"#256","IDENTIFIER","ARG","CCODE","TAGDEF","PERCENT_PERCENT","PERCENT_TOKEN","PERCENT_TYPE"
,"PERCENT_EXTERNAL","PERCENT_UNION","PERCENT_STATE","PERCENT_START","PERCENT_PREFIX","PERCENT_MODULE","PERCENT_LBRACE","PERCENT_RBRACE"
};

void
lldebug_init()
{
	char *p;
	p = getenv("LLDEBUG");
	if (p)
		lldebug = atoi(p);
}

void
lldebug_enter(char *ident)
{
	int i;

	if (lldebug < 2)
		return;
	for (i = 0; i < lldepth; i++)
		fputs("| ", stdout);
	printf("/--- trying rule %s\n", ident);
	lldepth++;
}

void
lldebug_leave(char *ident, int succ)
{
	int i;

	if (lldebug < 2)
		return;
	lldepth--;
	for (i = 0; i < lldepth; i++)
		fputs("| ", stdout);
	if (succ)
		printf("\\--- succeeded to apply rule %s\n", ident);
	else
		printf("\\--- failed to apply rule %s\n", ident);
}

void
lldebug_alternative(char *ident, int alt)
{
	int i;

	if (lldebug < 2)
		return;
	for (i = 0; i < lldepth - 1; i++)
		fputs("| ", stdout);
	printf(">--- trying alternative %d for rule %s\n", alt, ident);
}

lldebug_iteration(char *ident, int num)
{
	int i;

	if (lldebug < 2)
		return;
	for (i = 0; i < lldepth - 1; i++)
		fputs("| ", stdout);
	printf(">--- trying iteration %d for rule %s\n", num, ident);
}

void
lldebug_token(int expected, unsigned pos)
{
	int i;

	if (lldebug < 2)
		return;
	for (i = 0; i < lldepth; i++)
		fputs("| ", stdout);
	if (pos < llntokens && expected == lltokens[pos].token)
		printf("   found token ");
	else
		printf("   expected token %s, found token ", lltokentab[expected]);
	if (pos >= llntokens)
		printf("<EOF>");
	else
		llprinttoken(lltokens + pos, lltokentab[lltokens[pos].token], stdout);
	putchar('\n');
}

void
lldebug_anytoken(unsigned pos)
{
	int i;

	if (lldebug < 2)
		return;
	for (i = 0; i < lldepth; i++)
		fputs("| ", stdout);
	printf("   found token ");
	if (pos >= llntokens)
		printf("<EOF>");
	else
		llprinttoken(lltokens + pos, lltokentab[lltokens[pos].token], stdout);
	putchar('\n');
}

void
lldebug_backtracking(char *ident)
{
	int i;

	if (lldebug < 2)
		return;
	for (i = 0; i < lldepth; i++)
		fputs("| ", stdout);
	printf("   backtracking rule %s\n", ident);
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\asn1\asn1all\scanner.c ===
/* Copyright (C) Boris Nikolaus, Germany, 1996-1997. All rights reserved. */

#include <stdio.h>
#include <ctype.h>
#include <stdlib.h>
#include <stdarg.h>
#include <string.h>
#include "defs.h"
#include "parser.h"

#define IS_IDENT(c) (isalpha(c) || c == '_' || c == '\'' || c == '\"')

#ifdef YYDEBUG
extern int yydebug;
#endif

enum {
    DeclSection,
    Union,
    Union1,
    State,
    State1,
    CCode,
    RuleSection,
    Arg,
    Action,
    CSection,
    End
} state;

int bufferpos;
char *buffer = 0;
int buffersize = 0;

char *line = 0;
int linesize = 0;
int linelen = 0;
char *cptr;
int meteof = 0;
int lineno;
char filename[256];
FILE *fin;

void error(LLPOS *pos, char *fmt, ...);

void
addchar(char c)
{
    if (bufferpos >= buffersize) {
    if (!buffersize) {
        buffersize = 4096;
        buffer = (char *)malloc(buffersize);
    } else {
        buffersize <<= 1;
        buffer = (char *)realloc(buffer, buffersize);
    }
    if (!buffer)
        error(NULL, "Out of memory");
    }
    buffer[bufferpos++] = c;
}

void
memmove_fwd(char *dst, char *src, int len)
{
    while (len--)
    *dst++ = *src++;
}

int
read_line()
{
    int nread;
    int left;

    if (!linesize) {
    linesize = 4096;
    cptr = line = (char *)malloc(linesize);
    linelen = 0;
    }
    if (!linelen && meteof)
    return 0;
    if (linelen && (cptr <= line || cptr > line + linelen || cptr[-1] != '\n'))
    abort();
    left = linelen - (int)(cptr - line);
    if (left && memchr(cptr, '\n', left))
    return 1;
    linelen = left;
    if (left)
    memmove_fwd(line, cptr, left);
    cptr = line;
    while ((!linelen || !memchr(line, '\n', linelen)) && !meteof) {
    if (linesize - linelen < 2048) {
        linesize <<= 1;
        line = (char *)realloc(line, linesize);
        cptr = line;
    }
    nread = fread(line + linelen, 1, linesize - linelen, fin);
    if (nread < linesize - linelen)
        meteof = 1;
    linelen += nread;
    }
    return linelen > 0;
}

int
get_line()
{
    int depth = 0;
    char *p;

    for (;;) {
    if (!read_line())
        return 0;
    if (!strncmp(cptr, "#line ", 6)) {
        lineno = strtol(cptr + 6, &cptr, 10) - 1;
        while (isspace(*cptr) && *cptr != '\n')
            cptr++;
        if (*cptr == '\"') {
            cptr++;
            for (p = filename; *cptr != '\n' && *cptr != '\"';) {
            *p++ = *cptr++;
        }
        *p = 0;
        }
        cptr = strchr(cptr, '\n') + 1;
        continue;
    }
    lineno++;
    if (!strncmp(cptr, "%comment", 8)) {
        cptr = strchr(cptr, '\n') + 1;
        depth++;
        continue;
    }
    if (!strncmp(cptr, "%endcomment", 11)) {
        cptr = strchr(cptr, '\n') + 1;
        depth--;
        continue;
    }
    if (!depth)
        return 1;
    cptr = strchr(cptr, '\n') + 1;
    }
}

int
read_char()
{
    for (;;) {
    if (!cptr) {
        if (!get_line())
        return EOF;
        continue;
    }
    if (*cptr == '\n') {
        cptr++;
        if (!get_line())
        return EOF;
        continue;
    }
    if (isspace(*cptr)) {
        cptr++;
        continue;
    }
    if (*cptr == '/' && cptr[1] == '/') {
        cptr = strchr(cptr, '\n') + 1;
        continue;
    }
    if (*cptr == '/' && cptr[1] == '*') {
        cptr += 2;
        do {
        while (*cptr != '*') {
            if (*cptr++ == '\n') {
            if (!get_line())
                error(NULL, "Unexpected EOF");
            }
        }
        } while (*++cptr != '/');
        cptr++;
        continue;
    }
    break;
    }
    return *cptr;
}

void
get_identifier(LLPOS *pos)
{
    int quote;

    bufferpos = 0;
    addchar(*cptr);
    if (*cptr == '\'' || *cptr == '\"') {
    quote = *cptr++;
    while (*cptr != quote) {
        if (*cptr == '\n')
        error(pos, "Missing closing quote");
        addchar(*cptr);
        if (*cptr++ == '\\')
        addchar(*cptr++);
    }
    addchar(*cptr++);
    } else {
    cptr++;
    while (isalnum(*cptr) || *cptr == '_')
        addchar(*cptr++);
    }
    addchar(0);
}

int
get_token(LLSTYPE *lval, LLPOS *pos)
{
    int c;
    int depth;

    c = read_char();
    pos->line = lineno;
    pos->column = cptr ? (int)(cptr - line) - 1 : 0;
    pos->file = strdup(filename);

    switch (state) {
    case DeclSection:
    if (!strncmp(cptr, "%%", 2)) {
        state = RuleSection;
        cptr += 2;
        return PERCENT_PERCENT;
    }
    if (!strncmp(cptr, "%token", 6)) {
        cptr += 6;
        return PERCENT_TOKEN;
    }
    if (!strncmp(cptr, "%type", 5)) {
        cptr += 5;
        return PERCENT_TYPE;
    }
    if (!strncmp(cptr, "%external", 9)) {
        cptr += 9;
        return PERCENT_EXTERNAL;
    }
    if (!strncmp(cptr, "%start", 6)) {
        cptr += 6;
        return PERCENT_START;
    }
    if (!strncmp(cptr, "%union", 6)) {
        state = Union;
        cptr += 6;
        return PERCENT_UNION;
    }
    if (!strncmp(cptr, "%state", 6)) {
        state = State;
        cptr += 6;
        return PERCENT_STATE;
    }
    if (!strncmp(cptr, "%prefix", 7)) {
        cptr += 7;
        return PERCENT_PREFIX;
    }
    if (!strncmp(cptr, "%module", 7)) {
        cptr += 7;
        return PERCENT_MODULE;
    }
    if (!strncmp(cptr, "%{", 2)) { /*}*/
        state = CCode;
        cptr += 2;
        return PERCENT_LBRACE;
    }
    if (!strncmp(cptr, "%}", 2)) { /*{*/
        cptr += 2;
        return PERCENT_RBRACE;
    }
    if (c == '<' || c == '>' || c == '=') {
        return *cptr++;
    }
    if (IS_IDENT(c)) {
        get_identifier(pos);
        lval->_string = strdup(buffer);
        return IDENTIFIER;
    }
    break;
    case Union:
    if (c == '{') { /*}*/
        state = Union1;
        cptr++;
        return c;
    }
        break;
    case Union1:
    bufferpos = 0;
    if (c == '}') { /*{*/
        state = DeclSection;
        cptr++;
        return c;
    }
    if (c == ';') {
        cptr++;
        return c;
    }
    while (*cptr != ';') {
        addchar(*cptr++);
        if (*cptr == '\n') {
        cptr++;
        if (!get_line())
            error(pos, "Unexpected EOF");
        }
    }
    addchar(0);
    lval->_string = strdup(buffer);
    return TAGDEF;
    case State:
    if (c == '{') { /*}*/
        state = State1;
        cptr++;
        return c;
    }
        break;
    case State1:
    bufferpos = 0;
    if (c == '}') { /*{*/
        state = DeclSection;
        cptr++;
        return c;
    }
    if (c == ';') {
        cptr++;
        return c;
    }
    while (*cptr != ';') {
        addchar(*cptr++);
        if (*cptr == '\n') {
        cptr++;
        if (!get_line())
            error(pos, "Unexpected EOF");
        }
    }
    addchar(0);
    lval->_string = strdup(buffer);
    return TAGDEF;
    case CCode:
    bufferpos = 0;
    for (;;) {
        if (*cptr == '%' && cptr[1] == '}') /*{*/
        break;
        addchar(*cptr);
        if (*cptr++ == '\n') {
        if (!get_line())
            error(pos, "Unexpected EOF");
        }
    }
    state = DeclSection;
    addchar(0);
    lval->_ccode = strdup(buffer);
    return CCODE;
    case RuleSection:
    if (IS_IDENT(c)) {
        get_identifier(pos);
        lval->_string = strdup(buffer);
        return IDENTIFIER;
    }
    if (c == '(') {
        state = Arg;
        cptr++;
        return c;
    }
    if (c == ':' || c == ';' || c == '|' || c == '}' || c == '+' ||
        c == '*' || c == '?' || c == '[' || c == ']') { /*{*/
        cptr++;
        return c;
    }
    if (c == '%' && cptr[1] == '%') {
        state = CSection;
        cptr += 2;
        return PERCENT_PERCENT;
    }
    if (c == '{') {
        state = Action;
        cptr++;
        return c;
    }
    break;
    case Arg:
    if (c == ')') {
        state = RuleSection;
        cptr++;
        return c;
    }
    if (c == ',') {
        cptr++;
        return c;
    }
    bufferpos = 0;
    depth = 0;
    for (;;) {
        switch (*cptr) {
        case '(':
        depth++;
        addchar(*cptr++);
        continue;
        case ')':
        if (depth > 0) {
            depth--;
            addchar(*cptr++);
            continue;
        }
        break;
        case ',':
        if (depth > 0) {
            addchar(*cptr++);
            continue;
        }
        break;
        case '\n':
        error(pos, "Unterminated argument");
        /*NOTREACHED*/
        default:
        addchar(*cptr++);
        continue;
        }
        break;
    }
    addchar(0);
    lval->_string = strdup(buffer);
    return ARG;
    case Action:
    bufferpos = 0;
    depth = 0;
    for (;;) {
        switch (*cptr) {
        case '{': /*}*/
        depth++;
        addchar(*cptr++);
        continue;
        case '}': /*{*/
        if (depth > 0) {
            depth--;
            addchar(*cptr++);
            continue;
        }
        break;
        case '\'':
        case '\"':
        c = *cptr++;
        addchar((char)c);
        while (*cptr != c) {
            addchar(*cptr);
            if (*cptr == '\n') {
            cptr++;
            get_line();
            continue;
            }
            if (*cptr == '\\')
            addchar(*++cptr);
            cptr++;
        }
        addchar((char)c);
        cptr++;
        continue;
        case '\n':
        addchar(*cptr++);
        if (!get_line())
            error(pos, "Unexpected EOF");
        continue;
        default:
        addchar(*cptr++);
        continue;
        }
        break;
    }
    state = RuleSection;
    addchar(0);
    lval->_ccode = strdup(buffer);
    return CCODE;
    case CSection:
    bufferpos = 0;
    if (c != EOF) {
        do {
        do {
            addchar(*cptr);
        } while (*cptr++ != '\n');
        } while (get_line());
    }
    state = End;
    addchar(0);
    lval->_ccode = strdup(buffer);
    return CCODE;
    case End:
    return EOF;
    }
    error(pos, "Syntax error");
    return EOF;
    /*NOTREACHED*/
}

void
open_file(char *file)
{
    strcpy(filename, file);
    lineno = 0;
    fin = fopen(filename, "r");
    if (!fin) {
    perror(file);
    exit(1);
    }
}

int
llgettoken(int *token, LLSTYPE *lval, LLPOS *pos)
{
    *token = get_token(lval, pos);
    return *token != EOF;
}

void
llprinttoken(LLTERM *token, char *identifier, FILE *f)
{
    switch (token->token) {
    case IDENTIFIER:
    printf("scanner: delivering token IDENTIFIER(%s)\n", token->lval._string);
    break;
    case ARG:
    printf("scanner: delivering token ARG(%s)\n", token->lval._string);
    break;
    case CCODE:
    printf("scanner: delivering token CCODE(%s)\n", token->lval._ccode);
    break;
    case TAGDEF:
    printf("scanner: delivering token TAGDEF(%s)\n", token->lval._string);
    break;
    case PERCENT_PERCENT:
    printf("scanner: delivering token %%%%\n");
    break;
    case PERCENT_TOKEN:
    printf("scanner: delivering token %%token\n");
    break;
    case PERCENT_TYPE:
    printf("scanner: delivering token %%type\n");
    break;
    case PERCENT_UNION:
    printf("scanner: delivering token %%union\n");
    break;
    case PERCENT_START:
    printf("scanner: delivering token %%start\n");
    break;
    case PERCENT_PREFIX:
    printf("scanner: delivering token %%prefix\n");
    break;
    case PERCENT_LBRACE:
    printf("scanner: delivering token %%{\n");
    break;
    case PERCENT_RBRACE:
    printf("scanner: delivering token %%}\n");
    break;
    case EOF:
    printf("scanner: delivering token EOF\n");
    break;
    default:
    printf("scanner: delivering token %c\n", token->token);
    break;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\asn1\asn1c\char.c ===
/* Copyright (C) Boris Nikolaus, Germany, 1996-1997. All rights reserved. */
/* Copyright (C) Microsoft Corporation, 1997-1998. All rights reserved. */

#include "precomp.h"


/* check if a 16 bit character is a space */
int
ASN1is16space(ASN1char16_t c)
{
    return c == ' ' || c == '\t' || c == '\b' || c == '\f' || c == '\r' ||
	c == '\n' || c == '\v';
}

/* get length of a 16 bit string */
// lonchanc: lstrlenW()
int
ASN1str16len(ASN1char16_t *p)
{
    int len;

    for (len = 0; *p; p++)
	len++;
    return len;
}

/* check if a 32 bit character is a space */
int
ASN1is32space(ASN1char32_t c)
{
    return c == ' ' || c == '\t' || c == '\b' || c == '\f' || c == '\r' ||
	c == '\n' || c == '\v';
}

/* get length of a 32 bit string */
int
ASN1str32len(ASN1char32_t *p)
{
    int len;

    for (len = 0; *p; p++)
	len++;
    return len;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\asn1\asn1c\builtin.h ===
/* Copyright (C) Boris Nikolaus, Germany, 1996-1997. All rights reserved. */
/* Copyright (C) Microsoft Corporation, 1997-1998. All rights reserved. */

#ifndef _ASN1C_BUILTIN_H_
#define _ASN1C_BUILTIN_H_

extern Type_t *Builtin_Type_Null;
extern Type_t *Builtin_Type_Boolean;
extern Type_t *Builtin_Type_Integer;
extern Type_t *Builtin_Type_PositiveInteger;
extern Type_t *Builtin_Type_ObjectIdentifier;
extern Type_t *Builtin_Type_ObjectDescriptor;
extern Type_t *Builtin_Type_Open;
extern Type_t *Builtin_Type_BitString;
extern Type_t *Builtin_Type_OctetString;
extern Type_t *Builtin_Type_UTF8String;
extern Type_t *Builtin_Type_BMPString;
extern Type_t *Builtin_Type_GeneralString;
extern Type_t *Builtin_Type_GraphicString;
extern Type_t *Builtin_Type_IA5String;
extern Type_t *Builtin_Type_ISO646String;
extern Type_t *Builtin_Type_NumericString;
extern Type_t *Builtin_Type_PrintableString;
extern Type_t *Builtin_Type_TeletexString;
extern Type_t *Builtin_Type_T61String;
extern Type_t *Builtin_Type_UniversalString;
extern Type_t *Builtin_Type_VideotexString;
extern Type_t *Builtin_Type_VisibleString;
extern Type_t *Builtin_Type_CharacterString;
extern Type_t *Builtin_Type_GeneralizedTime;
extern Type_t *Builtin_Type_UTCTime;
extern Type_t *Builtin_Type_Real;
extern Type_t *Builtin_Type_External;
extern Type_t *Builtin_Type_EmbeddedPdv;
extern Value_t *Builtin_Value_Null;
extern Value_t *Builtin_Value_Integer_0;
extern Value_t *Builtin_Value_Integer_1;
extern Value_t *Builtin_Value_Integer_2;
extern Value_t *Builtin_Value_Integer_10;
extern ObjectClass_t *Builtin_ObjectClass_TypeIdentifier;
extern ObjectClass_t *Builtin_ObjectClass_AbstractSyntax;
extern ModuleIdentifier_t *Builtin_Module;
extern ModuleIdentifier_t *Builtin_Character_Module;
extern AssignmentList_t Builtin_Assignments;
extern AssignedObjIdList_t Builtin_ObjIds;

extern void InitBuiltin();

#endif // _ASN1C_BUILTIN_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\asn1\asn1c\asn1.c ===
/* Copyright (C) Boris Nikolaus, Germany, 1996-1997. All rights reserved. */
/* Copyright (C) Microsoft Corporation, 1997-1998. All rights reserved. */

#include "precomp.h"

#ifndef HAS_GETOPT
extern int getopt(int argc, char **argv, const char *opts);
extern char *optarg;
extern int optind;
#endif

int pass;

/* if ForceAllTypes is set, asn1c will generate encoding functions for */
/* all types (default: only for sequence/set/choice/sequence of/set of) */
int ForceAllTypes = 0;

/* type to use for unconstrained integers/semiconstrained signed integers */
char *IntegerRestriction = "ASN1int32_t";

/* type to use for semiconstrained unsigned integers */
char *UIntegerRestriction = "ASN1uint32_t";

/* type to use for real */
char *RealRestriction = "double";

/* output language */
Language_e g_eProgramLanguage = eLanguage_C;

/* alignment of encoding */
Alignment_e Alignment = eAlignment_Aligned;

/* encoding to generate code for */
Encoding_e g_eEncodingRule = eEncoding_Packed;

/* subencoding to generate code for */
SubEncoding_e g_eSubEncodingRule = eSubEncoding_Basic;

/* target compiler supports 64 bit integers */
int Has64Bits = 0;

/* zero out allocated buffers for decoded data */
int g_fDecZeroMemory = 1;

/* debug module name */
int g_nDbgModuleName = 0;

/* source file and header file pointers */
FILE *g_finc, *g_fout;

// default tag type in this module
TagType_e g_eDefTagType = eTagType_Unknown;

/* original main module name without postfixed _Module */
char *g_pszOrigModuleName = NULL;
char *g_pszOrigModuleNameLowerCase = NULL;

/* enable long name (prefixed with module name for imported) */
int g_fLongNameForImported = 0;

// extra struct type name postfixed with _s, and its original name is its pointer type.
int g_fExtraStructPtrTypeSS = 0;

// the default structure type for Sequence Of and Set Of
TypeRules_e g_eDefTypeRuleSS_NonSized = eTypeRules_SinglyLinkedList;
TypeRules_e g_eDefTypeRuleSS_Sized = eTypeRules_FixedArray;

// ignore the assertion
int g_fNoAssert = 0;

// object identifier is 16-node array
int g_fOidArray = 0;

// case based optimizer switch
int g_fCaseBasedOptimizer = 1;

// enable in-file directive
int g_fMicrosoftExtensions = 1;

// all platforms: little endian (default) and big endian
int g_fAllEndians = 0;

// directive begin, end, AND
int g_chDirectiveBegin = '#';
int g_chDirectiveEnd = '#';
int g_chDirectiveAND = '&';

// postfix
char *g_pszApiPostfix = "ID";
char *g_pszChoicePostfix = "choice";
char *g_pszOptionPostfix = "option";

// option value
char *g_pszOptionValue = "option_bits";

// invisble file array
int g_cGhostFiles = 0;
GhostFile_t g_aGhostFiles[16];

int _cdecl main(int argc, char **argv)
{
    FILE *finc, *fout;
    char *p;
    int c, chInvalidDir;
    LLSTATE in, out;
    UndefinedSymbol_t *lastundef;
    Assignment_t *a, **aa;
    LLTERM *tokens;
    unsigned ntokens;
    int fSupported;
    char *psz;
    char incfilename[256], outfilename[256], module[256];

    /* parse options */
    // if an option is followed by ':', then it has a parameter.
    while ((c = getopt(argc, argv, "ab:c:d:e:fg:hil:mn:o:p:q:s:t:uv:wy")) != EOF)
    {
        chInvalidDir = 0;
        switch (c)
        {
        case 'a':

            /* enable for all platforms: little endian and big endian */
            g_fAllEndians = 1;
            break;

        case 'b':

            /* maximum number of bits of target machine */
            if (atoi(optarg) == 32) {
                Has64Bits = 0;
                break;
            }
            if (atoi(optarg) == 64) {
                Has64Bits = 1;
                break;
            }
            fprintf(stderr, "Bad number of bits specified.\n");
            MyExit(1);
            /*NOTREACHED*/

        case 'c':

            // Choice postfix
            psz = strdup(optarg);
            if (psz && isalpha(*psz))
            {
                g_pszChoicePostfix = psz;
            }
            break;

        case 'd':

            // sequence of and set of data structure types
            if (! stricmp(optarg, "linked") || ! stricmp(optarg, "slinked"))
            {
                g_eDefTypeRuleSS_NonSized = eTypeRules_SinglyLinkedList;
            }
            else
            if (! stricmp(optarg, "lenptr"))
            {
                g_eDefTypeRuleSS_NonSized = eTypeRules_LengthPointer;
            }
            else
            if (! stricmp(optarg, "dlinked"))
            {
                g_eDefTypeRuleSS_NonSized = eTypeRules_DoublyLinkedList;
            }
            else
            {
                goto usage;
            }
            break;

        case 'e':

            /* encoding to generate code for */
            if (!stricmp(optarg, "packed"))
            {
                g_eEncodingRule = eEncoding_Packed;
            }
            else
            if (!stricmp(optarg, "basic"))
            {
                g_eEncodingRule = eEncoding_Basic;
            }
            else
            if (!stricmp(optarg, "per"))
            {
                g_eEncodingRule = eEncoding_Packed;
                Alignment = eAlignment_Aligned;
            }
            else
            if (!stricmp(optarg, "cer"))
            {
                g_eEncodingRule = eEncoding_Basic;
                g_eSubEncodingRule = eSubEncoding_Canonical;
            }
            else
            if (!stricmp(optarg, "der"))
            {
                g_eEncodingRule = eEncoding_Basic;
                g_eSubEncodingRule = eSubEncoding_Distinguished;
            }
            else
            if (!stricmp(optarg, "ber"))
            {
                g_eEncodingRule = eEncoding_Basic;
                g_eSubEncodingRule = eSubEncoding_Basic;
            }
            else
            {
                fprintf(stderr, "Bad encoding specified.\n");
                fprintf(stderr, "Allowed encodings are:\n");
                fprintf(stderr, "- packed (default)\n");
                fprintf(stderr, "- basic\n");
                MyExit(1);
                /*NOTREACHED*/
            }
            break;

        case 'f':

            /* force generation of encoding/decoding functions for all types */
            ForceAllTypes = 1;
            break;

        case 'g':

            /* ghost asn1 files */
            g_aGhostFiles[g_cGhostFiles].pszFileName = strdup(optarg);
            g_aGhostFiles[g_cGhostFiles++].pszModuleName = NULL;
            break;

        case 'h':

            goto usage;

        case 'i':

            /* ignore assertion */
            g_fNoAssert = 1;
            break;

        case 'l':

            /* set output language */
            if (!stricmp(optarg, "c")) {
                g_eProgramLanguage = eLanguage_C;
                break;
            }
            if (!stricmp(optarg, "c++") || !stricmp(optarg, "cpp")) {
                g_eProgramLanguage = eLanguage_Cpp;
                break;
            }
            goto usage;

        case 'm':

            /* enable Microsoft extension */
            g_fMicrosoftExtensions = 1;
            break;

        case 'n':

            /* debug module name */
            g_nDbgModuleName = 0;
            {
                int len = strlen(optarg);
                if (len > 4)
                    len = 4;
                memcpy(&g_nDbgModuleName, optarg, len);
            }
            break;

        case 'o':

            // Option postfix
            psz = strdup(optarg);
            if (psz && isalpha(*psz))
            {
                g_pszOptionPostfix = psz;
            }
            break;

        case 'p':

            // API postfix
            psz = strdup(optarg);
            if (psz && isalpha(*psz))
            {
                g_pszApiPostfix = psz;
            }
            break;

        case 'q':

            // sequence of and set of data structure types
            if (! stricmp(optarg, "linked") || ! stricmp(optarg, "slinked"))
            {
                g_eDefTypeRuleSS_Sized = eTypeRules_SinglyLinkedList;
            }
            else
            if (! stricmp(optarg, "lenptr"))
            {
                g_eDefTypeRuleSS_Sized = eTypeRules_LengthPointer;
            }
            else
            if (! stricmp(optarg, "array"))
            {
                g_eDefTypeRuleSS_Sized = eTypeRules_FixedArray;
            }
            else
            if (! stricmp(optarg, "pointer"))
            {
                g_eDefTypeRuleSS_Sized = eTypeRules_PointerToElement | eTypeRules_FixedArray;
            }
            else
            if (! stricmp(optarg, "dlinked"))
            {
                g_eDefTypeRuleSS_Sized = eTypeRules_DoublyLinkedList;
            }
            else
            {
                goto usage;
            }
            break;

        case 's':

            /* set subencoding */
            if (!stricmp(optarg, "aligned"))
            {
                Alignment = eAlignment_Aligned;
            }
            else
            if (!stricmp(optarg, "unaligned"))
            {
                Alignment = eAlignment_Unaligned;
            }
            else
            if (!stricmp(optarg, "cer"))
            {
                g_eSubEncodingRule = eSubEncoding_Canonical;
            }
            else
            if (!stricmp(optarg, "der"))
            {
                g_eSubEncodingRule = eSubEncoding_Distinguished;
            }
            else
            if (!stricmp(optarg, "basic"))
            {
                g_eSubEncodingRule = eSubEncoding_Basic;
            }
            else
            {
                fprintf(stderr, "Bad sub-encoding specified.\n");
                fprintf(stderr, "Allowed sub-encodings are:\n");
                fprintf(stderr, "- aligned (default) or unaligned\n");
                fprintf(stderr, "- basic (default), cer or der\n");
                MyExit(1);
                /*NOTREACHED*/
            }
            break;

        case 't':

            /* specify type to use for unconstrained/semiconstrained types */
            p = strchr(optarg, '=');
            if (!p)
                goto usage;
            *p++ = 0;
            if (!stricmp(optarg, "integer")) {
                if (!stricmp(p, "ASN1int32_t")) {
                    IntegerRestriction = "ASN1int32_t";
                    break;
                }
                if (!stricmp(p, "ASN1uint32_t")) {
                    IntegerRestriction = "ASN1uint32_t";
                    break;
                }
                if (!stricmp(p, "ASN1int64_t")) {
                    IntegerRestriction = "ASN1int64_t";
                    break;
                }
                if (!stricmp(p, "ASN1uint64_t")) {
                    IntegerRestriction = "ASN1uint64_t";
                    break;
                }
                if (!stricmp(p, "ASN1intx_t")) {
                    IntegerRestriction = "ASN1intx_t";
                    break;
                }
            }
            if (!stricmp(optarg, "unsigned")) {
                if (!stricmp(p, "ASN1int32_t")) {
                    UIntegerRestriction = "ASN1int32_t";
                    break;
                }
                if (!stricmp(p, "ASN1uint32_t")) {
                    UIntegerRestriction = "ASN1uint32_t";
                    break;
                }
                if (!stricmp(p, "ASN1int64_t")) {
                    UIntegerRestriction = "ASN1int64_t";
                    break;
                }
                if (!stricmp(p, "ASN1uint64_t")) {
                    UIntegerRestriction = "ASN1uint64_t";
                    break;
                }
                if (!stricmp(p, "ASN1intx_t")) {
                    UIntegerRestriction = "ASN1intx_t";
                    break;
                }
            }
            if (!stricmp(optarg, "real")) {
                if (!stricmp(p, "double")) {
                    RealRestriction = "double";
                    break;
                }
                if (!stricmp(p, "ASN1real_t")) {
                    RealRestriction = "ASN1real_t";
                    break;
                }
            }
            goto usage;

        case 'u':

            // no case-based optimizer
            g_fCaseBasedOptimizer = 0;
            break;

        case 'v':

            // Option value
            psz = strdup(optarg);
            if (psz && isalpha(*psz))
            {
                g_pszOptionValue = psz;
            }
            break;

        case 'w':

            // --#OID ARRAY#--
            g_fOidArray = 1;
            break;

        case 'y':

            /* enable long name (prefixed with module name for imported) */
            g_fLongNameForImported = 1;
            break;

        default:

            chInvalidDir = c;

        usage:
            fprintf(stderr,"ASN.1 Compiler V1.0\n");
            fprintf(stderr, "Copyright (C) Microsoft Corporation, U.S.A., 1997-1998. All rights reserved.\n");
            fprintf(stderr, "Copyright (C) Boris Nikolaus, Germany, 1996-1997. All rights reserved.\n");
            if (chInvalidDir)
            {
                fprintf(stderr, "Invalid option  -%c\n", chInvalidDir);
            }
            else
            {
                fprintf(stderr, "Usage: %s [options] [imported.asn1 ...] main.asn1\n", argv[0]);
                fprintf(stderr, "Options:\n");
                fprintf(stderr, "-h\t\tthis help\n");
                fprintf(stderr, "-z\t\tzero out allocated buffers for decoded data\n");
                fprintf(stderr, "-x\t\tbridge APIs\n");
                fprintf(stderr, "-a\t\textra type definition for structure\n");
                fprintf(stderr, "-n name\t\tmodule name for debugging purpose\n");
                // fprintf(stderr, "-l language\tgenerate code for <language> (c (default), c++)\n");
                // fprintf(stderr, "-b 64\t\tenable 64 bit support\n");
                fprintf(stderr, "-e encoding\tuse <encoding> as encoding rule\n");
                fprintf(stderr,     "\t\t(possible values: packed (default), basic)\n");
                fprintf(stderr, "-s subencoding\tuse <subencoding> as subencoding rules\n");
                fprintf(stderr,     "\t\t(possible values: aligned (default) or unaligned,\n");
                fprintf(stderr,     "\t\tbasic (default), canonical or distinguished)\n");
                fprintf(stderr, "-t type=rest.\trestrict/unrestrict a unconstrained/semiconstrained type:\n");
                fprintf(stderr,     "\t\tinteger=type\tuse <type> (ASN1[u]int32_t, ASN1[u]int64_t or\n\t\t\t\tASN1intx_t) for unconstrained integers\n\t\t\t\t(default: ASN1int32_t)\n");
                fprintf(stderr,     "\t\tunsigned=type\tuse <type> (ASN1[u]int32_t, ASN1[u]int64_t or\n\t\t\t\tASN1intx_t) for positive semiconstrained\n\t\t\t\tintegers (default: ASN1uint32_t)\n");
                fprintf(stderr,     "\t\treal=type\tuse <type> (double or ASN1real_t) for\n\t\t\t\tunconstrained floating point numbers\n\t\t\t\t(default: double)\n");
            }
            MyExit(1);
        }
    }

    /* check if any modules are given */
    if (argc < optind + 1)
        goto usage;

    /* check for unsupported encoding */
    fSupported = TRUE;
    if (g_eEncodingRule == eEncoding_Packed)
    {
        if (Alignment != eAlignment_Aligned || g_eSubEncodingRule != eSubEncoding_Basic)
        {
            fSupported = FALSE;
        }
    }
    else
    if (g_eEncodingRule == eEncoding_Basic)
    {
        // if (Alignment != eAlignment_Aligned || g_eSubEncodingRule == eSubEncoding_Distinguished)
        if (Alignment != eAlignment_Aligned)
        {
            fSupported = FALSE;
        }
    }
    if (! fSupported)
    {
        fprintf(stderr, "Encoding not implemented (yet)\n");
        MyExit(1);
    }

    /* initialize */
    InitBuiltin();

    /* scan file(s) */
#if defined(LLDEBUG) && LLDEBUG > 0
    pass = 1;
    fprintf(stderr, "Pass 1: Scanning input file\n");
#endif
    readfiles(argv + optind);
    llscanner(&tokens, &ntokens);

    /* setup initial state */
    in.Assignments = Builtin_Assignments;
    in.AssignedObjIds = Builtin_ObjIds;
    in.Undefined = NULL;
    in.BadlyDefined = NULL;
    in.Module = NULL;
    in.MainModule = NULL;
    in.Imported = NULL;
    in.TagDefault = eTagType_Unknown;
    in.ExtensionDefault = eExtensionType_None;
    lastundef = NULL;

    /* parse the modules */
    do {
#if defined(LLDEBUG) && LLDEBUG > 0
        fprintf(stderr, "Pass %d: Parsing                    \n", ++pass);
#endif

        /* parse modules */
        if (!llparser(tokens, ntokens, &in, &out)) {
            llprinterror(stderr);
            MyExit(1);
        }

        /* if undefined symbols remain the same as in previous pass */
        /* than print these undefined symbols and MyExit */
        if (!CmpUndefinedSymbolList(out.Assignments, out.Undefined, lastundef))
            UndefinedError(out.Assignments, out.Undefined, out.BadlyDefined);

        /* setup data for next pass */
        in = out;
        aa = &in.Assignments;
        for (a = Builtin_Assignments; a; a = a->Next) {
            *aa = DupAssignment(a);
            aa = &(*aa)->Next;
        }
        *aa = NewAssignment(eAssignment_NextPass);
        aa = &(*aa)->Next;
        *aa = out.Assignments;
        lastundef = out.Undefined;
        in.Undefined = NULL;
        in.BadlyDefined = NULL;

        /* continue parsing until no undefined symbols left */
    } while (lastundef);

    /* build internal information */
#if defined(LLDEBUG) && LLDEBUG > 0
    fprintf(stderr, "Pass %d: Building internal information                    \n", ++pass);
#endif
    Examination(&out.Assignments, out.MainModule);
    ExaminePER(out.Assignments);
    ExamineBER(out.Assignments);

    // remember who is the local duplicate of imported types
    for (a = out.Assignments; a; a = a->Next)
    {
        a->fImportedLocalDuplicate = IsImportedLocalDuplicate(out.Assignments, out.MainModule, a) ? 1 : 0;
    }

    /* create file names and open files */
#if defined(LLDEBUG) && LLDEBUG > 0
    fprintf(stderr, "Pass %d: Code generation                    \n", ++pass);
#endif

    // create module name
    StripModuleName(module, argv[argc - 1]);

    // create inc file and out file names
    strcpy(incfilename, module);
    strcat(incfilename, ".h");
    strcpy(outfilename, module);
    strcat(outfilename, ".c");
    for (p = module; *p; p++)
        *p = (char)toupper(*p);
    finc = fopen(incfilename, "w");
    if (!finc) {
        perror(incfilename);
        MyExit(1);
    }
    fout = fopen(outfilename, "w");
    if (!fout) {
        perror(outfilename);
        MyExit(1);
    }

    // lonchanc: change the full path name to file name only
    {
        char *psz = strrchr(module, '\\');
        if (psz)
        {
            strcpy(module, psz+1);
        }
    }

    // save the original module names
    g_pszOrigModuleName = strdup(module);
    g_pszOrigModuleNameLowerCase = strdup(module);
    {
        char *psz;
        for (psz = g_pszOrigModuleNameLowerCase; *psz; psz++)
        {
            *psz = (char)tolower(*psz);
        }
    }

    // lonchanc: append "_Module" to module name
    strcat(module, "_Module");

    /* code generation */
    g_finc = finc;
    g_fout = fout;
    GenInc(out.Assignments, finc, module);
    GenPrg(out.Assignments, fout, module, incfilename);

    setoutfile(finc);
    output("\n#ifdef __cplusplus\n");
    outputni("} /* extern \"C\" */\n");
    output("#endif\n\n");
    output("#endif /* _%s_H_ */\n", module);
    setoutfile(fout);

    /* finitialize */
    fclose(finc);
    fclose(fout);
#if defined(LLDEBUG) && LLDEBUG > 0
    fprintf(stderr, "Finished. \n");
#endif
    return 0;
}

/* why is this function not in MS libc? */
#ifndef HAS_GETOPT
char *optarg;
int optind = 1;
static int optpos = 1;

/* get the next option from the command line arguments */
int getopt(int argc, char **argv, const char *options) {
    char *p, *q;

    optarg = NULL;

    /* find start of next option */
    do {
        if (optind >= argc)
            return EOF;
        if (*argv[optind] != '-' && *argv[optind] != '/')
            return EOF;
        p = argv[optind] + optpos++;
        if (!*p) {
            optind++;
            optpos = 1;
        }
    } while (!*p);

    /* find option in option string */
    q = strchr(options, *p);
    if (!q)
        return '?';

    /* set optarg for parameterized option and adjust optind and optpos for next call */
    if (q[1] == ':') {
        if (p[1]) {
            optarg = p + 1;
            optind++;
            optpos = 1;
        } else if (++optind < argc) {
            optarg = argv[optind];
            optind++;
            optpos = 1;
        } else {
            return '?';
        }
    }

    /* return found option */
    return *p;
}
#endif


void StripModuleName(char *pszDst, char *pszSrc)
{
    strcpy(pszDst, pszSrc);
    if (!strcmp(pszDst + strlen(pszDst) - 5, ".asn1"))
        pszDst[strlen(pszDst) - 5] = 0;
    else if (!strcmp(pszDst + strlen(pszDst) - 4, ".asn"))
        pszDst[strlen(pszDst) - 4] = 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\asn1\asn1c\ber.c ===
/* Copyright (C) Boris Nikolaus, Germany, 1996-1997. All rights reserved. */
/* Copyright (C) Microsoft Corporation, 1997-1998. All rights reserved. */

#include "precomp.h"

void ExamineBERType(AssignmentList_t ass, Type_t *type, char *ideref);
void ExamineBERType_Boolean(AssignmentList_t ass, Type_t *type, BERTypeInfo_t *info);
void ExamineBERType_Integer(AssignmentList_t ass, Type_t *type, BERTypeInfo_t *info);
void ExamineBERType_Enumerated(AssignmentList_t ass, Type_t *type, BERTypeInfo_t *info);
void ExamineBERType_Real(AssignmentList_t ass, Type_t *type, BERTypeInfo_t *info);
void ExamineBERType_BitString(AssignmentList_t ass, Type_t *type, BERTypeInfo_t *info);
void ExamineBERType_OctetString(AssignmentList_t ass, Type_t *type, BERTypeInfo_t *info);
void ExamineBERType_UTF8String(AssignmentList_t ass, Type_t *type, BERTypeInfo_t *info);
void ExamineBERType_Null(AssignmentList_t ass, Type_t *type, BERTypeInfo_t *info);
void ExamineBERType_EmbeddedPdv(AssignmentList_t ass, Type_t *type, BERTypeInfo_t *info);
void ExamineBERType_External(AssignmentList_t ass, Type_t *type, BERTypeInfo_t *info);
void ExamineBERType_ObjectIdentifier(AssignmentList_t ass, Type_t *type, BERTypeInfo_t *info);
void ExamineBERType_BMPString(AssignmentList_t ass, Type_t *type, BERTypeInfo_t *info);
void ExamineBERType_GeneralString(AssignmentList_t ass, Type_t *type, BERTypeInfo_t *info);
void ExamineBERType_GraphicString(AssignmentList_t ass, Type_t *type, BERTypeInfo_t *info);
void ExamineBERType_IA5String(AssignmentList_t ass, Type_t *type, BERTypeInfo_t *info);
void ExamineBERType_ISO646String(AssignmentList_t ass, Type_t *type, BERTypeInfo_t *info);
void ExamineBERType_NumericString(AssignmentList_t ass, Type_t *type, BERTypeInfo_t *info);
void ExamineBERType_PrintableString(AssignmentList_t ass, Type_t *type, BERTypeInfo_t *info);
void ExamineBERType_TeletexString(AssignmentList_t ass, Type_t *type, BERTypeInfo_t *info);
void ExamineBERType_T61String(AssignmentList_t ass, Type_t *type, BERTypeInfo_t *info);
void ExamineBERType_UniversalString(AssignmentList_t ass, Type_t *type, BERTypeInfo_t *info);
void ExamineBERType_VideotexString(AssignmentList_t ass, Type_t *type, BERTypeInfo_t *info);
void ExamineBERType_VisibleString(AssignmentList_t ass, Type_t *type, BERTypeInfo_t *info);
void ExamineBERType_UnrestrictedString(AssignmentList_t ass, Type_t *type, BERTypeInfo_t *info);
void ExamineBERType_GeneralizedTime(AssignmentList_t ass, Type_t *type, BERTypeInfo_t *info);
void ExamineBERType_UTCTime(AssignmentList_t ass, Type_t *type, BERTypeInfo_t *info);
void ExamineBERType_ObjectDescriptor(AssignmentList_t ass, Type_t *type, BERTypeInfo_t *info);
void ExamineBERType_Open(AssignmentList_t ass, Type_t *type, BERTypeInfo_t *info);
void ExamineBERType_SequenceSet(AssignmentList_t ass, Type_t *type, BERTypeInfo_t *info);
void ExamineBERType_SequenceSetOf(AssignmentList_t ass, Type_t *type, BERTypeInfo_t *info);
void ExamineBERType_Choice(AssignmentList_t ass, Type_t *type, BERTypeInfo_t *info);
void ExamineBERType_InstanceOf(AssignmentList_t ass, Type_t *type, BERTypeInfo_t *info);
void ExamineBERType_Reference(AssignmentList_t ass, Type_t *type, BERTypeInfo_t *info);

/* examine all types and extract informations needed for BER encoding */
void
ExamineBER(AssignmentList_t ass)
{
    Assignment_t *a;

    /* examine all assignments */
    for (a = ass; a; a = a->Next) {

	/* examine types */
	switch (a->Type) {
	case eAssignment_Type:
	    ExamineBERType(ass, a->U.Type.Type, GetName(a));
	    break;
	}
    }
}

/* extract some type informations needed for BER encoding */
void
ExamineBERType(AssignmentList_t ass, Type_t *type, char *ideref)
{
    BERTypeInfo_t *info;

    info = &type->BERTypeInfo;
    info->pPrivateDirectives = &type->PrivateDirectives;

    /* get tags to en-/decode */
    if (IsReferenceType(type) && IsStructuredType(GetType(ass, type))) {
	info->Tags = type->Tags;
    } else {
	info->Tags = type->AllTags;
    }

    /* get the type to be examined */
    if (IsReferenceType(type) && !IsStructuredType(GetType(ass, type)))
	type = GetType(ass, type);

    /* initialize the BER informations */
    info->Identifier = ideref;
    info->Rules = type->Rules;
    info->Flags = type->Flags;
    info->NOctets = 0;
    info->SubIdentifier = NULL;
    info->SubType = NULL;
    info->Data = eBERSTIData_Null;

    /* BER informations are type specific ... */
    switch (type->Type) {
    case eType_Boolean:
	ExamineBERType_Boolean(ass, type, info);
	break;
    case eType_Integer:
	ExamineBERType_Integer(ass, type, info);
	break;
    case eType_Enumerated:
	ExamineBERType_Enumerated(ass, type, info);
	break;
    case eType_Real:
	ExamineBERType_Real(ass, type, info);
	break;
    case eType_BitString:
	ExamineBERType_BitString(ass, type, info);
	break;
    case eType_OctetString:
	ExamineBERType_OctetString(ass, type, info);
	break;
    case eType_UTF8String:
	ExamineBERType_UTF8String(ass, type, info);
	break;
    case eType_Null:
	ExamineBERType_Null(ass, type, info);
	break;
    case eType_EmbeddedPdv:
	ExamineBERType_EmbeddedPdv(ass, type, info);
	break;
    case eType_External:
	ExamineBERType_External(ass, type, info);
	break;
    case eType_ObjectIdentifier:
	ExamineBERType_ObjectIdentifier(ass, type, info);
	break;
    case eType_BMPString:
	ExamineBERType_BMPString(ass, type, info);
	break;
    case eType_GeneralString:
	ExamineBERType_GeneralString(ass, type, info);
	break;
    case eType_GraphicString:
	ExamineBERType_GraphicString(ass, type, info);
	break;
    case eType_IA5String:
	ExamineBERType_IA5String(ass, type, info);
	break;
    case eType_ISO646String:
	ExamineBERType_ISO646String(ass, type, info);
	break;
    case eType_NumericString:
	ExamineBERType_NumericString(ass, type, info);
	break;
    case eType_PrintableString:
	ExamineBERType_PrintableString(ass, type, info);
	break;
    case eType_TeletexString:
	ExamineBERType_TeletexString(ass, type, info);
	break;
    case eType_T61String:
	ExamineBERType_T61String(ass, type, info);
	break;
    case eType_UniversalString:
	ExamineBERType_UniversalString(ass, type, info);
	break;
    case eType_VideotexString:
	ExamineBERType_VideotexString(ass, type, info);
	break;
    case eType_VisibleString:
	ExamineBERType_VisibleString(ass, type, info);
	break;
    case eType_CharacterString:
	ExamineBERType_UnrestrictedString(ass, type, info);
	break;
    case eType_GeneralizedTime:
	ExamineBERType_GeneralizedTime(ass, type, info);
	break;
    case eType_UTCTime:
	ExamineBERType_UTCTime(ass, type, info);
	break;
    case eType_ObjectDescriptor:
	ExamineBERType_ObjectDescriptor(ass, type, info);
	break;
    case eType_Open:
	ExamineBERType_Open(ass, type, info);
	break;
    case eType_Sequence:
    case eType_Set:
	ExamineBERType_SequenceSet(ass, type, info);
	break;
    case eType_SequenceOf:
    case eType_SetOf:
	ExamineBERType_SequenceSetOf(ass, type, info);
	break;
    case eType_Choice:
	ExamineBERType_Choice(ass, type, info);
	break;
    case eType_InstanceOf:
	ExamineBERType_InstanceOf(ass, type, info);
	break;
    case eType_RestrictedString:
	MyAbort(); /* may never happen */
	/*NOTREACHED*/
    case eType_Selection:
	MyAbort(); /* may never happen */
	/*NOTREACHED*/
    case eType_Undefined:
	MyAbort(); /* may never happen */
	/*NOTREACHED*/
    case eType_Reference:
	ExamineBERType_Reference(ass, type, info);
	break;
    case eType_FieldReference:
	MyAbort(); /* may never happen */
	/*NOTREACHED*/
    }
}

/*
 * Description of the fields of BERTypeInfo_t:
 *   info.
 *	Identifier	complete name of the type
 *	Rules		encoding directive rules
 *	Flags		encoding flags
 *	NOctets		size of string characters/integer type
 *	Data		data type of value
 *	SubIdentifier	complete name of the subtype
 *	SubType		the subtype itself
 *	Tags		tag list of the type
 *
 * NOTES:
 *	The encoding is mostly controlled by following arguments:
 *	- Data, the type: one of:
 *	  eBERSTIData_Null, eBERSTIData_Boolean,
 *	  eBERSTIData_Integer, eBERSTIData_Unsigned,
 *	  eBERSTIData_Real, eBERSTIData_BitString, eBERSTIData_RZBBitString,
 *	  eBERSTIData_OctetString, eBERSTIData_SequenceOf, eBERSTIData_SetOf,
 *	  eBERSTIData_Sequence, eBERSTIData_Set, eBERSTIData_Choice,
 *	  eBERSTIData_ObjectIdentifier, eBERSTIData_ObjectIdEncoded, eBERSTIData_String,
 *	  eBERSTIData_ZeroString, eBERSTIData_Reference, eBERSTIData_External,
 *	  eBERSTIData_EmbeddedPdv, eBERSTIData_UnrestrictedString
 *
 *	Following arguments contain variable/function names in the generated
 *	code:
 *	- Identifier, the name of the current type
 *	- SubIdentifier, the name of the subtype
 *
 *	Following values require additional arguments:
 *	- Data == eBERSTIData_Reference
 *	  -> SubIdentifier, the name of the subtype
 *	  -> SubType, the subtype itself
 *	- Data == eBERSTIData_*String
 *	  -> NOctets, the size of the string characters
 *	- Data == eBERSTIData_Integer || Data == eBERSTIData_Unsigned ||
 *	  Data == eBERSTIData_Boolean || Data == eBERSTIData_Choice
 *	  -> NOctets, the size of the integer type
 *	- Data == eBERSTIData_SequenceOf || Data == eBERSTIData_SetOf
 *	  -> SubIdentifier, the name of the subtype
 *	  -> SubType, the subtype itself
 *	  -> Rule, the encoding directive rules
 */

/*
 * BOOLEAN:
 *
 *	Data == eBERSTIData_Boolean
 *
 * Additional arguments:
 *
 *	- Data == eBERSTIData_Integer || dat == eBERSTIData_Unsigned ||
 *	  Data == eBERSTIData_Boolean || dat == eBERSTIData_Choice
 *	  -> NOctets, the size of the integer type
 */
void
ExamineBERType_Boolean(AssignmentList_t ass, Type_t *type, BERTypeInfo_t *info)
{
    info->Data = eBERSTIData_Boolean;
    info->NOctets = GetOctets(GetBooleanType());
}

/*
 * INTEGER:
 *
 *	Data == eBERSTIData_Integer ||
 *	Data == eBERSTIData_Unsigned
 *
 * Additional arguments:
 *
 *	- Data == eBERSTIData_Integer || dat == eBERSTIData_Unsigned ||
 *	  Data == eBERSTIData_Boolean || dat == eBERSTIData_Choice
 *	  -> NOctets, the size of the integer type
 */
void
ExamineBERType_Integer(AssignmentList_t ass, Type_t *type, BERTypeInfo_t *info)
{
    int32_t sign;

    /* calculate NOctets and Data depending on the used C-Type */
    info->NOctets = GetOctets(GetIntegerType(ass, type, &sign));
    info->Data = sign > 0 ? eBERSTIData_Unsigned : eBERSTIData_Integer;
}

/*
 * ENUMERATED:
 *
 *	Data == eBERSTIData_Integer ||
 *	Data == eBERSTIData_Unsigned
 *
 * Additional arguments:
 *
 *	- Data == eBERSTIData_Integer || dat == eBERSTIData_Unsigned ||
 *	  Data == eBERSTIData_Boolean || dat == eBERSTIData_Choice
 *	  -> NOctets, the size of the integer type
 */
void
ExamineBERType_Enumerated(AssignmentList_t ass, Type_t *type, BERTypeInfo_t *info)
{
    int32_t sign;

    /* calculate NOctets and Data depending on the used C-Type */
    info->NOctets = GetOctets(GetEnumeratedType(ass, type, &sign));
    info->Data = sign > 0 ? eBERSTIData_Unsigned : eBERSTIData_Integer;
}

/*
 * REAL:
 *
 *	Data == eBERSTIData_Real
 *
 * Additional arguments:
 *
 *	none
 */
void
ExamineBERType_Real(AssignmentList_t ass, Type_t *type, BERTypeInfo_t *info)
{
    info->NOctets = GetOctets(GetRealType(type));
    info->Data = eBERSTIData_Real;
}

/*
 * BIT STRING:
 *
 *	Data == eBERSTIData_BitString ||
 *	Data == eBERSTIData_RZBBitString
 *
 * Additional arguments:
 *
 *	none
 */
void
ExamineBERType_BitString(AssignmentList_t ass, Type_t *type, BERTypeInfo_t *info)
{
    /* set Data to RZBBitString/BitString */
    if (type->U.BitString.NamedNumbers)
	info->Data = eBERSTIData_RZBBitString;
    else
	info->Data = eBERSTIData_BitString;
}

/*
 * OCTET STRING:
 *
 *	Data == eBERSTIData_OctetString
 *
 * Additional arguments:
 *
 *	none
 */
void
ExamineBERType_OctetString(AssignmentList_t ass, Type_t *type, BERTypeInfo_t *info)
{
    /* set Data to OctetString */
    info->Data = eBERSTIData_OctetString;
}

void
ExamineBERType_UTF8String(AssignmentList_t ass, Type_t *type, BERTypeInfo_t *info)
{
    /* set Data to UTF8String */
    info->Data = eBERSTIData_UTF8String;
}

/*
 * NULL:
 *
 *	Data == eBERSTIData_Null
 *
 * Additional arguments:
 *
 *	none
 */
void
ExamineBERType_Null(AssignmentList_t ass, Type_t *type, BERTypeInfo_t *info)
{
    info->Data = eBERSTIData_Null;
}

/*
 * EMBEDDED PDV:
 *
 *	Data == eBERSTIData_EmbeddedPdv
 *
 * Additional arguments:
 *
 *	none
 */
void
ExamineBERType_EmbeddedPdv(AssignmentList_t ass, Type_t *type, BERTypeInfo_t *info)
{
    info->Data = eBERSTIData_EmbeddedPdv;
}

/*
 * EXTERNAL:
 *
 *	Data == eBERSTIData_External
 *
 * Additional arguments:
 *
 *	none
 */
void
ExamineBERType_External(AssignmentList_t ass, Type_t *type, BERTypeInfo_t *info)
{
    info->Data = eBERSTIData_External;
}

/*
 * OBJECT IDENTIFIER:
 *
 *	Data == eBERSTIData_ObjectIdEncoded || eBERSTIData_ObjectIdentifier
 *
 * Additional arguments:
 *
 *	none
 */
void
ExamineBERType_ObjectIdentifier(AssignmentList_t ass, Type_t *type, BERTypeInfo_t *info)
{
    info->Data = type->PrivateDirectives.fOidPacked ? eBERSTIData_ObjectIdEncoded : eBERSTIData_ObjectIdentifier;
}

/*
 * *String:
 *
 *	Data == eBERSTIData_String ||
 *	Data == eBERSTIData_ZeroString
 *
 * Additional arguments:
 *
 *	- Data == eBERSTIData_*String
 *	  -> NOctets, the size of the string characters
 */

void
ExamineBERType_BMPString(AssignmentList_t ass, Type_t *type, BERTypeInfo_t *info)
{
    uint32_t zero;

    GetStringType(ass, type, &info->NOctets, &zero);
    info->Data = zero ? eBERSTIData_ZeroString : eBERSTIData_String;
}

void
ExamineBERType_GeneralString(AssignmentList_t ass, Type_t *type, BERTypeInfo_t *info)
{
    uint32_t zero;

    GetStringType(ass, type, &info->NOctets, &zero);
    info->Data = zero ? eBERSTIData_ZeroString : eBERSTIData_String;
}

void
ExamineBERType_GraphicString(AssignmentList_t ass, Type_t *type, BERTypeInfo_t *info)
{
    uint32_t zero;

    GetStringType(ass, type, &info->NOctets, &zero);
    info->Data = zero ? eBERSTIData_ZeroString : eBERSTIData_String;
}

void
ExamineBERType_IA5String(AssignmentList_t ass, Type_t *type, BERTypeInfo_t *info)
{
    uint32_t zero;

    GetStringType(ass, type, &info->NOctets, &zero);
    info->Data = zero ? eBERSTIData_ZeroString : eBERSTIData_String;
}

void
ExamineBERType_ISO646String(AssignmentList_t ass, Type_t *type, BERTypeInfo_t *info)
{
    uint32_t zero;

    GetStringType(ass, type, &info->NOctets, &zero);
    info->Data = zero ? eBERSTIData_ZeroString : eBERSTIData_String;
}

void
ExamineBERType_NumericString(AssignmentList_t ass, Type_t *type, BERTypeInfo_t *info)
{
    uint32_t zero;

    GetStringType(ass, type, &info->NOctets, &zero);
    info->Data = zero ? eBERSTIData_ZeroString : eBERSTIData_String;
}

void
ExamineBERType_PrintableString(AssignmentList_t ass, Type_t *type, BERTypeInfo_t *info)
{
    uint32_t zero;

    GetStringType(ass, type, &info->NOctets, &zero);
    info->Data = zero ? eBERSTIData_ZeroString : eBERSTIData_String;
}

void
ExamineBERType_TeletexString(AssignmentList_t ass, Type_t *type, BERTypeInfo_t *info)
{
    uint32_t noctets, zero;

    GetStringType(ass, type, &noctets, &zero); // to make hack directives become effective
    info->Data = eBERSTIData_MultibyteString;
    info->NOctets = 1;
}

void
ExamineBERType_T61String(AssignmentList_t ass, Type_t *type, BERTypeInfo_t *info)
{
    uint32_t noctets, zero;

    GetStringType(ass, type, &noctets, &zero); // to make hack directives become effective
    info->Data = eBERSTIData_MultibyteString;
    info->NOctets = 1;
}

void
ExamineBERType_UniversalString(AssignmentList_t ass, Type_t *type, BERTypeInfo_t *info)
{
    uint32_t zero;

    GetStringType(ass, type, &info->NOctets, &zero);
    info->Data = zero ? eBERSTIData_ZeroString : eBERSTIData_String;
}

void
ExamineBERType_VideotexString(AssignmentList_t ass, Type_t *type, BERTypeInfo_t *info)
{
    uint32_t noctets, zero;

    GetStringType(ass, type, &noctets, &zero); // to make hack directives become effective
    info->Data = eBERSTIData_MultibyteString;
    info->NOctets = 1;
}

void
ExamineBERType_VisibleString(AssignmentList_t ass, Type_t *type, BERTypeInfo_t *info)
{
    uint32_t zero;

    GetStringType(ass, type, &info->NOctets, &zero);
    info->Data = zero ? eBERSTIData_ZeroString : eBERSTIData_String;
}

/*
 * CHARACTER STRING:
 *
 *	Data == eBERSTIData_UnrestrictedString
 *
 * Additional arguments:
 *
 *	- Data == eBERSTIData_EmbeddedPdv ||
 *	  Data == eBERSTIData_UnrestrictedString
 *	  -> Identification, the identification of the type if the type
 *	     is constraint to fixed identification or syntaxes identification
 *	     with single value
 */
void
ExamineBERType_UnrestrictedString(AssignmentList_t ass, Type_t *type, BERTypeInfo_t *info)
{
    info->Data = eBERSTIData_UnrestrictedString;
}

/*
 * GeneralizedTime:
 *
 *	Data == eBERSTIData_GeneralizedTime
 *
 * Additional arguments:
 *
 *	none
 */
void
ExamineBERType_GeneralizedTime(AssignmentList_t ass, Type_t *type, BERTypeInfo_t *info)
{
    info->Data = eBERSTIData_GeneralizedTime;
}

/*
 * UTCTime:
 *
 *	Data == eBERSTIData_UTCTime
 *
 * Additional arguments:
 *
 *	none
 */
void
ExamineBERType_UTCTime(AssignmentList_t ass, Type_t *type, BERTypeInfo_t *info)
{
    info->Data = eBERSTIData_UTCTime;
}

/*
 * ObjectDescriptor:
 *
 *	Data == eBERSTIData_ZeroString
 *
 * Additional arguments:
 *
 *	none
 */
void
ExamineBERType_ObjectDescriptor(AssignmentList_t ass, Type_t *type, BERTypeInfo_t *info)
{
    info->NOctets = 1;
    info->Data = eBERSTIData_ZeroString;
}

/*
 * OpenType:
 *
 *	Data == eBERSTIData_Open
 *
 * Additional arguments:
 *
 *	none
 */
void
ExamineBERType_Open(AssignmentList_t ass, Type_t *type, BERTypeInfo_t *info)
{
    info->NOctets = 1;
    info->Data = eBERSTIData_Open;
}

/*
 * SEQUENCE/SET:
 *
 *	Data == eBERSTIData_Sequence ||
 *	Data == eBERSTIData_Set
 *
 * Additional arguments:
 *
 *	none
 */
void
ExamineBERType_SequenceSet(AssignmentList_t ass, Type_t *type, BERTypeInfo_t *info)
{
    Component_t *comp;
    NamedType_t *namedType;
    char idebuf[256];

    info->Data = (type->Type == eType_Sequence) ?
	eBERSTIData_Sequence : eBERSTIData_Set;

    /* examine types of components */
    for (comp = type->U.SSC.Components; comp; comp = comp->Next) {
	switch (comp->Type) {
	case eComponent_Normal:
	case eComponent_Optional:
	case eComponent_Default:
	    namedType = comp->U.NOD.NamedType;
	    sprintf(idebuf, "%s_%s", info->Identifier, namedType->Identifier);
	    ExamineBERType(ass, namedType->Type, strdup(idebuf));
	    break;
	}
    }
}

/*
 * SEQUENCE OF/SET OF:
 *
 *	Data == eBERSTIData_SequenceOf ||
 *	Data == eBERSTIData_SetOf
 *
 * Additional arguments:
 *
 *	- Data == eBERSTIData_SequenceOf || dat == eBERSTIData_SetOf
 *	  -> SubIdentifier, the name of the subtype
 *	  -> SubType, the subtype itself
 *	  -> Rule, the encoding directive rules
 */
void
ExamineBERType_SequenceSetOf(AssignmentList_t ass, Type_t *type, BERTypeInfo_t *info)
{
    char idebuf[256];

    /* set data type and Alignment */
    info->Data = (type->Type == eType_SequenceOf ?
	eBERSTIData_SequenceOf : eBERSTIData_SetOf);

    /* set SubType, SubIdentifier */
    info->SubType = type->U.SS.Type;
    info->SubIdentifier = GetTypeName(ass, info->SubType);

    /* examine subtype */
    sprintf(idebuf, "%s_%s", info->Identifier,
	type->Type == eType_SequenceOf ? "Sequence" : "Set");
    ExamineBERType(ass, type->U.SS.Type, strdup(idebuf));
}

/*
 * CHOICE:
 *
 *	Data == eBERSTIData_Choice
 *
 * Additional arguments:
 *
 *	- Data == eBERSTIData_Integer || dat == eBERSTIData_Unsigned ||
 *	  Data == eBERSTIData_Boolean || dat == eBERSTIData_Choice
 *	  -> NOctets, the size of the integer type
 */
void
ExamineBERType_Choice(AssignmentList_t ass, Type_t *type, BERTypeInfo_t *info)
{
    Component_t *comp;
    NamedType_t *namedType;
    char idebuf[256];

    info->NOctets = GetOctets(GetChoiceType(type));
    info->Data = eBERSTIData_Choice;

    /* examine types of alternatives */
    for (comp = type->U.SSC.Components; comp; comp = comp->Next) {
	switch (comp->Type) {
	case eComponent_Normal:
	    namedType = comp->U.NOD.NamedType;
	    sprintf(idebuf, "%s_%s", info->Identifier, namedType->Identifier);
	    ExamineBERType(ass, namedType->Type, strdup(idebuf));
	    break;
	}
    }
}

/*
 * INSTANCE OF:
 *
 *	Data == eBERSTIData_Sequence
 *
 * Additional arguments:
 *
 *	none
 */
void
ExamineBERType_InstanceOf(AssignmentList_t ass, Type_t *type, BERTypeInfo_t *info)
{
    Component_t *comp;
    NamedType_t *namedType;
    char idebuf[256];

    info->Data = eBERSTIData_Sequence;

    /* examine types of components */
    for (comp = type->U.SSC.Components; comp; comp = comp->Next) {
	switch (comp->Type) {
	case eComponent_Normal:
	case eComponent_Optional:
	case eComponent_Default:
	    namedType = comp->U.NOD.NamedType;
	    sprintf(idebuf, "%s_%s", info->Identifier, namedType->Identifier);
	    ExamineBERType(ass, namedType->Type, strdup(idebuf));
	    break;
	}
    }
}

/*
 * Reference:
 *
 *	Data == eBERSTIData_Reference
 *
 * Additional arguments:
 *
 *	- Data == eBERSTIData_Reference
 *	  -> SubIdentifier, the name of the subtype
 *	  -> SubType, the subtype itself
 */
void
ExamineBERType_Reference(AssignmentList_t ass, Type_t *type, BERTypeInfo_t *info)
{
    Assignment_t *a;

    info->Data = eBERSTIData_Reference;
    a = GetAssignment(ass, FindAssignment(ass, eAssignment_Type,
	type->U.Reference.Identifier, type->U.Reference.Module));
    info->SubIdentifier = GetName(a);
    info->SubType = a->U.Type.Type;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\asn1\asn1c\defs.c ===
/* Copyright (C) Boris Nikolaus, Germany, 1996-1997. All rights reserved. */
/* Copyright (C) Microsoft Corporation, 1997-1998. All rights reserved. */

#include "precomp.h"
#include "error.h"


/* allocate a new value of type _T, copy *_src and return this duplicate */
#define RETDUP(_T, _src) _T *ret; ret = (_T *)malloc(sizeof(_T)); *ret = *(_src); return ret

/* constructor of Assignment_t */
Assignment_t *
NewAssignment(Assignment_e type)
{
    Assignment_t *ret;

    ret = (Assignment_t *)malloc(sizeof(Assignment_t));
    if (! ret)
        return NULL;

    memset(ret, 0, sizeof(Assignment_t));
    // ret->Next = NULL;
    // ret->Identifier = NULL;
    // ret->Module = NULL;
    // ret->Flags = 0;
    // ret->fImportedLocalDuplicate = 0;
    // ret->fGhost = 0;
    ret->eDefTagType = eTagType_Unknown;
    ret->Type = type;
    switch (type) {
    case eAssignment_Undefined:
        break;
    case eAssignment_ModuleIdentifier:
        break;
    case eAssignment_Type:
        // ret->U.Type.Type = NULL;
        break;
    case eAssignment_Value:
        // ret->U.Value.Value = NULL;
        break;
    case eAssignment_ObjectClass:
        // ret->U.ObjectClass.ObjectClass = NULL;
        break;
    case eAssignment_Object:
        // ret->U.Object.Object = NULL;
        break;
    case eAssignment_ObjectSet:
        // ret->U.ObjectSet.ObjectSet = NULL;
        break;
    case eAssignment_Reference:
        // ret->U.Reference.Identifier = NULL;
        // ret->U.Reference.Module = NULL;
        break;
    }
    return ret;
}

/* copy constructor of Assignment_t */
Assignment_t *
DupAssignment(Assignment_t *src)
{
    RETDUP(Assignment_t, src);
}

/* find an assignment by name+moduleidentifier in an assignment list */
Assignment_t *
FindAssignment(AssignmentList_t ass, Assignment_e type, char *identifier, ModuleIdentifier_t *module)
{
    Assignment_t *a;
    Assignment_e at;

    for (a = ass; a; a = a->Next) {
        if (a->Type == eAssignment_NextPass)
            continue;
        if (type == eAssignment_Undefined) {
            at = eAssignment_Undefined;
        } else {
            at = GetAssignmentType(ass, a);
        }
        if (at == type &&
            !strcmp(a->Identifier, identifier) &&
            !CmpModuleIdentifier(ass, a->Module, module))
            return a;
    }
    return NULL;
}

/* find an exported assignment by name+moduleidentifier in an assignment list */
Assignment_t *
FindExportedAssignment(AssignmentList_t ass, Assignment_e type, char *identifier, ModuleIdentifier_t *module)
{
    Assignment_t *a;
    Assignment_e at;

    for (a = ass; a; a = a->Next) {
        if (a->Type == eAssignment_NextPass ||
            !(a->Flags & eAssignmentFlags_Exported))
            continue;
        if (type == eAssignment_Undefined) {
            at = eAssignment_Undefined;
        } else {
            at = GetAssignmentType(ass, a);
        }
        if (at == type &&
            !strcmp(a->Identifier, identifier) &&
            !CmpModuleIdentifier(ass, a->Module, module))
            return a;
    }
    return NULL;
}

/* find an assignment by name+moduleidentifier in an assignment list */
/* do not use assignments of previous parsing passes */
Assignment_t *
FindAssignmentInCurrentPass(AssignmentList_t ass, char *identifier, ModuleIdentifier_t *module)
{
    for (; ass; ass = ass->Next) {
        if (ass->Type == eAssignment_NextPass)
            return NULL;
        if (!strcmp(ass->Identifier, identifier) &&
            !CmpModuleIdentifier(ass, ass->Module, module))
            return ass;
    }
    return NULL;
}

/* resolve assignment references */
Assignment_t *
GetAssignment(AssignmentList_t ass, Assignment_t *a)
{
    while (a && a->Type == eAssignment_Reference) {
        a = FindAssignment(ass, eAssignment_Undefined,
            a->U.Reference.Identifier, a->U.Reference.Module);
    }
    return a;
}

/* get type of an assignment */
Assignment_e
GetAssignmentType(AssignmentList_t ass, Assignment_t *a)
{
    a = GetAssignment(ass, a);
    return a ? a->Type : eAssignment_Undefined;
}

/* assign a type */
/* lhs must be an type reference */
/* returns 0 if type is already defined in current parser pass */
int
AssignType(AssignmentList_t *ass, Type_t *lhs, Type_t *rhs)
{
    Assignment_t *a;

    if (lhs->Type != eType_Reference)
        MyAbort();
    for (a = *ass; a && a->Type != eAssignment_NextPass; a = a->Next) {
        if (a->Type == eAssignment_Type &&
            !strcmp(a->Identifier, lhs->U.Reference.Identifier) &&
            !CmpModuleIdentifier(*ass, a->Module, lhs->U.Reference.Module))
            return 0;
    }
    // propagate the directives from rhs to lhs
    PropagatePrivateDirectives(lhs, &(rhs->PrivateDirectives));
    // create new assignment
    a = NewAssignment(eAssignment_Type);
    a->Identifier = lhs->U.Reference.Identifier;
    a->Module = lhs->U.Reference.Module;
    a->U.Type.Type = rhs;
    a->Next = *ass;
    *ass = a;
    return 1;
}

/* assign a value */
/* lhs must be an value reference */
/* returns 0 if value is already defined in current parser pass */
int
AssignValue(AssignmentList_t *ass, Value_t *lhs, Value_t *rhs)
{
    Assignment_t *a;

    if (lhs->Type)
        MyAbort();
    for (a = *ass; a && a->Type != eAssignment_NextPass; a = a->Next) {
        if (a->Type == eAssignment_Value &&
            !strcmp(a->Identifier, lhs->U.Reference.Identifier) &&
            !CmpModuleIdentifier(*ass, a->Module, lhs->U.Reference.Module))
            return 0;
    }
    a = NewAssignment(eAssignment_Value);
    a->Identifier = lhs->U.Reference.Identifier;
    a->Module = lhs->U.Reference.Module;
    a->U.Value.Value = rhs;
    ASSERT(rhs);
    if (rhs->Type && rhs->Type->Type == eType_ObjectIdentifier)
    {
        AddDefinedOID(a->Identifier, rhs);
    }
    a->Next = *ass;
    *ass = a;
    return 1;
}

/* assign a object class */
/* lhs must be an object class reference */
/* returns 0 if object class is already defined in current parser pass */
int
AssignObjectClass(AssignmentList_t *ass, ObjectClass_t *lhs, ObjectClass_t *rhs)
{
    Assignment_t *a;

    if (lhs->Type != eObjectClass_Reference)
        MyAbort();
    for (a = *ass; a && a->Type != eAssignment_NextPass; a = a->Next) {
        if (a->Type == eAssignment_ObjectClass &&
            !strcmp(a->Identifier, lhs->U.Reference.Identifier) &&
            !CmpModuleIdentifier(*ass, a->Module, lhs->U.Reference.Module))
            return 0;
    }
    a = NewAssignment(eAssignment_ObjectClass);
    a->Identifier = lhs->U.Reference.Identifier;
    a->Module = lhs->U.Reference.Module;
    a->U.ObjectClass.ObjectClass = rhs;
    a->Next = *ass;
    *ass = a;
    return 1;
}

/* assign a object */
/* lhs must be an object reference */
/* returns 0 if object is already defined in current parser pass */
int
AssignObject(AssignmentList_t *ass, Object_t *lhs, Object_t *rhs)
{
    Assignment_t *a;

    if (lhs->Type != eObject_Reference)
        MyAbort();
    for (a = *ass; a && a->Type != eAssignment_NextPass; a = a->Next) {
        if (a->Type == eAssignment_Object &&
            !strcmp(a->Identifier, lhs->U.Reference.Identifier) &&
            !CmpModuleIdentifier(*ass, a->Module, lhs->U.Reference.Module))
            return 0;
    }
    a = NewAssignment(eAssignment_Object);
    a->Identifier = lhs->U.Reference.Identifier;
    a->Module = lhs->U.Reference.Module;
    a->U.Object.Object = rhs;
    a->Next = *ass;
    *ass = a;
    return 1;
}

/* assign a object set */
/* lhs must be an object set reference */
/* returns 0 if type is already defined in current parser pass */
int
AssignObjectSet(AssignmentList_t *ass, ObjectSet_t *lhs, ObjectSet_t *rhs)
{
    Assignment_t *a;

    if (lhs->Type != eObjectSet_Reference)
        MyAbort();
    for (a = *ass; a && a->Type != eAssignment_NextPass; a = a->Next) {
        if (a->Type == eAssignment_ObjectSet &&
            !strcmp(a->Identifier, lhs->U.Reference.Identifier) &&
            !CmpModuleIdentifier(*ass, a->Module, lhs->U.Reference.Module))
            return 0;
    }
    a = NewAssignment(eAssignment_ObjectSet);
    a->Identifier = lhs->U.Reference.Identifier;
    a->Module = lhs->U.Reference.Module;
    a->U.ObjectSet.ObjectSet = rhs;
    a->Next = *ass;
    *ass = a;
    return 1;
}

/* assign a macro */
/* lhs must be an macro reference */
/* returns 0 if macro is already defined in current parser pass */
int
AssignMacro(AssignmentList_t *ass, Macro_t *lhs, Macro_t *rhs)
{
    Assignment_t *a;

    if (lhs->Type != eMacro_Reference)
        MyAbort();
    for (a = *ass; a && a->Type != eAssignment_NextPass; a = a->Next) {
        if (a->Type == eAssignment_Macro &&
            !strcmp(a->Identifier, lhs->U.Reference.Identifier) &&
            !CmpModuleIdentifier(*ass, a->Module, lhs->U.Reference.Module))
            return 0;
    }
    a = NewAssignment(eAssignment_Macro);
    a->Identifier = lhs->U.Reference.Identifier;
    a->Module = lhs->U.Reference.Module;
    a->U.Macro.Macro = rhs;
    a->Next = *ass;
    *ass = a;
    return 1;
}

/* define a module identifier */
/* returns 0 if module identifier is already defined in current parser pass */
int
AssignModuleIdentifier(AssignmentList_t *ass, ModuleIdentifier_t *module)
{
    Assignment_t *a;

    for (a = *ass; a && a->Type != eAssignment_NextPass; a = a->Next) {
        if (a->Type == eAssignment_ModuleIdentifier &&
            !CmpModuleIdentifier(*ass, a->Module, module))
            return 0;
    }
    a = NewAssignment(eAssignment_ModuleIdentifier);
    a->Identifier = "<module>";
    a->Module = module;
    a->Next = *ass;
    *ass = a;
    return 1;
}

/* constructor of UndefinedSymbol_t */
UndefinedSymbol_t *
NewUndefinedSymbol(UndefinedSymbol_e type, Assignment_e reftype)
{
    UndefinedSymbol_t *ret;

    ret = (UndefinedSymbol_t *)malloc(sizeof(UndefinedSymbol_t));
    if (! ret)
        return NULL;

    memset(ret, 0, sizeof(UndefinedSymbol_t));
    ret->Type = type;
    ret->U.Symbol.ReferenceType = reftype;
    // ret->U.Symbol.Identifier = NULL;
    // ret->U.Symbol.Module = NULL;
    // ret->Next = NULL;
    return ret;
}

/* constructor of UndefinedSymbol_t */
UndefinedSymbol_t *
NewUndefinedField(UndefinedSymbol_e type, ObjectClass_t *oc, Settings_e reffieldtype)
{
    UndefinedSymbol_t *ret;

    if (oc->Type != eObjectClass_Reference)
        MyAbort();
    ret = (UndefinedSymbol_t *)malloc(sizeof(UndefinedSymbol_t));
    if (! ret)
        return NULL;

    memset(ret, 0, sizeof(UndefinedSymbol_t));
    ret->Type = type;
    ret->U.Field.ReferenceFieldType = reffieldtype;
    // ret->U.Field.Identifier = NULL;
    // ret->U.Field.Module = NULL;
    ret->U.Field.ObjectClass = oc;
    // ret->Next = NULL;
    return ret;
}

/* find an undefined symbol by type/name/moduleidentifier in a list of */
/* undefined symbols */
UndefinedSymbol_t *
FindUndefinedSymbol(AssignmentList_t ass, UndefinedSymbolList_t u, Assignment_e type, char *ide, ModuleIdentifier_t *mod)
{
    for (; u; u = u->Next) {
        if (u->Type != eUndefinedSymbol_SymbolNotDefined &&
            u->Type != eUndefinedSymbol_SymbolNotExported)
            continue;
        if ((type == eAssignment_Undefined ||
            u->U.Symbol.ReferenceType == eAssignment_Undefined ||
            u->U.Symbol.ReferenceType == type) &&
            !strcmp(u->U.Symbol.Identifier, ide) &&
            !CmpModuleIdentifier(ass, u->U.Field.Module, mod))
            return u;
    }
    return NULL;
}

/* find an undefined field by type/objectclass/name/moduleidentifier in a */
/* list of undefined symbols */
UndefinedSymbol_t *
FindUndefinedField(AssignmentList_t ass, UndefinedSymbolList_t u, Settings_e fieldtype, ObjectClass_t *oc, char *ide, ModuleIdentifier_t *mod)
{
    for (; u; u = u->Next) {
        if (u->Type != eUndefinedSymbol_FieldNotDefined &&
            u->Type != eUndefinedSymbol_FieldNotExported)
            continue;
        if ((fieldtype == eSetting_Undefined ||
            u->U.Field.ReferenceFieldType == eSetting_Undefined ||
            u->U.Field.ReferenceFieldType == fieldtype) &&
            !strcmp(u->U.Field.Identifier, ide) &&
            GetObjectClass(ass, oc) ==
            GetObjectClass(ass, u->U.Field.ObjectClass) &&
            !CmpModuleIdentifier(ass, u->U.Field.Module, mod))
            return u;
    }
    return NULL;
}

/* constructor of Type_t */
Type_t *
NewType(Type_e type)
{
    Type_t *ret;

    ret = (Type_t *)malloc(sizeof(Type_t));
    if (! ret)
        return NULL;

    memset(ret, 0, sizeof(Type_t));
    ret->Type = type;
    // ret->Tags = NULL;
    // ret->AllTags = NULL;
    // ret->FirstTags = NULL;
    // ret->Constraints = NULL;
    // ret->Directives = NULL;
    // ret->Flags = 0;
    ret->Rules = eTypeRules_Normal;
    ret->TagDefault = eTagType_Unknown;
    ret->ExtensionDefault = eExtensionType_None;
    ret->PERConstraints.Value.Type = eExtension_Unconstrained;
    // ret->PERConstraints.Value.Root = NULL;
    // ret->PERConstraints.Value.Additional = NULL;
    ret->PERConstraints.Size.Type = eExtension_Unconstrained;
    // ret->PERConstraints.Size.Root = NULL;
    // ret->PERConstraints.Size.Additional = NULL;
    ret->PERConstraints.PermittedAlphabet.Type = eExtension_Unconstrained;
    // ret->PERConstraints.PermittedAlphabet.Root = NULL;
    // ret->PERConstraints.PermittedAlphabet.Additional = NULL;
    // ret->PrivateDirectives = { 0 };
    switch (type) {
    case eType_Boolean:
        break;
    case eType_Integer:
    case eType_Enumerated:
    case eType_BitString:
        // ret->U.IEB.NamedNumbers = NULL;
        break;
    case eType_OctetString:
    case eType_UTF8String:
        break;
    case eType_Null:
        break;
    case eType_Sequence:
    case eType_Set:
    case eType_Choice:
    case eType_Real:
    case eType_EmbeddedPdv:
    case eType_External:
    case eType_CharacterString:
    case eType_InstanceOf:
        // ret->U.SSC.Components = NULL;
        // ret->U.SSC.Optionals = 0;
        // ret->U.SSC.Alternatives = 0;
        // ret->U.SSC.Extensions = 0;
        // ret->U.SSC.Autotag[0] = 0;
        // ret->U.SSC.Autotag[1] = 0;
        break;
    case eType_SequenceOf:
    case eType_SetOf:
        // ret->U.SS.Type = NULL;
        // ret->U.SS.Directives = NULL;
        break;
    case eType_Selection:
        // ret->U.Selection.Identifier = NULL;
        // ret->U.Selection.Type = NULL;
        break;
    case eType_ObjectIdentifier:
        break;
    case eType_BMPString:
        break;
    case eType_GeneralString:
        break;
    case eType_GraphicString:
        break;
    case eType_IA5String:
        break;
    case eType_ISO646String:
        break;
    case eType_NumericString:
        break;
    case eType_PrintableString:
        break;
    case eType_TeletexString:
        break;
    case eType_T61String:
        break;
    case eType_UniversalString:
        break;
    case eType_VideotexString:
        break;
    case eType_VisibleString:
        break;
    case eType_GeneralizedTime:
        break;
    case eType_UTCTime:
        break;
    case eType_ObjectDescriptor:
        break;
    case eType_Undefined:
        break;
    case eType_RestrictedString:
        break;
    case eType_Reference:
        // ret->U.Reference.Identifier = NULL;
        // ret->U.Reference.Module = NULL;
        break;
    case eType_FieldReference:
        // ret->U.FieldReference.ObjectClass = NULL;
        // ret->U.FieldReference.Identifier = NULL;
        break;
    case eType_Macro:
        // ret->U.Macro.Macro = NULL;
        // ret->U.Macro.LocalAssignments = NULL;
        break;
    }
    return ret;
}

/* copy constructor of Type_t */
Type_t *
DupType(Type_t *src)
{
    RETDUP(Type_t, src);
}

/* resolve field reference */
FieldSpec_t *
GetReferencedFieldSpec(AssignmentList_t ass, Type_t *type, ObjectClass_t **objectclass)
{
    FieldSpec_t *fs;
    ObjectClass_t *oc;

    if (type->Type != eType_FieldReference)
        MyAbort();
    oc = type->U.FieldReference.ObjectClass;
    oc = GetObjectClass(ass, oc);
    if (!oc)
        return NULL;
    fs = GetFieldSpec(ass, FindFieldSpec(oc->U.ObjectClass.FieldSpec,
        type->U.FieldReference.Identifier));
    if (!fs)
        return NULL;
    if (fs->Type == eFieldSpec_Object)
        oc = fs->U.Object.ObjectClass;
    else if (fs->Type == eFieldSpec_ObjectSet)
        oc = fs->U.ObjectSet.ObjectClass;
    else
        return NULL;
    if (objectclass)
        *objectclass = oc;
    return GetFieldSpec(ass, fs);
}

/* resolve type reference */
Type_t *
GetReferencedType(AssignmentList_t ass, Type_t *type)
{
    Assignment_t *a;
    FieldSpec_t *fs;

    switch (type->Type) {
    case eType_Reference:
        a = FindAssignment(ass, eAssignment_Type, type->U.Reference.Identifier,
            type->U.Reference.Module);
        a = GetAssignment(ass, a);
        if (!a)
            return NULL;
        return a->U.Type.Type;
    case eType_FieldReference:
        fs = GetReferencedFieldSpec(ass, type, NULL);
        if (!fs)
            return NULL;
        switch (fs->Type) {
        case eFieldSpec_FixedTypeValue:
            return fs->U.FixedTypeValue.Type;
        case eFieldSpec_FixedTypeValueSet:
            return fs->U.FixedTypeValueSet.Type;
        case eFieldSpec_Type:
        case eFieldSpec_VariableTypeValue:
        case eFieldSpec_VariableTypeValueSet:
            return Builtin_Type_Open;
        default:
            return NULL;
        }
        /*NOTREACHED*/
    default:
        MyAbort();
        /*NOTREACHED*/
    }
    return NULL;
}

/* constructor of Component_t */
Component_t *
NewComponent(Components_e type)
{
    Component_t *ret;

    ret = (Component_t *)malloc(sizeof(Component_t));
    if (! ret)
        return NULL;

    memset(ret, 0, sizeof(Component_t));
    ret->Type = type;
    // ret->Next = NULL;
    switch (type) {
    case eComponent_Normal:
        // ret->U.Normal.NamedType = NULL;
        break;
    case eComponent_Optional:
        // ret->U.Optional.NamedType = NULL;
        break;
    case eComponent_Default:
        // ret->U.Default.NamedType = NULL;
        // ret->U.Default.Value = NULL;
        break;
    case eComponent_ComponentsOf:
        // ret->U.ComponentsOf.Type = NULL;
        break;
    case eComponent_ExtensionMarker:
        /*ret->U.ExtensionMarker.ExceptionSpec = NULL;*/
        break;
    }
    return ret;
}

/* copy constructor of Component_t */
Component_t *
DupComponent(Component_t *src)
{
    RETDUP(Component_t, src);
}

/* find a component by name in a list of components */
Component_t *
FindComponent(AssignmentList_t ass, ComponentList_t components, char *identifier)
{
    Component_t *c;
    NamedType_t *namedType;

    while (components) {
        switch (components->Type) {
        case eComponent_Normal:
        case eComponent_Optional:
        case eComponent_Default:
            namedType = components->U.NOD.NamedType;
            if (namedType && !strcmp(namedType->Identifier, identifier))
                return components;
            break;
        case eComponent_ComponentsOf:
            switch (GetTypeType(ass, components->U.ComponentsOf.Type)) {
            case eType_Sequence:
            case eType_Set:
            case eType_Choice:
            case eType_External:
            case eType_EmbeddedPdv:
            case eType_CharacterString:
            case eType_Real:
            case eType_InstanceOf:
                c = FindComponent(ass,
                    GetType(ass, components->U.ComponentsOf.Type)->
                    U.SSC.Components, identifier);
                if (c)
                    return c;
                break;
            default:
                break;
            }
            break;
        }
        components = components->Next;
    }
    return NULL;
}

/* constructor of NamedType_t */
NamedType_t *
NewNamedType(char *identifier, Type_t *type)
{
    NamedType_t *ret;

    ret = (NamedType_t *)malloc(sizeof(NamedType_t));
    if (! ret)
        return NULL;

    ret->Type = type;
    ret->Identifier = identifier;
    return ret;
}

/* constructor of NamedValue_t */
NamedValue_t *
NewNamedValue(char *identifier, Value_t *value)
{
    NamedValue_t *ret;

    ret = (NamedValue_t *)malloc(sizeof(NamedValue_t));
    if (! ret)
        return NULL;

    ret->Next = NULL;
    ret->Value = value;
    ret->Identifier = identifier;
    return ret;
}

/* copy constructor of NamedValue_t */
NamedValue_t *
DupNamedValue(NamedValue_t *src)
{
    RETDUP(NamedValue_t, src);
}

/* find a named value by name in a list of named values */
NamedValue_t *
FindNamedValue(NamedValueList_t namedValues, char *identifier)
{
    for (; namedValues; namedValues = namedValues->Next) {
        if (!strcmp(namedValues->Identifier, identifier))
            return namedValues;
    }
    return NULL;
}

/* constructor of NamedNumber_t */
NamedNumber_t *
NewNamedNumber(NamedNumbers_e type)
{
    NamedNumber_t *ret;

    ret = (NamedNumber_t *)malloc(sizeof(NamedNumber_t));
    if (! ret)
        return NULL;

    memset(ret, 0, sizeof(NamedNumber_t));
    // ret->Next = NULL;
    ret->Type = type;
    switch (type) {
    case eNamedNumber_Normal:
        // ret->U.Normal.Identifier = NULL;
        // ret->U.Normal.Value = NULL;
        break;
    case eNamedNumber_ExtensionMarker:
        /*XXX*/
        break;
    }
    return ret;
}

/* copy constructor of NamedNumber_t */
NamedNumber_t *
DupNamedNumber(NamedNumber_t *src)
{
    RETDUP(NamedNumber_t, src);
}

/* find a named number by name in a list of named numbers */
NamedNumber_t *
FindNamedNumber(NamedNumberList_t namedNumbers, char *identifier)
{
    for (; namedNumbers; namedNumbers = namedNumbers->Next) {
        switch (namedNumbers->Type) {
        case eNamedNumber_Normal:
            if (!strcmp(namedNumbers->U.Normal.Identifier, identifier))
                return namedNumbers;
            break;
        case eNamedNumber_ExtensionMarker:
            break;
        }
    }
    return NULL;
}

/* constructor of Value_t */
Value_t *
NewValue(AssignmentList_t ass, Type_t *type)
{
    Value_t *ret;

    ret = (Value_t *)malloc(sizeof(Value_t));
    if (! ret)
        return NULL;

    memset(ret, 0, sizeof(Value_t));
    // ret->Next = NULL;
    ret->Type = type;
    if (type) {
        // ret->Flags = 0;
        switch (GetTypeType(ass, type)) {
        case eType_Boolean:
            // ret->U.Boolean.Value = 0;
            break;
        case eType_Integer:
            ret->U.Integer.Value.length = 1;
            ret->U.Integer.Value.value = (octet_t *)malloc(1);
            // ret->U.Integer.Value.value[0] = 0;
            break;
        case eType_Enumerated:
            // ret->U.Enumerated.Value = 0;
            break;
        case eType_Real:
            ret->U.Real.Value.type = eReal_Normal;
            intx_setuint32(&ret->U.Real.Value.mantissa, 0);
            intx_setuint32(&ret->U.Real.Value.exponent, 0);
            ret->U.Real.Value.base = 2;
            break;
        case eType_BitString:
            // ret->U.BitString.Value.length = 0;
            // ret->U.BitString.Value.value = NULL;
            break;
        case eType_OctetString:
        case eType_UTF8String:
            // ret->U.OctetString.Value.length = 0;
            // ret->U.OctetString.Value.value = NULL;
            break;
        case eType_Null:
            break;
        case eType_SequenceOf:
        case eType_SetOf:
            // ret->U.SS.Values = NULL;
            break;
        case eType_Sequence:
        case eType_Set:
        case eType_Choice:
        case eType_EmbeddedPdv:
        case eType_External:
        case eType_CharacterString:
        case eType_InstanceOf:
            // ret->U.SSC.NamedValues = NULL;
            break;
        case eType_Selection:
            break;
        case eType_ObjectIdentifier:
            break;
        case eType_BMPString:
            break;
        case eType_GeneralString:
            break;
        case eType_GraphicString:
            break;
        case eType_IA5String:
            break;
        case eType_ISO646String:
            break;
        case eType_NumericString:
            break;
        case eType_PrintableString:
            break;
        case eType_TeletexString:
            break;
        case eType_T61String:
            break;
        case eType_UniversalString:
            break;
        case eType_VideotexString:
            break;
        case eType_VisibleString:
            break;
        case eType_GeneralizedTime:
            break;
        case eType_UTCTime:
            break;
        case eType_ObjectDescriptor:
            break;
        case eType_Undefined:
            break;
        }
    } else {
        // ret->U.Reference.Identifier = NULL;
        // ret->U.Reference.Module = NULL;
    }
    return ret;
}

/* copy constructor of Value_t */
Value_t *
DupValue(Value_t *src)
{
    RETDUP(Value_t, src);
}

/* constructor of ValueSet_t */
ValueSet_t *
NewValueSet()
{
    ValueSet_t *ret;

    ret = (ValueSet_t *)malloc(sizeof(ValueSet_t));
    if (! ret)
        return NULL;

    memset(ret, 0, sizeof(ValueSet_t));
    // ret->Elements = NULL;
    return ret;
}

/* copy constructor of ValueSet_t */
ValueSet_t *
DupValueSet(ValueSet_t *src)
{
    RETDUP(ValueSet_t, src);
}

/* constructor of Macro_t */
Macro_t *
NewMacro(Macro_e type)
{
    Macro_t *ret;

    ret = (Macro_t *)malloc(sizeof(Macro_t));
    if (! ret)
        return NULL;

    ret->Type = type;
    return ret;
}

/* copy constructor of Macro_t */
Macro_t *
DupMacro(Macro_t *src)
{
    RETDUP(Macro_t, src);
}

/* constructor of MacroProduction_t */
MacroProduction_t *
NewMacroProduction(MacroProduction_e type)
{
    MacroProduction_t *ret;

    ret = (MacroProduction_t *)malloc(sizeof(MacroProduction_t));
    if (! ret)
        return NULL;

    memset(ret, 0, sizeof(MacroProduction_t));
    ret->Type = type;
    switch (type) {
    case eMacroProduction_Alternative:
        // ret->U.Alternative.Production1 = NULL;
        // ret->U.Alternative.Production2 = NULL;
        break;
    case eMacroProduction_Sequence:
        // ret->U.Sequence.Production1 = NULL;
        // ret->U.Sequence.Production2 = NULL;
        break;
    case eMacroProduction_AString:
        // ret->U.AString.String = NULL;
        break;
    case eMacroProduction_ProductionReference:
        // ret->U.ProductionReference.Reference = NULL;
        break;
    case eMacroProduction_String:
    case eMacroProduction_Identifier:
    case eMacroProduction_Number:
    case eMacroProduction_Empty:
        break;
    case eMacroProduction_Type:
        // ret->U.Type.LocalTypeReference = NULL;
        break;
    case eMacroProduction_Value:
        // ret->U.Value.LocalTypeReference = NULL;
        // ret->U.Value.LocalValueReference = NULL;
        // ret->U.Value.Type = NULL;
        break;
    case eMacroProduction_LocalTypeAssignment:
        // ret->U.LocalTypeAssignment.LocalTypeReference = NULL;
        // ret->U.LocalTypeAssignment.Type = NULL;
        break;
    case eMacroProduction_LocalValueAssignment:
        // ret->U.LocalValueAssignment.LocalValueReference = NULL;
        // ret->U.LocalValueAssignment.Value = NULL;
        break;
    }
    return ret;
}

/* copy constructor of MacroProduction_t */
MacroProduction_t *
DupMacroProduction(MacroProduction_t *src)
{
    RETDUP(MacroProduction_t, src);
}

/* constructor of NamedMacroProduction_t */
NamedMacroProduction_t *
NewNamedMacroProduction()
{
    NamedMacroProduction_t *ret;

    ret = (NamedMacroProduction_t *)malloc(sizeof(NamedMacroProduction_t));
    if (! ret)
        return NULL;

    memset(ret, 0, sizeof(NamedMacroProduction_t));
    // ret->Next = NULL;
    // ret->Identifier = NULL;
    // ret->Production = NULL;
    return ret;
}

/* copy constructor of NamedMacroProduction */
NamedMacroProduction_t *
DupNamedMacroProduction(NamedMacroProduction_t *src)
{
    RETDUP(NamedMacroProduction_t, src);
}

/* constructor of MacroLocalAssignment_t */
MacroLocalAssignment_t *
NewMacroLocalAssignment(MacroLocalAssignment_e type)
{
    MacroLocalAssignment_t *ret;

    ret = (MacroLocalAssignment_t *)malloc(sizeof(MacroLocalAssignment_t));
    if (! ret)
        return NULL;

    memset(ret, 0, sizeof(MacroLocalAssignment_t));
    // ret->Next = NULL;
    ret->Type = type;
    // ret->Identifier = NULL;
    switch (type) {
    case eMacroLocalAssignment_Type:
        // ret->U.Type = NULL;
        break;
    case eMacroLocalAssignment_Value:
        // ret->U.Value = NULL;
        break;
    }
    return ret;
}

/* copy constructor of MacroLocalAssignment_t */
MacroLocalAssignment_t *
DupMacroLocalAssignment(MacroLocalAssignment_t *src)
{
    RETDUP(MacroLocalAssignment_t, src);
}

/* find a macrolocalassignment by name in a list of macrolocalassignments */
MacroLocalAssignment_t *
FindMacroLocalAssignment(MacroLocalAssignmentList_t la, char *ide)
{
    for (; la; la = la->Next) {
        if (!strcmp(la->Identifier, ide))
            break;
    }
    return la;
}

/* constructor of EndPoint_t */
EndPoint_t *
NewEndPoint()
{
    EndPoint_t *ret;

    ret = (EndPoint_t *)malloc(sizeof(EndPoint_t));
    if (! ret)
        return NULL;

    memset(ret, 0, sizeof(EndPoint_t));
    // ret->Flags = 0;
    // ret->Value = NULL;
    return ret;
}

/* constructor of Constraint_t */
Constraint_t *
NewConstraint()
{
    Constraint_t *ret;

    ret = (Constraint_t *)malloc(sizeof(Constraint_t));
    if (! ret)
        return NULL;

    memset(ret, 0, sizeof(Constraint_t));
    ret->Type = eExtension_Unextended;
    // ret->Root = NULL;
    // ret->Additional = NULL;
    return ret;
}

/* copy constructor of Constraint_t */
Constraint_t *DupConstraint(Constraint_t *src)
{
    RETDUP(Constraint_t, src);
}

/* constructor of ElementSetSpec_t */
ElementSetSpec_t *
NewElementSetSpec(ElementSetSpec_e type)
{
    ElementSetSpec_t *ret;

    ret = (ElementSetSpec_t *)malloc(sizeof(ElementSetSpec_t));
    if (! ret)
        return NULL;

    memset(ret, 0, sizeof(ElementSetSpec_t));
    ret->Type = type;
    switch (type) {
    case eElementSetSpec_AllExcept:
        // ret->U.AllExcept.Elements = NULL;
        break;
    case eElementSetSpec_Union:
        // ret->U.Union.Elements1 = NULL;
        // ret->U.Union.Elements2 = NULL;
        break;
    case eElementSetSpec_Intersection:
        // ret->U.Intersection.Elements1 = NULL;
        // ret->U.Intersection.Elements2 = NULL;
        break;
    case eElementSetSpec_Exclusion:
        // ret->U.Exclusion.Elements1 = NULL;
        // ret->U.Exclusion.Elements2 = NULL;
        break;
    case eElementSetSpec_SubtypeElement:
        // ret->U.SubtypeElement.SubtypeElement = NULL;
        break;
    case eElementSetSpec_ObjectSetElement:
        // ret->U.ObjectSetElement.ObjectSetElement = NULL;
        break;
    default:
        MyAbort();
    }
    return ret;
}

/* constructor of SubtypeElement_t */
SubtypeElement_t *
NewSubtypeElement(SubtypeElement_e type)
{
    SubtypeElement_t *ret;

    ret = (SubtypeElement_t *)malloc(sizeof(SubtypeElement_t));
    if (! ret)
        return NULL;

    memset(ret, 0, sizeof(SubtypeElement_t));
    ret->Type = type;
    switch (type) {
    case eSubtypeElement_ValueRange:
        ret->U.ValueRange.Lower.Flags = eEndPoint_Min;
        // ret->U.ValueRange.Lower.Value = NULL;
        ret->U.ValueRange.Upper.Flags = eEndPoint_Max;
        // ret->U.ValueRange.Upper.Value = NULL;
        break;
    case eSubtypeElement_Size:
        // ret->U.Size.Constraints = NULL;
        break;
    case eSubtypeElement_SingleValue:
        // ret->U.SingleValue.Value = NULL;
        break;
    case eSubtypeElement_PermittedAlphabet:
        // ret->U.PermittedAlphabet.Constraints = NULL;
        break;
    case eSubtypeElement_ContainedSubtype:
        // ret->U.ContainedSubtype.Type = NULL;
        break;
    case eSubtypeElement_Type:
        // ret->U.Type.Type = NULL;
        break;
    case eSubtypeElement_SingleType:
        // ret->U.SingleType.Constraints = NULL;
        break;
    case eSubtypeElement_FullSpecification:
        // ret->U.FullSpecification.NamedConstraints = NULL;
        break;
    case eSubtypeElement_PartialSpecification:
        // ret->U.PartialSpecification.NamedConstraints = NULL;
        break;
    case eSubtypeElement_ElementSetSpec:
        // ret->U.ElementSetSpec.ElementSetSpec = NULL;
        break;
    }
    return ret;
}

/* constructor of ObjectSetElement_t */
ObjectSetElement_t *NewObjectSetElement(ObjectSetElement_e type)
{
    ObjectSetElement_t *ret;

    ret = (ObjectSetElement_t *)malloc(sizeof(ObjectSetElement_t));
    if (! ret)
        return NULL;

    memset(ret, 0, sizeof(ObjectSetElement_t));
    ret->Type = type;
    switch (type) {
    case eObjectSetElement_Object:
        // ret->U.Object.Object = NULL;
        break;
    case eObjectSetElement_ObjectSet:
        // ret->U.ObjectSet.ObjectSet = NULL;
        break;
    case eObjectSetElement_ElementSetSpec:
        // ret->U.ElementSetSpec.ElementSetSpec = NULL;
        break;
    }
    return ret;
}

/* constructor of ValueConstraint_t */
ValueConstraint_t *
NewValueConstraint()
{
    ValueConstraint_t *ret;

    ret = (ValueConstraint_t *)malloc(sizeof(ValueConstraint_t));
    if (! ret)
        return NULL;

    memset(ret, 0, sizeof(ValueConstraint_t));
    // ret->Next = NULL;
    // ret->Lower.Flags = ret->Upper.Flags = 0;
    // ret->Lower.Value = ret->Upper.Value = NULL;
    return ret;
}

/* constructor of NamedConstraint_t */
NamedConstraint_t *
NewNamedConstraint()
{
    NamedConstraint_t *ret;

    ret = (NamedConstraint_t *)malloc(sizeof(NamedConstraint_t));
    if (! ret)
        return NULL;

    memset(ret, 0, sizeof(NamedConstraint_t));
    // ret->Next = NULL;
    // ret->Identifier = NULL;
    // ret->Constraint = NULL;
    ret->Presence = ePresence_Normal;
    return ret;
}

/* constructor of Tag_t */
Tag_t *
NewTag(TagType_e type)
{
    Tag_t *tag;

    tag = (Tag_t *)malloc(sizeof(Tag_t));
    if (! tag)
        return NULL;

    memset(tag, 0, sizeof(Tag_t));
    tag->Type = type;
    tag->Class = eTagClass_Unknown;
    // tag->Tag = NULL;
    // tag->Next = NULL;
    return tag;
}

/* copy constructor of Tag_t */
Tag_t *
DupTag(Tag_t *src)
{
    RETDUP(Tag_t, src);
}

/* constructor of Directive_t */
Directive_t *
NewDirective(Directives_e type)
{
    Directive_t *ret;

    ret = (Directive_t *)malloc(sizeof(Directive_t));
    if (! ret)
        return NULL;

    memset(ret, 0, sizeof(Directive_t));
    ret->Type = type;
    // ret->Next = NULL;
    return ret;
}

/* copy constructor of Directive_t */
Directive_t *
DupDirective(Directive_t *src)
{
    RETDUP(Directive_t, src);
}

/* constructor of ModuleIdentifier_t */
ModuleIdentifier_t *
NewModuleIdentifier()
{
    ModuleIdentifier_t *ret;

    ret = (ModuleIdentifier_t *)malloc(sizeof(ModuleIdentifier_t));
    if (! ret)
        return NULL;

    memset(ret, 0, sizeof(ModuleIdentifier_t));
    // ret->Identifier = NULL;
    // ret->ObjectIdentifier = NULL;
    return ret;
}

/* constructor of ObjectClass_t */
ObjectClass_t *
NewObjectClass(ObjectClass_e type)
{
    ObjectClass_t *ret;

    ret = (ObjectClass_t *)malloc(sizeof(ObjectClass_t));
    if (! ret)
        return NULL;

    memset(ret, 0, sizeof(ObjectClass_t));
    ret->Type = type;
    switch (type) {
    case eObjectClass_ObjectClass:
        // ret->U.ObjectClass.FieldSpec = NULL;
        // ret->U.ObjectClass.SyntaxSpec = NULL;
        break;
    case eObjectClass_Reference:
        // ret->U.Reference.Identifier = NULL;
        // ret->U.Reference.Module = NULL;
        break;
    }

    return ret;
}

/* constructor of Object_t */
Object_t *
NewObject(Object_e type)
{
    Object_t *ret;

    ret = (Object_t *)malloc(sizeof(Object_t));
    if (! ret)
        return NULL;

    memset(ret, 0, sizeof(Object_t));
    ret->Type = type;
    switch (type) {
    case eObject_Object:
        // ret->U.Object.ObjectClass = NULL;
        // ret->U.Object.Settings = NULL;
        break;
    case eObject_Reference:
        // ret->U.Reference.Identifier = NULL;
        // ret->U.Reference.Module = NULL;
        break;
    }

    return ret;
}

/* constructor of ObjectSet_t */
ObjectSet_t *
NewObjectSet(ObjectSet_e type)
{
    ObjectSet_t *ret;

    ret = (ObjectSet_t *)malloc(sizeof(ObjectSet_t));
    if (! ret)
        return NULL;

    memset(ret, 0, sizeof(ObjectSet_t));
    ret->Type = type;
    switch (type) {
    case eObjectSet_ObjectSet:
        // ret->U.ObjectSet.ObjectClass = NULL;
        // ret->U.ObjectSet.Elements = NULL;
        break;
    case eObjectSet_Reference:
        // ret->U.Reference.Identifier = NULL;
        // ret->U.Reference.Module = NULL;
        break;
    case eObjectSet_ExtensionMarker:
        // ret->U.ExtensionMarker.ObjectClass = NULL;
        // ret->U.ExtensionMarker.Elements = NULL;
        break;
    }

    return ret;
}

/* constructor of Setting_t */
Setting_t *
NewSetting(Settings_e type)
{
    Setting_t *ret;

    ret = (Setting_t *)malloc(sizeof(Setting_t));
    if (! ret)
        return NULL;

    memset(ret, 0, sizeof(Setting_t));
    ret->Type = type;
    // ret->Identifier = NULL;
    // ret->Next = NULL;
    switch (type) {
    case eSetting_Type:
        // ret->U.Type.Type = NULL;
        break;
    case eSetting_Value:
        // ret->U.Value.Value = NULL;
        break;
    case eSetting_ValueSet:
        // ret->U.ValueSet.ValueSet = NULL;
        break;
    case eSetting_Object:
        // ret->U.Object.Object = NULL;
        break;
    case eSetting_ObjectSet:
        // ret->U.ObjectSet.ObjectSet = NULL;
        break;
    }

    return ret;
}

/* copy constructor of Setting_t */
Setting_t *
DupSetting(Setting_t *src)
{
    RETDUP(Setting_t, src);
}

/* get the type of a setting */
Settings_e
GetSettingType(Setting_t *se)
{
    return se ? se->Type : eSetting_Undefined;
}

/* find a setting by name in a list of settings */
Setting_t *
FindSetting(SettingList_t se, char *identifier)
{
    for (; se; se = se->Next) {
        if (!strcmp(se->Identifier, identifier))
            return se;
    }
    return NULL;
}

/* constructor of FieldSpec_t */
FieldSpec_t *
NewFieldSpec(FieldSpecs_e type)
{
    FieldSpec_t *ret;

    ret = (FieldSpec_t *)malloc(sizeof(FieldSpec_t));
    if (! ret)
        return NULL;

    memset(ret, 0, sizeof(FieldSpec_t));
    ret->Type = type;
    // ret->Identifier = NULL;
    // ret->Next = NULL;
    switch (type) {
    case eFieldSpec_Type:
        // ret->U.Type.Optionality = NULL;
        break;
    case eFieldSpec_FixedTypeValue:
        // ret->U.FixedTypeValue.Type = NULL;
        // ret->U.FixedTypeValue.Unique = 0;
        // ret->U.FixedTypeValue.Optionality = NULL;
        break;
    case eFieldSpec_VariableTypeValue:
        // ret->U.VariableTypeValue.Fields = NULL;
        // ret->U.VariableTypeValue.Optionality = NULL;
        break;
    case eFieldSpec_FixedTypeValueSet:
        // ret->U.FixedTypeValueSet.Type = NULL;
        // ret->U.FixedTypeValueSet.Optionality = NULL;
        break;
    case eFieldSpec_VariableTypeValueSet:
        // ret->U.VariableTypeValueSet.Fields = NULL;
        // ret->U.VariableTypeValueSet.Optionality = NULL;
        break;
    case eFieldSpec_Object:
        // ret->U.Object.ObjectClass = NULL;
        // ret->U.Object.Optionality = NULL;
        break;
    case eFieldSpec_ObjectSet:
        // ret->U.ObjectSet.ObjectClass = NULL;
        // ret->U.ObjectSet.Optionality = NULL;
        break;
    default:
        MyAbort();
    }

    return ret;
}

/* copy constructor of FieldSpec_t */
FieldSpec_t *
DupFieldSpec(FieldSpec_t *src)
{
    RETDUP(FieldSpec_t, src);
}

/* find a fieldspec by name in a list of fieldspecs */
FieldSpec_t *
FindFieldSpec(FieldSpecList_t fs, char *identifier)
{
    if (!identifier)
        return NULL;
    for (; fs; fs = fs->Next) {
        if (!strcmp(fs->Identifier, identifier))
            return fs;
    }
    return NULL;
}

/* constructor of Optionality_t */
Optionality_t *
NewOptionality(Optionality_e type)
{
    Optionality_t *ret;

    ret = (Optionality_t *)malloc(sizeof(Optionality_t));
    if (! ret)
        return NULL;

    memset(ret, 0, sizeof(Optionality_t));
    ret->Type = type;
    switch (type) {
    case eOptionality_Normal:
        break;
    case eOptionality_Optional:
        break;
    case eOptionality_Default_Type:
        // ret->U.Type = NULL;
        break;
    case eOptionality_Default_Value:
        // ret->U.Value = NULL;
        break;
    case eOptionality_Default_ValueSet:
        // ret->U.ValueSet = NULL;
        break;
    case eOptionality_Default_Object:
        // ret->U.Object = NULL;
        break;
    case eOptionality_Default_ObjectSet:
        // ret->U.ObjectSet = NULL;
        break;
    }

    return ret;
}

/* constructor of String_t */
String_t *
NewString()
{
    String_t *ret;

    ret = (String_t *)malloc(sizeof(String_t));
    if (! ret)
        return NULL;

    memset(ret, 0, sizeof(String_t));
    // ret->String = NULL;
    // ret->Next = NULL;
    return ret;
}

/* copy constructor of String_t */
String_t *
DupString(String_t *src)
{
    RETDUP(String_t, src);
}

/* find a string by name in a string list */
String_t *
FindString(StringList_t list, char *string)
{
    for (; list; list = list->Next) {
        if (!strcmp(list->String, string))
            return list;
    }
    return NULL;
}

/* constructor of StringModule_t */
StringModule_t *
NewStringModule()
{
    StringModule_t *ret;

    ret = (StringModule_t *)malloc(sizeof(StringModule_t));
    if (! ret)
        return NULL;

    memset(ret, 0, sizeof(StringModule_t));
    // ret->String = NULL;
    // ret->Module = NULL;
    // ret->Next = NULL;
    return ret;
}

/* copy constructor of StringModule_t */
StringModule_t *
DupStringModule(StringModule_t *src)
{
    RETDUP(StringModule_t, src);
}

/* find a stringmodule by name/module in a list of stringmodules */
StringModule_t *
FindStringModule(AssignmentList_t ass, StringModuleList_t list, char *string, ModuleIdentifier_t *module)
{
    for (; list; list = list->Next) {
        if (!strcmp(list->String, string) &&
            !CmpModuleIdentifier(ass, list->Module, module))
            return list;
    }
    return NULL;
}

/* constructor of SyntaxSpec_t */
SyntaxSpec_t *
NewSyntaxSpec(SyntaxSpecs_e type)
{
    SyntaxSpec_t *ret;

    ret = (SyntaxSpec_t *)malloc(sizeof(SyntaxSpec_t));
    if (! ret)
        return NULL;

    memset(ret, 0, sizeof(SyntaxSpec_t));
    // ret->Next = NULL;
    ret->Type = type;
    switch (type) {
    case eSyntaxSpec_Literal:
        // ret->U.Literal.Literal = NULL;
        break;
    case eSyntaxSpec_Field:
        // ret->U.Field.Field = NULL;
        break;
    case eSyntaxSpec_Optional:
        // ret->U.Optional.SyntaxSpec = NULL;
        break;
    }
    return ret;
}

/* copy constructor of SyntaxSpec_t */
SyntaxSpec_t *
DupSyntaxSpec(SyntaxSpec_t *src)
{
    RETDUP(SyntaxSpec_t, src);
}

/* check if a type depends on other types which would be declared later */
/* returns 1 if the type depends on a type of the unknown list and */
/* therefore has to be defined later */
/* returns 0 if the type can be defined now */
int
Depends(AssignmentList_t known, AssignmentList_t unknown, Type_t *type, Type_t *parent)
{
    Type_t *reftype;
    int isunknown = 0;

    /* no dependency if no type is referenced */
    if (type->Type != eType_Reference && type->Type != eType_FieldReference)
        return 0;

    /* get the directly referenced type */
    reftype = GetReferencedType(known, type);
    if (!reftype) {
        reftype = GetReferencedType(unknown, type);
        isunknown = 1;
    }
    if (!reftype)
        MyAbort();

    // fix intermediate pdu
    if (IsStructuredType(reftype) || IsSequenceType(reftype) || IsReferenceType(reftype))
    {
        reftype->Flags |= eTypeFlags_MiddlePDU;
    }

    /* no dependency if a structured type is referenced by use of pointer */
    /* because a 'struct XXX_s *' can be used */
    if (IsStructuredType(reftype) && (type->Rules & eTypeRules_IndirectMask))
        return 0;

    /* no dependency if a structured type is referenced in an length-pointer */
    /* type, because a 'struct XXX_s *values' can be used */
    if (IsStructuredType(reftype) && (parent->Rules & eTypeRules_LengthPointer))
        return 0;

    // special case for pointer related components
    if (! isunknown && IsStructuredType(reftype) &&
        (parent->Rules & eTypeRules_LinkedListMask))
        return 0;

    // special case for SequenceOf and SetOf because they are using Pxxx.
    if ((reftype->Type == eType_SequenceOf || reftype->Type == eType_SetOf) &&
        (reftype->Rules & (eTypeRules_LinkedListMask | eTypeRules_PointerToElement)))
       // && (type->Rules & eTypeRules_IndirectMask))
        return 0;

    /* return true if referenced type is unknown up to now */
    return isunknown;
}

/* sort the assignments */
/* obtain an order usable by C type definitions */
void
SortAssignedTypes(AssignmentList_t *a)
{
    Assignment_t *list, *curr, *next, **prev, **last;
    int depends;
    Component_t *components;
    Type_t *type;
    int flag;
    int structured;

    /* list will contain the unordered assignments */
    list = *a;

    /* *a is the ordered list of assignments */
    *a = NULL;

    /* last will be used for appending to the list of ordered assignments */
    last = a;

    /* at first try to dump all non-structured types */
    structured = 0;

    /* we have to move all elements of the unordered assignment list into */
    /* the list of the ordered assignments */
    while (list) {

        /* flag if any assignment has been moved */
        flag = 0;

        /* examine every element in the unordered list */
        for (prev = &list, curr = list; curr; ) {

            /* flag if the current type depends on another type and */
            /* therefore cannot be moved now */
            depends = 0;

            /* only types will need dependencies */
            if (curr->Type == eAssignment_Type) {

                /* examine the current type */
                switch (curr->U.Type.Type->Type) {
                case eType_Sequence:
                case eType_Set:
                case eType_Choice:
                case eType_External:
                case eType_EmbeddedPdv:
                case eType_CharacterString:
                case eType_Real:
                case eType_InstanceOf:
                    
                    /* structured types shall not be moved in the first pass */
                    if (!structured) {
                        depends = 1;
                        break;
                    }

                    /* examine all components of the current type */
                    for (components = curr->U.Type.Type->U.SSC.Components;
                        components && !depends; components = components->Next) {

                        switch (components->Type) {
                        case eComponent_Normal:
                        case eComponent_Optional:
                        case eComponent_Default:
                            
                            /* check if the type of the component depends */
                            /* on an undefined type */
                            type = components->U.NOD.NamedType->Type;
                            depends |= Depends(*a, list, type,
                                curr->U.Type.Type);
                            break;

                        case eComponent_ComponentsOf:

                            /* components of should have been already */
                            /* resolved */
                            MyAbort();
                            /*NOTREACHED*/

                        case eComponent_ExtensionMarker:
                            break;
                        }
                    }
                    break;

                case eType_SequenceOf:
                case eType_SetOf:

                    /* structured types shall not be moved in the first pass */
                    if (!structured) {
                        depends = 1;
                        break;
                    }

                    /* check if the type of the elements depends on an */
                    /* undefined type */
                    type = curr->U.Type.Type->U.SS.Type;
                    depends |= Depends(*a, list, type, curr->U.Type.Type);
                    break;

                case eType_Reference:

                    /* check if the referenced type depends on an */
                    /* undefined type */
                    type = curr->U.Type.Type;
                    depends |= Depends(*a, list, type, curr->U.Type.Type);
                    break;
                }
            }

            /* move assignment into ordered assignment list if there's no */
            /* unresolved dependency */
            if (!depends) {
                next = curr->Next;
                *last = curr;
                curr->Next = NULL;
                last = &curr->Next;
                curr = next;
                *prev = curr;
                flag = 1;
            } else {
                prev = &curr->Next;
                curr = curr->Next;
            }
        }

        /* if no types have been moved, allow examination of structured types */
        /* if already allowed structured types, MyAbort because of cyclic */
        /* type definitions */
        if (!flag) {
            if (!structured) {
                structured = 1;
            } else {
            if (! curr || ! curr->Next)
            {
                        error(E_recursive_type_definition, NULL);
            }
            }
        }
    }
}

// --- The following is added by Microsoft ---

static const char *c_aReservedWords[] =
{
    // special for C language
    "__asm",
    "__based",
    "__cdecl",
    "__declspec",
    "__except",
    "__fastcall",
    "__finally",
    "__inline",
    "__int16",
    "__int32",
    "__int64",
    "__int8",
    "__leave",
    "__multiple_inheritance",
    "__single_inheritance",
    "__stdcall",
    "__try",
    "__uuidof",
    "__virtual_inheritance",
    "auto",
    "bool",
    "break",
    "case",
    "catch",
    "char",
    "class",
    "const",
    "const_cast",
    "continue",
    "default",
    "delete",
    "dllexport",
    "dllimport",
    "do",
    "double",
    "dynamic_cast",
    "else",
    "enum",
    "explicit",
    "extern",
    "false",
    "float",
    "for",
    "friend",
    "goto",
    "if",
    "inline",
    "int",
    "long",
    "main",
    "mutable",
    "naked",
    "namespace",
    "new",
    "operator",
    "private",
    "protected",
    "public",
    "register",
    "reinterpret_cast",
    "return",
    "short",
    "signed",
    "sizeof",
    "static",
    "static_cast",
    "struct",
    "switch",
    "template",
    "this",
    "thread",
    "throw",
    "true",
    "try",
    "typedef",
    "typeid",
    "typename",
    "union",
    "unsigned",
    "using",
    "uuid",
    "virtual",
    "void",
    "volatile",
    "while",
    "wmain",
    "xalloc"
};
int IsReservedWord ( char *psz )
{
    int cWords = sizeof(c_aReservedWords) / sizeof(c_aReservedWords[0]);
    const char **ppszWord;
    for (ppszWord = &c_aReservedWords[0]; cWords--; ppszWord++)
    {
        if (strcmp(psz, *ppszWord) == 0)
            return 1;
    }
    return 0;
}

typedef struct ConflictNameList_s
{
    struct ConflictNameList_s   *next;
    char                        *pszName;
    unsigned int                cInstances;
}   ConflictNameList_t;
static ConflictNameList_t *g_pEnumNameList = NULL;      // ENUMERATED
static ConflictNameList_t *g_pOptNameList = NULL;       // OPTIONAL
static ConflictNameList_t *g_pChoiceNameList = NULL;    // CHOICE

void KeepConflictNames ( ConflictNameList_t **ppListHead, char *pszName )
{
    ConflictNameList_t *p;
    char *psz;
    char szName[256];

    strcpy(&szName[0], pszName);
    for (psz = &szName[0]; *psz; psz++)
    {
        if (*psz == '-')
            *psz = '_';
    }

    for (p = *ppListHead; p; p = p->next)
    {
        if (strcmp(p->pszName, &szName[0]) == 0)
        {
            p->cInstances++;
            return;
        }
    }

    p = (ConflictNameList_t *) malloc(sizeof(ConflictNameList_t));
    if (p)
    {
        memset(p, 0, sizeof(ConflictNameList_t));
        p->next = *ppListHead;
        *ppListHead = p;
        p->cInstances = 1;
        p->pszName = strdup(&szName[0]);
    }
}

void KeepEnumNames ( char *pszEnumName )
{
    KeepConflictNames(&g_pEnumNameList, pszEnumName);
}
void KeepOptNames ( char *pszOptName )
{
    KeepConflictNames(&g_pOptNameList, pszOptName);
}
void KeepChoiceNames ( char *pszChoiceName )
{
    KeepConflictNames(&g_pChoiceNameList, pszChoiceName);
}

unsigned int GetConflictNameInstanceCount ( ConflictNameList_t *pListHead, char *pszName )
{
    ConflictNameList_t *p;
    for (p = pListHead; p; p = p->next)
    {
        if (strcmp(p->pszName, pszName) == 0)
        {
            return p->cInstances;
        }
    }
    return 0;
}

int DoesEnumNameConflict ( char *pszEnumName )
{
    return (GetConflictNameInstanceCount(g_pEnumNameList, pszEnumName) > 2); // counted twice
}
int DoesOptNameConflict ( char *pszOptName )
{
    return (GetConflictNameInstanceCount(g_pOptNameList, pszOptName) > 2); // counted twice
}
int DoesChoiceNameConflict ( char *pszChoiceName )
{
    return (GetConflictNameInstanceCount(g_pChoiceNameList, pszChoiceName) > 2); // counted twice
}


int IsImportedLocalDuplicate(AssignmentList_t ass, ModuleIdentifier_t *pMainModule, Assignment_t *curr)
{
    if (0 == CmpModuleIdentifier(ass, curr->Module, pMainModule))
    {
        Assignment_t *a;
        for (a = ass; a; a = a->Next)
        {
            if (a->Flags & eAssignmentFlags_LongName)
            {
                if (0 == strcmp(a->Identifier, curr->Identifier))
                {
                    if (0 != CmpModuleIdentifier(ass, a->Module, curr->Module))
                    {
                        return 1;
                    }
                }
            }
        }
    }
    return 0;
}



DefinedObjectID_t *g_pDefinedObjectIDs = NULL;

Value_t *GetDefinedOIDValue ( char *pszName )
{
    if (pszName)
    {
        DefinedObjectID_t *p;
        for (p = g_pDefinedObjectIDs; p; p = p->next)
        {
            if (strcmp(pszName, p->pszName) == 0)
            {
                return p->pValue;
            }
        }
    }
    return NULL;
}

void AddDefinedOID ( char *pszName, Value_t *pValue )
{
    // add it only when it does not exist
    if (! GetDefinedOIDValue(pszName))
    {
        DefinedObjectID_t *p;
        p = (DefinedObjectID_t *) malloc(sizeof(DefinedObjectID_t));
        if (p)
        {
            p->next = g_pDefinedObjectIDs;
            p->pszName = pszName;
            p->pValue = pValue;
            g_pDefinedObjectIDs = p;
        }
    }
}


void PropagatePrivateDirectives ( Type_t *pDst, PrivateDirectives_t *pSrc )
{
    if (pSrc && pDst)
    {
        if (! pDst->PrivateDirectives.pszTypeName)
        {
            pDst->PrivateDirectives.pszTypeName = pSrc->pszTypeName;
        }
        if (! pDst->PrivateDirectives.pszFieldName)
        {
            pDst->PrivateDirectives.pszFieldName = pSrc->pszFieldName;
        }
        if (! pDst->PrivateDirectives.pszValueName)
        {
            pDst->PrivateDirectives.pszValueName = pSrc->pszValueName;
        }
        pDst->PrivateDirectives.fPublic |= pSrc->fPublic;
        pDst->PrivateDirectives.fIntx |= pSrc->fIntx;
        pDst->PrivateDirectives.fLenPtr |= pSrc->fLenPtr;
        pDst->PrivateDirectives.fPointer |= pSrc->fPointer;
        pDst->PrivateDirectives.fArray |= pSrc->fArray;
        pDst->PrivateDirectives.fNoCode |= pSrc->fNoCode;
        pDst->PrivateDirectives.fNoMemCopy |= pSrc->fNoMemCopy;
        pDst->PrivateDirectives.fOidPacked |= pSrc->fOidPacked;
        pDst->PrivateDirectives.fOidArray |= pSrc->fOidArray;
        pDst->PrivateDirectives.fSLinked |= pSrc->fSLinked;
        pDst->PrivateDirectives.fDLinked |= pSrc->fDLinked;
    }
}


void PropagateReferenceTypePrivateDirectives ( Type_t *pDst, PrivateDirectives_t *pSrc )
{
    if (pSrc && pDst)
    {
        pDst->PrivateDirectives.fPublic |= pSrc->fPublic;
        pDst->PrivateDirectives.fIntx |= pSrc->fIntx;
        pDst->PrivateDirectives.fLenPtr |= pSrc->fLenPtr;
        pDst->PrivateDirectives.fPointer |= pSrc->fPointer;
        pDst->PrivateDirectives.fArray |= pSrc->fArray;
        pDst->PrivateDirectives.fNoCode |= pSrc->fNoCode;
        pDst->PrivateDirectives.fNoMemCopy |= pSrc->fNoMemCopy;
        pDst->PrivateDirectives.fOidPacked |= pSrc->fOidPacked;
        pDst->PrivateDirectives.fOidArray |= pSrc->fOidArray;
        pDst->PrivateDirectives.fSLinked |= pSrc->fSLinked;
        pDst->PrivateDirectives.fDLinked |= pSrc->fDLinked;
    }
}


char *GetPrivateValueName(PrivateDirectives_t *pPrivateDirectives, char *pszDefValueName)
{
    return pPrivateDirectives->pszValueName ? pPrivateDirectives->pszValueName : pszDefValueName;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\asn1\asn1c\builtin.c ===
/* Copyright (C) Boris Nikolaus, Germany, 1996-1997. All rights reserved. */
/* Copyright (C) Microsoft Corporation, 1997-1998. All rights reserved. */

#include "precomp.h"

Type_t *Builtin_Type_Null;
Type_t *Builtin_Type_Boolean;
Type_t *Builtin_Type_Integer;
Type_t *Builtin_Type_PositiveInteger;
Type_t *Builtin_Type_ObjectIdentifier;
Type_t *Builtin_Type_ObjectDescriptor;
Type_t *Builtin_Type_Open;
Type_t *Builtin_Type_BitString;
Type_t *Builtin_Type_OctetString;
Type_t *Builtin_Type_UTF8String;
Type_t *Builtin_Type_BMPString;
Type_t *Builtin_Type_GeneralString;
Type_t *Builtin_Type_GraphicString;
Type_t *Builtin_Type_IA5String;
Type_t *Builtin_Type_ISO646String;
Type_t *Builtin_Type_NumericString;
Type_t *Builtin_Type_PrintableString;
Type_t *Builtin_Type_TeletexString;
Type_t *Builtin_Type_T61String;
Type_t *Builtin_Type_UniversalString;
Type_t *Builtin_Type_VideotexString;
Type_t *Builtin_Type_VisibleString;
Type_t *Builtin_Type_CharacterString;
Type_t *Builtin_Type_GeneralizedTime;
Type_t *Builtin_Type_UTCTime;
Type_t *Builtin_Type_Real;
Type_t *Builtin_Type_External;
Type_t *Builtin_Type_EmbeddedPdv;
Value_t *Builtin_Value_Null;
Value_t *Builtin_Value_Integer_0;
Value_t *Builtin_Value_Integer_1;
Value_t *Builtin_Value_Integer_2;
Value_t *Builtin_Value_Integer_10;
ObjectClass_t *Builtin_ObjectClass_AbstractSyntax;
ObjectClass_t *Builtin_ObjectClass_TypeIdentifier;
ModuleIdentifier_t *Builtin_Module;
AssignmentList_t Builtin_Assignments;
AssignedObjIdList_t Builtin_ObjIds;

/* create a type with a given tag */
static Type_t *
NewTaggedType(Type_e type, TagType_e tag, uint32_t val)
{
    Type_t *ty;
    Tag_t *ta;
    Value_t *va;

    ty = NewType(type);
    ty->Tags = ta = NewTag(tag);
    ta->Tag = va = NewValue(NULL, Builtin_Type_Integer);
    intx_setuint32(&va->U.Integer.Value, val);
    return ty;
}

/* create a type with a given permitted alphabet constraint */
/* n is the number of character ranges, the lower and upper characters */
/* of these ranges will follow in the vararg list */
static Type_t *
NewTypeWithPermittedAlphabetConstraint(Type_e type, int n, ...)
{
    va_list args;
    Type_t *ty;
    Value_t *va;
    Constraint_t **cc;
    ElementSetSpec_t *s, **ss;
    char32_t lo, up;
    int i;

    va_start(args, n);

    /* create type with permitted alphabet constraint */
    ty = NewType(type);
    cc = &ty->Constraints;
    *cc = NewConstraint();
    (*cc)->Root = NewElementSetSpec(eElementSetSpec_SubtypeElement);
    (*cc)->Root->U.SubtypeElement.SubtypeElement =
    NewSubtypeElement(eSubtypeElement_PermittedAlphabet);
    cc = &(*cc)->Root->U.SubtypeElement.SubtypeElement->
    U.PermittedAlphabet.Constraints;
    *cc = NewConstraint();
    ss = &(*cc)->Root;

    /* n character ranges will be needed */
    for (i = 0; i < n; i++) {

    /* get the lower and upper character of one range */
    lo = va_arg(args, char32_t);
    up = va_arg(args, char32_t);

    /* create an element set spec for this range */
    s = NewElementSetSpec(eElementSetSpec_SubtypeElement);
    s->U.SubtypeElement.SubtypeElement =
        NewSubtypeElement(eSubtypeElement_ValueRange);
    s->U.SubtypeElement.SubtypeElement->U.ValueRange.Lower.Flags = 0;
    s->U.SubtypeElement.SubtypeElement->U.ValueRange.Lower.Value = va =
        NewValue(NULL, ty);
    va->U.RestrictedString.Value.length = 1;
    va->U.RestrictedString.Value.value =
        (char32_t *)malloc(sizeof(char32_t));
    *va->U.RestrictedString.Value.value = lo;
    s->U.SubtypeElement.SubtypeElement->U.ValueRange.Upper.Flags = 0;
    s->U.SubtypeElement.SubtypeElement->U.ValueRange.Upper.Value = va =
        NewValue(NULL, ty);
    va->U.RestrictedString.Value.length = 1;
    va->U.RestrictedString.Value.value =
        (char32_t *)malloc(sizeof(char32_t));
    *va->U.RestrictedString.Value.value = up;

    /* setup for next range or last range */
    if (i < n - 1) {
        *ss = NewElementSetSpec(eElementSetSpec_Union);
        (*ss)->U.Union.Elements1 = s;
        ss = &(*ss)->U.Union.Elements2;
    } else {
        *ss = s;
    }
    }
    return ty;
}

/* initialize internally needed builtin types, values, information object */
/* classes and object identifier components */
void
InitBuiltin()
{
    Type_t *ty;
    Component_t *co1, *co2, *co3, *co4, *co5, *co6;
    Assignment_t *a;
    AssignedObjId_t *oi0, *oi1, *oi2, *oi0_0, *oi0_1, *oi0_2, *oi0_3, *oi0_4,
    *oi1_0, *oi1_2, *oi1_3, **oi;
    String_t *s1, *s2;
    int i;
    FieldSpec_t *fs1, *fs2, *fs3;
    Constraint_t *c;
    SubtypeElement_t *s;
    SyntaxSpec_t *sy1, *sy2, *sy3, *sy4, *sy5, *sy6, *sy7, *sy8;

    /* allocate a builtin module name */
    Builtin_Assignments = NULL;
    Builtin_Module = NewModuleIdentifier();
    Builtin_Module->Identifier = "<Internal>";

    /* allocate basic ASN.1 types */
    Builtin_Type_Null = NewType(eType_Null);
    Builtin_Type_Boolean = NewType(eType_Boolean);
    Builtin_Type_Integer = NewType(eType_Integer);
    Builtin_Type_ObjectIdentifier = NewType(eType_ObjectIdentifier);
    Builtin_Type_Open = NewType(eType_Open);
    Builtin_Type_BitString = NewType(eType_BitString);
    Builtin_Type_OctetString = NewType(eType_OctetString);
    Builtin_Type_UTF8String = NewType(eType_UTF8String);
    Builtin_Type_ObjectDescriptor = NewTypeWithPermittedAlphabetConstraint(
    eType_ObjectDescriptor, 1, 0x00, 0xff);
    Builtin_Type_BMPString = NewTypeWithPermittedAlphabetConstraint(
    eType_BMPString, 1, 0x0000, 0xffff);
    Builtin_Type_GeneralString = NewTypeWithPermittedAlphabetConstraint(
    eType_GeneralString, 1, 0x00, 0xff);
    Builtin_Type_GraphicString = NewTypeWithPermittedAlphabetConstraint(
    eType_GraphicString, 1, 0x00, 0xff);
    Builtin_Type_IA5String = NewTypeWithPermittedAlphabetConstraint(
    eType_IA5String, 1, 0x00, 0x7f);
    Builtin_Type_ISO646String = NewTypeWithPermittedAlphabetConstraint(
    eType_ISO646String, 1, 0x20, 0x7e);
    Builtin_Type_NumericString = NewTypeWithPermittedAlphabetConstraint(
    eType_NumericString, 2, 0x20, 0x20, 0x30, 0x39);
    Builtin_Type_PrintableString = NewTypeWithPermittedAlphabetConstraint(
    eType_PrintableString, 7, 0x20, 0x20, 0x27, 0x29, 0x2b, 0x3a,
    0x3d, 0x3d, 0x3f, 0x3f, 0x41, 0x5a, 0x61, 0x7a);
    Builtin_Type_TeletexString = NewTypeWithPermittedAlphabetConstraint(
    eType_TeletexString, 1, 0x00, 0xff);
    Builtin_Type_T61String = NewTypeWithPermittedAlphabetConstraint(
    eType_T61String, 1, 0x00, 0xff);
    Builtin_Type_UniversalString = NewTypeWithPermittedAlphabetConstraint(
    eType_UniversalString, 1, 0x00000000, 0xffffffff);
    Builtin_Type_VideotexString = NewTypeWithPermittedAlphabetConstraint(
    eType_VideotexString, 1, 0x00, 0xff);
    Builtin_Type_VisibleString = NewTypeWithPermittedAlphabetConstraint(
    eType_VisibleString, 1, 0x20, 0x7e);
    Builtin_Type_GeneralizedTime = NewTypeWithPermittedAlphabetConstraint(
    eType_GeneralizedTime, 1, 0x20, 0x7e);
    Builtin_Type_UTCTime = NewTypeWithPermittedAlphabetConstraint(
    eType_UTCTime, 1, 0x20, 0x7e);

    /* allocate basic ASN.1 values */
    Builtin_Value_Null = NewValue(NULL, Builtin_Type_Null);
    Builtin_Value_Integer_0 = NewValue(NULL, Builtin_Type_Integer);
    intx_setuint32(&Builtin_Value_Integer_0->U.Integer.Value, 0);
    Builtin_Value_Integer_1 = NewValue(NULL, Builtin_Type_Integer);
    intx_setuint32(&Builtin_Value_Integer_1->U.Integer.Value, 1);
    Builtin_Value_Integer_2 = NewValue(NULL, Builtin_Type_Integer);
    intx_setuint32(&Builtin_Value_Integer_2->U.Integer.Value, 2);
    Builtin_Value_Integer_10 = NewValue(NULL, Builtin_Type_Integer);
    intx_setuint32(&Builtin_Value_Integer_10->U.Integer.Value, 10);

    /* allocate a positive integer type */
    Builtin_Type_PositiveInteger = NewType(eType_Integer);
    Builtin_Type_PositiveInteger->Constraints = c = NewConstraint();
    c->Root = NewElementSetSpec(eElementSetSpec_SubtypeElement);
    c->Root->U.SubtypeElement.SubtypeElement = s =
    NewSubtypeElement(eSubtypeElement_ValueRange);
    s->U.ValueRange.Lower.Flags = 0;
    s->U.ValueRange.Lower.Value = Builtin_Value_Integer_0;
    s->U.ValueRange.Upper.Flags = eEndPoint_Max;

#ifndef NO_BUILTIN
    /* REAL */
    co1 = NewComponent(eComponent_Normal);
    co2 = co1->Next = NewComponent(eComponent_Normal);
    co3 = co2->Next = NewComponent(eComponent_Normal);
    ty = NewTaggedType(eType_Integer, eTagType_Implicit, 0);
    co1->U.Normal.NamedType = NewNamedType("mantissa", ty);
    ty = NewTaggedType(eType_Integer, eTagType_Implicit, 1);
    ty->Constraints = c = NewConstraint();
    c->Root = NewElementSetSpec(eElementSetSpec_Union);
    c->Root->U.Union.Elements1 =
    NewElementSetSpec(eElementSetSpec_SubtypeElement);
    c->Root->U.Union.Elements1->U.SubtypeElement.SubtypeElement = s =
    NewSubtypeElement(eSubtypeElement_SingleValue);
    s->U.SingleValue.Value = Builtin_Value_Integer_2;
    c->Root->U.Union.Elements2 =
    NewElementSetSpec(eElementSetSpec_SubtypeElement);
    c->Root->U.Union.Elements2->U.SubtypeElement.SubtypeElement = s =
    NewSubtypeElement(eSubtypeElement_SingleValue);
    s->U.SingleValue.Value = Builtin_Value_Integer_10;
    co2->U.Normal.NamedType = NewNamedType("base", ty);
    ty = NewTaggedType(eType_Integer, eTagType_Implicit, 2);
    co3->U.Normal.NamedType = NewNamedType("exponent", ty);
    Builtin_Type_Real = NewType(eType_Real);
    Builtin_Type_Real->U.Real.Components = co1;

    /* EXTERNAL.identification.syntaxes */
    co1 = NewComponent(eComponent_Normal);
    co2 = co1->Next = NewComponent(eComponent_Normal);
    ty = NewTaggedType(eType_ObjectIdentifier, eTagType_Implicit, 0);
    co1->U.Normal.NamedType = NewNamedType("abstract", ty);
    ty = NewTaggedType(eType_ObjectIdentifier, eTagType_Implicit, 1);
    co2->U.Normal.NamedType = NewNamedType("transfer", ty);
    ty = NewType(eType_Sequence);
    ty->U.Sequence.Components = co1;
    a = NewAssignment(eAssignment_Type);
    a->U.Type.Type = ty;
    a->Identifier = "<ASN1external_identification_syntaxes_t>";
    a->Module = Builtin_Module;
    a->Next = Builtin_Assignments;
    Builtin_Assignments = a;

    /* EXTERNAL.identification.context-negotiation */
    co1 = NewComponent(eComponent_Normal);
    co2 = co1->Next = NewComponent(eComponent_Normal);
    ty = NewTaggedType(eType_Integer, eTagType_Implicit, 0);
    co1->U.Normal.NamedType = NewNamedType("presentation-context-id", ty);
    ty = NewTaggedType(eType_ObjectIdentifier, eTagType_Implicit, 1);
    co2->U.Normal.NamedType = NewNamedType("transfer-syntax", ty);
    ty = NewType(eType_Sequence);
    ty->U.Sequence.Components = co1;
    a = NewAssignment(eAssignment_Type);
    a->U.Type.Type = ty;
    a->Identifier = "ASN1external_identification_context_negotiation_t";
    a->Module = Builtin_Module;
    a->Next = Builtin_Assignments;
    Builtin_Assignments = a;

    /* EXTERNAL.identification */
    co1 = NewComponent(eComponent_Normal);
    co2 = co1->Next = NewComponent(eComponent_Normal);
    co3 = co2->Next = NewComponent(eComponent_Normal);
    co4 = co3->Next = NewComponent(eComponent_Normal);
    co5 = co4->Next = NewComponent(eComponent_Normal);
    co6 = co5->Next = NewComponent(eComponent_Normal);
    ty = NewTaggedType(eType_Reference, eTagType_Explicit, 0);
    ty->U.Reference.Identifier = "<ASN1external_identification_syntaxes_t>";
    ty->U.Reference.Module = Builtin_Module;
    co1->U.Normal.NamedType = NewNamedType("<syntaxes>", ty);
    ty = NewTaggedType(eType_ObjectIdentifier, eTagType_Explicit, 1);
    co2->U.Normal.NamedType = NewNamedType("syntax", ty);
    ty = NewTaggedType(eType_Integer, eTagType_Explicit, 2);
    co3->U.Normal.NamedType = NewNamedType("presentation-context-id", ty);
    ty = NewTaggedType(eType_Reference, eTagType_Explicit, 3);
    ty->U.Reference.Identifier =
    "ASN1external_identification_context_negotiation_t";
    ty->U.Reference.Module = Builtin_Module;
    co4->U.Normal.NamedType = NewNamedType("context-negotiation", ty);
    ty = NewTaggedType(eType_ObjectIdentifier, eTagType_Explicit, 4);
    co5->U.Normal.NamedType = NewNamedType("<transfer-syntax>", ty);
    ty = NewTaggedType(eType_Null, eTagType_Explicit, 5);
    co6->U.Normal.NamedType = NewNamedType("<fixed>", ty);
    ty = NewType(eType_Choice);
    ty->U.Choice.Components = co1;
    a = NewAssignment(eAssignment_Type);
    a->U.Type.Type = ty;
    a->Identifier = "ASN1external_identification_t";
    a->Module = Builtin_Module;
    a->Next = Builtin_Assignments;
    Builtin_Assignments = a;

    /* EXTERNAL.data-value */
    co1 = NewComponent(eComponent_Normal);
    co2 = co1->Next = NewComponent(eComponent_Normal);
    ty = NewTaggedType(eType_Open, eTagType_Explicit, 0);
    co1->U.Normal.NamedType = NewNamedType("notation", ty);
    ty = NewTaggedType(eType_BitString, eTagType_Explicit, 1);
    co2->U.Normal.NamedType = NewNamedType("encoded", ty);
    ty = NewType(eType_Choice);
    ty->U.Choice.Components = co1;
    a = NewAssignment(eAssignment_Type);
    a->U.Type.Type = ty;
    a->Identifier = "ASN1external_data_value_t";
    a->Module = Builtin_Module;
    a->Next = Builtin_Assignments;
    Builtin_Assignments = a;

    /* EXTERNAL */
    co1 = NewComponent(eComponent_Normal);
    co2 = co1->Next = NewComponent(eComponent_Optional);
    co3 = co2->Next = NewComponent(eComponent_Normal);
    ty = NewTaggedType(eType_Reference, eTagType_Implicit, 0);
    ty->U.Reference.Identifier = "ASN1external_identification_t";
    ty->U.Reference.Module = Builtin_Module;
    co1->U.Normal.NamedType = NewNamedType("identification", ty);
    ty = NewTaggedType(eType_ObjectDescriptor, eTagType_Implicit, 1);
    co2->U.Optional.NamedType = NewNamedType("data-value-descriptor", ty);
    ty = NewTaggedType(eType_Reference, eTagType_Implicit, 2);
    ty->U.Reference.Identifier = "ASN1external_data_value_t";
    ty->U.Reference.Module = Builtin_Module;
    co3->U.Normal.NamedType = NewNamedType("data-value", ty);
    Builtin_Type_External = NewType(eType_External);
    Builtin_Type_External->U.External.Components = co1;
    Builtin_Type_External->U.External.Optionals = 1;

    /* EMBEDDED PDV.identification.syntaxes */
    co1 = NewComponent(eComponent_Normal);
    co2 = co1->Next = NewComponent(eComponent_Normal);
    ty = NewTaggedType(eType_ObjectIdentifier, eTagType_Implicit, 0);
    co1->U.Normal.NamedType = NewNamedType("abstract", ty);
    ty = NewTaggedType(eType_ObjectIdentifier, eTagType_Implicit, 1);
    co2->U.Normal.NamedType = NewNamedType("transfer", ty);
    ty = NewType(eType_Sequence);
    ty->U.Sequence.Components = co1;
    a = NewAssignment(eAssignment_Type);
    a->U.Type.Type = ty;
    a->Identifier = "ASN1embeddedpdv_identification_syntaxes_t";
    a->Module = Builtin_Module;
    a->Next = Builtin_Assignments;
    Builtin_Assignments = a;

    /* EMBEDDED PDV.identification.context-negotiation */
    co1 = NewComponent(eComponent_Normal);
    co2 = co1->Next = NewComponent(eComponent_Normal);
    ty = NewTaggedType(eType_Integer, eTagType_Implicit, 0);
    co1->U.Normal.NamedType = NewNamedType("presentation-context-id", ty);
    ty = NewTaggedType(eType_ObjectIdentifier, eTagType_Implicit, 1);
    co2->U.Normal.NamedType = NewNamedType("transfer-syntax", ty);
    ty = NewType(eType_Sequence);
    ty->U.Sequence.Components = co1;
    a = NewAssignment(eAssignment_Type);
    a->U.Type.Type = ty;
    a->Identifier = "ASN1embeddedpdv_identification_context_negotiation_t";
    a->Module = Builtin_Module;
    a->Next = Builtin_Assignments;
    Builtin_Assignments = a;

    /* EMBEDDED PDV.identification */
    co1 = NewComponent(eComponent_Normal);
    co2 = co1->Next = NewComponent(eComponent_Normal);
    co3 = co2->Next = NewComponent(eComponent_Normal);
    co4 = co3->Next = NewComponent(eComponent_Normal);
    co5 = co4->Next = NewComponent(eComponent_Normal);
    co6 = co5->Next = NewComponent(eComponent_Normal);
    ty = NewTaggedType(eType_Reference, eTagType_Explicit, 0);
    ty->U.Reference.Identifier = "ASN1embeddedpdv_identification_syntaxes_t";
    ty->U.Reference.Module = Builtin_Module;
    co1->U.Normal.NamedType = NewNamedType("syntaxes", ty);
    ty = NewTaggedType(eType_ObjectIdentifier, eTagType_Explicit, 1);
    co2->U.Normal.NamedType = NewNamedType("syntax", ty);
    ty = NewTaggedType(eType_Integer, eTagType_Explicit, 2);
    co3->U.Normal.NamedType = NewNamedType("presentation-context-id", ty);
    ty = NewTaggedType(eType_Reference, eTagType_Explicit, 3);
    ty->U.Reference.Identifier =
    "ASN1embeddedpdv_identification_context_negotiation_t";
    ty->U.Reference.Module = Builtin_Module;
    co4->U.Normal.NamedType = NewNamedType("context-negotiation", ty);
    ty = NewTaggedType(eType_ObjectIdentifier, eTagType_Explicit, 4);
    co5->U.Normal.NamedType = NewNamedType("transfer-syntax", ty);
    ty = NewTaggedType(eType_Null, eTagType_Explicit, 5);
    co6->U.Normal.NamedType = NewNamedType("fixed", ty);
    ty = NewType(eType_Choice);
    ty->U.Choice.Components = co1;
    a = NewAssignment(eAssignment_Type);
    a->U.Type.Type = ty;
    a->Identifier = "ASN1embeddedpdv_identification_t";
    a->Module = Builtin_Module;
    a->Next = Builtin_Assignments;
    Builtin_Assignments = a;

    /* EMBEDDED PDV.data-value */
    co1 = NewComponent(eComponent_Normal);
    co2 = co1->Next = NewComponent(eComponent_Normal);
    ty = NewTaggedType(eType_Open, eTagType_Explicit, 0);
    co1->U.Normal.NamedType = NewNamedType("notation", ty);
    ty = NewTaggedType(eType_BitString, eTagType_Explicit, 1);
    co2->U.Normal.NamedType = NewNamedType("encoded", ty);
    ty = NewType(eType_Choice);
    ty->U.Choice.Components = co1;
    a = NewAssignment(eAssignment_Type);
    a->U.Type.Type = ty;
    a->Identifier = "ASN1embeddedpdv_data_value_t";
    a->Module = Builtin_Module;
    a->Next = Builtin_Assignments;
    Builtin_Assignments = a;

    /* EMBEDDED PDV */
    co1 = NewComponent(eComponent_Normal);
    co2 = co1->Next = NewComponent(eComponent_Normal);
    ty = NewTaggedType(eType_Reference, eTagType_Implicit, 0);
    ty->U.Reference.Identifier = "ASN1embeddedpdv_identification_t";
    ty->U.Reference.Module = Builtin_Module;
    co1->U.Normal.NamedType = NewNamedType("identification", ty);
    ty = NewTaggedType(eType_Reference, eTagType_Implicit, 2);
    ty->U.Reference.Identifier = "ASN1embeddedpdv_data_value_t";
    ty->U.Reference.Module = Builtin_Module;
    co2->U.Normal.NamedType = NewNamedType("data-value", ty);
    Builtin_Type_EmbeddedPdv = NewType(eType_EmbeddedPdv);
    Builtin_Type_EmbeddedPdv->U.EmbeddedPdv.Components = co1;

    /* CHARACTER STRING.identification.syntaxes */
    co1 = NewComponent(eComponent_Normal);
    co2 = co1->Next = NewComponent(eComponent_Normal);
    ty = NewTaggedType(eType_ObjectIdentifier, eTagType_Implicit, 0);
    co1->U.Normal.NamedType = NewNamedType("abstract", ty);
    ty = NewTaggedType(eType_ObjectIdentifier, eTagType_Implicit, 1);
    co2->U.Normal.NamedType = NewNamedType("transfer", ty);
    ty = NewType(eType_Sequence);
    ty->U.Sequence.Components = co1;
    a = NewAssignment(eAssignment_Type);
    a->U.Type.Type = ty;
    a->Identifier = "ASN1characterstring_identification_syntaxes_t";
    a->Module = Builtin_Module;
    a->Next = Builtin_Assignments;
    Builtin_Assignments = a;

    /* CHARACTER STRING.identification.context-negotiation */
    co1 = NewComponent(eComponent_Normal);
    co2 = co1->Next = NewComponent(eComponent_Normal);
    ty = NewTaggedType(eType_Integer, eTagType_Implicit, 0);
    co1->U.Normal.NamedType = NewNamedType("presentation-context-id", ty);
    ty = NewTaggedType(eType_ObjectIdentifier, eTagType_Implicit, 1);
    co2->U.Normal.NamedType = NewNamedType("transfer-syntax", ty);
    ty = NewType(eType_Sequence);
    ty->U.Sequence.Components = co1;
    a = NewAssignment(eAssignment_Type);
    a->U.Type.Type = ty;
    a->Identifier = "ASN1characterstring_identification_context_negotiation_t";
    a->Module = Builtin_Module;
    a->Next = Builtin_Assignments;
    Builtin_Assignments = a;

    /* CHARACTER STRING.identification */
    co1 = NewComponent(eComponent_Normal);
    co2 = co1->Next = NewComponent(eComponent_Normal);
    co3 = co2->Next = NewComponent(eComponent_Normal);
    co4 = co3->Next = NewComponent(eComponent_Normal);
    co5 = co4->Next = NewComponent(eComponent_Normal);
    co6 = co5->Next = NewComponent(eComponent_Normal);
    ty = NewTaggedType(eType_Reference, eTagType_Explicit, 0);
    ty->U.Reference.Identifier = "ASN1characterstring_identification_syntaxes_t";
    ty->U.Reference.Module = Builtin_Module;
    co1->U.Normal.NamedType = NewNamedType("syntaxes", ty);
    ty = NewTaggedType(eType_ObjectIdentifier, eTagType_Explicit, 1);
    co2->U.Normal.NamedType = NewNamedType("syntax", ty);
    ty = NewTaggedType(eType_Integer, eTagType_Explicit, 2);
    co3->U.Normal.NamedType = NewNamedType("presentation-context-id", ty);
    ty = NewTaggedType(eType_Reference, eTagType_Explicit, 3);
    ty->U.Reference.Identifier =
    "ASN1characterstring_identification_context_negotiation_t";
    ty->U.Reference.Module = Builtin_Module;
    co4->U.Normal.NamedType = NewNamedType("context-negotiation", ty);
    ty = NewTaggedType(eType_ObjectIdentifier, eTagType_Explicit, 4);
    co5->U.Normal.NamedType = NewNamedType("transfer-syntax", ty);
    ty = NewTaggedType(eType_Null, eTagType_Explicit, 5);
    co6->U.Normal.NamedType = NewNamedType("fixed", ty);
    ty = NewType(eType_Choice);
    ty->U.Choice.Components = co1;
    a = NewAssignment(eAssignment_Type);
    a->U.Type.Type = ty;
    a->Identifier = "ASN1characterstring_identification_t";
    a->Module = Builtin_Module;
    a->Next = Builtin_Assignments;
    Builtin_Assignments = a;

    /* CHARACTER STRING.data-value */
    co1 = NewComponent(eComponent_Normal);
    co2 = co1->Next = NewComponent(eComponent_Normal);
    ty = NewTaggedType(eType_Open, eTagType_Explicit, 0);
    co1->U.Normal.NamedType = NewNamedType("notation", ty);
    ty = NewTaggedType(eType_OctetString, eTagType_Explicit, 1);
    co2->U.Normal.NamedType = NewNamedType("encoded", ty);
    ty = NewType(eType_Choice);
    ty->U.Choice.Components = co1;
    a = NewAssignment(eAssignment_Type);
    a->U.Type.Type = ty;
    a->Identifier = "ASN1characterstring_data_value_t";
    a->Module = Builtin_Module;
    a->Next = Builtin_Assignments;
    Builtin_Assignments = a;

    /* CHARACTER STRING */
    co1 = NewComponent(eComponent_Normal);
    co2 = co1->Next = NewComponent(eComponent_Normal);
    ty = NewTaggedType(eType_Reference, eTagType_Implicit, 0);
    ty->U.Reference.Identifier = "ASN1characterstring_identification_t";
    ty->U.Reference.Module = Builtin_Module;
    co1->U.Normal.NamedType = NewNamedType("identification", ty);
    ty = NewTaggedType(eType_Reference, eTagType_Implicit, 2);
    ty->U.Reference.Identifier = "ASN1characterstring_data_value_t";
    ty->U.Reference.Module = Builtin_Module;
    co2->U.Normal.NamedType = NewNamedType("data-value", ty);
    Builtin_Type_CharacterString = NewType(eType_CharacterString);
    Builtin_Type_CharacterString->U.CharacterString.Components = co1;

    /* ABSTRACT-SYNTAX */
    fs1 = NewFieldSpec(eFieldSpec_FixedTypeValue);
    fs2 = fs1->Next = NewFieldSpec(eFieldSpec_Type);
    fs3 = fs2->Next = NewFieldSpec(eFieldSpec_FixedTypeValue);
    fs1->Identifier = "&id";
    fs1->U.FixedTypeValue.Type = Builtin_Type_ObjectIdentifier;
    fs1->U.FixedTypeValue.Unique = 1;
    fs1->U.FixedTypeValue.Optionality = NewOptionality(eOptionality_Normal);
    fs2->Identifier = "&Type";
    fs2->U.Type.Optionality = NewOptionality(eOptionality_Normal);
    fs3->U.FixedTypeValue.Type = ty = NewType(eType_BitString);
    ty->U.BitString.NamedNumbers = NewNamedNumber(eNamedNumber_Normal);
    ty->U.BitString.NamedNumbers->U.Normal.Identifier =
    "handles-invalid-encodings";
    ty->U.BitString.NamedNumbers->U.Normal.Value = Builtin_Value_Integer_0;
    fs3->U.FixedTypeValue.Optionality =
    NewOptionality(eOptionality_Default_Value);
    fs3->U.FixedTypeValue.Optionality->U.Value = NewValue(NULL, ty);
    sy1 = NewSyntaxSpec(eSyntaxSpec_Field);
    sy2 = sy1->Next = NewSyntaxSpec(eSyntaxSpec_Literal);
    sy3 = sy2->Next = NewSyntaxSpec(eSyntaxSpec_Literal);
    sy4 = sy3->Next = NewSyntaxSpec(eSyntaxSpec_Field);
    sy5 = sy4->Next = NewSyntaxSpec(eSyntaxSpec_Optional);
    sy6 = sy5->U.Optional.SyntaxSpec = NewSyntaxSpec(eSyntaxSpec_Literal);
    sy7 = sy6->Next = NewSyntaxSpec(eSyntaxSpec_Literal);
    sy8 = sy7->Next = NewSyntaxSpec(eSyntaxSpec_Field);
    sy1->U.Field.Field = "&Type";
    sy2->U.Literal.Literal = "IDENTIFIED";
    sy3->U.Literal.Literal = "BY";
    sy4->U.Field.Field = "&id";
    sy6->U.Literal.Literal = "HAS";
    sy7->U.Literal.Literal = "PROPERTY";
    sy8->U.Field.Field = "&property";
    Builtin_ObjectClass_AbstractSyntax =
    NewObjectClass(eObjectClass_ObjectClass);
    Builtin_ObjectClass_AbstractSyntax->U.ObjectClass.FieldSpec = fs1;
    Builtin_ObjectClass_AbstractSyntax->U.ObjectClass.SyntaxSpec = sy1;

    /* TYPE-IDENTIFIER */
    fs1 = NewFieldSpec(eFieldSpec_FixedTypeValue);
    fs2 = fs1->Next = NewFieldSpec(eFieldSpec_Type);
    fs1->Identifier = "&id";
    fs1->U.FixedTypeValue.Type = Builtin_Type_ObjectIdentifier;
    fs1->U.FixedTypeValue.Unique = 1;
    fs1->U.FixedTypeValue.Optionality = NewOptionality(eOptionality_Normal);
    fs2->Identifier = "&Type";
    fs2->U.Type.Optionality = NewOptionality(eOptionality_Normal);
    sy1 = NewSyntaxSpec(eSyntaxSpec_Field);
    sy2 = sy1->Next = NewSyntaxSpec(eSyntaxSpec_Literal);
    sy3 = sy2->Next = NewSyntaxSpec(eSyntaxSpec_Literal);
    sy4 = sy3->Next = NewSyntaxSpec(eSyntaxSpec_Field);
    sy1->U.Field.Field = "&Type";
    sy2->U.Literal.Literal = "IDENTIFIED";
    sy3->U.Literal.Literal = "BY";
    sy4->U.Field.Field = "&id";
    Builtin_ObjectClass_TypeIdentifier =
    NewObjectClass(eObjectClass_ObjectClass);
    Builtin_ObjectClass_TypeIdentifier->U.ObjectClass.FieldSpec = fs1;
    Builtin_ObjectClass_TypeIdentifier->U.ObjectClass.SyntaxSpec = sy1;
#endif

    /* object identifiers components */

#ifndef NO_OBJID
    Builtin_ObjIds = oi0 = NewAssignedObjId();
    oi0->Next = oi1 = NewAssignedObjId();
    oi1->Next = oi2 = NewAssignedObjId();

    /* { itu-t(0) }, { ccitt(0) } */
    oi0->Number = 0;
    oi0->Names = s1 = NewString();
    s1->Next = s2 = NewString();
    s1->String = "itu-t";
    s2->String = "ccitt";

    /* { iso(1) } */
    oi1->Number = 1;
    oi1->Names = s1 = NewString();
    s1->String = "iso";

    /* { joint-iso-itu-t(2) }, { joint-iso-ccitt(2) } */
    oi2->Number = 2;
    oi2->Names = s1 = NewString();
    s1->Next = s2 = NewString();
    s1->String = "joint-iso-itu-t";
    s2->String = "joint-iso-ccitt";

    oi0->Child = oi0_0 = NewAssignedObjId();
    oi0_0->Next = oi0_1 = NewAssignedObjId();
    oi0_1->Next = oi0_2 = NewAssignedObjId();
    oi0_2->Next = oi0_3 = NewAssignedObjId();
    oi0_3->Next = oi0_4 = NewAssignedObjId();

    /* { itu-t recommendation(0) } */
    oi0_0->Number = 0;
    oi0_0->Names = s1 = NewString();
    s1->String = "recommendation";

    /* { itu-t question(1) } */
    oi0_1->Number = 1;
    oi0_1->Names = s1 = NewString();
    s1->String = "question";

    /* { itu-t administration(2) } */
    oi0_2->Number = 2;
    oi0_2->Names = s1 = NewString();
    s1->String = "administration";

    /* { itu-t network-operator(3) } */
    oi0_3->Number = 3;
    oi0_3->Names = s1 = NewString();
    s1->String = "network-operator";

    /* { itu-t identified-organization(4) } */
    oi0_4->Number = 4;
    oi0_4->Names = s1 = NewString();
    s1->String = "identified-organization";

    /* { itu-t recommendation a(1) } .. { itu-t recommendation z(26) } */
    oi = &oi0_0->Child;
    for (i = 'a'; i <= 'z'; i++) {
    *oi = NewAssignedObjId();
    (*oi)->Number = i - 'a' + 1;
    (*oi)->Names = s1 = NewString();
    s1->String = (char *)malloc(2);
    s1->String[0] = (char)i;
    s1->String[1] = 0;
    oi = &(*oi)->Next;
    }

    oi1->Child = oi1_0 = NewAssignedObjId();
    oi1_0->Next = oi1_2 = NewAssignedObjId();
    oi1_2->Next = oi1_3 = NewAssignedObjId();

    /* { iso standard(0) } */
    oi1_0->Number = 0;
    oi1_0->Names = s1 = NewString();
    s1->String = "standard";

    /* { iso member-body(2) } */
    oi1_2->Number = 2;
    oi1_2->Names = s1 = NewString();
    s1->String = "member-body";

    /* { iso identified-organization(3) } */
    oi1_3->Number = 3;
    oi1_3->Names = s1 = NewString();
    s1->String = "identified-organization";
#endif

    /* initialize ASN1-CHARACTER-MODULE */
    InitBuiltinASN1CharacterModule();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\asn1\asn1c\chrmodul.c ===
/* Copyright (C) Boris Nikolaus, Germany, 1996-1997. All rights reserved. */
/* Copyright (C) Microsoft Corporation, 1997-1998. All rights reserved. */

#include "precomp.h"

extern char32_t chrtab[];
ModuleIdentifier_t *Builtin_Character_Module;

void
InitBuiltinASN1CharacterModule()
{
	ModuleIdentifier_t *mid;
	Assignment_t *as;
	Value_t *va;
	Type_t *ty;
	Constraint_t *co;
	ElementSetSpec_t *es, **esp;
	SubtypeElement_t *se;

	Builtin_Character_Module = mid = NewModuleIdentifier();
	mid->Identifier = "ASN1-CHARACTER-MODULE";
	mid->ObjectIdentifier = NewValue(NULL, Builtin_Type_ObjectIdentifier);
	mid->ObjectIdentifier->U.ObjectIdentifier.Value.length = 5;
	mid->ObjectIdentifier->U.ObjectIdentifier.Value.value = (objectnumber_t *)malloc(5 * sizeof(objectnumber_t));
	mid->ObjectIdentifier->U.ObjectIdentifier.Value.value[0] = 2;
	mid->ObjectIdentifier->U.ObjectIdentifier.Value.value[1] = 1;
	mid->ObjectIdentifier->U.ObjectIdentifier.Value.value[2] = 0;
	mid->ObjectIdentifier->U.ObjectIdentifier.Value.value[3] = 0;
	mid->ObjectIdentifier->U.ObjectIdentifier.Value.value[4] = 0;
#ifndef NO_CHRMODULE
	as = NewAssignment(eAssignment_ModuleIdentifier);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "<module>";
	as->Module = mid;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_IA5String);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 0;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "nul";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_IA5String);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 1;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "soh";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_IA5String);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 2;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "stx";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_IA5String);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 3;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "etx";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_IA5String);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 4;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "eot";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_IA5String);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 5;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "enq";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_IA5String);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 6;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "ack";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_IA5String);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 7;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "bel";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_IA5String);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 8;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "bs";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_IA5String);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 9;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "ht";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_IA5String);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 10;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "lf";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_IA5String);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 11;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "vt";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_IA5String);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 12;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "ff";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_IA5String);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 13;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "cr";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_IA5String);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 14;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "so";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_IA5String);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 15;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "si";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_IA5String);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 16;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "dle";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_IA5String);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 17;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "dc1";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_IA5String);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 18;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "dc2";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_IA5String);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 19;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "dc3";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_IA5String);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 20;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "dc4";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_IA5String);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 21;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "nak";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_IA5String);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 22;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "syn";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_IA5String);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 23;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "etb";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_IA5String);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 24;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "can";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_IA5String);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 25;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "em";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_IA5String);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 26;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "sub";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_IA5String);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 27;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "esc";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_IA5String);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 28;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "is4";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_IA5String);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 29;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "is3";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_IA5String);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 30;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "is2";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_IA5String);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 31;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "is1";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_IA5String);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 32;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "del";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 33;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "space";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 34;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "exclamationMark";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 35;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "quotationMark";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 36;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "numberSign";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 37;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "dollarSign";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 38;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "percentSign";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 39;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "ampersand";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 40;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "apostrophe";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 41;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "leftParenthesis";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 42;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "rightParenthesis";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 43;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "asterisk";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 44;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "plusSign";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 45;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "comma";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 46;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "hyphen-minus";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 47;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "fullStop";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 48;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "solidus";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 49;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "digitZero";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 50;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "digitOne";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 51;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "digitTwo";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 52;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "digitThree";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 53;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "digitFour";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 54;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "digitFive";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 55;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "digitSix";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 56;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "digitSeven";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 57;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "digitEight";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 58;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "digitNine";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 59;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "colon";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 60;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "semicolon";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 61;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "less-thanSign";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 62;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "equalsSign";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 63;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "greater-thanSign";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 64;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "questionMark";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 65;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "commercialAt";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 66;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterA";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 67;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterB";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 68;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterC";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 69;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterD";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 70;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterE";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 71;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterF";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 72;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterG";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 73;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterH";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 74;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterI";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 75;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterJ";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 76;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterK";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 77;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterL";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 78;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterM";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 79;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterN";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 80;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterO";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 81;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterP";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 82;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterQ";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 83;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterR";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 84;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterS";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 85;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterT";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 86;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterU";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 87;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterV";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 88;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterW";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 89;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterX";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 90;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterY";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 91;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterZ";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 92;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "leftSquareBracket";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 93;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "reverseSolidus";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 94;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "rightSquareBracket";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 95;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "circumflexAccent";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 96;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "lowLine";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 97;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "graveAccent";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 98;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterA";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 99;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterB";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 100;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterC";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 101;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterD";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 102;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterE";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 103;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterF";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 104;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterG";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 105;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterH";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 106;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterI";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 107;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterJ";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 108;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterK";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 109;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterL";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 110;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterM";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 111;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterN";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 112;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterO";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 113;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterP";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 114;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterQ";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 115;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterR";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 116;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterS";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 117;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterT";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 118;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterU";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 119;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterV";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 120;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterW";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 121;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterX";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 122;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterY";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 123;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterZ";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 124;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "leftCurlyBracket";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 125;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "verticalLine";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 126;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "rightCurlyBracket";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 127;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "tilde";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	ty = NewType(eType_BMPString);
	ty->Constraints = co = NewConstraint();
	co->Root = es = NewElementSetSpec(eElementSetSpec_SubtypeElement);
	es->U.SubtypeElement.SubtypeElement = se = NewSubtypeElement(eSubtypeElement_PermittedAlphabet);
	se->U.PermittedAlphabet.Constraints = co = NewConstraint();
	esp = &co->Root;
	(*esp) = es = NewElementSetSpec(eElementSetSpec_SubtypeElement);
	es->U.SubtypeElement.SubtypeElement = se = NewSubtypeElement(eSubtypeElement_ValueRange);
	se->U.ValueRange.Lower.Flags = 0;
	se->U.ValueRange.Lower.Value = va = NewValue(NULL, ty);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 33;
	se->U.ValueRange.Upper.Flags = 0;
	se->U.ValueRange.Upper.Value = va = NewValue(NULL, ty);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 127;
	as = NewAssignment(eAssignment_Type);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "BasicLatin";
	as->Module = mid;
	as->U.Type.Type = ty;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 128;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "no-breakSpace";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 129;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "invertedExclamationMark";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 130;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "centSign";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 131;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "poundSign";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 132;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "currencySign";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 133;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "yenSign";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 134;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "brokenBar";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 135;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "sectionSign";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 136;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "diaeresis";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 137;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "copyrightSign";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 138;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "feminineOrdinalIndicator";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 139;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "left-pointingDoubleAngleQuotationMark";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 140;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "notSign";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 141;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "softHyphen";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 142;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "registeredSign";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 143;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "macron";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 144;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "degreeSign";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 145;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "plus-minusSign";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 146;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "superscriptTwo";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 147;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "superscriptThree";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 148;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "acuteAccent";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 149;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "microSign";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 150;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "pilcrowSign";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 151;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "middleDot";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 152;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "cedilla";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 153;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "superscriptOne";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 154;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "masculineOrdinalIndicator";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 155;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "right-pointingDoubleAngleQuotationMark";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 156;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "vulgarFractionOneQuarter";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 157;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "vulgarFractionOneHalf";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 158;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "valgarFractionThreeQuarters";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 159;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "invertedQuestionMark";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 160;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterAWithGrave";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 161;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterAWithAcute";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 162;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterAWithCircumflex";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 163;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterAWithTilde";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 164;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterAWithDiaeresis";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 165;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterAWithRingAbove";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 166;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterAe";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 167;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterCWithCedilla";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 168;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterEWithGrave";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 169;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterEWithAcute";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 170;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterEWithCircumflex";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 171;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterEWithDiaeresis";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 172;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterIWithGrave";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 173;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterIWithAcute";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 174;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterIWithCircumflex";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 175;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterIWithDiaeresis";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 176;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterEth";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 177;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterNWithTilde";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 178;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterOWithGrave";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 179;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterOWithAcute";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 180;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterOWithCircumflex";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 181;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterOTilde";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 182;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterOWithDiaeresis";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 183;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "multiplicationSign";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 184;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterOWithStroke";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 185;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterUWithGrave";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 186;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterUWithAcute";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 187;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterUWithCircumflex";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 188;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterUWithDiaeresis";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 189;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterYWithAcute";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 190;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterThorn";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 191;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterSharpS";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 192;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterAWithGrave";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 193;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterAWithAcute";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 194;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterAWithCircumflex";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 195;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterAWithTilde";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 196;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterAWithDiaeresis";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 197;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterAWithRingAbove";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 198;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterAe";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 199;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterCWithCedilla";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 200;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterEWithGrave";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 201;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterEWithAcute";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 202;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterEWithCircumflex";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 203;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterEWithDiaeresis";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 204;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterIWithGrave";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 205;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterIWithAcute";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 206;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterIWithCircumflex";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 207;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterIWithDiaeresis";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 208;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterEth";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 209;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterNWithTilde";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 210;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterOWithGrave";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 211;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterOWithAcute";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 212;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterOWithCircumflex";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 213;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterOTilde";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 214;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterOWithDiaeresis";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 215;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "divisionSign";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 216;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterOWithStroke";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 217;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterUWithGrave";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 218;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterUWithAcute";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 219;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterUWithCircumflex";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 220;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterUWithDiaeresis";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 221;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterYWithAcute";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 222;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterThorn";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 223;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterYWithDiaeresis";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	ty = NewType(eType_BMPString);
	ty->Constraints = co = NewConstraint();
	co->Root = es = NewElementSetSpec(eElementSetSpec_SubtypeElement);
	es->U.SubtypeElement.SubtypeElement = se = NewSubtypeElement(eSubtypeElement_PermittedAlphabet);
	se->U.PermittedAlphabet.Constraints = co = NewConstraint();
	esp = &co->Root;
	(*esp) = es = NewElementSetSpec(eElementSetSpec_SubtypeElement);
	es->U.SubtypeElement.SubtypeElement = se = NewSubtypeElement(eSubtypeElement_ValueRange);
	se->U.ValueRange.Lower.Flags = 0;
	se->U.ValueRange.Lower.Value = va = NewValue(NULL, ty);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 128;
	se->U.ValueRange.Upper.Flags = 0;
	se->U.ValueRange.Upper.Value = va = NewValue(NULL, ty);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 223;
	as = NewAssignment(eAssignment_Type);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "Latin-1Supplement";
	as->Module = mid;
	as->U.Type.Type = ty;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 224;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterAWithMacron";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 225;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterAWithMacron";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 226;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterAWithBreve";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 227;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterAWithBreve";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 228;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterAWithOgonek";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 229;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterAWithOgonek";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 230;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterCWithAcute";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 231;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterCWithAcute";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 232;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterCWithCircumflex";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 233;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterCWithCircumflex";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 234;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterCWithDotAbove";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 235;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterCWithDotAbove";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 236;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterCWithCaron";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 237;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterCWithCaron";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 238;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterDWithCaron";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 239;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterDWithCaron";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 240;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterDWithStroke";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 241;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterDWithStroke";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 242;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterEWithMacron";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 243;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterEWithMacron";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 244;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterEWithBreve";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 245;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterEWithBreve";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 246;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterEWithDotAbove";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 247;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterEWithDotAbove";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 248;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterEWithOgonek";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 249;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterEWithOgonek";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 250;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterEWithCaron";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 251;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterEWithCaron";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 252;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterGWithCircumflex";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 253;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterGWithCircumflex";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 254;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterGWithBreve";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 255;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterGWithBreve";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 256;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterGWithDotAbove";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 257;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterGWithDotAbove";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 258;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterGWithCedilla";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 259;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterGWithCedilla";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 260;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterHWithCircumflex";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 261;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterHWithCircumflex";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 262;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterHWithStroke";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 263;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterHWithStroke";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 264;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterIWithTilde";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 265;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterIWithTilde";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 266;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterIWithMacron";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 267;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterIWithMacron";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 268;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterIWithBreve";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 269;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterIWithBreve";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 270;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterIWithOgonek";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 271;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterIWithOgonek";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 272;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterWithDotAbove";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 273;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterDotlessI";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 274;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLigatureIj";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 275;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLigatureIj";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 276;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterJWithCircumflex";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 277;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterJWithCircumflex";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 278;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterKWithCedilla";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 279;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterKWithCedilla";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 280;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterKra";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 281;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterLWithAcute";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 282;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterLWithAcute";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 283;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterLWithCedilla";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 284;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterLWithCedilla";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 285;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterLWithCaron";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 286;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterLWithCaron";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 287;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterLWithMiddleDot";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 288;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterLWithMiddleDot";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 289;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterLWithStroke";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 290;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterLWithStroke";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 291;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterNWithAcute";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 292;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterNWithAcute";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 293;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterNWithCedilla";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 294;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterNWithCedilla";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 295;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterNWithCaron";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 296;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterNWithCaron";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 297;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterNPrecededByApostrophe";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 298;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterEng";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 299;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterEng";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 300;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterOWithMacron";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 301;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterOWithMacron";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 302;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterOWithBreve";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 303;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterOWithBreve";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 304;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterOWithDoubleAcute";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 305;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterOWithDoubleAcute";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 306;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLigatureOe";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 307;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLigatureOe";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 308;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterRWithAcute";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 309;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterRWithAcute";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 310;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterRWithCedilla";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 311;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterRWithCedilla";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 312;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterRWithCaron";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 313;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterRWithCaron";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 314;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterSWithAcute";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 315;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterSWithAcute";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 316;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterSWithCircumflex";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 317;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterSWithCircumflex";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 318;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterSWithCedilla";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 319;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterSWithCedilla";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 320;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterSWithCaron";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 321;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterSWithCaron";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 322;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterTWithCedilla";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 323;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterTWithCedilla";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 324;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterTWithCaron";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 325;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterTWithCaron";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 326;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterTWithStroke";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 327;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterTWithStroke";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 328;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterUWithTilde";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 329;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterUWithTilde";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 330;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterUWithMacron";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 331;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterUWithMacron";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 332;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterUWithBreve";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 333;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterUWithBreve";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 334;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterUWithRingAbove";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 335;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterUWithRingAbove";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 336;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterUWithDoubleAcute";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 337;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterUWithDoubleAcute";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 338;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterUWithOgonek";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 339;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterUWithOgonek";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 340;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterWWithCircumflex";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 341;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterWWithCircumflex";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 342;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterYWithCircumflex";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 343;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterYWithCircumflex";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 344;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterYWithDiaeresis";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 345;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterZWithAcute";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 346;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterZWithAcute";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 347;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterZWithDotAbove";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 348;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterZWithDotAbove";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 349;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterZWithCaron";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 350;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterZWithCaron";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 351;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterLongS";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	ty = NewType(eType_BMPString);
	ty->Constraints = co = NewConstraint();
	co->Root = es = NewElementSetSpec(eElementSetSpec_SubtypeElement);
	es->U.SubtypeElement.SubtypeElement = se = NewSubtypeElement(eSubtypeElement_PermittedAlphabet);
	se->U.PermittedAlphabet.Constraints = co = NewConstraint();
	esp = &co->Root;
	(*esp) = es = NewElementSetSpec(eElementSetSpec_SubtypeElement);
	es->U.SubtypeElement.SubtypeElement = se = NewSubtypeElement(eSubtypeElement_ValueRange);
	se->U.ValueRange.Lower.Flags = 0;
	se->U.ValueRange.Lower.Value = va = NewValue(NULL, ty);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 224;
	se->U.ValueRange.Upper.Flags = 0;
	se->U.ValueRange.Upper.Value = va = NewValue(NULL, ty);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 351;
	as = NewAssignment(eAssignment_Type);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "LatinExtended-a";
	as->Module = mid;
	as->U.Type.Type = ty;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 352;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterBWithStroke";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 353;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterBWithHook";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 354;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterBWithTopbar";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 355;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterBWithTopbar";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 356;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterToneSix";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 357;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterToneSix";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 358;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterOpenO";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 359;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterCWithHook";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 360;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterCWithHook";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 361;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterAfricanD";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 362;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterDWithHook";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 363;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterDWithTopbar";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 364;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterDWithTopbar";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 365;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterTurnedDelta";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 366;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterReverseE";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 367;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterSchwa";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 368;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterOpenE";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 369;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterFWithHook";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 370;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterFWithHook";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 371;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterGWithHook";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 372;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterGamma";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 373;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterHv";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 374;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterIota";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 375;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterIWithStroke";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 376;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterKWithHook";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 377;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterKWithHook";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 378;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterLWithBar";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 379;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterLambdaWithStroke";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 380;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterTurnedM";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 381;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterNWithLeftHook";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 382;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterNWithLongRightLeg";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 383;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterOWithMiddleTilde";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 384;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterOWithHorn";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 385;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterOWithHorn";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 386;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterOi";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 387;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterOi";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 388;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterPWithHook";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 389;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterPWithHook";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 390;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinLetterYr";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 391;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterToneTwo";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 392;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterToneTwo";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 393;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterEsh";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 394;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinLetterReversedEshLoop";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 395;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterTWithPalatalHook";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 396;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterTWithHook";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 397;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterTWithHook";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 398;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterTWithRetroflexHook";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 399;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterUWithHorn";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 400;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterUWithHorn";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 401;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterUpsilon";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 402;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterVWithHook";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 403;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterYWithHook";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 404;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterYWithHook";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 405;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterZWithStroke";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 406;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterZWithStroke";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 407;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterEzh";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 408;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterEzhReversed";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 409;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterEzhReversed";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 410;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterEzhWithTail";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 411;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinLetterTwoWithStroke";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 412;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterToneFive";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 413;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterToneFive";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 414;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinLetterInvertedGlottalStopWithStroke";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 415;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinLetterWynn";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 416;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinLetterDentalClick";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 417;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinLetterLateralClick";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 418;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinLetterAlveolarClick";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 419;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinLetterRetroflexClick";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 420;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterDzWithCaron";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 421;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterDWithSmallLetterZWithCaron";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 422;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterDzWithCaron";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 423;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterLj";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 424;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterLWithSmallLetterJ";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 425;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterLj";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 426;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterNj";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 427;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterNWithSmallLetterJ";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 428;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterNj";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 429;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterAWithCaron";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 430;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterAWithCaron";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 431;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterIWithCaron";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 432;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterIWithCaron";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 433;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterOWithCaron";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 434;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterOWithCaron";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 435;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterUWithCaron";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 436;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterUWithCaron";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 437;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterUWithDiaeresisAndMacron";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 438;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterUWithDiaeresisAndMacron";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 439;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterUWithDiaeresisAndAcute";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 440;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterUWithDiaeresisAndAcute";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 441;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterUWithDiaeresisAndCaron";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 442;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterUWithDiaeresisAndCaron";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 443;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterUWithDiaeresisAndGrave";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 444;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterUWithDiaeresisAndGrave";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 445;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterTurnedE";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 446;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterAWithDiaeresisAndMacron";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 447;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterAWithDiaeresisAndMacron";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 448;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterAWithDotAboveAndMacron";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 449;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterAWithDotAboveAndMacron";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 450;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterAeWithMacron";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 451;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterAeWithMacron";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 452;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterGWithStroke";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 453;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterGWithStroke";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 454;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterGWithCaron";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 455;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterGWithCaron";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 456;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterKWithCaron";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 457;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterKWithCaron";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 458;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterOWithOgonek";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 459;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterOWithOgonek";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 460;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterOWithOgonekAndMacron";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 461;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterOWithOgonekAndMacron";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 462;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterEzhWithCaron";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 463;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterEzhWithCaron";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 464;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterJWithCaron";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 465;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterDz";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 466;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterDWithSmallLetterZ";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 467;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterDz";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 468;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterGWithAcute";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 469;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterGWithAcute";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 470;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterAWithRingAboveAndAcute";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 471;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterAWithRingAboveAndAcute";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 472;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterAeWithAcute";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 473;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterAeWithAcute";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 474;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterOWithStrokeAndAcute";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 475;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterOWithStrokeAndAcute";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 476;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterAWithDoubleGrave";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 477;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterAWithDoubleGrave";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 478;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterAWithInvertedBreve";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 479;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterAWithInvertedBreve";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 480;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterEWithDoubleGrave";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 481;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterEWithDoubleGrave";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 482;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterEWithInvertedBreve";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 483;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterEWithInvertedBreve";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 484;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterIWithDoubleGrave";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 485;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterIWithDoubleGrave";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 486;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterIWithInvertedBreve";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 487;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterIWithInvertedBreve";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 488;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterOWithDoubleGrave";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 489;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterOWithDoubleGrave";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 490;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterOWithInvertedBreve";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 491;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterOWithInvertedBreve";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 492;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterRWithDoubleGrave";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 493;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterRWithDoubleGrave";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 494;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterRWithInvertedBreve";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 495;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterRWithInvertedBreve";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 496;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterUWithDoubleGrave";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 497;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterUWithDoubleGrave";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 498;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterUWithInvertedBreve";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 499;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterUWithInvertedBreve";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	ty = NewType(eType_BMPString);
	ty->Constraints = co = NewConstraint();
	co->Root = es = NewElementSetSpec(eElementSetSpec_SubtypeElement);
	es->U.SubtypeElement.SubtypeElement = se = NewSubtypeElement(eSubtypeElement_PermittedAlphabet);
	se->U.PermittedAlphabet.Constraints = co = NewConstraint();
	esp = &co->Root;
	*esp = NewElementSetSpec(eElementSetSpec_Union);
	(*esp)->U.Union.Elements1 = es = NewElementSetSpec(eElementSetSpec_SubtypeElement);
	es->U.SubtypeElement.SubtypeElement = se = NewSubtypeElement(eSubtypeElement_ValueRange);
	se->U.ValueRange.Lower.Flags = 0;
	se->U.ValueRange.Lower.Value = va = NewValue(NULL, ty);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 352;
	se->U.ValueRange.Upper.Flags = 0;
	se->U.ValueRange.Upper.Value = va = NewValue(NULL, ty);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 0;
esp = &(*esp)->U.Union.Elements2;
	(*esp) = es = NewElementSetSpec(eElementSetSpec_SubtypeElement);
	es->U.SubtypeElement.SubtypeElement = se = NewSubtypeElement(eSubtypeElement_ValueRange);
	se->U.ValueRange.Lower.Flags = 0;
	se->U.ValueRange.Lower.Value = va = NewValue(NULL, ty);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 0;
	se->U.ValueRange.Upper.Flags = 0;
	se->U.ValueRange.Upper.Value = va = NewValue(NULL, ty);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 499;
	as = NewAssignment(eAssignment_Type);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "LatinExtended-b";
	as->Module = mid;
	as->U.Type.Type = ty;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	ty = NewType(eType_BMPString);
	ty->Constraints = co = NewConstraint();
	co->Root = es = NewElementSetSpec(eElementSetSpec_SubtypeElement);
	es->U.SubtypeElement.SubtypeElement = se = NewSubtypeElement(eSubtypeElement_PermittedAlphabet);
	se->U.PermittedAlphabet.Constraints = co = NewConstraint();
	esp = &co->Root;
	(*esp) = es = NewElementSetSpec(eElementSetSpec_SubtypeElement);
	es->U.SubtypeElement.SubtypeElement = se = NewSubtypeElement(eSubtypeElement_SingleValue);
	se->U.SingleValue.Value = va = NewValue(NULL, ty);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 0;
	as = NewAssignment(eAssignment_Type);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "Level3";
	as->Module = mid;
	as->U.Type.Type = ty;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
#endif /* NO_CHRMODULE */
}

char32_t chrtab[] = {
	0, 1, 2, 3, 4, 5, 6, 7,
	8, 9, 10, 11, 12, 13, 14, 15,
	16, 17, 18, 19, 20, 21, 22, 23,
	24, 25, 26, 27, 28, 29, 30, 31,
	127, 32, 33, 34, 35, 36, 37, 38,
	39, 40, 41, 42, 43, 44, 45, 46,
	47, 48, 49, 50, 51, 52, 53, 54,
	55, 56, 57, 58, 59, 60, 61, 62,
	63, 64, 65, 66, 67, 68, 69, 70,
	71, 72, 73, 74, 75, 76, 77, 78,
	79, 80, 81, 82, 83, 84, 85, 86,
	87, 88, 89, 90, 91, 92, 93, 94,
	95, 96, 97, 98, 99, 100, 101, 102,
	103, 104, 105, 106, 107, 108, 109, 110,
	111, 112, 113, 114, 115, 116, 117, 118,
	119, 120, 121, 122, 123, 124, 125, 126,
	160, 161, 162, 163, 164, 165, 166, 167,
	168, 169, 170, 171, 172, 173, 174, 175,
	176, 177, 178, 179, 180, 181, 182, 183,
	184, 185, 186, 187, 188, 189, 190, 191,
	192, 193, 194, 195, 196, 197, 198, 199,
	200, 201, 202, 203, 204, 205, 206, 207,
	208, 209, 210, 211, 212, 213, 214, 215,
	216, 217, 218, 219, 220, 221, 222, 223,
	224, 225, 226, 227, 228, 229, 230, 231,
	232, 233, 234, 235, 236, 237, 238, 239,
	240, 241, 242, 243, 244, 245, 246, 247,
	248, 249, 250, 251, 252, 253, 254, 255,
	256, 257, 258, 259, 260, 261, 262, 263,
	264, 265, 266, 267, 268, 269, 270, 271,
	272, 273, 274, 275, 276, 277, 278, 279,
	280, 281, 282, 283, 284, 285, 286, 287,
	288, 289, 290, 291, 292, 293, 294, 295,
	296, 297, 298, 299, 300, 301, 302, 303,
	304, 305, 306, 307, 308, 309, 310, 311,
	312, 313, 314, 315, 316, 317, 318, 319,
	320, 321, 322, 323, 324, 325, 326, 327,
	328, 329, 330, 331, 332, 333, 334, 335,
	336, 337, 338, 339, 340, 341, 342, 343,
	344, 345, 346, 347, 348, 349, 350, 351,
	352, 353, 354, 355, 356, 357, 358, 359,
	360, 361, 362, 363, 364, 365, 366, 367,
	368, 369, 370, 371, 372, 373, 374, 375,
	376, 377, 378, 379, 380, 381, 382, 383,
	384, 385, 386, 387, 388, 389, 390, 391,
	392, 393, 394, 395, 396, 397, 398, 399,
	400, 401, 402, 403, 404, 405, 406, 407,
	408, 409, 410, 411, 412, 413, 414, 415,
	416, 417, 418, 419, 420, 421, 422, 423,
	424, 425, 426, 427, 428, 429, 430, 431,
	432, 433, 434, 435, 436, 437, 438, 439,
	440, 441, 442, 443, 444, 445, 446, 447,
	448, 449, 450, 451, 452, 453, 454, 455,
	456, 457, 458, 459, 460, 461, 462, 463,
	464, 465, 466, 467, 468, 469, 470, 471,
	472, 473, 474, 475, 476, 477, 478, 479,
	480, 481, 482, 483, 484, 485, 486, 487,
	488, 489, 490, 491, 492, 493, 494, 495,
	496, 497, 498, 499, 500, 501, 506, 507,
	508, 509, 510, 511, 512, 513, 514, 515,
	516, 517, 518, 519, 520, 521, 522, 523,
	524, 525, 526, 527, 528, 529, 530, 531,
	532, 533, 534, 535
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\asn1\asn1c\error.h ===
/* Copyright (C) Boris Nikolaus, Germany, 1996-1997. All rights reserved. */
/* Copyright (C) Microsoft Corporation, 1997-1998. All rights reserved. */

#ifndef _ASN1C_ERROR_H_
#define _ASN1C_ERROR_H_

#define E_success				0
#define E_systemerror				1
#define E_COMPONENTS_OF_in_extension		2
#define E_applied_COMPONENTS_OF_to_bad_type	3
#define E_COMPONENTS_OF_extended_type		4
#define E_bad_component_in_selectiontype	5
#define E_selection_of_bad_type			6
#define E_recursive_type_definition		7
#define E_undefined_typereference		8
#define E_unterminated_string			9
#define E_bad_character				10
#define E_duplicate_tag				11
#define E_bad_directive				12
#define E_constraint_too_complex		13

void error(int errornr, LLPOS *pos);

#endif // _ASN1C_ERROR_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\asn1\asn1c\error.c ===
/* Copyright (C) Boris Nikolaus, Germany, 1996-1997. All rights reserved. */
/* Copyright (C) Microsoft Corporation, 1997-1998. All rights reserved. */

#include "precomp.h"
#include "error.h"

/* MyAbort by an error message */
void
error(int errornr, LLPOS *pos)
{
    char errbuf[256];

    switch (errornr) {
    case E_systemerror:
	strcpy(errbuf, strerror(errno));
	break;
    case E_COMPONENTS_OF_in_extension:
	strcpy(errbuf, "`COMPONENTS OF' may not be used in extensions");
	break;
    case E_applied_COMPONENTS_OF_to_bad_type:
	strcpy(errbuf, "`COMPONENTS OF' must be applied to SEQUENCE/SET/CHOICE type");
	break;
    case E_COMPONENTS_OF_extended_type:
	strcpy(errbuf, "`COMPONENTS OF' can only be applied to unextended types");
	break;
    case E_bad_component_in_selectiontype:
	strcpy(errbuf, "unknown component in selection type");
	break;
    case E_selection_of_bad_type:
	strcpy(errbuf, "selection type can only be applied to SEQUENCE/SET/CHOICE types");
	break;
    case E_recursive_type_definition:
	strcpy(errbuf, "recursive type definition, introduce --<POINTER>-- to break recursion");
	break;
    case E_undefined_typereference:
	strcpy(errbuf, "undefined type reference");
	break;
    case E_unterminated_string:
	strcpy(errbuf, "unterminated string constant");
	break;
    case E_bad_character:
	strcpy(errbuf, "bad character in file");
	break;
    case E_duplicate_tag:
	strcpy(errbuf, "duplicate tag in sequence/set/choice type");
	break;
    case E_bad_directive:
	strcpy(errbuf, "directive does not fit to given type");
	break;
    case E_constraint_too_complex:
	strcpy(errbuf, "constraint is too complex");
	break;
    default:
	sprintf(errbuf, "unknown error 0x%x", errornr);
	break;
    }
    ASSERT(0);
    llerror(stderr, pos, "%s", errbuf);
    /*NOTREACHED*/
}

/* print an error message: */
/* print the file name, the line number, the line and mark the column where */
/* the error occured and terminate unsuccessful */
void
llverror(FILE *f, LLPOS *pos, char *fmt, va_list args)
{
    char *p, *q;
    int i;

    if (pos) {
	p = file;
	for (i = 1; i < pos->line; i++) {
	    p = strchr(p, '\n');
	    if (!p)
		break;
	    p++;
	}
	if (pos && pos->file)
	    fprintf(f, "File %s, line %d:\n", pos->file, pos->line);
	if (p && (q = strchr(p, '\n'))) {
	    if (q[-1] == '\r')
		q--;
	    fprintf(f, "%.*s\n", q - p, p);
	    for (i = 0; i < pos->column - 1; i++)
		putc(p[i] == '\t' ? '\t' : ' ', f);
	    fprintf(f, "^ ");
	}
    }
    vfprintf(f, fmt, args);
    putc('\n', f);
    MyExit(1);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\asn1\asn1c\defs.h ===
/* Copyright (C) Boris Nikolaus, Germany, 1996-1997. All rights reserved. */
/* Copyright (C) Microsoft Corporation, 1997-1998. All rights reserved. */

#ifndef _ASN1C_DEFS_H_
#define _ASN1C_DEFS_H_

typedef struct Assignment_s Assignment_t;
typedef struct UndefinedSymbol_s UndefinedSymbol_t;
typedef struct AssignedObjId_s AssignedObjId_t;
typedef struct AssignedModules_s AssignedModules_t;
typedef struct Type_s Type_t;
typedef struct Tag_s Tag_t;
typedef struct EndPoint_s EndPoint_t;
typedef struct ElementSetSpec_s ElementSetSpec_t;
typedef struct SubtypeElement_s SubtypeElement_t;
typedef struct ObjectSetElement_s ObjectSetElement_t;
typedef struct Constraint_s Constraint_t;
typedef struct NamedConstraint_s NamedConstraint_t;
typedef struct PERConstraint_s PERConstraint_t;
typedef struct PERConstraints_s PERConstraints_t;
typedef struct ValueConstraint_s ValueConstraint_t;
typedef struct NamedNumber_s NamedNumber_t;
typedef struct NamedType_s NamedType_t;
typedef struct NamedValue_s NamedValue_t;
typedef struct Component_s Component_t;
typedef struct Value_s Value_t;
typedef struct ValueSet_s ValueSet_t;
typedef struct Macro_s Macro_t;
typedef struct MacroProduction_s MacroProduction_t;
typedef struct NamedMacroProduction_s NamedMacroProduction_t;
typedef struct MacroLocalAssignment_s MacroLocalAssignment_t;
typedef struct Quadruple_s Quadruple_t;
typedef struct Tuple_s Tuple_t;
typedef struct Directive_s Directive_t;
typedef struct ModuleIdentifier_s ModuleIdentifier_t;
typedef struct NamedObjIdValue_s NamedObjIdValue_t;
typedef struct ObjectClass_s ObjectClass_t;
typedef struct Object_s Object_t;
typedef struct ObjectSet_s ObjectSet_t;
typedef struct Optionality_s Optionality_t;
typedef struct FieldSpec_s FieldSpec_t;
typedef struct SyntaxSpec_s SyntaxSpec_t;
typedef struct Setting_s Setting_t;
typedef struct String_s String_t;
typedef struct StringModule_s StringModule_t;
typedef struct PERSimpleTypeInfo_s PERSimpleTypeInfo_t;
typedef struct PERTypeInfo_s PERTypeInfo_t;
typedef struct BERTypeInfo_s BERTypeInfo_t;
typedef struct Arguments_s Arguments_t;

typedef Assignment_t *AssignmentList_t;
typedef AssignedObjId_t *AssignedObjIdList_t;
typedef Tag_t *TagList_t;
typedef NamedConstraint_t *NamedConstraintList_t;
typedef NamedNumber_t *NamedNumberList_t;
typedef ValueConstraint_t *ValueConstraintList_t;
typedef Component_t *ComponentList_t;
typedef NamedValue_t *NamedValueList_t;
typedef Directive_t *DirectiveList_t;
typedef Setting_t *SettingList_t;
typedef SyntaxSpec_t *SyntaxSpecList_t;
typedef FieldSpec_t *FieldSpecList_t;
typedef UndefinedSymbol_t *UndefinedSymbolList_t;
typedef NamedObjIdValue_t *NamedObjIdValueList_t;
typedef Value_t *ValueList_t;
typedef NamedMacroProduction_t *NamedMacroProductionList_t;
typedef MacroLocalAssignment_t *MacroLocalAssignmentList_t;
typedef String_t *StringList_t;
typedef StringModule_t *StringModuleList_t;

/* --- undefined element --- */

#define UNDEFINED_VALUE 1UL
#define UNDEFINED(_ptr) ((unsigned long)(_ptr) == UNDEFINED_VALUE)
#define DEFINED(_ptr) ((_ptr) && !UNDEFINED(_ptr))

/* --- Tag --- */

typedef enum {
    eTagType_Implicit,
    eTagType_Explicit,
    eTagType_Automatic,
    eTagType_Unknown
} TagType_e;

typedef enum {
    eTagClass_Universal          = 0x00,
    eTagClass_Application        = 0x40,
    eTagClass_Unknown            = 0x80,
    eTagClass_Private            = 0xc0
} TagClass_e;

struct Tag_s {
    TagList_t Next;
    TagType_e Type;
    TagClass_e Class;
    Value_t *Tag;
};

Tag_t *NewTag(TagType_e type);
Tag_t *DupTag(Tag_t *src);

/* --- Extension --- */

typedef enum {
    eExtension_Unconstrained,
    eExtension_Unextended,
    eExtension_Extendable,
    eExtension_Extended
} Extension_e;

/* --- Assignment --- */

typedef enum {
    eAssignment_Undefined,
    eAssignment_ModuleIdentifier,
    eAssignment_Type,
    eAssignment_Value,
    eAssignment_ObjectClass,
    eAssignment_Object,
    eAssignment_ObjectSet,
    eAssignment_Macro,
    eAssignment_Reference,
    eAssignment_NextPass
} Assignment_e;

typedef enum {
    eAssignmentFlags_Exported = 1,
    eAssignmentFlags_LongName = 2
} AssignmentFlags_e;

struct Assignment_s {
    AssignmentList_t Next;
    char *Identifier;
    ModuleIdentifier_t *Module;
    Assignment_e Type;
    AssignmentFlags_e Flags;
    int fImportedLocalDuplicate;
    int fGhost;
    TagType_e eDefTagType;
    union {
            struct {
            Type_t *Type;
        } Type;
        struct {
            Value_t *Value;
        } Value;
        struct {
            ObjectClass_t *ObjectClass;
        } ObjectClass;
        struct {
            Object_t *Object;
        } Object;
        struct {
            ObjectSet_t *ObjectSet;
        } ObjectSet;
        struct {
            Macro_t *Macro;
        } Macro;
        struct {
            char *Identifier;
            ModuleIdentifier_t *Module;
        } Reference;
    } U;
};

Assignment_t *NewAssignment(Assignment_e type);
Assignment_t *DupAssignment(Assignment_t *src);
Assignment_t *FindAssignment(AssignmentList_t a, Assignment_e type, char *ide, ModuleIdentifier_t *mod);
Assignment_t *FindExportedAssignment(AssignmentList_t a, Assignment_e type, char *ide, ModuleIdentifier_t *mod);
Assignment_t *FindAssignmentInCurrentPass(AssignmentList_t a, char *ide, ModuleIdentifier_t *mod);
Assignment_t *GetAssignment(AssignmentList_t ass, Assignment_t *a);
Assignment_e GetAssignmentType(AssignmentList_t ass, Assignment_t *a);
int AssignType(AssignmentList_t *ass, Type_t *lhs, Type_t *rhs);
int AssignValue(AssignmentList_t *ass, Value_t *lhs, Value_t *rhs);
int AssignModuleIdentifier(AssignmentList_t *ass, ModuleIdentifier_t *module);

/* --- AssignedObjIds --- */

struct AssignedObjId_s {
    AssignedObjIdList_t Next;
    StringList_t Names;
    uint32_t Number;
    AssignedObjId_t *Child;
};

AssignedObjId_t *NewAssignedObjId(void);
AssignedObjId_t *DupAssignedObjId(AssignedObjId_t *src);

typedef struct DefinedObjectID_s
{
    struct DefinedObjectID_s    *next;
    char                        *pszName;
    Value_t                     *pValue;
}
    DefinedObjectID_t;

extern DefinedObjectID_t *g_pDefinedObjectIDs;
Value_t *GetDefinedOIDValue ( char *pszName );
void AddDefinedOID ( char *pszName, Value_t *pValue );

/* --- TypeRules --- */

typedef enum {
    eTypeRules_Normal = 0x00,
    eTypeRules_Pointer = 0x01, // lonchanc: don't know what it is
    eTypeRules_SinglyLinkedList = 0x02, // --<LINKED>--
    eTypeRules_DoublyLinkedList = 0x04,
    eTypeRules_LengthPointer = 0x08, // --<UNBOUNDED>--
    eTypeRules_FixedArray = 0x10, // default
    eTypeRules_PointerToElement = 0x20, // --<POINTER>--
    eTypeRules_ZeroTerminated = 0x40,

    eTypeRules_LinkedListMask = (eTypeRules_SinglyLinkedList | eTypeRules_DoublyLinkedList),
    eTypeRules_PointerArrayMask = (eTypeRules_LengthPointer | eTypeRules_FixedArray),
    eTypeRules_PointerMask = (eTypeRules_LengthPointer | eTypeRules_PointerToElement),
    eTypeRules_IndirectMask = (eTypeRules_Pointer | eTypeRules_LinkedListMask | eTypeRules_PointerMask),
} TypeRules_e;

/* --- TypeFlags --- */

typedef enum {
    eTypeFlags_Null = 1,        /* type is not present in C, 'cause it's NULL */
    eTypeFlags_NullChoice = 2,        /* type is CHOICE with NULL-alternatives */
    eTypeFlags_ExtensionMarker = 4, /* type is extended */
    eTypeFlags_Simple = 8,        /* type has empty freefn, memcpy copyfn */
    eTypeFlags_Done = 0x10,
    eTypeFlags_GenType = 0x20,        /* generate a type */
    eTypeFlags_GenEncode = 0x40,        /* generate an encoding fn */
    eTypeFlags_GenDecode = 0x80,        /* generate a decoding fn */
    eTypeFlags_GenFree = 0x100,        /* generate a free fn */
    eTypeFlags_GenCheck = 0x200,        /* generate a check fn */
    eTypeFlags_GenCompare = 0x400,/* generate a cmp fn */
    eTypeFlags_GenCopy = 0x800,        /* generate a copy fn */
    eTypeFlags_GenPrint = 0x1000,        /* generate a print fn */
    eTypeFlags_GenPdu = 0x2000,        /* generate a pdu number */
    eTypeFlags_GenAll = 0x20+0x40+0x80+0x100+0x400+0x2000,
    eTypeFlags_GenSimple = 0x20+0x40+0x80+0x400+0x2000,
    eTypeFlags_MiddlePDU = 0x8000,
} TypeFlags_e;

/* ------ hack directives ------ */

typedef struct PrivateDirectives_s
{
    char   *pszTypeName;
    char   *pszFieldName;
    char   *pszValueName;
    int     fSLinked;
    int     fDLinked;
    int     fPublic;
    int     fLenPtr;
    int     fPointer; // pointer to fixed array, in PER SeqOf/SetOf only
    int     fArray;
    int     fIntx;
    int     fNoCode;
    int     fNoMemCopy;
    int     fOidPacked;
    int     fOidArray;
} PrivateDirectives_t;

void PropagatePrivateDirectives ( Type_t *pDst, PrivateDirectives_t *pSrc );
void PropagateReferenceTypePrivateDirectives ( Type_t *pDst, PrivateDirectives_t *pSrc );
char *GetPrivateValueName(PrivateDirectives_t *pPrivateDirectives, char *pszDefValueName);

/* --- ExtensionType --- */

typedef enum {
    eExtensionType_Automatic,
    eExtensionType_None
} ExtensionType_e;

/* --- PERConstraint --- */

struct PERConstraint_s {
    Extension_e Type;
    ValueConstraintList_t Root;
    ValueConstraintList_t Additional;
};

/* --- PERConstraints --- */

struct PERConstraints_s {
    PERConstraint_t Value;
    PERConstraint_t Size;
    PERConstraint_t PermittedAlphabet;
};

/* --- PERSimpleTypeInfo --- */

typedef enum {
    ePERSTIConstraint_Unconstrained,
    ePERSTIConstraint_Semiconstrained,
    ePERSTIConstraint_Upperconstrained,
    ePERSTIConstraint_Constrained
} PERSTIConstraint_e;

typedef enum {
    ePERSTIAlignment_BitAligned,
    ePERSTIAlignment_OctetAligned
} PERSTIAlignment_e;

typedef enum {
    ePERSTIData_Null,
    ePERSTIData_Boolean,
    ePERSTIData_Unsigned,
    ePERSTIData_Integer,
    ePERSTIData_Real,
    ePERSTIData_BitString,
    ePERSTIData_RZBBitString,
    ePERSTIData_OctetString,
    ePERSTIData_UTF8String,
    ePERSTIData_SequenceOf,
    ePERSTIData_SetOf,
    ePERSTIData_ObjectIdentifier,
    ePERSTIData_NormallySmall,
    ePERSTIData_String,
    ePERSTIData_TableString,
    ePERSTIData_ZeroString,
    ePERSTIData_ZeroTableString,
    ePERSTIData_Reference,
    ePERSTIData_Extension,
    ePERSTIData_External,
    ePERSTIData_EmbeddedPdv,
    ePERSTIData_MultibyteString,
    ePERSTIData_UnrestrictedString,
    ePERSTIData_GeneralizedTime,
    ePERSTIData_UTCTime,
    ePERSTIData_Open
} PERSTIData_e;

typedef enum {
    ePERSTILength_NoLength,
    ePERSTILength_Length,
    ePERSTILength_BitLength,
    ePERSTILength_SmallLength,
    ePERSTILength_InfiniteLength
} PERSTILength_e;

struct PERSimpleTypeInfo_s {
    PERSTIData_e Data;                        /* data type of value */
    char *TableIdentifier;                /* name of stringtable to use */
    ValueConstraintList_t Table;        /* stringtable values */
    Type_t *SubType;                        /* subtype */
    char *SubIdentifier;                /* name of subtype */
    NamedValue_t *Identification;        /* identification of EMB.PDV/CH.STR */
    PERSTIConstraint_e Constraint;        /* constraint of type values */
    intx_t LowerVal;                        /* lower bound of type values */
    intx_t UpperVal;                        /* upper bound of type values */
    uint32_t NBits;                        /* number of bits to use */
    PERSTIAlignment_e Alignment;        /* alignment for encoded value */
    PERSTILength_e Length;                /* type of length encoding */
    PERSTIConstraint_e LConstraint;        /* constraint of length */
    uint32_t LLowerVal;                        /* lower bound of length */
    uint32_t LUpperVal;                        /* upper bound of length */
    uint32_t LNBits;                        /* number of bits to use for length */
    PERSTIAlignment_e LAlignment;        /* alignment for encoded length */
    uint32_t cbFixedSizeBitString;      // number of bits in the bit string of fixed size
};

/* --- PERTypeInfo --- */

typedef enum {
    eBERSTIData_Null,
    eBERSTIData_Boolean,
    eBERSTIData_Unsigned,
    eBERSTIData_Integer,
    eBERSTIData_Real,
    eBERSTIData_BitString,
    eBERSTIData_RZBBitString,
    eBERSTIData_OctetString,
    eBERSTIData_UTF8String,
    eBERSTIData_SequenceOf,
    eBERSTIData_SetOf,
    eBERSTIData_Choice,
    eBERSTIData_Sequence,
    eBERSTIData_Set,
    eBERSTIData_ObjectIdentifier,
    eBERSTIData_ObjectIdEncoded,
    eBERSTIData_String,
    eBERSTIData_ZeroString,
    eBERSTIData_Reference,
    eBERSTIData_External,
    eBERSTIData_EmbeddedPdv,
    eBERSTIData_MultibyteString,
    eBERSTIData_UnrestrictedString,
    eBERSTIData_GeneralizedTime,
    eBERSTIData_UTCTime,
    eBERSTIData_Open
} BERSTIData_e;

struct PERTypeInfo_s {
    char *Identifier;                        /* the complete name of the type */
    TypeFlags_e Flags;                        /* encoding flags */
    TypeRules_e Rules;                        /* encoding directive rules */
    intx_t **EnumerationValues;                /* values of enumeration */
    int32_t NOctets;                        /* size of string chars/integer type */
    Extension_e Type;                        /* extension type */
    PERSimpleTypeInfo_t Root;                /* info for the extension root */
    PERSimpleTypeInfo_t Additional;        /* info for the extensions */
    PrivateDirectives_t *pPrivateDirectives;
};

/* --- BERTypeInfo --- */

struct BERTypeInfo_s {
    char *Identifier;                        /* the complete name of the type */
    TypeFlags_e Flags;                        /* encoding flags */
    TypeRules_e Rules;                        /* encoding directive rules */
    int32_t NOctets;                        /* size of string chars/integer type */
    BERSTIData_e Data;                        /* data type of value */
    Type_t *SubType;                        /* subtype */
    char *SubIdentifier;                /* name of subtype */
    TagList_t Tags;                        /* tags of this type */
    PrivateDirectives_t *pPrivateDirectives;
};

/* --- Type --- */

/* bit 0..4:  universal tag;
   bit 14:    internal bit to distingish types using same universal tag;
   bit 15:    set for internal types */
typedef enum {
    eType_Boolean                = 0x0001,
    eType_Integer                = 0x0002,
    eType_BitString                = 0x0003,
    eType_OctetString                = 0x0004,
    eType_Null                        = 0x0005,
    eType_ObjectIdentifier        = 0x0006,
    eType_ObjectDescriptor        = 0x0007,
    eType_External                = 0x0008,
    eType_InstanceOf                = 0x4008,
    eType_Real                        = 0x0009,
    eType_Enumerated                = 0x000a,
    eType_EmbeddedPdv                = 0x000b,
    eType_UTF8String                = 0x000c,
    eType_Sequence                = 0x0010,
    eType_SequenceOf                = 0x4010,
    eType_Set                        = 0x0011,
    eType_SetOf                        = 0x4011,
    eType_NumericString                = 0x0012,
    eType_PrintableString        = 0x0013,
    eType_TeletexString                = 0x0014,
    eType_T61String                = 0x4014,
    eType_VideotexString        = 0x0015,
    eType_IA5String                = 0x0016,
    eType_UTCTime                = 0x0017,
    eType_GeneralizedTime        = 0x0018,
    eType_GraphicString                = 0x0019,
    eType_VisibleString                = 0x001a,
    eType_ISO646String                = 0x401a,
    eType_GeneralString                = 0x001b,
    eType_UniversalString        = 0x001c,
    eType_CharacterString        = 0x001d,
    eType_BMPString                = 0x001e,
    eType_Choice                = 0x8000,
    eType_Selection                = 0x8001,
    eType_Reference                = 0x8002,
    eType_FieldReference        = 0x8003,
    eType_RestrictedString        = 0x8004,
    eType_Open                        = 0x8005,
    eType_Undefined                = 0x8006,
    eType_Macro                        = 0x8007
} Type_e;

struct Type_s {
    TagList_t Tags;
    TagList_t AllTags;
    TagList_t FirstTags;
    Constraint_t *Constraints;
    DirectiveList_t Directives;
    Type_e Type;
    TypeFlags_e Flags;
    TypeRules_e Rules;
    PERConstraints_t PERConstraints;
    PERTypeInfo_t PERTypeInfo;
    BERTypeInfo_t BERTypeInfo;
    TagType_e TagDefault;
    ExtensionType_e ExtensionDefault;
    PrivateDirectives_t PrivateDirectives;
    union {
        struct {
            NamedNumberList_t NamedNumbers;
        } Integer, Enumerated, BitString, IEB;
        struct {
            ComponentList_t Components;
            uint32_t Optionals;     /* not for Choice */
            uint32_t Alternatives;  /* only for Choice */
            uint32_t Extensions;
            uint8_t  Autotag[2];
        } Sequence, Set, Choice, SSC,
          Real, External, EmbeddedPdv, CharacterString, InstanceOf;
        struct {
            Type_t *Type;
            DirectiveList_t Directives;
        } SequenceOf, SetOf, SS;
        struct {
            char *Identifier;
            Type_t *Type;
        } Selection;
        struct {
            ModuleIdentifier_t *Module;
            char *Identifier;
        } Reference;
        struct {
            ObjectClass_t *ObjectClass;
            char *Identifier;
        } FieldReference;
        struct {
            Macro_t *Macro;
            MacroLocalAssignmentList_t LocalAssignments;
        } Macro;
    } U;
};
#define UndefType ((Type_t *)UNDEFINED_VALUE)

Type_t *NewType(Type_e type);
Type_t *DupType(Type_t *src);
Assignment_t *GetAssignedExternalType(AssignmentList_t *a, ModuleIdentifier_t *module, char *identifier);
Type_t *GetType(AssignmentList_t ass, Type_t *type);
Type_e GetTypeType(AssignmentList_t ass, Type_t *type);
TypeRules_e GetTypeRules(AssignmentList_t ass, Type_t *type);
int IsRestrictedString(Type_e type);
int IsStructuredType(Type_t *type);
int IsSequenceType(Type_t *type);
int IsReferenceType(Type_t *type);
Type_t *GetReferencedType(AssignmentList_t a, Type_t *type);

/* --- EndPoint --- */

typedef enum {
    eEndPoint_Min = 1,
    eEndPoint_Max = 2,
    eEndPoint_Open = 4
} EndPoint_e;

struct EndPoint_s {
    EndPoint_e Flags;
    Value_t *Value;
};

EndPoint_t *NewEndPoint();
EndPoint_t *GetLowerEndPoint(AssignmentList_t ass, EndPoint_t *e);
EndPoint_t *GetUpperEndPoint(AssignmentList_t ass, EndPoint_t *e);
int CmpLowerEndPoint(AssignmentList_t ass, EndPoint_t *v1, EndPoint_t *v2);
int CmpUpperEndPoint(AssignmentList_t ass, EndPoint_t *v1, EndPoint_t *v2);
int CmpLowerUpperEndPoint(AssignmentList_t ass, EndPoint_t *v1, EndPoint_t *v2);
int CheckEndPointsJoin(AssignmentList_t ass, EndPoint_t *v1, EndPoint_t *v2);

/* --- Constraint --- */

struct Constraint_s {
    Extension_e Type;
    ElementSetSpec_t *Root;
    ElementSetSpec_t *Additional;
    /*XXX exception spec */
};

Constraint_t *NewConstraint();
Constraint_t *DupConstraint(Constraint_t *src);
void IntersectConstraints(Constraint_t **ret, Constraint_t *c1, Constraint_t *c2);

/* --- ElementSetSpec --- */

typedef enum {
    eElementSetSpec_AllExcept,
    eElementSetSpec_Union,
    eElementSetSpec_Intersection,
    eElementSetSpec_Exclusion,
    eElementSetSpec_SubtypeElement,
    eElementSetSpec_ObjectSetElement
} ElementSetSpec_e;

struct ElementSetSpec_s {
    ElementSetSpec_e Type;
    union {
        struct {
            ElementSetSpec_t *Elements;
        } AllExcept;
        struct {
            ElementSetSpec_t *Elements1;
            ElementSetSpec_t *Elements2;
        } Union, Intersection, Exclusion, UIE;
        struct {
            SubtypeElement_t *SubtypeElement;
        } SubtypeElement;
        struct {
            ObjectSetElement_t *ObjectSetElement;
        } ObjectSetElement;
    } U;
};

ElementSetSpec_t *NewElementSetSpec(ElementSetSpec_e type);
ElementSetSpec_t *DupElementSetSpec(ElementSetSpec_t *src);

/* --- SubtypeElement --- */

typedef enum {
    eSubtypeElement_ValueRange,
    eSubtypeElement_Size,
    eSubtypeElement_SingleValue,
    eSubtypeElement_PermittedAlphabet,
    eSubtypeElement_ContainedSubtype,
    eSubtypeElement_Type,
    eSubtypeElement_SingleType,
    eSubtypeElement_FullSpecification,
    eSubtypeElement_PartialSpecification,
    eSubtypeElement_ElementSetSpec
} SubtypeElement_e;

struct SubtypeElement_s {
    SubtypeElement_e Type;
    union {
        struct {
            EndPoint_t Lower;
            EndPoint_t Upper;
        } ValueRange;
        struct {
            Constraint_t *Constraints;
        } Size, PermittedAlphabet, SingleType, SPS;
        struct {
            Value_t *Value;
        } SingleValue;
        struct {
            Type_t *Type;
        } ContainedSubtype;
        struct {
            Type_t *Type;
        } Type;
        struct {
            NamedConstraintList_t NamedConstraints;
        } FullSpecification, PartialSpecification, FP;
        struct {
            ElementSetSpec_t *ElementSetSpec;
        } ElementSetSpec;
    } U;
};

SubtypeElement_t *NewSubtypeElement(SubtypeElement_e type);
SubtypeElement_t *DupSubtypeElement(SubtypeElement_t *src);

/* --- ObjectSetElement --- */

typedef enum {
    eObjectSetElement_Object,
    eObjectSetElement_ObjectSet,
    eObjectSetElement_ElementSetSpec
} ObjectSetElement_e;

struct ObjectSetElement_s {
    ObjectSetElement_e Type;
    union {
        struct {
            Object_t *Object;
        } Object;
        struct {
            ObjectSet_t *ObjectSet;
        } ObjectSet;
        struct {
            ElementSetSpec_t *ElementSetSpec;
        } ElementSetSpec;
    } U;
};

ObjectSetElement_t *NewObjectSetElement(ObjectSetElement_e type);
ObjectSetElement_t *DupObjectSetElement(ObjectSetElement_t *src);

/* --- NamedConstraints --- */

typedef enum {
    ePresence_Present,
    ePresence_Absent,
    ePresence_Optional,
    ePresence_Normal
} Presence_e;

struct NamedConstraint_s {
    NamedConstraintList_t Next;
    char *Identifier;
    Constraint_t *Constraint;
    Presence_e Presence;
};

NamedConstraint_t *NewNamedConstraint(void);
NamedConstraint_t *DupNamedConstraint(NamedConstraint_t *src);

/* --- NamedNumber --- */

typedef enum {
    eNamedNumber_Normal,
    eNamedNumber_ExtensionMarker
} NamedNumbers_e;

struct NamedNumber_s {
    NamedNumberList_t Next;
    NamedNumbers_e Type;
    union {
        struct {
            char *Identifier;
            Value_t *Value;
        } Normal;
        struct {
            int dummy; /* ExceptionSpec */
        } ExtensionMarker;
    } U;
};

NamedNumber_t *NewNamedNumber(NamedNumbers_e type);
NamedNumber_t *DupNamedNumber(NamedNumber_t *src);
NamedNumber_t *FindNamedNumber(NamedNumberList_t numbers, char *identifier);

/* --- ValueConstraints --- */

struct ValueConstraint_s {
    ValueConstraintList_t Next;
    EndPoint_t Lower;
    EndPoint_t Upper;
};

ValueConstraint_t *NewValueConstraint();
ValueConstraint_t *DupValueConstraint(ValueConstraint_t *src);
int CountValues(AssignmentList_t ass, ValueConstraintList_t v, intx_t *n);
int HasNoValueConstraint(ValueConstraintList_t v);
int HasNoSizeConstraint(AssignmentList_t ass, ValueConstraintList_t v);
int HasNoPermittedAlphabetConstraint(AssignmentList_t ass, ValueConstraintList_t v);
NamedValue_t *GetFixedIdentification(AssignmentList_t ass, Constraint_t *constraints);

/* --- NamedType --- */

struct NamedType_s {
    char *Identifier;
    Type_t *Type;
};

NamedType_t *NewNamedType(char *identifier, Type_t *type);
NamedType_t *DupNamedType(NamedType_t *src);

/* --- Components --- */

typedef enum {
    eComponent_Normal,
    eComponent_Optional,
    eComponent_Default,
    eComponent_ComponentsOf,
    eComponent_ExtensionMarker
} Components_e;

struct Component_s {
    ComponentList_t Next;
    Components_e Type;
    union {
        struct {
            NamedType_t *NamedType;
            Value_t *Value; /* only Default */
        } Normal, Optional, Default, NOD;
        struct {
            Type_t *Type;
        } ComponentsOf;
        struct {
            int dummy; /* ExceptionSpec */
        } ExtensionMarker;
    } U;
};

Component_t *NewComponent(Components_e type);
Component_t *DupComponent(Component_t *src);
Component_t *FindComponent(AssignmentList_t ass, ComponentList_t components, char *identifier);

/* --- NamedValues --- */

struct NamedValue_s {
    NamedValueList_t Next;
    char *Identifier;
    Value_t *Value;
};

NamedValue_t *NewNamedValue(char *identifier, Value_t *value);
NamedValue_t *DupNamedValue(NamedValue_t *src);
NamedValue_t *FindNamedValue(NamedValueList_t namedValues, char *identifier);

/* --- NamedObjIdValue --- */

typedef enum {
    eNamedObjIdValue_NameForm,
    eNamedObjIdValue_NumberForm,
    eNamedObjIdValue_NameAndNumberForm
} NamedObjIdValue_e;

struct NamedObjIdValue_s {
    NamedObjIdValueList_t Next;
    NamedObjIdValue_e Type;
    char *Name;
    uint32_t Number;
};

NamedObjIdValue_t *NewNamedObjIdValue(NamedObjIdValue_e type);
NamedObjIdValue_t *DupNamedObjIdValue(NamedObjIdValue_t *src);
int GetAssignedObjectIdentifier(AssignedObjIdList_t *aoi, Value_t *parent, NamedObjIdValueList_t named, Value_t **val);

/* --- asn1c_objectidentifier_t --- */

typedef struct asn1c_objectidentifier_s
{
    ASN1uint32_t        length;
    objectnumber_t     *value;
}   asn1c_objectidentifier_t;

/* --- Value --- */

typedef enum {
    eValueFlags_GenValue = 1, /* generate value definition */
    eValueFlags_GenExternValue = 2, /* generate external value declaration */
    eValueFlags_GenAll = 3,
    eValueFlags_Done = 4      /* examination done */
} ValueFlags_e;

struct Value_s {
    Value_t *Next;
    Type_t *Type;
    ValueFlags_e Flags;
    union {
        struct {
            uint32_t Value;
        } Boolean;
        struct {
            intx_t Value;
        } Integer;
        struct {
            uint32_t Value;
        } Enumerated;
        struct {
            real_t Value;
        } Real;
        struct {
            bitstring_t Value;
        } BitString;
        struct {
            octetstring_t Value;
        } OctetString;
        struct {
            ASN1wstring_t Value;
        } UTF8String;
        struct {
            NamedValueList_t NamedValues;
        } Sequence, Set, Choice, SSC,
          External, EmbeddedPdv, CharacterString, InstanceOf;
        struct {
            ValueList_t Values;
        } SequenceOf, SetOf, SS;
        struct {
            asn1c_objectidentifier_t Value;
        } ObjectIdentifier;
        struct {
            char32string_t Value;
        } RestrictedString, ObjectDescriptor;
        struct {
            generalizedtime_t Value;
        } GeneralizedTime;
        struct {
            utctime_t Value;
        } UTCTime;
        struct {
            ModuleIdentifier_t *Module;
            char *Identifier;
        } Reference;
    } U;
};
#define UndefValue ((Value_t *)UNDEFINED_VALUE)

Value_t *NewValue(AssignmentList_t ass, Type_t *type);
Value_t *DupValue(Value_t *src);
Value_t *GetValue(AssignmentList_t ass, Value_t *value);
Assignment_t *GetAssignedExternalValue(AssignmentList_t *a, ModuleIdentifier_t *module, char *identifier);
int CmpValue(AssignmentList_t ass, Value_t *v1, Value_t *v2);
int SubstractValues(AssignmentList_t ass, intx_t *dst, Value_t *src1, Value_t *src2);

/* --- ValueSet --- */

struct ValueSet_s {
    ElementSetSpec_t *Elements;
    Type_t *Type;
};

ValueSet_t *NewValueSet();
ValueSet_t *DupValueSet(ValueSet_t *src);

/* --- Macro --- */

typedef enum {
    eMacro_Macro,
    eMacro_Reference
} Macro_e;

struct Macro_s {
    Macro_e Type;
    union {
        struct {
            MacroProduction_t *TypeProduction;
            MacroProduction_t *ValueProduction;
            NamedMacroProductionList_t SupportingProductions;
        } Macro;
        struct {
            ModuleIdentifier_t *Module;
            char *Identifier;
        } Reference;
    } U;
};

Macro_t *NewMacro(Macro_e type);
Macro_t *DupMacro(Macro_t *src);
Macro_t *GetMacro(AssignmentList_t ass, Macro_t *src);

/* --- MacroProduction --- */

typedef enum {
    eMacroProduction_Alternative,
    eMacroProduction_Sequence,
    eMacroProduction_AString,
    eMacroProduction_ProductionReference,
    eMacroProduction_String,
    eMacroProduction_Identifier,
    eMacroProduction_Number,
    eMacroProduction_Empty,
    eMacroProduction_Type,
    eMacroProduction_Value,
    eMacroProduction_LocalTypeAssignment,
    eMacroProduction_LocalValueAssignment
} MacroProduction_e;

struct MacroProduction_s {
    MacroProduction_e Type;
    union {
        struct {
            MacroProduction_t *Production1;
            MacroProduction_t *Production2;
        } Alternative, Sequence;
        struct {
            char *String;
        } AString;
        struct {
            char *Reference;
        } ProductionReference;
        struct {
            char *LocalTypeReference;
        } Type;
        struct {
            char *LocalValueReference;
            char *LocalTypeReference;
            Type_t *Type;
        } Value;
        struct {
            char *LocalTypeReference;
            Type_t *Type;
        } LocalTypeAssignment;
        struct {
            char *LocalValueReference;
            Value_t *Value;
        } LocalValueAssignment;
    } U;
};
#define UndefProduction ((MacroProduction_t *)UNDEFINED_VALUE)

MacroProduction_t *NewMacroProduction(MacroProduction_e type);
MacroProduction_t *DupMacroProduction(MacroProduction_t *src);

/* --- NamedMacroProduction --- */

struct NamedMacroProduction_s {
    NamedMacroProductionList_t Next;
    char *Identifier;
    MacroProduction_t *Production;
};

NamedMacroProduction_t *NewNamedMacroProduction();
NamedMacroProduction_t *DupNamedMacroProduction(NamedMacroProduction_t *src);

/* --- MacroLocalAssignment --- */

typedef enum {
    eMacroLocalAssignment_Type,
    eMacroLocalAssignment_Value
} MacroLocalAssignment_e;

struct MacroLocalAssignment_s {
    MacroLocalAssignmentList_t Next;
    char *Identifier;
    MacroLocalAssignment_e Type;
    union {
        Type_t *Type;
        Value_t *Value;
    } U;
};

MacroLocalAssignment_t *NewMacroLocalAssignment(MacroLocalAssignment_e type);
MacroLocalAssignment_t *DupMacroLocalAssignment(MacroLocalAssignment_t *src);
MacroLocalAssignment_t *FindMacroLocalAssignment(MacroLocalAssignmentList_t la, char *ide);

/* --- Quadruple --- */

struct Quadruple_s {
    uint32_t Group;
    uint32_t Plane;
    uint32_t Row;
    uint32_t Cell;
};

/* --- Tuple --- */

struct Tuple_s {
    uint32_t Column;
    uint32_t Row;
};

/* --- Directive --- */

typedef enum {
    eDirective_None,
    eDirective_FixedArray,
    eDirective_DoublyLinkedList,
    eDirective_SinglyLinkedList,
    eDirective_LengthPointer,
    eDirective_ZeroTerminated,
    eDirective_Pointer,
    eDirective_NoPointer
} Directives_e;

struct Directive_s {
    DirectiveList_t Next;
    Directives_e Type;
    /* may be extended in future ... */
};

Directive_t *NewDirective(Directives_e type);
Directive_t *DupDirective(Directive_t *src);

/* --- ModuleIdentifier --- */

struct ModuleIdentifier_s {
    char *Identifier;
    Value_t *ObjectIdentifier;
};

ModuleIdentifier_t *NewModuleIdentifier(void);
ModuleIdentifier_t *DupModuleIdentifier(ModuleIdentifier_t *src);
int CmpModuleIdentifier(AssignmentList_t ass, ModuleIdentifier_t *mod1, ModuleIdentifier_t *mod2);

/* --- ObjectClass --- */

typedef enum {
    eObjectClass_ObjectClass,
    eObjectClass_Reference,
    eObjectClass_FieldReference
} ObjectClass_e;

struct ObjectClass_s {
    ObjectClass_e Type;
    union {
        struct {
            FieldSpecList_t FieldSpec;
            SyntaxSpecList_t SyntaxSpec;
        } ObjectClass;
        struct {
            ModuleIdentifier_t *Module;
            char *Identifier;
        } Reference;
        struct {
            ObjectClass_t *ObjectClass;
            char *Identifier;
        } FieldReference;
    } U;
};

ObjectClass_t *NewObjectClass(ObjectClass_e type);
ObjectClass_t *DupObjectClass(ObjectClass_t *src);
ObjectClass_t *GetObjectClass(AssignmentList_t ass, ObjectClass_t *oc);
int AssignObjectClass(AssignmentList_t *ass, ObjectClass_t *lhs, ObjectClass_t *rhs);
Assignment_t *GetAssignedExternalObjectClass(ModuleIdentifier_t *module, char *identifier);

/* --- Object --- */

typedef enum {
    eObject_Object,
    eObject_Reference
} Object_e;

struct Object_s {
    Object_e Type;
    union {
        struct {
            ObjectClass_t *ObjectClass;
            SettingList_t Settings;
        } Object;
        struct {
            ModuleIdentifier_t *Module;
            char *Identifier;
        } Reference;
    } U;
};

Object_t *NewObject(Object_e type);
Object_t *DupObject(Object_t *src);
Object_t *GetObject(AssignmentList_t ass, Object_t *src);
int AssignObject(AssignmentList_t *ass, Object_t *lhs, Object_t *rhs);
Assignment_t *GetAssignedExternalObject(ModuleIdentifier_t *module, char *identifier);

/* --- ObjectSet --- */

typedef enum {
    eObjectSet_ObjectSet,
    eObjectSet_Reference,
    eObjectSet_ExtensionMarker
} ObjectSet_e;

struct ObjectSet_s {
    ObjectSet_e Type;
    union {
        struct {
            ObjectClass_t *ObjectClass;
            ElementSetSpec_t *Elements; /* only for ObjectSet */
        } ObjectSet, ExtensionMarker, OE;
        struct {
            ModuleIdentifier_t *Module;
            char *Identifier;
        } Reference;
    } U;
};

ObjectSet_t *NewObjectSet(ObjectSet_e type);
ObjectSet_t *DupObjectSet(ObjectSet_t *src);
ObjectSet_t *GetObjectSet(AssignmentList_t ass, ObjectSet_t *src);
int AssignObjectSet(AssignmentList_t *ass, ObjectSet_t *lhs, ObjectSet_t *rhs);
Assignment_t *GetAssignedExternalObjectSet(ModuleIdentifier_t *module, char *identifier);

/* --- Settings --- */

typedef enum {
    eSetting_Type,
    eSetting_Value,
    eSetting_ValueSet,
    eSetting_Object,
    eSetting_ObjectSet,
    eSetting_Undefined
} Settings_e;

struct Setting_s {
    SettingList_t Next;
    Settings_e Type;
    char *Identifier;
    union {
        struct {
            Type_t *Type;
        } Type;
        struct {
            Value_t *Value;
        } Value;
        struct {
            ValueSet_t *ValueSet;
        } ValueSet;
        struct {
            Object_t *Object;
        } Object;
        struct {
            ObjectSet_t *ObjectSet;
        } ObjectSet;
    } U;
};

Setting_t *NewSetting(Settings_e type);
Setting_t *DupSetting(Setting_t *src);
Settings_e GetSettingType(Setting_t *src);
Setting_t *FindSetting(SettingList_t se, char *identifier);

/* --- SyntaxSpec --- */

typedef enum {
    eSyntaxSpec_Literal,
    eSyntaxSpec_Field,
    eSyntaxSpec_Optional
} SyntaxSpecs_e;

struct SyntaxSpec_s {
    SyntaxSpecList_t Next;
    SyntaxSpecs_e Type;
    union {
        struct {
            char *Literal;
        } Literal;
        struct {
            char *Field;
        } Field;
        struct {
            SyntaxSpecList_t SyntaxSpec;
        } Optional;
    } U;
};
#define UndefSyntaxSpecs ((SyntaxSpec_t *)UNDEFINED_VALUE)

SyntaxSpec_t *NewSyntaxSpec(SyntaxSpecs_e type);
SyntaxSpec_t *DupSyntaxSpec(SyntaxSpec_t *src);

/* --- Optionality --- */

typedef enum {
    eOptionality_Normal,
    eOptionality_Optional,
    eOptionality_Default_Type,
    eOptionality_Default_Value,
    eOptionality_Default_ValueSet,
    eOptionality_Default_Object,
    eOptionality_Default_ObjectSet
} Optionality_e;

struct Optionality_s {
    Optionality_e Type;
    union {
        Type_t *Type;                        /* only for Default_Type */
        Value_t *Value;                        /* only for Default_Value */
        ValueSet_t *ValueSet;                /* only for Default_ValueSet */
        Object_t *Object;                /* only for Default_Object */
        ObjectSet_t *ObjectSet;                /* only for Default_ObjectSet */
    } U;
};

Optionality_t *NewOptionality(Optionality_e opt);
Optionality_t *DupOptionality(Optionality_t *src);

/* --- FieldSpec --- */

typedef enum {
    eFieldSpec_Type,
    eFieldSpec_FixedTypeValue,
    eFieldSpec_VariableTypeValue,
    eFieldSpec_FixedTypeValueSet,
    eFieldSpec_VariableTypeValueSet,
    eFieldSpec_Object,
    eFieldSpec_ObjectSet,
    eFieldSpec_Undefined
} FieldSpecs_e;

struct FieldSpec_s {
    FieldSpecList_t Next;
    FieldSpecs_e Type;
    char *Identifier;
    union {
        struct {
            Optionality_t *Optionality;
        } Type;
        struct {
            Type_t *Type;
            uint32_t Unique;
            Optionality_t *Optionality;
        } FixedTypeValue;
        struct {
            StringList_t Fields;
            Optionality_t *Optionality;
        } VariableTypeValue;
        struct {
            Type_t *Type;
            Optionality_t *Optionality;
        } FixedTypeValueSet;
        struct {
            StringList_t Fields;
            Optionality_t *Optionality;
        } VariableTypeValueSet;
        struct {
            ObjectClass_t *ObjectClass;
            Optionality_t *Optionality;
        } Object;
        struct {
            ObjectClass_t *ObjectClass;
            Optionality_t *Optionality;
        } ObjectSet;
    } U;
};

FieldSpec_t *NewFieldSpec(FieldSpecs_e type);
FieldSpec_t *DupFieldSpec(FieldSpec_t *src);
FieldSpec_t *GetFieldSpec(AssignmentList_t ass, FieldSpec_t *fs);
FieldSpecs_e GetFieldSpecType(AssignmentList_t ass, FieldSpec_t *fs);
FieldSpec_t *FindFieldSpec(FieldSpecList_t fs, char *identifier);

/* --- UndefinedSymbol --- */

typedef enum {
    eUndefinedSymbol_SymbolNotDefined,
    eUndefinedSymbol_SymbolNotExported,
    eUndefinedSymbol_FieldNotDefined,
    eUndefinedSymbol_FieldNotExported
} UndefinedSymbol_e;

struct UndefinedSymbol_s {
    UndefinedSymbolList_t Next;
    UndefinedSymbol_e Type;
    union {
        struct {
            char *Identifier;
            ModuleIdentifier_t *Module;
            Assignment_e ReferenceType;
        } Symbol;
        struct {
            char *Identifier;
            ModuleIdentifier_t *Module;
            Settings_e ReferenceFieldType;
            ObjectClass_t *ObjectClass;
        } Field;
    } U;
};

UndefinedSymbol_t *NewUndefinedSymbol(UndefinedSymbol_e type, Assignment_e reftype);
UndefinedSymbol_t *NewUndefinedField(UndefinedSymbol_e type, ObjectClass_t *oc, Settings_e reffieldtype);
int CmpUndefinedSymbol(AssignmentList_t ass, UndefinedSymbol_t *u1, UndefinedSymbol_t *u2);
int CmpUndefinedSymbolList(AssignmentList_t ass, UndefinedSymbolList_t u1, UndefinedSymbolList_t u2);
UndefinedSymbol_t *FindUndefinedSymbol(AssignmentList_t ass, UndefinedSymbolList_t a, Assignment_e type, char *ide, ModuleIdentifier_t *mod);
UndefinedSymbol_t *FindUndefinedField(AssignmentList_t ass, UndefinedSymbolList_t u, Settings_e fieldtype, ObjectClass_t *oc, char *ide, ModuleIdentifier_t *mod);

/* --- String --- */

struct String_s {
    StringList_t Next;
    char *String;
};
String_t *NewString(void);
String_t *DupString(String_t *src);
String_t *FindString(StringList_t list, char *str);
#define EXPORT_ALL ((String_t *)1)

/* --- StringModule --- */

struct StringModule_s {
    StringModuleList_t Next;
    char *String;
    ModuleIdentifier_t *Module;
};
StringModule_t *NewStringModule(void);
StringModule_t *DupStringModule(StringModule_t *src);
StringModule_t *FindStringModule(AssignmentList_t ass, StringModuleList_t list, char *str, ModuleIdentifier_t *module);
#define IMPORT_ALL ((StringModule_t *)1)

/* --- Language --- */

typedef enum {
    eLanguage_C,
    eLanguage_Cpp
} Language_e;

/* --- Alignment --- */

typedef enum {
    eAlignment_Unaligned,
    eAlignment_Aligned
} Alignment_e;

/* --- Encoding --- */

typedef enum {
    eEncoding_Basic,
    eEncoding_Packed
} Encoding_e;

/* --- SubEncoding --- */

typedef enum {
    eSubEncoding_Basic = 'B',
    eSubEncoding_Canonical = 'C',
    eSubEncoding_Distinguished = 'D'
} SubEncoding_e;

/* --- generation entities --- */

typedef enum { eStringTable, eEncode, eDecode, eCheck, ePrint, eFree, eCompare, eCopy } TypeFunc_e;
typedef enum { eDecl, eDefh, eDefn, eInit, eFinit } ValueFunc_e;

struct Arguments_s {
    char *enccast;
    char *encfunc;
    char *Pencfunc;
    char *deccast;
    char *decfunc;
    char *Pdecfunc;
    char *freecast;
    char *freefunc;
    char *Pfreefunc;
    char *cmpcast;
    char *cmpfunc;
    char *Pcmpfunc;
};

/* --- ghost file --- */

typedef struct GhostFile_s {
    char    *pszFileName;
    char    *pszModuleName;
}
    GhostFile_t;

/* --- utility functions --- */

char *GetIntType(AssignmentList_t ass, EndPoint_t *lower, EndPoint_t *upper, int32_t *sign);
char *GetIntegerType(AssignmentList_t ass, Type_t *type, int32_t *sign);
char *GetRealType(Type_t *type);
char *GetBooleanType(void);
char *GetEnumeratedType(AssignmentList_t ass, Type_t *type, int32_t *sign);
char *GetChoiceType(Type_t *type);
char *GetStringType(AssignmentList_t ass, Type_t *type, int32_t *noctets, uint32_t *zero);
uint32_t GetIntBits(intx_t *range);

void GetPERConstraints(AssignmentList_t ass, Constraint_t *constraints, PERConstraints_t *per);

char *Identifier2C(char *identifier);
char *Reference(char *expression);
char *Dereference(char *expression);

extern int ForceAllTypes;
extern char *IntegerRestriction;
extern char *UIntegerRestriction;
extern char *RealRestriction;
extern int Has64Bits;
extern Language_e g_eProgramLanguage;
extern Encoding_e g_eEncodingRule;
extern Alignment_e Alignment;
extern SubEncoding_e g_eSubEncodingRule;

int GetUndefined(AssignmentList_t ass, UndefinedSymbol_t *undef);
void UndefinedError(AssignmentList_t ass, UndefinedSymbolList_t undef, UndefinedSymbolList_t baddef);

extern FILE *g_finc, *g_fout;

void InitBuiltin();
void InitBuiltinASN1CharacterModule();
void Examination(AssignmentList_t *ass, ModuleIdentifier_t *mainmodule);
void GenInc(AssignmentList_t ass, FILE *finc, char *module);
void GenPrg(AssignmentList_t ass, FILE *fprg, char *module, char *incfilename);
void GenFuncSequenceSetDefaults(AssignmentList_t ass, char *valref, ComponentList_t components, char *obuf, TypeFunc_e et);
void GenFuncSequenceSetOptionals(AssignmentList_t ass, char *valref, ComponentList_t components, uint32_t optionals, uint32_t extensions, char *obuf, TypeFunc_e et);
void GenPERHeader();
void GenPERInit(AssignmentList_t ass, char *module);
void GenPERFuncType(AssignmentList_t ass, char *module, Assignment_t *at, TypeFunc_e et);
void GenBERHeader();
void GenBERInit(AssignmentList_t ass, char *module);
void GenBERFuncType(AssignmentList_t ass, char *module, Assignment_t *at, TypeFunc_e et);

void GetMinMax(AssignmentList_t ass, ValueConstraintList_t constraints,
    EndPoint_t *lower, EndPoint_t *upper);
char *GetTypeName(AssignmentList_t ass, Type_t *type);
char *PGetTypeName(AssignmentList_t ass, Type_t *type);
char *GetValueName(AssignmentList_t ass, Value_t *value);
char *GetObjectClassName(AssignmentList_t ass, ObjectClass_t *oc);
char *GetName(Assignment_t *a);
char *PGetName(AssignmentList_t ass, Assignment_t *a);
Tag_t *GetTag(AssignmentList_t ass, Type_t *type);
int32_t GetOctets(char *inttype);
void AutotagType(AssignmentList_t ass, Type_t *type);
void SortAssignedTypes(AssignmentList_t *ass);
void ExamineBER(AssignmentList_t ass);
void ExaminePER(AssignmentList_t ass);
void GetBERPrototype(Arguments_t *args);
void GetPERPrototype(Arguments_t *args);

int String2GeneralizedTime(generalizedtime_t *time, char32string_t *string);
int String2UTCTime(utctime_t *time, char32string_t *string);

FieldSpec_t *GetObjectClassField(AssignmentList_t ass, ObjectClass_t *oc, char *field);
FieldSpec_t *GetFieldSpecFromObjectClass(AssignmentList_t ass, ObjectClass_t *oc, StringList_t fields);
Setting_t *GetSettingFromObject(AssignmentList_t ass, Object_t *o, StringList_t sl);
Setting_t *GetSettingFromSettings(AssignmentList_t ass, SettingList_t se, StringList_t sl);

ObjectClass_t *GetObjectClassFromElementSetSpec(AssignmentList_t ass, ElementSetSpec_t *elems);
Value_t *GetValueFromObject(AssignmentList_t ass, Object_t *o, StringList_t sl);
ValueSet_t *GetValueSetFromObject(AssignmentList_t ass, Object_t *o, StringList_t sl);
Type_t *GetTypeFromObject(AssignmentList_t ass, Object_t *o, StringList_t sl);
Object_t *GetObjectFromObject(AssignmentList_t ass, Object_t *o, StringList_t sl);
ObjectSet_t *GetObjectSetFromObject(AssignmentList_t ass, Object_t *o, StringList_t sl);
ElementSetSpec_t *ConvertElementSetSpecToElementSetSpec(AssignmentList_t ass, ElementSetSpec_t *elems, StringList_t sl, ElementSetSpec_t *(*fn)(AssignmentList_t ass, Object_t *o, StringList_t sl));
ElementSetSpec_t *ConvertObjectSetToElementSetSpec(AssignmentList_t ass, ObjectSet_t *os, StringList_t sl, ElementSetSpec_t *(*fn)(AssignmentList_t ass, Object_t *o, StringList_t sl));
ValueSet_t *GetValueSetFromObjectSet(AssignmentList_t ass, ObjectSet_t *os, StringList_t sl);
ObjectSet_t *GetObjectSetFromObjectSet(AssignmentList_t ass, ObjectSet_t *os, StringList_t sl);
Type_t *GetTypeOfValueSet(AssignmentList_t ass, ValueSet_t *vs);
int IsPSetOfType(AssignmentList_t ass, Assignment_t *a);


// --- The following is added by Microsoft ---

int IsReservedWord ( char *psz );
void KeepEnumNames ( char *pszEnumName );
void KeepOptNames ( char *pszOptName );
void KeepChoiceNames ( char *pszChoiceName );
int DoesEnumNameConflict ( char *pszEnumName );
int DoesOptNameConflict ( char *pszOptName );
int DoesChoiceNameConflict ( char *pszChoiceName );

void SetDirective(char *psz);
void PrintVerbatim(void);

/* ------ char.c ------ */

int ASN1is16space(ASN1char16_t c);
int ASN1str16len(ASN1char16_t *p);
int ASN1is32space(ASN1char32_t c);
int ASN1str32len(ASN1char32_t *p);

int IsImportedLocalDuplicate(AssignmentList_t ass, ModuleIdentifier_t *pMainModule, Assignment_t *curr);

extern TagType_e g_eDefTagType;

extern TypeRules_e g_eDefTypeRuleSS_NonSized;
extern TypeRules_e g_eDefTypeRuleSS_Sized;
extern int g_fOidArray;

extern char *g_pszOrigModuleNameLowerCase;
extern int g_fLongNameForImported;
extern int g_fExtraStructPtrTypeSS;

extern int g_fMicrosoftExtensions;

extern int g_chDirectiveBegin;
extern int g_chDirectiveEnd;
extern int g_chDirectiveAND;

extern char *g_pszApiPostfix;
extern char *g_pszChoicePostfix;
extern char *g_pszOptionPostfix;
extern char *g_pszOptionValue;

extern void StripModuleName(char *pszDst, char *pszSrc);

extern int g_cGhostFiles;
extern GhostFile_t g_aGhostFiles[16];

#endif // _ASN1C_DEFS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\asn1\asn1c\examine.c ===
/* Copyright (C) Boris Nikolaus, Germany, 1996-1997. All rights reserved. */
/* Copyright (C) Microsoft Corporation, 1997-1998. All rights reserved. */

#include "precomp.h"
#include "error.h"
#include "util.h"

typedef enum {
    eNull, eSingle, eMultiple, eString
} RepresentationGroup_e;

void BuildTypeFlags(AssignmentList_t ass, Type_t *type);
Type_t *RebuildTypeWithoutSelectionType(AssignmentList_t ass, Type_t *type);

/* name the sub types of a type */
/* returns 1 if any naming has been performed */
int
NameSubType(AssignmentList_t *ass, char *identifier, Type_t *type, ModuleIdentifier_t *module)
{
    char name[256], *n;
    char *p;
    Component_t *components;
    Type_t *subtype;
    int ret = 0;

    /* build the prefix for the subtypes */
    strcpy(name, identifier);
    strcat(name, "_");
    p = name + strlen(name);

    switch (type->Type) {
    case eType_Sequence:
    case eType_Set:
    case eType_Choice:
    case eType_InstanceOf:

	/* check all components */
	for (components = type->U.SSC.Components; components;
	    components = components->Next) {
	    switch (components->Type) {
	    case eComponent_Normal:
	    case eComponent_Optional:
	    case eComponent_Default:

		/* do not name unstructured types */
		if (!IsStructuredType(components->U.NOD.NamedType->Type))
		    break;

		/* name the type of the component and use a type */
		/* reference instead */
		strcpy(p, components->U.NOD.NamedType->Identifier);
		n = Identifier2C(name);
		subtype = NewType(eType_Reference);
		subtype->U.Reference.Identifier = n;
		subtype->U.Reference.Module = module;
		AssignType(ass, subtype, components->U.NOD.NamedType->Type);
		components->U.NOD.NamedType->Type = subtype;
		if (components->Type == eComponent_Default)
		    components->U.NOD.Value->Type = subtype;
		ret = 1;
		break;
	    }
	}
	break;

    case eType_SequenceOf:
    case eType_SetOf:
	
	/* already named? */
	if (type->U.SS.Type->Type == eType_Reference)
	    break;

	/* name the type of the elements and use a type reference instead */
	strcpy(p, type->Type == eType_SequenceOf ? "Seq" : "Set");
	n = Identifier2C(name);
	subtype = NewType(eType_Reference);
	subtype->U.Reference.Identifier = n;
	subtype->U.Reference.Module = module;
	AssignType(ass, subtype, type->U.SS.Type);
	type->U.SS.Type = subtype;
	ret = 1;
	break;

    case eType_Selection:

	/* do not name unstructured types */
	if (!IsStructuredType(type->U.Selection.Type))
	    break;

	/* name the type of the selected type and use a type reference */
	/* instead */
	strcpy(p, "Sel");
	n = Identifier2C(name);
	subtype = NewType(eType_Reference);
	subtype->U.Reference.Identifier = n;
	subtype->U.Reference.Module = module;
	AssignType(ass, subtype, type->U.Selection.Type);
	type->U.Selection.Type = subtype;
	ret = 1;
	break;
    }

    /* return 1 if any naming has been performed */
    return ret;
}

/* name the default value of a type */
/* return 1 if any naming has been performed */
int
NameValueOfType(AssignmentList_t *ass, char *identifier, Type_t *type, ModuleIdentifier_t *module)
{
    char name[256], *n;
    char *p;
    Component_t *components;
    Value_t *subvalue;
    int ret = 0;

    /* build the prefix for the subtypes */
    strcpy(name, identifier);
    strcat(name, "_");
    p = name + strlen(name);

    switch (type->Type) {
    case eType_Sequence:
    case eType_Set:

	/* check all components */
	for (components = type->U.SSC.Components; components;
	    components = components->Next) {
	    switch (components->Type) {
	    case eComponent_Default:

		/* already named? */
		if (!components->U.NOD.Value->Type)
		    break;

		/* name the value of the default component and use a value */
		/* reference instead */
		strcpy(p, components->U.NOD.NamedType->Identifier);
		strcat(p, "_default");
		n = Identifier2C(name);
		subvalue = NewValue(NULL, NULL);
		subvalue->U.Reference.Identifier = n;
		subvalue->U.Reference.Module = module;
		AssignValue(ass, subvalue, components->U.NOD.Value);
		components->U.NOD.Value = subvalue;
		ret = 1;
		break;
	    }
	}
	break;
    }

    /* return 1 if any naming has been performed */
    return ret;
}

/* name the types of typefields of the settings of an object */
/* return 1 if any naming has been performed */
int
NameSettings(AssignmentList_t *ass, char *identifier, SettingList_t se, ModuleIdentifier_t *module)
{
    int ret = 0;
    char name[256], *n;
    char *p;
    Type_t *subtype;

    /* build the prefix for the subtypes */
    strcpy(name, identifier);
    strcat(name, "_");
    p = name + strlen(name);

    /* check all settings */
    for (; se; se = se->Next) {
	strcpy(p, se->Identifier + 1);
	switch (se->Type) {
	case eSetting_Type:

	    /* name field type if not already named */
	    if (se->U.Type.Type->Type != eType_Reference) {
		n = Identifier2C(name);
		subtype = NewType(eType_Reference);
		subtype->U.Reference.Identifier = n;
		subtype->U.Reference.Module = module;
		ret = AssignType(ass, subtype, se->U.Type.Type);
	    }

	    /* mark field type for generation */
	    se->U.Type.Type->Flags |= eTypeFlags_GenAll;
	    break;
	}
    }

    /* return 1 if any naming has been performed */
    return ret;
}

/* name the default types of typefields of the field specs of an object class */
/* return 1 if any naming has been performed */
int
NameDefaultTypes(AssignmentList_t *ass, char *identifier, ObjectClass_t *oc, SettingList_t se, ModuleIdentifier_t *module)
{
    int ret = 0;
    char name[256], *n;
    char *p;
    Type_t *subtype;
    FieldSpec_t *fs;

    /* build the prefix for the subtypes */
    strcpy(name, identifier);
    strcat(name, "_");
    p = name + strlen(name);
    oc = GetObjectClass(*ass, oc);

    /* check all field specs */
    for (fs = oc->U.ObjectClass.FieldSpec; fs; fs = fs->Next) {
	strcpy(p, fs->Identifier + 1);
	switch (fs->Type) {
	case eFieldSpec_Type:

	    /* check if typefield has a default type */
	    if (fs->U.Type.Optionality->Type != eOptionality_Default_Type ||
	        FindSetting(se, fs->Identifier))
		break;

	    /* name field type if not already named */
	    if (fs->U.Type.Optionality->U.Type->Type != eType_Reference) {
		n = Identifier2C(name);
		subtype = NewType(eType_Reference);
		subtype->U.Reference.Identifier = n;
		subtype->U.Reference.Module = module;
		ret = AssignType(ass, subtype, fs->U.Type.Optionality->U.Type);
	    }

	    /* mark field type for generation */
	    fs->U.Type.Optionality->U.Type->Flags |= eTypeFlags_GenAll;
	    break;
	}
    }

    /* return 1 if any naming has been performed */
    return ret;
}

/* name the types of type fields of an object and the default types of */
/* typefields of the field specs of an object class */
/* return 1 if any naming has been performed */
int
NameSettingsOfObject(AssignmentList_t *ass, char *identifier, Object_t *object, ModuleIdentifier_t *module)
{
    int ret = 0;

    switch (object->Type) {
    case eObject_Object:
	ret = NameSettings(ass, identifier, object->U.Object.Settings,
	    module);
	ret |= NameDefaultTypes(ass, identifier, object->U.Object.ObjectClass,
	    object->U.Object.Settings, module);
	break;
    }

    /* return 1 if any naming has been performed */
    return ret;
}

/* name the identification value of embedded pdv/character string types */
void
NameIdentificationValueOfType(AssignmentList_t *ass, char *identifier, Type_t *type, ModuleIdentifier_t *module)
{
    char name[256], *n;
    char *p;
    Component_t *components;
    NamedValue_t *namedValues;
    Value_t *subvalue;

    /* build the prefix for the subtypes */
    strcpy(name, identifier);
    strcat(name, "_");
    p = name + strlen(name);

    switch (type->Type) {
    case eType_Sequence:
    case eType_Set:
    case eType_Choice:
    case eType_InstanceOf:
	
	/* check all components */
	for (components = type->U.SSC.Components; components;
	    components = components->Next) {
	    switch (components->Type) {
	    case eComponent_Normal:
	    case eComponent_Optional:
	    case eComponent_Default:
		strcpy(p, components->U.NOD.NamedType->Identifier);
		NameIdentificationValueOfType(ass, name,
		    components->U.NOD.NamedType->Type, module);
		break;
	    }
	}
	break;

    case eType_SequenceOf:
    case eType_SetOf:

	/* check the subtype */
	strcpy(p, type->Type == eType_SequenceOf ? "Seq" : "Set");
	NameIdentificationValueOfType(ass, name, type->U.SS.Type, module);
	break;

    case eType_EmbeddedPdv:
    case eType_CharacterString:

	/* check if type has a fixed identification syntaxes constraint */
	namedValues = GetFixedIdentification(*ass, type->Constraints);
	if (namedValues && !strcmp(namedValues->Identifier, "syntaxes")) {

	    /* name the identification and use a value reference instead */
	    for (namedValues = namedValues->Value->U.SSC.NamedValues;
		namedValues; namedValues = namedValues->Next) {
		strcpy(p, "identification_syntaxes_");
		strcat(p, namedValues->Identifier);
		n = Identifier2C(name);
		subvalue = NewValue(NULL, NULL);
		subvalue->U.Reference.Identifier = n;
		subvalue->U.Reference.Module = module;
		AssignValue(ass, subvalue, namedValues->Value);
	    }
	}
	break;
    }
}

/* name the type of a value */
/* returns 1 if any naming has been performed */
int
NameTypeOfValue(AssignmentList_t *ass, char *identifier, Value_t *value, ModuleIdentifier_t *module)
{
    Type_t *type;
    char name[256], *n;
    Type_t *subtype;
    int ret = 0;

    type = value->Type;

    /* do not name types of value references or unstructured types */
    if (type && IsStructuredType(type)) {

	/* build the prefix for the subtype */
	strcpy(name, identifier);
	strcat(name, "_");
	strcat(name, "Type");
	n = Identifier2C(name);

	/* name the type and use a type reference instead */
	subtype = NewType(eType_Reference);
	subtype->U.Reference.Identifier = n;
	subtype->U.Reference.Module = module;
	AssignType(ass, subtype, type);
	value->Type = subtype;
	ret = 1;
    }
    return ret;
}

/* replace any components of by the components of the referenced type */
ComponentList_t
RebuildComponentsWithoutComponentsOf(AssignmentList_t ass, ComponentList_t components)
{
    Component_t *newcomponents, *subcomponents, **pcomponents;
    Type_t *subtype;
    int ext;

    ext = 0;
    pcomponents = &newcomponents;
    for (; components; components = components->Next) {
	switch (components->Type) {
	case eComponent_ComponentsOf:

	    /* components of should not be used in an extension */
	    if (ext)
		error(E_COMPONENTS_OF_in_extension, NULL);

	    /* get the components of the referenced type */
	    subtype = GetType(ass, components->U.ComponentsOf.Type);
	    switch (subtype->Type) {
	    case eType_Sequence:
	    case eType_Set:
	    case eType_Choice:
	    case eType_External:
	    case eType_EmbeddedPdv:
	    case eType_CharacterString:
	    case eType_Real:
	    case eType_InstanceOf:
		subcomponents = subtype->U.SSC.Components;
		break;
	    default:
		error(E_applied_COMPONENTS_OF_to_bad_type, NULL);
	    }

	    /* get the real components of the referenced type */
	    /*XXX self-referencing components of types will idle forever */
	    *pcomponents = RebuildComponentsWithoutComponentsOf(ass,
		subcomponents);

	    /* find end of components of referenced type */
	    while (*pcomponents) {
		if ((*pcomponents)->Type == eComponent_ExtensionMarker)
		    error(E_COMPONENTS_OF_extended_type, NULL);
		pcomponents = &(*pcomponents)->Next;
	    }
	    break;

	case eComponent_ExtensionMarker:

	    /* copy extension marker */
	    ext = 1;
	    *pcomponents = DupComponent(components);
	    pcomponents = &(*pcomponents)->Next;
	    break;
	default:

	    /* copy other components */
	    *pcomponents = DupComponent(components);
	    pcomponents = &(*pcomponents)->Next;
	    break;
	}
    }

    /* terminate and return component list */
    *pcomponents = NULL;
    return newcomponents;
}

/* replace any components of by the components of the referenced type */
Type_t *
RebuildTypeWithoutComponentsOf(AssignmentList_t ass, Type_t *type)
{
    switch (type->Type) {
    case eType_Sequence:
    case eType_Set:
    case eType_Choice:
	type->U.SSC.Components =
	    RebuildComponentsWithoutComponentsOf(ass, type->U.SSC.Components);
	break;
    }
    return type;
}

/* replace any selection type by the component of the selected type */
ComponentList_t
RebuildComponentsWithoutSelectionType(AssignmentList_t ass, ComponentList_t components)
{
    Component_t *c;

    for (c = components; c; c = c->Next) {
	switch (c->Type) {
	case eComponent_Normal:
	case eComponent_Optional:
	case eComponent_Default:
	    c->U.NOD.NamedType->Type = RebuildTypeWithoutSelectionType(
		ass, c->U.NOD.NamedType->Type);
	    break;
	}
    }
    return components;
}

/* replace any selection type by the component of the selected type */
Type_t *RebuildTypeWithoutSelectionType(AssignmentList_t ass, Type_t *type)
{
    Type_t *subtype;
    Component_t *components;

    switch (type->Type) {
    case eType_Selection:
	subtype = GetType(ass, type->U.Selection.Type);
	switch (subtype->Type) {
	case eType_Sequence:
	case eType_Set:
	case eType_Choice:
	case eType_External:
	case eType_EmbeddedPdv:
	case eType_CharacterString:
	case eType_Real:
	case eType_InstanceOf:

	    /* get the components of the referenced type */
	    components = FindComponent(ass, subtype->U.SSC.Components,
		type->U.Selection.Identifier);
	    if (!components)
		error(E_bad_component_in_selectiontype, NULL);

	    /* get the real type of the referenced type */
	    /*XXX self-referencing selection types will idle forever */
	    type = RebuildTypeWithoutSelectionType(ass,
		components->U.NOD.NamedType->Type);
	    break;
	default:
	    error(E_selection_of_bad_type, NULL);
	}
	break;

    case eType_Sequence:
    case eType_Set:
    case eType_Choice:
	type->U.SSC.Components =
	    RebuildComponentsWithoutSelectionType(ass, type->U.SSC.Components);
	break;

    case eType_SequenceOf:
    case eType_SetOf:
	type->U.SS.Type = RebuildTypeWithoutSelectionType(ass, type->U.SS.Type);
	break;
    }
    return type;
}

/* mark a type for autotagging */
void
MarkTypeForAutotagging(AssignmentList_t ass, Type_t *type)
{
    Component_t *components;
    int ext;

    switch (type->Type) {
    case eType_Sequence:
    case eType_Set:
    case eType_Choice:
	ext = 0;

	/* set flags for autotagging */
	type->U.SSC.Autotag[0] = 1;
	type->U.SSC.Autotag[1] = 1;

	/* reset flags for autotagging if a tag has been used */
	for (components = type->U.SSC.Components; components;
	    components = components->Next) {
	    switch (components->Type) {
	    case eComponent_Normal:
	    case eComponent_Optional:
	    case eComponent_Default:
		if (GetTag(ass, components->U.NOD.NamedType->Type))
		    type->U.SSC.Autotag[ext] = 0;
		break;
	    case eComponent_ExtensionMarker:
		ext = 1;
		break;
	    case eComponent_ComponentsOf:
		break;
	    }
	}
	break;
    }
}

/* autotag a marked type */
void
AutotagType(AssignmentList_t ass, Type_t *type)
{
    Component_t *components;
    Type_t *subtype;
    int ext;
    int tag;
    Tag_t *tags;

    switch (type->Type) {
    case eType_Sequence:
    case eType_Set:
    case eType_Choice:
	ext = 0;

	/* tag number to use */
	tag = 0;

	for (components = type->U.SSC.Components; components;
	    components = components->Next) {
	    switch (components->Type) {
	    case eComponent_Normal:
	    case eComponent_Optional:
	    case eComponent_Default:
		subtype = components->U.NOD.NamedType->Type;
		tags = subtype->Tags;

		/* check if type needs autotagging */
		if (!tags &&
		    type->TagDefault == eTagType_Automatic &&
		    type->U.SSC.Autotag[ext]) {

		    /* create a tagged version of the type */
		    components->U.NOD.NamedType->Type = subtype =
			DupType(subtype);

		    /* use explicit tag for choice components types and */
		    /* for open type and dummy reference, implicit tag */
		    /* otherwise */
		    if (subtype->Type == eType_Choice ||
			subtype->Type == eType_Open
			/*XXX || DummyReference*/) {
			subtype->Tags = NewTag(eTagType_Explicit);
		    } else {
			subtype->Tags = NewTag(eTagType_Implicit);
		    }
		    subtype->Tags->Tag = NewValue(NULL, Builtin_Type_Integer);
		    intx_setuint32(&subtype->Tags->Tag->U.Integer.Value,
			tag++);
		}
		break;

	    case eComponent_ExtensionMarker:
		ext = 1;
		break;
	    }
	}
	break;
    }
}

/* mark constraints extendable */
void
AutoextendConstraints(Constraint_t *constraints)
{
    if (!constraints)
	return;
    if (constraints->Type == eExtension_Unextended)
	constraints->Type = eExtension_Extendable;
}

/* autoextend a type if desired */
void
AutoextendType(AssignmentList_t ass, Type_t *type)
{
    Component_t *c, **cc;
    Type_t *subtype;
    int ext;

    /* already done? */
    if (type->Flags & eTypeFlags_Done)
	return;
    type->Flags |= eTypeFlags_Done;

    /* auto extending wanted? */
    if (type->ExtensionDefault != eExtensionType_Automatic)
	return;

    /* check all sub types */
    switch (type->Type) {
    case eType_Sequence:
    case eType_Set:
    case eType_Choice:

	/* extend a sequence/set/choice type */
	ext = 0;
	for (cc = &type->U.SSC.Components, c = *cc; c;
	    c = c->Next, cc = &(*cc)->Next) {
	    *cc = DupComponent(c);
	    switch (c->Type) {
	    case eComponent_Normal:
	    case eComponent_Optional:
	    case eComponent_Default:
		subtype = c->U.NOD.NamedType->Type;
		AutoextendType(ass, subtype);
		break;
	    case eComponent_ExtensionMarker:
		ext = 1;
		break;
	    }
	}
	if (!ext) {
	    *cc = NewComponent(eComponent_ExtensionMarker);
	    cc = &(*cc)->Next;
	}
	*cc = NULL;
	break;

    case eType_SequenceOf:
    case eType_SetOf:
	subtype = type->U.SS.Type;
	AutoextendType(ass, subtype);
	break;
    }

    /* mark type as extendable */
    AutoextendConstraints(type->Constraints);
}

/* set the tag type of unspecified tags to explicit or implicit, */
/* create list of all tags (including the type's universal tag and the */
/* tags of the referenced type if applicable), */
/* and create list of first tags (esp. for choice types) */
void
BuildTags(AssignmentList_t ass, Type_t *type, TagType_e eParentDefTagType)
{
    Tag_t *t, *t2, **tt;
    Component_t *components;
    Type_t *reftype;
    Type_e te;
    uint32_t i;

    /* already done? */
    if (type->Flags & eTypeFlags_Done)
	return;
    type->Flags |= eTypeFlags_Done;

    // update default tag type
	if (type->TagDefault == eTagType_Unknown &&
	    (eParentDefTagType == eTagType_Explicit || eParentDefTagType == eTagType_Implicit))
	{
		type->TagDefault = eParentDefTagType;
	}

    /* set tag type of unspecified tags to explicit or implicit */
    /* use explicit tags when: */
    /* - TagDefault indicates explicit tags, */
    /* - Type is choice/open type/dummy reference and no other explicit tag */
    /*   will follow */
    te = GetTypeType(ass, type);
	if (type->Tags)
	{
		for (tt = &type->Tags, t = type->Tags; t; tt = &(*tt)->Next, t = t->Next)
		{
			*tt = DupTag(t);
			if ((*tt)->Type == eTagType_Unknown)
			{
				for (t2 = t->Next; t2; t2 = t2->Next)
				{
				    if (t2->Type != eTagType_Implicit)
					    break;
				}
				if (type->TagDefault == eTagType_Explicit ||
				    (!t2 && (te == eType_Choice || te == eType_Open /*XXX || DummyReference*/)))
				{
				    (*tt)->Type = eTagType_Explicit;
				}
				else
				{
				    (*tt)->Type = eTagType_Implicit;
				}
			}
		}
	}

    /* copy given tags to AllTags list */
    for (tt = &type->AllTags, t = type->Tags;
         t;
	     tt = &(*tt)->Next, t = t->Next)
	{
    	*tt = DupTag(t);
    }

    /* build tags of subtypes and copy tags of reference type */
    switch (type->Type)
    {
    case eType_Sequence:
    case eType_Set:
    case eType_Choice:
    case eType_InstanceOf:
    	for (components = type->U.SSC.Components;
    	     components;
    	     components = components->Next)
    	{
    	    switch (components->Type)
    	    {
    	    case eComponent_Normal:
    	    case eComponent_Optional:
    	    case eComponent_Default:
    		    BuildTags(ass, components->U.NOD.NamedType->Type, type->TagDefault);
    		    break;
    	    }
    	}
    	break;
    case eType_SequenceOf:
    case eType_SetOf:
    	BuildTags(ass, type->U.SS.Type, eTagType_Unknown);
	    break;
    case eType_Reference:
    	reftype = GetReferencedType(ass, type);
    	BuildTags(ass, reftype, type->TagDefault);
    	for (t = reftype->AllTags; t; tt = &(*tt)->Next, t = t->Next)
    	{
    	    *tt = DupTag(t);
    	}
    	break;
    }

    /* add the type's universal tag to the AllTags list if the type is */
    /* not an internal type */
    if (!(type->Type & 0x8000))
    {
    	*tt = NewTag(eTagType_Implicit);
    	(*tt)->Class = eTagClass_Universal;
    	(*tt)->Tag = NewValue(NULL, Builtin_Type_Integer);
    	intx_setuint32(&(*tt)->Tag->U.Integer.Value, type->Type & 0x1f);
    }

    /* build list of FirstTags containing the possible tag values of the type */
    tt = &type->FirstTags;
    if (type->AllTags)
    {
    	/* if type has any tags, only the first tag is needed */
    	*tt = DupTag(type->AllTags);
    	tt = &(*tt)->Next;
    }
    else
    {
    	/* otherwise we have to examine the type */
    	switch (type->Type)
    	{
    	case eType_Choice:

    	    /* get the first tags of all components of a choice as FirstTags */
    	    for (components = type->U.SSC.Components;
    	         components;
    		     components = components->Next)
    		{
        		switch (components->Type)
        		{
        		case eComponent_Normal:
        		case eComponent_Optional:
        		case eComponent_Default:
        		    for (t = components->U.NOD.NamedType->Type->FirstTags;
        		         t;
        			     t = t->Next)
        			{
            			*tt = DupTag(t);
            			tt = &(*tt)->Next;
        		    }
        		    break;
        		}
    	    }
    	    break;

    	case eType_Open:

    	    /* create a list of all tags for open type */
    	    for (i = 1; i < 0x20; i++)
    	    {
        		*tt = NewTag(eTagType_Unknown);
        		(*tt)->Class = eTagClass_Unknown;
        		(*tt)->Tag = NewValue(NULL, Builtin_Type_Integer);
        		intx_setuint32(&(*tt)->Tag->U.Integer.Value, i);
        		tt = &(*tt)->Next;
    	    }
    	    break;

    	case eType_Reference:

    	    /* get the tags of the referenced type */
    	    for (t = reftype->FirstTags; t; t = t->Next)
    	    {
        		*tt = DupTag(t);
        		tt = &(*tt)->Next;
    	    }
    	    break;
    	}
    }
    *tt = NULL;
}

/* get the smallest tag of a tag list */
Tag_t *
FindSmallestTag(AssignmentList_t ass, TagList_t tags)
{
    Tag_t *mintag, *t;

    mintag = tags;
    for (t = tags->Next; t; t = t->Next) {
	if (mintag->Class > t->Class ||
	    mintag->Class == t->Class && intx_cmp(
	    &GetValue(ass, mintag->Tag)->U.Integer.Value,
	    &GetValue(ass, t->Tag)->U.Integer.Value) > 0)
	    mintag = t;
    }
    return mintag;
}

/* compare two tags by tag class and tag value */
int
CmpTags(const void *p1, const void *p2, void *ctx)
{
    Tag_t *tags1 = (Tag_t *)p1;
    Tag_t *tags2 = (Tag_t *)p2;
    Assignment_t *ass = (Assignment_t *)ctx;

    if (tags1->Class != tags2->Class)
	return tags1->Class - tags2->Class;
    return intx2uint32(&GetValue(ass, tags1->Tag)->U.Integer.Value) -
	intx2uint32(&GetValue(ass, tags2->Tag)->U.Integer.Value);
}

/* compare two components by their smallest tag */
int
CmpComponentsBySmallestTag(const void *p1, const void *p2, void *ctx)
{
    Component_t *c1 = (Component_t *)p1;
    Component_t *c2 = (Component_t *)p2;
    Assignment_t *ass = (Assignment_t *)ctx;
    Tag_t *tags1, *tags2;

    tags1 = FindSmallestTag(ass, c1->U.NOD.NamedType->Type->FirstTags);
    tags2 = FindSmallestTag(ass, c2->U.NOD.NamedType->Type->FirstTags);
    if (tags1->Class != tags2->Class)
	return tags1->Class - tags2->Class;
    return intx2uint32(&tags1->Tag->U.Integer.Value) -
	intx2uint32(&tags2->Tag->U.Integer.Value);
}

/* sort the components of a set or choice by their smallest tag */
void
SortTypeTags(AssignmentList_t ass, Type_t *type)
{
    Component_t **pcomponents, *extensions;

    switch (type->Type) {
    case eType_Set:
    case eType_Choice:
	/* remove extensions */
	for (pcomponents = &type->U.SSC.Components; *pcomponents;
	    pcomponents = &(*pcomponents)->Next) {
	    if ((*pcomponents)->Type == eComponent_ExtensionMarker)
		break;
	}
	extensions = *pcomponents;
	*pcomponents = NULL;

	/* sort extension root */
	qsortSL((void **)&type->U.SSC.Components, offsetof(Component_t, Next),
	    CmpComponentsBySmallestTag, ass);

	/* sort extensions */
	if (extensions && extensions->Next)
	    qsortSL((void **)&extensions->Next, offsetof(Component_t, Next),
		CmpComponentsBySmallestTag, ass);

	/* merge extension root and extensions */
	for (pcomponents = &type->U.SSC.Components; *pcomponents;
	    pcomponents = &(*pcomponents)->Next) {}
	*pcomponents = extensions;
	break;
    }
}

/* check if two lists of tags have common tags */
void
CheckCommonTags(AssignmentList_t ass, TagList_t tags1, TagList_t tags2)
{
    Tag_t *t1, *t2;
    int ret;

    qsortSL((void **)&tags1, offsetof(Tag_t, Next), CmpTags, ass);
    qsortSL((void **)&tags2, offsetof(Tag_t, Next), CmpTags, ass);
    for (t1 = tags1, t2 = tags2; t1 && t2; ) {
	ret = CmpTags((const void *)t1, (const void *)t2, (void *)ass);
	if (ret == 0) {
	    error(E_duplicate_tag, NULL);
	} else if (ret < 0) {
	    t1 = t1->Next;
	} else {
	    t2 = t2->Next;
	}
    }
}

/* check if a list of tags and the first tags of components have common tags */
void
CheckTagsInComponents(AssignmentList_t ass, TagList_t tags, ComponentList_t components, int untilnormal)
{
    for (; components; components = components->Next) {
	switch (components->Type) {
	case eComponent_Normal:
	case eComponent_Optional:
	case eComponent_Default:
	    CheckCommonTags(ass, tags,
		components->U.NOD.NamedType->Type->FirstTags);
	    if (untilnormal && components->Type == eComponent_Normal)
		return;
	    break;
	}
    }
}

/* check for common tags */
void
CheckTags(AssignmentList_t ass, Type_t *type)
{
    Component_t *c;
    Type_t *subtype;
    Tag_t *tag;

    switch (type->Type) {
    case eType_Sequence:

	/* check for common tags in a sequence: */
	/* the first tags of an optional/default component and the first */
	/* tags of the following components (up to and including the next */
	/* non-optional/non-default component) must not have common first */
	/* tags */
	for (c = type->U.Sequence.Components; c; c = c->Next) {
	    switch (c->Type) {
	    case eComponent_Optional:
	    case eComponent_Default:
		subtype = c->U.NOD.NamedType->Type;
		tag = subtype->FirstTags;
		CheckTagsInComponents(ass, tag, c->Next, 1);
		break;
	    }
	}
	break;

    case eType_Set:
    case eType_Choice:

	/* check for common tags in a set/choice: */
	/* the first tags of all components must be destinct */
	for (c = type->U.Sequence.Components; c; c = c->Next) {
	    switch (c->Type) {
	    case eComponent_Normal:
	    case eComponent_Optional:
	    case eComponent_Default:
		subtype = c->U.NOD.NamedType->Type;
		tag = subtype->FirstTags;
		CheckTagsInComponents(ass, tag, c->Next, 0);
		break;
	    }
	}
	break;
    }
}

/* build the list of PER-visible constraints */
void BuildConstraints(AssignmentList_t ass, Type_t *type)
{
    Type_t *reftype;
    Constraint_t *cons, *c1, *c2;
    Component_t *components;

    /* already done? */
    if (type->Flags & eTypeFlags_Done)
	return;
    type->Flags |= eTypeFlags_Done;

    switch (type->Type) {
    case eType_Reference:

	/* create an intersection of the constraints of the reference type */
	/* and the constraints of the referenced type */
	reftype = GetReferencedType(ass, type);
	BuildConstraints(ass, reftype);
	c1 = reftype->Constraints;
	c2 = type->Constraints;
	if (c1) {
	    if (c2) {
		IntersectConstraints(&cons, c1, c2);
	    } else {
		cons = c1;
	    }
	} else {
	    cons = c2;
	}
	type->Constraints = cons;

	/* get the PER-visible constraints */
	GetPERConstraints(ass, cons, &type->PERConstraints);
	break;

    case eType_Sequence:
    case eType_Set:
    case eType_Choice:
    case eType_InstanceOf:

	/* build the constraints of any component */
	for (components = type->U.SSC.Components; components;
	    components = components->Next) {
	    switch (components->Type) {
	    case eComponent_Normal:
	    case eComponent_Optional:
	    case eComponent_Default:
		reftype = components->U.NOD.NamedType->Type;
		BuildConstraints(ass, reftype);
		break;
	    }
	}

	/* get the PER-visible constraints */
	GetPERConstraints(ass, type->Constraints, &type->PERConstraints);
	break;

    case eType_SequenceOf:
    case eType_SetOf:

	/* build the constraints of the subtype */
	reftype = type->U.SS.Type;
	BuildConstraints(ass, reftype);

	/* get the PER-visible constraints */
	GetPERConstraints(ass, type->Constraints, &type->PERConstraints);
	break;

    default:

	/* get the PER-visible constraints */
	GetPERConstraints(ass, type->Constraints, &type->PERConstraints);
	break;
    }
}

/* build type flags from the directives */
void BuildDirectives(AssignmentList_t ass, Type_t *type, int isComponent)
{
    int pointer = 0;
    TypeRules_e rule = 0;
    RepresentationGroup_e grp;
    int32_t noctets;
    uint32_t zero;
    Directive_t *d;
    Component_t *components;
    Type_t *reftype;

    /* already done? */
    if (type->Flags & eTypeFlags_Done)
	return;
    type->Flags |= eTypeFlags_Done;

    /* get directive group which may be applied to the type */
    switch (type->Type)
    {
    case eType_Boolean:
    case eType_Integer:
    case eType_ObjectIdentifier:
    case eType_ObjectDescriptor:
    case eType_External:
    case eType_Real:
    case eType_Enumerated:
    case eType_EmbeddedPdv:
    case eType_Sequence:
    case eType_Set:
    case eType_InstanceOf:
    case eType_UTCTime:
    case eType_GeneralizedTime:
    case eType_Choice:
    case eType_BitString:
    case eType_OctetString:
        grp = eSingle;
        break;
    case eType_Reference:
        grp = eSingle;
        break;
    case eType_CharacterString:
    case eType_NumericString:
    case eType_PrintableString:
    case eType_TeletexString:
    case eType_T61String:
    case eType_VideotexString:
    case eType_IA5String:
    case eType_GraphicString:
    case eType_VisibleString:
    case eType_ISO646String:
    case eType_GeneralString:
    case eType_UniversalString:
    case eType_BMPString:
    case eType_RestrictedString:
    case eType_UTF8String:
        grp = eString;
        /*XXX rule = zero ? eTypeRules_ZeroTerminated : eTypeRules_FixedArray;
          for upperconstrained size */
        // lonchanc: it was eTypeRules_LengthPointer
        if (type->PrivateDirectives.fLenPtr)
        {
            rule = eTypeRules_LengthPointer;
        }
        else
        if (type->PrivateDirectives.fArray)
        {
            rule = eTypeRules_FixedArray;
        }
        else
        {
            GetStringType(ass, type, &noctets, &zero);
            rule = zero ? eTypeRules_ZeroTerminated : eTypeRules_LengthPointer;
        }
        break;
    case eType_Null:
        grp = eNull;
        break;
    case eType_SequenceOf:
    case eType_SetOf:
        grp = eMultiple;
        // lonchanc: it was eTypeRules_LengthPointer
        if (type->PrivateDirectives.fSLinked)
        {
            rule = eTypeRules_SinglyLinkedList;
        }
        else
        if (type->PrivateDirectives.fLenPtr)
        {
            rule = eTypeRules_LengthPointer;
        }
        else
        if (type->PrivateDirectives.fArray)
        {
            rule = eTypeRules_FixedArray;
        }
        else
        if (type->PrivateDirectives.fPointer)
        {
            rule = eTypeRules_PointerToElement | eTypeRules_FixedArray;
        }
        else
        if (type->PrivateDirectives.fDLinked)
        {
            rule = eTypeRules_DoublyLinkedList;
        }
        else
        {
            if (eExtension_Unconstrained == type->PERConstraints.Size.Type)
            {
                rule = g_eDefTypeRuleSS_NonSized;
            }
            else
            {
                rule = g_eDefTypeRuleSS_Sized;
            }
        }
        break;
    case eType_Selection:
	MyAbort();
	/*NOTREACHED*/
    case eType_Undefined:
	MyAbort();
	/*NOTREACHED*/
    }

    /* parse list of directives */
    for (d = type->Directives; d; d = d->Next) {
	switch (d->Type) {
	case eDirective_LengthPointer:
	    if (grp != eString)
		error(E_bad_directive, NULL);
	    rule = eTypeRules_LengthPointer;
	    break;
	case eDirective_ZeroTerminated:
	    if (grp != eString)
		error(E_bad_directive, NULL);
	    rule = eTypeRules_ZeroTerminated;
	    break;
	case eDirective_Pointer:
	    if (!isComponent)
		error(E_bad_directive, NULL);
	    pointer = eTypeRules_Pointer;
	    break;
	case eDirective_NoPointer:
	    if (!isComponent)
		error(E_bad_directive, NULL);
	    pointer = 0;
	    break;
	}
    }

    /* parse list of size directives of sequence of/set of */
    if (type->Type == eType_SequenceOf || type->Type == eType_SetOf) {
	for (d = type->U.SS.Directives; d; d = d->Next) {
	    switch (d->Type) {
	    case eDirective_FixedArray:
		rule = eTypeRules_FixedArray;
		break;
	    case eDirective_DoublyLinkedList:
		rule = eTypeRules_DoublyLinkedList;
		break;
	    case eDirective_SinglyLinkedList:
		rule = eTypeRules_SinglyLinkedList;
		break;
	    case eDirective_LengthPointer:
		rule = eTypeRules_LengthPointer;
		break;
	    }
	}
    }

    /* lists are always pointered, no additional pointer needed */
    if (rule & (eTypeRules_SinglyLinkedList | eTypeRules_DoublyLinkedList))
	pointer = 0;

    /* set type flags according to directive rule and pointer flag */
    type->Rules = rule | pointer;

    /* build directives of subtypes */
    switch (type->Type) {
    case eType_Sequence:
    case eType_Set:
    case eType_Choice:
    case eType_InstanceOf:
	components = type->U.SSC.Components;
	for (; components; components = components->Next) {
	    switch (components->Type) {
	    case eComponent_Normal:
	    case eComponent_Optional:
	    case eComponent_Default:
		reftype = components->U.NOD.NamedType->Type;
		BuildDirectives(ass, reftype, 1);
		break;
	    case eComponent_ExtensionMarker:
		break;
	    }
	}
	break;
    case eType_SequenceOf:
    case eType_SetOf:
	reftype = type->U.SS.Type;
	BuildDirectives(ass, reftype, 0);
	break;
    }
}

/* build type flags and counters for components */
/* will set eTypeFlags_Null if type has only null components */
/* will set eTypeFlags_Simple if type has only simple components */
/* will count optional/default components in the extension root (optionals) */
/* will count components in the extension root (alternatives) */
/* will count components in the extension (extensions) */
void
BuildComponentsTypeFlags(AssignmentList_t ass, ComponentList_t components, TypeFlags_e *flags, uint32_t *alternatives, uint32_t *optionals, uint32_t *extensions)
{
    int extended = 0;
    TypeFlags_e f = eTypeFlags_Null | eTypeFlags_Simple;

    while (components) {
	switch (components->Type) {
	case eComponent_Normal:
	case eComponent_Optional:
	case eComponent_Default:
	    BuildTypeFlags(ass, components->U.NOD.NamedType->Type);
	    if (!(components->U.NOD.NamedType->Type->Flags & eTypeFlags_Null))
		f &= ~eTypeFlags_Null;
	    if ((components->U.NOD.NamedType->Type->Rules &
		eTypeRules_Pointer) ||
		!(components->U.NOD.NamedType->Type->Flags & eTypeFlags_Simple))
		f &= ~eTypeFlags_Simple;
	    if (extended) {
		if (extensions)
		    (*extensions)++;
	    } else {
		if (alternatives)
		    (*alternatives)++;
		if (optionals && components->Type != eComponent_Normal)
		    (*optionals)++;
	    }
	    break;
	case eComponent_ExtensionMarker:
	    f |= eTypeFlags_ExtensionMarker;
	    extended = 1;
	    break;
	}
	components = components->Next;
    }
    *flags |= f;
}

/* build type flags and count components of sequence/set/choice types */
void
BuildTypeFlags(AssignmentList_t ass, Type_t *type)
{
    Assignment_t *a;
    Type_t *subtype;
    char *itype;
    int32_t sign;

    /* already done? */
    if (type->Flags & eTypeFlags_Done)
	return;
    type->Flags |= eTypeFlags_Done;


    switch (type->Type) {
    case eType_Null:

	/* null is null and simple */
	type->Flags |= eTypeFlags_Null | eTypeFlags_Simple;
	break;

    case eType_Boolean:
    case eType_Enumerated:

	/* boolean and enumerated are simple if no pointer is used  */
	if (!(type->Rules & eTypeRules_Pointer))
	    type->Flags |= eTypeFlags_Simple;
	break;

    case eType_Integer:

	/* integer is simple if no pointer is used and no intx_t is used */
	itype = GetIntegerType(ass, type, &sign);
	if (strcmp(itype, "ASN1intx_t") && !(type->Rules & eTypeRules_Pointer))
	    type->Flags |= eTypeFlags_Simple;
	break;

    case eType_Real:

	/* real is simple if no pointer is used and no real_t is used */
	itype = GetRealType(type);
	if (strcmp(itype, "ASN1real_t") && !(type->Rules & eTypeRules_Pointer))
	    type->Flags |= eTypeFlags_Simple;
	break;

    case eType_Sequence:
    case eType_Set:

	/* build type flags and counters for the components */
	BuildComponentsTypeFlags(ass, type->U.SSC.Components, &type->Flags,
	    NULL, &type->U.SSC.Optionals, &type->U.Sequence.Extensions);

	/* an extended type or a type containing optionals is not null */
	if ((type->Flags & eTypeFlags_ExtensionMarker) || type->U.SSC.Optionals)
	    type->Flags &= ~eTypeFlags_Null;
	break;

    case eType_SequenceOf:
    case eType_SetOf:

	/* never null nor simple */
    	BuildTypeFlags(ass, type->U.SS.Type);
    	break;

    case eType_Choice:

	/* build type flags and counters for the components */
	BuildComponentsTypeFlags(ass, type->U.Choice.Components, &type->Flags,
	    &type->U.Choice.Alternatives, NULL, &type->U.Choice.Extensions);

	/* a choice of nulls with more than one alternative or extensions */
	/* is not null because an offset has to be encoded */
	/* set the nullchoice flag instead */
	if ((type->Flags & eTypeFlags_Null) && 
	    ((type->Flags & eTypeFlags_ExtensionMarker) ||
	    type->U.Choice.Alternatives > 1)) {
	    type->Flags &= ~eTypeFlags_Null;
	    type->Flags |= eTypeFlags_NullChoice;
	}
	break;

    case eType_Reference:

	/* get the flags of the referenced type */
	a = FindAssignment(ass, eAssignment_Type,
	    type->U.Reference.Identifier, type->U.Reference.Module);
	a = GetAssignment(ass, a);
	subtype = a->U.Type.Type;
	BuildTypeFlags(ass, subtype);
	type->Flags = subtype->Flags;
	break;
    }
}

/* Mark non-structured types (or all types if wanted) for generation */
void MarkTypeForGeneration(AssignmentList_t ass, Type_t *type, TypeFlags_e needed)
{
    Assignment_t *a;
    Component_t *components;

    /* already done? */
    if (type->Flags & eTypeFlags_Done) {
	type->Flags |= needed;
	return;
    }
    type->Flags |= eTypeFlags_Done | needed;

    if (!IsStructuredType(GetType(ass, type)) && !ForceAllTypes) {

	/* generate type only */
	type->Flags |= eTypeFlags_GenType;
    } else {
	
	if (type->Flags & eTypeFlags_Simple) {

	    /* generate encoding/decoding/compare */
	    type->Flags |= eTypeFlags_GenSimple;
	} else {

	    /* generate encoding/decoding/free/compare */
	    type->Flags |= eTypeFlags_GenAll;
	}
    }

    /* mark subtypes for generation */
    switch (type->Type) {
    case eType_Sequence:
    case eType_Set:
    case eType_Choice:
    case eType_InstanceOf:
	for (components = type->U.SSC.Components; components;
	    components = components->Next) {
	    switch (components->Type) {
	    case eComponent_Normal:
	    case eComponent_Optional:
	    case eComponent_Default:
		MarkTypeForGeneration(ass, components->U.NOD.NamedType->Type,
		    needed);
		break;
	    }
	}
	break;
    case eType_SequenceOf:
    case eType_SetOf:
	MarkTypeForGeneration(ass, type->U.SS.Type,
	    needed | eTypeFlags_GenCompare);
	break;
    case eType_Reference:
	a = FindAssignment(ass, eAssignment_Type,
	    type->U.Reference.Identifier, type->U.Reference.Module);
	a = GetAssignment(ass, a);
	MarkTypeForGeneration(ass, a->U.Type.Type, needed);
	break;
    }
}

/* mark a value for generation */
void
MarkValueForGeneration(AssignmentList_t ass, Value_t *value)
{

    /* already done? */
    if (value->Flags & eValueFlags_Done)
	return;
    value->Flags |= eValueFlags_GenAll | eValueFlags_Done;

    /* mark type of value for generation */
    if (value->Type)
	MarkTypeForGeneration(ass, value->Type, 0);
}

/* mark assignments for generation */
void
MarkForGeneration(AssignmentList_t ass, ModuleIdentifier_t *mainmodule, Assignment_t *a)
{
    /* builtin elements need not to be generated */
    if (!CmpModuleIdentifier(ass, a->Module, Builtin_Module) ||
        !CmpModuleIdentifier(ass, a->Module, Builtin_Character_Module))
	return;

    /* non-main module elements will require long names and are only */
    /* generated if they are referenced by elements of the main module */
    if (CmpModuleIdentifier(ass, a->Module, mainmodule)) {
	a->Flags |= eAssignmentFlags_LongName;
	return;
    }

    /* mark type/value for generation */
    switch (a->Type) {
    case eAssignment_Type:
	MarkTypeForGeneration(ass, a->U.Type.Type, 0);
	break;
    case eAssignment_Value:
	MarkValueForGeneration(ass, a->U.Value.Value);
	break;
    }
}

/* clear done flags of types */
void
ClearTypeDone(Type_t *type)
{
    Component_t *components;

    type->Flags &= ~eTypeFlags_Done;
    switch (type->Type) {
    case eType_Sequence:
    case eType_Set:
    case eType_Choice:
    case eType_InstanceOf:
	for (components = type->U.SSC.Components; components;
	    components = components->Next) {
	    switch (components->Type) {
	    case eComponent_Normal:
	    case eComponent_Optional:
	    case eComponent_Default:
		ClearTypeDone(components->U.NOD.NamedType->Type);
		break;
	    }
	}
	break;
    case eType_SequenceOf:
    case eType_SetOf:
	ClearTypeDone(type->U.SS.Type);
	break;
    }
}

/* clear done flags of values */
void
ClearValueDone(Value_t *value)
{
    value->Flags &= ~eValueFlags_Done;
    if (value->Type)
	ClearTypeDone(value->Type);
}

/* clear done flags of assignments */
void
ClearDone(AssignmentList_t ass)
{
    for (; ass; ass = ass->Next) {
	switch (ass->Type) {
	case eAssignment_Type:
	    ClearTypeDone(ass->U.Type.Type);
	    break;
	case eAssignment_Value:
	    ClearValueDone(ass->U.Value.Value);
	    break;
	}
    }
}

/* examination of assignments */
void Examination(AssignmentList_t *ass, ModuleIdentifier_t *mainmodule)
{
    Assignment_t *a, *nexta, **aa;
    Type_t *subtype;
    Value_t *subvalue;
    ObjectClass_t *subobjclass;
    Object_t *subobject;
    ObjectSet_t *subobjset;
    int redo;

    /* drop results of previous passes */
    for (aa = ass; *aa;) {
	if ((*aa)->Type == eAssignment_NextPass)
	    *aa = NULL;
	else
	    aa = &(*aa)->Next;
    }

    /* reverse order of assignments to get the original order */
    for (a = *ass, *ass = NULL; a; a = nexta) {
	nexta = a->Next;
	a->Next = *ass;
	*ass = a;
    }

    /* replace references from IMPORT by corresponding type-/value-/...-refs */
    for (a = *ass; a; a = a->Next) {
	if (a->Type == eAssignment_Reference) {
	    a->Type = GetAssignmentType(*ass, a);
	    switch (a->Type) {
	    case eAssignment_Type:
		subtype = NewType(eType_Reference);
		subtype->U.Reference.Identifier = a->U.Reference.Identifier;
		subtype->U.Reference.Module = a->U.Reference.Module;
		a->U.Type.Type = subtype;
		break;
	    case eAssignment_Value:
		subvalue = NewValue(NULL, NULL);
		subvalue->U.Reference.Identifier = a->U.Reference.Identifier;
		subvalue->U.Reference.Module = a->U.Reference.Module;
		a->U.Value.Value = subvalue;
		break;
	    case eAssignment_ObjectClass:
		subobjclass = NewObjectClass(eObjectClass_Reference);
		subobjclass->U.Reference.Identifier = a->U.Reference.Identifier;
		subobjclass->U.Reference.Module = a->U.Reference.Module;
		a->U.ObjectClass.ObjectClass = subobjclass;
		break;
	    case eAssignment_Object:
		subobject = NewObject(eObject_Reference);
		subobject->U.Reference.Identifier = a->U.Reference.Identifier;
		subobject->U.Reference.Module = a->U.Reference.Module;
		a->U.Object.Object = subobject;
		break;
	    case eAssignment_ObjectSet:
		subobjset = NewObjectSet(eObjectSet_Reference);
		subobjset->U.Reference.Identifier = a->U.Reference.Identifier;
		subobjset->U.Reference.Module = a->U.Reference.Module;
		a->U.ObjectSet.ObjectSet = subobjset;
		break;
	    default:
		MyAbort();
	    }
	}
    }

    /* name types in types, values in types, types of values, types of objects*/
    do {
	redo = 0;
	for (a = *ass; a; a = a->Next) {
	    switch (a->Type) {
	    case eAssignment_Type:
		redo |= NameSubType(ass, Identifier2C(a->Identifier),
		    a->U.Type.Type, a->Module);
		redo |= NameValueOfType(ass, Identifier2C(a->Identifier),
		    a->U.Type.Type, a->Module);
		break;
	    case eAssignment_Value:
		redo |= NameTypeOfValue(ass, Identifier2C(a->Identifier),
		    a->U.Value.Value, a->Module);
		break;
	    case eAssignment_Object:
		redo |= NameSettingsOfObject(ass,
		    Identifier2C(a->Identifier),
		    a->U.Object.Object, a->Module);
		break;
	    }
	}
    } while (redo);

    /* name identification of embedded pdv/character strings */
    for (a = *ass; a; a = a->Next) {
	if (a->Type == eAssignment_Type)
	    NameIdentificationValueOfType(ass, Identifier2C(a->Identifier),
		a->U.Type.Type, a->Module);
    }

    /* mark types that will be automatically tagged */
    for (a = *ass; a; a = a->Next) {
	if (a->Type == eAssignment_Type)
	    MarkTypeForAutotagging(*ass, a->U.Type.Type);
    }

    /* replace components of by corresponding components */
    for (a = *ass; a; a = a->Next) {
	if (a->Type == eAssignment_Type)
	    a->U.Type.Type = RebuildTypeWithoutComponentsOf(*ass,
		a->U.Type.Type);
    }

    /* replace selection types by corresponding component types */
    for (a = *ass; a; a = a->Next) {
	if (a->Type == eAssignment_Type)
	    a->U.Type.Type = RebuildTypeWithoutSelectionType(*ass,
		a->U.Type.Type);
    }

    /* perform automatic tagging */
    for (a = *ass; a; a = a->Next) {
	if (a->Type == eAssignment_Type)
	    AutotagType(*ass, a->U.Type.Type);
    }

    /* perform automatic extension */
    ClearDone(*ass);
    for (a = *ass; a; a = a->Next) {
	if (a->Type == eAssignment_Type)
	    AutoextendType(*ass, a->U.Type.Type);
    }

    /* build tags of Sequence/Set/Choice/InstanceOf */
    ClearDone(*ass);
    for (a = *ass; a; a = a->Next)
	{
		if (a->Type == eAssignment_Type)
		{
			switch (a->U.Type.Type->Type)
			{
			case eType_Sequence:
			case eType_Set:
			case eType_Choice:
			case eType_InstanceOf:
				BuildTags(*ass, a->U.Type.Type, a->eDefTagType);
				break;
			}
		}
    }

    /* build tags of other types */
    ClearDone(*ass);
    for (a = *ass; a; a = a->Next)
	{
		if (a->Type == eAssignment_Type)
		{
			switch (a->U.Type.Type->Type)
			{
			case eType_Sequence:
			case eType_Set:
			case eType_Choice:
			case eType_InstanceOf:
				break;
			default:
			    BuildTags(*ass, a->U.Type.Type, a->eDefTagType);
				break;
			}
		}
    }

    /* sort set and choice types by tag */
    for (a = *ass; a; a = a->Next) {
	if (a->Type == eAssignment_Type)
	    SortTypeTags(*ass, a->U.Type.Type);
    }

    /* check for duplicate tags */
    for (a = *ass; a; a = a->Next) {
	if (a->Type == eAssignment_Type)
	    CheckTags(*ass, a->U.Type.Type);
    }

    /* derive constraints of referenced types to referencing types */
    ClearDone(*ass);
    for (a = *ass; a; a = a->Next) {
	if (a->Type == eAssignment_Type)
	    BuildConstraints(*ass, a->U.Type.Type);
    }

    /* derive constraints of referenced types to referencing types of values */
    for (a = *ass; a; a = a->Next) {
	if (a->Type == eAssignment_Value)
	    BuildConstraints(*ass, GetValue(*ass, a->U.Value.Value)->Type);
    }

    /* examine directives of types */
    ClearDone(*ass);
    for (a = *ass; a; a = a->Next) {
	if (a->Type == eAssignment_Type)
	    BuildDirectives(*ass, a->U.Type.Type, 0);
    }

    /* examine types to be empty/simple/choice of nulls */
    ClearDone(*ass);
    for (a = *ass; a; a = a->Next) {
	if (a->Type == eAssignment_Type)
	    BuildTypeFlags(*ass, a->U.Type.Type);
    }

    /* mark types and values that shall be generated */
    ClearDone(*ass);
    for (a = *ass; a; a = a->Next) {
	MarkForGeneration(*ass, mainmodule, a);
    }

    /* sort assignments so that no forward references will be needed */
    SortAssignedTypes(ass);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\asn1\asn1c\genber.c ===
/* Copyright (C) Boris Nikolaus, Germany, 1996-1997. All rights reserved. */
/* Copyright (C) Microsoft Corporation, 1997-1998. All rights reserved. */

#include "precomp.h"
#include "optcase.h"

// encode
#define LEN_OFFSET_STR2     "nExplTagLenOff"
#define LEN_OFFSET_STR      "nLenOff"

// decode
#define DECODER_NAME        "dd"
#define STREAM_END_NAME     "di"
#define DECODER_NAME2       "pExplTagDec"
#define STREAM_END_NAME2    "pbExplTagDataEnd"

void GenBERFuncSimpleType(AssignmentList_t ass, BERTypeInfo_t *info, char *valref, TypeFunc_e et, char *encref, char *tagref);
void GenBERStringTableSimpleType(AssignmentList_t ass, BERTypeInfo_t *info, char *valref);
void GenBEREncSimpleType(AssignmentList_t ass, BERTypeInfo_t *info, char *valref, char *encref, char *tagref);
void GenBEREncGenericUnextended(
    AssignmentList_t ass,
    BERTypeInfo_t *info,
    char *valref,
    char *lenref,
    char *encref,
    char *tagref);
void GenBERFuncComponents(AssignmentList_t ass, char *module, uint32_t optindex, ComponentList_t components, char *valref, char *encref, char *oref, TypeFunc_e et, BERTypeInfo_t *, int *);
void GenBERFuncSequenceSetType(AssignmentList_t ass, char *module, Assignment_t *at, char *valref, char *encref, TypeFunc_e et, char *tagref);
void GenBERFuncChoiceType(AssignmentList_t ass, char *module, Assignment_t *at, char *valref, char *encref, TypeFunc_e et, char *tagref);
void GenBERDecSimpleType(AssignmentList_t ass, BERTypeInfo_t *info, char *valref, char *encref, char *tagref);
void GenBERDecGenericUnextended(
    AssignmentList_t ass,
    BERTypeInfo_t *info,
    char *valref,
    char *lenref,
    char *encref,
    char *tagref);

extern int g_fDecZeroMemory;
extern int g_nDbgModuleName;
extern int g_fCaseBasedOptimizer;
extern int g_fNoAssert;

extern unsigned g_cPDUs;

int IsComponentOpenType(Component_t *com)
{
    if (eType_Open == com->U.NOD.NamedType->Type->Type)
    {
        return 1;
    }
    if (eType_Reference == com->U.NOD.NamedType->Type->Type)
    {
        if (eBERSTIData_Open == com->U.NOD.NamedType->Type->BERTypeInfo.Data)
        {
            return 1;
        }
    }
    return 0;
}

Component_t * FindOpenTypeComponent(ComponentList_t components)
{
    Component_t *com = NULL;
    for (com = components; com; com = com->Next)
    {
        if (IsComponentOpenType(com))
        {
            break;
        }
    }
    return com;
}

/* write header needed for BER encodings */
void
GenBERHeader()
{
//    output("#include \"berfnlib.h\"\n");
}

/* set prototypes and function args of BER functions */
void
GetBERPrototype(Arguments_t *args)
{
    args->enccast = "ASN1encoding_t, ASN1uint32_t, void *";
    args->encfunc = "ASN1encoding_t enc, ASN1uint32_t tag, %s *val";
    args->Pencfunc = "ASN1encoding_t enc, ASN1uint32_t tag, P%s *val";
    args->deccast = "ASN1decoding_t, ASN1uint32_t, void *";
    args->decfunc = "ASN1decoding_t dec, ASN1uint32_t tag, %s *val";
    args->Pdecfunc = "ASN1decoding_t dec, ASN1uint32_t tag, P%s *val";
    args->freecast = "void *";
    args->freefunc = "%s *val";
    args->Pfreefunc = "P%s *val";
    args->cmpcast = "void *, void *";
    args->cmpfunc = "%s *val1, %s *val2";
    args->Pcmpfunc = "P%s *val1, P%s *val2";
}

/* write initialization function needed for BER encodings */
void
GenBERInit(AssignmentList_t ass, char *module)
{
    char *pszRule;
    switch (g_eSubEncodingRule)
    {
    default:
    case eSubEncoding_Basic:
        pszRule = "ASN1_BER_RULE_BER";
        break;
    case eSubEncoding_Canonical:
        pszRule = "ASN1_BER_RULE_CER";
        break;
    case eSubEncoding_Distinguished:
        pszRule = "ASN1_BER_RULE_DER";
        break;
    }
    output("%s = ASN1_CreateModule(0x%x, %s, %s, %d, (const ASN1GenericFun_t *) encfntab, (const ASN1GenericFun_t *) decfntab, freefntab, sizetab, 0x%lx);\n",
        module,
        ASN1_THIS_VERSION,
        pszRule,
        g_fNoAssert ? "ASN1FLAGS_NOASSERT" : "ASN1FLAGS_NONE",
        g_cPDUs,
        g_nDbgModuleName);
}

/* convert a tag to an uint32_t: */
/* bits  0..29: tag value */
/* bits 30..31: tag class */
uint32_t
Tag2uint32(AssignmentList_t ass, Tag_t *tag)
{
    uint32_t tagvalue;
    uint32_t tagclass;

    tagvalue = intx2uint32(&GetValue(ass, tag->Tag)->U.Integer.Value);
    tagclass = tag->Class; /* multiple of 0x40 */
    return (tagclass << 24) | tagvalue;
}

/* generate encoding of a tag */
uint32_t GenBEREncTag(char *pszLenOffName, AssignmentList_t ass, BERTypeInfo_t *info, char *encref, char **tagref)
{
    Tag_t *tag;
    uint32_t tagvalue;
    uint32_t neoc;
    char tagbuf[64];
    int first;

    neoc = 0;
    first = 1;
    if (*tagref)
        strcpy(tagbuf, *tagref);
    else
        strcpy(tagbuf, "0");

    /* we have to examine all tags */
    for (tag = info->Tags; tag; tag = tag ? tag->Next : NULL) {

        /* get value of tag */
        tagvalue = Tag2uint32(ass, tag);
        while (tag && tag->Type == eTagType_Implicit)
            tag = tag->Next;

        /* get tag */
        if (first && *tagref) {
            sprintf(tagbuf, "%s ? %s : 0x%x", *tagref, *tagref, tagvalue);
        } else {
            sprintf(tagbuf, "0x%x", tagvalue);
        }

        /* encode explicit tag */
        if (tag) {
            char szLenOff[24];
            sprintf(&szLenOff[0], "%s%u", pszLenOffName, neoc);
            outputvar("ASN1uint32_t %s;\n", &szLenOff[0]);
            output("if (!ASN1BEREncExplicitTag(%s, %s, &%s))\n", encref, tagbuf, &szLenOff[0]);
            output("return 0;\n");
            neoc++;
            strcpy(tagbuf, "0");
        }
        first = 0;
    }

    /* return last implicit tag */
    *tagref = strdup(tagbuf);

    return neoc;
}

/* generate encoding of end of tag */
void
GenBEREncTagEnd(char *pszLenOffName, uint32_t neoc, char *encref)
{
    while (neoc--)
    {
        char szLenOff[24];
        sprintf(&szLenOff[0], "%s%u", pszLenOffName, neoc);
        outputvar("ASN1uint32_t %s;\n", &szLenOff[0]);
        output("if (!ASN1BEREncEndOfContents(%s, %s))\n", encref, &szLenOff[0]);
        output("return 0;\n");
    }
}

/* generate decoding of a tag */
uint32_t
GenBERDecTag(char *pszDecoderName, char *pszOctetPtrName, AssignmentList_t ass, BERTypeInfo_t *info, char **encref, char **tagref)
{
    Tag_t *tag;
    uint32_t tagvalue;
    uint32_t depth;
    char encbuf[16];
    char tagbuf[64];
    int first;

    depth = 0;
    first = 1;
    if (*tagref)
        strcpy(tagbuf, *tagref);
    else
        strcpy(tagbuf, "0");

    /* we have to examine all tags */
    for (tag = info->Tags; tag; tag = tag ? tag->Next : NULL) {

        /* get value of tag */
        tagvalue = Tag2uint32(ass, tag);
        while (tag && tag->Type == eTagType_Implicit)
            tag = tag->Next;

        /* get tag */
        if (first && *tagref) {
            sprintf(tagbuf, "%s ? %s : 0x%x", *tagref, *tagref, tagvalue);
        } else {
            sprintf(tagbuf, "0x%x", tagvalue);
        }
        
        /* decode explicit tag */
        if (tag)
        {
            char szDecName[24];
            char szPtrName[24];
            sprintf(&szDecName[0], "%s%u", pszDecoderName, depth);
            sprintf(&szPtrName[0], "%s%u", pszOctetPtrName, depth);
            outputvar("ASN1decoding_t %s;\n",&szDecName[0]);
            outputvar("ASN1octet_t *%s;\n", &szPtrName[0]);
            output("if (!ASN1BERDecExplicitTag(%s, %s, &%s, &%s))\n",
                *encref, tagbuf, &szDecName[0], &szPtrName[0]);
            output("return 0;\n");
            *encref = strdup(&szDecName[0]);
            depth++;
            strcpy(tagbuf, "0");
        }
        first = 0;
    }

    /* return last implicit tag */
    *tagref = strdup(tagbuf);

    return depth;
}

/* generate decoding of end of tag */
void
GenBERDecTagEnd(char *pszDecoderName, char *pszOctetPtrName, uint32_t depth, char *encref)
{
    char szDecName[24];
    char szPtrName[24];
    uint32_t i;

    for (i = 0; i < depth; i++)
    {
        sprintf(&szDecName[0], "%s%u", pszDecoderName, depth - i - 1);
        sprintf(&szPtrName[0], "%s%u", pszOctetPtrName, depth - i - 1);
        if (i != depth - 1)
        {
            output("if (!ASN1BERDecEndOfContents(%s%u, %s, %s))\n",
                pszDecoderName, depth - i - 2, &szDecName[0], &szPtrName[0]);
        }
        else
        {
            output("if (!ASN1BERDecEndOfContents(%s, %s, %s))\n",
                encref, &szDecName[0], &szPtrName[0]);
        }
        output("return 0;\n");
    }
}

/* generate function body for a type */
void GenBERFuncType(AssignmentList_t ass, char *module, Assignment_t *at, TypeFunc_e et)
{
    Type_t *type;
    char *encref;
    char *valref;

    /* get some informations */
    type = at->U.Type.Type;
    switch (et) {
    case eStringTable:
        valref = encref = "";
        break;
    case eEncode:
        encref = "enc";
        valref = "val";
        break;
    case eDecode:
        encref = "dec";
        valref = "val";
        break;
    }

    /* function body */
    switch (type->Type) {
    case eType_Boolean:
    case eType_Integer:
    case eType_Enumerated:
    case eType_Real:
    case eType_BitString:
    case eType_OctetString:
    case eType_UTF8String:
    case eType_Null:
    case eType_EmbeddedPdv:
    case eType_External:
    case eType_ObjectIdentifier:
    case eType_BMPString:
    case eType_GeneralString:
    case eType_GraphicString:
    case eType_IA5String:
    case eType_ISO646String:
    case eType_NumericString:
    case eType_PrintableString:
    case eType_TeletexString:
    case eType_T61String:
    case eType_UniversalString:
    case eType_VideotexString:
    case eType_VisibleString:
    case eType_CharacterString:
    case eType_GeneralizedTime:
    case eType_UTCTime:
    case eType_ObjectDescriptor:
    case eType_RestrictedString:
    case eType_Open:
    case eType_Reference:
    case eType_SequenceOf:
    case eType_SetOf:
        GenBERFuncSimpleType(ass, &type->BERTypeInfo, Dereference(valref), et, encref, "tag");
        break;

    case eType_Sequence:
    case eType_Set:
    case eType_InstanceOf:
        GenBERFuncSequenceSetType(ass, module, at, valref, encref, et, "tag");
        break;

    case eType_Choice:
        GenBERFuncChoiceType(ass, module, at, valref, encref, et, "tag");
        break;

    case eType_Selection:
    case eType_Undefined:
        MyAbort();
        /*NOTREACHED*/
    }
}

/* generate function body for components */
void GenBERFuncComponents(AssignmentList_t ass, char *module, uint32_t optindex, ComponentList_t components, char *valref, char *encref, char *oref, TypeFunc_e et, BERTypeInfo_t *info, int *pfContainOpenTypeComWithDefTags)
{
    BERSTIData_e data = info->Data;
    Component_t *com;
    NamedType_t *namedType;
    char *ide;
    int conditional, inextension;
    uint32_t flg;
    Tag_t *tags;
    unsigned int first_tag, last_tag;
    int fDefTags;
    int fOpenTypeComponent;
    char valbuf[256];
    char typebuf[256];

    *pfContainOpenTypeComWithDefTags = 0;

    /* emit components */
    inextension = 0;
    for (com = components; com; com = com->Next)
    {
        fDefTags = 0; // safety net
        fOpenTypeComponent = 0; // safety net

        /* check for extension marker */
        if (com->Type == eComponent_ExtensionMarker) {
            inextension = 1;

            /* update index into optional field for sequence/set */
            if (data != eBERSTIData_Choice)
                optindex = (optindex + 7) & ~7;
            continue;
        }

        /* get some information */
        namedType = com->U.NOD.NamedType;
        ide = Identifier2C(namedType->Identifier);

        /* check if optional/default component is present or choice is */
        /* selected*/
        conditional = 0;
        switch (et) {
        case eStringTable:
            break;
        case eEncode:
            if (data == eBERSTIData_Choice) {
                output("case %d:\n", optindex);
                conditional = 1;
                optindex++;
            } else {
                if (com->Type == eComponent_Optional ||
                    com->Type == eComponent_Default ||
                    inextension) {
                    output("if (%s[%u] & 0x%x) {\n", oref,
                        optindex / 8, 0x80 >> (optindex & 7));
                    conditional = 1;
                    optindex++;
                }
            }
            break;
        case eDecode:
            if (data == eBERSTIData_Sequence &&
                com->Type != eComponent_Optional &&
                com->Type != eComponent_Default &&
                !inextension)
                break;

            fOpenTypeComponent = IsComponentOpenType(com);
            if (fOpenTypeComponent)
            {
                const unsigned int c_nDefFirstTag = 0x80000001;
                const unsigned int c_nDefLastTag  = 0x8000001f;
                unsigned int nTag = c_nDefFirstTag;
                tags = com->U.NOD.NamedType->Type->FirstTags;
                first_tag = Tag2uint32(ass, com->U.NOD.NamedType->Type->FirstTags);
                fDefTags = 1; // initial value
                while (tags->Next)
                {
                    fDefTags = fDefTags && (Tag2uint32(ass, tags) == nTag++);
                    tags = tags->Next;
                }
                last_tag = Tag2uint32(ass, tags);
                fDefTags = fDefTags && (c_nDefFirstTag == first_tag) && (c_nDefLastTag == last_tag);
                *pfContainOpenTypeComWithDefTags = *pfContainOpenTypeComWithDefTags || fDefTags;
            }
            if (data == eBERSTIData_Sequence)
            {
                if (fOpenTypeComponent)
                {
                    outputvar("ASN1uint32_t t;\n");
                    output("if (ASN1BERDecPeekTag(%s, &t)) {\n", encref);
                }
                else
                {
                    outputvar("ASN1uint32_t t;\n");
                    output("ASN1BERDecPeekTag(%s, &t);\n", encref);
                }
                if (! fDefTags)
                {
                    output("if (");
                }
                flg = 0;
            }
            if (eBERSTIData_Sequence == data && fDefTags && fOpenTypeComponent)
            {
            #if 0
                if (first_tag == last_tag)
                {
                    output("0x%x == t", first_tag);
                }
                else
                {
                    output("0x%x <= t && t <= 0x%x", first_tag, last_tag);
                }
            #endif
                conditional = 1;
            }
            else
            if (eBERSTIData_Set == data && fDefTags && fOpenTypeComponent)
            {
                output("default:\n");
            #if 1
                if (info->Flags & eTypeFlags_ExtensionMarker)
                {
                    output("#error \"Untagged open type cannot be in the SET construct with an extension mark.\nPlease manually fix the source code.\"");
                    output("ASSERT(0); /* Untagged open type cannot be in the SET construct with an extension mark */\n");
                    output("if (1) {\n");
                }
            #else
                if (first_tag == last_tag)
                {
                    output("if (0x%x == t) {\n", first_tag);
                }
                else
                {
                    output("if (0x%x <= t && t <= 0x%x) {\n", first_tag, last_tag);
                }
            #endif
                conditional = 1;
            }
            else
            if (eBERSTIData_Choice == data && fDefTags && fOpenTypeComponent)
            {
                output("default:\n");
            #if 1
                if (info->Flags & eTypeFlags_ExtensionMarker)
                {
                    output("#error \"Untagged open type cannot be in the CHOICE construct with an extension mark.\nPlease manually fix the source code.\"");
                    output("ASSERT(0); /* Untagged open type cannot be in the CHOICE construct with an extension mark */\n");
                    output("if (1) {\n");
                }
            #else
                if (first_tag == last_tag)
                {
                    output("if (0x%x == t) {\n", first_tag);
                }
                else
                {
                    output("if (0x%x <= t && t <= 0x%x) {\n", first_tag, last_tag);
                }
            #endif
                conditional = 1;
            }
            else
            {
                for (tags = com->U.NOD.NamedType->Type->FirstTags; tags; tags = tags->Next)
                {
                    switch (data)
                    {
                    case eBERSTIData_Choice:
                        output("case 0x%x:\n", Tag2uint32(ass, tags));
                        break;
                    case eBERSTIData_Set:
                        output("case 0x%x:\n", Tag2uint32(ass, tags));
                        break;
                    case eBERSTIData_Sequence:
                        if (flg)
                            output(" || ");
                        output("t == 0x%x", Tag2uint32(ass, tags));
                        flg = 1;
                        break;
                    default:
                        if (flg)
                            output(" || ");
                        output("t == 0x%x", Tag2uint32(ass, tags));
                        flg = 1;
                        break;
                    }
                }
            }
            if (data == eBERSTIData_Choice) {
                output("(%s)->choice = %d;\n", valref, optindex);
                conditional = 1;
                optindex++;
                break;
            } else {
                if (data == eBERSTIData_Sequence)
                {
                    if (! fDefTags)
                    {
                        output(") {\n");
                    }
                }
                if (com->Type == eComponent_Optional ||
                    com->Type == eComponent_Default ||
                    inextension) {
                    output("%s[%u] |= 0x%x;\n", oref,
                        optindex / 8, 0x80 >> (optindex & 7));
                    optindex++;
                }
                conditional = 1;
            }
            break;
        }

        /* dereference pointer if pointer directive used */
        if (data == eBERSTIData_Choice) {
            if (GetTypeRules(ass, namedType->Type) & eTypeRules_Pointer)
                sprintf(valbuf, "*(%s)->u.%s", valref, ide);
            else
                sprintf(valbuf, "(%s)->u.%s", valref, ide);
        } else {
            if (GetTypeRules(ass, namedType->Type) & eTypeRules_Pointer)
                sprintf(valbuf, "*(%s)->%s", valref, ide);
            else
                sprintf(valbuf, "(%s)->%s", valref, ide);
        }

        /* allocate memory if decoding and pointer directive used */
        if (et == eDecode &&
            (GetTypeRules(ass, namedType->Type) & eTypeRules_Pointer) &&
            !(GetType(ass, namedType->Type)->Flags & eTypeFlags_Null)) {
            sprintf(typebuf, "%s *",
                GetTypeName(ass, namedType->Type));
            output("if (!(%s = (%s)ASN1DecAlloc(%s, sizeof(%s))))\n",
                Reference(valbuf), typebuf, encref, valbuf);
            output("return 0;\n");
        }

        /* handle subtype value */
        GenBERFuncSimpleType(ass, &namedType->Type->BERTypeInfo,
            valbuf, et, encref, NULL);

        if (eDecode == et && fOpenTypeComponent)
        {
            if (eBERSTIData_Set == data && fDefTags)
            {
                if (info->Flags & eTypeFlags_ExtensionMarker)
                {
                    output("} else {\n");
                    output("if (!ASN1BERDecSkip(%s))\n", encref);
                    output("return 0;\n");
                    output("}\n");
                }
            }
            else
            if (eBERSTIData_Sequence == data)
            {
                if (! fDefTags)
                {
                    output("}\n");
                }
            }
        }
        /* end of check for presence of optional/default component */
        if (data == eBERSTIData_Set && et == eDecode ||
            data == eBERSTIData_Choice)
        {
            if (conditional)
                output("break;\n");
        }
        else
        {
            if (conditional)
                output("}\n");
        }
    }
}

/* generate function body for sequence/set type */
void
GenBERFuncSequenceSetType(AssignmentList_t ass, char *module, Assignment_t *at, char *valref, char *encref, TypeFunc_e et, char *tagref)
{
    Type_t *type = at->U.Type.Type;
    BERTypeInfo_t *info = &type->BERTypeInfo;
    uint32_t optionals, extensions;
    ComponentList_t components;
    char *oldencref;
    char *oldencref2;
    uint32_t neoc, depth;
    int fContainOpenTypeComWithDefTags = 0;
    char obuf[256];
    
    optionals = type->U.SSC.Optionals;
    extensions = type->U.SSC.Extensions;
    components = type->U.SSC.Components;

    /* handle tag and length */
    switch (et) {
    case eEncode:
        neoc = GenBEREncTag(LEN_OFFSET_STR2, ass, info, encref, &tagref);
        outputvar("ASN1uint32_t %s;\n", LEN_OFFSET_STR);
        output("if (!ASN1BEREncExplicitTag(%s, %s, &%s))\n", encref, tagref, LEN_OFFSET_STR);
        output("return 0;\n");
        // neoc++;
        break;
    case eDecode:
        outputvar("ASN1decoding_t dd;\n");
        outputvar("ASN1octet_t *di;\n");
        oldencref = encref;
        depth = GenBERDecTag(DECODER_NAME2, STREAM_END_NAME2, ass, info, &encref, &tagref);
        oldencref2 = encref;
        output("if (!ASN1BERDecExplicitTag(%s, %s, &dd, &di))\n",
            encref, tagref);
        output("return 0;\n");
        encref = "dd";
        if (optionals || extensions)
            output("ZeroMemory((%s)->o, %d);\n", valref,
                (optionals + 7) / 8 + (extensions + 7) / 8);
        break;
    }

    /* set/clear missing bits in optional/default bit field */
    GenFuncSequenceSetOptionals(ass, valref, components, optionals, extensions,
        obuf, et);

    /* create switch statement */
    if (et == eDecode) {
        switch (info->Data) {
        case eBERSTIData_Set:
            outputvar("ASN1uint32_t t;\n");
            output("while (ASN1BERDecNotEndOfContents(%s, di)) {\n", encref);
            output("if (!ASN1BERDecPeekTag(%s, &t))\n", encref);
            output("return 0;\n");
            output("switch (t) {\n");
            break;
        }
    }

    /* emit components */
    GenBERFuncComponents(ass, module, 0, components,
        valref, encref, obuf, et, info, &fContainOpenTypeComWithDefTags);

    /* end of switch statement */
    if (et == eDecode) {
        switch (info->Data) {
        case eBERSTIData_Set:
            // if (NULL == FindOpenTypeComponent(components))
            if (! fContainOpenTypeComWithDefTags)
            {
                output("default:\n");
                if (info->Flags & eTypeFlags_ExtensionMarker) {
                    output("if (!ASN1BERDecSkip(%s))\n", encref);
                    output("return 0;\n");
                    output("break;\n");
                } else {
                    output("ASN1DecSetError(%s, ASN1_ERR_CORRUPT);\n", encref);
                    output("return 0;\n");
                }
            }
            output("}\n");
            output("}\n");
            break;
        }
    }

    /* some user-friendly assignments for non-present optional/default */
    /* components */
    GenFuncSequenceSetDefaults(ass, valref, components, obuf, et);

    /* generate end of contents */
    switch (et) {
    case eEncode:
        /* encode the end-of-contents octets */
        output("if (!ASN1BEREncEndOfContents(%s, %s))\n", encref, LEN_OFFSET_STR);
        output("return 0;\n");

        GenBEREncTagEnd(LEN_OFFSET_STR2, neoc, encref);
        break;
    case eDecode:
        if ((info->Flags & eTypeFlags_ExtensionMarker) &&
            info->Data != eBERSTIData_Set) {
            output("while (ASN1BERDecNotEndOfContents(%s, di)) {\n", encref);
            output("if (!ASN1BERDecSkip(%s))\n", encref);
            output("return 0;\n");
            output("}\n");
        }
        output("if (!ASN1BERDecEndOfContents(%s, dd, di))\n", oldencref2);
        output("return 0;\n");
        GenBERDecTagEnd(DECODER_NAME2, STREAM_END_NAME2, depth, oldencref);
        break;
    }
}

/* generate function body for choice type */
// lonchanc: we should re-visit the work about ASN1_CHOICE_BASE.
// the change for BER is not complete!!! BUGBUG
void
GenBERFuncChoiceType(AssignmentList_t ass, char *module, Assignment_t *at, char *valref, char *encref, TypeFunc_e et, char *tagref)
{
    Type_t *type;
    BERTypeInfo_t *info;
    Component_t *components, *c;
    uint32_t neoc, depth;
    char *oldencref;
    uint32_t ncomponents;
    int fContainOpenTypeComWithDefTags = 0;

    /* get some informations */
    type = at->U.Type.Type;
    info = &type->BERTypeInfo;
    components = type->U.SSC.Components;
    for (c = components, ncomponents = 0; c; c = c->Next) {
        switch (c->Type) {
        case eComponent_Normal:
            ncomponents++;
            break;
        }
    }

    /* encode explicit tags */
    switch (et) {
    case eEncode:
        neoc = GenBEREncTag(LEN_OFFSET_STR2, ass, info, encref, &tagref);
        break;
    case eDecode:
        oldencref = encref;
        depth = GenBERDecTag(DECODER_NAME2, STREAM_END_NAME2, ass, info, &encref, &tagref);
        break;
    }

    /* create switch statement */
    switch (et) {
    case eStringTable:
        break;
    case eEncode:
        output("switch ((%s)->choice) {\n", valref);
        break;
    case eDecode:
        outputvar("ASN1uint32_t t;\n");
        output("if (!ASN1BERDecPeekTag(%s, &t))\n", encref);
        output("return 0;\n");
        output("switch (t) {\n");
        break;
    }

    /* generate components */
    GenBERFuncComponents(ass, module, ASN1_CHOICE_BASE, components,
        valref, encref, NULL, et, info, &fContainOpenTypeComWithDefTags);

    /* end of switch statement */
    switch (et) {
    case eStringTable:
        break;
    case eEncode:
        output("}\n");
        break;
    case eDecode:
        if (fContainOpenTypeComWithDefTags)
        {
            if (info->Flags & eTypeFlags_ExtensionMarker)
            {
                output("} else {\n");
                output("(%s)->choice = %d;\n", valref, ASN1_CHOICE_BASE + ncomponents); /* unknown extens.*/
                output("if (!ASN1BERDecSkip(%s))\n", encref);
                output("return 0;\n");
                output("}\n");
                output("break;\n");
            }
        }
        else
        {
            output("default:\n");
            if (info->Flags & eTypeFlags_ExtensionMarker) {
                output("(%s)->choice = %d;\n", valref, ASN1_CHOICE_BASE + ncomponents); /* unknown extens.*/
                output("if (!ASN1BERDecSkip(%s))\n", encref);
                output("return 0;\n");
                output("break;\n");
            } else {
                output("ASN1DecSetError(%s, ASN1_ERR_CORRUPT);\n", encref);
                output("return 0;\n");
            }
        }
        output("}\n");
        break;
    }

    /* generate end of contents */
    switch (et) {
    case eEncode:
        GenBEREncTagEnd(LEN_OFFSET_STR2, neoc, encref);
        break;
    case eDecode:
        GenBERDecTagEnd(DECODER_NAME2, STREAM_END_NAME2, depth, oldencref);
    }
}

/* generate function body for simple type */
void
GenBERFuncSimpleType(AssignmentList_t ass, BERTypeInfo_t *info, char *valref, TypeFunc_e et, char *encref, char *tagref)
{
    switch (et) {
    case eStringTable:
        break;
    case eEncode:
        GenBEREncSimpleType(ass, info, valref, encref, tagref);
        break;
    case eDecode:
        GenBERDecSimpleType(ass, info, valref, encref, tagref);
        break;
    }
}

/* generate encoding statements for a simple value */
void
GenBEREncSimpleType(AssignmentList_t ass, BERTypeInfo_t *info, char *valref, char *encref, char *tagref)
{
    char *lenref;
    char lenbuf[256], valbuf[256];
    BERTypeInfo_t inf;

    inf = *info;

    /* examine type for special handling */
    switch (inf.Data) {
    case eBERSTIData_BitString:
    case eBERSTIData_RZBBitString:
    case eBERSTIData_OctetString:
    case eBERSTIData_UTF8String:
    case eBERSTIData_String:

        /* length and value of bit string, octet string and string */
        if (*valref != '*')
        {
            sprintf(lenbuf, "(%s).length", valref);
            sprintf(valbuf, "(%s).value", valref);
        }
        else
        {
            sprintf(lenbuf, "(%s)->length", Reference(valref));
            sprintf(valbuf, "(%s)->value", Reference(valref));
        }
        lenref = lenbuf;
        valref = valbuf;

        /* check for remove-zero-bits bit string */
        if (inf.Data == eBERSTIData_RZBBitString) {
            outputvar("ASN1uint32_t r;\n");
            output("r = %s;\n", lenref);
            output("ASN1BEREncRemoveZeroBits(&r, %s);\n",
                valref);
            lenref = "r";
        }
        break;

    case eBERSTIData_SequenceOf:
    case eBERSTIData_SetOf:

        if (inf.Rules & eTypeRules_PointerArrayMask)
        {
            /* length and value of sequence of/set of value with */
            /* length-pointer representation */
            sprintf(lenbuf, "(%s)->count", Reference(valref));
            sprintf(valbuf, "(%s)->value", Reference(valref));
            lenref = lenbuf;
            valref = valbuf;
        }
        else
        if (inf.Rules & eTypeRules_LinkedListMask)
        {
            lenref = "t";
        }
        else
        {
            MyAbort();
        }
        break;

    case eBERSTIData_ZeroString:

        /* length of a zero-terminated string value */
        outputvar("ASN1uint32_t t;\n");
        output("t = lstrlenA(%s);\n", valref);
        lenref = "t";
        break;

    case eBERSTIData_Boolean:

        if (g_fCaseBasedOptimizer)
        {
            if (BerOptCase_IsBoolean(&inf))
            {
                break;
            }
        }

        /* value of a boolean value */
        sprintf(valbuf, "(%s) ? 255 : 0", valref);
        valref = valbuf;
        inf.Data = eBERSTIData_Unsigned;
        break;

    default:

        /* other values have no additional length */
        lenref = NULL;
        break;
    }

    /* generate the encoding of the value */
    GenBEREncGenericUnextended(ass, &inf, valref, lenref, encref, tagref);
}

/* generate encoding statements for a simple value (after some special */
/* handling has been done) */
void
GenBEREncGenericUnextended(AssignmentList_t ass, BERTypeInfo_t *info, char *valref, char *lenref, char *encref, char *tagref)
{
    uint32_t neoc;
    char *p;
    char valbuf[256];

    /* encode tags */
    neoc = GenBEREncTag(LEN_OFFSET_STR, ass, info, encref, &tagref);

    /* encode length and value */
    switch (info->Data) {
    case eBERSTIData_Null:

        /* encode null value */
        output("if (!ASN1BEREncNull(%s, %s))\n", encref, tagref);
        output("return 0;\n");
        break;

    case eBERSTIData_Unsigned:
    case eBERSTIData_Integer:

        /* encode integer value; check for intx_t representation */
        if (info->NOctets) {
            if (info->Data == eBERSTIData_Unsigned) {
                output("if (!ASN1BEREncU32(%s, %s, %s))\n",
                    encref, tagref, valref);
            } else {
                output("if (!ASN1BEREncS32(%s, %s, %s))\n",
                    encref, tagref, valref);
            }
            output("return 0;\n");
        } else {
            output("if (!ASN1BEREncSX(%s, %s, %s))\n",
                encref, tagref, Reference(valref));
            output("return 0;\n");
        }
        break;

    case eBERSTIData_Real:

        /* encode real value; check for real_t representation */
        if (info->NOctets)
            output("if (!ASN1BEREncDouble(%s, %s, %s))\n",
                encref, tagref, valref);
        else
            output("if (!ASN1BEREncReal(%s, %s, %s))\n",
                encref, tagref, Reference(valref));
        output("return 0;\n");
        break;

    case eBERSTIData_BitString:
    case eBERSTIData_RZBBitString:

        /* encode bit string value */
        output("if (!ASN1%cEREncBitString(%s, %s, %s, %s))\n",
            g_eSubEncodingRule, encref, tagref, lenref, valref);
        output("return 0;\n");
        break;

    case eBERSTIData_OctetString:

        /* encode octet string value */
        output("if (!ASN1%cEREncOctetString(%s, %s, %s, %s))\n",
            g_eSubEncodingRule, encref, tagref, lenref, valref);
        output("return 0;\n");
        break;

    case eBERSTIData_UTF8String:

        /* encode octet string value */
        output("if (!ASN1%cEREncUTF8String(%s, %s, %s, %s))\n",
            g_eSubEncodingRule, encref, tagref, lenref, valref);
        output("return 0;\n");
        break;

    case eBERSTIData_SetOf:

        /* encoding of a set of value */
        if (eSubEncoding_Canonical      == g_eSubEncodingRule ||
            eSubEncoding_Distinguished  == g_eSubEncodingRule)
        {
            /* encoding of a set of value for DER/CER */

            /* lists will require an additional iterator */
            if (info->Rules &
                (eTypeRules_SinglyLinkedList | eTypeRules_DoublyLinkedList))
            {
                outputvar("P%s f;\n", info->Identifier);
            }

            /* encode the tag and infinite-length first */
            outputvar("ASN1uint32_t %s;\n", LEN_OFFSET_STR);
            output("if (!ASN1BEREncExplicitTag(%s, %s, &%s))\n", encref, tagref, LEN_OFFSET_STR);
            output("return 0;\n");

            /* create the SetOf block */
            outputvar("void *pBlk;\n");
            output("if (!ASN1DEREncBeginBlk(%s, ASN1_DER_SET_OF_BLOCK, &pBlk))\n", encref);
            output("return 0;\n");

            /* encode all elements */
            /* get the name of the elements */
            /* advance the iterator for lists */
            if (info->Rules & eTypeRules_PointerArrayMask)
            {
                outputvar("ASN1uint32_t i;\n");
                output("for (i = 0; i < %s; i++) {\n", lenref);
                sprintf(valbuf, "(%s)[i]", valref);
            }
            else if (info->Rules & eTypeRules_LinkedListMask)
            {
                output("for (f = %s; f; f = f->next) {\n", valref);
                sprintf(valbuf, "f->value");
            }
            else
            {
                MyAbort();
            }

            /* create the secondary encoder structure */
            outputvar("ASN1encoding_t enc2;\n");
            output("if (!ASN1DEREncNewBlkElement(pBlk, &enc2))\n");
            output("return 0;\n");

            /* encode the element */
            GenBERFuncSimpleType(ass, &info->SubType->BERTypeInfo, valbuf,
                eEncode, "enc2", NULL);

            /* create the secondary encoder structure */
            output("if (!ASN1DEREncFlushBlkElement(pBlk))\n");
            output("return 0;\n");

            /* end of loop */
            output("}\n");

            /* create the secondary encoder structure */
            output("if (!ASN1DEREncEndBlk(pBlk))\n");
            output("return 0;\n");

            /* encode the end-of-contents octets */
            output("if (!ASN1BEREncEndOfContents(%s, %s))\n", encref, LEN_OFFSET_STR);
            output("return 0;\n");
            break;
        }

        /*FALLTHROUGH*/

    case eBERSTIData_SequenceOf:

        /* encoding of a sequence of value */

        /* lists will require an additional iterator */
        if (info->Rules & eTypeRules_LinkedListMask)
        {
            outputvar("P%s f;\n", info->Identifier);
        }

        /* encode the tag and infinite-length first */
        outputvar("ASN1uint32_t %s;\n", LEN_OFFSET_STR);
        output("if (!ASN1BEREncExplicitTag(%s, %s, &%s))\n", encref, tagref, LEN_OFFSET_STR);
        output("return 0;\n");

        /* encode all elements */
        /* get the name of the elements */
        /* advance the iterator for lists */
        if (info->Rules & eTypeRules_PointerArrayMask)
        {
            outputvar("ASN1uint32_t i;\n");
            output("for (i = 0; i < %s; i++) {\n", lenref);
            sprintf(valbuf, "(%s)[i]", valref);
        }
        else if (info->Rules & eTypeRules_LinkedListMask)
        {
            output("for (f = %s; f; f = f->next) {\n", valref);
            sprintf(valbuf, "f->value");
        }
        else
		{
            MyAbort();
		}

        /* encode the element */
        GenBERFuncSimpleType(ass, &info->SubType->BERTypeInfo, valbuf,
            eEncode, encref, NULL);

        /* end of loop */
        output("}\n");

        /* encode the end-of-contents octets */
        output("if (!ASN1BEREncEndOfContents(%s, %s))\n", encref, LEN_OFFSET_STR);
        output("return 0;\n");
        break;

    case eBERSTIData_ObjectIdentifier:

        /* encode an object identifier value */
        if (info->pPrivateDirectives->fOidArray  || g_fOidArray)
        {
            output("if (!ASN1BEREncObjectIdentifier2(%s, %s, %s))\n",
                encref, tagref, Reference(valref));
        }
        else
        {
            output("if (!ASN1BEREncObjectIdentifier(%s, %s, %s))\n",
                encref, tagref, Reference(valref));
        }
        output("return 0;\n");
        break;

    case eBERSTIData_ObjectIdEncoded:

        /* encode an encoded object identifier value */
        output("if (!ASN1BEREncEoid(%s, %s, %s))\n",
            encref, tagref, Reference(valref));
        output("return 0;\n");
        break;

    case eBERSTIData_String:
    case eBERSTIData_ZeroString:

        /* encode a string value */
        if (info->NOctets == 1) {
            p = "Char";
        } else if (info->NOctets == 2) {
            p = "Char16";
        } else if (info->NOctets == 4) {
            p = "Char32";
        } else
            MyAbort();
        output("if (!ASN1%cEREnc%sString(%s, %s, %s, %s))\n",
            g_eSubEncodingRule, p, encref, tagref, lenref, valref);
        output("return 0;\n");
        break;

    case eBERSTIData_External:

        /* encode an external value */
        output("if (!ASN1BEREncExternal(%s, %s, %s))\n",
            encref, tagref, Reference(valref));
        output("return 0;\n");
        break;

    case eBERSTIData_EmbeddedPdv:

        /* encode an embedded pdv value */
        output("if (!ASN1BEREncEmbeddedPdv(%s, %s, %s))\n",
            encref, tagref, Reference(valref));
        output("return 0;\n");
        break;

    case eBERSTIData_MultibyteString:

        /* encode a multibyte string value */
        if (info->Rules & eTypeRules_LengthPointer)
        {
            output("if (!ASN1%cEREncMultibyteString(%s, %s, %s))\n",
                g_eSubEncodingRule, encref, tagref, Reference(valref));
        }
        else
        {
            output("if (!ASN1%cEREncZeroMultibyteString(%s, %s, %s))\n",
                g_eSubEncodingRule, encref, tagref, valref);
        }
        output("return 0;\n");
        break;

    case eBERSTIData_UnrestrictedString:

        /* encode an character string value */
        output("if (!ASN1BEREncCharacterString(%s, %s, %s))\n",
            encref, tagref, Reference(valref));
        output("return 0;\n");
        break;

    case eBERSTIData_GeneralizedTime:

        /* encode a generalized time value */
        output("if (!ASN1%cEREncGeneralizedTime(%s, %s, %s))\n",
            g_eSubEncodingRule, encref, tagref, Reference(valref));
        output("return 0;\n");
        break;

    case eBERSTIData_UTCTime:

        /* encode a utc time value */
        output("if (!ASN1%cEREncUTCTime(%s, %s, %s))\n",
            g_eSubEncodingRule, encref, tagref, Reference(valref));
        output("return 0;\n");
        break;

    case eBERSTIData_Open:
        
        /* encode an open type value */
        output("if (!ASN1BEREncOpenType(%s, %s))\n",
            encref, Reference(valref));
        output("return 0;\n");
        break;

    case eBERSTIData_Reference:

        /* call other encoding function for reference types */
        output("if (!ASN1Enc_%s(%s, %s, %s))\n",
            Identifier2C(info->SubIdentifier),
            encref, tagref, Reference(valref));
        output("return 0;\n");
        break;

    case eBERSTIData_Boolean:
        if (g_fCaseBasedOptimizer)
        {
            output("if (!ASN1BEREncBool(%s, %s, %s))\n", encref, tagref, valref);
            output("return 0;\n");
        }
        break;
    }

    /* encode the end of tag octets */
    GenBEREncTagEnd(LEN_OFFSET_STR, neoc, encref);
}

/* generate decoding statements for a simple value */
void
GenBERDecSimpleType(AssignmentList_t ass, BERTypeInfo_t *info, char *valref, char *encref, char *tagref)
{
    char valbuf[256], lenbuf[256];
    char *lenref;
    BERTypeInfo_t inf;

    inf = *info;

    /* examine type for special handling */
    switch (inf.Data) {
    case eBERSTIData_SequenceOf:
    case eBERSTIData_SetOf:

        if (inf.Rules & eTypeRules_PointerArrayMask)
        {
            /* length and value of sequence of/set of value with */
            /* length-pointer representation */
            sprintf(lenbuf, "(%s)->count", Reference(valref));
            sprintf(valbuf, "(%s)->value", Reference(valref));
            lenref = lenbuf;
            valref = valbuf;
        }
        else
        if (inf.Rules & eTypeRules_LinkedListMask)
        {
            /* use a loop for sequence of/set of value with */
            /* list representation */
            outputvar("P%s *f;\n", inf.Identifier);
            lenref = NULL;
        }
        else
        {
            MyAbort();
        }
        break;

    case eBERSTIData_Boolean:

        if (g_fCaseBasedOptimizer)
        {
            if (BerOptCase_IsBoolean(&inf))
            {
                break;
            }
        }

        /* boolean value */
        inf.Data = eBERSTIData_Unsigned;
        lenref = NULL;
        break;

    default:

        /* other values have no additional length */
        lenref = NULL;
        break;
    }

    /* generate the decoding of the value */
    GenBERDecGenericUnextended(ass, &inf, valref, lenref, encref, tagref);
}

/* generate decoding statements for a simple value (after some special */
/* handling has been done) */
void
GenBERDecGenericUnextended(AssignmentList_t ass, BERTypeInfo_t *info, char *valref, char *lenref, char *encref, char *tagref)
{
    uint32_t depth;
    char *p;
    char *oldencref;
    char *oldencref2;
    char valbuf[256];

    /* decode tags */
    oldencref = encref;
    depth = GenBERDecTag(DECODER_NAME, STREAM_END_NAME, ass, info, &encref, &tagref);

    /* decode length and value */
    switch (info->Data) {
    case eBERSTIData_Null:

        /* decode null value */
        output("if (!ASN1BERDecNull(%s, %s))\n", encref, tagref);
        output("return 0;\n");
        break;

    case eBERSTIData_Integer:

        /* decode integer value; check for intx_t representation */
        if (!info->NOctets) {
            output("if (!ASN1BERDecSXVal(%s, %s, %s))\n",
                encref, tagref, Reference(valref));
            output("return 0;\n");
        } else {
            output("if (!ASN1BERDecS%dVal(%s, %s, %s))\n",
                info->NOctets * 8, encref, tagref, Reference(valref));
            output("return 0;\n");
        }
        break;

    case eBERSTIData_Unsigned:
        if (!info->NOctets) {
            output("if (!ASN1BERDecSXVal(%s, %s, %s))\n",
                encref, tagref, Reference(valref));
            output("return 0;\n");
        } else {
            unsigned long cBits = info->NOctets * 8;
            if (32 == cBits)
            {
                output("if (!ASN1BERDecU32Val(%s, %s, (ASN1uint32_t *) %s))\n",
                    encref, tagref, Reference(valref));
            }
            else
            {
                output("if (!ASN1BERDecU%uVal(%s, %s, %s))\n",
                    cBits, encref, tagref, Reference(valref));
            }
            output("return 0;\n");
        }
        break;

    case eBERSTIData_Real:

        /* decode real value; check for real_t representation */
        if (info->NOctets)
            output("if (!ASN1BERDecDouble(%s, %s, %s))\n",
                encref, tagref, Reference(valref));
        else
            output("if (!ASN1BERDecReal(%s, %s, %s))\n",
                encref, tagref, Reference(valref));
        output("return 0;\n");
        break;

    case eBERSTIData_BitString:
    case eBERSTIData_RZBBitString:

        /* decode bit string value */
        output("if (!ASN1BERDecBitString%s(%s, %s, %s))\n",
            info->pPrivateDirectives->fNoMemCopy ? "2" : "",
            encref, tagref, Reference(valref));
        output("return 0;\n");
        break;

    case eBERSTIData_OctetString:

        /* decode octet string value */
        output("if (!ASN1BERDecOctetString%s(%s, %s, %s))\n",
            info->pPrivateDirectives->fNoMemCopy ? "2" : "",
            encref, tagref, Reference(valref));
        output("return 0;\n");
        break;

    case eBERSTIData_UTF8String:

        /* decode octet string value */
        output("if (!ASN1BERDecUTF8String(%s, %s, %s))\n",
            encref, tagref, Reference(valref));
        output("return 0;\n");
        break;

    case eBERSTIData_SetOf:
    case eBERSTIData_SequenceOf:

        /* encoding of a set of/sequence of value */
        outputvar("ASN1decoding_t dd;\n");
        outputvar("ASN1octet_t *di;\n");

        /* decode the tag and length first */
        output("if (!ASN1BERDecExplicitTag(%s, %s, &dd, &di))\n",
            encref, tagref);
        output("return 0;\n");

        oldencref2 = encref;
        encref = "dd";
        outputvar("ASN1uint32_t t;\n");
        if (info->Rules & eTypeRules_LengthPointer)
		{
            /* get length and value of sequence of/set of value with */
            /* length-pointer representation */
            outputvar("ASN1uint32_t n;\n");
            output("%s = n = 0;\n", lenref);
            output("%s = NULL;\n", valref);
        }
		else
        if (info->Rules & eTypeRules_FixedArray)
		{
            /* get length and value of sequence of/set of value with */
			/* fixed-array representation*/
            output("%s = 0;\n", lenref);
		}
		else
		if (info->Rules & eTypeRules_SinglyLinkedList)
		{
            /* use additional iterator for sequence of/set of value with */
            /* singly-linked-list representation */
            outputvar("P%s *f;\n", info->Identifier);
            output("f = %s;\n", Reference(valref));

        }
		else
		if (info->Rules & eTypeRules_DoublyLinkedList)
		{
            /* use additional iterator and iterator pointer for sequence of/ */
            /* set of value with doubly-linked-list representation */
            outputvar("P%s *f;\n", info->Identifier);
            outputvar("%s b;\n", info->Identifier);
            output("f = %s;\n", Reference(valref));
            output("b = NULL;\n");
        }

        /* decode while not constructed is not empty */
        output("while (ASN1BERDecNotEndOfContents(%s, di)) {\n", encref);

        /* get next tag */
        output("if (!ASN1BERDecPeekTag(%s, &t))\n", encref);
        output("return 0;\n");

        if (info->Rules & eTypeRules_PointerArrayMask)
        {
            if (info->Rules & eTypeRules_LengthPointer)
            {
                /* resize allocated array if it is too small */
                output("if (%s >= n) {\n", lenref);
                output("n = n ? (n << 1) : 16;\n");
                output("if (!(%s = (%s *)ASN1DecRealloc(%s, %s, n * sizeof(%s))))\n",
                    valref, GetTypeName(ass, info->SubType), encref,
                    valref, Dereference(valref));
                output("return 0;\n");
                output("}\n");
            }
            /* get the name of the value */
            sprintf(valbuf, "(%s)[%s]", valref, lenref);
        }
        else
        if (info->Rules & eTypeRules_LinkedListMask)
        {
            /* allocate one element */
            output("if (!(*f = (P%s)ASN1DecAlloc(%s, sizeof(**f))))\n",
                info->Identifier, encref);
            output("return 0;\n");

            /* get the name of the value */
            sprintf(valbuf, "(*f)->value");
        }

        /* decode the element */
        GenBERFuncSimpleType(ass, &info->SubType->BERTypeInfo, valbuf,
            eDecode, encref, NULL);

        if (info->Rules &
            (eTypeRules_LengthPointer | eTypeRules_FixedArray)) {

            /* advance the length of the array contents */
            output("(%s)++;\n", lenref);

        } else if (info->Rules & eTypeRules_SinglyLinkedList) {

            /* adjust the pointer for the next element */
            output("f = &(*f)->next;\n");

        } else if (info->Rules & eTypeRules_DoublyLinkedList) {

            /* adjust the pointer for the next element and */
            /* update the back pointer */
            output("(*f)->prev = b;\n");
            output("b = *f;\n");
            output("f = &b->next;\n");
        }

        /* end of loop */
        output("}\n");

        if (info->Rules & eTypeRules_LengthPointer)
        {
        #if 0 // lonchanc: no need to shrink the memory thru realloc
            // lonchanc: no need to allocate memory for eTypeRules_FixedArray
            /* resize allocated array to real size */
            output("if (n != %s) {\n", lenref);
            output("if (!(%s = (%s *)ASN1DecRealloc(%s, %s, %s * sizeof(%s))))\n",
                valref, GetTypeName(ass, info->SubType), encref,
                valref, lenref, Dereference(valref));
            output("return 0;\n");
            output("}\n");
        #endif // 0
        }
        else
        if (info->Rules & eTypeRules_LinkedListMask)
        {
            /* terminate the list */
            output("*f = NULL;\n");
        }

        /* decode end-of-contents */
        output("if (!ASN1BERDecEndOfContents(%s, dd, di))\n", oldencref2);
        output("return 0;\n");
        break;

    case eBERSTIData_ObjectIdentifier:

        if (info->pPrivateDirectives->fOidArray || g_fOidArray)
        {
            /* decode an object identifier value */
            output("if (!ASN1BERDecObjectIdentifier2(%s, %s, %s))\n",
                encref, tagref, Reference(valref));
        }
        else
        {
            /* decode an object identifier value */
            output("if (!ASN1BERDecObjectIdentifier(%s, %s, %s))\n",
                encref, tagref, Reference(valref));
        }
        output("return 0;\n");
        break;

    case eBERSTIData_ObjectIdEncoded:

        /* decode an encoded object identifier value */
        output("if (!ASN1BERDecEoid(%s, %s, %s))\n",
            encref, tagref, Reference(valref));
        output("return 0;\n");
        break;

    case eBERSTIData_String:

        /* decode a string value */
        if (info->NOctets == 1) {
            p = "Char";
        } else if (info->NOctets == 2) {
            p = "Char16";
        } else if (info->NOctets == 4) {
            p = "Char32";
        } else
            MyAbort();
        output("if (!ASN1BERDec%sString(%s, %s, %s))\n",
            p, encref, tagref, Reference(valref));
        output("return 0;\n");
        break;

    case eBERSTIData_ZeroString:

        /* decode a zero-termianted string value */
        if (info->NOctets == 1) {
            p = "Char";
        } else if (info->NOctets == 2) {
            p = "Char16";
        } else if (info->NOctets == 4) {
            p = "Char32";
        } else
            MyAbort();
        output("if (!ASN1BERDecZero%sString(%s, %s, %s))\n",
            p, encref, tagref, Reference(valref));
        output("return 0;\n");
        break;

    case eBERSTIData_External:

        /* decode an external value */
        output("if (!ASN1BERDecExternal(%s, %s, %s))\n",
            encref, tagref, Reference(valref));
        output("return 0;\n");
        break;

    case eBERSTIData_EmbeddedPdv:

        /* decode an embedded pdv value */
        output("if (!ASN1BERDecEmbeddedPdv(%s, %s, %s))\n",
            encref, tagref, Reference(valref));
        output("return 0;\n");
        break;

    case eBERSTIData_MultibyteString:

        /* decode a multibyte string value */
        if (info->Rules & eTypeRules_LengthPointer)
        {
            output("if (!ASN1BERDecMultibyteString(%s, %s, %s))\n",
                encref, tagref, Reference(valref));
        }
        else
        {
            output("if (!ASN1BERDecZeroMultibyteString(%s, %s, %s))\n",
                encref, tagref, Reference(valref));
        }
        output("return 0;\n");
        break;

    case eBERSTIData_UnrestrictedString:

        /* decode an character string value */
        output("if (!ASN1BERDecCharacterString(%s, %s, %s))\n",
            encref, tagref, Reference(valref));
        output("return 0;\n");
        break;

    case eBERSTIData_GeneralizedTime:

        /* decode a generalized time value */
        output("if (!ASN1BERDecGeneralizedTime(%s, %s, %s))\n",
            encref, tagref, Reference(valref));
        output("return 0;\n");
        break;

    case eBERSTIData_UTCTime:

        /* decode a utc time value */
        output("if (!ASN1BERDecUTCTime(%s, %s, %s))\n",
            encref, tagref, Reference(valref));
        output("return 0;\n");
        break;

    case eBERSTIData_Reference:

        /* call other encoding function for reference types */
        output("if (!ASN1Dec_%s(%s, %s, %s))\n",
            Identifier2C(info->SubIdentifier),
            encref, tagref, Reference(valref));
        output("return 0;\n");
        break;

    case eBERSTIData_Open:

        /* decode an open type value */
        output("if (!ASN1BERDecOpenType%s(%s, %s))\n",
            info->pPrivateDirectives->fNoMemCopy ? "2" : "",
            encref, Reference(valref));
        output("return 0;\n");
        break;

    case eBERSTIData_Boolean:
        if (g_fCaseBasedOptimizer)
        {
            output("if (!ASN1BERDecBool(%s, %s, %s))\n", encref, tagref, Reference(valref));
            output("return 0;\n");
        }
        break;
    }

    /* check length/get eoc for explicit tags */
    GenBERDecTagEnd(DECODER_NAME, STREAM_END_NAME, depth, oldencref);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\asn1\asn1c\geninc.c ===
/* Copyright (C) Boris Nikolaus, Germany, 1996-1997. All rights reserved. */
/* Copyright (C) Microsoft Corporation, 1997-1998. All rights reserved. */

#include "precomp.h"

const ASN1uint32_t c_BitMaskMap[sizeof(ASN1uint32_t) * 8] =
{
#ifdef USE_BIG_ENDIAN
        0x80000000, 0x40000000, 0x20000000, 0x10000000,
        0x08000000, 0x04000000, 0x02000000, 0x01000000,

        0x800000,   0x400000,   0x200000,   0x100000,
        0x080000,   0x040000,   0x020000,   0x010000,

        0x8000,     0x4000,     0x2000,     0x1000,
        0x0800,     0x0400,     0x0200,     0x0100,

        0x80,       0x40,       0x20,       0x10,
        0x08,       0x04,       0x02,       0x01,
#else // little endian 
        0x80,       0x40,       0x20,       0x10,
        0x08,       0x04,       0x02,       0x01,

        0x8000,     0x4000,     0x2000,     0x1000,
        0x0800,     0x0400,     0x0200,     0x0100,

        0x800000,   0x400000,   0x200000,   0x100000,
        0x080000,   0x040000,   0x020000,   0x010000,

        0x80000000, 0x40000000, 0x20000000, 0x10000000,
        0x08000000, 0x04000000, 0x02000000, 0x01000000,
#endif
};

void GenComponents(AssignmentList_t ass, ComponentList_t components,
    char *identifier, char *completeidentifier, int *choiceoffset,
    int *optionaloffset);
void GenType(AssignmentList_t ass, char *identifier, char *completeidentifier,
    Type_t *type, int withmodule, int pointer, int array, int fTypeDef);

void GenEnumeration(AssignmentList_t ass, ComponentList_t components,
    char *identifier, char *completeidentifier, int *choiceoffset,
    int *optionaloffset);

int NotInFunTbl(Assignment_t *a);

unsigned g_cPDUs = 0;

unsigned g_cOptionValueSize = 0;

extern int g_fAllEndians;

/* generate include file */
void
GenInc(AssignmentList_t ass, FILE *finc, char *module)
{
    Assignment_t *a;
    char *identifier;
    int offset, i;
    Type_t *type, *subtype;
    Value_t *value;
    unsigned npdu;
    char *pszPrivateValueName;
    unsigned cOptionValueSizeSave;

    setoutfile(finc);

    module = Identifier2C(module);

    // print verbatim
    PrintVerbatim();

    /* file header */
    output("#ifndef _%s_H_\n", module);
    output("#define _%s_H_\n\n", module);

    switch (g_eEncodingRule)
    {
    case eEncoding_Packed:
        output("#include \"msper.h\"\n");
        break;
    case eEncoding_Basic:
        output("#include \"msber.h\"\n");
        break;
    default:
        ASSERT(0);
        break;
    }
    output("\n");

    for (i = 0; i < g_cGhostFiles; i++)
    {
        StripModuleName(g_aGhostFiles[i].pszFileName, g_aGhostFiles[i].pszFileName);
        strcat(g_aGhostFiles[i].pszFileName, ".h");
        output("#include \"%s\"\n", g_aGhostFiles[i].pszFileName);
    }
    if (g_cGhostFiles)
    {
        output("\n");
    }

    // ghost all the data structures from the ghost asn1 files
    for (a = ass; a; a = a->Next)
    {
        if (a->Type != eAssignment_Type)
            continue;
        type = a->U.Type.Type;
        if (type->Flags & eTypeFlags_Null)
            continue;
        if (!(type->Flags & eTypeFlags_GenType))
            continue;
        if (a->Module && a->Module->Identifier)
        {
            for (i = 0; i < g_cGhostFiles; i++)
            {
                if (! strcmp(a->Module->Identifier, g_aGhostFiles[i].pszModuleName))
                {
                    a->fGhost = 1;
                    break;
                }
            }
        }
    }

    /* language dependent interface */
    switch (g_eProgramLanguage) {
    case eLanguage_C:
        // output("#include \"cinterf.h\"\n\n");
        output("#ifdef __cplusplus\n");
        outputni("extern \"C\" {\n");
        output("#endif\n\n");
        break;
    case eLanguage_Cpp:
        // output("#include \"cppinterf.h\"\n\n");
        // break;
    default:
        ASSERT(0);
        break;
    }

    /* create endian independent macros */
    if (g_fAllEndians)
    {
        output("#ifdef ASN1_BIG_ENDIAN\n");
        output("#define ASN1_LITE_TO_BIGE_16(n16)    ((((n16) & 0xFF) << 8)  | (((n16) & 0xFF00) >> 8))\n");
        output("#define ASN1_LITE_TO_BIGE_32(n32)    ((((n32) & 0xFF) << 24) | (((n32) & 0xFF00) << 8)) | (((n32) & 0xFF0000) >> 8) | (((n32) & 0xFF000000) >> 24)\n");
        output("#define ASN1_ENDIAN_16(n16)         ASN1_LITE_TO_BIGE_16(n16)\n");
        output("#define ASN1_ENDIAN_32(n32)         ASN1_LITE_TO_BIGE_32(n32)\n");
        output("#else\n");
        output("#define ASN1_ENDIAN_16(n16)         (n16)\n");
        output("#define ASN1_ENDIAN_32(n32)         (n32)\n");
        output("#endif // ASN1_BIG_ENDIAN\n\n");
    }

    /* typedefs for sequence of/set of with list representation */
    npdu = 0;
    for (a = ass; a; a = a->Next) {
        if (a->Type != eAssignment_Type)
            continue;
        type = a->U.Type.Type;
        if (type->Flags & eTypeFlags_Null)
            continue;
        if (!(type->Flags & eTypeFlags_GenType))
            continue;
        if (a->fGhost)
            continue;
        identifier = GetName(a);
        switch (type->Type) {
        case eType_SequenceOf:
        case eType_SetOf:
            if (GetTypeRules(ass, type) & (eTypeRules_LinkedListMask | eTypeRules_PointerToElement))
            {
                if (g_fExtraStructPtrTypeSS)
                {
                    output("typedef struct %s_s * P%s;\n",
                        identifier, identifier);
                }
                else
                {
                    output("typedef struct %s * P%s;\n",
                        identifier, identifier);
                }
                output("\n");
            }
            break;
        default:
            break;
        }
    }

    /* other type definitions */
    for (a = ass; a; a = a->Next) {
        if (a->Type != eAssignment_Type)
            continue;
        type = a->U.Type.Type;

        /* skip null type */
        if (type->Flags & eTypeFlags_Null)
        {
                if (type->Type == eType_Sequence)
                {
                        identifier = GetName(a);
                        output("typedef struct %s {\n", identifier);
                        output("char placeholder;\n");
                        output("} %s;\n\n", identifier);
                }
                continue;
        }

        /* type definition wanted? */
        if (!(type->Flags & eTypeFlags_GenType))
            continue;

        if ((! g_fLongNameForImported) && a->fImportedLocalDuplicate)
            continue;

        if (a->fGhost)
            continue;

        /* assign an id number to the type */
        identifier = GetName(a);

        /* write type definitions */
        switch (type->Type) {
        case eType_Sequence:
        case eType_Set:
        case eType_InstanceOf:

            // save
            cOptionValueSizeSave = g_cOptionValueSize;

            // generate scope-free enumeration
            offset = 0;
            GenEnumeration(ass, type->U.SSC.Components, identifier, identifier, NULL, &offset);

            /* use struct for sequence/set/instanceof type */
            /* add a bit field for optional components */
            output("typedef struct %s {\n", identifier);
            if (type->U.SSC.Optionals || type->U.SSC.Extensions) {
                int cOctets = (type->U.SSC.Optionals + 7) / 8 +
                              (type->U.SSC.Extensions + 7) / 8;
                g_cOptionValueSize = (cOctets <= 2) ? 16 : 32;
                output("union {\nASN1uint%u_t %s;\nASN1octet_t o[%d];\n};\n",
                    g_cOptionValueSize, g_pszOptionValue, cOctets);
            }
            offset = 0;
            GenComponents(ass, type->U.SSC.Components,
                identifier, identifier, NULL, &offset);
            output("} %s;\n", identifier);

            // restore
            g_cOptionValueSize = cOptionValueSizeSave;
            break;

        case eType_Choice:

            // generate scope-free enumeration
            offset = 0;
            GenEnumeration(ass, type->U.SSC.Components, identifier, identifier, NULL, &offset);

            /* use a struct of an selector and a union for choice type */
            output("typedef struct %s {\n", identifier);
            // output("%s o;\n", GetChoiceType(type));
            output("ASN1choice_t choice;\n");
            if (!(type->Flags & eTypeFlags_NullChoice))
                output("union {\n");
            offset = ASN1_CHOICE_BASE;
            GenComponents(ass, type->U.Choice.Components,
                identifier, identifier, &offset, NULL);
            if (!(type->Flags & eTypeFlags_NullChoice))
                output("} u;\n");
            output("} %s;\n", identifier);
            break;

        case eType_SequenceOf:
        case eType_SetOf:

            //
            // LONCHANC: The following two lines of code do not apply to
            // SEQUENCE OF and SET OF.
            //
            // generate scope-free enumeration
            // offset = 0;
            // GenEnumeration(ass, type->U.SSC.Components, identifier, identifier, NULL, &offset);

            /* use a struct of length+values for sequence of/set of with */
            /* length-pointer representation */
            /* use a struct of next+value for sequence of/set of with */
            /* singly-linked-list representation */
            /* use a struct of next+prev+value for sequence of/set of with */
            /* doubly-linked-list representation */
            subtype = type->U.SS.Type;
            if (g_fExtraStructPtrTypeSS &&
                (type->Rules & (eTypeRules_LinkedListMask | eTypeRules_PointerToElement)))
            {
                output("typedef struct %s_s {\n", identifier);
            }
            else
            {
                output("typedef struct %s {\n", identifier);
            }
            // fix (xyz..MAX) problem.
            if (type->Rules == eTypeRules_FixedArray && type->PERTypeInfo.Root.LUpperVal == 0)
            {
                type->Rules &= ~ eTypeRules_FixedArray;
                type->Rules |= g_eDefTypeRuleSS_NonSized;
                type->PERTypeInfo.Rules &= ~ eTypeRules_FixedArray;
                type->PERTypeInfo.Rules |= g_eDefTypeRuleSS_NonSized;
                type->BERTypeInfo.Rules &= ~ eTypeRules_FixedArray;
                type->BERTypeInfo.Rules |= g_eDefTypeRuleSS_NonSized;
            }
            pszPrivateValueName = GetPrivateValueName(&type->PrivateDirectives, "value");
            if (type->Rules & eTypeRules_FixedArray)
            {
                output("ASN1uint32_t count;\n");
                GenType(ass, pszPrivateValueName, pszPrivateValueName, subtype,
                    0, 0, type->PERTypeInfo.Root.LUpperVal, 0);
            }
            else
            if (type->Rules & eTypeRules_LengthPointer)
            {
                output("ASN1uint32_t count;\n");
                GenType(ass, pszPrivateValueName, pszPrivateValueName, subtype,
                    0, 1, 0, 0);
            }
            else
            if (type->Rules & eTypeRules_DoublyLinkedList)
            {
                output("P%s next;\n", identifier);
                output("P%s prev;\n", identifier);
                GenType(ass, pszPrivateValueName, pszPrivateValueName, subtype,
                    0, 0, 0, 0);
            }
            else
            if (type->Rules & eTypeRules_SinglyLinkedList)
            {
                output("P%s next;\n", identifier);
                GenType(ass, pszPrivateValueName, pszPrivateValueName, subtype,
                    0, 0, 0, 0);
            }
            else
            {
                MyAbort();
            }
            if (type->Rules & eTypeRules_LinkedListMask)
            {
                if (g_fExtraStructPtrTypeSS)
                {
                    output("} %s_Element, *%s;\n", identifier, identifier);
                }
                else
                {
                    output("} %s_Element;\n", identifier);
                }
            } else {
                output("} %s;\n", identifier);
            }
            break;

        default:

            /* use the builtin type for other types */
            output("typedef ");
            GenType(ass, a->Identifier, identifier, type, 1, 0, 0, 1);
            break;
        }

        if (! NotInFunTbl(a))
        {
            output("#define %s_%s %u\n", identifier, g_pszApiPostfix, npdu);
            switch (type->Type)
            {
            case eType_SequenceOf:
            case eType_SetOf:
                if (type->Rules & eTypeRules_LinkedListMask)
                {
                    output("#define SIZE_%s_%s_%u sizeof(%s_Element)\n", module, g_pszApiPostfix, npdu, identifier);
                    break;
                }
                // intentionally fall through
            default:
                output("#define SIZE_%s_%s_%u sizeof(%s)\n", module, g_pszApiPostfix, npdu, identifier);
                break;
            }
            npdu++;
        }

        output("\n");
    }

    /* write extern declarations for values */
    for (a = ass; a; a = a->Next)
    {
        if (a->Type != eAssignment_Value)
            continue;

        /* extern value wanted? */
        if (!(a->U.Value.Value->Flags & eValueFlags_GenExternValue))
            continue;
        value = GetValue(ass, a->U.Value.Value);

        /* skip value of null type */
        if (value->Type->Flags & eTypeFlags_Null)
            continue;

        /* output an extern declaration */
        switch (value->Type->Type)
        {
        case eType_ObjectIdentifier:
            if (value->Type->PrivateDirectives.fOidPacked)
            {
                output("extern ASN1encodedOID_t %s;\n", GetName(a));
                break;
            }
            else
            if (value->Type->PrivateDirectives.fOidArray || g_fOidArray)
            {
                output("extern ASN1objectidentifier2_t %s;\n", GetName(a));
                break;
            }
            // intentionally fall through
        default:
            output("extern %s %s;\n", GetTypeName(ass, value->Type), GetName(a));
            break;
        }
    }
    output("\n");

    /* write vars, functions and macros for the interface */
    output("extern ASN1module_t %s;\n", module);
    output("extern void ASN1CALL %s_Startup(void);\n", module);
    output("extern void ASN1CALL %s_Cleanup(void);\n", module);
    output("\n");

    output("/* Prototypes of element functions for SEQUENCE OF and SET OF constructs */\n");

    g_cPDUs = npdu;
}

/* generate a type */
void
GenType(AssignmentList_t ass, char *identifier, char *completeidentifier, Type_t *type, int withmodule, int pointer, int array, int fTypeDef)
{
    char *ptr, *pszOldEnumName;
    NamedNumber_t *namedNumbers;
        char arr[20];
    char modide[256];

    /* skip null type */
    // if (type->Flags & eTypeFlags_Null)
        // return;

    /* get type name */
    ptr = pointer ? "*" : "";
    if (array)
        sprintf(arr, "[%u]", array);
    else
        arr[0] = '\0';
    identifier = Identifier2C(identifier);
    if (withmodule)
        sprintf(modide, "%s%s%s", ptr, completeidentifier, arr);
    else
        sprintf(modide, "%s%s%s", ptr, identifier, arr);

    /* output type declaration */
    switch (type->Type) {
    case eType_Reference:

        /* use struct ..._s syntax for pointer to structured type */
        if (pointer && IsStructuredType(GetReferencedType(ass, type))) {
            output("struct %s %s;\n", GetTypeName(ass, type), modide);
        } else {
            char *psz = PGetTypeName(ass, type);
            char *psz2 = (0 == strcmp(psz, modide)) ? "_dont_care" : "";
            output("%s %s%s;\n", psz, modide, psz2);
        }
        break;

    case eType_OctetString:
        if (g_eEncodingRule == eEncoding_Packed)
        {
            if (type->PERTypeInfo.Root.LConstraint == ePERSTIConstraint_Constrained &&
                (! type->PrivateDirectives.fLenPtr))
            {
                if (strcmp(completeidentifier, modide) == 0)
                {
                    output("struct %s {\nASN1uint32_t length;\nASN1octet_t value[%u];\n} %s;\n",
                        modide, type->PERTypeInfo.Root.LUpperVal, modide);
                }
                else
                {
                    output("struct %s_%s {\nASN1uint32_t length;\nASN1octet_t value[%u];\n} %s;\n",
                        completeidentifier, modide, type->PERTypeInfo.Root.LUpperVal, modide);
                }
            }
            else
            {
                char *psz = GetTypeName(ass, type);
                char *psz2 = (0 == strcmp(psz, modide)) ? "_dont_care" : "";
                output("%s %s%s;\n", psz, modide, psz2);
            }
        }
        else
        {
            // only support unbounded in BER
            char *psz = GetTypeName(ass, type);
            char *psz2 = (0 == strcmp(psz, modide)) ? "_dont_care" : "";
            output("%s %s%s;\n", psz, modide, psz2);
        }
        break;

    case eType_UTF8String:
        {
            char *psz = GetTypeName(ass, type);
            char *psz2 = (0 == strcmp(psz, modide)) ? "_dont_care" : "";
            output("%s %s%s;\n", psz, modide, psz2);
        }
        break;

    case eType_InstanceOf:
    case eType_SequenceOf:
    case eType_SetOf:

    case eType_Boolean:
    case eType_Real:
    case eType_Sequence:
    case eType_Set:
    case eType_Choice:
    case eType_External:
    case eType_ObjectIdentifier:
    case eType_ObjectDescriptor:
    case eType_BMPString:
    case eType_UniversalString:
    case eType_GeneralizedTime:
    case eType_UTCTime:
    case eType_EmbeddedPdv:
    case eType_Open:

        /* use struct ..._s syntax for pointer to structured type */
        if (pointer && IsStructuredType(type)) {
            output("struct %s %s;\n", GetTypeName(ass, type), modide);
        } else {
            char *psz = GetTypeName(ass, type);
            char *psz2 = (0 == strcmp(psz, modide)) ? "_dont_care" : "";
            output("%s %s%s;\n", psz, modide, psz2);
        }
        break;

    case eType_NumericString:
    case eType_PrintableString:
    case eType_VisibleString:
    case eType_ISO646String:
    case eType_GraphicString:
    case eType_GeneralString:
    case eType_VideotexString:
    case eType_IA5String:
    case eType_T61String:
    case eType_TeletexString:
    case eType_CharacterString:
#ifdef ENABLE_CHAR_STR_SIZE
    {
        char *psz = GetTypeName(ass, type);
        if (g_eEncodingRule == eEncoding_Packed &&
            type->PERTypeInfo.Root.LConstraint == ePERSTIConstraint_Constrained &&
            strcmp(psz, "ASN1char_t") == 0)
        {
            char *psz2 = (0 == strcmp(psz, modide)) ? "_dont_care" : "";
            output("%s %s%s[%u];\n", psz, modide, psz2, type->PERTypeInfo.Root.LUpperVal + 1);
        }
        else
        {
            char *psz2 = (0 == strcmp(psz, modide)) ? "_dont_care" : "";
            output("%s %s%s;\n", psz, modide, psz2);
        }
    }
#else
    {
        char *psz = GetTypeName(ass, type);
        char *psz2 = (0 == strcmp(psz, modide)) ? "_dont_care" : "";
        output("%s %s%s;\n", psz, modide, psz2);
    }
#endif
        break;

    case eType_Enumerated:

        /* use name of the type */
    if (fTypeDef)
    {
        if (type->PrivateDirectives.pszTypeName)
        {
            output("enum %s {\n", type->PrivateDirectives.pszTypeName);
            pszOldEnumName = type->PrivateDirectives.pszTypeName;
        }
        else
        {
                output("enum %s {\n", modide);
            pszOldEnumName = "";
        }

            /* dump named numbers */
            namedNumbers = type->U.IEB.NamedNumbers;
            while (namedNumbers) {
                switch (namedNumbers->Type) {
                case eNamedNumber_Normal:
                    if (intxisuint32(&GetValue(ass,
                        namedNumbers->U.Normal.Value)->U.Integer.Value)) {
                        char *psz = Identifier2C(namedNumbers->U.Normal.Identifier);
                        if (IsReservedWord(psz) || DoesEnumNameConflict(psz))
                        {
                    output("%s_%s = %u,\n", *pszOldEnumName ? pszOldEnumName : modide, psz,
                                intx2uint32(&GetValue(ass,
                                namedNumbers->U.Normal.Value)->U.Integer.Value));
                        }
                        else
                        {
                            output("%s = %u,\n", psz,
                                intx2uint32(&GetValue(ass,
                                namedNumbers->U.Normal.Value)->U.Integer.Value));
                }
                    } else if (intxisint32(&GetValue(ass,
                        namedNumbers->U.Normal.Value)->U.Integer.Value)) {
                        char *psz = Identifier2C(namedNumbers->U.Normal.Identifier);
                        if (IsReservedWord(psz) || DoesEnumNameConflict(psz))
                        {
                            output("%s_%s = %d,\n", *pszOldEnumName ? pszOldEnumName : modide, psz,
                                intx2uint32(&GetValue(ass,
                                namedNumbers->U.Normal.Value)->U.Integer.Value));
                }
                else
                {
                            output("%s = %d,\n", psz,
                                intx2uint32(&GetValue(ass,
                                namedNumbers->U.Normal.Value)->U.Integer.Value));
                    }
                    }
                    break;
                case eNamedNumber_ExtensionMarker:
                    break;
                }
                namedNumbers = namedNumbers->Next;
            }

            output("} %s;\n", type->PrivateDirectives.pszTypeName ? type->PrivateDirectives.pszTypeName : modide);
    }
    else
    {
        if (type->PrivateDirectives.pszTypeName)
        {
            pszOldEnumName = type->PrivateDirectives.pszTypeName;
        }
        else
        {
            pszOldEnumName = modide;
        }

        output("%s %s;\n", pszOldEnumName, modide);
    }
    break;

    case eType_Integer:

        /* use name of the type */
        {
            char *psz = GetTypeName(ass, type);
            char *psz2 = (0 == strcmp(psz, modide)) ? "_dont_care" : "";
            output("%s %s%s;\n", psz, modide, psz2);
        }

        /* dump named numbers */
        namedNumbers = type->U.IEB.NamedNumbers;
        while (namedNumbers) {
            switch (namedNumbers->Type) {
            case eNamedNumber_Normal:
                if (intxisuint32(&GetValue(ass,
                    namedNumbers->U.Normal.Value)->U.Integer.Value)) {
                    output("#define %s_%s %u\n", completeidentifier,
                        Identifier2C(namedNumbers->U.Normal.Identifier),
                        intx2uint32(&GetValue(ass,
                        namedNumbers->U.Normal.Value)->U.Integer.Value));
                } else if (intxisint32(&GetValue(ass,
                    namedNumbers->U.Normal.Value)->U.Integer.Value)) {
                    output("#define %s_%s %d\n", completeidentifier,
                        Identifier2C(namedNumbers->U.Normal.Identifier),
                        intx2uint32(&GetValue(ass,
                        namedNumbers->U.Normal.Value)->U.Integer.Value));
                }
                break;
            case eNamedNumber_ExtensionMarker:
                break;
            }
            namedNumbers = namedNumbers->Next;
        }
        break;

    case eType_BitString: // lonchanc: split from eType_Integer

        /* use name of the type */
        if (g_eEncodingRule == eEncoding_Packed)
        {
            if (type->PERTypeInfo.Root.cbFixedSizeBitString)
            {
                output("ASN1uint%u_t %s;\n",
                    type->PERTypeInfo.Root.cbFixedSizeBitString * 8, modide);
            }
            else
            {
                char *psz = GetTypeName(ass, type);
                char *psz2 = (0 == strcmp(psz, modide)) ? "_dont_care" : "";
                output("%s %s%s;\n", psz, modide, psz2);
            }
        }
        else
        {
            // only support unbounded in BER
            char *psz = GetTypeName(ass, type);
            char *psz2 = (0 == strcmp(psz, modide)) ? "_dont_care" : "";
            output("%s %s%s;\n", psz, modide, psz2);
        }

        /* dump named numbers */
        namedNumbers = type->U.IEB.NamedNumbers;
        while (namedNumbers) {
            switch (namedNumbers->Type) {
            case eNamedNumber_Normal:
                if (intxisuint32(&GetValue(ass,
                    namedNumbers->U.Normal.Value)->U.Integer.Value)) {
                    char *psz = Identifier2C(namedNumbers->U.Normal.Identifier);
                    ASN1uint32_t idx = intx2uint32(&GetValue(ass,
                                namedNumbers->U.Normal.Value)->U.Integer.Value);
                    if (IsReservedWord(psz) || DoesEnumNameConflict(psz))
                    {
                        output("#define %s_%s 0x%lx\n", completeidentifier,
                                psz, c_BitMaskMap[idx]);
                    }
                    else
                    {
                        output("#define %s 0x%lx\n", psz, c_BitMaskMap[idx]);
                    }
                } else if (intxisint32(&GetValue(ass,
                    namedNumbers->U.Normal.Value)->U.Integer.Value)) {
                    char *psz = Identifier2C(namedNumbers->U.Normal.Identifier);
                    ASN1uint32_t idx = intx2uint32(&GetValue(ass,
                                namedNumbers->U.Normal.Value)->U.Integer.Value);
                    if (IsReservedWord(psz) || DoesEnumNameConflict(psz))
                    {
                        output("#define %s_%s 0x%lx\n", completeidentifier,
                                psz, c_BitMaskMap[idx]);
                    }
                    else
                    {
                        output("#define %s 0x%lx\n", psz, c_BitMaskMap[idx]);
                    }
                }
                break;
            case eNamedNumber_ExtensionMarker:
                break;
            }
            namedNumbers = namedNumbers->Next;
        }
        break;

    case eType_Null:
        break;

    case eType_Undefined:
        MyAbort();
        /*NOTREACHED*/
    }
}

/* write declarations for components */
void
GenComponents(AssignmentList_t ass, ComponentList_t components, char *identifier, char *completeidentifier, int *choiceoffset, int *optionaloffset)
{
    NamedType_t *namedType;
    int extended = 0;
    char cidebuf[256];

    /* add dummy for empty components */
    if (components && !components->Next &&
        components->Type == eComponent_ExtensionMarker) {
        output("char placeholder;\n");
        return;
    }

    /* write a declaration for every component */
    for (; components; components = components->Next) {
        switch (components->Type) {
        case eComponent_Normal:
        case eComponent_Optional:
        case eComponent_Default:
            /* write a selector for optional/default components */
            namedType = components->U.NOD.NamedType;
            if ((extended && optionaloffset) ||
                components->Type == eComponent_Optional ||
                components->Type == eComponent_Default)
           {
                char *psz;
                // construct the option value
                char szOptionValue[64];
                if (g_fAllEndians)
                {
                    sprintf(szOptionValue, "ASN1_ENDIAN_%u(0x%lx)", g_cOptionValueSize, c_BitMaskMap[*optionaloffset]);
                }
                else
                {
                    sprintf(szOptionValue, "0x%lx", c_BitMaskMap[*optionaloffset]);
                }

                psz = Identifier2C(namedType->Identifier);
                if (IsReservedWord(psz) || DoesOptNameConflict(psz))
                // lonchanc: do we always put in _preset definition after extended mark???
                // yes, we do. take an example of Setup-UUIE in q931asn.asn.
                // but, the extension mark does not have option-flag definition associated.
                // || (extended && optionaloffset))
                {
                    output("#define %s_%s_%s %s\n",
                        identifier, psz, g_pszOptionPostfix,
                        &szOptionValue[0]);
                }
                else
                {
                    output("#define %s_%s %s\n",
                        psz, g_pszOptionPostfix,
                        &szOptionValue[0]);
                }
                (*optionaloffset)++;
            }
            /* write a selector for choice alternatives */
            if (choiceoffset)
            {
                char *psz = Identifier2C(namedType->Identifier);
                if (IsReservedWord(psz) || DoesChoiceNameConflict(psz))
                {
                    output("#define %s_%s_%s %d\n",
                        identifier, psz, g_pszChoicePostfix,
                        *choiceoffset);
                }
                else
                {
                    output("#define %s_%s %d\n",
                        psz, g_pszChoicePostfix,
                        *choiceoffset);
                }
                (*choiceoffset)++;
            }            
            /* write the declaration itself */
            sprintf(cidebuf, "%s_%s", completeidentifier,
                Identifier2C(namedType->Identifier));
            GenType(ass, namedType->Identifier, cidebuf, namedType->Type,
                0, GetTypeRules(ass, namedType->Type) & eTypeRules_Pointer, 0, 0);
            break;

        case eComponent_ExtensionMarker:

            /* update the offset when an extension marker is met for a */
            /* sequence/set type */
            extended = 1;
            // lonchanc: however, the code generated by TELES handles this properly.
            // moreover, the code requires it to be rounded up.
            // as a result, we should enable this feature.
            if (optionaloffset)
                *optionaloffset = (*optionaloffset + 7) & ~7;
            break;
        }
    }
}

// The following is added by Microsoft

/* write enumerations for components */
void
GenEnumeration(AssignmentList_t ass, ComponentList_t components, char *identifier, char *completeidentifier, int *choiceoffset, int *optionaloffset)
{
    NamedType_t *namedType;
    int extended = 0;
    char cidebuf[256];

    /* write a declaration for every component */
    for (; components; components = components->Next)
    {
        switch (components->Type)
        {
        case eComponent_Normal:
        case eComponent_Optional:
        case eComponent_Default:
            namedType = components->U.NOD.NamedType;
            if (namedType && namedType->Type && namedType->Type->Type == eType_Enumerated)
            {
                output("typedef ");
                /* write the declaration itself */
                sprintf(cidebuf, "%s_%s", completeidentifier,
                    Identifier2C(namedType->Identifier));
                    GenType(ass, namedType->Identifier, cidebuf, namedType->Type,
                    0, GetTypeRules(ass, namedType->Type) & eTypeRules_Pointer, 0, 1);
            }
        break;
        }
    }   
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\asn1\asn1c\hackdir.h ===
/* Copyright (C) Boris Nikolaus, Germany, 1996-1997. All rights reserved. */
/* Copyright (C) Microsoft Corporation, 1997-1998. All rights reserved. */

#ifdef MS_DIRECTIVE

extern int g_fPrivateDir_FieldNameToken;
extern int g_fPrivateDir_TypeNameToken;
extern int g_fPrivateDir_ValueNameToken;

extern int g_fPrivateDir_SLinked;
extern int g_fPrivateDir_DLinked;
extern int g_fPrivateDir_Public;
extern int g_fPrivateDir_Intx;
extern int g_fPrivateDir_LenPtr;
extern int g_fPrivateDir_Pointer;
extern int g_fPrivateDir_Array;
extern int g_fPrivateDir_NoMemCopy;
extern int g_fPrivateDir_NoCode;
extern int g_fPrivateDir_OidPacked;
extern int g_fPrivateDir_OidArray;

extern char g_szPrivateDirectedFieldName[64];
extern char g_szPrivateDirectedTypeName[64];
extern char g_szPrivateDirectedValueName[64];

extern int PrivateDirectives_Input ( void );
extern void GetPrivateDirective ( int *p );

#endif // MS_DIRECTIVE
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\asn1\asn1c\genprg.c ===
/* Copyright (C) Boris Nikolaus, Germany, 1996-1997. All rights reserved. */
/* Copyright (C) Microsoft Corporation, 1997-1998. All rights reserved. */

#include "precomp.h"
#include "optcase.h"

void GenFuncType(AssignmentList_t ass, char *module, Assignment_t *at, TypeFunc_e et);
void GenFuncComponents(AssignmentList_t ass, char *module, Type_t *type, char *ideref, uint32_t optindex, ComponentList_t components, char *valref1, char *valref2, TypeFunc_e et, int inextension, int inchoice);
void GenFuncSequenceSetType(AssignmentList_t ass, char *module, Assignment_t *at, char *valref1, char *valref2, TypeFunc_e et);
void GenFuncChoiceType(AssignmentList_t ass, char *module, Assignment_t *at, char *valref1, char *valref2, TypeFunc_e et);
void GenFuncSimpleType(AssignmentList_t ass, Type_t *type, char *ideref, char *valref1, char *valref2, TypeFunc_e et);
void GenFreeSimpleType(AssignmentList_t ass, Type_t *type, char *ideref, char *valref);
void GenCompareSimpleType(AssignmentList_t ass, Type_t *type, char *ideref, char *valref1, char *valref2);
void GenCompareExpression(AssignmentList_t ass, Type_t *type, char *ideref, char *valref1, char *valref2);
void GenFuncValue(AssignmentList_t ass, Assignment_t *at, ValueFunc_e cod);
void GenDeclGeneric(AssignmentList_t ass, char *ideref, char *typeref, Value_t *value, Type_t *t);
void GenDefhGeneric(AssignmentList_t ass, char *ideref, char *typeref, Value_t *value, Type_t *t);
void GenDefnGeneric(AssignmentList_t ass, char *ideref, char *typeref, Value_t *value, Type_t *t);
void GenInitGeneric(AssignmentList_t ass, char *ideref, char *typeref, Value_t *value, Type_t *t);
extern unsigned g_cPDUs;
extern char *g_pszOrigModuleNameLowerCase;
extern int g_fLongNameForImported;
extern int g_fNoAssert;
extern int g_fCaseBasedOptimizer;

extern uint32_t Tag2uint32(AssignmentList_t ass, Tag_t *tag);

int NotInFunTbl(Assignment_t *a)
{
    if (a->Type != eAssignment_Type)
    {
        return 1;
    }

    if (a->U.Type.Type->PrivateDirectives.fPublic)
    {
        return 0;
    }

    return ((a->U.Type.Type->Flags & eTypeFlags_Null) ||
            !(a->U.Type.Type->Flags & eTypeFlags_GenType) ||
            !(a->U.Type.Type->Flags & eTypeFlags_GenPdu) ||
            (a->U.Type.Type->Flags & eTypeFlags_MiddlePDU));
}

/* generate c file */
void
GenPrg(AssignmentList_t ass, FILE *fout, char *module, char *incfilename)
{
    Assignment_t *a;
    TypeFunc_e et;
    ValueFunc_e ev;
    Arguments_t args;
    unsigned i;
    char *pszFunParam;
    char *identifier;
    char funcbuf[256];

    setoutfile(fout);

    // print verbatim
    PrintVerbatim();

    /* file header */
    output("#include <windows.h>\n");
    output("#include \"%s\"\n", incfilename);
    switch (g_eEncodingRule) {
    case eEncoding_Packed:
        GenPERHeader();
        GetPERPrototype(&args);
        pszFunParam = "x,y";
        break;
    case eEncoding_Basic:
        GenBERHeader();
        GetBERPrototype(&args);
        pszFunParam = "x,y,z";
        break;
    default:
        MyAbort();
    }

    output("\n");

    output("ASN1module_t %s = NULL;\n", module);
    output("\n");

    /* write function prototypes */
    for (et = eStringTable; et <= eCopy; et++)
    {
        for (a = ass; a; a = a->Next)
        {
            if (a->Type != eAssignment_Type)
                continue;
            if ((! g_fLongNameForImported) && a->fImportedLocalDuplicate)
                continue;
            if (a->U.Type.Type->PrivateDirectives.fPublic)
            {
                a->U.Type.Type->Flags |= eTypeFlags_GenEncode;
                a->U.Type.Type->Flags |= eTypeFlags_GenDecode;
                a->U.Type.Type->Flags |= eTypeFlags_GenFree;
                a->U.Type.Type->Flags |= eTypeFlags_GenCompare;
            }
            else
            {
                if ((GetType(ass, a->U.Type.Type)->Flags & eTypeFlags_Null) ||
                    !(a->U.Type.Type->Flags & eTypeFlags_GenType) ||
                    !(a->U.Type.Type->Flags & eTypeFlags_GenPdu))
                    continue;
            }
            switch (et)
            {
            case eStringTable:
                continue;
            case eEncode:
                if (!(a->U.Type.Type->Flags & eTypeFlags_GenEncode))
                    continue;
                identifier = GetName(a);
                sprintf(funcbuf, IsPSetOfType(ass, a) ? args.Pencfunc : args.encfunc, identifier);
                if (a->U.Type.Type->PrivateDirectives.fNoCode)
                {
                    output("#define ASN1Enc_%s(%s)      0\n", identifier, pszFunParam);
                }
                else
                {
                    output("static int ASN1CALL ASN1Enc_%s(%s);\n", identifier, funcbuf);
                }
                break;
            case eDecode:
                if (!(a->U.Type.Type->Flags & eTypeFlags_GenDecode))
                    continue;
                identifier = GetName(a);
                sprintf(funcbuf, IsPSetOfType(ass, a) ? args.Pdecfunc : args.decfunc, identifier);
                if (a->U.Type.Type->PrivateDirectives.fNoCode)
                {
                    output("#define ASN1Dec_%s(%s)      0\n", identifier, pszFunParam);
                }
                else
                {
                    output("static int ASN1CALL ASN1Dec_%s(%s);\n", identifier, funcbuf);
                }
                break;
            case eCheck:
                continue;
            case ePrint:
                continue;
            case eFree:
                if (!(a->U.Type.Type->Flags & eTypeFlags_GenFree) ||
                    (a->U.Type.Type->Flags & eTypeFlags_Simple))
                    continue;
                identifier = GetName(a);
                sprintf(funcbuf, IsPSetOfType(ass, a) ? args.Pfreefunc : args.freefunc, identifier);
                if (a->U.Type.Type->PrivateDirectives.fNoCode)
                {
                    output("#define ASN1Free_%s(x)     \n", identifier);
                }
                else
                {
                    output("static void ASN1CALL ASN1Free_%s(%s);\n", identifier, funcbuf);
                }
                break;
#ifdef ENABLE_COMPARE
            case eCompare:
                if (!(a->U.Type.Type->Flags & eTypeFlags_GenCompare))
                    continue;
                identifier = GetName(a);
                sprintf(funcbuf, IsPSetOfType(ass, a) ? args.Pcmpfun : args.cmpfunc, identifier, identifier);
                if (a->U.Type.Type->PrivateDirectives.fNoCode)
                {
                    output("#define ASN1Compare_%s(x,y)      0\n", identifier);
                }
                else
                {
                    output("static int ASN1CALL ASN1Compare_%s(%s);\n", identifier, funcbuf);
                }
                break;
#endif // ENABLE_COMPARE
            case eCopy:
                continue;
            }
        }
    }
    output("\n");

    /* write a table containing the encode function addresses */
    switch (g_eEncodingRule)
    {
    case eEncoding_Packed:
        output("typedef ASN1PerEncFun_t ASN1EncFun_t;\n");
        break;
    case eEncoding_Basic:
        output("typedef ASN1BerEncFun_t ASN1EncFun_t;\n");
        break;
    default:
        output("typedef int (ASN1CALL *ASN1EncFun_t)(%s);\n", args.enccast);
        break;
    }
    output("static const ASN1EncFun_t encfntab[%u] = {\n", g_cPDUs);
    for (a = ass; a; a = a->Next) {
        if ((! g_fLongNameForImported) && a->fImportedLocalDuplicate)
           continue;
        if (NotInFunTbl(a))
            continue;
        if (!(a->U.Type.Type->Flags & eTypeFlags_GenEncode)) {
            ASSERT(0);
            output("(ASN1EncFun_t) NULL,\n");
            continue;
        }
        output("(ASN1EncFun_t) ASN1Enc_%s,\n", GetName(a));
    }
    output("};\n");

    /* write a table containing the decode function addresses */
    switch (g_eEncodingRule)
    {
    case eEncoding_Packed:
        output("typedef ASN1PerDecFun_t ASN1DecFun_t;\n");
        break;
    case eEncoding_Basic:
        output("typedef ASN1BerDecFun_t ASN1DecFun_t;\n");
        break;
    default:
        output("typedef int (ASN1CALL *ASN1DecFun_t)(%s);\n", args.deccast);
        break;
    }
    output("static const ASN1DecFun_t decfntab[%u] = {\n", g_cPDUs);
    for (a = ass; a; a = a->Next)
    {
        if ((! g_fLongNameForImported) && a->fImportedLocalDuplicate)
           continue;
        if (NotInFunTbl(a))
            continue;
        if (!(a->U.Type.Type->Flags & eTypeFlags_GenDecode))
        {
            ASSERT(0);
            output("(ASN1DecFun_t) NULL,\n");
            continue;
        }
        output("(ASN1DecFun_t) ASN1Dec_%s,\n", GetName(a));
    }
    output("};\n");

    /* write a table containing the free function addresses */
    output("static const ASN1FreeFun_t freefntab[%u] = {\n", g_cPDUs);
    for (a = ass; a; a = a->Next)
    {
        if ((! g_fLongNameForImported) && a->fImportedLocalDuplicate)
           continue;
        if (NotInFunTbl(a))
            continue;
        if (!(a->U.Type.Type->Flags & eTypeFlags_GenFree) ||
            (a->U.Type.Type->Flags & eTypeFlags_Simple))
        {
            output("(ASN1FreeFun_t) NULL,\n");
            continue;
        }
        output("(ASN1FreeFun_t) ASN1Free_%s,\n", GetName(a));
    }
    output("};\n");

#ifdef ENABLE_COMPARE
    /* write a table containing the compare function addresses */
    output("typedef int (ASN1CALL *ASN1CmpFun_t)(%s);\n", args.cmpcast);
    output("static const ASN1CmpFun_t cmpfntab[%u] = {\n", g_cPDUs);
    for (a = ass; a; a = a->Next)
    {
        if ((! g_fLongNameForImported) && a->fImportedLocalDuplicate)
           continue;
        if (NotInFunTbl(a))
            continue;
        if (!(a->U.Type.Type->Flags & eTypeFlags_GenCompare))
        {
            ASSERT(0);
            output("(ASN1CmpFun_t) NULL,\n");
            continue;
        }
        output("(ASN1CmpFun_t) ASN1Compare_%s,\n", GetName(a));
    }
    output("};\n");
    output("\n");
#endif // ENABLE_COMPARE

    /* write a table containing the sizeof pdu structures */
    output("static const ULONG sizetab[%u] = {\n", g_cPDUs);
    for (i = 0; i < g_cPDUs; i++)
    {
        output("SIZE_%s_%s_%u,\n", module, g_pszApiPostfix, i);
    }
    output("};\n");
    output("\n");

    /* handle values in 4 steps: */
    /* 1. write forward declarations, */
    /* 2. write definitions of value components, */
    /* 3. write definitions of values, */
    /* 4. write assignments into the initialization function */
    for (ev = eDecl; ev <= eFinit; ev++)
    {
        switch (ev)
        {
        case eDecl:
            output("/* forward declarations of values: */\n");
            break;
        case eDefh:
            output("/* definitions of value components: */\n");
            break;
        case eDefn:
            output("/* definitions of values: */\n");
            break;
        case eInit:
            output("\nvoid ASN1CALL %s_Startup(void)\n", module);
            output("{\n");
            switch (g_eEncodingRule)
            {
            case eEncoding_Packed:
                GenPERInit(ass, module);
                break;
            case eEncoding_Basic:
                GenBERInit(ass, module);
                break;
            }
            break;
        case eFinit:
            output("\nvoid ASN1CALL %s_Cleanup(void)\n", module);
            output("{\n");
            output("ASN1_CloseModule(%s);\n", module);
            output("%s = NULL;\n", module);
            break;
        }
        for (a = ass; a; a = a->Next)
        {
            if (a->Type != eAssignment_Value)
                continue;
            if (GetValue(ass, a->U.Value.Value)->Type->Flags & eTypeFlags_Null)
                continue;
            switch (ev)
            {
            case eDecl:
            case eDefh:
            case eDefn:
            case eInit:
            case eFinit:
                if (!(a->U.Value.Value->Flags & eValueFlags_GenValue))
                    continue;
                break;
            }
            GenFuncValue(ass, a, ev);
        }
        if (ev == eInit || ev == eFinit) {
            output("}\n");
        }
    }
    output("\n");

    /* generate the type functions for all assignments as wanted */
    for (a = ass; a; a = a->Next)
    {
        if (a->Type != eAssignment_Type)
            continue;

        /* skip null types */
        if (a->U.Type.Type->Flags & eTypeFlags_Null)
            continue;

        if ((! g_fLongNameForImported) && a->fImportedLocalDuplicate)
           continue;

        if (a->U.Type.Type->PrivateDirectives.fNoCode)
            continue;

        /* generate the functions */
        identifier = GetName(a);
        for (et = eStringTable; et <= eCopy; et++)
        {
            switch (et)
            {
            case eStringTable:
                if (!(a->U.Type.Type->Flags &
                    (eTypeFlags_GenEncode | eTypeFlags_GenDecode)))
                    continue;
                switch (g_eEncodingRule)
                {
                case eEncoding_Packed:
                    GenPERFuncType(ass, module, a, et);
                    break;
                case eEncoding_Basic:
                    GenBERFuncType(ass, module, a, et);
                    break;
                }
                break;
            case eEncode:
                if (!(a->U.Type.Type->Flags & eTypeFlags_GenEncode))
                    continue;
                sprintf(funcbuf, IsPSetOfType(ass, a) ? args.Pencfunc : args.encfunc, identifier);
                output("static int ASN1CALL ASN1Enc_%s(%s)\n",
                    identifier, funcbuf);
                output("{\n");
                switch (g_eEncodingRule)
                {
                case eEncoding_Packed:
                    GenPERFuncType(ass, module, a, et);
                    break;
                case eEncoding_Basic:
                    GenBERFuncType(ass, module, a, et);
                    break;
                }
                output("return 1;\n");
                output("}\n\n");
                break;
            case eDecode:
                if (!(a->U.Type.Type->Flags & eTypeFlags_GenDecode))
                    continue;
                sprintf(funcbuf, IsPSetOfType(ass, a) ? args.Pdecfunc : args.decfunc, identifier);
                output("static int ASN1CALL ASN1Dec_%s(%s)\n",
                    identifier, funcbuf);
                output("{\n");
                switch (g_eEncodingRule)
                {
                case eEncoding_Packed:
                    GenPERFuncType(ass, module, a, et);
                    break;
                case eEncoding_Basic:
                    GenBERFuncType(ass, module, a, et);
                    break;
                }
                output("return 1;\n");
                output("}\n\n");
                break;
            case eCheck:
                if (!(a->U.Type.Type->Flags & eTypeFlags_GenCheck))
                    continue;
                GenFuncType(ass, module, a, et);
                break;
            case ePrint:
                if (!(a->U.Type.Type->Flags & eTypeFlags_GenPrint))
                    continue;
                GenFuncType(ass, module, a, et);
                break;
            case eFree:
                if (!(a->U.Type.Type->Flags & eTypeFlags_GenFree) ||
                    (a->U.Type.Type->Flags & eTypeFlags_Simple))
                    continue;
                sprintf(funcbuf, IsPSetOfType(ass, a) ? args.Pfreefunc : args.freefunc, identifier);
                output("static void ASN1CALL ASN1Free_%s(%s)\n",
                    identifier, funcbuf);
                output("{\n");
                output("if (val) {\n");  // opening the null pointer check
                GenFuncType(ass, module, a, et);
                output("}\n"); // closing the null pointer check
                output("}\n\n");
                break;
#ifdef ENABLE_COMPARE
            case eCompare:
                if (!(a->U.Type.Type->Flags & eTypeFlags_GenCompare))
                    continue;
                sprintf(funcbuf, IsPSetOfType(ass, a) ? args.Pcmpfunc : args.cmpfunc, identifier);
                output("static int ASN1CALL ASN1Compare_%s(%s)\n",
                    identifier, funcbuf);
                output("{\n");
                outputvar("int ret;\n");
                GenFuncType(ass, module, a, et);
                output("return 0;\n");
                output("}\n\n");
                break;
#endif // ENABLE_COMPARE
            case eCopy:
                if (!(a->U.Type.Type->Flags & eTypeFlags_GenCopy))
                    continue;
                GenFuncType(ass, module, a, et);
                break;
            }
        }
    }
}

/* generate function encoding-independent type-specific functions */
void
GenFuncType(AssignmentList_t ass, char *module, Assignment_t *at, TypeFunc_e et)
{
    Type_t *type;
    char *ideref;
    char *valref1, *valref2;

    /* get some informations */
    type = at->U.Type.Type;
    ideref = GetName(at);
    switch (et) {
    case eCompare:
        valref1 = "val1";
        valref2 = "val2";
        break;
    default:
        valref1 = "val";
        valref2 = "";
        break;
    }

    /* function body */
    switch (type->Type) {
    case eType_Boolean:
    case eType_Integer:
    case eType_Enumerated:
    case eType_Real:
    case eType_BitString:
    case eType_OctetString:
    case eType_UTF8String:
    case eType_Null:
    case eType_EmbeddedPdv:
    case eType_External:
    case eType_ObjectIdentifier:
    case eType_BMPString:
    case eType_GeneralString:
    case eType_GraphicString:
    case eType_IA5String:
    case eType_ISO646String:
    case eType_NumericString:
    case eType_PrintableString:
    case eType_TeletexString:
    case eType_T61String:
    case eType_UniversalString:
    case eType_VideotexString:
    case eType_VisibleString:
    case eType_CharacterString:
    case eType_GeneralizedTime:
    case eType_UTCTime:
    case eType_ObjectDescriptor:
    case eType_RestrictedString:
    case eType_Open:
    case eType_Reference:
        /* generate function for a simple type */
        GenFuncSimpleType(ass, type, ideref, Dereference(valref1), Dereference(valref2), et);
        break;

    case eType_SequenceOf:
    case eType_SetOf:
        /* generate function for seq-of and set-of */
        GenFuncSimpleType(ass, type, ideref, Dereference(valref1), Dereference(valref2), et);
        break;

    case eType_Sequence:
    case eType_Set:
    case eType_InstanceOf:
        /* generate function for a sequence/set/instanceof type */
        GenFuncSequenceSetType(ass, module, at, valref1, valref2, et);
        break;

    case eType_Choice:
        /* generate function for a choice type */
        GenFuncChoiceType(ass, module, at, valref1, valref2, et);
        break;

    case eType_Selection:
        MyAbort();
        /*NOTREACHED*/

    case eType_Undefined:
        MyAbort();
        /*NOTREACHED*/
    }
}

/* generate encoding-independent statements for components of a */
/* sequence/set/choice type */
void
GenFuncComponents(AssignmentList_t ass, char *module, Type_t *type, char *ideref, uint32_t optindex, ComponentList_t components, char *valref1, char *valref2, TypeFunc_e et, int inextension, int inchoice)
{
    Component_t *com;
    NamedType_t *namedType;
    char *ide, idebuf[256];
    char valbuf1[256], valbuf2[256], valbuf3[256];
    int skip;

    /* emit components of extension root */
    for (com = components; com; com = com->Next) {
        if (com->Type == eComponent_ExtensionMarker)
            break;

        /* get some information */
        namedType = com->U.NOD.NamedType;
        ide = Identifier2C(namedType->Identifier);
        sprintf(idebuf, "%s_%s", ideref, ide);

        /* skip unnecessary elements */
        switch (et) {
        case eFree:
            skip = (namedType->Type->Flags & eTypeFlags_Simple);
            break;
        default:
            skip = 0;
            break;
        }

        /* dereference pointer if pointer directive used */
        if (inchoice) {
            if (GetTypeRules(ass, namedType->Type) & eTypeRules_Pointer) {
                sprintf(valbuf1, "*(%s)->u.%s", valref1, ide);
                sprintf(valbuf2, "*(%s)->u.%s", valref2, ide);
            } else {
                sprintf(valbuf1, "(%s)->u.%s", valref1, ide);
                sprintf(valbuf2, "(%s)->u.%s", valref2, ide);
            }
        } else {
            if (GetTypeRules(ass, namedType->Type) & eTypeRules_Pointer) {
                sprintf(valbuf1, "*(%s)->%s", valref1, ide);
                sprintf(valbuf2, "*(%s)->%s", valref2, ide);
            } else {
                sprintf(valbuf1, "(%s)->%s", valref1, ide);
                sprintf(valbuf2, "(%s)->%s", valref2, ide);
            }
        }

        /* check if optional/default component is present */
        if (!skip) {
            if (inchoice) {
                switch (et) {
                case eFree:
                    output("case %d:\n", optindex);
                    GenFuncSimpleType(ass, namedType->Type, idebuf,
                        valbuf1, valbuf2, et);
                    if ((GetTypeRules(ass, namedType->Type) &
                        eTypeRules_Pointer) &&
                        !(GetType(ass, namedType->Type)->Flags &
                        eTypeFlags_Null))
                        output("ASN1Free(%s);\n", Reference(valbuf1));
                    output("break;\n");
                    break;
                default:
                    output("case %d:\n", optindex);
                    GenFuncSimpleType(ass, namedType->Type, idebuf,
                        valbuf1, valbuf2, et);
                    output("break;\n");
                    break;
                }
            } else {
                if (com->Type == eComponent_Optional ||
                    com->Type == eComponent_Default ||
                    inextension) {
                    switch (et) {
                    case eFree:
                        output("if ((%s)->o[%u] & 0x%x) {\n", valref1,
                            optindex / 8, 0x80 >> (optindex & 7));
                        GenFuncSimpleType(ass, namedType->Type, idebuf,
                            valbuf1, valbuf2, et);
                        if ((GetTypeRules(ass, namedType->Type) &
                            eTypeRules_Pointer) &&
                            !(GetType(ass, namedType->Type)->Flags &
                            eTypeFlags_Null))
                            output("ASN1Free(%s);\n", Reference(valbuf1));
                        output("}\n");
                        break;
                    case eCompare:
                        sprintf(valbuf3, "%s_default", idebuf);
                        output("if (((%s)->o[%u] & 0x%x)) {\n", valref1,
                            optindex / 8, 0x80 >> (optindex & 7));
                        output("if (((%s)->o[%u] & 0x%x)) {\n", valref2,
                            optindex / 8, 0x80 >> (optindex & 7));
                        GenFuncSimpleType(ass, namedType->Type, idebuf,
                            valbuf1, valbuf2, et);
                        output("} else {\n");
                        if (com->Type == eComponent_Default) {
                            GenFuncSimpleType(ass, namedType->Type, idebuf,
                                valbuf1, valbuf3, et);
                        } else {
                            output("return 1;\n");
                        }
                        output("}\n");
                        output("} else {\n");
                        output("if (((%s)->o[%u] & 0x%x)) {\n", valref2,
                            optindex / 8, 0x80 >> (optindex & 7));
                        if (com->Type == eComponent_Default) {
                            GenFuncSimpleType(ass, namedType->Type, idebuf,
                                valbuf3, valbuf2, et);
                        } else {
                            output("return 1;\n");
                        }
                        output("}\n");
                        output("}\n");
                        break;
                    default:
                        GenFuncSimpleType(ass, namedType->Type, idebuf,
                            valbuf1, valbuf2, et);
                        break;
                    }
                } else {
                    GenFuncSimpleType(ass, namedType->Type, idebuf,
                        valbuf1, valbuf2, et);
                }
            }
        }
        if (inchoice ||
            com->Type == eComponent_Optional ||
            com->Type == eComponent_Default ||
            inextension)
            optindex++;
    }
}

/* generate encoding-independent statements for sequence/set type */
void
GenFuncSequenceSetType(AssignmentList_t ass, char *module, Assignment_t *at, char *valref1, char *valref2, TypeFunc_e et)
{
    uint32_t optionals, extensions;
    Component_t *components, *com;
    Type_t *type;
    char *ideref;

    type = at->U.Type.Type;
    ideref = GetName(at);
    optionals = type->U.SSC.Optionals;
    extensions = type->U.SSC.Extensions;
    components = type->U.SSC.Components;

    /* emit components of extension root */
    GenFuncComponents(ass, module, type, ideref, 0,
        components, valref1, valref2, et, 0, 0);

    /* handle extensions */
    if (type->Flags & eTypeFlags_ExtensionMarker) {
        if (extensions) {

            /* get start of extensions */
            for (com = components; com; com = com->Next) {
                if (com->Type == eComponent_ExtensionMarker) {
                    com = com->Next;
                    break;
                }
            }

            /* emit components of extension */
            GenFuncComponents(ass, module, type, ideref, (optionals + 7) & ~7,
                com, valref1, valref2, et, 1, 0);
        }
    }
}

/* generate encoding-independent statements for choice type */
void
GenFuncChoiceType(AssignmentList_t ass, char *module, Assignment_t *at, char *valref1, char *valref2, TypeFunc_e et)
{
    Type_t *type;
    char *ideref;
    char valbuf1[256], valbuf2[256];
    uint32_t alternatives;
    Component_t *components, *com;

    /* get some informations */
    type = at->U.Type.Type;
    ideref = GetName(at);
    alternatives = type->U.SSC.Alternatives;
    components = type->U.SSC.Components;

    /* encode choice selector */
    sprintf(valbuf1, "(%s)->choice", valref1);
    sprintf(valbuf2, "(%s)->choice", valref2);
    GenFuncSimpleType(ass, type, ideref, valbuf1, valbuf2, et);

    /* finished if choice only contains NULL alternatives or if choice */
    /* contains no data to free */
    if ((type->Flags & eTypeFlags_NullChoice) ||
        (et == eFree && (type->Flags & eTypeFlags_Simple)))
        return;

    /* create switch statement */
    output("switch ((%s)->choice) {\n", valref1);

    /* generate components of extension root */
    GenFuncComponents(ass, module, type, ideref, ASN1_CHOICE_BASE,
        type->U.SSC.Components, valref1, valref2, et, 0, 1);

    /* get start of extensions */
    for (com = components; com; com = com->Next) {
        if (com->Type == eComponent_ExtensionMarker) {
            com = com->Next;
            break;
        }
    }

    /* generate components of extension */
    GenFuncComponents(ass, module, type, ideref, ASN1_CHOICE_BASE + alternatives,
        com, valref1, valref2, et, 1, 1);

    /* end of switch statement */
    output("}\n");
}

/* generate encoding-independent statements for a simple type */
void
GenFuncSimpleType(AssignmentList_t ass, Type_t *type, char *ideref, char *valref1, char *valref2, TypeFunc_e et)
{
    switch (et) {
    case eFree:
        GenFreeSimpleType(ass, type, ideref, valref1);
        break;
#ifdef ENABLE_COMPARE
    case eCompare:
        GenCompareSimpleType(ass, type, ideref, valref1, valref2);
        break;
#endif // ENABLE_COMPARE
    }
}

/* generate free statements for a simple type */
void
GenFreeSimpleType(AssignmentList_t ass, Type_t *type, char *ideref, char *valref)
{
    char idebuf[256];
    char valbuf[256];
    char valbuf2[256];
    char *itype;
    int32_t noctets;
    uint32_t zero;

    if (type->Flags & eTypeFlags_Simple)
        return;
    if (type->Type == eType_Reference && !IsStructuredType(GetType(ass, type)))
        type = GetType(ass, type);

    switch (type->Type) {
    case eType_Boolean:
    case eType_Integer:
    case eType_Enumerated:

        /* check if we have to free an intx_t value */
        itype = GetTypeName(ass, type);
        if (!strcmp(itype, "ASN1intx_t"))
            output("ASN1intx_free(%s);\n", Reference(valref));
        break;

    case eType_BitString:

        /* free bit string value */
        if (g_eEncodingRule == eEncoding_Packed)
        {
            if (type->PERTypeInfo.Root.cbFixedSizeBitString == 0)
            {
                output("ASN1bitstring_free(%s);\n", Reference(valref));
            }
        }
        else
        {
            // only support unbounded in BER
            if (! type->PrivateDirectives.fNoMemCopy)
            {
                output("ASN1bitstring_free(%s);\n", Reference(valref));
            }
        }
        break;

    case eType_OctetString:

        /* free octet string value */
        if (g_eEncodingRule == eEncoding_Packed)
        {
            if (type->PERTypeInfo.Root.LConstraint != ePERSTIConstraint_Constrained ||
                type->PrivateDirectives.fLenPtr)
            {
                output("ASN1octetstring_free(%s);\n", Reference(valref));
            }
        }
        else
        {
            // only support unbounded in BER
            if (! type->PrivateDirectives.fNoMemCopy)
            {
                output("ASN1octetstring_free(%s);\n", Reference(valref));
            }
        }
        break;

    case eType_UTF8String:

        /* free octet string value */
        output("ASN1utf8string_free(%s);\n", Reference(valref));
        break;

    case eType_ObjectIdentifier:

        /* free object identifier value */
        if (type->PrivateDirectives.fOidPacked)
        {
            output("ASN1BEREoid_free(%s);\n", Reference(valref));
        }
        else
        if (! (type->PrivateDirectives.fOidArray || g_fOidArray))
        {
            output("ASN1objectidentifier_free(%s);\n", Reference(valref));
        }
        break;

    case eType_External:

        /* free external value */
        output("ASN1external_free(%s);\n", Reference(valref));
        break;

    case eType_Real:

        /* free real value */
        output("ASN1real_free(%s);\n", Reference(valref));
        break;

    case eType_EmbeddedPdv:

        /* free embedded pdv value */
        output("ASN1embeddedpdv_free(%s);\n", Reference(valref));
        break;

    case eType_SetOf:

        /* create name of identifier */
        sprintf(idebuf, "%s_Set", ideref);
        goto FreeSequenceSetOf;

    case eType_SequenceOf:

        /* create name of identifier */
        sprintf(idebuf, "%s_Sequence", ideref);
    FreeSequenceSetOf:

        if (type->Rules & eTypeRules_FixedArray)
        {
            char *pszPrivateValueName = GetPrivateValueName(&type->PrivateDirectives, "value");
            /* free components of sequence of/set of */
            if (! (type->Rules & eTypeRules_PointerToElement))
                valref = Reference(valref);
            if (!(type->U.SS.Type->Flags & eTypeFlags_Simple)) {
                outputvar("ASN1uint32_t i;\n");
                output("for (i = 0; i < (%s)->count; i++) {\n", valref);
                sprintf(valbuf, "(%s)->%s[i]", valref, pszPrivateValueName);
                GenFuncSimpleType(ass, type->U.SS.Type, idebuf, valbuf, "", eFree);
                output("}\n");
            }
        }
        else
        if (type->Rules & eTypeRules_LengthPointer)
        {
            char *pszPrivateValueName = GetPrivateValueName(&type->PrivateDirectives, "value");
            /* free components of sequence of/set of */
            if (! (type->Rules & eTypeRules_PointerToElement))
                valref = Reference(valref);
            if (!(type->U.SS.Type->Flags & eTypeFlags_Simple)) {
                sprintf(valbuf2, "(%s)->%s[0]", valref, pszPrivateValueName);
                GenFuncSimpleType(ass, type->U.SS.Type, idebuf, valbuf2, "", eFree);
                outputvar("ASN1uint32_t i;\n");
                output("for (i = 1; i < (%s)->count; i++) {\n", valref);
                sprintf(valbuf2, "(%s)->%s[i]", valref, pszPrivateValueName);
                GenFuncSimpleType(ass, type->U.SS.Type, idebuf, valbuf2, "", eFree);
                output("}\n");
            }
            // lonchanc: no need to check length because we zero out decoded buffers.
            // output("if ((%s)->count)\n", valref);
            output("ASN1Free((%s)->%s);\n", valref, pszPrivateValueName);
        }
        else
        if (type->Rules & eTypeRules_LinkedListMask)
        {
            char szPrivateValueName[68];

            if (g_fCaseBasedOptimizer)
            {
                if (g_eEncodingRule == eEncoding_Packed &&
                    PerOptCase_IsTargetSeqOf(&type->PERTypeInfo))
                {
                    // generate the iterator
                    PERTypeInfo_t *info = &type->PERTypeInfo;
                    char szElmFn[128];
                    char szElmFnDecl[256];
                    sprintf(szElmFn, "ASN1Free_%s_ElmFn", info->Identifier);
                    sprintf(szElmFnDecl, "void ASN1CALL %s(P%s val)",
                        szElmFn, info->Identifier);

                    setoutfile(g_finc);
                    output("extern %s;\n", szElmFnDecl);
                    setoutfile(g_fout);

                    output("ASN1PERFreeSeqOf((ASN1iterator_t **) %s, (ASN1iterator_freefn) %s);\n",
                        Reference(valref), szElmFn);
                    output("}\n"); // closing the null pointer check
                    output("}\n\n"); // end of iterator body


                    // generate the element function
                    output("static %s\n", szElmFnDecl);
                    output("{\n");
                    output("if (val) {\n"); // opening the null pointer check
                    sprintf(&szPrivateValueName[0], "val->%s", GetPrivateValueName(info->pPrivateDirectives, "value"));
                    GenFuncSimpleType(ass, type->U.SS.Type, idebuf,
                        &szPrivateValueName[0], "", eFree);
                    // output("}\n"); // closing the null pointer check. lonchanc: closed by caller
                    // end of element body
                    return;
                }
            }

            /* free components of sequence of/set of */
            outputvar("P%s f, ff;\n", ideref);
            output("for (f = %s; f; f = ff) {\n", valref);
            sprintf(&szPrivateValueName[0], "f->%s", type->PrivateDirectives.pszValueName ? type->PrivateDirectives.pszValueName : "value");
            GenFuncSimpleType(ass, type->U.SS.Type, idebuf,
                &szPrivateValueName[0], "", eFree);
            output("ff = f->next;\n");

            /* free list entry of sequence of/set of */
            output("ASN1Free(f);\n");
            output("}\n");
        }
        break;

    case eType_ObjectDescriptor:

        /* free object descriptor value */
        output("ASN1ztcharstring_free(%s);\n", valref);
        break;

    case eType_NumericString:
    case eType_PrintableString:
    case eType_TeletexString:
    case eType_T61String:
    case eType_VideotexString:
    case eType_IA5String:
    case eType_GraphicString:
    case eType_VisibleString:
    case eType_ISO646String:
    case eType_GeneralString:
    case eType_UniversalString:
#ifdef ENABLE_CHAR_STR_SIZE
                if (g_eEncodingRule == eEncoding_Packed &&
                    type->PERTypeInfo.NOctets == 1 &&
                        type->PERTypeInfo.Root.LConstraint == ePERSTIConstraint_Constrained)
                {
                    // it is an array, no need to free it.
                    break;
                }
#endif

    case eType_BMPString:
    case eType_RestrictedString:

        /* free string value */
        GetStringType(ass, type, &noctets, &zero);
        if (zero) {
            switch (noctets) {
            case 1:
                output("ASN1ztcharstring_free(%s);\n", valref);
                break;
            case 2:
                output("ASN1ztchar16string_free(%s);\n", valref);
                break;
            case 4:
                output("ASN1ztchar32string_free(%s);\n", valref);
                break;
            }
        } else {
            switch (noctets) {
            case 1:
                output("ASN1charstring_free(%s);\n", Reference(valref));
                break;
            case 2:
                output("ASN1char16string_free(%s);\n", Reference(valref));
                break;
            case 4:
                output("ASN1char32string_free(%s);\n", Reference(valref));
                break;
            }
        }
        break;

    case eType_CharacterString:

        /* free character string value */
        output("ASN1characterstring_free(%s);\n", Reference(valref));
        break;

    case eType_Reference:

        /* call free function of referenced type */
        output("ASN1Free_%s(%s);\n",
            GetTypeName(ass, type), Reference(valref));
        break;

    case eType_Open:

        /* free open type value */
        if (g_eEncodingRule == eEncoding_Packed || (! type->PrivateDirectives.fNoMemCopy))
        {
            output("ASN1open_free(%s);\n", Reference(valref));
        }
        break;
    }
}

/* generate compare statements for a simple type */
/*ARGSUSED*/
#ifdef ENABLE_COMPARE
void
GenCompareSimpleType(AssignmentList_t ass, Type_t *type, char *ideref, char *valref1, char *valref2)
{
    /* skip null type */
    if (type->Flags & eTypeFlags_Null)
        return;

    /* compare the values and return difference if different */
    output("if ((ret = (");
    GenCompareExpression(ass, type, ideref, valref1, valref2);
    output(")))\n");
    output("return ret;\n");
}
#endif // ENABLE_COMPARE

/* generate compare expression for two values of simple type */
/*ARGSUSED*/
#ifdef ENABLE_COMPARE
void
GenCompareExpression(AssignmentList_t ass, Type_t *type, char *ideref, char *valref1, char *valref2)
{
    PERSTIData_e dat;
    uint32_t noctets;
    char *itype;
    char *subide;
    char *pszPrivateValueName;

    /*XXX switch to PER-independent field */
    dat = type->PERTypeInfo.Root.Data;
    noctets = type->PERTypeInfo.NOctets;

    switch (dat) {
    case ePERSTIData_Null:

        /* null values equal */
        output("0");
        break;

    case ePERSTIData_Boolean:

        /* boolean values have to be converted to 0/1 values before */
        /* comparison */
        output("!!%s - !!%s", valref1, valref2);
        break;

    case ePERSTIData_Integer:
    case ePERSTIData_Unsigned:

        /* substract integer values */
        if (noctets) {
            if (noctets <= 4)
                output("%s - %s", valref1, valref2);
            else
                output("%s < %s ? -1 : %s > %s ? 1 : 0",
                    valref1, valref2, valref1, valref2);
        } else {
            output("ASN1intx_cmp(%s, %s)",
                Reference(valref1), Reference(valref2));
        }
        break;

    case ePERSTIData_Real:

        /* compare real values */
        itype = GetTypeName(ass, type);
        if (!strcmp(itype, "ASN1real_t"))
            output("ASN1real_cmp(%s, %s)",
                Reference(valref1), Reference(valref2));
        else
            output("ASN1double_cmp(%s, %s)",
                valref1, valref2);
        break;

    case ePERSTIData_BitString:

        /* compare bit string values */
        output("ASN1bitstring_cmp(%s, %s, 0)",
            Reference(valref1), Reference(valref2));
        break;

    case ePERSTIData_RZBBitString:

        /* compare remove-zero-bit bit string values */
        output("ASN1bitstring_cmp(%s, %s, 1)",
            Reference(valref1), Reference(valref2));
        break;

    case ePERSTIData_OctetString:

        /* compare octet string values */
        output("ASN1octetstring_cmp(%s, %s)",
            Reference(valref1), Reference(valref2));
        break;

    case ePERSTIData_UTF8String:

        /* compare octet string values */
        output("ASN1utf8string_cmp(%s, %s)",
            Reference(valref1), Reference(valref2));
        break;

    case ePERSTIData_ObjectIdentifier:

        /* compare object identifier values */
        output("ASN1objectidentifier_cmp(%s, %s)",
            Reference(valref1), Reference(valref2));
        break;

    case ePERSTIData_String:
    case ePERSTIData_TableString:

        /* compare string values */
        switch (noctets) {
        case 1:
            output("ASN1charstring_cmp(%s, %s)",
                Reference(valref1), Reference(valref2));
            break;
        case 2:
            output("ASN1char16string_cmp(%s, %s)",
                Reference(valref1), Reference(valref2));
            break;
        case 4:
            output("ASN1char32string_cmp(%s, %s)",
                Reference(valref1), Reference(valref2));
            break;
        }
        break;

    case ePERSTIData_ZeroString:
    case ePERSTIData_ZeroTableString:

        /* compare zero-terminated string values */
        switch (noctets) {
        case 1:
            output("ASN1ztcharstring_cmp(%s, %s)",
                valref1, valref2);
            break;
        case 2:
            output("ASN1ztchar16string_cmp(%s, %s)",
                valref1, valref2);
            break;
        case 4:
            output("ASN1ztchar32string_cmp(%s, %s)",
                valref1, valref2);
            break;
        }
        break;

    case ePERSTIData_SequenceOf:

        /* compare sequence of values by use of a comparison function */
        /* use element comparison function as argument */
        subide = GetTypeName(ass, type->U.SS.Type);
        pszPrivateValueName = GetPrivateValueName(&type->PrivateDirectives, "value");
        if (type->Rules & eTypeRules_PointerArrayMask)
        {
            output("ASN1sequenceoflengthpointer_cmp((%s)->count, (%s)->%s, (%s)->count, (%s)->%s, sizeof(%s), (int (*)(void *, void *))ASN1Compare_%s)",
                Reference(valref1), Reference(valref1), pszPrivateValueName,
                Reference(valref2), Reference(valref2), pszPrivateValueName, subide, subide);
        }
        else
        if (type->Rules & eTypeRules_SinglyLinkedList)
        {
            output("ASN1sequenceofsinglylinkedlist_cmp(%s, %s, offsetof(%s_Element, %s), (ASN1int32_t (*)(void *, void *))ASN1Compare_%s)",
                valref1, valref2, ideref, pszPrivateValueName, subide);
        }
        else
        if (type->Rules & eTypeRules_DoublyLinkedList)
        {
            output("ASN1sequenceofdoublylinkedlist_cmp(%s, %s, offsetof(%s_Element, %s), (ASN1int32_t (*)(void *, void *))ASN1Compare_%s)",
                valref1, valref2, ideref, pszPrivateValueName, subide);
        }
        else
        {
            MyAbort();
        }
        break;

    case ePERSTIData_SetOf:

        /* compare set of values by use of a comparison function */
        /* use element comparison function as argument */
        subide = GetTypeName(ass, type->U.SS.Type);
        pszPrivateValueName = GetPrivateValueName(&type->PrivateDirectives, "value");
        if (type->Rules & eTypeRules_PointerArrayMask)
        {
            output("ASN1setoflengthpointer_cmp((%s)->count, (%s)->%s, (%s)->count, (%s)->%s, sizeof(%s), (int (*)(void *, void *))ASN1Compare_%s)",
                Reference(valref1), Reference(valref1), pszPrivateValueName,
                Reference(valref2), Reference(valref2), pszPrivateValueName, subide, subide);
        }
        else
        if (type->Rules & eTypeRules_SinglyLinkedList)
        {
            output("ASN1setofsinglylinkedlist_cmp(%s, %s, offsetof(%s_Element, %s), (ASN1int32_t (*)(void *, void *))ASN1Compare_%s)",
                valref1, valref2, ideref, pszPrivateValueName, subide);
        }
        else
        if (type->Rules & eTypeRules_DoublyLinkedList)
        {
            output("ASN1setofdoublylinkedlist_cmp(%s, %s, offsetof(%s_Element, %s), (ASN1int32_t (*)(void *, void *))ASN1Compare_%s)",
                valref1, valref2, ideref, pszPrivateValueName, subide);
        }
        else
        {
            MyAbort();
        }
        break;

    case ePERSTIData_Reference:

        /* call compare function of referenced value */
        output("ASN1Compare_%s(%s, %s)",
            GetTypeName(ass, type), Reference(valref1), Reference(valref2));
        break;

    case ePERSTIData_External:

        /* compare external values */
        output("ASN1external_cmp(%s, %s)",
            Reference(valref1), Reference(valref2));
        break;

    case ePERSTIData_EmbeddedPdv:

        /* compare embedded pdv values */
        output("ASN1embeddedpdv_cmp(%s, %s)",
            Reference(valref1), Reference(valref2));
        break;

    case ePERSTIData_MultibyteString:

        /* compare multibyte string values */
        output("ASN1ztcharstring_cmp(%s, %s)",
            valref1, valref2);
        break;

    case ePERSTIData_UnrestrictedString:

        /* compare character string values */
        output("ASN1characterstring_cmp(%s, %s)",
            Reference(valref1), Reference(valref2));
        break;

    case ePERSTIData_GeneralizedTime:

        /* compare generalized time values */
        output("ASN1generalizedtime_cmp(%s, %s)",
            Reference(valref1), Reference(valref2));
        break;

    case ePERSTIData_UTCTime:

        /* compare utc time values */
        output("ASN1utctime_cmp(%s, %s)",
            Reference(valref1), Reference(valref2));
        break;

    case ePERSTIData_Open:

        /* compare open type values */
        output("ASN1open_cmp(%s, %s)",
            Reference(valref1), Reference(valref2));
        break;
    }
}
#endif // ENABLE_COMPARE

/* generate encoding-independent statements for better optional flags of */
/* a sequence/set value */
void
GenFuncSequenceSetOptionals(AssignmentList_t ass, char *valref, ComponentList_t components, uint32_t optionals, uint32_t extensions, char *obuf, TypeFunc_e et)
{
    uint32_t optindex, inextension, oflg;
    Component_t *com;
    char *ide;
    char *itype;
    int flg;
    int32_t sign, noctets;
    uint32_t zero;

    sprintf(obuf, "(%s)->o", valref);
    oflg = 0;
    if (et == eEncode) {
        optindex = 0;
        inextension = 0;
        for (com = components; com; com = com->Next) {
            switch (com->Type) {
            case eComponent_Normal:

                /* non-optional fields in an extension will be mandatory, */
                /* so we can set the optional flag always. */
                if (inextension) {
                    if (!oflg) {
                        outputvar("ASN1octet_t o[%u];\n",
                            (optionals + 7) / 8 + (extensions + 7) / 8);
                        output("CopyMemory(o, (%s)->o, %u);\n", valref,
                            (optionals + 7) / 8 + (extensions + 7) / 8);
                        strcpy(obuf, "o");
                        oflg = 1;
                    }
                    output("%s[%u] |= 0x%x;\n", obuf, optindex / 8,
                        0x80 >> (optindex & 7));
                    optindex++;
                }
                break;

            case eComponent_Optional:

                /* optional pointers with value null are absent, so we */
                /* will clear the optional flag */
                ide = Identifier2C(com->U.Optional.NamedType->Identifier);
                switch (com->U.Optional.NamedType->Type->Type) {
                case eType_Reference:
                    if (GetTypeRules(ass, com->U.Optional.NamedType->Type) &
                        eTypeRules_Pointer) {
                        if (!oflg) {
                            outputvar("ASN1octet_t o[%u];\n",
                                (optionals + 7) / 8 + (extensions + 7) / 8);
                            output("CopyMemory(o, (%s)->o, %u);\n", valref,
                                (optionals + 7) / 8 + (extensions + 7) / 8);
                            strcpy(obuf, "o");
                            oflg = 1;
                        }
                        output("if (!(%s)->%s)\n", valref, ide);
                        output("o[%u] &= ~0x%x;\n", valref, optindex / 8,
                            0x80 >> (optindex & 7));
                    }
                    break;
                }
                optindex++;
                break;

            case eComponent_Default:

                /* default pointers with value null are absent, so we */
                /* will clear the optional flag */
                ide = Identifier2C(com->U.Default.NamedType->Identifier);
                switch (com->U.Default.NamedType->Type->Type) {
                case eType_Reference:
                    if (GetTypeRules(ass, com->U.Default.NamedType->Type) &
                        eTypeRules_Pointer) {
                        if (!oflg) {
                            outputvar("ASN1octet_t o[%u];\n",
                                (optionals + 7) / 8 + (extensions + 7) / 8);
                            output("CopyMemory(o, (%s)->o, %u);\n", valref,
                                (optionals + 7) / 8 + (extensions + 7) / 8);
                            strcpy(obuf, "o");
                            oflg = 1;
                        }
                        output("if (!(%s)->%s)\n", valref, ide);
                        output("o[%u] &= ~0x%x;\n", valref, optindex / 8,
                            0x80 >> (optindex & 7));
                    }
                    break;
                }

                /* if the given value is the default value, we can (BER) */
                /* or have to (CER) clear the corresponding optional flag */
                flg = 1;
                if (!oflg) {
                    switch (GetTypeType(ass, com->U.Default.NamedType->Type)) {
                    case eType_Choice:
                        if (!(GetType(ass, com->U.Default.NamedType->Type)->
                            Flags & eTypeFlags_NullChoice)) {
                            if (g_eSubEncodingRule == eSubEncoding_Canonical)
                                MyAbort(); /*XXX*/
                            flg = 0;
                        }
                        break;
                    case eType_Sequence:
                    case eType_Set:
                    case eType_InstanceOf:
                        if (g_eSubEncodingRule == eSubEncoding_Canonical)
                            MyAbort(); /*XXX*/
                        flg = 0;
                        break;
                    case eType_SequenceOf:
                    case eType_SetOf:
                        if (GetValue(ass, com->U.Default.Value)->U.SS.Values) {
                            if (g_eSubEncodingRule == eSubEncoding_Canonical)
                                MyAbort();
                            flg = 0;
                        }
                        break;
                    }
                    if (flg) {
                        outputvar("ASN1octet_t o[%u];\n",
                            (optionals + 7) / 8 + (extensions + 7) / 8);
                        output("CopyMemory(o, (%s)->o, %u);\n", valref,
                            (optionals + 7) / 8 + (extensions + 7) / 8);
                        strcpy(obuf, "o");
                        oflg = 1;
                    }
                }
                switch (GetTypeType(ass, com->U.Default.NamedType->Type)) {
                case eType_Boolean:
                    output("if (%s(%s)->%s)\n",
                        GetValue(ass,
                        com->U.Default.Value)->U.Boolean.Value ?  "" : "!",
                        valref, ide);
                    break;
                case eType_Integer:
                    itype = GetIntegerType(ass,
                        GetType(ass, com->U.Default.NamedType->Type),
                        &sign);
                    if (!strcmp(itype, "ASN1intx_t")) {
                        output("if (!ASN1intx_cmp(&(%s)->%s, &%s))\n",
                            valref, ide,
                            GetValueName(ass, com->U.Default.Value));
                    } else if (sign > 0) {
                        output("if ((%s)->%s == %u)\n", valref, ide,
                            intx2uint32(&GetValue(ass, com->U.Default.Value)
                            ->U.Integer.Value));
                    } else {
                        output("if ((%s)->%s == %d)\n", valref, ide,
                            intx2int32(&GetValue(ass, com->U.Default.Value)
                            ->U.Integer.Value));
                    }
                    break;
                case eType_BitString:
                    if (GetValue(ass, com->U.Default.Value)->
                        U.BitString.Value.length) {
                        output("if (!ASN1bitstring_cmp(&%s->%s, &%s, %d))\n",
                            valref, ide,
                            GetValueName(ass, com->U.Default.Value),
                            !!GetType(ass, com->U.Default.NamedType->Type)->
                            U.BitString.NamedNumbers);
                    } else {
                        output("if (!(%s)->%s.length)\n", valref, ide);
                    }
                    break;
                case eType_OctetString:
                    if (GetValue(ass, com->U.Default.Value)->U.OctetString.
                        Value.length) {
                        output("if (!ASN1octetstring_cmp(&%s->%s, &%s))\n",
                            valref, ide,
                            GetValueName(ass, com->U.Default.Value));
                    } else {
                        output("if (!(%s)->%s.length)\n", valref, ide);
                    }
                    break;
                case eType_UTF8String:
                    if (GetValue(ass, com->U.Default.Value)->U.UTF8String.
                        Value.length) {
                        output("if (!ASN1utf8string_cmp(&%s->%s, &%s))\n",
                            valref, ide,
                            GetValueName(ass, com->U.Default.Value));
                    } else {
                        output("if (!(%s)->%s.length)\n", valref, ide);
                    }
                    break;
                case eType_Null:
                    break;
                case eType_ObjectIdentifier:
                    if (GetValue(ass, com->U.Default.Value)->U.
                        ObjectIdentifier.Value.length) {
                        output("if (!ASN1objectidentifier%s_cmp(&%s->%s, &%s))\n",
                            com->U.Default.NamedType->Type->PrivateDirectives.fOidArray ? "2" : "",
                            valref, ide,
                            GetValueName(ass, com->U.Default.Value));
                    } else {
                        output("if (!(%s)->%s.length)\n", valref, ide);
                    }
                    break;
                case eType_ObjectDescriptor:
                    output("if (!strcmp((%s)->%s, %s))\n",
                        valref, ide,
                        GetValueName(ass, com->U.Default.Value));
                    break;
                case eType_External:
                    output("if (!ASN1external_cmp(&(%s)->%s, &%s))\n",
                        valref, ide,
                        GetValueName(ass, com->U.Default.Value));
                    break;
                case eType_Real:
                    itype = GetTypeName(ass, com->U.Default.NamedType->Type);
                    if (!strcmp(itype, "ASN1real_t")) {
                        output("if (!ASN1real_cmp(&(%s)->%s, &%s))\n",
                            valref, ide,
                            GetValueName(ass, com->U.Default.Value));
                    }
                    else
                    {
                        output("if ((%s)->%s == %g)\n",
                            valref, ide,
                            real2double(&GetValue(ass,
                            com->U.Default.Value)->U.Real.Value));
                    }
                    break;
                case eType_Enumerated:
                    output("if ((%s)->%s == %u)\n", valref, ide,
                        GetValue(ass, com->U.Default.Value)->
                        U.Enumerated.Value);
                    break;
                case eType_EmbeddedPdv:
                    output("if (!ASN1embeddedpdv_cmp(&(%s)->%s, &%s))\n",
                        valref, ide,
                        GetValueName(ass, com->U.Default.Value));
                    break;
                case eType_NumericString:
                case eType_PrintableString:
                case eType_TeletexString:
                case eType_T61String:
                case eType_VideotexString:
                case eType_IA5String:
                case eType_GraphicString:
                case eType_VisibleString:
                case eType_ISO646String:
                case eType_GeneralString:
                case eType_UniversalString:
                case eType_BMPString:
                case eType_RestrictedString:
                    GetStringType(ass, com->U.Default.NamedType->Type,
                        &noctets, &zero);
                    if (zero) {
                        switch (noctets) {
                        case 1:
                            output("if (!strcmp((%s)->%s, %s))\n",
                                valref, ide,
                                GetValueName(ass, com->U.Default.Value));
                            break;
                        case 2:
                            output("if (!ASN1str16cmp((%s)->%s, %s))\n",
                                valref, ide,
                                GetValueName(ass, com->U.Default.Value));
                            break;
                        case 4:
                            output("if (!ASN1str32cmp((%s)->%s, %s))\n",
                                valref, ide,
                                GetValueName(ass, com->U.Default.Value));
                            break;
                        default:
                            MyAbort();
                        }
                    } else {
                        switch (noctets) {
                        case 1:
                            output("if (!ASN1charstring_cmp(&(%s)->%s, &%s))\n",
                                valref, ide,
                                GetValueName(ass, com->U.Default.Value));
                            break;
                        case 2:
                            output("if (!ASN1char16string_cmp(&(%s)->%s, &%s))\n",
                                valref, ide,
                                GetValueName(ass, com->U.Default.Value));
                            break;
                        case 4:
                            output("if (!ASN1char32string_cmp(&(%s)->%s, &%s))\n",
                                valref, ide,
                                GetValueName(ass, com->U.Default.Value));
                            break;
                        default:
                            MyAbort();
                        }
                    }
                    break;
                case eType_CharacterString:
                    output("if (!ASN1characterstring_cmp(&(%s)->%s, &%s))\n",
                        valref, ide,
                        GetValueName(ass, com->U.Default.Value));
                    break;
                case eType_UTCTime:
                    output("if (!ASN1utctime_cmp(&(%s)->%s, &%s))\n",
                        valref, ide,
                        GetValueName(ass, com->U.Default.Value));
                    break;
                case eType_GeneralizedTime:
                    output("if (!ASN1generalizedtime_cmp(&(%s)->%s, &%s))\n",
                        valref, ide,
                        GetValueName(ass, com->U.Default.Value));
                    break;
                case eType_Choice:
                    if (GetType(ass, com->U.Default.NamedType->Type)->Flags
                        & eTypeFlags_NullChoice) {
                        output("if ((%s)->%s.o == %s.o)\n",
                            valref, ide,
                            GetValueName(ass, com->U.Default.Value));
                    } else {
                        if (g_eSubEncodingRule == eSubEncoding_Canonical)
                            MyAbort(); /*XXX*/
                        flg = 0;
                    }
                    break;
                case eType_Sequence:
                case eType_Set:
                case eType_InstanceOf:
                    if (g_eSubEncodingRule == eSubEncoding_Canonical)
                        MyAbort(); /*XXX*/
                    flg = 0;
                    break;
                case eType_SequenceOf:
                case eType_SetOf:
                    if (!GetValue(ass, com->U.Default.Value)->U.SS.Values) {
                        output("if (!(%s)->%s.count)\n", valref, ide);
                    } else {
                        if (g_eSubEncodingRule == eSubEncoding_Canonical)
                            MyAbort();
                        flg = 0;
                    }
                    break;
                default:
                    MyAbort();
                }
                if (flg)
                    output("%s[%u] &= ~0x%x;\n", obuf, optindex / 8,
                        0x80 >> (optindex & 7));
                optindex++;
                break;

            case eComponent_ExtensionMarker:

                /* update the optional index for extensions */
                optindex = (optindex + 7) & ~7;
                inextension = 1;
                break;
            }
        }
    }
}

/* generate encoding-independent statements for better optional values of */
/* a sequence/set value */
void
GenFuncSequenceSetDefaults(AssignmentList_t ass, char *valref, ComponentList_t components, char *obuf, TypeFunc_e et)
{
    uint32_t optindex, inextension;
    Component_t *com;
    char *ide;
    char *itype;
    int32_t sign;

    if (et == eDecode) {
        optindex = 0;
        inextension = 0;
        for (com = components; com; com = com->Next) {
            switch (com->Type) {
            case eComponent_Normal:

                /* all values in an extension are optional */
                if (!inextension)
                    break;
                /*FALLTHROUGH*/

            case eComponent_Optional:

                /* clear the pointer if the component is not present */
                ide = Identifier2C(com->U.Optional.NamedType->Identifier);
                switch (com->U.Optional.NamedType->Type->Type) {
                case eType_Reference:
                    if (GetTypeRules(ass, com->U.Optional.NamedType->Type) &
                        eTypeRules_Pointer) {
                        output("if (!(%s[%u] & 0x%x))\n", obuf,
                            optindex / 8, 0x80 >> (optindex & 7));
                        output("(%s)->%s = NULL;\n", valref, ide);
                    }
                    break;
                }
                optindex++;
                break;

            case eComponent_Default:

                /* clear the pointer if the component is not present */
                ide = Identifier2C(com->U.Default.NamedType->Identifier);
                switch (com->U.Optional.NamedType->Type->Type) {
                case eType_Reference:
                    if (GetTypeRules(ass, com->U.Optional.NamedType->Type) &
                        eTypeRules_Pointer) {
                        output("if (!(%s[%u] & 0x%x))\n", obuf,
                            optindex / 8, 0x80 >> (optindex & 7));
                        output("(%s)->%s = NULL;\n", valref, ide);
                    }
                    break;
                }

                /* set the element to the default value if it is simple */
                /* and not present */
                switch (GetTypeType(ass, com->U.Default.NamedType->Type)) {
                case eType_Boolean:
                    output("if (!(%s[%u] & 0x%x))\n", obuf, optindex / 8,
                        0x80 >> (optindex & 7));
                    output("(%s)->%s = %u;\n",
                        valref, ide, GetValue(ass, com->U.Default.Value)->
                        U.Boolean.Value);
                    break;
                case eType_Integer:
                    output("if (!(%s[%u] & 0x%x))\n", obuf, optindex / 8,
                        0x80 >> (optindex & 7));
                    itype = GetIntegerType(ass,
                        GetType(ass, com->U.Default.NamedType->Type),
                        &sign);
                    if (!strcmp(itype, "ASN1intx_t")) {
                        /*EMPTY*/
                    } else if (sign > 0) {
                        output("(%s)->%s = %u;\n", valref, ide,
                            intx2uint32(&GetValue(ass, com->U.Default.Value)
                            ->U.Integer.Value));
                    } else {
                        output("(%s)->%s = %d;\n", valref, ide,
                            intx2int32(&GetValue(ass, com->U.Default.Value)
                            ->U.Integer.Value));
                    }
                    break;
                case eType_Enumerated:
                    output("if (!(%s[%u] & 0x%x))\n", obuf, optindex / 8,
                        0x80 >> (optindex & 7));
                    output("(%s)->%s = %u;\n", valref, ide,
                        GetValue(ass, com->U.Default.Value)->
                        U.Enumerated.Value);
                    break;
                }
                optindex++;
                break;

            case eComponent_ExtensionMarker:

                /* update the optional index for extensions */
                optindex = (optindex + 7) & ~7;
                inextension = 1;
                break;
            }
        }
    }
}

/* generate values */
void
GenFuncValue(AssignmentList_t ass, Assignment_t *av, ValueFunc_e ev)
{
    char *ideref;
    char *typeref;
    Type_t *t;

    ideref = GetName(av);
    t = GetValue(ass, av->U.Value.Value)->Type;
    typeref = GetTypeName(ass, t);
    switch (ev) {
    case eDecl:
        GenDeclGeneric(ass, ideref, typeref, av->U.Value.Value, t);
        break;
    case eDefh:
        GenDefhGeneric(ass, ideref, typeref, av->U.Value.Value, t);
        break;
    case eDefn:
        GenDefnGeneric(ass, ideref, typeref, av->U.Value.Value, t);
        break;
    case eInit:
        GenInitGeneric(ass, ideref, typeref, av->U.Value.Value, t);
        break;
    case eFinit:
        break;
    }
}

/* generate forward declarations */
void
GenDeclGeneric(AssignmentList_t ass, char *ideref, char *typeref, Value_t *value, Type_t *t)
{
    value = GetValue(ass, value);
#if 0 // duplicate in the generated header file
    switch (t->Type)
    {
    case eType_ObjectIdentifier:
        if (t->PrivateDirectives.fOidArray || g_fOidArray)
        {
            output("extern ASN1objectidentifier2_t *%s;\n", ideref);
            break;
        }
        // intentionally fall through
    default:
        output("extern %s %s;\n", typeref, ideref);
        break;
    }
#endif // 0
    outputvalue0(ass, ideref, typeref, value);
}

/* generate definitions of value components */
void
GenDefhGeneric(AssignmentList_t ass, char *ideref, char *typeref, Value_t *value, Type_t *t)
{
    value = GetValue(ass, value);
    outputvalue1(ass, ideref, typeref, value);
}

/* generate definitions of values */
void
GenDefnGeneric(AssignmentList_t ass, char *ideref, char *typeref, Value_t *value, Type_t *t)
{
    value = GetValue(ass, value);
    switch (t->Type)
    {
    case eType_ObjectIdentifier:
        if (t->PrivateDirectives.fOidPacked ||
            t->PrivateDirectives.fOidArray || g_fOidArray)
        {
            // lonchanc: intentionally comment out the lines below
            // output("ASN1objectidentifier2_t *%s = ", ideref);
            // break;
            return;
        }
        // intentionally fall through
    default:
        output("%s %s = ", typeref, ideref);
        break;
    }
    outputvalue2(ass, ideref, value);
    output(";\n");
}

/* generate assignments into the initialization function */
/*ARGSUSED*/
void
GenInitGeneric(AssignmentList_t ass, char *ideref, char *typeref, Value_t *value, Type_t *t)
{
    outputvalue3(ass, ideref, ideref, value);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\asn1\asn1c\ident.c ===
/* Copyright (C) Boris Nikolaus, Germany, 1996-1997. All rights reserved. */
/* Copyright (C) Microsoft Corporation, 1997-1998. All rights reserved. */

#include "precomp.h"

char ident1[] = "$Copyright: Microsoft ASN.1 Compiler V1.0 $";
char ident2[] = "$Copyright: Copyright (C) Microsoft Corporation, 1997. All rights reserved. $";
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\asn1\asn1c\genper.c ===
/* Copyright (C) Boris Nikolaus, Germany, 1996-1997. All rights reserved. */
/* Copyright (C) Microsoft Corporation, 1997-1998. All rights reserved. */

#include "precomp.h"
#include "optcase.h"

void GenPERFuncSimpleType(AssignmentList_t ass, PERTypeInfo_t *info, char *valref, TypeFunc_e et, char *encref);
void GenPERStringTableSimpleType(AssignmentList_t ass, PERTypeInfo_t *info);

void GenPEREncSimpleType(AssignmentList_t ass, PERTypeInfo_t *info, char *valref, char *encref);
void GenPEREncGenericUnextended(
    AssignmentList_t ass,
    PERTypeInfo_t *info,
    PERSimpleTypeInfo_t *sinfo,
    char *valref,
    char *lenref,
    char *encref);
void GenPERFuncSequenceSetType(AssignmentList_t ass, char *module, Assignment_t *at, char *valref, char *encref, TypeFunc_e et);
void GenPERFuncChoiceType(AssignmentList_t ass, char *module, Assignment_t *at, char *valref, char *encref, TypeFunc_e et);

void GenPERDecSimpleType(AssignmentList_t ass, PERTypeInfo_t *info, char *valref, char *encref);
void GenPERDecGenericUnextended(
    AssignmentList_t ass,
    PERTypeInfo_t *info,
    PERSimpleTypeInfo_t *sinfo,
    char *valref,
    char *lenref,
    char *encref);

int IsUnconstrainedInteger(PERSimpleTypeInfo_t *sinfo);

extern int g_fDecZeroMemory;
extern int g_nDbgModuleName;
extern unsigned g_cPDUs;
extern int g_fCaseBasedOptimizer;
extern int g_fNoAssert;


/* write header needed for PER encodings */
void
GenPERHeader()
{
//    output("#include \"perfnlib.h\"\n");
}

/* set prototypes and function args of PER functions */
void
GetPERPrototype(Arguments_t *args)
{
    args->enccast = "ASN1encoding_t, void *";
    args->encfunc = "ASN1encoding_t enc, %s *val";
    args->Pencfunc = "ASN1encoding_t enc, P%s *val";
    args->deccast = "ASN1decoding_t, void *";
    args->decfunc = "ASN1decoding_t dec, %s *val";
    args->Pdecfunc = "ASN1decoding_t dec, P%s *val";
    args->freecast = "void *";
    args->freefunc = "%s *val";
    args->Pfreefunc = "P%s *val";
    args->cmpcast = "void *, void *";
    args->cmpfunc = "%s *val1, %s *val2";
    args->Pcmpfunc = "P%s *val1, P%s *val2";
}

/* write initialization function needed for PER encodings */
void
GenPERInit(AssignmentList_t ass, char *module)
{
    output("%s = ASN1_CreateModule(0x%x, ASN1_PER_RULE_ALIGNED, %s, %d, (const ASN1GenericFun_t *) encfntab, (const ASN1GenericFun_t *) decfntab, freefntab, sizetab, 0x%lx);\n",
        module,
        ASN1_THIS_VERSION,
        g_fNoAssert ? "ASN1FLAGS_NOASSERT" : "ASN1FLAGS_NONE",
        g_cPDUs,
        g_nDbgModuleName);
}

/* generate function body for a type */
void GenPERFuncType(AssignmentList_t ass, char *module, Assignment_t *at, TypeFunc_e et)
{
    Type_t *type;
    char *encref;
    char *valref;

    /* get some informations */
    type = at->U.Type.Type;
    switch (et) {
    case eStringTable:
        valref = encref = "";
        break;
    case eEncode:
        encref = "enc";
        valref = "val";
        break;
    case eDecode:
        encref = "dec";
        valref = "val";
        break;
    }

    /* function body */
    switch (type->Type) {
    case eType_Boolean:
    case eType_Integer:
    case eType_Enumerated:
    case eType_Real:
    case eType_BitString:
    case eType_OctetString:
    case eType_UTF8String:
    case eType_Null:
    case eType_EmbeddedPdv:
    case eType_External:
    case eType_ObjectIdentifier:
    case eType_BMPString:
    case eType_GeneralString:
    case eType_GraphicString:
    case eType_IA5String:
    case eType_ISO646String:
    case eType_NumericString:
    case eType_PrintableString:
    case eType_TeletexString:
    case eType_T61String:
    case eType_UniversalString:
    case eType_VideotexString:
    case eType_VisibleString:
    case eType_CharacterString:
    case eType_GeneralizedTime:
    case eType_UTCTime:
    case eType_ObjectDescriptor:
    case eType_RestrictedString:
    case eType_Open:
    case eType_Reference:
        GenPERFuncSimpleType(ass, &type->PERTypeInfo, Dereference(valref), et, encref);
        break;

    case eType_SequenceOf:
    case eType_SetOf:
        GenPERFuncSimpleType(ass, &type->PERTypeInfo, Dereference(valref), et, encref);
        break;

    case eType_Sequence:
    case eType_Set:
    case eType_InstanceOf:
        GenPERFuncSequenceSetType(ass, module, at, valref, encref, et);
        break;

    case eType_Choice:
        GenPERFuncChoiceType(ass, module, at, valref, encref, et);
        break;

    case eType_Selection:
    case eType_Undefined:
        MyAbort();
        /*NOTREACHED*/
    }
}

/* generate function body for components */
void
GenPERFuncComponents(AssignmentList_t ass, char *module, uint32_t optindex, ComponentList_t components, char *valref, char *encref, char *oref, TypeFunc_e et, int inextension, int inchoice)
{
    Component_t *com;
    NamedType_t *namedType;
    char *ide;
    char valbuf[256];
    char typebuf[256];
    int conditional, skip;

    /* get a parented encoding_t/decoding_t for sequence/set */
    if (inextension && !inchoice) {
        switch (et) {
        case eStringTable:
            break;
        case eEncode:
            outputvar("ASN1encoding_t ee;\n");
            output("if (ASN1_CreateEncoder(%s->module, &ee, NULL, 0, %s) < 0)\n",
                encref, encref);
            output("return 0;\n");
            break;
        case eDecode:
            outputvar("ASN1decoding_t dd;\n");
            break;
        }
    }

    /* emit components of extension root */
    for (com = components; com; com = com->Next) {
        if (com->Type == eComponent_ExtensionMarker)
            break;

        /* get some information */
        namedType = com->U.NOD.NamedType;
        ide = Identifier2C(namedType->Identifier);

        /* skip unnecessary elements */
        skip = (namedType->Type->Flags & eTypeFlags_Null) && !inextension;

        /* check if optional/default component is present or choice is */
        /* selected */
        conditional = 0;
        switch (et) {
        case eStringTable:
            break;
        case eEncode:
        case eDecode:
            if (inchoice) {
            // lonchanc: we should not skip any case in Decode
            // because we cannot tell skipped cases from extension.
            // on the other hand, in Encode, we'd better not either.
            // when people put in customization in extension,
            // we cannot tell as well.
                if (skip)
                {
                    output("case %d:\nbreak;\n", optindex);
                }
                else
                {
                    output("case %d:\n", optindex);
                    conditional = 1;
                }
                optindex++;
            } else {
                if (com->Type == eComponent_Optional ||
                    com->Type == eComponent_Default ||
                    inextension) {
                    if (!skip) {
                        output("if (%s[%u] & 0x%x) {\n", oref,
                            optindex / 8, 0x80 >> (optindex & 7));
                        conditional = 1;
                    }
                    optindex++;
                }
            }
            break;
        }

        /* get a parented encoding_t/decoding_t for choice */
        if (inextension && inchoice) {
            /* get a parented encoding_t/decoding_t */
            switch (et) {
            case eStringTable:
                break;
            case eEncode:
                outputvar("ASN1encoding_t ee;\n");
                output("if (ASN1_CreateEncoder(%s->module, &ee, NULL, 0, %s) < 0)\n",
                    encref, encref);
                output("return 0;\n");
                break;
            case eDecode:
                outputvar("ASN1decoding_t dd;\n");
                break;
            }
        }

        /* dereference pointer if pointer directive used */
        if (inchoice) {
            if (GetTypeRules(ass, namedType->Type) & eTypeRules_Pointer)
                sprintf(valbuf, "*(%s)->u.%s", valref, ide);
            else
                sprintf(valbuf, "(%s)->u.%s", valref, ide);
        } else {
            if (GetTypeRules(ass, namedType->Type) & eTypeRules_Pointer)
                sprintf(valbuf, "*(%s)->%s", valref, ide);
            else
                sprintf(valbuf, "(%s)->%s", valref, ide);
        }

        /* allocate memory if decoding and pointer directive used */
        if (et == eDecode &&
            (GetTypeRules(ass, namedType->Type) & eTypeRules_Pointer) &&
            !(GetType(ass, namedType->Type)->Flags & eTypeFlags_Null)) {
            sprintf(typebuf, "%s *",
                GetTypeName(ass, namedType->Type));
            output("if (!(%s = (%s)ASN1DecAlloc(%s, sizeof(%s))))\n",
                Reference(valbuf), typebuf, encref, valbuf);
            output("return 0;\n");
        }

        /* handle subtype value */
        if (!skip) {
            if (!inextension) {
                GenPERFuncSimpleType(ass, &namedType->Type->PERTypeInfo,
                    valbuf, et, encref);
            } else {
                switch (et) {
                case eStringTable:
                    GenPERFuncSimpleType(ass, &namedType->Type->PERTypeInfo,
                        valbuf, et, encref);
                    break;
                case eEncode:
                    GenPERFuncSimpleType(ass, &namedType->Type->PERTypeInfo,
                        valbuf, et, "ee");
                        // lonchanc: added the following API to replace the following
                        // chunk of code.
                        output("if (!ASN1PEREncFlushFragmentedToParent(ee))\n");
                    // output("if (!ASN1PEREncFlush(ee))\n");
                    // output("return 0;\n");
                    // output("if (!ASN1PEREncFragmented(%s, ee->len, ee->buf, 8))\n",
                        // encref);
                    output("return 0;\n");
                    break;
                case eDecode:
                    outputvar("ASN1octet_t *db;\n");
                    outputvar("ASN1uint32_t ds;\n");
                    output("if (!ASN1PERDecFragmented(%s, &ds, &db, 8))\n",
                        encref);
                    output("return 0;\n");
                    output("if (ASN1_CreateDecoderEx(%s->module, &dd, db, ds, %s, ASN1DECODE_AUTOFREEBUFFER) < 0)\n",
                        encref, encref);
                    output("return 0;\n");
                    GenPERFuncSimpleType(ass, &namedType->Type->PERTypeInfo,
                        valbuf, et, "dd");
                    output("ASN1_CloseDecoder(dd);\n");
                    // output("DecMemFree(%s, db);\n", encref);
                    break;
                }
            }
        }

        /* drop the parented encoding_t/decoding_t for choice */
        if (inextension && inchoice) {
            if (et == eEncode) {
                output("ASN1_CloseEncoder2(ee);\n");
            }
        }

        /* end of check for presence of optional/default component */
        if (inchoice) {
            if (conditional)
                output("break;\n");
        } else {
            if (conditional)
                output("}\n");
        }
    }

    /* drop the parented encoding_t/decoding_t for sequence/set */
    if (inextension && !inchoice) {
        if (et == eEncode) {
            output("ASN1_CloseEncoder2(ee);\n");
        }
    }
}

/* generate function body for sequence/set type */
void GenPERFuncSequenceSetType(AssignmentList_t ass, char *module, Assignment_t *at, char *valref, char *encref, TypeFunc_e et)
{
    uint32_t optionals, extensions;
    Component_t *components, *com;
    PERTypeInfo_t inf;
    Type_t *type;
    char valbuf[256];
    int conditional;
    char obuf[256];

    type = at->U.Type.Type;
    optionals = type->U.SSC.Optionals;
    extensions = type->U.SSC.Extensions;
    components = type->U.SSC.Components;
    inf.Identifier = NULL;
    inf.Flags = 0;
    inf.Rules = 0;
    inf.EnumerationValues = NULL;
    inf.NOctets = 0;
    inf.Type = eExtension_Unextended;
    inf.Root.TableIdentifier = NULL;
    inf.Root.Table = NULL;
    inf.Root.Data = ePERSTIData_Extension;
    inf.Root.SubType = NULL;
    inf.Root.SubIdentifier = NULL;
    inf.Root.NBits = 0;
    inf.Root.Constraint = ePERSTIConstraint_Unconstrained;
    intx_setuint32(&inf.Root.LowerVal, 0);
    intx_setuint32(&inf.Root.UpperVal, 0);
    inf.Root.Alignment = ePERSTIAlignment_BitAligned;
    inf.Root.Length = ePERSTILength_NoLength;
    inf.Root.LConstraint = ePERSTIConstraint_Unconstrained;
    inf.Root.LLowerVal = 0;
    inf.Root.LUpperVal = 0;
    inf.Root.LNBits = 0;
    inf.Root.LAlignment = ePERSTIAlignment_OctetAligned;

    /* set/clear missing bits in optional/default bit field */
    GenFuncSequenceSetOptionals(ass, valref, components,
        optionals, extensions, obuf, et);

    /* emit/get extension bit if needed */
    if (type->Flags & eTypeFlags_ExtensionMarker) {
        switch (et) {
        case eStringTable:
            break;
        case eEncode:
            if (type->Flags & eTypeFlags_ExtensionMarker) {
                if (!extensions) {
                    if (g_fCaseBasedOptimizer)
                    {
                        output("if (!ASN1PEREncExtensionBitClear(%s))\n", encref);
                    }
                    else
                    {
                        output("if (!ASN1PEREncBitVal(%s, 1, 0))\n", encref);
                    }
                    output("return 0;\n");
                } else {
                    outputvar("ASN1uint32_t y;\n");
                    output("y = ASN1PEREncCheckExtensions(%d, %s + %d);\n",
                        extensions, strcmp(obuf, "o") ? obuf : "(val)->o", (optionals + 7) / 8);
                    output("if (!ASN1PEREncBitVal(%s, 1, y))\n",
                        encref);
                    output("return 0;\n");
                }
            }
            break;
        case eDecode:
            if (type->Flags & eTypeFlags_ExtensionMarker) {
                outputvar("ASN1uint32_t y;\n");
                if (g_fCaseBasedOptimizer)
                {
                    output("if (!ASN1PERDecExtensionBit(%s, &y))\n", encref);
                }
                else
                {
                    output("if (!ASN1PERDecBit(%s, &y))\n", encref);
                }
                output("return 0;\n");
            }
            break;
        }
    }

    /* emit/get bit field of optionals */
    if (optionals) {
        inf.Root.NBits = optionals;
        inf.Root.Length = ePERSTILength_NoLength;
        if (optionals >= 0x10000)
            MyAbort();
        GenPERFuncSimpleType(ass, &inf, obuf, et, encref);
    }

    /* emit components of extension root */
    GenPERFuncComponents(ass, module, 0, components,
        valref, encref, obuf, et, 0, 0);

    /* handle extensions */
    if (type->Flags & eTypeFlags_ExtensionMarker) {
        conditional = 0;
        if (!extensions) {

            /* skip unknown extension bit field */
            if (et == eDecode) {
                output("if (y) {\n");
                inf.Root.NBits = 1;
                inf.Root.Length = ePERSTILength_SmallLength;
                inf.Root.LConstraint = ePERSTIConstraint_Semiconstrained;
                inf.Root.LLowerVal = 1;
                if (g_fCaseBasedOptimizer)
                {
                    output("if (!ASN1PERDecSkipNormallySmallExtensionFragmented(%s))\n",
                            encref);
                    output("return 0;\n");
                    output("}\n");
                    goto FinalTouch;
                }
                else
                {
                    GenPERFuncSimpleType(ass, &inf, NULL, et, encref);
                    conditional = 1;
                }
            }

        } else {

            /* check if extension bit is set */
            switch (et) {
            case eStringTable:
                break;
            case eEncode:
                output("if (y) {\n");
                conditional = 1;
                break;
            case eDecode:
                output("if (!y) {\n");
                output("ZeroMemory(%s + %d, %d);\n", obuf,
                    (optionals + 7) / 8, (extensions + 7) / 8);
                output("} else {\n");
                conditional = 1;
                break;
            }

            /* emit/get bit field of extensions */
            inf.Root.NBits = extensions;
            inf.Root.Length = ePERSTILength_SmallLength;
            inf.Root.LConstraint = ePERSTIConstraint_Semiconstrained;
            inf.Root.LLowerVal = 1;
            sprintf(valbuf, "%s + %d", obuf, (optionals + 7) / 8);
            GenPERFuncSimpleType(ass, &inf, valbuf, et, encref);

            /* get start of extensions */
            for (com = components; com; com = com->Next) {
                if (com->Type == eComponent_ExtensionMarker) {
                    com = com->Next;
                    break;
                }
            }

            /* emit components of extension */
            GenPERFuncComponents(ass, module, (optionals + 7) & ~7, com,
                valref, encref, obuf, et, 1, 0);
        }

        /* skip unknown extensions */
        if (et == eDecode) {
            outputvar("ASN1uint32_t i;\n");
            outputvar("ASN1uint32_t e;\n");
            output("for (i = 0; i < e; i++) {\n");
            output("if (!ASN1PERDecSkipFragmented(%s, 8))\n",
                encref);
            output("return 0;\n");
            output("}\n");
        }

        /* end of extension handling */
        if (conditional)
            output("}\n");
    }

FinalTouch:

    /* some user-friendly assignments for non-present optional/default */
    /* components */
    GenFuncSequenceSetDefaults(ass, valref, components, obuf, et);
}

/* generate function body for choice type */
void GenPERFuncChoiceType(AssignmentList_t ass, char *module, Assignment_t *at, char *valref, char *encref, TypeFunc_e et)
{
    Type_t *type;
    char valbuf[256];
    uint32_t alternatives;
    Component_t *components, *com;
    int fOptimizeCase = 0;

    /* get some informations */
    type = at->U.Type.Type;
    alternatives = type->U.SSC.Alternatives;
    components = type->U.SSC.Components;

    /* encode choice selector */
    switch (et) {
    case eStringTable:
        sprintf(valbuf, "(%s)->choice", valref);
        break;
    case eEncode:
        sprintf(valbuf, "(%s)->choice", valref);
        if (g_fCaseBasedOptimizer)
        {
            switch (type->PERTypeInfo.Type)
            {
            case eExtension_Unconstrained:
                break;
            case eExtension_Unextended: // no extension mark at all
                output("if (!ASN1PEREncSimpleChoice(%s, %s, %u))\n",
                        encref, valbuf, type->PERTypeInfo.Root.NBits);
                output("return 0;\n");
                fOptimizeCase = 1;
                break;
            case eExtension_Extendable: // extension mark exists, but no choice appears after the mark
                output("if (!ASN1PEREncSimpleChoiceEx(%s, %s, %u))\n",
                        encref, valbuf, type->PERTypeInfo.Root.NBits);
                output("return 0;\n");
                fOptimizeCase = 1;
                break;
            case eExtension_Extended: // extension mark exists, but some choices appear after the mark
                output("if (!ASN1PEREncComplexChoice(%s, %s, %u, %u))\n",
                        encref, valbuf, type->PERTypeInfo.Root.NBits, intx2uint32(&(type->PERTypeInfo.Additional.LowerVal)));
                output("return 0;\n");
                fOptimizeCase = 1;
                break;
            }
        }
        if (ASN1_CHOICE_BASE)
        {
            sprintf(valbuf, "(%s)->choice - %d", valref, ASN1_CHOICE_BASE);
        }
        break;
    case eDecode:
        sprintf(valbuf, "(%s)->choice", valref);
        if (g_fCaseBasedOptimizer)
        {
            switch (type->PERTypeInfo.Type)
            {
            case eExtension_Unconstrained:
                break;
            case eExtension_Unextended: // no extension mark at all
                output("if (!ASN1PERDecSimpleChoice(%s, %s, %u))\n",
                        encref, Reference(valbuf), type->PERTypeInfo.Root.NBits);
                output("return 0;\n");
                fOptimizeCase = 1;
                break;
            case eExtension_Extendable: // extension mark exists, but no choice appears after the mark
                output("if (!ASN1PERDecSimpleChoiceEx(%s, %s, %u))\n",
                        encref, Reference(valbuf), type->PERTypeInfo.Root.NBits);
                output("return 0;\n");
                fOptimizeCase = 1;
                break;
            case eExtension_Extended: // extension mark exists, but some choices appear after the mark
                output("if (!ASN1PERDecComplexChoice(%s, %s, %u, %u))\n",
                        encref, Reference(valbuf), type->PERTypeInfo.Root.NBits, intx2uint32(&(type->PERTypeInfo.Additional.LowerVal)));
                output("return 0;\n");
                fOptimizeCase = 1;
                break;
            }
        }
        break;
    }

    if (! fOptimizeCase)
    {
        if (eDecode == et)
        {
            output("%s = %d;\n", valbuf, ASN1_CHOICE_INVALID);
        }
        GenPERFuncSimpleType(ass, &type->PERTypeInfo, valbuf, et, encref);

        // lonchanc: in case of decoding, we need to increment choice value
        // by the amount of ASN1_CHOICE_BASE
        if (et == eDecode && ASN1_CHOICE_BASE)
        {
            output("(%s)->choice += %d;\n", valref, ASN1_CHOICE_BASE);
        }
    }

    /* finished if choice only contains NULL alternatives or if choice */
    /* contains no data to free */
    if (type->Flags & eTypeFlags_NullChoice)
        return;

    /* create switch statement */
    switch (et) {
    case eStringTable:
        break;
    case eDecode:
    case eEncode:
        output("switch ((%s)->choice) {\n", valref);
        break;
    }

    /* generate components of extension root */
    GenPERFuncComponents(ass, module, ASN1_CHOICE_BASE, components,
        valref, encref, NULL, et, 0, 1);

    /* get start of extensions */
    for (com = components; com; com = com->Next) {
        if (com->Type == eComponent_ExtensionMarker) {
            com = com->Next;
            break;
        }
    }

    /* generate components of extension */
    GenPERFuncComponents(ass, module, ASN1_CHOICE_BASE + alternatives, com,
        valref, encref, NULL, et, 1, 1);

    /* skip unknown extensions */
    if (et == eDecode && (type->Flags & eTypeFlags_ExtensionMarker)) {
        output("case %d:\n\t/* extension case */\n", ASN1_CHOICE_INVALID + 1);
        output("if (!ASN1PERDecSkipFragmented(%s, 8))\n", encref);
        output("return 0;\n");
        output("break;\n");
    }

    // debug purpose
    switch (et)
    {
    case eEncode:
        output("default:\n\t/* impossible */\n");
        output("ASN1EncSetError(%s, ASN1_ERR_CHOICE);\n", encref);
        output("return 0;\n");
        break;
    case eDecode:
        output("default:\n\t/* impossible */\n");
        output("ASN1DecSetError(%s, ASN1_ERR_CHOICE);\n", encref);
        output("return 0;\n");
        break;
    }

    /* end of switch statement */
    switch (et) {
    case eStringTable:
        break;
    case eEncode:
    case eDecode:
        output("}\n");
        break;
    }
}

/* generate function body for simple type */
void
GenPERFuncSimpleType(AssignmentList_t ass, PERTypeInfo_t *info, char *valref, TypeFunc_e et, char *encref)
{
    switch (et) {
    case eStringTable:
        GenPERStringTableSimpleType(ass, info);
        break;
    case eEncode:
        GenPEREncSimpleType(ass, info, valref, encref);
        break;
    case eDecode:
        GenPERDecSimpleType(ass, info, valref, encref);
        break;
    }
}

/* generate string table for a simple type */
void
GenPERStringTableSimpleType(AssignmentList_t ass, PERTypeInfo_t *info)
{
    ValueConstraint_t *pc;
    uint32_t i, n, lo, up;

    switch (info->Root.Data) {
    case ePERSTIData_String:
    case ePERSTIData_TableString:
    case ePERSTIData_ZeroString:
    case ePERSTIData_ZeroTableString:
        if (info->Root.TableIdentifier) {
            if (!strcmp(info->Root.TableIdentifier, "ASN1NumericStringTable"))
                break;
            output("static ASN1stringtableentry_t %sEntries[] = {\n",
                info->Root.TableIdentifier);
            i = n = 0;
            for (pc = info->Root.Table; pc; pc = pc->Next) {
                lo = GetValue(ass, pc->Lower.Value)->
                    U.RestrictedString.Value.value[0];
                up = GetValue(ass, pc->Upper.Value)->
                    U.RestrictedString.Value.value[0];
                output("{ %u, %u, %u }, ", lo, up, n);
                n += (up - lo) + 1;
                i++;
                if ((i & 3) == 3 || !pc->Next)
                    output("\n");
            }
            output("};\n");
            output("\n");
            output("static ASN1stringtable_t %s = {\n",
                info->Root.TableIdentifier);
            output("%d, %sEntries\n", i, info->Root.TableIdentifier);
            output("};\n");
            output("\n");
        }
        break;

    case ePERSTIData_SetOf:
    case ePERSTIData_SequenceOf:
        GenPERFuncSimpleType(ass, &info->Root.SubType->PERTypeInfo, "", eStringTable, "");
        break;
    }
}

/* generate encoding statements for a simple value */
void
GenPEREncSimpleType(AssignmentList_t ass, PERTypeInfo_t *info, char *valref, char *encref)
{
    uint32_t i;
    char lbbuf[256], ubbuf[256];
    char *lenref;
    char lenbuf[256], valbuf[256];
    char *p;
    PERTypeInfo_t inf;

    inf = *info;

    /* examine type for special handling */
    switch (inf.Root.Data) {
    case ePERSTIData_BitString:
    case ePERSTIData_RZBBitString:

        if (inf.Root.cbFixedSizeBitString)
        {
            sprintf(lenbuf, "%u", inf.Root.LUpperVal);
            sprintf(valbuf, "&(%s)", valref);
            lenref = lenbuf;
            valref = valbuf;
            break;
        }

        // lonchanc: intentionally fall through

    case ePERSTIData_OctetString:

        if (g_fCaseBasedOptimizer)
        {
            if (inf.Root.Data == ePERSTIData_OctetString && inf.Type == eExtension_Unextended)
            {
                switch (inf.Root.Length)
                {
                case ePERSTILength_NoLength:
                    if (inf.Root.LConstraint == ePERSTIConstraint_Constrained &&
                        inf.Root.LLowerVal == inf.Root.LUpperVal &&
                        inf.Root.LUpperVal < 64 * 1024)
                    {
                        // fixed size constraint, eg. OCTET STRING (SIZE (8))
                        if (inf.pPrivateDirectives->fLenPtr)
                        {
                            output("if (!ASN1PEREncOctetString_FixedSizeEx(%s, %s, %u))\n",
                                encref, Reference(valref), inf.Root.LLowerVal);
                        }
                        else
                        {
                            output("if (!ASN1PEREncOctetString_FixedSize(%s, (ASN1octetstring2_t *) %s, %u))\n",
                                encref, Reference(valref), inf.Root.LLowerVal);
                        }
                        output("return 0;\n");
                        return;
                    }
                    break;
                case ePERSTILength_Length:
                    break;
                case ePERSTILength_BitLength:
                    if (inf.Root.LConstraint == ePERSTIConstraint_Constrained &&
                        inf.Root.LLowerVal < inf.Root.LUpperVal &&
                        inf.Root.LUpperVal < 64 * 1024)
                    {
                        // variable size constraint, eg. OCTET STRING (SIZE (4..16))
                        if (inf.pPrivateDirectives->fLenPtr)
                        {
                            output("if (!ASN1PEREncOctetString_VarSizeEx(%s, %s, %u, %u, %u))\n",
                                encref, Reference(valref), inf.Root.LLowerVal, inf.Root.LUpperVal, inf.Root.LNBits);
                        }
                        else
                        {
                            output("if (!ASN1PEREncOctetString_VarSize(%s, (ASN1octetstring2_t *) %s, %u, %u, %u))\n",
                                encref, Reference(valref), inf.Root.LLowerVal, inf.Root.LUpperVal, inf.Root.LNBits);
                        }
                        output("return 0;\n");
                        return;
                    }
                    break;
                case ePERSTILength_SmallLength:
                    break;
                case ePERSTILength_InfiniteLength: // no size constraint, eg OCTET STRING
                    /* encode octet string in fragmented format */
                    output("if (!ASN1PEREncOctetString_NoSize(%s, %s))\n",
                        encref, Reference(valref));
                    output("return 0;\n");
                    return;
                } // switch
            } // if
        }

        /* length and value of bit string, octet string and string */
        sprintf(lenbuf, "(%s).length", valref);
        sprintf(valbuf, "(%s).value", valref);
        lenref = lenbuf;
        valref = valbuf;
        break;

    case ePERSTIData_UTF8String:

        /* length and value of bit string, octet string and string */
        sprintf(lenbuf, "(%s).length", valref);
        sprintf(valbuf, "(%s).value", valref);
        lenref = lenbuf;
        valref = valbuf;
        break;

    case ePERSTIData_String:
    case ePERSTIData_TableString:

        /* length and value of bit string, octet string and string */
        sprintf(lenbuf, "(%s).length", valref);
        sprintf(valbuf, "(%s).value", valref);
        lenref = lenbuf;
        valref = valbuf;
        break;

    case ePERSTIData_SequenceOf:
    case ePERSTIData_SetOf:

        if (inf.Rules & eTypeRules_PointerArrayMask)
        {
            /* length and value of sequence of/set of value with */
            /* length-pointer representation */
            if (inf.Rules & eTypeRules_PointerToElement)
            {
                sprintf(lenbuf, "(%s)->count", valref);
                sprintf(valbuf, "(%s)->%s", valref, GetPrivateValueName(inf.pPrivateDirectives, "value"));
            }
            else
            {
                sprintf(lenbuf, "(%s)->count", Reference(valref));
                sprintf(valbuf, "(%s)->%s", Reference(valref), GetPrivateValueName(inf.pPrivateDirectives, "value"));
            }
            lenref = lenbuf;
            valref = valbuf;
        }
        else
        if (inf.Rules & eTypeRules_LinkedListMask)
        {
            /* use a loop for sequence of/set of value with */
            /* list representation */

            if (g_fCaseBasedOptimizer)
            {
                if (PerOptCase_IsTargetSeqOf(&inf))
                {
                    // generate the iterator
                    char szElmFn[128];
                    char szElmFnDecl[256];
                    sprintf(szElmFn, "ASN1Enc_%s_ElmFn", inf.Identifier);
                    sprintf(szElmFnDecl, "int ASN1CALL %s(ASN1encoding_t %s, P%s val)",
                        szElmFn, encref, inf.Identifier);

                    setoutfile(g_finc);
                    output("extern %s;\n", szElmFnDecl);
                    setoutfile(g_fout);

                    if ((inf.Root.LLowerVal == 0 && inf.Root.LUpperVal == 0) ||
                        (inf.Root.LUpperVal >= 64 * 1024)
                       )
                    {
                        output("return ASN1PEREncSeqOf_NoSize(%s, (ASN1iterator_t **) %s, (ASN1iterator_encfn) %s);\n",
                            encref, Reference(valref), szElmFn);
                    }
                    else
                    {
                        if (inf.Root.LLowerVal == inf.Root.LUpperVal)
                            MyAbort();
                        output("return ASN1PEREncSeqOf_VarSize(%s, (ASN1iterator_t **) %s, (ASN1iterator_encfn) %s, %u, %u, %u);\n",
                            encref, Reference(valref), szElmFn,
                            inf.Root.LLowerVal, inf.Root.LUpperVal, inf.Root.LNBits);
                    }
                    output("}\n\n"); // end of iterator body

                    // generate the element function
                    output("static %s\n", szElmFnDecl);
                    output("{\n");
                    sprintf(valbuf, "val->%s", GetPrivateValueName(inf.pPrivateDirectives, "value"));
                    GenPERFuncSimpleType(ass, &inf.Root.SubType->PERTypeInfo, valbuf,
                        eEncode, encref);
                    // end of element body
                    return;
                }
            }

            outputvar("ASN1uint32_t t;\n");
            outputvar("P%s f;\n", inf.Identifier);
            output("for (t = 0, f = %s; f; f = f->next)\n", valref);
            output("t++;\n");
            lenref = "t";

        } else {
            MyAbort();
        }
        break;

    case ePERSTIData_ZeroString:
    case ePERSTIData_ZeroTableString:

        /* length of a zero-terminated string value */
        outputvar("ASN1uint32_t t;\n");
        output("t = lstrlenA(%s);\n", valref);
        lenref = "t";
        break;

    case ePERSTIData_Boolean:

        /* value of a boolean value */

        if (g_fCaseBasedOptimizer)
        {
            if (PerOptCase_IsBoolean(&inf.Root))
            {
                lenref = NULL;
                break;
            }
        }

        sprintf(valbuf, "(%s) ? 1 : 0", valref);
        valref = valbuf;
        lenref = NULL;
        inf.Root.Data = ePERSTIData_Unsigned;
        break;

    default:

        /* other values have no additional length */
        lenref = NULL;
        break;
    }

    /* map enumeration values */
    if (inf.EnumerationValues) {
        outputvar("ASN1uint32_t u;\n");
        output("switch (%s) {\n", valref);
        for (i = 0; inf.EnumerationValues[i]; i++) {
            output("case %u:\n", intx2uint32(inf.EnumerationValues[i]));
            output("u = %u;\n", i);
            output("break;\n");
        }
        output("}\n");
        valref = "u";
        inf.NOctets = 4;
    }

    /* check for extended values */
    if (inf.Type == eExtension_Extended) {
        switch (inf.Root.Data) {
        case ePERSTIData_Integer:
        case ePERSTIData_Unsigned:
            switch (inf.Root.Constraint) {
            case ePERSTIConstraint_Unconstrained:
                inf.Type = eExtension_Extendable;
                break;
            case ePERSTIConstraint_Semiconstrained:
                if (inf.NOctets == 0) {
                    sprintf(lbbuf, "%s_lb", inf.Identifier);
                    outputvarintx(lbbuf, &inf.Root.LowerVal);
                    output("if (ASN1intx_cmp(%s, &%s) >= 0) {\n",
                        Reference(valref), lbbuf);
                } else if (inf.Root.Data == ePERSTIData_Integer) {
                    output("if (%s >= %d) {\n",
                        valref, intx2int32(&inf.Root.LowerVal));
                } else {
                    if (intx2uint32(&inf.Root.LowerVal) > 0) {
                        output("if (%s >= %u) {\n",
                            valref, intx2uint32(&inf.Root.LowerVal));
                    } else {
                        inf.Type = eExtension_Extendable;
                    }
                }
                break;
            case ePERSTIConstraint_Upperconstrained:
                if (inf.NOctets == 0) {
                    sprintf(ubbuf, "%s_ub", inf.Identifier);
                    outputvarintx(ubbuf, &inf.Root.UpperVal);
                    output("if (ASN1intx_cmp(%s, &%s) <= 0) {\n",
                        Reference(valref), ubbuf);
                } else if (inf.Root.Data == ePERSTIData_Integer) {
                    output("if (%s <= %d) {\n",
                        valref, intx2int32(&inf.Root.UpperVal));
                } else {
                    output("if (%s <= %u) {\n",
                        valref, intx2uint32(&inf.Root.UpperVal));
                }
                break;
            case ePERSTIConstraint_Constrained:
                if (inf.NOctets == 0) {
                    sprintf(lbbuf, "%s_lb", inf.Identifier);
                    sprintf(ubbuf, "%s_ub", inf.Identifier);
                    outputvarintx(lbbuf, &inf.Root.LowerVal);
                    outputvarintx(ubbuf, &inf.Root.UpperVal);
                    output("if (ASN1intx_cmp(%s, &%s) >= 0 && ASN1intx_cmp(%s, &%s) <= 0) {\n",
                        Reference(valref), lbbuf, Reference(valref), ubbuf);
                } else if (inf.Root.Data == ePERSTIData_Integer) {
                    output("if (%s >= %d && %s <= %d) {\n",
                        valref, intx2int32(&inf.Root.LowerVal),
                        valref, intx2int32(&inf.Root.UpperVal));
                } else {
                    if (intx2uint32(&inf.Root.LowerVal) > 0) {
                        output("if (%s >= %u && %s <= %u) {\n",
                            valref, intx2uint32(&inf.Root.LowerVal),
                            valref, intx2uint32(&inf.Root.UpperVal));
                    } else {
                        output("if (%s <= %u) {\n",
                            valref, intx2uint32(&inf.Root.UpperVal));
                    }
                }
                break;
            }
            break;
        case ePERSTIData_SequenceOf:
        case ePERSTIData_SetOf:
        case ePERSTIData_OctetString:
        case ePERSTIData_UTF8String:
        case ePERSTIData_BitString:
        case ePERSTIData_RZBBitString:
        case ePERSTIData_Extension:
            switch (inf.Root.LConstraint) {
            case ePERSTIConstraint_Semiconstrained:
                if (inf.Root.LLowerVal != 0) {
                    output("if (%s >= %u) {\n",
                        lenref, inf.Root.LLowerVal);
                } else {
                    inf.Type = eExtension_Extendable;
                }
                break;
            case ePERSTIConstraint_Constrained:
                if (inf.Root.LLowerVal != 0) {
                    output("if (%s >= %u && %s <= %u) {\n",
                        lenref, inf.Root.LLowerVal, lenref, inf.Root.LUpperVal);
                } else {
                    output("if (%s <= %u) {\n",
                        lenref, inf.Root.LUpperVal);
                }
                break;
            }
            break;
        case ePERSTIData_String:
        case ePERSTIData_TableString:
        case ePERSTIData_ZeroString:
        case ePERSTIData_ZeroTableString:
            inf.Type = eExtension_Extendable;
            switch (inf.Root.LConstraint) {
            case ePERSTIConstraint_Semiconstrained:
                if (inf.Root.LLowerVal != 0) {
                    output("if (%s >= %u",
                        lenref, inf.Root.LLowerVal);
                    inf.Type = eExtension_Extended;
                }
                break;
            case ePERSTIConstraint_Constrained:
                output("if (%s >= %u && %s <= %u",
                    lenref, inf.Root.LLowerVal, lenref, inf.Root.LUpperVal);
                inf.Type = eExtension_Extended;
                break;
            }
            if (inf.Root.TableIdentifier) {
                if (inf.Type == eExtension_Extended)
                    output(" && ");
                else
                    output("if (");
                if (inf.NOctets == 1) {
                    p = "Char";
                } else if (inf.NOctets == 2) {
                    p = "Char16";
                } else if (inf.NOctets == 4) {
                    p = "Char32";
                } else
                    MyAbort();
                output("ASN1PEREncCheckTable%sString(%s, %s, %s)",
                    p, lenref, valref, Reference(inf.Root.TableIdentifier));
                inf.Type = eExtension_Extended;
            }
            if (inf.Type == eExtension_Extended)
                output(") {\n");
            break;
        }
    }

    /* encode unset extension bit */
    if (inf.Type > eExtension_Unextended) {
        if (g_fCaseBasedOptimizer)
        {
            output("if (!ASN1PEREncExtensionBitClear(%s))\n", encref);
        }
        else
        {
            output("if (!ASN1PEREncBitVal(%s, 1, 0))\n", encref);
        }
        output("return 0;\n");
    }

    /* encode unextended value (of extension root) */
    GenPEREncGenericUnextended(ass, &inf, &inf.Root, valref, lenref, encref);

    /* type is extended? */
    if (inf.Type == eExtension_Extended) {
        output("} else {\n");

        /* encode set extension bit */
        if (g_fCaseBasedOptimizer)
        {
            output("if (!ASN1PEREncExtensionBitSet(%s))\n", encref);
        }
        else
        {
            output("if (!ASN1PEREncBitVal(%s, 1, 1))\n", encref);
        }
        output("return 0;\n");

        /* encode extended value (of extension addition) */
        GenPEREncGenericUnextended(ass, &inf, &inf.Additional, valref, lenref, encref);
        output("}\n");
    }
}

/* generate encoding statements for a simple value (after some special */
/* handling has been done, esp. the evaluation of the extension) */
void GenPEREncGenericUnextended(AssignmentList_t ass, PERTypeInfo_t *info, PERSimpleTypeInfo_t *sinfo, char *valref, char *lenref, char *encref)
{
    char valbuf[256];
    char *lvref, lvbuf[256];
    char lbbuf[256];
    char *p;

    /* check for empty field */
    if (sinfo->NBits == 0)
        return;

    /* initial calculations for value encoding: */
    /* substract lower bound of constraint/semiconstraint value */
    /* for Integer and NormallySmall */
    switch (sinfo->Constraint) {
    case ePERSTIConstraint_Semiconstrained:
    case ePERSTIConstraint_Constrained:
        switch (sinfo->Data) {
        case ePERSTIData_Integer:
        case ePERSTIData_Unsigned:
        case ePERSTIData_NormallySmall:
            if (!info->NOctets) {

                /* calculate value-lowerbound for intx_t values */
                if (intx_cmp(&sinfo->LowerVal, &intx_0) != 0) {
                    sprintf(lbbuf, "%s_lb", info->Identifier);
                    outputvar("ASN1intx_t newval;\n");
                    outputvarintx(lbbuf, &sinfo->LowerVal);
                    output("ASN1intx_sub(&newval, %s, &%s);\n",
                        Reference(valref), lbbuf);
                    valref = "newval";
                }
            } else if (sinfo->Data == ePERSTIData_Integer) {

                /* calculate value-lowerbound for intx_t values */
                if (intx_cmp(&sinfo->LowerVal, &intx_0)) {
                    char szLowB[24];
                    sprintf(&szLowB[0], "%d", intx2int32(&sinfo->LowerVal));
                    if (szLowB[0] == '-')
                        sprintf(valbuf, "%s + %s", valref, &szLowB[1]); // minus minus become plus
                    else
                        sprintf(valbuf, "%s - %s", valref, &szLowB[0]);
                    valref = valbuf;
                }
            } else {

                /* calculate value-lowerbound for integer values */
                if (intx_cmp(&sinfo->LowerVal, &intx_0)) {
                    sprintf(valbuf, "%s - %u", valref, intx2uint32(&sinfo->LowerVal));
                    valref = valbuf;
                }
            }

            /* semiconstraint/constraint values will be encoded as unsigned */
            if (sinfo->Data == ePERSTIData_Integer)
                sinfo->Data = ePERSTIData_Unsigned;
            break;
        }
        break;
    }

    /* general rules */
    if (sinfo->LAlignment == ePERSTIAlignment_OctetAligned &&
        sinfo->Length == ePERSTILength_BitLength &&
        !(sinfo->LNBits & 7))
        sinfo->Alignment = ePERSTIAlignment_BitAligned;
                                /* octet alignment will be given by length */
    if (sinfo->Length == ePERSTILength_InfiniteLength &&
        (sinfo->Data == ePERSTIData_Integer && info->NOctets == 0 ||
        sinfo->Data == ePERSTIData_Unsigned && info->NOctets == 0 ||
        sinfo->Data == ePERSTIData_BitString ||
        sinfo->Data == ePERSTIData_RZBBitString ||
        sinfo->Data == ePERSTIData_Extension ||
        sinfo->Data == ePERSTIData_OctetString ||
        sinfo->Data == ePERSTIData_UTF8String ||
        sinfo->Data == ePERSTIData_SequenceOf ||
        sinfo->Data == ePERSTIData_SetOf ||
        sinfo->Data == ePERSTIData_String ||
        sinfo->Data == ePERSTIData_TableString ||
        sinfo->Data == ePERSTIData_ZeroString ||
        sinfo->Data == ePERSTIData_ZeroTableString) ||
        sinfo->Data == ePERSTIData_ObjectIdentifier ||
        sinfo->Data == ePERSTIData_Real ||
        sinfo->Data == ePERSTIData_GeneralizedTime ||
        sinfo->Data == ePERSTIData_UTCTime ||
        sinfo->Data == ePERSTIData_External ||
        sinfo->Data == ePERSTIData_EmbeddedPdv ||
        sinfo->Data == ePERSTIData_MultibyteString ||
        sinfo->Data == ePERSTIData_UnrestrictedString ||
        sinfo->Data == ePERSTIData_Open)
        sinfo->LAlignment = sinfo->Alignment = ePERSTIAlignment_BitAligned;
                                /* alignment will be done by encoding fn */
    if (sinfo->Length == ePERSTILength_NoLength ||
        sinfo->Length == ePERSTILength_SmallLength)
        sinfo->LAlignment = ePERSTIAlignment_BitAligned;
                                /* no alignment of no/small length */

    /* special initial calculations */
    switch (sinfo->Data) {
    case ePERSTIData_RZBBitString:

        /* remove trailing zero-bits */
        outputvar("ASN1uint32_t r;\n");
        output("r = %s;\n", lenref);
        output("ASN1PEREncRemoveZeroBits(&r, %s, %u);\n",
            valref, sinfo->LLowerVal);
        if (sinfo->LLowerVal) {
            outputvar("ASN1uint32_t s;\n");
            output("s = r < %u ? %u : r;\n", sinfo->LLowerVal, sinfo->LLowerVal);
            lenref = "s";
        } else {
            lenref = "r";
        }
            break;
    }

    if (g_fCaseBasedOptimizer)
    {
        // lonchanc: special handling for macro operations
        if (PerOptCase_IsSignedInteger(sinfo))
        {
            output("if (!ASN1PEREncInteger(%s, %s))\n", encref, valref);
            output("return 0;\n");
            return;
        }
        if (PerOptCase_IsUnsignedInteger(sinfo))
        {
            output("if (!ASN1PEREncUnsignedInteger(%s, %s))\n", encref, valref);
            output("return 0;\n");
            return;
        }
        if (PerOptCase_IsUnsignedShort(sinfo))
        {
            output("if (!ASN1PEREncUnsignedShort(%s, %s))\n", encref, valref);
            output("return 0;\n");
            return;
        }
        if (PerOptCase_IsBoolean(sinfo))
        {
            output("if (!ASN1PEREncBoolean(%s, %s))\n", encref, valref);
            output("return 0;\n");
            return;
        }
    }

    /* initial calculations for length: */
    /* get length of integer numbers if length req. */
    switch (sinfo->Length) {
    case ePERSTILength_BitLength:
    case ePERSTILength_InfiniteLength:
        switch (sinfo->Constraint) {
        case ePERSTIConstraint_Unconstrained:
        case ePERSTIConstraint_Upperconstrained:
            switch (sinfo->Data) {
            case ePERSTIData_Integer:
            case ePERSTIData_Unsigned:
                if (info->NOctets != 0) {
                    outputvar("ASN1uint32_t l;\n");
                    if (sinfo->Data == ePERSTIData_Integer)
                        output("l = ASN1int32_octets(%s);\n", valref);
                    else
                        output("l = ASN1uint32_octets(%s);\n", valref);
                    lenref = "l";
                } else {
                    if (sinfo->Length != ePERSTILength_InfiniteLength) {
                        outputvar("ASN1uint32_t l;\n");
                        output("l = ASN1intx_octets(%s);\n",
                            Reference(valref));
                        lenref = "l";
                    }
                }
                break;
            }
            break;
        case ePERSTIConstraint_Semiconstrained:
        case ePERSTIConstraint_Constrained:
            switch (sinfo->Data) {
            case ePERSTIData_Integer:
            case ePERSTIData_Unsigned:
                if (info->NOctets != 0) {
                    outputvar("ASN1uint32_t l;\n");
                    output("l = ASN1uint32_uoctets(%s);\n", valref);
                    lenref = "l";
                } else {
                    if (sinfo->Length != ePERSTILength_InfiniteLength) {
                        outputvar("ASN1uint32_t l;\n");
                        output("l = ASN1intx_uoctets(%s);\n",
                            Reference(valref));
                        lenref = "l";
                    }
                }
                break;
            }
            break;
        }
        break;
    }

    /* initial settings for length enconding: */
    /* substract lower bound of length from length */
    if (sinfo->LLowerVal != 0 && lenref) {
        sprintf(lvbuf, "%s - %u", lenref, sinfo->LLowerVal);
        lvref = lvbuf;
    } else {
        lvref = lenref;
    }

    /* length encoding */
    if (sinfo->LAlignment == ePERSTIAlignment_OctetAligned) {
        output("ASN1PEREncAlignment(%s);\n", encref);
    }
    switch (sinfo->Length) {
    case ePERSTILength_NoLength:

        /* not length used */
        break;

    case ePERSTILength_BitLength:

        /* length will be encoded in a bit field */
        output("if (!ASN1PEREncBitVal(%s, %u, %s))\n",
            encref, sinfo->LNBits, lvref);
        output("return 0;\n");
        break;

    case ePERSTILength_InfiniteLength:

        /* infinite length case: encode length only for integer values, */
        /* other length encodings will be the encoding function */
        switch (sinfo->Data) {
        case ePERSTIData_Integer:
        case ePERSTIData_Unsigned:
            if (info->NOctets != 0) {
                output("if (!ASN1PEREncBitVal(%s, 8, %s))\n",
                    encref, lvref);
                output("return 0;\n");
            }
            break;
        }
        break;
    }

    /* special initial calculations */
    switch (sinfo->Data) {
    case ePERSTIData_RZBBitString:

        /* real length of the bit string */
        lenref = "r";
        break;
    }

    /* value encoding */
    switch (sinfo->Length) {
    case ePERSTILength_NoLength:

        /* encode alignment of the value */
        if (sinfo->Alignment == ePERSTIAlignment_OctetAligned) {
            output("ASN1PEREncAlignment(%s);\n", encref);
        }

        switch (sinfo->Data) {
        case ePERSTIData_Integer:
        case ePERSTIData_Unsigned:

            /* encode the value as bit field */
            if (info->NOctets != 0) {
                output("if (!ASN1PEREncBitVal(%s, %u, %s))\n",
                    encref, sinfo->NBits, valref);
                output("return 0;\n");
            } else {
                output("if (!ASN1PEREncBitIntx(%s, %u, %s))\n",
                    encref, sinfo->NBits, Reference(valref));
                output("return 0;\n");
            }
            break;

        case ePERSTIData_NormallySmall:

            /* encode the value as normally small number */
            output("if (!ASN1PEREncNormallySmall(%s, %s))\n",
                encref, valref);
            output("return 0;\n");
            break;

        case ePERSTIData_BitString:
        case ePERSTIData_RZBBitString:

            /* encode bit string in a bit field */
            output("if (!ASN1PEREncBits(%s, %s, %s))\n",
                encref, lenref, valref);
            output("return 0;\n");
            break;

        case ePERSTIData_OctetString:

            /* encode octet string in a bit field */
            output("if (!ASN1PEREncBits(%s, %s * 8, %s))\n",
                encref, lenref, valref);
            output("return 0;\n");
            break;

        case ePERSTIData_UTF8String:

            /* encode octet string in a bit field */
            output("if (!ASN1PEREncUTF8String(%s, %s, %s))\n",
                encref, lenref, valref);
            output("return 0;\n");
            break;

        case ePERSTIData_Extension:

            /* encode extension bits in a bit field */
            output("if (!ASN1PEREncBits(%s, %u, %s))\n",
                encref, sinfo->NBits, valref);
            output("return 0;\n");
            break;

        case ePERSTIData_SetOf:

            /* same as BitLength encoding */
            goto SetOfEncoding;

        case ePERSTIData_SequenceOf:

            /* same as BitLength encoding */
            goto SequenceOfEncoding;

        case ePERSTIData_String:
        case ePERSTIData_ZeroString:

            /* same as BitLength encoding */
            goto StringEncoding;

        case ePERSTIData_TableString:
        case ePERSTIData_ZeroTableString:

            /* same as BitLength encoding */
            goto TableStringEncoding;

        case ePERSTIData_Reference:

            /* call encoding function of referenced type */
            output("if (!ASN1Enc_%s(%s, %s))\n",
                Identifier2C(sinfo->SubIdentifier),
                encref, Reference(valref));
            output("return 0;\n");
            break;

        case ePERSTIData_Real:

            /* encode real value */
            if (info->NOctets)
                output("if (!ASN1PEREncDouble(%s, %s))\n",
                    encref, valref);
            else
                output("if (!ASN1PEREncReal(%s, %s))\n",
                    encref, Reference(valref));
            output("return 0;\n");
            break;

        case ePERSTIData_GeneralizedTime:

            /* encode generalized time value */
            output("if (!ASN1PEREncGeneralizedTime(%s, %s, %d))\n",
                encref, Reference(valref), sinfo->NBits);
            output("return 0;\n");
            break;

        case ePERSTIData_UTCTime:

            /* encode utc time value */
            output("if (!ASN1PEREncUTCTime(%s, %s, %d))\n",
                encref, Reference(valref), sinfo->NBits);
            output("return 0;\n");
            break;
        }
        break;

    case ePERSTILength_BitLength:

        /* encode alignment of the value */
        if (sinfo->Alignment == ePERSTIAlignment_OctetAligned) {
            output("ASN1PEREncAlignment(%s);\n", encref);
        }

        switch (sinfo->Data) {
        case ePERSTIData_Integer:
        case ePERSTIData_Unsigned:

            /* encode the value as bit field */
            if (info->NOctets != 0) {
                output("if (!ASN1PEREncBitVal(%s, %s * 8, %s))\n",
                    encref, lenref, valref);
                output("return 0;\n");
            } else {
                output("if (!ASN1PEREncBitIntx(%s, %s * 8, %s))\n",
                    encref, lenref, Reference(valref));
                output("return 0;\n");
            }
            break;

        case ePERSTIData_BitString:
        case ePERSTIData_RZBBitString:

            /* encode the value as bit field */
            output("if (!ASN1PEREncBits(%s, %s, %s))\n",
                encref, lenref, valref);
            output("return 0;\n");
            break;

        case ePERSTIData_OctetString:

            /* encode the value as bit field */
            output("if (!ASN1PEREncBits(%s, %s * 8, %s))\n",
                encref, lenref, valref);
            output("return 0;\n");
            break;

        case ePERSTIData_UTF8String:

            /* encode the value as bit field */
            output("if (!ASN1PEREncUTF8String(%s, %s, %s))\n",
                encref, lenref, valref);
            output("return 0;\n");
            break;

        case ePERSTIData_SetOf:
        SetOfEncoding:

            /* skip null set of */
            if (sinfo->SubType->Flags & eTypeFlags_Null)
                break;

            /* canonical PER? */
            if (g_eSubEncodingRule == eSubEncoding_Canonical) {

                /* encode the elements one by one and sort them */
                outputvar("ASN1uint32_t i;\n");
                outputvar("ASN1encoding_t e, *p;\n");
                if (info->Rules &
                    (eTypeRules_SinglyLinkedList | eTypeRules_DoublyLinkedList))
                    MyAbort(); /*XXX*/
                output("if (%s) {\n", lenref);
                output("e = p = (ASN1encoding_t)malloc(%s * sizeof(ASN1encoding_t));\n",
                    lenref);
                output("ZeroMemory(b, %s * sizeof(ASN1encoding_t));\n", lenref);
                output("for (i = 0; i < %s; i++, p++) {\n", lenref);
                sprintf(valbuf, "(%s)[i]", valref);
                GenPERFuncSimpleType(ass, &sinfo->SubType->PERTypeInfo, valbuf, eEncode, encref);
                output("}\n");
                output("qsort(e, %s, sizeof(ASN1encoding_t), ASN1PEREncCmpEncodings);\n",
                    lenref);
                output("}\n");

                /* then dump them */
                output("for (p = e, i = 0; i < %s; i++, p++) {\n", lenref);
                output("if (!ASN1PEREncBits(%s, (p->pos - p->buf) * 8 + p->bit, p->buf))\n",
                    encref);
                output("return 0;\n");
                output("}\n");
                break;
            }

            /* again in non-canonical PER: */
            /*FALLTHROUGH*/
        case ePERSTIData_SequenceOf:
        SequenceOfEncoding:

            /* skip null sequence of */
            if (sinfo->SubType->Flags & eTypeFlags_Null)
                break;

            if (info->Rules & eTypeRules_PointerArrayMask)
            {
                /* loop over all elements */
                outputvar("ASN1uint32_t i;\n");
                output("for (i = 0; i < %s; i++) {\n", lenref);
                sprintf(valbuf, "(%s)[i]", valref);

            }
            else
            if (info->Rules & eTypeRules_LinkedListMask)
            {
                /* iterate over all elements */
                outputvar("P%s f;\n", info->Identifier);
                output("for (f = %s; f; f = f->next) {\n", valref);
                sprintf(valbuf, "f->%s", GetPrivateValueName(info->pPrivateDirectives, "value"));
            }

            /* encode the element */
            GenPERFuncSimpleType(ass, &sinfo->SubType->PERTypeInfo, valbuf,
                eEncode, encref);

            /* loop end */
            output("}\n");
            break;

        case ePERSTIData_String:
        case ePERSTIData_ZeroString:
        StringEncoding:

            /* encode string value */
            if (info->NOctets == 1) {
                p = "Char";
            } else if (info->NOctets == 2) {
                p = "Char16";
            } else if (info->NOctets == 4) {
                p = "Char32";
            } else
                MyAbort();
            output("if (!ASN1PEREnc%sString(%s, %s, %s, %u))\n",
                p, encref, lenref, valref, sinfo->NBits);
            output("return 0;\n");
            break;

        case ePERSTIData_TableString:
        case ePERSTIData_ZeroTableString:
        TableStringEncoding:

            /* encode table string value */
            if (info->NOctets == 1) {
                p = "Char";
            } else if (info->NOctets == 2) {
                p = "Char16";
            } else if (info->NOctets == 4) {
                p = "Char32";
            } else
                MyAbort();
            output("if (!ASN1PEREncTable%sString(%s, %s, %s, %u, %s))\n",
                p, encref, lenref, valref, sinfo->NBits, Reference(sinfo->TableIdentifier));
            output("return 0;\n");
            break;
        }
        break;

    case ePERSTILength_InfiniteLength:
        /* infinite length case */

        switch (sinfo->Data) {
        case ePERSTIData_Integer:
        case ePERSTIData_Unsigned:

            /* encode an integer in fragmented format */
            if (info->NOctets != 0) {
                output("if (!ASN1PEREncBitVal(%s, %s * 8, %s))\n",
                    encref, lenref, valref);
                output("return 0;\n");
            } else {
                if (sinfo->Data == ePERSTIData_Integer) {
                    output("if (!ASN1PEREncFragmentedIntx(%s, %s))\n",
                        encref, Reference(valref));
                    output("return 0;\n");
                } else {
                    output("if (!ASN1PEREncFragmentedUIntx(%s, %s))\n",
                        encref, Reference(valref));
                    output("return 0;\n");
                }
            }
            break;

        case ePERSTIData_BitString:
        case ePERSTIData_RZBBitString:

            /* encode bit string in fragmented format */
            output("if (!ASN1PEREncFragmented(%s, %s, %s, 1))\n",
                encref, lenref, valref);
            output("return 0;\n");
            break;

        case ePERSTIData_OctetString:

            /* encode octet string in fragmented format */
            output("if (!ASN1PEREncFragmented(%s, %s, %s, 8))\n",
                encref, lenref, valref);
            output("return 0;\n");
            break;

        case ePERSTIData_UTF8String:

            /* encode octet string in fragmented format */
            output("if (!ASN1PEREncUTF8String(%s, %s, %s))\n",
                encref, lenref, valref);
            output("return 0;\n");
            break;

        case ePERSTIData_Extension:

            /* encode extension bits in fragmented format */
            output("if (!ASN1PEREncFragmented(%s, %u, %s, 1))\n",
                encref, sinfo->NBits, valref);
            output("return 0;\n");
            break;

        case ePERSTIData_SetOf:

            /* skip null set of */
            if (sinfo->SubType->Flags & eTypeFlags_Null)
                break;

            /* canonical PER? */
            if (g_eSubEncodingRule == eSubEncoding_Canonical) {

                /* encode the elements one by one and sort them */
                outputvar("ASN1uint32_t i;\n");
                outputvar("ASN1uint32_t j, n = 0x4000;\n");
                outputvar("ASN1encoding_t e, *p;\n");
                if (info->Rules &
                    (eTypeRules_SinglyLinkedList | eTypeRules_DoublyLinkedList))
                    MyAbort(); /*XXX*/
                output("if (%s) {\n", lenref);
                output("e = p = (ASN1encoding_t)malloc(%s * sizeof(ASN1encoding_t));\n",
                    lenref);
                output("ZeroMemory(b, %s * sizeof(ASN1encoding_t));\n", lenref);
                output("for (i = 0; i < %s; i++, p++) {\n", lenref);
                sprintf(valbuf, "(%s)[i]", valref);
                GenPERFuncSimpleType(ass, &sinfo->SubType->PERTypeInfo, valbuf, eEncode, encref);
                output("}\n");
                output("qsort(e, %s, sizeof(ASN1encoding_t), ASN1PEREncCmpEncodings);\n",
                    lenref);
                output("}\n");

                /* then dump them */
                output("for (p = e, i = 0; i < %s; i += n) {\n", lenref);
                output("if (!ASN1PEREncFragmentedLength(&n, %s, %s - i))\n",
                    encref, lenref);
                output("return 0;\n");
                output("for (j = 0; j < n; p++, j++) {\n");
                output("if (!ASN1PEREncBits(%s, (p->pos - p->buf) * 8 + p->bit, p->buf))\n",
                    encref);
                output("return 0;\n");
                output("}\n");
                output("}\n");
                output("}\n");
                output("if (n >= 0x4000) {\n");
                output("if (!ASN1PEREncFragmentedLength(&n, %s, 0))\n",
                    encref);
                output("return 0;\n");
                output("}\n");
                break;
            }

            /* again in non-canonical PER: */
            /*FALLTHROUGH*/
        case ePERSTIData_SequenceOf:

            /* skip null sequence of */
            if (sinfo->SubType->Flags & eTypeFlags_Null)
                break;
            outputvar("ASN1uint32_t i;\n");
            outputvar("ASN1uint32_t j, n = 0x4000;\n");

            if (info->Rules &
                (eTypeRules_SinglyLinkedList | eTypeRules_DoublyLinkedList)) {

                /* additional iterator needed */
                outputvar("P%s f;\n", info->Identifier);
                output("f = %s;\n", valref);
            }

            /* encode all elements */
            output("for (i = 0; i < %s;) {\n", lenref);

            /* encode fragmented length */
            output("if (!ASN1PEREncFragmentedLength(&n, %s, %s - i))\n",
                encref, lenref);
            output("return 0;\n");

            /* encode elements of the fragment */
            output("for (j = 0; j < n; i++, j++) {\n");
            if (info->Rules & eTypeRules_PointerArrayMask)
            {
                sprintf(valbuf, "(%s)[i]", valref);
            }
            else if (info->Rules & eTypeRules_LinkedListMask)
            {
                sprintf(valbuf, "f->%s", GetPrivateValueName(info->pPrivateDirectives, "value"));
            }
            else
            {
                MyAbort();
            }
            GenPERFuncSimpleType(ass, &sinfo->SubType->PERTypeInfo, valbuf,
                eEncode, encref);

            /* advance the iterator */
            if (info->Rules & eTypeRules_LinkedListMask)
            {
                output("f = f->next;\n");
            }

            /* end of inner loop */
            output("}\n");

            /* end of outer loop */
            output("}\n");

            /* add an zero-sized fragment if needed */
            output("if (n >= 0x4000) {\n");
            output("if (!ASN1PEREncFragmentedLength(&n, %s, 0))\n",
                encref);
            output("return 0;\n");
            output("}\n");
            break;

        case ePERSTIData_ObjectIdentifier:

            if (info->pPrivateDirectives->fOidArray || g_fOidArray)
            {
                /* encode object identifier value */
                output("if (!ASN1PEREncObjectIdentifier2(%s, %s))\n",
                    encref, Reference(valref));
            }
            else
            {
                /* encode object identifier value */
                output("if (!ASN1PEREncObjectIdentifier(%s, %s))\n",
                    encref, Reference(valref));
            }
            output("return 0;\n");
            break;

        case ePERSTIData_External:

            /* encode external value */
            output("if (!ASN1PEREncExternal(%s, %s))\n",
                encref, Reference(valref));
            output("return 0;\n");
            break;

        case ePERSTIData_EmbeddedPdv:

            /* encode embedded pdv value */
            if (sinfo->Identification) {
                output("if (!ASN1PEREncEmbeddedPdvOpt(%s, %s))\n",
                    encref, Reference(valref));
            } else {
                output("if (!ASN1PEREncEmbeddedPdv(%s, %s))\n",
                    encref, Reference(valref));
            }
            output("return 0;\n");
            break;

        case ePERSTIData_MultibyteString:

            /* encode multibyte string value */
            output("if (!ASN1PEREncMultibyteString(%s, %s))\n",
                encref, valref);
            output("return 0;\n");
            break;

        case ePERSTIData_UnrestrictedString:

            /* encode character string value */
            if (sinfo->Identification) {
                output("if (!ASN1PEREncCharacterStringOpt(%s, %s))\n",
                    encref, Reference(valref));
            } else {
                output("if (!ASN1PEREncCharacterString(%s, %s))\n",
                    encref, Reference(valref));
            }
            output("return 0;\n");
            break;

        case ePERSTIData_String:
        case ePERSTIData_ZeroString:

            /* encode string value */
            if (info->NOctets == 1) {
                p = "Char";
            } else if (info->NOctets == 2) {
                p = "Char16";
            } else if (info->NOctets == 4) {
                p = "Char32";
            } else
                MyAbort();
            output("if (!ASN1PEREncFragmented%sString(%s, %s, %s, %u))\n",
                p, encref, lenref, valref, sinfo->NBits);
            output("return 0;\n");
            break;

        case ePERSTIData_TableString:
        case ePERSTIData_ZeroTableString:

            /* encode table string value */
            if (info->NOctets == 1) {
                p = "Char";
            } else if (info->NOctets == 2) {
                p = "Char16";
            } else if (info->NOctets == 4) {
                p = "Char32";
            } else
                MyAbort();
            output("if (!ASN1PEREncFragmentedTable%sString(%s, %s, %s, %u, %s))\n",
                p, encref, lenref, valref, sinfo->NBits, Reference(sinfo->TableIdentifier));
            output("return 0;\n");
            break;

        case ePERSTIData_Open:

            /* encode open type value */
            output("if (!ASN1PEREncOpenType(%s, %s))\n",
                encref, Reference(valref));
            output("return 0;\n");
            break;
        }
        break;

    case ePERSTILength_SmallLength:
        /* small length */

        switch (sinfo->Data) {
        case ePERSTIData_Extension:
            /* encode extension bits with normally small length */
            output("if (!ASN1PEREncNormallySmallBits(%s, %u, %s))\n",
                encref, sinfo->NBits, valref);
            output("return 0;\n");
            break;
        }
    }

    switch (sinfo->Data) {
    case ePERSTIData_RZBBitString:

        /* encode additional zero bits for remove zero bits bit string */
        /* of short length */
        if (sinfo->LLowerVal) {
            output("if (%s < %u) {\n", lenref, sinfo->LLowerVal);
            output("if (!ASN1PEREncZero(%s, %u - %s))\n",
                encref, sinfo->LLowerVal, lenref);
            output("return 0;\n");
            output("}\n");
        }
    }

    /* free calculated intx_t value */
    switch (sinfo->Constraint) {
    case ePERSTIConstraint_Semiconstrained:
    case ePERSTIConstraint_Constrained:
        switch (sinfo->Data) {
        case ePERSTIData_Integer:
        case ePERSTIData_Unsigned:
        case ePERSTIData_NormallySmall:
            if (!info->NOctets) {
                if (intx_cmp(&sinfo->LowerVal, &intx_0) != 0) {
                    output("ASN1intx_free(&newval);\n");
                }
            }
            break;
        }
        break;
    }
}

/* generate decoding statements for a simple value */
void
GenPERDecSimpleType(AssignmentList_t ass, PERTypeInfo_t *info, char *valref, char *encref)
{
    uint32_t i;
    char *oldvalref;
    char valbuf[256], lenbuf[256];
    char *lenref;
    PERTypeInfo_t inf;

    inf = *info;

    /* examine type for special handling */
    switch (inf.Root.Data) {
    case ePERSTIData_BitString:
    case ePERSTIData_RZBBitString:

        if (inf.Root.cbFixedSizeBitString)
        {
            sprintf(lenbuf, "%u", inf.Root.LUpperVal);
            sprintf(valbuf, "%s", valref);
            lenref = lenbuf;
            valref = valbuf;
            break;
        }

        // lonchanc: intentionally fall through

    case ePERSTIData_OctetString:

        if (g_fCaseBasedOptimizer)
        {
            if (inf.Root.Data == ePERSTIData_OctetString && inf.Type == eExtension_Unextended)
            {
                switch (inf.Root.Length)
                {
                case ePERSTILength_NoLength:
                    if (inf.Root.LConstraint == ePERSTIConstraint_Constrained &&
                        inf.Root.LLowerVal == inf.Root.LUpperVal &&
                        inf.Root.LUpperVal < 64 * 1024)
                    {
                        // fixed size constraint, eg. OCTET STRING (SIZE (8))
                        if (inf.pPrivateDirectives->fLenPtr)
                        {
                            output("if (!ASN1PERDecOctetString_FixedSizeEx(%s, %s, %u))\n",
                                encref, Reference(valref), inf.Root.LLowerVal);
                        }
                        else
                        {
                            output("if (!ASN1PERDecOctetString_FixedSize(%s, (ASN1octetstring2_t *) %s, %u))\n",
                                encref, Reference(valref), inf.Root.LLowerVal);
                        }
                        output("return 0;\n");
                        return;
                    }
                    break;
                case ePERSTILength_Length:
                    break;
                case ePERSTILength_BitLength:
                    if (inf.Root.LConstraint == ePERSTIConstraint_Constrained &&
                        inf.Root.LLowerVal < inf.Root.LUpperVal &&
                        inf.Root.LUpperVal < 64 * 1024)
                    {
                        // variable size constraint, eg. OCTET STRING (SIZE (4..16))
                        if (inf.pPrivateDirectives->fLenPtr)
                        {
                            output("if (!ASN1PERDecOctetString_VarSizeEx(%s, %s, %u, %u, %u))\n",
                                encref, Reference(valref), inf.Root.LLowerVal, inf.Root.LUpperVal, inf.Root.LNBits);
                        }
                        else
                        {
                            output("if (!ASN1PERDecOctetString_VarSize(%s, (ASN1octetstring2_t *) %s, %u, %u, %u))\n",
                                encref, Reference(valref), inf.Root.LLowerVal, inf.Root.LUpperVal, inf.Root.LNBits);
                        }
                        output("return 0;\n");
                        return;
                    }
                    break;
                case ePERSTILength_SmallLength:
                    break;
                case ePERSTILength_InfiniteLength: // no size constraint
                    /* get octet string as fragmented */
                    if (valref)
                    {
                        output("if (!ASN1PERDecOctetString_NoSize(%s, %s))\n",
                            encref, Reference(valref));
                        output("return 0;\n");
                        return;
                    }
                    break;
               } // switch
           } // if
        }

        /* length and value of bit string/octet string/string value */
        sprintf(lenbuf, "(%s).length", valref);
        sprintf(valbuf, "(%s).value", valref);
        lenref = lenbuf;
        valref = valbuf;
        break;

    case ePERSTIData_UTF8String:

        /* length and value of bit string/octet string/string value */
        sprintf(lenbuf, "(%s).length", valref);
        sprintf(valbuf, "(%s).value", valref);
        lenref = lenbuf;
        valref = valbuf;
        break;

    case ePERSTIData_String:
    case ePERSTIData_TableString:

        /* length and value of bit string/octet string/string value */
        sprintf(lenbuf, "(%s).length", valref);
        sprintf(valbuf, "(%s).value", valref);
        lenref = lenbuf;
        valref = valbuf;
        break;

    case ePERSTIData_SequenceOf:
    case ePERSTIData_SetOf:

        if (inf.Rules & eTypeRules_PointerArrayMask)
        {
            /* length and value of sequence of/set of value with */
            /* length-pointer representation */
            if (inf.Rules & eTypeRules_PointerToElement)
            {
                sprintf(lenbuf, "(%s)->count", valref);
                sprintf(valbuf, "(%s)->%s", valref, GetPrivateValueName(inf.pPrivateDirectives, "value"));
            }
            else
            {
                sprintf(lenbuf, "(%s)->count", Reference(valref));
                sprintf(valbuf, "(%s)->%s", Reference(valref), GetPrivateValueName(inf.pPrivateDirectives, "value"));
            }
            lenref = lenbuf;
            valref = valbuf;
        }
        else
        if (inf.Rules & eTypeRules_LinkedListMask)
        {
            if (g_fCaseBasedOptimizer)
            {
                if (PerOptCase_IsTargetSeqOf(&inf))
                {
                    // generate the iterator
                    char szElmFn[128];
                    char szElmFnDecl[256];
                    sprintf(szElmFn, "ASN1Dec_%s_ElmFn", inf.Identifier);
                    sprintf(szElmFnDecl, "int ASN1CALL %s(ASN1decoding_t %s, P%s val)",
                        szElmFn, encref, inf.Identifier);

                    setoutfile(g_finc);
                    output("extern %s;\n", szElmFnDecl);
                    setoutfile(g_fout);

                    if ((inf.Root.LLowerVal == 0 && inf.Root.LUpperVal == 0) ||
                        (inf.Root.LUpperVal >= 64 * 1024)
                       )
                    {
                        output("return ASN1PERDecSeqOf_NoSize(%s, (ASN1iterator_t **) %s, (ASN1iterator_decfn) %s, sizeof(*%s));\n",
                            encref, Reference(valref), szElmFn, valref);
                    }
                    else
                    {
                        if (inf.Root.LLowerVal == inf.Root.LUpperVal)
                            MyAbort();
                        output("return ASN1PERDecSeqOf_VarSize(%s, (ASN1iterator_t **) %s, (ASN1iterator_decfn) %s, sizeof(*%s), %u, %u, %u);\n",
                            encref, Reference(valref), szElmFn, valref,
                            inf.Root.LLowerVal, inf.Root.LUpperVal, inf.Root.LNBits);
                    }
                    output("}\n\n"); // end of iterator body

                    // generate the element function
                    output("static %s\n", szElmFnDecl);
                    output("{\n");
                    sprintf(valbuf, "val->%s", GetPrivateValueName(inf.pPrivateDirectives, "value"));
                    GenPERFuncSimpleType(ass, &inf.Root.SubType->PERTypeInfo, valbuf,
                            eDecode, encref);
                    // end of element body
                    return;
                }
            }

            /* use a loop for sequence of/set of value with */
            /* list representation */
            outputvar("P%s *f;\n", inf.Identifier);
            lenref = NULL;

        } else {
            MyAbort();
        }
        break;

    case ePERSTIData_Extension:

        /* length of extension */
        if (inf.Root.Length == ePERSTILength_SmallLength)
            lenref = "e";
            else
            lenref = NULL;
        break;

    case ePERSTIData_Boolean:

        if (g_fCaseBasedOptimizer)
        {
            if (PerOptCase_IsBoolean(&inf.Root))
            {
                lenref = NULL;
                break;
            }
        }

        /* boolean value */
        inf.Root.Data = ePERSTIData_Unsigned;
        lenref = NULL;
        break;

    default:

        /* other values have no additional length */
        lenref = NULL;
        break;
    }

    /* check for extended values */
    if (inf.Type > eExtension_Unextended) {
        outputvar("ASN1uint32_t x;\n");
        if (g_fCaseBasedOptimizer)
        {
            output("if (!ASN1PERDecExtensionBit(%s, &x))\n", encref);
        }
        else
        {
            output("if (!ASN1PERDecBit(%s, &x))\n", encref);
        }
        output("return 0;\n");
        output("if (!x) {\n");
    }

    /* additional variable for enumeraton value mapping */
    oldvalref = valref;
    if (inf.EnumerationValues && valref) {
        outputvar("ASN1uint32_t u;\n");
        valref = "u";
        inf.NOctets = 4;
    }

    /* decode unextended value (of extension root) */
    GenPERDecGenericUnextended(ass, &inf, &inf.Root, valref, lenref, encref);

    /* map enumeration values if type is extendable */
    if (inf.EnumerationValues && oldvalref &&
        inf.Type == eExtension_Extendable) {
        output("switch (u) {\n");
        for (i = 0; inf.EnumerationValues[i]; i++) {
            output("case %u:\n", i);
            output("%s = %u;\n", oldvalref, intx2uint32(inf.EnumerationValues[i]));
            output("break;\n");
        }
        output("}\n");
    }

    /* type is extendable? */
    if (inf.Type > eExtension_Unextended) {
        output("} else {\n");
        if (inf.Type == eExtension_Extendable)
            valref = lenref = NULL;

        /* decode extended value (of extension addition) */
        GenPERDecGenericUnextended(ass, &inf, &inf.Additional, valref, lenref, encref);
        output("}\n");
    }

    /* map enumeration values if type is unextended/extended */
    if (inf.EnumerationValues && oldvalref &&
        inf.Type != eExtension_Extendable) {
        output("switch (u) {\n");
        for (i = 0; inf.EnumerationValues[i]; i++) {
            output("case %u:\n", i);
            output("%s = %u;\n", oldvalref, intx2uint32(inf.EnumerationValues[i]));
            output("break;\n");
        }
        output("}\n");
    }
}

/* generate decoding statements for a simple value (after some special */
/* handling has been done, esp. the evaluation of the extension) */
void GenPERDecGenericUnextended(
    AssignmentList_t ass,
    PERTypeInfo_t *info,
    PERSimpleTypeInfo_t *sinfo,
    char *valref,
    char *lenref,
    char *encref)
{
    char valbuf[256];
    char lenbuf[256];
    char lbbuf[256];
    char *p;
    char *oldvalref;
    intx_t ix;

    /* check for empty field */
    if (sinfo->NBits == 0) {
        switch (sinfo->Data) {
        case ePERSTIData_Null:
            return;
        case ePERSTIData_Integer:
        case ePERSTIData_Unsigned:
            if (valref && (sinfo->Constraint == ePERSTIConstraint_Semiconstrained || sinfo->Constraint == ePERSTIConstraint_Constrained)) {
                if (info->NOctets == 0) {
                    sprintf(lbbuf, "%s_lb", info->Identifier);
                    outputvarintx(lbbuf, &sinfo->LowerVal);
                    output("ASN1intx_dup(%s, %s);\n", Reference(valref), lbbuf);
                } else if (sinfo->Data == ePERSTIData_Integer) {
                    output("%s = %d;\n", valref, intx2int32(&sinfo->LowerVal));
                } else {
                    output("%s = %u;\n", valref, intx2uint32(&sinfo->LowerVal));
                }
            }
            return;
        case ePERSTIData_BitString:
        case ePERSTIData_RZBBitString:
        case ePERSTIData_OctetString:
        case ePERSTIData_UTF8String:
        case ePERSTIData_SequenceOf:
        case ePERSTIData_SetOf:
        case ePERSTIData_String:
        case ePERSTIData_TableString:
        case ePERSTIData_ZeroString:
        case ePERSTIData_ZeroTableString:
            if (lenref)
                output("%s = 0;\n", lenref);
            return;
        case ePERSTIData_Extension:
            if (sinfo->Length == ePERSTILength_SmallLength)
                break;
            return;
        default:
            MyAbort();
        }
    }

    /* check for decoding of non-negative-binary-integer */
    switch (sinfo->Constraint) {
    case ePERSTIConstraint_Semiconstrained:
    case ePERSTIConstraint_Constrained:
        if (sinfo->Data == ePERSTIData_Integer)
            sinfo->Data = ePERSTIData_Unsigned;
        break;
    }

    /* use newval for dec of semiconstraint/constraint intx_t with lb != 0 */
    switch (sinfo->Constraint) {
    case ePERSTIConstraint_Semiconstrained:
    case ePERSTIConstraint_Constrained:
        switch (sinfo->Data) {
        case ePERSTIData_Integer:
        case ePERSTIData_Unsigned:
        case ePERSTIData_NormallySmall:
            if (valref) {
                if (intx_cmp(&sinfo->LowerVal, &intx_0) != 0) {
                    if (info->NOctets == 0) {
                        outputvar("ASN1intx_t newval;\n");
                        oldvalref = valref;
                        valref = "newval";
                    }
                }
            }
            break;
        }
        break;
    }

    /* general rules */
    if (sinfo->LAlignment == ePERSTIAlignment_OctetAligned && sinfo->Length == ePERSTILength_BitLength &&
        !(sinfo->LNBits & 7))
        sinfo->Alignment = ePERSTIAlignment_BitAligned;
                                /* octet alignment will be given my length */
    if (sinfo->Length == ePERSTILength_InfiniteLength &&
        (sinfo->Data == ePERSTIData_Integer && info->NOctets == 0 ||
        sinfo->Data == ePERSTIData_Unsigned && info->NOctets == 0 ||
        sinfo->Data == ePERSTIData_BitString ||
        sinfo->Data == ePERSTIData_RZBBitString ||
        sinfo->Data == ePERSTIData_Extension ||
        sinfo->Data == ePERSTIData_OctetString ||
        sinfo->Data == ePERSTIData_UTF8String ||
        sinfo->Data == ePERSTIData_SequenceOf ||
        sinfo->Data == ePERSTIData_SetOf ||
        sinfo->Data == ePERSTIData_String ||
        sinfo->Data == ePERSTIData_TableString ||
        sinfo->Data == ePERSTIData_ZeroString ||
        sinfo->Data == ePERSTIData_ZeroTableString) ||
        sinfo->Data == ePERSTIData_ObjectIdentifier ||
        sinfo->Data == ePERSTIData_Real ||
        sinfo->Data == ePERSTIData_GeneralizedTime ||
        sinfo->Data == ePERSTIData_UTCTime ||
        sinfo->Data == ePERSTIData_External ||
        sinfo->Data == ePERSTIData_EmbeddedPdv ||
        sinfo->Data == ePERSTIData_MultibyteString ||
        sinfo->Data == ePERSTIData_UnrestrictedString ||
        sinfo->Data == ePERSTIData_Open)
        sinfo->LAlignment = sinfo->Alignment = ePERSTIAlignment_BitAligned;
                                /* alignment will be done by encoding fn */
    if (sinfo->Length == ePERSTILength_NoLength ||
        sinfo->Length == ePERSTILength_SmallLength)
        sinfo->LAlignment = ePERSTIAlignment_BitAligned;
                                    /* no alignment of no length */

    if (g_fCaseBasedOptimizer)
    {
        // lonchanc: special handling for macro operations
        if (PerOptCase_IsSignedInteger(sinfo))
        {
            output("if (!ASN1PERDecInteger(%s, %s))\n", encref, Reference(valref));
            output("return 0;\n");
            goto FinalTouch;
        }
        if (PerOptCase_IsUnsignedInteger(sinfo))
        {
            output("if (!ASN1PERDecUnsignedInteger(%s, %s))\n", encref, Reference(valref));
            output("return 0;\n");
            goto FinalTouch;
        }
        if (PerOptCase_IsUnsignedShort(sinfo))
        {
            output("if (!ASN1PERDecUnsignedShort(%s, %s))\n", encref, Reference(valref));
            output("return 0;\n");
            goto FinalTouch;
        }
        if (PerOptCase_IsBoolean(sinfo))
        {
            output("if (!ASN1PERDecBoolean(%s, %s))\n", encref, Reference(valref));
            output("return 0;\n");
            return;
        }
    }

    /* initial settings for length enconding: */
    /* add lower bound of length to length */
    if (!lenref) {
        if (sinfo->Length == ePERSTILength_NoLength &&
            sinfo->Data != ePERSTIData_Extension) {
            sprintf(lenbuf, "%u", sinfo->LLowerVal);
            lenref = lenbuf;
        } else if (sinfo->Data != ePERSTIData_ObjectIdentifier &&
            sinfo->Data != ePERSTIData_External &&
            sinfo->Data != ePERSTIData_EmbeddedPdv &&
            sinfo->Data != ePERSTIData_MultibyteString &&
            sinfo->Data != ePERSTIData_UnrestrictedString &&
            sinfo->Data != ePERSTIData_Extension &&
            (sinfo->Length != ePERSTILength_InfiniteLength ||
            (sinfo->Data != ePERSTIData_SetOf &&
            sinfo->Data != ePERSTIData_SequenceOf) ||
            !IsStructuredType(GetType(ass, sinfo->SubType))) &&
            ((sinfo->Data != ePERSTIData_SetOf &&
            sinfo->Data != ePERSTIData_SequenceOf) || valref) &&
            (sinfo->Length != ePERSTILength_InfiniteLength ||
            info->NOctets != 0 ||
            (sinfo->Data != ePERSTIData_Integer &&
            sinfo->Data != ePERSTIData_Unsigned)) &&
            ((sinfo->Data != ePERSTIData_ZeroString &&
            sinfo->Data != ePERSTIData_ZeroTableString) ||
            sinfo->Length != ePERSTILength_InfiniteLength) &&
            (sinfo->Data != ePERSTIData_BitString &&
            sinfo->Data != ePERSTIData_UTF8String &&
            sinfo->Data != ePERSTIData_OctetString)) {
            outputvar("ASN1uint32_t l;\n");
            lenref = "l";
        }
    } else if (sinfo->Length == ePERSTILength_NoLength) {
        if ((sinfo->Data == ePERSTIData_BitString ||
             sinfo->Data == ePERSTIData_RZBBitString) &&
             sinfo->cbFixedSizeBitString)
        {
            // lonchanc: doing nothing here because lenref is a constant number
        }
        else
        {
            output("%s = %u;\n", lenref, sinfo->LLowerVal);
        }
    }

    /* length encoding */
    if (sinfo->LAlignment == ePERSTIAlignment_OctetAligned) {
        output("ASN1PERDecAlignment(%s);\n", encref);
    }
    switch (sinfo->Length) {
    case ePERSTILength_NoLength:
        break;

    case ePERSTILength_BitLength:

        /* get length */
        output("if (!ASN1PERDecU32Val(%s, %u, %s))\n",
            encref, sinfo->LNBits, Reference(lenref));
        output("return 0;\n");

        /* add lower bound of length */
        if (sinfo->LLowerVal)
            output("%s += %u;\n", lenref, sinfo->LLowerVal);

        /*
        if (sinfo->LConstraint == ePERSTIConstraint_Constrained) {
            output("if (%s > %u)\n", lenref, sinfo->LUpperVal);
            output("return ASN1DecError(%s, ASN1_ERR_CORRUPT);\n", encref);
        }
        */
        break;

    case ePERSTILength_InfiniteLength:

        /* infinite length case */
        switch (sinfo->Data) {
        case ePERSTIData_Integer:
        case ePERSTIData_Unsigned:

            /* get length of integer value */
            if (info->NOctets != 0) {
                output("if (!ASN1PERDecFragmentedLength(%s, %s))\n",
                    encref, Reference(lenref));
                output("return 0;\n");
                if (sinfo->LLowerVal)
                    output("%s += %u;\n", lenref, sinfo->LLowerVal);
                /*
                if (sinfo->LConstraint == ePERSTIConstraint_Constrained) {
                    output("if (%s > %u)\n", lenref, sinfo->LUpperVal);
                    output("return ASN1DecError(%s, ASN1_ERR_CORRUPT);\n",
                        encref);
                }
                */
            }
            break;
        }
        break;
    }

    /* value decoding */
    switch (sinfo->Length) {
    case ePERSTILength_NoLength:

        /* decode alignment of the value */
        if (sinfo->Alignment == ePERSTIAlignment_OctetAligned) {
            output("ASN1PERDecAlignment(%s);\n", encref);
        }

        switch (sinfo->Data) {
        case ePERSTIData_Integer:

            /* decode the value as bit field */
            if (valref) {
                if (!info->NOctets) {
                    output("if (!ASN1PERDecSXVal(%s, %u, %s))\n",
                        info->NOctets * 8, encref, sinfo->NBits, Reference(valref));
                    output("return 0;\n");
                } else {
                    output("if (!ASN1PERDecS%dVal(%s, %u, %s))\n",
                        info->NOctets * 8, encref, sinfo->NBits, Reference(valref));
                    output("return 0;\n");
                }
            } else {
                output("if (!ASN1PERDecSkipBits(%s, %u))\n",
                    encref, sinfo->NBits);
                output("return 0;\n");
            }
            break;

        case ePERSTIData_Unsigned:

            /* decode the value as bit field */
            if (valref) {
                if (!info->NOctets) {
                    output("if (!ASN1PERDecUXVal(%s, %u, %s))\n",
                        info->NOctets * 8, encref, sinfo->NBits, Reference(valref));
                    output("return 0;\n");
                } else {
                    output("if (!ASN1PERDecU%dVal(%s, %u, %s))\n",
                        info->NOctets * 8, encref, sinfo->NBits, Reference(valref));
                    output("return 0;\n");
                }
            } else {
                output("if (!ASN1PERDecSkipBits(%s, %u))\n",
                    encref, sinfo->NBits);
                output("return 0;\n");
            }
            break;

        case ePERSTIData_NormallySmall:

            /* decode the value as normally small number */
            if (valref) {
                if (!info->NOctets) {
                    MyAbort();
                } else {
                    output("if (!ASN1PERDecN%dVal(%s, %s))\n",
                        info->NOctets * 8, encref, Reference(valref));
                    output("return 0;\n");
                }
            } else {
                output("if (!ASN1PERDecSkipNormallySmall(%s))\n",
                    encref);
                output("return 0;\n");
            }
            break;

        case ePERSTIData_BitString:
        case ePERSTIData_RZBBitString:

            /* decode bit string in a bit field */
            if (valref) {
                if (sinfo->cbFixedSizeBitString)
                {
                    output("if (!ASN1PERDecExtension(%s, %s, %s))\n",
                        encref, lenref, Reference(valref));
                }
                else
                {
                    output("if (!ASN1PERDecBits(%s, %s, %s))\n",
                        encref, lenref, Reference(valref));
                }
                output("return 0;\n");
            } else {
                output("if (!ASN1PERDecSkipBits(%s, %s))\n",
                    encref, lenref);
                output("return 0;\n");
            }
            break;

        case ePERSTIData_OctetString:

            /* decode octet string in a bit field */
            if (valref) {
                if (sinfo->LConstraint == ePERSTIConstraint_Constrained &&
                    (! info->pPrivateDirectives->fLenPtr))
                {
                    output("if (!ASN1PERDecExtension(%s, %s * 8, %s))\n",
                        encref, lenref, valref);
                }
                else
                {
                    output("if (!ASN1PERDecBits(%s, %s * 8, %s))\n",
                        encref, lenref, Reference(valref));
                }
                output("return 0;\n");
            } else {
                output("if (!ASN1PERDecSkipBits(%s, %s * 8))\n",
                    encref, lenref);
                output("return 0;\n");
            }
            break;

        case ePERSTIData_UTF8String:

            /* decode octet string in a bit field */
            if (valref) {
                output("if (!ASN1PERDecUTF8String(%s, %s, %s))\n",
                    encref, lenref, Reference(valref));
                output("return 0;\n");
            } else {
                MyAbort();
            }
            break;

        case ePERSTIData_Extension:

            /* decode extension bits in a bit field */
            if (valref) {
                output("if (!ASN1PERDecExtension(%s, %u, %s))\n",
                    encref, sinfo->NBits, valref);
                output("return 0;\n");
            } else {
                output("if (!ASN1PERDecSkipBits(%s, %u))\n",
                    encref, sinfo->NBits);
                output("return 0;\n");
            }
            break;

        case ePERSTIData_SetOf:

            /* same as BitLength encoding */
            goto SetOfEncoding;

        case ePERSTIData_SequenceOf:

            /* same as BitLength encoding */
            goto SequenceOfEncoding;

        case ePERSTIData_String:

            /* same as BitLength encoding */
            goto StringEncoding;

        case ePERSTIData_ZeroString:

            /* same as BitLength encoding */
            goto ZeroStringEncoding;

        case ePERSTIData_TableString:

            /* same as BitLength encoding */
            goto TableStringEncoding;

        case ePERSTIData_ZeroTableString:

            /* same as BitLength encoding */
            goto ZeroTableStringEncoding;

        case ePERSTIData_Reference:

            /* call encoding function of referenced type */
            if (valref) {
                output("if (!ASN1Dec_%s(%s, %s))\n",
                    Identifier2C(sinfo->SubIdentifier),
                    encref, Reference(valref));
                output("return 0;\n");
            } else {
                output("if (!ASN1Dec_%s(%s, NULL))\n",
                    Identifier2C(sinfo->SubIdentifier),
                    encref);
                output("return 0;\n");
            }
            break;

        case ePERSTIData_Real:

            /* decode real value */
            if (valref) {
                if (info->NOctets)
                    output("if (!ASN1PERDecDouble(%s, %s))\n",
                        encref, Reference(valref));
                else
                    output("if (!ASN1PERDecReal(%s, %s))\n",
                        encref, Reference(valref));
                output("return 0;\n");
            } else {
                output("if (!ASN1PERDecSkipFragmented(%s, 8))\n",
                    encref);
                output("return 0;\n");
            }
            break;

        case ePERSTIData_GeneralizedTime:

            /* decode generalized time value */
            if (valref) {
                output("if (!ASN1PERDecGeneralizedTime(%s, %s, %d))\n",
                    encref, Reference(valref), sinfo->NBits);
                output("return 0;\n");
            } else {
                output("if (!ASN1PERDecSkipFragmented(%s, %d))\n",
                    encref, sinfo->NBits);
                output("return 0;\n");
            }
            break;

        case ePERSTIData_UTCTime:

            /* decode utc time value */
            if (valref) {
                output("if (!ASN1PERDecUTCTime(%s, %s, %d))\n",
                    encref, Reference(valref), sinfo->NBits);
                output("return 0;\n");
            } else {
                output("if (!ASN1PERDecSkipFragmented(%s, %d))\n",
                    encref, sinfo->NBits);
                output("return 0;\n");
            }
            break;
        }
        break;

    case ePERSTILength_BitLength:

        /* decode alignment of the value */
        if (sinfo->Alignment == ePERSTIAlignment_OctetAligned) {
            output("ASN1PERDecAlignment(%s);\n", encref);
        }

        switch (sinfo->Data) {
        case ePERSTIData_Integer:
        case ePERSTIData_Unsigned:

            /* decode the value as bit field */
            if (valref) {
                if (info->NOctets == 0 && sinfo->Data == ePERSTIData_Integer) {
                    output("if (!ASN1PERDecSXVal(%s, %s * 8, %s))\n",
                        encref, lenref, Reference(valref));
                    output("return 0;\n");
                } else if (info->NOctets == 0 && sinfo->Data == ePERSTIData_Unsigned) {
                    output("if (!ASN1PERDecUXVal(%s, %s * 8, %s))\n",
                        encref, lenref, Reference(valref));
                    output("return 0;\n");
                } else if (sinfo->Data == ePERSTIData_Integer) {
                    output("if (!ASN1PERDecS%dVal(%s, %s * 8, %s))\n",
                        info->NOctets * 8, encref, lenref, Reference(valref));
                    output("return 0;\n");
                } else {
                    output("if (!ASN1PERDecU%dVal(%s, %s * 8, %s))\n",
                        info->NOctets * 8, encref, lenref, Reference(valref));
                    output("return 0;\n");
                }
            } else {
                output("if (!ASN1PERDecSkipBits(%s, %s * 8))\n",
                    encref, lenref);
                output("return 0;\n");
            }
            break;

        case ePERSTIData_BitString:
        case ePERSTIData_RZBBitString:

            /* decode the value as bit field */
            if (valref) {
                output("if (!ASN1PERDecBits(%s, %s, %s))\n",
                    encref, lenref, Reference(valref));
                output("return 0;\n");
            } else {
                output("if (!ASN1PERDecSkipBits(%s, %s))\n",
                    encref, lenref);
                output("return 0;\n");
            }
            break;

        case ePERSTIData_OctetString:

            /* decode the value as bit field */
            if (valref) {
                if (sinfo->LConstraint == ePERSTIConstraint_Constrained &&
                    (! info->pPrivateDirectives->fLenPtr))
                {
                    output("if (!ASN1PERDecExtension(%s, %s * 8, %s))\n",
                        encref, lenref, valref);
                }
                else
                {
                    output("if (!ASN1PERDecBits(%s, %s * 8, %s))\n",
                        encref, lenref, Reference(valref));
                }
                output("return 0;\n");
            } else {
                output("if (!ASN1PERDecSkipBits(%s, %s * 8))\n",
                    encref, lenref);
                output("return 0;\n");
            }
            break;

        case ePERSTIData_UTF8String:

            /* decode the value as bit field */
            if (valref) {
                output("if (!ASN1PERDecUTF8String(%s, %s, %s))\n",
                    encref, lenref, Reference(valref));
                output("return 0;\n");
            } else {
                MyAbort();
            }
            break;

        case ePERSTIData_SetOf:
        SetOfEncoding:
            /*FALLTHROUGH*/
        case ePERSTIData_SequenceOf:
        SequenceOfEncoding:

            /* skip null sequence of/set of */
            if (sinfo->SubType->Flags & eTypeFlags_Null)
                break;

            outputvar("ASN1uint32_t i;\n");
            if (!valref || (info->Rules & eTypeRules_PointerArrayMask))
            {
                // lonchanc: no need to allocate memory for eTypeRules_FixedArray
                /* allocate memory for elements */
                if (valref && (info->Rules & eTypeRules_LengthPointer))
                {
                    output("if (!%s) {\n", lenref);
                    output("%s = NULL;\n", valref);
                    output("} else {\n");
                    output("if (!(%s = (%s *)ASN1DecAlloc(%s, %s * sizeof(%s))))\n",
                        valref, sinfo->SubIdentifier, encref,
                        lenref, Dereference(valref));
                    output("return 0;\n");
                }

                /* decode elements */
                output("for (i = 0; i < %s; i++) {\n", lenref);
                if (valref) {
                    sprintf(valbuf, "(%s)[i]", valref);
                    GenPERFuncSimpleType(ass, &sinfo->SubType->PERTypeInfo, valbuf, eDecode, encref);
                } else {
                    GenPERFuncSimpleType(ass, &sinfo->SubType->PERTypeInfo, NULL, eDecode, encref);
                }

                /* loop end */
                output("}\n");
                if (valref && (info->Rules & eTypeRules_LengthPointer))
                    output("}\n"); // closing bracket for else
            }
            else if (info->Rules & eTypeRules_SinglyLinkedList)
            {
                char szPrivateValueName[64];
                sprintf(&szPrivateValueName[0], "(*f)->%s", GetPrivateValueName(info->pPrivateDirectives, "value"));
                /* allocate and decode elements */
                outputvar("P%s *f;\n", info->Identifier);
                output("f = %s;\n", Reference(valref));
                output("for (i = 0; i < %s; i++) {\n", lenref);
                output("if (!(*f = (P%s)ASN1DecAlloc(%s, sizeof(**f))))\n",
                    info->Identifier, encref);
                output("return 0;\n");
                GenPERFuncSimpleType(ass, &sinfo->SubType->PERTypeInfo, &szPrivateValueName[0],
                    eDecode, encref);
                output("f = &(*f)->next;\n");
                output("}\n");
                output("*f = NULL;\n");
            }
            else
            if (info->Rules & eTypeRules_DoublyLinkedList)
            {
                char szPrivateValueName[64];
                sprintf(&szPrivateValueName[0], "(*f)->%s", GetPrivateValueName(info->pPrivateDirectives, "value"));
                /* allocate and decode elements */
                outputvar("P%s *f;\n", info->Identifier);
                outputvar("%s b;\n", info->Identifier);
                output("f = %s;\n", Reference(valref));
                output("b = NULL;\n");
                output("for (i = 0; i < %s; i++) {\n", lenref);
                output("if (!(*f = (P%s)ASN1DecAlloc(%s, sizeof(**f))))\n",
                    info->Identifier, encref);
                output("return 0;\n");
                GenPERFuncSimpleType(ass, &sinfo->SubType->PERTypeInfo, &szPrivateValueName[0],
                    eDecode, encref);
                output("f->prev = b;\n");
                output("b = *f;\n");
                output("f = &b->next;\n");
                output("}\n");
                output("*f = NULL;\n");
            }
            break;

        case ePERSTIData_String:
        StringEncoding:

            /* decode string value */
            if (info->NOctets == 1) {
                p = "Char";
            } else if (info->NOctets == 2) {
                p = "Char16";
            } else if (info->NOctets == 4) {
                p = "Char32";
            } else
                MyAbort();
            if (valref) {
#ifdef ENABLE_CHAR_STR_SIZE
                if (info->NOctets == 1 &&
                        info->Root.LConstraint == ePERSTIConstraint_Constrained)
                {
                    output("if (!ASN1PERDec%sStringNoAlloc(%s, %s, %s, %u))\n",
                        p, encref, lenref, valref, sinfo->NBits);
                }
                else
                {
                    output("if (!ASN1PERDec%sString(%s, %s, %s, %u))\n",
                        p, encref, lenref, Reference(valref), sinfo->NBits);
                }
#else
                output("if (!ASN1PERDec%sString(%s, %s, %s, %u))\n",
                    p, encref, lenref, Reference(valref), sinfo->NBits);
#endif
                output("return 0;\n");
            } else {
                output("if (!ASN1PERDecSkipBits(%s, %s * %u))\n",
                    encref, lenref, sinfo->NBits);
                output("return 0;\n");
            }
            break;

        case ePERSTIData_ZeroString:
        ZeroStringEncoding:

            /* decode zero-terminated string value */
            if (info->NOctets == 1) {
                p = "Char";
            } else if (info->NOctets == 2) {
                p = "Char16";
            } else if (info->NOctets == 4) {
                p = "Char32";
            } else
                MyAbort();
            if (valref) {
#ifdef ENABLE_CHAR_STR_SIZE
                if (info->NOctets == 1 &&
                        info->Root.LConstraint == ePERSTIConstraint_Constrained)
                {
                    output("if (!ASN1PERDecZero%sStringNoAlloc(%s, %s, %s, %u))\n",
                        p, encref, lenref, valref, sinfo->NBits);
                }
                else
                {
                    output("if (!ASN1PERDecZero%sString(%s, %s, %s, %u))\n",
                        p, encref, lenref, Reference(valref), sinfo->NBits);
                }
#else
                output("if (!ASN1PERDecZero%sString(%s, %s, %s, %u))\n",
                    p, encref, lenref, Reference(valref), sinfo->NBits);
#endif
                output("return 0;\n");
            } else {
                output("if (!ASN1PERDecSkipBits(%s, %s * %u))\n",
                    encref, lenref, sinfo->NBits);
                output("return 0;\n");
            }
            break;

        case ePERSTIData_TableString:
        TableStringEncoding:

            /* decode table string value */
            if (info->NOctets == 1) {
                p = "Char";
            } else if (info->NOctets == 2) {
                p = "Char16";
            } else if (info->NOctets == 4) {
                p = "Char32";
            } else
                MyAbort();
            if (valref) {
#ifdef ENABLE_CHAR_STR_SIZE
                if (info->NOctets == 1 &&
                        info->Root.LConstraint == ePERSTIConstraint_Constrained)
                {
                    output("if (!ASN1PERDecTable%sStringNoAlloc(%s, %s, %s, %u, %s))\n",
                        p, encref, lenref, valref, sinfo->NBits, Reference(sinfo->TableIdentifier));
                }
                else
                {
                    output("if (!ASN1PERDecTable%sString(%s, %s, %s, %u, %s))\n",
                        p, encref, lenref, Reference(valref), sinfo->NBits, Reference(sinfo->TableIdentifier));
                }
#else
                output("if (!ASN1PERDecTable%sString(%s, %s, %s, %u, %s))\n",
                    p, encref, lenref, Reference(valref), sinfo->NBits, Reference(sinfo->TableIdentifier));
#endif
                output("return 0;\n");
            } else {
                output("if (!ASN1PERDecSkipBits(%s, %s * %u, %s))\n",
                    encref, lenref, sinfo->NBits, Reference(sinfo->TableIdentifier));
                output("return 0;\n");
            }
            break;

        case ePERSTIData_ZeroTableString:
        ZeroTableStringEncoding:

                /* decode zero-terminated table string value */
                if (info->NOctets == 1) {
                p = "Char";
                } else if (info->NOctets == 2) {
                p = "Char16";
                } else if (info->NOctets == 4) {
                p = "Char32";
                } else
                MyAbort();
                if (valref) {
#ifdef ENABLE_CHAR_STR_SIZE
                if (info->NOctets == 1 &&
                        info->Root.LConstraint == ePERSTIConstraint_Constrained)
                {
                        output("if (!ASN1PERDecZeroTable%sStringNoAlloc(%s, %s, %s, %u, %s))\n",
                                p, encref, lenref, valref, sinfo->NBits, Reference(sinfo->TableIdentifier));
                }
                else
                {
                        output("if (!ASN1PERDecZeroTable%sString(%s, %s, %s, %u, %s))\n",
                                p, encref, lenref, Reference(valref), sinfo->NBits, Reference(sinfo->TableIdentifier));
                }
#else
                output("if (!ASN1PERDecZeroTable%sString(%s, %s, %s, %u, %s))\n",
                        p, encref, lenref, Reference(valref), sinfo->NBits, Reference(sinfo->TableIdentifier));
#endif
                output("return 0;\n");
                } else {
                output("if (!ASN1PERDecSkipBits(%s, %s * %u, %s))\n",
                        encref, lenref, sinfo->NBits, Reference(sinfo->TableIdentifier));
                output("return 0;\n");
                }
            break;
        }
        break;

    case ePERSTILength_InfiniteLength:

        /* infinite length case */
        switch (sinfo->Data) {
        case ePERSTIData_Integer:
        case ePERSTIData_Unsigned:

            /* get integer value as fragmented */
            if (valref) {
                if (info->NOctets == 0) {
                    if (sinfo->Data == ePERSTIData_Integer) {
                        output("if (!ASN1PERDecFragmentedIntx(%s, %s))\n",
                            encref, Reference(valref));
                    } else {
                        output("if (!ASN1PERDecFragmentedUIntx(%s, %s))\n",
                            encref, Reference(valref));
                    }
                    output("return 0;\n");
                } else if (sinfo->Data == ePERSTIData_Integer) {
                    output("if (!ASN1PERDecS%dVal(%s, %s * 8, %s))\n",
                        info->NOctets * 8, encref, lenref, Reference(valref));
                    output("return 0;\n");
                } else {
                    output("if (!ASN1PERDecU%dVal(%s, %s * 8, %s))\n",
                        info->NOctets * 8, encref, lenref, Reference(valref));
                    output("return 0;\n");
                }
            } else {
                if (info->NOctets != 0) {
                    output("if (!ASN1PERDecSkipBits(%s, %s * 8))\n",
                        encref, lenref);
                    output("return 0;\n");
                } else {
                    output("if (!ASN1PERDecSkipFragmented(%s, 8))\n",
                        encref);
                    output("return 0;\n");
                }
            }
            break;

        case ePERSTIData_Extension:

            /* get extension bits as fragmented */
            if (valref) {
                output("if (!ASN1PERDecFragmentedExtension(%s, %u, %s))\n",
                    encref, sinfo->NBits, valref);
                output("return 0;\n");
            } else {
                output("if (!ASN1PERDecSkipFragmented(%s, 1))\n",
                    encref);
                output("return 0;\n");
            }
            break;

        case ePERSTIData_BitString:
        case ePERSTIData_RZBBitString:

            /* get bit string as fragmented */
            if (valref) {
                output("if (!ASN1PERDecFragmented(%s, %s, %s, 1))\n",
                    encref, Reference(lenref), Reference(valref));
                output("return 0;\n");
            } else {
                output("if (!ASN1PERDecSkipFragmented(%s, 1))\n",
                    encref);
                output("return 0;\n");
            }
            break;

        case ePERSTIData_OctetString:

            /* get octet string as fragmented */
            if (valref) {
                output("if (!ASN1PERDecFragmented(%s, %s, %s, 8))\n",
                    encref, Reference(lenref), Reference(valref));
                output("return 0;\n");
            } else {
                output("if (!ASN1PERDecSkipFragmented(%s, 8))\n",
                    encref);
                output("return 0;\n");
            }
            break;

        case ePERSTIData_UTF8String:

            /* get octet string as fragmented */
            if (valref) {
                output("if (!ASN1PERDecUTF8StringEx(%s, %s, %s))\n",
                    encref, Reference(lenref), Reference(valref));
                output("return 0;\n");
            } else {
                MyAbort();
            }
            break;

        case ePERSTIData_SetOf:
        case ePERSTIData_SequenceOf:

            /* we need some counters and iterators */
            outputvar("ASN1uint32_t i;\n");
            outputvar("ASN1uint32_t n;\n");
            if (valref)
            {
                if (info->Rules & eTypeRules_LengthPointer)
                {
                    output("%s = 0;\n", lenref);
                    output("%s = NULL;\n", valref);
                }
                else
                if (info->Rules & eTypeRules_FixedArray)
                {
                    output("%s = 0;\n", lenref);
                }
                else
                if (info->Rules & eTypeRules_SinglyLinkedList)
                {
                    outputvar("P%s *f;\n", info->Identifier);
                    output("f = %s;\n", Reference(valref));
                }
                else
                if (info->Rules & eTypeRules_DoublyLinkedList)
                {
                    outputvar("P%s *f;\n", info->Identifier);
                    outputvar("%s b;\n", info->Identifier);
                    output("f = %s;\n", Reference(valref));
                    output("b = NULL;\n");
                }
            }

            /* get all elements of the sequence of/set of */
            output("do {\n");

            /* get length of a fragment */
            output("if (!ASN1PERDecFragmentedLength(%s, &n))\n",
                encref);
            output("return 0;\n");

            if (valref)
            {
                if (info->Rules & eTypeRules_LengthPointer)
                {
                    // lonchanc: no need to allocate memory for eTypeRules_FixedArray
                    /* resize memory for the element */
                    output("if (!(%s = (%s *)ASN1DecRealloc(%s, %s, (%s + n) * sizeof(%s))))\n",
                        valref, GetTypeName(ass, sinfo->SubType), encref,
                        valref, lenref, Dereference(valref));
                    output("return 0;\n");
                }
            }

            /* get the elements of the fragment */
            output("for (i = 0; i < n; i++) {\n");
            if (valref) {
                if (info->Rules & eTypeRules_PointerArrayMask)
                {
                    sprintf(valbuf, "(%s)[%s]", valref, lenref);
                }
                else
                if (info->Rules & eTypeRules_LinkedListMask)
                {
                    output("if (!(*f = (P%s)ASN1DecAlloc(%s, sizeof(**f))))\n",
                        info->Identifier, encref);
                    output("return 0;\n");
                    sprintf(valbuf, "(*f)->%s", GetPrivateValueName(info->pPrivateDirectives, "value"));
                }
                GenPERFuncSimpleType(ass, &sinfo->SubType->PERTypeInfo, valbuf, eDecode, encref);
                if (info->Rules & eTypeRules_SinglyLinkedList)
                {
                    output("f = &(*f)->next;\n");
                }
                else
                if (info->Rules & eTypeRules_DoublyLinkedList)
                {
                    output("(*f)->prev = b;\n");
                    output("b = *f;\n");
                    output("f = &b->next;\n");
                }
            } else {
                GenPERFuncSimpleType(ass, &sinfo->SubType->PERTypeInfo, NULL, eDecode, encref);
            }
            if ((info->Rules & (eTypeRules_LengthPointer | eTypeRules_FixedArray)) && lenref)
                output("(%s)++;\n", lenref);

            /* end of inner loop */
            output("}\n");

            /* end of outer loop */
            output("} while (n >= 0x4000);\n");

            /* terminate list */
            if (valref && (info->Rules & (eTypeRules_SinglyLinkedList | eTypeRules_DoublyLinkedList)))
                output("*f = NULL;\n");
            break;

        case ePERSTIData_ObjectIdentifier:

            /* decode object identifier value */
            if (valref) {
                if (info->pPrivateDirectives->fOidArray || g_fOidArray)
                {
                    output("if (!ASN1PERDecObjectIdentifier2(%s, %s))\n",
                        encref, Reference(valref));
                }
                else
                {
                    output("if (!ASN1PERDecObjectIdentifier(%s, %s))\n",
                        encref, Reference(valref));
                }
                output("return 0;\n");
            } else {
                output("if (!ASN1PERDecSkipFragmented(%s, 8))\n",
                    encref);
                output("return 0;\n");
            }
            break;

        case ePERSTIData_External:

            /* decode external value */
            output("if (!ASN1PERDecExternal(%s, %s))\n",
                encref, Reference(valref));
            output("return 0;\n");
            break;

        case ePERSTIData_EmbeddedPdv:

            /* decode embedded pdv value */
            if (sinfo->Identification) {
                if (!strcmp(sinfo->Identification->Identifier, "fixed")) {
                    output("if (!ASN1PERDecEmbeddedPdvOpt(%s, %s, NULL, NULL))\n",
                        encref, Reference(valref));
                } else {
                    output("if (!ASN1PERDecEmbeddedPdvOpt(%s, %s, &%s_identification_syntaxes_abstract, &%s_identification_syntaxes_transfer))\n",
                        encref, Reference(valref),
                        info->Identifier, info->Identifier);
                }
            } else {
                output("if (!ASN1PERDecEmbeddedPdv(%s, %s))\n",
                    encref, Reference(valref));
            }
            output("return 0;\n");
            break;

        case ePERSTIData_MultibyteString:

            /* decode multibyte string value */
            output("if (!ASN1PERDecMultibyteString(%s, %s))\n",
                encref, Reference(valref));
            output("return 0;\n");
            break;

        case ePERSTIData_UnrestrictedString:

            /* decode character string value */
            if (sinfo->Identification) {
                if (!strcmp(sinfo->Identification->Identifier, "fixed")) {
                    output("if (!ASN1PERDecCharacterStringOpt(%s, %s, NULL, NULL))\n",
                        encref, Reference(valref));
                } else {
                    output("if (!ASN1PERDecCharacterStringOpt(%s, %s, &%s_identification_syntaxes_abstract, &%s_identification_syntaxes_transfer))\n",
                        encref, Reference(valref),
                        info->Identifier, info->Identifier);
                }
            } else {
                output("if (!ASN1PERDecCharacterString(%s, %s))\n",
                    encref, Reference(valref));
            }
            output("return 0;\n");
            break;

        case ePERSTIData_String:

            /* decode string value as fragmented */
            if (info->NOctets == 1) {
                p = "Char";
            } else if (info->NOctets == 2) {
                p = "Char16";
            } else if (info->NOctets == 4) {
                p = "Char32";
            } else
                MyAbort();
            if (valref) {
                output("if (!ASN1PERDecFragmented%sString(%s, %s, %s, %u))\n",
                    p, encref, Reference(lenref), Reference(valref), sinfo->NBits);
                output("return 0;\n");
            } else {
                output("if (!ASN1PERDecSkipFragmented(%s, %u))\n",
                    encref, sinfo->NBits);
                output("return 0;\n");
            }
            break;

        case ePERSTIData_ZeroString:

            /* decode zero-terminated string value as fragmented */
            if (info->NOctets == 1) {
                p = "Char";
            } else if (info->NOctets == 2) {
                p = "Char16";
            } else if (info->NOctets == 4) {
                p = "Char32";
            } else
                MyAbort();
            if (valref) {
                output("if (!ASN1PERDecFragmentedZero%sString(%s, %s, %u))\n",
                    p, encref, Reference(valref), sinfo->NBits);
                output("return 0;\n");
            } else {
                output("if (!ASN1PERDecSkipFragmented(%s, %u))\n",
                    encref, sinfo->NBits);
                output("return 0;\n");
            }
            break;

        case ePERSTIData_TableString:

            /* decode table string value as fragmented */
            if (info->NOctets == 1) {
                p = "Char";
            } else if (info->NOctets == 2) {
                p = "Char16";
            } else if (info->NOctets == 4) {
                p = "Char32";
            } else
                MyAbort();
            if (valref) {
                output("if (!ASN1PERDecFragmentedTable%sString(%s, %s, %s, %u, %s))\n",
                    p, encref, Reference(lenref), Reference(valref), sinfo->NBits,
                    Reference(sinfo->TableIdentifier));
                output("return 0;\n");
            } else {
                output("if (!ASN1PERDecSkipFragmented(%s, %u))\n",
                    encref, sinfo->NBits);
                output("return 0;\n");
            }
            break;

        case ePERSTIData_ZeroTableString:

            /* decode zero-terminated table-string as fragmented */
            if (info->NOctets == 1) {
                p = "Char";
            } else if (info->NOctets == 2) {
                p = "Char16";
            } else if (info->NOctets == 4) {
                p = "Char32";
            } else
                MyAbort();
            if (valref) {
                output("if (!ASN1PERDecFragmentedZeroTable%sString(%s, %s, %u, %s))\n",
                    p, encref, Reference(valref), sinfo->NBits, Reference(sinfo->TableIdentifier));
                output("return 0;\n");
            } else {
                output("if (!ASN1PERDecSkipFragmented(%s, %u))\n",
                    encref, sinfo->NBits);
                output("return 0;\n");
            }
            break;

        case ePERSTIData_Open:

            /* decode open type value */
            if (valref) {
                output("if (!ASN1PERDecOpenType(%s, %s))\n",
                    encref, Reference(valref));
                output("return 0;\n");
            } else {
                output("if (!ASN1PERDecSkipFragmented(%s, 8))\n",
                    encref);
                output("return 0;\n");
            }
            break;
        }
        break;

    case ePERSTILength_SmallLength:

        switch (sinfo->Data) {
        case ePERSTIData_Extension:

            /* decode extension bits with normally small length */
            if (valref) {
                output("if (!ASN1PERDecNormallySmallExtension(%s, %s, %u, %s))\n",
                    encref, Reference(lenref), sinfo->NBits, valref);
                output("return 0;\n");
            } else {
                output("if (!ASN1PERDecSkipNormallySmallExtension(%s, %s))\n",
                    encref, Reference(lenref));
                output("return 0;\n");
            }
            break;
        }
    }

FinalTouch:

    /* additional calculations for value decoding: */
    /* add lower bound of constraint/semiconstraint value */
    switch (sinfo->Constraint) {
    case ePERSTIConstraint_Semiconstrained:
    case ePERSTIConstraint_Constrained:
        switch (sinfo->Data) {
        case ePERSTIData_Integer:
        case ePERSTIData_Unsigned:
        case ePERSTIData_NormallySmall:
            if (valref) {
                if (intx_cmp(&sinfo->LowerVal, &intx_0) != 0) {
                    if (info->NOctets != 0) {
                        if (intx_cmp(&sinfo->LowerVal, &intx_0) > 0) {
                            output("%s += %u;\n",
                                valref, intx2uint32(&sinfo->LowerVal));
                        } else {
                            intx_neg(&ix, &sinfo->LowerVal);
                            // LONCHANC: to workaround a compiler bug in vc++.
                            // output("%s += -%u;\n",
                            output("%s += 0 - %u;\n",
                                valref, intx2uint32(&ix));
                        }
                    } else {
                        sprintf(lbbuf, "%s_lb", info->Identifier);
                        outputvarintx(lbbuf, &sinfo->LowerVal);
                        output("ASN1intx_add(%s, %s, &%s);\n",
                            Reference(oldvalref), Reference(valref), lbbuf);
                        output("ASN1intx_free(%s);\n",
                            Reference(valref));
                    }
                }
            }
            break;
        }
        break;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\asn1\asn1c\hackdir.c ===
/* Copyright (C) Boris Nikolaus, Germany, 1996-1997. All rights reserved. */
/* Copyright (C) Microsoft Corporation, 1997-1998. All rights reserved. */

#include "precomp.h"
#include "hackdir.h"

#ifdef MS_DIRECTIVE
int g_fPrivateDir_FieldNameToken = 0;
int g_fPrivateDir_TypeNameToken = 0;
int g_fPrivateDir_ValueNameToken = 0;
int g_fPrivateDir_SLinked = 0;
int g_fPrivateDir_DLinked = 0;
int g_fPrivateDir_Public = 0;
int g_fPrivateDir_Intx = 0;
int g_fPrivateDir_LenPtr = 0;
int g_fPrivateDir_Pointer = 0;
int g_fPrivateDir_Array = 0;
int g_fPrivateDir_NoCode = 0;
int g_fPrivateDir_NoMemCopy = 0;
int g_fPrivateDir_OidPacked = 0;
int g_fPrivateDir_OidArray = 0;
char g_szPrivateDirectedFieldName[64];
char g_szPrivateDirectedTypeName[64];
char g_szPrivateDirectedValueName[64];

int My_toupper ( int ch )
{
    if ('a' <= ch && ch <= 'z')
    {
        ch = (ch - 'a' + 'A');
    }
    return ch;
}

int PrivateDirectives_MatchSymbol ( int *p, char *psz )
{
    int c = *p;
    int fMatched = 1;

    while (*psz != '\0')
    {
        if (My_toupper(c) != *psz++)
        {
            fMatched = 0;
            break;
        }
        c = PrivateDirectives_Input();
    }
    *p = c;
    return fMatched;
}

void PrivateDirectives_SkipSpace ( int *p )
{
    int c = *p;
    while (isspace(c))
    {
        c = PrivateDirectives_Input();
    }
    *p = c;
}

void PrivateDirectives_GetSymbol ( int *p, char *psz )
{
    int c = *p;
    while (c == '_' || isalnum(c))
    {
        *psz++ = (char)c;
        c = PrivateDirectives_Input();
    }
    *psz = '\0';
    *p = c;
}

void PrivateDirectives_IgnoreSymbol ( int *p )
{
    int c = *p;
    while (c == '_' || isalnum(c))
    {
        c = PrivateDirectives_Input();
    }
    *p = c;
}

void GetMicrosoftDirective ( int *p )
{
    int c = *p;

    // loop through to get all directives
    while (c != g_chDirectiveEnd)
    {
        if (c == g_chDirectiveAND)
        {
            c = PrivateDirectives_Input();
            PrivateDirectives_SkipSpace(&c);
        }

        switch (My_toupper(c))
        {
        case 'A': // possible ARRAY
            if (PrivateDirectives_MatchSymbol(&c, "ARRAY"))
            {
                g_fPrivateDir_Array = 1;
            }
            break;

        case 'D': // possible DLINKED
            if (PrivateDirectives_MatchSymbol(&c, "DLINKED"))
            {
                g_fPrivateDir_DLinked = 1;
            }
            break;

        case 'F': // possible FNAME
            if (PrivateDirectives_MatchSymbol(&c, "FIELD"))
            {
                // c should be a space now
                PrivateDirectives_SkipSpace(&c);
                // c should be a double quote now
                if (c == '"')
                {
                    c = PrivateDirectives_Input();
                }
                // c should be the first char of name
                PrivateDirectives_GetSymbol(&c, &g_szPrivateDirectedFieldName[0]);
                g_fPrivateDir_FieldNameToken = 0;
            }
            break;

        case 'I': // possible INTX
            if (PrivateDirectives_MatchSymbol(&c, "INTX"))
            {
                g_fPrivateDir_Intx = 1;
            }
            break;

        case 'L': // possible LENPTR
            if (PrivateDirectives_MatchSymbol(&c, "LENPTR"))
            {
                g_fPrivateDir_LenPtr = 1;
            }
            break;

        case 'N': // possible NO MEMCPY (or NOMEMCPY) or NO CODE (or NOCODE)
            if (PrivateDirectives_MatchSymbol(&c, "NO"))
            {
                // skip over possible spaces
                PrivateDirectives_SkipSpace(&c);
                switch (My_toupper(c))
                {
                case 'C':
                    if (PrivateDirectives_MatchSymbol(&c, "CODE")) // CODE
                    {
                        g_fPrivateDir_NoCode = 1;
                    }
                    break;
                case 'M':
                    if (PrivateDirectives_MatchSymbol(&c, "MEMCPY")) // MEMCPY
                    {
                        g_fPrivateDir_NoMemCopy = 1;
                    }
                    break;
                }
            }
            break;

        case 'O': // possible OID ARRAY (or OIDARRAY) or OID PACKED (or OIDPACKED)
            if (PrivateDirectives_MatchSymbol(&c, "OID"))
            {
                // skip over possible spaces
                PrivateDirectives_SkipSpace(&c);
                switch (My_toupper(c))
                {
                case 'A':
                    if (PrivateDirectives_MatchSymbol(&c, "ARRAY")) // ARRAY
                    {
                        g_fPrivateDir_OidArray = 1;
                    }
                    break;
                case 'P':
                    if (PrivateDirectives_MatchSymbol(&c, "PACKED")) // PACKED
                    {
                        g_fPrivateDir_OidPacked = 1;
                    }
                    break;
                }
            }
            break;

        case 'P': // possible POINTER or PUBLIC
            c = PrivateDirectives_Input();
            switch (My_toupper(c))
            {
            case 'O':
                if (PrivateDirectives_MatchSymbol(&c, "OINTER")) // POINTER
                {
                    g_fPrivateDir_Pointer = 1;
                }
                break;
            case 'U':
                if (PrivateDirectives_MatchSymbol(&c, "UBLIC")) // PUBLIC
                {
                    g_fPrivateDir_Public = 1;
                }
                break;
            }
            break;

        case 'S': // possible SLINKED
            if (PrivateDirectives_MatchSymbol(&c, "SLINKED"))
            {
                g_fPrivateDir_SLinked = 1;
            }
            break;

        case 'T': // possible TNAME
            if (PrivateDirectives_MatchSymbol(&c, "TYPE"))
            {
                // c should be a space now
                PrivateDirectives_SkipSpace(&c);
                // c should be a double quote now
                if (c == '"')
                {
                    c = PrivateDirectives_Input();
                }
                // c should be the first char of name
                PrivateDirectives_GetSymbol(&c, &g_szPrivateDirectedTypeName[0]);
                g_fPrivateDir_TypeNameToken = 0;
            }
            break;

        case 'V': // possible VNAME
            if (PrivateDirectives_MatchSymbol(&c, "VALUE"))
            {
                // c should be a space now
                PrivateDirectives_SkipSpace(&c);
                // c should be a double quote now
                if (c == '"')
                {
                    c = PrivateDirectives_Input();
                }
                // c should be the first char of name
                PrivateDirectives_GetSymbol(&c, &g_szPrivateDirectedValueName[0]);
                g_fPrivateDir_ValueNameToken = 0;
            }
            break;

        default:
            goto MyExit;
        }

        // determine if we should stay in the loop
        // skip over the ending double quote
        if (c == '"')
        {
            c = PrivateDirectives_Input();
        }
        // skip over unknown directives
        PrivateDirectives_IgnoreSymbol(&c);
        // skip over possible spaces
        PrivateDirectives_SkipSpace(&c);
    }

    // now, c is >. we need to advance to --
    c = PrivateDirectives_Input();

    // now, c should be -

MyExit:

    // return the current character
    *p = c;
}


void GetPrivateDirective ( int *p )
{
    GetMicrosoftDirective(p);
}


typedef struct Verbatim_s
{
    struct Verbatim_s   *next;
    char                pszVerbatim[1];
}
    Verbatim_t;

Verbatim_t *g_VerbatimList = NULL;

void RememberVerbatim(char *pszVerbatim)
{
    int cb = strlen(pszVerbatim) + 1;
    Verbatim_t *p = (Verbatim_t *) malloc(sizeof(Verbatim_t) + cb);
    if (p)
    {
        memcpy(p->pszVerbatim, pszVerbatim, cb);
        p->next = NULL;
        if (g_VerbatimList)
        {
            Verbatim_t *q;
            for (q = g_VerbatimList; q->next; q = q->next)
                ;
            q->next = p;
        }
        else
        {
            g_VerbatimList = p;
        }
    }
}

void PrintVerbatim(void)
{
    Verbatim_t *p;
    for (p = g_VerbatimList; p; p = p->next)
    {
        output("/* %s */\n", p->pszVerbatim);
    }
    if (g_VerbatimList)
    {
        output("\n");
    }
}

int CompareDirective(char *pszDirective, char *pszInput)
{
    int rc;
    int len = strlen(pszDirective);
    char ch = pszInput[len];
    pszInput[len] = '\0';
    rc = strcmpi(pszDirective, pszInput);
    pszInput[len] = ch;
    return rc;
}

void SetDirective(char *pszInput)
{
    // verbatim strings
    const char szComment[] = "COMMENT";
    if (! CompareDirective((char *) &szComment[0], pszInput))
    {
        pszInput += sizeof(szComment) - 1;
        if (isspace(*pszInput))
        {
            pszInput++;
            if ('"' == *pszInput++)
            {
                char *pszEnd = strchr(pszInput, '"');
                if (pszEnd)
                {
                    *pszEnd = '\0';
                    RememberVerbatim(pszInput);
                    *pszEnd = '"';
                }
            }
        }
        return;
    }

    // object identifier
    if (! CompareDirective("OID ARRAY", pszInput))
    {
        g_fOidArray = 1;
        return;
    }

    // set of/sequence of w/o size constraint
    if (! CompareDirective("SS.basic SLINKED", pszInput))
    {
        g_eDefTypeRuleSS_NonSized = eTypeRules_SinglyLinkedList;
        return;
    }
    if (! CompareDirective("SS.basic DLINKED", pszInput))
    {
        g_eDefTypeRuleSS_NonSized = eTypeRules_DoublyLinkedList;
        return;
    }
    if (! CompareDirective("SS.basic LENPTR", pszInput))
    {
        g_eDefTypeRuleSS_NonSized = eTypeRules_LengthPointer;
        return;
    }
    if (! CompareDirective("SS.basic ARRAY", pszInput))
    {
        g_eDefTypeRuleSS_NonSized = eTypeRules_FixedArray;
        return;
    }

    // set of/sequence of w/ size constraint
    if (! CompareDirective("SS.sized SLINKED", pszInput))
    {
        g_eDefTypeRuleSS_Sized = eTypeRules_SinglyLinkedList;
        return;
    }
    if (! CompareDirective("SS.sized DLINKED", pszInput))
    {
        g_eDefTypeRuleSS_Sized = eTypeRules_DoublyLinkedList;
        return;
    }
    if (! CompareDirective("SS.sized LENPTR", pszInput))
    {
        g_eDefTypeRuleSS_Sized = eTypeRules_LengthPointer;
        return;
    }
    if (! CompareDirective("SS.sized ARRAY", pszInput))
    {
        g_eDefTypeRuleSS_Sized = eTypeRules_FixedArray;
        return;
    }

    // set extra pointer type for SS construct, its struct name will be postfixed with _s
    if (! CompareDirective("SS.struct EXTRA-PTR-TYPE", pszInput))
    {
        g_fExtraStructPtrTypeSS = 1;
        return;
    }
}

#endif // MS_DIRECTIVE
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\asn1\asn1c\intx.c ===
/* Copyright (C) Boris Nikolaus, Germany, 1996-1997. All rights reserved. */
/* Copyright (C) Microsoft Corporation, 1997-1998. All rights reserved. */

// lonchanc: we seem to have a significant amount of memory leak
// while dealing with real number and unlimited integers.
// we definitely want to re-visit all the following routines carefully
// in the future.
// moreover, we need to make sure all the memory allocation and free
// are either using encoding and decoding memory manager or kernel one.
// need to make sure we do not mix them together.

#include "precomp.h"

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

/* builtin intx values */
ASN1octet_t ASN1intx_0_[] = { 0 };
ASN1intx_t ASN1intx_0 = { 1, ASN1intx_0_ };
ASN1octet_t ASN1intx_1_[] = { 1 };
ASN1intx_t ASN1intx_1 = { 1, ASN1intx_1_ };
ASN1octet_t ASN1intx_2_[] = { 2 };
ASN1intx_t ASN1intx_2 = { 1, ASN1intx_2_ };
ASN1octet_t ASN1intx_16_[] = { 16 };
ASN1intx_t ASN1intx_16 = { 1, ASN1intx_16_ };
ASN1octet_t ASN1intx_256_[] = { 1, 0 };
ASN1intx_t ASN1intx_256 = { 2, ASN1intx_256_ };
ASN1octet_t ASN1intx_64K_[] = { 1, 0, 0 };
ASN1intx_t ASN1intx_64K = { 3, ASN1intx_64K_ };
ASN1octet_t ASN1intx_1G_[] = { 64, 0, 0, 0 };
ASN1intx_t ASN1intx_1G = { 4, ASN1intx_1G_ };

/* add two intx values */
void
ASN1intx_add(ASN1intx_t *dst, ASN1intx_t *arg1, ASN1intx_t *arg2)
{
    ASN1octet_t *v;
    int l;
    int s1, s2;
    int o1, o2;
    int i;
    int c;
    int w;

    /* get signs */
    s1 = arg1->value[0] > 0x7f ? 0xff : 0x00;
    s2 = arg2->value[0] > 0x7f ? 0xff : 0x00;

    /* result length will be <= l */
    l = arg1->length > arg2->length ? arg1->length + 1 : arg2->length + 1;

    /* offset into values */
    o1 = l - arg1->length;
    o2 = l - arg2->length;

    /* allocate result */
    v = (ASN1octet_t *)malloc(l);

    /* clear carry bit */
    c = 0;

    /* add octet by octet */
    for (i = l - 1; i >= 0; i--) {
        w = (i >= o1 ? arg1->value[i - o1] : s1) + (i >= o2 ? arg2->value[i - o2] : s2) + c;
        v[i] = (ASN1octet_t)w;
        c = w > 0xff;
    }

    /* octets which may shall dropped */
    w = v[0] > 0x7f ? 0xff : 0x00;

    /* count octets that shall be dropped */
    for (i = 0; i < l - 1; i++) {
        if (v[i] != w)
            break;
    }
    if ((v[i] ^ w) & 0x80)
        i--;

    /* allocate and copy result */
    dst->length = l - i;
    dst->value = (ASN1octet_t *)malloc(l - i);
    memcpy(dst->value, v + i, l - i);
    free(v);
}

/* substract two intx values */
void
ASN1intx_sub(ASN1intx_t *dst, ASN1intx_t *arg1, ASN1intx_t *arg2)
{
    ASN1octet_t *v;
    int l;
    int s1, s2;
    int o1, o2;
    int i;
    int c;
    int w;

    /* get signs */
    s1 = arg1->value[0] > 0x7f ? 0xff : 0x00;
    s2 = arg2->value[0] > 0x7f ? 0xff : 0x00;

    /* result length will be <= l */
    l = arg1->length > arg2->length ? arg1->length + 1 : arg2->length + 1;

    /* offset into values */
    o1 = l - arg1->length;
    o2 = l - arg2->length;

    /* allocate result */
    v = (ASN1octet_t *)malloc(l);

    /* clear borrow bit */
    c = 0;

    /* substract octet by octet */
    for (i = l - 1; i >= 0; i--) {
        w = (i >= o1 ? arg1->value[i - o1] : s1) - (i >= o2 ? arg2->value[i - o2] : s2) - c;
        v[i] = (ASN1octet_t)w;
        c = w < 0;
    }

    /* octets which may shall dropped */
    w = v[0] > 0x7f ? 0xff : 0x00;

    /* count octets that shall be dropped */
    for (i = 0; i < l - 1; i++) {
        if (v[i] != w)
            break;
    }
    if ((v[i] ^ w) & 0x80)
        i--;

// lonchanc: do we forget to free dst->value???
// in case that dst and arg1 are identical. for instance, 
// ASN1BEREncReal() calls ASN1intx_sub(&exponent, &exponent, &help);
    /* allocate and copy result */
    dst->length = l - i;
    dst->value = (ASN1octet_t *)malloc(l - i);
    memcpy(dst->value, v + i, l - i);
    free(v);
}

/* add one octet to an intx */
void
ASN1intx_addoctet(ASN1intx_t *dst, ASN1intx_t *arg1, ASN1octet_t arg2)
{
    ASN1octet_t *v;
    int l;
    int i;
    int c;
    int w;

    /* result length will be <= l */
    l = arg1->length + 1;

    /* allocate result */
    v = (ASN1octet_t *)malloc(l);

    /* add octet by octet */
    c = arg2;
    for (i = l - 2; i >= 0; i--) {
        w = arg1->value[i] + c;
        v[i + 1] = (ASN1octet_t)w;
        c = (w > 0xff);
    }
    v[0] = arg1->value[0] > 0x7f ? (ASN1octet_t)(0xff + c) : (ASN1octet_t)c;

    /* octets which may shall dropped */
    w = v[0] > 0x7f ? 0xff : 0x00;

    /* count octets that shall be dropped */
    for (i = 0; i < l - 1; i++) {
        if (v[i] != w)
            break;
    }
    if ((v[i] ^ w) & 0x80)
        i--;

    /* allocate and copy result */
    dst->length = l - i;
    dst->value = (ASN1octet_t *)malloc(l - i);
    memcpy(dst->value, v + i, l - i);
    free(v);
}

/* substract one octet to an intx */
void
ASN1intx_suboctet(ASN1intx_t *dst, ASN1intx_t *arg1, ASN1octet_t arg2)
{
    ASN1octet_t *v;
    int l;
    int i;
    int c;
    int w;

    /* result length will be <= l */
    l = arg1->length + 1;

    /* allocate result */
    v = (ASN1octet_t *)malloc(l);

    /* substract octet by octet */
    c = arg2;
    for (i = l - 2; i >= 0; i--) {
        w = arg1->value[i] - c;
        v[i + 1] = (ASN1octet_t)w;
        c = (w < 0);
    }
    v[0] = arg1->value[0] > 0x7f ? (ASN1octet_t)(0xff - c) : (ASN1octet_t)c;

    /* octets which may shall dropped */
    w = v[0] > 0x7f ? 0xff : 0x00;

    /* count octets that shall be dropped */
    for (i = 0; i < l - 1; i++) {
        if (v[i] != w)
            break;
    }
    if ((v[i] ^ w) & 0x80)
        i--;

    /* allocate and copy result */
    dst->length = l - i;
    dst->value = (ASN1octet_t *)malloc(l - i);
    memcpy(dst->value, v + i, l - i);
    free(v);
}

/* multiply intx by an octet */
void
ASN1intx_muloctet(ASN1intx_t *dst, ASN1intx_t *arg1, ASN1octet_t arg2)
{
    ASN1octet_t *v;
    int l;
    int c;
    int i;
    int w;

    /* result length will be <= l */
    l = arg1->length + 1;

    /* allocate result */
    v = (ASN1octet_t *)malloc(l);

    /* multiply octet by octet */
    c = 0;
    for (i = l - 2; i >= 0; i--) {
        w = arg1->value[i] * arg2 + c;
        v[i + 1] = (ASN1octet_t)w;
        c = w >> 8;
    }
    v[0] = (ASN1octet_t)(arg1->value[0] > 0x7f ? 0xff * arg2 + c : c);

    /* octets which may shall dropped */
    w = v[0] > 0x7f ? 0xff : 0x00;

    /* count octets that shall be dropped */
    for (i = 0; i < l - 1; i++) {
        if (v[i] != w)
            break;
    }
    if ((v[i] ^ w) & 0x80)
        i--;

    /* allocate and copy result */
    dst->length = l - i;
    dst->value = (ASN1octet_t *)malloc(l - i);
    memcpy(dst->value, v + i, l - i);
    free(v);
}

/* increment an intx */
void
ASN1intx_inc(ASN1intx_t *val)
{
    ASN1octet_t *v;
    int l;
    int i;
    int w;

    /* result length will be <= l */
    l = val->length + 1;

    /* allocate result */
    v = (ASN1octet_t *)malloc(l);

    /* copy value */
    memcpy(v + 1, val->value, l - 1);
    free(val->value);
    v[0] = v[1] > 0x7f ? 0xff : 0x00;

    /* increment value */
    for (i = l - 1; i >= 0; i--) {
        if (++v[i])
            break;
    }

    /* octets which may shall dropped */
    w = v[0] > 0x7f ? 0xff : 0x00;

    /* count octets that shall be dropped */
    for (i = 0; i < l - 1; i++) {
        if (v[i] != w)
            break;
    }
    if ((v[i] ^ w) & 0x80)
        i--;

    /* allocate and copy result */
    val->length = l - i;
    val->value = (ASN1octet_t *)malloc(l - i);
    memcpy(val->value, v + i, l - i);
    free(v);
}

/* decrement an intx */
void
ASN1intx_dec(ASN1intx_t *val)
{
    ASN1octet_t *v;
    int l;
    int i;
    int w;

    /* result length will be <= l */
    l = val->length + 1;

    /* allocate result */
    v = (ASN1octet_t *)malloc(l);

    /* copy value */
    memcpy(v + 1, val->value, l - 1);
    free(val->value);
    v[0] = v[1] > 0x7f ? 0xff : 0x00;

    /* decrement value */
    for (i = l - 1; i >= 0; i--) {
        if (v[i]--)
            break;
    }

    /* octets which may shall dropped */
    w = v[0] > 0x7f ? 0xff : 0x00;

    /* count octets that shall be dropped */
    for (i = 0; i < l - 1; i++) {
        if (v[i] != w)
            break;
    }
    if ((v[i] ^ w) & 0x80)
        i--;

    /* allocate and copy result */
    val->length = l - i;
    val->value = (ASN1octet_t *)malloc(l - i);
    memcpy(val->value, v + i, l - i);
    free(v);
}

/* negate an intx value */
void
ASN1intx_neg(ASN1intx_t *dst, ASN1intx_t *arg)
{
    ASN1uint32_t i;

    /* duplicate value */
    ASN1intx_dup(dst, arg);

    /* ones complement */
    for (i = 0; i < dst->length; i++)
        dst->value[i] = ~dst->value[i];
    
    /* and increment */
    ASN1intx_inc(dst);
}

/* returns floor(log2(arg - 1)) */
ASN1uint32_t
ASN1intx_log2(ASN1intx_t *arg)
{
    ASN1uint32_t i;
    ASN1intx_t v;
    ASN1uint32_t n;

    ASN1intx_dup(&v, arg);
    ASN1intx_dec(&v);
    if (v.value[0] > 0x7f) {
        ASN1intx_free(&v);
        return 0;
    }
    for (i = 0; i < v.length; i++) {
        if (v.value[i])
            break;
    }
    if (i >= v.length) {
        n = 0;
    } else if (v.value[i] > 0x7f) {
        n = 8 * (v.length - i - 1) + 8;
    } else if (v.value[i] > 0x3f) {
        n = 8 * (v.length - i - 1) + 7;
    } else if (v.value[i] > 0x1f) {
        n = 8 * (v.length - i - 1) + 6;
    } else if (v.value[i] > 0x0f) {
        n = 8 * (v.length - i - 1) + 5;
    } else if (v.value[i] > 0x07) {
        n = 8 * (v.length - i - 1) + 4;
    } else if (v.value[i] > 0x03) {
        n = 8 * (v.length - i - 1) + 3;
    } else if (v.value[i] > 0x01) {
        n = 8 * (v.length - i - 1) + 2;
    } else {
        n = 8 * (v.length - i - 1) + 1;
    }
    ASN1intx_free(&v);
    return n;
}

/* returns floor(log2(arg - 1)) */
ASN1uint32_t
ASN1uint32_log2(ASN1uint32_t arg)
{
    ASN1uint32_t i;

    arg--;
    for (i = 32; i != 0; i--) {
        if (arg & (1 << (i - 1)))
            break;
    }
    return i;
}

/* returns floor(log256(arg - 1)) */
ASN1uint32_t
ASN1intx_log256(ASN1intx_t *arg)
{
    ASN1uint32_t i;
    ASN1intx_t v;

    ASN1intx_dup(&v, arg);
    ASN1intx_dec(&v);
    if (v.value[0] > 0x7f) {
        ASN1intx_free(&v);
        return 0;
    }
    for (i = 0; i < v.length; i++) {
        if (v.value[i])
            break;
    }
    ASN1intx_free(&v);
    return v.length - i;
}

/* returns floor(log256(arg - 1)) */
ASN1uint32_t
ASN1uint32_log256(ASN1uint32_t arg)
{
    if (arg > 0x10000) {
        if (arg > 0x1000000)
            return 4;
        return 3;
    }
    if (arg > 0x100)
        return 2;
    if (arg > 1)
        return 1;
    return 0;
}

/* compare two intx values; return 0 iff equal */
ASN1int32_t
ASN1intx_cmp(ASN1intx_t *arg1, ASN1intx_t *arg2)
{
    int s1, s2;
    int o1, o2;
    int l;
    int i;
    int d;

    s1 = arg1->value[0] > 0x7f ? 0xff : 0x00;
    s2 = arg2->value[0] > 0x7f ? 0xff : 0x00;
    if (s1 != s2)
        return s1 == 0xff ? -1 : 1;
    l = arg1->length > arg2->length ? arg1->length : arg2->length;
    o1 = l - arg1->length;
    o2 = l - arg2->length;
    for (i = 0; i < l; i++) {
        d = (i >= o1 ? arg1->value[i - o1] : s1) - (i >= o2 ? arg2->value[i - o2] : s2);
        if (d)
            return d;
    }
    return 0;
}

/* create an intx value from an uint32 value */
void
ASN1intx_setuint32(ASN1intx_t *dst, ASN1uint32_t val)
{
    ASN1octet_t o[5], *v = o;
    int n = 5;
    v[0] = 0;
    v[1] = (ASN1octet_t)(val >> 24);
    v[2] = (ASN1octet_t)(val >> 16);
    v[3] = (ASN1octet_t)(val >> 8);
    v[4] = (ASN1octet_t)(val);
    while (n > 1 && !*v && v[1] <= 0x7f) {
        n--;
        v++;
    }
    dst->length = n;
    dst->value = (ASN1octet_t *)malloc(n);
    memcpy(dst->value, v, n);
}

/* create an intx value from an int32 value */
void
ASN1intx_setint32(ASN1intx_t *dst, ASN1int32_t val)
{
    ASN1octet_t o[5], *v = o;
    int n = 5;
    v[0] = (ASN1octet_t)(val < 0 ? 0xff : 0x00);
    v[1] = (ASN1octet_t)(val >> 24);
    v[2] = (ASN1octet_t)(val >> 16);
    v[3] = (ASN1octet_t)(val >> 8);
    v[4] = (ASN1octet_t)(val);
    while (n > 1 && ((!*v && v[1] <= 0x7f) || (*v == 0xff && v[1] > 0x7f))) {
        n--;
        v++;
    }
    dst->length = n;
    dst->value = (ASN1octet_t *)malloc(n);
    memcpy(dst->value, v, n);
}

/* copy constructor */
void
ASN1intx_dup(ASN1intx_t *dst, ASN1intx_t *val)
{
    dst->length = val->length;
    dst->value = (ASN1octet_t *)malloc(val->length);
    memcpy(dst->value, val->value, val->length);
}

/* free an intx value */
void
ASN1intx_free(ASN1intx_t *val)
{
    free(val->value);
}

#ifdef HAS_SIXTYFOUR_BITS
/* convert an intx value to a uint64 value */
ASN1uint64_t
ASN1intx2uint64(ASN1intx_t *val)
{
    switch (val->length) {
    case 1:
        return (ASN1uint64_t)val->value[val->length - 1];
    case 2:
        return (ASN1uint64_t)(val->value[val->length - 1] |
            ((ASN1uint32_t)val->value[val->length - 2] << 8));
    case 3:
        return (ASN1uint64_t)(val->value[val->length - 1] |
            ((ASN1uint32_t)val->value[val->length - 2] << 8) |
            ((ASN1uint32_t)val->value[val->length - 3] << 16));
    case 4:
        return (ASN1uint64_t)(val->value[val->length - 1] |
            ((ASN1uint32_t)val->value[val->length - 2] << 8) |
            ((ASN1uint32_t)val->value[val->length - 3] << 16) |
            ((ASN1uint32_t)val->value[val->length - 4] << 24));
    case 5:
        return (ASN1uint64_t)(val->value[val->length - 1] |
            ((ASN1uint64_t)val->value[val->length - 2] << 8) |
            ((ASN1uint64_t)val->value[val->length - 3] << 16) |
            ((ASN1uint64_t)val->value[val->length - 4] << 24) |
            ((ASN1uint64_t)val->value[val->length - 5] << 32));
    case 6:
        return (ASN1uint64_t)(val->value[val->length - 1] |
            ((ASN1uint64_t)val->value[val->length - 2] << 8) |
            ((ASN1uint64_t)val->value[val->length - 3] << 16) |
            ((ASN1uint64_t)val->value[val->length - 4] << 24) |
            ((ASN1uint64_t)val->value[val->length - 5] << 32) |
            ((ASN1uint64_t)val->value[val->length - 6] << 40));
    case 7:
        return (ASN1uint64_t)(val->value[val->length - 1] |
            ((ASN1uint64_t)val->value[val->length - 2] << 8) |
            ((ASN1uint64_t)val->value[val->length - 3] << 16) |
            ((ASN1uint64_t)val->value[val->length - 4] << 24) |
            ((ASN1uint64_t)val->value[val->length - 5] << 32) |
            ((ASN1uint64_t)val->value[val->length - 6] << 40) |
            ((ASN1uint64_t)val->value[val->length - 7] << 48));
    default:
        return (ASN1uint64_t)(val->value[val->length - 1] |
            ((ASN1uint64_t)val->value[val->length - 2] << 8) |
            ((ASN1uint64_t)val->value[val->length - 3] << 16) |
            ((ASN1uint64_t)val->value[val->length - 4] << 24) |
            ((ASN1uint64_t)val->value[val->length - 5] << 32) |
            ((ASN1uint64_t)val->value[val->length - 6] << 40) |
            ((ASN1uint64_t)val->value[val->length - 7] << 48) |
            ((ASN1uint64_t)val->value[val->length - 8] << 56));
    }
}
#endif

/* check if intx value is a uint64 value */
int
ASN1intxisuint64(ASN1intx_t *val)
{
    if (val->value[0] > 0x7f)
        return 0;
    return ASN1intx_uoctets(val) <= 8;
}

#ifdef HAS_SIXTYFOUR_BITS
/* convert an intx value to a int64 value */
ASN1int64_t
ASN1intx2int64(ASN1intx_t *val)
{
    switch (val->length) {
    case 1:
        return (ASN1int64_t)(ASN1int8_t)val->value[val->length - 1];
    case 2:
        return (ASN1int64_t)(ASN1int16_t)(val->value[val->length - 1] |
            ((ASN1uint32_t)val->value[val->length - 2] << 8));
    case 3:
        return (ASN1int64_t)(ASN1int32_t)(val->value[val->length - 1] |
            ((ASN1uint32_t)val->value[val->length - 2] << 8) |
            ((ASN1uint32_t)val->value[val->length - 3] << 16) |
            ((ASN1uint32_t)val->value[val->length - 3] > 0x7f ?
            0xffffffffff000000LL : 0));
    case 4:
        return (ASN1int64_t)(ASN1int32_t)(val->value[val->length - 1] |
            ((ASN1uint32_t)val->value[val->length - 2] << 8) |
            ((ASN1uint32_t)val->value[val->length - 3] << 16) |
            ((ASN1uint32_t)val->value[val->length - 4] << 24));
    case 5:
        return (ASN1int64_t)(val->value[val->length - 1] |
            ((ASN1uint64_t)val->value[val->length - 2] << 8) |
            ((ASN1uint64_t)val->value[val->length - 3] << 16) |
            ((ASN1uint64_t)val->value[val->length - 4] << 24) |
            ((ASN1uint64_t)val->value[val->length - 5] << 32) |
            ((ASN1uint64_t)val->value[val->length - 5] > 0x7f ?
            0xffffff0000000000LL : 0));
    case 6:
        return (ASN1int64_t)(val->value[val->length - 1] |
            ((ASN1uint64_t)val->value[val->length - 2] << 8) |
            ((ASN1uint64_t)val->value[val->length - 3] << 16) |
            ((ASN1uint64_t)val->value[val->length - 4] << 24) |
            ((ASN1uint64_t)val->value[val->length - 5] << 32) |
            ((ASN1uint64_t)val->value[val->length - 6] << 40) |
            ((ASN1uint64_t)val->value[val->length - 6] > 0x7f ?
            0xffff000000000000LL : 0));
    case 7:
        return (ASN1int64_t)((ASN1uint64_t)val->value[val->length - 1] |
            ((ASN1uint64_t)val->value[val->length - 2] << 8) |
            ((ASN1uint64_t)val->value[val->length - 3] << 16) |
            ((ASN1uint64_t)val->value[val->length - 4] << 24) |
            ((ASN1uint64_t)val->value[val->length - 5] << 32) |
            ((ASN1uint64_t)val->value[val->length - 6] << 40) |
            ((ASN1uint64_t)val->value[val->length - 7] << 48) |
            ((ASN1uint64_t)val->value[val->length - 7] > 0x7f ?
            0xff00000000000000LL : 0));
    default:
        return (ASN1int64_t)((ASN1uint64_t)val->value[val->length - 1] |
            ((ASN1uint64_t)val->value[val->length - 2] << 8) |
            ((ASN1uint64_t)val->value[val->length - 3] << 16) |
            ((ASN1uint64_t)val->value[val->length - 4] << 24) |
            ((ASN1uint64_t)val->value[val->length - 5] << 32) |
            ((ASN1uint64_t)val->value[val->length - 6] << 40) |
            ((ASN1uint64_t)val->value[val->length - 7] << 48) |
            ((ASN1uint64_t)val->value[val->length - 8] << 56));
    }
}
#endif

/* check if intx value is an int64 value */
int
ASN1intxisint64(ASN1intx_t *val)
{
    return ASN1intx_octets(val) <= 8;
}

/* convert intx value to uint32 value */
ASN1uint32_t
ASN1intx2uint32(ASN1intx_t *val)
{
    switch (val->length) {
    case 1:
        return (ASN1uint32_t)val->value[val->length - 1];
    case 2:
        return (ASN1uint32_t)(val->value[val->length - 1] |
            ((ASN1uint32_t)val->value[val->length - 2] << 8));
    case 3:
        return (ASN1uint32_t)(val->value[val->length - 1] |
            ((ASN1uint32_t)val->value[val->length - 2] << 8) |
            ((ASN1uint32_t)val->value[val->length - 3] << 16));
    default:
        return (ASN1uint32_t)(val->value[val->length - 1] |
            ((ASN1uint32_t)val->value[val->length - 2] << 8) |
            ((ASN1uint32_t)val->value[val->length - 3] << 16) |
            ((ASN1uint32_t)val->value[val->length - 4] << 24));
    }
}

/* check if intx value is an uint32 value */
int
ASN1intxisuint32(ASN1intx_t *val)
{
    if (val->value[0] > 0x7f)
        return 0;
    return ASN1intx_uoctets(val) <= 4;
}

/* convert intx value to int32 value */
ASN1int32_t
ASN1intx2int32(ASN1intx_t *val)
{
    switch (val->length) {
    case 1:
        return (ASN1int32_t)(ASN1int8_t)val->value[val->length - 1];
    case 2:
        return (ASN1int32_t)(ASN1int16_t)(val->value[val->length - 1] |
            ((ASN1uint32_t)val->value[val->length - 2] << 8));
    case 3:
        return (ASN1int32_t)(val->value[val->length - 1] |
            ((ASN1uint32_t)val->value[val->length - 2] << 8) |
            ((ASN1uint32_t)val->value[val->length - 3] << 16) |
            ((ASN1uint32_t)val->value[val->length - 3] > 0x7f ?
            0xff000000 : 0));
    default:
        return (ASN1int32_t)(val->value[val->length - 1] |
            ((ASN1uint32_t)val->value[val->length - 2] << 8) |
            ((ASN1uint32_t)val->value[val->length - 3] << 16) |
            ((ASN1uint32_t)val->value[val->length - 4] << 24));
    }
}

/* check if intx value is an int32 value */
int
ASN1intxisint32(ASN1intx_t *val)
{
    return ASN1intx_octets(val) <= 4;
}

/* convert intx value to uint16 value */
ASN1uint16_t
ASN1intx2uint16(ASN1intx_t *val)
{
    if (val->length == 1)
        return (ASN1uint16_t)val->value[val->length - 1];
    return (ASN1uint16_t)(val->value[val->length - 1] |
        ((ASN1uint32_t)val->value[val->length - 2] << 8));
}

/* check if intx value is an uint16 value */
int
ASN1intxisuint16(ASN1intx_t *val)
{
    if (val->value[0] > 0x7f)
        return 0;
    return ASN1intx_uoctets(val) <= 2;
}

/* convert intx value to int16 value */
ASN1int16_t
ASN1intx2int16(ASN1intx_t *val)
{
    if (val->length == 1)
        return (ASN1int16_t)(ASN1int8_t)val->value[val->length - 1];
    return (ASN1int16_t)(val->value[val->length - 1] |
        ((ASN1uint32_t)val->value[val->length - 2] << 8));
}

/* check if intx value is an int16 value */
int
ASN1intxisint16(ASN1intx_t *val)
{
    return ASN1intx_octets(val) <= 2;
}

/* convert intx value to uint8 value */
ASN1uint8_t
ASN1intx2uint8(ASN1intx_t *val)
{
    return (ASN1uint8_t)val->value[val->length - 1];
}

/* check if intx value is an uint8 value */
int
ASN1intxisuint8(ASN1intx_t *val)
{
    if (val->value[0] > 0x7f)
        return 0;
    return ASN1intx_uoctets(val) <= 1;
}

/* convert intx value to int8 value */
ASN1int8_t
ASN1intx2int8(ASN1intx_t *val)
{
    return (ASN1int8_t)val->value[val->length - 1];
}

/* check if intx value is an int8 value */
int
ASN1intxisint8(ASN1intx_t *val)
{
    return ASN1intx_octets(val) <= 1;
}

/* count octets for a signed encoding of an intx value */
ASN1uint32_t
ASN1intx_octets(ASN1intx_t *val)
{
    ASN1uint32_t i;
    ASN1uint32_t s;

    s = val->value[0] > 0x7f ? 0xff : 0x00;
    for (i = 0; i < val->length; i++) {
        if (val->value[i] != s)
            break;
    }
    if (i && ((val->value[i] ^ s) & 0x80))
        i--;
    return val->length - i;
}

/* count octets for unsigned encoding of an unsigned intx value */
ASN1uint32_t
ASN1intx_uoctets(ASN1intx_t *val)
{
    ASN1uint32_t i;

    for (i = 0; i < val->length; i++) {
        if (val->value[i])
            break;
    }
    return val->length - i;
}

/* count octets for signed encoding of an uint32 value */
ASN1uint32_t
ASN1uint32_octets(ASN1uint32_t val)
{
    if (val >= 0x8000) {
        if (val >= 0x800000) {
            if (val >= 0x80000000)
                return 5;
            return 4;
        }
        return 3;
    }
    if (val >= 0x80)
        return 2;
    return 1;
}

/* count octets for unsigned encoding of an uint32 value */
ASN1uint32_t
ASN1uint32_uoctets(ASN1uint32_t val)
{
    if (val >= 0x10000) {
        if (val >= 0x1000000)
            return 4;
        return 3;
    }
    if (val >= 0x100)
        return 2;
    return 1;
}

/* count octets for signed encoding of an int32 value */
ASN1uint32_t
ASN1int32_octets(ASN1int32_t val)
{
    if (val >= 0) {
        if (val >= 0x8000) {
            if (val >= 0x800000)
                return 4;
            return 3;
        }
        if (val >= 0x80)
            return 2;
        return 1;
    }
    if (val < -0x8000) {
        if (val < -0x800000)
            return 4;
        return 3;
    }
    if (val < -0x80)
        return 2;
    return 1;
}

/* convert an intx value into a double */
double
ASN1intx2double(ASN1intx_t *val)
{
    double ret;
    ASN1uint32_t i;

    if (val->value[0] > 0x7f)
        ret = (double)(val->value[0] - 0x100);
    else
        ret = (double)val->value[0];
    for (i = 1; i < val->length; i++) {
        ret = ret * 256.0 + (double)val->value[i];
    }
    return ret;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\asn1\asn1c\libasn1.h ===
/* Copyright (C) Boris Nikolaus, Germany, 1996-1997. All rights reserved. */
/* Copyright (C) Microsoft Corporation 1997-1998, All rights reserved. */

#ifndef __ASN1C_LIB_ASN1_H__
#define __ASN1C_LIB_ASN1_H__

#include <msasn1.h>

#ifdef __cplusplus
extern "C" {
#endif

// THE FOLLOWING IS FROM MS_CORE.H

/*
 * This file contains operating system specific defines:
 *
 * Dynamic link library support:
 * Define DllExport as declspec for exported functions and
 * DllImport as declspec for imported functions.
 *
 * Floating point encoding support:
 * For encoding floating point values either
 * - finite()+isinf()+copysign()+frexp() or
 * - finite()+fpclass()+FP_PINF+FP_NINF+frexp()
 * is needed. Define HAS_ISINF for the former case or HAS_FPCLASS for
 * the latter case.
 * Define HAS_IEEEFP_H for inclusion of <ieeefp.h> or HAS_FLOAT_H for
 * inclusion of <float.h> if required.
 *
 * Integer type support
 * [u]int{8,16,32}_t must specify an integral (unsigned iff u-prefixed)
 * type of the specified size (in bits).
 */

/* MS-Windows 95/MS-Windows NT */
#define THIRTYTWO_BITS  1
// #define HAS_SIXTYFOUR_BITS 1
#define HAS_FLOAT_H     1
#define HAS_FPCLASS     1
#define fpclass(_d)     _fpclass(_d)
#define finite(_d)      _finite(_d)
#define isnan(_d)       _isnan(_d)
#define FP_PINF         _FPCLASS_PINF
#define FP_NINF         _FPCLASS_NINF
// #define HAS_STRICMP     1
#define DBL_PINF        {0x00,0x00,0x00,0x00,0x00,0x00,0xf0,0x7f}
#define DBL_MINF        {0x00,0x00,0x00,0x00,0x00,0x00,0xf0,0xff}


extern ASN1_PUBLIC ASN1intx_t ASN1intx_0, ASN1intx_1, ASN1intx_2, ASN1intx_16, ASN1intx_256, ASN1intx_64K, ASN1intx_1G;
// extern ASN1_PUBLIC ASN1stringtable_t ASN1NumericStringTable;
extern ASN1_PUBLIC void ASN1API ASN1intx_addoctet(ASN1intx_t *, ASN1intx_t *, ASN1octet_t);
extern ASN1_PUBLIC void ASN1API ASN1intx_suboctet(ASN1intx_t *, ASN1intx_t *, ASN1octet_t);
extern ASN1_PUBLIC void ASN1API ASN1intx_muloctet(ASN1intx_t *, ASN1intx_t *, ASN1octet_t);
extern ASN1_PUBLIC void ASN1API ASN1intx_inc(ASN1intx_t *);
extern ASN1_PUBLIC void ASN1API ASN1intx_dec(ASN1intx_t *);
extern ASN1_PUBLIC void ASN1API ASN1intx_neg(ASN1intx_t *, ASN1intx_t *);
extern ASN1_PUBLIC ASN1uint32_t ASN1API ASN1intx_log2(ASN1intx_t *);
extern ASN1_PUBLIC ASN1uint32_t ASN1API ASN1intx_log256(ASN1intx_t *);
extern ASN1_PUBLIC ASN1int32_t ASN1API ASN1intx_cmp(ASN1intx_t *, ASN1intx_t *);
extern ASN1_PUBLIC void ASN1API ASN1intx_dup(ASN1intx_t *, ASN1intx_t *);
extern ASN1_PUBLIC void ASN1API ASN1intx_setuint32(ASN1intx_t *, ASN1uint32_t);
extern ASN1_PUBLIC void ASN1API ASN1intx_setint32(ASN1intx_t *, ASN1int32_t);
extern ASN1_PUBLIC int ASN1API ASN1intxisuint64(ASN1intx_t *);
extern ASN1_PUBLIC int ASN1API ASN1intxisint64(ASN1intx_t *);
extern ASN1_PUBLIC int ASN1API ASN1intxisuint32(ASN1intx_t *);
extern ASN1_PUBLIC int ASN1API ASN1intxisint32(ASN1intx_t *);
extern ASN1_PUBLIC int ASN1API ASN1intxisuint16(ASN1intx_t *);
extern ASN1_PUBLIC int ASN1API ASN1intxisint16(ASN1intx_t *);
extern ASN1_PUBLIC int ASN1API ASN1intxisuint8(ASN1intx_t *);
extern ASN1_PUBLIC int ASN1API ASN1intxisint8(ASN1intx_t *);
#ifdef HAS_SIXTYFOUR_BITS
extern ASN1_PUBLIC ASN1uint64_t ASN1API ASN1intx2uint64(ASN1intx_t *);
extern ASN1_PUBLIC ASN1int64_t ASN1API ASN1intx2int64(ASN1intx_t *);
#endif
extern ASN1_PUBLIC ASN1uint32_t ASN1API ASN1intx2uint32(ASN1intx_t *);
extern ASN1_PUBLIC ASN1int32_t ASN1API ASN1intx2int32(ASN1intx_t *);
extern ASN1_PUBLIC ASN1uint16_t ASN1API ASN1intx2uint16(ASN1intx_t *);
extern ASN1_PUBLIC ASN1int16_t ASN1API ASN1intx2int16(ASN1intx_t *);
extern ASN1_PUBLIC ASN1uint8_t ASN1API ASN1intx2uint8(ASN1intx_t *);
extern ASN1_PUBLIC ASN1int8_t ASN1API ASN1intx2int8(ASN1intx_t *);
extern ASN1_PUBLIC ASN1uint32_t ASN1API ASN1intx_octets(ASN1intx_t *);
extern ASN1_PUBLIC ASN1uint32_t ASN1API ASN1uint32_log2(ASN1uint32_t);
extern ASN1_PUBLIC ASN1uint32_t ASN1API ASN1uint32_log256(ASN1uint32_t);
extern ASN1_PUBLIC ASN1uint32_t ASN1API ASN1uint32_octets(ASN1uint32_t);
extern ASN1_PUBLIC ASN1uint32_t ASN1API ASN1uint32_uoctets(ASN1uint32_t);
extern ASN1_PUBLIC ASN1uint32_t ASN1API ASN1int32_octets(ASN1int32_t);
extern ASN1_PUBLIC double ASN1API ASN1intx2double(ASN1intx_t *);
extern ASN1_PUBLIC double ASN1API ASN1real2double(ASN1real_t *);
extern ASN1_PUBLIC double ASN1API ASN1double_minf();
extern ASN1_PUBLIC double ASN1API ASN1double_pinf();
extern ASN1_PUBLIC int ASN1API ASN1double_isminf(double);
extern ASN1_PUBLIC int ASN1API ASN1double_ispinf(double);
extern ASN1_PUBLIC int ASN1API ASN1generalizedtime2string(char *, ASN1generalizedtime_t *);
extern ASN1_PUBLIC int ASN1API ASN1utctime2string(char *, ASN1utctime_t *);
extern ASN1_PUBLIC int ASN1API ASN1string2generalizedtime(ASN1generalizedtime_t *, char *);
extern ASN1_PUBLIC int ASN1API ASN1string2utctime(ASN1utctime_t *, char *);

/* ------ Memory Free APIs ------ */

extern ASN1_PUBLIC void ASN1API ASN1real_free(ASN1real_t *);
extern ASN1_PUBLIC void ASN1API ASN1bitstring_free(ASN1bitstring_t *);
extern ASN1_PUBLIC void ASN1API ASN1octetstring_free(ASN1octetstring_t *);
extern ASN1_PUBLIC void ASN1API ASN1objectidentifier_free(ASN1objectidentifier_t *);
extern ASN1_PUBLIC void ASN1API ASN1charstring_free(ASN1charstring_t *);
extern ASN1_PUBLIC void ASN1API ASN1char16string_free(ASN1char16string_t *);
extern ASN1_PUBLIC void ASN1API ASN1char32string_free(ASN1char32string_t *);
extern ASN1_PUBLIC void ASN1API ASN1ztcharstring_free(ASN1ztcharstring_t);
extern ASN1_PUBLIC void ASN1API ASN1ztchar16string_free(ASN1ztchar16string_t);
extern ASN1_PUBLIC void ASN1API ASN1ztchar32string_free(ASN1ztchar32string_t);
extern ASN1_PUBLIC void ASN1API ASN1external_free(ASN1external_t *);
extern ASN1_PUBLIC void ASN1API ASN1embeddedpdv_free(ASN1embeddedpdv_t *);
extern ASN1_PUBLIC void ASN1API ASN1characterstring_free(ASN1characterstring_t *);
extern ASN1_PUBLIC void ASN1API ASN1open_free(ASN1open_t *);

/* ------ Comparison APIs ------ */

extern ASN1_PUBLIC long ASN1API ASN1double_cmp(double, double);
extern ASN1_PUBLIC long ASN1API ASN1real_cmp(ASN1real_t *, ASN1real_t *);
extern ASN1_PUBLIC long ASN1API ASN1external_cmp(ASN1external_t *, ASN1external_t *);
extern ASN1_PUBLIC long ASN1API ASN1embeddedpdv_cmp(ASN1embeddedpdv_t *, ASN1embeddedpdv_t *);
extern ASN1_PUBLIC long ASN1API ASN1characterstring_cmp(ASN1characterstring_t *, ASN1characterstring_t *);
extern ASN1_PUBLIC long ASN1API ASN1sequenceoflengthpointer_cmp(ASN1uint32_t, void *, ASN1uint32_t, void *, ASN1uint32_t, int (*)(void *, void *));
extern ASN1_PUBLIC long ASN1API ASN1sequenceofsinglylinkedlist_cmp(void *, void *, ASN1uint32_t, int (*)(void *, void *));
extern ASN1_PUBLIC long ASN1API ASN1sequenceofdoublylinkedlist_cmp(void *, void *, ASN1uint32_t, int (*)(void *, void *));
extern ASN1_PUBLIC long ASN1API ASN1setoflengthpointer_cmp(ASN1uint32_t, void *, ASN1uint32_t, void *, ASN1uint32_t, int (*)(void *, void *));
extern ASN1_PUBLIC long ASN1API ASN1setofsinglylinkedlist_cmp(void *, void *, ASN1uint32_t, int (*)(void *, void *));
extern ASN1_PUBLIC long ASN1API ASN1setofdoublylinkedlist_cmp(void *, void *, ASN1uint32_t, int (*)(void *, void *));



#define ASN1BITSET(_val, _bitnr) \
    ((_val)[(_bitnr) >> 3] |= 0x80 >> ((_bitnr) & 7))
#define ASN1BITCLR(_val, _bitnr) \
    ((_val)[(_bitnr) >> 3] &= ~(0x80 >> ((_bitnr) & 7)))
#define ASN1BITTEST(_val, _bitnr) \
    ((_val)[(_bitnr) >> 3] & (0x80 >> ((_bitnr) & 7)))
    



#ifdef __cplusplus
}
#endif

#endif // __ASN1C_LIB_ASN1_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\asn1\asn1c\list.c ===
/* Copyright (C) Boris Nikolaus, Germany, 1996-1997. All rights reserved. */
/* Copyright (C) Microsoft Corporation, 1997-1998. All rights reserved. */

#include "precomp.h"

/* get length of a singly linked list */
size_t SLlength(void *head, size_t offset)
{
    size_t nelem = 0;

    while (head) {
	/*LINTED*/
    	head = *(void **)((char *)head + offset);
	nelem++;
    }
    return nelem;
}

/* search for an element in a singly linked list */
int SLcontains(void *head, size_t offset, void *elem)
{
    while (head) {
	if (head == elem)
	    return 1;
	/*LINTED pointer cast may result in improper alignment*/
	head = *(void **)((char *)head + offset);
    }
    return 0;
}

/* copy elements of a singly linked list into an array */
void SLtoA(void *head, size_t offset, size_t elemsize, void **base, size_t *nelem)
{
    void *p;

    *nelem = SLlength(head, offset);
    if (!*nelem) {
    	*base = NULL;
	return;
    }
    p = *base = malloc(*nelem * elemsize);
    /*LINTED*/
    for (; head; head = *(void **)((char *)head + offset)) {
    	memcpy(p, head, elemsize);
	p = (void *)((char *)p + elemsize);
    }
}

/* copy pointers to elements of a singly linked list into an array */
void SLtoAP(void *head, size_t offset, void ***base, size_t *nelem)
{
    void **p;

    *nelem = SLlength(head, offset);
    if (!*nelem) {
    	*base = NULL;
	return;
    }
    p = *base = (void **)malloc(*nelem * sizeof(void *));
    /*LINTED*/
    for (; head; head = *(void **)((char *)head + offset)) {
    	*p++ = head;
    }
}

/* copy elements of an array into a singly linked list */
void AtoSL(void *base, size_t offset, size_t nelem, size_t elemsize, void **head)
{
    while (nelem--) {
    	*head = malloc(elemsize);
	memcpy(*head, base, elemsize);
	base = (void *)((char *)base + elemsize);
	/*LINTED*/
	head = (void **)((char *)*head + offset);
    }
    *head = NULL;
}

/* user defined compare function of qsortSL */
static int (*qsortSL_CmpFnCb)(const void *, const void *, void *);
static void *qsortSL_Context;

/* compare function of qsortSL */
static int __cdecl qsortSL_CmpFn(const void *p1, const void *p2)
{
    return qsortSL_CmpFnCb(*(void **)p1, *(void **)p2, qsortSL_Context);
}

/* sort a singly linked list */
void qsortSL(void **head, size_t offset, int (*cmpfn)(const void *, const void *, void *), void *context)
{
    void **base, **p;
    size_t nelem;

    SLtoAP(*head, offset, &base, &nelem);
    qsortSL_CmpFnCb = cmpfn;
    qsortSL_Context = context;
    qsort(base, nelem, sizeof(void *), qsortSL_CmpFn);
    p = base;
    while (nelem--) {
    	*head = *p++;
	/*LINTED*/
	head = (void **)((char *)*head + offset);
    }
    *head = NULL;
    free(base);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\asn1\asn1c\objid.c ===
/* Copyright (C) Boris Nikolaus, Germany, 1996-1997. All rights reserved. */
/* Copyright (C) Microsoft Corporation, 1997-1998. All rights reserved. */

#include "precomp.h"

/* --- NamedObjIdValue --- */

/* constructor of NamedObjIdValue_t */
NamedObjIdValue_t *NewNamedObjIdValue(NamedObjIdValue_e type)
{
    NamedObjIdValue_t *ret;

    ret = (NamedObjIdValue_t *)malloc(sizeof(NamedObjIdValue_t));
    ret->Type = type;
    ret->Next = NULL;
    ret->Name = NULL;
    ret->Number = 0xffffffff;
    return ret;
}

/* copy constructor of NamedObjIdValue_t */
NamedObjIdValue_t *DupNamedObjIdValue(NamedObjIdValue_t *src)
{
    NamedObjIdValue_t *ret;

    if (!src)
	return NULL;
    ret = (NamedObjIdValue_t *)malloc(sizeof(NamedObjIdValue_t));
    *ret = *src;
    return ret;
}

/* --- AssignedObjIds --- */

/* constructor of AssignedObjId_t */
AssignedObjId_t *NewAssignedObjId()
{
    AssignedObjId_t *ret;

    ret = (AssignedObjId_t *)malloc(sizeof(AssignedObjId_t));
    ret->Next = NULL;
    ret->Child = NULL;
    ret->Names = NULL;
    ret->Number = 0;
    return ret;
}

/* copy constructor of AssignedObjId_t */
AssignedObjId_t *DupAssignedObjId(AssignedObjId_t *src)
{
    AssignedObjId_t *ret;

    if (!src)
	return NULL;
    ret = (AssignedObjId_t *)malloc(sizeof(AssignedObjId_t));
    *ret = *src;
    return ret;
}

/* find an AssignedObjId_t by number in a list of AssignedObjId_t's */
static AssignedObjId_t *FindAssignedObjIdByNumber(AssignedObjId_t *aoi, objectnumber_t number)
{
    for (; aoi; aoi = aoi->Next) {
    	if (aoi->Number == number)
	    return aoi;
    }
    return NULL;
}

/* find an AssignedObjId_t by name in a list of AssignedObjId_t's */
static AssignedObjId_t *FindAssignedObjIdByName(AssignedObjId_t *aoi, char *name)
{
    String_t *names;

    for (; aoi; aoi = aoi->Next) {
	for (names = aoi->Names; names; names = names->Next) {
	    if (!strcmp(names->String, name))
		return aoi;
	}
    }
    return NULL;
}

/* convert a NamedObjIdValue into an object identifier value */
/* search for one NamedObjIdValue in AssignedObjIds; */
/* returns -1 for bad NamedObjIdValue (names defined to different values), */
/* returns 0 for unknown NamedObjIdValue (will probably be resolved in */
/* the next pass), */
/* returns 1 for success; */
/* on success: */
/* number contains the objectnumber, */
/* aoi contains a duplicate of the AssignedObjIds for the found */
/* NamedObjIdValue */
static int GetObjectIdentifierNumber(AssignedObjId_t **aoi, NamedObjIdValue_t *val, objectnumber_t *number)
{
    AssignedObjId_t *a, *a2;

    switch (val->Type) {
    case eNamedObjIdValue_NameForm:

	/* name form: search the assigned objid by name and return 0 if not */
	/* found */
	a2 = FindAssignedObjIdByName(*aoi, val->Name);
	if (!a2)
	    return 0;
	
	/* otherwise create a duplicate */
	a = DupAssignedObjId(a2);
	a->Next = *aoi;
	*aoi = a;
	break;

    case eNamedObjIdValue_NumberForm:

	/* number form: search the assigned objid by number and create */
	/* a new one/a duplicate */
	a2 = FindAssignedObjIdByNumber(*aoi, val->Number);
	if (!a2) {
	    a = NewAssignedObjId();
	    a->Number = val->Number;
	    a->Next = *aoi;
	    *aoi = a;
	} else {
	    a = DupAssignedObjId(a2);
	    a->Next = *aoi;
	    *aoi = a;
	}
	break;

    case eNamedObjIdValue_NameAndNumberForm:

	/* name and number form: search the assigned objid by name and by */
	/* number */
	a = FindAssignedObjIdByName(*aoi, val->Name);
	a2 = FindAssignedObjIdByNumber(*aoi, val->Number);

	/* successful but different results are errorneous */
	if (a && a != a2)
	    return -1;

	if (!a && !a2) {

	    /* found none, then create it */
	    a = NewAssignedObjId();
	    a->Number = val->Number;
	    a->Names = NewString();
	    a->Names->String = val->Name;
	    a->Next = *aoi;
	    *aoi = a;

	} else if (!a) {

	    /* found only by number, then duplicate it and add the name */
	    a = DupAssignedObjId(a2);
	    a->Names = NewString();
	    a->Names->String = val->Name;
	    a->Names->Next = a2->Names;
	    a->Next = *aoi;
	    *aoi = a;

	} else {

	    /* found only by name, then duplicate it */
	    a = DupAssignedObjId(a2);
	    a->Next = *aoi;
	    *aoi = a;
	}
	break;
    }
    *number = a->Number;
    return 1;
}

/*
 * create a value out of NamedObjIdValues
 * returns -1 for bad NamedObjIdValue (names defined to different values),
 * returns 0 for unknown NamedObjIdValue (will probably be resolved next pass),
 * returns 1 for success;
 */
int GetAssignedObjectIdentifier(AssignedObjId_t **aoi, Value_t *parent, NamedObjIdValueList_t named, Value_t **val)
{
    Value_t *v;
    int parentl;
    int l;
    NamedObjIdValue_t *n;
    objectnumber_t *on;

    /* get length of object identifier */
    parentl = (parent ? parent->U.ObjectIdentifier.Value.length : 0);
    for (l = parentl, n = named; n; n = n->Next)
    {
        Value_t *pValue;
        pValue = (n->Type == eNamedObjIdValue_NameForm) ?
                 GetDefinedOIDValue(n->Name) : NULL;
        if (pValue)
        {
            ASSERT(pValue->Type->Type == eType_ObjectIdentifier);
            l += pValue->U.ObjectIdentifier.Value.length;
        }
        else
        {
            l++;
        }
    }

    /* create the object identifier value */
    v = NewValue(NULL, Builtin_Type_ObjectIdentifier);
    v->U.ObjectIdentifier.Value.length = l;
    v->U.ObjectIdentifier.Value.value = on = 
	(objectnumber_t *)malloc(l * sizeof(objectnumber_t));

    /* get the numbers of the parent object identifier and walk in the object */
    /* identifier tree */
    n = NewNamedObjIdValue(eNamedObjIdValue_NumberForm);
    for (l = 0; l < parentl; l++) {
	n->Number = parent->U.ObjectIdentifier.Value.value[l];
	switch (GetObjectIdentifierNumber(aoi, n, on + l)) {
	case -1:
	    return -1;
	case 0:
	    return 0;
	default:
	    aoi = &(*aoi)->Child;
	    break;
	}
    }

    /* get the numers from the namedobjidvaluelist */
    for (n = named; n; n = n->Next)
    {
        Value_t *pValue;
        pValue = (n->Type == eNamedObjIdValue_NameForm) ?
                 GetDefinedOIDValue(n->Name) : NULL;
        if (pValue)
        {
            memcpy(on + l, pValue->U.ObjectIdentifier.Value.value,
                 pValue->U.ObjectIdentifier.Value.length * sizeof(objectnumber_t));
            l += pValue->U.ObjectIdentifier.Value.length;
        }
        else
        {
	        switch (GetObjectIdentifierNumber(aoi, n, on + l))
            {
	        case -1:
	            return -1;
	        case 0:
	            return 0;
	        default:
	            aoi = &(*aoi)->Child;
	            break;
	        }
            l++;
        }
    }

    *val = v;
    return 1;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\asn1\asn1c\optcase.h ===
/* Copyright (C) Boris Nikolaus, Germany, 1996-1997. All rights reserved. */
/* Copyright (C) Microsoft Corporation, 1997-1998. All rights reserved. */

#ifndef _ASN1C_OPT_CASE_H_
#define _ASN1C_OPT_CASE_H_

int PerOptCase_IsSignedInteger(PERSimpleTypeInfo_t *sinfo);
int PerOptCase_IsUnsignedInteger(PERSimpleTypeInfo_t *sinfo);
int PerOptCase_IsSignedShort(PERSimpleTypeInfo_t *sinfo);
int PerOptCase_IsUnsignedShort(PERSimpleTypeInfo_t *sinfo);
int PerOptCase_IsBoolean(PERSimpleTypeInfo_t *sinfo);
int PerOptCase_IsTargetSeqOf(PERTypeInfo_t *info);

int BerOptCase_IsBoolean(BERTypeInfo_t *info);

#endif // _ASN1C_OPT_CASE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\asn1\asn1c\parser.h ===
#ifndef _ASN1_PARSER_ 
#define _ASN1_PARSER_ 
/* Copyright (C) Boris Nikolaus, Germany, 1996-1997. All rights reserved. */

typedef char *XString;
typedef char32_t *XString32;
typedef intx_t XNumber;
typedef ASN1bool_t XBoolean;
typedef Type_t *XType;
typedef TagType_e XTagType;
typedef TagClass_e XTagClass;
typedef Tag_t *XTags;
typedef ExtensionType_e XExtensionType;
typedef NamedType_t *XNamedType;
typedef ComponentList_t XComponents;
typedef Constraint_t *XConstraints;
typedef ElementSetSpec_t *XElementSetSpec;
typedef SubtypeElement_t *XSubtypeElement;
typedef ObjectSetElement_t *XObjectSetElement;
typedef DirectiveList_t XDirectives;
typedef NamedConstraintList_t XNamedConstraints;
typedef Presence_e XPresence;
typedef NamedNumberList_t XNamedNumbers;
typedef Value_t *XValue;
typedef ValueSet_t *XValueSet;
typedef EndPoint_t XEndPoint;
typedef Tuple_t XTuple;
typedef Quadruple_t XQuadruple;
typedef NamedValueList_t XNamedValues;
typedef ModuleIdentifier_t *XModuleIdentifier;
typedef NamedObjIdValueList_t XNamedObjIdValue;
typedef ObjectClass_t *XObjectClass;
typedef ObjectSet_t *XObjectSet;
typedef Object_t *XObject;
typedef SyntaxSpecList_t XSyntaxSpecs;
typedef FieldSpecList_t XFieldSpecs;
typedef Optionality_t *XOptionality;
typedef SettingList_t XSettings;
typedef StringList_t XStrings;
typedef StringModuleList_t XStringModules;
typedef Macro_t *XMacro;
typedef MacroProduction_t *XMacroProduction;
typedef NamedMacroProductionList_t XMacroProductions;
typedef MacroLocalAssignmentList_t XMacroLocalAssignments;
typedef PrivateDirectives_t *XPrivateDirectives;
typedef struct LLPOS {
	int line;
	int column;
	char *file;
} LLPOS;
typedef struct LLSTATE {
	LLPOS pos;
	AssignmentList_t Assignments;
	AssignedObjIdList_t AssignedObjIds;
	UndefinedSymbolList_t Undefined;
	UndefinedSymbolList_t BadlyDefined;
	ModuleIdentifier_t *Module;
	ModuleIdentifier_t *MainModule;
	StringModuleList_t Imported;
	TagType_e TagDefault;
	ExtensionType_e ExtensionDefault;
} LLSTATE;
int ll_Main(LLSTATE *llin, LLSTATE *llout);
int ll_ModuleDefinition_ESeq(LLSTATE *llin, LLSTATE *llout);
int ll_ModuleDefinition(LLSTATE *llin, LLSTATE *llout);
int ll_ModuleIdentifier(XModuleIdentifier *llret, LLSTATE *llin, LLSTATE *llout);
int ll_DefinitiveIdentifier(XValue *llret, LLSTATE *llin, LLSTATE *llout);
int ll_DefinitiveObjIdComponentList(XNamedObjIdValue *llret, LLSTATE *llin, LLSTATE *llout);
int ll_DefinitiveObjIdComponent(XNamedObjIdValue *llret, LLSTATE *llin, LLSTATE *llout);
int ll_DefinitiveNumberForm(XNamedObjIdValue *llret, LLSTATE *llin, LLSTATE *llout);
int ll_DefinitiveNameAndNumberForm(XNamedObjIdValue *llret, LLSTATE *llin, LLSTATE *llout);
int ll_TagDefault(XTagType *llret, LLSTATE *llin, LLSTATE *llout);
int ll_ExtensionDefault(XExtensionType *llret, LLSTATE *llin, LLSTATE *llout);
int ll_ModuleBody(LLSTATE *llin, LLSTATE *llout);
int ll_Exports(XStrings *llret, LLSTATE *llin, LLSTATE *llout);
int ll_SymbolsExported(XStrings *llret, LLSTATE *llin, LLSTATE *llout);
int ll_Imports(XStringModules *llret, LLSTATE *llin, LLSTATE *llout);
int ll_SymbolsImported(XStringModules *llret, LLSTATE *llin, LLSTATE *llout);
int ll_SymbolsFromModule_ESeq(XStringModules *llret, LLSTATE *llin, LLSTATE *llout);
int ll_SymbolsFromModule(XStringModules *llret, LLSTATE *llin, LLSTATE *llout);
int ll_GlobalModuleReference(XModuleIdentifier *llret, LLSTATE *llin, LLSTATE *llout);
int ll_AssignedIdentifier(XValue *llret, LLSTATE *llin, LLSTATE *llout);
int ll_SymbolList(XStrings *llret, LLSTATE *llin, LLSTATE *llout);
int ll_Symbol(XString *llret, LLSTATE *llin, LLSTATE *llout);
int ll_Reference(XString *llret, LLSTATE *llin, LLSTATE *llout);
int ll_AssignmentList(LLSTATE *llin, LLSTATE *llout);
int ll_Assignment_ESeq(LLSTATE *llin, LLSTATE *llout);
int ll_Assignment(LLSTATE *llin, LLSTATE *llout);
int ll_typereference(XType *llret, LLSTATE *llin, LLSTATE *llout);
int ll_Externaltypereference(XType *llret, LLSTATE *llin, LLSTATE *llout);
int ll_valuereference(XValue *llret, LLSTATE *llin, LLSTATE *llout);
int ll_Externalvaluereference(XValue *llret, LLSTATE *llin, LLSTATE *llout);
int ll_objectclassreference(XObjectClass *llret, LLSTATE *llin, LLSTATE *llout);
int ll_ExternalObjectClassReference(XObjectClass *llret, LLSTATE *llin, LLSTATE *llout);
int ll_objectreference(XObject *llret, LLSTATE *llin, LLSTATE *llout);
int ll_ExternalObjectReference(XObject *llret, LLSTATE *llin, LLSTATE *llout);
int ll_objectsetreference(XObjectSet *llret, LLSTATE *llin, LLSTATE *llout);
int ll_ExternalObjectSetReference(XObjectSet *llret, LLSTATE *llin, LLSTATE *llout);
int ll_macroreference(XMacro *llret, LLSTATE *llin, LLSTATE *llout);
int ll_Externalmacroreference(XMacro *llret, LLSTATE *llin, LLSTATE *llout);
int ll_localtypereference(XString *llret, LLSTATE *llin, LLSTATE *llout);
int ll_localvaluereference(XString *llret, LLSTATE *llin, LLSTATE *llout);
int ll_productionreference(XString *llret, LLSTATE *llin, LLSTATE *llout);
int ll_modulereference(XModuleIdentifier *llret, LLSTATE *llin, LLSTATE *llout);
int ll_typefieldreference(XString *llret, LLSTATE *llin, LLSTATE *llout, XObjectClass llarg_oc);
int ll_valuefieldreference(XString *llret, LLSTATE *llin, LLSTATE *llout, XObjectClass llarg_oc);
int ll_valuesetfieldreference(XString *llret, LLSTATE *llin, LLSTATE *llout, XObjectClass llarg_oc);
int ll_objectfieldreference(XString *llret, LLSTATE *llin, LLSTATE *llout, XObjectClass llarg_oc);
int ll_objectsetfieldreference(XString *llret, LLSTATE *llin, LLSTATE *llout, XObjectClass llarg_oc);
int ll_word(XString *llret, LLSTATE *llin, LLSTATE *llout);
int ll_identifier(XString *llret, LLSTATE *llin, LLSTATE *llout);
int ll_ucsymbol(XString *llret, LLSTATE *llin, LLSTATE *llout);
int ll_ocsymbol(XString *llret, LLSTATE *llin, LLSTATE *llout);
int ll_astring(XString *llret, LLSTATE *llin, LLSTATE *llout);
int ll_DefinedType(XType *llret, LLSTATE *llin, LLSTATE *llout);
int ll_TypeAssignment(LLSTATE *llin, LLSTATE *llout);
int ll_ValueSetTypeAssignment(LLSTATE *llin, LLSTATE *llout);
int ll_ValueSet(XValueSet *llret, LLSTATE *llin, LLSTATE *llout, XType llarg_type);
int ll_Type(XType *llret, LLSTATE *llin, LLSTATE *llout);
int ll_UndirectivedType(XType *llret, LLSTATE *llin, LLSTATE *llout);
int ll_UntaggedType(XType *llret, LLSTATE *llin, LLSTATE *llout);
int ll_ConstrainableType(XType *llret, LLSTATE *llin, LLSTATE *llout);
int ll_Constraint_ESeq(XConstraints *llret, LLSTATE *llin, LLSTATE *llout, XType llarg_type);
int ll_BuiltinType(XType *llret, LLSTATE *llin, LLSTATE *llout);
int ll_ReferencedType(XType *llret, LLSTATE *llin, LLSTATE *llout);
int ll_NamedType(XNamedType *llret, LLSTATE *llin, LLSTATE *llout);
int ll_BooleanType(XType *llret, LLSTATE *llin, LLSTATE *llout);
int ll_IntegerType(XType *llret, LLSTATE *llin, LLSTATE *llout);
int ll_NamedNumberList(XNamedNumbers *llret, LLSTATE *llin, LLSTATE *llout);
int ll_NamedNumber(XNamedNumbers *llret, LLSTATE *llin, LLSTATE *llout);
int ll_EnumeratedType(XType *llret, LLSTATE *llin, LLSTATE *llout);
int ll_Enumerations(XNamedNumbers *llret, LLSTATE *llin, LLSTATE *llout);
int ll_EnumerationExtension(XNamedNumbers *llret, LLSTATE *llin, LLSTATE *llout);
int ll_Enumeration(XNamedNumbers *llret, LLSTATE *llin, LLSTATE *llout);
int ll_EnumerationItem(XNamedNumbers *llret, LLSTATE *llin, LLSTATE *llout);
int ll_RealType(XType *llret, LLSTATE *llin, LLSTATE *llout);
int ll_BitStringType(XType *llret, LLSTATE *llin, LLSTATE *llout);
int ll_NamedBitList(XNamedNumbers *llret, LLSTATE *llin, LLSTATE *llout);
int ll_NamedBit(XNamedNumbers *llret, LLSTATE *llin, LLSTATE *llout);
int ll_OctetStringType(XType *llret, LLSTATE *llin, LLSTATE *llout);
int ll_UTF8StringType(XType *llret, LLSTATE *llin, LLSTATE *llout);
int ll_NullType(XType *llret, LLSTATE *llin, LLSTATE *llout);
int ll_SequenceType(XType *llret, LLSTATE *llin, LLSTATE *llout);
int ll_ExtensionAndException(XComponents *llret, LLSTATE *llin, LLSTATE *llout);
int ll_ExtendedComponentTypeList(XComponents *llret, LLSTATE *llin, LLSTATE *llout);
int ll_ComponentTypeListExtension(XComponents *llret, LLSTATE *llin, LLSTATE *llout);
int ll_AdditionalComponentTypeList(XComponents *llret, LLSTATE *llin, LLSTATE *llout);
int ll_ComponentTypeList(XComponents *llret, LLSTATE *llin, LLSTATE *llout);
int ll_ComponentType(XComponents *llret, LLSTATE *llin, LLSTATE *llout);
int ll_ComponentTypePostfix(XComponents *llret, LLSTATE *llin, LLSTATE *llout, XType llarg_type);
int ll_SequenceOfType(XType *llret, LLSTATE *llin, LLSTATE *llout);
int ll_SetType(XType *llret, LLSTATE *llin, LLSTATE *llout);
int ll_SetOfType(XType *llret, LLSTATE *llin, LLSTATE *llout);
int ll_ChoiceType(XType *llret, LLSTATE *llin, LLSTATE *llout);
int ll_ExtendedAlternativeTypeList(XComponents *llret, LLSTATE *llin, LLSTATE *llout);
int ll_AlternativeTypeListExtension(XComponents *llret, LLSTATE *llin, LLSTATE *llout);
int ll_AdditionalAlternativeTypeList(XComponents *llret, LLSTATE *llin, LLSTATE *llout);
int ll_AlternativeTypeList(XComponents *llret, LLSTATE *llin, LLSTATE *llout);
int ll_AnyType(XType *llret, LLSTATE *llin, LLSTATE *llout);
int ll_SelectionType(XType *llret, LLSTATE *llin, LLSTATE *llout);
int ll_TaggedType(XType *llret, LLSTATE *llin, LLSTATE *llout);
int ll_TagType(XTagType *llret, LLSTATE *llin, LLSTATE *llout);
int ll_Tag(XTags *llret, LLSTATE *llin, LLSTATE *llout);
int ll_ClassNumber(XValue *llret, LLSTATE *llin, LLSTATE *llout);
int ll_Class(XTagClass *llret, LLSTATE *llin, LLSTATE *llout);
int ll_ObjectIdentifierType(XType *llret, LLSTATE *llin, LLSTATE *llout);
int ll_EmbeddedPDVType(XType *llret, LLSTATE *llin, LLSTATE *llout);
int ll_ExternalType(XType *llret, LLSTATE *llin, LLSTATE *llout);
int ll_CharacterStringType(XType *llret, LLSTATE *llin, LLSTATE *llout);
int ll_RestrictedCharacterStringType(XType *llret, LLSTATE *llin, LLSTATE *llout);
int ll_UnrestrictedCharacterStringType(XType *llret, LLSTATE *llin, LLSTATE *llout);
int ll_UsefulType(XType *llret, LLSTATE *llin, LLSTATE *llout);
int ll_TypeWithConstraint(XType *llret, LLSTATE *llin, LLSTATE *llout);
int ll_DefinedValue(XValue *llret, LLSTATE *llin, LLSTATE *llout);
int ll_ValueAssignment(LLSTATE *llin, LLSTATE *llout);
int ll_Value(XValue *llret, LLSTATE *llin, LLSTATE *llout, XType llarg_type);
int ll_BuiltinValue(XValue *llret, LLSTATE *llin, LLSTATE *llout, XType llarg_type);
int ll_ReferencedValue(XValue *llret, LLSTATE *llin, LLSTATE *llout);
int ll_NamedValue(XNamedValues *llret, LLSTATE *llin, LLSTATE *llout, XComponents llarg_components);
int ll_BooleanValue(XValue *llret, LLSTATE *llin, LLSTATE *llout, XType llarg_type);
int ll_SignedNumber(XValue *llret, LLSTATE *llin, LLSTATE *llout, XType llarg_type);
int ll_IntegerValue(XValue *llret, LLSTATE *llin, LLSTATE *llout, XType llarg_type);
int ll_EnumeratedValue(XValue *llret, LLSTATE *llin, LLSTATE *llout, XType llarg_type);
int ll_RealValue(XValue *llret, LLSTATE *llin, LLSTATE *llout, XType llarg_type);
int ll_NumericRealValue(XValue *llret, LLSTATE *llin, LLSTATE *llout, XType llarg_type);
int ll_SpecialRealValue(XValue *llret, LLSTATE *llin, LLSTATE *llout, XType llarg_type);
int ll_BitStringValue(XValue *llret, LLSTATE *llin, LLSTATE *llout, XType llarg_type);
int ll_IdentifierList(XValue *llret, LLSTATE *llin, LLSTATE *llout, XType llarg_type);
int ll_Identifier_EList(XValue *llret, LLSTATE *llin, LLSTATE *llout, XType llarg_type);
int ll_IdentifierList_Elem(XValue *llret, LLSTATE *llin, LLSTATE *llout, XType llarg_type);
int ll_OctetStringValue(XValue *llret, LLSTATE *llin, LLSTATE *llout, XType llarg_type);
int ll_NullValue(XValue *llret, LLSTATE *llin, LLSTATE *llout, XType llarg_type);
int ll_GeneralizedTimeValue(XValue *llret, LLSTATE *llin, LLSTATE *llout, XType llarg_type);
int ll_UTCTimeValue(XValue *llret, LLSTATE *llin, LLSTATE *llout, XType llarg_type);
int ll_ObjectDescriptorValue(XValue *llret, LLSTATE *llin, LLSTATE *llout, XType llarg_type);
int ll_SequenceValue(XValue *llret, LLSTATE *llin, LLSTATE *llout, XType llarg_type);
int ll_ComponentValueList(XNamedValues *llret, LLSTATE *llin, LLSTATE *llout, XComponents llarg_components);
int ll_ComponentValueCList(XNamedValues *llret, LLSTATE *llin, LLSTATE *llout, XComponents llarg_components);
int ll_SequenceOfValue(XValue *llret, LLSTATE *llin, LLSTATE *llout, XType llarg_type);
int ll_ValueList(XValue *llret, LLSTATE *llin, LLSTATE *llout, XType llarg_type);
int ll_ValueCList(XValue *llret, LLSTATE *llin, LLSTATE *llout, XType llarg_type);
int ll_SetValue(XValue *llret, LLSTATE *llin, LLSTATE *llout, XType llarg_type);
int ll_SetOfValue(XValue *llret, LLSTATE *llin, LLSTATE *llout, XType llarg_type);
int ll_ChoiceValue(XValue *llret, LLSTATE *llin, LLSTATE *llout, XType llarg_type);
int ll_ObjectIdentifierValue(XValue *llret, LLSTATE *llin, LLSTATE *llout);
int ll_ObjIdComponentList(XNamedObjIdValue *llret, LLSTATE *llin, LLSTATE *llout);
int ll_ObjIdComponent_ESeq(XNamedObjIdValue *llret, LLSTATE *llin, LLSTATE *llout);
int ll_ObjIdComponent(XNamedObjIdValue *llret, LLSTATE *llin, LLSTATE *llout);
int ll_NameForm(XNamedObjIdValue *llret, LLSTATE *llin, LLSTATE *llout);
int ll_NumberForm(XNamedObjIdValue *llret, LLSTATE *llin, LLSTATE *llout);
int ll_NameAndNumberForm(XNamedObjIdValue *llret, LLSTATE *llin, LLSTATE *llout);
int ll_EmbeddedPDVValue(XValue *llret, LLSTATE *llin, LLSTATE *llout, XType llarg_type);
int ll_ExternalValue(XValue *llret, LLSTATE *llin, LLSTATE *llout, XType llarg_type);
int ll_CharacterStringValue(XValue *llret, LLSTATE *llin, LLSTATE *llout, XType llarg_type);
int ll_RestrictedCharacterStringValue(XValue *llret, LLSTATE *llin, LLSTATE *llout, XType llarg_type);
int ll_UnrestrictedCharacterStringValue(XValue *llret, LLSTATE *llin, LLSTATE *llout, XType llarg_type);
int ll_CharacterStringList(XValue *llret, LLSTATE *llin, LLSTATE *llout, XType llarg_type);
int ll_CharSyms(XValue *llret, LLSTATE *llin, LLSTATE *llout, XType llarg_type);
int ll_CharDefn(XValue *llret, LLSTATE *llin, LLSTATE *llout, XType llarg_type);
int ll_Quadruple(XQuadruple *llret, LLSTATE *llin, LLSTATE *llout);
int ll_Tuple(XTuple *llret, LLSTATE *llin, LLSTATE *llout);
int ll_AnyValue(XValue *llret, LLSTATE *llin, LLSTATE *llout, XType llarg_type);
int ll_Constraint(XConstraints *llret, LLSTATE *llin, LLSTATE *llout, XType llarg_type, XBoolean llarg_permalpha);
int ll_ConstraintSpec(XConstraints *llret, LLSTATE *llin, LLSTATE *llout, XType llarg_type, XBoolean llarg_permalpha);
int ll_SubtypeConstraint(XConstraints *llret, LLSTATE *llin, LLSTATE *llout, XType llarg_type, XBoolean llarg_permalpha);
int ll_ExceptionSpec(LLSTATE *llin, LLSTATE *llout);
int ll_ExceptionIdentification(LLSTATE *llin, LLSTATE *llout);
int ll_ElementSetSpecs(XConstraints *llret, LLSTATE *llin, LLSTATE *llout, XType llarg_type, XBoolean llarg_permalpha);
int ll_ElementSetSpecExtension(XConstraints *llret, LLSTATE *llin, LLSTATE *llout, XType llarg_type, XBoolean llarg_permalpha);
int ll_AdditionalElementSetSpec(XElementSetSpec *llret, LLSTATE *llin, LLSTATE *llout, XType llarg_type, XBoolean llarg_permalpha);
int ll_ElementSetSpec(XElementSetSpec *llret, LLSTATE *llin, LLSTATE *llout, XType llarg_type, XObjectClass llarg_objectclass, XBoolean llarg_permalpha);
int ll_Unions(XElementSetSpec *llret, LLSTATE *llin, LLSTATE *llout, XType llarg_type, XObjectClass llarg_objectclass, XBoolean llarg_permalpha);
int ll_UnionList(XElementSetSpec *llret, LLSTATE *llin, LLSTATE *llout, XType llarg_type, XObjectClass llarg_objectclass, XBoolean llarg_permalpha);
int ll_Intersections(XElementSetSpec *llret, LLSTATE *llin, LLSTATE *llout, XType llarg_type, XObjectClass llarg_objectclass, XBoolean llarg_permalpha);
int ll_IntersectionList(XElementSetSpec *llret, LLSTATE *llin, LLSTATE *llout, XType llarg_type, XObjectClass llarg_objectclass, XBoolean llarg_permalpha);
int ll_IntersectionElements(XElementSetSpec *llret, LLSTATE *llin, LLSTATE *llout, XType llarg_type, XObjectClass llarg_objectclass, XBoolean llarg_permalpha);
int ll_Exclusions_Opt(XElementSetSpec *llret, LLSTATE *llin, LLSTATE *llout, XType llarg_type, XObjectClass llarg_objectclass, XBoolean llarg_permalpha);
int ll_Exclusions(XElementSetSpec *llret, LLSTATE *llin, LLSTATE *llout, XType llarg_type, XObjectClass llarg_objectclass, XBoolean llarg_permalpha);
int ll_UnionMark(LLSTATE *llin, LLSTATE *llout);
int ll_IntersectionMark(LLSTATE *llin, LLSTATE *llout);
int ll_Elements(XElementSetSpec *llret, LLSTATE *llin, LLSTATE *llout, XType llarg_type, XObjectClass llarg_objectclass, XBoolean llarg_permalpha);
int ll_SubtypeElements(XSubtypeElement *llret, LLSTATE *llin, LLSTATE *llout, XType llarg_type, XBoolean llarg_permalpha);
int ll_SingleValue(XSubtypeElement *llret, LLSTATE *llin, LLSTATE *llout, XType llarg_type);
int ll_ContainedSubtype(XSubtypeElement *llret, LLSTATE *llin, LLSTATE *llout, XType llarg_type);
int ll_Includes(XBoolean *llret, LLSTATE *llin, LLSTATE *llout);
int ll_ValueRange(XSubtypeElement *llret, LLSTATE *llin, LLSTATE *llout, XType llarg_type);
int ll_LowerEndpoint(XEndPoint *llret, LLSTATE *llin, LLSTATE *llout, XType llarg_type);
int ll_UpperEndpoint(XEndPoint *llret, LLSTATE *llin, LLSTATE *llout, XType llarg_type);
int ll_LowerEndValue(XEndPoint *llret, LLSTATE *llin, LLSTATE *llout, XType llarg_type);
int ll_UpperEndValue(XEndPoint *llret, LLSTATE *llin, LLSTATE *llout, XType llarg_type);
int ll_SizeConstraint(XSubtypeElement *llret, LLSTATE *llin, LLSTATE *llout);
int ll_TypeConstraint(XSubtypeElement *llret, LLSTATE *llin, LLSTATE *llout);
int ll_PermittedAlphabet(XSubtypeElement *llret, LLSTATE *llin, LLSTATE *llout, XType llarg_type);
int ll_InnerTypeConstraints(XSubtypeElement *llret, LLSTATE *llin, LLSTATE *llout, XType llarg_type);
int ll_SingleTypeConstraint(XSubtypeElement *llret, LLSTATE *llin, LLSTATE *llout, XType llarg_type);
int ll_MultipleTypeConstraints(XSubtypeElement *llret, LLSTATE *llin, LLSTATE *llout, XComponents llarg_components);
int ll_FullSpecification(XSubtypeElement *llret, LLSTATE *llin, LLSTATE *llout, XComponents llarg_components);
int ll_PartialSpecification(XSubtypeElement *llret, LLSTATE *llin, LLSTATE *llout, XComponents llarg_components);
int ll_TypeConstraints(XNamedConstraints *llret, LLSTATE *llin, LLSTATE *llout, XComponents llarg_components);
int ll_NamedConstraint(XNamedConstraints *llret, LLSTATE *llin, LLSTATE *llout, XComponents llarg_components);
int ll_ComponentConstraint(XNamedConstraints *llret, LLSTATE *llin, LLSTATE *llout, XType llarg_type);
int ll_ValueConstraint(XConstraints *llret, LLSTATE *llin, LLSTATE *llout, XType llarg_type);
int ll_PresenceConstraint(XPresence *llret, LLSTATE *llin, LLSTATE *llout);
int ll_GeneralConstraint(LLSTATE *llin, LLSTATE *llout);
int ll_LocalTypeDirectiveSeq(XDirectives *llret, LLSTATE *llin, LLSTATE *llout);
int ll_LocalTypeDirectiveESeq(XDirectives *llret, LLSTATE *llin, LLSTATE *llout);
int ll_LocalTypeDirective(XDirectives *llret, LLSTATE *llin, LLSTATE *llout);
int ll_LocalSizeDirectiveSeq(XDirectives *llret, LLSTATE *llin, LLSTATE *llout);
int ll_LocalSizeDirectiveESeq(XDirectives *llret, LLSTATE *llin, LLSTATE *llout);
int ll_LocalSizeDirective(XDirectives *llret, LLSTATE *llin, LLSTATE *llout);
int ll_PrivateDir_Type(XString *llret, LLSTATE *llin, LLSTATE *llout);
int ll_PrivateDir_Field(XString *llret, LLSTATE *llin, LLSTATE *llout);
int ll_PrivateDir_Value(XString *llret, LLSTATE *llin, LLSTATE *llout);
int ll_PrivateDir_Public(int *llret, LLSTATE *llin, LLSTATE *llout);
int ll_PrivateDir_Intx(int *llret, LLSTATE *llin, LLSTATE *llout);
int ll_PrivateDir_LenPtr(int *llret, LLSTATE *llin, LLSTATE *llout);
int ll_PrivateDir_Pointer(int *llret, LLSTATE *llin, LLSTATE *llout);
int ll_PrivateDir_Array(int *llret, LLSTATE *llin, LLSTATE *llout);
int ll_PrivateDir_NoCode(int *llret, LLSTATE *llin, LLSTATE *llout);
int ll_PrivateDir_NoMemCopy(int *llret, LLSTATE *llin, LLSTATE *llout);
int ll_PrivateDir_OidPacked(int *llret, LLSTATE *llin, LLSTATE *llout);
int ll_PrivateDir_OidArray(int *llret, LLSTATE *llin, LLSTATE *llout);
int ll_PrivateDir_SLinked(int *llret, LLSTATE *llin, LLSTATE *llout);
int ll_PrivateDir_DLinked(int *llret, LLSTATE *llin, LLSTATE *llout);
int ll_PrivateDirectives(XPrivateDirectives *llret, LLSTATE *llin, LLSTATE *llout);
int ll_DefinedObjectClass(XObjectClass *llret, LLSTATE *llin, LLSTATE *llout);
int ll_DefinedObject(XObject *llret, LLSTATE *llin, LLSTATE *llout);
int ll_DefinedObjectSet(XObjectSet *llret, LLSTATE *llin, LLSTATE *llout);
int ll_Usefulobjectclassreference(XObjectClass *llret, LLSTATE *llin, LLSTATE *llout);
int ll_ObjectClassAssignment(LLSTATE *llin, LLSTATE *llout);
int ll_ObjectClass(XObjectClass *llret, LLSTATE *llin, LLSTATE *llout, XObjectClass llarg_oc);
int ll_ObjectClassDefn(XObjectClass *llret, LLSTATE *llin, LLSTATE *llout, XObjectClass llarg_oc);
int ll_FieldSpec_List(XFieldSpecs *llret, LLSTATE *llin, LLSTATE *llout, XObjectClass llarg_oc);
int ll_FieldSpec_EList(XFieldSpecs *llret, LLSTATE *llin, LLSTATE *llout, XObjectClass llarg_oc);
int ll_WithSyntaxSpec_opt(XSyntaxSpecs *llret, LLSTATE *llin, LLSTATE *llout, XObjectClass llarg_oc);
int ll_FieldSpec(XFieldSpecs *llret, LLSTATE *llin, LLSTATE *llout, XObjectClass llarg_oc);
int ll_TypeFieldSpec(XFieldSpecs *llret, LLSTATE *llin, LLSTATE *llout, XObjectClass llarg_oc);
int ll_TypeOptionalitySpec_opt(XOptionality *llret, LLSTATE *llin, LLSTATE *llout);
int ll_FixedTypeValueFieldSpec(XFieldSpecs *llret, LLSTATE *llin, LLSTATE *llout, XObjectClass llarg_oc);
int ll_UNIQUE_opt(XBoolean *llret, LLSTATE *llin, LLSTATE *llout);
int ll_ValueOptionalitySpec_opt(XOptionality *llret, LLSTATE *llin, LLSTATE *llout, XType llarg_type);
int ll_VariableTypeValueFieldSpec(XFieldSpecs *llret, LLSTATE *llin, LLSTATE *llout, XObjectClass llarg_oc);
int ll_FixedTypeValueSetFieldSpec(XFieldSpecs *llret, LLSTATE *llin, LLSTATE *llout, XObjectClass llarg_oc);
int ll_ValueSetOptionalitySpec_opt(XOptionality *llret, LLSTATE *llin, LLSTATE *llout, XType llarg_type);
int ll_VariableTypeValueSetFieldSpec(XFieldSpecs *llret, LLSTATE *llin, LLSTATE *llout, XObjectClass llarg_oc);
int ll_ObjectFieldSpec(XFieldSpecs *llret, LLSTATE *llin, LLSTATE *llout, XObjectClass llarg_oc);
int ll_ObjectOptionalitySpec_opt(XOptionality *llret, LLSTATE *llin, LLSTATE *llout, XObjectClass llarg_oc);
int ll_ObjectSetFieldSpec(XFieldSpecs *llret, LLSTATE *llin, LLSTATE *llout, XObjectClass llarg_oc);
int ll_ObjectSetOptionalitySpec_opt(XOptionality *llret, LLSTATE *llin, LLSTATE *llout, XObjectClass llarg_oc);
int ll_PrimitiveFieldName(XString *llret, LLSTATE *llin, LLSTATE *llout, XObjectClass llarg_oc);
int ll_FieldName(XStrings *llret, LLSTATE *llin, LLSTATE *llout, XObjectClass llarg_oc);
int ll_SyntaxList(XSyntaxSpecs *llret, LLSTATE *llin, LLSTATE *llout, XObjectClass llarg_oc);
int ll_TokenOrGroupSpec_Seq(XSyntaxSpecs *llret, LLSTATE *llin, LLSTATE *llout, XObjectClass llarg_oc);
int ll_TokenOrGroupSpec_ESeq(XSyntaxSpecs *llret, LLSTATE *llin, LLSTATE *llout, XObjectClass llarg_oc);
int ll_TokenOrGroupSpec(XSyntaxSpecs *llret, LLSTATE *llin, LLSTATE *llout, XObjectClass llarg_oc);
int ll_OptionalGroup(XSyntaxSpecs *llret, LLSTATE *llin, LLSTATE *llout, XObjectClass llarg_oc);
int ll_RequiredToken(XSyntaxSpecs *llret, LLSTATE *llin, LLSTATE *llout, XObjectClass llarg_oc);
int ll_Literal(XString *llret, LLSTATE *llin, LLSTATE *llout);
int ll_ObjectAssignment(LLSTATE *llin, LLSTATE *llout);
int ll_Object(XObject *llret, LLSTATE *llin, LLSTATE *llout, XObjectClass llarg_oc);
int ll_ObjectDefn(XObject *llret, LLSTATE *llin, LLSTATE *llout, XObjectClass llarg_oc);
int ll_DefaultSyntax(XObject *llret, LLSTATE *llin, LLSTATE *llout, XObjectClass llarg_oc);
int ll_FieldSetting_EList(XSettings *llret, LLSTATE *llin, LLSTATE *llout, XObjectClass llarg_oc, XSettings llarg_se);
int ll_FieldSetting_EListC(XSettings *llret, LLSTATE *llin, LLSTATE *llout, XObjectClass llarg_oc, XSettings llarg_se);
int ll_FieldSetting(XSettings *llret, LLSTATE *llin, LLSTATE *llout, XObjectClass llarg_oc, XSettings llarg_se);
int ll_DefinedSyntax(XObject *llret, LLSTATE *llin, LLSTATE *llout, XObjectClass llarg_oc);
int ll_DefinedSyntaxToken_ESeq(XSettings *llret, LLSTATE *llin, LLSTATE *llout, XObjectClass llarg_oc, XSettings llarg_se, XSyntaxSpecs llarg_sy);
int ll_DefinedSyntaxToken(XSettings *llret, LLSTATE *llin, LLSTATE *llout, XObjectClass llarg_oc, XSettings llarg_se, XSyntaxSpecs llarg_sy);
int ll_DefinedSyntaxToken_Elem(XSettings *llret, LLSTATE *llin, LLSTATE *llout, XObjectClass llarg_oc, XSettings llarg_se, XSyntaxSpecs llarg_sy);
int ll_Setting(XSettings *llret, LLSTATE *llin, LLSTATE *llout, XObjectClass llarg_oc, XSettings llarg_se, XString llarg_f);
int ll_ObjectSetAssignment(LLSTATE *llin, LLSTATE *llout);
int ll_ObjectSet(XObjectSet *llret, LLSTATE *llin, LLSTATE *llout, XObjectClass llarg_oc);
int ll_ObjectSetSpec(XObjectSet *llret, LLSTATE *llin, LLSTATE *llout, XObjectClass llarg_oc);
int ll_ObjectSetElements(XObjectSetElement *llret, LLSTATE *llin, LLSTATE *llout, XObjectClass llarg_oc);
int ll_ObjectClassFieldType(XType *llret, LLSTATE *llin, LLSTATE *llout);
int ll_ObjectClassFieldValue(XValue *llret, LLSTATE *llin, LLSTATE *llout, XType llarg_type);
int ll_OpenTypeFieldVal(XValue *llret, LLSTATE *llin, LLSTATE *llout);
int ll_FixedTypeFieldVal(XValue *llret, LLSTATE *llin, LLSTATE *llout, XType llarg_type);
int ll_ValueFromObject(XValue *llret, LLSTATE *llin, LLSTATE *llout);
int ll_ValueSetFromObjects(XValueSet *llret, LLSTATE *llin, LLSTATE *llout);
int ll_TypeFromObject(XType *llret, LLSTATE *llin, LLSTATE *llout);
int ll_ObjectFromObject(XObject *llret, LLSTATE *llin, LLSTATE *llout);
int ll_ObjectSetFromObjects(XObjectSet *llret, LLSTATE *llin, LLSTATE *llout);
int ll_ReferencedObjects(XObject *llret, LLSTATE *llin, LLSTATE *llout);
int ll_ReferencedObjectSets(XObjectSet *llret, LLSTATE *llin, LLSTATE *llout);
int ll_InstanceOfType(XType *llret, LLSTATE *llin, LLSTATE *llout);
int ll_InstanceOfValue(XValue *llret, LLSTATE *llin, LLSTATE *llout, XType llarg_type);
int ll_MacroDefinition(LLSTATE *llin, LLSTATE *llout);
int ll_MacroDefinedType(XType *llret, LLSTATE *llin, LLSTATE *llout);
int ll_MacroDefinedValue(XValue *llret, LLSTATE *llin, LLSTATE *llout, XType llarg_type);
int ll_ParameterizedValueSetType(LLSTATE *llin, LLSTATE *llout);
int ll_ParameterizedReference(LLSTATE *llin, LLSTATE *llout);
int ll_ParameterizedType(LLSTATE *llin, LLSTATE *llout);
int ll_ParameterizedValue(LLSTATE *llin, LLSTATE *llout);
int ll_ParameterizedAssignment(LLSTATE *llin, LLSTATE *llout);
int ll_ParameterizedObjectClass(LLSTATE *llin, LLSTATE *llout);
int ll_ParameterizedObject(LLSTATE *llin, LLSTATE *llout);
int ll_ParameterizedObjectSet(LLSTATE *llin, LLSTATE *llout);
typedef union LLSTYPE{
	XNumber _XNumber;
	XString _XString;
	XString32 _XString32;
	XModuleIdentifier _XModuleIdentifier;
	XValue _XValue;
	XNamedObjIdValue _XNamedObjIdValue;
	XTagType _XTagType;
	XExtensionType _XExtensionType;
	XStrings _XStrings;
	XStringModules _XStringModules;
	XType _XType;
	XObjectClass _XObjectClass;
	XObject _XObject;
	XObjectSet _XObjectSet;
	XMacro _XMacro;
	XValueSet _XValueSet;
	XConstraints _XConstraints;
	XNamedType _XNamedType;
	XNamedNumbers _XNamedNumbers;
	XComponents _XComponents;
	XTags _XTags;
	XTagClass _XTagClass;
	XNamedValues _XNamedValues;
	XQuadruple _XQuadruple;
	XTuple _XTuple;
	XBoolean _XBoolean;
	XElementSetSpec _XElementSetSpec;
	XSubtypeElement _XSubtypeElement;
	XEndPoint _XEndPoint;
	XNamedConstraints _XNamedConstraints;
	XPresence _XPresence;
	XDirectives _XDirectives;
	int _int;
	XPrivateDirectives _XPrivateDirectives;
	XFieldSpecs _XFieldSpecs;
	XSyntaxSpecs _XSyntaxSpecs;
	XOptionality _XOptionality;
	XSettings _XSettings;
	XObjectSetElement _XObjectSetElement;
} LLSTYPE;
typedef struct LLTERM {
	int token;
	LLSTYPE lval;
	LLPOS pos;
} LLTERM;
void llscanner(LLTERM **tokens, unsigned *ntokens);
int llparser(LLTERM *tokens, unsigned ntokens, LLSTATE *llin, LLSTATE *llout);
void llprinterror(FILE *f);
void llverror(FILE *f, LLPOS *pos, char *fmt, va_list args);
void llerror(FILE *f, LLPOS *pos, char *fmt, ...);
int llgettoken(int *token, LLSTYPE *lval, LLPOS *pos);
#if LLDEBUG > 0
void lldebug_init();
#endif
#define T_DEF 257
#define T_DDOT 258
#define T_TDOT 259
#define T_TYPE_IDENTIFIER 260
#define T_ABSTRACT_SYNTAX 261
#define T_ZERO_TERMINATED 262
#define T_POINTER 263
#define T_NO_POINTER 264
#define T_FIXED_ARRAY 265
#define T_SINGLY_LINKED_LIST 266
#define T_DOUBLY_LINKED_LIST 267
#define T_LENGTH_POINTER 268
#define T_Number 269
#define T_number 270
#define T_bstring 271
#define T_hstring 272
#define T_cstring 273
#define T_only_uppercase_symbol 274
#define T_only_uppercase_digits_symbol 275
#define T_uppercase_symbol 276
#define T_lcsymbol 277
#define T_ampucsymbol 278
#define T_amplcsymbol 279
#define T_CON_XXX1 280
#define T_CON_XXX2 281
#define T_OBJ_XXX1 282
#define T_OBJ_XXX2 283
#define T_OBJ_XXX3 284
#define T_OBJ_XXX4 285
#define T_OBJ_XXX5 286
#define T_OBJ_XXX6 287
#define T_OBJ_XXX7 288
#define T_DUM_XXX1 289
#define T_DUM_XXX2 290
#define T_DUM_XXX3 291
#define T_DUM_XXX4 292
#define T_DUM_XXX5 293
#define T_DUM_XXX6 294
#define T_DUM_XXX7 295
#define T_DUM_XXX8 296
#define T_DUM_XXX9 297
#define T_DUM_XXX10 298
#define T_DUM_XXX11 299
#define T_DUM_XXX12 300
#define T_DUM_XXX13 301
#define T_DUM_XXX14 302
#define T_DUM_XXX15 303
#define T_DUM_XXX16 304
#define T_DUM_XXX17 305
#define T_DUM_XXX18 306
#define T_DUM_XXX19 307
#define T_DUM_XXX20 308
#define T_DEFINITIONS 309
#define T_BEGIN 310
#define T_END 311
#define T_EXPLICIT 312
#define T_TAGS 313
#define T_IMPLICIT 314
#define T_AUTOMATIC 315
#define T_EXTENSIBILITY 316
#define T_IMPLIED 317
#define T_EXPORTS 318
#define T_IMPORTS 319
#define T_FROM 320
#define T_ABSENT 321
#define T_ALL 322
#define T_ANY 323
#define T_APPLICATION 324
#define T_BMPString 325
#define T_BY 326
#define T_CLASS 327
#define T_COMPONENT 328
#define T_COMPONENTS 329
#define T_CONSTRAINED 330
#define T_DEFAULT 331
#define T_DEFINED 332
#define T_empty 333
#define T_EXCEPT 334
#define T_GeneralizedTime 335
#define T_GeneralString 336
#define T_GraphicString 337
#define T_IA5String 338
#define T_IDENTIFIER 339
#define T_identifier 340
#define T_INCLUDES 341
#define T_ISO646String 342
#define T_MACRO 343
#define T_MAX 344
#define T_MIN 345
#define T_NOTATION 346
#define T_NumericString 347
#define T_ObjectDescriptor 348
#define T_OF 349
#define T_OPTIONAL 350
#define T_PDV 351
#define T_PRESENT 352
#define T_PrintableString 353
#define T_PRIVATE 354
#define T_SIZE 355
#define T_STRING 356
#define T_string 357
#define T_SYNTAX 358
#define T_T61String 359
#define T_TeletexString 360
#define T_TYPE 361
#define T_type 362
#define T_UNIQUE 363
#define T_UNIVERSAL 364
#define T_UniversalString 365
#define T_UTCTime 366
#define T_UTF8String 367
#define T_VALUE 368
#define T_value 369
#define T_VideotexString 370
#define T_VisibleString 371
#define T_WITH 372
#define T_BOOLEAN 373
#define T_INTEGER 374
#define T_ENUMERATED 375
#define T_REAL 376
#define T_BIT 377
#define T_OCTET 378
#define T_NULL 379
#define T_SEQUENCE 380
#define T_SET 381
#define T_CHOICE 382
#define T_OBJECT 383
#define T_EMBEDDED 384
#define T_EXTERNAL 385
#define T_CHARACTER 386
#define T_TRUE 387
#define T_FALSE 388
#define T_PLUS_INFINITY 389
#define T_MINUS_INFINITY 390
#define T_UNION 391
#define T_INTERSECTION 392
#define T_PrivateDir_TypeName 393
#define T_PrivateDir_FieldName 394
#define T_PrivateDir_ValueName 395
#define T_PrivateDir_Public 396
#define T_PrivateDir_Intx 397
#define T_PrivateDir_LenPtr 398
#define T_PrivateDir_Pointer 399
#define T_PrivateDir_Array 400
#define T_PrivateDir_NoCode 401
#define T_PrivateDir_NoMemCopy 402
#define T_PrivateDir_OidPacked 403
#define T_PrivateDir_OidArray 404
#define T_PrivateDir_SLinked 405
#define T_PrivateDir_DLinked 406
#define T_INSTANCE 407
#endif // _ASN1_PARSER_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\asn1\asn1c\per.c ===
/* Copyright (C) Boris Nikolaus, Germany, 1996-1997. All rights reserved. */
/* Copyright (C) Microsoft Corporation, 1997-1998. All rights reserved. */

#include "precomp.h"

void ExaminePERType(AssignmentList_t ass, Type_t *type, char *ideref);
static int __cdecl CmpIntxP(const void *v1, const void *v2);
void ExaminePERType_Boolean(AssignmentList_t ass, Type_t *type, PERConstraints_t *per, PERTypeInfo_t *info);
void ExaminePERType_Integer(AssignmentList_t ass, Type_t *type, PERConstraints_t *per, PERTypeInfo_t *info);
void ExaminePERType_Enumerated(AssignmentList_t ass, Type_t *type, PERConstraints_t *per, PERTypeInfo_t *info);
void ExaminePERType_Real(AssignmentList_t ass, Type_t *type, PERConstraints_t *per, PERTypeInfo_t *info);
void ExaminePERType_BitString(AssignmentList_t ass, Type_t *type, PERConstraints_t *per, PERTypeInfo_t *info);
void ExaminePERType_OctetString(AssignmentList_t ass, Type_t *type, PERConstraints_t *per, PERTypeInfo_t *info);
void ExaminePERType_UTF8String(AssignmentList_t ass, Type_t *type, PERConstraints_t *per, PERTypeInfo_t *info);
void ExaminePERType_Null(AssignmentList_t ass, Type_t *type, PERConstraints_t *per, PERTypeInfo_t *info);
void ExaminePERType_EmbeddedPdv(AssignmentList_t ass, Type_t *type, PERConstraints_t *per, PERTypeInfo_t *info);
void ExaminePERType_External(AssignmentList_t ass, Type_t *type, PERConstraints_t *per, PERTypeInfo_t *info);
void ExaminePERType_ObjectIdentifier(AssignmentList_t ass, Type_t *type, PERConstraints_t *per, PERTypeInfo_t *info);
void ExaminePERType_BMPString(AssignmentList_t ass, Type_t *type, PERConstraints_t *per, PERTypeInfo_t *info);
void ExaminePERType_GeneralString(AssignmentList_t ass, Type_t *type, PERConstraints_t *per, PERTypeInfo_t *info);
void ExaminePERType_GraphicString(AssignmentList_t ass, Type_t *type, PERConstraints_t *per, PERTypeInfo_t *info);
void ExaminePERType_IA5String(AssignmentList_t ass, Type_t *type, PERConstraints_t *per, PERTypeInfo_t *info);
void ExaminePERType_ISO646String(AssignmentList_t ass, Type_t *type, PERConstraints_t *per, PERTypeInfo_t *info);
void ExaminePERType_NumericString(AssignmentList_t ass, Type_t *type, PERConstraints_t *per, PERTypeInfo_t *info);
void ExaminePERType_PrintableString(AssignmentList_t ass, Type_t *type, PERConstraints_t *per, PERTypeInfo_t *info);
void ExaminePERType_TeletexString(AssignmentList_t ass, Type_t *type, PERConstraints_t *per, PERTypeInfo_t *info);
void ExaminePERType_T61String(AssignmentList_t ass, Type_t *type, PERConstraints_t *per, PERTypeInfo_t *info);
void ExaminePERType_UniversalString(AssignmentList_t ass, Type_t *type, PERConstraints_t *per, PERTypeInfo_t *info);
void ExaminePERType_VideotexString(AssignmentList_t ass, Type_t *type, PERConstraints_t *per, PERTypeInfo_t *info);
void ExaminePERType_VisibleString(AssignmentList_t ass, Type_t *type, PERConstraints_t *per, PERTypeInfo_t *info);
void ExaminePERType_UnrestrictedString(AssignmentList_t ass, Type_t *type, PERConstraints_t *per, PERTypeInfo_t *info);
void ExaminePERType_RestrictedString(AssignmentList_t ass, Type_t *type, intx_t *up, intx_t *nchars, char *tabref, uint32_t enbits, PERConstraints_t *per, PERTypeInfo_t *info);
void ExaminePERType_GeneralizedTime(AssignmentList_t ass, Type_t *type, PERConstraints_t *per, PERTypeInfo_t *info);
void ExaminePERType_UTCTime(AssignmentList_t ass, Type_t *type, PERConstraints_t *per, PERTypeInfo_t *info);
void ExaminePERType_ObjectDescriptor(AssignmentList_t ass, Type_t *type, PERConstraints_t *per, PERTypeInfo_t *info);
void ExaminePERType_Open(AssignmentList_t ass, Type_t *type, PERConstraints_t *per, PERTypeInfo_t *info);
void ExaminePERType_SequenceSet(AssignmentList_t ass, Type_t *type, PERConstraints_t *per, PERTypeInfo_t *info);
void ExaminePERType_SequenceSetOf(AssignmentList_t ass, Type_t *type, PERConstraints_t *per, PERTypeInfo_t *info);
void ExaminePERType_Choice(AssignmentList_t ass, Type_t *type, PERConstraints_t *per, PERTypeInfo_t *info);
void ExaminePERType_Reference(AssignmentList_t ass, Type_t *type, PERConstraints_t *per, PERTypeInfo_t *info);

/* examine all types and extract informations needed for PER encoding */
void
ExaminePER(AssignmentList_t ass)
{
    Assignment_t *a;

    for (a = ass; a; a = a->Next) {
	switch (a->Type) {
	case eAssignment_Type:
	    ExaminePERType(ass, a->U.Type.Type, GetName(a));
	    break;
	default:
	    break;
	}
    }
}

/* extract some type informations needed for PER encoding */
void
ExaminePERType(AssignmentList_t ass, Type_t *type, char *ideref)
{
    PERConstraints_t *per;
    PERTypeInfo_t *info;
    uint32_t lrange, lrangelog2;

    per = &type->PERConstraints;
    info = &type->PERTypeInfo;
    info->pPrivateDirectives = &type->PrivateDirectives;

    /* get the type to be examined */
    if (type->Type == eType_Reference && !IsStructuredType(GetType(ass, type)))
	type = GetType(ass, type);

    /* initialize the PER informations */
    info->Type = eExtension_Unextended;
    info->Identifier = ideref;
    info->Rules = type->Rules;
    info->Flags = type->Flags;
    info->EnumerationValues = NULL;
    info->NOctets = 0;
    info->Root.TableIdentifier = NULL;
    info->Root.Table = NULL;
    info->Root.SubIdentifier = NULL;
    info->Root.SubType = NULL;
    info->Root.Data = ePERSTIData_Null;
    info->Root.Identification = NULL;
    info->Root.Constraint = ePERSTIConstraint_Unconstrained;
    intx_setuint32(&info->Root.LowerVal, 0);
    intx_setuint32(&info->Root.UpperVal, 0);
    info->Root.NBits = 1;
    info->Root.Alignment = ePERSTIAlignment_OctetAligned;
    info->Root.Length = ePERSTILength_NoLength;
    info->Root.LConstraint = ePERSTIConstraint_Semiconstrained;
    info->Root.LLowerVal = info->Root.LUpperVal = 0;
    info->Root.LNBits = 1;
    info->Root.LAlignment = ePERSTIAlignment_OctetAligned;
    info->Additional = info->Root;
    info->Additional.NBits = 8;
    info->Additional.Length = ePERSTILength_InfiniteLength;
    info->Additional.LNBits = 1;
    info->Additional.LAlignment = ePERSTIAlignment_OctetAligned;

    /* PER informations are type specific ... */
    switch (type->Type) {
    case eType_Boolean:
	ExaminePERType_Boolean(ass, type, per, info);
	break;
    case eType_Integer:
	ExaminePERType_Integer(ass, type, per, info);
	break;
    case eType_Enumerated:
	ExaminePERType_Enumerated(ass, type, per, info);
	break;
    case eType_Real:
	ExaminePERType_Real(ass, type, per, info);
	break;
    case eType_BitString:
	ExaminePERType_BitString(ass, type, per, info);
	break;
    case eType_OctetString:
	ExaminePERType_OctetString(ass, type, per, info);
	break;
    case eType_UTF8String:
	ExaminePERType_UTF8String(ass, type, per, info);
	break;
    case eType_Null:
	ExaminePERType_Null(ass, type, per, info);
	break;
    case eType_EmbeddedPdv:
	ExaminePERType_EmbeddedPdv(ass, type, per, info);
	break;
    case eType_External:
	ExaminePERType_External(ass, type, per, info);
	break;
    case eType_ObjectIdentifier:
	ExaminePERType_ObjectIdentifier(ass, type, per, info);
	break;
    case eType_BMPString:
	ExaminePERType_BMPString(ass, type, per, info);
	break;
    case eType_GeneralString:
	ExaminePERType_GeneralString(ass, type, per, info);
	break;
    case eType_GraphicString:
	ExaminePERType_GraphicString(ass, type, per, info);
	break;
    case eType_IA5String:
	ExaminePERType_IA5String(ass, type, per, info);
	break;
    case eType_ISO646String:
	ExaminePERType_ISO646String(ass, type, per, info);
	break;
    case eType_NumericString:
	ExaminePERType_NumericString(ass, type, per, info);
	break;
    case eType_PrintableString:
	ExaminePERType_PrintableString(ass, type, per, info);
	break;
    case eType_TeletexString:
	ExaminePERType_TeletexString(ass, type, per, info);
	break;
    case eType_T61String:
	ExaminePERType_T61String(ass, type, per, info);
	break;
    case eType_UniversalString:
	ExaminePERType_UniversalString(ass, type, per, info);
	break;
    case eType_VideotexString:
	ExaminePERType_VideotexString(ass, type, per, info);
	break;
    case eType_VisibleString:
	ExaminePERType_VisibleString(ass, type, per, info);
	break;
    case eType_CharacterString:
	ExaminePERType_UnrestrictedString(ass, type, per, info);
	break;
    case eType_GeneralizedTime:
	ExaminePERType_GeneralizedTime(ass, type, per, info);
	break;
    case eType_UTCTime:
	ExaminePERType_UTCTime(ass, type, per, info);
	break;
    case eType_ObjectDescriptor:
	ExaminePERType_ObjectDescriptor(ass, type, per, info);
	break;
    case eType_Open:
	ExaminePERType_Open(ass, type, per, info);
	break;
    case eType_Sequence:
    case eType_Set:
    case eType_InstanceOf:
	ExaminePERType_SequenceSet(ass, type, per, info);
	break;
    case eType_SequenceOf:
    case eType_SetOf:
	ExaminePERType_SequenceSetOf(ass, type, per, info);
	break;
    case eType_Choice:
	ExaminePERType_Choice(ass, type, per, info);
	break;
    case eType_RestrictedString:
	MyAbort(); /* may never happen */
	/*NOTREACHED*/
    case eType_Selection:
	MyAbort(); /* may never happen */
	/*NOTREACHED*/
    case eType_Undefined:
	MyAbort(); /* may never happen */
	/*NOTREACHED*/
    case eType_Reference:
	ExaminePERType_Reference(ass, type, per, info);
	break;
    }

    /* get real Length, LNBits and LAlignment */
    if (info->Root.Length == ePERSTILength_Length) {
	switch (info->Root.LConstraint) {
	case ePERSTIConstraint_Constrained:
	    lrange = info->Root.LUpperVal - info->Root.LLowerVal + 1;
	    lrangelog2 = uint32_log2(lrange);
	    if (info->Root.LUpperVal < 0x10000) {
		if (lrange < 0x100) {
		    info->Root.Length = ePERSTILength_BitLength;
		    info->Root.LAlignment = ePERSTIAlignment_BitAligned;
		    info->Root.LNBits = lrangelog2;
		} else if (lrange == 0x100) {
		    info->Root.Length = ePERSTILength_BitLength;
		    info->Root.LNBits = 8;
		} else if (lrange <= 0x10000) {
		    info->Root.Length = ePERSTILength_BitLength;
		    info->Root.LNBits = 16;
		} else {
		    info->Root.Length = ePERSTILength_InfiniteLength;
		    info->Root.LLowerVal = 0;
		}
	    } else {
		info->Root.Length = ePERSTILength_InfiniteLength;
		info->Root.LLowerVal = 0;
	    }
	    break;
	case ePERSTIConstraint_Semiconstrained:
	    info->Root.Length = ePERSTILength_InfiniteLength;
	    info->Root.LLowerVal = 0;
	    break;
	}
    } else if (info->Root.Length == ePERSTILength_NoLength) {
	info->Root.LAlignment = ePERSTIAlignment_BitAligned;
    }
}

/*
 * Description of the fields of PERTypeInfo_t:
 *   info.
 *	Identifier	complete name of the type
 *	Rules		encoding directive rules
 *	Flags		encoding flags
 *	EnumerationValues values of enumeration type
 *	NOctets		size of string characters/integer type
 *	Type		unextended/extendable/extended
 *	Root		information for the extension root
 *	Additional	information for the extensions
 *   info.{Root,Additional}.
 *	Data		data type of value
 *	TableIdentifier	name of stringtable to use
 *	Table		stringtable to use
 *	SubIdentifier	complete name of the subtype
 *	SubType		the subtype itself
 *	Identification	identification of EMBEDDED PDV/CHARACTER STRING
 *	NBits		number of bits to use
 *	Constraint	constraint of type values
 *	LowerVal	lower bound of values (if constrained)
 *	UpperVal	upper bound of values (if constrained)
 *	Alignment	alignment to be used for value encoding
 *	Length		type of length encoding
 *	LConstraint	constraint of length
 *	LLowerVal	lower bound of length
 *	LUpperVal	upper bound of length
 *	LAlignment	alignment to be used for length encoding
 *
 * NOTES:
 *	The encoding is mostly controlled by following arguments:
 *	- Data, the type: one of:
 *	  ePERSTIData_Null, ePERSTIData_Boolean,
 *	  ePERSTIData_Integer, ePERSTIData_Unsigned,
 *	  ePERSTIData_Real, ePERSTIData_BitString, ePERSTIData_RZBBitString,
 *	  ePERSTIData_OctetString, ePERSTIData_SequenceOf, ePERSTIData_SetOf,
 *	  ePERSTIData_ObjectIdentifier, ePERSTIData_NormallySmall,
 *	  ePERSTIData_String, ePERSTIData_TableString, ePERSTIData_ZeroString,
 *	  ePERSTIData_ZeroTableString, ePERSTIData_Reference,
 *	  ePERSTIData_Extension, ePERSTIData_External,
 *	  ePERSTIData_EmbeddedPdv, ePERSTIData_UnrestrictedString
 *	- NBits, the item size for encoding
 *	- Length, the length encoding: one of:
 *	  ePERSTILength_NoLength, ePERSTILength_SmallLength,
 *	  ePERSTILength_Length
 *	  (internally eLength will be replaced by one of:
 *	  ePERSTILength_BitLength, ePERSTILength_InfiniteLength,
 *	  depending on the constraints)
 *
 *	Additional arguments:
 *	- Alignment, the value alignment: one of:
 *	  ePERSTIAlignment_BitAligned, ePERSTIAlignment_OctetAligned
 *	- LAlignment, the length alignment: one of:
 *	  ePERSTIAlignment_BitAligned, ePERSTIAlignment_OctetAligned
 *	- Constraint, the value constraint: one of:
 *	  ePERSTIConstraint_Unconstrained, ePERSTIConstraint_Semiconstrained,
 *	  ePERSTIConstraint_Upperconstrained, ePERSTIConstraint_Constrained
 *	- LConstraint, the length constraint: one of:
 *	  ePERSTIConstraint_Semiconstrained, ePERSTIConstraint_Constrained
 *
 *	Following arguments contain variable/function names in the generated
 *	code:
 *	- Identifier, the name of the current type
 *	- SubIdentifier, the name of the subtype
 *	- TableIdentifier, the name of the stringtable
 *
 *	Following values require additional arguments:
 *	- Constraint == ePERSTIConstraint_Semiconstrained ||
 *	  Constraint == ePERSTIConstraint_Constrained:
 *	  -> LowerVal, the lower bound of the value
 *	- Constraint == ePERSTIConstraint_Upperconstrained ||
 *	  Constraint == ePERSTIConstraint_Constrained:
 *	  -> UpperVal, the upper bound of the value
 *	- Length == ePERSTILength_Length:
 *	  -> LLowerVal, the lower bound of the length
 *	- Length == ePERSTILength_Length &&
 *	  LConstraint == ePERSTIConstraint_Constrained:
 *	  -> LUpperVal, the upper bound of the length
 *	- Data == ePERSTIData_TableString ||
 *        Data == ePERSTIData_ZeroTableString:
 *	  -> TableIdentifier, the name of the string table
 *	  -> Table, the string table
 *	- Data == ePERSTIData_Reference:
 *	  -> SubIdentifier, the name of the subtype
 *	  -> SubType, the subtype itself
 *	- Data == ePERSTIData_*String:
 *	  -> NOctets, the size of the string characters
 *	- Data == ePERSTIData_Integer || Data == ePERSTIData_Unsigned ||
 *	  Data == ePERSTIData_Boolean:
 *	  -> NOctets, the size of the integer type
 *	- Data == ePERSTIData_SequenceOf || Data == ePERSTIData_SetOf:
 *	  -> SubIdentifier, the name of the subtype
 *	  -> SubType, the subtype itself
 *	  -> Rule, the encoding directive rules
 *	- Data == ePERSTIData_EmbeddedPdv ||
 *	  Data == ePERSTIData_UnrestrictedString
 *	  -> Identification, the identification of the type if the type
 *	     is constraint to fixed identification or syntaxes identification
 *	     with single value
 *
 *	Following values have optional arguments:
 *	- Data == ePERSTIData_Integer || dat == ePERSTIData_Unsigned:
 *	  -> EnumerationValues, the mapping for enumeration values
 *
 *	Following combinations are allowed:
 *	
 *	Data/NBits/Length		Description
 *	-----------------------------------------------------------------------
 *	Null/0/NoLength			NULL type
 *
 *	Boolean/1/NoLength		boolean value, stored in an
 *					int{8,16,32}_t/intx_t
 *					(noctets == 1/2/4/0)
 *
 *	Integer/0/NoLength		constrained whole number of fixed
 *					value, stored in an
 *					int{8,16,32}_t/intx_t
 *					(noctets == 1/2/4/0)
 *
 *	Integer/n/NoLength		constrained whole number of fixed
 *					length < 64K, stored in an
 *					int{8,16,32}_t/intx_t
 *					(noctets == 1/2/4/0)
 *					encoded in n bits
 *
 *	Integer/8/Length		constrained whole number of var.
 *					length or length >= 64K or
 *					semiconstrained or unconstrained
 *					whole number, stored in an
 *					int{8,16,32}_t/intx_t
 *					(noctets == 1/2/4/0)
 *					encoded in units of octets
 *
 *	Unsigned/0/NoLength		constrained whole number of fixed
 *					value, stored in an
 *					uint{8,16,32}_t/intx_t
 *					(noctets == 1/2/4/0)
 *
 *	Unsigned/n/NoLength		constrained whole number of fixed
 *					length < 64K, stored in an
 *					uint{8,16,32}_t/intx_t
 *					(noctets == 1/2/4/0)
 *					encoded in n bits
 *
 *	Unsigned/8/Length		constrained whole number of var.
 *					length or length >= 64K or
 *					semiconstrained or unconstrained
 *					whole number, stored in an
 *					uint{8,16,32}_t/intx_t
 *					(noctets == 1/2/4/0)
 *					encoded in units of octets
 *
 *	NormallySmall/1/NoLength	normally small non-negative
 *					whole number, stored in an
 *					uint{8,16,32}_t
 *					(noctets == 1/2/4)
 *
 *	Real/8/Length			REAL value
 *
 *	*BitString/0/NoLength		BIT STRING of fixed length 0
 *
 *	*BitString/1/NoLength		BIT STRING of fixed length < 64K
 *
 *	*BitString/1/Length		BIT STRING of var. length or
 *					length >= 64K or semiconstrained
 *					length, encoded in units of bits
 *
 *					"RZB" in e*BitString means, bit
 *					strings with removed leading zero bits
 *
 *	OctetString/0/NoLength		OCTET STRING of fixed length 0
 *
 *	OctetString/8/NoLength		OCTET STRING of fixed length < 64K,
 *
 *	OctetString/8/Length		OCTET STRING of var. length or
 *					length >= 64K or semiconstrained
 *					length, encoded in units of octets
 *
 *	Extension/n/NoLength		bit field representing presence or
 *					absence of <64K OPTIONAL/DEFAULT
 *					components in SEQUENCEs/SETs, encoded
 *					in n bits
 *
 *	Extension/n/Length		bit field representing presence or
 *					absence of >=64K OPTIONAL/DEFAULT
 *					components in SEQUENCEs/SETs, encoded
 *					in n bits
 *
 *	Extension/n/SmallLength		bit field representing presence or
 *					absence of components in the extension
 *					of SEQUENCEs/SETs, encoded in n bits
 *
 *	ObjectIdentifier/8/Length	OBJECT IDENTIFIER value
 *
 *	*String/0/NoLength		String of fixed length 0
 *
 *	*String/n/NoLength		String of fixed length < 64K,
 *					encoded in n bits
 *
 *	*String/n/Length		String of var. length or
 *					length >= 64K or semiconstrained
 *					length, encoded in units of n bits
 *
 *					"Zero" in *String means
 *					zero-terminated strings,
 *					"Table" means renumbering of the
 *					characters.
 *
 *	MultibyteString/8/Length	not known-multiplier character strings
 *
 *	SequenceOf/0/NoLength		SEQUENCE OF subtype or SET OF subtype
 *	SetOf/0/NoLength		of zero length
 *
 *	SequenceOf/1/NoLength		SEQUENCE OF subtype or SET OF subtype
 *	SetOf/1/NoLength		of fixed length <64K
 *
 *	SequenceOf/1/Length		SEQUENCE OF subtype or SET OF subtype
 *	SetOf/1/Length			of var. length or length >= 64K or
 *					semiconstrained length
 *
 *	External/8/NoLength		EXTERNAL
 *
 *	EmbeddedPdv/8/Length		EMBEDDED PDV
 *
 *	UnrestrictedString/8/Length	CHARACTER STRING
 *
 *	GeneralizedTime/n/NoLength	GeneralizedTime, encoded in units of
 *					n bits
 *
 *	UTCTime/n/NoLength		UTCTime, encoded in units of n bits
 *
 *	Reference/1/NoLength		Reference to a structured subtype
 *
 *	Open/8/Length			Open type
 */

/* for sorting of intx_t's */
static int
__cdecl CmpIntxP(const void *v1, const void *v2)
{
    intx_t *n1 = *(intx_t **)v1;
    intx_t *n2 = *(intx_t **)v2;
    return intx_cmp(n1, n2);
}

/*
 * BOOLEAN:
 *
 * Data/NBits/Length used for encoding:
 *
 *	Boolean/1/NoLength		boolean value, stored in an
 *					int{8,16,32}_t/intx_t
 *					(noctets == 1/2/4/0)
 *
 * Additional arguments:
 *
 *	- Data == ePERSTIData_Integer || dat == ePERSTIData_Unsigned ||
 *	  Data == ePERSTIData_Boolean
 *	  -> NOctets, the size of the integer type
 */
void
ExaminePERType_Boolean(AssignmentList_t ass, Type_t *type, PERConstraints_t *per, PERTypeInfo_t *info)
{
    info->Root.Data = ePERSTIData_Boolean;
    info->NOctets = GetOctets(GetBooleanType());
    info->Root.Alignment = ePERSTIAlignment_BitAligned;
}

/*
 * INTEGER:
 *
 * Data/NBits/Length used for encoding:
 *
 *	Integer/0/NoLength		constrained whole number of fixed
 *					value, stored in an
 *					int{8,16,32}_t/intx_t
 *					(noctets == 1/2/4/0)
 *
 *	Integer/n/NoLength		constrained whole number of fixed
 *					length < 64K, stored in an
 *					int{8,16,32}_t/intx_t
 *					(noctets == 1/2/4/0)
 *					encoded in n bits
 *
 *	Integer/8/Length		constrained whole number of var.
 *					length or length >= 64K or
 *					semiconstrained or unconstrained
 *					whole number, stored in an
 *					int{8,16,32}_t/intx_t
 *					(noctets == 1/2/4/0)
 *					encoded in units of octets
 *
 *	Unsigned/0/NoLength		constrained whole number of fixed
 *					value, stored in an
 *					uint{8,16,32}_t/intx_t
 *					(noctets == 1/2/4/0)
 *
 *	Unsigned/n/NoLength		constrained whole number of fixed
 *					length < 64K, stored in an
 *					uint{8,16,32}_t/intx_t
 *					(noctets == 1/2/4/0)
 *					encoded in n bits
 *
 *	Unsigned/8/Length		constrained whole number of var.
 *					length or length >= 64K or
 *					semiconstrained or unconstrained
 *					whole number, stored in an
 *					uint{8,16,32}_t/intx_t
 *					(noctets == 1/2/4/0)
 *					encoded in units of octets
 *
 * Additional arguments:
 *
 *	- Data == ePERSTIData_Integer || dat == ePERSTIData_Unsigned ||
 *	  Data == ePERSTIData_Boolean
 *	  -> NOctets, the size of the integer type
 */
void
ExaminePERType_Integer(AssignmentList_t ass, Type_t *type, PERConstraints_t *per, PERTypeInfo_t *info)
{
    EndPoint_t lower, upper;
    int32_t sign;
    intx_t range;
    uint32_t rangelog2;
    uint32_t rangelog256;

    /* calculate LowerVal, UpperVal and range of extension root */
    /* set Constraint according to presence of LowerVal/UpperVal */
    if (per->Value.Type == eExtension_Unconstrained) {
	lower.Flags = eEndPoint_Min;
	upper.Flags = eEndPoint_Max;
    } else {
	lower.Flags = eEndPoint_Max;
	upper.Flags = eEndPoint_Min;
	GetMinMax(ass, per->Value.Root, &lower, &upper);
	if (lower.Flags & eEndPoint_Max)
	    lower.Flags = eEndPoint_Min;
	if (upper.Flags & eEndPoint_Min)
	    upper.Flags = eEndPoint_Max;
    }
    if (!(lower.Flags & eEndPoint_Min)) {
	intx_dup(&info->Root.LowerVal,
	    &GetValue(ass, lower.Value)->U.Integer.Value);
	info->Root.Constraint = ePERSTIConstraint_Semiconstrained;
    }
    if (!(upper.Flags & eEndPoint_Max)) {
	intx_dup(&info->Root.UpperVal,
	    &GetValue(ass, upper.Value)->U.Integer.Value);
	info->Root.Constraint = ePERSTIConstraint_Upperconstrained;
    }
    if (!(lower.Flags & eEndPoint_Min) && !(upper.Flags & eEndPoint_Max)) {
	intx_sub(&range, &info->Root.UpperVal, &info->Root.LowerVal);
	intx_inc(&range);
	rangelog2 = intx_log2(&range);
	rangelog256 = intx_log256(&range);
	info->Root.Constraint = ePERSTIConstraint_Constrained;
    }

    /* calculate NOctets and Data depending on the used C-Type */
    info->NOctets = GetOctets(GetIntegerType(ass, type, &sign));
    info->Root.Data = sign > 0 ? ePERSTIData_Unsigned : ePERSTIData_Integer;

    /* calculate Length, NBits, Alignment, LConstraint, LLowerVal and */
    /* LUpperVal */
    switch (info->Root.Constraint) {
    case ePERSTIConstraint_Unconstrained:
    case ePERSTIConstraint_Semiconstrained:
    case ePERSTIConstraint_Upperconstrained:
	info->Root.Length = ePERSTILength_Length;
	info->Root.NBits = 8;
	info->Root.LLowerVal = 1;
	break;
    case ePERSTIConstraint_Constrained:
	if (intx_cmp(&range, &intx_1) == 0) {
	    info->Root.NBits = 0;
	} else if (intx_cmp(&range, &intx_256) < 0 || Alignment == eAlignment_Unaligned) {
	    info->Root.NBits = rangelog2;
	    info->Root.Alignment = ePERSTIAlignment_BitAligned;
	} else if (intx_cmp(&range, &intx_256) == 0) {
	    info->Root.NBits = 8;
	} else if (intx_cmp(&range, &intx_64K) <= 0) {
	    info->Root.NBits = 16;
	} else {
	    info->Root.NBits = 8;
	    info->Root.Length = ePERSTILength_Length;
	    info->Root.LConstraint = ePERSTIConstraint_Constrained;
	    info->Root.LLowerVal = 1;
	    info->Root.LUpperVal = rangelog256;
	}
    }

    /* check for extensions */
    info->Type = per->Value.Type;
    if (info->Type == eExtension_Unconstrained)
	info->Type = eExtension_Unextended;
    info->Additional.Data = info->Root.Data;
}

/*
 * ENUMERATED:
 *
 * Data/NBits/Length used for encoding:
 *
 *	Integer/0/NoLength		constrained whole number of fixed
 *					value, stored in an
 *					int{8,16,32}_t/intx_t
 *					(noctets == 1/2/4/0)
 *
 *	Integer/n/NoLength		constrained whole number of fixed
 *					length < 64K, stored in an
 *					int{8,16,32}_t/intx_t
 *					(noctets == 1/2/4/0)
 *					encoded in n bits
 *
 *	Integer/8/Length		constrained whole number of var.
 *					length or length >= 64K or
 *					semiconstrained or unconstrained
 *					whole number, stored in an
 *					int{8,16,32}_t/intx_t
 *					(noctets == 1/2/4/0)
 *					encoded in units of octets
 *
 *	Unsigned/0/NoLength		constrained whole number of fixed
 *					value, stored in an
 *					uint{8,16,32}_t/intx_t
 *					(noctets == 1/2/4/0)
 *
 *	Unsigned/n/NoLength		constrained whole number of fixed
 *					length < 64K, stored in an
 *					uint{8,16,32}_t/intx_t
 *					(noctets == 1/2/4/0)
 *					encoded in n bits
 *
 *	Unsigned/8/Length		constrained whole number of var.
 *					length or length >= 64K or
 *					semiconstrained or unconstrained
 *					whole number, stored in an
 *					uint{8,16,32}_t/intx_t
 *					(noctets == 1/2/4/0)
 *					encoded in units of octets
 *
 *	NormallySmall/1/NoLength	normally small non-negative
 *					whole number, stored in an
 *					uint{8,16,32}_t
 *					(noctets == 1/2/4)
 *
 * Additional arguments:
 *
 *	- Data == ePERSTIData_Integer || dat == ePERSTIData_Unsigned ||
 *	  Data == ePERSTIData_Boolean
 *	  -> NOctets, the size of the integer type
 */
void
ExaminePERType_Enumerated(AssignmentList_t ass, Type_t *type, PERConstraints_t *per, PERTypeInfo_t *info)
{
    uint32_t nroot, nindex, i;
    NamedNumber_t *n;
    int32_t sign;
    uint32_t rangelog2;
    intx_t range;

    /* count number of enumeration values in extension root and extension */
    /* set extension type of extensions are present/possible */
    nroot = nindex = 0;
    for (n = type->U.Enumerated.NamedNumbers; n; n = n->Next) {
	switch (n->Type) {
	case eNamedNumber_Normal:
	    nindex++;
	    switch (info->Type) {
	    case eExtension_Unextended:
		nroot = nindex;
		break;
	    case eExtension_Extendable:
		info->Type = eExtension_Extended;
		break;
	    }
	    break;
	case eNamedNumber_ExtensionMarker:
	    info->Type = eExtension_Extendable;
	    break;
	}
    }

    /* allocate table for enumeration values and copy the values into */
    info->EnumerationValues =
	(intx_t **)malloc((nindex + 1) * sizeof(intx_t *));
    nindex = 0;
    for (n = type->U.Enumerated.NamedNumbers; n; n = n->Next) {
	switch (n->Type) {
	case eNamedNumber_Normal:
	    info->EnumerationValues[nindex++] =
		&GetValue(ass, n->U.Normal.Value)->U.Integer.Value;
	    break;
	case eNamedNumber_ExtensionMarker:
	    break;
	}
    }
    info->EnumerationValues[nindex] = 0;

    /* sort values of extension root according to their value */
    qsort(info->EnumerationValues, nroot,
	sizeof(*info->EnumerationValues), CmpIntxP);

    /* check the need for an index translation */
    for (i = 0; info->EnumerationValues[i]; i++) {
	if (intx2uint32(info->EnumerationValues[i]) != i)
	    break;
    }
    if (!info->EnumerationValues[i])
	info->EnumerationValues = NULL;

    /* calculate NOctets and Data depending on the used C-Type */
    info->NOctets = GetOctets(GetEnumeratedType(ass, type, &sign));
    info->Root.Data = sign > 0 ? ePERSTIData_Unsigned : ePERSTIData_Integer;

    /* enumeration is always constrained to value from 0 to nroot-1 */
    info->Root.Constraint = ePERSTIConstraint_Constrained;
    intx_setuint32(&info->Root.LowerVal, 0);
    intx_setuint32(&info->Root.UpperVal, nroot - 1);
    intx_setuint32(&range, nroot);
    rangelog2 = intx_log2(&range);

    /* calculate NBits and Alignment */
    if (nroot <= 1) {
	info->Root.NBits = 0;
    } else if (nroot < 256) {
	info->Root.Alignment = ePERSTIAlignment_BitAligned;
	info->Root.NBits = rangelog2;
    } else if (nroot == 256) {
	info->Root.NBits = 8;
    } else if (nroot < 65536) {
	info->Root.NBits = 16;
    } else {
	MyAbort();
    }

    /* values of extension will always be encoded as normally small numbers */
    /* with lowerbound = nroot */
    info->Additional.Data = ePERSTIData_NormallySmall;
    info->Additional.NBits = 1;
    info->Additional.Alignment = ePERSTIAlignment_BitAligned;
    info->Additional.Length = ePERSTILength_NoLength;
    info->Additional.Constraint = ePERSTIConstraint_Semiconstrained;
    intx_setuint32(&info->Additional.LowerVal, nroot);
}

/*
 * REAL:
 *
 * Data/NBits/Length used for encoding:
 *
 *	Real/8/Length			REAL value
 *
 * Additional arguments:
 *
 *	none
 */
void
ExaminePERType_Real(AssignmentList_t ass, Type_t *type, PERConstraints_t *per, PERTypeInfo_t *info)
{
    info->Root.Data = ePERSTIData_Real;
    info->Root.NBits = 8;
    info->NOctets = GetOctets(GetRealType(type));
}

/*
 * BIT STRING:
 *
 * Data/NBits/Length used for encoding:
 *
 *	*BitString/0/NoLength		BIT STRING of fixed length 0
 *
 *	*BitString/1/NoLength		BIT STRING of fixed length < 64K,
 *					encoded in n bits
 *
 *	*BitString/1/Length		BIT STRING of var. length or
 *					length >= 64K or semiconstrained
 *					length, encoded in units of bits
 *
 *					"RZB" in e*BitString means, bit
 *					strings with removed leading zero bits
 *
 * Additional arguments:
 *
 *	none
 */
void
ExaminePERType_BitString(AssignmentList_t ass, Type_t *type, PERConstraints_t *per, PERTypeInfo_t *info)
{
    EndPoint_t lower, upper;

    /* calculate LConstraint, LLowerVal and LUpperVal */
    if (per->Size.Type != eExtension_Unconstrained) {
	lower.Flags = eEndPoint_Max;
	upper.Flags = eEndPoint_Min;
	GetMinMax(ass, per->Size.Root, &lower, &upper);
	if (upper.Flags & eEndPoint_Min)
	    upper.Flags = eEndPoint_Max;
	info->Root.LLowerVal =
	    intx2uint32(&GetValue(ass, lower.Value)->U.Integer.Value);
	info->Root.LConstraint = ePERSTIConstraint_Semiconstrained;
	if (!(upper.Flags & eEndPoint_Max)) {
	    info->Root.LUpperVal =
		intx2uint32(&GetValue(ass, upper.Value)->U.Integer.Value);
	    info->Root.LConstraint = ePERSTIConstraint_Constrained;
	}
    }

    /* calculate NBits, Alignment and Length */
    info->Root.cbFixedSizeBitString = 0; // clear it up first
    switch (info->Root.LConstraint) {
    case ePERSTIConstraint_Constrained:
	if (info->Root.LUpperVal == 0) {
	    info->Root.NBits = 0;
	} else {
	    info->Root.NBits = 1;
	    if (info->Root.LLowerVal == info->Root.LUpperVal) {
		if (info->Root.LUpperVal <= 32)
		{
		    info->Root.cbFixedSizeBitString = (info->Root.LUpperVal + 7) / 8;
        }
		if (info->Root.LUpperVal <= 16) {
		    info->Root.Alignment = ePERSTIAlignment_BitAligned;
		} else if (info->Root.LUpperVal >= 0x10000) {
		    info->Root.Length = ePERSTILength_Length;
		}
	    } else {
		info->Root.Length = ePERSTILength_Length;
	    }
	}
	break;
    case ePERSTIConstraint_Semiconstrained:
	info->Root.NBits = 1;
	info->Root.Length = ePERSTILength_Length;
	break;
    }

    /* get extension type */
    info->Type = per->Size.Type;
    if (info->Type == eExtension_Unconstrained)
	info->Type = eExtension_Unextended;

    /* set Data to RZBBitString/BitString */
    if (type->U.BitString.NamedNumbers)
	info->Root.Data = ePERSTIData_RZBBitString;
    else
	info->Root.Data = ePERSTIData_BitString;

    /* set extension informations */
    info->Additional.Data = info->Root.Data;
    info->Additional.NBits = 1;
}

/*
 * OCTET STRING:
 *
 * Data/NBits/Length used for encoding:
 *
 *	OctetString/0/NoLength		OCTET STRING of fixed length 0
 *
 *	OctetString/8/NoLength		OCTET STRING of fixed length < 64K,
 *
 *	OctetString/8/Length		OCTET STRING of var. length or
 *					length >= 64K or semiconstrained
 *					length, encoded in units of octets
 *
 * Additional arguments:
 *
 *	none
 */
void
ExaminePERType_OctetString(AssignmentList_t ass, Type_t *type, PERConstraints_t *per, PERTypeInfo_t *info)
{
    EndPoint_t lower, upper;

    /* calculate LConstraint, LLowerVal and LUpperVal */
    if (per->Size.Type != eExtension_Unconstrained) {
	lower.Flags = eEndPoint_Max;
	upper.Flags = eEndPoint_Min;
	GetMinMax(ass, per->Size.Root, &lower, &upper);
	if (upper.Flags & eEndPoint_Min)
	    upper.Flags = eEndPoint_Max;
	info->Root.LLowerVal =
	    intx2uint32(&GetValue(ass, lower.Value)->U.Integer.Value);
	info->Root.LConstraint = ePERSTIConstraint_Semiconstrained;
	if (!(upper.Flags & eEndPoint_Max)) {
	    info->Root.LUpperVal =
		intx2uint32(&GetValue(ass, upper.Value)->U.Integer.Value);
	    info->Root.LConstraint = ePERSTIConstraint_Constrained;
	}
    }

    /* calculate NBits, Alignment and Length */
    switch (info->Root.LConstraint) {
    case ePERSTIConstraint_Constrained:
	if (info->Root.LUpperVal == 0) {
	    info->Root.NBits = 0;
	} else {
	    info->Root.NBits = 8;
	    if (info->Root.LLowerVal == info->Root.LUpperVal) {
		if (info->Root.LUpperVal <= 2) {
		    info->Root.Alignment = ePERSTIAlignment_BitAligned;
		} else if (info->Root.LUpperVal >= 0x10000) {
		    info->Root.Length = ePERSTILength_Length;
		}
	    } else {
		info->Root.Length = ePERSTILength_Length;
	    }
	}
	break;
    case ePERSTIConstraint_Semiconstrained:
	info->Root.NBits = 8;
	info->Root.Length = ePERSTILength_Length;
	break;
    }

    /* get extension type */
    info->Type = per->Size.Type;
    if (info->Type == eExtension_Unconstrained)
	info->Type = eExtension_Unextended;

    /* set Data to OctetString */
    info->Root.Data = ePERSTIData_OctetString;

    /* set extension informations */
    info->Additional.Data = info->Root.Data;
}

void
ExaminePERType_UTF8String(AssignmentList_t ass, Type_t *type, PERConstraints_t *per, PERTypeInfo_t *info)
{
    EndPoint_t lower, upper;

    /* calculate LConstraint, LLowerVal and LUpperVal */
    if (per->Size.Type != eExtension_Unconstrained) {
	lower.Flags = eEndPoint_Max;
	upper.Flags = eEndPoint_Min;
	GetMinMax(ass, per->Size.Root, &lower, &upper);
	if (upper.Flags & eEndPoint_Min)
	    upper.Flags = eEndPoint_Max;
	info->Root.LLowerVal =
	    intx2uint32(&GetValue(ass, lower.Value)->U.Integer.Value);
	info->Root.LConstraint = ePERSTIConstraint_Semiconstrained;
	if (!(upper.Flags & eEndPoint_Max)) {
	    info->Root.LUpperVal =
		intx2uint32(&GetValue(ass, upper.Value)->U.Integer.Value);
	    info->Root.LConstraint = ePERSTIConstraint_Constrained;
	}
    }

    /* calculate NBits, Alignment and Length */
    switch (info->Root.LConstraint) {
    case ePERSTIConstraint_Constrained:
	if (info->Root.LUpperVal == 0) {
	    info->Root.NBits = 0;
	} else {
	    info->Root.NBits = 8;
	    if (info->Root.LLowerVal == info->Root.LUpperVal) {
		if (info->Root.LUpperVal <= 2) {
		    info->Root.Alignment = ePERSTIAlignment_BitAligned;
		} else if (info->Root.LUpperVal >= 0x10000) {
		    info->Root.Length = ePERSTILength_Length;
		}
	    } else {
		info->Root.Length = ePERSTILength_Length;
	    }
	}
	break;
    case ePERSTIConstraint_Semiconstrained:
	info->Root.NBits = 8;
	info->Root.Length = ePERSTILength_Length;
	break;
    }

    /* get extension type */
    info->Type = per->Size.Type;
    if (info->Type == eExtension_Unconstrained)
	info->Type = eExtension_Unextended;

    /* set Data to OctetString */
    info->Root.Data = ePERSTIData_UTF8String;

    /* set extension informations */
    info->Additional.Data = info->Root.Data;
}

/*
 * NULL:
 *
 * Data/NBits/Length used for encoding:
 *
 *	Null/0/NoLength			NULL type
 *
 * Additional arguments:
 *
 *	none
 */
void
ExaminePERType_Null(AssignmentList_t ass, Type_t *type, PERConstraints_t *per, PERTypeInfo_t *info)
{
    info->Root.NBits = 0;
    info->Root.Data = ePERSTIData_Null;
}

/*
 * EMBEDDED PDV:
 *
 * Data/NBits/Length used for encoding:
 *
 *	EmbeddedPdv/8/Length		EMBEDDED PDV
 *
 * Additional arguments:
 *
 *	- Data == ePERSTIData_EmbeddedPdv ||
 *	  Data == ePERSTIData_UnrestrictedString
 *	  -> Identification, the identification of the type if the type
 *	     is constraint to fixed identification or syntaxes identification
 *	     with single value
 */
void
ExaminePERType_EmbeddedPdv(AssignmentList_t ass, Type_t *type, PERConstraints_t *per, PERTypeInfo_t *info)
{
    info->Root.Identification = GetFixedIdentification(ass, type->Constraints);
    info->Root.Data = ePERSTIData_EmbeddedPdv;
    info->Root.NBits = 8;
    info->Root.Length = ePERSTILength_Length;
}

/*
 * EXTERNAL:
 *
 * Data/NBits/Length used for encoding:
 *
 *	External/8/Length		EXTERNAL
 *
 * Additional arguments:
 *
 *	none
 */
void
ExaminePERType_External(AssignmentList_t ass, Type_t *type, PERConstraints_t *per, PERTypeInfo_t *info)
{
    info->Root.Data = ePERSTIData_External;
    info->Root.NBits = 8;
    info->Root.Length = ePERSTILength_Length;
}

/*
 * OBJECT IDENTIFIER:
 *
 * Data/NBits/Length used for encoding:
 *
 *	ObjectIdentifier/8/Length	OBJECT IDENTIFIER value
 *
 * Additional arguments:
 *
 *	none
 */
void
ExaminePERType_ObjectIdentifier(AssignmentList_t ass, Type_t *type, PERConstraints_t *per, PERTypeInfo_t *info)
{
    info->Root.Data = ePERSTIData_ObjectIdentifier;
    info->Root.NBits = 8;
    info->Root.Length = ePERSTILength_Length;
}

/*
 * *String:
 *
 * Data/NBits/Length used for encoding:
 *
 *	*String/0/NoLength		String of fixed length 0
 *
 *	*String/n/NoLength		String of fixed length < 64K,
 *					encoded in n bits
 *
 *	*String/n/Length		String of var. length or
 *					length >= 64K or semiconstrained
 *					length, encoded in units of n bits
 *
 *					"Zero" in *String means
 *					zero-terminated strings,
 *					"Table" means renumbering of the
 *					characters.
 *
 *	MultibyteString/8/Length	not known-multiplier character strings
 *
 * Additional arguments:
 *
 *	- Data == ePERSTIData_TableString || dat == ePERSTIData_ZeroTableString:
 *	  -> TableIdentifier, the name of the string table
 *	  -> Table, the string table
 *	- Data == ePERSTIData_*String:
 *	  -> NOctets, the size of the string characters
 */

void
ExaminePERType_BMPString(AssignmentList_t ass, Type_t *type, PERConstraints_t *per, PERTypeInfo_t *info)
{
    intx_t up, nchars;

    intx_setuint32(&up, 0xffff);
    intx_setuint32(&nchars, 0x10000);
    ExaminePERType_RestrictedString(ass, type, &up, &nchars,
	NULL, 16, per, info);
}

void
ExaminePERType_GeneralString(AssignmentList_t ass, Type_t *type, PERConstraints_t *per, PERTypeInfo_t *info)
{
    uint32_t zero;

    GetStringType(ass, type, &info->NOctets, &zero);
    info->Root.NBits = 8;
    info->Root.Data = zero ? ePERSTIData_ZeroString : ePERSTIData_String;
    info->Root.Length = ePERSTILength_Length;
}

void
ExaminePERType_GraphicString(AssignmentList_t ass, Type_t *type, PERConstraints_t *per, PERTypeInfo_t *info)
{
    uint32_t zero;

    GetStringType(ass, type, &info->NOctets, &zero);
    info->Root.NBits = 8;
    info->Root.Data = zero ? ePERSTIData_ZeroString : ePERSTIData_String;
    info->Root.Length = ePERSTILength_Length;
}

void
ExaminePERType_IA5String(AssignmentList_t ass, Type_t *type, PERConstraints_t *per, PERTypeInfo_t *info)
{
    intx_t up, nchars;

    intx_setuint32(&up, 0x7f);
    intx_setuint32(&nchars, 0x80);
    ExaminePERType_RestrictedString(ass, type, &up, &nchars,
	NULL, Alignment == eAlignment_Aligned ? 8 : 7, per, info);
}

void
ExaminePERType_ISO646String(AssignmentList_t ass, Type_t *type, PERConstraints_t *per, PERTypeInfo_t *info)
{
    intx_t up, nchars;

    intx_setuint32(&up, 0x7e);
    intx_setuint32(&nchars, 0x5f);
    ExaminePERType_RestrictedString(ass, type, &up, &nchars,
	NULL, Alignment == eAlignment_Aligned ? 8 : 7, per, info);
}

void
ExaminePERType_NumericString(AssignmentList_t ass, Type_t *type, PERConstraints_t *per, PERTypeInfo_t *info)
{
    intx_t up, nchars;

    intx_setuint32(&up, 0x39);
    intx_setuint32(&nchars, 0xb);
    ExaminePERType_RestrictedString(ass, type, &up, &nchars,
	"ASN1NumericStringTable", 4, per, info);
}

void
ExaminePERType_PrintableString(AssignmentList_t ass, Type_t *type, PERConstraints_t *per, PERTypeInfo_t *info)
{
    intx_t up, nchars;

    intx_setuint32(&up, 0x7a);
    intx_setuint32(&nchars, 0x4a);
    ExaminePERType_RestrictedString(ass, type, &up, &nchars,
	NULL, Alignment == eAlignment_Aligned ? 8 : 7, per, info);
}

void
ExaminePERType_TeletexString(AssignmentList_t ass, Type_t *type, PERConstraints_t *per, PERTypeInfo_t *info)
{
    info->Root.Data = ePERSTIData_MultibyteString;
    info->Root.NBits = 8;
    info->Root.Length = ePERSTILength_Length;
    info->NOctets = 1;
}

void
ExaminePERType_T61String(AssignmentList_t ass, Type_t *type, PERConstraints_t *per, PERTypeInfo_t *info)
{
    info->Root.Data = ePERSTIData_MultibyteString;
    info->Root.NBits = 8;
    info->Root.Length = ePERSTILength_Length;
    info->NOctets = 1;
}

void
ExaminePERType_UniversalString(AssignmentList_t ass, Type_t *type, PERConstraints_t *per, PERTypeInfo_t *info)
{
    intx_t up, nchars;

    intx_setuint32(&up, 0xffffffff);
    intx_setuint32(&nchars, 0xffffffff);
    intx_inc(&nchars);
    ExaminePERType_RestrictedString(ass, type, &up, &nchars,
	NULL, 32, per, info);
}

void
ExaminePERType_VideotexString(AssignmentList_t ass, Type_t *type, PERConstraints_t *per, PERTypeInfo_t *info)
{
    info->Root.Data = ePERSTIData_MultibyteString;
    info->Root.NBits = 8;
    info->Root.Length = ePERSTILength_Length;
    info->NOctets = 1;
}

void
ExaminePERType_VisibleString(AssignmentList_t ass, Type_t *type, PERConstraints_t *per, PERTypeInfo_t *info)
{
    intx_t up, nchars;

    intx_setuint32(&up, 0x7e);
    intx_setuint32(&nchars, 0x5f);
    ExaminePERType_RestrictedString(ass, type, &up, &nchars,
	NULL, Alignment == eAlignment_Aligned ? 8 : 7, per, info);
}

void
ExaminePERType_RestrictedString(AssignmentList_t ass, Type_t *type, intx_t *up, intx_t *nchars, char *tabref, uint32_t enbits, PERConstraints_t *per, PERTypeInfo_t *info)
{
    EndPoint_t lower, upper;
    uint32_t zero, rangelog2;
    intx_t ix, range;
    char tabbuf[256];

    /* calculate NOctets depending on the used C-Type */
    GetStringType(ass, type, &info->NOctets, &zero);

    /* calculate LConstraint, LLowerVal and LUpperVal if size constraint is */
    /* given */
    if (per->Size.Type != eExtension_Unconstrained) {
	lower.Flags = eEndPoint_Max;
	upper.Flags = eEndPoint_Min;
	GetMinMax(ass, per->Size.Root, &lower, &upper);
	if (upper.Flags & eEndPoint_Min)
	    upper.Flags = eEndPoint_Max;
	if (lower.Flags & eEndPoint_Max) {
	    lower.Flags = 0;
	    lower.Value = Builtin_Value_Integer_0;
	}
	info->Root.LLowerVal =
	    intx2uint32(&GetValue(ass, lower.Value)->U.Integer.Value);
	if (!(upper.Flags & eEndPoint_Max)) {
	    info->Root.LUpperVal =
		intx2uint32(&GetValue(ass, upper.Value)->U.Integer.Value);
	    info->Root.LConstraint = ePERSTIConstraint_Constrained;
	}
    }

    /* get extension type */
    info->Type = per->Size.Type;
    if (info->Type == eExtension_Unconstrained)
	info->Type = eExtension_Unextended;

    /* get string table if permitted alphabet constraint is present */
    /* update extension type if needed */
    if (per->PermittedAlphabet.Type != eExtension_Unconstrained) {
	info->Root.Table = per->PermittedAlphabet.Root;
	if (per->PermittedAlphabet.Type > info->Type)
	    info->Type = per->PermittedAlphabet.Type;
	if (CountValues(ass, info->Root.Table, &ix)) {
	    nchars = &ix;
	    sprintf(tabbuf, "%s_StringTable", info->Identifier);
	    tabref = tabbuf;
	} else {
	    MyAbort(); /*XXX*/
	}
    }

    /* get bits needed for one character */
    info->Root.NBits = intx_log2(nchars);
    if (Alignment == eAlignment_Aligned) {
	if (info->Root.NBits > 16)
	    info->Root.NBits = 32;
	else if (info->Root.NBits > 8)
	    info->Root.NBits = 16;
	else if (info->Root.NBits > 4)
	    info->Root.NBits = 8;
	else if (info->Root.NBits > 2)
	    info->Root.NBits = 4;
    }

    /* set data type */
    info->Root.Data = tabref ?
	(zero ? ePERSTIData_ZeroTableString : ePERSTIData_TableString) :
	(zero ? ePERSTIData_ZeroString : ePERSTIData_String);

    /* check if stringtable is really needed for encoding or extension check */
    intx_dup(&range, up);
    intx_inc(&range);
    rangelog2 = intx_log2(&range);
    if (rangelog2 <= info->Root.NBits) {
	info->Root.Data = zero ? ePERSTIData_ZeroString : ePERSTIData_String;
	if (per->PermittedAlphabet.Type < eExtension_Extended)
	    tabref = NULL;
    }
    info->Root.TableIdentifier = tabref ? strdup(tabref) : NULL;

    /* calculate Length and Alignment */
    switch (info->Root.LConstraint) {
    case ePERSTIConstraint_Constrained:
	if (info->Root.LUpperVal == 0) {
	    info->Root.NBits = 0;
	} else {
	    if (info->Root.LLowerVal == info->Root.LUpperVal) {
		if (info->Root.LUpperVal * info->Root.NBits <= 16) {
		    info->Root.Alignment = ePERSTIAlignment_BitAligned;
		} else if (info->Root.LUpperVal >= 0x10000) {
		    info->Root.Length = ePERSTILength_Length;
		}
	    } else {
		if (info->Root.LUpperVal * info->Root.NBits <= 16)
		    info->Root.Alignment = ePERSTIAlignment_BitAligned;
		info->Root.Length = ePERSTILength_Length;
	    }
	}
	break;
    case ePERSTIConstraint_Semiconstrained:
	info->Root.Length = ePERSTILength_Length;
	break;
    }

    /* set extension informations */
    info->Additional.Data = zero ? ePERSTIData_ZeroString : ePERSTIData_String;
    info->Additional.NBits = enbits;
}

/*
 * CHARACTER STRING:
 *
 * Data/NBits/Length used for encoding:
 *
 *	UnrestrictedString/8/Length	CHARACTER STRING
 *
 * Additional arguments:
 *
 *	- Data == ePERSTIData_EmbeddedPdv ||
 *	  Data == ePERSTIData_UnrestrictedString
 *	  -> Identification, the identification of the type if the type
 *	     is constraint to fixed identification or syntaxes identification
 *	     with single value
 */
void
ExaminePERType_UnrestrictedString(AssignmentList_t ass, Type_t *type, PERConstraints_t *per, PERTypeInfo_t *info)
{
    info->Root.Identification = GetFixedIdentification(ass, type->Constraints);
    info->Root.Data = ePERSTIData_UnrestrictedString;
    info->Root.NBits = 8;
    info->Root.Length = ePERSTILength_Length;
}

/*
 * GeneralizedTime:
 *
 * Data/NBits/Length used for encoding:
 *
 *	GeneralizedTime/n/NoLength	GeneralizedTime, encoded in units of
 *					n bits
 *
 * Additional arguments:
 *
 *	none
 */
void
ExaminePERType_GeneralizedTime(AssignmentList_t ass, Type_t *type, PERConstraints_t *per, PERTypeInfo_t *info)
{
    info->Root.NBits = (Alignment == eAlignment_Aligned) ? 8 : 7;
    info->Root.Data = ePERSTIData_GeneralizedTime;
}

/*
 * UTCTime:
 *
 * Data/NBits/Length used for encoding:
 *
 *	UTCTime/n/NoLength		UTCTime, encoded in units of
 *					n bits
 *
 * Additional arguments:
 *
 *	none
 */
void
ExaminePERType_UTCTime(AssignmentList_t ass, Type_t *type, PERConstraints_t *per, PERTypeInfo_t *info)
{
    info->Root.NBits = (Alignment == eAlignment_Aligned) ? 8 : 7;
    info->Root.Data = ePERSTIData_UTCTime;
}

/*
 * ObjectDescriptor:
 *
 * Data/NBits/Length used for encoding:
 *
 *	*String/n/Length		String of var. length or
 *					length >= 64K or semiconstrained
 *					length, encoded in units of n bits
 *
 *					"Zero" in *String means
 *					zero-terminated strings
 *
 * Additional arguments:
 *
 *	none
 */
void
ExaminePERType_ObjectDescriptor(AssignmentList_t ass, Type_t *type, PERConstraints_t *per, PERTypeInfo_t *info)
{
    info->NOctets = 1;
    info->Root.NBits = 8;
    info->Root.Data = ePERSTIData_ZeroString;
    info->Root.Length = ePERSTILength_Length;
}

/*
 * OpenType:
 *
 * Data/NBits/Length used for encoding:
 *
 *	Open/8/Length			Open type
 *
 * Additional arguments:
 *
 *	none
 */
void
ExaminePERType_Open(AssignmentList_t ass, Type_t *type, PERConstraints_t *per, PERTypeInfo_t *info)
{
    info->NOctets = 1;
    info->Root.NBits = 8;
    info->Root.Data = ePERSTIData_Open;
    info->Root.Length = ePERSTILength_Length;
}

/*
 * SEQUENCE/SET:
 *
 * Data/NBits/Length used for encoding:
 *
 *	none
 *
 * Additional arguments:
 *
 *	none
 */
void
ExaminePERType_SequenceSet(AssignmentList_t ass, Type_t *type, PERConstraints_t *per, PERTypeInfo_t *info)
{
    Component_t *comp;
    NamedType_t *namedType;
    char idebuf[256];

    /* examine types of components */
    for (comp = type->U.SSC.Components; comp; comp = comp->Next) {
	switch (comp->Type) {
	case eComponent_Normal:
	case eComponent_Optional:
	case eComponent_Default:
	    namedType = comp->U.NOD.NamedType;
	    sprintf(idebuf, "%s_%s", info->Identifier, namedType->Identifier);
	    ExaminePERType(ass, namedType->Type, strdup(idebuf));
	    break;
	}
    }
}

/*
 * SEQUENCE OF/SET OF:
 *
 * Data/NBits/Length used for encoding:
 *
 *	SequenceOf/0/NoLength		SEQUENCE OF subtype or SET OF subtype
 *	SetOf/0/NoLength		of zero length
 *
 *	SequenceOf/1/NoLength		SEQUENCE OF subtype or SET OF subtype
 *	SetOf/1/NoLength		of fixed length <64K
 *
 *	SequenceOf/1/Length		SEQUENCE OF subtype or SET OF subtype
 *	SetOf/1/Length			of var. length or length >= 64K or
 *					semiconstrained length
 *
 * Additional arguments:
 *
 *	- Data == ePERSTIData_SequenceOf || dat == ePERSTIData_SetOf:
 *	  -> SubIdentifier, the name of the subtype
 *	  -> SubType, the subtype itself
 *	  -> Rule, the encoding directive rules
 */
void
ExaminePERType_SequenceSetOf(AssignmentList_t ass, Type_t *type, PERConstraints_t *per, PERTypeInfo_t *info)
{
    EndPoint_t lower, upper;
    char idebuf[256];

    /* calculate LConstraint, LLowerVal and LUpperVal */
    if (per->Size.Type != eExtension_Unconstrained) {
	lower.Flags = eEndPoint_Max;
	upper.Flags = eEndPoint_Min;
	GetMinMax(ass, per->Size.Root, &lower, &upper);
	if (upper.Flags & eEndPoint_Min)
	    upper.Flags = eEndPoint_Max;
	info->Root.LLowerVal = intx2uint32(&GetValue(ass, lower.Value)->
	    U.Integer.Value);
	if (!(upper.Flags & eEndPoint_Max)) {
	    info->Root.LUpperVal = intx2uint32(&GetValue(ass, upper.Value)->
		U.Integer.Value);
	    info->Root.LConstraint = ePERSTIConstraint_Constrained;
	}
    }

    /* calculate NBits, Length */
    switch (info->Root.LConstraint) {
    case ePERSTIConstraint_Constrained:
	if (info->Root.LUpperVal == 0) {
	    info->Root.NBits = 0;
	} else {
	    if (info->Root.LLowerVal != info->Root.LUpperVal)
		info->Root.Length = ePERSTILength_Length;
	}
	break;
    case ePERSTIConstraint_Semiconstrained:
	info->Root.Length = ePERSTILength_Length;
	break;
    }

    /* set data type and Alignment */
    info->Root.Data = (type->Type == eType_SequenceOf ?
	ePERSTIData_SequenceOf : ePERSTIData_SetOf);
    info->Root.Alignment = ePERSTIAlignment_BitAligned;

    /* set SubType, SubIdentifier */
    info->Root.SubType = type->U.SS.Type;
    info->Root.SubIdentifier = GetTypeName(ass, info->Root.SubType);

    /* get extension type */
    info->Type = per->Size.Type;
    if (info->Type == eExtension_Unconstrained)
	info->Type = eExtension_Unextended;

    /* set extension informations */
    info->Additional.Data = info->Root.Data;
    info->Additional.NBits = 1;
    info->Additional.SubType = info->Root.SubType;
    info->Additional.SubIdentifier = info->Root.SubIdentifier;

    /* examine subtype */
    sprintf(idebuf, "%s_%s", info->Identifier,
	type->Type == eType_SequenceOf ? "Sequence" : "Set");
    ExaminePERType(ass, type->U.SS.Type, strdup(idebuf));
}

/*
 * CHOICE:
 *
 * Data/NBits/Length used for encoding of the choice selector:
 *
 *	Unsigned/0/NoLength		constrained whole number of fixed
 *					value, stored in an
 *					uint{8,16,32}_t/intx_t
 *					(noctets == 1/2/4/0)
 *
 *	Unsigned/n/NoLength		constrained whole number of fixed
 *					length < 64K, stored in an
 *					uint{8,16,32}_t/intx_t
 *					(noctets == 1/2/4/0)
 *					encoded in n bits
 *
 *	Unsigned/8/Length		constrained whole number of var.
 *					length or length >= 64K or
 *					semiconstrained or unconstrained
 *					whole number, stored in an
 *					uint{8,16,32}_t/intx_t
 *					(noctets == 1/2/4/0)
 *					encoded in units of octets
 *
 *	NormallySmall/1/NoLength	normally small non-negative
 *					whole number, stored in an
 *					uint{8,16,32}_t
 *					(noctets == 1/2/4)
 *
 * Additional arguments:
 *
 *	- Data == ePERSTIData_Integer || dat == ePERSTIData_Unsigned ||
 *	  Data == ePERSTIData_Boolean
 *	  -> NOctets, the size of the integer type
 *
 */
void
ExaminePERType_Choice(AssignmentList_t ass, Type_t *type, PERConstraints_t *per, PERTypeInfo_t *info)
{
    uint32_t nroot, rangelog2;
    intx_t range;
    Component_t *comp;
    NamedType_t *namedType;
    char idebuf[256];

    if (type->Flags & eTypeFlags_ExtensionMarker) {
	info->Type = type->U.Choice.Extensions ?
	    eExtension_Extended : eExtension_Extendable;
    }
    nroot = type->U.Choice.Alternatives;
    info->NOctets = GetOctets(GetChoiceType(type));
    info->Root.Constraint = ePERSTIConstraint_Constrained;
    intx_setuint32(&info->Root.UpperVal, nroot - 1);
    intx_setuint32(&range, nroot);
    rangelog2 = intx_log2(&range);
    if (nroot <= 1) {
	info->Root.NBits = 0;
    } else if (nroot < 256) {
	info->Root.Alignment = ePERSTIAlignment_BitAligned;
	info->Root.NBits = rangelog2;
    } else if (nroot == 256) {
	info->Root.NBits = 8;
    } else if (nroot < 65536) {
	info->Root.NBits = 16;
    } else {
	MyAbort();
    }
    info->Root.Data = ePERSTIData_Unsigned;
    info->Additional.Data = ePERSTIData_NormallySmall;
    info->Additional.NBits = 1;
    info->Additional.Alignment = ePERSTIAlignment_BitAligned;
    info->Additional.Length = ePERSTILength_NoLength;
    info->Additional.Constraint = ePERSTIConstraint_Semiconstrained;
    intx_setuint32(&info->Additional.LowerVal, nroot);

    /* examine types of alternatives */
    for (comp = type->U.SSC.Components; comp; comp = comp->Next) {
	switch (comp->Type) {
	case eComponent_Normal:
	    namedType = comp->U.NOD.NamedType;
	    sprintf(idebuf, "%s_%s", info->Identifier, namedType->Identifier);
	    ExaminePERType(ass, namedType->Type, strdup(idebuf));
	    break;
	}
    }
}

/*
 * Reference:
 *
 * Data/NBits/Length used for encoding:
 *
 *	Reference/1/NoLength		Reference to a structured subtype
 *
 * Additional arguments:
 *
 *	- Data == ePERSTIData_Reference:
 *	  -> SubIdentifier, the name of the subtype
 *	  -> SubType, the subtype itself
 */
void
ExaminePERType_Reference(AssignmentList_t ass, Type_t *type, PERConstraints_t *per, PERTypeInfo_t *info)
{
    info->Root.Data = ePERSTIData_Reference;
    info->Root.Alignment = ePERSTIAlignment_BitAligned;
    info->Root.SubIdentifier = GetName(FindAssignment(ass, eAssignment_Type, type->U.Reference.Identifier, type->U.Reference.Module));
    info->Root.SubType = GetAssignment(ass, FindAssignment(ass, eAssignment_Type, type->U.Reference.Identifier, type->U.Reference.Module))->U.Type.Type;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\asn1\asn1c\optcase.c ===
/* Copyright (C) Boris Nikolaus, Germany, 1996-1997. All rights reserved. */
/* Copyright (C) Microsoft Corporation, 1997-1998. All rights reserved. */

#include "precomp.h"

static int _IsNotBounded(PERSimpleTypeInfo_t *sinfo);
static int _IsUnsignedShortRange(PERSimpleTypeInfo_t *sinfo);
static int _IsExtendedShortRange(PERSimpleTypeInfo_t *sinfo);


int PerOptCase_IsSignedInteger(PERSimpleTypeInfo_t *sinfo)
{
    return (sinfo->Data       == ePERSTIData_Integer &&
            sinfo->Constraint == ePERSTIConstraint_Unconstrained &&
            sinfo->Length     == ePERSTILength_InfiniteLength &&
            sinfo->NBits      == 8 &&   // default
            sinfo->Alignment &&
            _IsNotBounded(sinfo) &&
            sinfo->LConstraint== ePERSTIConstraint_Semiconstrained &&
            sinfo->LLowerVal  == 0 &&
            sinfo->LUpperVal  == 0);
}

int PerOptCase_IsUnsignedInteger(PERSimpleTypeInfo_t *sinfo)
{
    return (sinfo->Data       == ePERSTIData_Unsigned &&
            sinfo->Constraint == ePERSTIConstraint_Semiconstrained &&
            sinfo->Length     == ePERSTILength_InfiniteLength &&
            sinfo->NBits      == 8 &&  // default
            sinfo->Alignment &&
            _IsNotBounded(sinfo) &&
            sinfo->LConstraint== ePERSTIConstraint_Semiconstrained &&
            sinfo->LLowerVal  == 0 &&
            sinfo->LUpperVal  == 0);
}

int PerOptCase_IsUnsignedShort(PERSimpleTypeInfo_t *sinfo)
{
    return (sinfo->Data       == ePERSTIData_Unsigned &&
            sinfo->Constraint == ePERSTIConstraint_Constrained &&
            sinfo->Length     == ePERSTILength_NoLength &&
            sinfo->NBits      == 16 &&
            sinfo->Alignment &&
            _IsUnsignedShortRange(sinfo) &&
            sinfo->LConstraint== ePERSTIConstraint_Semiconstrained &&
            sinfo->LLowerVal  == 0 &&
            sinfo->LUpperVal  == 0);
}

int PerOptCase_IsBoolean(PERSimpleTypeInfo_t *sinfo)
{
    return (sinfo->Data       == ePERSTIData_Boolean &&
            sinfo->Constraint == ePERSTIConstraint_Unconstrained &&
            sinfo->Length     == ePERSTILength_NoLength &&
            sinfo->NBits      == 1 &&
            ! sinfo->Alignment &&
            _IsNotBounded(sinfo) &&
            sinfo->LConstraint== ePERSTIConstraint_Semiconstrained &&
            sinfo->LLowerVal  == 0 &&
            sinfo->LUpperVal  == 0);
}

int PerOptCase_IsTargetSeqOf(PERTypeInfo_t *info)
{
    return (
            // we only deal with singly linked-list case
            (info->Rules & eTypeRules_SinglyLinkedList)
            &&
            // check for size of sequence of/set of
            ((info->Root.LLowerVal == 0 && info->Root.LUpperVal == 0) ||
             (info->Root.LLowerVal < info->Root.LUpperVal)
            )
            &&
            // we do not deal with null body case
            (! (info->Root.SubType->Flags & eTypeFlags_Null))
            &&
            // we do not deal with recursive sequence of/set of
            (info->Root.SubType->PERTypeInfo.Root.Data != ePERSTIData_SequenceOf)
            &&
            (info->Root.SubType->PERTypeInfo.Root.Data != ePERSTIData_SetOf)
            &&
            // we only deal with sequence of or non-canonical set of.
            ((info->Root.Data == ePERSTIData_SequenceOf) ||
             (info->Root.Data == ePERSTIData_SetOf && g_eSubEncodingRule != eSubEncoding_Canonical))
           );
}


// UTILITIES

static int _IsNotBounded(PERSimpleTypeInfo_t *sinfo)
{
    return (sinfo->LowerVal.length      == 1 &&
            sinfo->LowerVal.value[0]    == 0 &&
            sinfo->UpperVal.length      == 1 &&
            sinfo->UpperVal.value[0]    == 0);
}

static int _IsUnsignedShortRange(PERSimpleTypeInfo_t *sinfo)
{
    return ((sinfo->UpperVal.length < 3 ) ||
            (sinfo->UpperVal.length == 3 && sinfo->UpperVal.value[0] == 0 &&
             ! _IsExtendedShortRange(sinfo)));
}


static int _IsExtendedShortRange(PERSimpleTypeInfo_t *sinfo)
{
    // if the lower bound is negative and the upper bound greater than 0x7FFF
    // then it is an extended short.
    return ((sinfo->LowerVal.length >= 1) &&
            (sinfo->LowerVal.value[0] & 0x80) && // lower bound is negative
            (sinfo->UpperVal.length == 3) &&
            (sinfo->UpperVal.value[0] == 0) &&  // upper bound is positive
            (*((ASN1uint16_t *) &(sinfo->UpperVal.value[1])) > 0x7FFF)); // upper bound greater than 0x7FFF

}



int BerOptCase_IsBoolean(BERTypeInfo_t *info)
{
    return (eBERSTIData_Boolean == info->Data && 1 == info->NOctets);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\asn1\asn1c\scanner.h ===
/* Copyright (C) Boris Nikolaus, Germany, 1996-1997. All rights reserved. */
/* Copyright (C) Microsoft Corporation, 1997-1998. All rights reserved. */

#ifndef _ASN1C_SCANNER_H_
#define _ASN1C_SCANNER_H_

void readfiles(char **filenames);
extern char *file;

#endif // _ASN1C_SCANNER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\asn1\asn1c\precomp.h ===
/* Copyright (C) Boris Nikolaus, Germany, 1996-1997. All rights reserved. */
/* Copyright (C) Microsoft Corporation, 1997-1998. All rights reserved. */

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <stdarg.h>
#include <stddef.h>
#include <ctype.h>
#include <memory.h>

#define ASN1C

#include <windows.h>

// resolve conflicts
#ifdef GetObject
#undef GetObject
#endif

#include "libasn1.h"

#ifdef ASSERT
#undef ASSERT
#endif

#ifdef _DEBUG
__inline void MyDebugBreak(void) { DebugBreak(); }
#define ASSERT(x)   if (!(x)) MyDebugBreak();
#else
#define ASSERT(x)   
#endif // _DEBUG


typedef ASN1uint8_t     uint8_t;
typedef ASN1uint16_t    uint16_t;
typedef ASN1uint32_t    uint32_t;
typedef ASN1int8_t      int8_t;
typedef ASN1int16_t     int16_t;
typedef ASN1int32_t     int32_t;
typedef ASN1octet_t octet_t;
typedef ASN1intx_t intx_t;
typedef ASN1real_e real_e;
typedef ASN1real_t real_t;
typedef ASN1octetstring_t octetstring_t;
typedef ASN1bitstring_t bitstring_t;
typedef ASN1char_t char_t;
typedef ASN1charstring_t charstring_t;
typedef ASN1ztcharstring_t ztcharstring_t;
typedef ASN1char16_t char16_t;
typedef ASN1char16string_t char16string_t;
typedef ASN1ztchar16string_t ztchar16string_t;
typedef ASN1char32_t char32_t;
typedef ASN1char32string_t char32string_t;
typedef ASN1ztchar32string_t ztchar32string_t;
typedef ASN1uint32_t objectnumber_t;
typedef ASN1objectidentifier_t objectidentifier_t;
typedef ASN1stringtableentry_t stringtableentry_t;
typedef ASN1stringtable_t stringtable_t;
typedef ASN1objectdescriptor_t objectdescriptor_t;
typedef ASN1generalizedtime_t generalizedtime_t;
typedef ASN1utctime_t utctime_t;
typedef ASN1external_t external_t;
#define intx_0 ASN1intx_0
#define intx_1 ASN1intx_1
#define intx_2 ASN1intx_2
#define intx_16 ASN1intx_16
#define intx_256 ASN1intx_256
#define intx_64K ASN1intx_64K
#define intx_1G ASN1intx_1G
#define NumericStringTable ASN1NumericStringTable;
#define intx_add ASN1intx_add
#define intx_addoctet ASN1intx_addoctet
#define intx_sub ASN1intx_sub
#define intx_suboctet ASN1intx_suboctet
#define intx_muloctet ASN1intx_muloctet
#define intx_inc ASN1intx_inc
#define intx_dec ASN1intx_dec
#define intx_neg ASN1intx_neg
#define intx_log2 ASN1intx_log2
#define intx_log256 ASN1intx_log256
#define intx_cmp ASN1intx_cmp
#define intx_dup ASN1intx_dup
#define intx_free ASN1intx_free
#define intx_setuint32 ASN1intx_setuint32
#define intx_setint32 ASN1intx_setint32
#define intx2uint64 ASN1intx2uint64
#define intx2int64 ASN1intx2int64
#define intx2uint32 ASN1intx2uint32
#define intx2int32 ASN1intx2int32
#define intx2uint16 ASN1intx2uint16
#define intx2int16 ASN1intx2int16
#define intx2uint8 ASN1intx2uint8
#define intx2int8 ASN1intx2int8
#define intxisuint64 ASN1intxisuint64
#define intxisint64 ASN1intxisint64
#define intxisuint32 ASN1intxisuint32
#define intxisint32 ASN1intxisint32
#define intxisuint16 ASN1intxisuint16
#define intxisint16 ASN1intxisint16
#define intxisuint8 ASN1intxisuint8
#define intxisint8 ASN1intxisint8
#define intx_octets ASN1intx_octets
#define intx_uoctets ASN1intx_uoctets
#define uint32_log2 ASN1uint32_log2
#define uint32_log256 ASN1uint32_log256
#define uint32_octets ASN1uint32_octets
#define uint32_uoctets ASN1uint32_uoctets
#define int32_octets ASN1int32_octets
#define intx2double ASN1intx2double
#define real2double ASN1real2double
#define intx2double ASN1intx2double
#define real2double ASN1real2double
#define double_minf ASN1double_minf
#define double_pinf ASN1double_pinf
#define double_isminf ASN1double_isminf
#define double_ispinf ASN1double_ispinf
#define generalizedtime2string ASN1generalizedtime2string
#define utctime2string ASN1utctime2string
#define string2generalizedtime ASN1string2generalizedtime
#define string2utctime ASN1string2utctime
#define real_free ASN1real_free
#define bitstring_free ASN1bitstring_free
#define octetstring_free ASN1octetstring_free
#define objectidentifier_free ASN1objectidentifier_free
#define charstring_free ASN1charstring_free
#define char16string_free ASN1char16string_free
#define char32string_free ASN1char32string_free
#define ztcharstring_free ASN1ztcharstring_free
#define ztchar16string_free ASN1ztchar16string_free
#define ztchar32string_free ASN1ztchar32string_free
#define external_free ASN1external_free
#define embeddedpdv_free ASN1embeddedpdv_free
#define characterstring_free ASN1characterstring_free
#define open_free ASN1open_free
#define bitstring_cmp ASN1bitstring_cmp
#define octetstring_cmp ASN1octetstring_cmp
#define objectidentifier_cmp ASN1objectidentifier_cmp
#define charstring_cmp ASN1charstring_cmp
#define char16string_cmp ASN1char16string_cmp
#define char32string_cmp ASN1char32string_cmp
#define ztcharstring_cmp ASN1ztcharstring_cmp
#define ztchar16string_cmp ASN1ztchar16string_cmp
#define ztchar32string_cmp ASN1ztchar32string_cmp
#define double_cmp double
#define real_cmp ASN1real_cmp
#define external_cmp ASN1external_cmp
#define embeddedpdv_cmp ASN1embeddedpdv_cmp
#define characterstring_cmp ASN1characterstring_cmp
#define open_cmp ASN1open_cmp
#define generalizedtime_cmp ASN1generalizedtime_cmp
#define utctime_cmp ASN1utctime_cmp
#define sequenceoflengthpointer_cmp
#define sequenceofsinglylinkedlist_cmp
#define sequenceofdoublylinkedlist_cmp
#define setoflengthpointer_cmp
#define setofsinglylinkedlist_cmp
#define setofdoublylinkedlist_cmp
#define is32space ASN1is32space
#define str32len ASN1str32len
#define is16space ASN1is16space
#define str16len ASN1str16len
#define bitcpy ASN1bitcpy
#define bitclr ASN1bitclr
#define bitset ASN1bitset
#define bitput ASN1bitput
#define octetput ASN1octetput


#include "defs.h"
#include "scanner.h"
#include "parser.h"
#include "builtin.h"
#include "write.h"
#include "error.h"
#include "util.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\asn1\asn1c\scanner.c ===
/* Copyright (C) Boris Nikolaus, Germany, 1996-1997. All rights reserved. */
/* Copyright (C) Microsoft Corporation, 1997-1998. All rights reserved. */

#include "precomp.h"

/* A lexical scanner generated by flex */

/* Scanner skeleton version:
 * $Header: /home/daffy/u0/vern/flex/RCS/flex.skl,v 2.91 96/09/10 16:58:48 vern Exp $
 */

#define FLEX_SCANNER
#define YY_FLEX_MAJOR_VERSION 2
#define YY_FLEX_MINOR_VERSION 5

#include <stdio.h>


/* cfront 1.2 defines "c_plusplus" instead of "__cplusplus" */
#ifdef c_plusplus
#ifndef __cplusplus
#define __cplusplus
#endif
#endif


#ifdef __cplusplus

#include <stdlib.h>
#include <unistd.h>

/* Use prototypes in function declarations. */
#define YY_USE_PROTOS

/* The "const" storage-class-modifier is valid. */
#define YY_USE_CONST

#else   /* ! __cplusplus */

#if __STDC__

#define YY_USE_PROTOS
#define YY_USE_CONST

#endif  /* __STDC__ */
#endif  /* ! __cplusplus */

#ifdef __TURBOC__
 #pragma warn -rch
 #pragma warn -use
#include <io.h>
#include <stdlib.h>
#define YY_USE_CONST
#define YY_USE_PROTOS
#endif

#ifdef YY_USE_CONST
#define yyconst const
#else
#define yyconst
#endif


#ifdef YY_USE_PROTOS
#define YY_PROTO(proto) proto
#else
#define YY_PROTO(proto) ()
#endif

#include "hackdir.h"

/* Returned upon end-of-file. */
#define YY_NULL 0

/* Promotes a possibly negative, possibly signed char to an unsigned
 * integer for use as an array index.  If the signed char is negative,
 * we want to instead treat it as an 8-bit unsigned char, hence the
 * double cast.
 */
#define YY_SC_TO_UI(c) ((unsigned int) (unsigned char) c)

/* Enter a start condition.  This macro really ought to take a parameter,
 * but we do it the disgusting crufty way forced on us by the ()-less
 * definition of BEGIN.
 */
#define BEGIN yy_start = 1 + 2 *

/* Translate the current start state into a value that can be later handed
 * to BEGIN to return to the state.  The YYSTATE alias is for lex
 * compatibility.
 */
#define YY_START ((yy_start - 1) / 2)
#define YYSTATE YY_START

/* Action number for EOF rule of a given start state. */
#define YY_STATE_EOF(state) (YY_END_OF_BUFFER + state + 1)

/* Special action meaning "start processing a new file". */
#define YY_NEW_FILE yyrestart( yyin )

#define YY_END_OF_BUFFER_CHAR 0

/* Size of default input buffer. */
#define YY_BUF_SIZE 16384

typedef struct yy_buffer_state *YY_BUFFER_STATE;

extern int yyleng;
extern FILE *yyin, *yyout;

#define EOB_ACT_CONTINUE_SCAN 0
#define EOB_ACT_END_OF_FILE 1
#define EOB_ACT_LAST_MATCH 2

/* The funky do-while in the following #define is used to turn the definition
 * int a single C statement (which needs a semi-colon terminator).  This
 * avoids problems with code like:
 *
 *  if ( condition_holds )
 *      yyless( 5 );
 *  else
 *      do_something_else();
 *
 * Prior to using the do-while the compiler would get upset at the
 * "else" because it interpreted the "if" statement as being all
 * done when it reached the ';' after the yyless() call.
 */

/* Return all but the first 'n' matched characters back to the input stream. */

#define yyless(n) \
    do \
        { \
        /* Undo effects of setting up yytext. */ \
        *yy_cp = yy_hold_char; \
        yy_c_buf_p = yy_cp = yy_bp + n - YY_MORE_ADJ; \
        YY_DO_BEFORE_ACTION; /* set up yytext again */ \
        } \
    while ( 0 )

#define unput(c) yyunput( c, yytext_ptr )

/* The following is because we cannot portably get our hands on size_t
 * (without autoconf's help, which isn't available because we want
 * flex-generated scanners to compile on their own).
 */
typedef unsigned int yy_size_t;


struct yy_buffer_state
    {
    FILE *yy_input_file;

    char *yy_ch_buf;        /* input buffer */
    char *yy_buf_pos;       /* current position in input buffer */

    /* Size of input buffer in bytes, not including room for EOB
     * characters.
     */
    yy_size_t yy_buf_size;

    /* Number of characters read into yy_ch_buf, not including EOB
     * characters.
     */
    int yy_n_chars;

    /* Whether we "own" the buffer - i.e., we know we created it,
     * and can realloc() it to grow it, and should free() it to
     * delete it.
     */
    int yy_is_our_buffer;

    /* Whether this is an "interactive" input source; if so, and
     * if we're using stdio for input, then we want to use getc()
     * instead of fread(), to make sure we stop fetching input after
     * each newline.
     */
    int yy_is_interactive;

    /* Whether we're considered to be at the beginning of a line.
     * If so, '^' rules will be active on the next match, otherwise
     * not.
     */
    int yy_at_bol;

    /* Whether to try to fill the input buffer when we reach the
     * end of it.
     */
    int yy_fill_buffer;

    int yy_buffer_status;
#define YY_BUFFER_NEW 0
#define YY_BUFFER_NORMAL 1
    /* When an EOF's been seen but there's still some text to process
     * then we mark the buffer as YY_EOF_PENDING, to indicate that we
     * shouldn't try reading from the input source any more.  We might
     * still have a bunch of tokens to match, though, because of
     * possible backing-up.
     *
     * When we actually see the EOF, we change the status to "new"
     * (via yyrestart()), so that the user can continue scanning by
     * just pointing yyin at a new input file.
     */
#define YY_BUFFER_EOF_PENDING 2
    };

static YY_BUFFER_STATE yy_current_buffer = 0;

/* We provide macros for accessing buffer states in case in the
 * future we want to put the buffer states in a more general
 * "scanner state".
 */
#define YY_CURRENT_BUFFER yy_current_buffer


/* yy_hold_char holds the character lost when yytext is formed. */
static char yy_hold_char;

static int yy_n_chars;      /* number of characters read into yy_ch_buf */


int yyleng;

/* Points to current character in buffer. */
static char *yy_c_buf_p = (char *) 0;
static int yy_init = 1;     /* whether we need to initialize */
static int yy_start = 0;    /* start state number */

/* Flag which is used to allow yywrap()'s to do buffer switches
 * instead of setting up a fresh yyin.  A bit of a hack ...
 */
static int yy_did_buffer_switch_on_eof;

void yyrestart YY_PROTO(( FILE *input_file ));

void yy_switch_to_buffer YY_PROTO(( YY_BUFFER_STATE new_buffer ));
void yy_load_buffer_state YY_PROTO(( void ));
YY_BUFFER_STATE yy_create_buffer YY_PROTO(( FILE *file, int size ));
void yy_delete_buffer YY_PROTO(( YY_BUFFER_STATE b ));
void yy_init_buffer YY_PROTO(( YY_BUFFER_STATE b, FILE *file ));
void yy_flush_buffer YY_PROTO(( YY_BUFFER_STATE b ));
#define YY_FLUSH_BUFFER yy_flush_buffer( yy_current_buffer )

YY_BUFFER_STATE yy_scan_buffer YY_PROTO(( char *base, yy_size_t size ));
YY_BUFFER_STATE yy_scan_string YY_PROTO(( yyconst char *yy_str ));
YY_BUFFER_STATE yy_scan_bytes YY_PROTO(( yyconst char *bytes, int len ));

static void *yy_flex_alloc YY_PROTO(( yy_size_t ));
static void *yy_flex_realloc YY_PROTO(( void *, yy_size_t ));
static void yy_flex_free YY_PROTO(( void * ));

#define yy_new_buffer yy_create_buffer

#define yy_set_interactive(is_interactive) \
    { \
    if ( ! yy_current_buffer ) \
        yy_current_buffer = yy_create_buffer( yyin, YY_BUF_SIZE ); \
    yy_current_buffer->yy_is_interactive = is_interactive; \
    }

#define yy_set_bol(at_bol) \
    { \
    if ( ! yy_current_buffer ) \
        yy_current_buffer = yy_create_buffer( yyin, YY_BUF_SIZE ); \
    yy_current_buffer->yy_at_bol = at_bol; \
    }

#define YY_AT_BOL() (yy_current_buffer->yy_at_bol)

typedef unsigned char YY_CHAR;
FILE *yyin = (FILE *) 0, *yyout = (FILE *) 0;
typedef int yy_state_type;
extern char *yytext;
#define yytext_ptr yytext

static yy_state_type yy_get_previous_state YY_PROTO(( void ));
static yy_state_type yy_try_NUL_trans YY_PROTO(( yy_state_type current_state ));
static int yy_get_next_buffer YY_PROTO(( void ));
static void yy_fatal_error YY_PROTO(( yyconst char msg[] ));

/* Done after the current pattern has been matched and before the
 * corresponding action - sets up yytext.
 */
#define YY_DO_BEFORE_ACTION \
    yytext_ptr = yy_bp; \
    yyleng = (int) (yy_cp - yy_bp); \
    yy_hold_char = *yy_cp; \
    *yy_cp = '\0'; \
    yy_c_buf_p = yy_cp;

#define YY_NUM_RULES 126
#define YY_END_OF_BUFFER 127
static yyconst short int yy_accept[722] =
    {   0,
        0,    0,    0,    0,  127,  125,  123,  123,  124,   89,
       96,  125,  125,   89,   89,   93,   93,   89,   97,   97,
       97,   97,   97,   97,   97,   97,   97,   97,   97,   97,
       97,   97,   97,   97,   97,   97,   97,  100,  100,  100,
      100,  100,  100,  100,  121,  120,  105,  126,  121,  121,
      121,  121,  117,  121,  121,  123,  102,  101,    0,    0,
        0,  122,   92,   93,    0,    0,   98,   97,   97,   97,
       97,   97,   97,   99,   97,   97,   97,   97,   11,   97,
       97,   97,   97,   97,   97,   97,   97,   97,   99,   99,
       97,   97,   97,   97,   97,   97,   97,   97,   97,   99,

       97,   97,   58,   97,   99,   97,   97,   97,   99,   97,
       97,   97,   97,   97,   98,   97,   97,   97,   99,   97,
       97,   99,   97,   99,   97,    0,  100,  100,  100,  100,
      100,  100,  100,  121,  120,  104,  121,  121,  107,  121,
      121,  113,  121,  119,  121,  121,  121,  121,  115,    0,
      102,    0,  101,   94,   95,    0,  103,   91,   90,    0,
       97,    3,    4,   97,   97,    0,   97,    8,   97,   97,
       97,   97,   97,   97,   97,   97,   97,   23,   97,   97,
       97,   97,   97,   97,   99,   99,   98,   97,   97,   97,
       97,   97,   97,   97,   48,   49,   97,   97,   99,   97,

       97,   97,   99,   60,   97,   97,   97,   99,   97,   97,
       67,   97,   97,   97,   98,   97,   97,   97,   99,   97,
       97,   97,   99,   97,   99,   99,   97,  100,  100,  100,
      100,  100,  100,  111,  121,  121,  121,    0,  121,  121,
      109,  121,   97,   97,   97,   97,   97,   97,   97,   97,
       97,   97,   97,   97,   97,   97,   97,   97,   97,   97,
       97,   97,   97,   31,   99,   99,   98,   97,   97,   97,
       97,   97,   97,   98,   97,   97,   97,   52,   99,   97,
       97,   97,   99,   97,   97,   97,   99,   65,   97,   68,
       97,   97,   98,   73,   75,   76,   99,   97,   97,   97,

       97,   98,   99,   97,   99,   99,   88,  100,  100,  100,
      100,   77,  100,  121,  121,  121,    0,  121,  121,  121,
       97,   97,   97,   97,    7,   99,   97,   97,   97,   14,
       97,   97,   97,   97,   97,   97,   97,   97,   97,   97,
       97,   30,   99,   99,   99,   97,   97,   97,   97,   97,
       97,   97,   98,   47,   97,   97,   99,   97,   57,   97,
       99,    0,   97,   97,   99,   97,   97,   97,   99,    0,
       99,   78,   97,   97,   99,   98,   99,   84,   99,   99,
       22,  100,  100,  100,   85,  121,  121,  121,    0,  121,
      121,    0,    1,   97,   97,   97,   99,   97,   97,   13,

       97,   97,   97,   97,   97,   97,   97,   25,   97,   97,
       97,   97,   99,   99,   99,   97,   97,   97,   97,   97,
       97,   97,   97,   98,    0,   97,   99,   55,   97,   99,
       97,   97,   97,   99,   97,   69,   71,   99,   97,   99,
       79,   97,   99,   99,   99,   99,   99,  100,   53,   70,
      121,    0,  121,    0,  121,  121,    0,   97,   97,   97,
       99,   10,   97,   97,   97,   18,   19,   97,   97,   97,
       97,   27,   97,   97,   99,   99,   99,   97,   97,   40,
       41,   97,   97,   44,   97,   98,   97,   97,   99,   97,
       99,   97,   62,   64,   99,   97,   99,   97,   99,   97,

       82,   99,   99,   99,   99,  100,    0,    0,    0,    0,
      116,    0,    0,   97,   97,   97,   99,   97,   97,   97,
       97,   21,   97,   26,   97,   29,   99,   99,   99,   99,
       97,   39,   42,   43,   97,   99,   97,   51,   99,   59,
       99,   97,   99,   66,   99,   97,   99,   97,   99,   99,
       99,   99,  100,    0,    0,    0,    0,    0,    0,    0,
       97,    6,    9,   12,   15,   97,   97,   97,   97,   99,
       99,   99,   35,   97,   97,   99,   97,   99,   99,   97,
       99,   72,   97,   99,   80,   99,   99,   99,   99,  100,
        0,    0,    0,    0,    0,    0,   97,   97,   16,   97,

       97,   24,   97,   99,   99,   99,   37,   97,   99,   97,
       99,   99,   97,   99,   97,   99,   83,   99,   99,   99,
       38,    0,    0,    0,  118,    0,    0,   97,    5,   17,
       20,   97,   99,   99,   99,   97,   99,   97,   99,   99,
       97,   99,   97,   99,   99,   99,   99,    0,  106,    0,
        0,    0,   97,   97,   99,   99,   99,   45,   46,   97,
       99,   99,   97,   99,   97,   99,   99,   99,   99,    0,
        0,    0,    0,   97,   28,   33,   99,   34,   97,   54,
       99,   61,   99,   97,   74,   99,   99,   87,    0,    0,
        0,    0,   97,   99,   50,   99,   99,   97,   99,   86,

        0,  112,    0,    0,    2,   32,   99,   63,   36,   81,
        0,    0,  114,   56,    0,    0,    0,    0,  110,  108,
        0
    } ;

static yyconst int yy_ec[256] =
    {   0,
        1,    1,    1,    1,    1,    1,    1,    1,    2,    3,
        2,    2,    2,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    4,    1,    1,    1,    1,
        1,    2,    5,    6,    1,    7,    1,    8,    9,   10,
       11,    1,    1,   12,   13,   14,    1,   15,   16,   17,
       17,   18,   19,   20,   17,   21,   17,   22,   23,   24,
       25,   26,    1,   27,   28,   29,   30,   31,   32,   33,
       34,   35,   36,   37,   38,   39,   40,   41,   42,   43,
       44,   45,   46,   47,   48,   49,   50,   51,   52,   53,
       54,    1,   55,   56,    1,    1,   57,   58,   59,   60,

       61,   62,   63,   64,   65,   66,   67,   68,   69,   70,
       71,   72,   73,   74,   75,   76,   77,   78,   73,   79,
       80,   81,   82,   83,   84,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,

        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1
    } ;

static yyconst int yy_meta[85] =
    {   0,
        1,    2,    2,    1,    1,    1,    1,    1,    2,    1,
        1,    1,    3,    1,    4,    4,    4,    4,    4,    4,
        4,    1,    1,    1,    1,    1,    1,    4,    4,    4,
        4,    4,    4,    5,    5,    5,    5,    5,    5,    5,
        5,    5,    5,    5,    5,    5,    5,    5,    5,    5,
        5,    5,    5,    1,    1,    1,    5,    5,    5,    5,
        5,    5,    5,    5,    5,    5,    5,    5,    5,    5,
        5,    5,    5,    5,    5,    5,    5,    5,    5,    5,
        5,    1,    1,    1
    } ;

static yyconst short int yy_base[729] =
    {   0,
        0,    0,   83,   97, 1486, 3743,   85,   87, 3743, 3743,
     3743,  151,   89, 1471, 1469, 3743,   96, 1449,  220,   89,
      273,  281,  294,  310,  311,  113,  334,  328,  349,  365,
      371,  386,  392,  418,  421,  444,  445, 1457,   80,   84,
       89,   94,   88,   81,    0,  121,    0, 1456,   35,   62,
       63,   68, 1397,   82,   87,  171, 1454, 1451,  302,   91,
     1445, 1446, 1437,  479, 1424,  472,  508,  475,  483,  533,
      534,  549,  555, 1434,  566,  572,  583,  594,  600,  616,
      622,  633,  646,  649,  662,  670,  673,  686,  164,  149,
      701,  704,  712,  727,  738,  753,  759,  770,  781,  234,

      794,  797,  810,  818,  109,  821,  834,  842,   95,  858,
      864,  875,  881,  892, 1429,  898,  909,  915,  262,  926,
      942,  261,  939,  306,  950, 1431, 1430,  133,  318,  263,
      232,  296,  315,    0,  334, 3743, 1372, 1362,    0, 1353,
     1360,    0, 1415,    0, 1357, 1351, 1347, 1339,    0, 1398,
     1396, 1392, 1391, 3743, 3743, 1363, 3743, 3743, 3743,    0,
      963,  974,  980,  991, 1002, 1383, 1013, 1019, 1030, 1036,
     1051, 1052, 1068, 1069, 1084, 1090, 1105, 1106, 1121, 1127,
     1138, 1144, 1155, 1166,  328,  312, 1348, 1179, 1182, 1190,
     1203, 1216, 1227, 1224, 1242, 1245, 1248, 1263,  335, 1266,

     1281, 1287,  348, 1298, 1304, 1315, 1326,  331, 1337, 1343,
     1354, 1360, 1371, 1377, 1344, 1388, 1394, 1409,  380, 1417,
     1433, 1434,  229, 1449,  390,  334, 1450,  373,  347,  374,
      357,  392,  330,    0, 1330, 1326, 1318, 1307, 1307, 1310,
        0, 1300, 1465, 1466, 1481, 1487, 1502, 1503, 1520, 1519,
     1535, 1541, 1552, 1563, 1574, 1580, 1595, 1598, 1606, 1619,
     1627, 1635, 1650, 1656,  429,  407, 1294, 1667, 1680, 1688,
     1691, 1709, 1706, 1350, 1717, 1732, 1738, 1753,  443, 1754,
     1769, 1780,  417, 1786, 1801, 1807,  430, 1818, 1824, 1835,
     1841, 1857, 1288, 1858, 1873, 1879,  452, 1890, 1896, 1911,

     1912, 1316,  441, 1932,  439,  424, 1933,  163,  454,  464,
      435, 1347,  506, 1291, 1297, 1277, 1280, 1273, 1280, 1329,
     1949, 1965, 1971, 1987, 1988,  494, 2004, 2010, 2025, 2026,
     2041, 2042, 2057, 2063, 2078, 2079, 2094, 2109, 2115, 2126,
     2132, 2147,  398,  462,  495, 2148, 2168, 2165, 2186, 2185,
     2203, 2202, 1320, 2218, 2224, 2235,  467, 2241, 2252, 2258,
      551, 2269, 2275, 2286,  476, 2297, 2303, 2314,  558, 2320,
      522, 2331, 2337, 2348,  465, 1262,  566, 2359,  552,  553,
     1323,  591,  572,  567, 1321, 1252, 1318, 1261, 1256, 1258,
     1238, 1241, 2365, 2380, 2383, 2386,  595, 2401, 2407, 2418,

     2424, 2440, 2446, 2461, 2467, 2484, 2483, 2499, 2500, 2515,
     2516, 2537,  557,  593,  603, 2538, 2553, 2559, 2570, 2576,
     2591, 2597, 2612, 1269, 2618, 2629,  621, 2635, 2651,  586,
     2652, 2667, 2680,  580, 2688, 2691, 2704,  641, 2715,  574,
     2712, 2728,  605,  597,  656,  634,  671,  636, 1299, 1295,
     1290, 1244, 1287, 1229, 1223, 1281, 1221, 2736, 2739, 2752,
      654, 2760, 2773, 2781, 2789, 2797, 2805, 2813, 2826, 2829,
     2842, 2853, 2859, 2870,  673,  691,  669, 2876, 2887, 2898,
     2904, 2915, 2921, 2936, 2937, 1204, 2952, 2953,  713, 2968,
      710, 2969, 2984, 2985,  694, 3002,  695, 3008,  741, 3024,

     1266,  670,  733,  735,  745,  750, 1210, 1199, 1190, 1185,
        0, 1192, 1184, 3025, 3040, 3041,  709, 3056, 3064, 3067,
     3080, 3088, 3101, 3109, 3117, 3125,  751,  765,  756,  771,
     3138, 3146, 3149, 3162, 3170,  780, 3173, 3186,  772, 3194,
      737, 3202,  782, 3210,  792, 3218,  776, 3226,  806,  748,
      784,  808,  795, 1189, 1178, 1178, 1182, 1176, 1171, 3234,
     3242, 3250, 1226, 3258, 3266, 3279, 3287, 3290, 3303,  793,
      828,  875, 1224, 3311, 3319,  763, 3332,  879,  866, 3335,
      867, 1223, 3343,  885, 3356,  882,  896,  923,  887,  902,
     1165, 1177, 1163, 1152, 1147, 1151, 3359, 3367, 3380, 3383,

     3391, 3404, 3412,  878,  812,  921, 3415, 3428,  881, 3436,
      947,  934, 3444,  951, 3452,  953, 1202,  957,  964,  960,
     1200, 1145, 1130, 1134, 3743, 1135, 1130, 3460, 3468, 3476,
     3484, 3492,  981,  855,  983, 3505,  992, 3513,  987,  971,
     3516,  994, 3529, 1013, 1011,  975, 1016, 1132, 3743, 1115,
     1128, 1131, 3537, 3540, 1001, 1022, 1003, 3557, 1169, 3560,
     1057, 1033, 3573, 1024, 3581, 1059, 1050, 1034, 1061, 1114,
     1111, 1098, 1079, 3598, 3599, 1139, 1088, 1130, 3614, 1129,
     1089, 3615, 1069, 3632,  988, 1093, 1108,  917,  906,  843,
      883,  742, 3631, 1090, 3647, 1128, 1115, 3648, 1127,  683,

      609, 3743,  523,  529, 3663,  477, 1123,  445, 3669,  423,
      262,  181, 3743,  231,  132,   96,   60,   58, 3743, 3743,
     3743, 3717, 3721, 3723, 3728, 3731, 3734, 3737
    } ;

static yyconst short int yy_def[729] =
    {   0,
      721,    1,  722,  722,  721,  721,  721,  721,  721,  721,
      721,  721,  723,  721,  721,  721,  721,  721,  721,   19,
       19,   19,   19,   19,   19,   19,   19,   19,   19,   19,
       19,   19,   19,   19,   19,   19,   19,  724,  724,  724,
      724,  724,  724,  724,  725,  725,  725,  721,  725,  725,
      725,  725,  725,  725,  725,  721,  726,  727,  723,  721,
      723,  721,  721,  721,  721,   19,   19,   19,   19,   19,
       19,   19,   19,  728,   19,   19,   19,   19,   19,   19,
       19,   19,   19,   19,   19,   19,   19,   19,  728,  728,
       19,   19,   19,   19,   19,   19,   19,   19,   19,  728,

       19,   19,   19,   19,  728,   19,   19,   19,  728,   19,
       19,   19,   19,   19,   67,   19,   19,   19,  728,   19,
       19,  728,   19,  728,   19,  724,  724,  724,  724,  724,
      724,  724,  724,  725,  725,  721,  725,  725,  725,  725,
      725,  725,  725,  725,  725,  725,  725,  725,  725,  726,
      726,  727,  727,  721,  721,  721,  721,  721,  721,   67,
       19,   19,   19,   19,   19,  728,   19,   19,   19,   19,
       19,   19,   19,   19,   19,   19,   19,   19,   19,   19,
       19,   19,   19,   19,  728,  728,   67,   19,   19,   19,
       19,   19,   19,   19,   19,   19,   19,   19,  728,   19,

       19,   19,  728,   19,   19,   19,   19,  728,   19,   19,
       19,   19,   19,   19,   67,   19,   19,   19,  728,   19,
       19,   19,  728,   19,  728,  728,   19,  724,  724,  724,
      724,  724,  724,  725,  725,  725,  725,  721,  725,  725,
      725,  725,   19,   19,   19,   19,   19,   19,   19,   19,
       19,   19,   19,   19,   19,   19,   19,   19,   19,   19,
       19,   19,   19,   19,  728,  728,   67,   19,   19,   19,
       19,   19,   19,   67,   19,   19,   19,   19,  728,   19,
       19,   19,  728,   19,   19,   19,  728,   19,   19,   19,
       19,   19,   67,   19,   19,   19,  728,   19,   19,   19,

       19,   67,  728,   19,  728,  728,   19,  724,  724,  724,
      724,  724,  724,  725,  725,  725,  721,  725,  725,  725,
       19,   19,   19,   19,   19,  728,   19,   19,   19,   19,
       19,   19,   19,   19,   19,   19,   19,   19,   19,   19,
       19,   19,  728,  728,  728,   19,   19,   19,   19,   19,
       19,   19,   67,   19,   19,   19,  728,   19,   19,   19,
      728,   19,   19,   19,  728,   19,   19,   19,  728,   19,
      728,   19,   19,   19,  728,   67,  728,   19,  728,  728,
      724,  724,  724,  724,  724,  725,  725,  725,  721,  725,
      725,  721,   19,   19,   19,   19,  728,   19,   19,   19,

       19,   19,   19,   19,   19,   19,   19,   19,   19,   19,
       19,   19,  728,  728,  728,   19,   19,   19,   19,   19,
       19,   19,   19,   67,   19,   19,  728,   19,   19,  728,
       19,   19,   19,  728,   19,   19,   19,  728,   19,  728,
       19,   19,  728,  728,  728,  728,  728,  724,  724,  724,
      725,  721,  725,  721,  725,  725,  721,   19,   19,   19,
      728,   19,   19,   19,   19,   19,   19,   19,   19,   19,
       19,   19,   19,   19,  728,  728,  728,   19,   19,   19,
       19,   19,   19,   19,   19,   67,   19,   19,  728,   19,
      728,   19,   19,   19,  728,   19,  728,   19,  728,   19,

      728,  728,  728,  728,  728,  724,  721,  721,  721,  721,
      725,  721,  721,   19,   19,   19,  728,   19,   19,   19,
       19,   19,   19,   19,   19,   19,  728,  728,  728,  728,
       19,   19,   19,   19,   19,  728,   19,   19,  728,   19,
      728,   19,  728,   19,  728,   19,  728,   19,  728,  728,
      728,  728,  724,  721,  721,  721,  721,  721,  721,   19,
       19,   19,  728,   19,   19,   19,   19,   19,   19,  728,
      728,  728,  728,   19,   19,  728,   19,  728,  728,   19,
      728,  728,   19,  728,   19,  728,  728,  728,  728,  724,
      721,  721,  721,  721,  721,  721,   19,   19,   19,   19,

       19,   19,   19,  728,  728,  728,   19,   19,  728,   19,
      728,  728,   19,  728,   19,  728,  728,  728,  728,  728,
      724,  721,  721,  721,  721,  721,  721,   19,   19,   19,
       19,   19,  728,  728,  728,   19,  728,   19,  728,  728,
       19,  728,   19,  728,  728,  728,  728,  721,  721,  721,
      721,  721,   19,   19,  728,  728,  728,   19,  728,   19,
      728,  728,   19,  728,   19,  728,  728,  728,  728,  721,
      721,  721,  721,   19,   19,  728,  728,  728,   19,  728,
      728,   19,  728,   19,  728,  728,  728,  728,  721,  721,
      721,  721,   19,  728,   19,  728,  728,   19,  728,  728,

      721,  721,  721,  721,   19,  728,  728,  728,   19,  728,
      721,  721,  721,  728,  721,  721,  721,  721,  721,  721,
        0,  721,  721,  721,  721,  721,  721,  721
    } ;

static yyconst short int yy_nxt[3828] =
    {   0,
        6,    7,    8,    9,   10,   11,    6,   12,   13,   10,
       10,   10,   14,   15,   16,   17,   17,   17,   17,   17,
       17,   18,   10,   10,    6,   10,   10,   19,   20,   21,
       22,   23,   24,   25,   26,   27,   26,   26,   26,   28,
       29,   30,   31,   26,   32,   33,   34,   35,   36,   37,
       26,   26,   26,   10,   10,   10,   38,   38,   38,   38,
       39,   38,   38,   38,   40,   38,   38,   38,   38,   41,
       38,   38,   38,   38,   42,   43,   38,   44,   38,   38,
       38,   10,   10,   10,   46,   47,   56,   56,   56,   56,
       59,   59,  126,  126,   46,   48,  126,   60,   46,   47,

      126,  126,  137,   59,   59,  138,  126,  166,   46,   48,
       64,   64,   64,   64,   64,   64,   64,   68,  139,  154,
       75,  166,  135,  141,   76,  155,  140,   68,   77,   68,
       78,   68,  135,  720,  142,  719,   68,  133,  143,  144,
       79,   68,   49,  129,   50,  126,  146,  148,  128,  147,
       51,   68,   52,   68,   53,   68,   49,   54,   50,  208,
       68,  166,  149,   55,   51,  130,   52,  132,   53,  131,
      718,   54,   56,   56,  203,  126,  166,   55,   57,   57,
       57,   57,   57,   57,   57,   57,   57,   57,   57,   57,
       57,   57,   57,   57,   57,   57,   57,   57,   57,   57,

       57,   57,   57,   57,  228,  186,  717,   58,   58,   58,
       58,   58,   58,   58,   58,   58,   58,   58,   58,   58,
       58,   58,   58,   58,   58,   58,   58,   58,   58,   58,
       58,   58,   66,  185,   67,   67,   67,   67,   67,   67,
       67,  166,  381,  166,  126,  716,  166,   68,   69,   68,
       68,   68,   68,   68,   68,   68,   68,   68,   70,   68,
       71,   68,   72,   68,   68,   68,   68,   73,   68,   68,
       68,   68,   68,  166,  166,  126,   74,   74,   74,   74,
       74,   74,   74,   74,   74,   74,   74,   74,   74,   74,
       74,   74,   74,   74,   74,   74,   74,   74,   74,   74,

       74,   68,  199,   59,   59,  231,  303,   80,  126,   68,
       60,   81,   83,   68,   82,   68,   59,   59,  166,   68,
       68,   68,   68,   68,  166,  223,  715,  126,   68,  219,
      126,  230,   68,   84,   85,  135,   68,   87,   68,   68,
      166,   68,  126,  166,   86,  135,  166,  166,   68,   68,
       68,   68,   68,   68,   88,   96,   68,   68,   68,  126,
      166,   91,   68,   97,   92,  225,   68,  232,   68,  126,
       68,   89,   68,   93,   94,   68,   68,   68,  229,   95,
      226,   68,  233,  266,   90,  126,  126,   68,  265,   68,
       98,   68,  166,  101,  102,  279,   99,  103,  306,   68,

      287,  106,  166,   68,  126,   68,  313,  104,  283,  107,
      166,   68,   68,   68,   68,  108,  309,  110,   68,  166,
       68,  311,  105,  111,   68,  100,   68,  112,   68,  166,
       68,  310,   68,   68,   68,  166,  166,  115,  113,   68,
      297,  166,  166,  114,  109,  116,   68,  126,  308,   68,
      305,  166,  312,  166,  413,  166,   68,  166,   68,   68,
       68,  120,  117,   68,  166,   68,  126,  121,   68,  118,
      344,  123,   68,   68,  166,  361,  126,  166,  119,  166,
      125,  380,   68,   68,   68,   68,   68,   68,  166,  166,
      122,   68,   68,   64,   64,   64,   64,   64,   64,   64,

       68,  377,  343,   68,  384,  365,  166,  166,  124,  379,
       68,   68,   68,   68,   68,   68,  357,   68,  126,   68,
      160,   68,   68,   68,  383,   68,  414,  371,  161,  382,
       68,  427,  434,  443,  166,   67,   67,   67,   67,   67,
       67,   67,   67,   67,   67,   67,   67,   67,   67,   67,
       67,   67,   67,   67,   67,   67,   67,   67,   67,   67,
       67,   68,   68,  166,  166,  166,  385,  397,  415,  166,
      166,  162,   68,   68,   68,   68,   68,   68,  166,  126,
       68,   68,  440,   68,  126,  163,  166,   68,  713,   68,
      712,  164,  166,   68,   68,   68,   68,   68,  166,  167,

       68,  165,   68,  126,   68,  166,   68,  166,   68,  166,
       68,   68,   68,   68,   68,  166,  491,  166,  168,   68,
      447,   68,   68,   68,  475,  169,  430,  446,   68,  450,
       68,  438,   68,  166,   68,  170,   68,  495,   68,  445,
       68,   68,   68,  171,   68,  449,  166,   68,  126,  173,
       68,  476,  499,  166,   68,  448,   68,  172,   68,  461,
       68,   68,   68,   68,   68,  501,  166,  477,  166,   68,
      502,   68,  174,  175,   68,   68,  711,  177,  176,  489,
       68,  166,  166,  166,   68,  166,   68,   68,   68,   68,
       68,   68,  178,   68,  504,  166,   68,  506,   68,  180,

       68,   68,   68,  166,   68,  497,  166,  166,   68,  179,
       68,  183,  181,   68,   68,   68,  182,   68,  527,  187,
       68,  166,  166,  517,   68,  166,   68,  184,   68,   68,
      503,  505,   68,   68,  549,  188,  529,  528,  530,   68,
       68,   68,   68,   68,   68,  166,   68,  166,   68,  166,
       68,   68,   68,  166,  189,   68,  190,  166,  539,   68,
      166,  543,  126,  166,  545,   68,   68,   68,  166,   68,
      541,  563,  191,  192,   68,  166,   68,  166,   68,  193,
       68,   68,  194,  166,  166,   68,  547,   68,  166,  550,
      552,   68,  166,   68,  166,   68,  166,   68,   68,  196,

       68,   68,  704,  195,  166,  166,   68,  126,   68,   68,
       68,  579,   68,  551,  553,  587,  197,   68,  166,  198,
      166,   68,   68,   68,  166,   68,  570,  609,   68,  588,
      200,  572,   68,  573,   68,   68,   68,   68,   68,   68,
      166,   68,  581,  201,   68,  571,   68,  578,   68,   68,
       68,  584,   68,  576,  582,  590,   68,   68,   68,   68,
       68,   68,   68,   68,  202,   68,  604,  166,   68,  204,
       68,  634,   68,  206,   68,  586,   68,  207,  166,  166,
       68,  205,   68,  589,   68,  209,   68,  166,  605,   68,
      166,  166,   68,  166,  166,  703,   68,  166,   68,  166,

       68,  656,   68,   68,   68,   68,   68,  210,  166,   68,
      211,   68,  614,   68,  126,   68,  702,   68,  701,   68,
       68,   68,   68,   68,  612,  213,   68,  212,   68,  166,
       68,  216,  214,  166,   68,  166,   68,   68,   68,   68,
       68,  618,  633,   68,  617,   68,  166,   68,  606,   68,
      637,   68,  611,   68,   68,   68,  217,  218,  616,  166,
      620,  220,   68,  166,   68,  166,   68,   68,   68,  166,
       68,  221,  166,   68,  222,  621,  166,  224,   68,   68,
       68,   68,   68,  166,   68,  635,   68,  166,   68,   68,
       68,   68,   68,  166,  243,  166,  227,   68,  619,  166,

      166,   68,   68,   68,  166,   68,  166,  640,   68,  244,
       68,  639,   68,  166,   68,  166,   68,  644,   68,   68,
       68,   68,   68,  166,  647,  166,  642,   68,  166,  245,
       68,   68,  645,   68,  166,  662,  166,  646,   68,  668,
       68,   68,   68,  246,   68,  166,  166,   68,  247,   68,
      655,   68,  657,   68,  659,   68,  661,   68,   68,   68,
       68,   68,  166,  676,   68,  678,   68,  664,   68,  166,
       68,  166,   68,  166,  249,  248,   68,   68,   68,   68,
       68,  166,  666,   68,  667,  669,  677,  251,  683,   68,
       68,   68,   68,   68,   68,  250,   68,   68,   68,   68,

      166,  166,  166,  687,  681,  166,   68,   68,   68,   68,
       68,  253,   68,  252,  686,   68,   68,  255,   68,  680,
      166,  685,   68,  688,   68,  256,   68,  166,   68,  254,
       68,   68,   68,   68,   68,  166,  257,   68,  697,  166,
      166,  166,  166,   68,   68,   68,   68,   68,   68,   68,
      706,  166,   68,   68,  692,   68,  694,  691,  259,   68,
      258,   68,  699,   68,  696,   68,   68,   68,   68,   68,
      700,  690,   68,  689,   68,  262,  260,  708,   68,  261,
       68,  166,   68,   68,   68,   68,   68,  673,  672,  710,
      671,   68,  670,   68,   68,   68,  714,   68,  707,  652,

      263,  651,   68,  650,   68,  264,   68,   68,   68,  649,
       68,  648,  126,   68,  166,  627,  626,   68,   68,  268,
      269,   68,   68,  270,   68,  625,   68,  624,  271,   68,
       68,   68,   68,  623,  622,  166,  166,   68,  166,  596,
      595,   68,  594,   68,   68,   68,  274,  273,  593,  272,
       68,  592,   68,  591,   68,   68,   68,  559,   68,  558,
      557,  556,   68,   68,   68,   68,   68,   68,  275,   68,
       68,   68,  555,   68,   68,  277,   68,  554,  166,  536,
       68,  513,   68,   68,   68,   68,   68,   68,   68,   68,
       68,   68,  276,  512,   68,   68,  511,  280,  510,  509,

      508,  278,  507,   68,   68,   68,   68,  126,   68,   68,
       68,  126,  281,   68,  486,   68,  457,  456,  455,   68,
      454,   68,  282,   68,  453,   68,   68,   68,   68,   68,
      452,  451,   68,  126,   68,  126,   68,  444,   68,  424,
       68,  392,   68,   68,   68,   68,   68,  391,  390,  284,
      389,   68,  388,   68,   68,   68,  387,   68,  386,  126,
      285,  376,   68,  369,   68,   68,   68,  353,   68,  345,
      320,   68,  319,   68,  286,  288,  318,   68,  317,   68,
      316,   68,   68,   68,   68,   68,  315,  314,   68,  293,
      289,  290,   68,  267,   68,  166,   68,  155,   68,   68,

       68,   68,   68,  152,  152,   68,  291,   68,  150,   68,
      150,   68,  242,   68,  241,   68,   68,   68,   68,   68,
      240,  239,   68,  292,   68,  295,   68,  238,   68,  237,
       68,  236,   68,  294,   68,   68,   68,   68,  235,  234,
      296,   68,  126,  126,  215,   68,  166,   68,  159,   68,
      158,   68,  157,  156,  302,   68,   68,   68,  298,   68,
      299,   68,   68,  152,   68,  300,  150,  145,  136,  126,
       65,   68,   68,   68,   68,   68,   68,   68,   68,  301,
       68,   68,   63,   62,  307,  721,  721,   68,   68,   68,
       68,   68,   68,   68,   68,  721,  304,   68,  721,  721,

      721,  721,  721,   68,   68,  321,   68,   68,   68,   68,
      322,  721,   68,   68,  721,   68,  323,  721,  721,   68,
      721,   68,  721,   68,  721,   68,  324,   68,   68,   68,
       68,   68,  721,  721,   68,  721,  721,  721,  721,  721,
       68,   68,  325,   68,   68,   68,  328,   68,   68,   68,
       68,  327,  721,  721,  721,  721,  721,   68,   68,   68,
       68,   68,   68,   68,  329,  721,   68,   68,  721,   68,
      721,  721,  721,   68,  721,   68,  721,   68,  326,   68,
       68,   68,   68,   68,  721,  721,  330,  721,   68,  721,
       68,   68,   68,  331,   68,  721,  721,  721,  721,   68,

      721,   68,   68,   68,  721,   68,  721,  721,   68,  332,
       68,  721,   68,  721,   68,  721,   68,  721,   68,  721,
      334,  333,   68,   68,  721,  335,   68,   68,  721,  336,
      721,  721,  721,   68,   68,   68,   68,   68,   68,  721,
       68,  721,   68,  721,   68,   68,   68,   68,  337,  721,
      721,  721,  721,   68,  338,   68,  721,   68,  721,   68,
      721,   68,  721,   68,  721,   68,   68,   68,  721,   68,
      721,  339,  721,   68,   68,  340,  721,   68,   68,  341,
      721,  342,   68,  721,   68,  721,  721,  721,   68,  721,
       68,  721,   68,  721,   68,   68,   68,   68,   68,  721,

      721,  721,  721,   68,  721,   68,  721,   68,   68,   68,
      721,  721,  721,  346,   68,  347,   68,  721,   68,   68,
       68,  721,   68,  721,  721,  721,   68,   68,   68,   68,
       68,   68,  348,   68,   68,   68,  350,   68,  349,  351,
      721,  721,  721,  721,   68,   68,   68,   68,   68,   68,
      352,   68,  721,   68,  721,   68,   68,   68,  354,   68,
       68,  721,  721,  721,   68,  721,   68,  721,  721,  721,
       68,  721,   68,  721,   68,  721,   68,  355,   68,   68,
       68,   68,   68,  358,  356,   68,  721,  721,  721,  721,
      721,   68,   68,   68,   68,   68,   68,   68,  362,  721,

       68,   68,  721,  721,  721,  721,  721,   68,   68,   68,
      721,   68,  721,  721,   68,  359,   68,  721,   68,  721,
       68,  360,   68,  721,   68,  721,   68,   68,   68,   68,
      721,  721,  363,   68,  364,   68,  721,  721,  721,   68,
      721,   68,  721,   68,  721,   68,   68,   68,   68,   68,
      721,  721,   68,  721,   68,  366,   68,  721,   68,  721,
       68,  721,   68,   68,   68,   68,   68,  721,  721,   68,
      721,   68,  721,   68,  721,   68,  721,   68,  721,   68,
      721,  367,   68,   68,  368,   68,   68,  721,   68,  721,
      721,  370,  721,  721,  721,   68,   68,   68,   68,   68,

       68,   68,  721,  721,   68,   68,  721,   68,  721,  721,
      721,   68,  721,   68,  721,   68,  721,   68,   68,   68,
       68,   68,  721,  721,   68,  721,   68,  721,   68,  721,
      372,  721,   68,  721,   68,  721,   68,   68,   68,   68,
       68,  721,  374,  373,  721,  721,  721,  721,  721,   68,
       68,   68,   68,   68,   68,  721,  721,  721,   68,   68,
       68,   68,  721,  378,  721,  721,  721,  721,  721,  721,
       68,   68,   68,   68,   68,   68,  375,   68,  721,   68,
       68,  721,  721,  721,  721,  721,  721,   68,  721,   68,
      721,   68,  394,   68,  721,  393,   68,  721,  721,   68,

      395,  721,  721,   68,  721,   68,  721,   68,  721,   68,
      721,   68,   68,   68,  396,   68,   68,  721,   68,  721,
      721,  721,  721,  721,  721,   68,   68,   68,   68,   68,
       68,  398,   68,  721,   68,   68,  721,  721,   68,  399,
      721,  721,   68,  721,   68,  721,   68,  721,   68,  721,
       68,   68,   68,   68,   68,  721,  400,   68,  721,  721,
      721,  721,  721,   68,   68,   68,   68,   68,   68,   68,
       68,  721,   68,   68,  721,  721,  721,  721,  721,   68,
       68,  401,   68,   68,   68,   68,  402,  721,   68,   68,
      721,   68,  721,  721,  404,  403,  721,   68,  405,   68,

      721,   68,  721,   68,   68,   68,   68,   68,  406,  721,
       68,  721,  721,  721,  721,  721,   68,   68,   68,   68,
       68,   68,   68,  407,  721,   68,   68,  721,  721,  721,
      721,  721,   68,  721,   68,  721,   68,   68,  409,  721,
      408,   68,  721,   68,  721,  721,  721,   68,  721,   68,
      721,   68,  721,   68,   68,   68,   68,   68,  721,  721,
       68,  410,   68,  721,   68,  721,   68,  721,   68,  721,
       68,  411,  412,   68,   68,   68,   68,  721,  721,   68,
      721,  721,  721,  416,  721,   68,   68,   68,   68,   68,
       68,  721,  721,   68,   68,   68,   68,  417,  721,  418,

      721,  721,  721,   68,  721,   68,   68,   68,   68,  721,
       68,  419,   68,   68,   68,   68,  420,  721,  721,  721,
      721,  721,  721,   68,   68,  421,   68,   68,   68,  721,
       68,   68,   68,   68,  422,  721,  425,  721,  721,  721,
       68,   68,   68,   68,   68,   68,   68,  423,  721,   68,
       68,  721,   68,  721,  721,  721,   68,  721,   68,  721,
       68,  721,   68,   68,   68,   68,   68,  721,  721,   68,
      426,   68,  721,   68,  721,   68,  721,   68,  721,   68,
       68,   68,   68,   68,  721,  721,   68,  428,   68,  721,
       68,  721,   68,  721,   68,  721,   68,   68,  429,   68,

       68,  721,  721,   68,  431,   68,  721,   68,  721,   68,
      721,   68,  721,   68,   68,  432,   68,   68,  721,  721,
      721,  721,   68,  721,   68,   68,   68,  721,   68,  721,
      721,   68,  433,   68,  721,   68,  436,  435,  721,   68,
      721,   68,   68,   68,   68,   68,  721,  721,   68,  721,
       68,  721,   68,  721,   68,  439,   68,  721,   68,   68,
       68,   68,   68,  721,  437,   68,  721,   68,  441,   68,
      721,   68,  721,   68,  721,   68,   68,   68,   68,   68,
      721,  721,  721,  721,   68,  721,   68,   68,   68,  721,
       68,  721,  442,   68,  721,   68,  721,   68,  721,   68,

      721,   68,  721,   68,  721,   68,   68,   68,   68,  458,
      459,   68,   68,  721,   68,  721,  721,  721,   68,  721,
       68,   68,   68,   68,   68,   68,   68,   68,   68,   68,
       68,  721,  460,   68,  721,   68,  721,  721,  721,   68,
      721,  462,  721,   68,  721,   68,   68,   68,   68,   68,
      721,  721,   68,  463,   68,  464,   68,  721,   68,  721,
       68,  721,   68,  721,   68,   68,   68,  465,   68,  721,
      721,   68,  721,  721,   68,  721,  721,  721,   68,  721,
       68,  721,   68,  721,   68,  721,   68,   68,   68,   68,
      721,  467,  466,   68,  721,   68,  721,  721,  721,   68,

      721,   68,  721,   68,  721,   68,  721,   68,   68,   68,
      470,   68,   68,  468,   68,  469,  721,  721,  721,  721,
      721,   68,   68,   68,   68,   68,   68,   68,   68,  721,
       68,   68,  721,  721,  721,  471,  721,   68,   68,   68,
       68,   68,   68,   68,   68,  721,   68,   68,  721,  721,
      721,  473,  721,   68,   68,   68,   68,   68,   68,  721,
      472,  721,   68,   68,  474,   68,   68,  721,  721,  721,
      478,  721,  721,  721,  721,   68,   68,   68,   68,   68,
       68,   68,  721,  721,   68,   68,  721,   68,  479,  480,
      721,   68,  721,   68,  721,   68,  721,   68,   68,   68,

       68,   68,  721,  721,   68,  721,   68,  482,   68,  721,
       68,  721,   68,  721,   68,  481,   68,   68,   68,   68,
      483,  721,  721,   68,  721,   68,  721,  721,  721,   68,
      721,   68,  721,   68,  721,   68,  721,   68,   68,   68,
       68,  484,  721,  485,   68,  721,   68,  721,  721,  721,
       68,  721,   68,  487,   68,  721,   68,   68,   68,   68,
       68,  721,  721,   68,  721,   68,  721,   68,  721,   68,
      488,   68,  721,   68,  721,   68,   68,   68,  490,   68,
       68,  721,   68,  721,  721,  721,  721,  721,  721,   68,
       68,   68,  492,   68,   68,   68,  721,  721,   68,   68,

      721,  721,  721,  721,  721,   68,  721,   68,   68,   68,
      721,  494,  721,  493,   68,  721,   68,  496,   68,   68,
       68,  721,   68,  721,  721,  721,   68,   68,   68,   68,
       68,   68,   68,   68,  721,   68,  721,  721,   68,  721,
       68,  721,   68,   68,   68,  498,   68,  721,  721,  721,
       68,   68,   68,   68,   68,   68,   68,   68,  721,   68,
      721,  721,   68,  721,   68,  721,   68,   68,   68,  721,
       68,  721,  721,  500,   68,   68,   68,   68,   68,   68,
       68,   68,  514,   68,  721,  515,   68,  516,   68,  721,
       68,  721,   68,  721,   68,  721,  721,  721,   68,   68,

       68,   68,   68,  721,  518,  721,  721,   68,  721,   68,
      721,   68,  721,   68,  721,   68,  721,   68,  721,   68,
       68,  519,  721,   68,  520,   68,  721,   68,   68,   68,
      721,   68,  721,   68,  721,   68,   68,   68,  721,   68,
      721,   68,  721,   68,   68,   68,  721,   68,  521,  721,
      721,   68,   68,   68,   68,   68,  522,   68,  721,  721,
       68,  721,  721,  721,   68,  721,   68,   68,   68,   68,
       68,   68,  721,   68,  721,  523,   68,  721,  721,  721,
       68,   68,   68,  721,   68,  721,  721,  525,  524,   68,
      721,   68,  721,   68,  721,   68,  721,   68,   68,   68,

       68,   68,  721,  721,   68,  721,   68,  721,  526,  721,
       68,  531,   68,  721,   68,   68,   68,   68,   68,  721,
      721,  721,  721,   68,  721,   68,   68,   68,  721,   68,
      721,  721,   68,  532,   68,  721,   68,  721,   68,  721,
       68,  721,   68,   68,   68,   68,   68,  721,  721,   68,
      721,   68,  534,   68,  721,   68,  721,   68,  721,   68,
      533,   68,   68,   68,   68,   68,  535,  721,   68,  721,
      721,  721,  721,  721,   68,   68,   68,   68,   68,   68,
       68,   68,  721,   68,   68,  721,  721,  721,  721,  721,
       68,   68,  537,  538,   68,   68,   68,   68,  721,   68,

       68,  542,  721,  721,  721,  721,  540,   68,   68,   68,
       68,   68,   68,   68,  721,   68,   68,  721,  721,  721,
      721,  721,   68,   68,   68,   68,   68,   68,  721,  721,
       68,   68,   68,  544,  721,  721,   68,  560,  721,  546,
       68,  721,   68,  721,   68,  721,   68,  721,   68,   68,
       68,  548,   68,   68,  721,   68,  721,  721,  721,  721,
      721,  721,   68,   68,   68,   68,   68,   68,   68,   68,
      562,   68,   68,  721,  721,  561,  721,  721,   68,   68,
       68,   68,   68,   68,   68,  721,  721,   68,   68,  721,
      721,  721,   68,  721,   68,   68,   68,  721,   68,  721,

      564,  721,   68,   68,   68,   68,   68,  566,   68,   68,
      565,   68,  721,  721,   68,  721,   68,  721,   68,  721,
       68,  567,   68,  721,  721,  721,   68,   68,   68,   68,
       68,  721,  568,  721,  721,   68,  721,   68,  721,   68,
      721,   68,  721,   68,  721,   68,  721,   68,   68,   68,
      721,   68,  569,   68,  721,   68,   68,   68,  721,   68,
      721,  721,  721,   68,   68,   68,   68,   68,  721,  574,
      721,  721,   68,  721,   68,  721,   68,   68,   68,  721,
       68,  721,  721,  721,   68,   68,   68,   68,   68,   68,
       68,   68,  721,   68,  721,  721,   68,  721,   68,  721,

       68,   68,   68,  721,   68,  577,  721,  721,   68,   68,
       68,   68,   68,   68,   68,   68,  575,   68,  721,  721,
       68,  721,   68,  721,   68,  721,   68,  721,   68,  721,
       68,  721,   68,   68,   68,  721,   68,  580,   68,  721,
       68,   68,   68,  721,   68,  721,   68,  721,   68,   68,
       68,  721,   68,  721,   68,  721,   68,   68,  583,  721,
       68,  721,   68,  721,  585,   68,   68,  721,   68,  721,
       68,  721,   68,   68,   68,  721,   68,  721,   68,  597,
       68,   68,   68,  598,   68,  721,   68,  721,   68,   68,
       68,  721,   68,  721,   68,  721,   68,   68,   68,  721,

       68,  721,  721,  721,   68,   68,   68,   68,   68,  721,
      600,  599,  721,   68,  721,   68,  721,   68,   68,   68,
      602,   68,  721,  721,  721,   68,   68,  601,   68,   68,
       68,   68,   68,  721,   68,  721,  721,   68,  721,   68,
      721,  603,  721,   68,  721,   68,  721,   68,  721,   68,
       68,   68,  721,   68,  608,  607,  721,   68,   68,   68,
       68,   68,  721,   68,  721,  721,   68,  610,  721,  721,
       68,   68,   68,   68,   68,  613,  721,   68,  721,   68,
      721,   68,   68,   68,   68,   68,  721,   68,  721,  615,
       68,  721,  721,  721,   68,   68,   68,   68,   68,   68,

      721,   68,  721,   68,  721,   68,   68,  629,   68,   68,
      628,   68,  721,  630,   68,  721,  721,  721,   68,   68,
       68,   68,   68,   68,  721,   68,  721,   68,  721,   68,
       68,   68,   68,   68,  721,  721,  631,  721,   68,  721,
       68,  721,   68,   68,   68,  721,   68,  632,  721,  721,
       68,   68,   68,   68,   68,   68,   68,   68,  721,   68,
      721,  721,   68,  721,   68,  721,   68,  721,   68,  636,
       68,  721,   68,  721,   68,   68,  638,  721,   68,  641,
       68,  721,   68,   68,   68,  721,   68,  643,   68,  721,
       68,   68,   68,  721,   68,  721,   68,  721,   68,   68,

      653,  721,   68,  721,   68,  721,   68,   68,   68,  721,
       68,  721,   68,  721,   68,   68,   68,  721,   68,  721,
       68,  721,   68,   68,   68,  721,   68,  721,  721,  721,
       68,   68,   68,   68,   68,  721,  721,  721,  654,   68,
      721,   68,  721,   68,   68,  658,  721,   68,  660,  721,
      721,   68,   68,   68,   68,   68,   68,   68,   68,  721,
       68,  665,  663,   68,  721,   68,  721,   68,   68,   68,
      721,   68,  721,  721,  721,   68,   68,   68,   68,   68,
       68,  721,   68,  674,   68,   68,  721,   68,   68,  721,
      721,  675,  721,  721,  721,   68,  721,   68,   68,   68,

       68,   68,   68,  721,   68,  721,  679,   68,  721,   68,
      721,   68,  721,   68,  721,   68,  684,  721,  721,   68,
       68,   68,  721,   68,  682,  693,   68,   68,   68,  721,
      721,  721,  721,  721,  721,  721,   68,   68,   68,   68,
       68,   68,   68,   68,  721,   68,   68,  721,  721,  721,
      721,  721,   68,   68,   68,   68,   68,   68,  721,   68,
       68,   68,   68,  698,  721,  695,  721,  721,  721,   68,
       68,   68,   68,   68,   68,   68,   68,  721,   68,   68,
      721,  705,  721,  721,  721,   68,   68,   68,   68,   68,
       68,   68,  709,  721,   68,   68,  721,   68,  721,  721,

      721,   68,  721,   68,  721,   68,  721,   68,  721,   68,
       68,   68,  721,  721,  721,  721,   68,   45,   45,   45,
       45,   45,   61,  721,   61,  127,  127,  127,  134,  134,
      721,  134,  134,  151,  151,  151,  153,  153,  153,   74,
       74,   74,    5,  721,  721,  721,  721,  721,  721,  721,
      721,  721,  721,  721,  721,  721,  721,  721,  721,  721,
      721,  721,  721,  721,  721,  721,  721,  721,  721,  721,
      721,  721,  721,  721,  721,  721,  721,  721,  721,  721,
      721,  721,  721,  721,  721,  721,  721,  721,  721,  721,
      721,  721,  721,  721,  721,  721,  721,  721,  721,  721,

      721,  721,  721,  721,  721,  721,  721,  721,  721,  721,
      721,  721,  721,  721,  721,  721,  721,  721,  721,  721,
      721,  721,  721,  721,  721,  721,  721
    } ;

static yyconst short int yy_chk[3828] =
    {   0,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    3,    3,    7,    7,    8,    8,
       13,   13,   39,   44,    3,    3,   40,   13,    4,    4,

       43,   41,   49,   13,   13,   49,   42,  109,    4,    4,
       17,   17,   17,   17,   17,   17,   17,   20,   50,   60,
       20,  105,   46,   51,   20,   60,   50,   20,   20,   20,
       20,   20,   46,  718,   51,  717,   20,   44,   52,   52,
       20,   26,    3,   40,    3,  128,   54,   55,   39,   54,
        3,   26,    3,   26,    3,   26,    4,    3,    4,  109,
       26,   90,   55,    3,    4,   41,    4,   43,    4,   42,
      716,    4,   56,   56,  105,  308,   89,    4,   12,   12,
       12,   12,   12,   12,   12,   12,   12,   12,   12,   12,
       12,   12,   12,   12,   12,   12,   12,   12,   12,   12,

       12,   12,   12,   12,  128,   90,  715,   12,   12,   12,
       12,   12,   12,   12,   12,   12,   12,   12,   12,   12,
       12,   12,   12,   12,   12,   12,   12,   12,   12,   12,
       12,   12,   19,   89,   19,   19,   19,   19,   19,   19,
       19,  223,  308,  714,  131,  712,  100,   19,   19,   19,
       19,   19,   19,   19,   19,   19,   19,   19,   19,   19,
       19,   19,   19,   19,   19,   19,   19,   19,   19,   19,
       19,   19,   19,  122,  119,  130,   19,   19,   19,   19,
       19,   19,   19,   19,   19,   19,   19,   19,   19,   19,
       19,   19,   19,   19,   19,   19,   19,   19,   19,   19,

       19,   21,  100,   59,   59,  131,  223,   21,  132,   22,
       59,   21,   22,   21,   21,   21,   59,   59,  124,   22,
       21,   22,   23,   22,  186,  122,  711,  133,   22,  119,
      129,  130,   23,   23,   23,  135,   23,   24,   24,   25,
      185,   23,  233,  208,   23,  135,  226,  199,   24,   25,
       24,   25,   24,   25,   24,   28,   28,   24,   25,  229,
      203,   27,   27,   28,   27,  124,   28,  132,   28,  231,
       28,   25,   27,   27,   27,   28,   27,   29,  129,   27,
      124,   27,  133,  186,   25,  228,  230,   29,  185,   29,
       29,   29,  219,   30,   30,  199,   29,   30,  226,   31,

      208,   31,  225,   30,  232,   30,  233,   30,  203,   31,
      343,   31,   30,   31,   32,   31,  229,   32,   31,  266,
       33,  231,   30,   33,   32,   29,   32,   33,   32,  283,
       33,  230,   33,   32,   33,  710,  306,   34,   33,   33,
      219,  265,  287,   33,   31,   34,   34,  311,  228,   35,
      225,  305,  232,  303,  343,  279,   34,  708,   34,   35,
       34,   35,   34,   35,  297,   34,  309,   35,   35,   34,
      266,   36,   36,   37,  344,  283,  310,  375,   34,  357,
       37,  306,   36,   37,   36,   37,   36,   37,  365,  706,
       35,   36,   37,   64,   64,   64,   64,   64,   64,   64,

       66,  303,  265,   68,  311,  287,  326,  345,   36,  305,
       66,   69,   66,   68,   66,   68,  279,   68,  313,   66,
       67,   69,   68,   69,  310,   69,  344,  297,   69,  309,
       69,  357,  365,  375,  371,   67,   67,   67,   67,   67,
       67,   67,   67,   67,   67,   67,   67,   67,   67,   67,
       67,   67,   67,   67,   67,   67,   67,   67,   67,   67,
       67,   70,   71,  361,  379,  380,  313,  326,  345,  413,
      369,   70,   71,   70,   71,   70,   71,   72,  377,  384,
       70,   71,  371,   73,  383,   71,  440,   72,  704,   72,
      703,   72,  434,   73,   75,   73,   72,   73,  430,   75,

       76,   73,   73,  382,   75,  414,   75,  397,   75,  444,
       76,   77,   76,   75,   76,  415,  430,  443,   76,   76,
      380,   77,   78,   77,  413,   77,  361,  379,   79,  384,
       77,  369,   78,  427,   78,   78,   78,  434,   79,  377,
       79,   78,   79,   80,   80,  383,  446,   79,  448,   81,
       81,  414,  440,  438,   80,  382,   80,   80,   80,  397,
       81,   82,   81,   80,   81,  443,  461,  415,  445,   81,
      444,   82,   82,   82,   83,   82,  701,   84,   83,  427,
       82,  477,  502,  447,   83,  475,   83,   84,   83,   84,
       85,   84,   85,   83,  446,  700,   84,  448,   86,   86,

       85,   87,   85,  476,   85,  438,  495,  497,   86,   85,
       86,   87,   86,   87,   88,   87,   86,   86,  475,   91,
       87,  517,  491,  461,   88,  489,   88,   88,   88,   91,
      445,  447,   92,   88,  502,   92,  476,  475,  477,   91,
       93,   91,   92,   91,   92,  503,   92,  504,   91,  541,
       93,   92,   93,  499,   93,   94,   94,  505,  489,   93,
      550,  495,  506,  527,  497,   94,   95,   94,  529,   94,
      491,  517,   94,   94,   94,  576,   95,  528,   95,   95,
       95,   96,   96,  530,  539,   95,  499,   97,  547,  503,
      505,   96,  536,   96,  543,   96,  551,   97,   98,   97,

       96,   97,  692,   96,  545,  570,   97,  553,   98,   99,
       98,  541,   98,  504,  506,  550,   98,   98,  549,   99,
      552,   99,  101,   99,  605,  102,  527,  576,   99,  551,
      101,  529,  101,  530,  101,  102,  101,  102,  103,  102,
      571,  101,  543,  102,  102,  528,  104,  539,  103,  106,
      103,  547,  103,  536,  545,  553,  104,  103,  104,  106,
      104,  106,  107,  106,  104,  104,  570,  634,  106,  106,
      108,  605,  107,  108,  107,  549,  107,  108,  579,  581,
      108,  107,  108,  552,  108,  110,  110,  572,  571,  108,
      604,  578,  111,  609,  586,  691,  110,  584,  110,  589,

      110,  634,  111,  112,  111,  110,  111,  111,  587,  113,
      111,  111,  581,  112,  590,  112,  690,  112,  689,  113,
      114,  113,  112,  113,  579,  113,  116,  112,  113,  688,
      114,  116,  114,  606,  114,  588,  116,  117,  116,  114,
      116,  587,  604,  118,  586,  116,  612,  117,  572,  117,
      609,  117,  578,  118,  120,  118,  117,  118,  584,  611,
      589,  120,  118,  614,  120,  616,  120,  123,  120,  618,
      121,  121,  620,  120,  121,  590,  619,  123,  125,  123,
      121,  123,  121,  640,  121,  606,  123,  646,  125,  121,
      125,  161,  125,  633,  161,  635,  125,  125,  588,  639,

      685,  161,  162,  161,  637,  161,  642,  612,  163,  161,
      161,  611,  162,  655,  162,  657,  162,  616,  163,  164,
      163,  162,  163,  645,  620,  644,  614,  163,  647,  164,
      165,  164,  618,  164,  656,  640,  664,  619,  164,  646,
      165,  167,  165,  165,  165,  662,  668,  168,  167,  165,
      633,  167,  635,  167,  637,  167,  639,  168,  169,  168,
      167,  168,  667,  655,  170,  657,  168,  642,  169,  661,
      169,  666,  169,  669,  170,  169,  170,  169,  170,  171,
      172,  683,  644,  170,  645,  647,  656,  172,  664,  171,
      172,  171,  172,  171,  172,  171,  173,  174,  171,  172,

      677,  681,  694,  668,  662,  686,  173,  174,  173,  174,
      173,  174,  175,  173,  667,  173,  174,  176,  176,  661,
      687,  666,  175,  669,  175,  176,  175,  697,  176,  175,
      176,  175,  176,  177,  178,  707,  177,  176,  683,  699,
      696,  680,  678,  177,  178,  177,  178,  177,  178,  179,
      694,  676,  177,  178,  673,  180,  677,  672,  180,  179,
      179,  179,  686,  179,  681,  180,  181,  180,  179,  180,
      687,  671,  182,  670,  180,  182,  181,  697,  181,  181,
      181,  659,  182,  183,  182,  181,  182,  652,  651,  699,
      650,  182,  648,  183,  184,  183,  707,  183,  696,  627,

      183,  626,  183,  624,  184,  184,  184,  188,  184,  623,
      189,  622,  621,  184,  617,  596,  595,  188,  190,  188,
      189,  188,  189,  189,  189,  594,  188,  593,  190,  189,
      190,  191,  190,  592,  591,  582,  573,  190,  563,  559,
      558,  191,  557,  191,  192,  191,  193,  192,  556,  191,
      191,  555,  194,  554,  192,  193,  192,  513,  192,  512,
      510,  509,  194,  192,  194,  193,  194,  193,  194,  193,
      195,  194,  508,  196,  193,  197,  197,  507,  501,  486,
      195,  457,  195,  196,  195,  196,  197,  196,  197,  195,
      197,  198,  196,  456,  200,  197,  455,  200,  454,  453,

      452,  198,  451,  198,  200,  198,  200,  450,  200,  201,
      198,  449,  201,  200,  424,  202,  392,  391,  390,  201,
      389,  201,  202,  201,  388,  202,  204,  202,  201,  202,
      387,  386,  205,  385,  202,  381,  204,  376,  204,  353,
      204,  320,  205,  206,  205,  204,  205,  319,  318,  205,
      317,  205,  316,  206,  207,  206,  315,  206,  314,  312,
      206,  302,  206,  293,  207,  209,  207,  274,  207,  267,
      242,  210,  240,  207,  207,  209,  239,  209,  238,  209,
      237,  210,  211,  210,  209,  210,  236,  235,  212,  215,
      210,  212,  211,  187,  211,  166,  211,  156,  212,  213,

      212,  211,  212,  153,  152,  214,  213,  212,  151,  213,
      150,  213,  148,  213,  147,  214,  216,  214,  213,  214,
      146,  145,  217,  214,  214,  217,  216,  143,  216,  141,
      216,  140,  217,  216,  217,  216,  217,  218,  138,  137,
      218,  217,  127,  126,  115,  220,   74,  218,   65,  218,
       63,  218,   62,   61,  222,  220,  218,  220,  220,  220,
      220,  221,  222,   58,  220,  220,   57,   53,   48,   38,
       18,  221,  222,  221,  222,  221,  222,  224,  227,  221,
      221,  222,   15,   14,  227,    5,    0,  224,  227,  224,
      227,  224,  227,  243,  244,    0,  224,  227,    0,    0,

        0,    0,    0,  243,  244,  243,  244,  243,  244,  245,
      244,    0,  243,  244,    0,  246,  245,    0,    0,  245,
        0,  245,    0,  245,    0,  246,  246,  246,  245,  246,
      247,  248,    0,    0,  246,    0,    0,    0,    0,    0,
      247,  248,  247,  248,  247,  248,  250,  250,  249,  247,
      248,  249,    0,    0,    0,    0,    0,  250,  249,  250,
      249,  250,  249,  251,  251,    0,  250,  249,    0,  252,
        0,    0,    0,  251,    0,  251,    0,  251,  248,  252,
      253,  252,  251,  252,    0,    0,  252,    0,  252,    0,
      253,  254,  253,  253,  253,    0,    0,    0,    0,  253,

        0,  254,  255,  254,    0,  254,    0,    0,  256,  254,
      254,    0,  255,    0,  255,    0,  255,    0,  256,    0,
      256,  255,  256,  257,    0,  257,  258,  256,    0,  258,
        0,    0,    0,  257,  259,  257,  258,  257,  258,    0,
      258,    0,  257,    0,  259,  258,  259,  260,  259,    0,
        0,    0,    0,  259,  260,  261,    0,  260,    0,  260,
        0,  260,    0,  262,    0,  261,  260,  261,    0,  261,
        0,  261,    0,  262,  261,  262,    0,  262,  263,  262,
        0,  263,  262,    0,  264,    0,    0,    0,  263,    0,
      263,    0,  263,    0,  264,  268,  264,  263,  264,    0,

        0,    0,    0,  264,    0,  268,    0,  268,  269,  268,
        0,    0,    0,  268,  268,  269,  270,    0,  269,  271,
      269,    0,  269,    0,    0,    0,  270,  269,  270,  271,
      270,  271,  270,  271,  273,  270,  272,  272,  271,  273,
        0,    0,    0,    0,  273,  275,  273,  272,  273,  272,
      273,  272,    0,  273,    0,  275,  272,  275,  275,  275,
      276,    0,    0,    0,  275,    0,  277,    0,    0,    0,
      276,    0,  276,    0,  276,    0,  277,  276,  277,  276,
      277,  278,  280,  280,  277,  277,    0,    0,    0,    0,
        0,  278,  280,  278,  280,  278,  280,  281,  284,    0,

      278,  280,    0,    0,    0,    0,    0,  281,  282,  281,
        0,  281,    0,    0,  284,  281,  281,    0,  282,    0,
      282,  282,  282,    0,  284,    0,  284,  282,  284,  285,
        0,    0,  285,  284,  286,  286,    0,    0,    0,  285,
        0,  285,    0,  285,    0,  286,  288,  286,  285,  286,
        0,    0,  289,    0,  286,  289,  288,    0,  288,    0,
      288,    0,  289,  290,  289,  288,  289,    0,    0,  291,
        0,  289,    0,  290,    0,  290,    0,  290,    0,  291,
        0,  291,  290,  291,  292,  292,  294,    0,  291,    0,
        0,  296,    0,    0,    0,  292,  294,  292,  294,  292,

      294,  295,    0,    0,  292,  294,    0,  296,    0,    0,
        0,  295,    0,  295,    0,  295,    0,  296,  298,  296,
      295,  296,    0,    0,  299,    0,  296,    0,  298,    0,
      298,    0,  298,    0,  299,    0,  299,  298,  299,  300,
      301,    0,  300,  299,    0,    0,    0,    0,    0,  300,
      301,  300,  301,  300,  301,    0,    0,    0,  300,  301,
      304,  307,    0,  304,    0,    0,    0,    0,    0,    0,
      304,  307,  304,  307,  304,  307,  301,  321,    0,  304,
      307,    0,    0,    0,    0,    0,    0,  321,    0,  321,
        0,  321,  322,  322,    0,  321,  321,    0,    0,  323,

      323,    0,    0,  322,    0,  322,    0,  322,    0,  323,
        0,  323,  322,  323,  324,  324,  325,    0,  323,    0,
        0,    0,    0,    0,    0,  324,  325,  324,  325,  324,
      325,  327,  327,    0,  324,  325,    0,    0,  328,  328,
        0,    0,  327,    0,  327,    0,  327,    0,  328,    0,
      328,  327,  328,  329,  330,    0,  329,  328,    0,    0,
        0,    0,    0,  329,  330,  329,  330,  329,  330,  331,
      332,    0,  329,  330,    0,    0,    0,    0,    0,  331,
      332,  331,  332,  331,  332,  333,  332,    0,  331,  332,
        0,  334,    0,    0,  334,  333,    0,  333,  334,  333,

        0,  334,    0,  334,  333,  334,  335,  336,  335,    0,
      334,    0,    0,    0,    0,    0,  335,  336,  335,  336,
      335,  336,  337,  336,    0,  335,  336,    0,    0,    0,
        0,    0,  337,    0,  337,    0,  337,  338,  338,    0,
      337,  337,    0,  339,    0,    0,    0,  338,    0,  338,
        0,  338,    0,  339,  340,  339,  338,  339,    0,    0,
      341,  339,  339,    0,  340,    0,  340,    0,  340,    0,
      341,  340,  341,  340,  341,  342,  346,    0,    0,  341,
        0,    0,    0,  346,    0,  342,  346,  342,  346,  342,
      346,    0,    0,  348,  342,  346,  347,  347,    0,  347,

        0,    0,    0,  348,    0,  348,  347,  348,  347,    0,
      347,  348,  348,  350,  349,  347,  349,    0,    0,    0,
        0,    0,    0,  350,  349,  350,  349,  350,  349,    0,
      352,  351,  350,  349,  351,    0,  355,    0,    0,    0,
      352,  351,  352,  351,  352,  351,  354,  352,    0,  352,
      351,    0,  355,    0,    0,    0,  354,    0,  354,    0,
      354,    0,  355,  356,  355,  354,  355,    0,    0,  358,
      356,  355,    0,  356,    0,  356,    0,  356,    0,  358,
      359,  358,  356,  358,    0,    0,  360,  358,  358,    0,
      359,    0,  359,    0,  359,    0,  360,  362,  360,  359,

      360,    0,    0,  363,  362,  360,    0,  362,    0,  362,
        0,  362,    0,  363,  364,  363,  362,  363,    0,    0,
        0,    0,  363,    0,  364,  366,  364,    0,  364,    0,
        0,  367,  364,  364,    0,  366,  367,  366,    0,  366,
        0,  367,  368,  367,  366,  367,    0,    0,  370,    0,
      367,    0,  368,    0,  368,  370,  368,    0,  370,  372,
      370,  368,  370,    0,  368,  373,    0,  370,  373,  372,
        0,  372,    0,  372,    0,  373,  374,  373,  372,  373,
        0,    0,    0,    0,  373,    0,  374,  378,  374,    0,
      374,    0,  374,  393,    0,  374,    0,  378,    0,  378,

        0,  378,    0,  393,    0,  393,  378,  393,  394,  394,
      395,  395,  393,    0,  396,    0,    0,    0,  394,    0,
      394,  395,  394,  395,  396,  395,  396,  394,  396,  398,
      395,    0,  396,  396,    0,  399,    0,    0,    0,  398,
        0,  398,    0,  398,    0,  399,  400,  399,  398,  399,
        0,    0,  401,  399,  399,  401,  400,    0,  400,    0,
      400,    0,  401,    0,  401,  400,  401,  402,  402,    0,
        0,  401,    0,    0,  403,    0,    0,    0,  402,    0,
      402,    0,  402,    0,  403,    0,  403,  402,  403,  404,
        0,  404,  403,  403,    0,  405,    0,    0,    0,  404,

        0,  404,    0,  404,    0,  405,    0,  405,  404,  405,
      407,  407,  406,  405,  405,  406,    0,    0,    0,    0,
        0,  407,  406,  407,  406,  407,  406,  408,  409,    0,
      407,  406,    0,    0,    0,  409,    0,  408,  409,  408,
      409,  408,  409,  410,  411,    0,  408,  409,    0,    0,
        0,  411,    0,  410,  411,  410,  411,  410,  411,    0,
      410,    0,  410,  411,  412,  412,  416,    0,    0,    0,
      416,    0,    0,    0,    0,  412,  416,  412,  416,  412,
      416,  417,    0,    0,  412,  416,    0,  418,  417,  418,
        0,  417,    0,  417,    0,  417,    0,  418,  419,  418,

      417,  418,    0,    0,  420,    0,  418,  420,  419,    0,
      419,    0,  419,    0,  420,  419,  420,  419,  420,  421,
      421,    0,    0,  420,    0,  422,    0,    0,    0,  421,
        0,  421,    0,  421,    0,  422,    0,  422,  421,  422,
      423,  422,    0,  423,  422,    0,  425,    0,    0,    0,
      423,    0,  423,  425,  423,    0,  425,  426,  425,  423,
      425,    0,    0,  428,    0,  425,    0,  426,    0,  426,
      426,  426,    0,  428,    0,  428,  426,  428,  429,  429,
      431,    0,  428,    0,    0,    0,    0,    0,    0,  429,
      431,  429,  431,  429,  431,  432,    0,    0,  429,  431,

        0,    0,    0,    0,    0,  432,    0,  432,  433,  432,
        0,  433,    0,  432,  432,    0,  435,  435,  433,  436,
      433,    0,  433,    0,    0,    0,  435,  433,  435,  436,
      435,  436,  437,  436,    0,  435,    0,    0,  436,    0,
      441,    0,  437,  439,  437,  439,  437,    0,    0,    0,
      441,  437,  441,  439,  441,  439,  442,  439,    0,  441,
        0,    0,  439,    0,  458,    0,  442,  459,  442,    0,
      442,    0,    0,  442,  458,  442,  458,  459,  458,  459,
      460,  459,  458,  458,    0,  459,  459,  460,  462,    0,
      460,    0,  460,    0,  460,    0,    0,    0,  462,  460,

      462,  463,  462,    0,  463,    0,    0,  462,    0,  464,
        0,  463,    0,  463,    0,  463,    0,  465,    0,  464,
      463,  464,    0,  464,  465,  466,    0,  465,  464,  465,
        0,  465,    0,  467,    0,  466,  465,  466,    0,  466,
        0,  468,    0,  467,  466,  467,    0,  467,  468,    0,
        0,  468,  467,  468,  469,  468,  469,  470,    0,    0,
      468,    0,    0,    0,  469,    0,  469,  470,  469,  470,
      471,  470,    0,  469,    0,  470,  470,    0,    0,    0,
      471,  472,  471,    0,  471,    0,    0,  473,  471,  471,
        0,  472,    0,  472,    0,  472,    0,  473,  474,  473,

      472,  473,    0,    0,  478,    0,  473,    0,  474,    0,
      474,  478,  474,    0,  478,  479,  478,  474,  478,    0,
        0,    0,    0,  478,    0,  479,  480,  479,    0,  479,
        0,    0,  481,  479,  479,    0,  480,    0,  480,    0,
      480,    0,  481,  482,  481,  480,  481,    0,    0,  483,
        0,  481,  483,  482,    0,  482,    0,  482,    0,  483,
      482,  483,  482,  483,  484,  485,  485,    0,  483,    0,
        0,    0,    0,    0,  484,  485,  484,  485,  484,  485,
      487,  488,    0,  484,  485,    0,    0,    0,    0,    0,
      487,  488,  487,  488,  487,  488,  490,  492,    0,  487,

      488,  492,    0,    0,    0,    0,  490,  492,  490,  492,
      490,  492,  493,  494,    0,  490,  492,    0,    0,    0,
        0,    0,  493,  494,  493,  494,  493,  494,    0,    0,
      496,  493,  494,  496,    0,    0,  498,  514,    0,  498,
      496,    0,  496,    0,  496,    0,  498,    0,  498,  496,
      498,  500,  500,  514,    0,  498,    0,    0,    0,    0,
        0,    0,  500,  514,  500,  514,  500,  514,  515,  516,
      516,  500,  514,    0,    0,  515,    0,    0,  515,  516,
      515,  516,  515,  516,  518,    0,    0,  515,  516,    0,
        0,    0,  519,    0,  518,  520,  518,    0,  518,    0,

      518,    0,  519,  518,  519,  520,  519,  520,  521,  520,
      519,  519,    0,    0,  520,    0,  522,    0,  521,    0,
      521,  521,  521,    0,    0,    0,  522,  521,  522,  523,
      522,    0,  523,    0,    0,  522,    0,  524,    0,  523,
        0,  523,    0,  523,    0,  525,    0,  524,  523,  524,
        0,  524,  525,  526,    0,  525,  524,  525,    0,  525,
        0,    0,    0,  526,  525,  526,  531,  526,    0,  531,
        0,    0,  526,    0,  532,    0,  531,  533,  531,    0,
      531,    0,    0,    0,  532,  531,  532,  533,  532,  533,
      534,  533,    0,  532,    0,    0,  533,    0,  535,    0,

      534,  537,  534,    0,  534,  537,    0,    0,  535,  534,
      535,  537,  535,  537,  538,  537,  535,  535,    0,    0,
      537,    0,  540,    0,  538,    0,  538,    0,  538,    0,
      542,    0,  540,  538,  540,    0,  540,  542,  544,    0,
      542,  540,  542,    0,  542,    0,  546,    0,  544,  542,
      544,    0,  544,    0,  548,    0,  546,  544,  546,    0,
      546,    0,  560,    0,  548,  546,  548,    0,  548,    0,
      561,    0,  560,  548,  560,    0,  560,    0,  562,  560,
      561,  560,  561,  561,  561,    0,  564,    0,  562,  561,
      562,    0,  562,    0,  565,    0,  564,  562,  564,    0,

      564,    0,    0,    0,  565,  564,  565,  566,  565,    0,
      566,  565,    0,  565,    0,  567,    0,  566,  568,  566,
      568,  566,    0,    0,    0,  567,  566,  567,  568,  567,
      568,  569,  568,    0,  567,    0,    0,  568,    0,  574,
        0,  569,    0,  569,    0,  569,    0,  575,    0,  574,
      569,  574,    0,  574,  575,  574,    0,  575,  574,  575,
      577,  575,    0,  580,    0,    0,  575,  577,    0,    0,
      577,  583,  577,  580,  577,  580,    0,  580,    0,  577,
        0,  583,  580,  583,  585,  583,    0,  597,    0,  583,
      583,    0,    0,    0,  585,  598,  585,  597,  585,  597,

        0,  597,    0,  585,    0,  598,  597,  598,  599,  598,
      597,  600,    0,  600,  598,    0,    0,    0,  599,  601,
      599,  600,  599,  600,    0,  600,    0,  599,    0,  601,
      600,  601,  602,  601,    0,    0,  601,    0,  601,    0,
      603,    0,  602,  607,  602,    0,  602,  603,    0,    0,
      603,  602,  603,  607,  603,  607,  608,  607,    0,  603,
        0,    0,  607,    0,  610,    0,  608,    0,  608,  608,
      608,    0,  613,    0,  610,  608,  610,    0,  610,  613,
      615,    0,  613,  610,  613,    0,  613,  615,  628,    0,
      615,  613,  615,    0,  615,    0,  629,    0,  628,  615,

      628,    0,  628,    0,  630,    0,  629,  628,  629,    0,
      629,    0,  631,    0,  630,  629,  630,    0,  630,    0,
      632,    0,  631,  630,  631,    0,  631,    0,    0,    0,
      632,  631,  632,  636,  632,    0,    0,    0,  632,  632,
        0,  638,    0,  636,  641,  636,    0,  636,  638,    0,
        0,  638,  636,  638,  641,  638,  641,  643,  641,    0,
      638,  643,  641,  641,    0,  653,    0,  643,  654,  643,
        0,  643,    0,    0,    0,  653,  643,  653,  654,  653,
      654,    0,  654,  653,  653,  658,    0,  654,  660,    0,
        0,  654,    0,    0,    0,  658,    0,  658,  660,  658,

      660,  663,  660,    0,  658,    0,  660,  660,    0,  665,
        0,  663,    0,  663,    0,  663,  665,    0,    0,  665,
      663,  665,    0,  665,  663,  674,  674,  675,  665,    0,
        0,    0,    0,    0,    0,    0,  674,  675,  674,  675,
      674,  675,  679,  682,    0,  674,  675,    0,    0,    0,
        0,    0,  679,  682,  679,  682,  679,  682,    0,  693,
      684,  679,  682,  684,    0,  679,    0,    0,    0,  693,
      684,  693,  684,  693,  684,  695,  698,    0,  693,  684,
        0,  693,    0,    0,    0,  695,  698,  695,  698,  695,
      698,  705,  698,    0,  695,  698,    0,  709,    0,    0,

        0,  705,    0,  705,    0,  705,    0,  709,    0,  709,
      705,  709,    0,    0,    0,    0,  709,  722,  722,  722,
      722,  722,  723,    0,  723,  724,  724,  724,  725,  725,
        0,  725,  725,  726,  726,  726,  727,  727,  727,  728,
      728,  728,  721,  721,  721,  721,  721,  721,  721,  721,
      721,  721,  721,  721,  721,  721,  721,  721,  721,  721,
      721,  721,  721,  721,  721,  721,  721,  721,  721,  721,
      721,  721,  721,  721,  721,  721,  721,  721,  721,  721,
      721,  721,  721,  721,  721,  721,  721,  721,  721,  721,
      721,  721,  721,  721,  721,  721,  721,  721,  721,  721,

      721,  721,  721,  721,  721,  721,  721,  721,  721,  721,
      721,  721,  721,  721,  721,  721,  721,  721,  721,  721,
      721,  721,  721,  721,  721,  721,  721
    } ;

static yy_state_type yy_last_accepting_state;
static char *yy_last_accepting_cpos;

/* The intent behind this definition is that it'll catch
 * any uses of REJECT which flex missed.
 */
#define REJECT reject_used_but_not_detected
#define yymore() yymore_used_but_not_detected
#define YY_MORE_ADJ 0
char *yytext;
#define INITIAL 0
/* Copyright (C) Boris Nikolaus, Germany, 1996-1997. All rights reserved. */
#include <stdarg.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>
#include "defs.h"
#include "parser.h"
#include "error.h"

#define T_NOTOKEN       9999

static LLPOS current_pos;
static LLPOS last_pos;

#undef YY_INPUT
#define YY_INPUT(buf,result,max_size) {\
if (!filelen) { result = YY_NULL;\
} else { while (currentfilepos >= allfilestarts[currentfile+1]) currentfile++;\
buf[0] = *currentfilepos++; filelen--;\
last_pos = current_pos;\
if (buf[0] == '\n') { current_pos.line++; current_pos.column = 1; }\
else { current_pos.column++; }\
current_pos.file = allfilenames[currentfile];\
result = 1;\
}}

LLSTYPE yylval;
char *file = NULL;
int filelen = 0;
char *currentfilepos = NULL;
char **allfilenames;
char **allfilestarts;
int currentfile;
#define DIRECTIVE 1


/* Macros after this point can all be overridden by user definitions in
 * section 1.
 */

#ifndef YY_SKIP_YYWRAP
#ifdef __cplusplus
extern "C" int yywrap YY_PROTO(( void ));
#else
extern int yywrap YY_PROTO(( void ));
#endif
#endif

#ifndef YY_NO_UNPUT
static void yyunput YY_PROTO(( int c, char *buf_ptr ));
#endif

#ifndef yytext_ptr
static void yy_flex_strncpy YY_PROTO(( char *, yyconst char *, int ));
#endif

#ifndef YY_NO_INPUT
#ifdef __cplusplus
static int yyinput YY_PROTO(( void ));
#else
static int input YY_PROTO(( void ));
#endif
#endif

#if YY_STACK_USED
static int yy_start_stack_ptr = 0;
static int yy_start_stack_depth = 0;
static int *yy_start_stack = 0;
#ifndef YY_NO_PUSH_STATE
static void yy_push_state YY_PROTO(( int new_state ));
#endif
#ifndef YY_NO_POP_STATE
static void yy_pop_state YY_PROTO(( void ));
#endif
#ifndef YY_NO_TOP_STATE
static int yy_top_state YY_PROTO(( void ));
#endif

#else
#define YY_NO_PUSH_STATE 1
#define YY_NO_POP_STATE 1
#define YY_NO_TOP_STATE 1
#endif

#ifdef YY_MALLOC_DECL
YY_MALLOC_DECL
#else
#if __STDC__
#ifndef __cplusplus
#include <stdlib.h>
#endif
#else
/* Just try to get by without declaring the routines.  This will fail
 * miserably on non-ANSI systems for which sizeof(size_t) != sizeof(int)
 * or sizeof(void*) != sizeof(int).
 */
#endif
#endif

/* Amount of stuff to slurp up with each read. */
#ifndef YY_READ_BUF_SIZE
#define YY_READ_BUF_SIZE 8192
#endif

/* Copy whatever the last rule matched to the standard output. */

#ifndef ECHO
/* This used to be an fputs(), but since the string might contain NUL's,
 * we now use fwrite().
 */
#define ECHO (void) fwrite( yytext, yyleng, 1, yyout )
#endif

/* Gets input and stuffs it into "buf".  number of characters read, or YY_NULL,
 * is returned in "result".
 */
#ifndef YY_INPUT
#define YY_INPUT(buf,result,max_size) \
    if ( yy_current_buffer->yy_is_interactive ) \
        { \
        int c = '*', n; \
        for ( n = 0; n < max_size && \
                 (c = getc( yyin )) != EOF && c != '\n'; ++n ) \
            buf[n] = (char) c; \
        if ( c == '\n' ) \
            buf[n++] = (char) c; \
        if ( c == EOF && ferror( yyin ) ) \
            YY_FATAL_ERROR( "input in flex scanner failed" ); \
        result = n; \
        } \
    else if ( ((result = fread( buf, 1, max_size, yyin )) == 0) \
          && ferror( yyin ) ) \
        YY_FATAL_ERROR( "input in flex scanner failed" );
#endif

/* No semi-colon after return; correct usage is to write "yyterminate();" -
 * we don't want an extra ';' after the "return" because that will cause
 * some compilers to complain about unreachable statements.
 */
#ifndef yyterminate
#define yyterminate() return YY_NULL
#endif

/* Number of entries by which start-condition stack grows. */
#ifndef YY_START_STACK_INCR
#define YY_START_STACK_INCR 25
#endif

/* Report a fatal error. */
#ifndef YY_FATAL_ERROR
#define YY_FATAL_ERROR(msg) yy_fatal_error( msg )
#endif

/* Default declaration of generated scanner - a define so the user can
 * easily add parameters.
 */
#ifndef YY_DECL
#define YY_DECL int yylex YY_PROTO(( void ))
#endif

/* Code executed at the beginning of each rule, after yytext and yyleng
 * have been set up.
 */
#ifndef YY_USER_ACTION
#define YY_USER_ACTION
#endif

/* Code executed at the end of each rule. */
#ifndef YY_BREAK
#define YY_BREAK break;
#endif

#define YY_RULE_SETUP \
    YY_USER_ACTION

YY_DECL
    {
    register yy_state_type yy_current_state;
    register char *yy_cp, *yy_bp;
    register int yy_act;


    if ( yy_init )
        {
        yy_init = 0;

#ifdef YY_USER_INIT
        YY_USER_INIT;
#endif

        if ( ! yy_start )
            yy_start = 1;   /* first start state */

        if ( ! yyin )
            yyin = stdin;

        if ( ! yyout )
            yyout = stdout;

        if ( ! yy_current_buffer )
            yy_current_buffer =
                yy_create_buffer( yyin, YY_BUF_SIZE );

        yy_load_buffer_state();
        }

    while ( 1 )     /* loops until end-of-file is reached */
        {
        yy_cp = yy_c_buf_p;

        /* Support of yytext. */
        *yy_cp = yy_hold_char;

        /* yy_bp points to the position in yy_ch_buf of the start of
         * the current run.
         */
        yy_bp = yy_cp;

        yy_current_state = yy_start;
yy_match:
        do
            {
            register YY_CHAR yy_c = (YY_CHAR)yy_ec[YY_SC_TO_UI(*yy_cp)];
            if ( yy_accept[yy_current_state] )
                {
                yy_last_accepting_state = yy_current_state;
                yy_last_accepting_cpos = yy_cp;
                }
            while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
                {
                yy_current_state = (int) yy_def[yy_current_state];
                if ( yy_current_state >= 722 )
                    yy_c = (YY_CHAR)yy_meta[(unsigned int) yy_c];
                }
            yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];
            ++yy_cp;
            }
        while ( yy_base[yy_current_state] != 3743 );

yy_find_action:
        yy_act = yy_accept[yy_current_state];
        if ( yy_act == 0 )
            { /* have to back up */
            yy_cp = yy_last_accepting_cpos;
            yy_current_state = yy_last_accepting_state;
            yy_act = yy_accept[yy_current_state];
            }

        YY_DO_BEFORE_ACTION;


do_action:  /* This label is used only to access EOF actions. */


        switch ( yy_act )
    { /* beginning of action switch */
            case 0: /* must back up */
            /* undo the effects of YY_DO_BEFORE_ACTION */
            *yy_cp = yy_hold_char;
            yy_cp = yy_last_accepting_cpos;
            yy_current_state = yy_last_accepting_state;
            goto yy_find_action;

case 1:
YY_RULE_SETUP
return T_ABSENT;
    YY_BREAK
case 2:
YY_RULE_SETUP
return T_ABSTRACT_SYNTAX;
    YY_BREAK
case 3:
YY_RULE_SETUP
return T_ALL;
    YY_BREAK
case 4:
YY_RULE_SETUP
return T_ANY;
    YY_BREAK
case 5:
YY_RULE_SETUP
return T_APPLICATION;
    YY_BREAK
case 6:
YY_RULE_SETUP
return T_AUTOMATIC;
    YY_BREAK
case 7:
YY_RULE_SETUP
return T_BEGIN;
    YY_BREAK
case 8:
YY_RULE_SETUP
return T_BIT;
    YY_BREAK
case 9:
YY_RULE_SETUP
return T_BMPString;
    YY_BREAK
case 10:
YY_RULE_SETUP
return T_BOOLEAN;
    YY_BREAK
case 11:
YY_RULE_SETUP
return T_BY;
    YY_BREAK
case 12:
YY_RULE_SETUP
return T_CHARACTER;
    YY_BREAK
case 13:
YY_RULE_SETUP
return T_CHOICE;
    YY_BREAK
case 14:
YY_RULE_SETUP
return T_CLASS;
    YY_BREAK
case 15:
YY_RULE_SETUP
return T_COMPONENT;
    YY_BREAK
case 16:
YY_RULE_SETUP
return T_COMPONENTS;
    YY_BREAK
case 17:
YY_RULE_SETUP
return T_CONSTRAINED;
    YY_BREAK
case 18:
YY_RULE_SETUP
return T_DEFAULT;
    YY_BREAK
case 19:
YY_RULE_SETUP
return T_DEFINED;
    YY_BREAK
case 20:
YY_RULE_SETUP
return T_DEFINITIONS;
    YY_BREAK
case 21:
YY_RULE_SETUP
return T_EMBEDDED;
    YY_BREAK
case 22:
YY_RULE_SETUP
return T_empty;
    YY_BREAK
case 23:
YY_RULE_SETUP
return T_END;
    YY_BREAK
case 24:
YY_RULE_SETUP
return T_ENUMERATED;
    YY_BREAK
case 25:
YY_RULE_SETUP
return T_EXCEPT;
    YY_BREAK
case 26:
YY_RULE_SETUP
return T_EXPLICIT;
    YY_BREAK
case 27:
YY_RULE_SETUP
return T_EXPORTS;
    YY_BREAK
case 28:
YY_RULE_SETUP
return T_EXTENSIBILITY;
    YY_BREAK
case 29:
YY_RULE_SETUP
return T_EXTERNAL;
    YY_BREAK
case 30:
YY_RULE_SETUP
return T_FALSE;
    YY_BREAK
case 31:
YY_RULE_SETUP
return T_FROM;
    YY_BREAK
case 32:
YY_RULE_SETUP
return T_GeneralizedTime;
    YY_BREAK
case 33:
YY_RULE_SETUP
return T_GeneralString;
    YY_BREAK
case 34:
YY_RULE_SETUP
return T_GraphicString;
    YY_BREAK
case 35:
YY_RULE_SETUP
return T_IA5String;
    YY_BREAK
case 36:
YY_RULE_SETUP
return T_TYPE_IDENTIFIER;
    YY_BREAK
case 37:
YY_RULE_SETUP
return T_IDENTIFIER;
    YY_BREAK
case 38:
YY_RULE_SETUP
return T_identifier;
    YY_BREAK
case 39:
YY_RULE_SETUP
return T_IMPLICIT;
    YY_BREAK
case 40:
YY_RULE_SETUP
return T_IMPLIED;
    YY_BREAK
case 41:
YY_RULE_SETUP
return T_IMPORTS;
    YY_BREAK
case 42:
YY_RULE_SETUP
return T_INCLUDES;
    YY_BREAK
case 43:
YY_RULE_SETUP
return T_INSTANCE;
    YY_BREAK
case 44:
YY_RULE_SETUP
return T_INTEGER;
    YY_BREAK
case 45:
YY_RULE_SETUP
return T_INTERSECTION;
    YY_BREAK
case 46:
YY_RULE_SETUP
return T_ISO646String;
    YY_BREAK
case 47:
YY_RULE_SETUP
return T_MACRO;
    YY_BREAK
case 48:
YY_RULE_SETUP
return T_MAX;
    YY_BREAK
case 49:
YY_RULE_SETUP
return T_MIN;
    YY_BREAK
case 50:
YY_RULE_SETUP
return T_MINUS_INFINITY;
    YY_BREAK
case 51:
YY_RULE_SETUP
return T_NOTATION;
    YY_BREAK
case 52:
YY_RULE_SETUP
return T_NULL;
    YY_BREAK
case 53:
YY_RULE_SETUP
return T_Number;
    YY_BREAK
case 54:
YY_RULE_SETUP
return T_NumericString;
    YY_BREAK
case 55:
YY_RULE_SETUP
return T_OBJECT;
    YY_BREAK
case 56:
YY_RULE_SETUP
return T_ObjectDescriptor;
    YY_BREAK
case 57:
YY_RULE_SETUP
return T_OCTET;
    YY_BREAK
case 58:
YY_RULE_SETUP
return T_OF;
    YY_BREAK
case 59:
YY_RULE_SETUP
return T_OPTIONAL;
    YY_BREAK
case 60:
YY_RULE_SETUP
return T_PDV;
    YY_BREAK
case 61:
YY_RULE_SETUP
return T_PLUS_INFINITY;
    YY_BREAK
case 62:
YY_RULE_SETUP
return T_PRESENT;
    YY_BREAK
case 63:
YY_RULE_SETUP
return T_PrintableString;
    YY_BREAK
case 64:
YY_RULE_SETUP
return T_PRIVATE;
    YY_BREAK
case 65:
YY_RULE_SETUP
return T_REAL;
    YY_BREAK
case 66:
YY_RULE_SETUP
return T_SEQUENCE;
    YY_BREAK
case 67:
YY_RULE_SETUP
return T_SET;
    YY_BREAK
case 68:
YY_RULE_SETUP
return T_SIZE;
    YY_BREAK
case 69:
YY_RULE_SETUP
return T_STRING;
    YY_BREAK
case 70:
YY_RULE_SETUP
return T_string;
    YY_BREAK
case 71:
YY_RULE_SETUP
return T_SYNTAX;
    YY_BREAK
case 72:
YY_RULE_SETUP
return T_T61String;
    YY_BREAK
case 73:
YY_RULE_SETUP
return T_TAGS;
    YY_BREAK
case 74:
YY_RULE_SETUP
return T_TeletexString;
    YY_BREAK
case 75:
YY_RULE_SETUP
return T_TRUE;
    YY_BREAK
case 76:
YY_RULE_SETUP
return T_TYPE;
    YY_BREAK
case 77:
YY_RULE_SETUP
return T_type;
    YY_BREAK
case 78:
YY_RULE_SETUP
return T_UNION;
    YY_BREAK
case 79:
YY_RULE_SETUP
return T_UNIQUE;
    YY_BREAK
case 80:
YY_RULE_SETUP
return T_UNIVERSAL;
    YY_BREAK
case 81:
YY_RULE_SETUP
return T_UniversalString;
    YY_BREAK
case 82:
YY_RULE_SETUP
return T_UTCTime;
    YY_BREAK
case 83:
YY_RULE_SETUP
return T_UTF8String;
    YY_BREAK
case 84:
YY_RULE_SETUP
return T_VALUE;
    YY_BREAK
case 85:
YY_RULE_SETUP
return T_value;
    YY_BREAK
case 86:
YY_RULE_SETUP
return T_VideotexString;
    YY_BREAK
case 87:
YY_RULE_SETUP
return T_VisibleString;
    YY_BREAK
case 88:
YY_RULE_SETUP
return T_WITH;
    YY_BREAK
case 89:
YY_RULE_SETUP
return *yytext;
    YY_BREAK
case 90:
YY_RULE_SETUP
return T_DEF;
    YY_BREAK
case 91:
YY_RULE_SETUP
return T_TDOT;
    YY_BREAK
case 92:
YY_RULE_SETUP
return T_DDOT;
    YY_BREAK
case 93:
YY_RULE_SETUP
{   int i;
                    intx_t h;
                    intx_setuint32(&yylval._XNumber, 0);
                    for (i = 0; i < yyleng; i++) {
                        intx_muloctet(&h, &yylval._XNumber,
                        10);
                        intx_addoctet(&yylval._XNumber, &h,
                        (octet_t)(yytext[i] - '0'));
                    }
                    return T_number;
                }
    YY_BREAK
case 94:
YY_RULE_SETUP
{   char *p, *q;
                    q = yylval._XString =
                        (char *)malloc(yyleng - 2);
                    for (p = yytext + 1; *p != '\''; p++)
                        if (*p == '0' || *p == '1')
                            *q++ = *p;
                    *q = 0;
                    return T_bstring;
                }
    YY_BREAK
case 95:
YY_RULE_SETUP
{   char *p, *q;
                    q = yylval._XString =
                        (char *)malloc(yyleng - 2);
                    for (p = yytext + 1; *p != '\''; p++)
                        if (isxdigit(*p))
                            *q++ = *p;
                    *q = 0;
                    return T_hstring;
                }
    YY_BREAK
case 96:
YY_RULE_SETUP
{   int s, l = 0, c;
                    LLPOS start_pos;
                    yylval._XString32 =
                        (char32_t *)malloc(
                        (s = 32) * sizeof(char32_t));
                    start_pos = last_pos;
                    for (;;) {
                        c = input();
                        if (!c || c == EOF) {
                        error(E_unterminated_string,
                            &start_pos);
                        /*NOTREACHED*/
                        }
                        if (c == '\n') {
                        while (l > 0 && is32space(
                            yylval._XString32[l - 1]))
                            l--;
                        while (c = input()) {
                            if (!isspace(c))
                            break;
                        }
                        }
                        if (c == '\"') {
                        c = input();
                        if (c != '\"') {
                            unput(c);
                            yylval._XString32[l] = 0;
                            return T_cstring;
                        }
                        }
                        if (l + 1 >= s) {
                        yylval._XString32 = (char32_t *)
                            realloc(yylval._XString32,
                            (s *= 2) *
                            sizeof(char32_t));
                        }
                        yylval._XString32[l++] = c;
                    }
                }
    YY_BREAK
case 97:
YY_RULE_SETUP
{
                    yylval._XString =
                        (char *)malloc(yyleng + 1);
                    strcpy(yylval._XString, yytext);
                    return T_only_uppercase_symbol;
                }
    YY_BREAK
case 98:
YY_RULE_SETUP
{
                    yylval._XString =
                        (char *)malloc(yyleng + 1);
                    strcpy(yylval._XString, yytext);
                    return T_only_uppercase_digits_symbol;
                }
    YY_BREAK
case 99:
YY_RULE_SETUP
{
                    yylval._XString =
                        (char *)malloc(yyleng + 1);
                    strcpy(yylval._XString, yytext);
                    return T_uppercase_symbol;
                }
    YY_BREAK
case 100:
YY_RULE_SETUP
{
                    yylval._XString =
                        (char *)malloc(yyleng + 1);
                    strcpy(yylval._XString, yytext);
                    return T_lcsymbol;
                }
    YY_BREAK
case 101:
YY_RULE_SETUP
{
                    yylval._XString =
                        (char *)malloc(yyleng + 1);
                    strcpy(yylval._XString, yytext);
                    return T_amplcsymbol;
                }
    YY_BREAK
case 102:
YY_RULE_SETUP
{
                    yylval._XString =
                        (char *)malloc(yyleng + 1);
                    strcpy(yylval._XString, yytext);
                    return T_ampucsymbol;
                }
    YY_BREAK
case 103:
YY_RULE_SETUP
{   BEGIN DIRECTIVE;
                }
    YY_BREAK
case 104:
YY_RULE_SETUP
{   BEGIN INITIAL;
                }
    YY_BREAK
case 105:
YY_RULE_SETUP
{   BEGIN INITIAL;
                }
    YY_BREAK
case 106:
case 107:
YY_RULE_SETUP
{   return T_FIXED_ARRAY;
                }
    YY_BREAK
case 108:
case 109:
YY_RULE_SETUP
{   return T_SINGLY_LINKED_LIST;
                }
    YY_BREAK
case 110:
case 111:
YY_RULE_SETUP
{   return T_DOUBLY_LINKED_LIST;
                }
    YY_BREAK
case 112:
case 113:
YY_RULE_SETUP
{   return T_LENGTH_POINTER;
                }
    YY_BREAK
case 114:
case 115:
YY_RULE_SETUP
{   return T_ZERO_TERMINATED;
                }
    YY_BREAK
case 116:
case 117:
YY_RULE_SETUP
{   return T_POINTER;
                }
    YY_BREAK
case 118:
case 119:
YY_RULE_SETUP
{   return T_NO_POINTER;
                }
    YY_BREAK
case 120:
YY_RULE_SETUP
{   /* ignore */
                }
    YY_BREAK
case 121:
YY_RULE_SETUP
{   fprintf(stderr,
                        "Bad directive %s (ignored)\n",
                        yytext);
                }
    YY_BREAK
case 122:
YY_RULE_SETUP
{   int c;
                    for (;;) {
                        c = input();
                        if (c == 0 || c == EOF)
                            break;
                        if (c == '\n')
                            break;
#ifdef MS_DIRECTIVE
                        if (c == g_chDirectiveBegin)
                        {
                            c = input();
                            GetPrivateDirective(&c);
                        }
#endif // MS_DIRECTIVE
                        if (c != '-')
                            continue;
                        c = input();
                        if (c == 0 || c == EOF)
                            break;
                        if (c == '\n')
                            break;
                        if (c != '-')
                            continue;
                        break;
                    }
                    return T_NOTOKEN;
                }
    YY_BREAK
case 123:
YY_RULE_SETUP
return T_NOTOKEN;
    YY_BREAK
case 124:
YY_RULE_SETUP
return EOF;
    YY_BREAK
case 125:
YY_RULE_SETUP
{   error(E_bad_character, &last_pos);
                }
    YY_BREAK
case 126:
YY_RULE_SETUP
ECHO;
    YY_BREAK
case YY_STATE_EOF(INITIAL):
case YY_STATE_EOF(DIRECTIVE):
    yyterminate();

    case YY_END_OF_BUFFER:
        {
        /* Amount of text matched not including the EOB char. */
        int yy_amount_of_matched_text = (int) (yy_cp - yytext_ptr) - 1;

        /* Undo the effects of YY_DO_BEFORE_ACTION. */
        *yy_cp = yy_hold_char;

        if ( yy_current_buffer->yy_buffer_status == YY_BUFFER_NEW )
            {
            /* We're scanning a new file or input source.  It's
             * possible that this happened because the user
             * just pointed yyin at a new source and called
             * yylex().  If so, then we have to assure
             * consistency between yy_current_buffer and our
             * globals.  Here is the right place to do so, because
             * this is the first action (other than possibly a
             * back-up) that will match for the new input source.
             */
            yy_n_chars = yy_current_buffer->yy_n_chars;
            yy_current_buffer->yy_input_file = yyin;
            yy_current_buffer->yy_buffer_status = YY_BUFFER_NORMAL;
            }

        /* Note that here we test for yy_c_buf_p "<=" to the position
         * of the first EOB in the buffer, since yy_c_buf_p will
         * already have been incremented past the NUL character
         * (since all states make transitions on EOB to the
         * end-of-buffer state).  Contrast this with the test
         * in input().
         */
        if ( yy_c_buf_p <= &yy_current_buffer->yy_ch_buf[yy_n_chars] )
            { /* This was really a NUL. */
            yy_state_type yy_next_state;

            yy_c_buf_p = yytext_ptr + yy_amount_of_matched_text;

            yy_current_state = yy_get_previous_state();

            /* Okay, we're now positioned to make the NUL
             * transition.  We couldn't have
             * yy_get_previous_state() go ahead and do it
             * for us because it doesn't know how to deal
             * with the possibility of jamming (and we don't
             * want to build jamming into it because then it
             * will run more slowly).
             */

            yy_next_state = yy_try_NUL_trans( yy_current_state );

            yy_bp = yytext_ptr + YY_MORE_ADJ;

            if ( yy_next_state )
                {
                /* Consume the NUL. */
                yy_cp = ++yy_c_buf_p;
                yy_current_state = yy_next_state;
                goto yy_match;
                }

            else
                {
                yy_cp = yy_c_buf_p;
                goto yy_find_action;
                }
            }

        else switch ( yy_get_next_buffer() )
            {
            case EOB_ACT_END_OF_FILE:
                {
                yy_did_buffer_switch_on_eof = 0;

                if ( yywrap() )
                    {
                    /* Note: because we've taken care in
                     * yy_get_next_buffer() to have set up
                     * yytext, we can now set up
                     * yy_c_buf_p so that if some total
                     * hoser (like flex itself) wants to
                     * call the scanner after we return the
                     * YY_NULL, it'll still work - another
                     * YY_NULL will get returned.
                     */
                    yy_c_buf_p = yytext_ptr + YY_MORE_ADJ;

                    yy_act = YY_STATE_EOF(YY_START);
                    goto do_action;
                    }

                else
                    {
                    if ( ! yy_did_buffer_switch_on_eof )
                        YY_NEW_FILE;
                    }
                break;
                }

            case EOB_ACT_CONTINUE_SCAN:
                yy_c_buf_p =
                    yytext_ptr + yy_amount_of_matched_text;

                yy_current_state = yy_get_previous_state();

                yy_cp = yy_c_buf_p;
                yy_bp = yytext_ptr + YY_MORE_ADJ;
                goto yy_match;

            case EOB_ACT_LAST_MATCH:
                yy_c_buf_p =
                &yy_current_buffer->yy_ch_buf[yy_n_chars];

                yy_current_state = yy_get_previous_state();

                yy_cp = yy_c_buf_p;
                yy_bp = yytext_ptr + YY_MORE_ADJ;
                goto yy_find_action;
            }
        break;
        }

    default:
        YY_FATAL_ERROR(
            "fatal flex scanner internal error--no action found" );
    } /* end of action switch */
        } /* end of scanning one token */
    } /* end of yylex */


/* yy_get_next_buffer - try to read in a new buffer
 *
 * Returns a code representing an action:
 *  EOB_ACT_LAST_MATCH -
 *  EOB_ACT_CONTINUE_SCAN - continue scanning from current position
 *  EOB_ACT_END_OF_FILE - end of file
 */

static int yy_get_next_buffer()
    {
    register char *dest = yy_current_buffer->yy_ch_buf;
    register char *source = yytext_ptr;
    register int number_to_move, i;
    int ret_val;

    if ( yy_c_buf_p > &yy_current_buffer->yy_ch_buf[yy_n_chars + 1] )
        YY_FATAL_ERROR(
        "fatal flex scanner internal error--end of buffer missed" );

    if ( yy_current_buffer->yy_fill_buffer == 0 )
        { /* Don't try to fill the buffer, so this is an EOF. */
        if ( yy_c_buf_p - yytext_ptr - YY_MORE_ADJ == 1 )
            {
            /* We matched a single character, the EOB, so
             * treat this as a final EOF.
             */
            return EOB_ACT_END_OF_FILE;
            }

        else
            {
            /* We matched some text prior to the EOB, first
             * process it.
             */
            return EOB_ACT_LAST_MATCH;
            }
        }

    /* Try to read more data. */

    /* First move last chars to start of buffer. */
    number_to_move = (int) (yy_c_buf_p - yytext_ptr) - 1;

    for ( i = 0; i < number_to_move; ++i )
        *(dest++) = *(source++);

    if ( yy_current_buffer->yy_buffer_status == YY_BUFFER_EOF_PENDING )
        /* don't do the read, it's not guaranteed to return an EOF,
         * just force an EOF
         */
        yy_n_chars = 0;

    else
        {
        int num_to_read =
            yy_current_buffer->yy_buf_size - number_to_move - 1;

        while ( num_to_read <= 0 )
            { /* Not enough room in the buffer - grow it. */
#ifdef YY_USES_REJECT
            YY_FATAL_ERROR(
"input buffer overflow, can't enlarge buffer because scanner uses REJECT" );
#else

            /* just a shorter name for the current buffer */
            YY_BUFFER_STATE b = yy_current_buffer;

            int yy_c_buf_p_offset =
                (int) (yy_c_buf_p - b->yy_ch_buf);

            if ( b->yy_is_our_buffer )
                {
                int new_size = b->yy_buf_size * 2;

                if ( new_size <= 0 )
                    b->yy_buf_size += b->yy_buf_size / 8;
                else
                    b->yy_buf_size *= 2;

                b->yy_ch_buf = (char *)
                    /* Include room in for 2 EOB chars. */
                    yy_flex_realloc( (void *) b->yy_ch_buf,
                             b->yy_buf_size + 2 );
                }
            else
                /* Can't grow it, we don't own it. */
                b->yy_ch_buf = 0;

            if ( ! b->yy_ch_buf )
                YY_FATAL_ERROR(
                "fatal error - scanner input buffer overflow" );

            yy_c_buf_p = &b->yy_ch_buf[yy_c_buf_p_offset];

            num_to_read = yy_current_buffer->yy_buf_size -
                        number_to_move - 1;
#endif
            }

        if ( num_to_read > YY_READ_BUF_SIZE )
            num_to_read = YY_READ_BUF_SIZE;

        /* Read in more data. */
        YY_INPUT( (&yy_current_buffer->yy_ch_buf[number_to_move]),
            yy_n_chars, num_to_read );
        }

    if ( yy_n_chars == 0 )
        {
        if ( number_to_move == YY_MORE_ADJ )
            {
            ret_val = EOB_ACT_END_OF_FILE;
            yyrestart( yyin );
            }

        else
            {
            ret_val = EOB_ACT_LAST_MATCH;
            yy_current_buffer->yy_buffer_status =
                YY_BUFFER_EOF_PENDING;
            }
        }

    else
        ret_val = EOB_ACT_CONTINUE_SCAN;

    yy_n_chars += number_to_move;
    yy_current_buffer->yy_ch_buf[yy_n_chars] = YY_END_OF_BUFFER_CHAR;
    yy_current_buffer->yy_ch_buf[yy_n_chars + 1] = YY_END_OF_BUFFER_CHAR;

    yytext_ptr = &yy_current_buffer->yy_ch_buf[0];

    return ret_val;
    }


/* yy_get_previous_state - get the state just before the EOB char was reached */

static yy_state_type yy_get_previous_state()
    {
    register yy_state_type yy_current_state;
    register char *yy_cp;

    yy_current_state = yy_start;

    for ( yy_cp = yytext_ptr + YY_MORE_ADJ; yy_cp < yy_c_buf_p; ++yy_cp )
        {
        register YY_CHAR yy_c = (*yy_cp ? yy_ec[YY_SC_TO_UI(*yy_cp)] : 1);
        if ( yy_accept[yy_current_state] )
            {
            yy_last_accepting_state = yy_current_state;
            yy_last_accepting_cpos = yy_cp;
            }
        while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
            {
            yy_current_state = (int) yy_def[yy_current_state];
            if ( yy_current_state >= 722 )
                yy_c = (YY_CHAR)yy_meta[(unsigned int) yy_c];
            }
        yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];
        }

    return yy_current_state;
    }


/* yy_try_NUL_trans - try to make a transition on the NUL character
 *
 * synopsis
 *  next_state = yy_try_NUL_trans( current_state );
 */

#ifdef YY_USE_PROTOS
static yy_state_type yy_try_NUL_trans( yy_state_type yy_current_state )
#else
static yy_state_type yy_try_NUL_trans( yy_current_state )
yy_state_type yy_current_state;
#endif
    {
    register int yy_is_jam;
    register char *yy_cp = yy_c_buf_p;

    register YY_CHAR yy_c = 1;
    if ( yy_accept[yy_current_state] )
        {
        yy_last_accepting_state = yy_current_state;
        yy_last_accepting_cpos = yy_cp;
        }
    while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
        {
        yy_current_state = (int) yy_def[yy_current_state];
        if ( yy_current_state >= 722 )
            yy_c = (YY_CHAR)yy_meta[(unsigned int) yy_c];
        }
    yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];
    yy_is_jam = (yy_current_state == 721);

    return yy_is_jam ? 0 : yy_current_state;
    }


#ifndef YY_NO_UNPUT
#ifdef YY_USE_PROTOS
static void yyunput( int c, register char *yy_bp )
#else
static void yyunput( c, yy_bp )
int c;
register char *yy_bp;
#endif
    {
    register char *yy_cp = yy_c_buf_p;

    /* undo effects of setting up yytext */
    *yy_cp = yy_hold_char;

    if ( yy_cp < yy_current_buffer->yy_ch_buf + 2 )
        { /* need to shift things up to make room */
        /* +2 for EOB chars. */
        register int number_to_move = yy_n_chars + 2;
        register char *dest = &yy_current_buffer->yy_ch_buf[
                    yy_current_buffer->yy_buf_size + 2];
        register char *source =
                &yy_current_buffer->yy_ch_buf[number_to_move];

        while ( source > yy_current_buffer->yy_ch_buf )
            *--dest = *--source;

        yy_cp += (int) (dest - source);
        yy_bp += (int) (dest - source);
        yy_n_chars = yy_current_buffer->yy_buf_size;

        if ( yy_cp < yy_current_buffer->yy_ch_buf + 2 )
            YY_FATAL_ERROR( "flex scanner push-back overflow" );
        }

    *--yy_cp = (char) c;


    yytext_ptr = yy_bp;
    yy_hold_char = *yy_cp;
    yy_c_buf_p = yy_cp;
    }
#endif  /* ifndef YY_NO_UNPUT */


#ifdef __cplusplus
static int yyinput()
#else
static int input()
#endif
    {
    int c;

    *yy_c_buf_p = yy_hold_char;

    if ( *yy_c_buf_p == YY_END_OF_BUFFER_CHAR )
        {
        /* yy_c_buf_p now points to the character we want to return.
         * If this occurs *before* the EOB characters, then it's a
         * valid NUL; if not, then we've hit the end of the buffer.
         */
        if ( yy_c_buf_p < &yy_current_buffer->yy_ch_buf[yy_n_chars] )
            /* This was really a NUL. */
            *yy_c_buf_p = '\0';

        else
            { /* need more input */
            yytext_ptr = yy_c_buf_p;
            ++yy_c_buf_p;

            switch ( yy_get_next_buffer() )
                {
                case EOB_ACT_END_OF_FILE:
                    {
                    if ( yywrap() )
                        {
                        yy_c_buf_p =
                        yytext_ptr + YY_MORE_ADJ;
                        return EOF;
                        }

                    if ( ! yy_did_buffer_switch_on_eof )
                        YY_NEW_FILE;
#ifdef __cplusplus
                    return yyinput();
#else
                    return input();
#endif
                    }

                case EOB_ACT_CONTINUE_SCAN:
                    yy_c_buf_p = yytext_ptr + YY_MORE_ADJ;
                    break;

                case EOB_ACT_LAST_MATCH:
#ifdef __cplusplus
                    YY_FATAL_ERROR(
                    "unexpected last match in yyinput()" );
#else
                    YY_FATAL_ERROR(
                    "unexpected last match in input()" );
#endif
                }
            }
        }

    c = *(unsigned char *) yy_c_buf_p;  /* cast for 8-bit char's */
    *yy_c_buf_p = '\0'; /* preserve yytext */
    yy_hold_char = *++yy_c_buf_p;


    return c;
    }


#ifdef YY_USE_PROTOS
void yyrestart( FILE *input_file )
#else
void yyrestart( input_file )
FILE *input_file;
#endif
    {
    if ( ! yy_current_buffer )
        yy_current_buffer = yy_create_buffer( yyin, YY_BUF_SIZE );

    yy_init_buffer( yy_current_buffer, input_file );
    yy_load_buffer_state();
    }


#ifdef YY_USE_PROTOS
void yy_switch_to_buffer( YY_BUFFER_STATE new_buffer )
#else
void yy_switch_to_buffer( new_buffer )
YY_BUFFER_STATE new_buffer;
#endif
    {
    if ( yy_current_buffer == new_buffer )
        return;

    if ( yy_current_buffer )
        {
        /* Flush out information for old buffer. */
        *yy_c_buf_p = yy_hold_char;
        yy_current_buffer->yy_buf_pos = yy_c_buf_p;
        yy_current_buffer->yy_n_chars = yy_n_chars;
        }

    yy_current_buffer = new_buffer;
    yy_load_buffer_state();

    /* We don't actually know whether we did this switch during
     * EOF (yywrap()) processing, but the only time this flag
     * is looked at is after yywrap() is called, so it's safe
     * to go ahead and always set it.
     */
    yy_did_buffer_switch_on_eof = 1;
    }


#ifdef YY_USE_PROTOS
void yy_load_buffer_state( void )
#else
void yy_load_buffer_state()
#endif
    {
    yy_n_chars = yy_current_buffer->yy_n_chars;
    yytext_ptr = yy_c_buf_p = yy_current_buffer->yy_buf_pos;
    yyin = yy_current_buffer->yy_input_file;
    yy_hold_char = *yy_c_buf_p;
    }


#ifdef YY_USE_PROTOS
YY_BUFFER_STATE yy_create_buffer( FILE *file, int size )
#else
YY_BUFFER_STATE yy_create_buffer( file, size )
FILE *file;
int size;
#endif
    {
    YY_BUFFER_STATE b;

    b = (YY_BUFFER_STATE) yy_flex_alloc( sizeof( struct yy_buffer_state ) );
    if ( ! b )
        YY_FATAL_ERROR( "out of dynamic memory in yy_create_buffer()" );

    b->yy_buf_size = size;

    /* yy_ch_buf has to be 2 characters longer than the size given because
     * we need to put in 2 end-of-buffer characters.
     */
    b->yy_ch_buf = (char *) yy_flex_alloc( b->yy_buf_size + 2 );
    if ( ! b->yy_ch_buf )
        YY_FATAL_ERROR( "out of dynamic memory in yy_create_buffer()" );

    b->yy_is_our_buffer = 1;

    yy_init_buffer( b, file );

    return b;
    }


#ifdef YY_USE_PROTOS
void yy_delete_buffer( YY_BUFFER_STATE b )
#else
void yy_delete_buffer( b )
YY_BUFFER_STATE b;
#endif
    {
    if ( ! b )
        return;

    if ( b == yy_current_buffer )
        yy_current_buffer = (YY_BUFFER_STATE) 0;

    if ( b->yy_is_our_buffer )
        yy_flex_free( (void *) b->yy_ch_buf );

    yy_flex_free( (void *) b );
    }


#ifndef YY_ALWAYS_INTERACTIVE
#ifndef YY_NEVER_INTERACTIVE
extern int __cdecl isatty YY_PROTO(( int ));
#endif
#endif

#ifdef YY_USE_PROTOS
void yy_init_buffer( YY_BUFFER_STATE b, FILE *file )
#else
void yy_init_buffer( b, file )
YY_BUFFER_STATE b;
FILE *file;
#endif


    {
    yy_flush_buffer( b );

    b->yy_input_file = file;
    b->yy_fill_buffer = 1;

#if YY_ALWAYS_INTERACTIVE
    b->yy_is_interactive = 1;
#else
#if YY_NEVER_INTERACTIVE
    b->yy_is_interactive = 0;
#else
    b->yy_is_interactive = file ? (isatty( fileno(file) ) > 0) : 0;
#endif
#endif
    }


#ifdef YY_USE_PROTOS
void yy_flush_buffer( YY_BUFFER_STATE b )
#else
void yy_flush_buffer( b )
YY_BUFFER_STATE b;
#endif

    {
    b->yy_n_chars = 0;

    /* We always need two end-of-buffer characters.  The first causes
     * a transition to the end-of-buffer state.  The second causes
     * a jam in that state.
     */
    b->yy_ch_buf[0] = YY_END_OF_BUFFER_CHAR;
    b->yy_ch_buf[1] = YY_END_OF_BUFFER_CHAR;

    b->yy_buf_pos = &b->yy_ch_buf[0];

    b->yy_at_bol = 1;
    b->yy_buffer_status = YY_BUFFER_NEW;

    if ( b == yy_current_buffer )
        yy_load_buffer_state();
    }


#ifndef YY_NO_SCAN_BUFFER
#ifdef YY_USE_PROTOS
YY_BUFFER_STATE yy_scan_buffer( char *base, yy_size_t size )
#else
YY_BUFFER_STATE yy_scan_buffer( base, size )
char *base;
yy_size_t size;
#endif
    {
    YY_BUFFER_STATE b;

    if ( size < 2 ||
         base[size-2] != YY_END_OF_BUFFER_CHAR ||
         base[size-1] != YY_END_OF_BUFFER_CHAR )
        /* They forgot to leave room for the EOB's. */
        return 0;

    b = (YY_BUFFER_STATE) yy_flex_alloc( sizeof( struct yy_buffer_state ) );
    if ( ! b )
        YY_FATAL_ERROR( "out of dynamic memory in yy_scan_buffer()" );

    b->yy_buf_size = size - 2;  /* "- 2" to take care of EOB's */
    b->yy_buf_pos = b->yy_ch_buf = base;
    b->yy_is_our_buffer = 0;
    b->yy_input_file = 0;
    b->yy_n_chars = b->yy_buf_size;
    b->yy_is_interactive = 0;
    b->yy_at_bol = 1;
    b->yy_fill_buffer = 0;
    b->yy_buffer_status = YY_BUFFER_NEW;

    yy_switch_to_buffer( b );

    return b;
    }
#endif


#ifndef YY_NO_SCAN_STRING
#ifdef YY_USE_PROTOS
YY_BUFFER_STATE yy_scan_string( yyconst char *yy_str )
#else
YY_BUFFER_STATE yy_scan_string( yy_str )
yyconst char *yy_str;
#endif
    {
    int len;
    for ( len = 0; yy_str[len]; ++len )
        ;

    return yy_scan_bytes( yy_str, len );
    }
#endif


#ifndef YY_NO_SCAN_BYTES
#ifdef YY_USE_PROTOS
YY_BUFFER_STATE yy_scan_bytes( yyconst char *bytes, int len )
#else
YY_BUFFER_STATE yy_scan_bytes( bytes, len )
yyconst char *bytes;
int len;
#endif
    {
    YY_BUFFER_STATE b;
    char *buf;
    yy_size_t n;
    int i;

    /* Get memory for full buffer, including space for trailing EOB's. */
    n = len + 2;
    buf = (char *) yy_flex_alloc( n );
    if ( ! buf )
        YY_FATAL_ERROR( "out of dynamic memory in yy_scan_bytes()" );

    for ( i = 0; i < len; ++i )
        buf[i] = bytes[i];

    buf[len] = buf[len+1] = YY_END_OF_BUFFER_CHAR;

    b = yy_scan_buffer( buf, n );
    if ( ! b )
        YY_FATAL_ERROR( "bad buffer in yy_scan_bytes()" );

    /* It's okay to grow etc. this buffer, and we should throw it
     * away when we're done.
     */
    b->yy_is_our_buffer = 1;

    return b;
    }
#endif


#ifndef YY_NO_PUSH_STATE
#ifdef YY_USE_PROTOS
static void yy_push_state( int new_state )
#else
static void yy_push_state( new_state )
int new_state;
#endif
    {
    if ( yy_start_stack_ptr >= yy_start_stack_depth )
        {
        yy_size_t new_size;

        yy_start_stack_depth += YY_START_STACK_INCR;
        new_size = yy_start_stack_depth * sizeof( int );

        if ( ! yy_start_stack )
            yy_start_stack = (int *) yy_flex_alloc( new_size );

        else
            yy_start_stack = (int *) yy_flex_realloc(
                    (void *) yy_start_stack, new_size );

        if ( ! yy_start_stack )
            YY_FATAL_ERROR(
            "out of memory expanding start-condition stack" );
        }

    yy_start_stack[yy_start_stack_ptr++] = YY_START;

    BEGIN(new_state);
    }
#endif


#ifndef YY_NO_POP_STATE
static void yy_pop_state()
    {
    if ( --yy_start_stack_ptr < 0 )
        YY_FATAL_ERROR( "start-condition stack underflow" );

    BEGIN(yy_start_stack[yy_start_stack_ptr]);
    }
#endif


#ifndef YY_NO_TOP_STATE
static int yy_top_state()
    {
    return yy_start_stack[yy_start_stack_ptr - 1];
    }
#endif

#ifndef YY_EXIT_FAILURE
#define YY_EXIT_FAILURE 2
#endif

#ifdef YY_USE_PROTOS
static void yy_fatal_error( yyconst char msg[] )
#else
static void yy_fatal_error( msg )
char msg[];
#endif
    {
    (void) fprintf( stderr, "%s\n", msg );
    MyExit( YY_EXIT_FAILURE );
    }



/* Redefine yyless() so it works in section 3 code. */

#undef yyless
#define yyless(n) \
    do \
        { \
        /* Undo effects of setting up yytext. */ \
        yytext[yyleng] = yy_hold_char; \
        yy_c_buf_p = yytext + n - YY_MORE_ADJ; \
        yy_hold_char = *yy_c_buf_p; \
        *yy_c_buf_p = '\0'; \
        yyleng = n; \
        } \
    while ( 0 )


/* Internal utility routines. */

#ifndef yytext_ptr
#ifdef YY_USE_PROTOS
static void yy_flex_strncpy( char *s1, yyconst char *s2, int n )
#else
static void yy_flex_strncpy( s1, s2, n )
char *s1;
yyconst char *s2;
int n;
#endif
    {
    register int i;
    for ( i = 0; i < n; ++i )
        s1[i] = s2[i];
    }
#endif

#ifdef YY_USE_PROTOS
static void *yy_flex_alloc( yy_size_t size )
#else
static void *yy_flex_alloc( size )
yy_size_t size;
#endif
    {
    return (void *) malloc( size );
    }

#ifdef YY_USE_PROTOS
static void *yy_flex_realloc( void *ptr, yy_size_t size )
#else
static void *yy_flex_realloc( ptr, size )
void *ptr;
yy_size_t size;
#endif
    {
    /* The cast to (char *) in the following accommodates both
     * implementations that use char* generic pointers, and those
     * that use void* generic pointers.  It works with the latter
     * because both ANSI C and C++ allow castless assignment from
     * any pointer type to void*, and deal with argument conversions
     * as though doing an assignment.
     */
    return (void *) realloc( (char *) ptr, size );
    }

#ifdef YY_USE_PROTOS
static void yy_flex_free( void *ptr )
#else
static void yy_flex_free( ptr )
void *ptr;
#endif
    {
    free( ptr );
    }

#if YY_MAIN
int main()
    {
    yylex();
    return 0;
    }
#endif


int llgettoken(int *token, LLSTYPE *lval, LLPOS *pos)
{
    for (;;) {
#ifdef MS_DIRECTIVE
// Ordering of hack directives
//      PrivateDir_Huge PrivateDir_Unbounded PrivateDir_Array PrivateDir_NoCopy PrivateDir_PDU
//      PrivateDir_ObjectIdEncoded PrivateDir_ObjectIdFixedSize
//      PrivateDir_Type PrivateDir_Field PrivateDir_Value PrivateDir_Linked

    if (g_fPrivateDir_Intx)
    {
        g_fPrivateDir_Intx = 0;
        yylval._XString = "PrivateDir_Intx";
        *lval = yylval;
        *token = T_PrivateDir_Intx;
        return 1;
    }
    if (g_fPrivateDir_LenPtr)
    {
        g_fPrivateDir_LenPtr = 0;
        yylval._XString = "PrivateDir_LenPtr";
        *lval = yylval;
        *token = T_PrivateDir_LenPtr;
        return 1;
    }
    if (g_fPrivateDir_Pointer)
    {
        g_fPrivateDir_Pointer = 0;
        yylval._XString = "PrivateDir_Pointer";
        *lval = yylval;
        *token = T_PrivateDir_Pointer;
        return 1;
    }
    if (g_fPrivateDir_Array)
    {
        g_fPrivateDir_Array = 0;
        yylval._XString = "PrivateDir_Array";
        *lval = yylval;
        *token = T_PrivateDir_Array;
        return 1;
    }
    if (g_fPrivateDir_NoCode)
    {
        g_fPrivateDir_NoCode = 0;
        yylval._XString = "PrivateDir_NoCode";
        *lval = yylval;
        *token = T_PrivateDir_NoCode;
        return 1;
    }
    if (g_fPrivateDir_NoMemCopy)
    {
        g_fPrivateDir_NoMemCopy = 0;
        yylval._XString = "PrivateDir_NoMemCopy";
        *lval = yylval;
        *token = T_PrivateDir_NoMemCopy;
        return 1;
    }
    if (g_fPrivateDir_Public)
    {
        g_fPrivateDir_Public = 0;
        yylval._XString = "PrivateDir_Public";
        *lval = yylval;
        *token = T_PrivateDir_Public;
        return 1;
    }
    if (g_fPrivateDir_OidPacked)
    {
        g_fPrivateDir_OidPacked = 0;
        yylval._XString = "PrivateDir_OidPacked";
        *lval = yylval;
        *token = T_PrivateDir_OidPacked;
        return 1;
    }
    if (g_fPrivateDir_OidArray)
    {
        g_fPrivateDir_OidArray = 0;
        yylval._XString = "PrivateDir_OidArray";
        *lval = yylval;
        *token = T_PrivateDir_OidArray;
        return 1;
    }
    if (g_szPrivateDirectedTypeName[0])
    {
        if (g_fPrivateDir_TypeNameToken)
        {
            yylval._XString = strdup(&g_szPrivateDirectedTypeName[0]);
            g_szPrivateDirectedTypeName[0] = '\0';
            *lval = yylval;
            *token = T_lcsymbol;
        }
        else
        {
            g_fPrivateDir_TypeNameToken = 1;
            yylval._XString = "PrivateDir_TypeName";
            *lval = yylval;
            *token = T_PrivateDir_TypeName;
        }
        return 1;
    }
    if (g_szPrivateDirectedFieldName[0])
    {
        if (g_fPrivateDir_FieldNameToken)
        {
            yylval._XString = strdup(&g_szPrivateDirectedFieldName[0]);
            g_szPrivateDirectedFieldName[0] = '\0';
            *lval = yylval;
            *token = T_lcsymbol;
        }
        else
        {
            g_fPrivateDir_FieldNameToken = 1;
            yylval._XString = "PrivateDir_FieldName";
            *lval = yylval;
            *token = T_PrivateDir_FieldName;
        }
        return 1;
    }
    if (g_szPrivateDirectedValueName[0])
    {
        if (g_fPrivateDir_ValueNameToken)
        {
            yylval._XString = strdup(&g_szPrivateDirectedValueName[0]);
            g_szPrivateDirectedValueName[0] = '\0';
            *lval = yylval;
            *token = T_lcsymbol;
        }
        else
        {
            g_fPrivateDir_ValueNameToken = 1;
            yylval._XString = "PrivateDir_ValueName";
            *lval = yylval;
            *token = T_PrivateDir_ValueName;
        }
        return 1;
    }
    if (g_fPrivateDir_SLinked)
    {
        g_fPrivateDir_SLinked = 0;
        yylval._XString = "PrivateDir_SLinked";
        *lval = yylval;
        *token = T_PrivateDir_SLinked;
        return 1;
    }
    if (g_fPrivateDir_DLinked)
    {
        g_fPrivateDir_DLinked = 0;
        yylval._XString = "PrivateDir_DLinked";
        *lval = yylval;
        *token = T_PrivateDir_DLinked;
        return 1;
    }
#endif // MS_DIRECTIVE
    if (yy_hold_char == YY_END_OF_BUFFER_CHAR) {
        *pos = current_pos;
    } else {
        *pos = last_pos;
    }
    *token = yylex();
    if (*token == 0 || *token == EOF)
        return 0;
    if (*token == T_NOTOKEN)
        continue;
    *lval = yylval;
    return 1;
    }
}

void readfiles(char **filenames)
{
    FILE *fin;
    long len;
    int i, nfiles, j;

    for (nfiles = 0; filenames[nfiles]; nfiles++) {}
    allfilenames = filenames;
    allfilestarts = (char **)malloc((nfiles + 1) * sizeof(char *));
    filelen = 0;
    for (i = 0; i < nfiles; i++) {
    fin = fopen(filenames[i], "r");
    if (!fin) {
        perror(filenames[i]);
        MyExit(1);
    }
    fseek(fin, 0, SEEK_END);
    filelen += ftell(fin);
    fclose(fin);
    }
    currentfilepos = file = (char *)malloc(filelen);
    for (i = 0; i < nfiles; i++) {
    fin = fopen(filenames[i], "r");
    if (!fin) {
        perror(filenames[i]);
        MyExit(1);
    }
    fseek(fin, 0, SEEK_END);
    len = ftell(fin);
    fseek(fin, 0, SEEK_SET);
    allfilestarts[i] = currentfilepos;
    len = fread(currentfilepos, 1, len, fin);
    currentfilepos += len;
    fclose(fin);
    }
    filelen = currentfilepos - file;
    allfilestarts[i] = currentfilepos;

    // set up the first file's info
    currentfilepos = file;
    current_pos.line = 1;
    current_pos.column = 1;
    current_pos.file = filenames[0];
    last_pos = current_pos;

    // mask out all the directives prior to the body
    for (i = 0; i < nfiles; i++)
    {
        char *psz = allfilestarts[i];
        while (isspace(*psz))
            psz++;
        while ('-' == *psz && '-' == *(psz+1))
        {
            psz += 2;
            // mask out directives if needed
            if (g_chDirectiveBegin == *psz)
                *psz++ = ' ';
            SetDirective(psz);
            // locate the closing '--'
            while ('\n' != *psz)
            {
                if ('-' == *psz && '-' == *(psz+1))
                {
                    psz++;
                    break;
                }
                psz++;
            }
            psz++; // skip over '\n' or the second '-'
            // skip over white spaces
            while (isspace(*psz))
                psz++;
        }

        // associate ghost files with ghost modules
        for (j = 0; j < g_cGhostFiles; j++)
        {
            if (! strcmp(g_aGhostFiles[j].pszFileName, filenames[i]))
            {
                int ch_idx;
                char szModuleName[128];
                // get the module identifier
                while (! isalpha(*psz))
                    psz++;
                for (ch_idx = 0; isalnum(*psz) || *psz == '-'; )
                {
                    szModuleName[ch_idx++] = *psz++;
                }
                szModuleName[ch_idx] = '\0'; // null terminator
                ASSERT(! g_aGhostFiles[j].pszModuleName);
                g_aGhostFiles[j].pszModuleName = strdup(szModuleName);
            }
        }
    }
}

void
llprinttoken(LLTERM *term, char *identifier, FILE *f)
{
    char32_t *p;

    switch (term->token) {
    case T_number:
    fprintf(f, "%s(%u)", identifier, intx2uint32(&term->lval._XNumber));
    break;
    case T_bstring:
    case T_hstring:
    case T_only_uppercase_symbol:
    case T_only_uppercase_digits_symbol:
    case T_uppercase_symbol:
    case T_lcsymbol:
    case T_ampucsymbol:
    case T_amplcsymbol:
    fprintf(f, "%s(%s)", identifier, term->lval._XString);
    break;
    case T_cstring:
    fprintf(f, "%s(", identifier);
    for (p = term->lval._XString32; *p; p++)
        putc(*p, f);
    putc(')', f);
    break;
    default:
    fprintf(f, "%s", identifier);
    }
}


#ifdef MS_DIRECTIVE
int PrivateDirectives_Input ( void )
{
    return input();
}
#endif // MS_DIRECTIVE
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\asn1\asn1c\parser.c ===
#include "precomp.h" 
/* Copyright (C) Boris Nikolaus, Germany, 1996-1997. All rights reserved. */

#include <stdio.h>
#include <string.h>
#include <ctype.h>
#include "defs.h"
#include "builtin.h"
#include "hackdir.h"

extern int pass;


#include <stdio.h>
#include <stdlib.h>
#include <stdarg.h>
#include <limits.h>
#include "parser.h"

int llcpos;
int *llstk;
unsigned llstksize;
unsigned llcstp = 1;
LLTERM *lltokens;
int llntokens;
char llerrormsg[256];
LLPOS llerrorpos;
int llepos;
LLSTYPE lllval;

int llterm(int token, LLSTYPE *lval, LLSTATE *llin, LLSTATE *llout);
void llfailed(LLPOS *pos, char *fmt, ...);
void llresizestk();
#define LLCHECKSTK do{if (llcstp + 1 >= llstksize) llresizestk();}while(/*CONSTCOND*/0)
#define LLFAILED(_err) do{llfailed _err; goto failed;}while(/*CONSTCOND*/0)
#define LLCUTOFF do{unsigned i; for (i = llstp; i < llcstp; i++) if (llstk[i] > 0) llstk[i] = -llstk[i];}while(/*CONSTCOND*/0)
#define LLCUTTHIS do{if (llstk[llstp] > 0) llstk[llstp] = -llstk[llstp];}while(/*CONSTCOND*/0)
#define LLCUTALL do{unsigned i; for (i = 0; i < llcstp; i++) if (llstk[i] > 0) llstk[i] = -llstk[i];}while(/*CONSTCOND*/0)

#if LLDEBUG > 0
int lldebug;
int last_linenr;
char *last_file = "";
#define LLDEBUG_ENTER(_ident) lldebug_enter(_ident)
#define LLDEBUG_LEAVE(_ident,_succ) lldebug_leave(_ident,_succ)
#define LLDEBUG_ALTERNATIVE(_ident,_alt) lldebug_alternative(_ident,_alt)
#define LLDEBUG_ITERATION(_ident,_num) lldebug_iteration(_ident,_num)
#define LLDEBUG_TOKEN(_exp,_pos) lldebug_token(_exp,_pos)
#define LLDEBUG_ANYTOKEN(_pos) lldebug_anytoken(_pos)
#define LLDEBUG_BACKTRACKING(_ident) lldebug_backtracking(_ident)
void lldebug_init();
void lldebug_enter(char *ident);
void lldebug_leave(char *ident, int succ);
void lldebug_alternative(char *ident, int alt);
void lldebug_token(int expected, unsigned pos);
void lldebug_anytoken(unsigned pos);
void lldebug_backtracking(char *ident);
void llprinttoken(LLTERM *token, char *identifier, FILE *f);
#else
#define LLDEBUG_ENTER(_ident)
#define LLDEBUG_LEAVE(_ident,_succ)
#define LLDEBUG_ALTERNATIVE(_ident,_alt)
#define LLDEBUG_ITERATION(_ident,_num)
#define LLDEBUG_TOKEN(_exp,_pos)
#define LLDEBUG_ANYTOKEN(_pos)
#define LLDEBUG_BACKTRACKING(_ident)
#endif

int ll_Main(LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("Main");

llstate_0 = *llin;
#undef failed
#define failed failed1
{LLSTATE llstate_1;
if (!ll_ModuleDefinition(&llstate_0, &llstate_1)) goto failed1;
{LLSTATE llstate_2;
if (!ll_ModuleDefinition_ESeq(&llstate_1, &llstate_2)) goto failed1;
*llout = llstate_2;
}}
LLDEBUG_LEAVE("Main", 1);
return 1;
failed1: LLDEBUG_LEAVE("Main", 0);
return 0;
}

int ll_ModuleDefinition_ESeq(LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("ModuleDefinition_ESeq");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("ModuleDefinition_ESeq", 1);
{LLSTATE llstate_1;
if (!ll_ModuleDefinition(&llstate_0, &llstate_1)) goto failed2;
{LLSTATE llstate_2;
if (!ll_ModuleDefinition_ESeq(&llstate_1, &llstate_2)) goto failed2;
*llout = llstate_2;
break;
}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("ModuleDefinition_ESeq", 2);
*llout = llstate_0;
break;
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("ModuleDefinition_ESeq");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("ModuleDefinition_ESeq", 1);
return 1;
failed1: LLDEBUG_LEAVE("ModuleDefinition_ESeq", 0);
return 0;
}

int ll_ModuleDefinition(LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("ModuleDefinition");

llstate_0 = *llin;
#undef failed
#define failed failed1
{LLSTATE llstate_1;XModuleIdentifier llatt_1;
if (!ll_ModuleIdentifier(&llatt_1, &llstate_0, &llstate_1)) goto failed1;
{LLSTATE llstate_2;
if (!llterm(T_DEFINITIONS, (LLSTYPE *)0, &llstate_1, &llstate_2)) goto failed1;
{LLSTATE llstate_3;XTagType llatt_3;
if (!ll_TagDefault(&llatt_3, &llstate_2, &llstate_3)) goto failed1;
{LLSTATE llstate_4;XExtensionType llatt_4;
if (!ll_ExtensionDefault(&llatt_4, &llstate_3, &llstate_4)) goto failed1;
{LLSTATE llstate_5;
if (!llterm(T_DEF, (LLSTYPE *)0, &llstate_4, &llstate_5)) goto failed1;
{if (!AssignModuleIdentifier(&llstate_5.Assignments, llatt_1))
		LLFAILED((&llstate_1.pos, "Module `%s' twice defined", llatt_1->Identifier));
	    llstate_5.MainModule = llatt_1;
	    llstate_5.Module = llatt_1;
	    llstate_5.TagDefault = llatt_3;
	    llstate_5.ExtensionDefault = llatt_4;
	    g_eDefTagType = llatt_3;
	
{LLSTATE llstate_6;
if (!llterm(T_BEGIN, (LLSTYPE *)0, &llstate_5, &llstate_6)) goto failed1;
{LLSTATE llstate_7;
if (!ll_ModuleBody(&llstate_6, &llstate_7)) goto failed1;
{LLSTATE llstate_8;
if (!llterm(T_END, (LLSTYPE *)0, &llstate_7, &llstate_8)) goto failed1;
*llout = llstate_8;
{LLCUTALL;
	
}}}}}}}}}}
LLDEBUG_LEAVE("ModuleDefinition", 1);
return 1;
failed1: LLDEBUG_LEAVE("ModuleDefinition", 0);
return 0;
}

int ll_ModuleIdentifier(XModuleIdentifier *llret, LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("ModuleIdentifier");

llstate_0 = *llin;
#undef failed
#define failed failed1
{LLSTATE llstate_1;XModuleIdentifier llatt_1;
if (!ll_modulereference(&llatt_1, &llstate_0, &llstate_1)) goto failed1;
{LLSTATE llstate_2;XValue llatt_2;
if (!ll_DefinitiveIdentifier(&llatt_2, &llstate_1, &llstate_2)) goto failed1;
*llout = llstate_2;
{if (llatt_2) {
		(*llret) = NewModuleIdentifier();
		(*llret)->Identifier = llatt_1->Identifier;
		(*llret)->ObjectIdentifier = llatt_2;
	    } else {
		(*llret) = llatt_1;
	    }
	
}}}
LLDEBUG_LEAVE("ModuleIdentifier", 1);
return 1;
failed1: LLDEBUG_LEAVE("ModuleIdentifier", 0);
return 0;
}

int ll_DefinitiveIdentifier(XValue *llret, LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("DefinitiveIdentifier");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("DefinitiveIdentifier", 1);
{LLSTATE llstate_1;
if (!llterm('{', (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
{LLSTATE llstate_2;XNamedObjIdValue llatt_2;
if (!ll_DefinitiveObjIdComponentList(&llatt_2, &llstate_1, &llstate_2)) goto failed2;
{LLSTATE llstate_3;
if (!llterm('}', (LLSTYPE *)0, &llstate_2, &llstate_3)) goto failed2;
*llout = llstate_3;
{switch (GetAssignedObjectIdentifier(
		&(*llout).AssignedObjIds, NULL, llatt_2, &(*llret))) {
	    case -1:
		LLFAILED((&llstate_2.pos, "Different numbers for equally named object identifier components"));
		/*NOTREACHED*/
	    case 0:
		(*llret) = NULL;
		break;
	    case 1:
		break;
	    }
	
break;
}}}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("DefinitiveIdentifier", 2);
*llout = llstate_0;
{(*llret) = NULL;
	
break;
}
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("DefinitiveIdentifier");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("DefinitiveIdentifier", 1);
return 1;
failed1: LLDEBUG_LEAVE("DefinitiveIdentifier", 0);
return 0;
}

int ll_DefinitiveObjIdComponentList(XNamedObjIdValue *llret, LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("DefinitiveObjIdComponentList");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("DefinitiveObjIdComponentList", 1);
{LLSTATE llstate_1;XNamedObjIdValue llatt_1;
if (!ll_DefinitiveObjIdComponent(&llatt_1, &llstate_0, &llstate_1)) goto failed2;
{LLSTATE llstate_2;XNamedObjIdValue llatt_2;
if (!ll_DefinitiveObjIdComponentList(&llatt_2, &llstate_1, &llstate_2)) goto failed2;
*llout = llstate_2;
{(*llret) = DupNamedObjIdValue(llatt_1);
	    (*llret)->Next = llatt_2;
	
break;
}}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("DefinitiveObjIdComponentList", 2);
{LLSTATE llstate_1;XNamedObjIdValue llatt_1;
if (!ll_DefinitiveObjIdComponent(&llatt_1, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = llatt_1;
	
break;
}}
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("DefinitiveObjIdComponentList");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("DefinitiveObjIdComponentList", 1);
return 1;
failed1: LLDEBUG_LEAVE("DefinitiveObjIdComponentList", 0);
return 0;
}

int ll_DefinitiveObjIdComponent(XNamedObjIdValue *llret, LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("DefinitiveObjIdComponent");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("DefinitiveObjIdComponent", 1);
{LLSTATE llstate_1;XNamedObjIdValue llatt_1;
if (!ll_NameForm(&llatt_1, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = llatt_1;
	
break;
}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("DefinitiveObjIdComponent", 2);
{LLSTATE llstate_1;XNamedObjIdValue llatt_1;
if (!ll_DefinitiveNumberForm(&llatt_1, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = llatt_1;
	
break;
}}
case 3: case -3:
LLDEBUG_ALTERNATIVE("DefinitiveObjIdComponent", 3);
{LLSTATE llstate_1;XNamedObjIdValue llatt_1;
if (!ll_DefinitiveNameAndNumberForm(&llatt_1, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = llatt_1;
	
break;
}}
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("DefinitiveObjIdComponent");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("DefinitiveObjIdComponent", 1);
return 1;
failed1: LLDEBUG_LEAVE("DefinitiveObjIdComponent", 0);
return 0;
}

int ll_DefinitiveNumberForm(XNamedObjIdValue *llret, LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("DefinitiveNumberForm");

llstate_0 = *llin;
#undef failed
#define failed failed1
{LLSTATE llstate_1;XNumber llatt_1;
if (!llterm(T_number, &lllval, &llstate_0, &llstate_1)) goto failed1;
llatt_1 = lllval._XNumber;
*llout = llstate_1;
{(*llret) = NewNamedObjIdValue(eNamedObjIdValue_NumberForm);
	    (*llret)->Number = intx2uint32(&llatt_1);
	
}}
LLDEBUG_LEAVE("DefinitiveNumberForm", 1);
return 1;
failed1: LLDEBUG_LEAVE("DefinitiveNumberForm", 0);
return 0;
}

int ll_DefinitiveNameAndNumberForm(XNamedObjIdValue *llret, LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("DefinitiveNameAndNumberForm");

llstate_0 = *llin;
#undef failed
#define failed failed1
{LLSTATE llstate_1;XString llatt_1;
if (!ll_identifier(&llatt_1, &llstate_0, &llstate_1)) goto failed1;
{LLSTATE llstate_2;
if (!llterm('(', (LLSTYPE *)0, &llstate_1, &llstate_2)) goto failed1;
{LLSTATE llstate_3;XNumber llatt_3;
if (!llterm(T_number, &lllval, &llstate_2, &llstate_3)) goto failed1;
llatt_3 = lllval._XNumber;
{LLSTATE llstate_4;
if (!llterm(')', (LLSTYPE *)0, &llstate_3, &llstate_4)) goto failed1;
*llout = llstate_4;
{(*llret) = NewNamedObjIdValue(eNamedObjIdValue_NameAndNumberForm);
	    (*llret)->Name = llatt_1;
	    (*llret)->Number = intx2uint32(&llatt_3);
	
}}}}}
LLDEBUG_LEAVE("DefinitiveNameAndNumberForm", 1);
return 1;
failed1: LLDEBUG_LEAVE("DefinitiveNameAndNumberForm", 0);
return 0;
}

int ll_TagDefault(XTagType *llret, LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("TagDefault");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("TagDefault", 1);
{LLSTATE llstate_1;
if (!llterm(T_EXPLICIT, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
{LLSTATE llstate_2;
if (!llterm(T_TAGS, (LLSTYPE *)0, &llstate_1, &llstate_2)) goto failed2;
*llout = llstate_2;
{(*llret) = eTagType_Explicit;
	
break;
}}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("TagDefault", 2);
{LLSTATE llstate_1;
if (!llterm(T_IMPLICIT, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
{LLSTATE llstate_2;
if (!llterm(T_TAGS, (LLSTYPE *)0, &llstate_1, &llstate_2)) goto failed2;
*llout = llstate_2;
{(*llret) = eTagType_Implicit;
	
break;
}}}
case 3: case -3:
LLDEBUG_ALTERNATIVE("TagDefault", 3);
{LLSTATE llstate_1;
if (!llterm(T_AUTOMATIC, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
{LLSTATE llstate_2;
if (!llterm(T_TAGS, (LLSTYPE *)0, &llstate_1, &llstate_2)) goto failed2;
*llout = llstate_2;
{(*llret) = eTagType_Automatic;
	
break;
}}}
case 4: case -4:
LLDEBUG_ALTERNATIVE("TagDefault", 4);
*llout = llstate_0;
{(*llret) = eTagType_Explicit;
	
break;
}
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("TagDefault");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("TagDefault", 1);
return 1;
failed1: LLDEBUG_LEAVE("TagDefault", 0);
return 0;
}

int ll_ExtensionDefault(XExtensionType *llret, LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("ExtensionDefault");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("ExtensionDefault", 1);
{LLSTATE llstate_1;
if (!llterm(T_EXTENSIBILITY, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
{LLSTATE llstate_2;
if (!llterm(T_IMPLIED, (LLSTYPE *)0, &llstate_1, &llstate_2)) goto failed2;
*llout = llstate_2;
{(*llret) = eExtensionType_Automatic;
	
break;
}}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("ExtensionDefault", 2);
*llout = llstate_0;
{(*llret) = eExtensionType_None;
	
break;
}
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("ExtensionDefault");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("ExtensionDefault", 1);
return 1;
failed1: LLDEBUG_LEAVE("ExtensionDefault", 0);
return 0;
}

int ll_ModuleBody(LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("ModuleBody");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("ModuleBody", 1);
{LLSTATE llstate_1;XStrings llatt_1;
if (!ll_Exports(&llatt_1, &llstate_0, &llstate_1)) goto failed2;
{LLSTATE llstate_2;XStringModules llatt_2;
if (!ll_Imports(&llatt_2, &llstate_1, &llstate_2)) goto failed2;
{llstate_2.Imported = llatt_2;
	
{LLSTATE llstate_3;
if (!ll_AssignmentList(&llstate_2, &llstate_3)) goto failed2;
*llout = llstate_3;
{String_t *s;
	    StringModule_t *sm;
	    Assignment_t *a, **aa, *oldass;
	    UndefinedSymbol_t *u;
	    if (llatt_2 != IMPORT_ALL) {
		for (sm = llatt_2; sm; sm = sm->Next) {
		    if (!FindExportedAssignment((*llout).Assignments,
			eAssignment_Undefined, sm->String, sm->Module)) {
			if (FindAssignment((*llout).Assignments,
			    eAssignment_Undefined, sm->String,
			    sm->Module)) {
			    u = NewUndefinedSymbol(
				eUndefinedSymbol_SymbolNotExported,
				eAssignment_Undefined);
			} else {
			    u = NewUndefinedSymbol(
				eUndefinedSymbol_SymbolNotDefined,
				eAssignment_Undefined);
			}
			u->U.Symbol.Identifier = sm->String;
			u->U.Symbol.Module = sm->Module;
			u->Next = (*llout).Undefined;
			(*llout).Undefined = u;
			continue;
		    }
		    if (!FindAssignmentInCurrentPass((*llout).Assignments,
			sm->String, (*llout).Module)) {
			a = NewAssignment(eAssignment_Reference);
			a->Identifier = sm->String;
			a->Module = (*llout).Module;
			a->U.Reference.Identifier = sm->String;
			a->U.Reference.Module = sm->Module;
			a->Next = (*llout).Assignments;
			(*llout).Assignments = a;
		    }
		}
	    }
	    if (llatt_1 != EXPORT_ALL) {
		for (s = llatt_1; s; s = s->Next) {
		    if (!FindAssignment((*llout).Assignments, eAssignment_Undefined,
			s->String, (*llout).Module))
			LLFAILED((&llstate_1.pos, "Exported symbol `%s' is undefined",
			    s->String));
		}
	    }
	    oldass = (*llout).Assignments;
	    for (a = (*llout).Assignments, aa = &(*llout).Assignments; a;
		a = a->Next, aa = &(*aa)->Next) {
		if (a->Type == eAssignment_NextPass)
		    break;
		*aa = DupAssignment(a);
		if (!FindAssignmentInCurrentPass(a->Next, 
		    a->Identifier, a->Module) &&
		    FindAssignmentInCurrentPass(oldass,
		    a->Identifier, a->Module) == a &&
		    !CmpModuleIdentifier(oldass, a->Module, (*llout).Module) &&
		    (llatt_1 == EXPORT_ALL || FindString(llatt_1, a->Identifier)))
		    (*aa)->Flags |= eAssignmentFlags_Exported;
	    }
	    *aa = a;
	
break;
}}}}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("ModuleBody", 2);
*llout = llstate_0;
break;
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("ModuleBody");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("ModuleBody", 1);
return 1;
failed1: LLDEBUG_LEAVE("ModuleBody", 0);
return 0;
}

int ll_Exports(XStrings *llret, LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("Exports");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("Exports", 1);
{LLSTATE llstate_1;
if (!llterm(T_EXPORTS, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
{LLSTATE llstate_2;XStrings llatt_2;
if (!ll_SymbolsExported(&llatt_2, &llstate_1, &llstate_2)) goto failed2;
{LLSTATE llstate_3;
if (!llterm(';', (LLSTYPE *)0, &llstate_2, &llstate_3)) goto failed2;
*llout = llstate_3;
{String_t *s, *t;
	    for (s = llatt_2; s && s->Next; s = s->Next) {
		for (t = s->Next; t; t = t->Next) {
		    if (!strcmp(s->String, t->String))
			LLFAILED((&llstate_2.pos, "Symbol `%s' has been exported twice",
			    s->String));
		}
	    }
	    (*llret) = llatt_2;
	
break;
}}}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("Exports", 2);
*llout = llstate_0;
{(*llret) = EXPORT_ALL;
	
break;
}
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("Exports");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("Exports", 1);
return 1;
failed1: LLDEBUG_LEAVE("Exports", 0);
return 0;
}

int ll_SymbolsExported(XStrings *llret, LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("SymbolsExported");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("SymbolsExported", 1);
{LLSTATE llstate_1;XStrings llatt_1;
if (!ll_SymbolList(&llatt_1, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = llatt_1;
	
break;
}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("SymbolsExported", 2);
*llout = llstate_0;
{(*llret) = NULL;
	
break;
}
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("SymbolsExported");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("SymbolsExported", 1);
return 1;
failed1: LLDEBUG_LEAVE("SymbolsExported", 0);
return 0;
}

int ll_Imports(XStringModules *llret, LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("Imports");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("Imports", 1);
{LLSTATE llstate_1;
if (!llterm(T_IMPORTS, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
{LLSTATE llstate_2;XStringModules llatt_2;
if (!ll_SymbolsImported(&llatt_2, &llstate_1, &llstate_2)) goto failed2;
{LLSTATE llstate_3;
if (!llterm(';', (LLSTYPE *)0, &llstate_2, &llstate_3)) goto failed2;
*llout = llstate_3;
{(*llret) = llatt_2;
	
break;
}}}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("Imports", 2);
*llout = llstate_0;
{(*llret) = IMPORT_ALL;
	
break;
}
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("Imports");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("Imports", 1);
return 1;
failed1: LLDEBUG_LEAVE("Imports", 0);
return 0;
}

int ll_SymbolsImported(XStringModules *llret, LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("SymbolsImported");

llstate_0 = *llin;
#undef failed
#define failed failed1
{LLSTATE llstate_1;XStringModules llatt_1;
if (!ll_SymbolsFromModule_ESeq(&llatt_1, &llstate_0, &llstate_1)) goto failed1;
*llout = llstate_1;
{(*llret) = llatt_1;
	
}}
LLDEBUG_LEAVE("SymbolsImported", 1);
return 1;
failed1: LLDEBUG_LEAVE("SymbolsImported", 0);
return 0;
}

int ll_SymbolsFromModule_ESeq(XStringModules *llret, LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("SymbolsFromModule_ESeq");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("SymbolsFromModule_ESeq", 1);
{LLSTATE llstate_1;XStringModules llatt_1;
if (!ll_SymbolsFromModule(&llatt_1, &llstate_0, &llstate_1)) goto failed2;
{LLSTATE llstate_2;XStringModules llatt_2;
if (!ll_SymbolsFromModule_ESeq(&llatt_2, &llstate_1, &llstate_2)) goto failed2;
*llout = llstate_2;
{StringModule_t *s, **ss;
	    for (s = llatt_1, ss = &(*llret); s; s = s->Next) {
		*ss = DupStringModule(s);
		ss = &(*ss)->Next;
	    }
	    *ss = llatt_2;
	
break;
}}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("SymbolsFromModule_ESeq", 2);
*llout = llstate_0;
{(*llret) = NULL;
	
break;
}
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("SymbolsFromModule_ESeq");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("SymbolsFromModule_ESeq", 1);
return 1;
failed1: LLDEBUG_LEAVE("SymbolsFromModule_ESeq", 0);
return 0;
}

int ll_SymbolsFromModule(XStringModules *llret, LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("SymbolsFromModule");

llstate_0 = *llin;
#undef failed
#define failed failed1
{LLSTATE llstate_1;XStrings llatt_1;
if (!ll_SymbolList(&llatt_1, &llstate_0, &llstate_1)) goto failed1;
{LLSTATE llstate_2;
if (!llterm(T_FROM, (LLSTYPE *)0, &llstate_1, &llstate_2)) goto failed1;
{LLSTATE llstate_3;XModuleIdentifier llatt_3;
if (!ll_GlobalModuleReference(&llatt_3, &llstate_2, &llstate_3)) goto failed1;
*llout = llstate_3;
{String_t *s, *t;
	    StringModule_t **ss;
	    for (s = llatt_1; s && s->Next; s = s->Next) {
		for (t = s->Next; t; t = t->Next) {
		    if (!strcmp(s->String, t->String))
			LLFAILED((&llstate_2.pos, "Symbol `%s' has been imported twice",
			    s->String));
		}
	    }
	    for (s = llatt_1, ss = &(*llret); s; s = s->Next) {
		*ss = NewStringModule();
		(*ss)->String = s->String;
		(*ss)->Module = llatt_3;
		ss = &(*ss)->Next;
	    }
	    *ss = NULL;
	
}}}}
LLDEBUG_LEAVE("SymbolsFromModule", 1);
return 1;
failed1: LLDEBUG_LEAVE("SymbolsFromModule", 0);
return 0;
}

int ll_GlobalModuleReference(XModuleIdentifier *llret, LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("GlobalModuleReference");

llstate_0 = *llin;
#undef failed
#define failed failed1
{LLSTATE llstate_1;XModuleIdentifier llatt_1;
if (!ll_modulereference(&llatt_1, &llstate_0, &llstate_1)) goto failed1;
{LLSTATE llstate_2;XValue llatt_2;
if (!ll_AssignedIdentifier(&llatt_2, &llstate_1, &llstate_2)) goto failed1;
*llout = llstate_2;
{(*llret) = NewModuleIdentifier();
	    (*llret)->Identifier = llatt_1->Identifier;
	    (*llret)->ObjectIdentifier = llatt_2;
	
}}}
LLDEBUG_LEAVE("GlobalModuleReference", 1);
return 1;
failed1: LLDEBUG_LEAVE("GlobalModuleReference", 0);
return 0;
}

int ll_AssignedIdentifier(XValue *llret, LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("AssignedIdentifier");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("AssignedIdentifier", 1);
{LLSTATE llstate_1;XValue llatt_1;
if (!ll_ObjectIdentifierValue(&llatt_1, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = llatt_1;
	
break;
}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("AssignedIdentifier", 2);
{LLSTATE llstate_1;XValue llatt_1;
if (!ll_DefinedValue(&llatt_1, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = llatt_1;
	
break;
}}
case 3: case -3:
LLDEBUG_ALTERNATIVE("AssignedIdentifier", 3);
*llout = llstate_0;
{(*llret) = NULL;
	
break;
}
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("AssignedIdentifier");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("AssignedIdentifier", 1);
return 1;
failed1: LLDEBUG_LEAVE("AssignedIdentifier", 0);
return 0;
}

int ll_SymbolList(XStrings *llret, LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("SymbolList");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("SymbolList", 1);
{LLSTATE llstate_1;XString llatt_1;
if (!ll_Symbol(&llatt_1, &llstate_0, &llstate_1)) goto failed2;
{LLSTATE llstate_2;
if (!llterm(',', (LLSTYPE *)0, &llstate_1, &llstate_2)) goto failed2;
{LLSTATE llstate_3;XStrings llatt_3;
if (!ll_SymbolList(&llatt_3, &llstate_2, &llstate_3)) goto failed2;
*llout = llstate_3;
{(*llret) = NewString();
	    (*llret)->String = llatt_1;
	    (*llret)->Next = llatt_3;
	
break;
}}}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("SymbolList", 2);
{LLSTATE llstate_1;XString llatt_1;
if (!ll_Symbol(&llatt_1, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = NewString();
	    (*llret)->String = llatt_1;
	
break;
}}
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("SymbolList");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("SymbolList", 1);
return 1;
failed1: LLDEBUG_LEAVE("SymbolList", 0);
return 0;
}

int ll_Symbol(XString *llret, LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("Symbol");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("Symbol", 1);
{LLSTATE llstate_1;XString llatt_1;
if (!ll_Reference(&llatt_1, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = llatt_1;
	
break;
}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("Symbol", 2);
{LLSTATE llstate_1;
if (!ll_ParameterizedReference(&llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{MyAbort();
	
break;
}}
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("Symbol");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("Symbol", 1);
return 1;
failed1: LLDEBUG_LEAVE("Symbol", 0);
return 0;
}

int ll_Reference(XString *llret, LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("Reference");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("Reference", 1);
{LLSTATE llstate_1;XString llatt_1;
if (!ll_ucsymbol(&llatt_1, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = llatt_1;
	
break;
}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("Reference", 2);
{LLSTATE llstate_1;XString llatt_1;
if (!llterm(T_lcsymbol, &lllval, &llstate_0, &llstate_1)) goto failed2;
llatt_1 = lllval._XString;
*llout = llstate_1;
{(*llret) = llatt_1;
	
break;
}}
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("Reference");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("Reference", 1);
return 1;
failed1: LLDEBUG_LEAVE("Reference", 0);
return 0;
}

int ll_AssignmentList(LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("AssignmentList");

llstate_0 = *llin;
#undef failed
#define failed failed1
{LLSTATE llstate_1;
if (!ll_Assignment(&llstate_0, &llstate_1)) goto failed1;
{LLSTATE llstate_2;
if (!ll_Assignment_ESeq(&llstate_1, &llstate_2)) goto failed1;
*llout = llstate_2;
}}
LLDEBUG_LEAVE("AssignmentList", 1);
return 1;
failed1: LLDEBUG_LEAVE("AssignmentList", 0);
return 0;
}

int ll_Assignment_ESeq(LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("Assignment_ESeq");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("Assignment_ESeq", 1);
{LLSTATE llstate_1;
if (!ll_Assignment(&llstate_0, &llstate_1)) goto failed2;
{LLSTATE llstate_2;
if (!ll_Assignment_ESeq(&llstate_1, &llstate_2)) goto failed2;
*llout = llstate_2;
break;
}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("Assignment_ESeq", 2);
*llout = llstate_0;
break;
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("Assignment_ESeq");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("Assignment_ESeq", 1);
return 1;
failed1: LLDEBUG_LEAVE("Assignment_ESeq", 0);
return 0;
}

int ll_Assignment(LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("Assignment");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("Assignment", 1);
{LLSTATE llstate_1;
if (!ll_TypeAssignment(&llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{LLCUTALL;
	
break;
}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("Assignment", 2);
{LLSTATE llstate_1;
if (!ll_ValueAssignment(&llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{LLCUTALL;
	
break;
}}
case 3: case -3:
LLDEBUG_ALTERNATIVE("Assignment", 3);
{LLSTATE llstate_1;
if (!ll_ValueSetTypeAssignment(&llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{LLCUTALL;
	
break;
}}
case 4: case -4:
LLDEBUG_ALTERNATIVE("Assignment", 4);
{LLSTATE llstate_1;
if (!ll_ObjectClassAssignment(&llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{LLCUTALL;
	
break;
}}
case 5: case -5:
LLDEBUG_ALTERNATIVE("Assignment", 5);
{LLSTATE llstate_1;
if (!ll_ObjectAssignment(&llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{LLCUTALL;
	
break;
}}
case 6: case -6:
LLDEBUG_ALTERNATIVE("Assignment", 6);
{LLSTATE llstate_1;
if (!ll_ObjectSetAssignment(&llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{LLCUTALL;
	
break;
}}
case 7: case -7:
LLDEBUG_ALTERNATIVE("Assignment", 7);
{LLSTATE llstate_1;
if (!ll_ParameterizedAssignment(&llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{LLCUTALL;
	
break;
}}
case 8: case -8:
LLDEBUG_ALTERNATIVE("Assignment", 8);
{LLSTATE llstate_1;
if (!ll_MacroDefinition(&llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{LLCUTALL;
	
break;
}}
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("Assignment");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("Assignment", 1);
return 1;
failed1: LLDEBUG_LEAVE("Assignment", 0);
return 0;
}

int ll_typereference(XType *llret, LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("typereference");

llstate_0 = *llin;
#undef failed
#define failed failed1
{LLSTATE llstate_1;XString llatt_1;
if (!ll_ucsymbol(&llatt_1, &llstate_0, &llstate_1)) goto failed1;
*llout = llstate_1;
{Assignment_t *ref;
	    UndefinedSymbol_t *u;
	    ref = FindAssignment((*llout).Assignments,
		eAssignment_Undefined, llatt_1, (*llout).Module);
	    if (!ref) {
		u = NewUndefinedSymbol(eUndefinedSymbol_SymbolNotDefined,
		    eAssignment_Type);
		u->U.Symbol.Module = (*llout).Module;
		u->U.Symbol.Identifier = llatt_1;
		u->Next = (*llout).Undefined;
		(*llout).Undefined = u;
	    } else if (GetAssignmentType((*llout).Assignments, ref) !=
		eAssignment_Type)
		LLFAILED((&llstate_1.pos, "Symbol `%s' is not a typereference", llatt_1));
	    (*llret) = NewType(eType_Reference);
	    if (ref && ref->U.Type.Type)
	    {
	    	int fPublic = ref->U.Type.Type->PrivateDirectives.fPublic;
	    	ref->U.Type.Type->PrivateDirectives.fPublic = 0;
	    	PropagateReferenceTypePrivateDirectives((*llret), &(ref->U.Type.Type->PrivateDirectives));
	    	ref->U.Type.Type->PrivateDirectives.fPublic = fPublic;
	    }
	    (*llret)->U.Reference.Identifier = llatt_1;
	    (*llret)->U.Reference.Module = (*llout).Module;
	
}}
LLDEBUG_LEAVE("typereference", 1);
return 1;
failed1: LLDEBUG_LEAVE("typereference", 0);
return 0;
}

int ll_Externaltypereference(XType *llret, LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("Externaltypereference");

llstate_0 = *llin;
#undef failed
#define failed failed1
{LLSTATE llstate_1;XModuleIdentifier llatt_1;
if (!ll_modulereference(&llatt_1, &llstate_0, &llstate_1)) goto failed1;
{LLSTATE llstate_2;
if (!llterm('.', (LLSTYPE *)0, &llstate_1, &llstate_2)) goto failed1;
{LLSTATE llstate_3;XString llatt_3;
if (!ll_ucsymbol(&llatt_3, &llstate_2, &llstate_3)) goto failed1;
*llout = llstate_3;
{Assignment_t *ref;
	    UndefinedSymbol_t *u;
	    if ((*llout).Imported != IMPORT_ALL &&
		!FindStringModule((*llout).Assignments, (*llout).Imported, llatt_3, llatt_1))
		LLFAILED((&llstate_1.pos, "Symbol `%s.%s' has not been imported",
		    llatt_1->Identifier, llatt_3));
	    ref = FindExportedAssignment((*llout).Assignments,
		eAssignment_Type, llatt_3, llatt_1);
	    if (!ref) {
		if (FindAssignment((*llout).Assignments,
		    eAssignment_Type, llatt_3, llatt_1)) {
		    u = NewUndefinedSymbol(eUndefinedSymbol_SymbolNotExported,
			eAssignment_Type);
		} else {
		    u = NewUndefinedSymbol(eUndefinedSymbol_SymbolNotDefined,
			eAssignment_Type);
		}
		u->U.Symbol.Module = llatt_1;
		u->U.Symbol.Identifier = llatt_3;
		u->Next = (*llout).Undefined;
		(*llout).Undefined = u;
	    } else if (GetAssignmentType((*llout).Assignments, ref) !=
		eAssignment_Type)
		LLFAILED((&llstate_1.pos, "Symbol `%s' is not a typereference", llatt_1));
	    (*llret) = NewType(eType_Reference);
	    (*llret)->U.Reference.Identifier = llatt_3;
	    (*llret)->U.Reference.Module = llatt_1;
	
}}}}
LLDEBUG_LEAVE("Externaltypereference", 1);
return 1;
failed1: LLDEBUG_LEAVE("Externaltypereference", 0);
return 0;
}

int ll_valuereference(XValue *llret, LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("valuereference");

llstate_0 = *llin;
#undef failed
#define failed failed1
{LLSTATE llstate_1;XString llatt_1;
if (!llterm(T_lcsymbol, &lllval, &llstate_0, &llstate_1)) goto failed1;
llatt_1 = lllval._XString;
*llout = llstate_1;
{Assignment_t *ref;
	    UndefinedSymbol_t *u;
	    ref = FindAssignment((*llout).Assignments,
		eAssignment_Undefined, llatt_1, (*llout).Module);
	    if (!ref) {
		u = NewUndefinedSymbol(eUndefinedSymbol_SymbolNotDefined,
		    eAssignment_Value);
		u->U.Symbol.Module = (*llout).Module;
		u->U.Symbol.Identifier = llatt_1;
		u->Next = (*llout).Undefined;
		(*llout).Undefined = u;
	    } else if (GetAssignmentType((*llout).Assignments, ref) !=
		eAssignment_Value)
		LLFAILED((&llstate_1.pos, "Symbol `%s' is not a valuereference", llatt_1));
	    (*llret) = NewValue(NULL, NULL);
	    (*llret)->U.Reference.Identifier = llatt_1;
	    (*llret)->U.Reference.Module = (*llout).Module;
	
}}
LLDEBUG_LEAVE("valuereference", 1);
return 1;
failed1: LLDEBUG_LEAVE("valuereference", 0);
return 0;
}

int ll_Externalvaluereference(XValue *llret, LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("Externalvaluereference");

llstate_0 = *llin;
#undef failed
#define failed failed1
{LLSTATE llstate_1;XModuleIdentifier llatt_1;
if (!ll_modulereference(&llatt_1, &llstate_0, &llstate_1)) goto failed1;
{LLSTATE llstate_2;
if (!llterm('.', (LLSTYPE *)0, &llstate_1, &llstate_2)) goto failed1;
{LLSTATE llstate_3;XString llatt_3;
if (!llterm(T_lcsymbol, &lllval, &llstate_2, &llstate_3)) goto failed1;
llatt_3 = lllval._XString;
*llout = llstate_3;
{Assignment_t *ref;
	    UndefinedSymbol_t *u;
	    if ((*llout).Imported != IMPORT_ALL &&
		!FindStringModule((*llout).Assignments, (*llout).Imported, llatt_3, llatt_1))
		LLFAILED((&llstate_1.pos, "Symbol `%s.%s' has not been imported",
		    llatt_1->Identifier, llatt_3));
	    ref = FindExportedAssignment((*llout).Assignments,
		eAssignment_Value, llatt_3, llatt_1);
	    if (!ref) {
		if (FindAssignment((*llout).Assignments,
		    eAssignment_Value, llatt_3, llatt_1)) {
		    u = NewUndefinedSymbol(eUndefinedSymbol_SymbolNotExported,
			eAssignment_Value);
		} else {
		    u = NewUndefinedSymbol(eUndefinedSymbol_SymbolNotDefined,
			eAssignment_Value);
		}
		u->U.Symbol.Module = llatt_1;
		u->U.Symbol.Identifier = llatt_3;
		u->Next = (*llout).Undefined;
		(*llout).Undefined = u;
	    } else if (GetAssignmentType((*llout).Assignments, ref) !=
		eAssignment_Value)
		LLFAILED((&llstate_1.pos, "Symbol `%s' is not a valuereference", llatt_1));
	    (*llret) = NewValue(NULL, NULL);
	    (*llret)->U.Reference.Identifier = llatt_3;
	    (*llret)->U.Reference.Module = llatt_1;
	
}}}}
LLDEBUG_LEAVE("Externalvaluereference", 1);
return 1;
failed1: LLDEBUG_LEAVE("Externalvaluereference", 0);
return 0;
}

int ll_objectclassreference(XObjectClass *llret, LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("objectclassreference");

llstate_0 = *llin;
#undef failed
#define failed failed1
{LLSTATE llstate_1;XString llatt_1;
if (!ll_ocsymbol(&llatt_1, &llstate_0, &llstate_1)) goto failed1;
*llout = llstate_1;
{Assignment_t *ref;
	    UndefinedSymbol_t *u;
	    ref = FindAssignment((*llout).Assignments,
		eAssignment_Undefined, llatt_1, (*llout).Module);
	    if (!ref) {
		u = NewUndefinedSymbol(eUndefinedSymbol_SymbolNotDefined,
		    eAssignment_ObjectClass);
		u->U.Symbol.Module = (*llout).Module;
		u->U.Symbol.Identifier = llatt_1;
		u->Next = (*llout).Undefined;
		(*llout).Undefined = u;
	    } else if (GetAssignmentType((*llout).Assignments, ref) !=
		eAssignment_ObjectClass)
		LLFAILED((&llstate_1.pos, "Symbol `%s' is not an objectclassreference", llatt_1));
	    (*llret) = NewObjectClass(eObjectClass_Reference);
	    (*llret)->U.Reference.Identifier = llatt_1;
	    (*llret)->U.Reference.Module = (*llout).Module;
	
}}
LLDEBUG_LEAVE("objectclassreference", 1);
return 1;
failed1: LLDEBUG_LEAVE("objectclassreference", 0);
return 0;
}

int ll_ExternalObjectClassReference(XObjectClass *llret, LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("ExternalObjectClassReference");

llstate_0 = *llin;
#undef failed
#define failed failed1
{LLSTATE llstate_1;XModuleIdentifier llatt_1;
if (!ll_modulereference(&llatt_1, &llstate_0, &llstate_1)) goto failed1;
{LLSTATE llstate_2;
if (!llterm('.', (LLSTYPE *)0, &llstate_1, &llstate_2)) goto failed1;
{LLSTATE llstate_3;XString llatt_3;
if (!ll_ocsymbol(&llatt_3, &llstate_2, &llstate_3)) goto failed1;
*llout = llstate_3;
{Assignment_t *ref;
	    UndefinedSymbol_t *u;
	    if ((*llout).Imported != IMPORT_ALL &&
		!FindStringModule((*llout).Assignments, (*llout).Imported, llatt_3, llatt_1))
		LLFAILED((&llstate_1.pos, "Symbol `%s.%s' has not been imported",
		    llatt_1->Identifier, llatt_3));
	    ref = FindExportedAssignment((*llout).Assignments,
		eAssignment_ObjectClass, llatt_3, llatt_1);
	    if (!ref) {
		if (FindAssignment((*llout).Assignments,
		    eAssignment_ObjectClass, llatt_3, llatt_1)) {
		    u = NewUndefinedSymbol(eUndefinedSymbol_SymbolNotExported,
			eAssignment_ObjectClass);
		} else {
		    u = NewUndefinedSymbol(eUndefinedSymbol_SymbolNotDefined,
			eAssignment_ObjectClass);
		}
		u->U.Symbol.Module = llatt_1;
		u->U.Symbol.Identifier = llatt_3;
		u->Next = (*llout).Undefined;
		(*llout).Undefined = u;
	    } else if (GetAssignmentType((*llout).Assignments, ref) !=
		eAssignment_ObjectClass)
		LLFAILED((&llstate_1.pos, "Symbol `%s' is not an objectclassreference", llatt_1));
	    (*llret) = NewObjectClass(eObjectClass_Reference);
	    (*llret)->U.Reference.Identifier = llatt_3;
	    (*llret)->U.Reference.Module = llatt_1;
	
}}}}
LLDEBUG_LEAVE("ExternalObjectClassReference", 1);
return 1;
failed1: LLDEBUG_LEAVE("ExternalObjectClassReference", 0);
return 0;
}

int ll_objectreference(XObject *llret, LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("objectreference");

llstate_0 = *llin;
#undef failed
#define failed failed1
{LLSTATE llstate_1;XString llatt_1;
if (!llterm(T_lcsymbol, &lllval, &llstate_0, &llstate_1)) goto failed1;
llatt_1 = lllval._XString;
*llout = llstate_1;
{Assignment_t *ref;
	    UndefinedSymbol_t *u;
	    ref = FindAssignment((*llout).Assignments,
		eAssignment_Undefined, llatt_1, (*llout).Module);
	    if (!ref) {
		u = NewUndefinedSymbol(eUndefinedSymbol_SymbolNotDefined,
		    eAssignment_Object);
		u->U.Symbol.Module = (*llout).Module;
		u->U.Symbol.Identifier = llatt_1;
		u->Next = (*llout).Undefined;
		(*llout).Undefined = u;
	    } else if (GetAssignmentType((*llout).Assignments, ref) !=
		eAssignment_Object)
		LLFAILED((&llstate_1.pos, "Symbol `%s' is not an objectreference", llatt_1));
	    (*llret) = NewObject(eObject_Reference);
	    (*llret)->U.Reference.Identifier = llatt_1;
	    (*llret)->U.Reference.Module = (*llout).Module;
	
}}
LLDEBUG_LEAVE("objectreference", 1);
return 1;
failed1: LLDEBUG_LEAVE("objectreference", 0);
return 0;
}

int ll_ExternalObjectReference(XObject *llret, LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("ExternalObjectReference");

llstate_0 = *llin;
#undef failed
#define failed failed1
{LLSTATE llstate_1;XModuleIdentifier llatt_1;
if (!ll_modulereference(&llatt_1, &llstate_0, &llstate_1)) goto failed1;
{LLSTATE llstate_2;
if (!llterm('.', (LLSTYPE *)0, &llstate_1, &llstate_2)) goto failed1;
{LLSTATE llstate_3;XString llatt_3;
if (!llterm(T_lcsymbol, &lllval, &llstate_2, &llstate_3)) goto failed1;
llatt_3 = lllval._XString;
*llout = llstate_3;
{Assignment_t *ref;
	    UndefinedSymbol_t *u;
	    if ((*llout).Imported != IMPORT_ALL &&
		!FindStringModule((*llout).Assignments, (*llout).Imported, llatt_3, llatt_1))
		LLFAILED((&llstate_1.pos, "Symbol `%s.%s' has not been imported",
		    llatt_1->Identifier, llatt_3));
	    ref = FindExportedAssignment((*llout).Assignments,
		eAssignment_Object, llatt_3, llatt_1);
	    if (!ref) {
		if (FindAssignment((*llout).Assignments,
		    eAssignment_Object, llatt_3, llatt_1)) {
		    u = NewUndefinedSymbol(eUndefinedSymbol_SymbolNotExported,
			eAssignment_Object);
		} else {
		    u = NewUndefinedSymbol(eUndefinedSymbol_SymbolNotDefined,
			eAssignment_Object);
		}
		u->U.Symbol.Module = llatt_1;
		u->U.Symbol.Identifier = llatt_3;
		u->Next = (*llout).Undefined;
		(*llout).Undefined = u;
	    } else if (GetAssignmentType((*llout).Assignments, ref) !=
		eAssignment_Object)
		LLFAILED((&llstate_1.pos, "Symbol `%s' is not an objectreference", llatt_1));
	    (*llret) = NewObject(eObject_Reference);
	    (*llret)->U.Reference.Identifier = llatt_3;
	    (*llret)->U.Reference.Module = llatt_1;
	
}}}}
LLDEBUG_LEAVE("ExternalObjectReference", 1);
return 1;
failed1: LLDEBUG_LEAVE("ExternalObjectReference", 0);
return 0;
}

int ll_objectsetreference(XObjectSet *llret, LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("objectsetreference");

llstate_0 = *llin;
#undef failed
#define failed failed1
{LLSTATE llstate_1;XString llatt_1;
if (!ll_ucsymbol(&llatt_1, &llstate_0, &llstate_1)) goto failed1;
*llout = llstate_1;
{Assignment_t *ref;
	    UndefinedSymbol_t *u;
	    ref = FindAssignment((*llout).Assignments,
		eAssignment_Undefined, llatt_1, (*llout).Module);
	    if (!ref) {
		u = NewUndefinedSymbol(eUndefinedSymbol_SymbolNotDefined,
		    eAssignment_ObjectSet);
		u->U.Symbol.Module = (*llout).Module;
		u->U.Symbol.Identifier = llatt_1;
		u->Next = (*llout).Undefined;
		(*llout).Undefined = u;
	    } else if (GetAssignmentType((*llout).Assignments, ref) !=
		eAssignment_ObjectSet)
		LLFAILED((&llstate_1.pos, "Symbol `%s' is not an objectsetreference", llatt_1));
	    (*llret) = NewObjectSet(eObjectSet_Reference);
	    (*llret)->U.Reference.Identifier = llatt_1;
	    (*llret)->U.Reference.Module = (*llout).Module;
	
}}
LLDEBUG_LEAVE("objectsetreference", 1);
return 1;
failed1: LLDEBUG_LEAVE("objectsetreference", 0);
return 0;
}

int ll_ExternalObjectSetReference(XObjectSet *llret, LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("ExternalObjectSetReference");

llstate_0 = *llin;
#undef failed
#define failed failed1
{LLSTATE llstate_1;XModuleIdentifier llatt_1;
if (!ll_modulereference(&llatt_1, &llstate_0, &llstate_1)) goto failed1;
{LLSTATE llstate_2;
if (!llterm('.', (LLSTYPE *)0, &llstate_1, &llstate_2)) goto failed1;
{LLSTATE llstate_3;XString llatt_3;
if (!ll_ucsymbol(&llatt_3, &llstate_2, &llstate_3)) goto failed1;
*llout = llstate_3;
{Assignment_t *ref;
	    UndefinedSymbol_t *u;
	    if ((*llout).Imported != IMPORT_ALL &&
		!FindStringModule((*llout).Assignments, (*llout).Imported, llatt_3, llatt_1))
		LLFAILED((&llstate_1.pos, "Symbol `%s.%s' has not been imported",
		    llatt_1->Identifier, llatt_3));
	    ref = FindExportedAssignment((*llout).Assignments,
		eAssignment_ObjectSet, llatt_3, llatt_1);
	    if (!ref) {
		if (FindAssignment((*llout).Assignments,
		    eAssignment_ObjectSet, llatt_3, llatt_1)) {
		    u = NewUndefinedSymbol(eUndefinedSymbol_SymbolNotExported,
			eAssignment_ObjectSet);
		} else {
		    u = NewUndefinedSymbol(eUndefinedSymbol_SymbolNotDefined,
			eAssignment_ObjectSet);
		}
		u->U.Symbol.Module = llatt_1;
		u->U.Symbol.Identifier = llatt_3;
		u->Next = (*llout).Undefined;
		(*llout).Undefined = u;
	    } else if (GetAssignmentType((*llout).Assignments, ref) !=
		eAssignment_ObjectSet)
		LLFAILED((&llstate_1.pos, "Symbol `%s' is not an objectsetreference", llatt_1));
	    (*llret) = NewObjectSet(eObjectSet_Reference);
	    (*llret)->U.Reference.Identifier = llatt_3;
	    (*llret)->U.Reference.Module = llatt_1;
	
}}}}
LLDEBUG_LEAVE("ExternalObjectSetReference", 1);
return 1;
failed1: LLDEBUG_LEAVE("ExternalObjectSetReference", 0);
return 0;
}

int ll_macroreference(XMacro *llret, LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("macroreference");

llstate_0 = *llin;
#undef failed
#define failed failed1
{LLSTATE llstate_1;XString llatt_1;
if (!ll_ocsymbol(&llatt_1, &llstate_0, &llstate_1)) goto failed1;
*llout = llstate_1;
{Assignment_t *ref;
	    UndefinedSymbol_t *u;
	    ref = FindAssignment((*llout).Assignments,
		eAssignment_Undefined, llatt_1, (*llout).Module);
	    if (!ref) {
		u = NewUndefinedSymbol(eUndefinedSymbol_SymbolNotDefined,
		    eAssignment_Macro);
		u->U.Symbol.Module = (*llout).Module;
		u->U.Symbol.Identifier = llatt_1;
		u->Next = (*llout).Undefined;
		(*llout).Undefined = u;
	    } else if (GetAssignmentType((*llout).Assignments, ref) !=
		eAssignment_Macro)
		LLFAILED((&llstate_1.pos, "Symbol `%s' is not an macroreference", llatt_1));
	    (*llret) = NewMacro(eMacro_Reference);
	    (*llret)->U.Reference.Identifier = llatt_1;
	    (*llret)->U.Reference.Module = (*llout).Module;
	
}}
LLDEBUG_LEAVE("macroreference", 1);
return 1;
failed1: LLDEBUG_LEAVE("macroreference", 0);
return 0;
}

int ll_Externalmacroreference(XMacro *llret, LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("Externalmacroreference");

llstate_0 = *llin;
#undef failed
#define failed failed1
{LLSTATE llstate_1;XModuleIdentifier llatt_1;
if (!ll_modulereference(&llatt_1, &llstate_0, &llstate_1)) goto failed1;
{LLSTATE llstate_2;
if (!llterm('.', (LLSTYPE *)0, &llstate_1, &llstate_2)) goto failed1;
{LLSTATE llstate_3;XString llatt_3;
if (!ll_ucsymbol(&llatt_3, &llstate_2, &llstate_3)) goto failed1;
*llout = llstate_3;
{Assignment_t *ref;
	    UndefinedSymbol_t *u;
	    if ((*llout).Imported != IMPORT_ALL &&
		!FindStringModule((*llout).Assignments, (*llout).Imported, llatt_3, llatt_1))
		LLFAILED((&llstate_1.pos, "Symbol `%s.%s' has not been imported",
		    llatt_1->Identifier, llatt_3));
	    ref = FindExportedAssignment((*llout).Assignments,
		eAssignment_Macro, llatt_3, llatt_1);
	    if (!ref) {
		if (FindAssignment((*llout).Assignments,
		    eAssignment_Macro, llatt_3, llatt_1)) {
		    u = NewUndefinedSymbol(eUndefinedSymbol_SymbolNotExported,
			eAssignment_Macro);
		} else {
		    u = NewUndefinedSymbol(eUndefinedSymbol_SymbolNotDefined,
			eAssignment_Macro);
		}
		u->U.Symbol.Module = llatt_1;
		u->U.Symbol.Identifier = llatt_3;
		u->Next = (*llout).Undefined;
		(*llout).Undefined = u;
	    } else if (GetAssignmentType((*llout).Assignments, ref) !=
		eAssignment_Macro)
		LLFAILED((&llstate_1.pos, "Symbol `%s' is not an macroreference", llatt_1));
	    (*llret) = NewMacro(eMacro_Reference);
	    (*llret)->U.Reference.Identifier = llatt_3;
	    (*llret)->U.Reference.Module = llatt_1;
	
}}}}
LLDEBUG_LEAVE("Externalmacroreference", 1);
return 1;
failed1: LLDEBUG_LEAVE("Externalmacroreference", 0);
return 0;
}

int ll_localtypereference(XString *llret, LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("localtypereference");

llstate_0 = *llin;
#undef failed
#define failed failed1
{LLSTATE llstate_1;XString llatt_1;
if (!ll_ucsymbol(&llatt_1, &llstate_0, &llstate_1)) goto failed1;
*llout = llstate_1;
{(*llret) = llatt_1;
	
}}
LLDEBUG_LEAVE("localtypereference", 1);
return 1;
failed1: LLDEBUG_LEAVE("localtypereference", 0);
return 0;
}

int ll_localvaluereference(XString *llret, LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("localvaluereference");

llstate_0 = *llin;
#undef failed
#define failed failed1
{LLSTATE llstate_1;XString llatt_1;
if (!ll_ucsymbol(&llatt_1, &llstate_0, &llstate_1)) goto failed1;
*llout = llstate_1;
{(*llret) = llatt_1;
	
}}
LLDEBUG_LEAVE("localvaluereference", 1);
return 1;
failed1: LLDEBUG_LEAVE("localvaluereference", 0);
return 0;
}

int ll_productionreference(XString *llret, LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("productionreference");

llstate_0 = *llin;
#undef failed
#define failed failed1
{LLSTATE llstate_1;XString llatt_1;
if (!ll_ucsymbol(&llatt_1, &llstate_0, &llstate_1)) goto failed1;
*llout = llstate_1;
{(*llret) = llatt_1;
	
}}
LLDEBUG_LEAVE("productionreference", 1);
return 1;
failed1: LLDEBUG_LEAVE("productionreference", 0);
return 0;
}

int ll_modulereference(XModuleIdentifier *llret, LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("modulereference");

llstate_0 = *llin;
#undef failed
#define failed failed1
{LLSTATE llstate_1;XString llatt_1;
if (!ll_ucsymbol(&llatt_1, &llstate_0, &llstate_1)) goto failed1;
*llout = llstate_1;
{(*llret) = NewModuleIdentifier();
	    (*llret)->Identifier = llatt_1;
	
}}
LLDEBUG_LEAVE("modulereference", 1);
return 1;
failed1: LLDEBUG_LEAVE("modulereference", 0);
return 0;
}

int ll_typefieldreference(XString *llret, LLSTATE *llin, LLSTATE *llout, XObjectClass llarg_oc)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("typefieldreference");

llstate_0 = *llin;
#undef failed
#define failed failed1
{LLSTATE llstate_1;XString llatt_1;
if (!llterm(T_ampucsymbol, &lllval, &llstate_0, &llstate_1)) goto failed1;
llatt_1 = lllval._XString;
*llout = llstate_1;
{FieldSpec_t *fs;
	    FieldSpecs_e fe;
	    ObjectClass_t *oc;
	    UndefinedSymbol_t *u;
	    oc = GetObjectClass((*llout).Assignments, llarg_oc);
	    fs = oc ? FindFieldSpec(oc->U.ObjectClass.FieldSpec, llatt_1) : NULL;
	    fe = GetFieldSpecType((*llout).Assignments, fs);
	    if (fe == eFieldSpec_Undefined) {
		if (llarg_oc) {
		    u = NewUndefinedField(eUndefinedSymbol_FieldNotDefined,
			llarg_oc, eSetting_Type);
		    u->U.Field.Module = (*llout).Module;
		    u->U.Field.Identifier = llatt_1;
		    u->Next = (*llout).Undefined;
		    (*llout).Undefined = u;
		}
	    } else if (fe != eFieldSpec_Type)
		LLFAILED((&llstate_1.pos, "%s is not a typefieldreference", llatt_1));
	    (*llret) = llatt_1;
	
}}
LLDEBUG_LEAVE("typefieldreference", 1);
return 1;
failed1: LLDEBUG_LEAVE("typefieldreference", 0);
return 0;
}

int ll_valuefieldreference(XString *llret, LLSTATE *llin, LLSTATE *llout, XObjectClass llarg_oc)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("valuefieldreference");

llstate_0 = *llin;
#undef failed
#define failed failed1
{LLSTATE llstate_1;XString llatt_1;
if (!llterm(T_amplcsymbol, &lllval, &llstate_0, &llstate_1)) goto failed1;
llatt_1 = lllval._XString;
*llout = llstate_1;
{FieldSpec_t *fs;
	    FieldSpecs_e fe;
	    ObjectClass_t *oc;
	    UndefinedSymbol_t *u;
	    oc = GetObjectClass((*llout).Assignments, llarg_oc);
	    fs = oc ? FindFieldSpec(oc->U.ObjectClass.FieldSpec, llatt_1) : NULL;
	    fe = GetFieldSpecType((*llout).Assignments, fs);
	    if (fe == eFieldSpec_Undefined) {
		if (llarg_oc) {
		    u = NewUndefinedField(eUndefinedSymbol_FieldNotDefined,
			llarg_oc, eSetting_Value);
		    u->U.Field.Module = (*llout).Module;
		    u->U.Field.Identifier = llatt_1;
		    u->Next = (*llout).Undefined;
		    (*llout).Undefined = u;
		}
	    } else if (fe != eFieldSpec_FixedTypeValue &&
		fe != eFieldSpec_VariableTypeValue)
		LLFAILED((&llstate_1.pos, "%s is not a valuefieldreference", llatt_1));
	    (*llret) = llatt_1;
	
}}
LLDEBUG_LEAVE("valuefieldreference", 1);
return 1;
failed1: LLDEBUG_LEAVE("valuefieldreference", 0);
return 0;
}

int ll_valuesetfieldreference(XString *llret, LLSTATE *llin, LLSTATE *llout, XObjectClass llarg_oc)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("valuesetfieldreference");

llstate_0 = *llin;
#undef failed
#define failed failed1
{LLSTATE llstate_1;XString llatt_1;
if (!llterm(T_ampucsymbol, &lllval, &llstate_0, &llstate_1)) goto failed1;
llatt_1 = lllval._XString;
*llout = llstate_1;
{FieldSpec_t *fs;
	    FieldSpecs_e fe;
	    ObjectClass_t *oc;
	    UndefinedSymbol_t *u;
	    oc = GetObjectClass((*llout).Assignments, llarg_oc);
	    fs = oc ? FindFieldSpec(oc->U.ObjectClass.FieldSpec, llatt_1) : NULL;
	    fe = GetFieldSpecType((*llout).Assignments, fs);
	    if (fe == eFieldSpec_Undefined) {
		if (llarg_oc) {
		    u = NewUndefinedField(eUndefinedSymbol_FieldNotDefined,
			llarg_oc, eSetting_ValueSet);
		    u->U.Field.Module = (*llout).Module;
		    u->U.Field.Identifier = llatt_1;
		    u->Next = (*llout).Undefined;
		    (*llout).Undefined = u;
		}
	    } else if (fe != eFieldSpec_FixedTypeValueSet &&
		fe != eFieldSpec_VariableTypeValueSet)
		LLFAILED((&llstate_1.pos, "%s is not a valuesetfieldreference", llatt_1));
	    (*llret) = llatt_1;
	
}}
LLDEBUG_LEAVE("valuesetfieldreference", 1);
return 1;
failed1: LLDEBUG_LEAVE("valuesetfieldreference", 0);
return 0;
}

int ll_objectfieldreference(XString *llret, LLSTATE *llin, LLSTATE *llout, XObjectClass llarg_oc)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("objectfieldreference");

llstate_0 = *llin;
#undef failed
#define failed failed1
{LLSTATE llstate_1;XString llatt_1;
if (!llterm(T_amplcsymbol, &lllval, &llstate_0, &llstate_1)) goto failed1;
llatt_1 = lllval._XString;
*llout = llstate_1;
{FieldSpec_t *fs;
	    FieldSpecs_e fe;
	    ObjectClass_t *oc;
	    UndefinedSymbol_t *u;
	    oc = GetObjectClass((*llout).Assignments, llarg_oc);
	    fs = oc ? FindFieldSpec(oc->U.ObjectClass.FieldSpec, llatt_1) : NULL;
	    fe = GetFieldSpecType((*llout).Assignments, fs);
	    if (fe == eFieldSpec_Undefined) {
		if (llarg_oc) {
		    u = NewUndefinedField(eUndefinedSymbol_FieldNotDefined,
			llarg_oc, eSetting_Object);
		    u->U.Field.Module = (*llout).Module;
		    u->U.Field.Identifier = llatt_1;
		    u->Next = (*llout).Undefined;
		    (*llout).Undefined = u;
		}
	    } else if (fe != eFieldSpec_Object)
		LLFAILED((&llstate_1.pos, "%s is not a objectfieldreference", llatt_1));
	    (*llret) = llatt_1;
	
}}
LLDEBUG_LEAVE("objectfieldreference", 1);
return 1;
failed1: LLDEBUG_LEAVE("objectfieldreference", 0);
return 0;
}

int ll_objectsetfieldreference(XString *llret, LLSTATE *llin, LLSTATE *llout, XObjectClass llarg_oc)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("objectsetfieldreference");

llstate_0 = *llin;
#undef failed
#define failed failed1
{LLSTATE llstate_1;XString llatt_1;
if (!llterm(T_ampucsymbol, &lllval, &llstate_0, &llstate_1)) goto failed1;
llatt_1 = lllval._XString;
*llout = llstate_1;
{FieldSpec_t *fs;
	    FieldSpecs_e fe;
	    ObjectClass_t *oc;
	    UndefinedSymbol_t *u;
	    oc = GetObjectClass((*llout).Assignments, llarg_oc);
	    fs = oc ? FindFieldSpec(oc->U.ObjectClass.FieldSpec, llatt_1) : NULL;
	    fe = GetFieldSpecType((*llout).Assignments, fs);
	    if (fe == eFieldSpec_Undefined) {
		if (llarg_oc) {
		    u = NewUndefinedField(eUndefinedSymbol_FieldNotDefined,
			llarg_oc, eSetting_ObjectSet);
		    u->U.Field.Module = (*llout).Module;
		    u->U.Field.Identifier = llatt_1;
		    u->Next = (*llout).Undefined;
		    (*llout).Undefined = u;
		}
	    } else if (fe != eFieldSpec_ObjectSet)
		LLFAILED((&llstate_1.pos, "%s is not a objectsetfieldreference", llatt_1));
	    (*llret) = llatt_1;
	
}}
LLDEBUG_LEAVE("objectsetfieldreference", 1);
return 1;
failed1: LLDEBUG_LEAVE("objectsetfieldreference", 0);
return 0;
}

int ll_word(XString *llret, LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("word");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("word", 1);
{LLSTATE llstate_1;XString llatt_1;
if (!ll_ucsymbol(&llatt_1, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = llatt_1;
	
break;
}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("word", 2);
{LLSTATE llstate_1;
if (!llterm(T_ABSENT, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = "ABSENT";
	
break;
}}
case 3: case -3:
LLDEBUG_ALTERNATIVE("word", 3);
{LLSTATE llstate_1;
if (!llterm(T_ABSTRACT_SYNTAX, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = "ABSTRACT-SYNTAX";
	
break;
}}
case 4: case -4:
LLDEBUG_ALTERNATIVE("word", 4);
{LLSTATE llstate_1;
if (!llterm(T_ALL, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = "ALL";
	
break;
}}
case 5: case -5:
LLDEBUG_ALTERNATIVE("word", 5);
{LLSTATE llstate_1;
if (!llterm(T_ANY, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = "ANY";
	
break;
}}
case 6: case -6:
LLDEBUG_ALTERNATIVE("word", 6);
{LLSTATE llstate_1;
if (!llterm(T_APPLICATION, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = "APPLICATION";
	
break;
}}
case 7: case -7:
LLDEBUG_ALTERNATIVE("word", 7);
{LLSTATE llstate_1;
if (!llterm(T_AUTOMATIC, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = "AUTOMATIC";
	
break;
}}
case 8: case -8:
LLDEBUG_ALTERNATIVE("word", 8);
{LLSTATE llstate_1;
if (!llterm(T_BEGIN, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = "BEGIN";
	
break;
}}
case 9: case -9:
LLDEBUG_ALTERNATIVE("word", 9);
{LLSTATE llstate_1;
if (!llterm(T_BMPString, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = "BMPString";
	
break;
}}
case 10: case -10:
LLDEBUG_ALTERNATIVE("word", 10);
{LLSTATE llstate_1;
if (!llterm(T_BY, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = "BY";
	
break;
}}
case 11: case -11:
LLDEBUG_ALTERNATIVE("word", 11);
{LLSTATE llstate_1;
if (!llterm(T_CLASS, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = "CLASS";
	
break;
}}
case 12: case -12:
LLDEBUG_ALTERNATIVE("word", 12);
{LLSTATE llstate_1;
if (!llterm(T_COMPONENT, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = "COMPONENT";
	
break;
}}
case 13: case -13:
LLDEBUG_ALTERNATIVE("word", 13);
{LLSTATE llstate_1;
if (!llterm(T_COMPONENTS, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = "COMPONENTS";
	
break;
}}
case 14: case -14:
LLDEBUG_ALTERNATIVE("word", 14);
{LLSTATE llstate_1;
if (!llterm(T_CONSTRAINED, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = "CONSTRAINED";
	
break;
}}
case 15: case -15:
LLDEBUG_ALTERNATIVE("word", 15);
{LLSTATE llstate_1;
if (!llterm(T_DEFAULT, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = "DEFAULT";
	
break;
}}
case 16: case -16:
LLDEBUG_ALTERNATIVE("word", 16);
{LLSTATE llstate_1;
if (!llterm(T_DEFINED, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = "DEFINED";
	
break;
}}
case 17: case -17:
LLDEBUG_ALTERNATIVE("word", 17);
{LLSTATE llstate_1;
if (!llterm(T_DEFINITIONS, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = "DEFINITIONS";
	
break;
}}
case 18: case -18:
LLDEBUG_ALTERNATIVE("word", 18);
{LLSTATE llstate_1;
if (!llterm(T_empty, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = "empty";
	
break;
}}
case 19: case -19:
LLDEBUG_ALTERNATIVE("word", 19);
{LLSTATE llstate_1;
if (!llterm(T_EXCEPT, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = "EXCEPT";
	
break;
}}
case 20: case -20:
LLDEBUG_ALTERNATIVE("word", 20);
{LLSTATE llstate_1;
if (!llterm(T_EXPLICIT, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = "EXPLICIT";
	
break;
}}
case 21: case -21:
LLDEBUG_ALTERNATIVE("word", 21);
{LLSTATE llstate_1;
if (!llterm(T_EXPORTS, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = "EXPORTS";
	
break;
}}
case 22: case -22:
LLDEBUG_ALTERNATIVE("word", 22);
{LLSTATE llstate_1;
if (!llterm(T_EXTENSIBILITY, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = "EXTENSIBILITY";
	
break;
}}
case 23: case -23:
LLDEBUG_ALTERNATIVE("word", 23);
{LLSTATE llstate_1;
if (!llterm(T_FROM, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = "FROM";
	
break;
}}
case 24: case -24:
LLDEBUG_ALTERNATIVE("word", 24);
{LLSTATE llstate_1;
if (!llterm(T_GeneralizedTime, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = "GeneralizedTime";
	
break;
}}
case 25: case -25:
LLDEBUG_ALTERNATIVE("word", 25);
{LLSTATE llstate_1;
if (!llterm(T_GeneralString, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = "GeneralString";
	
break;
}}
case 26: case -26:
LLDEBUG_ALTERNATIVE("word", 26);
{LLSTATE llstate_1;
if (!llterm(T_GraphicString, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = "GraphicString";
	
break;
}}
case 27: case -27:
LLDEBUG_ALTERNATIVE("word", 27);
{LLSTATE llstate_1;
if (!llterm(T_IA5String, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = "IA5String";
	
break;
}}
case 28: case -28:
LLDEBUG_ALTERNATIVE("word", 28);
{LLSTATE llstate_1;
if (!llterm(T_IDENTIFIER, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = "IDENTIFIER";
	
break;
}}
case 29: case -29:
LLDEBUG_ALTERNATIVE("word", 29);
{LLSTATE llstate_1;
if (!llterm(T_identifier, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = "identifier";
	
break;
}}
case 30: case -30:
LLDEBUG_ALTERNATIVE("word", 30);
{LLSTATE llstate_1;
if (!llterm(T_IMPLICIT, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = "IMPLICIT";
	
break;
}}
case 31: case -31:
LLDEBUG_ALTERNATIVE("word", 31);
{LLSTATE llstate_1;
if (!llterm(T_IMPLIED, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = "IMPLIED";
	
break;
}}
case 32: case -32:
LLDEBUG_ALTERNATIVE("word", 32);
{LLSTATE llstate_1;
if (!llterm(T_IMPORTS, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = "IMPORTS";
	
break;
}}
case 33: case -33:
LLDEBUG_ALTERNATIVE("word", 33);
{LLSTATE llstate_1;
if (!llterm(T_INCLUDES, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = "INCLUDES";
	
break;
}}
case 34: case -34:
LLDEBUG_ALTERNATIVE("word", 34);
{LLSTATE llstate_1;
if (!llterm(T_ISO646String, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = "ISO646String";
	
break;
}}
case 35: case -35:
LLDEBUG_ALTERNATIVE("word", 35);
{LLSTATE llstate_1;
if (!llterm(T_MACRO, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = "MACRO";
	
break;
}}
case 36: case -36:
LLDEBUG_ALTERNATIVE("word", 36);
{LLSTATE llstate_1;
if (!llterm(T_MAX, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = "MAX";
	
break;
}}
case 37: case -37:
LLDEBUG_ALTERNATIVE("word", 37);
{LLSTATE llstate_1;
if (!llterm(T_MIN, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = "MIN";
	
break;
}}
case 38: case -38:
LLDEBUG_ALTERNATIVE("word", 38);
{LLSTATE llstate_1;
if (!llterm(T_NOTATION, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = "NOTATION";
	
break;
}}
case 39: case -39:
LLDEBUG_ALTERNATIVE("word", 39);
{LLSTATE llstate_1;
if (!llterm(T_Number, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = "number";
	
break;
}}
case 40: case -40:
LLDEBUG_ALTERNATIVE("word", 40);
{LLSTATE llstate_1;
if (!llterm(T_NumericString, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = "NumericString";
	
break;
}}
case 41: case -41:
LLDEBUG_ALTERNATIVE("word", 41);
{LLSTATE llstate_1;
if (!llterm(T_ObjectDescriptor, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = "ObjectDescriptor";
	
break;
}}
case 42: case -42:
LLDEBUG_ALTERNATIVE("word", 42);
{LLSTATE llstate_1;
if (!llterm(T_OF, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = "OF";
	
break;
}}
case 43: case -43:
LLDEBUG_ALTERNATIVE("word", 43);
{LLSTATE llstate_1;
if (!llterm(T_OPTIONAL, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = "OPTIONAL";
	
break;
}}
case 44: case -44:
LLDEBUG_ALTERNATIVE("word", 44);
{LLSTATE llstate_1;
if (!llterm(T_PDV, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = "PDV";
	
break;
}}
case 45: case -45:
LLDEBUG_ALTERNATIVE("word", 45);
{LLSTATE llstate_1;
if (!llterm(T_PRESENT, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = "PRESENT";
	
break;
}}
case 46: case -46:
LLDEBUG_ALTERNATIVE("word", 46);
{LLSTATE llstate_1;
if (!llterm(T_PrintableString, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = "PrintableString";
	
break;
}}
case 47: case -47:
LLDEBUG_ALTERNATIVE("word", 47);
{LLSTATE llstate_1;
if (!llterm(T_PRIVATE, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = "PRIVATE";
	
break;
}}
case 48: case -48:
LLDEBUG_ALTERNATIVE("word", 48);
{LLSTATE llstate_1;
if (!llterm(T_SIZE, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = "SIZE";
	
break;
}}
case 49: case -49:
LLDEBUG_ALTERNATIVE("word", 49);
{LLSTATE llstate_1;
if (!llterm(T_STRING, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = "STRING";
	
break;
}}
case 50: case -50:
LLDEBUG_ALTERNATIVE("word", 50);
{LLSTATE llstate_1;
if (!llterm(T_string, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = "string";
	
break;
}}
case 51: case -51:
LLDEBUG_ALTERNATIVE("word", 51);
{LLSTATE llstate_1;
if (!llterm(T_SYNTAX, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = "SYNTAX";
	
break;
}}
case 52: case -52:
LLDEBUG_ALTERNATIVE("word", 52);
{LLSTATE llstate_1;
if (!llterm(T_T61String, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = "T61String";
	
break;
}}
case 53: case -53:
LLDEBUG_ALTERNATIVE("word", 53);
{LLSTATE llstate_1;
if (!llterm(T_TAGS, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = "TAGS";
	
break;
}}
case 54: case -54:
LLDEBUG_ALTERNATIVE("word", 54);
{LLSTATE llstate_1;
if (!llterm(T_TeletexString, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = "TeletexString";
	
break;
}}
case 55: case -55:
LLDEBUG_ALTERNATIVE("word", 55);
{LLSTATE llstate_1;
if (!llterm(T_TYPE, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = "TYPE";
	
break;
}}
case 56: case -56:
LLDEBUG_ALTERNATIVE("word", 56);
{LLSTATE llstate_1;
if (!llterm(T_type, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = "type";
	
break;
}}
case 57: case -57:
LLDEBUG_ALTERNATIVE("word", 57);
{LLSTATE llstate_1;
if (!llterm(T_TYPE_IDENTIFIER, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = "TYPE-IDENTIFIER";
	
break;
}}
case 58: case -58:
LLDEBUG_ALTERNATIVE("word", 58);
{LLSTATE llstate_1;
if (!llterm(T_UNIQUE, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = "UNIQUE";
	
break;
}}
case 59: case -59:
LLDEBUG_ALTERNATIVE("word", 59);
{LLSTATE llstate_1;
if (!llterm(T_UNIVERSAL, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = "UNIVERSAL";
	
break;
}}
case 60: case -60:
LLDEBUG_ALTERNATIVE("word", 60);
{LLSTATE llstate_1;
if (!llterm(T_UniversalString, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = "UniversalString";
	
break;
}}
case 61: case -61:
LLDEBUG_ALTERNATIVE("word", 61);
{LLSTATE llstate_1;
if (!llterm(T_UTCTime, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = "UTCTime";
	
break;
}}
case 62: case -62:
LLDEBUG_ALTERNATIVE("word", 62);
{LLSTATE llstate_1;
if (!llterm(T_UTF8String, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = "UTF8String";
	
break;
}}
case 63: case -63:
LLDEBUG_ALTERNATIVE("word", 63);
{LLSTATE llstate_1;
if (!llterm(T_VALUE, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = "VALUE";
	
break;
}}
case 64: case -64:
LLDEBUG_ALTERNATIVE("word", 64);
{LLSTATE llstate_1;
if (!llterm(T_value, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = "value";
	
break;
}}
case 65: case -65:
LLDEBUG_ALTERNATIVE("word", 65);
{LLSTATE llstate_1;
if (!llterm(T_VideotexString, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = "VideotexString";
	
break;
}}
case 66: case -66:
LLDEBUG_ALTERNATIVE("word", 66);
{LLSTATE llstate_1;
if (!llterm(T_VisibleString, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = "VisibleString";
	
break;
}}
case 67: case -67:
LLDEBUG_ALTERNATIVE("word", 67);
{LLSTATE llstate_1;
if (!llterm(T_WITH, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = "WITH";
	
break;
}}
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("word");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("word", 1);
return 1;
failed1: LLDEBUG_LEAVE("word", 0);
return 0;
}

int ll_identifier(XString *llret, LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("identifier");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("identifier", 1);
{LLSTATE llstate_1;XString llatt_1;
if (!llterm(T_lcsymbol, &lllval, &llstate_0, &llstate_1)) goto failed2;
llatt_1 = lllval._XString;
*llout = llstate_1;
{(*llret) = llatt_1;
	
break;
}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("identifier", 2);
{LLSTATE llstate_1;
if (!llterm(T_empty, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = "empty";
	
break;
}}
case 3: case -3:
LLDEBUG_ALTERNATIVE("identifier", 3);
{LLSTATE llstate_1;
if (!llterm(T_identifier, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = "identifier";
	
break;
}}
case 4: case -4:
LLDEBUG_ALTERNATIVE("identifier", 4);
{LLSTATE llstate_1;
if (!llterm(T_Number, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = "number";
	
break;
}}
case 5: case -5:
LLDEBUG_ALTERNATIVE("identifier", 5);
{LLSTATE llstate_1;
if (!llterm(T_string, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = "string";
	
break;
}}
case 6: case -6:
LLDEBUG_ALTERNATIVE("identifier", 6);
{LLSTATE llstate_1;
if (!llterm(T_type, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = "type";
	
break;
}}
case 7: case -7:
LLDEBUG_ALTERNATIVE("identifier", 7);
{LLSTATE llstate_1;
if (!llterm(T_value, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = "value";
	
break;
}}
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("identifier");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("identifier", 1);
return 1;
failed1: LLDEBUG_LEAVE("identifier", 0);
return 0;
}

int ll_ucsymbol(XString *llret, LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("ucsymbol");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("ucsymbol", 1);
{LLSTATE llstate_1;XString llatt_1;
if (!ll_ocsymbol(&llatt_1, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = llatt_1;
	
break;
}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("ucsymbol", 2);
{LLSTATE llstate_1;XString llatt_1;
if (!llterm(T_uppercase_symbol, &lllval, &llstate_0, &llstate_1)) goto failed2;
llatt_1 = lllval._XString;
*llout = llstate_1;
{(*llret) = llatt_1;
	
break;
}}
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("ucsymbol");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("ucsymbol", 1);
return 1;
failed1: LLDEBUG_LEAVE("ucsymbol", 0);
return 0;
}

int ll_ocsymbol(XString *llret, LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("ocsymbol");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("ocsymbol", 1);
{LLSTATE llstate_1;XString llatt_1;
if (!llterm(T_only_uppercase_symbol, &lllval, &llstate_0, &llstate_1)) goto failed2;
llatt_1 = lllval._XString;
*llout = llstate_1;
{(*llret) = llatt_1;
	
break;
}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("ocsymbol", 2);
{LLSTATE llstate_1;XString llatt_1;
if (!llterm(T_only_uppercase_digits_symbol, &lllval, &llstate_0, &llstate_1)) goto failed2;
llatt_1 = lllval._XString;
*llout = llstate_1;
{(*llret) = llatt_1;
	
break;
}}
case 3: case -3:
LLDEBUG_ALTERNATIVE("ocsymbol", 3);
{LLSTATE llstate_1;
if (!llterm(T_MACRO, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = "MACRO";
	
break;
}}
case 4: case -4:
LLDEBUG_ALTERNATIVE("ocsymbol", 4);
{LLSTATE llstate_1;
if (!llterm(T_NOTATION, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = "NOTATION";
	
break;
}}
case 5: case -5:
LLDEBUG_ALTERNATIVE("ocsymbol", 5);
{LLSTATE llstate_1;
if (!llterm(T_TYPE, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = "TYPE";
	
break;
}}
case 6: case -6:
LLDEBUG_ALTERNATIVE("ocsymbol", 6);
{LLSTATE llstate_1;
if (!llterm(T_VALUE, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = "VALUE";
	
break;
}}
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("ocsymbol");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("ocsymbol", 1);
return 1;
failed1: LLDEBUG_LEAVE("ocsymbol", 0);
return 0;
}

int ll_astring(XString *llret, LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("astring");

llstate_0 = *llin;
#undef failed
#define failed failed1
{LLSTATE llstate_1;XString32 llatt_1;
if (!llterm(T_cstring, &lllval, &llstate_0, &llstate_1)) goto failed1;
llatt_1 = lllval._XString32;
*llout = llstate_1;
{uint32_t i, len;
	    len = str32len(llatt_1);
	    (*llret) = (char *)malloc(len + 1);
	    for (i = 0; i <= len; i++)
		(*llret)[i] = (char)(llatt_1[i]);
	
}}
LLDEBUG_LEAVE("astring", 1);
return 1;
failed1: LLDEBUG_LEAVE("astring", 0);
return 0;
}

int ll_DefinedType(XType *llret, LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("DefinedType");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("DefinedType", 1);
{LLSTATE llstate_1;XType llatt_1;
if (!ll_Externaltypereference(&llatt_1, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = llatt_1;
	
break;
}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("DefinedType", 2);
{LLSTATE llstate_1;XType llatt_1;
if (!ll_typereference(&llatt_1, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = llatt_1;
	
break;
}}
case 3: case -3:
LLDEBUG_ALTERNATIVE("DefinedType", 3);
{LLSTATE llstate_1;
if (!ll_ParameterizedType(&llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{MyAbort();
	
break;
}}
case 4: case -4:
LLDEBUG_ALTERNATIVE("DefinedType", 4);
{LLSTATE llstate_1;
if (!ll_ParameterizedValueSetType(&llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{MyAbort();
	
break;
}}
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("DefinedType");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("DefinedType", 1);
return 1;
failed1: LLDEBUG_LEAVE("DefinedType", 0);
return 0;
}

int ll_TypeAssignment(LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("TypeAssignment");

llstate_0 = *llin;
#undef failed
#define failed failed1
{LLSTATE llstate_1;XType llatt_1;
if (!ll_typereference(&llatt_1, &llstate_0, &llstate_1)) goto failed1;
{LLSTATE llstate_2;
if (!llterm(T_DEF, (LLSTYPE *)0, &llstate_1, &llstate_2)) goto failed1;
{LLSTATE llstate_3;XType llatt_3;
if (!ll_Type(&llatt_3, &llstate_2, &llstate_3)) goto failed1;
{LLSTATE llstate_4;XPrivateDirectives llatt_4;
if (!ll_PrivateDirectives(&llatt_4, &llstate_3, &llstate_4)) goto failed1;
*llout = llstate_4;
{PropagatePrivateDirectives(llatt_3, llatt_4);
	    if (!AssignType(&(*llout).Assignments, llatt_1, llatt_3))
		LLFAILED((&llstate_1.pos, "Type `%s' twice defined",
		    llatt_1->U.Reference.Identifier));
		((*llout).Assignments)->eDefTagType = g_eDefTagType;
	
}}}}}
LLDEBUG_LEAVE("TypeAssignment", 1);
return 1;
failed1: LLDEBUG_LEAVE("TypeAssignment", 0);
return 0;
}

int ll_ValueSetTypeAssignment(LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("ValueSetTypeAssignment");

llstate_0 = *llin;
#undef failed
#define failed failed1
{LLSTATE llstate_1;XType llatt_1;
if (!ll_typereference(&llatt_1, &llstate_0, &llstate_1)) goto failed1;
{LLSTATE llstate_2;XType llatt_2;
if (!ll_Type(&llatt_2, &llstate_1, &llstate_2)) goto failed1;
{LLSTATE llstate_3;
if (!llterm(T_DEF, (LLSTYPE *)0, &llstate_2, &llstate_3)) goto failed1;
{LLSTATE llstate_4;XValueSet llatt_4;
if (!ll_ValueSet(&llatt_4, &llstate_3, &llstate_4, llatt_2)) goto failed1;
*llout = llstate_4;
{Type_t *type;
	    type = GetTypeOfValueSet((*llout).Assignments, llatt_4);
	    if (!AssignType(&(*llout).Assignments, llatt_1, type))
		LLFAILED((&llstate_1.pos, "Type `%s' twice defined",
		    llatt_1->U.Reference.Identifier));
	
}}}}}
LLDEBUG_LEAVE("ValueSetTypeAssignment", 1);
return 1;
failed1: LLDEBUG_LEAVE("ValueSetTypeAssignment", 0);
return 0;
}

int ll_ValueSet(XValueSet *llret, LLSTATE *llin, LLSTATE *llout, XType llarg_type)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("ValueSet");

llstate_0 = *llin;
#undef failed
#define failed failed1
{LLSTATE llstate_1;
if (!llterm('{', (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed1;
{LLSTATE llstate_2;XElementSetSpec llatt_2;
if (!ll_ElementSetSpec(&llatt_2, &llstate_1, &llstate_2, llarg_type, NULL, 0)) goto failed1;
{LLSTATE llstate_3;
if (!llterm('}', (LLSTYPE *)0, &llstate_2, &llstate_3)) goto failed1;
*llout = llstate_3;
{(*llret) = NewValueSet();
	    (*llret)->Elements = llatt_2;
	    (*llret)->Type = llarg_type;
	
}}}}
LLDEBUG_LEAVE("ValueSet", 1);
return 1;
failed1: LLDEBUG_LEAVE("ValueSet", 0);
return 0;
}

int ll_Type(XType *llret, LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("Type");

llstate_0 = *llin;
#undef failed
#define failed failed1
{LLSTATE llstate_1;XDirectives llatt_1;
if (!ll_LocalTypeDirectiveESeq(&llatt_1, &llstate_0, &llstate_1)) goto failed1;
{LLSTATE llstate_2;XType llatt_2;
if (!ll_UndirectivedType(&llatt_2, &llstate_1, &llstate_2)) goto failed1;
{LLSTATE llstate_3;XDirectives llatt_3;
if (!ll_LocalTypeDirectiveESeq(&llatt_3, &llstate_2, &llstate_3)) goto failed1;
*llout = llstate_3;
{Directive_t **dd, *d;
	    if (llatt_1 || llatt_3) {
		(*llret) = DupType(llatt_2);
		dd = &(*llret)->Directives;
		for (d = llatt_1; d; d = d->Next) {
		    *dd = DupDirective(d);
		    dd = &(*dd)->Next;
		}
		for (d = llatt_3; d; d = d->Next) {
		    *dd = DupDirective(d);
		    dd = &(*dd)->Next;
		}
		*dd = llatt_2->Directives;
	    } else {
		(*llret) = llatt_2;
	    }
	
}}}}
LLDEBUG_LEAVE("Type", 1);
return 1;
failed1: LLDEBUG_LEAVE("Type", 0);
return 0;
}

int ll_UndirectivedType(XType *llret, LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("UndirectivedType");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("UndirectivedType", 1);
{LLSTATE llstate_1;XType llatt_1;
if (!ll_UntaggedType(&llatt_1, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = llatt_1;
	
break;
}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("UndirectivedType", 2);
{LLSTATE llstate_1;XType llatt_1;
if (!ll_TaggedType(&llatt_1, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = llatt_1;
	
break;
}}
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("UndirectivedType");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("UndirectivedType", 1);
return 1;
failed1: LLDEBUG_LEAVE("UndirectivedType", 0);
return 0;
}

int ll_UntaggedType(XType *llret, LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("UntaggedType");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("UntaggedType", 1);
{LLSTATE llstate_1;XType llatt_1;
if (!ll_ConstrainableType(&llatt_1, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = llatt_1;
	
break;
}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("UntaggedType", 2);
{LLSTATE llstate_1;XType llatt_1;
if (!ll_SequenceOfType(&llatt_1, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = llatt_1;
	
break;
}}
case 3: case -3:
LLDEBUG_ALTERNATIVE("UntaggedType", 3);
{LLSTATE llstate_1;XType llatt_1;
if (!ll_SetOfType(&llatt_1, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = llatt_1;
	
break;
}}
case 4: case -4:
LLDEBUG_ALTERNATIVE("UntaggedType", 4);
{LLSTATE llstate_1;XType llatt_1;
if (!ll_TypeWithConstraint(&llatt_1, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = llatt_1;
	
break;
}}
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("UntaggedType");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("UntaggedType", 1);
return 1;
failed1: LLDEBUG_LEAVE("UntaggedType", 0);
return 0;
}

int ll_ConstrainableType(XType *llret, LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("ConstrainableType");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("ConstrainableType", 1);
{LLSTATE llstate_1;XType llatt_1;
if (!ll_BuiltinType(&llatt_1, &llstate_0, &llstate_1)) goto failed2;
{LLSTATE llstate_2;XDirectives llatt_2;
if (!ll_LocalTypeDirectiveESeq(&llatt_2, &llstate_1, &llstate_2)) goto failed2;
{LLSTATE llstate_3;XPrivateDirectives llatt_3;
if (!ll_PrivateDirectives(&llatt_3, &llstate_2, &llstate_3)) goto failed2;
{LLSTATE llstate_4;XConstraints llatt_4;
if (!ll_Constraint_ESeq(&llatt_4, &llstate_3, &llstate_4, llatt_1)) goto failed2;
{LLSTATE llstate_5;XDirectives llatt_5;
if (!ll_LocalTypeDirectiveESeq(&llatt_5, &llstate_4, &llstate_5)) goto failed2;
{LLSTATE llstate_6;XPrivateDirectives llatt_6;
if (!ll_PrivateDirectives(&llatt_6, &llstate_5, &llstate_6)) goto failed2;
*llout = llstate_6;
{Directive_t *d, **dd;
	    if (llatt_2 || llatt_4 || llatt_5) {
		(*llret) = DupType(llatt_1);
		IntersectConstraints(&(*llret)->Constraints,
		    llatt_1->Constraints, llatt_4);
		dd = &(*llret)->Directives;
		for (d = llatt_2; d; d = d->Next) {
		    *dd = DupDirective(d);
		    dd = &(*dd)->Next;
		}
		for (d = llatt_5; d; d = d->Next) {
		    *dd = DupDirective(d);
		    dd = &(*dd)->Next;
		}
		*dd = NULL;
	    } else {
		(*llret) = (llatt_3 || llatt_6) ? DupType(llatt_1) : llatt_1;
	    }
	    PropagatePrivateDirectives((*llret), llatt_3);
	    PropagatePrivateDirectives((*llret), llatt_6);
	
break;
}}}}}}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("ConstrainableType", 2);
{LLSTATE llstate_1;XType llatt_1;
if (!ll_ReferencedType(&llatt_1, &llstate_0, &llstate_1)) goto failed2;
{LLSTATE llstate_2;XDirectives llatt_2;
if (!ll_LocalTypeDirectiveESeq(&llatt_2, &llstate_1, &llstate_2)) goto failed2;
{LLSTATE llstate_3;XPrivateDirectives llatt_3;
if (!ll_PrivateDirectives(&llatt_3, &llstate_2, &llstate_3)) goto failed2;
{LLSTATE llstate_4;XConstraints llatt_4;
if (!ll_Constraint_ESeq(&llatt_4, &llstate_3, &llstate_4, llatt_1)) goto failed2;
{LLSTATE llstate_5;XDirectives llatt_5;
if (!ll_LocalTypeDirectiveESeq(&llatt_5, &llstate_4, &llstate_5)) goto failed2;
{LLSTATE llstate_6;XPrivateDirectives llatt_6;
if (!ll_PrivateDirectives(&llatt_6, &llstate_5, &llstate_6)) goto failed2;
*llout = llstate_6;
{Directive_t *d, **dd;
	    if (llatt_2 || llatt_4 || llatt_5) {
		(*llret) = DupType(llatt_1);
		IntersectConstraints(&(*llret)->Constraints,
		    llatt_1->Constraints, llatt_4);
		dd = &(*llret)->Directives;
		for (d = llatt_2; d; d = d->Next) {
		    *dd = DupDirective(d);
		    dd = &(*dd)->Next;
		}
		for (d = llatt_5; d; d = d->Next) {
		    *dd = DupDirective(d);
		    dd = &(*dd)->Next;
		}
		*dd = NULL;
	    } else {
		(*llret) = (llatt_3 || llatt_6) ? DupType(llatt_1) : llatt_1;
	    }
	    PropagatePrivateDirectives((*llret), llatt_3);
	    PropagatePrivateDirectives((*llret), llatt_6);
	
break;
}}}}}}}
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("ConstrainableType");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("ConstrainableType", 1);
return 1;
failed1: LLDEBUG_LEAVE("ConstrainableType", 0);
return 0;
}

int ll_Constraint_ESeq(XConstraints *llret, LLSTATE *llin, LLSTATE *llout, XType llarg_type)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("Constraint_ESeq");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("Constraint_ESeq", 1);
{LLSTATE llstate_1;XConstraints llatt_1;
if (!ll_Constraint(&llatt_1, &llstate_0, &llstate_1, llarg_type, 0)) goto failed2;
{LLSTATE llstate_2;XConstraints llatt_2;
if (!ll_Constraint_ESeq(&llatt_2, &llstate_1, &llstate_2, llarg_type)) goto failed2;
*llout = llstate_2;
{if (llatt_2) {
		IntersectConstraints(&(*llret), llatt_1, llatt_2);
	    } else {
		(*llret) = llatt_1;
	    }
	
break;
}}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("Constraint_ESeq", 2);
*llout = llstate_0;
{(*llret) = NULL;
	
break;
}
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("Constraint_ESeq");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("Constraint_ESeq", 1);
return 1;
failed1: LLDEBUG_LEAVE("Constraint_ESeq", 0);
return 0;
}

int ll_BuiltinType(XType *llret, LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("BuiltinType");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("BuiltinType", 1);
{LLSTATE llstate_1;XType llatt_1;
if (!ll_BitStringType(&llatt_1, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = llatt_1;
	
break;
}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("BuiltinType", 2);
{LLSTATE llstate_1;XType llatt_1;
if (!ll_BooleanType(&llatt_1, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = llatt_1;
	
break;
}}
case 3: case -3:
LLDEBUG_ALTERNATIVE("BuiltinType", 3);
{LLSTATE llstate_1;XType llatt_1;
if (!ll_CharacterStringType(&llatt_1, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = llatt_1;
	
break;
}}
case 4: case -4:
LLDEBUG_ALTERNATIVE("BuiltinType", 4);
{LLSTATE llstate_1;XType llatt_1;
if (!ll_ChoiceType(&llatt_1, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = llatt_1;
	
break;
}}
case 5: case -5:
LLDEBUG_ALTERNATIVE("BuiltinType", 5);
{LLSTATE llstate_1;XType llatt_1;
if (!ll_EmbeddedPDVType(&llatt_1, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = llatt_1;
	
break;
}}
case 6: case -6:
LLDEBUG_ALTERNATIVE("BuiltinType", 6);
{LLSTATE llstate_1;XType llatt_1;
if (!ll_EnumeratedType(&llatt_1, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = llatt_1;
	
break;
}}
case 7: case -7:
LLDEBUG_ALTERNATIVE("BuiltinType", 7);
{LLSTATE llstate_1;XType llatt_1;
if (!ll_ExternalType(&llatt_1, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = llatt_1;
	
break;
}}
case 8: case -8:
LLDEBUG_ALTERNATIVE("BuiltinType", 8);
{LLSTATE llstate_1;XType llatt_1;
if (!ll_InstanceOfType(&llatt_1, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = llatt_1;
	
break;
}}
case 9: case -9:
LLDEBUG_ALTERNATIVE("BuiltinType", 9);
{LLSTATE llstate_1;XType llatt_1;
if (!ll_IntegerType(&llatt_1, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = llatt_1;
	
break;
}}
case 10: case -10:
LLDEBUG_ALTERNATIVE("BuiltinType", 10);
{LLSTATE llstate_1;XType llatt_1;
if (!ll_NullType(&llatt_1, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = llatt_1;
	
break;
}}
case 11: case -11:
LLDEBUG_ALTERNATIVE("BuiltinType", 11);
{LLSTATE llstate_1;XType llatt_1;
if (!ll_ObjectClassFieldType(&llatt_1, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = llatt_1;
	
break;
}}
case 12: case -12:
LLDEBUG_ALTERNATIVE("BuiltinType", 12);
{LLSTATE llstate_1;XType llatt_1;
if (!ll_ObjectIdentifierType(&llatt_1, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = llatt_1;
	
break;
}}
case 13: case -13:
LLDEBUG_ALTERNATIVE("BuiltinType", 13);
{LLSTATE llstate_1;XType llatt_1;
if (!ll_OctetStringType(&llatt_1, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = llatt_1;
	
break;
}}
case 14: case -14:
LLDEBUG_ALTERNATIVE("BuiltinType", 14);
{LLSTATE llstate_1;XType llatt_1;
if (!ll_UTF8StringType(&llatt_1, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = llatt_1;
	
break;
}}
case 15: case -15:
LLDEBUG_ALTERNATIVE("BuiltinType", 15);
{LLSTATE llstate_1;XType llatt_1;
if (!ll_RealType(&llatt_1, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = llatt_1;
	
break;
}}
case 16: case -16:
LLDEBUG_ALTERNATIVE("BuiltinType", 16);
{LLSTATE llstate_1;XType llatt_1;
if (!ll_SequenceType(&llatt_1, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = llatt_1;
	
break;
}}
case 17: case -17:
LLDEBUG_ALTERNATIVE("BuiltinType", 17);
{LLSTATE llstate_1;XType llatt_1;
if (!ll_SetType(&llatt_1, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = llatt_1;
	
break;
}}
case 18: case -18:
LLDEBUG_ALTERNATIVE("BuiltinType", 18);
{LLSTATE llstate_1;XType llatt_1;
if (!ll_AnyType(&llatt_1, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = llatt_1;
	
break;
}}
case 19: case -19:
LLDEBUG_ALTERNATIVE("BuiltinType", 19);
{LLSTATE llstate_1;XType llatt_1;
if (!ll_MacroDefinedType(&llatt_1, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = llatt_1;
	
break;
}}
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("BuiltinType");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("BuiltinType", 1);
return 1;
failed1: LLDEBUG_LEAVE("BuiltinType", 0);
return 0;
}

int ll_ReferencedType(XType *llret, LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("ReferencedType");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("ReferencedType", 1);
{LLSTATE llstate_1;XType llatt_1;
if (!ll_DefinedType(&llatt_1, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = llatt_1;
	
break;
}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("ReferencedType", 2);
{LLSTATE llstate_1;XType llatt_1;
if (!ll_UsefulType(&llatt_1, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = llatt_1;
	
break;
}}
case 3: case -3:
LLDEBUG_ALTERNATIVE("ReferencedType", 3);
{LLSTATE llstate_1;XType llatt_1;
if (!ll_SelectionType(&llatt_1, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = llatt_1;
	
break;
}}
case 4: case -4:
LLDEBUG_ALTERNATIVE("ReferencedType", 4);
{LLSTATE llstate_1;XType llatt_1;
if (!ll_TypeFromObject(&llatt_1, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = llatt_1;
	
break;
}}
case 5: case -5:
LLDEBUG_ALTERNATIVE("ReferencedType", 5);
{LLSTATE llstate_1;XValueSet llatt_1;
if (!ll_ValueSetFromObjects(&llatt_1, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = GetTypeOfValueSet((*llout).Assignments, llatt_1);
	
break;
}}
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("ReferencedType");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("ReferencedType", 1);
return 1;
failed1: LLDEBUG_LEAVE("ReferencedType", 0);
return 0;
}

int ll_NamedType(XNamedType *llret, LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("NamedType");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("NamedType", 1);
{LLSTATE llstate_1;XString llatt_1;
if (!ll_identifier(&llatt_1, &llstate_0, &llstate_1)) goto failed2;
{LLSTATE llstate_2;XType llatt_2;
if (!ll_Type(&llatt_2, &llstate_1, &llstate_2)) goto failed2;
*llout = llstate_2;
{(*llret) = NewNamedType(llatt_2->PrivateDirectives.pszFieldName ? llatt_2->PrivateDirectives.pszFieldName : llatt_1, llatt_2);
	    llatt_2->PrivateDirectives.pszFieldName = NULL;
	
break;
}}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("NamedType", 2);
{LLSTATE llstate_1;XString llatt_1;
if (!ll_identifier(&llatt_1, &llstate_0, &llstate_1)) goto failed2;
{LLSTATE llstate_2;
if (!llterm('<', (LLSTYPE *)0, &llstate_1, &llstate_2)) goto failed2;
{LLSTATE llstate_3;XType llatt_3;
if (!ll_Type(&llatt_3, &llstate_2, &llstate_3)) goto failed2;
*llout = llstate_3;
{Type_t *type;
	    type = NewType(eType_Selection);
	    type->U.Selection.Type = llatt_3;
	    type->U.Selection.Identifier = llatt_1;
	    (*llret) = NewNamedType(llatt_3->PrivateDirectives.pszFieldName ? llatt_3->PrivateDirectives.pszFieldName : llatt_1, type);
	    llatt_3->PrivateDirectives.pszFieldName = NULL;
	
break;
}}}}
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("NamedType");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("NamedType", 1);
return 1;
failed1: LLDEBUG_LEAVE("NamedType", 0);
return 0;
}

int ll_BooleanType(XType *llret, LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("BooleanType");

llstate_0 = *llin;
#undef failed
#define failed failed1
{LLSTATE llstate_1;
if (!llterm(T_BOOLEAN, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed1;
*llout = llstate_1;
{(*llret) = Builtin_Type_Boolean;
	
}}
LLDEBUG_LEAVE("BooleanType", 1);
return 1;
failed1: LLDEBUG_LEAVE("BooleanType", 0);
return 0;
}

int ll_IntegerType(XType *llret, LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("IntegerType");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("IntegerType", 1);
{LLSTATE llstate_1;
if (!llterm(T_INTEGER, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
{LLSTATE llstate_2;
if (!llterm('{', (LLSTYPE *)0, &llstate_1, &llstate_2)) goto failed2;
{LLSTATE llstate_3;XNamedNumbers llatt_3;
if (!ll_NamedNumberList(&llatt_3, &llstate_2, &llstate_3)) goto failed2;
{LLSTATE llstate_4;
if (!llterm('}', (LLSTYPE *)0, &llstate_3, &llstate_4)) goto failed2;
*llout = llstate_4;
{NamedNumber_t *n, *m;
	    for (n = llatt_3; n && n->Next; n = n->Next) {
		for (m = n->Next; m; m = m->Next) {
		    if (n->Type == eNamedNumber_Normal &&
			m->Type == eNamedNumber_Normal) {
			if (!strcmp(n->U.Normal.Identifier,
			    m->U.Normal.Identifier))
			    LLFAILED((&llstate_3.pos,
				"identifier `%s' has been assigned twice",
				n->U.Normal.Identifier));
			if (GetValue((*llout).Assignments, n->U.Normal.Value) &&
			    GetValue((*llout).Assignments, m->U.Normal.Value) &&
			    GetTypeType((*llout).Assignments,
			    GetValue((*llout).Assignments, n->U.Normal.Value)->Type)
			    == eType_Integer &&
			    GetTypeType((*llout).Assignments,
			    GetValue((*llout).Assignments, m->U.Normal.Value)->Type)
			    == eType_Integer &&
			    !intx_cmp(&GetValue((*llout).Assignments,
			    n->U.Normal.Value)->U.Integer.Value,
			    &GetValue((*llout).Assignments,
			    m->U.Normal.Value)->U.Integer.Value))
			    LLFAILED((&llstate_3.pos,
				"value `%d' has been assigned twice",
				intx2int32(&GetValue((*llout).Assignments,
				n->U.Normal.Value)->U.Integer.Value)));
		    }
		}
	    }
	    (*llret) = NewType(eType_Integer);
	    (*llret)->ExtensionDefault = (*llout).ExtensionDefault;
	    (*llret)->U.Integer.NamedNumbers = llatt_3;
	
break;
}}}}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("IntegerType", 2);
{LLSTATE llstate_1;
if (!llterm(T_INTEGER, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = NewType(eType_Integer);
	    (*llret)->ExtensionDefault = (*llout).ExtensionDefault;
	
break;
}}
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("IntegerType");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("IntegerType", 1);
return 1;
failed1: LLDEBUG_LEAVE("IntegerType", 0);
return 0;
}

int ll_NamedNumberList(XNamedNumbers *llret, LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("NamedNumberList");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("NamedNumberList", 1);
{LLSTATE llstate_1;XNamedNumbers llatt_1;
if (!ll_NamedNumber(&llatt_1, &llstate_0, &llstate_1)) goto failed2;
{LLSTATE llstate_2;
if (!llterm(',', (LLSTYPE *)0, &llstate_1, &llstate_2)) goto failed2;
{LLSTATE llstate_3;XNamedNumbers llatt_3;
if (!ll_NamedNumberList(&llatt_3, &llstate_2, &llstate_3)) goto failed2;
*llout = llstate_3;
{(*llret) = DupNamedNumber(llatt_1);
	    (*llret)->Next = llatt_3;
	
break;
}}}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("NamedNumberList", 2);
{LLSTATE llstate_1;XNamedNumbers llatt_1;
if (!ll_NamedNumber(&llatt_1, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = llatt_1;
	
break;
}}
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("NamedNumberList");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("NamedNumberList", 1);
return 1;
failed1: LLDEBUG_LEAVE("NamedNumberList", 0);
return 0;
}

int ll_NamedNumber(XNamedNumbers *llret, LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("NamedNumber");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("NamedNumber", 1);
{LLSTATE llstate_1;XString llatt_1;
if (!ll_identifier(&llatt_1, &llstate_0, &llstate_1)) goto failed2;
{LLSTATE llstate_2;
if (!llterm('(', (LLSTYPE *)0, &llstate_1, &llstate_2)) goto failed2;
{LLSTATE llstate_3;XValue llatt_3;
if (!ll_SignedNumber(&llatt_3, &llstate_2, &llstate_3, Builtin_Type_Integer)) goto failed2;
{LLSTATE llstate_4;
if (!llterm(')', (LLSTYPE *)0, &llstate_3, &llstate_4)) goto failed2;
*llout = llstate_4;
{(*llret) = NewNamedNumber(eNamedNumber_Normal);
	    (*llret)->U.Normal.Identifier = llatt_1;
	    (*llret)->U.Normal.Value = llatt_3;
	
break;
}}}}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("NamedNumber", 2);
{LLSTATE llstate_1;XString llatt_1;
if (!ll_identifier(&llatt_1, &llstate_0, &llstate_1)) goto failed2;
{LLSTATE llstate_2;
if (!llterm('(', (LLSTYPE *)0, &llstate_1, &llstate_2)) goto failed2;
{LLSTATE llstate_3;XValue llatt_3;
if (!ll_DefinedValue(&llatt_3, &llstate_2, &llstate_3)) goto failed2;
{LLSTATE llstate_4;
if (!llterm(')', (LLSTYPE *)0, &llstate_3, &llstate_4)) goto failed2;
*llout = llstate_4;
{Value_t *v;
	    v = GetValue((*llout).Assignments, llatt_3);
	    if (v) {
		if (GetTypeType((*llout).Assignments, v->Type) != eType_Undefined &&
		    GetTypeType((*llout).Assignments, v->Type) != eType_Integer)
		    LLFAILED((&llstate_3.pos, "Bad type of value"));
		if (GetTypeType((*llout).Assignments, v->Type) != eType_Integer &&
		    intx_cmp(&v->U.Integer.Value, &intx_0) < 0)
		    LLFAILED((&llstate_3.pos, "Bad value"));
	    }
	    (*llret) = NewNamedNumber(eNamedNumber_Normal);
	    (*llret)->U.Normal.Identifier = llatt_1;
	    (*llret)->U.Normal.Value = llatt_3;
	
break;
}}}}}
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("NamedNumber");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("NamedNumber", 1);
return 1;
failed1: LLDEBUG_LEAVE("NamedNumber", 0);
return 0;
}

int ll_EnumeratedType(XType *llret, LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("EnumeratedType");

llstate_0 = *llin;
#undef failed
#define failed failed1
{LLSTATE llstate_1;
if (!llterm(T_ENUMERATED, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed1;
{LLSTATE llstate_2;
if (!llterm('{', (LLSTYPE *)0, &llstate_1, &llstate_2)) goto failed1;
{LLSTATE llstate_3;XNamedNumbers llatt_3;
if (!ll_Enumerations(&llatt_3, &llstate_2, &llstate_3)) goto failed1;
{LLSTATE llstate_4;
if (!llterm('}', (LLSTYPE *)0, &llstate_3, &llstate_4)) goto failed1;
*llout = llstate_4;
{NamedNumber_t **nn, *n, *m;
	    intx_t *ix;
	    uint32_t num = 0;
	    (*llret) = NewType(eType_Enumerated);
	    (*llret)->ExtensionDefault = (*llout).ExtensionDefault;
	    for (n = llatt_3; n; n = n->Next)
		if (n->Type == eNamedNumber_Normal)
		    KeepEnumNames(n->U.Normal.Identifier); // global conflict check
	    for (n = llatt_3; n && n->Next; n = n->Next) {
		if (n->Type != eNamedNumber_Normal)
		    continue;
		for (m = n->Next; m; m = m->Next) {
		    if (m->Type != eNamedNumber_Normal)
			continue;
		    if (!strcmp(n->U.Normal.Identifier,
			m->U.Normal.Identifier))
			LLFAILED((&llstate_3.pos,
			    "identifier `%s' has been assigned twice",
			    n->U.Normal.Identifier));
		    if (GetValue((*llout).Assignments, n->U.Normal.Value) &&
			GetValue((*llout).Assignments, m->U.Normal.Value) &&
			GetTypeType((*llout).Assignments,
			GetValue((*llout).Assignments, n->U.Normal.Value)->Type)
			== eType_Integer &&
			GetTypeType((*llout).Assignments,
			GetValue((*llout).Assignments, m->U.Normal.Value)->Type)
			== eType_Integer &&
			!intx_cmp(&GetValue((*llout).Assignments,
			n->U.Normal.Value)->U.Integer.Value,
			&GetValue((*llout).Assignments,
			m->U.Normal.Value)->U.Integer.Value))
			LLFAILED((&llstate_3.pos,
			    "value `%d' has been assigned twice",
			    intx2int32(&GetValue((*llout).Assignments,
			    n->U.Normal.Value)->U.Integer.Value)));
		}
	    }
	    nn = &(*llret)->U.Enumerated.NamedNumbers;
	    for (n = llatt_3; n; n = n->Next) {
		*nn = DupNamedNumber(n);
		switch (n->Type) {
		case eNamedNumber_Normal:
		    if (n->U.Normal.Value)
			break;
		    for (;; num++) {
			for (m = llatt_3; m; m = m->Next) {
			    switch (m->Type) {
			    case eNamedNumber_Normal:
				if (!m->U.Normal.Value)
				    continue;
				ix = &GetValue((*llout).Assignments,
				    m->U.Normal.Value)->U.Integer.Value;
				if (!intxisuint32(ix) ||
				    intx2uint32(ix) != num)
				    continue;
				break;
			    default:
				continue;
			    }
			    break;
			}
			if (!m)
			    break;
		    }
		    (*nn)->U.Normal.Value = NewValue(NULL,
			Builtin_Type_Integer);
		    intx_setuint32(
			&(*nn)->U.Normal.Value->U.Integer.Value,
		    	num++);
		    break;
		case eNamedNumber_ExtensionMarker:
		    break;
		}
		nn = &(*nn)->Next;
	    }
	    *nn = NULL;
	
}}}}}
LLDEBUG_LEAVE("EnumeratedType", 1);
return 1;
failed1: LLDEBUG_LEAVE("EnumeratedType", 0);
return 0;
}

int ll_Enumerations(XNamedNumbers *llret, LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("Enumerations");

llstate_0 = *llin;
#undef failed
#define failed failed1
{LLSTATE llstate_1;XNamedNumbers llatt_1;
if (!ll_Enumeration(&llatt_1, &llstate_0, &llstate_1)) goto failed1;
{LLSTATE llstate_2;XNamedNumbers llatt_2;
if (!ll_EnumerationExtension(&llatt_2, &llstate_1, &llstate_2)) goto failed1;
*llout = llstate_2;
{NamedNumber_t **nn, *n;
	    nn = &(*llret);
	    for (n = llatt_1; n; n = n->Next) {
		*nn = DupNamedNumber(n);
		nn = &(*nn)->Next;
	    }
	    *nn = llatt_2;
	
}}}
LLDEBUG_LEAVE("Enumerations", 1);
return 1;
failed1: LLDEBUG_LEAVE("Enumerations", 0);
return 0;
}

int ll_EnumerationExtension(XNamedNumbers *llret, LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("EnumerationExtension");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("EnumerationExtension", 1);
{LLSTATE llstate_1;
if (!llterm(',', (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
{LLSTATE llstate_2;
if (!llterm(T_TDOT, (LLSTYPE *)0, &llstate_1, &llstate_2)) goto failed2;
{LLSTATE llstate_3;
if (!llterm(',', (LLSTYPE *)0, &llstate_2, &llstate_3)) goto failed2;
{LLSTATE llstate_4;XNamedNumbers llatt_4;
if (!ll_Enumeration(&llatt_4, &llstate_3, &llstate_4)) goto failed2;
*llout = llstate_4;
{(*llret) = NewNamedNumber(eNamedNumber_ExtensionMarker);
	    (*llret)->Next = llatt_4;
	
break;
}}}}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("EnumerationExtension", 2);
{LLSTATE llstate_1;
if (!llterm(',', (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
{LLSTATE llstate_2;
if (!llterm(T_TDOT, (LLSTYPE *)0, &llstate_1, &llstate_2)) goto failed2;
*llout = llstate_2;
{(*llret) = NewNamedNumber(eNamedNumber_ExtensionMarker);
	
break;
}}}
case 3: case -3:
LLDEBUG_ALTERNATIVE("EnumerationExtension", 3);
*llout = llstate_0;
{(*llret) = NULL;
	
break;
}
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("EnumerationExtension");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("EnumerationExtension", 1);
return 1;
failed1: LLDEBUG_LEAVE("EnumerationExtension", 0);
return 0;
}

int ll_Enumeration(XNamedNumbers *llret, LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("Enumeration");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("Enumeration", 1);
{LLSTATE llstate_1;XNamedNumbers llatt_1;
if (!ll_EnumerationItem(&llatt_1, &llstate_0, &llstate_1)) goto failed2;
{LLSTATE llstate_2;
if (!llterm(',', (LLSTYPE *)0, &llstate_1, &llstate_2)) goto failed2;
{LLSTATE llstate_3;XNamedNumbers llatt_3;
if (!ll_Enumeration(&llatt_3, &llstate_2, &llstate_3)) goto failed2;
*llout = llstate_3;
{(*llret) = DupNamedNumber(llatt_1);
	    (*llret)->Next = llatt_3;
	
break;
}}}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("Enumeration", 2);
{LLSTATE llstate_1;XNamedNumbers llatt_1;
if (!ll_EnumerationItem(&llatt_1, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = llatt_1;
	
break;
}}
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("Enumeration");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("Enumeration", 1);
return 1;
failed1: LLDEBUG_LEAVE("Enumeration", 0);
return 0;
}

int ll_EnumerationItem(XNamedNumbers *llret, LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("EnumerationItem");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("EnumerationItem", 1);
{LLSTATE llstate_1;XString llatt_1;
if (!ll_identifier(&llatt_1, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = NewNamedNumber(eNamedNumber_Normal);
	    (*llret)->U.Normal.Identifier = llatt_1;
	
break;
}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("EnumerationItem", 2);
{LLSTATE llstate_1;XNamedNumbers llatt_1;
if (!ll_NamedNumber(&llatt_1, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = llatt_1;
	
break;
}}
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("EnumerationItem");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("EnumerationItem", 1);
return 1;
failed1: LLDEBUG_LEAVE("EnumerationItem", 0);
return 0;
}

int ll_RealType(XType *llret, LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("RealType");

llstate_0 = *llin;
#undef failed
#define failed failed1
{LLSTATE llstate_1;
if (!llterm(T_REAL, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed1;
*llout = llstate_1;
{(*llret) = Builtin_Type_Real;
	
}}
LLDEBUG_LEAVE("RealType", 1);
return 1;
failed1: LLDEBUG_LEAVE("RealType", 0);
return 0;
}

int ll_BitStringType(XType *llret, LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("BitStringType");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("BitStringType", 1);
{LLSTATE llstate_1;
if (!llterm(T_BIT, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
{LLSTATE llstate_2;
if (!llterm(T_STRING, (LLSTYPE *)0, &llstate_1, &llstate_2)) goto failed2;
{LLSTATE llstate_3;
if (!llterm('{', (LLSTYPE *)0, &llstate_2, &llstate_3)) goto failed2;
{LLSTATE llstate_4;XNamedNumbers llatt_4;
if (!ll_NamedBitList(&llatt_4, &llstate_3, &llstate_4)) goto failed2;
{LLSTATE llstate_5;
if (!llterm('}', (LLSTYPE *)0, &llstate_4, &llstate_5)) goto failed2;
*llout = llstate_5;
{NamedNumber_t *n, *m;
	    (*llret) = NewType(eType_BitString);
	    (*llret)->ExtensionDefault = (*llout).ExtensionDefault;
	    (*llret)->U.BitString.NamedNumbers = llatt_4;
	    for (n = llatt_4; n; n = n->Next)
	        KeepEnumNames(n->U.Normal.Identifier); // global conflict check
	    for (n = llatt_4; n && n->Next; n = n->Next) {
		for (m = n->Next; m; m = m->Next) {
		    if (!strcmp(n->U.Normal.Identifier,
			m->U.Normal.Identifier))
			LLFAILED((&llstate_4.pos,
			    "identifier `%s' has been assigned twice",
			    n->U.Normal.Identifier));
		    if (GetValue((*llout).Assignments, n->U.Normal.Value) &&
			GetValue((*llout).Assignments, m->U.Normal.Value) &&
			GetTypeType((*llout).Assignments,
			GetValue((*llout).Assignments, n->U.Normal.Value)->Type)
			== eType_Integer &&
			GetTypeType((*llout).Assignments,
			GetValue((*llout).Assignments, m->U.Normal.Value)->Type)
			== eType_Integer &&
			!intx_cmp(&GetValue((*llout).Assignments,
			n->U.Normal.Value)->U.Integer.Value,
			&GetValue((*llout).Assignments,
			m->U.Normal.Value)->U.Integer.Value))
			LLFAILED((&llstate_4.pos,
			    "value `%u' has been assigned twice",
			    intx2uint32(&GetValue((*llout).Assignments,
			    n->U.Normal.Value)->U.Integer.Value)));
		}
	    }
	
break;
}}}}}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("BitStringType", 2);
{LLSTATE llstate_1;
if (!llterm(T_BIT, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
{LLSTATE llstate_2;
if (!llterm(T_STRING, (LLSTYPE *)0, &llstate_1, &llstate_2)) goto failed2;
*llout = llstate_2;
{(*llret) = NewType(eType_BitString);
	    (*llret)->ExtensionDefault = (*llout).ExtensionDefault;
	
break;
}}}
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("BitStringType");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("BitStringType", 1);
return 1;
failed1: LLDEBUG_LEAVE("BitStringType", 0);
return 0;
}

int ll_NamedBitList(XNamedNumbers *llret, LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("NamedBitList");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("NamedBitList", 1);
{LLSTATE llstate_1;XNamedNumbers llatt_1;
if (!ll_NamedBit(&llatt_1, &llstate_0, &llstate_1)) goto failed2;
{LLSTATE llstate_2;
if (!llterm(',', (LLSTYPE *)0, &llstate_1, &llstate_2)) goto failed2;
{LLSTATE llstate_3;XNamedNumbers llatt_3;
if (!ll_NamedBitList(&llatt_3, &llstate_2, &llstate_3)) goto failed2;
*llout = llstate_3;
{(*llret) = DupNamedNumber(llatt_1);
	    (*llret)->Next = llatt_3;
	
break;
}}}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("NamedBitList", 2);
{LLSTATE llstate_1;XNamedNumbers llatt_1;
if (!ll_NamedBit(&llatt_1, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = llatt_1;
	
break;
}}
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("NamedBitList");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("NamedBitList", 1);
return 1;
failed1: LLDEBUG_LEAVE("NamedBitList", 0);
return 0;
}

int ll_NamedBit(XNamedNumbers *llret, LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("NamedBit");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("NamedBit", 1);
{LLSTATE llstate_1;XString llatt_1;
if (!ll_identifier(&llatt_1, &llstate_0, &llstate_1)) goto failed2;
{LLSTATE llstate_2;
if (!llterm('(', (LLSTYPE *)0, &llstate_1, &llstate_2)) goto failed2;
{LLSTATE llstate_3;XNumber llatt_3;
if (!llterm(T_number, &lllval, &llstate_2, &llstate_3)) goto failed2;
llatt_3 = lllval._XNumber;
{LLSTATE llstate_4;
if (!llterm(')', (LLSTYPE *)0, &llstate_3, &llstate_4)) goto failed2;
*llout = llstate_4;
{(*llret) = NewNamedNumber(eNamedNumber_Normal);
	    (*llret)->U.Normal.Identifier = llatt_1;
	    (*llret)->U.Normal.Value = NewValue(NULL, Builtin_Type_Integer);
	    (*llret)->U.Normal.Value->U.Integer.Value = llatt_3;
	
break;
}}}}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("NamedBit", 2);
{LLSTATE llstate_1;XString llatt_1;
if (!ll_identifier(&llatt_1, &llstate_0, &llstate_1)) goto failed2;
{LLSTATE llstate_2;
if (!llterm('(', (LLSTYPE *)0, &llstate_1, &llstate_2)) goto failed2;
{LLSTATE llstate_3;XValue llatt_3;
if (!ll_DefinedValue(&llatt_3, &llstate_2, &llstate_3)) goto failed2;
{LLSTATE llstate_4;
if (!llterm(')', (LLSTYPE *)0, &llstate_3, &llstate_4)) goto failed2;
*llout = llstate_4;
{Value_t *v;
	    v = GetValue((*llout).Assignments, llatt_3);
	    if (v) {
		if (GetTypeType((*llout).Assignments, v->Type) != eType_Undefined &&
		    GetTypeType((*llout).Assignments, v->Type) != eType_Integer)
		    LLFAILED((&llstate_3.pos, "Bad type of value"));
		if (GetTypeType((*llout).Assignments, v->Type) == eType_Integer &&
		    intx_cmp(&v->U.Integer.Value, &intx_0) < 0)
		    LLFAILED((&llstate_3.pos, "Bad value"));
	    }
	    (*llret) = NewNamedNumber(eNamedNumber_Normal);
	    (*llret)->U.Normal.Identifier = llatt_1;
	    (*llret)->U.Normal.Value = llatt_3;
	
break;
}}}}}
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("NamedBit");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("NamedBit", 1);
return 1;
failed1: LLDEBUG_LEAVE("NamedBit", 0);
return 0;
}

int ll_OctetStringType(XType *llret, LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("OctetStringType");

llstate_0 = *llin;
#undef failed
#define failed failed1
{LLSTATE llstate_1;
if (!llterm(T_OCTET, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed1;
{LLSTATE llstate_2;
if (!llterm(T_STRING, (LLSTYPE *)0, &llstate_1, &llstate_2)) goto failed1;
*llout = llstate_2;
{(*llret) = Builtin_Type_OctetString;
	
}}}
LLDEBUG_LEAVE("OctetStringType", 1);
return 1;
failed1: LLDEBUG_LEAVE("OctetStringType", 0);
return 0;
}

int ll_UTF8StringType(XType *llret, LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("UTF8StringType");

llstate_0 = *llin;
#undef failed
#define failed failed1
{LLSTATE llstate_1;
if (!llterm(T_UTF8String, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed1;
*llout = llstate_1;
{(*llret) = Builtin_Type_UTF8String;
	
}}
LLDEBUG_LEAVE("UTF8StringType", 1);
return 1;
failed1: LLDEBUG_LEAVE("UTF8StringType", 0);
return 0;
}

int ll_NullType(XType *llret, LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("NullType");

llstate_0 = *llin;
#undef failed
#define failed failed1
{LLSTATE llstate_1;
if (!llterm(T_NULL, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed1;
*llout = llstate_1;
{(*llret) = Builtin_Type_Null;
	
}}
LLDEBUG_LEAVE("NullType", 1);
return 1;
failed1: LLDEBUG_LEAVE("NullType", 0);
return 0;
}

int ll_SequenceType(XType *llret, LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("SequenceType");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("SequenceType", 1);
{LLSTATE llstate_1;
if (!llterm(T_SEQUENCE, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
{LLSTATE llstate_2;
if (!llterm('{', (LLSTYPE *)0, &llstate_1, &llstate_2)) goto failed2;
{LLSTATE llstate_3;XComponents llatt_3;
if (!ll_ExtendedComponentTypeList(&llatt_3, &llstate_2, &llstate_3)) goto failed2;
{LLSTATE llstate_4;
if (!llterm('}', (LLSTYPE *)0, &llstate_3, &llstate_4)) goto failed2;
*llout = llstate_4;
{Component_t *c, *d; int fExtended = 0;
	    for (c = llatt_3; c; c = c->Next)
		if (c->Type == eComponent_Optional || c->Type == eComponent_Default || fExtended)
		    KeepOptNames(c->U.NOD.NamedType->Identifier); // global conflict check
		else
		if (c->Type == eComponent_ExtensionMarker)
		    fExtended = 1;
	    for (c = llatt_3; c && c->Next; c = c->Next) {
		if (c->Type != eComponent_Normal &&
		    c->Type != eComponent_Optional &&
		    c->Type != eComponent_Default)
		    continue;
		for (d = c->Next; d; d = d->Next) {
		    if (d->Type != eComponent_Normal &&
			d->Type != eComponent_Optional &&
			d->Type != eComponent_Default)
			continue;
		    if (!strcmp(c->U.NOD.NamedType->Identifier,
			d->U.NOD.NamedType->Identifier))
			LLFAILED((&llstate_3.pos, "Component `%s' has been used twice",
			    c->U.NOD.NamedType->Identifier));
		}
	    }
	    (*llret) = NewType(eType_Sequence);
	    (*llret)->TagDefault = (*llout).TagDefault;
	    (*llret)->ExtensionDefault = (*llout).ExtensionDefault;
	    (*llret)->U.Sequence.Components = llatt_3;
	
break;
}}}}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("SequenceType", 2);
{LLSTATE llstate_1;
if (!llterm(T_SEQUENCE, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
{LLSTATE llstate_2;
if (!llterm('{', (LLSTYPE *)0, &llstate_1, &llstate_2)) goto failed2;
{LLSTATE llstate_3;
if (!llterm('}', (LLSTYPE *)0, &llstate_2, &llstate_3)) goto failed2;
*llout = llstate_3;
{(*llret) = NewType(eType_Sequence);
	    (*llret)->ExtensionDefault = (*llout).ExtensionDefault;
	
break;
}}}}
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("SequenceType");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("SequenceType", 1);
return 1;
failed1: LLDEBUG_LEAVE("SequenceType", 0);
return 0;
}

int ll_ExtensionAndException(XComponents *llret, LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("ExtensionAndException");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("ExtensionAndException", 1);
{LLSTATE llstate_1;
if (!llterm(T_TDOT, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
{LLSTATE llstate_2;
if (!ll_ExceptionSpec(&llstate_1, &llstate_2)) goto failed2;
*llout = llstate_2;
{(*llret) = NewComponent(eComponent_ExtensionMarker);
	    /*(*llret)->U.ExtensionMarker.ExceptionSpec = llatt_2;*/
	
break;
}}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("ExtensionAndException", 2);
{LLSTATE llstate_1;
if (!llterm(T_TDOT, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = NewComponent(eComponent_ExtensionMarker);
	
break;
}}
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("ExtensionAndException");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("ExtensionAndException", 1);
return 1;
failed1: LLDEBUG_LEAVE("ExtensionAndException", 0);
return 0;
}

int ll_ExtendedComponentTypeList(XComponents *llret, LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("ExtendedComponentTypeList");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("ExtendedComponentTypeList", 1);
{LLSTATE llstate_1;XComponents llatt_1;
if (!ll_ComponentTypeList(&llatt_1, &llstate_0, &llstate_1)) goto failed2;
{LLSTATE llstate_2;XComponents llatt_2;
if (!ll_ComponentTypeListExtension(&llatt_2, &llstate_1, &llstate_2)) goto failed2;
*llout = llstate_2;
{Component_t **cc, *c;
	    if (llatt_2) {
		cc = &(*llret);
		for (c = llatt_1; c; c = c->Next) {
		    *cc = DupComponent(c);
		    cc = &(*cc)->Next;
		}
		*cc = llatt_2;
	    } else {
		(*llret) = llatt_1;
	    }
	
break;
}}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("ExtendedComponentTypeList", 2);
{LLSTATE llstate_1;XComponents llatt_1;
if (!ll_ExtensionAndException(&llatt_1, &llstate_0, &llstate_1)) goto failed2;
{LLSTATE llstate_2;XComponents llatt_2;
if (!ll_AdditionalComponentTypeList(&llatt_2, &llstate_1, &llstate_2)) goto failed2;
*llout = llstate_2;
{Component_t **cc, *c;
	    if (llatt_2) {
		cc = &(*llret);
		for (c = llatt_1; c; c = c->Next) {
		    *cc = DupComponent(c);
		    cc = &(*cc)->Next;
		}
		*cc = llatt_2;
	    } else {
		(*llret) = llatt_1;
	    }
	
break;
}}}
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("ExtendedComponentTypeList");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("ExtendedComponentTypeList", 1);
return 1;
failed1: LLDEBUG_LEAVE("ExtendedComponentTypeList", 0);
return 0;
}

int ll_ComponentTypeListExtension(XComponents *llret, LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("ComponentTypeListExtension");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("ComponentTypeListExtension", 1);
{LLSTATE llstate_1;
if (!llterm(',', (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
{LLSTATE llstate_2;XComponents llatt_2;
if (!ll_ExtensionAndException(&llatt_2, &llstate_1, &llstate_2)) goto failed2;
{LLSTATE llstate_3;XComponents llatt_3;
if (!ll_AdditionalComponentTypeList(&llatt_3, &llstate_2, &llstate_3)) goto failed2;
*llout = llstate_3;
{Component_t **cc, *c;
	    if (llatt_3) {
		cc = &(*llret);
		for (c = llatt_2; c; c = c->Next) {
		    *cc = DupComponent(c);
		    cc = &(*cc)->Next;
		}
		*cc = llatt_3;
	    } else {
		(*llret) = llatt_2;
	    }
	
break;
}}}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("ComponentTypeListExtension", 2);
*llout = llstate_0;
{(*llret) = NULL;
	
break;
}
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("ComponentTypeListExtension");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("ComponentTypeListExtension", 1);
return 1;
failed1: LLDEBUG_LEAVE("ComponentTypeListExtension", 0);
return 0;
}

int ll_AdditionalComponentTypeList(XComponents *llret, LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("AdditionalComponentTypeList");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("AdditionalComponentTypeList", 1);
{LLSTATE llstate_1;
if (!llterm(',', (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
{LLSTATE llstate_2;XComponents llatt_2;
if (!ll_ComponentTypeList(&llatt_2, &llstate_1, &llstate_2)) goto failed2;
*llout = llstate_2;
{(*llret) = llatt_2;
	
break;
}}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("AdditionalComponentTypeList", 2);
*llout = llstate_0;
{(*llret) = NULL;
	
break;
}
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("AdditionalComponentTypeList");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("AdditionalComponentTypeList", 1);
return 1;
failed1: LLDEBUG_LEAVE("AdditionalComponentTypeList", 0);
return 0;
}

int ll_ComponentTypeList(XComponents *llret, LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("ComponentTypeList");

llstate_0 = *llin;
#undef failed
#define failed failed1
{LLSTATE llstate_1;XComponents llatt_1;
if (!ll_ComponentType(&llatt_1, &llstate_0, &llstate_1)) goto failed1;
{LLSTATE llstate_2;XComponents llatt_2;
if (!ll_AdditionalComponentTypeList(&llatt_2, &llstate_1, &llstate_2)) goto failed1;
*llout = llstate_2;
{if (llatt_2) {
		(*llret) = DupComponent(llatt_1);
		(*llret)->Next = llatt_2;
	    } else {
		(*llret) = llatt_1;
	    }
	
}}}
LLDEBUG_LEAVE("ComponentTypeList", 1);
return 1;
failed1: LLDEBUG_LEAVE("ComponentTypeList", 0);
return 0;
}

int ll_ComponentType(XComponents *llret, LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("ComponentType");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("ComponentType", 1);
{LLSTATE llstate_1;XNamedType llatt_1;
if (!ll_NamedType(&llatt_1, &llstate_0, &llstate_1)) goto failed2;
{LLSTATE llstate_2;XComponents llatt_2;
if (!ll_ComponentTypePostfix(&llatt_2, &llstate_1, &llstate_2, llatt_1->Type)) goto failed2;
*llout = llstate_2;
{(*llret) = DupComponent(llatt_2);
	    (*llret)->U.NOD.NamedType = llatt_1;
	
break;
}}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("ComponentType", 2);
{LLSTATE llstate_1;
if (!llterm(T_COMPONENTS, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
{LLSTATE llstate_2;
if (!llterm(T_OF, (LLSTYPE *)0, &llstate_1, &llstate_2)) goto failed2;
{LLSTATE llstate_3;XType llatt_3;
if (!ll_Type(&llatt_3, &llstate_2, &llstate_3)) goto failed2;
*llout = llstate_3;
{(*llret) = NewComponent(eComponent_ComponentsOf);
	    (*llret)->U.ComponentsOf.Type = llatt_3;
	
break;
}}}}
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("ComponentType");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("ComponentType", 1);
return 1;
failed1: LLDEBUG_LEAVE("ComponentType", 0);
return 0;
}

int ll_ComponentTypePostfix(XComponents *llret, LLSTATE *llin, LLSTATE *llout, XType llarg_type)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("ComponentTypePostfix");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("ComponentTypePostfix", 1);
{LLSTATE llstate_1;
if (!llterm(T_OPTIONAL, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = NewComponent(eComponent_Optional);
	
break;
}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("ComponentTypePostfix", 2);
{LLSTATE llstate_1;
if (!llterm(T_DEFAULT, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
{LLSTATE llstate_2;XValue llatt_2;
if (!ll_Value(&llatt_2, &llstate_1, &llstate_2, llarg_type)) goto failed2;
*llout = llstate_2;
{(*llret) = NewComponent(eComponent_Default);
	    (*llret)->U.Default.Value = llatt_2;
	
break;
}}}
case 3: case -3:
LLDEBUG_ALTERNATIVE("ComponentTypePostfix", 3);
*llout = llstate_0;
{(*llret) = NewComponent(eComponent_Normal);
	
break;
}
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("ComponentTypePostfix");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("ComponentTypePostfix", 1);
return 1;
failed1: LLDEBUG_LEAVE("ComponentTypePostfix", 0);
return 0;
}

int ll_SequenceOfType(XType *llret, LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("SequenceOfType");

llstate_0 = *llin;
#undef failed
#define failed failed1
{LLSTATE llstate_1;
if (!llterm(T_SEQUENCE, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed1;
{LLSTATE llstate_2;XDirectives llatt_2;
if (!ll_LocalSizeDirectiveESeq(&llatt_2, &llstate_1, &llstate_2)) goto failed1;
{LLSTATE llstate_3;XPrivateDirectives llatt_3;
if (!ll_PrivateDirectives(&llatt_3, &llstate_2, &llstate_3)) goto failed1;
{LLSTATE llstate_4;
if (!llterm(T_OF, (LLSTYPE *)0, &llstate_3, &llstate_4)) goto failed1;
{LLSTATE llstate_5;XType llatt_5;
if (!ll_Type(&llatt_5, &llstate_4, &llstate_5)) goto failed1;
*llout = llstate_5;
{(*llret) = NewType(eType_SequenceOf);
	    (*llret)->ExtensionDefault = (*llout).ExtensionDefault;
	    (*llret)->U.SequenceOf.Type = llatt_5;
	    (*llret)->U.SequenceOf.Directives = llatt_2;
	    if (llatt_3)
	    {
	        PropagatePrivateDirectives((*llret), llatt_3);
	    }
	    if ((*llret)->PrivateDirectives.pszTypeName &&
		strncmp("PSetOf", (*llret)->PrivateDirectives.pszTypeName, 6) == 0)
	    {
		(*llret)->PrivateDirectives.pszTypeName++;
	    }
	
}}}}}}
LLDEBUG_LEAVE("SequenceOfType", 1);
return 1;
failed1: LLDEBUG_LEAVE("SequenceOfType", 0);
return 0;
}

int ll_SetType(XType *llret, LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("SetType");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("SetType", 1);
{LLSTATE llstate_1;
if (!llterm(T_SET, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
{LLSTATE llstate_2;
if (!llterm('{', (LLSTYPE *)0, &llstate_1, &llstate_2)) goto failed2;
{LLSTATE llstate_3;XComponents llatt_3;
if (!ll_ExtendedComponentTypeList(&llatt_3, &llstate_2, &llstate_3)) goto failed2;
{LLSTATE llstate_4;
if (!llterm('}', (LLSTYPE *)0, &llstate_3, &llstate_4)) goto failed2;
*llout = llstate_4;
{Component_t *c, *d;
	    for (c = llatt_3; c && c->Next; c = c->Next) {
		if (c->Type != eComponent_Normal &&
		    c->Type != eComponent_Optional &&
		    c->Type != eComponent_Default)
		    continue;
		for (d = c->Next; d; d = d->Next) {
		    if (d->Type != eComponent_Normal &&
			d->Type != eComponent_Optional &&
			d->Type != eComponent_Default)
			continue;
		    if (!strcmp(c->U.NOD.NamedType->Identifier,
			d->U.NOD.NamedType->Identifier))
			LLFAILED((&llstate_3.pos, "Component `%s' has been used twice",
			    c->U.NOD.NamedType->Identifier));
		}
	    }
	    (*llret) = NewType(eType_Set);
	    (*llret)->TagDefault = (*llout).TagDefault;
	    (*llret)->ExtensionDefault = (*llout).ExtensionDefault;
	    (*llret)->U.Set.Components = llatt_3;
	
break;
}}}}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("SetType", 2);
{LLSTATE llstate_1;
if (!llterm(T_SET, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
{LLSTATE llstate_2;
if (!llterm('{', (LLSTYPE *)0, &llstate_1, &llstate_2)) goto failed2;
{LLSTATE llstate_3;
if (!llterm('}', (LLSTYPE *)0, &llstate_2, &llstate_3)) goto failed2;
*llout = llstate_3;
{(*llret) = NewType(eType_Set);
	    (*llret)->ExtensionDefault = (*llout).ExtensionDefault;
	
break;
}}}}
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("SetType");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("SetType", 1);
return 1;
failed1: LLDEBUG_LEAVE("SetType", 0);
return 0;
}

int ll_SetOfType(XType *llret, LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("SetOfType");

llstate_0 = *llin;
#undef failed
#define failed failed1
{LLSTATE llstate_1;
if (!llterm(T_SET, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed1;
{LLSTATE llstate_2;XDirectives llatt_2;
if (!ll_LocalSizeDirectiveESeq(&llatt_2, &llstate_1, &llstate_2)) goto failed1;
{LLSTATE llstate_3;XPrivateDirectives llatt_3;
if (!ll_PrivateDirectives(&llatt_3, &llstate_2, &llstate_3)) goto failed1;
{LLSTATE llstate_4;
if (!llterm(T_OF, (LLSTYPE *)0, &llstate_3, &llstate_4)) goto failed1;
{LLSTATE llstate_5;XType llatt_5;
if (!ll_Type(&llatt_5, &llstate_4, &llstate_5)) goto failed1;
*llout = llstate_5;
{(*llret) = NewType(eType_SetOf);
	    (*llret)->ExtensionDefault = (*llout).ExtensionDefault;
	    (*llret)->U.SetOf.Type = llatt_5;
	    (*llret)->U.SetOf.Directives = llatt_2;
	    if (llatt_3)
	    {
	    	PropagatePrivateDirectives((*llret), llatt_3);
	    }
	    if ((*llret)->PrivateDirectives.pszTypeName &&
		strncmp("PSetOf", (*llret)->PrivateDirectives.pszTypeName, 6) == 0)
	    {
		(*llret)->PrivateDirectives.pszTypeName++;
	    }
	
}}}}}}
LLDEBUG_LEAVE("SetOfType", 1);
return 1;
failed1: LLDEBUG_LEAVE("SetOfType", 0);
return 0;
}

int ll_ChoiceType(XType *llret, LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("ChoiceType");

llstate_0 = *llin;
#undef failed
#define failed failed1
{LLSTATE llstate_1;
if (!llterm(T_CHOICE, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed1;
{LLSTATE llstate_2;
if (!llterm('{', (LLSTYPE *)0, &llstate_1, &llstate_2)) goto failed1;
{LLSTATE llstate_3;XComponents llatt_3;
if (!ll_ExtendedAlternativeTypeList(&llatt_3, &llstate_2, &llstate_3)) goto failed1;
{LLSTATE llstate_4;
if (!llterm('}', (LLSTYPE *)0, &llstate_3, &llstate_4)) goto failed1;
*llout = llstate_4;
{Component_t *c, *d;
	    for (c = llatt_3; c; c = c->Next)
		if (c->Type == eComponent_Normal ||
		    c->Type == eComponent_Optional ||
		    c->Type == eComponent_Default)
		    KeepChoiceNames(c->U.NOD.NamedType->Identifier); // global conflict check
	    for (c = llatt_3; c && c->Next; c = c->Next) {
		if (c->Type != eComponent_Normal &&
		    c->Type != eComponent_Optional &&
		    c->Type != eComponent_Default)
		    continue;
		for (d = c->Next; d; d = d->Next) {
		    if (d->Type != eComponent_Normal &&
			d->Type != eComponent_Optional &&
			d->Type != eComponent_Default)
			continue;
		    if (!strcmp(c->U.NOD.NamedType->Identifier,
			d->U.NOD.NamedType->Identifier))
			LLFAILED((&llstate_3.pos, "Component `%s' has been used twice",
			    c->U.NOD.NamedType->Identifier));
		}
	    }
	    (*llret) = NewType(eType_Choice);
	    (*llret)->TagDefault = (*llout).TagDefault;
	    (*llret)->ExtensionDefault = (*llout).ExtensionDefault;
	    (*llret)->U.Choice.Components = llatt_3;
	
}}}}}
LLDEBUG_LEAVE("ChoiceType", 1);
return 1;
failed1: LLDEBUG_LEAVE("ChoiceType", 0);
return 0;
}

int ll_ExtendedAlternativeTypeList(XComponents *llret, LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("ExtendedAlternativeTypeList");

llstate_0 = *llin;
#undef failed
#define failed failed1
{LLSTATE llstate_1;XComponents llatt_1;
if (!ll_AlternativeTypeList(&llatt_1, &llstate_0, &llstate_1)) goto failed1;
{LLSTATE llstate_2;XComponents llatt_2;
if (!ll_AlternativeTypeListExtension(&llatt_2, &llstate_1, &llstate_2)) goto failed1;
*llout = llstate_2;
{Component_t **cc, *c;
	    if (llatt_2) {
		cc = &(*llret);
		for (c = llatt_1; c; c = c->Next) {
		    *cc = DupComponent(c);
		    cc = &(*cc)->Next;
		}
		*cc = llatt_2;
	    } else {
		(*llret) = llatt_1;
	    }
	
}}}
LLDEBUG_LEAVE("ExtendedAlternativeTypeList", 1);
return 1;
failed1: LLDEBUG_LEAVE("ExtendedAlternativeTypeList", 0);
return 0;
}

int ll_AlternativeTypeListExtension(XComponents *llret, LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("AlternativeTypeListExtension");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("AlternativeTypeListExtension", 1);
{LLSTATE llstate_1;
if (!llterm(',', (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
{LLSTATE llstate_2;XComponents llatt_2;
if (!ll_ExtensionAndException(&llatt_2, &llstate_1, &llstate_2)) goto failed2;
{LLSTATE llstate_3;XComponents llatt_3;
if (!ll_AdditionalAlternativeTypeList(&llatt_3, &llstate_2, &llstate_3)) goto failed2;
*llout = llstate_3;
{Component_t **cc, *c;
	    if (llatt_3) {
		cc = &(*llret);
		for (c = llatt_2; c; c = c->Next) {
		    *cc = DupComponent(c);
		    cc = &(*cc)->Next;
		}
		*cc = llatt_3;
	    } else {
		(*llret) = llatt_2;
	    }
	
break;
}}}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("AlternativeTypeListExtension", 2);
*llout = llstate_0;
{(*llret) = NULL;
	
break;
}
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("AlternativeTypeListExtension");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("AlternativeTypeListExtension", 1);
return 1;
failed1: LLDEBUG_LEAVE("AlternativeTypeListExtension", 0);
return 0;
}

int ll_AdditionalAlternativeTypeList(XComponents *llret, LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("AdditionalAlternativeTypeList");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("AdditionalAlternativeTypeList", 1);
{LLSTATE llstate_1;
if (!llterm(',', (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
{LLSTATE llstate_2;XComponents llatt_2;
if (!ll_AlternativeTypeList(&llatt_2, &llstate_1, &llstate_2)) goto failed2;
*llout = llstate_2;
{(*llret) = llatt_2;
	
break;
}}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("AdditionalAlternativeTypeList", 2);
*llout = llstate_0;
{(*llret) = NULL;
	
break;
}
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("AdditionalAlternativeTypeList");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("AdditionalAlternativeTypeList", 1);
return 1;
failed1: LLDEBUG_LEAVE("AdditionalAlternativeTypeList", 0);
return 0;
}

int ll_AlternativeTypeList(XComponents *llret, LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("AlternativeTypeList");

llstate_0 = *llin;
#undef failed
#define failed failed1
{LLSTATE llstate_1;XNamedType llatt_1;
if (!ll_NamedType(&llatt_1, &llstate_0, &llstate_1)) goto failed1;
{LLSTATE llstate_2;XComponents llatt_2;
if (!ll_AdditionalAlternativeTypeList(&llatt_2, &llstate_1, &llstate_2)) goto failed1;
*llout = llstate_2;
{(*llret) = NewComponent(eComponent_Normal);
	    (*llret)->U.Normal.NamedType = llatt_1;
	    (*llret)->Next = llatt_2;
	
}}}
LLDEBUG_LEAVE("AlternativeTypeList", 1);
return 1;
failed1: LLDEBUG_LEAVE("AlternativeTypeList", 0);
return 0;
}

int ll_AnyType(XType *llret, LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("AnyType");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("AnyType", 1);
{LLSTATE llstate_1;
if (!llterm(T_ANY, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = Builtin_Type_Open;
	
break;
}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("AnyType", 2);
{LLSTATE llstate_1;
if (!llterm(T_ANY, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
{LLSTATE llstate_2;
if (!llterm(T_DEFINED, (LLSTYPE *)0, &llstate_1, &llstate_2)) goto failed2;
{LLSTATE llstate_3;
if (!llterm(T_BY, (LLSTYPE *)0, &llstate_2, &llstate_3)) goto failed2;
{LLSTATE llstate_4;XString llatt_4;
if (!ll_identifier(&llatt_4, &llstate_3, &llstate_4)) goto failed2;
*llout = llstate_4;
{(*llret) = Builtin_Type_Open;
	
break;
}}}}}
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("AnyType");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("AnyType", 1);
return 1;
failed1: LLDEBUG_LEAVE("AnyType", 0);
return 0;
}

int ll_SelectionType(XType *llret, LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("SelectionType");

llstate_0 = *llin;
#undef failed
#define failed failed1
{LLSTATE llstate_1;XString llatt_1;
if (!ll_identifier(&llatt_1, &llstate_0, &llstate_1)) goto failed1;
{LLSTATE llstate_2;
if (!llterm('<', (LLSTYPE *)0, &llstate_1, &llstate_2)) goto failed1;
{LLSTATE llstate_3;XType llatt_3;
if (!ll_Type(&llatt_3, &llstate_2, &llstate_3)) goto failed1;
*llout = llstate_3;
{(*llret) = NewType(eType_Selection);
	    (*llret)->U.Selection.Identifier = llatt_1;
	    (*llret)->U.Selection.Type = llatt_3;
	
}}}}
LLDEBUG_LEAVE("SelectionType", 1);
return 1;
failed1: LLDEBUG_LEAVE("SelectionType", 0);
return 0;
}

int ll_TaggedType(XType *llret, LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("TaggedType");

llstate_0 = *llin;
#undef failed
#define failed failed1
{LLSTATE llstate_1;XTags llatt_1;
if (!ll_Tag(&llatt_1, &llstate_0, &llstate_1)) goto failed1;
{LLSTATE llstate_2;XTagType llatt_2;
if (!ll_TagType(&llatt_2, &llstate_1, &llstate_2)) goto failed1;
{LLSTATE llstate_3;XType llatt_3;
if (!ll_Type(&llatt_3, &llstate_2, &llstate_3)) goto failed1;
*llout = llstate_3;
{Tag_t *t;
	    Type_e eType = GetTypeType((*llout).Assignments, llatt_3);
	    if (eType == eType_Choice || eType == eType_Open)
	    {
	    	if (llatt_2 == eTagType_Unknown &&
	    	    ((*llout).TagDefault == eTagType_Implicit || (*llout).TagDefault == eTagType_Automatic))
	    	{
	    	    llatt_2 = eTagType_Explicit;
	    	}
	    	else
	    	if (llatt_2 == eTagType_Implicit)
	    	{
		    for (t = llatt_3->Tags; t; t = t->Next) {
		        if (t->Type == eTagType_Explicit)
			    break;
		    }
		    if (!t)
		        LLFAILED((&llstate_3.pos, "Bad tag type for choice/open type"));
	        }
	    }
	    (*llret) = DupType(llatt_3);
	    (*llret)->Tags = DupTag(llatt_1);
	    (*llret)->Tags->Type = llatt_2;
	    (*llret)->Tags->Next = llatt_3->Tags;
	
}}}}
LLDEBUG_LEAVE("TaggedType", 1);
return 1;
failed1: LLDEBUG_LEAVE("TaggedType", 0);
return 0;
}

int ll_TagType(XTagType *llret, LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("TagType");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("TagType", 1);
*llout = llstate_0;
{(*llret) = eTagType_Unknown;
	
break;
}
case 2: case -2:
LLDEBUG_ALTERNATIVE("TagType", 2);
{LLSTATE llstate_1;
if (!llterm(T_IMPLICIT, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = eTagType_Implicit;
	
break;
}}
case 3: case -3:
LLDEBUG_ALTERNATIVE("TagType", 3);
{LLSTATE llstate_1;
if (!llterm(T_EXPLICIT, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = eTagType_Explicit;
	
break;
}}
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("TagType");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("TagType", 1);
return 1;
failed1: LLDEBUG_LEAVE("TagType", 0);
return 0;
}

int ll_Tag(XTags *llret, LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("Tag");

llstate_0 = *llin;
#undef failed
#define failed failed1
{LLSTATE llstate_1;
if (!llterm('[', (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed1;
{LLSTATE llstate_2;XTagClass llatt_2;
if (!ll_Class(&llatt_2, &llstate_1, &llstate_2)) goto failed1;
{LLSTATE llstate_3;XValue llatt_3;
if (!ll_ClassNumber(&llatt_3, &llstate_2, &llstate_3)) goto failed1;
{LLSTATE llstate_4;
if (!llterm(']', (LLSTYPE *)0, &llstate_3, &llstate_4)) goto failed1;
*llout = llstate_4;
{(*llret) = NewTag(eTagType_Unknown);
	    (*llret)->Class = llatt_2;
	    (*llret)->Tag = llatt_3;
	
}}}}}
LLDEBUG_LEAVE("Tag", 1);
return 1;
failed1: LLDEBUG_LEAVE("Tag", 0);
return 0;
}

int ll_ClassNumber(XValue *llret, LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("ClassNumber");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("ClassNumber", 1);
{LLSTATE llstate_1;XNumber llatt_1;
if (!llterm(T_number, &lllval, &llstate_0, &llstate_1)) goto failed2;
llatt_1 = lllval._XNumber;
*llout = llstate_1;
{if (intx_cmp(&llatt_1, &intx_1G) >= 0)
		LLFAILED((&llstate_1.pos, "Bad tag value"));
	    (*llret) = NewValue(NULL, Builtin_Type_Integer);
	    (*llret)->U.Integer.Value = llatt_1;
	
break;
}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("ClassNumber", 2);
{LLSTATE llstate_1;XValue llatt_1;
if (!ll_DefinedValue(&llatt_1, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{Value_t *v;
	    v = GetValue((*llout).Assignments, llatt_1);
	    if (v &&
		GetTypeType((*llout).Assignments, v->Type) != eType_Integer &&
		GetTypeType((*llout).Assignments, v->Type) != eType_Undefined)
		LLFAILED((&llstate_1.pos, "Bad type of tag value"));
	    if (v &&
		GetTypeType((*llout).Assignments, v->Type) == eType_Integer &&
		(intx_cmp(&v->U.Integer.Value, &intx_0) < 0 ||
		intx_cmp(&v->U.Integer.Value, &intx_1G) >= 0))
		LLFAILED((&llstate_1.pos, "Bad tag value"));
	    (*llret) = llatt_1;
	
break;
}}
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("ClassNumber");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("ClassNumber", 1);
return 1;
failed1: LLDEBUG_LEAVE("ClassNumber", 0);
return 0;
}

int ll_Class(XTagClass *llret, LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("Class");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("Class", 1);
{LLSTATE llstate_1;
if (!llterm(T_UNIVERSAL, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = eTagClass_Universal;
	
break;
}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("Class", 2);
{LLSTATE llstate_1;
if (!llterm(T_APPLICATION, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = eTagClass_Application;
	
break;
}}
case 3: case -3:
LLDEBUG_ALTERNATIVE("Class", 3);
{LLSTATE llstate_1;
if (!llterm(T_PRIVATE, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = eTagClass_Private;
	
break;
}}
case 4: case -4:
LLDEBUG_ALTERNATIVE("Class", 4);
*llout = llstate_0;
{(*llret) = eTagClass_Unknown;
	
break;
}
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("Class");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("Class", 1);
return 1;
failed1: LLDEBUG_LEAVE("Class", 0);
return 0;
}

int ll_ObjectIdentifierType(XType *llret, LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("ObjectIdentifierType");

llstate_0 = *llin;
#undef failed
#define failed failed1
{LLSTATE llstate_1;
if (!llterm(T_OBJECT, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed1;
{LLSTATE llstate_2;
if (!llterm(T_IDENTIFIER, (LLSTYPE *)0, &llstate_1, &llstate_2)) goto failed1;
*llout = llstate_2;
{(*llret) = Builtin_Type_ObjectIdentifier;
	
}}}
LLDEBUG_LEAVE("ObjectIdentifierType", 1);
return 1;
failed1: LLDEBUG_LEAVE("ObjectIdentifierType", 0);
return 0;
}

int ll_EmbeddedPDVType(XType *llret, LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("EmbeddedPDVType");

llstate_0 = *llin;
#undef failed
#define failed failed1
{LLSTATE llstate_1;
if (!llterm(T_EMBEDDED, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed1;
{LLSTATE llstate_2;
if (!llterm(T_PDV, (LLSTYPE *)0, &llstate_1, &llstate_2)) goto failed1;
*llout = llstate_2;
{(*llret) = Builtin_Type_EmbeddedPdv;
	
}}}
LLDEBUG_LEAVE("EmbeddedPDVType", 1);
return 1;
failed1: LLDEBUG_LEAVE("EmbeddedPDVType", 0);
return 0;
}

int ll_ExternalType(XType *llret, LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("ExternalType");

llstate_0 = *llin;
#undef failed
#define failed failed1
{LLSTATE llstate_1;
if (!llterm(T_EXTERNAL, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed1;
*llout = llstate_1;
{(*llret) = Builtin_Type_External;
	
}}
LLDEBUG_LEAVE("ExternalType", 1);
return 1;
failed1: LLDEBUG_LEAVE("ExternalType", 0);
return 0;
}

int ll_CharacterStringType(XType *llret, LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("CharacterStringType");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("CharacterStringType", 1);
{LLSTATE llstate_1;XType llatt_1;
if (!ll_RestrictedCharacterStringType(&llatt_1, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = llatt_1;
	
break;
}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("CharacterStringType", 2);
{LLSTATE llstate_1;XType llatt_1;
if (!ll_UnrestrictedCharacterStringType(&llatt_1, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = llatt_1;
	
break;
}}
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("CharacterStringType");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("CharacterStringType", 1);
return 1;
failed1: LLDEBUG_LEAVE("CharacterStringType", 0);
return 0;
}

int ll_RestrictedCharacterStringType(XType *llret, LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("RestrictedCharacterStringType");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("RestrictedCharacterStringType", 1);
{LLSTATE llstate_1;
if (!llterm(T_BMPString, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = Builtin_Type_BMPString;
	
break;
}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("RestrictedCharacterStringType", 2);
{LLSTATE llstate_1;
if (!llterm(T_GeneralString, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = Builtin_Type_GeneralString;
	
break;
}}
case 3: case -3:
LLDEBUG_ALTERNATIVE("RestrictedCharacterStringType", 3);
{LLSTATE llstate_1;
if (!llterm(T_GraphicString, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = Builtin_Type_GraphicString;
	
break;
}}
case 4: case -4:
LLDEBUG_ALTERNATIVE("RestrictedCharacterStringType", 4);
{LLSTATE llstate_1;
if (!llterm(T_IA5String, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = Builtin_Type_IA5String;
	
break;
}}
case 5: case -5:
LLDEBUG_ALTERNATIVE("RestrictedCharacterStringType", 5);
{LLSTATE llstate_1;
if (!llterm(T_ISO646String, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = Builtin_Type_ISO646String;
	
break;
}}
case 6: case -6:
LLDEBUG_ALTERNATIVE("RestrictedCharacterStringType", 6);
{LLSTATE llstate_1;
if (!llterm(T_NumericString, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = Builtin_Type_NumericString;
	
break;
}}
case 7: case -7:
LLDEBUG_ALTERNATIVE("RestrictedCharacterStringType", 7);
{LLSTATE llstate_1;
if (!llterm(T_PrintableString, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = Builtin_Type_PrintableString;
	
break;
}}
case 8: case -8:
LLDEBUG_ALTERNATIVE("RestrictedCharacterStringType", 8);
{LLSTATE llstate_1;
if (!llterm(T_TeletexString, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = Builtin_Type_TeletexString;
	
break;
}}
case 9: case -9:
LLDEBUG_ALTERNATIVE("RestrictedCharacterStringType", 9);
{LLSTATE llstate_1;
if (!llterm(T_T61String, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = Builtin_Type_T61String;
	
break;
}}
case 10: case -10:
LLDEBUG_ALTERNATIVE("RestrictedCharacterStringType", 10);
{LLSTATE llstate_1;
if (!llterm(T_UniversalString, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = Builtin_Type_UniversalString;
	
break;
}}
case 11: case -11:
LLDEBUG_ALTERNATIVE("RestrictedCharacterStringType", 11);
{LLSTATE llstate_1;
if (!llterm(T_VideotexString, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = Builtin_Type_VideotexString;
	
break;
}}
case 12: case -12:
LLDEBUG_ALTERNATIVE("RestrictedCharacterStringType", 12);
{LLSTATE llstate_1;
if (!llterm(T_VisibleString, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = Builtin_Type_VisibleString;
	
break;
}}
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("RestrictedCharacterStringType");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("RestrictedCharacterStringType", 1);
return 1;
failed1: LLDEBUG_LEAVE("RestrictedCharacterStringType", 0);
return 0;
}

int ll_UnrestrictedCharacterStringType(XType *llret, LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("UnrestrictedCharacterStringType");

llstate_0 = *llin;
#undef failed
#define failed failed1
{LLSTATE llstate_1;
if (!llterm(T_CHARACTER, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed1;
{LLSTATE llstate_2;
if (!llterm(T_STRING, (LLSTYPE *)0, &llstate_1, &llstate_2)) goto failed1;
*llout = llstate_2;
{(*llret) = Builtin_Type_CharacterString;
	
}}}
LLDEBUG_LEAVE("UnrestrictedCharacterStringType", 1);
return 1;
failed1: LLDEBUG_LEAVE("UnrestrictedCharacterStringType", 0);
return 0;
}

int ll_UsefulType(XType *llret, LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("UsefulType");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("UsefulType", 1);
{LLSTATE llstate_1;
if (!llterm(T_GeneralizedTime, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = Builtin_Type_GeneralizedTime;
	
break;
}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("UsefulType", 2);
{LLSTATE llstate_1;
if (!llterm(T_UTCTime, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = Builtin_Type_UTCTime;
	
break;
}}
case 3: case -3:
LLDEBUG_ALTERNATIVE("UsefulType", 3);
{LLSTATE llstate_1;
if (!llterm(T_ObjectDescriptor, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = Builtin_Type_ObjectDescriptor;
	
break;
}}
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("UsefulType");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("UsefulType", 1);
return 1;
failed1: LLDEBUG_LEAVE("UsefulType", 0);
return 0;
}

int ll_TypeWithConstraint(XType *llret, LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("TypeWithConstraint");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("TypeWithConstraint", 1);
{LLSTATE llstate_1;
if (!llterm(T_SET, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
{LLSTATE llstate_2;XDirectives llatt_2;
if (!ll_LocalSizeDirectiveESeq(&llatt_2, &llstate_1, &llstate_2)) goto failed2;
{LLSTATE llstate_3;XPrivateDirectives llatt_3;
if (!ll_PrivateDirectives(&llatt_3, &llstate_2, &llstate_3)) goto failed2;
{LLSTATE llstate_4;XConstraints llatt_4;
if (!ll_Constraint(&llatt_4, &llstate_3, &llstate_4, NULL, 0)) goto failed2;
{LLSTATE llstate_5;XDirectives llatt_5;
if (!ll_LocalSizeDirectiveESeq(&llatt_5, &llstate_4, &llstate_5)) goto failed2;
{LLSTATE llstate_6;
if (!llterm(T_OF, (LLSTYPE *)0, &llstate_5, &llstate_6)) goto failed2;
{LLSTATE llstate_7;XType llatt_7;
if (!ll_Type(&llatt_7, &llstate_6, &llstate_7)) goto failed2;
*llout = llstate_7;
{Directive_t **dd, *d;
	    (*llret) = NewType(eType_SetOf);
	    (*llret)->ExtensionDefault = (*llout).ExtensionDefault;
	    (*llret)->Constraints = llatt_4;
	    (*llret)->U.SetOf.Type = llatt_7;
	    if (llatt_3)
	    {
	    	PropagatePrivateDirectives((*llret), llatt_3);
	    }
	    dd = &(*llret)->U.SetOf.Directives;
	    for (d = llatt_2; d; d = d->Next) {
		*dd = DupDirective(d);
		dd = &(*dd)->Next;
	    }
	    for (d = llatt_5; d; d = d->Next) {
		*dd = DupDirective(d);
		dd = &(*dd)->Next;
	    }
	    *dd = NULL;
	    if ((*llret)->PrivateDirectives.pszTypeName &&
		strncmp("PSetOf", (*llret)->PrivateDirectives.pszTypeName, 6) == 0)
	    {
		(*llret)->PrivateDirectives.pszTypeName++;
	    }
	
break;
}}}}}}}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("TypeWithConstraint", 2);
{LLSTATE llstate_1;
if (!llterm(T_SET, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
{LLSTATE llstate_2;XDirectives llatt_2;
if (!ll_LocalSizeDirectiveESeq(&llatt_2, &llstate_1, &llstate_2)) goto failed2;
{LLSTATE llstate_3;XPrivateDirectives llatt_3;
if (!ll_PrivateDirectives(&llatt_3, &llstate_2, &llstate_3)) goto failed2;
{LLSTATE llstate_4;XSubtypeElement llatt_4;
if (!ll_SizeConstraint(&llatt_4, &llstate_3, &llstate_4)) goto failed2;
{LLSTATE llstate_5;XDirectives llatt_5;
if (!ll_LocalSizeDirectiveESeq(&llatt_5, &llstate_4, &llstate_5)) goto failed2;
{LLSTATE llstate_6;XPrivateDirectives llatt_6;
if (!ll_PrivateDirectives(&llatt_6, &llstate_5, &llstate_6)) goto failed2;
{LLSTATE llstate_7;
if (!llterm(T_OF, (LLSTYPE *)0, &llstate_6, &llstate_7)) goto failed2;
{LLSTATE llstate_8;XType llatt_8;
if (!ll_Type(&llatt_8, &llstate_7, &llstate_8)) goto failed2;
*llout = llstate_8;
{Directive_t **dd, *d;
	    (*llret) = NewType(eType_SetOf);
	    (*llret)->ExtensionDefault = (*llout).ExtensionDefault;
	    (*llret)->Constraints = NewConstraint();
	    (*llret)->Constraints->Type = eExtension_Unextended;
	    (*llret)->Constraints->Root = NewElementSetSpec(
		eElementSetSpec_SubtypeElement);
	    (*llret)->Constraints->Root->U.SubtypeElement.SubtypeElement = llatt_4;
	    (*llret)->U.SetOf.Type = llatt_8;
	    if (llatt_3)
	    {
	    	PropagatePrivateDirectives((*llret), llatt_3);
	    }
	    if (llatt_6)
	    {
	    	PropagatePrivateDirectives((*llret), llatt_6);
	    }
	    dd = &(*llret)->U.SetOf.Directives;
	    for (d = llatt_2; d; d = d->Next) {
		*dd = DupDirective(d);
		dd = &(*dd)->Next;
	    }
	    for (d = llatt_5; d; d = d->Next) {
		*dd = DupDirective(d);
		dd = &(*dd)->Next;
	    }
	    *dd = NULL;
	    if ((*llret)->PrivateDirectives.pszTypeName &&
		strncmp("PSetOf", (*llret)->PrivateDirectives.pszTypeName, 6) == 0)
	    {
		(*llret)->PrivateDirectives.pszTypeName++;
	    }
	
break;
}}}}}}}}}
case 3: case -3:
LLDEBUG_ALTERNATIVE("TypeWithConstraint", 3);
{LLSTATE llstate_1;
if (!llterm(T_SEQUENCE, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
{LLSTATE llstate_2;XDirectives llatt_2;
if (!ll_LocalSizeDirectiveESeq(&llatt_2, &llstate_1, &llstate_2)) goto failed2;
{LLSTATE llstate_3;XPrivateDirectives llatt_3;
if (!ll_PrivateDirectives(&llatt_3, &llstate_2, &llstate_3)) goto failed2;
{LLSTATE llstate_4;XConstraints llatt_4;
if (!ll_Constraint(&llatt_4, &llstate_3, &llstate_4, NULL, 0)) goto failed2;
{LLSTATE llstate_5;XDirectives llatt_5;
if (!ll_LocalSizeDirectiveESeq(&llatt_5, &llstate_4, &llstate_5)) goto failed2;
{LLSTATE llstate_6;
if (!llterm(T_OF, (LLSTYPE *)0, &llstate_5, &llstate_6)) goto failed2;
{LLSTATE llstate_7;XType llatt_7;
if (!ll_Type(&llatt_7, &llstate_6, &llstate_7)) goto failed2;
*llout = llstate_7;
{Directive_t **dd, *d;
	    (*llret) = NewType(eType_SequenceOf);
	    (*llret)->ExtensionDefault = (*llout).ExtensionDefault;
	    (*llret)->Constraints = llatt_4;
	    (*llret)->U.SequenceOf.Type = llatt_7;
	    if (llatt_3)
	    {
		PropagatePrivateDirectives((*llret), llatt_3);
	    }
	    dd = &(*llret)->U.SequenceOf.Directives;
	    for (d = llatt_2; d; d = d->Next) {
		*dd = DupDirective(d);
		dd = &(*dd)->Next;
	    }
	    for (d = llatt_5; d; d = d->Next) {
		*dd = DupDirective(d);
		dd = &(*dd)->Next;
	    }
	    *dd = NULL;
	    if ((*llret)->PrivateDirectives.pszTypeName &&
		strncmp("PSetOf", (*llret)->PrivateDirectives.pszTypeName, 6) == 0)
	    {
		(*llret)->PrivateDirectives.pszTypeName++;
	    }
	
break;
}}}}}}}}
case 4: case -4:
LLDEBUG_ALTERNATIVE("TypeWithConstraint", 4);
{LLSTATE llstate_1;
if (!llterm(T_SEQUENCE, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
{LLSTATE llstate_2;XDirectives llatt_2;
if (!ll_LocalSizeDirectiveESeq(&llatt_2, &llstate_1, &llstate_2)) goto failed2;
{LLSTATE llstate_3;XPrivateDirectives llatt_3;
if (!ll_PrivateDirectives(&llatt_3, &llstate_2, &llstate_3)) goto failed2;
{LLSTATE llstate_4;XSubtypeElement llatt_4;
if (!ll_SizeConstraint(&llatt_4, &llstate_3, &llstate_4)) goto failed2;
{LLSTATE llstate_5;XDirectives llatt_5;
if (!ll_LocalSizeDirectiveESeq(&llatt_5, &llstate_4, &llstate_5)) goto failed2;
{LLSTATE llstate_6;XPrivateDirectives llatt_6;
if (!ll_PrivateDirectives(&llatt_6, &llstate_5, &llstate_6)) goto failed2;
{LLSTATE llstate_7;
if (!llterm(T_OF, (LLSTYPE *)0, &llstate_6, &llstate_7)) goto failed2;
{LLSTATE llstate_8;XType llatt_8;
if (!ll_Type(&llatt_8, &llstate_7, &llstate_8)) goto failed2;
*llout = llstate_8;
{Directive_t **dd, *d;
	    (*llret) = NewType(eType_SequenceOf);
	    (*llret)->ExtensionDefault = (*llout).ExtensionDefault;
	    (*llret)->Constraints = NewConstraint();
	    (*llret)->Constraints->Type = eExtension_Unextended;
	    (*llret)->Constraints->Root = NewElementSetSpec(
		eElementSetSpec_SubtypeElement);
	    (*llret)->Constraints->Root->U.SubtypeElement.SubtypeElement = llatt_4;
	    (*llret)->U.SequenceOf.Type = llatt_8;
	    if (llatt_3)
	    {
	    	PropagatePrivateDirectives((*llret), llatt_3);
	    }
	    if (llatt_6)
	    {
	    	PropagatePrivateDirectives((*llret), llatt_6);
	    }
	    dd = &(*llret)->U.SequenceOf.Directives;
	    for (d = llatt_2; d; d = d->Next) {
		*dd = DupDirective(d);
		dd = &(*dd)->Next;
	    }
	    for (d = llatt_5; d; d = d->Next) {
		*dd = DupDirective(d);
		dd = &(*dd)->Next;
	    }
	    *dd = NULL;
	    if ((*llret)->PrivateDirectives.pszTypeName &&
		strncmp("PSetOf", (*llret)->PrivateDirectives.pszTypeName, 6) == 0)
	    {
		(*llret)->PrivateDirectives.pszTypeName++;
	    }
	
break;
}}}}}}}}}
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("TypeWithConstraint");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("TypeWithConstraint", 1);
return 1;
failed1: LLDEBUG_LEAVE("TypeWithConstraint", 0);
return 0;
}

int ll_DefinedValue(XValue *llret, LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("DefinedValue");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("DefinedValue", 1);
{LLSTATE llstate_1;XValue llatt_1;
if (!ll_Externalvaluereference(&llatt_1, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = llatt_1;
	
break;
}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("DefinedValue", 2);
{LLSTATE llstate_1;XValue llatt_1;
if (!ll_valuereference(&llatt_1, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = llatt_1;
	
break;
}}
case 3: case -3:
LLDEBUG_ALTERNATIVE("DefinedValue", 3);
{LLSTATE llstate_1;
if (!ll_ParameterizedValue(&llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{MyAbort();
	
break;
}}
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("DefinedValue");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("DefinedValue", 1);
return 1;
failed1: LLDEBUG_LEAVE("DefinedValue", 0);
return 0;
}

int ll_ValueAssignment(LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("ValueAssignment");

llstate_0 = *llin;
#undef failed
#define failed failed1
{LLSTATE llstate_1;XValue llatt_1;
if (!ll_valuereference(&llatt_1, &llstate_0, &llstate_1)) goto failed1;
{LLSTATE llstate_2;XType llatt_2;
if (!ll_Type(&llatt_2, &llstate_1, &llstate_2)) goto failed1;
{LLSTATE llstate_3;
if (!llterm(T_DEF, (LLSTYPE *)0, &llstate_2, &llstate_3)) goto failed1;
{LLSTATE llstate_4;XValue llatt_4;
if (!ll_Value(&llatt_4, &llstate_3, &llstate_4, llatt_2)) goto failed1;
*llout = llstate_4;
{if (!AssignValue(&(*llout).Assignments, llatt_1, llatt_4))
		LLFAILED((&llstate_1.pos, "Value `%s' twice defined",
		    llatt_1->U.Reference.Identifier));
	
}}}}}
LLDEBUG_LEAVE("ValueAssignment", 1);
return 1;
failed1: LLDEBUG_LEAVE("ValueAssignment", 0);
return 0;
}

int ll_Value(XValue *llret, LLSTATE *llin, LLSTATE *llout, XType llarg_type)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("Value");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("Value", 1);
{LLSTATE llstate_1;XValue llatt_1;
if (!ll_BuiltinValue(&llatt_1, &llstate_0, &llstate_1, llarg_type)) goto failed2;
*llout = llstate_1;
{(*llret) = llatt_1;
	
break;
}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("Value", 2);
{LLSTATE llstate_1;XValue llatt_1;
if (!ll_ReferencedValue(&llatt_1, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = llatt_1;
	
break;
}}
case 3: case -3:
LLDEBUG_ALTERNATIVE("Value", 3);
{LLSTATE llstate_1;XValue llatt_1;
if (!ll_ObjectClassFieldValue(&llatt_1, &llstate_0, &llstate_1, llarg_type)) goto failed2;
*llout = llstate_1;
{(*llret) = llatt_1;
	
break;
}}
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("Value");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("Value", 1);
return 1;
failed1: LLDEBUG_LEAVE("Value", 0);
return 0;
}

int ll_BuiltinValue(XValue *llret, LLSTATE *llin, LLSTATE *llout, XType llarg_type)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("BuiltinValue");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("BuiltinValue", 1);
{if (GetTypeType((*llin).Assignments, llarg_type) != eType_Undefined &&
		GetTypeType((*llin).Assignments, llarg_type) != eType_BitString)
		LLFAILED((&llstate_0.pos, "Bad type of value"));
	
{LLSTATE llstate_1;XValue llatt_1;
if (!ll_BitStringValue(&llatt_1, &llstate_0, &llstate_1, llarg_type)) goto failed2;
*llout = llstate_1;
{(*llret) = llatt_1;
	
break;
}}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("BuiltinValue", 2);
{if (GetTypeType((*llin).Assignments, llarg_type) != eType_Undefined &&
		GetTypeType((*llin).Assignments, llarg_type) != eType_Boolean)
		LLFAILED((&llstate_0.pos, "Bad type of value"));
	
{LLSTATE llstate_1;XValue llatt_1;
if (!ll_BooleanValue(&llatt_1, &llstate_0, &llstate_1, llarg_type)) goto failed2;
*llout = llstate_1;
{(*llret) = llatt_1;
	
break;
}}}
case 3: case -3:
LLDEBUG_ALTERNATIVE("BuiltinValue", 3);
{LLSTATE llstate_1;XValue llatt_1;
if (!ll_CharacterStringValue(&llatt_1, &llstate_0, &llstate_1, llarg_type)) goto failed2;
*llout = llstate_1;
{(*llret) = llatt_1;
	
break;
}}
case 4: case -4:
LLDEBUG_ALTERNATIVE("BuiltinValue", 4);
{if (GetTypeType((*llin).Assignments, llarg_type) != eType_Undefined &&
		GetTypeType((*llin).Assignments, llarg_type) != eType_Choice)
		LLFAILED((&llstate_0.pos, "Bad type of value"));
	
{LLSTATE llstate_1;XValue llatt_1;
if (!ll_ChoiceValue(&llatt_1, &llstate_0, &llstate_1, llarg_type)) goto failed2;
*llout = llstate_1;
{(*llret) = llatt_1;
	
break;
}}}
case 5: case -5:
LLDEBUG_ALTERNATIVE("BuiltinValue", 5);
{if (GetTypeType((*llin).Assignments, llarg_type) != eType_Undefined &&
		GetTypeType((*llin).Assignments, llarg_type) != eType_EmbeddedPdv)
		LLFAILED((&llstate_0.pos, "Bad type of value"));
	
{LLSTATE llstate_1;XValue llatt_1;
if (!ll_EmbeddedPDVValue(&llatt_1, &llstate_0, &llstate_1, llarg_type)) goto failed2;
*llout = llstate_1;
{(*llret) = llatt_1;
	
break;
}}}
case 6: case -6:
LLDEBUG_ALTERNATIVE("BuiltinValue", 6);
{if (GetTypeType((*llin).Assignments, llarg_type) != eType_Undefined &&
		GetTypeType((*llin).Assignments, llarg_type) != eType_Enumerated)
		LLFAILED((&llstate_0.pos, "Bad type of value"));
	
{LLSTATE llstate_1;XValue llatt_1;
if (!ll_EnumeratedValue(&llatt_1, &llstate_0, &llstate_1, llarg_type)) goto failed2;
*llout = llstate_1;
{(*llret) = llatt_1;
	
break;
}}}
case 7: case -7:
LLDEBUG_ALTERNATIVE("BuiltinValue", 7);
{if (GetTypeType((*llin).Assignments, llarg_type) != eType_Undefined &&
		GetTypeType((*llin).Assignments, llarg_type) != eType_External)
		LLFAILED((&llstate_0.pos, "Bad type of value"));
	
{LLSTATE llstate_1;XValue llatt_1;
if (!ll_ExternalValue(&llatt_1, &llstate_0, &llstate_1, llarg_type)) goto failed2;
*llout = llstate_1;
{(*llret) = llatt_1;
	
break;
}}}
case 8: case -8:
LLDEBUG_ALTERNATIVE("BuiltinValue", 8);
{if (GetTypeType((*llin).Assignments, llarg_type) != eType_Undefined &&
		GetTypeType((*llin).Assignments, llarg_type) != eType_InstanceOf)
		LLFAILED((&llstate_0.pos, "Bad type of value"));
	
{LLSTATE llstate_1;XValue llatt_1;
if (!ll_InstanceOfValue(&llatt_1, &llstate_0, &llstate_1, llarg_type)) goto failed2;
*llout = llstate_1;
{(*llret) = llatt_1;
	
break;
}}}
case 9: case -9:
LLDEBUG_ALTERNATIVE("BuiltinValue", 9);
{if (GetTypeType((*llin).Assignments, llarg_type) != eType_Undefined &&
		GetTypeType((*llin).Assignments, llarg_type) != eType_Integer)
		LLFAILED((&llstate_0.pos, "Bad type of value"));
	
{LLSTATE llstate_1;XValue llatt_1;
if (!ll_IntegerValue(&llatt_1, &llstate_0, &llstate_1, llarg_type)) goto failed2;
*llout = llstate_1;
{(*llret) = llatt_1;
	
break;
}}}
case 10: case -10:
LLDEBUG_ALTERNATIVE("BuiltinValue", 10);
{if (GetTypeType((*llin).Assignments, llarg_type) != eType_Undefined &&
		GetTypeType((*llin).Assignments, llarg_type) != eType_Null)
		LLFAILED((&llstate_0.pos, "Bad type of value"));
	
{LLSTATE llstate_1;XValue llatt_1;
if (!ll_NullValue(&llatt_1, &llstate_0, &llstate_1, llarg_type)) goto failed2;
*llout = llstate_1;
{(*llret) = llatt_1;
	
break;
}}}
case 11: case -11:
LLDEBUG_ALTERNATIVE("BuiltinValue", 11);
{if (GetTypeType((*llin).Assignments, llarg_type) != eType_Undefined &&
		GetTypeType((*llin).Assignments, llarg_type) != eType_ObjectIdentifier)
		LLFAILED((&llstate_0.pos, "Bad type of value"));
	
{LLSTATE llstate_1;XValue llatt_1;
if (!ll_ObjectIdentifierValue(&llatt_1, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = llatt_1;
		if (llatt_1->Type != NULL)
		{
			PropagatePrivateDirectives(llatt_1->Type, &(llarg_type->PrivateDirectives));
		}
	
break;
}}}
case 12: case -12:
LLDEBUG_ALTERNATIVE("BuiltinValue", 12);
{if (GetTypeType((*llin).Assignments, llarg_type) != eType_Undefined &&
		GetTypeType((*llin).Assignments, llarg_type) != eType_OctetString)
		LLFAILED((&llstate_0.pos, "Bad type of value"));
	
{LLSTATE llstate_1;XValue llatt_1;
if (!ll_OctetStringValue(&llatt_1, &llstate_0, &llstate_1, llarg_type)) goto failed2;
*llout = llstate_1;
{(*llret) = llatt_1;
	
break;
}}}
case 13: case -13:
LLDEBUG_ALTERNATIVE("BuiltinValue", 13);
{if (GetTypeType((*llin).Assignments, llarg_type) != eType_Undefined &&
		GetTypeType((*llin).Assignments, llarg_type) != eType_Real)
		LLFAILED((&llstate_0.pos, "Bad type of value"));
	
{LLSTATE llstate_1;XValue llatt_1;
if (!ll_RealValue(&llatt_1, &llstate_0, &llstate_1, llarg_type)) goto failed2;
*llout = llstate_1;
{(*llret) = llatt_1;
	
break;
}}}
case 14: case -14:
LLDEBUG_ALTERNATIVE("BuiltinValue", 14);
{if (GetTypeType((*llin).Assignments, llarg_type) != eType_Undefined &&
		GetTypeType((*llin).Assignments, llarg_type) !=
		eType_GeneralizedTime)
		LLFAILED((&llstate_0.pos, "Bad type of value"));
	
{LLSTATE llstate_1;XValue llatt_1;
if (!ll_GeneralizedTimeValue(&llatt_1, &llstate_0, &llstate_1, llarg_type)) goto failed2;
*llout = llstate_1;
{(*llret) = llatt_1;
	
break;
}}}
case 15: case -15:
LLDEBUG_ALTERNATIVE("BuiltinValue", 15);
{if (GetTypeType((*llin).Assignments, llarg_type) != eType_Undefined &&
		GetTypeType((*llin).Assignments, llarg_type) != eType_UTCTime)
		LLFAILED((&llstate_0.pos, "Bad type of value"));
	
{LLSTATE llstate_1;XValue llatt_1;
if (!ll_UTCTimeValue(&llatt_1, &llstate_0, &llstate_1, llarg_type)) goto failed2;
*llout = llstate_1;
{(*llret) = llatt_1;
	
break;
}}}
case 16: case -16:
LLDEBUG_ALTERNATIVE("BuiltinValue", 16);
{if (GetTypeType((*llin).Assignments, llarg_type) != eType_Undefined &&
		GetTypeType((*llin).Assignments, llarg_type) != eType_ObjectDescriptor)
		LLFAILED((&llstate_0.pos, "Bad type of value"));
	
{LLSTATE llstate_1;XValue llatt_1;
if (!ll_ObjectDescriptorValue(&llatt_1, &llstate_0, &llstate_1, llarg_type)) goto failed2;
*llout = llstate_1;
{(*llret) = llatt_1;
	
break;
}}}
case 17: case -17:
LLDEBUG_ALTERNATIVE("BuiltinValue", 17);
{if (GetTypeType((*llin).Assignments, llarg_type) != eType_Undefined &&
		GetTypeType((*llin).Assignments, llarg_type) != eType_Sequence)
		LLFAILED((&llstate_0.pos, "Bad type of value"));
	
{LLSTATE llstate_1;XValue llatt_1;
if (!ll_SequenceValue(&llatt_1, &llstate_0, &llstate_1, llarg_type)) goto failed2;
*llout = llstate_1;
{(*llret) = llatt_1;
	
break;
}}}
case 18: case -18:
LLDEBUG_ALTERNATIVE("BuiltinValue", 18);
{if (GetTypeType((*llin).Assignments, llarg_type) != eType_Undefined &&
		GetTypeType((*llin).Assignments, llarg_type) != eType_SequenceOf)
		LLFAILED((&llstate_0.pos, "Bad type of value"));
	
{LLSTATE llstate_1;XValue llatt_1;
if (!ll_SequenceOfValue(&llatt_1, &llstate_0, &llstate_1, llarg_type)) goto failed2;
*llout = llstate_1;
{(*llret) = llatt_1;
	
break;
}}}
case 19: case -19:
LLDEBUG_ALTERNATIVE("BuiltinValue", 19);
{if (GetTypeType((*llin).Assignments, llarg_type) != eType_Undefined &&
		GetTypeType((*llin).Assignments, llarg_type) != eType_Set)
		LLFAILED((&llstate_0.pos, "Bad type of value"));
	
{LLSTATE llstate_1;XValue llatt_1;
if (!ll_SetValue(&llatt_1, &llstate_0, &llstate_1, llarg_type)) goto failed2;
*llout = llstate_1;
{(*llret) = llatt_1;
	
break;
}}}
case 20: case -20:
LLDEBUG_ALTERNATIVE("BuiltinValue", 20);
{if (GetTypeType((*llin).Assignments, llarg_type) != eType_Undefined &&
		GetTypeType((*llin).Assignments, llarg_type) != eType_SetOf)
		LLFAILED((&llstate_0.pos, "Bad type of value"));
	
{LLSTATE llstate_1;XValue llatt_1;
if (!ll_SetOfValue(&llatt_1, &llstate_0, &llstate_1, llarg_type)) goto failed2;
*llout = llstate_1;
{(*llret) = llatt_1;
	
break;
}}}
case 21: case -21:
LLDEBUG_ALTERNATIVE("BuiltinValue", 21);
{if (GetTypeType((*llin).Assignments, llarg_type) != eType_Undefined &&
		GetTypeType((*llin).Assignments, llarg_type) != eType_Open)
		LLFAILED((&llstate_0.pos, "Bad type of value"));
	
{LLSTATE llstate_1;XValue llatt_1;
if (!ll_AnyValue(&llatt_1, &llstate_0, &llstate_1, llarg_type)) goto failed2;
*llout = llstate_1;
{(*llret) = llatt_1;
	
break;
}}}
case 22: case -22:
LLDEBUG_ALTERNATIVE("BuiltinValue", 22);
{if (GetTypeType((*llin).Assignments, llarg_type) != eType_Undefined &&
		GetTypeType((*llin).Assignments, llarg_type) != eType_Macro)
		LLFAILED((&llstate_0.pos, "Bad type of value"));
	
{LLSTATE llstate_1;XValue llatt_1;
if (!ll_MacroDefinedValue(&llatt_1, &llstate_0, &llstate_1, llarg_type)) goto failed2;
*llout = llstate_1;
{(*llret) = llatt_1;
	
break;
}}}
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("BuiltinValue");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("BuiltinValue", 1);
return 1;
failed1: LLDEBUG_LEAVE("BuiltinValue", 0);
return 0;
}

int ll_ReferencedValue(XValue *llret, LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("ReferencedValue");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("ReferencedValue", 1);
{LLSTATE llstate_1;XValue llatt_1;
if (!ll_DefinedValue(&llatt_1, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = llatt_1;
	
break;
}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("ReferencedValue", 2);
{LLSTATE llstate_1;XValue llatt_1;
if (!ll_ValueFromObject(&llatt_1, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = llatt_1;
	
break;
}}
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("ReferencedValue");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("ReferencedValue", 1);
return 1;
failed1: LLDEBUG_LEAVE("ReferencedValue", 0);
return 0;
}

int ll_NamedValue(XNamedValues *llret, LLSTATE *llin, LLSTATE *llout, XComponents llarg_components)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("NamedValue");

llstate_0 = *llin;
#undef failed
#define failed failed1
{LLSTATE llstate_1;XString llatt_1;
if (!ll_identifier(&llatt_1, &llstate_0, &llstate_1)) goto failed1;
{Component_t *component;
	    Type_t *type;
	    component = FindComponent((*llin).Assignments, llarg_components, llatt_1);
	    if (component)
		type = component->U.NOD.NamedType->Type;
	    else
		type = NULL;
	
{LLSTATE llstate_2;XValue llatt_2;
if (!ll_Value(&llatt_2, &llstate_1, &llstate_2, type)) goto failed1;
*llout = llstate_2;
{(*llret) = NewNamedValue(llatt_1, llatt_2);
	
}}}}
LLDEBUG_LEAVE("NamedValue", 1);
return 1;
failed1: LLDEBUG_LEAVE("NamedValue", 0);
return 0;
}

int ll_BooleanValue(XValue *llret, LLSTATE *llin, LLSTATE *llout, XType llarg_type)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("BooleanValue");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("BooleanValue", 1);
{LLSTATE llstate_1;
if (!llterm(T_TRUE, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = NewValue((*llout).Assignments, llarg_type);
	    (*llret)->U.Boolean.Value = 1;
	
break;
}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("BooleanValue", 2);
{LLSTATE llstate_1;
if (!llterm(T_FALSE, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = NewValue((*llout).Assignments, llarg_type);
	    (*llret)->U.Boolean.Value = 0;
	
break;
}}
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("BooleanValue");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("BooleanValue", 1);
return 1;
failed1: LLDEBUG_LEAVE("BooleanValue", 0);
return 0;
}

int ll_SignedNumber(XValue *llret, LLSTATE *llin, LLSTATE *llout, XType llarg_type)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("SignedNumber");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("SignedNumber", 1);
{LLSTATE llstate_1;XNumber llatt_1;
if (!llterm(T_number, &lllval, &llstate_0, &llstate_1)) goto failed2;
llatt_1 = lllval._XNumber;
*llout = llstate_1;
{(*llret) = NewValue((*llout).Assignments, llarg_type);
	    (*llret)->U.Integer.Value = llatt_1;
	
break;
}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("SignedNumber", 2);
{LLSTATE llstate_1;
if (!llterm('-', (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
{LLSTATE llstate_2;XNumber llatt_2;
if (!llterm(T_number, &lllval, &llstate_1, &llstate_2)) goto failed2;
llatt_2 = lllval._XNumber;
*llout = llstate_2;
{if (!intx_cmp(&llatt_2, &intx_0))
		LLFAILED((&llstate_2.pos, "Bad negative value"));
	    (*llret) = NewValue((*llout).Assignments, llarg_type);
	    intx_neg(&(*llret)->U.Integer.Value, &llatt_2);
	
break;
}}}
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("SignedNumber");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("SignedNumber", 1);
return 1;
failed1: LLDEBUG_LEAVE("SignedNumber", 0);
return 0;
}

int ll_IntegerValue(XValue *llret, LLSTATE *llin, LLSTATE *llout, XType llarg_type)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("IntegerValue");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("IntegerValue", 1);
{LLSTATE llstate_1;XValue llatt_1;
if (!ll_SignedNumber(&llatt_1, &llstate_0, &llstate_1, llarg_type)) goto failed2;
*llout = llstate_1;
{(*llret) = llatt_1;
	
break;
}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("IntegerValue", 2);
{LLSTATE llstate_1;XString llatt_1;
if (!ll_identifier(&llatt_1, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{NamedNumber_t *n;
	    Type_t *type;
	    type = GetType((*llout).Assignments, llarg_type);
	    if (type) {
		n = FindNamedNumber(type->U.Integer.NamedNumbers, llatt_1);
		if (!n)
		    LLFAILED((&llstate_1.pos, "Undefined integer value"));
		(*llret) = NewValue((*llout).Assignments, llarg_type);
		intx_dup(&(*llret)->U.Integer.Value,
		    &n->U.Normal.Value->U.Integer.Value);
	    } else {
		(*llret) = NULL;
	    }
	
break;
}}
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("IntegerValue");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("IntegerValue", 1);
return 1;
failed1: LLDEBUG_LEAVE("IntegerValue", 0);
return 0;
}

int ll_EnumeratedValue(XValue *llret, LLSTATE *llin, LLSTATE *llout, XType llarg_type)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("EnumeratedValue");

llstate_0 = *llin;
#undef failed
#define failed failed1
{LLSTATE llstate_1;XString llatt_1;
if (!ll_identifier(&llatt_1, &llstate_0, &llstate_1)) goto failed1;
*llout = llstate_1;
{NamedNumber_t *n;
	    Type_t *type;
	    type = GetType((*llout).Assignments, llarg_type);
	    if (type) {
		n = FindNamedNumber(type->U.Enumerated.NamedNumbers, llatt_1);
		if (!n)
		    LLFAILED((&llstate_1.pos, "Undefined enumeration value"));
		(*llret) = NewValue((*llout).Assignments, llarg_type);
		(*llret)->U.Enumerated.Value =
		    intx2uint32(&n->U.Normal.Value->U.Integer.Value);
	    } else {
		(*llret) = NULL;
	    }
	
}}
LLDEBUG_LEAVE("EnumeratedValue", 1);
return 1;
failed1: LLDEBUG_LEAVE("EnumeratedValue", 0);
return 0;
}

int ll_RealValue(XValue *llret, LLSTATE *llin, LLSTATE *llout, XType llarg_type)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("RealValue");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("RealValue", 1);
{LLSTATE llstate_1;XValue llatt_1;
if (!ll_NumericRealValue(&llatt_1, &llstate_0, &llstate_1, llarg_type)) goto failed2;
*llout = llstate_1;
{(*llret) = llatt_1;
	
break;
}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("RealValue", 2);
{LLSTATE llstate_1;XValue llatt_1;
if (!ll_SpecialRealValue(&llatt_1, &llstate_0, &llstate_1, llarg_type)) goto failed2;
*llout = llstate_1;
{(*llret) = llatt_1;
	
break;
}}
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("RealValue");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("RealValue", 1);
return 1;
failed1: LLDEBUG_LEAVE("RealValue", 0);
return 0;
}

int ll_NumericRealValue(XValue *llret, LLSTATE *llin, LLSTATE *llout, XType llarg_type)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("NumericRealValue");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("NumericRealValue", 1);
{LLSTATE llstate_1;XNumber llatt_1;
if (!llterm(T_number, &lllval, &llstate_0, &llstate_1)) goto failed2;
llatt_1 = lllval._XNumber;
*llout = llstate_1;
{if (intx_cmp(&llatt_1, &intx_0))
		LLFAILED((&llstate_1.pos, "Bad real value"));
	    (*llret) = NewValue((*llout).Assignments, llarg_type);
	
break;
}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("NumericRealValue", 2);
{LLSTATE llstate_1;XValue llatt_1;
if (!ll_SequenceValue(&llatt_1, &llstate_0, &llstate_1, llarg_type)) goto failed2;
*llout = llstate_1;
{NamedValue_t *mant, *expo, *base;
	    mant = FindNamedValue(llatt_1->U.Sequence.NamedValues, "mantissa");
	    expo = FindNamedValue(llatt_1->U.Sequence.NamedValues, "exponent");
	    base = FindNamedValue(llatt_1->U.Sequence.NamedValues, "base");
	    if (!mant || !expo || !base) {
		(*llret) = NULL;
	    } else {
		(*llret) = NewValue((*llout).Assignments, llarg_type);
		intx_dup(&(*llret)->U.Real.Value.mantissa,
		    &mant->Value->U.Integer.Value);
		intx_dup(&(*llret)->U.Real.Value.exponent,
		    &expo->Value->U.Integer.Value);
		(*llret)->U.Real.Value.base =
		    intx2uint32(&base->Value->U.Integer.Value);
	    }
	
break;
}}
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("NumericRealValue");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("NumericRealValue", 1);
return 1;
failed1: LLDEBUG_LEAVE("NumericRealValue", 0);
return 0;
}

int ll_SpecialRealValue(XValue *llret, LLSTATE *llin, LLSTATE *llout, XType llarg_type)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("SpecialRealValue");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("SpecialRealValue", 1);
{LLSTATE llstate_1;
if (!llterm(T_PLUS_INFINITY, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = NewValue((*llout).Assignments, llarg_type);
	    (*llret)->U.Real.Value.type = eReal_PlusInfinity;
	
break;
}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("SpecialRealValue", 2);
{LLSTATE llstate_1;
if (!llterm(T_MINUS_INFINITY, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = NewValue((*llout).Assignments, llarg_type);
	    (*llret)->U.Real.Value.type = eReal_MinusInfinity;
	
break;
}}
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("SpecialRealValue");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("SpecialRealValue", 1);
return 1;
failed1: LLDEBUG_LEAVE("SpecialRealValue", 0);
return 0;
}

int ll_BitStringValue(XValue *llret, LLSTATE *llin, LLSTATE *llout, XType llarg_type)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("BitStringValue");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("BitStringValue", 1);
{LLSTATE llstate_1;XString llatt_1;
if (!llterm(T_bstring, &lllval, &llstate_0, &llstate_1)) goto failed2;
llatt_1 = lllval._XString;
*llout = llstate_1;
{int i, len;
	    if (GetTypeType((*llout).Assignments, llarg_type) == eType_BitString) {
		len = strlen(llatt_1);
		(*llret) = NewValue((*llout).Assignments, llarg_type);
		(*llret)->U.BitString.Value.length = len;
		(*llret)->U.BitString.Value.value =
		    (octet_t *)malloc((len + 7) / 8);
		memset((*llret)->U.BitString.Value.value, 0, (len + 7) / 8);
		for (i = 0; i < len; i++) {
		    if (llatt_1[i] == '1')
			ASN1BITSET((*llret)->U.BitString.Value.value, i);
		}
	    } else {
		(*llret) = NULL;
	    }
	
break;
}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("BitStringValue", 2);
{LLSTATE llstate_1;XString llatt_1;
if (!llterm(T_hstring, &lllval, &llstate_0, &llstate_1)) goto failed2;
llatt_1 = lllval._XString;
*llout = llstate_1;
{int i, len, c;
	    if (GetTypeType((*llout).Assignments, llarg_type) == eType_BitString) {
		len = strlen(llatt_1);
		(*llret) = NewValue((*llout).Assignments, llarg_type);
		(*llret)->U.BitString.Value.length = len * 4;
		(*llret)->U.BitString.Value.value =
		    (octet_t *)malloc((len + 1) / 2);
		memset((*llret)->U.BitString.Value.value, 0, (len + 1) / 2);
		for (i = 0; i < len; i++) {
		    c = isdigit(llatt_1[i]) ? llatt_1[i] - '0' : llatt_1[i] - 'A' + 10;
		    (*llret)->U.BitString.Value.value[i / 2] |=
			(i & 1) ? c : (c << 4);
		}
	    } else {
		(*llret) = NULL;
	    }
	
break;
}}
case 3: case -3:
LLDEBUG_ALTERNATIVE("BitStringValue", 3);
{LLSTATE llstate_1;
if (!llterm('{', (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
{LLSTATE llstate_2;XValue llatt_2;
if (!ll_IdentifierList(&llatt_2, &llstate_1, &llstate_2, llarg_type)) goto failed2;
{LLSTATE llstate_3;
if (!llterm('}', (LLSTYPE *)0, &llstate_2, &llstate_3)) goto failed2;
*llout = llstate_3;
{(*llret) = llatt_2;
	
break;
}}}}
case 4: case -4:
LLDEBUG_ALTERNATIVE("BitStringValue", 4);
{LLSTATE llstate_1;
if (!llterm('{', (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
{LLSTATE llstate_2;
if (!llterm('}', (LLSTYPE *)0, &llstate_1, &llstate_2)) goto failed2;
*llout = llstate_2;
{(*llret) = NewValue((*llout).Assignments, llarg_type);
	
break;
}}}
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("BitStringValue");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("BitStringValue", 1);
return 1;
failed1: LLDEBUG_LEAVE("BitStringValue", 0);
return 0;
}

int ll_IdentifierList(XValue *llret, LLSTATE *llin, LLSTATE *llout, XType llarg_type)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("IdentifierList");

llstate_0 = *llin;
#undef failed
#define failed failed1
{LLSTATE llstate_1;XValue llatt_1;
if (!ll_IdentifierList_Elem(&llatt_1, &llstate_0, &llstate_1, llarg_type)) goto failed1;
{LLSTATE llstate_2;XValue llatt_2;
if (!ll_Identifier_EList(&llatt_2, &llstate_1, &llstate_2, llarg_type)) goto failed1;
*llout = llstate_2;
{uint32_t bit, len;
	    bitstring_t *src, *dst;
	    if (llatt_1 && llatt_2) {
		bit = intx2uint32(&llatt_1->U.Integer.Value);
		src = &llatt_2->U.BitString.Value;
		len = bit + 1;
		if (len < src->length)
		    len = src->length;
		(*llret) = DupValue(llatt_2);
		dst = &(*llret)->U.BitString.Value;
		dst->length = len;
		dst->value = (octet_t *)malloc((len + 7) / 8);
		memcpy(dst->value, src->value, (src->length + 7) / 8);
		memset(dst->value + (src->length + 7) / 8, 0,
		    (len + 7) / 8 - (src->length + 7) / 8);
		ASN1BITSET(dst->value, bit);
	    } else if (llatt_1) {
		bit = intx2uint32(&llatt_1->U.Integer.Value);
		len = bit + 1;
		(*llret) = NewValue((*llout).Assignments, llarg_type);
		dst = &(*llret)->U.BitString.Value;
		dst->length = len;
		dst->value = (octet_t *)malloc((len + 7) / 8);
		memset(dst->value, 0, (len + 7) / 8);
		ASN1BITSET(dst->value, bit);
	    } else {
		(*llret) = NULL;
	    }
	
}}}
LLDEBUG_LEAVE("IdentifierList", 1);
return 1;
failed1: LLDEBUG_LEAVE("IdentifierList", 0);
return 0;
}

int ll_Identifier_EList(XValue *llret, LLSTATE *llin, LLSTATE *llout, XType llarg_type)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("Identifier_EList");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("Identifier_EList", 1);
{LLSTATE llstate_1;XValue llatt_1;
if (!ll_IdentifierList_Elem(&llatt_1, &llstate_0, &llstate_1, llarg_type)) goto failed2;
{LLSTATE llstate_2;XValue llatt_2;
if (!ll_Identifier_EList(&llatt_2, &llstate_1, &llstate_2, llarg_type)) goto failed2;
*llout = llstate_2;
{uint32_t bit, len;
	    bitstring_t *src, *dst;
	    if (llatt_1 && llatt_2) {
		bit = intx2uint32(&llatt_1->U.Integer.Value);
		src = &llatt_2->U.BitString.Value;
		len = bit + 1;
		if (len < src->length)
		    len = src->length;
		(*llret) = DupValue(llatt_2);
		dst = &(*llret)->U.BitString.Value;
		dst->length = len;
		dst->value = (octet_t *)malloc((len + 7) / 8);
		memcpy(dst->value, src->value, (src->length + 7) / 8);
		memset(dst->value + (src->length + 7) / 8, 0,
		    (len + 7) / 8 - (src->length + 7) / 8);
		ASN1BITSET(dst->value, bit);
	    } else if (llatt_1) {
		bit = intx2uint32(&llatt_1->U.Integer.Value);
		len = bit + 1;
		(*llret) = NewValue((*llout).Assignments, llarg_type);
		dst = &(*llret)->U.BitString.Value;
		dst->length = len;
		dst->value = (octet_t *)malloc((len + 7) / 8);
		memset(dst->value, 0, (len + 7) / 8);
		ASN1BITSET(dst->value, bit);
	    } else {
		(*llret) = NULL;
	    }
	
break;
}}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("Identifier_EList", 2);
*llout = llstate_0;
{if (llarg_type) {
		(*llret) = NewValue((*llout).Assignments, llarg_type);
	    } else {
		(*llret) = NULL;
	    }
	
break;
}
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("Identifier_EList");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("Identifier_EList", 1);
return 1;
failed1: LLDEBUG_LEAVE("Identifier_EList", 0);
return 0;
}

int ll_IdentifierList_Elem(XValue *llret, LLSTATE *llin, LLSTATE *llout, XType llarg_type)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("IdentifierList_Elem");

llstate_0 = *llin;
#undef failed
#define failed failed1
{LLSTATE llstate_1;XString llatt_1;
if (!ll_identifier(&llatt_1, &llstate_0, &llstate_1)) goto failed1;
*llout = llstate_1;
{Value_t *v;
	    NamedNumber_t *n;
	    Type_t *type;
	    type = GetType((*llout).Assignments, llarg_type);
	    if (type) {
		n = FindNamedNumber(type->U.BitString.NamedNumbers, llatt_1);
		if (!n)
		    LLFAILED((&llstate_1.pos, "Bad bit string value"));
		v = GetValue((*llout).Assignments, n->U.Normal.Value);
		if (v) {
		    if (GetTypeType((*llout).Assignments, v->Type) != eType_Integer)
			MyAbort();
		    (*llret) = v;
		} else {
		    (*llret) = NULL;
		}
	    } else {
		(*llret) = NULL;
	    }
	
}}
LLDEBUG_LEAVE("IdentifierList_Elem", 1);
return 1;
failed1: LLDEBUG_LEAVE("IdentifierList_Elem", 0);
return 0;
}

int ll_OctetStringValue(XValue *llret, LLSTATE *llin, LLSTATE *llout, XType llarg_type)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("OctetStringValue");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("OctetStringValue", 1);
{LLSTATE llstate_1;XString llatt_1;
if (!llterm(T_bstring, &lllval, &llstate_0, &llstate_1)) goto failed2;
llatt_1 = lllval._XString;
*llout = llstate_1;
{int len, i;
	    if (GetTypeType((*llout).Assignments, llarg_type) == eType_OctetString) {
		len = strlen(llatt_1);
		(*llret) = NewValue((*llout).Assignments, llarg_type);
		(*llret)->U.OctetString.Value.length = (len + 7) / 8;
		(*llret)->U.OctetString.Value.value =
		    (octet_t *)malloc((len + 7) / 8);
		memset((*llret)->U.OctetString.Value.value, 0, (len + 7) / 8);
		for (i = 0; i < len; i++) {
		    if (llatt_1[i] == '1')
			ASN1BITSET((*llret)->U.OctetString.Value.value, i);
		}
	    } else {
		(*llret) = NULL;
	    }
	
break;
}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("OctetStringValue", 2);
{LLSTATE llstate_1;XString llatt_1;
if (!llterm(T_hstring, &lllval, &llstate_0, &llstate_1)) goto failed2;
llatt_1 = lllval._XString;
*llout = llstate_1;
{int i, len, c;
	    if (GetTypeType((*llout).Assignments, llarg_type) == eType_OctetString) {
		len = strlen(llatt_1);
		(*llret) = NewValue((*llout).Assignments, llarg_type);
		(*llret)->U.OctetString.Value.length = (len + 1) / 2;
		(*llret)->U.OctetString.Value.value =
		    (octet_t *)malloc((len + 1) / 2);
		memset((*llret)->U.OctetString.Value.value, 0, (len + 1) / 2);
		for (i = 0; i < len; i++) {
		    c = isdigit(llatt_1[i]) ?  llatt_1[i] - '0' : llatt_1[i] - 'A' + 10;
		    (*llret)->U.OctetString.Value.value[i / 2] |=
			(i & 1) ? c : (c << 4);
		}
	    } else {
		(*llret) = NULL;
	    }
	
break;
}}
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("OctetStringValue");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("OctetStringValue", 1);
return 1;
failed1: LLDEBUG_LEAVE("OctetStringValue", 0);
return 0;
}

int ll_NullValue(XValue *llret, LLSTATE *llin, LLSTATE *llout, XType llarg_type)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("NullValue");

llstate_0 = *llin;
#undef failed
#define failed failed1
{LLSTATE llstate_1;
if (!llterm(T_NULL, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed1;
*llout = llstate_1;
{(*llret) = NewValue((*llout).Assignments, llarg_type);
	
}}
LLDEBUG_LEAVE("NullValue", 1);
return 1;
failed1: LLDEBUG_LEAVE("NullValue", 0);
return 0;
}

int ll_GeneralizedTimeValue(XValue *llret, LLSTATE *llin, LLSTATE *llout, XType llarg_type)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("GeneralizedTimeValue");

llstate_0 = *llin;
#undef failed
#define failed failed1
{LLSTATE llstate_1;XValue llatt_1;
if (!ll_RestrictedCharacterStringValue(&llatt_1, &llstate_0, &llstate_1, llarg_type)) goto failed1;
*llout = llstate_1;
{(*llret) = NewValue((*llout).Assignments, llarg_type);
	    if (!String2GeneralizedTime(&(*llret)->U.GeneralizedTime.Value,
		&llatt_1->U.RestrictedString.Value))
		LLFAILED((&llstate_1.pos, "Bad time value"));
	
}}
LLDEBUG_LEAVE("GeneralizedTimeValue", 1);
return 1;
failed1: LLDEBUG_LEAVE("GeneralizedTimeValue", 0);
return 0;
}

int ll_UTCTimeValue(XValue *llret, LLSTATE *llin, LLSTATE *llout, XType llarg_type)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("UTCTimeValue");

llstate_0 = *llin;
#undef failed
#define failed failed1
{LLSTATE llstate_1;XValue llatt_1;
if (!ll_RestrictedCharacterStringValue(&llatt_1, &llstate_0, &llstate_1, llarg_type)) goto failed1;
*llout = llstate_1;
{(*llret) = NewValue((*llout).Assignments, llarg_type);
	    if (!String2UTCTime(&(*llret)->U.UTCTime.Value,
		&llatt_1->U.RestrictedString.Value))
		LLFAILED((&llstate_1.pos, "Bad time value"));
	
}}
LLDEBUG_LEAVE("UTCTimeValue", 1);
return 1;
failed1: LLDEBUG_LEAVE("UTCTimeValue", 0);
return 0;
}

int ll_ObjectDescriptorValue(XValue *llret, LLSTATE *llin, LLSTATE *llout, XType llarg_type)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("ObjectDescriptorValue");

llstate_0 = *llin;
#undef failed
#define failed failed1
{LLSTATE llstate_1;XValue llatt_1;
if (!ll_RestrictedCharacterStringValue(&llatt_1, &llstate_0, &llstate_1, llarg_type)) goto failed1;
*llout = llstate_1;
{(*llret) = llatt_1;
	
}}
LLDEBUG_LEAVE("ObjectDescriptorValue", 1);
return 1;
failed1: LLDEBUG_LEAVE("ObjectDescriptorValue", 0);
return 0;
}

int ll_SequenceValue(XValue *llret, LLSTATE *llin, LLSTATE *llout, XType llarg_type)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("SequenceValue");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("SequenceValue", 1);
{LLSTATE llstate_1;
if (!llterm('{', (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
{Component_t *components;
	    Type_t *type;
	    type = GetType(llstate_1.Assignments, llarg_type);
	    components = type ? type->U.SSC.Components : NULL;
	
{LLSTATE llstate_2;XNamedValues llatt_2;
if (!ll_ComponentValueList(&llatt_2, &llstate_1, &llstate_2, components)) goto failed2;
{LLSTATE llstate_3;
if (!llterm('}', (LLSTYPE *)0, &llstate_2, &llstate_3)) goto failed2;
*llout = llstate_3;
{Component_t *c;
	    NamedValue_t *v;
	    if (type) {
		for (c = components, v = llatt_2; c; c = c->Next) {
		    switch (c->Type) {
		    case eComponent_Normal:
			if (!v)
			    LLFAILED((&llstate_2.pos,
				"Value for component `%s' is missing",
				c->U.NOD.NamedType->Identifier));
			if (strcmp(v->Identifier,
			    c->U.NOD.NamedType->Identifier))
			    LLFAILED((&llstate_2.pos, "Value for component `%s' expected",
				c->U.NOD.NamedType->Identifier));
			v = v->Next;
			break;
		    case eComponent_Optional:
		    case eComponent_Default:
			if (v && !strcmp(v->Identifier,
			    c->U.NOD.NamedType->Identifier))
			    v = v->Next;
			break;
		    }
		}
		if (v)
		    LLFAILED((&llstate_2.pos, "Component `%s' is unexpected",
			v->Identifier));
	    }
	    (*llret) = NewValue((*llout).Assignments, llarg_type);
	    (*llret)->U.SSC.NamedValues = llatt_2;
	
break;
}}}}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("SequenceValue", 2);
{LLSTATE llstate_1;
if (!llterm('{', (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
{LLSTATE llstate_2;
if (!llterm('}', (LLSTYPE *)0, &llstate_1, &llstate_2)) goto failed2;
*llout = llstate_2;
{(*llret) = NewValue((*llout).Assignments, llarg_type);
	
break;
}}}
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("SequenceValue");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("SequenceValue", 1);
return 1;
failed1: LLDEBUG_LEAVE("SequenceValue", 0);
return 0;
}

int ll_ComponentValueList(XNamedValues *llret, LLSTATE *llin, LLSTATE *llout, XComponents llarg_components)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("ComponentValueList");

llstate_0 = *llin;
#undef failed
#define failed failed1
{LLSTATE llstate_1;XNamedValues llatt_1;
if (!ll_NamedValue(&llatt_1, &llstate_0, &llstate_1, llarg_components)) goto failed1;
{LLSTATE llstate_2;XNamedValues llatt_2;
if (!ll_ComponentValueCList(&llatt_2, &llstate_1, &llstate_2, llarg_components)) goto failed1;
*llout = llstate_2;
{if (llatt_2) {
		(*llret) = DupNamedValue(llatt_1);
		(*llret)->Next = llatt_2;
	    } else {
		(*llret) = llatt_1;
	    }
	
}}}
LLDEBUG_LEAVE("ComponentValueList", 1);
return 1;
failed1: LLDEBUG_LEAVE("ComponentValueList", 0);
return 0;
}

int ll_ComponentValueCList(XNamedValues *llret, LLSTATE *llin, LLSTATE *llout, XComponents llarg_components)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("ComponentValueCList");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("ComponentValueCList", 1);
{LLSTATE llstate_1;
if (!llterm(',', (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
{LLSTATE llstate_2;XNamedValues llatt_2;
if (!ll_ComponentValueList(&llatt_2, &llstate_1, &llstate_2, llarg_components)) goto failed2;
*llout = llstate_2;
{(*llret) = llatt_2;
	
break;
}}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("ComponentValueCList", 2);
*llout = llstate_0;
{(*llret) = NULL;
	
break;
}
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("ComponentValueCList");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("ComponentValueCList", 1);
return 1;
failed1: LLDEBUG_LEAVE("ComponentValueCList", 0);
return 0;
}

int ll_SequenceOfValue(XValue *llret, LLSTATE *llin, LLSTATE *llout, XType llarg_type)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("SequenceOfValue");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("SequenceOfValue", 1);
{LLSTATE llstate_1;
if (!llterm('{', (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
{Type_t *type, *subtype;
	    type = GetType(llstate_1.Assignments, llarg_type);
	    subtype = (type ? type->U.SS.Type : NULL);
	
{LLSTATE llstate_2;XValue llatt_2;
if (!ll_ValueList(&llatt_2, &llstate_1, &llstate_2, subtype)) goto failed2;
{LLSTATE llstate_3;
if (!llterm('}', (LLSTYPE *)0, &llstate_2, &llstate_3)) goto failed2;
*llout = llstate_3;
{(*llret) = NewValue((*llout).Assignments, llarg_type);
	    (*llret)->U.SequenceOf.Values = llatt_2;
	
break;
}}}}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("SequenceOfValue", 2);
{LLSTATE llstate_1;
if (!llterm('{', (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
{LLSTATE llstate_2;
if (!llterm('}', (LLSTYPE *)0, &llstate_1, &llstate_2)) goto failed2;
*llout = llstate_2;
{(*llret) = NewValue((*llout).Assignments, llarg_type);
	
break;
}}}
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("SequenceOfValue");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("SequenceOfValue", 1);
return 1;
failed1: LLDEBUG_LEAVE("SequenceOfValue", 0);
return 0;
}

int ll_ValueList(XValue *llret, LLSTATE *llin, LLSTATE *llout, XType llarg_type)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("ValueList");

llstate_0 = *llin;
#undef failed
#define failed failed1
{LLSTATE llstate_1;XValue llatt_1;
if (!ll_Value(&llatt_1, &llstate_0, &llstate_1, llarg_type)) goto failed1;
{LLSTATE llstate_2;XValue llatt_2;
if (!ll_ValueCList(&llatt_2, &llstate_1, &llstate_2, llarg_type)) goto failed1;
*llout = llstate_2;
{(*llret) = DupValue(llatt_1);
	    (*llret)->Next = llatt_2;
	
}}}
LLDEBUG_LEAVE("ValueList", 1);
return 1;
failed1: LLDEBUG_LEAVE("ValueList", 0);
return 0;
}

int ll_ValueCList(XValue *llret, LLSTATE *llin, LLSTATE *llout, XType llarg_type)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("ValueCList");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("ValueCList", 1);
{LLSTATE llstate_1;
if (!llterm(',', (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
{LLSTATE llstate_2;XValue llatt_2;
if (!ll_ValueList(&llatt_2, &llstate_1, &llstate_2, llarg_type)) goto failed2;
*llout = llstate_2;
{(*llret) = llatt_2;
	
break;
}}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("ValueCList", 2);
*llout = llstate_0;
{(*llret) = NULL;
	
break;
}
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("ValueCList");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("ValueCList", 1);
return 1;
failed1: LLDEBUG_LEAVE("ValueCList", 0);
return 0;
}

int ll_SetValue(XValue *llret, LLSTATE *llin, LLSTATE *llout, XType llarg_type)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("SetValue");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("SetValue", 1);
{LLSTATE llstate_1;
if (!llterm('{', (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
{Component_t *components;
	    Type_t *type;
	    type = GetType(llstate_1.Assignments, llarg_type);
	    components = type ? type->U.SSC.Components : NULL;
	
{LLSTATE llstate_2;XNamedValues llatt_2;
if (!ll_ComponentValueList(&llatt_2, &llstate_1, &llstate_2, components)) goto failed2;
{LLSTATE llstate_3;
if (!llterm('}', (LLSTYPE *)0, &llstate_2, &llstate_3)) goto failed2;
*llout = llstate_3;
{Component_t *c;
	    NamedValue_t *v;
	    if (type) {
		for (c = components; c; c = c->Next) {
		    switch (c->Type) {
		    case eComponent_Normal:
			v = FindNamedValue(llatt_2, c->U.NOD.NamedType->Identifier);
			if (!v)
			    LLFAILED((&llstate_2.pos,
				"Value for component `%s' is missing",
				c->U.NOD.NamedType->Identifier));
			break;
		    }
		}
		for (v = llatt_2; v; v = v->Next) {
		    if (!FindComponent((*llout).Assignments, components,
			v->Identifier) ||
			FindNamedValue(v->Next, v->Identifier))
			LLFAILED((&llstate_2.pos, "Component `%s' is unexpected",
			    v->Identifier));
		}
	    }
	    (*llret) = NewValue((*llout).Assignments, llarg_type);
	    (*llret)->U.Set.NamedValues = llatt_2;
	
break;
}}}}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("SetValue", 2);
{LLSTATE llstate_1;
if (!llterm('{', (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
{LLSTATE llstate_2;
if (!llterm('}', (LLSTYPE *)0, &llstate_1, &llstate_2)) goto failed2;
*llout = llstate_2;
{(*llret) = NewValue((*llout).Assignments, llarg_type);
	
break;
}}}
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("SetValue");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("SetValue", 1);
return 1;
failed1: LLDEBUG_LEAVE("SetValue", 0);
return 0;
}

int ll_SetOfValue(XValue *llret, LLSTATE *llin, LLSTATE *llout, XType llarg_type)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("SetOfValue");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("SetOfValue", 1);
{LLSTATE llstate_1;
if (!llterm('{', (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
{Type_t *type, *subtype;
	    type = GetType(llstate_1.Assignments, llarg_type);
	    subtype = (type ? type->U.SS.Type : NULL);
	
{LLSTATE llstate_2;XValue llatt_2;
if (!ll_ValueList(&llatt_2, &llstate_1, &llstate_2, subtype)) goto failed2;
{LLSTATE llstate_3;
if (!llterm('}', (LLSTYPE *)0, &llstate_2, &llstate_3)) goto failed2;
*llout = llstate_3;
{(*llret) = NewValue((*llout).Assignments, llarg_type);
	    (*llret)->U.SetOf.Values = llatt_2;
	
break;
}}}}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("SetOfValue", 2);
{LLSTATE llstate_1;
if (!llterm('{', (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
{LLSTATE llstate_2;
if (!llterm('}', (LLSTYPE *)0, &llstate_1, &llstate_2)) goto failed2;
*llout = llstate_2;
{(*llret) = NewValue((*llout).Assignments, llarg_type);
	
break;
}}}
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("SetOfValue");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("SetOfValue", 1);
return 1;
failed1: LLDEBUG_LEAVE("SetOfValue", 0);
return 0;
}

int ll_ChoiceValue(XValue *llret, LLSTATE *llin, LLSTATE *llout, XType llarg_type)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("ChoiceValue");

llstate_0 = *llin;
#undef failed
#define failed failed1
{LLSTATE llstate_1;XString llatt_1;
if (!ll_identifier(&llatt_1, &llstate_0, &llstate_1)) goto failed1;
{LLSTATE llstate_2;
if (!llterm(':', (LLSTYPE *)0, &llstate_1, &llstate_2)) goto failed1;
{Component_t *component;
	    Type_t *type, *subtype;
	    type = GetType(llstate_2.Assignments, llarg_type);
	    if (type) {
		component = FindComponent(llstate_2.Assignments,
		    type->U.Choice.Components, llatt_1);
		if (!component)
		    LLFAILED((&llstate_1.pos, "Bad alternative `%s'", llatt_1));
		subtype = component->U.NOD.NamedType->Type;
	    } else {
		subtype = NULL;
	    }
	
{LLSTATE llstate_3;XValue llatt_3;
if (!ll_Value(&llatt_3, &llstate_2, &llstate_3, subtype)) goto failed1;
*llout = llstate_3;
{(*llret) = NewValue((*llout).Assignments, llarg_type);
	    (*llret)->U.SSC.NamedValues = NewNamedValue(llatt_1, llatt_3);
	
}}}}}
LLDEBUG_LEAVE("ChoiceValue", 1);
return 1;
failed1: LLDEBUG_LEAVE("ChoiceValue", 0);
return 0;
}

int ll_ObjectIdentifierValue(XValue *llret, LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("ObjectIdentifierValue");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("ObjectIdentifierValue", 1);
{LLSTATE llstate_1;
if (!llterm('{', (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
{LLSTATE llstate_2;XNamedObjIdValue llatt_2;
if (!ll_ObjIdComponentList(&llatt_2, &llstate_1, &llstate_2)) goto failed2;
{LLSTATE llstate_3;
if (!llterm('}', (LLSTYPE *)0, &llstate_2, &llstate_3)) goto failed2;
*llout = llstate_3;
{switch (GetAssignedObjectIdentifier(
		&(*llout).AssignedObjIds, NULL, llatt_2, &(*llret))) {
	    case -1:
		LLFAILED((&llstate_2.pos, "Different numbers for equally named object identifier components"));
		/*NOTREACHED*/
	    case 0:
		if (pass <= 2)
		    (*llret) = NULL;
		else
		    LLFAILED((&llstate_2.pos, "Unknown object identifier component"));
		break;
	    case 1:
		break;
	    }
	
break;
}}}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("ObjectIdentifierValue", 2);
{LLSTATE llstate_1;
if (!llterm('{', (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
{LLSTATE llstate_2;XValue llatt_2;
if (!ll_DefinedValue(&llatt_2, &llstate_1, &llstate_2)) goto failed2;
{LLSTATE llstate_3;XNamedObjIdValue llatt_3;
if (!ll_ObjIdComponentList(&llatt_3, &llstate_2, &llstate_3)) goto failed2;
{LLSTATE llstate_4;
if (!llterm('}', (LLSTYPE *)0, &llstate_3, &llstate_4)) goto failed2;
*llout = llstate_4;
{Value_t *v;
	    v = GetValue((*llout).Assignments, llatt_2);
	    if (v) {
		if (GetTypeType((*llout).Assignments, v->Type) !=
		    eType_ObjectIdentifier &&
		    GetTypeType((*llout).Assignments, v->Type) !=
		    eType_Undefined)
		    LLFAILED((&llstate_2.pos, "Bad type of value in object identifier"));
		if (GetTypeType((*llout).Assignments, v->Type) ==
		    eType_ObjectIdentifier) {
		    switch (GetAssignedObjectIdentifier(
			&(*llout).AssignedObjIds, v, llatt_3, &(*llret))) {
		    case -1:
			LLFAILED((&llstate_3.pos, "Different numbers for equally named object identifier components"));
			/*NOTREACHED*/
		    case 0:
			if (pass <= 2)
			    (*llret) = NULL;
			else
			    LLFAILED((&llstate_2.pos, "Unknown object identifier component"));
			break;
		    case 1:
			break;
		    }
		}
	    } else {
		(*llret) = NULL;
	    }
	
break;
}}}}}
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("ObjectIdentifierValue");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("ObjectIdentifierValue", 1);
return 1;
failed1: LLDEBUG_LEAVE("ObjectIdentifierValue", 0);
return 0;
}

int ll_ObjIdComponentList(XNamedObjIdValue *llret, LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("ObjIdComponentList");

llstate_0 = *llin;
#undef failed
#define failed failed1
{LLSTATE llstate_1;XNamedObjIdValue llatt_1;
if (!ll_ObjIdComponent(&llatt_1, &llstate_0, &llstate_1)) goto failed1;
{LLSTATE llstate_2;XNamedObjIdValue llatt_2;
if (!ll_ObjIdComponent_ESeq(&llatt_2, &llstate_1, &llstate_2)) goto failed1;
*llout = llstate_2;
{if (llatt_1) {
		(*llret) = DupNamedObjIdValue(llatt_1);
		(*llret)->Next = llatt_2;
	    } else {
		(*llret) = NULL;
	    }
	
}}}
LLDEBUG_LEAVE("ObjIdComponentList", 1);
return 1;
failed1: LLDEBUG_LEAVE("ObjIdComponentList", 0);
return 0;
}

int ll_ObjIdComponent_ESeq(XNamedObjIdValue *llret, LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("ObjIdComponent_ESeq");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("ObjIdComponent_ESeq", 1);
{LLSTATE llstate_1;XNamedObjIdValue llatt_1;
if (!ll_ObjIdComponent(&llatt_1, &llstate_0, &llstate_1)) goto failed2;
{LLSTATE llstate_2;XNamedObjIdValue llatt_2;
if (!ll_ObjIdComponent_ESeq(&llatt_2, &llstate_1, &llstate_2)) goto failed2;
*llout = llstate_2;
{if (llatt_1) {
		(*llret) = DupNamedObjIdValue(llatt_1);
		(*llret)->Next = llatt_2;
	    } else {
		(*llret) = NULL;
	    }
	
break;
}}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("ObjIdComponent_ESeq", 2);
*llout = llstate_0;
{(*llret) = NULL;
	
break;
}
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("ObjIdComponent_ESeq");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("ObjIdComponent_ESeq", 1);
return 1;
failed1: LLDEBUG_LEAVE("ObjIdComponent_ESeq", 0);
return 0;
}

int ll_ObjIdComponent(XNamedObjIdValue *llret, LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("ObjIdComponent");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("ObjIdComponent", 1);
{LLSTATE llstate_1;XNamedObjIdValue llatt_1;
if (!ll_NameForm(&llatt_1, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = llatt_1;
	
break;
}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("ObjIdComponent", 2);
{LLSTATE llstate_1;XNamedObjIdValue llatt_1;
if (!ll_NumberForm(&llatt_1, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = llatt_1;
	
break;
}}
case 3: case -3:
LLDEBUG_ALTERNATIVE("ObjIdComponent", 3);
{LLSTATE llstate_1;XNamedObjIdValue llatt_1;
if (!ll_NameAndNumberForm(&llatt_1, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = llatt_1;
	
break;
}}
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("ObjIdComponent");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("ObjIdComponent", 1);
return 1;
failed1: LLDEBUG_LEAVE("ObjIdComponent", 0);
return 0;
}

int ll_NameForm(XNamedObjIdValue *llret, LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("NameForm");

llstate_0 = *llin;
#undef failed
#define failed failed1
{LLSTATE llstate_1;XString llatt_1;
if (!ll_identifier(&llatt_1, &llstate_0, &llstate_1)) goto failed1;
*llout = llstate_1;
{(*llret) = NewNamedObjIdValue(eNamedObjIdValue_NameForm);
	    (*llret)->Name = llatt_1;
	
}}
LLDEBUG_LEAVE("NameForm", 1);
return 1;
failed1: LLDEBUG_LEAVE("NameForm", 0);
return 0;
}

int ll_NumberForm(XNamedObjIdValue *llret, LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("NumberForm");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("NumberForm", 1);
{LLSTATE llstate_1;XNumber llatt_1;
if (!llterm(T_number, &lllval, &llstate_0, &llstate_1)) goto failed2;
llatt_1 = lllval._XNumber;
*llout = llstate_1;
{(*llret) = NewNamedObjIdValue(eNamedObjIdValue_NumberForm);
	    (*llret)->Number = intx2uint32(&llatt_1);
	
break;
}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("NumberForm", 2);
{LLSTATE llstate_1;XValue llatt_1;
if (!ll_DefinedValue(&llatt_1, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{Value_t *v;
	    v = GetValue((*llout).Assignments, llatt_1);
	    if (v &&
		GetTypeType((*llout).Assignments, v->Type) != eType_Integer &&
		GetTypeType((*llout).Assignments, v->Type) != eType_Undefined)
		LLFAILED((&llstate_1.pos, "Bad type in object identifier"));
	    if (v &&
		GetTypeType((*llout).Assignments, v->Type) == eType_Integer &&
		intx_cmp(&v->U.Integer.Value, &intx_0) < 0)
		LLFAILED((&llstate_1.pos, "Bad value in object identifier"));
	    if (v &&
		GetTypeType((*llout).Assignments, v->Type) == eType_Integer) {
		(*llret) = NewNamedObjIdValue(eNamedObjIdValue_NumberForm);
		(*llret)->Number = intx2uint32(&v->U.Integer.Value);
	    } else {
		(*llret) = NULL;
	    }
	
break;
}}
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("NumberForm");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("NumberForm", 1);
return 1;
failed1: LLDEBUG_LEAVE("NumberForm", 0);
return 0;
}

int ll_NameAndNumberForm(XNamedObjIdValue *llret, LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("NameAndNumberForm");

llstate_0 = *llin;
#undef failed
#define failed failed1
{LLSTATE llstate_1;XString llatt_1;
if (!ll_identifier(&llatt_1, &llstate_0, &llstate_1)) goto failed1;
{LLSTATE llstate_2;
if (!llterm('(', (LLSTYPE *)0, &llstate_1, &llstate_2)) goto failed1;
{LLSTATE llstate_3;XNamedObjIdValue llatt_3;
if (!ll_NumberForm(&llatt_3, &llstate_2, &llstate_3)) goto failed1;
{LLSTATE llstate_4;
if (!llterm(')', (LLSTYPE *)0, &llstate_3, &llstate_4)) goto failed1;
*llout = llstate_4;
{if (llatt_3) {
		(*llret) = NewNamedObjIdValue(eNamedObjIdValue_NameAndNumberForm);
		(*llret)->Name = llatt_1;
		(*llret)->Number = llatt_3->Number;
	    } else {
		(*llret) = NULL;
	    }
	
}}}}}
LLDEBUG_LEAVE("NameAndNumberForm", 1);
return 1;
failed1: LLDEBUG_LEAVE("NameAndNumberForm", 0);
return 0;
}

int ll_EmbeddedPDVValue(XValue *llret, LLSTATE *llin, LLSTATE *llout, XType llarg_type)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("EmbeddedPDVValue");

llstate_0 = *llin;
#undef failed
#define failed failed1
{LLSTATE llstate_1;XValue llatt_1;
if (!ll_SequenceValue(&llatt_1, &llstate_0, &llstate_1, llarg_type)) goto failed1;
*llout = llstate_1;
{(*llret) = llatt_1;
	
}}
LLDEBUG_LEAVE("EmbeddedPDVValue", 1);
return 1;
failed1: LLDEBUG_LEAVE("EmbeddedPDVValue", 0);
return 0;
}

int ll_ExternalValue(XValue *llret, LLSTATE *llin, LLSTATE *llout, XType llarg_type)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("ExternalValue");

llstate_0 = *llin;
#undef failed
#define failed failed1
{LLSTATE llstate_1;XValue llatt_1;
if (!ll_SequenceValue(&llatt_1, &llstate_0, &llstate_1, llarg_type)) goto failed1;
*llout = llstate_1;
{(*llret) = llatt_1;
	
}}
LLDEBUG_LEAVE("ExternalValue", 1);
return 1;
failed1: LLDEBUG_LEAVE("ExternalValue", 0);
return 0;
}

int ll_CharacterStringValue(XValue *llret, LLSTATE *llin, LLSTATE *llout, XType llarg_type)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("CharacterStringValue");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("CharacterStringValue", 1);
{Type_e type;
	    type = GetTypeType((*llin).Assignments, llarg_type);
	    if (type != eType_Undefined && !IsRestrictedString(type))
		LLFAILED((&llstate_0.pos, "Bad type of value"));
	
{LLSTATE llstate_1;XValue llatt_1;
if (!ll_RestrictedCharacterStringValue(&llatt_1, &llstate_0, &llstate_1, llarg_type)) goto failed2;
*llout = llstate_1;
{(*llret) = llatt_1;
	
break;
}}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("CharacterStringValue", 2);
{if (GetTypeType((*llin).Assignments, llarg_type) != eType_Undefined &&
		GetTypeType((*llin).Assignments, llarg_type) != eType_CharacterString)
		LLFAILED((&llstate_0.pos, "Bad type of value"));
	
{LLSTATE llstate_1;XValue llatt_1;
if (!ll_UnrestrictedCharacterStringValue(&llatt_1, &llstate_0, &llstate_1, llarg_type)) goto failed2;
*llout = llstate_1;
{(*llret) = llatt_1;
	
break;
}}}
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("CharacterStringValue");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("CharacterStringValue", 1);
return 1;
failed1: LLDEBUG_LEAVE("CharacterStringValue", 0);
return 0;
}

int ll_RestrictedCharacterStringValue(XValue *llret, LLSTATE *llin, LLSTATE *llout, XType llarg_type)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("RestrictedCharacterStringValue");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("RestrictedCharacterStringValue", 1);
{LLSTATE llstate_1;XString32 llatt_1;
if (!llterm(T_cstring, &lllval, &llstate_0, &llstate_1)) goto failed2;
llatt_1 = lllval._XString32;
*llout = llstate_1;
{(*llret) = NewValue((*llout).Assignments, llarg_type);
	    (*llret)->U.RestrictedString.Value.length = str32len(llatt_1);
	    (*llret)->U.RestrictedString.Value.value = llatt_1;
	
break;
}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("RestrictedCharacterStringValue", 2);
{LLSTATE llstate_1;XValue llatt_1;
if (!ll_CharacterStringList(&llatt_1, &llstate_0, &llstate_1, llarg_type)) goto failed2;
*llout = llstate_1;
{(*llret) = llatt_1;
	
break;
}}
case 3: case -3:
LLDEBUG_ALTERNATIVE("RestrictedCharacterStringValue", 3);
{LLSTATE llstate_1;XQuadruple llatt_1;
if (!ll_Quadruple(&llatt_1, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = NewValue((*llout).Assignments, llarg_type);
	    (*llret)->U.RestrictedString.Value.length = 1;
	    (*llret)->U.RestrictedString.Value.value =
		(char32_t *)malloc(sizeof(char32_t));
	    (*llret)->U.RestrictedString.Value.value[0] =
		256 * (256 * (256 * llatt_1.Group + llatt_1.Plane) + llatt_1.Row) + llatt_1.Cell;
	
break;
}}
case 4: case -4:
LLDEBUG_ALTERNATIVE("RestrictedCharacterStringValue", 4);
{LLSTATE llstate_1;XTuple llatt_1;
if (!ll_Tuple(&llatt_1, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = NewValue((*llout).Assignments, llarg_type);
	    (*llret)->U.RestrictedString.Value.length = 1;
	    (*llret)->U.RestrictedString.Value.value =
		(char32_t *)malloc(sizeof(char32_t));
	    *(*llret)->U.RestrictedString.Value.value =
		llatt_1.Column * 16 + llatt_1.Row;
	
break;
}}
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("RestrictedCharacterStringValue");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("RestrictedCharacterStringValue", 1);
return 1;
failed1: LLDEBUG_LEAVE("RestrictedCharacterStringValue", 0);
return 0;
}

int ll_UnrestrictedCharacterStringValue(XValue *llret, LLSTATE *llin, LLSTATE *llout, XType llarg_type)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("UnrestrictedCharacterStringValue");

llstate_0 = *llin;
#undef failed
#define failed failed1
{LLSTATE llstate_1;XValue llatt_1;
if (!ll_SequenceValue(&llatt_1, &llstate_0, &llstate_1, llarg_type)) goto failed1;
*llout = llstate_1;
{(*llret) = llatt_1;
	
}}
LLDEBUG_LEAVE("UnrestrictedCharacterStringValue", 1);
return 1;
failed1: LLDEBUG_LEAVE("UnrestrictedCharacterStringValue", 0);
return 0;
}

int ll_CharacterStringList(XValue *llret, LLSTATE *llin, LLSTATE *llout, XType llarg_type)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("CharacterStringList");

llstate_0 = *llin;
#undef failed
#define failed failed1
{LLSTATE llstate_1;
if (!llterm('{', (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed1;
{LLSTATE llstate_2;XValue llatt_2;
if (!ll_CharSyms(&llatt_2, &llstate_1, &llstate_2, llarg_type)) goto failed1;
{LLSTATE llstate_3;
if (!llterm('}', (LLSTYPE *)0, &llstate_2, &llstate_3)) goto failed1;
*llout = llstate_3;
{(*llret) = llatt_2;
	
}}}}
LLDEBUG_LEAVE("CharacterStringList", 1);
return 1;
failed1: LLDEBUG_LEAVE("CharacterStringList", 0);
return 0;
}

int ll_CharSyms(XValue *llret, LLSTATE *llin, LLSTATE *llout, XType llarg_type)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("CharSyms");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("CharSyms", 1);
{LLSTATE llstate_1;XValue llatt_1;
if (!ll_CharDefn(&llatt_1, &llstate_0, &llstate_1, llarg_type)) goto failed2;
*llout = llstate_1;
{(*llret) = llatt_1;
	
break;
}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("CharSyms", 2);
{LLSTATE llstate_1;XValue llatt_1;
if (!ll_CharDefn(&llatt_1, &llstate_0, &llstate_1, llarg_type)) goto failed2;
{LLSTATE llstate_2;
if (!llterm(',', (LLSTYPE *)0, &llstate_1, &llstate_2)) goto failed2;
{LLSTATE llstate_3;XValue llatt_3;
if (!ll_CharSyms(&llatt_3, &llstate_2, &llstate_3, llarg_type)) goto failed2;
*llout = llstate_3;
{if (!llatt_1 || !llatt_3) {
		(*llret) = NULL;
	    } else {
		(*llret) = NewValue((*llout).Assignments, llarg_type);
		(*llret)->U.RestrictedString.Value.length =
		    llatt_1->U.RestrictedString.Value.length +
		    llatt_3->U.RestrictedString.Value.length;
		(*llret)->U.RestrictedString.Value.value =
		    (char32_t *)malloc(
		    (*llret)->U.RestrictedString.Value.length *
		    sizeof(char32_t));
		memcpy((*llret)->U.RestrictedString.Value.value,
		    llatt_1->U.RestrictedString.Value.value,
		    llatt_1->U.RestrictedString.Value.length *
		    sizeof(char32_t));
		memcpy((*llret)->U.RestrictedString.Value.value +
		    llatt_1->U.RestrictedString.Value.length,
		    llatt_3->U.RestrictedString.Value.value,
		    llatt_3->U.RestrictedString.Value.length *
		    sizeof(char32_t));
	    }
	
break;
}}}}
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("CharSyms");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("CharSyms", 1);
return 1;
failed1: LLDEBUG_LEAVE("CharSyms", 0);
return 0;
}

int ll_CharDefn(XValue *llret, LLSTATE *llin, LLSTATE *llout, XType llarg_type)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("CharDefn");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("CharDefn", 1);
{LLSTATE llstate_1;XString32 llatt_1;
if (!llterm(T_cstring, &lllval, &llstate_0, &llstate_1)) goto failed2;
llatt_1 = lllval._XString32;
*llout = llstate_1;
{(*llret) = NewValue((*llout).Assignments, llarg_type);
	    (*llret)->U.RestrictedString.Value.length = str32len(llatt_1);
	    (*llret)->U.RestrictedString.Value.value = llatt_1;
	
break;
}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("CharDefn", 2);
{LLSTATE llstate_1;XValue llatt_1;
if (!ll_DefinedValue(&llatt_1, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = llatt_1;
	
break;
}}
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("CharDefn");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("CharDefn", 1);
return 1;
failed1: LLDEBUG_LEAVE("CharDefn", 0);
return 0;
}

int ll_Quadruple(XQuadruple *llret, LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("Quadruple");

llstate_0 = *llin;
#undef failed
#define failed failed1
{LLSTATE llstate_1;
if (!llterm('{', (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed1;
{LLSTATE llstate_2;XNumber llatt_2;
if (!llterm(T_number, &lllval, &llstate_1, &llstate_2)) goto failed1;
llatt_2 = lllval._XNumber;
{LLSTATE llstate_3;
if (!llterm(',', (LLSTYPE *)0, &llstate_2, &llstate_3)) goto failed1;
{LLSTATE llstate_4;XNumber llatt_4;
if (!llterm(T_number, &lllval, &llstate_3, &llstate_4)) goto failed1;
llatt_4 = lllval._XNumber;
{LLSTATE llstate_5;
if (!llterm(',', (LLSTYPE *)0, &llstate_4, &llstate_5)) goto failed1;
{LLSTATE llstate_6;XNumber llatt_6;
if (!llterm(T_number, &lllval, &llstate_5, &llstate_6)) goto failed1;
llatt_6 = lllval._XNumber;
{LLSTATE llstate_7;
if (!llterm(',', (LLSTYPE *)0, &llstate_6, &llstate_7)) goto failed1;
{LLSTATE llstate_8;XNumber llatt_8;
if (!llterm(T_number, &lllval, &llstate_7, &llstate_8)) goto failed1;
llatt_8 = lllval._XNumber;
{LLSTATE llstate_9;
if (!llterm('}', (LLSTYPE *)0, &llstate_8, &llstate_9)) goto failed1;
*llout = llstate_9;
{(*llret).Group = intx2uint32(&llatt_2);
	    (*llret).Plane = intx2uint32(&llatt_4);
	    (*llret).Row = intx2uint32(&llatt_6);
	    (*llret).Cell = intx2uint32(&llatt_8);
	
}}}}}}}}}}
LLDEBUG_LEAVE("Quadruple", 1);
return 1;
failed1: LLDEBUG_LEAVE("Quadruple", 0);
return 0;
}

int ll_Tuple(XTuple *llret, LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("Tuple");

llstate_0 = *llin;
#undef failed
#define failed failed1
{LLSTATE llstate_1;
if (!llterm('{', (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed1;
{LLSTATE llstate_2;XNumber llatt_2;
if (!llterm(T_number, &lllval, &llstate_1, &llstate_2)) goto failed1;
llatt_2 = lllval._XNumber;
{LLSTATE llstate_3;
if (!llterm(',', (LLSTYPE *)0, &llstate_2, &llstate_3)) goto failed1;
{LLSTATE llstate_4;XNumber llatt_4;
if (!llterm(T_number, &lllval, &llstate_3, &llstate_4)) goto failed1;
llatt_4 = lllval._XNumber;
{LLSTATE llstate_5;
if (!llterm('}', (LLSTYPE *)0, &llstate_4, &llstate_5)) goto failed1;
*llout = llstate_5;
{(*llret).Column = intx2uint32(&llatt_2);
	    (*llret).Row = intx2uint32(&llatt_4);
	
}}}}}}
LLDEBUG_LEAVE("Tuple", 1);
return 1;
failed1: LLDEBUG_LEAVE("Tuple", 0);
return 0;
}

int ll_AnyValue(XValue *llret, LLSTATE *llin, LLSTATE *llout, XType llarg_type)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("AnyValue");

llstate_0 = *llin;
#undef failed
#define failed failed1
{LLSTATE llstate_1;XType llatt_1;
if (!ll_Type(&llatt_1, &llstate_0, &llstate_1)) goto failed1;
{LLSTATE llstate_2;
if (!llterm(':', (LLSTYPE *)0, &llstate_1, &llstate_2)) goto failed1;
{LLSTATE llstate_3;XValue llatt_3;
if (!ll_Value(&llatt_3, &llstate_2, &llstate_3, llatt_1)) goto failed1;
*llout = llstate_3;
{(*llret) = llatt_3;
	
}}}}
LLDEBUG_LEAVE("AnyValue", 1);
return 1;
failed1: LLDEBUG_LEAVE("AnyValue", 0);
return 0;
}

int ll_Constraint(XConstraints *llret, LLSTATE *llin, LLSTATE *llout, XType llarg_type, XBoolean llarg_permalpha)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("Constraint");

llstate_0 = *llin;
#undef failed
#define failed failed1
{LLSTATE llstate_1;
if (!llterm('(', (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed1;
{LLSTATE llstate_2;XConstraints llatt_2;
if (!ll_ConstraintSpec(&llatt_2, &llstate_1, &llstate_2, llarg_type, llarg_permalpha)) goto failed1;
{LLSTATE llstate_3;
if (!ll_ExceptionSpec(&llstate_2, &llstate_3)) goto failed1;
{LLSTATE llstate_4;
if (!llterm(')', (LLSTYPE *)0, &llstate_3, &llstate_4)) goto failed1;
*llout = llstate_4;
{(*llret) = llatt_2; /*XXX ExceptionSpec */
	
}}}}}
LLDEBUG_LEAVE("Constraint", 1);
return 1;
failed1: LLDEBUG_LEAVE("Constraint", 0);
return 0;
}

int ll_ConstraintSpec(XConstraints *llret, LLSTATE *llin, LLSTATE *llout, XType llarg_type, XBoolean llarg_permalpha)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("ConstraintSpec");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("ConstraintSpec", 1);
{LLSTATE llstate_1;XConstraints llatt_1;
if (!ll_SubtypeConstraint(&llatt_1, &llstate_0, &llstate_1, llarg_type, llarg_permalpha)) goto failed2;
*llout = llstate_1;
{(*llret) = llatt_1;
	
break;
}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("ConstraintSpec", 2);
{LLSTATE llstate_1;
if (!ll_GeneralConstraint(&llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = NULL; /*XXX*/
	
break;
}}
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("ConstraintSpec");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("ConstraintSpec", 1);
return 1;
failed1: LLDEBUG_LEAVE("ConstraintSpec", 0);
return 0;
}

int ll_SubtypeConstraint(XConstraints *llret, LLSTATE *llin, LLSTATE *llout, XType llarg_type, XBoolean llarg_permalpha)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("SubtypeConstraint");

llstate_0 = *llin;
#undef failed
#define failed failed1
{LLSTATE llstate_1;XConstraints llatt_1;
if (!ll_ElementSetSpecs(&llatt_1, &llstate_0, &llstate_1, llarg_type, llarg_permalpha)) goto failed1;
*llout = llstate_1;
{(*llret) = llatt_1;
	
}}
LLDEBUG_LEAVE("SubtypeConstraint", 1);
return 1;
failed1: LLDEBUG_LEAVE("SubtypeConstraint", 0);
return 0;
}

int ll_ExceptionSpec(LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("ExceptionSpec");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("ExceptionSpec", 1);
{LLSTATE llstate_1;
if (!llterm('!', (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
{LLSTATE llstate_2;
if (!ll_ExceptionIdentification(&llstate_1, &llstate_2)) goto failed2;
*llout = llstate_2;
break;
}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("ExceptionSpec", 2);
*llout = llstate_0;
break;
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("ExceptionSpec");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("ExceptionSpec", 1);
return 1;
failed1: LLDEBUG_LEAVE("ExceptionSpec", 0);
return 0;
}

int ll_ExceptionIdentification(LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("ExceptionIdentification");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("ExceptionIdentification", 1);
{LLSTATE llstate_1;XValue llatt_1;
if (!ll_SignedNumber(&llatt_1, &llstate_0, &llstate_1, Builtin_Type_Integer)) goto failed2;
*llout = llstate_1;
break;
}
case 2: case -2:
LLDEBUG_ALTERNATIVE("ExceptionIdentification", 2);
{LLSTATE llstate_1;XValue llatt_1;
if (!ll_DefinedValue(&llatt_1, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
break;
}
case 3: case -3:
LLDEBUG_ALTERNATIVE("ExceptionIdentification", 3);
{LLSTATE llstate_1;XType llatt_1;
if (!ll_Type(&llatt_1, &llstate_0, &llstate_1)) goto failed2;
{LLSTATE llstate_2;
if (!llterm(':', (LLSTYPE *)0, &llstate_1, &llstate_2)) goto failed2;
{LLSTATE llstate_3;XValue llatt_3;
if (!ll_Value(&llatt_3, &llstate_2, &llstate_3, llatt_1)) goto failed2;
*llout = llstate_3;
break;
}}}
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("ExceptionIdentification");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("ExceptionIdentification", 1);
return 1;
failed1: LLDEBUG_LEAVE("ExceptionIdentification", 0);
return 0;
}

int ll_ElementSetSpecs(XConstraints *llret, LLSTATE *llin, LLSTATE *llout, XType llarg_type, XBoolean llarg_permalpha)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("ElementSetSpecs");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("ElementSetSpecs", 1);
{LLSTATE llstate_1;XElementSetSpec llatt_1;
if (!ll_ElementSetSpec(&llatt_1, &llstate_0, &llstate_1, llarg_type, NULL, llarg_permalpha)) goto failed2;
{LLSTATE llstate_2;XConstraints llatt_2;
if (!ll_ElementSetSpecExtension(&llatt_2, &llstate_1, &llstate_2, llarg_type, llarg_permalpha)) goto failed2;
*llout = llstate_2;
{if (llatt_2) {
		(*llret) = DupConstraint(llatt_2);
	    } else {
		(*llret) = NewConstraint();
	    }
	    (*llret)->Root = llatt_1;
	
break;
}}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("ElementSetSpecs", 2);
{LLSTATE llstate_1;
if (!llterm(T_TDOT, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
{LLSTATE llstate_2;XElementSetSpec llatt_2;
if (!ll_AdditionalElementSetSpec(&llatt_2, &llstate_1, &llstate_2, llarg_type, llarg_permalpha)) goto failed2;
*llout = llstate_2;
{(*llret) = NewConstraint();
	    (*llret)->Type = llatt_2 ? eExtension_Extended : eExtension_Extendable;
	    (*llret)->Additional = llatt_2;
	
break;
}}}
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("ElementSetSpecs");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("ElementSetSpecs", 1);
return 1;
failed1: LLDEBUG_LEAVE("ElementSetSpecs", 0);
return 0;
}

int ll_ElementSetSpecExtension(XConstraints *llret, LLSTATE *llin, LLSTATE *llout, XType llarg_type, XBoolean llarg_permalpha)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("ElementSetSpecExtension");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("ElementSetSpecExtension", 1);
{LLSTATE llstate_1;
if (!llterm(',', (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
{LLSTATE llstate_2;
if (!llterm(T_TDOT, (LLSTYPE *)0, &llstate_1, &llstate_2)) goto failed2;
{LLSTATE llstate_3;XElementSetSpec llatt_3;
if (!ll_AdditionalElementSetSpec(&llatt_3, &llstate_2, &llstate_3, llarg_type, llarg_permalpha)) goto failed2;
*llout = llstate_3;
{(*llret) = NewConstraint();
	    (*llret)->Type = llatt_3 ? eExtension_Extended : eExtension_Extendable;
	    (*llret)->Additional = llatt_3;
	
break;
}}}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("ElementSetSpecExtension", 2);
*llout = llstate_0;
{(*llret) = NULL;
	
break;
}
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("ElementSetSpecExtension");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("ElementSetSpecExtension", 1);
return 1;
failed1: LLDEBUG_LEAVE("ElementSetSpecExtension", 0);
return 0;
}

int ll_AdditionalElementSetSpec(XElementSetSpec *llret, LLSTATE *llin, LLSTATE *llout, XType llarg_type, XBoolean llarg_permalpha)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("AdditionalElementSetSpec");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("AdditionalElementSetSpec", 1);
{LLSTATE llstate_1;
if (!llterm(',', (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
{LLSTATE llstate_2;XElementSetSpec llatt_2;
if (!ll_ElementSetSpec(&llatt_2, &llstate_1, &llstate_2, llarg_type, NULL, llarg_permalpha)) goto failed2;
*llout = llstate_2;
{(*llret) = llatt_2;
	
break;
}}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("AdditionalElementSetSpec", 2);
*llout = llstate_0;
{(*llret) = NULL;
	
break;
}
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("AdditionalElementSetSpec");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("AdditionalElementSetSpec", 1);
return 1;
failed1: LLDEBUG_LEAVE("AdditionalElementSetSpec", 0);
return 0;
}

int ll_ElementSetSpec(XElementSetSpec *llret, LLSTATE *llin, LLSTATE *llout, XType llarg_type, XObjectClass llarg_objectclass, XBoolean llarg_permalpha)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("ElementSetSpec");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("ElementSetSpec", 1);
{LLSTATE llstate_1;XElementSetSpec llatt_1;
if (!ll_Unions(&llatt_1, &llstate_0, &llstate_1, llarg_type, llarg_objectclass, llarg_permalpha)) goto failed2;
*llout = llstate_1;
{(*llret) = llatt_1;
	
break;
}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("ElementSetSpec", 2);
{LLSTATE llstate_1;
if (!llterm(T_ALL, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
{LLSTATE llstate_2;XElementSetSpec llatt_2;
if (!ll_Exclusions(&llatt_2, &llstate_1, &llstate_2, llarg_type, llarg_objectclass, llarg_permalpha)) goto failed2;
*llout = llstate_2;
{(*llret) = NewElementSetSpec(eElementSetSpec_AllExcept);
	    (*llret)->U.AllExcept.Elements = llatt_2;
	
break;
}}}
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("ElementSetSpec");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("ElementSetSpec", 1);
return 1;
failed1: LLDEBUG_LEAVE("ElementSetSpec", 0);
return 0;
}

int ll_Unions(XElementSetSpec *llret, LLSTATE *llin, LLSTATE *llout, XType llarg_type, XObjectClass llarg_objectclass, XBoolean llarg_permalpha)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("Unions");

llstate_0 = *llin;
#undef failed
#define failed failed1
{LLSTATE llstate_1;XElementSetSpec llatt_1;
if (!ll_Intersections(&llatt_1, &llstate_0, &llstate_1, llarg_type, llarg_objectclass, llarg_permalpha)) goto failed1;
{LLSTATE llstate_2;XElementSetSpec llatt_2;
if (!ll_UnionList(&llatt_2, &llstate_1, &llstate_2, llarg_type, llarg_objectclass, llarg_permalpha)) goto failed1;
*llout = llstate_2;
{if (llatt_2) {
		(*llret) = NewElementSetSpec(eElementSetSpec_Union);
		(*llret)->U.Union.Elements1 = llatt_1;
		(*llret)->U.Union.Elements2 = llatt_2;
	    } else {
		(*llret) = llatt_1;
	    }
	
}}}
LLDEBUG_LEAVE("Unions", 1);
return 1;
failed1: LLDEBUG_LEAVE("Unions", 0);
return 0;
}

int ll_UnionList(XElementSetSpec *llret, LLSTATE *llin, LLSTATE *llout, XType llarg_type, XObjectClass llarg_objectclass, XBoolean llarg_permalpha)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("UnionList");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("UnionList", 1);
{LLSTATE llstate_1;
if (!ll_UnionMark(&llstate_0, &llstate_1)) goto failed2;
{LLSTATE llstate_2;XElementSetSpec llatt_2;
if (!ll_Unions(&llatt_2, &llstate_1, &llstate_2, llarg_type, llarg_objectclass, llarg_permalpha)) goto failed2;
*llout = llstate_2;
{(*llret) = llatt_2;
	
break;
}}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("UnionList", 2);
*llout = llstate_0;
{(*llret) = NULL;
	
break;
}
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("UnionList");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("UnionList", 1);
return 1;
failed1: LLDEBUG_LEAVE("UnionList", 0);
return 0;
}

int ll_Intersections(XElementSetSpec *llret, LLSTATE *llin, LLSTATE *llout, XType llarg_type, XObjectClass llarg_objectclass, XBoolean llarg_permalpha)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("Intersections");

llstate_0 = *llin;
#undef failed
#define failed failed1
{LLSTATE llstate_1;XElementSetSpec llatt_1;
if (!ll_IntersectionElements(&llatt_1, &llstate_0, &llstate_1, llarg_type, llarg_objectclass, llarg_permalpha)) goto failed1;
{LLSTATE llstate_2;XElementSetSpec llatt_2;
if (!ll_IntersectionList(&llatt_2, &llstate_1, &llstate_2, llarg_type, llarg_objectclass, llarg_permalpha)) goto failed1;
*llout = llstate_2;
{if (llatt_2) {
		(*llret) = NewElementSetSpec(eElementSetSpec_Intersection);
		(*llret)->U.Intersection.Elements1 = llatt_1;
		(*llret)->U.Intersection.Elements2 = llatt_2;
	    } else {
		(*llret) = llatt_1;
	    }
	
}}}
LLDEBUG_LEAVE("Intersections", 1);
return 1;
failed1: LLDEBUG_LEAVE("Intersections", 0);
return 0;
}

int ll_IntersectionList(XElementSetSpec *llret, LLSTATE *llin, LLSTATE *llout, XType llarg_type, XObjectClass llarg_objectclass, XBoolean llarg_permalpha)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("IntersectionList");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("IntersectionList", 1);
{LLSTATE llstate_1;
if (!ll_IntersectionMark(&llstate_0, &llstate_1)) goto failed2;
{LLSTATE llstate_2;XElementSetSpec llatt_2;
if (!ll_Intersections(&llatt_2, &llstate_1, &llstate_2, llarg_type, llarg_objectclass, llarg_permalpha)) goto failed2;
*llout = llstate_2;
{(*llret) = llatt_2;
	
break;
}}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("IntersectionList", 2);
*llout = llstate_0;
{(*llret) = NULL;
	
break;
}
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("IntersectionList");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("IntersectionList", 1);
return 1;
failed1: LLDEBUG_LEAVE("IntersectionList", 0);
return 0;
}

int ll_IntersectionElements(XElementSetSpec *llret, LLSTATE *llin, LLSTATE *llout, XType llarg_type, XObjectClass llarg_objectclass, XBoolean llarg_permalpha)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("IntersectionElements");

llstate_0 = *llin;
#undef failed
#define failed failed1
{LLSTATE llstate_1;XElementSetSpec llatt_1;
if (!ll_Elements(&llatt_1, &llstate_0, &llstate_1, llarg_type, llarg_objectclass, llarg_permalpha)) goto failed1;
{LLSTATE llstate_2;XElementSetSpec llatt_2;
if (!ll_Exclusions_Opt(&llatt_2, &llstate_1, &llstate_2, llarg_type, llarg_objectclass, llarg_permalpha)) goto failed1;
*llout = llstate_2;
{if (llatt_2) {
		(*llret) = NewElementSetSpec(eElementSetSpec_Exclusion);
		(*llret)->U.Exclusion.Elements1 = llatt_1;
		(*llret)->U.Exclusion.Elements2 = llatt_2;
	    } else {
		(*llret) = llatt_1;
	    }
	
}}}
LLDEBUG_LEAVE("IntersectionElements", 1);
return 1;
failed1: LLDEBUG_LEAVE("IntersectionElements", 0);
return 0;
}

int ll_Exclusions_Opt(XElementSetSpec *llret, LLSTATE *llin, LLSTATE *llout, XType llarg_type, XObjectClass llarg_objectclass, XBoolean llarg_permalpha)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("Exclusions_Opt");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("Exclusions_Opt", 1);
{LLSTATE llstate_1;XElementSetSpec llatt_1;
if (!ll_Exclusions(&llatt_1, &llstate_0, &llstate_1, llarg_type, llarg_objectclass, llarg_permalpha)) goto failed2;
*llout = llstate_1;
{(*llret) = llatt_1;
	
break;
}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("Exclusions_Opt", 2);
*llout = llstate_0;
{(*llret) = NULL;
	
break;
}
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("Exclusions_Opt");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("Exclusions_Opt", 1);
return 1;
failed1: LLDEBUG_LEAVE("Exclusions_Opt", 0);
return 0;
}

int ll_Exclusions(XElementSetSpec *llret, LLSTATE *llin, LLSTATE *llout, XType llarg_type, XObjectClass llarg_objectclass, XBoolean llarg_permalpha)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("Exclusions");

llstate_0 = *llin;
#undef failed
#define failed failed1
{LLSTATE llstate_1;
if (!llterm(T_EXCEPT, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed1;
{LLSTATE llstate_2;XElementSetSpec llatt_2;
if (!ll_Elements(&llatt_2, &llstate_1, &llstate_2, llarg_type, llarg_objectclass, llarg_permalpha)) goto failed1;
*llout = llstate_2;
{(*llret) = llatt_2;
	
}}}
LLDEBUG_LEAVE("Exclusions", 1);
return 1;
failed1: LLDEBUG_LEAVE("Exclusions", 0);
return 0;
}

int ll_UnionMark(LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("UnionMark");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("UnionMark", 1);
{LLSTATE llstate_1;
if (!llterm('|', (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
break;
}
case 2: case -2:
LLDEBUG_ALTERNATIVE("UnionMark", 2);
{LLSTATE llstate_1;
if (!llterm(T_UNION, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
break;
}
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("UnionMark");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("UnionMark", 1);
return 1;
failed1: LLDEBUG_LEAVE("UnionMark", 0);
return 0;
}

int ll_IntersectionMark(LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("IntersectionMark");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("IntersectionMark", 1);
{LLSTATE llstate_1;
if (!llterm('^', (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
break;
}
case 2: case -2:
LLDEBUG_ALTERNATIVE("IntersectionMark", 2);
{LLSTATE llstate_1;
if (!llterm(T_INTERSECTION, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
break;
}
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("IntersectionMark");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("IntersectionMark", 1);
return 1;
failed1: LLDEBUG_LEAVE("IntersectionMark", 0);
return 0;
}

int ll_Elements(XElementSetSpec *llret, LLSTATE *llin, LLSTATE *llout, XType llarg_type, XObjectClass llarg_objectclass, XBoolean llarg_permalpha)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("Elements");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("Elements", 1);
{if (llarg_objectclass)
		LLFAILED((&llstate_0.pos, "Bad object set"));
	
{LLSTATE llstate_1;XSubtypeElement llatt_1;
if (!ll_SubtypeElements(&llatt_1, &llstate_0, &llstate_1, llarg_type, llarg_permalpha)) goto failed2;
*llout = llstate_1;
{(*llret) = NewElementSetSpec(eElementSetSpec_SubtypeElement);
	    (*llret)->U.SubtypeElement.SubtypeElement = llatt_1;
	
break;
}}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("Elements", 2);
{if (llarg_type)
		LLFAILED((&llstate_0.pos, "Bad constraint"));
	
{LLSTATE llstate_1;XObjectSetElement llatt_1;
if (!ll_ObjectSetElements(&llatt_1, &llstate_0, &llstate_1, llarg_objectclass)) goto failed2;
*llout = llstate_1;
{(*llret) = NewElementSetSpec(eElementSetSpec_ObjectSetElement);
	    (*llret)->U.ObjectSetElement.ObjectSetElement = llatt_1;
	
break;
}}}
case 3: case -3:
LLDEBUG_ALTERNATIVE("Elements", 3);
{LLSTATE llstate_1;
if (!llterm('(', (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
{LLSTATE llstate_2;XElementSetSpec llatt_2;
if (!ll_ElementSetSpec(&llatt_2, &llstate_1, &llstate_2, llarg_type, llarg_objectclass, llarg_permalpha)) goto failed2;
{LLSTATE llstate_3;
if (!llterm(')', (LLSTYPE *)0, &llstate_2, &llstate_3)) goto failed2;
*llout = llstate_3;
{(*llret) = llatt_2;
	
break;
}}}}
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("Elements");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("Elements", 1);
return 1;
failed1: LLDEBUG_LEAVE("Elements", 0);
return 0;
}

int ll_SubtypeElements(XSubtypeElement *llret, LLSTATE *llin, LLSTATE *llout, XType llarg_type, XBoolean llarg_permalpha)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("SubtypeElements");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("SubtypeElements", 1);
{Type_e type;
	    type = GetTypeType((*llin).Assignments, llarg_type);
	    if (type == eType_Open)
		LLFAILED((&llstate_0.pos, "Bad constraint"));
	
{LLSTATE llstate_1;XSubtypeElement llatt_1;
if (!ll_SingleValue(&llatt_1, &llstate_0, &llstate_1, llarg_type)) goto failed2;
*llout = llstate_1;
{(*llret) = llatt_1;
	
break;
}}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("SubtypeElements", 2);
{Type_e type;
	    type = GetTypeType((*llin).Assignments, llarg_type);
	    if (type == eType_EmbeddedPdv ||
		type == eType_External ||
		type == eType_Open ||
		type == eType_CharacterString)
		LLFAILED((&llstate_0.pos, "Bad constraint"));
	
{LLSTATE llstate_1;XSubtypeElement llatt_1;
if (!ll_ContainedSubtype(&llatt_1, &llstate_0, &llstate_1, llarg_type)) goto failed2;
*llout = llstate_1;
{(*llret) = llatt_1;
	
break;
}}}
case 3: case -3:
LLDEBUG_ALTERNATIVE("SubtypeElements", 3);
{Type_e type;
	    type = GetTypeType((*llin).Assignments, llarg_type);
	    if (llarg_permalpha ?
		(type != eType_Undefined &&
		type != eType_BMPString &&
		type != eType_IA5String &&
		type != eType_NumericString &&
		type != eType_PrintableString &&
		type != eType_VisibleString &&
		type != eType_UniversalString) :
		(type != eType_Undefined &&
		type != eType_Integer &&
		type != eType_Real))
		LLFAILED((&llstate_0.pos, "Bad constraint"));
	
{LLSTATE llstate_1;XSubtypeElement llatt_1;
if (!ll_ValueRange(&llatt_1, &llstate_0, &llstate_1, llarg_type)) goto failed2;
*llout = llstate_1;
{(*llret) = llatt_1;
	
break;
}}}
case 4: case -4:
LLDEBUG_ALTERNATIVE("SubtypeElements", 4);
{Type_e type;
	    type = GetTypeType((*llin).Assignments, llarg_type);
	    if (type != eType_Undefined &&
		!IsRestrictedString(type) ||
		llarg_permalpha)
		LLFAILED((&llstate_0.pos, "Bad constraint"));
	
{LLSTATE llstate_1;XSubtypeElement llatt_1;
if (!ll_PermittedAlphabet(&llatt_1, &llstate_0, &llstate_1, llarg_type)) goto failed2;
*llout = llstate_1;
{(*llret) = llatt_1;
	
break;
}}}
case 5: case -5:
LLDEBUG_ALTERNATIVE("SubtypeElements", 5);
{Type_e type;
	    type = GetTypeType((*llin).Assignments, llarg_type);
	    if (type != eType_Undefined &&
		type != eType_BitString &&
		type != eType_OctetString &&
		type != eType_UTF8String &&
		type != eType_SequenceOf &&
		type != eType_SetOf &&
		type != eType_CharacterString &&
		!IsRestrictedString(type) ||
		llarg_permalpha)
		LLFAILED((&llstate_0.pos, "Bad constraint"));
	
{LLSTATE llstate_1;XSubtypeElement llatt_1;
if (!ll_SizeConstraint(&llatt_1, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = llatt_1;
	
break;
}}}
case 6: case -6:
LLDEBUG_ALTERNATIVE("SubtypeElements", 6);
{Type_e type;
	    type = GetTypeType((*llin).Assignments, llarg_type);
	    if (type != eType_Undefined &&
		type != eType_Open ||
		llarg_permalpha)
		LLFAILED((&llstate_0.pos, "Bad constraint"));
	
{LLSTATE llstate_1;XSubtypeElement llatt_1;
if (!ll_TypeConstraint(&llatt_1, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = llatt_1;
	
break;
}}}
case 7: case -7:
LLDEBUG_ALTERNATIVE("SubtypeElements", 7);
{Type_e type;
	    type = GetTypeType((*llin).Assignments, llarg_type);
	    if (type != eType_Undefined &&
		type != eType_Choice &&
		type != eType_EmbeddedPdv &&
		type != eType_External &&
		type != eType_InstanceOf &&
		type != eType_Real &&
		type != eType_Sequence &&
		type != eType_SequenceOf &&
		type != eType_Set &&
		type != eType_SetOf &&
		type != eType_CharacterString ||
		llarg_permalpha)
		LLFAILED((&llstate_0.pos, "Bad constraint"));
	
{LLSTATE llstate_1;XSubtypeElement llatt_1;
if (!ll_InnerTypeConstraints(&llatt_1, &llstate_0, &llstate_1, llarg_type)) goto failed2;
*llout = llstate_1;
{(*llret) = llatt_1;
	
break;
}}}
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("SubtypeElements");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("SubtypeElements", 1);
return 1;
failed1: LLDEBUG_LEAVE("SubtypeElements", 0);
return 0;
}

int ll_SingleValue(XSubtypeElement *llret, LLSTATE *llin, LLSTATE *llout, XType llarg_type)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("SingleValue");

llstate_0 = *llin;
#undef failed
#define failed failed1
{LLSTATE llstate_1;XValue llatt_1;
if (!ll_Value(&llatt_1, &llstate_0, &llstate_1, llarg_type)) goto failed1;
*llout = llstate_1;
{(*llret) = NewSubtypeElement(eSubtypeElement_SingleValue);
	    (*llret)->U.SingleValue.Value = llatt_1;
	
}}
LLDEBUG_LEAVE("SingleValue", 1);
return 1;
failed1: LLDEBUG_LEAVE("SingleValue", 0);
return 0;
}

int ll_ContainedSubtype(XSubtypeElement *llret, LLSTATE *llin, LLSTATE *llout, XType llarg_type)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("ContainedSubtype");

llstate_0 = *llin;
#undef failed
#define failed failed1
{LLSTATE llstate_1;XBoolean llatt_1;
if (!ll_Includes(&llatt_1, &llstate_0, &llstate_1)) goto failed1;
{LLSTATE llstate_2;XType llatt_2;
if (!ll_Type(&llatt_2, &llstate_1, &llstate_2)) goto failed1;
*llout = llstate_2;
{if (GetTypeType((*llout).Assignments, llatt_2) == eType_Null && !llatt_1)
		LLFAILED((&llstate_1.pos, "Bad constraint"));
	    if (GetTypeType((*llout).Assignments, llarg_type) != eType_Undefined &&
		GetTypeType((*llout).Assignments, llatt_2) != eType_Undefined &&
		GetTypeType((*llout).Assignments, llarg_type) !=
		GetTypeType((*llout).Assignments, llatt_2) &&
		GetTypeType((*llout).Assignments, llarg_type) != eType_Open &&
		GetTypeType((*llout).Assignments, llatt_2) != eType_Open &&
		(!IsRestrictedString(GetTypeType((*llout).Assignments, llarg_type)) ||
		!IsRestrictedString(GetTypeType((*llout).Assignments, llatt_2))))
		LLFAILED((&llstate_2.pos, "Bad type of contained-subtype-constraint"));
	    (*llret) = NewSubtypeElement(eSubtypeElement_ContainedSubtype);
	    (*llret)->U.ContainedSubtype.Type = llatt_2;
	
}}}
LLDEBUG_LEAVE("ContainedSubtype", 1);
return 1;
failed1: LLDEBUG_LEAVE("ContainedSubtype", 0);
return 0;
}

int ll_Includes(XBoolean *llret, LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("Includes");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("Includes", 1);
{LLSTATE llstate_1;
if (!llterm(T_INCLUDES, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = 1;
	
break;
}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("Includes", 2);
*llout = llstate_0;
{(*llret) = 0;
	
break;
}
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("Includes");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("Includes", 1);
return 1;
failed1: LLDEBUG_LEAVE("Includes", 0);
return 0;
}

int ll_ValueRange(XSubtypeElement *llret, LLSTATE *llin, LLSTATE *llout, XType llarg_type)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("ValueRange");

llstate_0 = *llin;
#undef failed
#define failed failed1
{LLSTATE llstate_1;XEndPoint llatt_1;
if (!ll_LowerEndpoint(&llatt_1, &llstate_0, &llstate_1, llarg_type)) goto failed1;
{LLSTATE llstate_2;
if (!llterm(T_DDOT, (LLSTYPE *)0, &llstate_1, &llstate_2)) goto failed1;
{LLSTATE llstate_3;XEndPoint llatt_3;
if (!ll_UpperEndpoint(&llatt_3, &llstate_2, &llstate_3, llarg_type)) goto failed1;
*llout = llstate_3;
{if (!llarg_type) {
		(*llret) = NULL;
	    } else {
		(*llret) = NewSubtypeElement(eSubtypeElement_ValueRange);
		(*llret)->U.ValueRange.Lower = llatt_1;
		(*llret)->U.ValueRange.Upper = llatt_3;
	    }
	
}}}}
LLDEBUG_LEAVE("ValueRange", 1);
return 1;
failed1: LLDEBUG_LEAVE("ValueRange", 0);
return 0;
}

int ll_LowerEndpoint(XEndPoint *llret, LLSTATE *llin, LLSTATE *llout, XType llarg_type)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("LowerEndpoint");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("LowerEndpoint", 1);
{LLSTATE llstate_1;XEndPoint llatt_1;
if (!ll_LowerEndValue(&llatt_1, &llstate_0, &llstate_1, llarg_type)) goto failed2;
{LLSTATE llstate_2;
if (!llterm('<', (LLSTYPE *)0, &llstate_1, &llstate_2)) goto failed2;
*llout = llstate_2;
{(*llret) = llatt_1;
	    (*llret).Flags |= eEndPoint_Open;
	
break;
}}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("LowerEndpoint", 2);
{LLSTATE llstate_1;XEndPoint llatt_1;
if (!ll_LowerEndValue(&llatt_1, &llstate_0, &llstate_1, llarg_type)) goto failed2;
*llout = llstate_1;
{(*llret) = llatt_1;
	
break;
}}
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("LowerEndpoint");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("LowerEndpoint", 1);
return 1;
failed1: LLDEBUG_LEAVE("LowerEndpoint", 0);
return 0;
}

int ll_UpperEndpoint(XEndPoint *llret, LLSTATE *llin, LLSTATE *llout, XType llarg_type)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("UpperEndpoint");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("UpperEndpoint", 1);
{LLSTATE llstate_1;
if (!llterm('<', (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
{LLSTATE llstate_2;XEndPoint llatt_2;
if (!ll_UpperEndValue(&llatt_2, &llstate_1, &llstate_2, llarg_type)) goto failed2;
*llout = llstate_2;
{(*llret) = llatt_2;
	    (*llret).Flags |= eEndPoint_Open;
	
break;
}}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("UpperEndpoint", 2);
{LLSTATE llstate_1;XEndPoint llatt_1;
if (!ll_UpperEndValue(&llatt_1, &llstate_0, &llstate_1, llarg_type)) goto failed2;
*llout = llstate_1;
{(*llret) = llatt_1;
	
break;
}}
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("UpperEndpoint");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("UpperEndpoint", 1);
return 1;
failed1: LLDEBUG_LEAVE("UpperEndpoint", 0);
return 0;
}

int ll_LowerEndValue(XEndPoint *llret, LLSTATE *llin, LLSTATE *llout, XType llarg_type)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("LowerEndValue");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("LowerEndValue", 1);
{LLSTATE llstate_1;XValue llatt_1;
if (!ll_Value(&llatt_1, &llstate_0, &llstate_1, llarg_type)) goto failed2;
*llout = llstate_1;
{(*llret).Value = llatt_1;
	    (*llret).Flags = 0;
	
break;
}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("LowerEndValue", 2);
{LLSTATE llstate_1;
if (!llterm(T_MIN, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret).Value = NULL;
	    (*llret).Flags = eEndPoint_Min;
	
break;
}}
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("LowerEndValue");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("LowerEndValue", 1);
return 1;
failed1: LLDEBUG_LEAVE("LowerEndValue", 0);
return 0;
}

int ll_UpperEndValue(XEndPoint *llret, LLSTATE *llin, LLSTATE *llout, XType llarg_type)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("UpperEndValue");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("UpperEndValue", 1);
{LLSTATE llstate_1;XValue llatt_1;
if (!ll_Value(&llatt_1, &llstate_0, &llstate_1, llarg_type)) goto failed2;
*llout = llstate_1;
{(*llret).Value = llatt_1;
	    (*llret).Flags = 0;
	
break;
}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("UpperEndValue", 2);
{LLSTATE llstate_1;
if (!llterm(T_MAX, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret).Value = NULL;
	    (*llret).Flags = eEndPoint_Max;
	
break;
}}
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("UpperEndValue");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("UpperEndValue", 1);
return 1;
failed1: LLDEBUG_LEAVE("UpperEndValue", 0);
return 0;
}

int ll_SizeConstraint(XSubtypeElement *llret, LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("SizeConstraint");

llstate_0 = *llin;
#undef failed
#define failed failed1
{LLSTATE llstate_1;
if (!llterm(T_SIZE, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed1;
{LLSTATE llstate_2;XConstraints llatt_2;
if (!ll_Constraint(&llatt_2, &llstate_1, &llstate_2, Builtin_Type_PositiveInteger, 0)) goto failed1;
*llout = llstate_2;
{(*llret) = NewSubtypeElement(eSubtypeElement_Size);
	    (*llret)->U.Size.Constraints = llatt_2;
	
}}}
LLDEBUG_LEAVE("SizeConstraint", 1);
return 1;
failed1: LLDEBUG_LEAVE("SizeConstraint", 0);
return 0;
}

int ll_TypeConstraint(XSubtypeElement *llret, LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("TypeConstraint");

llstate_0 = *llin;
#undef failed
#define failed failed1
{LLSTATE llstate_1;XType llatt_1;
if (!ll_Type(&llatt_1, &llstate_0, &llstate_1)) goto failed1;
*llout = llstate_1;
{(*llret) = NewSubtypeElement(eSubtypeElement_Type);
	    (*llret)->U.Type.Type = llatt_1;
	
}}
LLDEBUG_LEAVE("TypeConstraint", 1);
return 1;
failed1: LLDEBUG_LEAVE("TypeConstraint", 0);
return 0;
}

int ll_PermittedAlphabet(XSubtypeElement *llret, LLSTATE *llin, LLSTATE *llout, XType llarg_type)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("PermittedAlphabet");

llstate_0 = *llin;
#undef failed
#define failed failed1
{LLSTATE llstate_1;
if (!llterm(T_FROM, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed1;
{LLSTATE llstate_2;XConstraints llatt_2;
if (!ll_Constraint(&llatt_2, &llstate_1, &llstate_2, llarg_type, 1)) goto failed1;
*llout = llstate_2;
{(*llret) = NewSubtypeElement(eSubtypeElement_PermittedAlphabet);
	    (*llret)->U.PermittedAlphabet.Constraints = llatt_2;
	
}}}
LLDEBUG_LEAVE("PermittedAlphabet", 1);
return 1;
failed1: LLDEBUG_LEAVE("PermittedAlphabet", 0);
return 0;
}

int ll_InnerTypeConstraints(XSubtypeElement *llret, LLSTATE *llin, LLSTATE *llout, XType llarg_type)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("InnerTypeConstraints");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("InnerTypeConstraints", 1);
{Type_t *subtype;
	    if (GetTypeType((*llin).Assignments, llarg_type) != eType_Undefined &&
		GetTypeType((*llin).Assignments, llarg_type) != eType_SequenceOf &&
		GetTypeType((*llin).Assignments, llarg_type) != eType_SetOf)
		LLFAILED((&llstate_0.pos, "Bad constraint"));
	    if (GetTypeType((*llin).Assignments, llarg_type) == eType_Undefined)
		subtype = NULL;
	    else
		subtype = GetType((*llin).Assignments, llarg_type)->U.SS.Type;
	
{LLSTATE llstate_1;
if (!llterm(T_WITH, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
{LLSTATE llstate_2;
if (!llterm(T_COMPONENT, (LLSTYPE *)0, &llstate_1, &llstate_2)) goto failed2;
{LLSTATE llstate_3;XSubtypeElement llatt_3;
if (!ll_SingleTypeConstraint(&llatt_3, &llstate_2, &llstate_3, subtype)) goto failed2;
*llout = llstate_3;
{(*llret) = llatt_3;
	
break;
}}}}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("InnerTypeConstraints", 2);
{Component_t *components;
	    if (GetTypeType((*llin).Assignments, llarg_type) != eType_Undefined &&
		GetTypeType((*llin).Assignments, llarg_type) != eType_Sequence &&
		GetTypeType((*llin).Assignments, llarg_type) != eType_Set &&
		GetTypeType((*llin).Assignments, llarg_type) != eType_Choice &&
		GetTypeType((*llin).Assignments, llarg_type) != eType_Real &&
		GetTypeType((*llin).Assignments, llarg_type) != eType_External &&
		GetTypeType((*llin).Assignments, llarg_type) != eType_EmbeddedPdv &&
		GetTypeType((*llin).Assignments, llarg_type) != eType_CharacterString)
		LLFAILED((&llstate_0.pos, "Bad constraint"));
	    if (GetTypeType((*llin).Assignments, llarg_type) == eType_Undefined)
	    	components = NULL;
	    else
		components = GetType((*llin).Assignments, llarg_type)->U.SSC.Components;
	
{LLSTATE llstate_1;
if (!llterm(T_WITH, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
{LLSTATE llstate_2;
if (!llterm(T_COMPONENTS, (LLSTYPE *)0, &llstate_1, &llstate_2)) goto failed2;
{LLSTATE llstate_3;XSubtypeElement llatt_3;
if (!ll_MultipleTypeConstraints(&llatt_3, &llstate_2, &llstate_3, components)) goto failed2;
*llout = llstate_3;
{(*llret) = llatt_3;
	
break;
}}}}}
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("InnerTypeConstraints");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("InnerTypeConstraints", 1);
return 1;
failed1: LLDEBUG_LEAVE("InnerTypeConstraints", 0);
return 0;
}

int ll_SingleTypeConstraint(XSubtypeElement *llret, LLSTATE *llin, LLSTATE *llout, XType llarg_type)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("SingleTypeConstraint");

llstate_0 = *llin;
#undef failed
#define failed failed1
{LLSTATE llstate_1;XConstraints llatt_1;
if (!ll_Constraint(&llatt_1, &llstate_0, &llstate_1, llarg_type, 0)) goto failed1;
*llout = llstate_1;
{(*llret) = NewSubtypeElement(eSubtypeElement_SingleType);
	    (*llret)->U.SingleType.Constraints = llatt_1;
	
}}
LLDEBUG_LEAVE("SingleTypeConstraint", 1);
return 1;
failed1: LLDEBUG_LEAVE("SingleTypeConstraint", 0);
return 0;
}

int ll_MultipleTypeConstraints(XSubtypeElement *llret, LLSTATE *llin, LLSTATE *llout, XComponents llarg_components)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("MultipleTypeConstraints");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("MultipleTypeConstraints", 1);
{LLSTATE llstate_1;XSubtypeElement llatt_1;
if (!ll_FullSpecification(&llatt_1, &llstate_0, &llstate_1, llarg_components)) goto failed2;
*llout = llstate_1;
{(*llret) = llatt_1;
	
break;
}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("MultipleTypeConstraints", 2);
{LLSTATE llstate_1;XSubtypeElement llatt_1;
if (!ll_PartialSpecification(&llatt_1, &llstate_0, &llstate_1, llarg_components)) goto failed2;
*llout = llstate_1;
{(*llret) = llatt_1;
	
break;
}}
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("MultipleTypeConstraints");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("MultipleTypeConstraints", 1);
return 1;
failed1: LLDEBUG_LEAVE("MultipleTypeConstraints", 0);
return 0;
}

int ll_FullSpecification(XSubtypeElement *llret, LLSTATE *llin, LLSTATE *llout, XComponents llarg_components)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("FullSpecification");

llstate_0 = *llin;
#undef failed
#define failed failed1
{LLSTATE llstate_1;
if (!llterm('{', (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed1;
{LLSTATE llstate_2;XNamedConstraints llatt_2;
if (!ll_TypeConstraints(&llatt_2, &llstate_1, &llstate_2, llarg_components)) goto failed1;
{LLSTATE llstate_3;
if (!llterm('}', (LLSTYPE *)0, &llstate_2, &llstate_3)) goto failed1;
*llout = llstate_3;
{(*llret) = NewSubtypeElement(eSubtypeElement_FullSpecification);
	    (*llret)->U.FullSpecification.NamedConstraints = llatt_2;
	
}}}}
LLDEBUG_LEAVE("FullSpecification", 1);
return 1;
failed1: LLDEBUG_LEAVE("FullSpecification", 0);
return 0;
}

int ll_PartialSpecification(XSubtypeElement *llret, LLSTATE *llin, LLSTATE *llout, XComponents llarg_components)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("PartialSpecification");

llstate_0 = *llin;
#undef failed
#define failed failed1
{LLSTATE llstate_1;
if (!llterm('{', (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed1;
{LLSTATE llstate_2;
if (!llterm(T_TDOT, (LLSTYPE *)0, &llstate_1, &llstate_2)) goto failed1;
{LLSTATE llstate_3;
if (!llterm(',', (LLSTYPE *)0, &llstate_2, &llstate_3)) goto failed1;
{LLSTATE llstate_4;XNamedConstraints llatt_4;
if (!ll_TypeConstraints(&llatt_4, &llstate_3, &llstate_4, llarg_components)) goto failed1;
{LLSTATE llstate_5;
if (!llterm('}', (LLSTYPE *)0, &llstate_4, &llstate_5)) goto failed1;
*llout = llstate_5;
{(*llret) = NewSubtypeElement(eSubtypeElement_PartialSpecification);
	    (*llret)->U.PartialSpecification.NamedConstraints = llatt_4;
	
}}}}}}
LLDEBUG_LEAVE("PartialSpecification", 1);
return 1;
failed1: LLDEBUG_LEAVE("PartialSpecification", 0);
return 0;
}

int ll_TypeConstraints(XNamedConstraints *llret, LLSTATE *llin, LLSTATE *llout, XComponents llarg_components)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("TypeConstraints");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("TypeConstraints", 1);
{LLSTATE llstate_1;XNamedConstraints llatt_1;
if (!ll_NamedConstraint(&llatt_1, &llstate_0, &llstate_1, llarg_components)) goto failed2;
*llout = llstate_1;
{(*llret) = llatt_1;
	
break;
}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("TypeConstraints", 2);
{LLSTATE llstate_1;XNamedConstraints llatt_1;
if (!ll_NamedConstraint(&llatt_1, &llstate_0, &llstate_1, llarg_components)) goto failed2;
{LLSTATE llstate_2;
if (!llterm(',', (LLSTYPE *)0, &llstate_1, &llstate_2)) goto failed2;
{LLSTATE llstate_3;XNamedConstraints llatt_3;
if (!ll_TypeConstraints(&llatt_3, &llstate_2, &llstate_3, llarg_components)) goto failed2;
*llout = llstate_3;
{(*llret) = llatt_1;
	    (*llret)->Next = llatt_3;
	
break;
}}}}
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("TypeConstraints");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("TypeConstraints", 1);
return 1;
failed1: LLDEBUG_LEAVE("TypeConstraints", 0);
return 0;
}

int ll_NamedConstraint(XNamedConstraints *llret, LLSTATE *llin, LLSTATE *llout, XComponents llarg_components)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("NamedConstraint");

llstate_0 = *llin;
#undef failed
#define failed failed1
{LLSTATE llstate_1;XString llatt_1;
if (!ll_identifier(&llatt_1, &llstate_0, &llstate_1)) goto failed1;
{Component_t *component;
	    Type_t *type;
	    component = FindComponent(llstate_1.Assignments, llarg_components, llatt_1);
	    type = component ? component->U.NOD.NamedType->Type : NULL;
	
{LLSTATE llstate_2;XNamedConstraints llatt_2;
if (!ll_ComponentConstraint(&llatt_2, &llstate_1, &llstate_2, type)) goto failed1;
*llout = llstate_2;
{(*llret) = llatt_2;
	    (*llret)->Identifier = llatt_1;
	
}}}}
LLDEBUG_LEAVE("NamedConstraint", 1);
return 1;
failed1: LLDEBUG_LEAVE("NamedConstraint", 0);
return 0;
}

int ll_ComponentConstraint(XNamedConstraints *llret, LLSTATE *llin, LLSTATE *llout, XType llarg_type)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("ComponentConstraint");

llstate_0 = *llin;
#undef failed
#define failed failed1
{LLSTATE llstate_1;XConstraints llatt_1;
if (!ll_ValueConstraint(&llatt_1, &llstate_0, &llstate_1, llarg_type)) goto failed1;
{LLSTATE llstate_2;XPresence llatt_2;
if (!ll_PresenceConstraint(&llatt_2, &llstate_1, &llstate_2)) goto failed1;
*llout = llstate_2;
{(*llret) = NewNamedConstraint();
	    (*llret)->Constraint = llatt_1;
	    (*llret)->Presence = llatt_2;
	
}}}
LLDEBUG_LEAVE("ComponentConstraint", 1);
return 1;
failed1: LLDEBUG_LEAVE("ComponentConstraint", 0);
return 0;
}

int ll_ValueConstraint(XConstraints *llret, LLSTATE *llin, LLSTATE *llout, XType llarg_type)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("ValueConstraint");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("ValueConstraint", 1);
{LLSTATE llstate_1;XConstraints llatt_1;
if (!ll_Constraint(&llatt_1, &llstate_0, &llstate_1, llarg_type, 0)) goto failed2;
*llout = llstate_1;
{(*llret) = llatt_1;
	
break;
}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("ValueConstraint", 2);
*llout = llstate_0;
{(*llret) = NULL;
	
break;
}
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("ValueConstraint");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("ValueConstraint", 1);
return 1;
failed1: LLDEBUG_LEAVE("ValueConstraint", 0);
return 0;
}

int ll_PresenceConstraint(XPresence *llret, LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("PresenceConstraint");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("PresenceConstraint", 1);
{LLSTATE llstate_1;
if (!llterm(T_PRESENT, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = ePresence_Present;
	
break;
}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("PresenceConstraint", 2);
{LLSTATE llstate_1;
if (!llterm(T_ABSENT, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = ePresence_Absent;
	
break;
}}
case 3: case -3:
LLDEBUG_ALTERNATIVE("PresenceConstraint", 3);
{LLSTATE llstate_1;
if (!llterm(T_OPTIONAL, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = ePresence_Optional;
	
break;
}}
case 4: case -4:
LLDEBUG_ALTERNATIVE("PresenceConstraint", 4);
*llout = llstate_0;
{(*llret) = ePresence_Normal;
	
break;
}
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("PresenceConstraint");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("PresenceConstraint", 1);
return 1;
failed1: LLDEBUG_LEAVE("PresenceConstraint", 0);
return 0;
}

int ll_GeneralConstraint(LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("GeneralConstraint");

llstate_0 = *llin;
#undef failed
#define failed failed1
{LLSTATE llstate_1;
if (!llterm(T_CON_XXX1, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed1;
*llout = llstate_1;
{MyAbort(); 
}}
LLDEBUG_LEAVE("GeneralConstraint", 1);
return 1;
failed1: LLDEBUG_LEAVE("GeneralConstraint", 0);
return 0;
}

int ll_LocalTypeDirectiveSeq(XDirectives *llret, LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("LocalTypeDirectiveSeq");

llstate_0 = *llin;
#undef failed
#define failed failed1
{LLSTATE llstate_1;XDirectives llatt_1;
if (!ll_LocalTypeDirective(&llatt_1, &llstate_0, &llstate_1)) goto failed1;
{LLSTATE llstate_2;XDirectives llatt_2;
if (!ll_LocalTypeDirectiveESeq(&llatt_2, &llstate_1, &llstate_2)) goto failed1;
*llout = llstate_2;
{if (llatt_2) {
		(*llret) = DupDirective(llatt_1);
		(*llret)->Next = llatt_2;
	    } else {
		(*llret) = llatt_1;
	    }
	
}}}
LLDEBUG_LEAVE("LocalTypeDirectiveSeq", 1);
return 1;
failed1: LLDEBUG_LEAVE("LocalTypeDirectiveSeq", 0);
return 0;
}

int ll_LocalTypeDirectiveESeq(XDirectives *llret, LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("LocalTypeDirectiveESeq");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("LocalTypeDirectiveESeq", 1);
{LLSTATE llstate_1;XDirectives llatt_1;
if (!ll_LocalTypeDirective(&llatt_1, &llstate_0, &llstate_1)) goto failed2;
{LLSTATE llstate_2;XDirectives llatt_2;
if (!ll_LocalTypeDirectiveESeq(&llatt_2, &llstate_1, &llstate_2)) goto failed2;
*llout = llstate_2;
{if (llatt_2) {
		(*llret) = DupDirective(llatt_1);
		(*llret)->Next = llatt_2;
	    } else {
		(*llret) = llatt_1;
	    }
	
break;
}}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("LocalTypeDirectiveESeq", 2);
*llout = llstate_0;
{(*llret) = NULL;
	
break;
}
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("LocalTypeDirectiveESeq");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("LocalTypeDirectiveESeq", 1);
return 1;
failed1: LLDEBUG_LEAVE("LocalTypeDirectiveESeq", 0);
return 0;
}

int ll_LocalTypeDirective(XDirectives *llret, LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("LocalTypeDirective");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("LocalTypeDirective", 1);
{LLSTATE llstate_1;
if (!llterm(T_ZERO_TERMINATED, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = NewDirective(eDirective_ZeroTerminated);
	
break;
}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("LocalTypeDirective", 2);
{LLSTATE llstate_1;
if (!llterm(T_POINTER, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = NewDirective(eDirective_Pointer);
	
break;
}}
case 3: case -3:
LLDEBUG_ALTERNATIVE("LocalTypeDirective", 3);
{LLSTATE llstate_1;
if (!llterm(T_NO_POINTER, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = NewDirective(eDirective_NoPointer);
	
break;
}}
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("LocalTypeDirective");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("LocalTypeDirective", 1);
return 1;
failed1: LLDEBUG_LEAVE("LocalTypeDirective", 0);
return 0;
}

int ll_LocalSizeDirectiveSeq(XDirectives *llret, LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("LocalSizeDirectiveSeq");

llstate_0 = *llin;
#undef failed
#define failed failed1
{LLSTATE llstate_1;XDirectives llatt_1;
if (!ll_LocalSizeDirective(&llatt_1, &llstate_0, &llstate_1)) goto failed1;
{LLSTATE llstate_2;XDirectives llatt_2;
if (!ll_LocalSizeDirectiveESeq(&llatt_2, &llstate_1, &llstate_2)) goto failed1;
*llout = llstate_2;
{if (llatt_2) {
		(*llret) = DupDirective(llatt_1);
		(*llret)->Next = llatt_2;
	    } else {
		(*llret) = llatt_1;
	    }
	
}}}
LLDEBUG_LEAVE("LocalSizeDirectiveSeq", 1);
return 1;
failed1: LLDEBUG_LEAVE("LocalSizeDirectiveSeq", 0);
return 0;
}

int ll_LocalSizeDirectiveESeq(XDirectives *llret, LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("LocalSizeDirectiveESeq");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("LocalSizeDirectiveESeq", 1);
{LLSTATE llstate_1;XDirectives llatt_1;
if (!ll_LocalSizeDirective(&llatt_1, &llstate_0, &llstate_1)) goto failed2;
{LLSTATE llstate_2;XDirectives llatt_2;
if (!ll_LocalSizeDirectiveESeq(&llatt_2, &llstate_1, &llstate_2)) goto failed2;
*llout = llstate_2;
{if (llatt_2) {
		(*llret) = DupDirective(llatt_1);
		(*llret)->Next = llatt_2;
	    } else {
		(*llret) = llatt_1;
	    }
	
break;
}}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("LocalSizeDirectiveESeq", 2);
*llout = llstate_0;
{(*llret) = NULL;
	
break;
}
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("LocalSizeDirectiveESeq");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("LocalSizeDirectiveESeq", 1);
return 1;
failed1: LLDEBUG_LEAVE("LocalSizeDirectiveESeq", 0);
return 0;
}

int ll_LocalSizeDirective(XDirectives *llret, LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("LocalSizeDirective");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("LocalSizeDirective", 1);
{LLSTATE llstate_1;
if (!llterm(T_FIXED_ARRAY, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = NewDirective(eDirective_FixedArray);
	
break;
}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("LocalSizeDirective", 2);
{LLSTATE llstate_1;
if (!llterm(T_DOUBLY_LINKED_LIST, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = NewDirective(eDirective_DoublyLinkedList);
	
break;
}}
case 3: case -3:
LLDEBUG_ALTERNATIVE("LocalSizeDirective", 3);
{LLSTATE llstate_1;
if (!llterm(T_SINGLY_LINKED_LIST, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = NewDirective(eDirective_SinglyLinkedList);
	
break;
}}
case 4: case -4:
LLDEBUG_ALTERNATIVE("LocalSizeDirective", 4);
{LLSTATE llstate_1;
if (!llterm(T_LENGTH_POINTER, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = NewDirective(eDirective_LengthPointer);
	
break;
}}
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("LocalSizeDirective");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("LocalSizeDirective", 1);
return 1;
failed1: LLDEBUG_LEAVE("LocalSizeDirective", 0);
return 0;
}

int ll_PrivateDir_Type(XString *llret, LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("PrivateDir_Type");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("PrivateDir_Type", 1);
{LLSTATE llstate_1;
if (!llterm(T_PrivateDir_TypeName, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
{LLSTATE llstate_2;XString llatt_2;
if (!llterm(T_lcsymbol, &lllval, &llstate_1, &llstate_2)) goto failed2;
llatt_2 = lllval._XString;
*llout = llstate_2;
{(*llret) = llatt_2;
	
break;
}}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("PrivateDir_Type", 2);
*llout = llstate_0;
{(*llret) = NULL;
	
break;
}
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("PrivateDir_Type");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("PrivateDir_Type", 1);
return 1;
failed1: LLDEBUG_LEAVE("PrivateDir_Type", 0);
return 0;
}

int ll_PrivateDir_Field(XString *llret, LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("PrivateDir_Field");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("PrivateDir_Field", 1);
{LLSTATE llstate_1;
if (!llterm(T_PrivateDir_FieldName, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
{LLSTATE llstate_2;XString llatt_2;
if (!llterm(T_lcsymbol, &lllval, &llstate_1, &llstate_2)) goto failed2;
llatt_2 = lllval._XString;
*llout = llstate_2;
{(*llret) = llatt_2;
	
break;
}}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("PrivateDir_Field", 2);
*llout = llstate_0;
{(*llret) = NULL;
	
break;
}
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("PrivateDir_Field");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("PrivateDir_Field", 1);
return 1;
failed1: LLDEBUG_LEAVE("PrivateDir_Field", 0);
return 0;
}

int ll_PrivateDir_Value(XString *llret, LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("PrivateDir_Value");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("PrivateDir_Value", 1);
{LLSTATE llstate_1;
if (!llterm(T_PrivateDir_ValueName, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
{LLSTATE llstate_2;XString llatt_2;
if (!llterm(T_lcsymbol, &lllval, &llstate_1, &llstate_2)) goto failed2;
llatt_2 = lllval._XString;
*llout = llstate_2;
{(*llret) = llatt_2;
	
break;
}}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("PrivateDir_Value", 2);
*llout = llstate_0;
{(*llret) = NULL;
	
break;
}
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("PrivateDir_Value");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("PrivateDir_Value", 1);
return 1;
failed1: LLDEBUG_LEAVE("PrivateDir_Value", 0);
return 0;
}

int ll_PrivateDir_Public(int *llret, LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("PrivateDir_Public");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("PrivateDir_Public", 1);
{LLSTATE llstate_1;
if (!llterm(T_PrivateDir_Public, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = 1;
	
break;
}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("PrivateDir_Public", 2);
*llout = llstate_0;
{(*llret) = 0;
	
break;
}
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("PrivateDir_Public");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("PrivateDir_Public", 1);
return 1;
failed1: LLDEBUG_LEAVE("PrivateDir_Public", 0);
return 0;
}

int ll_PrivateDir_Intx(int *llret, LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("PrivateDir_Intx");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("PrivateDir_Intx", 1);
{LLSTATE llstate_1;
if (!llterm(T_PrivateDir_Intx, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = 1;
	
break;
}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("PrivateDir_Intx", 2);
*llout = llstate_0;
{(*llret) = 0;
	
break;
}
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("PrivateDir_Intx");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("PrivateDir_Intx", 1);
return 1;
failed1: LLDEBUG_LEAVE("PrivateDir_Intx", 0);
return 0;
}

int ll_PrivateDir_LenPtr(int *llret, LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("PrivateDir_LenPtr");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("PrivateDir_LenPtr", 1);
{LLSTATE llstate_1;
if (!llterm(T_PrivateDir_LenPtr, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = 1;
	
break;
}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("PrivateDir_LenPtr", 2);
*llout = llstate_0;
{(*llret) = 0;
	
break;
}
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("PrivateDir_LenPtr");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("PrivateDir_LenPtr", 1);
return 1;
failed1: LLDEBUG_LEAVE("PrivateDir_LenPtr", 0);
return 0;
}

int ll_PrivateDir_Pointer(int *llret, LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("PrivateDir_Pointer");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("PrivateDir_Pointer", 1);
{LLSTATE llstate_1;
if (!llterm(T_PrivateDir_Pointer, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = 1;
	
break;
}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("PrivateDir_Pointer", 2);
*llout = llstate_0;
{(*llret) = 0;
	
break;
}
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("PrivateDir_Pointer");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("PrivateDir_Pointer", 1);
return 1;
failed1: LLDEBUG_LEAVE("PrivateDir_Pointer", 0);
return 0;
}

int ll_PrivateDir_Array(int *llret, LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("PrivateDir_Array");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("PrivateDir_Array", 1);
{LLSTATE llstate_1;
if (!llterm(T_PrivateDir_Array, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = 1;
	
break;
}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("PrivateDir_Array", 2);
*llout = llstate_0;
{(*llret) = 0;
	
break;
}
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("PrivateDir_Array");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("PrivateDir_Array", 1);
return 1;
failed1: LLDEBUG_LEAVE("PrivateDir_Array", 0);
return 0;
}

int ll_PrivateDir_NoCode(int *llret, LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("PrivateDir_NoCode");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("PrivateDir_NoCode", 1);
{LLSTATE llstate_1;
if (!llterm(T_PrivateDir_NoCode, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = 1;
	
break;
}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("PrivateDir_NoCode", 2);
*llout = llstate_0;
{(*llret) = 0;
	
break;
}
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("PrivateDir_NoCode");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("PrivateDir_NoCode", 1);
return 1;
failed1: LLDEBUG_LEAVE("PrivateDir_NoCode", 0);
return 0;
}

int ll_PrivateDir_NoMemCopy(int *llret, LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("PrivateDir_NoMemCopy");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("PrivateDir_NoMemCopy", 1);
{LLSTATE llstate_1;
if (!llterm(T_PrivateDir_NoMemCopy, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = 1;
	
break;
}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("PrivateDir_NoMemCopy", 2);
*llout = llstate_0;
{(*llret) = 0;
	
break;
}
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("PrivateDir_NoMemCopy");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("PrivateDir_NoMemCopy", 1);
return 1;
failed1: LLDEBUG_LEAVE("PrivateDir_NoMemCopy", 0);
return 0;
}

int ll_PrivateDir_OidPacked(int *llret, LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("PrivateDir_OidPacked");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("PrivateDir_OidPacked", 1);
{LLSTATE llstate_1;
if (!llterm(T_PrivateDir_OidPacked, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = 1;
	
break;
}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("PrivateDir_OidPacked", 2);
*llout = llstate_0;
{(*llret) = 0;
	
break;
}
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("PrivateDir_OidPacked");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("PrivateDir_OidPacked", 1);
return 1;
failed1: LLDEBUG_LEAVE("PrivateDir_OidPacked", 0);
return 0;
}

int ll_PrivateDir_OidArray(int *llret, LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("PrivateDir_OidArray");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("PrivateDir_OidArray", 1);
{LLSTATE llstate_1;
if (!llterm(T_PrivateDir_OidArray, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = 1;
	
break;
}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("PrivateDir_OidArray", 2);
*llout = llstate_0;
{(*llret) = 0;
	
break;
}
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("PrivateDir_OidArray");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("PrivateDir_OidArray", 1);
return 1;
failed1: LLDEBUG_LEAVE("PrivateDir_OidArray", 0);
return 0;
}

int ll_PrivateDir_SLinked(int *llret, LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("PrivateDir_SLinked");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("PrivateDir_SLinked", 1);
{LLSTATE llstate_1;
if (!llterm(T_PrivateDir_SLinked, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = 1;
	
break;
}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("PrivateDir_SLinked", 2);
*llout = llstate_0;
{(*llret) = 0;
	
break;
}
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("PrivateDir_SLinked");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("PrivateDir_SLinked", 1);
return 1;
failed1: LLDEBUG_LEAVE("PrivateDir_SLinked", 0);
return 0;
}

int ll_PrivateDir_DLinked(int *llret, LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("PrivateDir_DLinked");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("PrivateDir_DLinked", 1);
{LLSTATE llstate_1;
if (!llterm(T_PrivateDir_DLinked, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = 1;
	
break;
}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("PrivateDir_DLinked", 2);
*llout = llstate_0;
{(*llret) = 0;
	
break;
}
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("PrivateDir_DLinked");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("PrivateDir_DLinked", 1);
return 1;
failed1: LLDEBUG_LEAVE("PrivateDir_DLinked", 0);
return 0;
}

int ll_PrivateDirectives(XPrivateDirectives *llret, LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("PrivateDirectives");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("PrivateDirectives", 1);
{LLSTATE llstate_1;int llatt_1;
if (!ll_PrivateDir_Intx(&llatt_1, &llstate_0, &llstate_1)) goto failed2;
{LLSTATE llstate_2;int llatt_2;
if (!ll_PrivateDir_LenPtr(&llatt_2, &llstate_1, &llstate_2)) goto failed2;
{LLSTATE llstate_3;int llatt_3;
if (!ll_PrivateDir_Pointer(&llatt_3, &llstate_2, &llstate_3)) goto failed2;
{LLSTATE llstate_4;int llatt_4;
if (!ll_PrivateDir_Array(&llatt_4, &llstate_3, &llstate_4)) goto failed2;
{LLSTATE llstate_5;int llatt_5;
if (!ll_PrivateDir_NoCode(&llatt_5, &llstate_4, &llstate_5)) goto failed2;
{LLSTATE llstate_6;int llatt_6;
if (!ll_PrivateDir_NoMemCopy(&llatt_6, &llstate_5, &llstate_6)) goto failed2;
{LLSTATE llstate_7;int llatt_7;
if (!ll_PrivateDir_Public(&llatt_7, &llstate_6, &llstate_7)) goto failed2;
{LLSTATE llstate_8;int llatt_8;
if (!ll_PrivateDir_OidPacked(&llatt_8, &llstate_7, &llstate_8)) goto failed2;
{LLSTATE llstate_9;int llatt_9;
if (!ll_PrivateDir_OidArray(&llatt_9, &llstate_8, &llstate_9)) goto failed2;
{LLSTATE llstate_10;XString llatt_10;
if (!ll_PrivateDir_Type(&llatt_10, &llstate_9, &llstate_10)) goto failed2;
{LLSTATE llstate_11;XString llatt_11;
if (!ll_PrivateDir_Field(&llatt_11, &llstate_10, &llstate_11)) goto failed2;
{LLSTATE llstate_12;XString llatt_12;
if (!ll_PrivateDir_Value(&llatt_12, &llstate_11, &llstate_12)) goto failed2;
{LLSTATE llstate_13;int llatt_13;
if (!ll_PrivateDir_SLinked(&llatt_13, &llstate_12, &llstate_13)) goto failed2;
{LLSTATE llstate_14;int llatt_14;
if (!ll_PrivateDir_DLinked(&llatt_14, &llstate_13, &llstate_14)) goto failed2;
*llout = llstate_14;
{(*llret) = (PrivateDirectives_t *) malloc(sizeof(PrivateDirectives_t));
	    if ((*llret))
	    {
	    	memset((*llret), 0, sizeof(PrivateDirectives_t));
		(*llret)->fIntx = llatt_1;
		(*llret)->fLenPtr = llatt_2;
		(*llret)->fPointer = llatt_3;
   		(*llret)->fArray = llatt_4;
		(*llret)->fNoCode = llatt_5;
		(*llret)->fNoMemCopy = llatt_6;
		(*llret)->fPublic = llatt_7;
		(*llret)->fOidPacked = llatt_8;
		(*llret)->fOidArray = llatt_9 | g_fOidArray;
   		(*llret)->pszTypeName = llatt_10;
   		(*llret)->pszFieldName = llatt_11;
   		(*llret)->pszValueName = llatt_12;
   		(*llret)->fSLinked = llatt_13;
   		(*llret)->fDLinked = llatt_14;
	    }
	
break;
}}}}}}}}}}}}}}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("PrivateDirectives", 2);
*llout = llstate_0;
{(*llret) = NULL;
	
break;
}
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("PrivateDirectives");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("PrivateDirectives", 1);
return 1;
failed1: LLDEBUG_LEAVE("PrivateDirectives", 0);
return 0;
}

int ll_DefinedObjectClass(XObjectClass *llret, LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("DefinedObjectClass");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("DefinedObjectClass", 1);
{LLSTATE llstate_1;XObjectClass llatt_1;
if (!ll_ExternalObjectClassReference(&llatt_1, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = llatt_1;
	
break;
}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("DefinedObjectClass", 2);
{LLSTATE llstate_1;XObjectClass llatt_1;
if (!ll_objectclassreference(&llatt_1, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = llatt_1;
	
break;
}}
case 3: case -3:
LLDEBUG_ALTERNATIVE("DefinedObjectClass", 3);
{LLSTATE llstate_1;XObjectClass llatt_1;
if (!ll_Usefulobjectclassreference(&llatt_1, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = llatt_1;
	
break;
}}
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("DefinedObjectClass");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("DefinedObjectClass", 1);
return 1;
failed1: LLDEBUG_LEAVE("DefinedObjectClass", 0);
return 0;
}

int ll_DefinedObject(XObject *llret, LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("DefinedObject");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("DefinedObject", 1);
{LLSTATE llstate_1;XObject llatt_1;
if (!ll_ExternalObjectReference(&llatt_1, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = llatt_1;
	
break;
}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("DefinedObject", 2);
{LLSTATE llstate_1;XObject llatt_1;
if (!ll_objectreference(&llatt_1, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = llatt_1;
	
break;
}}
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("DefinedObject");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("DefinedObject", 1);
return 1;
failed1: LLDEBUG_LEAVE("DefinedObject", 0);
return 0;
}

int ll_DefinedObjectSet(XObjectSet *llret, LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("DefinedObjectSet");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("DefinedObjectSet", 1);
{LLSTATE llstate_1;XObjectSet llatt_1;
if (!ll_ExternalObjectSetReference(&llatt_1, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = llatt_1;
	
break;
}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("DefinedObjectSet", 2);
{LLSTATE llstate_1;XObjectSet llatt_1;
if (!ll_objectsetreference(&llatt_1, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = llatt_1;
	
break;
}}
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("DefinedObjectSet");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("DefinedObjectSet", 1);
return 1;
failed1: LLDEBUG_LEAVE("DefinedObjectSet", 0);
return 0;
}

int ll_Usefulobjectclassreference(XObjectClass *llret, LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("Usefulobjectclassreference");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("Usefulobjectclassreference", 1);
{LLSTATE llstate_1;
if (!llterm(T_TYPE_IDENTIFIER, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = Builtin_ObjectClass_TypeIdentifier;
	
break;
}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("Usefulobjectclassreference", 2);
{LLSTATE llstate_1;
if (!llterm(T_ABSTRACT_SYNTAX, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = Builtin_ObjectClass_AbstractSyntax;
	
break;
}}
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("Usefulobjectclassreference");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("Usefulobjectclassreference", 1);
return 1;
failed1: LLDEBUG_LEAVE("Usefulobjectclassreference", 0);
return 0;
}

int ll_ObjectClassAssignment(LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("ObjectClassAssignment");

llstate_0 = *llin;
#undef failed
#define failed failed1
{LLSTATE llstate_1;XObjectClass llatt_1;
if (!ll_objectclassreference(&llatt_1, &llstate_0, &llstate_1)) goto failed1;
{LLSTATE llstate_2;
if (!llterm(T_DEF, (LLSTYPE *)0, &llstate_1, &llstate_2)) goto failed1;
{LLSTATE llstate_3;XObjectClass llatt_3;
if (!ll_ObjectClass(&llatt_3, &llstate_2, &llstate_3, llatt_1)) goto failed1;
*llout = llstate_3;
{if (!AssignObjectClass(&(*llout).Assignments, llatt_1, llatt_3))
		LLFAILED((&llstate_1.pos, "Type `%s' twice defined",
		    llatt_1->U.Reference.Identifier));
	
}}}}
LLDEBUG_LEAVE("ObjectClassAssignment", 1);
return 1;
failed1: LLDEBUG_LEAVE("ObjectClassAssignment", 0);
return 0;
}

int ll_ObjectClass(XObjectClass *llret, LLSTATE *llin, LLSTATE *llout, XObjectClass llarg_oc)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("ObjectClass");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("ObjectClass", 1);
{LLSTATE llstate_1;XObjectClass llatt_1;
if (!ll_DefinedObjectClass(&llatt_1, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = llatt_1;
	
break;
}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("ObjectClass", 2);
{LLSTATE llstate_1;XObjectClass llatt_1;
if (!ll_ObjectClassDefn(&llatt_1, &llstate_0, &llstate_1, llarg_oc)) goto failed2;
*llout = llstate_1;
{(*llret) = llatt_1;
	
break;
}}
case 3: case -3:
LLDEBUG_ALTERNATIVE("ObjectClass", 3);
{LLSTATE llstate_1;
if (!ll_ParameterizedObjectClass(&llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{MyAbort();
	
break;
}}
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("ObjectClass");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("ObjectClass", 1);
return 1;
failed1: LLDEBUG_LEAVE("ObjectClass", 0);
return 0;
}

int ll_ObjectClassDefn(XObjectClass *llret, LLSTATE *llin, LLSTATE *llout, XObjectClass llarg_oc)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("ObjectClassDefn");

llstate_0 = *llin;
#undef failed
#define failed failed1
{LLSTATE llstate_1;
if (!llterm(T_CLASS, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed1;
{LLSTATE llstate_2;
if (!llterm('{', (LLSTYPE *)0, &llstate_1, &llstate_2)) goto failed1;
{LLSTATE llstate_3;XFieldSpecs llatt_3;
if (!ll_FieldSpec_List(&llatt_3, &llstate_2, &llstate_3, llarg_oc)) goto failed1;
{LLSTATE llstate_4;
if (!llterm('}', (LLSTYPE *)0, &llstate_3, &llstate_4)) goto failed1;
{LLSTATE llstate_5;XSyntaxSpecs llatt_5;
if (!ll_WithSyntaxSpec_opt(&llatt_5, &llstate_4, &llstate_5, llarg_oc)) goto failed1;
*llout = llstate_5;
{ObjectClass_t *oc;
	    oc = NewObjectClass(eObjectClass_ObjectClass);
	    oc->U.ObjectClass.FieldSpec = llatt_3;
	    oc->U.ObjectClass.SyntaxSpec = llatt_5;
	    (*llret) = oc;
	
}}}}}}
LLDEBUG_LEAVE("ObjectClassDefn", 1);
return 1;
failed1: LLDEBUG_LEAVE("ObjectClassDefn", 0);
return 0;
}

int ll_FieldSpec_List(XFieldSpecs *llret, LLSTATE *llin, LLSTATE *llout, XObjectClass llarg_oc)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("FieldSpec_List");

llstate_0 = *llin;
#undef failed
#define failed failed1
{LLSTATE llstate_1;XFieldSpecs llatt_1;
if (!ll_FieldSpec(&llatt_1, &llstate_0, &llstate_1, llarg_oc)) goto failed1;
{LLSTATE llstate_2;XFieldSpecs llatt_2;
if (!ll_FieldSpec_EList(&llatt_2, &llstate_1, &llstate_2, llarg_oc)) goto failed1;
*llout = llstate_2;
{if (llatt_1) {
		if (llatt_2) {
		    (*llret) = DupFieldSpec(llatt_1);
		    (*llret)->Next = llatt_2;
		} else {
		    (*llret) = llatt_1;
		}
	    } else {
		(*llret) = llatt_2;
	    }
	
}}}
LLDEBUG_LEAVE("FieldSpec_List", 1);
return 1;
failed1: LLDEBUG_LEAVE("FieldSpec_List", 0);
return 0;
}

int ll_FieldSpec_EList(XFieldSpecs *llret, LLSTATE *llin, LLSTATE *llout, XObjectClass llarg_oc)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("FieldSpec_EList");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("FieldSpec_EList", 1);
{LLSTATE llstate_1;
if (!llterm(',', (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
{LLSTATE llstate_2;XFieldSpecs llatt_2;
if (!ll_FieldSpec(&llatt_2, &llstate_1, &llstate_2, llarg_oc)) goto failed2;
{LLSTATE llstate_3;XFieldSpecs llatt_3;
if (!ll_FieldSpec_EList(&llatt_3, &llstate_2, &llstate_3, llarg_oc)) goto failed2;
*llout = llstate_3;
{if (llatt_2) {
		if (llatt_3) {
		    (*llret) = DupFieldSpec(llatt_2);
		    (*llret)->Next = llatt_3;
		} else {
		    (*llret) = llatt_2;
		}
	    } else {
		(*llret) = llatt_3;
	    }
	
break;
}}}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("FieldSpec_EList", 2);
*llout = llstate_0;
{(*llret) = NULL;
	
break;
}
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("FieldSpec_EList");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("FieldSpec_EList", 1);
return 1;
failed1: LLDEBUG_LEAVE("FieldSpec_EList", 0);
return 0;
}

int ll_WithSyntaxSpec_opt(XSyntaxSpecs *llret, LLSTATE *llin, LLSTATE *llout, XObjectClass llarg_oc)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("WithSyntaxSpec_opt");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("WithSyntaxSpec_opt", 1);
{LLSTATE llstate_1;
if (!llterm(T_WITH, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
{LLSTATE llstate_2;
if (!llterm(T_SYNTAX, (LLSTYPE *)0, &llstate_1, &llstate_2)) goto failed2;
{LLSTATE llstate_3;XSyntaxSpecs llatt_3;
if (!ll_SyntaxList(&llatt_3, &llstate_2, &llstate_3, llarg_oc)) goto failed2;
*llout = llstate_3;
{(*llret) = llatt_3;
	
break;
}}}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("WithSyntaxSpec_opt", 2);
*llout = llstate_0;
{(*llret) = NULL;
	
break;
}
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("WithSyntaxSpec_opt");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("WithSyntaxSpec_opt", 1);
return 1;
failed1: LLDEBUG_LEAVE("WithSyntaxSpec_opt", 0);
return 0;
}

int ll_FieldSpec(XFieldSpecs *llret, LLSTATE *llin, LLSTATE *llout, XObjectClass llarg_oc)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("FieldSpec");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("FieldSpec", 1);
{LLSTATE llstate_1;XFieldSpecs llatt_1;
if (!ll_TypeFieldSpec(&llatt_1, &llstate_0, &llstate_1, llarg_oc)) goto failed2;
*llout = llstate_1;
{(*llret) = llatt_1;
	
break;
}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("FieldSpec", 2);
{LLSTATE llstate_1;XFieldSpecs llatt_1;
if (!ll_FixedTypeValueFieldSpec(&llatt_1, &llstate_0, &llstate_1, llarg_oc)) goto failed2;
*llout = llstate_1;
{(*llret) = llatt_1;
	
break;
}}
case 3: case -3:
LLDEBUG_ALTERNATIVE("FieldSpec", 3);
{LLSTATE llstate_1;XFieldSpecs llatt_1;
if (!ll_VariableTypeValueFieldSpec(&llatt_1, &llstate_0, &llstate_1, llarg_oc)) goto failed2;
*llout = llstate_1;
{(*llret) = llatt_1;
	
break;
}}
case 4: case -4:
LLDEBUG_ALTERNATIVE("FieldSpec", 4);
{LLSTATE llstate_1;XFieldSpecs llatt_1;
if (!ll_FixedTypeValueSetFieldSpec(&llatt_1, &llstate_0, &llstate_1, llarg_oc)) goto failed2;
*llout = llstate_1;
{(*llret) = llatt_1;
	
break;
}}
case 5: case -5:
LLDEBUG_ALTERNATIVE("FieldSpec", 5);
{LLSTATE llstate_1;XFieldSpecs llatt_1;
if (!ll_VariableTypeValueSetFieldSpec(&llatt_1, &llstate_0, &llstate_1, llarg_oc)) goto failed2;
*llout = llstate_1;
{(*llret) = llatt_1;
	
break;
}}
case 6: case -6:
LLDEBUG_ALTERNATIVE("FieldSpec", 6);
{LLSTATE llstate_1;XFieldSpecs llatt_1;
if (!ll_ObjectFieldSpec(&llatt_1, &llstate_0, &llstate_1, llarg_oc)) goto failed2;
*llout = llstate_1;
{(*llret) = llatt_1;
	
break;
}}
case 7: case -7:
LLDEBUG_ALTERNATIVE("FieldSpec", 7);
{LLSTATE llstate_1;XFieldSpecs llatt_1;
if (!ll_ObjectSetFieldSpec(&llatt_1, &llstate_0, &llstate_1, llarg_oc)) goto failed2;
*llout = llstate_1;
{(*llret) = llatt_1;
	
break;
}}
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("FieldSpec");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("FieldSpec", 1);
return 1;
failed1: LLDEBUG_LEAVE("FieldSpec", 0);
return 0;
}

int ll_TypeFieldSpec(XFieldSpecs *llret, LLSTATE *llin, LLSTATE *llout, XObjectClass llarg_oc)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("TypeFieldSpec");

llstate_0 = *llin;
#undef failed
#define failed failed1
{LLSTATE llstate_1;XString llatt_1;
if (!ll_typefieldreference(&llatt_1, &llstate_0, &llstate_1, llarg_oc)) goto failed1;
{LLSTATE llstate_2;XOptionality llatt_2;
if (!ll_TypeOptionalitySpec_opt(&llatt_2, &llstate_1, &llstate_2)) goto failed1;
*llout = llstate_2;
{(*llret) = NewFieldSpec(eFieldSpec_Type);
	    (*llret)->Identifier = llatt_1;
	    (*llret)->U.Type.Optionality = llatt_2;
	
}}}
LLDEBUG_LEAVE("TypeFieldSpec", 1);
return 1;
failed1: LLDEBUG_LEAVE("TypeFieldSpec", 0);
return 0;
}

int ll_TypeOptionalitySpec_opt(XOptionality *llret, LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("TypeOptionalitySpec_opt");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("TypeOptionalitySpec_opt", 1);
{LLSTATE llstate_1;
if (!llterm(T_OPTIONAL, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = NewOptionality(eOptionality_Optional);
	
break;
}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("TypeOptionalitySpec_opt", 2);
{LLSTATE llstate_1;
if (!llterm(T_DEFAULT, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
{LLSTATE llstate_2;XType llatt_2;
if (!ll_Type(&llatt_2, &llstate_1, &llstate_2)) goto failed2;
*llout = llstate_2;
{(*llret) = NewOptionality(eOptionality_Default_Type);
	    (*llret)->U.Type = llatt_2;
	
break;
}}}
case 3: case -3:
LLDEBUG_ALTERNATIVE("TypeOptionalitySpec_opt", 3);
*llout = llstate_0;
{(*llret) = NewOptionality(eOptionality_Normal);
	
break;
}
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("TypeOptionalitySpec_opt");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("TypeOptionalitySpec_opt", 1);
return 1;
failed1: LLDEBUG_LEAVE("TypeOptionalitySpec_opt", 0);
return 0;
}

int ll_FixedTypeValueFieldSpec(XFieldSpecs *llret, LLSTATE *llin, LLSTATE *llout, XObjectClass llarg_oc)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("FixedTypeValueFieldSpec");

llstate_0 = *llin;
#undef failed
#define failed failed1
{LLSTATE llstate_1;XString llatt_1;
if (!ll_valuefieldreference(&llatt_1, &llstate_0, &llstate_1, llarg_oc)) goto failed1;
{LLSTATE llstate_2;XType llatt_2;
if (!ll_Type(&llatt_2, &llstate_1, &llstate_2)) goto failed1;
{LLSTATE llstate_3;XBoolean llatt_3;
if (!ll_UNIQUE_opt(&llatt_3, &llstate_2, &llstate_3)) goto failed1;
{LLSTATE llstate_4;XOptionality llatt_4;
if (!ll_ValueOptionalitySpec_opt(&llatt_4, &llstate_3, &llstate_4, llatt_2)) goto failed1;
*llout = llstate_4;
{if (GetType((*llout).Assignments, llatt_2)) {
		(*llret) = NewFieldSpec(eFieldSpec_FixedTypeValue);
		(*llret)->Identifier = llatt_1;
		(*llret)->U.FixedTypeValue.Type = llatt_2;
		(*llret)->U.FixedTypeValue.Unique = llatt_3;
		(*llret)->U.FixedTypeValue.Optionality = llatt_4;
	    } else {
		(*llret) = NULL;
	    }
	
}}}}}
LLDEBUG_LEAVE("FixedTypeValueFieldSpec", 1);
return 1;
failed1: LLDEBUG_LEAVE("FixedTypeValueFieldSpec", 0);
return 0;
}

int ll_UNIQUE_opt(XBoolean *llret, LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("UNIQUE_opt");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("UNIQUE_opt", 1);
{LLSTATE llstate_1;
if (!llterm(T_UNIQUE, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = 1;
	
break;
}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("UNIQUE_opt", 2);
*llout = llstate_0;
{(*llret) = 0;
	
break;
}
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("UNIQUE_opt");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("UNIQUE_opt", 1);
return 1;
failed1: LLDEBUG_LEAVE("UNIQUE_opt", 0);
return 0;
}

int ll_ValueOptionalitySpec_opt(XOptionality *llret, LLSTATE *llin, LLSTATE *llout, XType llarg_type)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("ValueOptionalitySpec_opt");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("ValueOptionalitySpec_opt", 1);
{LLSTATE llstate_1;
if (!llterm(T_OPTIONAL, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = NewOptionality(eOptionality_Optional);
	
break;
}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("ValueOptionalitySpec_opt", 2);
{LLSTATE llstate_1;
if (!llterm(T_DEFAULT, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
{LLSTATE llstate_2;XValue llatt_2;
if (!ll_Value(&llatt_2, &llstate_1, &llstate_2, llarg_type)) goto failed2;
*llout = llstate_2;
{(*llret) = NewOptionality(eOptionality_Default_Value);
	    (*llret)->U.Value = llatt_2;
	
break;
}}}
case 3: case -3:
LLDEBUG_ALTERNATIVE("ValueOptionalitySpec_opt", 3);
*llout = llstate_0;
{(*llret) = NewOptionality(eOptionality_Normal);
	
break;
}
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("ValueOptionalitySpec_opt");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("ValueOptionalitySpec_opt", 1);
return 1;
failed1: LLDEBUG_LEAVE("ValueOptionalitySpec_opt", 0);
return 0;
}

int ll_VariableTypeValueFieldSpec(XFieldSpecs *llret, LLSTATE *llin, LLSTATE *llout, XObjectClass llarg_oc)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("VariableTypeValueFieldSpec");

llstate_0 = *llin;
#undef failed
#define failed failed1
{LLSTATE llstate_1;XString llatt_1;
if (!ll_valuefieldreference(&llatt_1, &llstate_0, &llstate_1, llarg_oc)) goto failed1;
{LLSTATE llstate_2;XStrings llatt_2;
if (!ll_FieldName(&llatt_2, &llstate_1, &llstate_2, llarg_oc)) goto failed1;
{Type_t *deftype;
	    FieldSpec_t *fs, *deffs;
	    fs = GetFieldSpecFromObjectClass(llstate_2.Assignments, llarg_oc, llatt_2);
	    deffs = GetFieldSpec(llstate_2.Assignments, fs);
	    if (deffs &&
		deffs->Type == eFieldSpec_Type &&
		deffs->U.Type.Optionality->Type == eOptionality_Default_Type)
		deftype = deffs->U.Type.Optionality->U.Type;
	    else
		deftype = NULL;
	
{LLSTATE llstate_3;XOptionality llatt_3;
if (!ll_ValueOptionalitySpec_opt(&llatt_3, &llstate_2, &llstate_3, deftype)) goto failed1;
*llout = llstate_3;
{(*llret) = NewFieldSpec(eFieldSpec_VariableTypeValue);
	    (*llret)->Identifier = llatt_1;
	    (*llret)->U.VariableTypeValue.Fields = llatt_2;
	    (*llret)->U.VariableTypeValue.Optionality = llatt_3;
	
}}}}}
LLDEBUG_LEAVE("VariableTypeValueFieldSpec", 1);
return 1;
failed1: LLDEBUG_LEAVE("VariableTypeValueFieldSpec", 0);
return 0;
}

int ll_FixedTypeValueSetFieldSpec(XFieldSpecs *llret, LLSTATE *llin, LLSTATE *llout, XObjectClass llarg_oc)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("FixedTypeValueSetFieldSpec");

llstate_0 = *llin;
#undef failed
#define failed failed1
{LLSTATE llstate_1;XString llatt_1;
if (!ll_valuesetfieldreference(&llatt_1, &llstate_0, &llstate_1, llarg_oc)) goto failed1;
{LLSTATE llstate_2;XType llatt_2;
if (!ll_Type(&llatt_2, &llstate_1, &llstate_2)) goto failed1;
{LLSTATE llstate_3;XOptionality llatt_3;
if (!ll_ValueSetOptionalitySpec_opt(&llatt_3, &llstate_2, &llstate_3, llatt_2)) goto failed1;
*llout = llstate_3;
{if (GetType((*llout).Assignments, llatt_2)) {
		(*llret) = NewFieldSpec(eFieldSpec_FixedTypeValueSet);
		(*llret)->Identifier = llatt_1;
		(*llret)->U.FixedTypeValueSet.Type = llatt_2;
		(*llret)->U.FixedTypeValueSet.Optionality = llatt_3;
	    } else {
		(*llret) = NULL;
	    }
	
}}}}
LLDEBUG_LEAVE("FixedTypeValueSetFieldSpec", 1);
return 1;
failed1: LLDEBUG_LEAVE("FixedTypeValueSetFieldSpec", 0);
return 0;
}

int ll_ValueSetOptionalitySpec_opt(XOptionality *llret, LLSTATE *llin, LLSTATE *llout, XType llarg_type)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("ValueSetOptionalitySpec_opt");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("ValueSetOptionalitySpec_opt", 1);
{LLSTATE llstate_1;
if (!llterm(T_OPTIONAL, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = NewOptionality(eOptionality_Optional);
	
break;
}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("ValueSetOptionalitySpec_opt", 2);
{LLSTATE llstate_1;
if (!llterm(T_DEFAULT, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
{LLSTATE llstate_2;XValueSet llatt_2;
if (!ll_ValueSet(&llatt_2, &llstate_1, &llstate_2, llarg_type)) goto failed2;
*llout = llstate_2;
{(*llret) = NewOptionality(eOptionality_Default_ValueSet);
	    (*llret)->U.ValueSet = llatt_2;
	
break;
}}}
case 3: case -3:
LLDEBUG_ALTERNATIVE("ValueSetOptionalitySpec_opt", 3);
*llout = llstate_0;
{(*llret) = NewOptionality(eOptionality_Normal);
	
break;
}
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("ValueSetOptionalitySpec_opt");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("ValueSetOptionalitySpec_opt", 1);
return 1;
failed1: LLDEBUG_LEAVE("ValueSetOptionalitySpec_opt", 0);
return 0;
}

int ll_VariableTypeValueSetFieldSpec(XFieldSpecs *llret, LLSTATE *llin, LLSTATE *llout, XObjectClass llarg_oc)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("VariableTypeValueSetFieldSpec");

llstate_0 = *llin;
#undef failed
#define failed failed1
{LLSTATE llstate_1;XString llatt_1;
if (!ll_valuesetfieldreference(&llatt_1, &llstate_0, &llstate_1, llarg_oc)) goto failed1;
{LLSTATE llstate_2;XStrings llatt_2;
if (!ll_FieldName(&llatt_2, &llstate_1, &llstate_2, llarg_oc)) goto failed1;
{Type_t *deftype;
	    FieldSpec_t *fs, *deffs;
	    fs = GetFieldSpecFromObjectClass(llstate_2.Assignments, llarg_oc, llatt_2);
	    deffs = GetFieldSpec(llstate_2.Assignments, fs);
	    if (deffs &&
		deffs->Type == eFieldSpec_Type &&
		deffs->U.Type.Optionality->Type == eOptionality_Default_Type)
		deftype = deffs->U.Type.Optionality->U.Type;
	    else
		deftype = NULL;
	
{LLSTATE llstate_3;XOptionality llatt_3;
if (!ll_ValueSetOptionalitySpec_opt(&llatt_3, &llstate_2, &llstate_3, deftype)) goto failed1;
*llout = llstate_3;
{(*llret) = NewFieldSpec(eFieldSpec_VariableTypeValueSet);
	    (*llret)->Identifier = llatt_1;
	    (*llret)->U.VariableTypeValueSet.Fields = llatt_2;
	    (*llret)->U.VariableTypeValueSet.Optionality = llatt_3;
	
}}}}}
LLDEBUG_LEAVE("VariableTypeValueSetFieldSpec", 1);
return 1;
failed1: LLDEBUG_LEAVE("VariableTypeValueSetFieldSpec", 0);
return 0;
}

int ll_ObjectFieldSpec(XFieldSpecs *llret, LLSTATE *llin, LLSTATE *llout, XObjectClass llarg_oc)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("ObjectFieldSpec");

llstate_0 = *llin;
#undef failed
#define failed failed1
{LLSTATE llstate_1;XString llatt_1;
if (!ll_objectfieldreference(&llatt_1, &llstate_0, &llstate_1, llarg_oc)) goto failed1;
{LLSTATE llstate_2;XObjectClass llatt_2;
if (!ll_DefinedObjectClass(&llatt_2, &llstate_1, &llstate_2)) goto failed1;
{LLSTATE llstate_3;XOptionality llatt_3;
if (!ll_ObjectOptionalitySpec_opt(&llatt_3, &llstate_2, &llstate_3, llatt_2)) goto failed1;
*llout = llstate_3;
{if (GetObjectClass((*llout).Assignments, llatt_2)) {
		(*llret) = NewFieldSpec(eFieldSpec_Object);
		(*llret)->Identifier = llatt_1;
		(*llret)->U.Object.ObjectClass = llatt_2;
		(*llret)->U.Object.Optionality = llatt_3;
	    } else {
		(*llret) = NULL;
	    }
	
}}}}
LLDEBUG_LEAVE("ObjectFieldSpec", 1);
return 1;
failed1: LLDEBUG_LEAVE("ObjectFieldSpec", 0);
return 0;
}

int ll_ObjectOptionalitySpec_opt(XOptionality *llret, LLSTATE *llin, LLSTATE *llout, XObjectClass llarg_oc)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("ObjectOptionalitySpec_opt");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("ObjectOptionalitySpec_opt", 1);
{LLSTATE llstate_1;
if (!llterm(T_OPTIONAL, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = NewOptionality(eOptionality_Optional);
	
break;
}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("ObjectOptionalitySpec_opt", 2);
{LLSTATE llstate_1;
if (!llterm(T_DEFAULT, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
{LLSTATE llstate_2;XObject llatt_2;
if (!ll_Object(&llatt_2, &llstate_1, &llstate_2, llarg_oc)) goto failed2;
*llout = llstate_2;
{(*llret) = NewOptionality(eOptionality_Default_Object);
	    (*llret)->U.Object = llatt_2;
	
break;
}}}
case 3: case -3:
LLDEBUG_ALTERNATIVE("ObjectOptionalitySpec_opt", 3);
*llout = llstate_0;
{(*llret) = NewOptionality(eOptionality_Normal);
	
break;
}
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("ObjectOptionalitySpec_opt");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("ObjectOptionalitySpec_opt", 1);
return 1;
failed1: LLDEBUG_LEAVE("ObjectOptionalitySpec_opt", 0);
return 0;
}

int ll_ObjectSetFieldSpec(XFieldSpecs *llret, LLSTATE *llin, LLSTATE *llout, XObjectClass llarg_oc)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("ObjectSetFieldSpec");

llstate_0 = *llin;
#undef failed
#define failed failed1
{LLSTATE llstate_1;XString llatt_1;
if (!ll_objectsetfieldreference(&llatt_1, &llstate_0, &llstate_1, llarg_oc)) goto failed1;
{LLSTATE llstate_2;XObjectClass llatt_2;
if (!ll_DefinedObjectClass(&llatt_2, &llstate_1, &llstate_2)) goto failed1;
{LLSTATE llstate_3;XOptionality llatt_3;
if (!ll_ObjectSetOptionalitySpec_opt(&llatt_3, &llstate_2, &llstate_3, llatt_2)) goto failed1;
*llout = llstate_3;
{if (GetObjectClass((*llout).Assignments, llatt_2)) {
		(*llret) = NewFieldSpec(eFieldSpec_ObjectSet);
		(*llret)->Identifier = llatt_1;
		(*llret)->U.ObjectSet.ObjectClass = llatt_2;
		(*llret)->U.ObjectSet.Optionality = llatt_3;
	    } else {
		(*llret) = NULL;
	    }
	
}}}}
LLDEBUG_LEAVE("ObjectSetFieldSpec", 1);
return 1;
failed1: LLDEBUG_LEAVE("ObjectSetFieldSpec", 0);
return 0;
}

int ll_ObjectSetOptionalitySpec_opt(XOptionality *llret, LLSTATE *llin, LLSTATE *llout, XObjectClass llarg_oc)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("ObjectSetOptionalitySpec_opt");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("ObjectSetOptionalitySpec_opt", 1);
{LLSTATE llstate_1;
if (!llterm(T_OPTIONAL, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = NewOptionality(eOptionality_Optional);
	
break;
}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("ObjectSetOptionalitySpec_opt", 2);
{LLSTATE llstate_1;
if (!llterm(T_DEFAULT, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
{LLSTATE llstate_2;XObjectSet llatt_2;
if (!ll_ObjectSet(&llatt_2, &llstate_1, &llstate_2, llarg_oc)) goto failed2;
*llout = llstate_2;
{(*llret) = NewOptionality(eOptionality_Default_ObjectSet);
	    (*llret)->U.ObjectSet = llatt_2;
	
break;
}}}
case 3: case -3:
LLDEBUG_ALTERNATIVE("ObjectSetOptionalitySpec_opt", 3);
*llout = llstate_0;
{(*llret) = NewOptionality(eOptionality_Normal);
	
break;
}
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("ObjectSetOptionalitySpec_opt");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("ObjectSetOptionalitySpec_opt", 1);
return 1;
failed1: LLDEBUG_LEAVE("ObjectSetOptionalitySpec_opt", 0);
return 0;
}

int ll_PrimitiveFieldName(XString *llret, LLSTATE *llin, LLSTATE *llout, XObjectClass llarg_oc)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("PrimitiveFieldName");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("PrimitiveFieldName", 1);
{LLSTATE llstate_1;XString llatt_1;
if (!ll_typefieldreference(&llatt_1, &llstate_0, &llstate_1, llarg_oc)) goto failed2;
*llout = llstate_1;
{(*llret) = llatt_1;
	
break;
}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("PrimitiveFieldName", 2);
{LLSTATE llstate_1;XString llatt_1;
if (!ll_valuefieldreference(&llatt_1, &llstate_0, &llstate_1, llarg_oc)) goto failed2;
*llout = llstate_1;
{(*llret) = llatt_1;
	
break;
}}
case 3: case -3:
LLDEBUG_ALTERNATIVE("PrimitiveFieldName", 3);
{LLSTATE llstate_1;XString llatt_1;
if (!ll_valuesetfieldreference(&llatt_1, &llstate_0, &llstate_1, llarg_oc)) goto failed2;
*llout = llstate_1;
{(*llret) = llatt_1;
	
break;
}}
case 4: case -4:
LLDEBUG_ALTERNATIVE("PrimitiveFieldName", 4);
{LLSTATE llstate_1;XString llatt_1;
if (!ll_objectfieldreference(&llatt_1, &llstate_0, &llstate_1, llarg_oc)) goto failed2;
*llout = llstate_1;
{(*llret) = llatt_1;
	
break;
}}
case 5: case -5:
LLDEBUG_ALTERNATIVE("PrimitiveFieldName", 5);
{LLSTATE llstate_1;XString llatt_1;
if (!ll_objectsetfieldreference(&llatt_1, &llstate_0, &llstate_1, llarg_oc)) goto failed2;
*llout = llstate_1;
{(*llret) = llatt_1;
	
break;
}}
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("PrimitiveFieldName");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("PrimitiveFieldName", 1);
return 1;
failed1: LLDEBUG_LEAVE("PrimitiveFieldName", 0);
return 0;
}

int ll_FieldName(XStrings *llret, LLSTATE *llin, LLSTATE *llout, XObjectClass llarg_oc)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("FieldName");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("FieldName", 1);
{LLSTATE llstate_1;XString llatt_1;
if (!ll_objectfieldreference(&llatt_1, &llstate_0, &llstate_1, llarg_oc)) goto failed2;
{LLSTATE llstate_2;
if (!llterm('.', (LLSTYPE *)0, &llstate_1, &llstate_2)) goto failed2;
{FieldSpec_t *fs;
	    ObjectClass_t *oc;
	    fs = GetObjectClassField(llstate_2.Assignments, llarg_oc, llatt_1);
	    if (fs)
		oc = fs->U.Object.ObjectClass;
	    else
		oc = NULL;
	
{LLSTATE llstate_3;XStrings llatt_3;
if (!ll_FieldName(&llatt_3, &llstate_2, &llstate_3, oc)) goto failed2;
*llout = llstate_3;
{(*llret) = NewString();
	    (*llret)->String = llatt_1;
	    (*llret)->Next = llatt_3;
	
break;
}}}}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("FieldName", 2);
{LLSTATE llstate_1;XString llatt_1;
if (!ll_objectsetfieldreference(&llatt_1, &llstate_0, &llstate_1, llarg_oc)) goto failed2;
{LLSTATE llstate_2;
if (!llterm('.', (LLSTYPE *)0, &llstate_1, &llstate_2)) goto failed2;
{FieldSpec_t *fs;
	    ObjectClass_t *oc;
	    fs = GetObjectClassField(llstate_2.Assignments, llarg_oc, llatt_1);
	    if (fs)
		oc = fs->U.ObjectSet.ObjectClass;
	    else
		oc = NULL;
	
{LLSTATE llstate_3;XStrings llatt_3;
if (!ll_FieldName(&llatt_3, &llstate_2, &llstate_3, oc)) goto failed2;
*llout = llstate_3;
{(*llret) = NewString();
	    (*llret)->String = llatt_1;
	    (*llret)->Next = llatt_3;
	
break;
}}}}}
case 3: case -3:
LLDEBUG_ALTERNATIVE("FieldName", 3);
{LLSTATE llstate_1;XString llatt_1;
if (!ll_PrimitiveFieldName(&llatt_1, &llstate_0, &llstate_1, llarg_oc)) goto failed2;
*llout = llstate_1;
{(*llret) = NewString();
	    (*llret)->String = llatt_1;
	
break;
}}
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("FieldName");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("FieldName", 1);
return 1;
failed1: LLDEBUG_LEAVE("FieldName", 0);
return 0;
}

int ll_SyntaxList(XSyntaxSpecs *llret, LLSTATE *llin, LLSTATE *llout, XObjectClass llarg_oc)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("SyntaxList");

llstate_0 = *llin;
#undef failed
#define failed failed1
{LLSTATE llstate_1;
if (!llterm('{', (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed1;
{LLSTATE llstate_2;XSyntaxSpecs llatt_2;
if (!ll_TokenOrGroupSpec_Seq(&llatt_2, &llstate_1, &llstate_2, llarg_oc)) goto failed1;
{LLSTATE llstate_3;
if (!llterm('}', (LLSTYPE *)0, &llstate_2, &llstate_3)) goto failed1;
*llout = llstate_3;
{(*llret) = llatt_2;
	
}}}}
LLDEBUG_LEAVE("SyntaxList", 1);
return 1;
failed1: LLDEBUG_LEAVE("SyntaxList", 0);
return 0;
}

int ll_TokenOrGroupSpec_Seq(XSyntaxSpecs *llret, LLSTATE *llin, LLSTATE *llout, XObjectClass llarg_oc)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("TokenOrGroupSpec_Seq");

llstate_0 = *llin;
#undef failed
#define failed failed1
{LLSTATE llstate_1;XSyntaxSpecs llatt_1;
if (!ll_TokenOrGroupSpec(&llatt_1, &llstate_0, &llstate_1, llarg_oc)) goto failed1;
{LLSTATE llstate_2;XSyntaxSpecs llatt_2;
if (!ll_TokenOrGroupSpec_ESeq(&llatt_2, &llstate_1, &llstate_2, llarg_oc)) goto failed1;
*llout = llstate_2;
{(*llret) = DupSyntaxSpec(llatt_1);
	    (*llret)->Next = llatt_2;
	
}}}
LLDEBUG_LEAVE("TokenOrGroupSpec_Seq", 1);
return 1;
failed1: LLDEBUG_LEAVE("TokenOrGroupSpec_Seq", 0);
return 0;
}

int ll_TokenOrGroupSpec_ESeq(XSyntaxSpecs *llret, LLSTATE *llin, LLSTATE *llout, XObjectClass llarg_oc)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("TokenOrGroupSpec_ESeq");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("TokenOrGroupSpec_ESeq", 1);
{LLSTATE llstate_1;XSyntaxSpecs llatt_1;
if (!ll_TokenOrGroupSpec(&llatt_1, &llstate_0, &llstate_1, llarg_oc)) goto failed2;
{LLSTATE llstate_2;XSyntaxSpecs llatt_2;
if (!ll_TokenOrGroupSpec_ESeq(&llatt_2, &llstate_1, &llstate_2, llarg_oc)) goto failed2;
*llout = llstate_2;
{(*llret) = DupSyntaxSpec(llatt_1);
	    (*llret)->Next = llatt_2;
	
break;
}}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("TokenOrGroupSpec_ESeq", 2);
*llout = llstate_0;
{(*llret) = NULL;
	
break;
}
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("TokenOrGroupSpec_ESeq");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("TokenOrGroupSpec_ESeq", 1);
return 1;
failed1: LLDEBUG_LEAVE("TokenOrGroupSpec_ESeq", 0);
return 0;
}

int ll_TokenOrGroupSpec(XSyntaxSpecs *llret, LLSTATE *llin, LLSTATE *llout, XObjectClass llarg_oc)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("TokenOrGroupSpec");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("TokenOrGroupSpec", 1);
{LLSTATE llstate_1;XSyntaxSpecs llatt_1;
if (!ll_RequiredToken(&llatt_1, &llstate_0, &llstate_1, llarg_oc)) goto failed2;
*llout = llstate_1;
{(*llret) = llatt_1;
	
break;
}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("TokenOrGroupSpec", 2);
{LLSTATE llstate_1;XSyntaxSpecs llatt_1;
if (!ll_OptionalGroup(&llatt_1, &llstate_0, &llstate_1, llarg_oc)) goto failed2;
*llout = llstate_1;
{(*llret) = llatt_1;
	
break;
}}
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("TokenOrGroupSpec");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("TokenOrGroupSpec", 1);
return 1;
failed1: LLDEBUG_LEAVE("TokenOrGroupSpec", 0);
return 0;
}

int ll_OptionalGroup(XSyntaxSpecs *llret, LLSTATE *llin, LLSTATE *llout, XObjectClass llarg_oc)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("OptionalGroup");

llstate_0 = *llin;
#undef failed
#define failed failed1
{LLSTATE llstate_1;
if (!llterm('[', (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed1;
{LLSTATE llstate_2;XSyntaxSpecs llatt_2;
if (!ll_TokenOrGroupSpec_Seq(&llatt_2, &llstate_1, &llstate_2, llarg_oc)) goto failed1;
{LLSTATE llstate_3;
if (!llterm(']', (LLSTYPE *)0, &llstate_2, &llstate_3)) goto failed1;
*llout = llstate_3;
{(*llret) = NewSyntaxSpec(eSyntaxSpec_Optional);
	    (*llret)->U.Optional.SyntaxSpec = llatt_2;
	
}}}}
LLDEBUG_LEAVE("OptionalGroup", 1);
return 1;
failed1: LLDEBUG_LEAVE("OptionalGroup", 0);
return 0;
}

int ll_RequiredToken(XSyntaxSpecs *llret, LLSTATE *llin, LLSTATE *llout, XObjectClass llarg_oc)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("RequiredToken");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("RequiredToken", 1);
{LLSTATE llstate_1;XString llatt_1;
if (!ll_Literal(&llatt_1, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = NewSyntaxSpec(eSyntaxSpec_Literal);
	    (*llret)->U.Literal.Literal = llatt_1;
	
break;
}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("RequiredToken", 2);
{LLSTATE llstate_1;XString llatt_1;
if (!ll_PrimitiveFieldName(&llatt_1, &llstate_0, &llstate_1, llarg_oc)) goto failed2;
*llout = llstate_1;
{(*llret) = NewSyntaxSpec(eSyntaxSpec_Field);
	    (*llret)->U.Field.Field = llatt_1;
	
break;
}}
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("RequiredToken");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("RequiredToken", 1);
return 1;
failed1: LLDEBUG_LEAVE("RequiredToken", 0);
return 0;
}

int ll_Literal(XString *llret, LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("Literal");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("Literal", 1);
{LLSTATE llstate_1;XString llatt_1;
if (!ll_word(&llatt_1, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = llatt_1;
	
break;
}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("Literal", 2);
{LLSTATE llstate_1;
if (!llterm(',', (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = ",";
	
break;
}}
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("Literal");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("Literal", 1);
return 1;
failed1: LLDEBUG_LEAVE("Literal", 0);
return 0;
}

int ll_ObjectAssignment(LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("ObjectAssignment");

llstate_0 = *llin;
#undef failed
#define failed failed1
{LLSTATE llstate_1;XObject llatt_1;
if (!ll_objectreference(&llatt_1, &llstate_0, &llstate_1)) goto failed1;
{LLSTATE llstate_2;XObjectClass llatt_2;
if (!ll_DefinedObjectClass(&llatt_2, &llstate_1, &llstate_2)) goto failed1;
{LLSTATE llstate_3;
if (!llterm(T_DEF, (LLSTYPE *)0, &llstate_2, &llstate_3)) goto failed1;
{LLSTATE llstate_4;XObject llatt_4;
if (!ll_Object(&llatt_4, &llstate_3, &llstate_4, llatt_2)) goto failed1;
*llout = llstate_4;
{AssignObject(&(*llout).Assignments, llatt_1, llatt_4);
	
}}}}}
LLDEBUG_LEAVE("ObjectAssignment", 1);
return 1;
failed1: LLDEBUG_LEAVE("ObjectAssignment", 0);
return 0;
}

int ll_Object(XObject *llret, LLSTATE *llin, LLSTATE *llout, XObjectClass llarg_oc)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("Object");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("Object", 1);
{LLSTATE llstate_1;XObject llatt_1;
if (!ll_ObjectDefn(&llatt_1, &llstate_0, &llstate_1, llarg_oc)) goto failed2;
*llout = llstate_1;
{(*llret) = llatt_1;
	
break;
}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("Object", 2);
{LLSTATE llstate_1;XObject llatt_1;
if (!ll_ObjectFromObject(&llatt_1, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = llatt_1;
	
break;
}}
case 3: case -3:
LLDEBUG_ALTERNATIVE("Object", 3);
{LLSTATE llstate_1;XObject llatt_1;
if (!ll_DefinedObject(&llatt_1, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = llatt_1;
	
break;
}}
case 4: case -4:
LLDEBUG_ALTERNATIVE("Object", 4);
{LLSTATE llstate_1;
if (!ll_ParameterizedObject(&llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{MyAbort();
	
break;
}}
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("Object");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("Object", 1);
return 1;
failed1: LLDEBUG_LEAVE("Object", 0);
return 0;
}

int ll_ObjectDefn(XObject *llret, LLSTATE *llin, LLSTATE *llout, XObjectClass llarg_oc)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("ObjectDefn");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("ObjectDefn", 1);
{LLSTATE llstate_1;XObject llatt_1;
if (!ll_DefaultSyntax(&llatt_1, &llstate_0, &llstate_1, llarg_oc)) goto failed2;
*llout = llstate_1;
{(*llret) = llatt_1;
	
break;
}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("ObjectDefn", 2);
{LLSTATE llstate_1;XObject llatt_1;
if (!ll_DefinedSyntax(&llatt_1, &llstate_0, &llstate_1, llarg_oc)) goto failed2;
*llout = llstate_1;
{(*llret) = llatt_1;
	
break;
}}
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("ObjectDefn");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("ObjectDefn", 1);
return 1;
failed1: LLDEBUG_LEAVE("ObjectDefn", 0);
return 0;
}

int ll_DefaultSyntax(XObject *llret, LLSTATE *llin, LLSTATE *llout, XObjectClass llarg_oc)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("DefaultSyntax");

llstate_0 = *llin;
#undef failed
#define failed failed1
{LLSTATE llstate_1;
if (!llterm('{', (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed1;
{LLSTATE llstate_2;XSettings llatt_2;
if (!ll_FieldSetting_EList(&llatt_2, &llstate_1, &llstate_2, llarg_oc, NULL)) goto failed1;
{LLSTATE llstate_3;
if (!llterm('}', (LLSTYPE *)0, &llstate_2, &llstate_3)) goto failed1;
*llout = llstate_3;
{(*llret) = NewObject(eObject_Object);
	    (*llret)->U.Object.ObjectClass = llarg_oc;
	    (*llret)->U.Object.Settings = llatt_2;
	
}}}}
LLDEBUG_LEAVE("DefaultSyntax", 1);
return 1;
failed1: LLDEBUG_LEAVE("DefaultSyntax", 0);
return 0;
}

int ll_FieldSetting_EList(XSettings *llret, LLSTATE *llin, LLSTATE *llout, XObjectClass llarg_oc, XSettings llarg_se)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("FieldSetting_EList");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("FieldSetting_EList", 1);
{LLSTATE llstate_1;XSettings llatt_1;
if (!ll_FieldSetting(&llatt_1, &llstate_0, &llstate_1, llarg_oc, llarg_se)) goto failed2;
{Setting_t *s, **ss, *se;
	    for (s = llatt_1, ss = &se; s; s = s->Next, ss = &(*ss)->Next)
		*ss = DupSetting(s);
	    *ss = llarg_se;
	
{LLSTATE llstate_2;XSettings llatt_2;
if (!ll_FieldSetting_EListC(&llatt_2, &llstate_1, &llstate_2, llarg_oc, se)) goto failed2;
*llout = llstate_2;
{for (s = llatt_1, ss = &(*llret); s; s = s->Next, ss = &(*ss)->Next)
		*ss = DupSetting(s);
	    *ss = llatt_2;
	
break;
}}}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("FieldSetting_EList", 2);
*llout = llstate_0;
{(*llret) = NULL;
	
break;
}
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("FieldSetting_EList");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("FieldSetting_EList", 1);
return 1;
failed1: LLDEBUG_LEAVE("FieldSetting_EList", 0);
return 0;
}

int ll_FieldSetting_EListC(XSettings *llret, LLSTATE *llin, LLSTATE *llout, XObjectClass llarg_oc, XSettings llarg_se)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("FieldSetting_EListC");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("FieldSetting_EListC", 1);
{LLSTATE llstate_1;
if (!llterm(',', (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
{LLSTATE llstate_2;XSettings llatt_2;
if (!ll_FieldSetting(&llatt_2, &llstate_1, &llstate_2, llarg_oc, llarg_se)) goto failed2;
{Setting_t *s, **ss, *se;
	    for (s = llatt_2, ss = &se; s; s = s->Next, ss = &(*ss)->Next)
		*ss = DupSetting(s);
	    *ss = llarg_se;
	
{LLSTATE llstate_3;XSettings llatt_3;
if (!ll_FieldSetting_EListC(&llatt_3, &llstate_2, &llstate_3, llarg_oc, se)) goto failed2;
*llout = llstate_3;
{for (s = llatt_2, ss = &(*llret); s; s = s->Next, ss = &(*ss)->Next)
		*ss = DupSetting(s);
	    *ss = llatt_3;
	
break;
}}}}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("FieldSetting_EListC", 2);
*llout = llstate_0;
{(*llret) = NULL;
	
break;
}
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("FieldSetting_EListC");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("FieldSetting_EListC", 1);
return 1;
failed1: LLDEBUG_LEAVE("FieldSetting_EListC", 0);
return 0;
}

int ll_FieldSetting(XSettings *llret, LLSTATE *llin, LLSTATE *llout, XObjectClass llarg_oc, XSettings llarg_se)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("FieldSetting");

llstate_0 = *llin;
#undef failed
#define failed failed1
{LLSTATE llstate_1;XString llatt_1;
if (!ll_PrimitiveFieldName(&llatt_1, &llstate_0, &llstate_1, llarg_oc)) goto failed1;
{LLSTATE llstate_2;XSettings llatt_2;
if (!ll_Setting(&llatt_2, &llstate_1, &llstate_2, llarg_oc, llarg_se, llatt_1)) goto failed1;
*llout = llstate_2;
{(*llret) = llatt_2;
	
}}}
LLDEBUG_LEAVE("FieldSetting", 1);
return 1;
failed1: LLDEBUG_LEAVE("FieldSetting", 0);
return 0;
}

int ll_DefinedSyntax(XObject *llret, LLSTATE *llin, LLSTATE *llout, XObjectClass llarg_oc)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("DefinedSyntax");

llstate_0 = *llin;
#undef failed
#define failed failed1
{ObjectClass_t *oc;
	    SyntaxSpec_t *sy;
	    oc = GetObjectClass((*llin).Assignments, llarg_oc);
	    if (oc && !oc->U.ObjectClass.SyntaxSpec)
		LLFAILED((&llstate_0.pos, "Bad settings"));
	    sy = oc ? oc->U.ObjectClass.SyntaxSpec : UndefSyntaxSpecs;
	
{LLSTATE llstate_1;
if (!llterm('{', (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed1;
{LLSTATE llstate_2;XSettings llatt_2;
if (!ll_DefinedSyntaxToken_ESeq(&llatt_2, &llstate_1, &llstate_2, llarg_oc, NULL, sy)) goto failed1;
{LLSTATE llstate_3;
if (!llterm('}', (LLSTYPE *)0, &llstate_2, &llstate_3)) goto failed1;
*llout = llstate_3;
{(*llret) = NewObject(eObject_Object);
	    (*llret)->U.Object.ObjectClass = llarg_oc;
	    (*llret)->U.Object.Settings = llatt_2;
	
}}}}}
LLDEBUG_LEAVE("DefinedSyntax", 1);
return 1;
failed1: LLDEBUG_LEAVE("DefinedSyntax", 0);
return 0;
}

int ll_DefinedSyntaxToken_ESeq(XSettings *llret, LLSTATE *llin, LLSTATE *llout, XObjectClass llarg_oc, XSettings llarg_se, XSyntaxSpecs llarg_sy)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("DefinedSyntaxToken_ESeq");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("DefinedSyntaxToken_ESeq", 1);
{if (!llarg_sy)
		LLFAILED((&llstate_0.pos, "Bad settings"));
	
{LLSTATE llstate_1;XSettings llatt_1;
if (!ll_DefinedSyntaxToken(&llatt_1, &llstate_0, &llstate_1, llarg_oc, llarg_se, llarg_sy)) goto failed2;
{Setting_t *s, **ss, *se;
	    for (s = llatt_1, ss = &se; s; s = s->Next, ss = &(*ss)->Next)
		*ss = DupSetting(s);
	    *ss = llarg_se;
	
{LLSTATE llstate_2;XSettings llatt_2;
if (!ll_DefinedSyntaxToken_ESeq(&llatt_2, &llstate_1, &llstate_2, llarg_oc, se, DEFINED(llarg_sy) ? llarg_sy->Next : llarg_sy)) goto failed2;
*llout = llstate_2;
{for (s = llatt_1, ss = &(*llret); s; s = s->Next, ss = &(*ss)->Next)
		*ss = DupSetting(s);
	    *ss = llatt_2;
	
break;
}}}}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("DefinedSyntaxToken_ESeq", 2);
*llout = llstate_0;
{if (DEFINED(llarg_sy))
		LLFAILED((&llstate_0.pos, "Bad settings"));
	    (*llret) = NULL;
	
break;
}
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("DefinedSyntaxToken_ESeq");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("DefinedSyntaxToken_ESeq", 1);
return 1;
failed1: LLDEBUG_LEAVE("DefinedSyntaxToken_ESeq", 0);
return 0;
}

int ll_DefinedSyntaxToken(XSettings *llret, LLSTATE *llin, LLSTATE *llout, XObjectClass llarg_oc, XSettings llarg_se, XSyntaxSpecs llarg_sy)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("DefinedSyntaxToken");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("DefinedSyntaxToken", 1);
{if (!DEFINED(llarg_sy) || llarg_sy->Type != eSyntaxSpec_Optional)
		LLFAILED((&llstate_0.pos, "Bad settings"));
	
{LLSTATE llstate_1;XSettings llatt_1;
if (!ll_DefinedSyntaxToken_ESeq(&llatt_1, &llstate_0, &llstate_1, llarg_oc, llarg_se, llarg_sy->U.Optional.SyntaxSpec)) goto failed2;
*llout = llstate_1;
{(*llret) = llatt_1;
	
break;
}}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("DefinedSyntaxToken", 2);
*llout = llstate_0;
{if (!DEFINED(llarg_sy) || llarg_sy->Type != eSyntaxSpec_Optional)
		LLFAILED((&llstate_0.pos, "Bad settings"));
	
{(*llret) = NULL;
	
break;
}}
case 3: case -3:
LLDEBUG_ALTERNATIVE("DefinedSyntaxToken", 3);
{if (DEFINED(llarg_sy) && llarg_sy->Type == eSyntaxSpec_Optional)
		LLFAILED((&llstate_0.pos, "Bad settings"));
	
{LLSTATE llstate_1;XSettings llatt_1;
if (!ll_DefinedSyntaxToken_Elem(&llatt_1, &llstate_0, &llstate_1, llarg_oc, llarg_se, llarg_sy)) goto failed2;
*llout = llstate_1;
{(*llret) = llatt_1;
	
break;
}}}
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("DefinedSyntaxToken");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("DefinedSyntaxToken", 1);
return 1;
failed1: LLDEBUG_LEAVE("DefinedSyntaxToken", 0);
return 0;
}

int ll_DefinedSyntaxToken_Elem(XSettings *llret, LLSTATE *llin, LLSTATE *llout, XObjectClass llarg_oc, XSettings llarg_se, XSyntaxSpecs llarg_sy)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("DefinedSyntaxToken_Elem");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("DefinedSyntaxToken_Elem", 1);
{if (!llarg_sy || (DEFINED(llarg_sy) && llarg_sy->Type != eSyntaxSpec_Literal))
		LLFAILED((&llstate_0.pos, "Bad settings"));
	
{LLSTATE llstate_1;XString llatt_1;
if (!ll_Literal(&llatt_1, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{if (DEFINED(llarg_sy) && strcmp(llarg_sy->U.Literal.Literal, llatt_1))
		LLFAILED((&llstate_0.pos, "Bad settings"));
	    (*llret) = NULL;
	
break;
}}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("DefinedSyntaxToken_Elem", 2);
{if (!llarg_sy || (DEFINED(llarg_sy) && llarg_sy->Type != eSyntaxSpec_Field))
		LLFAILED((&llstate_0.pos, "Bad settings"));
	
{LLSTATE llstate_1;XSettings llatt_1;
if (!ll_Setting(&llatt_1, &llstate_0, &llstate_1, llarg_oc, llarg_se, DEFINED(llarg_sy) ? llarg_sy->U.Field.Field : NULL)) goto failed2;
*llout = llstate_1;
{(*llret) = llatt_1;
	
break;
}}}
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("DefinedSyntaxToken_Elem");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("DefinedSyntaxToken_Elem", 1);
return 1;
failed1: LLDEBUG_LEAVE("DefinedSyntaxToken_Elem", 0);
return 0;
}

int ll_Setting(XSettings *llret, LLSTATE *llin, LLSTATE *llout, XObjectClass llarg_oc, XSettings llarg_se, XString llarg_f)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("Setting");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("Setting", 1);
{FieldSpec_t *fs;
	    FieldSpecs_e fe;
	    fs = GetObjectClassField((*llin).Assignments, llarg_oc, llarg_f);
	    fe = GetFieldSpecType((*llin).Assignments, fs);
	    if (fe != eFieldSpec_Undefined &&
		fe != eFieldSpec_Type)
		LLFAILED((&llstate_0.pos, "Bad setting"));
	
{LLSTATE llstate_1;XType llatt_1;
if (!ll_Type(&llatt_1, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = NewSetting(eSetting_Type);
	    (*llret)->Identifier = llarg_f;
	    (*llret)->U.Type.Type = llatt_1;
	
break;
}}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("Setting", 2);
{Type_t *type;
	    FieldSpec_t *fs;
	    FieldSpecs_e fe;
	    Setting_t *se;
	    fs = GetObjectClassField((*llin).Assignments, llarg_oc, llarg_f);
	    fe = GetFieldSpecType((*llin).Assignments, fs);
	    if (fe != eFieldSpec_Undefined &&
		fe != eFieldSpec_FixedTypeValue &&
		fe != eFieldSpec_VariableTypeValue)
		LLFAILED((&llstate_0.pos, "Bad setting"));
	    if (fe == eFieldSpec_FixedTypeValue) {
		type = fs->U.FixedTypeValue.Type;
	    } else if (fe == eFieldSpec_VariableTypeValue) {
		se = GetSettingFromSettings((*llin).Assignments, llarg_se,
		    fs->U.VariableTypeValue.Fields);
		if (GetSettingType(se) != eSetting_Type &&
		    GetSettingType(se) != eSetting_Undefined)
		    MyAbort();
		if (GetSettingType(se) == eSetting_Type)
		    type = se->U.Type.Type;
		else
		    type = NULL;
	    } else {
		type = NULL;
	    }
	
{LLSTATE llstate_1;XValue llatt_1;
if (!ll_Value(&llatt_1, &llstate_0, &llstate_1, type)) goto failed2;
*llout = llstate_1;
{if (type) {
		(*llret) = NewSetting(eSetting_Value);
		(*llret)->Identifier = llarg_f;
		(*llret)->U.Value.Value = llatt_1;
	    } else {
		(*llret) = NULL;
	    }
	
break;
}}}
case 3: case -3:
LLDEBUG_ALTERNATIVE("Setting", 3);
{Type_t *type;
	    FieldSpec_t *fs;
	    FieldSpecs_e fe;
	    Setting_t *se;
	    fs = GetObjectClassField((*llin).Assignments, llarg_oc, llarg_f);
	    fe = GetFieldSpecType((*llin).Assignments, fs);
	    if (fe != eFieldSpec_Undefined &&
		fe != eFieldSpec_FixedTypeValueSet &&
		fe != eFieldSpec_VariableTypeValueSet)
		LLFAILED((&llstate_0.pos, "Bad setting"));
	    if (fe == eFieldSpec_FixedTypeValueSet) {
		type = fs->U.FixedTypeValueSet.Type;
	    } else if (fe == eFieldSpec_VariableTypeValueSet) {
		se = GetSettingFromSettings((*llin).Assignments, llarg_se,
		    fs->U.VariableTypeValueSet.Fields);
		if (GetSettingType(se) != eSetting_Type &&
		    GetSettingType(se) != eSetting_Undefined)
		    MyAbort();
		if (GetSettingType(se) == eSetting_Type)
		    type = se->U.Type.Type;
		else
		    type = NULL;
	    } else {
		type = NULL;
	    }
	
{LLSTATE llstate_1;XValueSet llatt_1;
if (!ll_ValueSet(&llatt_1, &llstate_0, &llstate_1, type)) goto failed2;
*llout = llstate_1;
{if (type) {
		(*llret) = NewSetting(eSetting_ValueSet);
		(*llret)->Identifier = llarg_f;
		(*llret)->U.ValueSet.ValueSet = llatt_1;
	    } else {
		(*llret) = NULL;
	    }
	
break;
}}}
case 4: case -4:
LLDEBUG_ALTERNATIVE("Setting", 4);
{ObjectClass_t *oc;
	    FieldSpec_t *fs;
	    FieldSpecs_e fe;
	    fs = GetObjectClassField((*llin).Assignments, llarg_oc, llarg_f);
	    fe = GetFieldSpecType((*llin).Assignments, fs);
	    if (fe != eFieldSpec_Undefined &&
		fe != eFieldSpec_Object)
		LLFAILED((&llstate_0.pos, "Bad setting"));
	    if (fe == eFieldSpec_Object)
		oc = fs->U.Object.ObjectClass;
	    else
		oc = NULL;
	
{LLSTATE llstate_1;XObject llatt_1;
if (!ll_Object(&llatt_1, &llstate_0, &llstate_1, oc)) goto failed2;
*llout = llstate_1;
{(*llret) = NewSetting(eSetting_Object);
	    (*llret)->Identifier = llarg_f;
	    (*llret)->U.Object.Object = llatt_1;
	
break;
}}}
case 5: case -5:
LLDEBUG_ALTERNATIVE("Setting", 5);
{ObjectClass_t *oc;
	    FieldSpec_t *fs;
	    FieldSpecs_e fe;
	    fs = GetObjectClassField((*llin).Assignments, llarg_oc, llarg_f);
	    fe = GetFieldSpecType((*llin).Assignments, fs);
	    if (fe != eFieldSpec_Undefined &&
		fe != eFieldSpec_ObjectSet)
		LLFAILED((&llstate_0.pos, "Bad setting"));
	    if (fe == eFieldSpec_ObjectSet)
		oc = fs->U.ObjectSet.ObjectClass;
	    else
		oc = NULL;
	
{LLSTATE llstate_1;XObjectSet llatt_1;
if (!ll_ObjectSet(&llatt_1, &llstate_0, &llstate_1, oc)) goto failed2;
*llout = llstate_1;
{(*llret) = NewSetting(eSetting_ObjectSet);
	    (*llret)->Identifier = llarg_f;
	    (*llret)->U.ObjectSet.ObjectSet = llatt_1;
	
break;
}}}
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("Setting");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("Setting", 1);
return 1;
failed1: LLDEBUG_LEAVE("Setting", 0);
return 0;
}

int ll_ObjectSetAssignment(LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("ObjectSetAssignment");

llstate_0 = *llin;
#undef failed
#define failed failed1
{LLSTATE llstate_1;XObjectSet llatt_1;
if (!ll_objectsetreference(&llatt_1, &llstate_0, &llstate_1)) goto failed1;
{LLSTATE llstate_2;XObjectClass llatt_2;
if (!ll_DefinedObjectClass(&llatt_2, &llstate_1, &llstate_2)) goto failed1;
{LLSTATE llstate_3;
if (!llterm(T_DEF, (LLSTYPE *)0, &llstate_2, &llstate_3)) goto failed1;
{LLSTATE llstate_4;XObjectSet llatt_4;
if (!ll_ObjectSet(&llatt_4, &llstate_3, &llstate_4, llatt_2)) goto failed1;
*llout = llstate_4;
{AssignObjectSet(&(*llout).Assignments, llatt_1, llatt_4);
	
}}}}}
LLDEBUG_LEAVE("ObjectSetAssignment", 1);
return 1;
failed1: LLDEBUG_LEAVE("ObjectSetAssignment", 0);
return 0;
}

int ll_ObjectSet(XObjectSet *llret, LLSTATE *llin, LLSTATE *llout, XObjectClass llarg_oc)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("ObjectSet");

llstate_0 = *llin;
#undef failed
#define failed failed1
{LLSTATE llstate_1;
if (!llterm('{', (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed1;
{LLSTATE llstate_2;XObjectSet llatt_2;
if (!ll_ObjectSetSpec(&llatt_2, &llstate_1, &llstate_2, llarg_oc)) goto failed1;
{LLSTATE llstate_3;
if (!llterm('}', (LLSTYPE *)0, &llstate_2, &llstate_3)) goto failed1;
*llout = llstate_3;
{(*llret) = llatt_2;
	
}}}}
LLDEBUG_LEAVE("ObjectSet", 1);
return 1;
failed1: LLDEBUG_LEAVE("ObjectSet", 0);
return 0;
}

int ll_ObjectSetSpec(XObjectSet *llret, LLSTATE *llin, LLSTATE *llout, XObjectClass llarg_oc)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("ObjectSetSpec");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("ObjectSetSpec", 1);
{LLSTATE llstate_1;XElementSetSpec llatt_1;
if (!ll_ElementSetSpec(&llatt_1, &llstate_0, &llstate_1, NULL, llarg_oc, 0)) goto failed2;
*llout = llstate_1;
{(*llret) = NewObjectSet(eObjectSet_ObjectSet);
	    (*llret)->U.ObjectSet.ObjectClass = llarg_oc;
	    (*llret)->U.ObjectSet.Elements = llatt_1;
	
break;
}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("ObjectSetSpec", 2);
{LLSTATE llstate_1;
if (!llterm(T_TDOT, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = NewObjectSet(eObjectSet_ExtensionMarker);
	    (*llret)->U.ExtensionMarker.ObjectClass = llarg_oc;
	
break;
}}
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("ObjectSetSpec");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("ObjectSetSpec", 1);
return 1;
failed1: LLDEBUG_LEAVE("ObjectSetSpec", 0);
return 0;
}

int ll_ObjectSetElements(XObjectSetElement *llret, LLSTATE *llin, LLSTATE *llout, XObjectClass llarg_oc)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("ObjectSetElements");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("ObjectSetElements", 1);
{LLSTATE llstate_1;XObjectSet llatt_1;
if (!ll_ObjectSetFromObjects(&llatt_1, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = NewObjectSetElement(eObjectSetElement_ObjectSet);
	    (*llret)->U.ObjectSet.ObjectSet = llatt_1;
	
break;
}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("ObjectSetElements", 2);
{LLSTATE llstate_1;XObject llatt_1;
if (!ll_Object(&llatt_1, &llstate_0, &llstate_1, llarg_oc)) goto failed2;
*llout = llstate_1;
{(*llret) = NewObjectSetElement(eObjectSetElement_Object);
	    (*llret)->U.Object.Object = llatt_1;
	
break;
}}
case 3: case -3:
LLDEBUG_ALTERNATIVE("ObjectSetElements", 3);
{LLSTATE llstate_1;XObjectSet llatt_1;
if (!ll_DefinedObjectSet(&llatt_1, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = NewObjectSetElement(eObjectSetElement_ObjectSet);
	    (*llret)->U.ObjectSet.ObjectSet = llatt_1;
	
break;
}}
case 4: case -4:
LLDEBUG_ALTERNATIVE("ObjectSetElements", 4);
{LLSTATE llstate_1;
if (!ll_ParameterizedObjectSet(&llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{MyAbort();
	
break;
}}
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("ObjectSetElements");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("ObjectSetElements", 1);
return 1;
failed1: LLDEBUG_LEAVE("ObjectSetElements", 0);
return 0;
}

int ll_ObjectClassFieldType(XType *llret, LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("ObjectClassFieldType");

llstate_0 = *llin;
#undef failed
#define failed failed1
{LLSTATE llstate_1;XObjectClass llatt_1;
if (!ll_DefinedObjectClass(&llatt_1, &llstate_0, &llstate_1)) goto failed1;
{LLSTATE llstate_2;
if (!llterm('.', (LLSTYPE *)0, &llstate_1, &llstate_2)) goto failed1;
{LLSTATE llstate_3;XStrings llatt_3;
if (!ll_FieldName(&llatt_3, &llstate_2, &llstate_3, llatt_1)) goto failed1;
*llout = llstate_3;
{FieldSpec_t *fs;
	    fs = GetFieldSpecFromObjectClass((*llout).Assignments, llatt_1, llatt_3);
	    if (!fs) {
		(*llret) = NewType(eType_Undefined);
	    } else {
		switch (fs->Type) {
		case eFieldSpec_Type:
		case eFieldSpec_VariableTypeValue:
		case eFieldSpec_VariableTypeValueSet:
		    (*llret) = NewType(eType_Open);
		    break;
		case eFieldSpec_FixedTypeValue:
		    (*llret) = fs->U.FixedTypeValue.Type;
		    break;
		case eFieldSpec_FixedTypeValueSet:
		    (*llret) = fs->U.FixedTypeValueSet.Type;
		    break;
		case eFieldSpec_Object:
		    LLFAILED((&llstate_1.pos, "Object field not permitted"));
		    /*NOTREACHED*/
		case eFieldSpec_ObjectSet:
		    LLFAILED((&llstate_1.pos, "ObjectSet field not permitted"));
		    /*NOTREACHED*/
		default:
		    MyAbort();
		}
	    }
	
}}}}
LLDEBUG_LEAVE("ObjectClassFieldType", 1);
return 1;
failed1: LLDEBUG_LEAVE("ObjectClassFieldType", 0);
return 0;
}

int ll_ObjectClassFieldValue(XValue *llret, LLSTATE *llin, LLSTATE *llout, XType llarg_type)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("ObjectClassFieldValue");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("ObjectClassFieldValue", 1);
{LLSTATE llstate_1;XValue llatt_1;
if (!ll_OpenTypeFieldVal(&llatt_1, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = llatt_1;
	
break;
}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("ObjectClassFieldValue", 2);
{LLSTATE llstate_1;XValue llatt_1;
if (!ll_FixedTypeFieldVal(&llatt_1, &llstate_0, &llstate_1, llarg_type)) goto failed2;
*llout = llstate_1;
{(*llret) = llatt_1;
	
break;
}}
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("ObjectClassFieldValue");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("ObjectClassFieldValue", 1);
return 1;
failed1: LLDEBUG_LEAVE("ObjectClassFieldValue", 0);
return 0;
}

int ll_OpenTypeFieldVal(XValue *llret, LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("OpenTypeFieldVal");

llstate_0 = *llin;
#undef failed
#define failed failed1
{LLSTATE llstate_1;XType llatt_1;
if (!ll_Type(&llatt_1, &llstate_0, &llstate_1)) goto failed1;
{LLSTATE llstate_2;
if (!llterm(':', (LLSTYPE *)0, &llstate_1, &llstate_2)) goto failed1;
{LLSTATE llstate_3;XValue llatt_3;
if (!ll_Value(&llatt_3, &llstate_2, &llstate_3, llatt_1)) goto failed1;
*llout = llstate_3;
{(*llret) = llatt_3;
	
}}}}
LLDEBUG_LEAVE("OpenTypeFieldVal", 1);
return 1;
failed1: LLDEBUG_LEAVE("OpenTypeFieldVal", 0);
return 0;
}

int ll_FixedTypeFieldVal(XValue *llret, LLSTATE *llin, LLSTATE *llout, XType llarg_type)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("FixedTypeFieldVal");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("FixedTypeFieldVal", 1);
{LLSTATE llstate_1;XValue llatt_1;
if (!ll_BuiltinValue(&llatt_1, &llstate_0, &llstate_1, llarg_type)) goto failed2;
*llout = llstate_1;
{(*llret) = llatt_1;
	
break;
}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("FixedTypeFieldVal", 2);
{LLSTATE llstate_1;XValue llatt_1;
if (!ll_ReferencedValue(&llatt_1, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = llatt_1;
	
break;
}}
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("FixedTypeFieldVal");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("FixedTypeFieldVal", 1);
return 1;
failed1: LLDEBUG_LEAVE("FixedTypeFieldVal", 0);
return 0;
}

int ll_ValueFromObject(XValue *llret, LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("ValueFromObject");

llstate_0 = *llin;
#undef failed
#define failed failed1
{LLSTATE llstate_1;XObject llatt_1;
if (!ll_ReferencedObjects(&llatt_1, &llstate_0, &llstate_1)) goto failed1;
{LLSTATE llstate_2;
if (!llterm('.', (LLSTYPE *)0, &llstate_1, &llstate_2)) goto failed1;
{Object_t *o;
	    ObjectClass_t *oc;
	    o = GetObject(llstate_2.Assignments, llatt_1);
	    oc = o ? o->U.Object.ObjectClass : NULL;
	
{LLSTATE llstate_3;XStrings llatt_3;
if (!ll_FieldName(&llatt_3, &llstate_2, &llstate_3, oc)) goto failed1;
*llout = llstate_3;
{FieldSpec_t *fs;
	    FieldSpecs_e fe;
	    fs = GetFieldSpecFromObjectClass((*llout).Assignments, oc, llatt_3);
	    fe = GetFieldSpecType((*llout).Assignments, fs);
	    if (fe != eFieldSpec_Undefined &&
		fe != eFieldSpec_FixedTypeValue &&
		fe != eFieldSpec_VariableTypeValue)
		LLFAILED((&llstate_2.pos, "Bad field type"));
	    if (fe != eFieldSpec_Undefined) {
		(*llret) = GetValueFromObject((*llout).Assignments, llatt_1, llatt_3);
	    } else {
		(*llret) = NULL;
	    }
	
}}}}}
LLDEBUG_LEAVE("ValueFromObject", 1);
return 1;
failed1: LLDEBUG_LEAVE("ValueFromObject", 0);
return 0;
}

int ll_ValueSetFromObjects(XValueSet *llret, LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("ValueSetFromObjects");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("ValueSetFromObjects", 1);
{LLSTATE llstate_1;XObject llatt_1;
if (!ll_ReferencedObjects(&llatt_1, &llstate_0, &llstate_1)) goto failed2;
{LLSTATE llstate_2;
if (!llterm('.', (LLSTYPE *)0, &llstate_1, &llstate_2)) goto failed2;
{Object_t *o;
	    ObjectClass_t *oc;
	    o = GetObject(llstate_2.Assignments, llatt_1);
	    oc = o ? o->U.Object.ObjectClass : NULL;
	
{LLSTATE llstate_3;XStrings llatt_3;
if (!ll_FieldName(&llatt_3, &llstate_2, &llstate_3, oc)) goto failed2;
*llout = llstate_3;
{FieldSpec_t *fs;
	    FieldSpecs_e fe;
	    fs = GetFieldSpecFromObjectClass((*llout).Assignments, oc, llatt_3);
	    fe = GetFieldSpecType((*llout).Assignments, fs);
	    if (fe != eFieldSpec_Undefined &&
		fe != eFieldSpec_FixedTypeValueSet &&
		fe != eFieldSpec_VariableTypeValueSet)
		LLFAILED((&llstate_2.pos, "Bad field type"));
	    if (fe != eFieldSpec_Undefined) {
		(*llret) = GetValueSetFromObject((*llout).Assignments, llatt_1, llatt_3);
	    } else {
		(*llret) = NULL;
	    }
	
break;
}}}}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("ValueSetFromObjects", 2);
{LLSTATE llstate_1;XObjectSet llatt_1;
if (!ll_ReferencedObjectSets(&llatt_1, &llstate_0, &llstate_1)) goto failed2;
{LLSTATE llstate_2;
if (!llterm('.', (LLSTYPE *)0, &llstate_1, &llstate_2)) goto failed2;
{ObjectSet_t *os;
	    ObjectClass_t *oc;
	    os = GetObjectSet(llstate_2.Assignments, llatt_1);
	    oc = os && os->Type == eObjectSet_ObjectSet ?
	    	os->U.ObjectSet.ObjectClass : NULL;
	
{LLSTATE llstate_3;XStrings llatt_3;
if (!ll_FieldName(&llatt_3, &llstate_2, &llstate_3, oc)) goto failed2;
*llout = llstate_3;
{FieldSpec_t *fs;
	    FieldSpecs_e fe;
	    fs = GetFieldSpecFromObjectClass((*llout).Assignments, oc, llatt_3);
	    fe = GetFieldSpecType((*llout).Assignments, fs);
	    if (fe != eFieldSpec_Undefined &&
		fe != eFieldSpec_FixedTypeValue &&
		fe != eFieldSpec_FixedTypeValueSet)
		LLFAILED((&llstate_2.pos, "Bad field type"));
	    if (fe != eFieldSpec_Undefined) {
		(*llret) = GetValueSetFromObjectSet((*llout).Assignments, llatt_1, llatt_3);
	    } else {
		(*llret) = NULL;
	    }
	
break;
}}}}}
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("ValueSetFromObjects");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("ValueSetFromObjects", 1);
return 1;
failed1: LLDEBUG_LEAVE("ValueSetFromObjects", 0);
return 0;
}

int ll_TypeFromObject(XType *llret, LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("TypeFromObject");

llstate_0 = *llin;
#undef failed
#define failed failed1
{LLSTATE llstate_1;XObject llatt_1;
if (!ll_ReferencedObjects(&llatt_1, &llstate_0, &llstate_1)) goto failed1;
{LLSTATE llstate_2;
if (!llterm('.', (LLSTYPE *)0, &llstate_1, &llstate_2)) goto failed1;
{Object_t *o;
	    ObjectClass_t *oc;
	    o = GetObject(llstate_2.Assignments, llatt_1);
	    oc = o ? o->U.Object.ObjectClass : NULL;
	
{LLSTATE llstate_3;XStrings llatt_3;
if (!ll_FieldName(&llatt_3, &llstate_2, &llstate_3, oc)) goto failed1;
*llout = llstate_3;
{FieldSpec_t *fs;
	    FieldSpecs_e fe;
	    fs = GetFieldSpecFromObjectClass((*llout).Assignments, oc, llatt_3);
	    fe = GetFieldSpecType((*llout).Assignments, fs);
	    if (fe != eFieldSpec_Undefined &&
		fe != eFieldSpec_Type)
		LLFAILED((&llstate_2.pos, "Bad field type"));
	    if (fe != eFieldSpec_Undefined)
		(*llret) = GetTypeFromObject((*llout).Assignments, llatt_1, llatt_3);
	    else
		(*llret) = NULL;
	
}}}}}
LLDEBUG_LEAVE("TypeFromObject", 1);
return 1;
failed1: LLDEBUG_LEAVE("TypeFromObject", 0);
return 0;
}

int ll_ObjectFromObject(XObject *llret, LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("ObjectFromObject");

llstate_0 = *llin;
#undef failed
#define failed failed1
{LLSTATE llstate_1;XObject llatt_1;
if (!ll_ReferencedObjects(&llatt_1, &llstate_0, &llstate_1)) goto failed1;
{LLSTATE llstate_2;
if (!llterm('.', (LLSTYPE *)0, &llstate_1, &llstate_2)) goto failed1;
{Object_t *o;
	    ObjectClass_t *oc;
	    o = GetObject(llstate_2.Assignments, llatt_1);
	    oc = o ? o->U.Object.ObjectClass : NULL;
	
{LLSTATE llstate_3;XStrings llatt_3;
if (!ll_FieldName(&llatt_3, &llstate_2, &llstate_3, oc)) goto failed1;
*llout = llstate_3;
{FieldSpec_t *fs;
	    FieldSpecs_e fe;
	    fs = GetFieldSpecFromObjectClass((*llout).Assignments, oc, llatt_3);
	    fe = GetFieldSpecType((*llout).Assignments, fs);
	    if (fe != eFieldSpec_Undefined &&
		fe != eFieldSpec_Object)
		LLFAILED((&llstate_2.pos, "Bad field type"));
	    if (fe != eFieldSpec_Undefined)
		(*llret) = GetObjectFromObject((*llout).Assignments, llatt_1, llatt_3);
	    else
		(*llret) = NULL;
	
}}}}}
LLDEBUG_LEAVE("ObjectFromObject", 1);
return 1;
failed1: LLDEBUG_LEAVE("ObjectFromObject", 0);
return 0;
}

int ll_ObjectSetFromObjects(XObjectSet *llret, LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("ObjectSetFromObjects");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("ObjectSetFromObjects", 1);
{LLSTATE llstate_1;XObject llatt_1;
if (!ll_ReferencedObjects(&llatt_1, &llstate_0, &llstate_1)) goto failed2;
{LLSTATE llstate_2;
if (!llterm('.', (LLSTYPE *)0, &llstate_1, &llstate_2)) goto failed2;
{Object_t *o;
	    ObjectClass_t *oc;
	    o = GetObject(llstate_2.Assignments, llatt_1);
	    oc = o ? o->U.Object.ObjectClass : NULL;
	
{LLSTATE llstate_3;XStrings llatt_3;
if (!ll_FieldName(&llatt_3, &llstate_2, &llstate_3, oc)) goto failed2;
*llout = llstate_3;
{FieldSpec_t *fs;
	    FieldSpecs_e fe;
	    fs = GetFieldSpecFromObjectClass((*llout).Assignments, oc, llatt_3);
	    fe = GetFieldSpecType((*llout).Assignments, fs);
	    if (fe != eFieldSpec_Undefined &&
		fe != eFieldSpec_ObjectSet)
		LLFAILED((&llstate_2.pos, "Bad field type"));
	    if (fe != eFieldSpec_Undefined)
		(*llret) = GetObjectSetFromObject((*llout).Assignments, llatt_1, llatt_3);
	    else
		(*llret) = NULL;
	
break;
}}}}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("ObjectSetFromObjects", 2);
{LLSTATE llstate_1;XObjectSet llatt_1;
if (!ll_ReferencedObjectSets(&llatt_1, &llstate_0, &llstate_1)) goto failed2;
{LLSTATE llstate_2;
if (!llterm('.', (LLSTYPE *)0, &llstate_1, &llstate_2)) goto failed2;
{ObjectSet_t *os;
	    ObjectClass_t *oc;
	    os = GetObjectSet(llstate_2.Assignments, llatt_1);
	    oc = os ? os->U.OE.ObjectClass : NULL;
	
{LLSTATE llstate_3;XStrings llatt_3;
if (!ll_FieldName(&llatt_3, &llstate_2, &llstate_3, oc)) goto failed2;
*llout = llstate_3;
{FieldSpec_t *fs;
	    FieldSpecs_e fe;
	    fs = GetFieldSpecFromObjectClass((*llout).Assignments, oc, llatt_3);
	    fe = GetFieldSpecType((*llout).Assignments, fs);
	    if (fe != eFieldSpec_Undefined &&
		fe != eFieldSpec_Object &&
		fe != eFieldSpec_ObjectSet)
		LLFAILED((&llstate_2.pos, "Bad field type"));
	    if (fe != eFieldSpec_Undefined)
		(*llret) = GetObjectSetFromObjectSet((*llout).Assignments, llatt_1, llatt_3);
	    else
		(*llret) = NULL;
	
break;
}}}}}
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("ObjectSetFromObjects");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("ObjectSetFromObjects", 1);
return 1;
failed1: LLDEBUG_LEAVE("ObjectSetFromObjects", 0);
return 0;
}

int ll_ReferencedObjects(XObject *llret, LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("ReferencedObjects");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("ReferencedObjects", 1);
{LLSTATE llstate_1;XObject llatt_1;
if (!ll_DefinedObject(&llatt_1, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = llatt_1;
	
break;
}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("ReferencedObjects", 2);
{LLSTATE llstate_1;
if (!ll_ParameterizedObject(&llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{MyAbort();
	
break;
}}
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("ReferencedObjects");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("ReferencedObjects", 1);
return 1;
failed1: LLDEBUG_LEAVE("ReferencedObjects", 0);
return 0;
}

int ll_ReferencedObjectSets(XObjectSet *llret, LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("ReferencedObjectSets");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("ReferencedObjectSets", 1);
{LLSTATE llstate_1;XObjectSet llatt_1;
if (!ll_DefinedObjectSet(&llatt_1, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = llatt_1;
	
break;
}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("ReferencedObjectSets", 2);
{LLSTATE llstate_1;
if (!ll_ParameterizedObjectSet(&llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{MyAbort();
	
break;
}}
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("ReferencedObjectSets");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("ReferencedObjectSets", 1);
return 1;
failed1: LLDEBUG_LEAVE("ReferencedObjectSets", 0);
return 0;
}

int ll_InstanceOfType(XType *llret, LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("InstanceOfType");

llstate_0 = *llin;
#undef failed
#define failed failed1
{LLSTATE llstate_1;
if (!llterm(T_INSTANCE, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed1;
{LLSTATE llstate_2;
if (!llterm(T_OF, (LLSTYPE *)0, &llstate_1, &llstate_2)) goto failed1;
{LLSTATE llstate_3;XObjectClass llatt_3;
if (!ll_DefinedObjectClass(&llatt_3, &llstate_2, &llstate_3)) goto failed1;
*llout = llstate_3;
{Component_t *co1, *co2;
	    Type_t *ty;
	    (*llret) = NewType(eType_InstanceOf);
	    (*llret)->U.Sequence.Components = co1 = NewComponent(eComponent_Normal);
	    co1->Next = co2 = NewComponent(eComponent_Normal);
	    ty = NewType(eType_FieldReference);
	    ty->U.FieldReference.Identifier = "&id";
	    ty->U.FieldReference.ObjectClass = llatt_3;
	    co1->U.Normal.NamedType = NewNamedType("type-id", ty);
	    ty = NewType(eType_FieldReference);
	    ty->Tags = NewTag(eTagType_Explicit);
	    ty->Tags->Tag = Builtin_Value_Integer_0;
	    ty->U.FieldReference.Identifier = "&Type";
	    ty->U.FieldReference.ObjectClass = llatt_3;
	    co2->U.Normal.NamedType = NewNamedType("value", ty);
	
}}}}
LLDEBUG_LEAVE("InstanceOfType", 1);
return 1;
failed1: LLDEBUG_LEAVE("InstanceOfType", 0);
return 0;
}

int ll_InstanceOfValue(XValue *llret, LLSTATE *llin, LLSTATE *llout, XType llarg_type)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("InstanceOfValue");

llstate_0 = *llin;
#undef failed
#define failed failed1
{LLSTATE llstate_1;XValue llatt_1;
if (!ll_SequenceValue(&llatt_1, &llstate_0, &llstate_1, llarg_type)) goto failed1;
*llout = llstate_1;
{(*llret) = llatt_1;
	
}}
LLDEBUG_LEAVE("InstanceOfValue", 1);
return 1;
failed1: LLDEBUG_LEAVE("InstanceOfValue", 0);
return 0;
}

int ll_MacroDefinition(LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("MacroDefinition");

llstate_0 = *llin;
#undef failed
#define failed failed1
{LLSTATE llstate_1;
if (!llterm(T_DUM_XXX1, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed1;
*llout = llstate_1;
{MyAbort(); 
}}
LLDEBUG_LEAVE("MacroDefinition", 1);
return 1;
failed1: LLDEBUG_LEAVE("MacroDefinition", 0);
return 0;
}

int ll_MacroDefinedType(XType *llret, LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("MacroDefinedType");

llstate_0 = *llin;
#undef failed
#define failed failed1
{LLSTATE llstate_1;
if (!llterm(T_DUM_XXX2, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed1;
*llout = llstate_1;
{MyAbort(); 
}}
LLDEBUG_LEAVE("MacroDefinedType", 1);
return 1;
failed1: LLDEBUG_LEAVE("MacroDefinedType", 0);
return 0;
}

int ll_MacroDefinedValue(XValue *llret, LLSTATE *llin, LLSTATE *llout, XType llarg_type)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("MacroDefinedValue");

llstate_0 = *llin;
#undef failed
#define failed failed1
{LLSTATE llstate_1;
if (!llterm(T_DUM_XXX3, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed1;
*llout = llstate_1;
{MyAbort(); 
}}
LLDEBUG_LEAVE("MacroDefinedValue", 1);
return 1;
failed1: LLDEBUG_LEAVE("MacroDefinedValue", 0);
return 0;
}

int ll_ParameterizedValueSetType(LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("ParameterizedValueSetType");

llstate_0 = *llin;
#undef failed
#define failed failed1
{LLSTATE llstate_1;
if (!llterm(T_DUM_XXX4, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed1;
*llout = llstate_1;
{MyAbort(); 
}}
LLDEBUG_LEAVE("ParameterizedValueSetType", 1);
return 1;
failed1: LLDEBUG_LEAVE("ParameterizedValueSetType", 0);
return 0;
}

int ll_ParameterizedReference(LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("ParameterizedReference");

llstate_0 = *llin;
#undef failed
#define failed failed1
{LLSTATE llstate_1;
if (!llterm(T_DUM_XXX5, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed1;
*llout = llstate_1;
{MyAbort(); 
}}
LLDEBUG_LEAVE("ParameterizedReference", 1);
return 1;
failed1: LLDEBUG_LEAVE("ParameterizedReference", 0);
return 0;
}

int ll_ParameterizedType(LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("ParameterizedType");

llstate_0 = *llin;
#undef failed
#define failed failed1
{LLSTATE llstate_1;
if (!llterm(T_DUM_XXX7, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed1;
*llout = llstate_1;
{MyAbort(); 
}}
LLDEBUG_LEAVE("ParameterizedType", 1);
return 1;
failed1: LLDEBUG_LEAVE("ParameterizedType", 0);
return 0;
}

int ll_ParameterizedValue(LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("ParameterizedValue");

llstate_0 = *llin;
#undef failed
#define failed failed1
{LLSTATE llstate_1;
if (!llterm(T_DUM_XXX9, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed1;
*llout = llstate_1;
{MyAbort(); 
}}
LLDEBUG_LEAVE("ParameterizedValue", 1);
return 1;
failed1: LLDEBUG_LEAVE("ParameterizedValue", 0);
return 0;
}

int ll_ParameterizedAssignment(LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("ParameterizedAssignment");

llstate_0 = *llin;
#undef failed
#define failed failed1
{LLSTATE llstate_1;
if (!llterm(T_DUM_XXX16, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed1;
*llout = llstate_1;
{MyAbort(); 
}}
LLDEBUG_LEAVE("ParameterizedAssignment", 1);
return 1;
failed1: LLDEBUG_LEAVE("ParameterizedAssignment", 0);
return 0;
}

int ll_ParameterizedObjectClass(LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("ParameterizedObjectClass");

llstate_0 = *llin;
#undef failed
#define failed failed1
{LLSTATE llstate_1;
if (!llterm(T_DUM_XXX17, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed1;
*llout = llstate_1;
{MyAbort(); 
}}
LLDEBUG_LEAVE("ParameterizedObjectClass", 1);
return 1;
failed1: LLDEBUG_LEAVE("ParameterizedObjectClass", 0);
return 0;
}

int ll_ParameterizedObject(LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("ParameterizedObject");

llstate_0 = *llin;
#undef failed
#define failed failed1
{LLSTATE llstate_1;
if (!llterm(T_DUM_XXX2, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed1;
*llout = llstate_1;
{MyAbort(); 
}}
LLDEBUG_LEAVE("ParameterizedObject", 1);
return 1;
failed1: LLDEBUG_LEAVE("ParameterizedObject", 0);
return 0;
}

int ll_ParameterizedObjectSet(LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("ParameterizedObjectSet");

llstate_0 = *llin;
#undef failed
#define failed failed1
{LLSTATE llstate_1;
if (!llterm(T_DUM_XXX12, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed1;
*llout = llstate_1;
{MyAbort(); 
}}
LLDEBUG_LEAVE("ParameterizedObjectSet", 1);
return 1;
failed1: LLDEBUG_LEAVE("ParameterizedObjectSet", 0);
return 0;
}


int
llparser(LLTERM *tokens, unsigned ntokens, LLSTATE *llin, LLSTATE *llout)
{
unsigned i;
LLDEBUG_ENTER("llparser");
lltokens = tokens; llntokens = ntokens;
for (i = 0; i < llstksize; i++) llstk[i] = 1;
llcstp = 1; llcpos = 0; llepos = 0; *llerrormsg = 0;
#if LLDEBUG > 0
last_linenr = 0; last_file = "";
#endif
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
if (!ll_Main(llin, llout)) goto failed2;
if (llcpos != llntokens) goto failed2;
break;
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("llparser");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("llparser", 1);
return 1;
failed1:
LLDEBUG_LEAVE("llparser", 0);
return 0;
}

int
llterm(int token, LLSTYPE *lval, LLSTATE *llin, LLSTATE *llout)
{
#if LLDEBUG > 0
	if (lldebug > 0 && (lltokens[llcpos].pos.line > last_linenr || strcmp(lltokens[llcpos].pos.file, last_file))) {
	fprintf(stderr, "File \"%s\", Line %5d                    \r",
		lltokens[llcpos].pos.file, lltokens[llcpos].pos.line);
	last_linenr = lltokens[llcpos].pos.line / 10 * 10 + 9;
	last_file = lltokens[llcpos].pos.file;
	}
#endif
	if (llstk[llcstp] != 1 && llstk[llcstp] != -1) {
		LLDEBUG_BACKTRACKING("llterm");
		llstk[llcstp] = 1;
		return 0;
	}
	LLDEBUG_TOKEN(token, llcpos);
	if (llcpos < llntokens && lltokens[llcpos].token == token) {
		if (lval)
			*lval = lltokens[llcpos].lval;
		*llout = *llin;
		llout->pos = lltokens[llcpos].pos;
		llcpos++;
		LLCHECKSTK;
		llcstp++;
		return 1;
	}
	llfailed(&lltokens[llcpos].pos, NULL);
	llstk[llcstp] = 1;
	return 0;
}

int
llanyterm(LLSTYPE *lval, LLSTATE *llin, LLSTATE *llout)
{
#if LLDEBUG > 0
	if (lldebug > 0 && (lltokens[llcpos].pos.line > last_linenr || strcmp(lltokens[llcpos].pos.file, last_file))) {
	fprintf(stderr, "File \"%s\", Line %5d                    \r",
		lltokens[llcpos].pos.file, lltokens[llcpos].pos.line);
	last_linenr = lltokens[llcpos].pos.line / 10 * 10 + 9;
	last_file = lltokens[llcpos].pos.file;
	}
#endif
	if (llstk[llcstp] != 1 && llstk[llcstp] != -1) {
		LLDEBUG_BACKTRACKING("llanyterm");
		llstk[llcstp] = 1;
		return 0;
	}
	LLDEBUG_ANYTOKEN(llcpos);
	if (llcpos < llntokens) {
		if (lval)
			*lval = lltokens[llcpos].lval;
		*llout = *llin;
		llout->pos = lltokens[llcpos].pos;
		llcpos++;
		LLCHECKSTK;
		llcstp++;
		return 1;
	}
	llfailed(&lltokens[llcpos].pos, NULL);
	llstk[llcstp] = 1;
	return 0;
}
void
llscanner(LLTERM **tokens, unsigned *ntokens)
{
	unsigned i = 0;
#if LLDEBUG > 0
	int line = -1;
#endif

	*ntokens = 1024;
	*tokens = (LLTERM *)malloc(*ntokens * sizeof(LLTERM));
	while (llgettoken(&(*tokens)[i].token, &(*tokens)[i].lval, &(*tokens)[i].pos)) {
#if LLDEBUG > 0
		if (lldebug > 0 && (*tokens)[i].pos.line > line) {
			line = (*tokens)[i].pos.line / 10 * 10 + 9;
			fprintf(stderr, "File \"%s\", Line %5d                    \r",
				(*tokens)[i].pos.file, (*tokens)[i].pos.line);
		}
#endif
		if (++i >= *ntokens) {
			*ntokens *= 2;
			*tokens = (LLTERM *)realloc(*tokens, *ntokens * sizeof(LLTERM));
		}
	}
	(*tokens)[i].token = 0;
	*ntokens = i;
#if LLDEBUG > 0
	lldebug_init();
#endif
	llresizestk();
}

void
llfailed(LLPOS *pos, char *fmt, ...)
{
	va_list args;

	va_start(args, fmt);
	if (llcpos > llepos || llcpos == llepos && !*llerrormsg) {
		llepos = llcpos;
		if (fmt)
			vsprintf(llerrormsg, fmt, args);
		else
			*llerrormsg = 0;
		llerrorpos = *pos;
	}
	va_end(args);
}

void
llprinterror(FILE *f)
{
#if LLDEBUG > 0
	fputs("                                \r", stderr);
#endif
	if (*llerrormsg)
		llerror(f, &llerrorpos, llerrormsg);
	else
		llerror(f, &llerrorpos, "Syntax error");
}

void
llerror(FILE *f, LLPOS *pos, char *fmt, ...)
{
	va_list args;
	va_start(args, fmt);
	llverror(f, pos, fmt, args);
	va_end(args);
}

void
llresizestk()
{
	unsigned i;

	if (llcstp + 1 >= llstksize) {
		i = llstksize;
		if (!llstksize)
			llstk = (int *)malloc((llstksize = 4096) * sizeof(int));
		else
			llstk = (int *)realloc(llstk, (llstksize *= 2) * sizeof(int));
		for (; i < llstksize; i++)
			llstk[i] = 1;
	}
}

#if LLDEBUG > 0
int lldepth;
char *lltokentab[] = {
"EOF","#1","#2","#3","#4","#5","#6","#7"
,"#8","#9","#10","#11","#12","#13","#14","#15"
,"#16","#17","#18","#19","#20","#21","#22","#23"
,"#24","#25","#26","#27","#28","#29","#30","#31"
,"' '","'!'","'\"'","'#'","'$'","'%'","'&'","'''"
,"'('","')'","'*'","'+'","','","'-'","'.'","'/'"
,"'0'","'1'","'2'","'3'","'4'","'5'","'6'","'7'"
,"'8'","'9'","':'","';'","'<'","'='","'>'","'?'"
,"'@'","'A'","'B'","'C'","'D'","'E'","'F'","'G'"
,"'H'","'I'","'J'","'K'","'L'","'M'","'N'","'O'"
,"'P'","'Q'","'R'","'S'","'T'","'U'","'V'","'W'"
,"'X'","'Y'","'Z'","'['","'\\'","']'","'^'","'_'"
,"'`'","'a'","'b'","'c'","'d'","'e'","'f'","'g'"
,"'h'","'i'","'j'","'k'","'l'","'m'","'n'","'o'"
,"'p'","'q'","'r'","'s'","'t'","'u'","'v'","'w'"
,"'x'","'y'","'z'","'{'","'|'","'}'","'~'","#127"
,"#128","#129","#130","#131","#132","#133","#134","#135"
,"#136","#137","#138","#139","#140","#141","#142","#143"
,"#144","#145","#146","#147","#148","#149","#150","#151"
,"#152","#153","#154","#155","#156","#157","#158","#159"
,"#160","#161","#162","#163","#164","#165","#166","#167"
,"#168","#169","#170","#171","#172","#173","#174","#175"
,"#176","#177","#178","#179","#180","#181","#182","#183"
,"#184","#185","#186","#187","#188","#189","#190","#191"
,"#192","#193","#194","#195","#196","#197","#198","#199"
,"#200","#201","#202","#203","#204","#205","#206","#207"
,"#208","#209","#210","#211","#212","#213","#214","#215"
,"#216","#217","#218","#219","#220","#221","#222","#223"
,"#224","#225","#226","#227","#228","#229","#230","#231"
,"#232","#233","#234","#235","#236","#237","#238","#239"
,"#240","#241","#242","#243","#244","#245","#246","#247"
,"#248","#249","#250","#251","#252","#253","#254","#255"
,"#256","\"::=\"","\"..\"","\"...\"","\"TYPE-IDENTIFIER\"","\"ABSTRACT-SYNTAX\"","\"--$zero-terminated--\"","\"--$pointer--\""
,"\"--$no-pointer--\"","\"--$fixed-array--\"","\"--$singly-linked-list--\"","\"--$doubly-linked-list--\"","\"--$length-pointer--\"","\"number\"","number","bstring"
,"hstring","cstring","only_uppercase_symbol","only_uppercase_digits_symbol","uppercase_symbol","lcsymbol","ampucsymbol","amplcsymbol"
,"CON_XXX1","CON_XXX2","OBJ_XXX1","OBJ_XXX2","OBJ_XXX3","OBJ_XXX4","OBJ_XXX5","OBJ_XXX6"
,"OBJ_XXX7","DUM_XXX1","DUM_XXX2","DUM_XXX3","DUM_XXX4","DUM_XXX5","DUM_XXX6","DUM_XXX7"
,"DUM_XXX8","DUM_XXX9","DUM_XXX10","DUM_XXX11","DUM_XXX12","DUM_XXX13","DUM_XXX14","DUM_XXX15"
,"DUM_XXX16","DUM_XXX17","DUM_XXX18","DUM_XXX19","DUM_XXX20","\"DEFINITIONS\"","\"BEGIN\"","\"END\""
,"\"EXPLICIT\"","\"TAGS\"","\"IMPLICIT\"","\"AUTOMATIC\"","\"EXTENSIBILITY\"","\"IMPLIED\"","\"EXPORTS\"","\"IMPORTS\""
,"\"FROM\"","\"ABSENT\"","\"ALL\"","\"ANY\"","\"APPLICATION\"","\"BMPString\"","\"BY\"","\"CLASS\""
,"\"COMPONENT\"","\"COMPONENTS\"","\"CONSTRAINED\"","\"DEFAULT\"","\"DEFINED\"","\"empty\"","\"EXCEPT\"","\"GeneralizedTime\""
,"\"GeneralString\"","\"GraphicString\"","\"IA5String\"","\"IDENTIFIER\"","\"identifier\"","\"INCLUDES\"","\"ISO646String\"","\"MACRO\""
,"\"MAX\"","\"MIN\"","\"NOTATION\"","\"NumericString\"","\"ObjectDescriptor\"","\"OF\"","\"OPTIONAL\"","\"PDV\""
,"\"PRESENT\"","\"PrintableString\"","\"PRIVATE\"","\"SIZE\"","\"STRING\"","\"string\"","\"SYNTAX\"","\"T61String\""
,"\"TeletexString\"","\"TYPE\"","\"type\"","\"UNIQUE\"","\"UNIVERSAL\"","\"UniversalString\"","\"UTCTime\"","\"UTF8String\""
,"\"VALUE\"","\"value\"","\"VideotexString\"","\"VisibleString\"","\"WITH\"","\"BOOLEAN\"","\"INTEGER\"","\"ENUMERATED\""
,"\"REAL\"","\"BIT\"","\"OCTET\"","\"NULL\"","\"SEQUENCE\"","\"SET\"","\"CHOICE\"","\"OBJECT\""
,"\"EMBEDDED\"","\"EXTERNAL\"","\"CHARACTER\"","\"TRUE\"","\"FALSE\"","\"PLUS_INFINITY\"","\"MINUS_INFINITY\"","\"UNION\""
,"\"INTERSECTION\"","\"PrivateDir_TypeName\"","\"PrivateDir_FieldName\"","\"PrivateDir_ValueName\"","\"PrivateDir_Public\"","\"PrivateDir_Intx\"","\"PrivateDir_LenPtr\"","\"PrivateDir_Pointer\""
,"\"PrivateDir_Array\"","\"PrivateDir_NoCode\"","\"PrivateDir_NoMemCopy\"","\"PrivateDir_OidPacked\"","\"PrivateDir_OidArray\"","\"PrivateDir_SLinked\"","\"PrivateDir_DLinked\"","\"INSTANCE\""
};

void
lldebug_init()
{
	char *p;
	p = getenv("LLDEBUG");
	if (p)
		lldebug = atoi(p);
}

void
lldebug_enter(char *ident)
{
	int i;

	if (lldebug < 2)
		return;
	for (i = 0; i < lldepth; i++)
		fputs("| ", stdout);
	printf("/--- trying rule %s\n", ident);
	lldepth++;
}

void
lldebug_leave(char *ident, int succ)
{
	int i;

	if (lldebug < 2)
		return;
	lldepth--;
	for (i = 0; i < lldepth; i++)
		fputs("| ", stdout);
	if (succ)
		printf("\\--- succeeded to apply rule %s\n", ident);
	else
		printf("\\--- failed to apply rule %s\n", ident);
}

void
lldebug_alternative(char *ident, int alt)
{
	int i;

	if (lldebug < 2)
		return;
	for (i = 0; i < lldepth - 1; i++)
		fputs("| ", stdout);
	printf(">--- trying alternative %d for rule %s\n", alt, ident);
}

lldebug_iteration(char *ident, int num)
{
	int i;

	if (lldebug < 2)
		return;
	for (i = 0; i < lldepth - 1; i++)
		fputs("| ", stdout);
	printf(">--- trying iteration %d for rule %s\n", num, ident);
}

void
lldebug_token(int expected, unsigned pos)
{
	int i;

	if (lldebug < 2)
		return;
	for (i = 0; i < lldepth; i++)
		fputs("| ", stdout);
	if (pos < llntokens && expected == lltokens[pos].token)
		printf("   found token ");
	else
		printf("   expected token %s, found token ", lltokentab[expected]);
	if (pos >= llntokens)
		printf("<EOF>");
	else
		llprinttoken(lltokens + pos, lltokentab[lltokens[pos].token], stdout);
	putchar('\n');
}

void
lldebug_anytoken(unsigned pos)
{
	int i;

	if (lldebug < 2)
		return;
	for (i = 0; i < lldepth; i++)
		fputs("| ", stdout);
	printf("   found token ");
	if (pos >= llntokens)
		printf("<EOF>");
	else
		llprinttoken(lltokens + pos, lltokentab[lltokens[pos].token], stdout);
	putchar('\n');
}

void
lldebug_backtracking(char *ident)
{
	int i;

	if (lldebug < 2)
		return;
	for (i = 0; i < lldepth; i++)
		fputs("| ", stdout);
	printf("   backtracking rule %s\n", ident);
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\asn1\asn1c\types.c ===
/* Copyright (C) Boris Nikolaus, Germany, 1996-1997. All rights reserved. */
/* Copyright (C) Microsoft Corporation, 1997-1998. All rights reserved. */

// lonchanc: when we call any routine in this file, we must use kernel memory,
// otheriwse, the client app should free the buffer in its entirety
// rather than free the structure piece by piece.

#include "precomp.h"

#include <stdio.h>
#include <stdlib.h>
#include <math.h>
#include <string.h>
#include <ctype.h>

#if HAS_IEEEFP_H
#include <ieeefp.h>
#elif HAS_FLOAT_H
#include <float.h>
#endif

ASN1octet_t ASN1double_pinf_octets[] = DBL_PINF;
ASN1octet_t ASN1double_minf_octets[] = DBL_MINF;

/* get a positive infinite double value */
double ASN1double_pinf()
{
    union {
        double val;
        ASN1octet_t octets[1];
    } mix;
    memcpy(mix.octets, ASN1double_pinf_octets, sizeof(ASN1double_pinf_octets));
    return mix.val;
}

/* get a negative infinite double value */
double ASN1double_minf()
{
    union {
        double val;
        ASN1octet_t octets[1];
    } mix;
    memcpy(mix.octets, ASN1double_minf_octets, sizeof(ASN1double_minf_octets));
    return mix.val;
}

/* check if double is plus infinity */
int ASN1double_ispinf(double d)
{
#if HAS_FPCLASS
    return !finite(d) && fpclass(d) == FP_PINF;
#elif HAS_ISINF
    return !finite(d) && isinf(d) && copysign(1.0, d) > 0.0;
#else
#error "cannot encode NaN fp values"
#endif
}

/* check if double is minus infinity */
int ASN1double_isminf(double d)
{
#if HAS_FPCLASS
    return !finite(d) && fpclass(d) == FP_NINF;
#elif HAS_ISINF
    return !finite(d) && isinf(d) && copysign(1.0, d) < 0.0;
#else
#error "cannot encode NaN fp values"
#endif
}

/* convert a real value into a double */
double ASN1real2double(ASN1real_t *val)
{
    ASN1intx_t exp;
    ASN1int32_t e;
    double m;

    switch (val->type) {
    case eReal_Normal:
        m = ASN1intx2double(&val->mantissa);
        if (val->base == 10) {
            return m * pow(10.0, (double)ASN1intx2int32(&val->exponent));
        } else {
            if (val->base == 2) {
                ASN1intx_dup(&exp, &val->exponent);
            } else if (val->base == 8) {
                ASN1intx_muloctet(&exp, &val->exponent, 3);
            } else if (val->base == 16) {
                ASN1intx_muloctet(&exp, &val->exponent, 4);
            } else {
                return 0.0;
            }
            e = ASN1intx2int32(&exp);
            ASN1intx_free(&exp);
            return ldexp(m, e);
        }
    case eReal_PlusInfinity:
        return ASN1double_pinf();
    case eReal_MinusInfinity:
        return ASN1double_minf();
    default:
        return 0.0;
    }
}

/* free a real value */
void ASN1real_free(ASN1real_t *val)
{
    ASN1intx_free(&val->mantissa);
    ASN1intx_free(&val->exponent);
}

/* free a bitstring value */
void ASN1bitstring_free(ASN1bitstring_t *val)
{
    if (val->length)
        free(val->value);
}

/* free an octet string value */
void ASN1octetstring_free(ASN1octetstring_t *val)
{
    if (val->length)
        free(val->value);
}

/* free an object identifier value */
void ASN1objectidentifier_free(ASN1objectidentifier_t *val)
{
    // lonchanc: we allocate the entire object identifer as a chunk.
    // as a result, we free it only once as a chunk.
    if (*val)
        free(*val);
}

/* free a string value */
void ASN1charstring_free(ASN1charstring_t *val)
{
    if (val->length)
        free(val->value);
}

/* free a 16 bit string value */
void ASN1char16string_free(ASN1char16string_t *val)
{
    if (val->length)
        free(val->value);
}

/* free a 32 bit string value */
void ASN1char32string_free(ASN1char32string_t *val)
{
    if (val->length)
        free(val->value);
}

/* free a zero-terminated string value */
void ASN1ztcharstring_free(ASN1ztcharstring_t val)
{
    free(val);
}

/* free a zero-terminated 16 bit string value */
void ASN1ztchar16string_free(ASN1ztchar16string_t val)
{
    free(val);
}

/* free a zero-terminated 32 bit string value */
void ASN1ztchar32string_free(ASN1ztchar32string_t val)
{
    free(val);
}

/* free an external value */
void ASN1external_free(ASN1external_t *val)
{
    switch (val->identification.o) {
    case ASN1external_identification_syntax_o:
        ASN1objectidentifier_free(&val->identification.u.syntax);
        break;
    case ASN1external_identification_presentation_context_id_o:
        break;
    case ASN1external_identification_context_negotiation_o:
        ASN1objectidentifier_free(
            &val->identification.u.context_negotiation.transfer_syntax);
        break;
    }
    ASN1ztcharstring_free(val->data_value_descriptor);
    switch (val->data_value.o) {
    case ASN1external_data_value_notation_o:
        ASN1open_free(&val->data_value.u.notation);
        break;
    case ASN1external_data_value_encoded_o:
        ASN1bitstring_free(&val->data_value.u.encoded);
        break;
    }
}

/* free an embedded pdv value */
void ASN1embeddedpdv_free(ASN1embeddedpdv_t *val)
{
    switch (val->identification.o) {
    case ASN1embeddedpdv_identification_syntaxes_o:
        ASN1objectidentifier_free(&val->identification.u.syntaxes.abstract);
        ASN1objectidentifier_free(&val->identification.u.syntaxes.transfer);
        break;
    case ASN1embeddedpdv_identification_syntax_o:
        ASN1objectidentifier_free(&val->identification.u.syntax);
        break;
    case ASN1embeddedpdv_identification_presentation_context_id_o:
        break;
    case ASN1embeddedpdv_identification_context_negotiation_o:
        ASN1objectidentifier_free(
            &val->identification.u.context_negotiation.transfer_syntax);
        break;
    case ASN1embeddedpdv_identification_transfer_syntax_o:
        ASN1objectidentifier_free(&val->identification.u.transfer_syntax);
        break;
    case ASN1embeddedpdv_identification_fixed_o:
        break;
    }
    switch (val->data_value.o) {
    case ASN1embeddedpdv_data_value_notation_o:
        ASN1open_free(&val->data_value.u.notation);
        break;
    case ASN1embeddedpdv_data_value_encoded_o:
        ASN1bitstring_free(&val->data_value.u.encoded);
        break;
    }
}

/* free a character string value */
void ASN1characterstring_free(ASN1characterstring_t *val)
{
    switch (val->identification.o) {
    case ASN1characterstring_identification_syntaxes_o:
        ASN1objectidentifier_free(&val->identification.u.syntaxes.abstract);
        ASN1objectidentifier_free(&val->identification.u.syntaxes.transfer);
        break;
    case ASN1characterstring_identification_syntax_o:
        ASN1objectidentifier_free(&val->identification.u.syntax);
        break;
    case ASN1characterstring_identification_presentation_context_id_o:
        break;
    case ASN1characterstring_identification_context_negotiation_o:
        ASN1objectidentifier_free(
            &val->identification.u.context_negotiation.transfer_syntax);
        break;
    case ASN1characterstring_identification_transfer_syntax_o:
        ASN1objectidentifier_free(&val->identification.u.transfer_syntax);
        break;
    case ASN1characterstring_identification_fixed_o:
        break;
    }
    switch (val->data_value.o) {
    case ASN1characterstring_data_value_notation_o:
        ASN1open_free(&val->data_value.u.notation);
        break;
    case ASN1characterstring_data_value_encoded_o:
        ASN1octetstring_free(&val->data_value.u.encoded);
        break;
    }
}

/* free an open type value */
void ASN1open_free(ASN1open_t *val)
{
    if (val->length)
        free(val->encoded);
}

/* convert a generalized time value into a string */
int ASN1generalizedtime2string(char *dst, ASN1generalizedtime_t *val)
{
    sprintf(dst, "%04d%02d%02d%02d%02d%02d",
        val->year, val->month, val->day,
        val->hour, val->minute, val->second);
    if (val->millisecond) {
        if (!(val->millisecond % 100))
            sprintf(dst + 14, ".%01d", val->millisecond / 100);
        else if (!(val->millisecond % 10))
            sprintf(dst + 14, ".%02d", val->millisecond / 10);
        else
            sprintf(dst + 14, ".%03d", val->millisecond);
    }
    if (val->universal)
        strcpy(dst + strlen(dst), "Z");
    else if (val->diff > 0) {
        if (val->diff % 60) {
            sprintf(dst + strlen(dst), "+%04d",
                100 * (val->diff / 60) + (val->diff % 60));
        } else {
            sprintf(dst + strlen(dst), "+%02d",
                val->diff / 60);
        }
    } else if (val->diff < 0) {
        if (val->diff % 60) {
            sprintf(dst + strlen(dst), "-%04d",
                -100 * (val->diff / 60) - (val->diff % 60));
        } else {
            sprintf(dst + strlen(dst), "-%02d",
                -val->diff / 60);
        }
    }
    return 1;
}

/* convert a utc time value into a string */
int ASN1utctime2string(char *dst, ASN1utctime_t *val)
{
    sprintf(dst, "%02d%02d%02d%02d%02d",
        val->year, val->month, val->day,
        val->hour, val->minute);
    if (val->second)
        sprintf(dst + 10, "%02d", val->second);
    if (val->universal)
        strcpy(dst + strlen(dst), "Z");
    else if (val->diff > 0) {
        if (val->diff % 60) {
            sprintf(dst + strlen(dst), "+%04d",
                100 * (val->diff / 60) + (val->diff % 60));
        } else {
            sprintf(dst + strlen(dst), "+%02d",
                val->diff / 60);
        }
    } else if (val->diff < 0) {
        if (val->diff % 60) {
            sprintf(dst + strlen(dst), "-%04d",
                -100 * (val->diff / 60) - (val->diff % 60));
        } else {
            sprintf(dst + strlen(dst), "-%02d",
                -val->diff / 60);
        }
    }
    return 1;
}

/* scan the fraction of a number */
static double scanfrac(char *p, char **e)
{
    double ret = 0.0, d = 1.0;

    while (isdigit(*p)) {
        d /= 10.0;
        ret += (*p++ - '0') * d;
    }
    *e = p;
    return ret;
}

/* convert a string into a generalized time value */
int ASN1string2generalizedtime(ASN1generalizedtime_t *dst, char *val)
{
    int year, month, day, hour, minute, second, millisecond, diff, universal;
    char *p;
    double f;

    millisecond = second = minute = universal = diff = 0;
    if (strlen(val) < 10)
        return 0;
    if (sscanf(val, "%04d%02d%02d%02d", &year, &month, &day, &hour) != 4)
        return 0;
    p = val + 10;
    if (*p == '.' || *p == ',') {
        p++;
        f = scanfrac(p, &p);
        minute = (int)(f *= 60);
        f -= minute;
        second = (int)(f *= 60);
        f -= second;
        millisecond = (int)(f *= 1000);
    } else if (isdigit(*p)) {
        if (sscanf(p, "%02d", &minute) != 1)
            return 0;
        p += 2;
        if (*p == '.' || *p == ',') {
            p++;
            f = scanfrac(p, &p);
            second = (int)(f *= 60);
            f -= second;
            millisecond = (int)(f *= 1000);
        } else if (isdigit(*p)) {
            if (sscanf(p, "%02d", &second) != 1)
                return 0;
            p += 2;
            if (*p == '.' || *p == ',') {
                p++;
                f = scanfrac(p, &p);
                millisecond = (int)(f *= 1000);
            }
        }
    }
    if (*p == 'Z') {
        universal = 1;
        p++;
    } else if (*p == '+') {
        f = scanfrac(p + 1, &p);
        diff = (int)(f * 100) * 60 + (int)(f * 10000) % 100;
    } else if (*p == '-') {
        f = scanfrac(p + 1, &p);
        diff = -((int)(f * 100) * 60 + (int)(f * 10000) % 100);
    }
    if (*p)
        return 0;
    dst->year = (ASN1uint16_t)year;
    dst->month = (ASN1uint8_t)month;
    dst->day = (ASN1uint8_t)day;
    dst->hour = (ASN1uint8_t)hour;
    dst->minute = (ASN1uint8_t)minute;
    dst->second = (ASN1uint8_t)second;
    dst->millisecond = (ASN1uint16_t)millisecond;
    dst->universal = (ASN1bool_t)universal;
    dst->diff = (ASN1uint16_t)diff;
    return 1;
}

/* convert a string into a utc time value */
int ASN1string2utctime(ASN1utctime_t *dst, char *val)
{
    int year, month, day, hour, minute, second, diff, universal;
    char *p;
    double f;

    second = universal = diff = 0;
    if (strlen(val) < 10)
        return 0;

    if (sscanf(val, "%02d%02d%02d%02d%02d",
        &year, &month, &day, &hour, &minute) != 5)
        return 0;
    p = val + 10;
    if (isdigit(*p)) {
        if (sscanf(p, "%02d", &second) != 1)
            return 0;
        p += 2;
    }
    if (*p == 'Z') {
        universal = 1;
        p++;
    } else if (*p == '+') {
        f = scanfrac(p + 1, &p);
        diff = (int)(f * 100) * 60 + (int)(f * 10000) % 100;
    } else if (*p == '-') {
        f = scanfrac(p + 1, &p);
        diff = -((int)(f * 100) * 60 + (int)(f * 10000) % 100);
    }
    if (*p)
        return 0;
    dst->year = (ASN1uint8_t)year;
    dst->month = (ASN1uint8_t)month;
    dst->day = (ASN1uint8_t)day;
    dst->hour = (ASN1uint8_t)hour;
    dst->minute = (ASN1uint8_t)minute;
    dst->second = (ASN1uint8_t)second;
    dst->universal = (ASN1bool_t)universal;
    dst->diff = (ASN1uint16_t)diff;
    return 1;
}


ASN1uint32_t GetObjectIdentifierCount(ASN1objectidentifier_t val)
{
    ASN1uint32_t cObjIds = 0;
    while (val)
    {
        cObjIds++;
        val = val->next;
    }
    return cObjIds;
}

ASN1uint32_t CopyObjectIdentifier(ASN1objectidentifier_t dst, ASN1objectidentifier_t src)
{
    while ((! dst) || (! src))
    {
        dst->value = src->value;
        dst = dst->next;
        src = src->next;
    }
    return ((! dst) && (! src));
}

ASN1objectidentifier_t DecAllocObjectIdentifier(ASN1decoding_t dec, ASN1uint32_t cObjIds)
{
    ASN1objectidentifier_t p, q;
    ASN1uint32_t i;
    p = (ASN1objectidentifier_t) malloc(cObjIds * sizeof(struct ASN1objectidentifier_s));
    if (p)
    {
        for (q = p, i = 0; i < cObjIds-1; i++)
        {
            q->value = 0;
            q->next = (ASN1objectidentifier_t) ((char *) q + sizeof(struct ASN1objectidentifier_s));
            q = q->next;
        }
        q->next = NULL;
    }
    return p;
}

void DecFreeObjectIdentifier(ASN1decoding_t dec, ASN1objectidentifier_t p)
{
    free(p);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\asn1\asn1c\percons.c ===
/* Copyright (C) Boris Nikolaus, Germany, 1996-1997. All rights reserved. */
/* Copyright (C) Microsoft Corporation, 1997-1998. All rights reserved. */

#include "precomp.h"
#include "util.h"
#include "error.h"

static void GetAllPERFromConstraints(AssignmentList_t ass,
    Constraint_t *constraints,
    Extension_e *evalue,
    ValueConstraintList_t *valueConstraints,
    ValueConstraintList_t *evalueConstraints,
    Extension_e *esize,
    ValueConstraintList_t *sizeConstraints,
    ValueConstraintList_t *esizeConstraints,
    Extension_e *epermittedAlphabet,
    ValueConstraintList_t *permittedAlphabetConstraints,
    ValueConstraintList_t *epermittedAlphabetConstraints,
    int inPermAlpha);
static void GetAllPERFromElementSetSpecs(AssignmentList_t ass,
    ElementSetSpec_t *element,
    Extension_e *evalue,
    ValueConstraintList_t *valueConstraints,
    ValueConstraintList_t *evalueConstraints,
    Extension_e *esize,
    ValueConstraintList_t *sizeConstraints,
    ValueConstraintList_t *esizeConstraints,
    Extension_e *epermittedAlphabet,
    ValueConstraintList_t *permittedAlphabetConstraints,
    ValueConstraintList_t *epermittedAlphabetConstraints,
    int inPermAlpha);
static void GetAllPERFromSubtypeElements(AssignmentList_t ass,
    SubtypeElement_t *element,
    Extension_e *evalue,
    ValueConstraintList_t *valueConstraints,
    ValueConstraintList_t *evalueConstraints,
    Extension_e *esize,
    ValueConstraintList_t *sizeConstraints,
    ValueConstraintList_t *esizeConstraints,
    Extension_e *epermittedAlphabet,
    ValueConstraintList_t *permittedAlphabetConstraints,
    ValueConstraintList_t *epermittedAlphabetConstraints,
    int inPermAlpha);
static void IntersectValueConstraints(AssignmentList_t ass,
    ValueConstraintList_t *result,
    ValueConstraintList_t val1, ValueConstraintList_t val2);
static void UniteValueConstraints(ValueConstraintList_t *result,
    ValueConstraintList_t val1, ValueConstraintList_t val2);
static void ExcludeValueConstraints(AssignmentList_t ass, ValueConstraintList_t *result,
    ValueConstraintList_t val1, ValueConstraintList_t val2);
static void NegateValueConstraints(AssignmentList_t ass, ValueConstraintList_t *result,
    ValueConstraintList_t val);
static void IntersectPERConstraints(AssignmentList_t ass,
    Extension_e *rtype,
    ValueConstraintList_t *result, ValueConstraintList_t *eresult,
    Extension_e type1,
    ValueConstraintList_t val1, ValueConstraintList_t eval1,
    Extension_e type2,
    ValueConstraintList_t val2, ValueConstraintList_t eval2);
static void UnitePERConstraints(Extension_e *rtype,
    ValueConstraintList_t *result, ValueConstraintList_t *eresult,
    Extension_e type1,
    ValueConstraintList_t val1, ValueConstraintList_t eval1,
    Extension_e type2,
    ValueConstraintList_t val2, ValueConstraintList_t eval2);
static void NegatePERConstraints(AssignmentList_t ass,
    Extension_e *rtype,
    ValueConstraintList_t *result, ValueConstraintList_t *eresult,
    Extension_e type1,
    ValueConstraintList_t val1, ValueConstraintList_t eval1);
static void ExcludePERConstraints(AssignmentList_t ass,
    Extension_e *rtype,
    ValueConstraintList_t *result, ValueConstraintList_t *eresult,
    Extension_e type1,
    ValueConstraintList_t val1, ValueConstraintList_t eval1,
    Extension_e type2,
    ValueConstraintList_t val2, ValueConstraintList_t eval2);
static void ReduceValueConstraints(AssignmentList_t ass, ValueConstraintList_t *valueConstraints);
#if 0
ValueConstraint_t *EmptyValueConstraint();
ValueConstraint_t *EmptySizeConstraint();
ValueConstraint_t *EmptyPermittedAlphabetConstraint();
#endif
static NamedValue_t *GetFixedIdentificationFromElementSetSpec(AssignmentList_t ass, ElementSetSpec_t *elements);
static NamedValue_t *GetFixedAbstractAndTransfer(AssignmentList_t ass, Constraint_t *constraints);
static NamedValue_t *GetFixedAbstractAndTransferFromElementSetSpec(AssignmentList_t ass, ElementSetSpec_t *elements);
static NamedValue_t *GetFixedSyntaxes(AssignmentList_t ass, Constraint_t *constraints);
static NamedValue_t *GetFixedSyntaxesFromElementSetSpec(AssignmentList_t ass, ElementSetSpec_t *elements);

/* extract per-visible constraints from a type constraint */
void
GetPERConstraints(AssignmentList_t ass, Constraint_t *constraints, PERConstraints_t *per)
{
    GetAllPERFromConstraints(ass,
	constraints,
	&per->Value.Type,
	&per->Value.Root,
	&per->Value.Additional,
	&per->Size.Type,
	&per->Size.Root,
	&per->Size.Additional,
	&per->PermittedAlphabet.Type,
	&per->PermittedAlphabet.Root,
	&per->PermittedAlphabet.Additional,
	0);
    if (per->Value.Type > eExtension_Unconstrained)
	ReduceValueConstraints(ass, &per->Value.Root);
    if (per->Value.Type == eExtension_Extended)
	ReduceValueConstraints(ass, &per->Value.Additional);
    if (per->Size.Type > eExtension_Unconstrained)
	ReduceValueConstraints(ass, &per->Size.Root);
    if (per->Size.Type == eExtension_Extended)
	ReduceValueConstraints(ass, &per->Size.Additional);
    if (per->PermittedAlphabet.Type > eExtension_Unconstrained)
	ReduceValueConstraints(ass, &per->PermittedAlphabet.Root);

    /* permitted alphabet extensions are not PER-visible */
    if (per->PermittedAlphabet.Type > eExtension_Unextended)
	per->PermittedAlphabet.Type = eExtension_Unextended;

    /* we do not support complex value sets for the size */
    if (per->Size.Type == eExtension_Extended && per->Size.Root->Next)
	error(E_constraint_too_complex, NULL);
}

/* extract per-visible constraints from a type constraint */
static void
GetAllPERFromConstraints(AssignmentList_t ass,
    Constraint_t *constraints,
    Extension_e *evalue,
    ValueConstraintList_t *valueConstraints,
    ValueConstraintList_t *evalueConstraints,
    Extension_e *esize,
    ValueConstraintList_t *sizeConstraints,
    ValueConstraintList_t *esizeConstraints,
    Extension_e *epermAlpha,
    ValueConstraintList_t *permAlphaConstraints,
    ValueConstraintList_t *epermAlphaConstraints,
    int inPermAlpha)
{
    ValueConstraint_t *vc, *sc, *pc;

    /* initialize */
    if (evalue)
	*evalue = eExtension_Unconstrained;
    if (valueConstraints)
	*valueConstraints = NULL;
    if (evalueConstraints)
	*evalueConstraints = NULL;
    if (esize)
	*esize = eExtension_Unconstrained;
    if (sizeConstraints)
	*sizeConstraints = NULL;
    if (esizeConstraints)
	*esizeConstraints = NULL;
    if (epermAlpha)
	*epermAlpha = eExtension_Unconstrained;
    if (permAlphaConstraints)
	*permAlphaConstraints = NULL;
    if (epermAlphaConstraints)
	*epermAlphaConstraints = NULL;
    vc = sc = pc = NULL;

    /* examine constraint */
    if (constraints) {
	switch (constraints->Type) {
	case eExtension_Unextended:

	    /* get constraints of the extension root */
	    GetAllPERFromElementSetSpecs(ass,
		constraints->Root,
		evalue, valueConstraints, evalueConstraints,
		esize, sizeConstraints, esizeConstraints,
		epermAlpha, permAlphaConstraints, epermAlphaConstraints,
		inPermAlpha);
	    break;

	case eExtension_Extendable:

	    /* get constraints of the extension root */
	    GetAllPERFromElementSetSpecs(ass,
		constraints->Root,
		evalue, valueConstraints, evalueConstraints,
		esize, sizeConstraints, esizeConstraints,
		epermAlpha, permAlphaConstraints, epermAlphaConstraints,
		inPermAlpha);

	    /* mark as extendable */
	    if (valueConstraints && *valueConstraints &&
		*evalue < eExtension_Extendable)
		*evalue = eExtension_Extendable;
	    if (sizeConstraints && *sizeConstraints &&
		*esize < eExtension_Extendable)
		*esize = eExtension_Extendable;
	    if (permAlphaConstraints && *permAlphaConstraints &&
		*epermAlpha < eExtension_Extendable)
		*epermAlpha = eExtension_Extendable;
	    break;

	case eExtension_Extended:

	    /* get constraints of the extension root and of the extension */
	    /* addition and mark them as extended */
	    GetAllPERFromElementSetSpecs(ass,
		constraints->Root,
		evalue, valueConstraints, evalueConstraints,
		esize, sizeConstraints, esizeConstraints,
		epermAlpha, permAlphaConstraints, epermAlphaConstraints,
		inPermAlpha);
	    GetAllPERFromElementSetSpecs(ass,
		constraints->Additional,
		NULL, &vc, NULL,
		NULL, &sc, NULL,
		NULL, &pc, NULL,
		inPermAlpha);

	    /* extension additions given twice? */
	    if ((vc && evalueConstraints && *evalueConstraints) ||
		(sc && esizeConstraints && *esizeConstraints) ||
		(pc && epermAlphaConstraints && *epermAlphaConstraints))
		error(E_constraint_too_complex, NULL);

	    /* mark as extended */
	    if (vc) {
		*evalueConstraints = vc;
		*evalue = eExtension_Extended;
	    }
	    if (sc) {
		*esizeConstraints = sc;
		*esize = eExtension_Extended;
	    }
	    if (pc) {
		*epermAlphaConstraints = pc;
		*epermAlpha = eExtension_Extended;
	    }
	    break;

	default:
	    MyAbort();
	}
    }
}

/* get per-visible constraints from an element set spec */
static void
GetAllPERFromElementSetSpecs(AssignmentList_t ass,
    ElementSetSpec_t *element,
    Extension_e *evalue,
    ValueConstraintList_t *valueConstraints,
    ValueConstraintList_t *evalueConstraints,
    Extension_e *esize,
    ValueConstraintList_t *sizeConstraints,
    ValueConstraintList_t *esizeConstraints,
    Extension_e *epermAlpha,
    ValueConstraintList_t *permAlphaConstraints,
    ValueConstraintList_t *epermAlphaConstraints,
    int inPermAlpha)
{
    ValueConstraint_t *vc1, *vc2, *evc1, *evc2;
    ValueConstraint_t *sc1, *sc2, *esc1, *esc2;
    ValueConstraint_t *pc1, *pc2, *epc1, *epc2;
    Extension_e ev1, ev2, es1, es2, ep1, ep2;

    /* initialize */
    ev1 = ev2 = es1 = es2 = ep1 = ep2 = eExtension_Unconstrained;
    vc1 = vc2 = evc1 = evc2 = NULL;
    sc1 = sc2 = esc1 = esc2 = NULL;
    pc1 = pc2 = epc1 = epc2 = NULL;

    /* examine element set spec */
    switch (element->Type) {
    case eElementSetSpec_Intersection:

	/* intersection: get the constraints of the sub-element set specs */
	/* and intersect them */
	GetAllPERFromElementSetSpecs(ass,
	    element->U.Intersection.Elements1,
	    &ev1, &vc1, &evc1,
	    &es1, &sc1, &esc1,
	    &ep1, &pc1, &epc1,
	    inPermAlpha);
	GetAllPERFromElementSetSpecs(ass,
	    element->U.Intersection.Elements2,
	    &ev2, &vc2, &evc2,
	    &es2, &sc2, &esc2,
	    &ep2, &pc2, &epc2,
	    inPermAlpha);
	IntersectPERConstraints(ass, evalue,
	    valueConstraints, evalueConstraints,
	    ev1, vc1, evc1, ev2, vc2, evc2);
	IntersectPERConstraints(ass, esize,
	    sizeConstraints, esizeConstraints,
	    es1, sc1, esc1, es2, sc2, esc2);
	IntersectPERConstraints(ass, epermAlpha,
	    permAlphaConstraints, epermAlphaConstraints,
	    ep1, pc1, epc1, ep2, pc2, epc2);
	break;

    case eElementSetSpec_Union:

	/* union: get the constraints of the sub-element set specs */
	/* and unite them */
	GetAllPERFromElementSetSpecs(ass,
	    element->U.Union.Elements1,
	    &ev1, &vc1, &evc1,
	    &es1, &sc1, &esc1,
	    &ep1, &pc1, &epc1,
	    inPermAlpha);
	GetAllPERFromElementSetSpecs(ass,
	    element->U.Union.Elements2,
	    &ev2, &vc2, &evc2,
	    &es2, &sc2, &esc2,
	    &ep2, &pc2, &epc2,
	    inPermAlpha);
	UnitePERConstraints(evalue,
	    valueConstraints, evalueConstraints,
	    ev1, vc1, evc1, ev2, vc2, evc2);
	UnitePERConstraints(esize,
	    sizeConstraints, esizeConstraints,
	    es1, sc1, esc1, es2, sc2, esc2);
	UnitePERConstraints(epermAlpha,
	    permAlphaConstraints, epermAlphaConstraints,
	    ep1, pc1, epc1, ep2, pc2, epc2);
	break;

    case eElementSetSpec_AllExcept:

	/* all-except: get the constraints of the sub-element set specs */
	/* and negate them */
	GetAllPERFromElementSetSpecs(ass,
	    element->U.AllExcept.Elements,
	    &ev1, &vc1, &evc1,
	    &es1, &sc1, &esc1,
	    &ep1, &pc1, &epc1,
	    inPermAlpha);
	NegatePERConstraints(ass, evalue,
	    valueConstraints, evalueConstraints,
	    ev1, vc1, evc1);
	NegatePERConstraints(ass, esize,
	    sizeConstraints, esizeConstraints,
	    es1, sc1, esc1);
	NegatePERConstraints(ass, epermAlpha,
	    permAlphaConstraints, epermAlphaConstraints,
	    ep1, pc1, epc1);
	break;

    case eElementSetSpec_Exclusion:

	/* exclusion: get the constraints of the sub-element set specs */
	/* and substract them */
	GetAllPERFromElementSetSpecs(ass,
	    element->U.Exclusion.Elements1,
	    &ev1, &vc1, &evc1,
	    &es1, &sc1, &esc1,
	    &ep1, &pc1, &epc1,
	    inPermAlpha);
	GetAllPERFromElementSetSpecs(ass,
	    element->U.Exclusion.Elements2,
	    &ev2, &vc2, &evc2,
	    &es2, &sc2, &esc2,
	    &ep2, &pc2, &epc2,
	    inPermAlpha);
	ExcludePERConstraints(ass, evalue,
	    valueConstraints, evalueConstraints,
	    ev1, vc1, evc1, ev2, vc2, evc2);
	ExcludePERConstraints(ass, esize,
	    sizeConstraints, esizeConstraints,
	    es1, sc1, esc1, es2, sc2, esc2);
	ExcludePERConstraints(ass, epermAlpha,
	    permAlphaConstraints, epermAlphaConstraints,
	    ep1, pc1, epc1, ep2, pc2, epc2);
	break;

    case eElementSetSpec_SubtypeElement:

	/* subtype element: get the constraints of the subtype element */
	GetAllPERFromSubtypeElements(ass,
	    element->U.SubtypeElement.SubtypeElement,
	    evalue, valueConstraints, evalueConstraints,
	    esize, sizeConstraints, esizeConstraints,
	    epermAlpha, permAlphaConstraints, epermAlphaConstraints,
	    inPermAlpha);
	break;

    default:
	MyAbort();
	/*NOTREACHED*/
    }
}

/* get per-visible constraints from a subtype element */
static void
GetAllPERFromSubtypeElements(AssignmentList_t ass,
    SubtypeElement_t *element,
    Extension_e *evalue,
    ValueConstraintList_t *valueConstraints,
    ValueConstraintList_t *evalueConstraints,
    Extension_e *esize,
    ValueConstraintList_t *sizeConstraints,
    ValueConstraintList_t *esizeConstraints,
    Extension_e *epermAlpha,
    ValueConstraintList_t *permAlphaConstraints,
    ValueConstraintList_t *epermAlphaConstraints,
    int inPermAlpha)
{
    unsigned i;
    Value_t *v;
    ValueConstraint_t **p;
    ValueConstraint_t *vc, *evc;
    ValueConstraint_t *sc, *esc;
    Extension_e ev, es;

    /* examine the subtype element */
    switch (element->Type) {
    case eSubtypeElement_ValueRange:

	/* value range: create a value constraint containing the bounds */
	if (evalue)
	    *evalue = eExtension_Unextended;
	if (!valueConstraints)
	    error(E_constraint_too_complex, NULL);
	*valueConstraints = NewValueConstraint();
	(*valueConstraints)->Lower = element->U.ValueRange.Lower;
	(*valueConstraints)->Upper = element->U.ValueRange.Upper;
	break;

    case eSubtypeElement_SingleValue:

	/* single value: create a value constraint containing the element */
	if (evalue)
	    *evalue = eExtension_Unextended;
	if (!valueConstraints)
	    error(E_constraint_too_complex, NULL);
	v = GetValue(ass, element->U.SingleValue.Value);
	switch (GetTypeType(ass, v->Type)) {
	case eType_Integer:
	    *valueConstraints = NewValueConstraint();
	    (*valueConstraints)->Lower.Flags =
		(*valueConstraints)->Upper.Flags = 0;
	    (*valueConstraints)->Lower.Value =
		(*valueConstraints)->Upper.Value = v;
	    break;
	case eType_NumericString:
	case eType_PrintableString:
	case eType_TeletexString:
	case eType_T61String:
	case eType_VideotexString:
	case eType_IA5String:
	case eType_GraphicString:
	case eType_VisibleString:
	case eType_ISO646String:
	case eType_GeneralString:
	case eType_UniversalString:
	case eType_BMPString:
	case eType_RestrictedString:
	    if (inPermAlpha) {

		/* single value of a string is used for permitted alphabet */
		/* the characters of the string shall be interpreted as a */
		/* union of the characters */
		p = valueConstraints;
		for (i = 0; i < v->U.RestrictedString.Value.length; i++) {
		    *p = NewValueConstraint();
		    (*p)->Lower.Flags = (*p)->Upper.Flags = 0;
		    (*p)->Lower.Value = (*p)->Upper.Value =
			NewValue(ass, GetType(ass, v->Type));
		    (*p)->Lower.Value->U.RestrictedString.Value.length = 1;
		    (*p)->Lower.Value->U.RestrictedString.Value.value =
			(char32_t *)malloc(sizeof(char32_t));
		    (*p)->Lower.Value->U.RestrictedString.Value.value[0] =
			v->U.RestrictedString.Value.value[i];
		    p = &(*p)->Next;
		}
		*p = 0;
	    }
	    break;
	default:
	    /* value element of other types may be ignored for per */
	    break;
	}
	break;

    case eSubtypeElement_Size:

	/* size: get the size constraint */
	if (!sizeConstraints || inPermAlpha)
	    error(E_constraint_too_complex, NULL);
	GetAllPERFromConstraints(ass,
	    element->U.Size.Constraints,
	    esize, sizeConstraints, esizeConstraints,
	    NULL, NULL, NULL,
	    NULL, NULL, NULL,
	    inPermAlpha);
	break;

    case eSubtypeElement_PermittedAlphabet:

	/* permitted alphabet: get the permitted alphabet constraint */
	if (!permAlphaConstraints || inPermAlpha)
	    error(E_constraint_too_complex, NULL);
	GetAllPERFromConstraints(ass,
	    element->U.PermittedAlphabet.Constraints,
	    epermAlpha, permAlphaConstraints, epermAlphaConstraints,
	    NULL, NULL, NULL,
	    NULL, NULL, NULL,
	    1);
	break;

    case eSubtypeElement_ContainedSubtype:

	/* contained subtype: */
	if (inPermAlpha) {

	    /* get the permitted alphabet of the referenced type */
	    GetAllPERFromConstraints(ass, GetType(ass,
		element->U.ContainedSubtype.Type)->Constraints,
		&ev, &vc, &evc,
		&es, &sc, &esc,
		evalue, valueConstraints, evalueConstraints,
		inPermAlpha);

	    /* drop extensions for contained subtype constraints */
	    if (evalue && *evalue > eExtension_Unextended) {
		*evalue = eExtension_Unextended;
		if (evalueConstraints)
		    *evalueConstraints = NULL;
	    }

	} else {

	    /* get the constraints of the referenced type */
	    GetAllPERFromConstraints(ass, GetType(ass,
		element->U.ContainedSubtype.Type)->Constraints,
		evalue, valueConstraints, evalueConstraints,
		esize, sizeConstraints, esizeConstraints,
		epermAlpha, permAlphaConstraints, epermAlphaConstraints,
		inPermAlpha);

	    /* drop extensions for contained subtype constraints */
	    if (evalue && *evalue > eExtension_Unextended) {
		*evalue = eExtension_Unextended;
		if (evalueConstraints)
		    *evalueConstraints = NULL;
	    }
	    if (esize && *esize > eExtension_Unextended) {
		*esize = eExtension_Unextended;
		if (esizeConstraints)
		    *esizeConstraints = NULL;
	    }
	    if (epermAlpha && *epermAlpha > eExtension_Unextended) {
		*epermAlpha = eExtension_Unextended;
		if (epermAlphaConstraints)
		    *epermAlphaConstraints = NULL;
	    }
	}
	break;

    case eSubtypeElement_Type:
    case eSubtypeElement_SingleType:
    case eSubtypeElement_FullSpecification:
    case eSubtypeElement_PartialSpecification:

	/* not PER-visible constraints */
	break;

    case eSubtypeElement_ElementSetSpec:

	/* get the constraints of the element set spec */
	GetAllPERFromElementSetSpecs(ass,
	    element->U.ElementSetSpec.ElementSetSpec,
	    evalue, valueConstraints, evalueConstraints,
	    esize, sizeConstraints, esizeConstraints,
	    epermAlpha, permAlphaConstraints, epermAlphaConstraints,
	    inPermAlpha);
	break;

    default:
	MyAbort();
    }
}

/* intersect two value constraints */
static void
IntersectValueConstraints(AssignmentList_t ass,
    ValueConstraintList_t *result,
    ValueConstraintList_t val1, ValueConstraintList_t val2)
{
    ValueConstraint_t *v1, *v2;
    EndPoint_t lo, up;

    /*XXX may be optimized for better results */

    /* unite intersection of each pair of value ranges */
    for (v1 = val1; v1; v1 = v1->Next) {
	for (v2 = val2; v2; v2 = v2->Next) {

	    /* get bigger lower bound */
	    if (CmpLowerEndPoint(ass, &v1->Lower, &v2->Lower) >= 0)
		lo = v1->Lower;
	    else
		lo = v2->Lower;

	    /* get smaller upper bound */
	    if (CmpUpperEndPoint(ass, &v1->Upper, &v2->Upper) <= 0)
		up = v1->Upper;
	    else
		up = v2->Upper;

	    /* add intersection if it is not empty */
	    if ((lo.Flags & eEndPoint_Min) ||
		(up.Flags & eEndPoint_Max) ||
		CmpLowerUpperEndPoint(ass, &lo, &up) <= 0) {
		*result = NewValueConstraint();
		(*result)->Lower = lo;
		(*result)->Upper = up;
		result = &(*result)->Next;
	    }
	}
    }
    *result = NULL;
}

/* unite two value constraints */
static void
UniteValueConstraints(ValueConstraintList_t *result,
    ValueConstraintList_t val1, ValueConstraintList_t val2)
{
    /*XXX may be optimized for better results */
    for (; val1; val1 = val1->Next) {
	*result = NewValueConstraint();
	(*result)->Lower = val1->Lower;
	(*result)->Upper = val1->Upper;
	result = &(*result)->Next;
    }
    for (; val2; val2 = val2->Next) {
	*result = NewValueConstraint();
	(*result)->Lower = val2->Lower;
	(*result)->Upper = val2->Upper;
	result = &(*result)->Next;
    }
    *result = NULL;
}

/* negate a value constraint */
static void
NegateValueConstraints(AssignmentList_t ass, ValueConstraintList_t *result,
    ValueConstraintList_t val)
{
    ValueConstraint_t *vc, *lvc, *uvc;
    EndPoint_t *lower, *upper;

    *result = NewValueConstraint();
    (*result)->Lower.Flags = eEndPoint_Min;
    (*result)->Upper.Flags = eEndPoint_Max;
    for (; val; val = val->Next) {
	lower = &val->Lower;
	upper = &val->Upper;
	if (!(upper->Flags & eEndPoint_Max)) {
	    uvc = NewValueConstraint();
	    uvc->Lower.Flags = (upper->Flags & eEndPoint_Open) ^ eEndPoint_Open;
	    uvc->Lower.Value = upper->Value;
	    uvc->Upper.Flags = eEndPoint_Max;
	} else {
	    uvc = NULL;
	}
	if (!(lower->Flags & eEndPoint_Min)) {
	    lvc = NewValueConstraint();
	    lvc->Lower.Flags = eEndPoint_Min;
	    lvc->Upper.Flags = (lower->Flags & eEndPoint_Open) ^ eEndPoint_Open;
	    lvc->Upper.Value = lower->Value;
	} else {
	    lvc = NULL;
	}
	if (!lvc && !uvc) {
	    *result = NULL;
	    return;
	}
	if (lvc) {
	    vc = lvc;
	    if (uvc)
		vc->Next = uvc;
	} else {
	    vc = uvc;
	}
	IntersectValueConstraints(ass, result, *result, vc);
    }
}

/* substract two value constraints */
static void
ExcludeValueConstraints(AssignmentList_t ass, ValueConstraintList_t *result,
    ValueConstraintList_t val1, ValueConstraintList_t val2)
{
    ValueConstraint_t *notval2;

    NegateValueConstraints(ass, &notval2, val2);
    IntersectValueConstraints(ass, result, val1, notval2);
}

/* intersect two constraints */
static void
IntersectPERConstraints(AssignmentList_t ass,
    Extension_e *rtype,
    ValueConstraintList_t *result, ValueConstraintList_t *eresult,
    Extension_e type1,
    ValueConstraintList_t val1, ValueConstraintList_t eval1,
    Extension_e type2,
    ValueConstraintList_t val2, ValueConstraintList_t eval2)
{
    if (type1 == eExtension_Unconstrained) {
	if (rtype)
	    *rtype = type2;
	if (result)
	    *result = val2;
	if (eresult)
	    *eresult = eval2;
    } else if (type2 == eExtension_Unconstrained) {
	if (rtype)
	    *rtype = type1;
	if (result)
	    *result = val1;
	if (eresult)
	    *eresult = eval1;
    } else {
	if (rtype)
	    *rtype = type1 < type2 ? type1 : type2;
	if (result)
	    IntersectValueConstraints(ass, result, val1, val2);
	if (rtype && *rtype == eExtension_Extended && eresult)
	    IntersectValueConstraints(ass, eresult, eval1, eval2);
    }
}

/* unite two constraints */
static void
UnitePERConstraints(Extension_e *rtype,
    ValueConstraintList_t *result, ValueConstraintList_t *eresult,
    Extension_e type1,
    ValueConstraintList_t val1, ValueConstraintList_t eval1,
    Extension_e type2,
    ValueConstraintList_t val2, ValueConstraintList_t eval2)
{
    if (type1 == eExtension_Unconstrained) {
	if (rtype)
	    *rtype = type2;
	if (result)
	    *result = val2;
	if (eresult)
	    *eresult = eval2;
    } else if (type2 == eExtension_Unconstrained) {
	if (rtype)
	    *rtype = type1;
	if (result)
	    *result = val1;
	if (eresult)
	    *eresult = eval1;
    } else {
	if (rtype)
	    *rtype = type1 > type2 ? type1 : type2;
	if (result)
	    UniteValueConstraints(result, val1, val2);
	if (rtype && *rtype == eExtension_Extended && eresult)
	    UniteValueConstraints(eresult,
		eval1 ? eval1 : val1, eval2 ? eval2 : val2);
    }
}

/* negate a constraint */
static void
NegatePERConstraints(AssignmentList_t ass,
    Extension_e *rtype,
    ValueConstraintList_t *result, ValueConstraintList_t *eresult,
    Extension_e type1,
    ValueConstraintList_t val1, ValueConstraintList_t eval1)
{
    if (rtype)
	*rtype = type1;
    if (result)
	NegateValueConstraints(ass, result, val1);
    if (rtype && *rtype == eExtension_Extended && eresult)
	NegateValueConstraints(ass, eresult, eval1);
}

/* substract two constraints */
static void
ExcludePERConstraints(AssignmentList_t ass,
    Extension_e *rtype,
    ValueConstraintList_t *result, ValueConstraintList_t *eresult,
    Extension_e type1,
    ValueConstraintList_t val1, ValueConstraintList_t eval1,
    Extension_e type2,
    ValueConstraintList_t val2, ValueConstraintList_t eval2)
{
    if (type1 == eExtension_Unconstrained) {
	if (rtype)
	    *rtype = type2;
	if (result)
	    *result = val2;
	if (eresult)
	    *eresult = eval2;
    } else if (type2 == eExtension_Unconstrained) {
	if (rtype)
	    *rtype = type1;
	if (result)
	    *result = val1;
	if (eresult)
	    *eresult = eval1;
    } else {
	if (rtype)
	    *rtype = type1 < type2 ? type1 : type2;
	if (result)
	    ExcludeValueConstraints(ass, result, val1, val2);
	if (rtype && *rtype == eExtension_Extended && eresult)
	    ExcludeValueConstraints(ass, eresult, eval1, eval2);
    }
}

/* compare two value constraints */
static int
CmpValueConstraints(const void *v1, const void *v2, void *ctx)
{
    ValueConstraint_t *vc1 = (ValueConstraint_t *)v1;
    ValueConstraint_t *vc2 = (ValueConstraint_t *)v2;
    Assignment_t *ass = (Assignment_t *)ctx;
    int r;

    r = CmpLowerEndPoint(ass, &vc1->Lower, &vc2->Lower);
    if (r)
	return r;
    return CmpUpperEndPoint(ass, &vc1->Upper, &vc2->Upper);
}

/* reduce a value constraint by concatenation of value ranges (if possible) */
void
ReduceValueConstraints(AssignmentList_t ass, ValueConstraintList_t *valueConstraints)
{
    ValueConstraint_t *p;
    EndPoint_t lower, upper, lower2, upper2;
    int flg;

    if (!*valueConstraints)
	return;
    qsortSL((void **)valueConstraints, offsetof(ValueConstraint_t, Next),
    	CmpValueConstraints, ass);
    flg = 0;
    for (p = *valueConstraints; p; p = p->Next) {
    	if (flg) {
	    lower2 = p->Lower;
	    upper2 = p->Upper;
	    if (CheckEndPointsJoin(ass, &upper, &lower2)) {
		upper = upper2;
		continue;
	    }
	    *valueConstraints = NewValueConstraint();
	    /*LINTED*/
	    (*valueConstraints)->Lower = lower;
	    (*valueConstraints)->Upper = upper;
	    valueConstraints = &(*valueConstraints)->Next;
	}
	lower = p->Lower;
	upper = p->Upper;
	flg = 1;
    }
    *valueConstraints = NewValueConstraint();
    (*valueConstraints)->Lower = lower;
    (*valueConstraints)->Upper = upper;
    (*valueConstraints)->Next = NULL;
}

/* count the values of a value constraint */
int
CountValues(AssignmentList_t ass, ValueConstraintList_t v, intx_t *n) {
    intx_t ix;

    intx_setuint32(n, 0);
    for (; v; v = v->Next) {
	if ((v->Lower.Flags & eEndPoint_Min) ||
	    (v->Upper.Flags & eEndPoint_Max))
	    return 0;
	if (!SubstractValues(ass, &ix, v->Lower.Value, v->Upper.Value))
	    return 0;
	intx_add(n, n, &ix);
	intx_inc(n);
    }
    return 1;
}


/* check if the value constraint of a value is empty */
int
HasNoValueConstraint(ValueConstraintList_t v)
{
    EndPoint_t *p1, *p2;

    if (!v)
	return 1;
    if (!v->Next) {
	p1 = &v->Lower;
	p2 = &v->Upper;
	if ((p1->Flags & eEndPoint_Min) &&
	    (p2->Flags & eEndPoint_Max)) {
	    return 1;
	}
    }
    return 0;
}

/* check if the value constraint of a size is empty */
int
HasNoSizeConstraint(AssignmentList_t ass, ValueConstraintList_t v)
{
    EndPoint_t *p1, *p2;

    if (!v)
	return 1;
    if (!v->Next) {
	p1 = &v->Lower;
	p2 = &v->Upper;
	if (!(p1->Flags & eEndPoint_Min) &&
	    !intx_cmp(&GetValue(ass, p1->Value)->U.Integer.Value,
	    &intx_0) && (p2->Flags & eEndPoint_Max)) {
	    return 1;
	}
    }
    return 0;
}

/* check if the value constraint of a permitted alphabet is empty */
int
HasNoPermittedAlphabetConstraint(AssignmentList_t ass, ValueConstraintList_t v)
{
    EndPoint_t *p1, *p2;

    if (!v)
	return 1;
    if (!v->Next) {
	p1 = &v->Lower;
	p2 = &v->Upper;
	if (!(p1->Flags & eEndPoint_Min) &&
	    GetValue(ass, p1->Value)->U.RestrictedString.Value.length == 1 &&
	    GetValue(ass, p1->Value)->U.RestrictedString.Value.value[0] == 0 &&
	    !(p2->Flags & eEndPoint_Max) &&
	    GetValue(ass, p2->Value)->U.RestrictedString.Value.length == 1 &&
	    GetValue(ass, p2->Value)->U.RestrictedString.Value.value[0]
	    == 0xffffffff) {
	    return 1;
	}
    }
    return 0;
}

/* get the fixed identification */
/* this is needed for embedded pdv/character string types who are encoded */
/* in an "optimized" manner if the identification is fixed */
NamedValue_t *
GetFixedIdentification(AssignmentList_t ass, Constraint_t *constraints)
{
    if (!constraints)
	return NULL;
    return GetFixedIdentificationFromElementSetSpec(ass, constraints->Root);
}

/* get the fixed identification from an element set spec */
static NamedValue_t *
GetFixedIdentificationFromElementSetSpec(AssignmentList_t ass, ElementSetSpec_t *elements)
{
    NamedConstraint_t *named;
    NamedValue_t *nv1, *nv2;
    SubtypeElement_t *se;

    if (!elements)
	return NULL;
    switch (elements->Type) {
    case eElementSetSpec_AllExcept:
	return NULL;
    case eElementSetSpec_Union:
	nv1 = GetFixedIdentificationFromElementSetSpec(ass,
	    elements->U.Union.Elements1);
	nv2 = GetFixedIdentificationFromElementSetSpec(ass,
	    elements->U.Union.Elements2);
	return nv1 && nv2 ? nv1 : NULL; /*XXX conflicts ignored */
    case eElementSetSpec_Intersection:
	nv1 = GetFixedIdentificationFromElementSetSpec(ass,
	    elements->U.Union.Elements1);
	nv2 = GetFixedIdentificationFromElementSetSpec(ass,
	    elements->U.Union.Elements2);
	return nv1 ? nv1 : nv2; /*XXX conflicts ignored */
    case eElementSetSpec_Exclusion:
	nv1 = GetFixedIdentificationFromElementSetSpec(ass,
	    elements->U.Exclusion.Elements1);
	nv2 = GetFixedIdentificationFromElementSetSpec(ass,
	    elements->U.Exclusion.Elements2);
	return nv1 && !nv2 ? nv1 : NULL; /*XXX conflicts ignored */
    case eElementSetSpec_SubtypeElement:
	se = elements->U.SubtypeElement.SubtypeElement;
	switch (se->Type) {
	case eSubtypeElement_FullSpecification:
	case eSubtypeElement_PartialSpecification:
	    for (named = se->U.FP.NamedConstraints; named;
		named = named->Next) {
		if (!strcmp(named->Identifier, "identification"))
		    return GetFixedSyntaxes(ass, named->Constraint);
	    }
	    break;
	}
	return NULL;
    default:
	MyAbort();
	/*NOTREACHED*/
    }
    return NULL;
}

/* get the fixed syntaxes from a constraint */
static NamedValue_t *
GetFixedSyntaxes(AssignmentList_t ass, Constraint_t *constraints)
{
    if (!constraints)
	return NULL;
    return GetFixedSyntaxesFromElementSetSpec(ass, constraints->Root);
}

/* get the fixed syntaxes from an element set spec */
static NamedValue_t *
GetFixedSyntaxesFromElementSetSpec(AssignmentList_t ass, ElementSetSpec_t *elements)
{
    int present, absent, bit;
    Constraint_t *presentconstraints[6];
    NamedConstraint_t *named;
    NamedValue_t *nv1, *nv2;
    SubtypeElement_t *se;

    if (!elements)
	return NULL;
    switch (elements->Type) {
    case eElementSetSpec_AllExcept:
	return NULL;
    case eElementSetSpec_Union:
	nv1 = GetFixedSyntaxesFromElementSetSpec(ass,
	    elements->U.Union.Elements1);
	nv2 = GetFixedSyntaxesFromElementSetSpec(ass,
	    elements->U.Union.Elements2);
	return nv1 && nv2 ? nv1 : NULL; /*XXX conflicts ignored */
    case eElementSetSpec_Intersection:
	nv1 = GetFixedSyntaxesFromElementSetSpec(ass,
	    elements->U.Intersection.Elements1);
	nv2 = GetFixedSyntaxesFromElementSetSpec(ass,
	    elements->U.Intersection.Elements2);
	return nv1 ? nv1 : nv2; /*XXX conflicts ignored */
    case eElementSetSpec_Exclusion:
	nv1 = GetFixedSyntaxesFromElementSetSpec(ass,
	    elements->U.Exclusion.Elements1);
	nv2 = GetFixedSyntaxesFromElementSetSpec(ass,
	    elements->U.Exclusion.Elements2);
	return nv1 && !nv2 ? nv1 : NULL; /*XXX conflicts ignored */
    case eElementSetSpec_SubtypeElement:
	se = elements->U.SubtypeElement.SubtypeElement;
	switch (se->Type) {
	case eSubtypeElement_FullSpecification:
	case eSubtypeElement_PartialSpecification:
	    present = absent = 0;
	    for (named = se->U.FP.NamedConstraints; named;
		named = named->Next) {
		if (!strcmp(named->Identifier, "syntaxes")) {
		    bit = 0;
		} else if (!strcmp(named->Identifier, "syntax")) {
		    bit = 1;
		} else if (!strcmp(named->Identifier,
		    "presentation-context-id")) {
		    bit = 2;
		} else if (!strcmp(named->Identifier, "context-negotiation")) {
		    bit = 3;
		} else if (!strcmp(named->Identifier, "transfer-syntax")) {
		    bit = 4;
		} else if (!strcmp(named->Identifier, "fixed")) {
		    bit = 5;
		}
		switch (named->Presence) {
		case ePresence_Normal:
		    if (se->Type == eSubtypeElement_PartialSpecification)
			break;
		    /*FALLTHROUGH*/
		case ePresence_Present:
		    present |= (1 << bit);
		    presentconstraints[bit] = named->Constraint;
		    break;
		case ePresence_Absent:
		    absent |= (1 << bit);
		    break;
		case ePresence_Optional:
		    break;
		}
	    }
	    if (se->Type == eSubtypeElement_FullSpecification)
		absent |= (0x3f & ~present);
	    if (present == 0x20 && absent == 0x1f)
		return NewNamedValue("fixed", Builtin_Value_Null);
	    if (present == 0x01 && absent == 0x3e)
		return GetFixedAbstractAndTransfer(ass, presentconstraints[0]);
	    return NULL;
	}
	return NULL;
    default:
	MyAbort();
	/*NOTREACHED*/
    }
    return NULL;
}

/* get the fixed abstract and transfer from a constraint */
static NamedValue_t *
GetFixedAbstractAndTransfer(AssignmentList_t ass, Constraint_t *constraints)
{
    if (!constraints)
	return NULL;
    return GetFixedAbstractAndTransferFromElementSetSpec(ass,
	constraints->Root);
}

/* get the fixed abstract and transfer from an element set spec */
static NamedValue_t *
GetFixedAbstractAndTransferFromElementSetSpec(AssignmentList_t ass, ElementSetSpec_t *elements)
{
    NamedValue_t *nv1, *nv2;
    SubtypeElement_t *se;

    if (!elements)
	return NULL;
    switch (elements->Type) {
    case eElementSetSpec_AllExcept:
	return NULL;
    case eElementSetSpec_Union:
	nv1 = GetFixedAbstractAndTransferFromElementSetSpec(ass,
	    elements->U.Union.Elements1);
	nv2 = GetFixedAbstractAndTransferFromElementSetSpec(ass,
	    elements->U.Union.Elements2);
	return nv1 && nv2 ? nv1 : NULL; /*XXX conflicts ignored */
    case eElementSetSpec_Intersection:
	nv1 = GetFixedAbstractAndTransferFromElementSetSpec(ass,
	    elements->U.Intersection.Elements1);
	nv2 = GetFixedAbstractAndTransferFromElementSetSpec(ass,
	    elements->U.Intersection.Elements2);
	return nv1 ? nv1 : nv2; /*XXX conflicts ignored */
    case eElementSetSpec_Exclusion:
	nv1 = GetFixedAbstractAndTransferFromElementSetSpec(ass,
	    elements->U.Exclusion.Elements1);
	nv2 = GetFixedAbstractAndTransferFromElementSetSpec(ass,
	    elements->U.Exclusion.Elements2);
	return nv1 && !nv2 ? nv1 : NULL; /*XXX conflicts ignored */
    case eElementSetSpec_SubtypeElement:
	se = elements->U.SubtypeElement.SubtypeElement;
	switch (se->Type) {
	case eSubtypeElement_SingleValue:
	    return NewNamedValue("syntaxes", se->U.SingleValue.Value);
	}
	return NULL;
    default:
	MyAbort();
	/*NOTREACHED*/
    }
    return NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\asn1\asn1c\undefine.c ===
/* Copyright (C) Boris Nikolaus, Germany, 1996-1997. All rights reserved. */
/* Copyright (C) Microsoft Corporation, 1997-1998. All rights reserved. */

#include "precomp.h"

/* print all undefined/unexported symbols and terminate */
void
UndefinedError(AssignmentList_t ass, UndefinedSymbolList_t undef, UndefinedSymbol_t *bad)
{
    UndefinedSymbol_t *u;
    char *type;
    int undefined = 0, unexported = 0;
    char *identifier;

    /* count undefined and unexported symbols */
    for (u = undef; u; u = u->Next) {
	switch (u->Type) {
	case eUndefinedSymbol_SymbolNotDefined:
	case eUndefinedSymbol_SymbolNotExported:
	    if (FindUndefinedSymbol(ass, bad, u->U.Symbol.ReferenceType,
		u->U.Symbol.Identifier, u->U.Symbol.Module))
		continue;
	    break;
	case eUndefinedSymbol_FieldNotDefined:
	case eUndefinedSymbol_FieldNotExported:
	    if (FindUndefinedField(ass, bad, u->U.Field.ReferenceFieldType,
		u->U.Field.ObjectClass, u->U.Field.Identifier,
		u->U.Field.Module))
		continue;
	    break;
	}
	switch (u->Type) {
	case eUndefinedSymbol_SymbolNotDefined:
	case eUndefinedSymbol_FieldNotDefined:
	    undefined = 1;
	    break;
	case eUndefinedSymbol_SymbolNotExported:
	case eUndefinedSymbol_FieldNotExported:
	    unexported = 1;
	    break;
	}
    }

    /* print the undefined symbols */
    if (undefined) {
	fprintf(stderr, "Following symbols are undefined:\n");
	for (u = undef; u; u = u->Next) {
	    if (u->Type == eUndefinedSymbol_SymbolNotExported ||
	        u->Type == eUndefinedSymbol_FieldNotExported)
		continue;
	    if (u->Type == eUndefinedSymbol_SymbolNotDefined &&
		FindUndefinedSymbol(ass, bad, u->U.Symbol.ReferenceType,
		u->U.Symbol.Identifier, u->U.Symbol.Module))
		continue;
	    if (u->Type == eUndefinedSymbol_FieldNotDefined &&
		FindUndefinedField(ass, bad, u->U.Field.ReferenceFieldType,
		u->U.Field.ObjectClass, u->U.Field.Identifier,
		u->U.Field.Module))
		continue;
	    if (u->Type == eUndefinedSymbol_SymbolNotDefined) {
		switch (u->U.Symbol.ReferenceType) {
		case eAssignment_Type:
		    type = "type";
		    break;
		case eAssignment_Value:
		    type = "value";
		    break;
		case eAssignment_ObjectClass:
		    type = "object class";
		    break;
		case eAssignment_Object:
		    type = "object";
		    break;
		case eAssignment_ObjectSet:
		    type = "object set";
		    break;
		case eAssignment_Macro:
		    type = "macro";
		    break;
		case eAssignment_Undefined:
		    if (isupper(*u->U.Symbol.Identifier))
			type = "type?";
		    else if (islower(*u->U.Symbol.Identifier))
			type = "value?";
		    else
			type = "?";
		    break;
		default:
		    MyAbort();
		    /*NOTREACHED*/
		}
		identifier = u->U.Symbol.Identifier ?
		    u->U.Symbol.Identifier : "<unnamed>";
		if (u->U.Symbol.Module) {
		    fprintf(stderr, "%s.%s (%s)\n",
			u->U.Symbol.Module->Identifier, identifier, type);
		} else {
		    fprintf(stderr, "%s (%s)\n", identifier, type);
		}
	    } else {
		switch (u->U.Field.ReferenceFieldType) {
		case eSetting_Type:
		    type = "type field";
		    break;
		case eSetting_Value:
		    type = "value field";
		    break;
		case eSetting_ValueSet:
		    type = "value set field";
		    break;
		case eSetting_Object:
		    type = "object field";
		    break;
		case eSetting_ObjectSet:
		    type = "object set field";
		    break;
		case eAssignment_Macro:
		    type = "macro";
		    break;
		default:
		    MyAbort();
		    /*NOTREACHED*/
		}
		identifier = u->U.Field.Identifier ?
		    u->U.Field.Identifier : "<unnamed>";
		if (u->U.Field.Module) {
		    fprintf(stderr, "%s.%s.%s (%s)\n",
			u->U.Field.Module->Identifier,
			u->U.Field.ObjectClass->U.Reference.Identifier,
			identifier, type);
		} else {
		    fprintf(stderr, "%s.%s (%s)\n",
			u->U.Field.ObjectClass->U.Reference.Identifier,
			identifier, type);
		}
	    }
	}
    }

    /* print the unexported symbols */
    if (unexported) {
	fprintf(stderr, "Following symbols have not been exported:\n");
	for (u = undef; u; u = u->Next) {
	    if (u->Type == eUndefinedSymbol_SymbolNotDefined ||
	        u->Type == eUndefinedSymbol_FieldNotDefined)
		continue;
	    if (u->Type == eUndefinedSymbol_SymbolNotExported &&
		FindUndefinedSymbol(ass, bad, u->U.Symbol.ReferenceType,
		u->U.Symbol.Identifier, u->U.Symbol.Module))
		continue;
	    if (u->Type == eUndefinedSymbol_FieldNotExported &&
		FindUndefinedField(ass, bad, u->U.Field.ReferenceFieldType,
		u->U.Field.ObjectClass, u->U.Field.Identifier,
		u->U.Field.Module))
		continue;
	    if (u->Type == eUndefinedSymbol_SymbolNotExported) {
		switch (u->U.Symbol.ReferenceType) {
		case eAssignment_Type:
		    type = "type";
		    break;
		case eAssignment_Value:
		    type = "value";
		    break;
		case eAssignment_ObjectClass:
		    type = "object class";
		    break;
		case eAssignment_Object:
		    type = "object";
		    break;
		case eAssignment_ObjectSet:
		    type = "object set";
		    break;
		case eAssignment_Macro:
		    type = "macro";
		    break;
		case eAssignment_Undefined:
		    if (isupper(*u->U.Symbol.Identifier))
			type = "type?";
		    else if (islower(*u->U.Symbol.Identifier))
			type = "value?";
		    else
			type = "?";
		    break;
		default:
		    MyAbort();
		    /*NOTREACHED*/
		}
		identifier = u->U.Symbol.Identifier ?
		    u->U.Symbol.Identifier : "<unnamed>";
		if (u->U.Symbol.Module) {
		    fprintf(stderr, "%s.%s (%s)\n",
			u->U.Symbol.Module->Identifier, identifier, type);
		} else {
		    fprintf(stderr, "%s (%s)\n", identifier, type);
		}
	    } else {
		switch (u->U.Field.ReferenceFieldType) {
		case eSetting_Type:
		    type = "type field";
		    break;
		case eSetting_Value:
		    type = "value field";
		    break;
		case eSetting_ValueSet:
		    type = "value set field";
		    break;
		case eSetting_Object:
		    type = "object field";
		    break;
		case eSetting_ObjectSet:
		    type = "object set field";
		    break;
		case eAssignment_Macro:
		    type = "macro";
		    break;
		default:
		    MyAbort();
		    /*NOTREACHED*/
		}
		identifier = u->U.Field.Identifier ?
		    u->U.Field.Identifier : "<unnamed>";
		if (u->U.Field.Module) {
		    fprintf(stderr, "%s.%s.%s (%s)\n",
			u->U.Field.Module->Identifier,
			u->U.Field.ObjectClass->U.Reference.Identifier,
			identifier, type);
		} else {
		    fprintf(stderr, "%s.%s (%s)\n",
			u->U.Field.ObjectClass->U.Reference.Identifier,
			identifier, type);
		}
	    }
	}
    }
    MyExit(1);
}

/* compare two undefined symbol entries */
/* return 0 if equal */
int CmpUndefinedSymbol(AssignmentList_t ass, UndefinedSymbol_t *u1, UndefinedSymbol_t *u2) {
    if (u1->Type != u2->Type)
	return 1;
    switch (u1->Type) {
    case eUndefinedSymbol_SymbolNotExported:
    case eUndefinedSymbol_SymbolNotDefined:
        return strcmp(u1->U.Symbol.Identifier, u2->U.Symbol.Identifier) ||
	    u1->U.Symbol.Module && !u2->U.Symbol.Module ||
	    !u1->U.Symbol.Module && u2->U.Symbol.Module ||
	    u1->U.Symbol.Module && u2->U.Symbol.Module &&
	    CmpModuleIdentifier(ass, u1->U.Symbol.Module, u2->U.Symbol.Module);
    case eUndefinedSymbol_FieldNotExported:
    case eUndefinedSymbol_FieldNotDefined:
        return strcmp(u1->U.Field.Identifier, u2->U.Field.Identifier) ||
	    strcmp(u1->U.Field.ObjectClass->U.Reference.Identifier,
	    u2->U.Field.ObjectClass->U.Reference.Identifier) ||
	    CmpModuleIdentifier(ass,
	    u1->U.Field.ObjectClass->U.Reference.Module,
	    u2->U.Field.ObjectClass->U.Reference.Module) ||
	    u1->U.Field.Module && !u2->U.Field.Module ||
	    !u1->U.Field.Module && u2->U.Field.Module ||
	    u1->U.Field.Module && u2->U.Field.Module &&
	    CmpModuleIdentifier(ass, u1->U.Field.Module, u2->U.Field.Module);
    default:
	MyAbort();
	/*NOTREACHED*/
    }
    return 1; // not equal
}

/* compare two lists of undefined symbols */
int CmpUndefinedSymbolList(AssignmentList_t ass, UndefinedSymbolList_t u1, UndefinedSymbolList_t u2) {
    for (; u1 && u2; u1 = u1->Next, u2 = u2->Next) {
	if (CmpUndefinedSymbol(ass, u1, u2))
	    return 1;
    }
    return u1 || u2;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\asn1\asn1c\util.c ===
/* Copyright (C) Boris Nikolaus, Germany, 1996-1997. All rights reserved. */
/* Copyright (C) Microsoft Corporation, 1997-1998. All rights reserved. */

#include "precomp.h"

extern int g_fLongNameForImported;

/* get the type by resolving references */
Type_t *
GetType(AssignmentList_t ass, Type_t *type)
{
    if (!type)
        return NULL;
    if (IsReferenceType(type))
        return GetType(ass, GetReferencedType(ass, type));
    return type;
}

/* get the type's type by resolving references */
Type_e
GetTypeType(AssignmentList_t ass, Type_t *type)
{
    type = GetType(ass, type);
    return type ? type->Type : eType_Undefined;
}

/* get the type rules */
TypeRules_e
GetTypeRules(AssignmentList_t ass, Type_t *type)
{
    if (!IsReferenceType(type))
        return type->Rules;
    return type->Rules | GetTypeRules(ass, GetReferencedType(ass, type));
}

/* get the value by resolving references */
Value_t *
GetValue(AssignmentList_t ass, Value_t *value)
{
    Assignment_t *a;

    if (!value)
        return NULL;
    if (!value->Type) {
        a = GetAssignment(ass, FindAssignment(ass, eAssignment_Value,
            value->U.Reference.Identifier, value->U.Reference.Module));
        if (!a)
            return NULL;
        return GetValue(ass, a->U.Value.Value);
    }
    return value;
}

/* get the object class by resolving references */
ObjectClass_t *
GetObjectClass(AssignmentList_t ass, ObjectClass_t *oc)
{
    Assignment_t *a;
    FieldSpec_t *fs;
    ObjectClass_t *oc2;

    if (!oc)
        return NULL;
    switch (oc->Type) {
    case eObjectClass_Reference:
        a = GetAssignment(ass, FindAssignment(ass, eAssignment_ObjectClass,
            oc->U.Reference.Identifier, oc->U.Reference.Module));
        if (!a)
            return NULL;
        return GetObjectClass(ass, a->U.ObjectClass.ObjectClass);
    case eObjectClass_FieldReference:
        oc2 = GetObjectClass(ass, oc->U.FieldReference.ObjectClass);
        if (!oc2)
            return NULL;
        fs = GetFieldSpec(ass, FindFieldSpec(oc2->U.ObjectClass.FieldSpec,
            oc->U.FieldReference.Identifier));
        if (!fs)
            return NULL;
        if (fs->Type == eFieldSpec_Object)
            return GetObjectClass(ass, fs->U.Object.ObjectClass);
        else if (fs->Type == eFieldSpec_ObjectSet)
            return GetObjectClass(ass, fs->U.ObjectSet.ObjectClass);
        else
            return NULL;
    }
    return oc;
}

/* get the object by resolving references */
Object_t *
GetObject(AssignmentList_t ass, Object_t *o)
{
    Assignment_t *a;

    if (!o)
        return NULL;
    if (o->Type == eObject_Reference) {
        a = GetAssignment(ass, FindAssignment(ass, eAssignment_Object,
            o->U.Reference.Identifier, o->U.Reference.Module));
        if (!a)
            return NULL;
        return GetObject(ass, a->U.Object.Object);
    }
    return o;
}

/* get the object set by resolving references */
ObjectSet_t *
GetObjectSet(AssignmentList_t ass, ObjectSet_t *os)
{
    Assignment_t *a;

    if (!os)
        return NULL;
    if (os->Type == eObjectSet_Reference) {
        a = GetAssignment(ass, FindAssignment(ass, eAssignment_ObjectSet,
            os->U.Reference.Identifier, os->U.Reference.Module));
        if (!a)
            return NULL;
        return GetObjectSet(ass, a->U.ObjectSet.ObjectSet);
    }
    return os;
}

/* get the field spec */
FieldSpec_t *
GetFieldSpec(AssignmentList_t ass, FieldSpec_t *fs)
{
    return fs;
}

/* get the field spec type */
FieldSpecs_e
GetFieldSpecType(AssignmentList_t ass, FieldSpec_t *fs)
{
    return fs ? fs->Type : eFieldSpec_Undefined;
}

/* convert an identifier into C syntax */
char *
Identifier2C(char *identifier)
{
    char buffer[256];
    char *p = buffer;

    while (*identifier) {
        if (isalnum(*identifier))
            *p++ = *identifier;
        else
            *p++ = '_';
        identifier++;
    }
    *p = 0;
    return strdup(buffer);
}

/* convert an identifier into C syntax */
char *
PIdentifier2C(char *identifier)
{
    char buffer[256];
    char *p = buffer;

    *p++ = 'P';
    while (*identifier) {
        if (isalnum(*identifier))
            *p++ = *identifier;
        else
            *p++ = '_';
        identifier++;
    }
    *p = 0;
    return strdup(buffer);
}

/* get the integer type and the sign of an integer with the given bounds */
static char *
GetIType(intx_t *lb, intx_t *ub, int32_t *sign)
{
    enum {
        eint8 = 1,
        euint8 = 2,
        eint16 = 4,
        euint16 = 8,
        eint32 = 16,
        euint32 = 32,
        eint64 = 64,
        euint64 = 128,
        eintx = 256,
        euintx = 512
    } type;
    
    type = (eint8 | euint8 | eint16 | euint16 | eint32 | euint32 | eintx | euintx);
    if (Has64Bits)
        type |= eint64 | euint64;
    if (!intxisuint8(lb) || !intxisuint8(ub))
        type &= ~euint8;
    if (!intxisuint16(lb) || !intxisuint16(ub))
        type &= ~euint16;
    if (!intxisuint32(lb) || !intxisuint32(ub))
        type &= ~euint32;
    if (!intxisuint64(lb) || !intxisuint64(ub))
        type &= ~euint64;
    if (!intxisint8(lb) || !intxisint8(ub))
        type &= ~eint8;
    if (!intxisint16(lb) || !intxisint16(ub))
        type &= ~eint16;
    if (!intxisint32(lb) || !intxisint32(ub))
        type &= ~eint32;
    if (!intxisint64(lb) || !intxisint64(ub))
        type &= ~eint64;
    if (lb->value[0] >= 0x7f || ub->value[0] >= 0x7f)
        type &= ~euintx;
    if (type & euint8) {
        *sign = 1;
        return "ASN1uint16_t"; // lonchanc: for av; original is "ASN1uint8_t";
    }
    if (type & eint8) {
        *sign = -1;
        return "ASN1int8_t";
    }
    if (type & euint16) {
        *sign = 1;
        return "ASN1uint16_t";
    }
    if (type & eint16) {
        *sign = -1;
        return "ASN1int16_t";
    }
    if (type & euint32) {
        *sign = 1;
        return "ASN1uint32_t";
    }
    if (type & eint32) {
        *sign = -1;
        return "ASN1int32_t";
    }
    if (type & euint64) {
        *sign = 1;
        return "ASN1uint64_t";
    }
    if (type & eint64) {
        *sign = -1;
        return "ASN1int64_t";
    }
    if (type & euintx) {
        *sign = 1;
        return "ASN1intx_t";
    }
    if (type & eintx) {
        *sign = -1;
        return "ASN1intx_t";
    }
    MyAbort();
    /*NOTREACHED*/
    return NULL;
}

/* adjust the lower and upper bound according to the value constraints in */
/* the constraints list */
void GetMinMax(AssignmentList_t ass, ValueConstraintList_t constraints,
    EndPoint_t *lower, EndPoint_t *upper)
{
    ValueConstraint_t *vc;
    EndPoint_t lo, up;

    for (vc = constraints; vc; vc = vc->Next) {
        lo = vc->Lower;
        up = vc->Upper;
        if (CmpLowerEndPoint(ass, lower, &lo) > 0)
            *lower = lo;
        if (CmpUpperEndPoint(ass, upper, &up) < 0)
            *upper = up;
    }
}

/* get the integer type and the sign of an integer with the given bounds */
char *GetIntType(AssignmentList_t ass, EndPoint_t *lower, EndPoint_t *upper, int32_t *sign)
{
    char *inttype;

    if (!(lower->Flags & eEndPoint_Min) &&
        !(upper->Flags & eEndPoint_Max)) {
        inttype = GetIType(&GetValue(ass, lower->Value)->U.Integer.Value,
            &GetValue(ass, upper->Value)->U.Integer.Value, sign);
    } else {
        if (!(lower->Flags & eEndPoint_Min) &&
            intx_cmp(&GetValue(ass, lower->Value)->U.Integer.Value, &intx_0) >= 0) {
            inttype = UIntegerRestriction;
            *sign = 1;
        } else {
            inttype = IntegerRestriction;
            *sign = -1;
        }
        if (!strncmp(inttype, "ASN1uint", 8))
            *sign = 1;
        else if (!strncmp(inttype, "ASN1int", 7))
            *sign = -1;
    }
    return inttype;
}

/* get the integer type and the sign of an integer type */
char *GetIntegerType(AssignmentList_t ass, Type_t *type, int32_t *sign)
{
    EndPoint_t lower, upper;

    if (type->PrivateDirectives.fIntx)
    {
        return "ASN1intx_t";
    }

    lower.Flags = eEndPoint_Max;
    upper.Flags = eEndPoint_Min;
    GetMinMax(ass, type->PERConstraints.Value.Root, &lower, &upper);
    if (type->PERConstraints.Value.Type == eExtension_Extended)
        GetMinMax(ass, type->PERConstraints.Value.Additional,
            &lower, &upper);
    if (lower.Flags & eEndPoint_Max)
        lower.Flags = eEndPoint_Min;
    if (upper.Flags & eEndPoint_Min)
        upper.Flags = eEndPoint_Max;
    return GetIntType(ass, &lower, &upper, sign);
}

/* get the real type */
/*ARGSUSED*/
char *GetRealType(Type_t *type)
{
    return RealRestriction;
}

/* get the boolean type */
char *GetBooleanType()
{
    return "ASN1bool_t";
}

/* get the enumerated type */
char *GetEnumeratedType(AssignmentList_t ass, Type_t *type, int32_t *sign)
{
#if 1 // added by Microsoft
    return "ASN1enum_t";
#else
    EndPoint_t lower, upper, ep;
    NamedNumber_t *namedNumbers;

    lower.Flags = eEndPoint_Max;
    upper.Flags = eEndPoint_Min;
    ep.Flags = 0;
    for (namedNumbers = type->U.Enumerated.NamedNumbers; namedNumbers;
        namedNumbers = namedNumbers->Next) {
        switch (namedNumbers->Type) {
        case eNamedNumber_Normal:
            ep.Value = namedNumbers->U.Normal.Value;
            if (CmpLowerEndPoint(ass, &lower, &ep) > 0)
                lower = ep;
            if (CmpUpperEndPoint(ass, &upper, &ep) < 0)
                upper = ep;
            break;
        case eNamedNumber_ExtensionMarker:
            break;
        }
    }
    if (lower.Flags & eEndPoint_Max)
        lower.Flags = eEndPoint_Min;
    if (upper.Flags & eEndPoint_Min)
        upper.Flags = eEndPoint_Max;
    return GetIntType(ass, &lower, &upper, sign);
#endif
}

/* get the type of an choice selector */
char *GetChoiceType(Type_t *type)
{
#if 1 // added by Microsoft
    return "ASN1choice_t";
#else
    uint32_t nchoice;
    Component_t *components;

    nchoice = 0;
    for (components = type->U.Choice.Components; components;
        components = components->Next) {
        switch (components->Type) {
        case eComponent_Normal:
            nchoice++;
            break;
        case eComponent_ExtensionMarker:
            nchoice++; /* one reserved value for unknown extensions */
            break;
        default:
            MyAbort();
        }
    }
    if (nchoice < 0x100)
        return "ASN1uint8_t";
    if (nchoice < 0x10000)
        return "ASN1uint16_t";
    return "ASN1uint32_t";
#endif
}

/* get the type of a string */
char *GetStringType(AssignmentList_t ass, Type_t *type, int32_t *noctets, uint32_t *zero)
{
    EndPoint_t lower, upper;
    uint32_t up;

    type = GetType(ass, type);
    *zero = type->PrivateDirectives.fLenPtr ? 0 : 1; // null terminator

    /* get the upper bound and zero flag of the type */
    switch (type->Type) {
    case eType_NumericString:
        up = 0x39;
        break;
    case eType_PrintableString:
        up = 0x7a;
        break;
    case eType_ISO646String:
    case eType_VisibleString:
        up = 0x7e;
        break;
    case eType_IA5String:
        up = 0x7f;
        // *zero = 0;
        break;
    case eType_UTF8String:
        up = 0xffff;
        break;
    case eType_BMPString:
        up = 0xffff;
        *zero = 0; // must be unbounded
        break;
    case eType_UniversalString:
        up = 0xffffffff;
        *zero = 0; // must be unbounded
        break;
    case eType_GeneralString:
    case eType_GraphicString:
        up = 0xff;
        break;
    case eType_TeletexString:
        up = 0xff;
        break;
    case eType_T61String:
        up = 0xff;
        break;
    case eType_VideotexString:
        up = 0xff;
        break;
    default:
        MyAbort();
        /*NOTREACHED*/
    }
    lower.Flags = eEndPoint_Max;
    upper.Flags = 0;
    upper.Value = NewValue(NULL, NewType(eType_RestrictedString));
    upper.Value->U.RestrictedString.Value.length = 1;
    upper.Value->U.RestrictedString.Value.value = &up;

    /* apply permitted alphabet constraints */
    if (type->PERConstraints.PermittedAlphabet.Type !=
        eExtension_Unconstrained) {
        GetMinMax(ass, type->PERConstraints.PermittedAlphabet.Root,
            &lower, &upper);
        if (type->PERConstraints.PermittedAlphabet.Type == eExtension_Extended)
            GetMinMax(ass, type->PERConstraints.PermittedAlphabet.Additional,
                &lower, &upper);
    }

    /* set zero flag if the resulting type rejects the 0-character */
    if (!(lower.Flags & eEndPoint_Max) &&
        *GetValue(ass, lower.Value)->U.RestrictedString.Value.value > 0)
        *zero = 1;

    /* get the number of octets needed for a character */
    *noctets = uint32_uoctets(
        *GetValue(ass, upper.Value)->U.RestrictedString.Value.value);

    /* if the type is marked as zero-terminated or length/value, use the */
    /* appropriate type */
    if (GetTypeRules(ass, type) & eTypeRules_ZeroTerminated)
        *zero = 1;
    else if (GetTypeRules(ass, type) & (eTypeRules_LengthPointer|eTypeRules_FixedArray))
        *zero = 0;

    /* return the correct type */
    if (*zero) {
        if (*noctets == 1)
        {
#ifdef ENABLE_CHAR_STR_SIZE
        if (g_eEncodingRule == eEncoding_Packed &&
            type->PERTypeInfo.Root.LConstraint == ePERSTIConstraint_Constrained)
        {
            return "ASN1char_t";
        }
        else
        {
                return "ASN1ztcharstring_t";
        }
#else
            return "ASN1ztcharstring_t";
#endif
        }
        if (*noctets == 2)
            return "ASN1ztchar16string_t";
        *noctets = 4;
        return "ASN1ztchar32string_t";
    } else {
        if (*noctets == 1)
            return "ASN1charstring_t";
        if (*noctets == 2)
            return "ASN1char16string_t";
        *noctets = 4;
        return "ASN1char32string_t";
    }
}

/* check if a type is a restricted string type */
int IsRestrictedString(Type_e type)
{
    return
        type == eType_NumericString ||
        type == eType_PrintableString ||
        type == eType_TeletexString ||
        type == eType_T61String ||
        type == eType_VideotexString ||
        type == eType_IA5String ||
        type == eType_GraphicString ||
        type == eType_VisibleString ||
        type == eType_ISO646String ||
        type == eType_GeneralString ||
        type == eType_UniversalString ||
        type == eType_BMPString ||
        type == eType_RestrictedString;
}

/* create a reference to a value */
char *Reference(char *p)
{
    char *q;

    if (*p == '*')
        return p + 1;
    q = (char *)malloc(strlen(p) + 2);
    *q = '&';
    strcpy(q + 1, p);
    return q;
}

/* create a dereference to a value */
char *Dereference(char *p)
{
    char *q;

    if (*p == '&')
        return p + 1;
    q = (char *)malloc(strlen(p) + 2);
    *q = '*';
    strcpy(q + 1, p);
    return q;
}

/* get the name of a type */
char *GetTypeName(AssignmentList_t ass, Type_t *t)
{
    Assignment_t *a;
    int32_t noctets;
    uint32_t zero;
    int32_t sign;
    char buf[256];
    char *p;

    switch (t->Type) {
    case eType_Boolean:
        return GetBooleanType();
    case eType_Integer:
        return GetIntegerType(ass, t, &sign);
    case eType_BitString:
        return "ASN1bitstring_t";
    case eType_OctetString:
        return "ASN1octetstring_t";
    case eType_UTF8String:
        return "ASN1wstring_t";
    case eType_Null:
        MyAbort();
        /*NOTREACHED*/
    case eType_ObjectIdentifier:
        if (t->PrivateDirectives.fOidPacked)
        {
            return "ASN1encodedOID_t";
        }
        return t->PrivateDirectives.fOidArray ? "ASN1objectidentifier2_t" : "ASN1objectidentifier_t";
    case eType_Real:
        return GetRealType(t);
    case eType_Enumerated:
        return GetEnumeratedType(ass, t, &sign);
    case eType_EmbeddedPdv:
        return "ASN1embeddedpdv_t";
    case eType_Sequence:
    case eType_SequenceOf:
    case eType_Set:
    case eType_SetOf:
    case eType_Choice:
    case eType_InstanceOf:
        MyAbort();
        /*NOTREACHED*/
    case eType_NumericString:
    case eType_PrintableString:
    case eType_VisibleString:
    case eType_ISO646String:
    case eType_GraphicString:
    case eType_GeneralString:
    case eType_IA5String:
    case eType_UniversalString:
    case eType_BMPString:
    case eType_TeletexString:
    case eType_T61String:
    case eType_VideotexString:
        return GetStringType(ass, t, &noctets, &zero);
    case eType_UTCTime:
        return "ASN1utctime_t";
    case eType_GeneralizedTime:
        return "ASN1generalizedtime_t";
    case eType_ObjectDescriptor:
        return "ASN1objectdescriptor_t";
    case eType_External:
        return "ASN1external_t";
    case eType_CharacterString:
        return "ASN1characterstring_t";
        /*NOTREACHED*/
    case eType_Selection:
        MyAbort();
        /*NOTREACHED*/
    case eType_Reference:
        a = FindAssignment(ass, eAssignment_Type,
            t->U.Reference.Identifier, t->U.Reference.Module);
        return GetName(a);
    case eType_FieldReference:
        p = GetObjectClassName(ass, t->U.FieldReference.ObjectClass);
        sprintf(buf, "%s_%s", p, t->U.FieldReference.Identifier);
        return Identifier2C(buf);
    case eType_RestrictedString:
        MyAbort();
        /*NOTREACHED*/
    case eType_Open:
        return "ASN1open_t";
    case eType_Undefined:
        MyAbort();
        /*NOTREACHED*/
    }
	/*NOTREACHED*/
	return NULL;
}

/* get the name of a type */
char *PGetTypeName(AssignmentList_t ass, Type_t *t)
{
    Assignment_t *a;

    if (t->Type == eType_Reference)
    {
        a = FindAssignment(ass, eAssignment_Type,
                t->U.Reference.Identifier, t->U.Reference.Module);
        return IsPSetOfType(ass, a) ? PGetName(ass, a) : GetName(a);
    }
    return GetTypeName(ass, t);
}

/* get the name of a value */
char *GetValueName(AssignmentList_t ass, Value_t *value)
{
    Assignment_t *a;

    if (value->Type)
        MyAbort();
    a = FindAssignment(ass, eAssignment_Value,
        value->U.Reference.Identifier, value->U.Reference.Module);
    return GetName(a);
}

/* get the name of an object class */
char *GetObjectClassName(AssignmentList_t ass, ObjectClass_t *oc)
{
    Assignment_t *a;

    switch (oc->Type) {
    case eObjectClass_Reference:
        a = FindAssignment(ass, eAssignment_ObjectClass,
            oc->U.Reference.Identifier, oc->U.Reference.Module);
        return GetName(a);
    default:
        MyAbort();
        /*NOTREACHED*/
    }
    return NULL;
}

/* check if a type is of structured type */
int IsStructuredType(Type_t *type)
{
    switch (type->Type) {
    case eType_Sequence:
    case eType_SequenceOf:
    case eType_Set:
    case eType_SetOf:
    case eType_Choice:
    case eType_InstanceOf:
        return 1;
    default:
        return 0;
    }
}

/* check if a type is of sequence type */
int IsSequenceType(Type_t *type)
{
    switch (type->Type) {
    case eType_Sequence:
    case eType_Set:
    case eType_Choice:
    case eType_Real:
    case eType_External:
    case eType_EmbeddedPdv:
    case eType_CharacterString:
    case eType_InstanceOf:
        return 1;
    default:
        return 0;
    }
}

/* check if a type is a reference type */
int IsReferenceType(Type_t *type)
{
    switch (type->Type) {
    case eType_Reference:
    case eType_FieldReference:
        return 1;
    default:
        return 0;
    }
}

/* get the tag of a type */
Tag_t *GetTag(AssignmentList_t ass, Type_t *type)
{
    Type_t *type2;
    for (;;) {
        if (type->Tags || !IsReferenceType(type))
            return type->Tags;
        type2 = GetReferencedType(ass, type);
        /*XXX self-referencing types will idle forever */
        if (type == type2)
        {
            ASSERT(0);
            return NULL;
        }
        type = type2;
    }
    /*NOTREACHED*/
}

/* get the number of octets of a C type */
int32_t GetOctets(char *inttype)
{
    if (!strcmp(inttype, "ASN1uint8_t"))
        return sizeof(ASN1uint8_t);
    if (!strcmp(inttype, "ASN1uint16_t"))
        return sizeof(ASN1uint16_t);
    if (!strcmp(inttype, "ASN1uint32_t"))
        return sizeof(ASN1uint32_t);
    if (!strcmp(inttype, "ASN1uint64_t"))
        return 8;
    if (!strcmp(inttype, "ASN1int8_t"))
        return sizeof(ASN1int8_t);
    if (!strcmp(inttype, "ASN1int16_t"))
        return sizeof(ASN1int16_t);
    if (!strcmp(inttype, "ASN1int32_t"))
        return sizeof(ASN1int32_t);
    if (!strcmp(inttype, "ASN1int64_t"))
        return 8;
    if (!strcmp(inttype, "ASN1intx_t"))
        return 0;
    if (!strcmp(inttype, "ASN1bool_t"))
        return sizeof(ASN1bool_t);
    if (!strcmp(inttype, "ASN1char_t"))
        return sizeof(ASN1char_t);
    if (!strcmp(inttype, "ASN1char16_t"))
        return sizeof(ASN1char16_t);
    if (!strcmp(inttype, "ASN1char32_t"))
        return sizeof(ASN1char32_t);
    if (!strcmp(inttype, "double"))
        return 8;
    if (!strcmp(inttype, "ASN1real_t"))
        return 0;
    // added by Microsoft
    if (!strcmp(inttype, "ASN1enum_t"))
        return sizeof(ASN1enum_t);
    if (!strcmp(inttype, "ASN1choice_t"))
        return sizeof(ASN1choice_t);
    MyAbort();
    /*NOTREACHED*/
    return 0;
}

/* compare two values; return 0 if equal */
int CmpValue(AssignmentList_t ass, Value_t *v1, Value_t *v2)
{
    uint32_t i;
    int32_t d;
    Type_e t1, t2;

    v1 = GetValue(ass, v1);
    v2 = GetValue(ass, v2);
    t1 = GetTypeType(ass, v1->Type);
    t2 = GetTypeType(ass, v2->Type);
    if (t1 == eType_Integer && t2 == eType_Integer) {
        return intx_cmp(&v1->U.Integer.Value, &v2->U.Integer.Value);
    }
    if (t1 == eType_ObjectIdentifier && t2 == eType_ObjectIdentifier) {
        d = v1->U.ObjectIdentifier.Value.length -
            v2->U.ObjectIdentifier.Value.length;
        if (d)
            return d;
        for (i = 0; i < v1->U.ObjectIdentifier.Value.length; i++) {
            d = v1->U.ObjectIdentifier.Value.value[i] -
                v2->U.ObjectIdentifier.Value.value[i];
            if (d)
                return d;
        }
        return 0;
    }
    if (IsRestrictedString(t1) && IsRestrictedString(t2)) {
        if (v1->U.RestrictedString.Value.length != 1 ||
            v2->U.RestrictedString.Value.length != 1)
            MyAbort();
        if (*v1->U.RestrictedString.Value.value <
            *v2->U.RestrictedString.Value.value)
            return -1;
        if (*v1->U.RestrictedString.Value.value >
            *v2->U.RestrictedString.Value.value)
            return 1;
        return 0;
    }
    MyAbort();
    /*NOTREACHED*/
    return 1; // not equal
}

/* substract two values (integer/character) */
int SubstractValues(AssignmentList_t ass, intx_t *diff, Value_t *v1, Value_t *v2)
{
    v1 = GetValue(ass, v1);
    v2 = GetValue(ass, v2);
    switch (GetTypeType(ass, v1->Type)) {
    case eType_Integer:
            intx_sub(diff, &v1->U.Integer.Value, &v2->U.Integer.Value);
        return 1;
    default:
            if (IsRestrictedString(GetTypeType(ass, v1->Type))) {
            if (v1->U.RestrictedString.Value.length != 1 ||
                v2->U.RestrictedString.Value.length != 1)
                return 0;
            intx_setuint32(diff, v2->U.RestrictedString.Value.value[0] -
                v1->U.RestrictedString.Value.value[0]);
            return 1;
        }
        break;
    }
    MyAbort();
    /*NOTREACHED*/
    return 0;
}

/* get the lower endpoint; adjust endpoint if the endpoint is "open" */
/* (means "not including the value") */
EndPoint_t *GetLowerEndPoint(AssignmentList_t ass, EndPoint_t *e)
{
    EndPoint_t *newe;
    Type_t *type;

    if ((e->Flags & eEndPoint_Min) || !(e->Flags & eEndPoint_Open))
        return e;
    type = GetType(ass, GetValue(ass, e->Value)->Type);
    switch (type->Type) {
    case eType_Integer:
        newe = NewEndPoint();
        newe->Value = NewValue(ass, type);
        intx_add(&newe->Value->U.Integer.Value, &e->Value->U.Integer.Value,
            &intx_1);
        return newe;
    case eType_NumericString:
    case eType_PrintableString:
    case eType_TeletexString:
    case eType_T61String:
    case eType_VideotexString:
    case eType_IA5String:
    case eType_GraphicString:
    case eType_VisibleString:
    case eType_ISO646String:
    case eType_GeneralString:
    case eType_UniversalString:
    case eType_BMPString:
    case eType_RestrictedString:
        newe = NewEndPoint();
        newe->Value = NewValue(ass, type);
        newe->Value->U.RestrictedString.Value.length = 1;
        newe->Value->U.RestrictedString.Value.value =
            (char32_t *)malloc(sizeof(char32_t));
        *newe->Value->U.RestrictedString.Value.value =
            *e->Value->U.RestrictedString.Value.value + 1;
        return newe;
    default:
        return e;
    }
}

/* get the upper endpoint; adjust endpoint if the endpoint is "open" */
/* (means "not including the value") */
EndPoint_t *GetUpperEndPoint(AssignmentList_t ass, EndPoint_t *e)
{
    EndPoint_t *newe;
    Type_t *type;

    if ((e->Flags & eEndPoint_Max) || !(e->Flags & eEndPoint_Open))
        return e;
    type = GetType(ass, GetValue(ass, e->Value)->Type);
    switch (type->Type) {
    case eType_Integer:
        newe = NewEndPoint();
        newe->Value = NewValue(ass, type);
        intx_sub(&newe->Value->U.Integer.Value, &e->Value->U.Integer.Value,
            &intx_1);
        return newe;
    case eType_NumericString:
    case eType_PrintableString:
    case eType_TeletexString:
    case eType_T61String:
    case eType_VideotexString:
    case eType_IA5String:
    case eType_GraphicString:
    case eType_VisibleString:
    case eType_ISO646String:
    case eType_GeneralString:
    case eType_UniversalString:
    case eType_BMPString:
    case eType_RestrictedString:
        newe = NewEndPoint();
        newe->Value = NewValue(ass, type);
        newe->Value->U.RestrictedString.Value.length = 1;
        newe->Value->U.RestrictedString.Value.value =
            (char32_t *)malloc(sizeof(char32_t));
        *newe->Value->U.RestrictedString.Value.value =
            *e->Value->U.RestrictedString.Value.value - 1;
        return newe;
    default:
        return e;
    }
}

/* compare two lower endpoints */
int CmpLowerEndPoint(AssignmentList_t ass, EndPoint_t *e1, EndPoint_t *e2)
{
    int ret;

    e1 = GetLowerEndPoint(ass, e1);
    e2 = GetLowerEndPoint(ass, e2);
    if (e1->Flags & eEndPoint_Min) {
            if (e2->Flags & eEndPoint_Min)
            return 0;
        return -1;
    } else if (e2->Flags & eEndPoint_Min) {
            return 1;
    } else if (e1->Flags & eEndPoint_Max) {
            if (e2->Flags & eEndPoint_Max)
            return 0;
        return 1;
    } else if (e2->Flags & eEndPoint_Max) {
            return -1;
    } else {
        ret = CmpValue(ass, e1->Value, e2->Value);
        if (ret != 0)
            return ret;
        if (e1->Flags & eEndPoint_Open) {
            if (e2->Flags & eEndPoint_Open)
                return 0;
            else
                return 1;
        } else {
            if (e2->Flags & eEndPoint_Open)
                return -1;
            else
                return 0;
        }
    }
}

/* compare two upper endpoints */
int CmpUpperEndPoint(AssignmentList_t ass, EndPoint_t *e1, EndPoint_t *e2)
{
    int ret;

    e1 = GetUpperEndPoint(ass, e1);
    e2 = GetUpperEndPoint(ass, e2);
    if (e1->Flags & eEndPoint_Min) {
            if (e2->Flags & eEndPoint_Min)
            return 0;
        return -1;
    } else if (e2->Flags & eEndPoint_Min) {
            return 1;
    } else if (e1->Flags & eEndPoint_Max) {
            if (e2->Flags & eEndPoint_Max)
            return 0;
        return 1;
    } else if (e2->Flags & eEndPoint_Max) {
            return -1;
    } else {
        ret = CmpValue(ass, e1->Value, e2->Value);
        if (ret != 0)
            return ret;
        if (e1->Flags & eEndPoint_Open) {
            if (e2->Flags & eEndPoint_Open)
                return 0;
            else
                return -1;
        } else {
            if (e2->Flags & eEndPoint_Open)
                return 1;
            else
                return 0;
        }
    }
}

/* compare a lower and an upper endpoints */
int CmpLowerUpperEndPoint(AssignmentList_t ass, EndPoint_t *e1, EndPoint_t *e2)
{
    int ret;

    e1 = GetLowerEndPoint(ass, e1);
    e2 = GetUpperEndPoint(ass, e2);
    if (e1->Flags & eEndPoint_Min) {
            if (e2->Flags & eEndPoint_Min)
            return 0;
        return -1;
    } else if (e2->Flags & eEndPoint_Min) {
            return 1;
    } else if (e1->Flags & eEndPoint_Max) {
            if (e2->Flags & eEndPoint_Max)
            return 0;
        return 1;
    } else if (e2->Flags & eEndPoint_Max) {
            return -1;
    } else {
        ret = CmpValue(ass, e1->Value, e2->Value);
        if (ret != 0)
            return ret;
        if ((e1->Flags & eEndPoint_Open) || (e2->Flags & eEndPoint_Open))
            return 1;
        else
            return 0;
    }
}

/* check whether two EndPoint_t's join together */
int CheckEndPointsJoin(AssignmentList_t ass, EndPoint_t *e1, EndPoint_t *e2)
{
    intx_t ix;
    Value_t *v1, *v2;

    /* check if endpoints overlap */
    if (CmpLowerUpperEndPoint(ass, e2, e1) <= 0)
        return 1;

    e1 = GetUpperEndPoint(ass, e1);
    e2 = GetLowerEndPoint(ass, e2);
    v1 = GetValue(ass, e1->Value);
    v2 = GetValue(ass, e2->Value);
    switch (GetTypeType(ass, v1->Type)) {
    case eType_Integer:
        /* check for subsequent integers */
            intx_dup(&ix, &v1->U.Integer.Value);
        intx_inc(&ix);
        return intx_cmp(&ix, &v2->U.Integer.Value) >= 0;
    case eType_NumericString:
    case eType_PrintableString:
    case eType_TeletexString:
    case eType_T61String:
    case eType_VideotexString:
    case eType_IA5String:
    case eType_GraphicString:
    case eType_VisibleString:
    case eType_ISO646String:
    case eType_GeneralString:
    case eType_UniversalString:
    case eType_BMPString:
    case eType_RestrictedString:
        /* reject multiple characters */
            if (v1->U.RestrictedString.Value.length != 1 ||
                v2->U.RestrictedString.Value.length != 1)
            MyAbort();

        /* beware of wrap around */
        if (v1->U.RestrictedString.Value.value[0] == 0xffffffff &&
            v2->U.RestrictedString.Value.value[0] == 0)
            return 0;

        /* check for subsequent characters */
        return v2->U.RestrictedString.Value.value[0] -
            v1->U.RestrictedString.Value.value[0] == 1;
    }
    MyAbort();
    /*NOTREACHED*/
    return 0;
}

/* compare two module identifiers; return 0 if equal */
int CmpModuleIdentifier(AssignmentList_t ass, ModuleIdentifier_t *mod1, ModuleIdentifier_t *mod2)
{
    if (mod1->ObjectIdentifier && mod2->ObjectIdentifier)
        return CmpValue(ass, mod1->ObjectIdentifier, mod2->ObjectIdentifier);
    if (mod1->Identifier && mod2->Identifier)
        return strcmp(mod1->Identifier, mod2->Identifier);
    return 0;
}

/* get the name of an assignment */
char *GetNameEx(AssignmentList_t ass, AssignmentList_t a, int fPSetOf)
{
    char *p;
    char *ide;
    char *mod;

    if (a->Type == eAssignment_Type &&
        a->U.Type.Type && a->U.Type.Type->PrivateDirectives.pszTypeName)
    {
        if (fPSetOf && IsPSetOfType(ass, a))
        {
            ide = PIdentifier2C(a->U.Type.Type->PrivateDirectives.pszTypeName);
        }
        else
        {
            ide = Identifier2C(a->U.Type.Type->PrivateDirectives.pszTypeName);
        }
    }
    else
    {
        if (fPSetOf && IsPSetOfType(ass, a))
        {
            ide = PIdentifier2C(a->Identifier);
        }
        else
        {
            ide = Identifier2C(a->Identifier);
        }
    }

// LONCHANC: disable the following code per MikeV.
    if (g_fLongNameForImported)
    {
        if (!(a->Flags & eAssignmentFlags_LongName))
            return ide;
        mod = Identifier2C(a->Module->Identifier);
        p = (char *)malloc(strlen(mod) + strlen(ide) + 2);
        sprintf(p, "%s_%s", mod, ide);
        return p;
    }
    else
    {
        return ide;
    }
}

/* get the name of an assignment */
char *GetName(AssignmentList_t a)
{
    return GetNameEx(NULL, a, 0);
}
char *PGetName(AssignmentList_t ass, AssignmentList_t a)
{
    return GetNameEx(ass, a, 1);
}

/* convert a 32 bit string into a generalized time */
int String2GeneralizedTime(generalizedtime_t *time, char32string_t *string)
{
    char str[64];
    unsigned i;

    if (string->length > 63 || string->length < 10)
        return 0;
    for (i = 0; i < string->length; i++)
        str[i] = (char)string->value[i];
    str[i] = 0;
    return string2generalizedtime(time, str);
}

/* convert a 32 bit string into an utc time */
int String2UTCTime(utctime_t *time, char32string_t *string)
{
    char str[64];
    unsigned i;

    if (string->length > 63 || string->length < 10)
        return 0;
    for (i = 0; i < string->length; i++)
        str[i] = (char)string->value[i];
    str[i] = 0;
    return string2utctime(time, str);
}

/* build an intersection of two constraints */
void IntersectConstraints(Constraint_t **ret, Constraint_t *c1, Constraint_t *c2)
{
    ElementSetSpec_t *e;

    if (!c2) {
        *ret = c1;
        return;
    }
    if (!c1) {
        *ret = c2;
        return;
    }
    *ret = NewConstraint();
    if (!c1->Root) {
        (*ret)->Root = c2->Root;
    } else if (!c2->Root) {
        (*ret)->Root = c1->Root;
    } else {
        (*ret)->Root = e = NewElementSetSpec(eElementSetSpec_Intersection);
        e->U.Intersection.Elements1 = c1->Root;
        e->U.Intersection.Elements2 = c2->Root;
    }
    if (c1->Type > c2->Type)
        (*ret)->Type = c1->Type;
    else
        (*ret)->Type = c2->Type;
    if ((*ret)->Type == eExtension_Extended) {
        if (c1->Type != eExtension_Extended || !c1->Additional) {
            (*ret)->Additional = c2->Additional;
        } else if (c2->Type != eExtension_Extended || !c2->Additional) {
            (*ret)->Additional = c1->Additional;
        } else {
            (*ret)->Additional = e =
                NewElementSetSpec(eElementSetSpec_Intersection);
            e->U.Intersection.Elements1 = c1->Additional;
            e->U.Intersection.Elements2 = c2->Additional;
        }
    }
}

/* find a field spec by name of an object class */
FieldSpec_t *GetObjectClassField(AssignmentList_t ass, ObjectClass_t *oc, char *field)
{
    oc = GetObjectClass(ass, oc);
    if (!oc)
        return NULL;
    return GetFieldSpec(ass, FindFieldSpec(oc->U.ObjectClass.FieldSpec, field));
}

/* find a field spec by name list of an object class */
FieldSpec_t *GetFieldSpecFromObjectClass(AssignmentList_t ass, ObjectClass_t *oc, StringList_t sl)
{
    FieldSpec_t *fs;

    for (; sl; sl = sl->Next) {
        fs = GetObjectClassField(ass, oc, sl->String);
        if (!fs)
            return NULL;
        if (!sl->Next)
            return fs;
        if (fs->Type == eFieldSpec_Object)
            oc = fs->U.Object.ObjectClass;
        else if (fs->Type == eFieldSpec_ObjectSet)
            oc = fs->U.ObjectSet.ObjectClass;
        else
            return NULL;
    }
    return NULL;
}

/* get the default setting of a field spec */
static Setting_t *GetDefaultSetting(FieldSpec_t *fs)
{
    Setting_t *ret = NULL;
    Optionality_t *op;

    switch (fs->Type) {
    case eFieldSpec_Type:
        op = fs->U.Type.Optionality;
        if (op && op->Type == eOptionality_Default_Type) {
            ret = NewSetting(eSetting_Type);
            ret->Identifier = fs->Identifier;
            ret->U.Type.Type = op->U.Type;
        }
        break;
    case eFieldSpec_FixedTypeValue:
        op = fs->U.FixedTypeValue.Optionality;
        if (op && op->Type == eOptionality_Default_Value) {
            ret = NewSetting(eSetting_Value);
            ret->Identifier = fs->Identifier;
            ret->U.Value.Value = op->U.Value;
        }
        break;
    case eFieldSpec_VariableTypeValue:
        op = fs->U.VariableTypeValue.Optionality;
        if (op && op->Type == eOptionality_Default_Value) {
            ret = NewSetting(eSetting_Value);
            ret->Identifier = fs->Identifier;
            ret->U.Value.Value = op->U.Value;
        }
        break;
    case eFieldSpec_FixedTypeValueSet:
        op = fs->U.FixedTypeValueSet.Optionality;
        if (op && op->Type == eOptionality_Default_ValueSet) {
            ret = NewSetting(eSetting_ValueSet);
            ret->Identifier = fs->Identifier;
            ret->U.ValueSet.ValueSet = op->U.ValueSet;
        }
        break;
    case eFieldSpec_VariableTypeValueSet:
        op = fs->U.VariableTypeValueSet.Optionality;
        if (op && op->Type == eOptionality_Default_ValueSet) {
            ret = NewSetting(eSetting_ValueSet);
            ret->Identifier = fs->Identifier;
            ret->U.ValueSet.ValueSet = op->U.ValueSet;
        }
        break;
    case eFieldSpec_Object:
        op = fs->U.Object.Optionality;
        if (op && op->Type == eOptionality_Default_Object) {
            ret = NewSetting(eSetting_Object);
            ret->Identifier = fs->Identifier;
            ret->U.Object.Object = op->U.Object;
        }
        break;
    case eFieldSpec_ObjectSet:
        op = fs->U.Object.Optionality;
        if (op && op->Type == eOptionality_Default_ObjectSet) {
            ret = NewSetting(eSetting_ObjectSet);
            ret->Identifier = fs->Identifier;
            ret->U.ObjectSet.ObjectSet = op->U.ObjectSet;
        }
        break;
    default:
        return NULL;
    }
    return ret;
}

Setting_t *GetSettingFromSettings(AssignmentList_t ass, SettingList_t se, StringList_t sl)
{
    Object_t *o;

    for (; sl; sl = sl->Next) {
        for (; se; se = se->Next) {
            if (!strcmp(se->Identifier, sl->String))
                break;
        }
        if (!se)
            return NULL;
        if (!sl->Next)
            return se;
        if (se->Type != eSetting_Object)
            return NULL;
        o = GetObject(ass, se->U.Object.Object);
        if (!o)
            return NULL;
        se = o->U.Object.Settings;
    }
    return NULL;
}

Setting_t *GetSettingFromObject(AssignmentList_t ass, Object_t *o, StringList_t sl)
{
    FieldSpec_t *fs;
    Setting_t *se;
    ObjectClass_t *oc;

    for (; sl; sl = sl->Next) {
        o = GetObject(ass, o);
        if (!o)
            return NULL;
        oc = GetObjectClass(ass, o->U.Object.ObjectClass);
        if (!oc)
            return NULL;
        fs = GetFieldSpec(ass,
            FindFieldSpec(oc->U.ObjectClass.FieldSpec, sl->String));
        if (!fs)
            return NULL;
        se = FindSetting(o->U.Object.Settings, sl->String);
        if (!se) {
            se = GetDefaultSetting(fs);
            if (!se)
                return NULL;
        }
        if (!sl->Next)
            return se;
        if (fs->Type == eFieldSpec_Object && se->Type == eSetting_Object) {
            o = se->U.Object.Object;
        } else {
            return NULL;
        }
    }
    return NULL;
}

ObjectClass_t *GetObjectClassFromElementSetSpec(AssignmentList_t ass, ElementSetSpec_t *elems)
{
    ObjectSetElement_t *ose;
    Object_t *o;
    ObjectSet_t *os;

    switch (elems->Type) {
    case eElementSetSpec_AllExcept:
        return GetObjectClassFromElementSetSpec(ass,
            elems->U.AllExcept.Elements);
    case eElementSetSpec_Union:
    case eElementSetSpec_Intersection:
    case eElementSetSpec_Exclusion:
        return GetObjectClassFromElementSetSpec(ass,
            elems->U.UIE.Elements1);
    case eElementSetSpec_SubtypeElement:
        MyAbort();
        /*NOTREACHED*/
    case eElementSetSpec_ObjectSetElement:
        ose = elems->U.ObjectSetElement.ObjectSetElement;
        switch (ose->Type) {
        case eObjectSetElement_Object:
            o = ose->U.Object.Object;
            o = GetObject(ass, o);
            if (!o)
                return NULL;
            return o->U.Object.ObjectClass;
        case eObjectSetElement_ObjectSet:
            os = ose->U.ObjectSet.ObjectSet;
            os = GetObjectSet(ass, os);
            if (!os)
                return NULL;
            return os->U.ObjectSet.ObjectClass;
        case eObjectSetElement_ElementSetSpec:
            return GetObjectClassFromElementSetSpec(ass,
                ose->U.ElementSetSpec.ElementSetSpec);
        } 
        /*NOTREACHED*/
    }
    /*NOTREACHED*/
	return NULL;
}

#if 0
Type_t *GetTypeFromElementSetSpec(AssignmentList_t ass, ElementSetSpec_t *elems)
{
    Type_t *ret;
    SubtypeElement_t *sub;
    Value_t *value;

    switch (elems->Type) {
    case eElementSetSpec_AllExcept:
        return GetTypeFromElementSetSpec(ass,
            elems->U.AllExcept.Elements);
    case eElementSetSpec_Union:
    case eElementSetSpec_Intersection:
    case eElementSetSpec_Exclusion:
        ret = GetTypeFromElementSetSpec(ass, elems->U.UIE.Elements1);
        if (ret)
            return ret;
        return GetTypeFromElementSetSpec(ass, elems->U.UIE.Elements2);
    case eElementSetSpec_SubtypeElement:
        sub = elems->U.SubtypeElement.SubtypeElement;
        switch (sub->Type) {
        case eSubtypeElement_Size:
        case eSubtypeElement_PermittedAlphabet:
        case eSubtypeElement_SingleType:
        case eSubtypeElement_FullSpecification:
        case eSubtypeElement_PartialSpecification:
            return NULL;
        case eSubtypeElement_Type:
            return Builtin_Type_Open;
        case eSubtypeElement_ContainedSubtype:
            return sub->U.ContainedSubtype.Type;
        case eSubtypeElement_SingleValue:
            value = GetValue(ass, sub->U.SingleValue.Value);
            return value->Type;
        case eSubtypeElement_ValueRange:
            if (!(sub->U.ValueRange.Lower.Flags & eEndPoint_Min)) {
                value = GetValue(ass, sub->U.ValueRange.Lower.Value);
                return value->Type;
            }
            if (!(sub->U.ValueRange.Upper.Flags & eEndPoint_Max)) {
                value = GetValue(ass, sub->U.ValueRange.Upper.Value);
                return value->Type;
            }
            return NULL;
        case eSubtypeElement_ElementSetSpec:
            return GetTypeFromElementSetSpec(ass,
                sub->U.ElementSetSpec.ElementSetSpec);
        } 
        /*NOTREACHED*/
    case eElementSetSpec_ObjectSetElement:
        MyAbort();
        /*NOTREACHED*/
    }
    /*NOTREACHED*/
}
#endif

Type_t *GetTypeOfValueSet(AssignmentList_t ass, ValueSet_t *vs)
{
    Type_t *ret;
    Constraint_t *c;

    if (!vs)
        return NULL;
    ret = DupType(vs->Type);
    c = NewConstraint();
    c->Type = eExtension_Unextended;
    c->Root = vs->Elements;
    IntersectConstraints(&ret->Constraints, vs->Type->Constraints, c);
    return ret;
}

Value_t *GetValueFromObject(AssignmentList_t ass, Object_t *o, StringList_t sl)
{
    Setting_t *se;

    se = GetSettingFromObject(ass, o, sl);
    if (!se)
        return NULL;
    if (se->Type != eSetting_Value)
        return NULL; /* error */
    return se->U.Value.Value;
}

ValueSet_t *GetValueSetFromObject(AssignmentList_t ass, Object_t *o, StringList_t sl)
{
    Setting_t *se;

    se = GetSettingFromObject(ass, o, sl);
    if (!se)
        return NULL;
    if (se->Type != eSetting_ValueSet)
        return NULL; /* error */
    return se->U.ValueSet.ValueSet;
}

Type_t *GetTypeFromObject(AssignmentList_t ass, Object_t *o, StringList_t sl)
{
    Setting_t *se;

    se = GetSettingFromObject(ass, o, sl);
    if (!se)
        return NULL;
    if (se->Type != eSetting_Type)
        return NULL; /* error */
    return se->U.Type.Type;
}

Object_t *GetObjectFromObject(AssignmentList_t ass, Object_t *o, StringList_t sl)
{
    Setting_t *se;

    se = GetSettingFromObject(ass, o, sl);
    if (!se)
        return NULL;
    if (se->Type != eSetting_Object)
        return NULL; /* error */
    return se->U.Object.Object;
}

ObjectSet_t *GetObjectSetFromObject(AssignmentList_t ass, Object_t *o, StringList_t sl)
{
    Setting_t *se;

    se = GetSettingFromObject(ass, o, sl);
    if (!se)
        return NULL;
    if (se->Type != eSetting_ObjectSet)
        return NULL; /* error */
    return se->U.ObjectSet.ObjectSet;
}

ElementSetSpec_t *ConvertElementSetSpecToElementSetSpec(AssignmentList_t ass, ElementSetSpec_t *elems, StringList_t sl, ElementSetSpec_t *(*fn)(AssignmentList_t ass, Object_t *o, StringList_t sl))
{
    ElementSetSpec_t *ret, *e1, *e2;
    ObjectSetElement_t *ose;

    ret = NULL;
    switch (elems->Type) {
    case eElementSetSpec_AllExcept:
        e1 = ConvertElementSetSpecToElementSetSpec(
            ass, elems->U.AllExcept.Elements, sl, fn);
        if (e1) {
            ret = NewElementSetSpec(elems->Type);
            ret->U.AllExcept.Elements = e1;
        }
        break;
    case eElementSetSpec_Union:
    case eElementSetSpec_Intersection:
    case eElementSetSpec_Exclusion:
        e1 = ConvertElementSetSpecToElementSetSpec(
            ass, elems->U.UIE.Elements1, sl, fn);
        e2 = ConvertElementSetSpecToElementSetSpec(
            ass, elems->U.UIE.Elements2, sl, fn);
        if (e1 && e2) {
            ret = NewElementSetSpec(elems->Type);
            ret->U.UIE.Elements1 = ConvertElementSetSpecToElementSetSpec(
                ass, elems->U.UIE.Elements1, sl, fn);
            ret->U.UIE.Elements2 = ConvertElementSetSpecToElementSetSpec(
                ass, elems->U.UIE.Elements2, sl, fn);
        } else if (e1) {
            ret = e1;
        } else if (e2) {
            if (elems->Type == eElementSetSpec_Exclusion) {
                ret = NewElementSetSpec(eElementSetSpec_AllExcept);
                ret->U.AllExcept.Elements = e2;
            } else {
                ret = e2;
            }
        }
        break;
    case eElementSetSpec_ObjectSetElement:
        ose = elems->U.ObjectSetElement.ObjectSetElement;
        switch (ose->Type) {
        case eObjectSetElement_Object:
            ret = fn(ass, ose->U.Object.Object, sl);
            break;
        case eObjectSetElement_ObjectSet:
            ret = ConvertObjectSetToElementSetSpec(ass,
                ose->U.ObjectSet.ObjectSet, sl, fn);
            break;
        case eObjectSetElement_ElementSetSpec:
            ret = ConvertElementSetSpecToElementSetSpec(ass,
                ose->U.ElementSetSpec.ElementSetSpec, sl, fn);
            break;
        }
        break;
    case eElementSetSpec_SubtypeElement:
        MyAbort();
        /*NOTREACHED*/
    }
    return ret;
}

ElementSetSpec_t *ConvertObjectSetToElementSetSpec(AssignmentList_t ass, ObjectSet_t *os, StringList_t sl, ElementSetSpec_t *(*fn)(AssignmentList_t ass, Object_t *o, StringList_t sl))
{
    os = GetObjectSet(ass, os);
    if (!os)
        return NULL;
    return ConvertElementSetSpecToElementSetSpec(ass,
        os->U.ObjectSet.Elements, sl, fn);
}

static ElementSetSpec_t *CbGetValueSetFromObjectSet(AssignmentList_t ass, Object_t *o, StringList_t sl)
{
    ElementSetSpec_t *ret;
    Setting_t *se;
    SubtypeElement_t *sub;

    se = GetSettingFromObject(ass, o, sl);
    if (!se)
        return NULL;
    if (se->Type == eSetting_Value) {
        sub = NewSubtypeElement(eSubtypeElement_SingleValue);
        sub->U.SingleValue.Value = se->U.Value.Value;
        ret = NewElementSetSpec(eElementSetSpec_SubtypeElement);
        ret->U.SubtypeElement.SubtypeElement = sub;
        return ret;
    } else if (se->Type == eSetting_ValueSet) {
        return se->U.ValueSet.ValueSet->Elements;
    } else {
        return NULL; /* error */
    }
}

ValueSet_t *GetValueSetFromObjectSet(AssignmentList_t ass, ObjectSet_t *os, StringList_t sl)
{
    ElementSetSpec_t *elems;
    ValueSet_t *ret;
    ObjectClass_t *oc;
    FieldSpec_t *fs;
    Type_t *type;

    os = GetObjectSet(ass, os);
    if (!os)
        return NULL;
    oc = os->U.ObjectSet.ObjectClass;
    fs = GetFieldSpecFromObjectClass(ass, oc, sl);
    if (!fs)
        return NULL;
    if (fs->Type == eFieldSpec_FixedTypeValue)
        type = fs->U.FixedTypeValue.Type;
    else if (fs->Type == eFieldSpec_FixedTypeValueSet)
        type = fs->U.FixedTypeValueSet.Type;
    else
        return NULL;
    elems = ConvertObjectSetToElementSetSpec(ass, os, sl,
        CbGetValueSetFromObjectSet);
    if (!elems)
        return NULL;
    ret = NewValueSet();
    ret->Elements = elems;
    ret->Type = type;
    return ret;
}

static ElementSetSpec_t *CbGetObjectSetFromObjectSet(AssignmentList_t ass, Object_t *o, StringList_t sl)
{
    ElementSetSpec_t *ret;
    Setting_t *se;
    ObjectSetElement_t *sub;

    se = GetSettingFromObject(ass, o, sl);
    if (!se)
        return NULL;
    if (se->Type == eSetting_Object) {
        sub = NewObjectSetElement(eObjectSetElement_Object);
        sub->U.Object.Object = se->U.Object.Object;
        ret = NewElementSetSpec(eElementSetSpec_ObjectSetElement);
        ret->U.ObjectSetElement.ObjectSetElement = sub;
        return ret;
    } else if (se->Type == eSetting_ObjectSet) {
        return se->U.ObjectSet.ObjectSet->U.ObjectSet.Elements;
    } else {
        return NULL; /* error */
    }
}

ObjectSet_t *GetObjectSetFromObjectSet(AssignmentList_t ass, ObjectSet_t *os, StringList_t sl)
{
    ElementSetSpec_t *elems;
    ObjectSet_t *ret;

    elems = ConvertObjectSetToElementSetSpec(ass, os, sl,
        CbGetObjectSetFromObjectSet);
    if (!elems)
        return NULL;
    ret = NewObjectSet(eObjectSet_ObjectSet);
    ret->U.ObjectSet.Elements = elems;
    ret->U.ObjectSet.ObjectClass = GetObjectClassFromElementSetSpec(ass, elems);
    return ret;
}

// The following is added by Microsoft

int IsPSetOfType(AssignmentList_t ass, Assignment_t *a)
{
    Type_t *t2 = a->U.Type.Type;
#if 0
    if (t2->Type == eType_Reference)
    {
        t2 = GetType(ass, t2);
    }
#endif
    return ((eType_SequenceOf == t2->Type || eType_SetOf == t2->Type)
            &&
            (t2->Rules & (eTypeRules_LinkedListMask | eTypeRules_PointerToElement))
            // (t2->PrivateDirectives.fSLinked)
           );
}


void MyAbort(void)
{
    ASSERT(0);
    abort();
}

void MyExit(int val)
{
    ASSERT(0);
    exit(val);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\asn1\asn1c\yywrap.c ===
/* Copyright (C) Boris Nikolaus, Germany, 1996-1997. All rights reserved. */
/* Copyright (C) Microsoft Corporation, 1997-1998. All rights reserved. */

#include "precomp.h"

int yywrap()
{
    return 1;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\asn1\asn1c\write.c ===
/* Copyright (C) Boris Nikolaus, Germany, 1996-1997. All rights reserved. */
/* Copyright (C) Microsoft Corporation, 1997-1998. All rights reserved. */

#include "precomp.h"

#define IDCHRSET "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789_"

#define INDENT 4
#define TABSIZE 8

static FILE *fout;
static int xcurrindent = 0;
static int xindentflag = 0;
static char *xbuf = 0;
static int xbufsize = 0;
static int xbuflen = 0;
static int ycurrindent = 1;
static char *ybuf = 0;
static int ybufsize = 0;
static int ybuflen = 0;

void xputc(char c);
void xputs(char *s);
void xflush();
void yputc(char c);
void yputs(char *s);
void yflush();

/* set the output file */
void
setoutfile(FILE *f)
{
    xflush();
    fout = f;
}

/* print indentation up to current indentation level */
static void
findent()
{
    int indent;

    indent = xcurrindent * INDENT;
    while (indent >= TABSIZE) {
	xputc('\t');
	indent -= TABSIZE;
    }
    while (indent-- > 0)
	xputc(' ');
}

/* print indentation up to current indentation level */
/* but expect one character to be printed already */
static void
findent1()
{
    int indent;

    indent = xcurrindent * INDENT;
    if (indent > 0 && indent < TABSIZE)
	indent--;
    while (indent >= TABSIZE) {
	xputc('\t');
	indent -= TABSIZE;
    }
    while (indent-- > 0)
	xputc(' ');
}

/* output function doing indentation automatically */
void
outputv(const char *format, va_list args)
{
    static char buf[4098];
    static int pos = 0;
    char *p, *q;
    int l;
    
    /* get the string to write */
    vsprintf(buf + pos, format, args);

    /* print it line by line */
    for (p = buf; *p; p = q) {
	q = strchr(p, '\n');
	if (!q) {
	    for (q = buf; *p;)
		*q++ = *p++;
	    *q = 0;
	    pos = q - buf;
	    return;
	}
	*q++ = 0;

	/* examine the first character for correct indentation */
	if (strchr(IDCHRSET, *p)) {
	    l = strspn(p, IDCHRSET);
	} else if (*p == '{' || *p == '}' || *p == '*' || *p == '&' ||
	    *p == '(' || *p == ')' || *p == '#') {
	    l = 1;
	} else {
	    l = 0;
	}

	if (!l) {

	    /* no indentation at all */
	    xputs(p);
	    xputc('\n');
	    continue;
	}

	if (p[0] == '#') {

	    /* preprocessor directive: indent after # */
	    xputc('#');
	    findent1();
	    xputs(p + 1);
	    xputc('\n');
	    continue;
	}

	/* closing brace? then unindent */
	if (p[0] == '}')
	    xcurrindent--;

	/* print the indentation, but labels will be less indented */
	if (p[strlen(p) - 1] == ':') {
	    xcurrindent--;
	    findent();
	    xcurrindent++;
	} else {
	    findent();
	}

	/* output the line */
	xputs(p);
	xputc('\n');

	/* back at indentation level 0? then we can flush our buffers */
	/* first the variables then the other lines */
	if (!xcurrindent) {
	    yflush();
	    xflush();
	}

	/* undo indentation of non-braced if/else/switch/for/while/do stmt */
	if (xindentflag) {
	    xcurrindent--;
	    xindentflag = 0;
	}

	/* indent after opening brace */
	if (p[strlen(p) - 1] == '{') {
	    xcurrindent++;
	    xindentflag = 0;

	/* indent one line after if/else/switch/for/while/do stmt */
	} else if (l == 2 && !memcmp(p, "if", l) ||
	    l == 4 && !memcmp(p, "else", l) ||
	    l == 6 && !memcmp(p, "switch", l) ||
	    l == 3 && !memcmp(p, "for", l) ||
	    l == 5 && !memcmp(p, "while", l) ||
	    l == 2 && !memcmp(p, "do", l)) {
	    xcurrindent++;
	    xindentflag = 1;
	}
    }

    /* empty buffer after printing */
    pos = 0;
}

/* output function doing indentation automatically */
/*PRINTFLIKE1*/
void
output(const char *format, ...)
{
    va_list args;

    va_start(args, format);
    outputv(format, args);
    va_end(args);
}

/* output function without indentation */
void
outputniv(const char *format, va_list args)
{
    static char buf[512];

    vsprintf(buf, format, args);
    xputs(buf);
}

/* output function without indentation */
/*PRINTFLIKE1*/
void
outputni(const char *format, ...)
{
    va_list args;

    va_start(args, format);
    outputniv(format, args);
    va_end(args);
}

/* output an intx value definition */
void
outputintx(const char *name, intx_t *val)
{
    outputoctets(name, val->length, val->value);
    output("static ASN1intx_t %s = { %d, %s_octets };\n",
	name, val->length, name);
}

/* output an real value definition */
void
outputreal(const char *name, real_t *val)
{
    char buf[256];
    switch (val->type) {
    case eReal_Normal:
	sprintf(buf, "%s_mantissa", name);
	outputoctets(buf, val->mantissa.length, val->mantissa.value);
	sprintf(buf, "%s_exponent", name);
	outputoctets(buf, val->exponent.length, val->exponent.value);
	output("ASN1real_t %s = { eReal_Normal, { %u, %s_mantissa_octets }, %u, { %u, %s_exponent_octets } };\n",
	    name, val->mantissa.length, name,
	    val->base, val->exponent.length, name);
	break;
    case eReal_PlusInfinity:
	output("ASN1real_t %s = { eReal_PlusInfinity };\n", name);
	break;
    case eReal_MinusInfinity:
	output("ASN1real_t %s = { eReal_MinusInfinity };\n", name);
	break;
    }
}

/* output an octet array definition */
void
outputoctets(const char *name, uint32_t length, octet_t *val)
{
    uint32_t i;
    char buf[1024];
    char *p;

    p = buf;
    for (i = 0; i < length; i++) {
	sprintf(p, "0x%02x", val[i]);
	p += 4;
	if (i < length - 1) {
	    sprintf(p, ", ");
	    p += 2;
	}
    }
    *p = 0;
    output("static ASN1octet_t %s_octets[%u] = { %s };\n",
	name, length, buf);
}

/* output an uint32 array definition */
void
outputuint32s(const char *name, uint32_t length, uint32_t *val)
{
    uint32_t i;
    char buf[256];
    char *p;

    p = buf;
    for (i = 0; i < length; i++) {
	sprintf(p, "%u", val[i]);
	p += strlen(p);
	if (i < length - 1) {
	    sprintf(p, ", ");
	    p += 2;
	}
    }
    *p = 0;
    output("static ASN1uint32_t %s_elems[%u] = { %s };\n",
	name, length, buf);
}

/* output forward declaration for a value */
void
outputvalue0(AssignmentList_t ass, char *ideref, char *typeref, Value_t *value)
{
    Type_t *type;
    char buf[256];
    char *itype;
    int32_t noctets;
    uint32_t zero;
    uint32_t i;
    Value_t *values;
    Component_t *components;
    NamedValue_t *namedvalue;
    int32_t sign;
    char *pszStatic = "extern";

    value = GetValue(ass, value);
    type = GetType(ass, value->Type);
    value = GetValue(ass, value);
    switch (type->Type) {
    case eType_Integer:
	itype = GetIntegerType(ass, type, &sign);
	if (!strcmp(itype, "ASN1intx_t")) {
	    output("%s ASN1octet_t %s_octets[%u];\n", pszStatic,
		ideref, value->U.Integer.Value.length);
	}
	break;
    case eType_Real:
	itype = GetRealType(type);
	if (!strcmp(itype, "ASN1real_t"))
	{
	    switch (value->U.Real.Value.type) {
	    case eReal_Normal:
		output("%s ASN1octet_t %s_mantissa_octets[%u];\n", pszStatic,
		    ideref, value->U.Real.Value.mantissa.length);
		output("%s ASN1octet_t %s_exponent_octets[%u];\n", pszStatic,
		    ideref, value->U.Real.Value.exponent.length);
		break;
	    }
	}
	break;
    case eType_BitString:
	output("%s ASN1octet_t %s_octets[%u];\n", pszStatic,
	    ideref, (value->U.BitString.Value.length + 7) / 8);
	break;
    case eType_OctetString:
	output("%s ASN1octet_t %s_octets[%u];\n", pszStatic,
	    ideref, value->U.OctetString.Value.length);
	break;
    case eType_UTF8String:
	output("%s ASN1wchar_t %s_wchars[%u];\n", pszStatic,
	    ideref, value->U.UTF8String.Value.length);
	break;
    case eType_ObjectIdentifier:
        if (type->PrivateDirectives.fOidPacked ||
            type->PrivateDirectives.fOidArray || g_fOidArray)
        {
            // doing nothing
        }
        else
        {
            output("%s ASN1uint32_t %s_elems[%u];\n", pszStatic,
                ideref, value->U.ObjectIdentifier.Value.length);
        }
        break;
    case eType_BMPString:
    case eType_GeneralString:
    case eType_GraphicString:
    case eType_IA5String:
    case eType_ISO646String:
    case eType_NumericString:
    case eType_PrintableString:
    case eType_TeletexString:
    case eType_T61String:
    case eType_UniversalString:
    case eType_VideotexString:
    case eType_VisibleString:
    case eType_RestrictedString:
	itype = GetStringType(ass, type, &noctets, &zero);
	switch (noctets) {
	case 1:
	    output("%s ASN1char_t %s_chars[%u];\n", pszStatic,
		ideref, value->U.RestrictedString.Value.length + zero);
	    break;
	case 2:
	    output("%s ASN1char16_t %s_chars[%u];\n", pszStatic,
		ideref, value->U.RestrictedString.Value.length + zero);
	    break;
	case 4:
	    output("%s ASN1char32_t %s_chars[%u];\n", pszStatic,
		ideref, value->U.RestrictedString.Value.length + zero);
	    break;
	}
	break;
    case eType_ObjectDescriptor:
	output("%s ASN1char_t %s_chars[%u];\n", pszStatic,
	    ideref, value->U.ObjectDescriptor.Value.length + 1);
	break;
    case eType_SequenceOf:
    case eType_SetOf:
        if (type->Rules & (eTypeRules_LengthPointer | eTypeRules_FixedArray))
        {
            for (i = 0, values = value->U.SS.Values; values;
            i++, values = values->Next) {}
            if (value->U.SS.Values) {
            for (i = 0, values = value->U.SS.Values; values;
                i++, values = values->Next) {
                sprintf(buf, "%s_value%d", ideref, i);
                outputvalue0(ass, buf,
                GetTypeName(ass, type->U.SS.Type), values);
            }
            output("%s %s %s_values[%u];\n", pszStatic,
                GetTypeName(ass, type->U.SS.Type),
                ideref, i);
            }
        }
        else
        if (type->Rules & (eTypeRules_SinglyLinkedList | eTypeRules_DoublyLinkedList))
        {
            for (i = 0, values = value->U.SS.Values; values;
            i++, values = values->Next) {
            sprintf(buf, "%s_element%d", ideref, i);
            outputvalue0(ass, buf, GetTypeName(ass, type->U.SS.Type),
                values);
            output("%s %s_Element %s_value%d;\n", pszStatic,
                typeref, ideref, i);
            }
        }
        else
        {
            MyAbort();
        }
        break;
    case eType_Sequence:
    case eType_Set:
    case eType_External:
    case eType_EmbeddedPdv:
    case eType_CharacterString:
    case eType_InstanceOf:
	for (components = type->U.SSC.Components; components;
	    components = components->Next) {
	    switch (components->Type) {
	    case eComponent_Normal:
	    case eComponent_Optional:
	    case eComponent_Default:
		namedvalue = FindNamedValue(value->U.SSC.NamedValues,
		    components->U.NOD.NamedType->Identifier);
		if (!namedvalue)
		    break;
		sprintf(buf, "%s_%s", ideref,
		    Identifier2C(components->U.NOD.NamedType->Identifier));
		outputvalue0(ass, buf,
		    GetTypeName(ass, components->U.NOD.NamedType->Type),
		    namedvalue->Value);
		break;
	    }
	}
	break;
    }
}

/* output definitions of value components */
void
outputvalue1(AssignmentList_t ass, char *ideref, char *typeref, Value_t *value)
{
    static uint32_t nOidPackedCount = 0;
    Type_t *type;
    char buf[256];
    char *itype;
    int32_t noctets;
    uint32_t zero;
    uint32_t i;
    Value_t *values;
    Component_t *components;
    NamedValue_t *namedvalue;
    int32_t sign;

    value = GetValue(ass, value);
    type = GetType(ass, value->Type);
    value = GetValue(ass, value);
    switch (type->Type) {
    case eType_Integer:
	itype = GetIntegerType(ass, type, &sign);
	if (!strcmp(itype, "ASN1intx_t")) {
	    outputoctets(ideref, value->U.Integer.Value.length,
		value->U.Integer.Value.value);
	}
	break;
    case eType_Real:
	itype = GetRealType(type);
	if (!strcmp(itype, "ASN1real_t")) {
	    switch (value->U.Real.Value.type) {
	    case eReal_Normal:
		sprintf(buf, "%s_mantissa", ideref);
		outputoctets(buf, value->U.Real.Value.mantissa.length,
		    value->U.Real.Value.mantissa.value);
		sprintf(buf, "%s_exponent", ideref);
		outputoctets(buf, value->U.Real.Value.exponent.length,
		    value->U.Real.Value.exponent.value);
		break;
	    }
	}
	break;
    case eType_BitString:
	outputoctets(ideref, (value->U.BitString.Value.length + 7) / 8,
	    value->U.BitString.Value.value);
	break;
    case eType_OctetString:
	outputoctets(ideref, value->U.OctetString.Value.length,
	    value->U.OctetString.Value.value);
	break;
    case eType_UTF8String:
        itype = GetStringType(ass, type, &noctets, &zero);
        output("static ASN1wchar_t %s_wchars[%u] = { ",
        ideref, value->U.UTF8String.Value.length + zero);
        for (i = 0; i < value->U.UTF8String.Value.length; i++) {
            output("0x%x", value->U.UTF8String.Value.value[i]);
            if (i < value->U.UTF8String.Value.length - 1)
                output(", ");
        }
        if (zero) {
            if (value->U.UTF8String.Value.length)
                output(", 0x0");
            else
                output("0x0");
        }
        output(" };\n");
        break;
    case eType_ObjectIdentifier:
        if (type->PrivateDirectives.fOidPacked)
        {
            uint32_t length = value->U.ObjectIdentifier.Value.length;
            uint32_t *val = value->U.ObjectIdentifier.Value.value;
            uint32_t i, j, cb;
            uint32_t count = 0;
            uint32_t node;
            unsigned char aLittleEndian[16];
            char buf[1024];
            char *p = buf;
            sprintf(p, "{");
            p += strlen(p);
            for (i = 0; i < length; i++)
            {
                // get node value
                node = val[i];

                // special case for the first node
                if (0 == i && length > 1)
                {
                    i++;
                    node = node * 40 + val[1];
                }

                // encode this node
                ZeroMemory(aLittleEndian, sizeof(aLittleEndian));
                for (j = 0; node != 0; j++)
                {
                    aLittleEndian[j] = (unsigned char) (node & 0x7f);
                    if (j != 0)
                    {
                        aLittleEndian[j] |= (unsigned char) 0x80;
                    }
                    node >>= 7;
                }
                cb = j ? j : 1; // at least one byte for zero value

                // print out the values
                for (j = 0; j < cb; j ++)
                {
                    count++;
                    sprintf(p, " %u,", (unsigned char) aLittleEndian[cb - j - 1]);
                    p += strlen(p);
                }
            }
            --p; // remove the last ','
            strcpy(p, " }");
            output("static ASN1octet_t s_oid%u[] = %s;\n", nOidPackedCount, buf);
            output("ASN1encodedOID_t %s = { %u, s_oid%u };\n", ideref, count, nOidPackedCount);
            nOidPackedCount++;
        }
        else
        if (type->PrivateDirectives.fOidArray || g_fOidArray)
        {
            uint32_t length = value->U.ObjectIdentifier.Value.length;
            uint32_t *val = value->U.ObjectIdentifier.Value.value;
            uint32_t i;
            char buf[1024];
            char *p = buf;
            sprintf(p, "{ ");
            p += strlen(p);
            for (i = 0; i < length; i++)
            {
                if (i == length - 1)
                {
                    sprintf(p, "%u }", val[i]);
                }
                else
                {
                    sprintf(p, "%u, ", val[i]);
                }
                p += strlen(p);
            }
            *p = 0;
            output("ASN1objectidentifier2_t %s = {\n%u, %s\n};\n", ideref, length, buf);
        }
        else
        {
            uint32_t length = value->U.ObjectIdentifier.Value.length;
            uint32_t *val = value->U.ObjectIdentifier.Value.value;
            uint32_t i;
            char buf[1024];
            char *p = buf;
            for (i = 0; i < length; i++)
            {
                if (i == length - 1)
                {
                    sprintf(p, "{ NULL, %u }", val[i]);
                }
                else
                {
                    sprintf(p, "{ (ASN1objectidentifier_t) &(%s_list[%u]), %u },\n", ideref, i+1, val[i]);
                }
                p += strlen(p);
            }
            *p = 0;
            output("static const struct ASN1objectidentifier_s %s_list[%u] = {\n%s\n};\n",
            ideref, length, buf);
        }
        break;
    case eType_BMPString:
    case eType_GeneralString:
    case eType_GraphicString:
    case eType_IA5String:
    case eType_ISO646String:
    case eType_NumericString:
    case eType_PrintableString:
    case eType_TeletexString:
    case eType_T61String:
    case eType_UniversalString:
    case eType_VideotexString:
    case eType_VisibleString:
    case eType_RestrictedString:
	itype = GetStringType(ass, type, &noctets, &zero);
	switch (noctets) {
	case 1:
	    output("static ASN1char_t %s_chars[%u] = { ",
		ideref, value->U.RestrictedString.Value.length + zero);
	    break;
	case 2:
	    output("static ASN1char16_t %s_chars[%u] = { ",
		ideref, value->U.RestrictedString.Value.length + zero);
	    break;
	case 4:
	    output("static ASN1char32_t %s_chars[%u] = { ",
		ideref, value->U.RestrictedString.Value.length + zero);
	    break;
	}
	for (i = 0; i < value->U.RestrictedString.Value.length; i++) {
	    output("0x%x", value->U.RestrictedString.Value.value[i]);
	    if (i < value->U.RestrictedString.Value.length - 1)
		output(", ");
	}
	if (zero) {
	    if (value->U.RestrictedString.Value.length)
		output(", 0x0");
	    else
		output("0x0");
	}
	output(" };\n");
	break;
    case eType_ObjectDescriptor:
	output("static ASN1char_t %s_chars[%u] = { ",
	    ideref, value->U.ObjectDescriptor.Value.length + 1);
	for (i = 0; i < value->U.ObjectDescriptor.Value.length; i++) {
	    output("0x%x, ", value->U.ObjectDescriptor.Value.value[i]);
	}
	output("0x0 };\n");
	break;
    case eType_SequenceOf:
    case eType_SetOf:
	if (type->Rules & 
	    (eTypeRules_LengthPointer | eTypeRules_FixedArray)) {
	    if (value->U.SS.Values) {
		for (i = 0, values = value->U.SS.Values; values;
		    i++, values = values->Next) {
		    sprintf(buf, "%s_value%d", ideref, i);
		    outputvalue1(ass, buf,
			GetTypeName(ass, type->U.SS.Type),
			values);
		}
		output("static %s %s_values[%u] = { ",
		    GetTypeName(ass, type->U.SS.Type),
		    ideref, i);
		for (i = 0, values = value->U.SS.Values; values;
		    i++, values = values->Next) {
		    if (i)
			output(", ");
		    sprintf(buf, "%s_value%d", ideref, i);
		    outputvalue2(ass, buf, values);
		}
		output(" };\n");
	    }
	} else if (type->Rules &
	    (eTypeRules_SinglyLinkedList | eTypeRules_DoublyLinkedList)) {
	    for (i = 0, values = value->U.SS.Values; values;
		i++, values = values->Next) {
		sprintf(buf, "%s_element%d", ideref, i);
		outputvalue1(ass, buf, GetTypeName(ass, type->U.SS.Type),
		    values);
	    }
	    for (i = 0, values = value->U.SS.Values; values;
		i++, values = values->Next) {
		output("static %s_Element %s_value%d = { ",
		    typeref, ideref, i);
		if (values->Next)
		    output("&%s_value%d, ", ideref, i + 1);
		else
		    output("0, ");
		if (type->Rules & eTypeRules_DoublyLinkedList) {
		    if (i)
			output("&%s_value%d, ", ideref, i - 1);
		    else
			output("0, ");
		}
		sprintf(buf, "%s_element%d", ideref, i);
		outputvalue2(ass, buf, values);
		output(" };\n");
	    }
	} else {
	    MyAbort();
	}
	break;
    case eType_Sequence:
    case eType_Set:
    case eType_External:
    case eType_EmbeddedPdv:
    case eType_CharacterString:
    case eType_InstanceOf:
	for (components = type->U.SSC.Components; components;
	    components = components->Next) {
	    switch (components->Type) {
	    case eComponent_Normal:
	    case eComponent_Optional:
	    case eComponent_Default:
		namedvalue = FindNamedValue(value->U.SSC.NamedValues,
		    components->U.NOD.NamedType->Identifier);
		if (!namedvalue)
		    break;
		sprintf(buf, "%s_%s", ideref,
		    Identifier2C(components->U.NOD.NamedType->Identifier));
		outputvalue1(ass, buf,
		    GetTypeName(ass, components->U.NOD.NamedType->Type),
		    namedvalue->Value);
		break;
	    }
	}
	break;
    case eType_Choice:
	namedvalue = value->U.Choice.NamedValues;
	components = FindComponent(ass, type->U.Choice.Components,
	    namedvalue->Identifier);
	sprintf(buf, "%s_%s", ideref,
	    Identifier2C(components->U.NOD.NamedType->Identifier));
	outputvalue1(ass, buf, GetTypeName(ass,
	    components->U.NOD.NamedType->Type),
	    namedvalue->Value);
	output("static %s %s = ",
	    GetTypeName(ass, components->U.NOD.NamedType->Type), buf);
	outputvalue2(ass, buf, namedvalue->Value);
	output(";\n");
	break;
    }
}

/* output definition of value */
void
outputvalue2(AssignmentList_t ass, char *ideref, Value_t *value)
{
    Type_t *type;
    char buf[256];
    char *itype;
    int32_t noctets;
    uint32_t zero;
    uint32_t i;
    Value_t *values;
    Component_t *components;
    NamedValue_t *namedvalue;
    char *comma;
    uint32_t ext;
    uint32_t opt;
    int32_t sign;

    value = GetValue(ass, value);
    type = GetType(ass, value->Type);
    value = GetValue(ass, value);
    switch (type->Type) {
    case eType_Boolean:
	output("%d", value->U.Boolean.Value);
	break;
    case eType_Integer:
	itype = GetIntegerType(ass, type, &sign);
	if (!strcmp(itype, "ASN1intx_t")) {
	    output("{ %d, %s_octets }", value->U.Integer.Value.length, ideref);
	} else if (sign > 0) {
	    output("%u", intx2uint32(&value->U.Integer.Value));
	} else {
	    output("%d", intx2int32(&value->U.Integer.Value));
	}
	break;
    case eType_Enumerated:
	output("%u", value->U.Enumerated.Value);
	break;
    case eType_Real:
	itype = GetRealType(type);
	if (!strcmp(itype, "ASN1real_t")) {
	    switch (value->U.Real.Value.type) {
	    case eReal_Normal:
		output("{ eReal_Normal, { %u, %s_mantissa_octets }, %u, { %u, %s_exponent_octets } }",
		    value->U.Real.Value.mantissa.length, ideref,
		    value->U.Real.Value.base,
		    value->U.Real.Value.exponent.length, ideref);
		break;
	    case eReal_PlusInfinity:
		output("{ eReal_PlusInfinity }");
		break;
	    case eReal_MinusInfinity:
		output("{ eReal_MinusInfinity }");
		break;
	    }
	}
	else
	{
	    switch (value->U.Real.Value.type) {
	    case eReal_Normal:
		output("%g", real2double(&value->U.Real.Value));
		break;
	    case eReal_PlusInfinity:
	    case eReal_MinusInfinity:
		output("0.0");
		break;
	    }
	}
	break;
    case eType_BitString:
	output("{ %u, %s_octets }",
	    value->U.BitString.Value.length, ideref);
	break;
    case eType_OctetString:
	output("{ %u, %s_octets }",
	    value->U.OctetString.Value.length, ideref);
	break;
    case eType_UTF8String:
        output("{ %u, %s_utf8chars }",
            value->U.UTF8String.Value.length, ideref);
        break;
    case eType_ObjectIdentifier:
        if (type->PrivateDirectives.fOidPacked)
        {
            // doing nothing
        }
        else
        if (type->PrivateDirectives.fOidArray || g_fOidArray)
        {
            output("(ASN1objectidentifier2_t *) &%s_list", ideref);
        }
        else
        {
            output("(ASN1objectidentifier_t) %s_list", ideref);
        }
        break;
    case eType_BMPString:
    case eType_GeneralString:
    case eType_GraphicString:
    case eType_IA5String:
    case eType_ISO646String:
    case eType_NumericString:
    case eType_PrintableString:
    case eType_TeletexString:
    case eType_T61String:
    case eType_UniversalString:
    case eType_VideotexString:
    case eType_VisibleString:
    case eType_RestrictedString:
	itype = GetStringType(ass, type, &noctets, &zero);
	if (zero) {
	    output("%s_chars", ideref);
	} else {
	    output("{ %u, %s_chars }",
		value->U.RestrictedString.Value.length, ideref);
	}
	break;
    case eType_ObjectDescriptor:
	output("%s_chars", ideref);
	break;
    case eType_GeneralizedTime:
	output("{ %d, %d, %d, %d, %d, %d, %d, %d, %d }",
	    value->U.GeneralizedTime.Value.year,
	    value->U.GeneralizedTime.Value.month,
	    value->U.GeneralizedTime.Value.day,
	    value->U.GeneralizedTime.Value.hour,
	    value->U.GeneralizedTime.Value.minute,
	    value->U.GeneralizedTime.Value.second,
	    value->U.GeneralizedTime.Value.millisecond,
	    value->U.GeneralizedTime.Value.universal,
	    value->U.GeneralizedTime.Value.diff);
	break;
    case eType_UTCTime:
	output("{ %d, %d, %d, %d, %d, %d, %d, %d }",
	    value->U.UTCTime.Value.year,
	    value->U.UTCTime.Value.month,
	    value->U.UTCTime.Value.day,
	    value->U.UTCTime.Value.hour,
	    value->U.UTCTime.Value.minute,
	    value->U.UTCTime.Value.second,
	    value->U.UTCTime.Value.universal,
	    value->U.UTCTime.Value.diff);
	break;
    case eType_SequenceOf:
    case eType_SetOf:
	if (type->Rules &
	    (eTypeRules_LengthPointer | eTypeRules_FixedArray)) {
	    if (value->U.SS.Values) {
		for (i = 0, values = value->U.SS.Values; values;
		    i++, values = values->Next) {}
		output("{ %d, %s_values }", i, ideref);
	    } else {
		output("{ 0, NULL }");
	    }
	} else if (type->Rules &
	    (eTypeRules_SinglyLinkedList | eTypeRules_DoublyLinkedList)) {
	    output("&%s_value0", ideref);
	} else {
	    MyAbort();
	}
	break;
    case eType_Sequence:
    case eType_Set:
    case eType_External:
    case eType_EmbeddedPdv:
    case eType_CharacterString:
    case eType_InstanceOf:
	comma = "";
	output("{ ");
	if (type->U.SSC.Optionals || type->U.SSC.Extensions) {
	    output("{ ");
	    ext = 0;
	    opt = 0;
	    i = 0;
	    comma = "";
	    for (components = type->U.SSC.Components; components;
		components = components->Next) {
		switch (components->Type) {
		case eComponent_Normal:
		    if (!ext)
			break;
		    /*FALLTHROUGH*/
		case eComponent_Optional:
		case eComponent_Default:
		    namedvalue = FindNamedValue(value->U.SSC.NamedValues,
			components->U.NOD.NamedType->Identifier);
		    if (namedvalue)
			opt |= (0x80 >> i);
		    if (++i > 7) {
			output("%s0x%02x", comma, opt);
			opt = 0;
			i = 0;
			comma = ", ";
		    }
		    break;
		case eComponent_ExtensionMarker:
		    if (i) {
			output("%s0x%02x", comma, opt);
			opt = 0;
			i = 0;
			comma = ", ";
		    }
		    ext = 1;
		    break;
		}
	    }
	    if (i)
		output("%s0x%02x", comma, opt);
	    output(" }");
	    comma = ", ";
	}
	for (components = type->U.SSC.Components; components;
	    components = components->Next) {
	    switch (components->Type) {
	    case eComponent_Normal:
	    case eComponent_Optional:
	    case eComponent_Default:
		namedvalue = FindNamedValue(value->U.SSC.NamedValues,
		    components->U.NOD.NamedType->Identifier);
		if (!namedvalue) {
		    output("%s0", comma);
		} else {
		    output("%s", comma);
		    sprintf(buf, "%s_%s", ideref,
			Identifier2C(components->U.NOD.NamedType->Identifier));
		    outputvalue2(ass, buf, namedvalue->Value);
		}
		comma = ", ";
		break;
	    }
	}
	output(" }");
	break;
    case eType_Choice:
	i = ASN1_CHOICE_BASE;
	for (components = type->U.SSC.Components; components;
	    components = components->Next) {
	    switch (components->Type) {
	    case eComponent_Normal:
		if (!strcmp(value->U.SSC.NamedValues->Identifier,
		    components->U.NOD.NamedType->Identifier))
		    break;
		i++;
		continue;
	    case eComponent_ExtensionMarker:
		continue;
	    default:
		MyAbort();
	    }
	    break;
	}
	output("{ %d }", i);
    }
}

/* output assignments needed in initialization function */
void
outputvalue3(AssignmentList_t ass, char *ideref, char *valref, Value_t *value)
{
    Type_t *type;
    NamedValue_t *named;
    Value_t *values;
    int i;
    char idebuf[256];
    char valbuf[256];
    char *itype;

    value = GetValue(ass, value);
    type = GetType(ass, value->Type);
    switch (type->Type) {
    case eType_SequenceOf:
    case eType_SetOf:
	for (values = value->U.SS.Values, i = 0; values;
	    values = values->Next, i++) {
	    if (type->Rules &
	        (eTypeRules_LengthPointer | eTypeRules_FixedArray)) {
		sprintf(idebuf, "%s.value[%d]", ideref, i);
	    } else if (type->Rules &
		(eTypeRules_SinglyLinkedList | eTypeRules_DoublyLinkedList)) {
		sprintf(idebuf, "%s_value%d", ideref, i);
	    } else {
		MyAbort();
	    }
	    sprintf(valbuf, "%s_value%d", valref, i);
	    outputvalue3(ass, idebuf, valbuf, values);
	}
	break;
    case eType_Choice:
	output("%s.u.%s = %s_%s;\n",
	    ideref, Identifier2C(value->U.SSC.NamedValues->Identifier),
	    valref, Identifier2C(value->U.SSC.NamedValues->Identifier));
	/*FALLTHROUGH*/
    case eType_Sequence:
    case eType_Set:
    case eType_External:
    case eType_EmbeddedPdv:
    case eType_CharacterString:
    case eType_InstanceOf:
	for (named = value->U.SSC.NamedValues; named; named = named->Next) {
	    sprintf(idebuf, "%s.%s", ideref,
		Identifier2C(named->Identifier));
	    sprintf(valbuf, "%s_%s", valref,
		Identifier2C(named->Identifier));
	    outputvalue3(ass, idebuf, valbuf, named->Value);
	}
	break;
    case eType_Real:
	itype = GetRealType(type);
	if (strcmp(itype, "ASN1real_t"))
	{
	    switch (value->U.Real.Value.type) {
	    case eReal_Normal:
		break;
	    case eReal_PlusInfinity:
		output("%s = ASN1double_pinf();\n", ideref);
		break;
	    case eReal_MinusInfinity:
		output("%s = ASN1double_minf();\n", ideref);
		break;
	    }
	}
    }
}

/* print indentation up to current indentation level for variables */
static void
findentvar()
{
    int indent;

    indent = ycurrindent * INDENT;
    while (indent >= TABSIZE) {
	yputc('\t');
	indent -= TABSIZE;
    }
    while (indent--)
	yputc(' ');
}

/* print indentation up to current indentation level for variables */
void
outputvarv(const char *format, va_list args)
{
    static char buf[512];
    static int pos = 0;
    char *p, *q;
    int l;
    
    /* get the string to write */
    vsprintf(buf + pos, format, args);

    /* print it line by line */
    for (p = buf; *p; p = q) {
	q = strchr(p, '\n');
	if (!q) {
	    for (q = buf; *p;)
		*q++ = *p++;
	    *q = 0;
	    pos = q - buf;
	    return;
	}
	*q++ = 0;

	/* output every variable only once */
	if (ycurrindent == 1) {
	    l = 0;
	    while (l < ybuflen) {
		if (!memcmp(ybuf + l + INDENT / TABSIZE + INDENT % TABSIZE,
		    p, strlen(p)))
		    break;
		l += (strchr(ybuf + l, '\n') - (ybuf + l)) + 1;
	    }
	    if (l < ybuflen)
		continue;
	}

	/* examine the first character for correct indentation */
	if (strchr(IDCHRSET, *p)) {
	    l = strspn(p, IDCHRSET);
	} else if (*p == '{' || *p == '}') {
	    l = 1;
	} else {
	    l = 0;
	}

	if (!l) {

	    /* no indentation at all */
	    yputs(p);
	    yputc('\n');
	    continue;
	}

	/* closing brace? then unindent */
	if (p[0] == '}')
	    ycurrindent--;

	/* print indentation */
	findentvar();

	/* output the line */
	yputs(p);
	yputc('\n');

	/* indent after opening brace */
	if (p[strlen(p) - 1] == '{') {
	    ycurrindent++;
	}
    }
    pos = 0;
}

/* print indentation up to current indentation level for variables */
/*PRINTFLIKE1*/
void
outputvar(const char *format, ...)
{
    va_list args;

    va_start(args, format);
    outputvarv(format, args);
    va_end(args);
}

/* output an octet array definition for variables */
void
outputvaroctets(const char *name, uint32_t length, octet_t *val)
{
    uint32_t i;
    char buf[256];
    char *p;

    p = buf;
    for (i = 0; i < length; i++) {
	sprintf(p, "0x%02x", val[i]);
	p += 4;
	if (i < length - 1) {
	    sprintf(p, ", ");
	    p += 2;
	}
    }
    outputvar("static ASN1octet_t %s_octets[%u] = { %s };\n",
	name, length, buf);
}

/* output an intx value definition for variables */
void outputvarintx(const char *name, intx_t *val)
{
    outputvaroctets(name, val->length, val->value);
    outputvar("static ASN1intx_t %s = { %d, %s_octets };\n",
	name, val->length, name);
}

/* output an real value definition for variables */
void outputvarreal(const char *name, real_t *val)
{
    char buf[256];
    switch (val->type) {
    case eReal_Normal:
	sprintf(buf, "%s_mantissa", name);
	outputvaroctets(buf, val->mantissa.length, val->mantissa.value);
	sprintf(buf, "%s_exponent", name);
	outputvaroctets(buf, val->exponent.length, val->exponent.value);
	outputvar("ASN1real_t %s = { eReal_Normal, { %u, %s_mantissa_octets }, %u, { %u, %s_exponent_octets } };\n",
	    name, val->mantissa.length, name,
	    val->base, val->exponent.length, name);
	break;
    case eReal_PlusInfinity:
	outputvar("ASN1real_t %s = { eReal_PlusInfinity };\n", name);
	break;
    case eReal_MinusInfinity:
	outputvar("ASN1real_t %s = { eReal_MinusInfinity };\n", name);
	break;
    }
}

/* output a character of the function body */
void xputc(char c)
{
    if (xbuflen + 1 > xbufsize) {
    	xbufsize += 1024;
	if (!xbuf)
	    xbuf = (char *)malloc(xbufsize);
	else
	    xbuf = (char *)realloc(xbuf, xbufsize);
    }
    xbuf[xbuflen++] = c;
}

/* output a string of the function body */
void xputs(char *s)
{
    int sl;

    sl = strlen(s);
    if (xbuflen + sl > xbufsize) {
	while (xbuflen + sl > xbufsize)
	    xbufsize += 1024;
	if (!xbuf)
	    xbuf = (char *)malloc(xbufsize);
	else
	    xbuf = (char *)realloc(xbuf, xbufsize);
    }
    memcpy(xbuf + xbuflen, s, sl);
    xbuflen += sl;
}

/* flush the function body into the output file */
void xflush()
{
    if (xbuflen) {
	fwrite(xbuf, xbuflen, 1, fout);
#if 0
	fflush(fout);
#endif
	xbuflen = 0;
    }
}

/* output a character of the function variables */
void yputc(char c)
{
    if (ybuflen + 1 > ybufsize) {
    	ybufsize += 1024;
	if (!ybuf)
	    ybuf = (char *)malloc(ybufsize);
	else
	    ybuf = (char *)realloc(ybuf, ybufsize);
    }
    ybuf[ybuflen++] = c;
}

/* output a string of the function variables */
void yputs(char *s)
{
    int sl;

    sl = strlen(s);
    if (ybuflen + sl > ybufsize) {
	while (ybuflen + sl > ybufsize)
	    ybufsize += 1024;
	if (!ybuf)
	    ybuf = (char *)malloc(ybufsize);
	else
	    ybuf = (char *)realloc(ybuf, ybufsize);
    }
    memcpy(ybuf + ybuflen, s, sl);
    ybuflen += sl;
}

/* flush the function variables into the output file */
void yflush()
{
    if (ybuflen) {
	fwrite(ybuf, ybuflen, 1, fout);
#if 0
	fflush(fout);
#endif
	ybuflen = 0;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\asn1\asn1c\util.h ===
/* Copyright (C) Boris Nikolaus, Germany, 1996-1997. All rights reserved. */
/* Copyright (C) Microsoft Corporation, 1997-1998. All rights reserved. */

#ifndef _ASN1C_UTIL_H_
#define _ASN1C_UTIL_H_

size_t SLlength(void *head, size_t offset);
int SLcontains(void *head, size_t offset, void *elem);
void SLtoA(void *head, size_t offset, size_t elemsize, void **base, size_t *nelem);
void SLtoAP(void *head, size_t offset, void ***base, size_t *nelem);
void AtoSL(void *base, size_t offset, size_t nelem, size_t elemsize, void **head);
void qsortSL(void **head, size_t offset, int (*cmpfn)(const void *, const void *, void *), void *context);

void MyAbort(void);
void MyExit(int val);

#endif /* _ASN1C_UTIL_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\asn1\asn1c\write.h ===
/* Copyright (C) Boris Nikolaus, Germany, 1996-1997. All rights reserved. */
/* Copyright (C) Microsoft Corporation, 1997-1998. All rights reserved. */

#ifndef _ASN1C_WRITE_H_
#define _ASN1C_WRITE_H_

void setoutfile(FILE *);
/*PRINTFLIKE1*/
void output(const char *fmt, ...);
/*PRINTFLIKE1*/
void outputni(const char *fmt, ...);
void outputreal(const char *fmt, real_t *real);
void outputoctets(const char *name, uint32_t length, octet_t *val);
void outputuint32s(const char *name, uint32_t length, uint32_t *val);
void outputvalue0(AssignmentList_t ass, char *ideref, char *typeref, Value_t *value);
void outputvalue1(AssignmentList_t ass, char *ideref, char *typeref, Value_t *value);
void outputvalue2(AssignmentList_t ass, char *ideref, Value_t *value);
void outputvalue3(AssignmentList_t ass, char *ideref, char *valref, Value_t *value);
/*PRINTFLIKE1*/
void outputvar(const char *fmt, ...);
void outputvarintx(const char *fmt, intx_t *intx);
void outputvarreal(const char *fmt, real_t *real);
void outputvaroctets(const char *name, uint32_t length, octet_t *val);

#endif // _ASN1C_WRITE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\asn1\asn1cpp\asn1cpp.cpp ===
/* Copyright (C) Microsoft Corporation, 1998. All rights reserved. */

#include "precomp.h"
#include "getsym.h"
#include "macro.h"
#include "typeid.h"
#include "utils.h"


// local prototypes
BOOL ExpandFile ( LPSTR pszInputFile, LPSTR pszOutputFile, CMacroMgrList *pMacrMgrList );
BOOL CollectMacros ( CInput *, CMacroMgr *, CTypeID *, CMacroMgrList * );
BOOL InstantiateMacros ( CInput *, CMacroMgr * );
BOOL GenerateOutput ( CInput *, COutput *, CMacroMgr *, CTypeID * );
void BuildOutputFileName ( LPSTR pszInputFileName, LPSTR pszNewOutputFileName );


class CFileList : public CList
{
    DEFINE_CLIST(CFileList, LPSTR)
};


int __cdecl main ( int argc, char * argv[] )
{
    BOOL rc;
    BOOL fShowHelp = (1 == argc);
    int i;
    LPSTR pszMainInputFile = NULL;
    LPSTR pszMainOutputFile = NULL;

    CFileList FileList;
    CMacroMgrList MacroMgrList;

    LPSTR psz;
    char szScratch[MAX_PATH];

    // output product information
    printf("ASN.1 Compiler Preprocessor V0.1\n");
    printf("Copyright (C) Microsoft Corporation, 1998. All rights reserved.\n");

    // parse command line
    for (i = 1; i < argc; i++)
    {
        if ('-' == *argv[i])
        {
            // parse the option
            if (0 == ::strcmp(argv[i], "-h"))
            {
                fShowHelp = TRUE;
            }
            else
            if (0 == ::strcmp(argv[i], "-o"))
            {
                pszMainOutputFile = ::My_strdup(argv[++i]);
                ASSERT(NULL != pszMainOutputFile);
            }
            else
            {
                fprintf(stderr, "Unknown option [%s]\n", argv[i]);
                fShowHelp = TRUE;
                break;
            }
        }
        else
        {
            // must be a file name
            FileList.Append(argv[i]);

            // the last file will be the main input file
            pszMainInputFile = argv[i];
        }
    }

    // output help information if needed
    if (fShowHelp || 0 == FileList.GetCount() || NULL == pszMainInputFile)
    {
        printf("Usage: %s [options] [imported.asn ...] main.asn\n", argv[0]);
        printf("Options:\n");
        printf("-h\t\tthis help\n");
        printf("-o filename\toutput file name\n");
        return EXIT_SUCCESS;
    }

    // construct outpt file name if needed
    if (NULL == pszMainOutputFile)
    {
        // create an output file
        ::BuildOutputFileName(pszMainInputFile, &szScratch[0]);
        pszMainOutputFile = ::My_strdup(&szScratch[0]);
        ASSERT(NULL != pszMainOutputFile);
    }

    // input and output files must have a different name.
    ASSERT(0 != ::strcmp(pszMainInputFile, pszMainOutputFile));

    // expand macros in the files
    FileList.Reset();
    while (NULL != (psz = FileList.Iterate()))
    {
        if (0 != ::strcmp(psz, pszMainInputFile))
        {
            ::BuildOutputFileName(psz, &szScratch[0]);
            rc = ::ExpandFile(psz, &szScratch[0], &MacroMgrList);
            ASSERT(rc);

            // remove all the instances of macros
            MacroMgrList.Uninstance();
        }
        else
        {
            // it is main input file
            rc = ::ExpandFile(pszMainInputFile, pszMainOutputFile, &MacroMgrList);
            ASSERT(rc);
        }
    }

    //
    // Cleanup
    //
    delete pszMainOutputFile;
    MacroMgrList.DeleteList();

    return EXIT_SUCCESS;
}


BOOL ExpandFile
(
    LPSTR           pszInputFile,
    LPSTR           pszOutputFile,
    CMacroMgrList  *pMacroMgrList
)
{
    BOOL rc, rc1, rc2;
    CInput *pInput = NULL;
    COutput *pOutput = NULL;
    CTypeID *pTypeID = NULL;
    CMacroMgr *pMacroMgr = NULL;

    pInput = new CInput(&rc1, pszInputFile);
    pOutput = new COutput(&rc2, pszOutputFile);
    pTypeID = new CTypeID();
    pMacroMgr = new CMacroMgr();
    if (NULL != pInput && rc1 &&
        NULL != pOutput && rc2 &&
        NULL != pTypeID &&
        NULL != pMacroMgr)
    {
        //
        // Locate a list of macros
        //
        rc = ::CollectMacros(pInput, pMacroMgr, pTypeID, pMacroMgrList);
        if (rc)
        {
            rc = pInput->Rewind();
            ASSERT(rc);

            //
            // Create instances of macros
            //
            rc = ::InstantiateMacros(pInput, pMacroMgr);
            if (rc)
            {
                rc = pInput->Rewind();
                ASSERT(rc);

                //
                // Generate macro-expanded file
                //
                rc = ::GenerateOutput(pInput, pOutput, pMacroMgr, pTypeID);
                ASSERT(rc);
            }
            else
            {
                ASSERT(rc);
            }
        }
        else
        {
            ASSERT(rc);
        }
    }
    else
    {
        ASSERT(0);
    }

    //
    // Cleanup
    //
    if (NULL != pMacroMgrList && NULL != pMacroMgr)
    {
        pMacroMgrList->Append(pMacroMgr);
    }
    else
    {
        delete pMacroMgr;
    }
    delete pTypeID;
    delete pOutput;
    delete pInput;

    return rc;
}


BOOL CollectMacros
(
    CInput          *pInput,
    CMacroMgr       *pMacroMgr,
    CTypeID         *pTypeID,
    CMacroMgrList   *pMacroMgrList
)
{
    CNameList   NameList(16);

    // Create a running symbol handler
    CSymbol *pSym = new CSymbol(pInput);
    if (NULL == pSym)
    {
        return FALSE;
    }

    BOOL rc;
    BOOL fWasNewLine = TRUE;
    BOOL fEndMacro = FALSE;
    UINT cInsideBigBracket = 0;
    BOOL fInsideComment = FALSE;

    char szNameScratch[MAX_PATH];

    // Get the module name first
    pSym->NextUsefulSymbol();
    if (pSym->GetID() == SYMBOL_IDENTIFIER)
    {
        ::strcpy(&szNameScratch[0], pSym->GetStr());
        pSym->NextUsefulSymbol();
        if (pSym->GetID() == SYMBOL_KEYWORD &&
            0 == ::strcmp(pSym->GetStr(), "DEFINITIONS"))
        {
            pMacroMgr->AddModuleName(&szNameScratch[0]);
        }
    }

    // Rewind the input file
    rc = pInput->Rewind();
    ASSERT(rc);

    // Walk through the text
    while (pSym->NextSymbol())
    {
        // printf("symbol:id[%d], str[%s]\n", pSym->GetID(), pSym->GetStr());

        if (pSym->GetID() == SYMBOL_SPACE_EOL)
        {
            fWasNewLine = TRUE;
            fInsideComment = FALSE;
            continue;
        }

        if (pSym->IsComment())
        {
            fInsideComment = ! fInsideComment;
        }
        else
        if (! fInsideComment)
        {
            if (pSym->IsLeftBigBracket())
            {
                cInsideBigBracket++;
            }
            else
            if (pSym->IsRightBigBracket())
            {
                cInsideBigBracket--;
            }
            else
            // The macro must be outside the big brackets and
            // in the beginning of a line.
            if (fWasNewLine &&
                (0 == cInsideBigBracket) &&
                (pSym->GetID() == SYMBOL_IDENTIFIER))
            {
                ::strcpy(&szNameScratch[0], pSym->GetStr());
                pSym->NextUsefulSymbol();
                if (pSym->IsLeftBigBracket())
                {
                    cInsideBigBracket++;
                    CMacro *pMacro = new CMacro(&rc, &szNameScratch[0]);
                    ASSERT(NULL != pMacro);
                    ASSERT(rc);

                    // process argument list
                    do
                    {
                        pSym->NextUsefulSymbol();
                        pMacro->SetArg(pSym->GetStr());
                        pSym->NextUsefulSymbol();
                    }
                    while (pSym->IsComma());
                    ASSERT(pSym->IsRightBigBracket());
                    if (pSym->IsRightBigBracket())
                    {
                        cInsideBigBracket--;
                    }

                    // save the macro body
                    ASSERT(0 == cInsideBigBracket);
                    fEndMacro = FALSE;
                    while (! fEndMacro || pSym->GetID() != SYMBOL_SPACE_EOL)
                    {
                        pSym->NextSymbol();
                        if (pSym->GetID() == SYMBOL_SPACE_EOL)
                        {
                            fInsideComment = FALSE;
                        }
                        else
                        if (pSym->IsComment())
                        {
                            fInsideComment = ! fInsideComment;
                        }
                        else
                        if (! fInsideComment)
                        {
                            if (pSym->IsLeftBigBracket())
                            {
                                cInsideBigBracket++;
                            }
                            else
                            if (pSym->IsRightBigBracket())
                            {
                                cInsideBigBracket--;
                                if (0 == cInsideBigBracket && ! fEndMacro)
                                {
                                    // basically, it is the end of macro
                                    pMacro->SetBodyPart(pSym->GetStr());
                                    fEndMacro = TRUE;
                                }
                            }
                        } // while

                        // throw away anything possibly in CONSTRAINED BY
                        if (! fEndMacro)
                        {
                            pMacro->SetBodyPart(pSym->GetStr());
                        }
                    } // while

                    // macro must end with a eol
                    fWasNewLine = TRUE;
                    fInsideComment = FALSE;

                    // write out the eol
                    pMacro->SetBodyPart("\n");

                    // take a note of ending a macro
                    pMacro->EndMacro();
                    pMacroMgr->AddMacro(pMacro);

                    // to avoid fWasNewLine being reset.
                    continue;
                } // if left bracket
                else
                if (pSym->GetID() == SYMBOL_DEFINITION)
                {
                    pSym->NextUsefulSymbol();
                    if (pSym->GetID() == SYMBOL_IDENTIFIER &&
                        pTypeID->FindAlias(pSym->GetStr()))
                    {
                        // Found a type identifier
                        pSym->NextSymbol();
                        if (pSym->IsDot())
                        {
                            pSym->NextSymbol();
                            if (pSym->GetID() == SYMBOL_FIELD &&
                                0 == ::strcmp("&Type", pSym->GetStr()))
                            {
                                // defined type identifier
                                pSym->NextUsefulSymbol();
                                ASSERT(pSym->IsLeftParenth());
                                if (pSym->IsLeftParenth())
                                {
                                    pSym->NextUsefulSymbol();
                                    if (pSym->GetID() == SYMBOL_IDENTIFIER)
                                    {
                                        rc = pTypeID->AddInstance(&szNameScratch[0], pSym->GetStr());
                                        ASSERT(rc);

                                        pSym->NextUsefulSymbol();
                                        ASSERT(pSym->IsRightParenth());
                                    }
                                }
                            }
                        }
                        else
                        {
                            rc = pTypeID->AddAlias(&szNameScratch[0]);
                            ASSERT(rc);
                        }
                    }
                } // if symbol definition
            } // if symbol identifier
            else
            if (fWasNewLine &&
                (0 == cInsideBigBracket) &&
                (pSym->GetID() == SYMBOL_KEYWORD) &&
                (0 == ::strcmp("IMPORTS", pSym->GetStr())))
            {
                // skip the entire import area
                do
                {
                    pSym->NextUsefulSymbol();
                    if (pSym->GetID() == SYMBOL_IDENTIFIER)
                    {
                        ::strcpy(&szNameScratch[0], pSym->GetStr());
                        pSym->NextUsefulSymbol();
                        if (pSym->IsLeftBigBracket())
                        {
                            NameList.AddName(&szNameScratch[0]);
                            pSym->NextUsefulSymbol();
                            ASSERT(pSym->IsRightBigBracket());
                        }
                    }
                    // else // no else because the current symbol can be FROM
                    if (pSym->GetID() == SYMBOL_KEYWORD &&
                        0 == ::strcmp("FROM", pSym->GetStr()))
                    {
                        pSym->NextUsefulSymbol();
                        if (pSym->GetID() == SYMBOL_IDENTIFIER)
                        {
                            LPSTR pszName;
                            CMacro *pMacro;
                            while (NULL != (pszName = NameList.Get()))
                            {
                                pMacro = pMacroMgrList->FindMacro(pSym->GetStr(), pszName);
                                if (NULL != pMacro)
                                {
                                    pMacro = new CMacro(&rc, pMacro);
                                    if (NULL != pMacro && rc)
                                    {
                                        pMacroMgr->AddMacro(pMacro);
                                    }
                                    else
                                    {
                                        ASSERT(0);
                                    }
                                }
                                else
                                {
                                    ASSERT(0);
                                }
                                delete pszName;
                            } // while
                        }
                    }
                }
                while (! pSym->IsSemicolon());
            }
        } // if ! comment

        // Must be reset at the end of this block.
        fWasNewLine = FALSE;
    } // while

    delete pSym;
    return TRUE;
}


BOOL InstantiateMacros
(
    CInput          *pInput,
    CMacroMgr       *pMacroMgr
)
{
    // Create a running symbol handler
    CSymbol *pSym = new CSymbol(pInput);
    if (NULL == pSym)
    {
        return FALSE;
    }

    BOOL rc;
    BOOL fInsideComment = FALSE;
    UINT cInsideBigBracket = 0;

    // Walk through the text
    while (pSym->NextSymbol())
    {
        if (pSym->GetID() == SYMBOL_SPACE_EOL)
        {
            fInsideComment = FALSE;
        }
        else
        if (pSym->IsComment())
        {
            fInsideComment = ! fInsideComment;
        }
        else
        if (! fInsideComment)
        {
            if (pSym->IsLeftBigBracket())
            {
                cInsideBigBracket++;
            }
            else
            if (pSym->IsRightBigBracket())
            {
                cInsideBigBracket--;
            }
            else
            if ((0 < cInsideBigBracket) &&
                (pSym->GetID() == SYMBOL_IDENTIFIER))
            {
                CMacro *pMacro = pMacroMgr->FindMacro(pSym->GetStr());
                if (NULL != pMacro)
                {
                    UINT cCurrBracket = cInsideBigBracket;

                    // Found a macro instance
                    pSym->NextUsefulSymbol();
                    if (pSym->IsLeftBigBracket())
                    {
                        cInsideBigBracket++;

                        // We need to process the argument list now.
                        do
                        {
                            pSym->NextUsefulSymbol();
                            pMacro->SetArg(pSym->GetStr());
                            pSym->NextUsefulSymbol();
                        }
                        while (pSym->IsComma());

                        ASSERT(pSym->IsRightBigBracket());
                        if (pSym->IsRightBigBracket())
                        {
                            cInsideBigBracket--;
                        }
                        ASSERT(cCurrBracket == cInsideBigBracket);

                        rc = pMacro->InstantiateMacro();
                        ASSERT(rc);
                    }
                }
            }
        } // ! inside comment
    } // while

    delete pSym;
    return TRUE;
}


BOOL GenerateOutput
(
    CInput          *pInput,
    COutput         *pOutput,
    CMacroMgr       *pMacroMgr,
    CTypeID         *pTypeID
)
{
    // Create a running symbol handler
    CSymbol *pSym = new CSymbol(pInput);
    if (NULL == pSym)
    {
        return FALSE;
    }

    BOOL rc;
    BOOL fWasNewLine = FALSE;
    BOOL fEndMacro = FALSE;
    UINT cInsideBigBracket = 0;
    BOOL fInsideComment = FALSE;
    BOOL fIgnoreThisSym = FALSE;
    BOOL fInsideImport = FALSE;
    UINT nOutputImportedMacrosNow = 0;

    // Walk through the text
    while (pSym->NextSymbol())
    {
        fIgnoreThisSym = FALSE; // default is to output this symbol

        if (pSym->GetID() == SYMBOL_SPACE_EOL)
        {
            fWasNewLine = TRUE;
            fInsideComment = FALSE;
        }
        else
        {
            if (pSym->IsComment())
            {
                fInsideComment = ! fInsideComment;
            }
            else
            if (! fInsideComment)
            {
                if (pSym->IsLeftBigBracket())
                {
                    cInsideBigBracket++;
                }
                else
                if (pSym->IsRightBigBracket())
                {
                    cInsideBigBracket--;
                }
                else
                if (pSym->IsSemicolon())
                {
                    fInsideImport = FALSE;
                    nOutputImportedMacrosNow++;
                }
                else
                // The macro must be outside the big brackets and
                // in the beginning of a line.
                if (fWasNewLine &&
                    (0 == cInsideBigBracket) &&
                    (pSym->GetID() == SYMBOL_IDENTIFIER))
                {
                    CMacro *pMacro;
                    LPSTR pszOldSubType;

                    if (NULL != (pMacro = pMacroMgr->FindMacro(pSym->GetStr())))
                    {
                        // Found a macro template
                        fIgnoreThisSym = TRUE;

                        if (! pMacro->IsImported())
                        {
                            // Output all instances of this macro.
                            rc = pMacro->OutputInstances(pOutput);
                            ASSERT(rc);

                            // Ignore the macro template body
                            pSym->NextUsefulSymbol();
                            if (pSym->IsLeftBigBracket())
                            {
                                cInsideBigBracket++;

                                // Ignore the argument list
                                do
                                {
                                    // yes, two calls... not a mistake!
                                    pSym->NextUsefulSymbol();
                                    pSym->NextUsefulSymbol();
                                }
                                while (pSym->IsComma());
                                ASSERT(pSym->IsRightBigBracket());
                                if (pSym->IsRightBigBracket())
                                {
                                    cInsideBigBracket--;
                                }

                                // Ignore the macro body
                                ASSERT(0 == cInsideBigBracket);
                                fEndMacro = FALSE;
                                while (! fEndMacro || pSym->GetID() != SYMBOL_SPACE_EOL)
                                {
                                    pSym->NextSymbol();
                                    if (pSym->GetID() == SYMBOL_SPACE_EOL)
                                    {
                                        fInsideComment = FALSE;
                                    }
                                    else
                                    if (pSym->IsComment())
                                    {
                                        fInsideComment = ! fInsideComment;
                                    }
                                    else
                                    if (! fInsideComment)
                                    {
                                        if (pSym->IsLeftBigBracket())
                                        {
                                            cInsideBigBracket++;
                                        }
                                        else
                                        if (pSym->IsRightBigBracket())
                                        {
                                            cInsideBigBracket--;
                                            if (0 == cInsideBigBracket)
                                            {
                                                // basically, it is the end of macro
                                                fEndMacro = TRUE;
                                            }
                                        }
                                    }
                                } // while

                                // macro must end with a eol
                                fWasNewLine = TRUE;
                                fInsideComment = FALSE;

                                // to avoid fWasNewLine being reset
                                // it is ok to continue because we do not output this symbol.
                                ASSERT(fIgnoreThisSym);
                                continue;
                            } // if left bracket
                        } // ! imported
                        else
                        {
                            // Ignore the macro template body
                            pSym->NextUsefulSymbol();
                            ASSERT(pSym->IsLeftBigBracket());
                            pSym->NextUsefulSymbol();
                            ASSERT(pSym->IsRightBigBracket());
                            pSym->NextUsefulSymbol();
                            if (! pSym->IsComma())
                            {
                                fIgnoreThisSym = FALSE;
                            }
                        } // imported
                    } // if pMacro
                    else
                    if (pTypeID->FindAlias(pSym->GetStr()))
                    {
                        // Found a type ID alias. Let's skip this line entirely
                        do
                        {
                            pSym->NextSymbol();
                        }
                        while (pSym->GetID() != SYMBOL_SPACE_EOL);
                    } // if find alias
                    else
                    if (NULL != (pszOldSubType = pTypeID->FindInstance(pSym->GetStr())))
                    {
                        // Found a type ID instance. Let's output the construct.
                        rc = pTypeID->GenerateOutput(pOutput, pSym->GetStr(), pszOldSubType);
                        ASSERT(rc);

                        // Skip the body entirely
                        do
                        {
                            pSym->NextUsefulSymbol();
                        }
                        while (! pSym->IsRightParenth());

                        // Skip the rest of this line
                        do
                        {
                            pSym->NextSymbol();
                        }
                        while (pSym->GetID() != SYMBOL_SPACE_EOL);
                    } // if find instance
                }
                else
                if ((0 < cInsideBigBracket) &&
                    (pSym->GetID() == SYMBOL_IDENTIFIER))
                {
                    CMacro *pMacro = pMacroMgr->FindMacro(pSym->GetStr());
                    if (NULL != pMacro)
                    {
                        UINT cCurrBracket = cInsideBigBracket;

                        // Found a macro instance
                        fIgnoreThisSym = TRUE;

                        // Create an instance name.
                        pSym->NextUsefulSymbol();
                        if (pSym->IsLeftBigBracket())
                        {
                            cInsideBigBracket++;

                            // We need to process the argument list now.
                            do
                            {
                                pSym->NextUsefulSymbol();
                                pMacro->SetArg(pSym->GetStr());
                                pSym->NextUsefulSymbol();
                            }
                            while (pSym->IsComma());

                            ASSERT(pSym->IsRightBigBracket());
                            if (pSym->IsRightBigBracket())
                            {
                                cInsideBigBracket--;
                            }
                            ASSERT(cCurrBracket == cInsideBigBracket);

                            LPSTR pszInstanceName = pMacro->CreateInstanceName();
                            ASSERT(NULL != pszInstanceName);
                            if (NULL != pszInstanceName)
                            {
                                rc = pOutput->Write(pszInstanceName, ::strlen(pszInstanceName));
                                ASSERT(rc);
                                delete pszInstanceName;
                            }
                            pMacro->DeleteArgList();
                        }
                    }
                }
                else
                if (fWasNewLine &&
                    (0 == cInsideBigBracket) &&
                    (pSym->GetID() == SYMBOL_KEYWORD) &&
                    (0 == ::strcmp("IMPORTS", pSym->GetStr())))
                {
                    fInsideImport = TRUE;
                }
            } // if ! comment

            // Must be reset at the end of this block.
            fWasNewLine = FALSE;
        } // if ! space eol

        if (! fIgnoreThisSym)
        {
            // write out this symbol
            rc = pOutput->Write(pSym->GetStr(), pSym->GetStrLen());
            ASSERT(rc);
        }

        // only generate once
        if (1 == nOutputImportedMacrosNow)
        {
            nOutputImportedMacrosNow++;
            rc = pMacroMgr->OutputImportedMacros(pOutput);
            ASSERT(rc);
        }
    } // while

    delete pSym;
    return TRUE;
}



void BuildOutputFileName
(
    LPSTR           pszInputFileName,
    LPSTR           pszNewOutputFileName
)
{
    LPSTR psz;
    ::strcpy(pszNewOutputFileName, pszInputFileName);
    if (NULL != (psz = ::strrchr(pszNewOutputFileName, '.')) &&
        0 == ::strcmpi(psz, ".asn"))
    {
        ::strcpy(psz, ".out");
    }
    else
    {
        ::strcat(pszNewOutputFileName, ".out");
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\asn1\asn1cpp\getsym.cpp ===
/* Copyright (C) Microsoft Corporation, 1998. All rights reserved. */

#include "precomp.h"
#include "getsym.h"
#include "utils.h"


CInput::
CInput
(
    BOOL           *pfRetCode,
    LPSTR           pszPathName,
    UINT            cbBufSize
)
:
    m_cbBufSize(cbBufSize),
    m_cbValidData(0),
    m_nCurrOffset(0),
    m_chCurr(INVALID_CHAR),
    m_fEndOfFile(TRUE)
{
    m_pszPathName = ::My_strdup(pszPathName);
    m_pbDataBuf = new BYTE[m_cbBufSize];

    m_hFile = ::CreateFile(pszPathName,
                           GENERIC_READ,
                           FILE_SHARE_READ,
                           NULL, // default security
                           OPEN_EXISTING,
                           FILE_ATTRIBUTE_NORMAL | FILE_ATTRIBUTE_READONLY,
                           NULL); // no template

    m_cbFileSize = (NULL != m_hFile) ? ::GetFileSize(m_hFile, NULL) : 0;

    *pfRetCode = (NULL != m_pszPathName) &&
                 (NULL != m_pbDataBuf) &&
                 (NULL != m_hFile);

    if (*pfRetCode)
    {
        if (CheckBuffer(1))
        {
            m_chCurr = m_pbDataBuf[0];
            m_fEndOfFile = FALSE;
        }
    }
}


CInput::
~CInput ( void )
{
    delete m_pszPathName;
    delete m_pbDataBuf;

    if (NULL != m_hFile)
    {
        ::CloseHandle(m_hFile);
    }
}


void CInput::
NextChar ( void )
{
    if (INVALID_CHAR != m_chCurr)
    {
        // set up the next new char
        if (CheckBuffer(1))
        {
            m_chCurr = m_pbDataBuf[++m_nCurrOffset];
        }
        else
        {
            m_chCurr = INVALID_CHAR;
            m_fEndOfFile = TRUE;
        }
    }
}


void CInput::
PeekChars ( UINT cChars, LPSTR pszChars )
{
    if (CheckBuffer(cChars - 1))
    {
        ::CopyMemory(pszChars, &m_pbDataBuf[m_nCurrOffset], cChars);
    }
    else
    {
        ::ZeroMemory(pszChars, cChars);
    }
}


void CInput::
SkipChars ( UINT cChars )
{
    for (UINT i = 0; i < cChars; i++)
    {
        NextChar();
    }
}


BOOL CInput::
CheckBuffer ( UINT cChars )
{
    if (m_nCurrOffset + cChars >= m_cbValidData)
    {
        ASSERT(m_cbValidData >= m_nCurrOffset);
        UINT cbCurrValid = m_cbValidData - m_nCurrOffset;
        UINT cbToRead = m_cbBufSize - cbCurrValid;

        if (cbCurrValid > 0)
        {
            // Move the data to the front of the buffer.
            ::CopyMemory(&m_pbDataBuf[0], &m_pbDataBuf[m_nCurrOffset], cbCurrValid);
            m_nCurrOffset = 0;
        }

        ULONG cbRead = 0;
        if (::ReadFile(m_hFile, &m_pbDataBuf[cbCurrValid], cbToRead, &cbRead, NULL))
        {
            ASSERT(cbRead <= cbToRead);
            m_cbValidData = cbCurrValid + cbRead;
            m_nCurrOffset = 0;

            if (cbRead < cbToRead)
            {
                m_fEndOfFile = TRUE;
            }
        }
        else
        {
            m_fEndOfFile = TRUE;
        }

        return (m_nCurrOffset + cChars < m_cbValidData);
    }

    return TRUE;
}


BOOL CInput::
Rewind ( void )
{
    if ((DWORD) -1 != ::SetFilePointer(m_hFile, 0, NULL, FILE_BEGIN))
    {
        // clean up members
        m_cbValidData = 0;
        m_nCurrOffset = 0;
        m_chCurr = INVALID_CHAR;

        // set up the buffer
        if (CheckBuffer(1))
        {
            m_chCurr = m_pbDataBuf[0];
            m_fEndOfFile = FALSE;
        }
        else
        {
            m_fEndOfFile = TRUE;
        }
        return TRUE;
    }
    return FALSE;
}




CSymbol::
CSymbol ( CInput *pInput )
:
    m_pInput(pInput),
    m_eSymbolID(SYMBOL_UNKNOWN),
    m_cchSymbolStr(0)
{
    m_szSymbolStr[0] = '\0';
}


BOOL CSymbol::
NextSymbol ( void )
{
    if (SYMBOL_EOF == m_eSymbolID)
    {
        return FALSE;
    }

    char ch = m_pInput->GetChar();
    m_szSymbolStr[0] = ch;
    m_cchSymbolStr = 1;

    m_pInput->NextChar();

    if (::isdigit(ch))
    {
        // numbers
        while (INVALID_CHAR != (ch = m_pInput->GetChar()))
        {
            if (::isdigit(ch))
            {
                m_szSymbolStr[m_cchSymbolStr++] = ch;
                m_pInput->NextChar();
            }
            else
            {
                break;
            }
        }
        m_eSymbolID = SYMBOL_NUMBER;
    }
    else
    if (::isalpha(ch))
    {
        // alphanumeric
        while (INVALID_CHAR != (ch = m_pInput->GetChar()))
        {
            if (::isalnum(ch) || '_' == ch || '-' == ch)
            {
                m_szSymbolStr[m_cchSymbolStr++] = ch;
                m_pInput->NextChar();
            }
            else
            {
                m_szSymbolStr[m_cchSymbolStr] = '\0';
                break;
            }
        }

        m_eSymbolID = ::IsKeyword(&m_szSymbolStr[0]) ? SYMBOL_KEYWORD : SYMBOL_IDENTIFIER;
    }
    else
    if ('\n' == ch)
    {
        m_szSymbolStr[m_cchSymbolStr++] = '\n';
        m_eSymbolID = SYMBOL_SPACE_EOL;
    }
    else
    if (::isspace(ch))
    {
        // space
        m_eSymbolID = SYMBOL_SPACE;
        while (INVALID_CHAR != (ch = m_pInput->GetChar()))
        {
            if (::isspace(ch))
            {
                m_szSymbolStr[m_cchSymbolStr++] = ch;
                m_pInput->NextChar();
                if ('\n' == ch)
                {
                    m_eSymbolID = SYMBOL_SPACE_EOL;
                }
            }
            else
            {
                break;
            }
        }
    }
    else
    if ('&' == ch)
    {
        m_eSymbolID = SYMBOL_FIELD;

        // alphanumeric
        while (INVALID_CHAR != (ch = m_pInput->GetChar()))
        {
            if (::isalnum(ch) || '_' == ch)
            {
                m_szSymbolStr[m_cchSymbolStr++] = ch;
                m_pInput->NextChar();
            }
            else
            {
                m_szSymbolStr[m_cchSymbolStr] = '\0';
                break;
            }
        }
    }
    else
    {
        char szTemp[4];
        m_eSymbolID = SYMBOL_SPECIAL;

        if (':' == ch)
        {
            m_pInput->PeekChars(2, &szTemp[0]);
            if (':' == szTemp[0] && '=' == szTemp[1])
            {
                m_pInput->SkipChars(2);
                m_szSymbolStr[m_cchSymbolStr++] = ':';
                m_szSymbolStr[m_cchSymbolStr++] = '=';
                m_eSymbolID = SYMBOL_DEFINITION;
            }
        }
        else
        if ('-' == ch)
        {
            m_pInput->PeekChars(1, &szTemp[0]);
            if ('-' == szTemp[0])
            {
                m_pInput->SkipChars(1);
                m_szSymbolStr[m_cchSymbolStr++] = '-';
                m_eSymbolID = SYMBOL_COMMENT;
            }
        }
        else
        if ('.' == ch)
        {
            m_pInput->PeekChars(2, &szTemp[0]);
            if ('.' == szTemp[0] && '.' == szTemp[1])
            {
                m_pInput->SkipChars(2);
                m_szSymbolStr[m_cchSymbolStr++] = '.';
                m_szSymbolStr[m_cchSymbolStr++] = '.';
                m_eSymbolID = SYMBOL_DOTDOTDOT;
            }
        }
    }

    // null terminate the string
    m_szSymbolStr[m_cchSymbolStr] = '\0';

    if (INVALID_CHAR != m_szSymbolStr[0])
    {
        return TRUE;
    }

    m_eSymbolID = SYMBOL_EOF;
    return FALSE;
}


BOOL CSymbol::
NextUsefulSymbol ( void )
{
    BOOL fInsideComment = FALSE;
    while (NextSymbol())
    {
        if (SYMBOL_SPACE_EOL == m_eSymbolID)
        {
            fInsideComment = FALSE;
        }
        else
        if (SYMBOL_COMMENT == m_eSymbolID)
        {
            fInsideComment = ! fInsideComment;
        }
        else
        if (! fInsideComment)
        {
            if (SYMBOL_SPACE != m_eSymbolID)
            {
                return TRUE;
            }
        }
    }
    return FALSE;
}



COutput::
COutput
(
    BOOL           *pfRetCode,
    LPSTR           pszPathName,
    UINT            cbBufSize
)
:
    m_cbBufSize(cbBufSize),
    m_cbValidData(0)
{
    m_pszPathName = ::My_strdup(pszPathName);
    m_pbDataBuf = new BYTE[m_cbBufSize];
    m_hFile = ::CreateFile(pszPathName,
                           GENERIC_WRITE,
                           FILE_SHARE_READ,
                           NULL, // default security
                           CREATE_ALWAYS,
                           FILE_ATTRIBUTE_NORMAL,
                           NULL); // no template
    *pfRetCode = (NULL != m_pszPathName) &&
                 (NULL != m_pbDataBuf) &&
                 (NULL != m_hFile);
}


COutput::
~COutput ( void )
{
    delete m_pszPathName;
    delete m_pbDataBuf;

    if (NULL != m_hFile)
    {
        Flush();
        ::CloseHandle(m_hFile);
    }
}


BOOL COutput::
Write
(
    LPBYTE          pbDataBuf,
    UINT            cbToWrite
)
{
    ULONG cbWritten;

    while (0 != cbToWrite)
    {
        if (::WriteFile(m_hFile, pbDataBuf, cbToWrite, &cbWritten, NULL))
        {
            pbDataBuf += cbWritten;
            cbToWrite -= cbWritten;
        }
        else
        {
            return FALSE;
        }
    }

    return TRUE;
}


BOOL COutput::
Writeln
(
    LPBYTE          pbDataBuf,
    UINT            cbToWrite
)
{
    return Write(pbDataBuf, cbToWrite) && Write("\n", 1);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\asn1\asn1cpp\getsym.h ===
/* Copyright (C) Microsoft Corporation, 1998. All rights reserved. */

#ifndef _GETSYM_H_
#define _GETSYM_H_

#define INPUT_BUFFER_SIZE       4096
#define OUTPUT_BUFFER_SIZE      4096

#define INVALID_CHAR            ((char) 0)

class CInput
{
public:

    CInput ( BOOL *pfRetCode, LPSTR pszPathName, UINT cbBufSize = INPUT_BUFFER_SIZE );
    ~CInput ( void );

    void NextChar ( void );
    void PeekChars ( UINT cChars, LPSTR pszChars );
    void SkipChars ( UINT cChars );
    char GetChar ( void ) { return (char)m_chCurr; }

    BOOL IsEOF ( void )
    {
        return (m_fEndOfFile && (m_nCurrOffset >= m_cbValidData));
    }

    UINT GetFileSize ( void ) { return m_cbFileSize; }
    BOOL Rewind ( void );

private:

    BOOL CheckBuffer ( UINT cChars );

    LPSTR           m_pszPathName;
    UINT            m_chCurr;
    UINT            m_nCurrOffset;
    BOOL            m_fEndOfFile;
    UINT            m_cbBufSize;
    LPBYTE          m_pbDataBuf;
    UINT            m_cbValidData;
    HANDLE          m_hFile;
    UINT            m_cbFileSize;
};



typedef enum
{
    SYMBOL_UNKNOWN,     // initial value
    SYMBOL_EOF,
    SYMBOL_IDENTIFIER,
    SYMBOL_KEYWORD,
    SYMBOL_SPECIAL,
    SYMBOL_NUMBER,
    SYMBOL_DEFINITION,  // "::="
    SYMBOL_COMMENT,     // "--"
    SYMBOL_DOTDOTDOT,   // "..."
    SYMBOL_SPACE,
    SYMBOL_SPACE_EOL,
    SYMBOL_FIELD,       // "&Type"
}
    SYMBOL_ID;


class CSymbol
{
public:

    CSymbol ( CInput *pInput );
    ~CSymbol ( void ) { }

    BOOL NextSymbol ( void );
    BOOL NextUsefulSymbol ( void );

    SYMBOL_ID GetID ( void ) { return m_eSymbolID; }
    UINT GetStrLen ( void ) { return m_cchSymbolStr; }
    LPSTR GetStr ( void ) { return &m_szSymbolStr[0]; }

    BOOL IsSpecial ( void ) { return (SYMBOL_SPECIAL == m_eSymbolID); }
    BOOL IsSpecialChar ( char ch ) { return (IsSpecial() && ch == m_szSymbolStr[0]); }

    BOOL IsLeftBigBracket ( void ) { return IsSpecialChar('{'); }
    BOOL IsRightBigBracket ( void ) { return IsSpecialChar('}'); }
    BOOL IsComma ( void ) { return IsSpecialChar(','); }
    BOOL IsDot ( void ) { return IsSpecialChar('.'); }
    BOOL IsLeftParenth ( void ) { return IsSpecialChar('('); }
    BOOL IsRightParenth ( void ) { return IsSpecialChar(')'); }
    BOOL IsSemicolon ( void ) { return IsSpecialChar(';'); }
    BOOL IsComment ( void ) { return (SYMBOL_COMMENT == m_eSymbolID); }

private:

    CInput         *m_pInput;
    SYMBOL_ID       m_eSymbolID;
    UINT            m_cchSymbolStr;
    char            m_szSymbolStr[MAX_PATH];
};




class COutput
{
public:

    COutput ( BOOL *pfRetCode, LPSTR pszPathName, UINT cbBufSize = OUTPUT_BUFFER_SIZE );
    ~COutput ( void );

    void Flush ( void ) { ::FlushFileBuffers(m_hFile); }

    BOOL Write ( LPBYTE pbDataBuf, UINT cbData );
    BOOL Write ( LPSTR pszDataBuf, UINT cbData ) { return Write((LPBYTE) pszDataBuf, cbData); }
    BOOL Write ( LPCSTR pszDataBuf, UINT cbData ) { return Write((LPBYTE) pszDataBuf, cbData); }
    BOOL Write ( CSymbol *pSym ) { return Write(pSym->GetStr(), pSym->GetStrLen()); }

    BOOL Writeln ( LPBYTE pbDataBuf, UINT cbData );
    BOOL Writeln ( LPSTR pszDataBuf, UINT cbData ) { return Writeln((LPBYTE) pszDataBuf, cbData); }
    BOOL Writeln ( LPCSTR pszDataBuf, UINT cbData ) { return Writeln((LPBYTE) pszDataBuf, cbData); }

private:

    LPSTR           m_pszPathName;
    UINT            m_cbBufSize;
    LPBYTE          m_pbDataBuf;
    UINT            m_cbValidData;
    HANDLE          m_hFile;
};


#endif // _GETSYM_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\asn1\asn1cpp\macro.h ===
/* Copyright (C) Microsoft Corporation, 1998. All rights reserved. */

#ifndef _MACRO_H_
#define _MACRO_H_

#include "getsym.h"
#include "utils.h"
#include "cntlist.h"


#define DEF_BODY_SIZE       2048

#define ARG_ESCAPE_CHAR     '$'
#define ARG_INDEX_BASE      '0'


// forward class definitions
class CMacro;
class CMacroMgr;
class CMacroInstance;

// list classes
class CMacroInstList : public CList
{
    DEFINE_CLIST(CMacroInstList, CMacroInstance*);
    void DeleteList ( void );
};
class CMacroList : public CList
{
    DEFINE_CLIST(CMacroList, CMacro*);
    void DeleteList ( void );
};
class CMacroMgrList : public CList
{
    DEFINE_CLIST(CMacroMgrList, CMacroMgr*);
    CMacro *FindMacro ( LPSTR pszModuleName, LPSTR pszMacroName );
    CMacroMgr *FindMacroMgr ( LPSTR pszModuleName );
    void Uninstance ( void );
    void DeleteList ( void );
};
class CNameList : public CList
{
    DEFINE_CLIST(CNameList, LPSTR);
    BOOL AddName ( LPSTR );
    LPSTR GetNthItem ( UINT nth );
    void DeleteList ( void );
};






class CMacro
{
public:

    CMacro ( BOOL *pfRetCode, LPSTR pszMacroName, UINT cbMaxBodySize = DEF_BODY_SIZE );
    CMacro ( BOOL *pfRetCode, CMacro *pMacro );
    ~CMacro ( void );

    void SetArg ( LPSTR pszArgName ) { m_ArgList.AddName(pszArgName); }
    void DeleteArgList ( void ) { m_ArgList.DeleteList(); }

    BOOL SetBodyPart ( LPSTR pszBodyPart );
    void EndMacro ( void );

    LPSTR CreateInstanceName ( void );
    BOOL InstantiateMacro ( void );
    BOOL OutputInstances ( COutput *pOutput );

    LPSTR GetName ( void ) { return m_pszMacroName; }

    void Uninstance ( void );

    BOOL IsImported ( void ) { return m_fImported; }

private:

    LPSTR               m_pszMacroName;

    UINT                m_cFormalArgs;
    CNameList           m_ArgList;

    UINT                m_cbMaxBodySize;
    UINT                m_cbBodySize;
    LPSTR               m_pszCurr;
    LPSTR               m_pszBodyBuffer;
    LPSTR               m_pszExpandBuffer;

    CMacroInstList      m_MacroInstList;

    BOOL                m_fArgExistsInBody;
    BOOL                m_fImported;
};



class CMacroMgr
{
public:

    CMacroMgr ( void );
    ~CMacroMgr ( void );

    BOOL AddModuleName ( LPSTR pszModuleName );
    LPSTR GetModuleName ( void ) { return m_pszModuleName; }

    void AddMacro ( CMacro *pMacro ) { m_MacroList.Append(pMacro); }
    CMacro *FindMacro ( LPSTR pszMacroName );

    BOOL OutputImportedMacros ( COutput *pOutput );

    void Uninstance ( void );

private:

    CMacroList          m_MacroList;
    LPSTR               m_pszModuleName;
};



class CMacroInstance
{
public:

    CMacroInstance ( BOOL *pfRetCode, LPSTR pszInstanceName, UINT cbBufSize, LPSTR pszInstBuf );
    ~CMacroInstance ( void );

    LPSTR GetName ( void ) { return m_pszInstanceName; }
    UINT GetNameLen ( void ) { return ::strlen(m_pszInstanceName); }

    LPSTR GetBuffer ( void ) { return m_pszInstanceBuffer; }
    UINT GetBufSize ( void ) { return m_cbBufSize; }

private:

    LPSTR               m_pszInstanceName;

    UINT                m_cbBufSize;
    LPSTR               m_pszInstanceBuffer;
};



#endif // _MACRO_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\asn1\asn1cpp\cntlist.cpp ===
/* Copyright (C) Microsoft Corporation, 1998. All rights reserved. */

#include "precomp.h"
#include "cntlist.h"


CList::CList(UINT cMaxItems)
:
    m_cMaxEntries(cMaxItems)
{
    Init(1);
}


CList::CList(CList *pSrc)
:
    m_cMaxEntries(pSrc->GetCount())
{

    Init(1);

    LPVOID p;
    pSrc->Reset();
    while (NULL != (p = pSrc->Iterate()))
    {
        Append(p);
    }
}


CList::CList(UINT cMaxItems, UINT cSubItems)
:
    m_cMaxEntries(cMaxItems)
{
    ASSERT(2 == cSubItems);
    Init(cSubItems);
}


BOOL CList::Init(UINT cSubItems)
{
    if (m_cMaxEntries < CLIST_DEFAULT_MAX_ITEMS)
    {
        m_cMaxEntries = CLIST_DEFAULT_MAX_ITEMS;
    }

    m_cEntries = 0;
    m_nHeadOffset = 0;
    m_nCurrOffset = CLIST_END_OF_ARRAY_MARK;
    m_cSubItems = cSubItems;

    // it is kind of bad here because there is no way to return an error.
    // unfortunately it won't fault here and later.
    m_aEntries = (LPVOID *) new char[m_cMaxEntries * m_cSubItems * sizeof(LPVOID)];
    CalcKeyArray();
    return (BOOL) m_aEntries;
}


CList::~CList(void) 
{
    delete m_aEntries;
}


void CList::CalcKeyArray(void)
{
    if (1 == m_cSubItems)
    {
        m_aKeys = NULL;
    }
    else
    {
        ASSERT(2 == m_cSubItems);
        m_aKeys = (NULL != m_aEntries) ?
                        (UINT *) &m_aEntries[m_cMaxEntries] :
                        NULL;
    }
}


BOOL CList::Expand(void)
{
    if (NULL == m_aEntries)
    {
        // it is impossible.
        ASSERT(FALSE);
        return Init(m_cSubItems);
    }

    // the current array is full
    ASSERT(m_cEntries == m_cMaxEntries);

    // remember the old array to free or to restore
    LPVOID  *aOldEntries = m_aEntries;

    // we need to allocate a bigger array to hold more data.
    // the new array has twice the size of the old one
    UINT cNewMaxEntries = m_cMaxEntries << 1;
    m_aEntries = (LPVOID *) new char[cNewMaxEntries * m_cSubItems * sizeof(LPVOID)];
    if (NULL == m_aEntries)
    {
        // we failed; we have to restore the array and return
        m_aEntries = aOldEntries;
        return FALSE;
    }

    // copy the old entries into the new array, starting from the beginning
    UINT nIdx = m_cMaxEntries - m_nHeadOffset;
    ::CopyMemory(m_aEntries, &aOldEntries[m_nHeadOffset], nIdx * sizeof(LPVOID));
    ::CopyMemory(&m_aEntries[nIdx], aOldEntries, m_nHeadOffset * sizeof(LPVOID));

    // set the new max entries (required for the key array)
    m_cMaxEntries = cNewMaxEntries;

    if (m_cSubItems > 1)
    {
        ASSERT(2 == m_cSubItems);
        UINT *aOldKeys = m_aKeys;
        CalcKeyArray();
        ::CopyMemory(m_aKeys, &aOldKeys[m_nHeadOffset], nIdx * sizeof(UINT));
        ::CopyMemory(&m_aKeys[nIdx], aOldKeys, m_nHeadOffset * sizeof(UINT));
    }

    // Free the old array of entries
    delete aOldEntries;

    // Set the instance variables
    m_nHeadOffset = 0;
    m_nCurrOffset = CLIST_END_OF_ARRAY_MARK;

    return TRUE;
}


BOOL CList::Append(LPVOID pData)
{
    if (NULL == m_aEntries || m_cEntries >= m_cMaxEntries)
    {
        if (! Expand())
        {
            return FALSE;
        }
    }

    ASSERT(NULL != m_aEntries);
    ASSERT(m_cEntries < m_cMaxEntries);

    m_aEntries[(m_nHeadOffset + (m_cEntries++)) % m_cMaxEntries] = pData;

    return TRUE;
}


BOOL CList::Prepend(LPVOID pData)
{
    if (NULL == m_aEntries || m_cEntries >= m_cMaxEntries)
    {
        if (! Expand())
        {
            return FALSE;
        }
    }

    ASSERT(NULL != m_aEntries);
    ASSERT(m_cEntries < m_cMaxEntries);

    m_cEntries++;
    m_nHeadOffset = (0 == m_nHeadOffset) ? m_cMaxEntries - 1 : m_nHeadOffset - 1;
    m_aEntries[m_nHeadOffset] = pData;

    return TRUE;
}


BOOL CList::Find(LPVOID pData)
{
    for (UINT i = 0; i < m_cEntries; i++)
    {
        if (pData == m_aEntries[(m_nHeadOffset + i) % m_cMaxEntries])
        {
            return TRUE;
        }
    }
    return FALSE;
}


BOOL CList::Remove(LPVOID pData)
{
    UINT nIdx;
    for (UINT i = 0; i < m_cEntries; i++)
    {
        nIdx = (m_nHeadOffset + i) % m_cMaxEntries;
        if (pData == m_aEntries[nIdx])
        {
            // to remove the current, we simply move the last to here.
            UINT nIdxSrc = (m_nHeadOffset + (m_cEntries - 1)) % m_cMaxEntries;
            m_aEntries[nIdx] = m_aEntries[nIdxSrc];
            if (m_cSubItems > 1)
            {
                ASSERT(2 == m_cSubItems);
                m_aKeys[nIdx] = m_aKeys[nIdxSrc];
            }
            m_cEntries--;
            return TRUE;
        }
    }
    return FALSE;
}


LPVOID CList::Get(void)
{
    LPVOID pRet = NULL;

    if (m_cEntries > 0)
    {
        pRet = m_aEntries[m_nHeadOffset];
        m_cEntries--;
        m_nHeadOffset = (m_nHeadOffset + 1) % m_cMaxEntries;
    }
    else
    {
        pRet = NULL;
    }
    return pRet;
}


LPVOID CList::Iterate(void)
{
    if (0 == m_cEntries)
    {
        return NULL;
    }

    if (m_nCurrOffset == CLIST_END_OF_ARRAY_MARK)
    {
        // start from the beginning
        m_nCurrOffset = 0;
    }
    else
    {
        if (++m_nCurrOffset >= m_cEntries)
        {
            // reset the iterator
            m_nCurrOffset = CLIST_END_OF_ARRAY_MARK;
            return NULL;
        }
    }

    return m_aEntries[(m_nHeadOffset + m_nCurrOffset) % m_cMaxEntries];
}





CList2::CList2(CList2 *pSrc)
:
    CList(pSrc->GetCount(), 2)
{
    CalcKeyArray();

    LPVOID p;
    UINT n;
    pSrc->Reset();
    while (NULL != (p = pSrc->Iterate(&n)))
    {
        Append(n, p);
    }
}


BOOL CList2::Append(UINT nKey, LPVOID pData)
{
    if (! CList::Append(pData))
    {
        return FALSE;
    }

    // after CList::append(), m_cEntries has been incremented,
    // therefore, we need decrement it again.
    m_aKeys[(m_nHeadOffset + (m_cEntries - 1)) % m_cMaxEntries] = nKey;
    return TRUE;
}


BOOL CList2::Prepend(UINT nKey, LPVOID pData)
{
    if (! CList::Prepend(pData))
    {
        return FALSE;
    }

    m_aKeys[m_nHeadOffset] = nKey;
    return TRUE;
}


LPVOID CList2::Find(UINT nKey)
{
    UINT nIdx;
    for (UINT i = 0; i < m_cEntries; i++)
    {
        nIdx = (m_nHeadOffset + i) % m_cMaxEntries;
        if (nKey == m_aKeys[nIdx])
        {
            return m_aEntries[nIdx];
        }
    }
    return NULL;
}


LPVOID CList2::Remove(UINT nKey)
{
    UINT nIdx;
    for (UINT i = 0; i < m_cEntries; i++)
    {
        nIdx = (m_nHeadOffset + i) % m_cMaxEntries;
        if (nKey == m_aKeys[nIdx])
        {
            LPVOID pRet = m_aEntries[nIdx];

            // to remove the current, we simply move the last to here.
            UINT nIdxSrc = (m_nHeadOffset + (m_cEntries - 1)) % m_cMaxEntries;
            m_aEntries[nIdx] = m_aEntries[nIdxSrc];
            m_aKeys[nIdx] = m_aKeys[nIdxSrc];
            m_cEntries--;
            return pRet;
        }
    }
    return NULL;
}


LPVOID CList2::Get(UINT *pnKey)
{
    LPVOID pRet = NULL;

    if (m_cEntries > 0)
    {
        pRet = m_aEntries[m_nHeadOffset];
        *pnKey = m_aKeys[m_nHeadOffset];
        m_cEntries--;
        m_nHeadOffset = (m_nHeadOffset + 1) % m_cMaxEntries;
    }
    else
    {
        pRet = NULL;
        *pnKey = 0;
    }
    return pRet;
}


LPVOID CList2::Iterate(UINT *pnKey)
{
    LPVOID p = CList::Iterate();
    *pnKey = (NULL != p) ? m_aKeys[(m_nHeadOffset + m_nCurrOffset) % m_cMaxEntries] : 0;
    return p;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\asn1\asn1cpp\cntlist.h ===
/* Copyright (C) Microsoft Corporation, 1998. All rights reserved. */

#ifndef _CONTAINED_LIST_H_
#define _CONTAINED_LIST_H_


#define CLIST_DEFAULT_MAX_ITEMS   8
#define CLIST_END_OF_ARRAY_MARK   ((UINT) -1)


class CList
{
public:

    CList(UINT cMaxItems = CLIST_DEFAULT_MAX_ITEMS);
    CList(CList *pSrc);

    CList(UINT cMaxItems, UINT cSubItems);

    ~CList(void);

    BOOL Append(LPVOID pData);
    BOOL Prepend(LPVOID pData);

    BOOL Find(LPVOID pData);
    BOOL Remove(LPVOID pData);

    LPVOID Get(void);

    LPVOID Iterate(void);

    void Reset(void) { m_nCurrOffset = CLIST_END_OF_ARRAY_MARK; };
    void Clear(void) { m_cEntries = 0; m_nHeadOffset = 0; m_nCurrOffset = CLIST_END_OF_ARRAY_MARK; };

    UINT GetCount(void) { return m_cEntries; };
    BOOL IsEmpty(void) { return (m_cEntries == 0); };

    LPVOID PeekHead(void) { return (0 != m_cEntries) ? m_aEntries[m_nHeadOffset] : NULL; }

protected:

    void CalcKeyArray(void);

protected:

    UINT       m_cEntries;
    UINT       m_cMaxEntries;
    UINT       m_nHeadOffset;
    UINT       m_nCurrOffset;
    UINT       m_cSubItems;    // 1 for CList, 2 for CList2

    LPVOID      *m_aEntries;
    UINT        *m_aKeys;       // for CList2

private:

    BOOL Expand(void);
    BOOL Init(UINT cSubItems);
};


#define DEFINE_CLIST(_NewClass_,_PtrItemType_) \
            public: \
            _NewClass_(UINT cMaxItems = CLIST_DEFAULT_MAX_ITEMS) : CList(cMaxItems) { ASSERT(sizeof(_PtrItemType_) == sizeof(LPVOID)); } \
            _NewClass_(_NewClass_ *pSrc) : CList((CList *) pSrc) { ASSERT(sizeof(_PtrItemType_) == sizeof(LPVOID)); } \
            _NewClass_(_NewClass_ &Src) : CList((CList *) &Src) { ASSERT(sizeof(_PtrItemType_) == sizeof(LPVOID)); } \
            BOOL Append(_PtrItemType_ pData) { return CList::Append((LPVOID) pData); } \
            BOOL Prepend(_PtrItemType_ pData) { return CList::Prepend((LPVOID) pData); } \
            BOOL Remove(_PtrItemType_ pData) { return CList::Remove((LPVOID) pData); } \
            BOOL Find(_PtrItemType_ pData) { return CList::Find((LPVOID) pData); } \
            _PtrItemType_ Get(void) { return (_PtrItemType_) CList::Get(); } \
            _PtrItemType_ PeekHead(void) { return (_PtrItemType_) CList::PeekHead(); } \
            _PtrItemType_ Iterate(void) { return (_PtrItemType_) CList::Iterate(); }

#define DEFINE_CLIST_(_NewClass_,_IntItemType_) \
            public: \
            _NewClass_(UINT cMaxItems = CLIST_DEFAULT_MAX_ITEMS) : CList(cMaxItems) { ASSERT(sizeof(_IntItemType_) <= sizeof(LPVOID)); } \
            _NewClass_(_NewClass_ *pSrc) : CList((CList *) pSrc) { ASSERT(sizeof(_IntItemType_) <= sizeof(LPVOID)); } \
            _NewClass_(_NewClass_ &Src) : CList((CList *) &Src) { ASSERT(sizeof(_IntItemType_) <= sizeof(LPVOID)); } \
            BOOL Append(_IntItemType_ nData) { return CList::Append((LPVOID) nData); } \
            BOOL Prepend(_IntItemType_ nData) { return CList::Prepend((LPVOID) nData); } \
            BOOL Remove(_IntItemType_ nData) { return CList::Remove((LPVOID) nData); } \
            BOOL Find(_IntItemType_ nData) { return CList::Find((LPVOID) nData); } \
            _IntItemType_ Get(void) { return (_IntItemType_) CList::Get(); } \
            _IntItemType_ PeekHead(void) { return (_IntItemType_) CList::PeekHead(); } \
            _IntItemType_ Iterate(void) { return (_IntItemType_) CList::Iterate(); }


class CList2 : public CList
{
public:

    CList2(UINT cMaxItems = CLIST_DEFAULT_MAX_ITEMS) : CList(cMaxItems, 2) { }
    CList2(CList2 *pSrc);

    BOOL Append(UINT nKey, LPVOID pData);
    BOOL Prepend(UINT nKey, LPVOID pData);

    // BOOL Remove(LPVOID pData); // inherited from CList
    LPVOID Remove(UINT nKey);

    // BOOL Find(LPVOID pData); // inherited from CList
    LPVOID Find(UINT nKey);

    // LPVOID Get(void); // inheirted from CList
    LPVOID Get(UINT *pnKey);

    // LPVOID Iterate(void); // inherited from CList
    LPVOID Iterate(UINT *pnKey);
};


#define DEFINE_CLIST2(_NewClass_,_PtrItemType_,_IntKeyType_) \
            public: \
            _NewClass_(UINT cMaxItems = CLIST_DEFAULT_MAX_ITEMS) : CList2(cMaxItems) { ASSERT(sizeof(_IntKeyType_) == sizeof(UINT)); ASSERT(sizeof(_PtrItemType_) <= sizeof(LPVOID)); } \
            _NewClass_(_NewClass_ *pSrc) : CList2((CList2 *) pSrc) { ASSERT(sizeof(_IntKeyType_) == sizeof(UINT)); ASSERT(sizeof(_PtrItemType_) <= sizeof(LPVOID)); } \
            _NewClass_(_NewClass_ &Src) : CList2((CList2 *) &Src) { ASSERT(sizeof(_IntKeyType_) == sizeof(UINT)); ASSERT(sizeof(_PtrItemType_) <= sizeof(LPVOID)); } \
            BOOL Append(_IntKeyType_ nKey, _PtrItemType_ pData) { return CList2::Append((UINT) nKey, (LPVOID) pData); } \
            BOOL Prepend(_IntKeyType_ nKey, _PtrItemType_ pData) { return CList2::Prepend((UINT) nKey, (LPVOID) pData); } \
            BOOL          Remove(_PtrItemType_ pData) { return CList::Remove((LPVOID) pData); } \
            _PtrItemType_ Remove(_IntKeyType_ nKey) { return (_PtrItemType_) CList2::Remove((UINT) nKey); } \
            BOOL          Find(_PtrItemType_ pData) { return CList::Find((LPVOID) pData); } \
            _PtrItemType_ Find(_IntKeyType_ nKey) { return (_PtrItemType_) CList2::Find((UINT) nKey); } \
            _PtrItemType_ Get(void) { return (_PtrItemType_) CList::Get(); } \
            _PtrItemType_ Get(_IntKeyType_ *pnKey) { return (_PtrItemType_) CList2::Get((UINT *) pnKey); } \
            _PtrItemType_ PeekHead(void) { return (_PtrItemType_) CList::PeekHead(); } \
            _PtrItemType_ Iterate(void) { return (_PtrItemType_) CList::Iterate(); } \
            _PtrItemType_ Iterate(_IntKeyType_ *pnKey) { return (_PtrItemType_) CList2::Iterate((UINT *) pnKey); }

#define DEFINE_CLIST2_(_NewClass_,_PtrItemType_,_ShortKeyType_) \
            public: \
            _NewClass_(UINT cMaxItems = CLIST_DEFAULT_MAX_ITEMS) : CList2(cMaxItems) { ASSERT(sizeof(_ShortKeyType_) != sizeof(UINT)); ASSERT(sizeof(_PtrItemType_) == sizeof(LPVOID)); } \
            _NewClass_(_NewClass_ *pSrc) : CList2((CList2 *) pSrc) { ASSERT(sizeof(_ShortKeyType_) != sizeof(UINT)); ASSERT(sizeof(_PtrItemType_) == sizeof(LPVOID)); } \
            _NewClass_(_NewClass_ &Src) : CList2((CList2 *) &Src) { ASSERT(sizeof(_ShortKeyType_) != sizeof(UINT)); ASSERT(sizeof(_PtrItemType_) == sizeof(LPVOID)); } \
            BOOL Append(_ShortKeyType_ nKey, _PtrItemType_ pData) { return CList2::Append((UINT) nKey, (LPVOID) pData); } \
            BOOL Prepend(_ShortKeyType_ nKey, _PtrItemType_ pData) { return CList2::Prepend((UINT) nKey, (LPVOID) pData); } \
            BOOL          Remove(_PtrItemType_ pData) { return CList::Remove((LPVOID) pData); } \
            _PtrItemType_ Remove(_ShortKeyType_ nKey) { return (_PtrItemType_) CList2::Remove((UINT) nKey); } \
            BOOL          Find(_PtrItemType_ pData) { return CList::Find((LPVOID) pData); } \
            _PtrItemType_ Find(_ShortKeyType_ nKey) { return (_PtrItemType_) CList2::Find((UINT) nKey); } \
            _PtrItemType_ Get(void) { return (_PtrItemType_) CList::Get(); } \
            _PtrItemType_ Get(_ShortKeyType_ *pnKey) { UINT n; _PtrItemType_ p = (_PtrItemType_) CList2::Get(&n); *pnKey = (_ShortKeyType_) n; return p; } \
            _PtrItemType_ PeekHead(void) { return (_PtrItemType_) CList::PeekHead(); } \
            _PtrItemType_ Iterate(void) { return (_PtrItemType_) CList::Iterate(); } \
            _PtrItemType_ Iterate(_ShortKeyType_ *pnKey) { UINT n; _PtrItemType_ p = (_PtrItemType_) CList2::Iterate(&n); *pnKey = (_ShortKeyType_) n; return p; }

// both key and item are of the same type
#define DEFINE_CLIST2__(_NewClass_,_IntKeyType_) \
            public: \
            _NewClass_(UINT cMaxItems = CLIST_DEFAULT_MAX_ITEMS) : CList2(cMaxItems) { ASSERT(sizeof(_IntKeyType_) == sizeof(UINT)); ASSERT(sizeof(_IntKeyType_) == sizeof(LPVOID)); } \
            _NewClass_(_NewClass_ *pSrc) : CList2((CList2 *) pSrc) { ASSERT(sizeof(_IntKeyType_) == sizeof(UINT)); ASSERT(sizeof(_IntKeyType_) == sizeof(LPVOID)); } \
            _NewClass_(_NewClass_ &Src) : CList2((CList2 *) &Src) { ASSERT(sizeof(_IntKeyType_) == sizeof(UINT)); ASSERT(sizeof(_IntKeyType_) == sizeof(LPVOID)); } \
            BOOL Append(_IntKeyType_ nKey, _IntKeyType_ nData) { return CList2::Append((UINT) nKey, (LPVOID) nData); } \
            BOOL Prepend(_IntKeyType_ nKey, _IntKeyType_ nData) { return CList2::Prepend((UINT) nKey, (LPVOID) nData); } \
            _IntKeyType_ Remove(_IntKeyType_ nKey) { return (_IntKeyType_) CList2::Remove((UINT) nKey); } \
            _IntKeyType_ Find(_IntKeyType_ nKey) { return (_IntKeyType_) CList2::Find((UINT) nKey); } \
            _IntKeyType_ Get(void) { return (_IntKeyType_) CList::Get(); } \
            _IntKeyType_ Get(_IntKeyType_ *pnKey) { return (_IntKeyType_) CList2::Get((UINT *) pnKey); } \
            _IntKeyType_ PeekHead(void) { return (_IntKeyType_) CList::PeekHead(); } \
            _IntKeyType_ Iterate(void) { return (_IntKeyType_) CList::Iterate(); } \
            _IntKeyType_ Iterate(_IntKeyType_ *pnKey) { return (_IntKeyType_) CList2::Iterate((UINT *) pnKey); }


typedef LPVOID          BOOL_PTR;
#define TRUE_PTR        ((LPVOID) (UINT)  1)
#define FALSE_PTR       ((LPVOID) (UINT) -1)

#endif // _CONTAINED_LIST_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\asn1\asn1cpp\precomp.h ===
/* Copyright (C) Microsoft Corporation, 1998. All rights reserved. */

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <stdarg.h>
#include <stddef.h>
#include <ctype.h>
#include <memory.h>

#define ASN1CPP

#include <windows.h>

#define ARRAY_SIZE(arr)     (sizeof(arr) / sizeof(arr[0]))


#ifdef _DEBUG

__inline void MyDebugBreak(void) { DebugBreak(); }

#undef ASSERT
#define ASSERT(x)           if (!(x)) MyDebugBreak();

#else

#undef ASSERT
#define ASSERT(x)

#endif // _DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\asn1\asn1cpp\macro.cpp ===
/* Copyright (C) Microsoft Corporation, 1998. All rights reserved. */

#include "precomp.h"
#include "macro.h"


CMacro::
CMacro
(
    BOOL           *pfRetCode,
    LPSTR           pszMacroName,
    UINT            cbMaxBodySize
)
:
    m_ArgList(8),  // default 8 arguments
    m_MacroInstList(16), // default 16 instances of this macro
    m_cFormalArgs(0),
    m_cbBodySize(0),
    m_cbMaxBodySize(cbMaxBodySize),
    m_pszExpandBuffer(NULL),
    m_fArgExistsInBody(FALSE),
    m_fImported(FALSE)
{
    m_pszMacroName = ::My_strdup(pszMacroName);

    m_pszBodyBuffer = new char[m_cbMaxBodySize];
    m_pszCurr = m_pszBodyBuffer;

    *pfRetCode = (NULL != m_pszMacroName) &&
                 (NULL != m_pszBodyBuffer);
}


CMacro::
CMacro
(
    BOOL            *pfRetCode,
    CMacro          *pMacro
)
:
    m_ArgList(pMacro->m_ArgList.GetCount()),  // default 8 arguments
    m_MacroInstList(16), // default 16 instances of this macro
    m_cFormalArgs(pMacro->m_cFormalArgs),
    m_cbBodySize(pMacro->m_cbBodySize),
    m_cbMaxBodySize(pMacro->m_cbMaxBodySize),
    m_pszExpandBuffer(NULL),
    m_fArgExistsInBody(pMacro->m_fArgExistsInBody),
    m_fImported(TRUE)
{
    m_pszMacroName = ::My_strdup(pMacro->m_pszMacroName);
    m_pszBodyBuffer = new char[m_cbMaxBodySize];
    if (NULL != m_pszMacroName && NULL != m_pszBodyBuffer)
    {
        // copy the body
        ::memcpy(m_pszBodyBuffer, pMacro->m_pszBodyBuffer, pMacro->m_cbBodySize);

        // adjust the current buffer pointer
        m_pszCurr = m_pszBodyBuffer + m_cbBodySize;

        // null terminated the body
        *m_pszCurr++ = '\0';

        // set up the expand buffer
        m_pszExpandBuffer = m_pszCurr;

        *pfRetCode = TRUE;
    }
    else
    {
        *pfRetCode = FALSE;
    }
}


CMacro::
~CMacro ( void )
{
    delete m_pszBodyBuffer;

    Uninstance();
}


void CMacro::
Uninstance ( void )
{
    m_ArgList.DeleteList();
    m_MacroInstList.DeleteList();
}


BOOL CMacro::
SetBodyPart ( LPSTR pszBodyPart )
{
    UINT cch = ::strlen(pszBodyPart);
    ASSERT(m_pszCurr + cch + 1 < m_pszBodyBuffer + m_cbMaxBodySize);
    if (m_pszCurr + cch + 1 < m_pszBodyBuffer + m_cbMaxBodySize)
    {
        LPSTR psz;
        m_ArgList.Reset();
        for (UINT i = 0; NULL != (psz = m_ArgList.Iterate()); i++)
        {
            if (0 == ::strcmp(pszBodyPart, psz))
            {
                // this is an argument
                m_fArgExistsInBody = TRUE;
                *m_pszCurr++ = ARG_ESCAPE_CHAR;
                *m_pszCurr++ = ARG_INDEX_BASE + i;
                return TRUE;
            }
        }

        // this is not an argument.
        ::memcpy(m_pszCurr, pszBodyPart, cch);
        m_pszCurr += cch;
        *m_pszCurr = '\0';
        return TRUE;
    }
    return FALSE;
}


void CMacro::
EndMacro ( void )
{
    // save the count of arguments
    m_cFormalArgs = m_ArgList.GetCount();

    // calculate the size of the body
    m_cbBodySize = m_pszCurr - m_pszBodyBuffer;

    // null terminated the body
    *m_pszCurr++ = '\0';

    // set up the expand buffer
    m_pszExpandBuffer = m_pszCurr;

    // free the memory
    DeleteArgList();
}


BOOL CMacro::
InstantiateMacro ( void )
{
    BOOL rc = FALSE; // assume failure
    LPSTR pszInstName, pszSrc, pszDst;
    UINT i, cch;
    CMacroInstance *pInst;

    if (! m_fArgExistsInBody)
    {
        // No need to instantiate because the body does not contain any argument.
        // We can take the body as the instance.
        rc = TRUE;
        goto MyExit;
    }

    ASSERT(m_ArgList.GetCount() == m_cFormalArgs);
    if (m_ArgList.GetCount() != m_cFormalArgs)
    {
        goto MyExit;
    }

    pszInstName = CreateInstanceName();
    if (NULL == pszInstName)
    {
        goto MyExit;
    }

    m_MacroInstList.Reset();
    while (NULL != (pInst = m_MacroInstList.Iterate()))
    {
        if (0 == ::strcmp(pszInstName, pInst->GetName()))
        {
            // same instance has been instantiated before.
            rc = TRUE;
            delete pszInstName;
            goto MyExit;
        }
    }

    // Let's instantiate a new instance...

    pszSrc = m_pszBodyBuffer;
    pszDst = m_pszExpandBuffer;

    // put in macro name first
    ::strcpy(pszDst, pszInstName);
    pszDst += ::strlen(pszDst);

    // put in macro body now.
    while (*pszSrc != '\0')
    {
        if (*pszSrc == ARG_ESCAPE_CHAR)
        {
            pszSrc++;
            i = *pszSrc++ - ARG_INDEX_BASE;
            ASSERT(i < m_ArgList.GetCount());
            LPSTR pszArgName = m_ArgList.GetNthItem(i);
            cch = ::strlen(pszArgName);
            ::memcpy(pszDst, pszArgName, cch);
            pszDst += cch;
        }
        else
        {
            *pszDst++ = *pszSrc++;
        }
    }
    *pszDst++ = '\n';
    *pszDst = '\0';

    // create an instance
    pInst = new CMacroInstance(&rc,
                               pszInstName,
                               pszDst - m_pszExpandBuffer,
                               m_pszExpandBuffer);
    if (NULL != pInst && rc)
    {
        m_MacroInstList.Append(pInst);
    }

MyExit:

    // free up temporary argument names
    m_ArgList.DeleteList();

    return rc;
}


BOOL CMacro::
OutputInstances ( COutput *pOutput )
{
    BOOL rc = TRUE;
    CMacroInstance *pInst;
    if (m_fArgExistsInBody)
    {
        m_MacroInstList.Reset();
        while (NULL != (pInst = m_MacroInstList.Iterate()))
        {
            rc = pOutput->Write(pInst->GetBuffer(), pInst->GetBufSize());
            ASSERT(rc);
        }
    }
    else
    {
        rc = pOutput->Write(m_pszMacroName, ::strlen(m_pszMacroName));
        ASSERT(rc);
        rc = pOutput->Writeln(m_pszBodyBuffer, m_cbBodySize);
        ASSERT(rc);
    }
    return rc;
}


LPSTR CMacro::
CreateInstanceName ( void )
{
    UINT cch = ::strlen(m_pszMacroName) + 2;
    UINT i;
    LPSTR psz, pszArgName;

    if (m_fArgExistsInBody)
    {
        ASSERT(m_ArgList.GetCount() == m_cFormalArgs);
        m_ArgList.Reset();
        while (NULL != (pszArgName = m_ArgList.Iterate()))
        {
            cch += ::strlen(pszArgName) + 1;
        }
    }

    LPSTR pszInstanceName = new char[cch];
    if (NULL != pszInstanceName)
    {
        psz = pszInstanceName;
        ::strcpy(psz, m_pszMacroName);

        if (m_fArgExistsInBody)
        {
            psz += ::strlen(psz);
            m_ArgList.Reset();
            while (NULL != (pszArgName = m_ArgList.Iterate()))
            {
                *psz++ = '-';
                ::strcpy(psz, pszArgName);
                psz += ::strlen(psz);
            }
        }
    }

    return pszInstanceName;
}





CMacro * CMacroMgrList::
FindMacro
(
    LPSTR           pszModuleName,
    LPSTR           pszMacroName
)
{
    CMacroMgr *pMacroMgr = FindMacroMgr(pszModuleName);
    return (NULL != pMacroMgr) ? pMacroMgr->FindMacro(pszMacroName) : NULL;
}


CMacroMgr * CMacroMgrList::
FindMacroMgr ( LPSTR pszModuleName )
{
    CMacroMgr *pMacroMgr;
    Reset();
    while (NULL != (pMacroMgr = Iterate()))
    {
        if (0 == ::strcmp(pszModuleName, pMacroMgr->GetModuleName()))
        {
            return pMacroMgr;
        }
    }
    return NULL;
}


void CMacroMgrList::
Uninstance ( void )
{
    CMacroMgr *pMacroMgr;
    Reset();
    while (NULL != (pMacroMgr = Iterate()))
    {
        pMacroMgr->Uninstance();
    }
}






CMacroMgr::
CMacroMgr ( void )
:
    m_MacroList(16),  // default 16 macros
    m_pszModuleName(NULL)
{
}


CMacroMgr::
~CMacroMgr ( void )
{
    m_MacroList.DeleteList();
    delete m_pszModuleName;
}


BOOL CMacroMgr::
AddModuleName ( LPSTR pszModuleName )
{
    // can only be set once
    ASSERT(NULL == m_pszModuleName);

    m_pszModuleName = ::My_strdup(pszModuleName);
    ASSERT(NULL != m_pszModuleName);

    return (NULL != m_pszModuleName);
}


CMacro *CMacroMgr::
FindMacro ( LPSTR pszMacroName )
{
    CMacro *pMacro;
    m_MacroList.Reset();
    while (NULL != (pMacro = m_MacroList.Iterate()))
    {
        if (0 == ::strcmp(pszMacroName, pMacro->GetName()))
        {
            return pMacro;
        }
    }
    return NULL;
}


BOOL CMacroMgr::
OutputImportedMacros ( COutput *pOutput )
{
    BOOL rc = TRUE;
    CMacro *pMacro;

    rc = pOutput->Write("\n\n", 2);

    m_MacroList.Reset();
    while (NULL != (pMacro = m_MacroList.Iterate()))
    {
        if (pMacro->IsImported())
        {
            rc = pMacro->OutputInstances(pOutput);
            if (! rc)
            {
                ASSERT(0);
                return FALSE;
            }
        }
    }
    return rc;
}


void CMacroMgr::
Uninstance ( void )
{
    CMacro *pMacro;
    m_MacroList.Reset();
    while (NULL != (pMacro = m_MacroList.Iterate()))
    {
        pMacro->Uninstance();  
    }
}







CMacroInstance::
CMacroInstance
(
    BOOL       *pfRetCode,
    LPSTR       pszInstanceName,
    UINT        cbBufSize,
    LPSTR       pszInstBuf
)
:
    m_pszInstanceName(pszInstanceName),
    m_cbBufSize(cbBufSize)
{
    m_pszInstanceBuffer = new char[m_cbBufSize];
    if (NULL != m_pszInstanceBuffer)
    {
        ::memcpy(m_pszInstanceBuffer, pszInstBuf, m_cbBufSize);
    }

    *pfRetCode = (NULL != m_pszInstanceName) && (NULL != m_pszInstanceBuffer);
}


CMacroInstance::
~CMacroInstance ( void )
{
    delete m_pszInstanceName;
    delete m_pszInstanceBuffer;
}





void CMacroInstList::
DeleteList ( void )
{
    CMacroInstance *pInst;
    while (NULL != (pInst = Get()))
    {
        delete pInst;
    }
}




void CMacroList::
DeleteList ( void )
{
    CMacro *pMacro;
    while (NULL != (pMacro = Get()))
    {
        delete pMacro;
    }
}



void CMacroMgrList::
DeleteList ( void )
{
    CMacroMgr *pMacroMgr;
    while (NULL != (pMacroMgr = Get()))
    {
        delete pMacroMgr;
    }
}


BOOL CNameList::
AddName ( LPSTR pszName )
{
    pszName = ::My_strdup(pszName);
    if (NULL != pszName)
    {
        Append(pszName);
        return TRUE;
    }
    return FALSE;
}


LPSTR CNameList::
GetNthItem ( UINT nth )
{
    LPSTR psz;
    if (nth < GetCount())
    {
        Reset();
        do
        {
            psz = Iterate();
        }
        while (nth--);
    }
    else
    {
        psz = NULL;
    }
    return psz;
}


void CNameList::
DeleteList ( void )
{
    LPSTR psz;
    while (NULL != (psz = Get()))
    {
        delete psz;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\asn1\asn1cpp\typeid.h ===
/* Copyright (C) Microsoft Corporation, 1998. All rights reserved. */

#ifndef _TYPEID_H_
#define _TYPEID_H_

#include "getsym.h"
#include "utils.h"
#include "cntlist.h"



// list classes
class CAliasList : public CList
{
    DEFINE_CLIST(CAliasList, LPSTR);
};
class CTypeInstList2 : public CList2
{
    // key: new super type, item: old sub type
    DEFINE_CLIST2__(CTypeInstList2, LPSTR);
};


class CTypeID
{
public:

    CTypeID ( void );
    ~CTypeID ( void );

    BOOL AddAlias ( LPSTR pszAlias );
    LPSTR FindAlias ( LPSTR pszToMatch );

    BOOL AddInstance ( LPSTR pszNewSuperType, LPSTR pszOldSubType );
    LPSTR FindInstance ( LPSTR pszInstName );

    BOOL GenerateOutput ( COutput *pOutput, LPSTR pszNewSuperType, LPSTR pszOldSubType );

private:

    UINT                m_cbPriorPartSize;
    UINT                m_cbPostPartSize;

    CAliasList          m_AliasList;
    CTypeInstList2      m_TypeInstList2;
};




#endif // _TYPEID_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\asn1\asn1cpp\typeid.cpp ===
/* Copyright (C) Microsoft Corporation, 1998. All rights reserved. */

#include "precomp.h"
#include "typeid.h"


const char c_szTypeIdentifierPriorPart[] = 
                    " ::= SEQUENCE \n"
                    "{\n"
                    "\tid\t\tOBJECT IDENTIFIER,\n"
                    "\ttype\t\t";

const char c_szTypeIdentifierPostPart[] = 
                    "\n"
                    "}\n";



CTypeID::
CTypeID ( void )
:
    m_AliasList(8), // default 8 aliases
    m_TypeInstList2(16) // default 16 type instances
{
    m_cbPriorPartSize = ::strlen(&c_szTypeIdentifierPriorPart[0]);
    m_cbPostPartSize = ::strlen(&c_szTypeIdentifierPostPart[0]);

    BOOL rc;
    rc = AddAlias("TYPE-IDENTIFIER");
    ASSERT(rc);
    rc = AddAlias("ABSTRACT-IDENTIFIER");
    ASSERT(rc);
}


CTypeID::
~CTypeID ( void )
{
    LPSTR pszAlias;
    while (NULL != (pszAlias = m_AliasList.Get()))
    {
        delete pszAlias;
    }

    LPSTR pszNewSuperType, pszOldSubType;
    while (NULL != (pszOldSubType = m_TypeInstList2.Get(&pszNewSuperType)))
    {
        delete pszOldSubType;
        delete pszNewSuperType;
    }
}


BOOL CTypeID::
AddAlias ( LPSTR pszAlias )
{
    pszAlias = ::My_strdup(pszAlias);
    if (NULL != pszAlias)
    {
        m_AliasList.Append(pszAlias);
        return TRUE;
    }
    return FALSE;
}


LPSTR CTypeID::
FindAlias ( LPSTR pszToMatch )
{
    LPSTR pszAlias;
    m_AliasList.Reset();
    while (NULL != (pszAlias = m_AliasList.Iterate()))
    {
        if (0 == ::strcmp(pszAlias, pszToMatch))
        {
            break;
        }
    }
    return pszAlias;
}


BOOL CTypeID::
AddInstance
(
    LPSTR       pszNewSuperType,
    LPSTR       pszOldSubType
)
{
    pszNewSuperType = ::My_strdup(pszNewSuperType);
    pszOldSubType = ::My_strdup(pszOldSubType);
    if (NULL != pszNewSuperType && NULL != pszOldSubType)
    {
        m_TypeInstList2.Append(pszNewSuperType, pszOldSubType);
        return TRUE;
    }

    delete pszNewSuperType;
    delete pszOldSubType;
    return FALSE;
}


LPSTR CTypeID::
FindInstance ( LPSTR pszInstName )
{
    LPSTR pszNewSuperType, pszOldSubType;
    m_TypeInstList2.Reset();
    while (NULL != (pszOldSubType = m_TypeInstList2.Iterate(&pszNewSuperType)))
    {
        if (0 == ::strcmp(pszInstName, pszNewSuperType))
        {
            return pszOldSubType;
        }
    }
    return NULL;
}


BOOL CTypeID::
GenerateOutput
(
    COutput    *pOutput,
    LPSTR       pszNewSuperType,
    LPSTR       pszOldSubType
)
{
    BOOL rc1, rc2, rc3, rc4;

    rc1 = pOutput->Write(pszNewSuperType, ::strlen(pszNewSuperType));
    ASSERT(rc1);

    rc2 = pOutput->Write(&c_szTypeIdentifierPriorPart[0], m_cbPriorPartSize);
    ASSERT(rc2);

    rc3 = pOutput->Write(pszOldSubType, ::strlen(pszOldSubType));
    ASSERT(rc3);

    rc4 = pOutput->Write(&c_szTypeIdentifierPostPart[0], m_cbPostPartSize);
    ASSERT(rc4);

    return (rc1 && rc2 && rc3 && rc4);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\asn1\asn1cpp\utils.cpp ===
/* Copyright (C) Microsoft Corporation, 1998. All rights reserved. */

#include "precomp.h"
#include "utils.h"


LPSTR My_strdup ( LPCSTR pszSrc )
{
    LPSTR pszDst = NULL;
    if (NULL != pszSrc)
    {
        UINT cch = ::strlen(pszSrc) + 1;
        if (NULL != (pszDst = new char[cch]))
        {
            ::CopyMemory(pszDst, pszSrc, cch);
        }
    }
    return pszDst;
}


const LPSTR c_apszKeywords[] =
{
    "ANY",
    "AUTOMATIC",
    "BEGIN",
    "BIT",
    "BMPString",
    "BY",
    "CHOICE",
    "COMPONENT",
    "CONSTRAINED",
    "DEFINITIONS",
    "END",
    "FROM",
    "IDENTIFIER",
    "IMPORTS",
    "INTEGER",
    "IV8",
    "NULL",
    "OBJECT",
    "OCTET",
    "OPTIONAL",
    "SEQUENCE",
    "SIZE",
    "STRING",
    "SYNTAX",
    "TAGS",
    "WITH",
};


BOOL IsKeyword ( LPSTR pszSymbol )
{
    return (BOOL) BinarySearch_Str(pszSymbol, &c_apszKeywords[0], ARRAY_SIZE(c_apszKeywords));
}


LPSTR BinarySearch_Str ( LPSTR pszKey, const LPSTR aKeyTbl[], UINT cKeys )
{
    UINT lo = 0;
    UINT hi = cKeys - 1;
    UINT num = cKeys;
    UINT mid, half;
    int result;

    while (lo <= hi)
    {
        if (0 != (half = num >> 1))
        {
            mid = lo + ((num - 1) >> 1);
            if (0 == (result = ::strcmp(pszKey, aKeyTbl[mid])))
            {
                return aKeyTbl[mid];
            }
            else if (result < 0)
            {
                hi = mid - 1;
                num = (num - 1) >> 1;
            }
            else
            {
                lo = mid + 1;
                num = half;
            }
        }
        else if (num)
        {
            return (::strcmp(pszKey, aKeyTbl[lo]) ? NULL : aKeyTbl[lo]);
        }
        else
        {
            break;
        }
    }

    return NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\asn1\asn1cpp\utils.h ===
/* Copyright (C) Microsoft Corporation, 1998. All rights reserved. */

#ifndef _UTILS_H_
#define _UTILS_H_


LPSTR My_strdup ( LPCSTR pszSrc );

BOOL IsKeyword ( LPSTR pszSymbol );
LPSTR BinarySearch_Str ( LPSTR pszKey, const LPSTR aKeyTbl[], UINT cKeys );

#endif // _UTILS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\buggy\control\tcontrol.cxx ===
//
// Template driver user-mode controller
// Copyright (c) Microsoft Corporation, 1999.
//
// Module:  tcontrol.cxx
// Author:  Silviu Calinoiu (SilviuC)
// Created: 4/20/1999 3:40pm
//
// This module contains a user-mode controller for a template
// driver.
//
// --- History ---
//
// 4/20/1999 (SilviuC): initial version.
//

#include <stdlib.h>
#include <stdio.h>
#include <tchar.h>
#include <windows.h>
#include <winioctl.h>
#include <time.h>

#define NO_BUGGY_FUNCTIONS
#define FUNS_DEFINITION_MODULE
#include "..\driver\tdriver.h"
#include "..\driver\funs.h"


//
// Get rid of performance warnings for BOOL to bool conversions
//

#pragma warning (disable: 4800)


bool TdCreateService (LPCTSTR DriverName);
bool TdDeleteService (LPCTSTR DriverName);
bool TdStartService (LPCTSTR DriverName);
bool TdStopService (LPCTSTR DriverName);
bool TdOpenDevice (LPCTSTR DriverName, PHANDLE DeviceHandle);
bool TdCloseDevice (HANDLE Device);
bool TdSendIoctl (IN HANDLE Device, IN DWORD Ioctl, IN PVOID pData OPTIONAL, IN ULONG uDataSize OPTIONAL);

void TdSectMapProcessAddressSpaceTest();
void TdSectMapSystemAddressSpaceTest();

VOID
TdReservedMapSetSize( int argc, char *argv[] );

VOID
TdReservedMapRead( VOID );

BOOL
ProcessCommandLine (
    LPCTSTR Option
    );

ULONG_PTR
UtilHexStringToUlongPtr( char *szHexNumber );

///////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////// Main()
///////////////////////////////////////////////////////////////////////////////

void _cdecl
main (int argc, char *argv[])
{
    BOOL DisplayHelp;
    HANDLE Device;
    DWORD Index;
    char *pCrtChar;

    DisplayHelp = FALSE;

    try {

        if (argc == 3 && _stricmp (argv[1], "/create") == 0) {
            TdCreateService (argv[2]);
        }
        else if (argc == 3 && _stricmp (argv[1], "/delete") == 0) {
            TdDeleteService (argv[2]);
        }
        else if (argc == 3 && _stricmp (argv[1], "/start") == 0) {
            TdStartService (argv[2]);
        }
        else if (argc == 3 && _stricmp (argv[1], "/stop") == 0) {
            TdStopService (argv[2]);
        }
        else if (argc == 2 && _stricmp (argv[1], "/sectionmaptest") == 0) {

            TdSectMapProcessAddressSpaceTest();
        }
        else if (argc == 2 && _stricmp (argv[1], "/sectionmaptestsysspace") == 0) {

            TdSectMapSystemAddressSpaceTest();
        }
        else if ( _stricmp (argv[1], "/ReservedMapSetSize") == 0) {

            TdReservedMapSetSize( argc, argv );
        }
        else if ( _stricmp (argv[1], "/ReservedMapRead") == 0) {

            TdReservedMapRead();
        }
        else if (argc >= 2 && _stricmp (argv[1], "/ioctlbugcheck") == 0) {

            //
            // Send the bugcheck parameters from the command line
            //

            BUGCHECK_PARAMS BugcheckParams;

            ZeroMemory( &BugcheckParams, sizeof( BugcheckParams ) );

            //
            // Bugcheck code
            //

            if( argc >= 3 )
            {
                BugcheckParams.BugCheckCode = (ULONG)UtilHexStringToUlongPtr( argv[ 2 ] );
            }

            //
            // Bugcheck paramaters
            //

            for( int nCrtCommandLineArg = 3; nCrtCommandLineArg < argc; nCrtCommandLineArg++ )
            {
                BugcheckParams.BugCheckParameters[ nCrtCommandLineArg - 3 ] = 
                    UtilHexStringToUlongPtr( argv[ nCrtCommandLineArg ] );
            }

            //
            // Send the IOCTL to the driver
            //

            HANDLE Device;

            if ( TdOpenDevice ("buggy", &Device) ) {
                
                TdSendIoctl (
                    Device, 
                    IOCTL_TD_BUGCHECK,
                    &BugcheckParams,
                    sizeof( BugcheckParams ) );

                TdCloseDevice (Device);
            }
        }
        else {
            if (ProcessCommandLine (argv[1]) == FALSE) {
                DisplayHelp = TRUE;
            }
        }
    }
    catch (char * Message) {

        printf ("Error: s", GetLastError(), Message);
    }

    if ( DisplayHelp == TRUE ) {

        printf ("ctlbuggy /create DRIVER \n");
        printf ("ctlbuggy /delete DRIVER \n");
        printf ("ctlbuggy /start DRIVER \n");
        printf ("ctlbuggy /stop DRIVER \n");
        printf ("                                 \n");
        printf ("ctlbuggy /sectionmaptest             \n");
        printf ("ctlbuggy /sectionmaptestsysspace     \n");
        printf ("                                 \n");
        printf ("ctlbuggy IOCTL-NAME              \n");
        printf ("\n\n");

        for (Index = 0; BuggyFuns[Index].Ioctl != 0; Index++) {
            printf("ctlbuggy %s \n", BuggyFuns[Index].Command);
        }

        printf ("\n");
        exit (1);
    }

    exit( 0 );
}

BOOL
ProcessCommandLine (
    LPCTSTR Option
    )
/*++

Routine Description:

    This routine tries to figure out if the command line option
    is specifies one of the ioctls that can be processed.

Arguments:

    `Option' - command line option.

Return Value:

    TRUE if an option has been found and processed.
    FALSE otherwise.

Environment:

    Nothing special.

--*/

{
    DWORD Index;
    HANDLE Device;
    BOOL Result = FALSE;

    for (Index = 0; BuggyFuns[Index].Ioctl != 0; Index++) {
        if (_stricmp (BuggyFuns[Index].Command, Option) == 0) {
            if ( TdOpenDevice ("buggy", &Device) ) {
                TdSendIoctl (Device, BuggyFuns[Index].Ioctl, NULL, 0);
                TdCloseDevice (Device);
                Result = TRUE;
                break;
            }
        }
    }

    return Result;
}

///////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////// Driver load/unload
///////////////////////////////////////////////////////////////////////////////

bool
TdCreateService (

    LPCTSTR DriverName)
{
    SC_HANDLE ServiceManager = NULL;
    SC_HANDLE ServiceHandle = NULL;
    BOOL ReturnValue;
    HANDLE Driver;
    TCHAR ScratchBuffer [MAX_PATH];
    TCHAR DriverPath [MAX_PATH];
    TCHAR DevicePath [MAX_PATH];

    try {

        GetSystemDirectory (ScratchBuffer, sizeof ScratchBuffer);
        _stprintf (DriverPath, "%s\\drivers\\%s.sys", ScratchBuffer, DriverName);
        _stprintf (DevicePath, "\\\\.\\%s", DriverName);

        //
        // Open the service control manager
        //

        ServiceManager = OpenSCManager (

            NULL,
            NULL,
            SC_MANAGER_ALL_ACCESS);

        if (ServiceManager == NULL) {
            throw "OpenScManager()";
        }

        //
        // Create the service
        //

        printf("Driver path: %s \n", DriverPath);
        printf("Device path: %s \n", DevicePath);

        ServiceHandle = CreateService (

            ServiceManager,         // handle to SC manager
            DriverName,             // name of service
            DriverName,             // display name
            SERVICE_ALL_ACCESS,     // access mask
            SERVICE_KERNEL_DRIVER,  // service type
            SERVICE_DEMAND_START,   // start type
            SERVICE_ERROR_NORMAL,   // error control
            DriverPath,             // full path to driver
            NULL,                   // load ordering
            NULL,                   // tag id
            NULL,                   // dependency
            NULL,                   // account name
            NULL);                  // password

        if (ServiceHandle == NULL && GetLastError() != ERROR_SERVICE_EXISTS) {
            throw "CreateService()";
        }

        ReturnValue = TRUE;
    }
    catch (char * Msg) {

        printf("Error: %u: %s\n", GetLastError(), Msg);
        fflush (stdout);
        ReturnValue = FALSE;
    }

    //
    // Close handles and return.
    //

    if (ServiceHandle) {
        CloseServiceHandle (ServiceHandle);
    }

    if (ServiceManager) {
        CloseServiceHandle (ServiceManager);
    }

    return ReturnValue;


}

bool
TdStartService (

    LPCTSTR DriverName)
{
    SC_HANDLE ServiceManager = NULL;
    SC_HANDLE ServiceHandle = NULL;
    BOOL ReturnValue;
    HANDLE Driver;
    TCHAR ScratchBuffer [MAX_PATH];
    TCHAR DriverPath [MAX_PATH];
    TCHAR DevicePath [MAX_PATH];


    try {

        GetSystemDirectory (ScratchBuffer, sizeof ScratchBuffer);
        _stprintf (DriverPath, "%s\\drivers\\%s.sys", ScratchBuffer, DriverName);
        _stprintf (DevicePath, "\\\\.\\%s", DriverName);

        //
        // Open the service control manager
        //

        ServiceManager = OpenSCManager (

            NULL,
            NULL,
            SC_MANAGER_ALL_ACCESS);

        if (ServiceManager == NULL) {
            throw "OpenScManager()";
        }

        //
        // Open the service. The function assumes that
        // TdCreateService has been called before this one
        // and the service is already installed.
        //

        ServiceHandle = OpenService (

            ServiceManager,
            DriverName,
            SERVICE_ALL_ACCESS);

        if (ServiceHandle == NULL) {
            throw "OpenService()";
        }

        //
        // Start the service
        //

        if (! StartService (ServiceHandle, 0, NULL)) {
            if (GetLastError() != ERROR_SERVICE_ALREADY_RUNNING) {
                throw "StartService()";
            }
        }

        ReturnValue = TRUE;
    }
    catch (char * Msg) {

        printf("Error: %u: %s\n", GetLastError(), Msg);
        fflush (stdout);
        ReturnValue = FALSE;
    }

    //
    // Close handles and return.
    //

    if (ServiceHandle) {
        CloseServiceHandle (ServiceHandle);
    }

    if (ServiceManager) {
        CloseServiceHandle (ServiceManager);
    }

    return ReturnValue;
}

bool
TdStopService (

    LPCTSTR DriverName)
{
    SC_HANDLE ServiceManager = NULL;
    SC_HANDLE ServiceHandle = NULL;
    SERVICE_STATUS ServiceStatus;
    BOOL ReturnValue;

    try {

        //
        // Open the service control manager
        //

        ServiceManager = OpenSCManager (

            NULL,
            NULL,
            SC_MANAGER_ALL_ACCESS);

        if (ServiceManager == NULL) {
            throw "OpenSCManager()";
        }

        //
        // Open the service so we can stop it
        //

        ServiceHandle = OpenService (

            ServiceManager,
            DriverName,
            SERVICE_ALL_ACCESS);

        if (ServiceHandle == NULL) {
            throw "OpenService()";
        }

        //
        // Stop the service
        //

        if (! ControlService (ServiceHandle, SERVICE_CONTROL_STOP, &ServiceStatus)) {
            throw "ControlService()";
        }

        ReturnValue = TRUE;
    }
    catch (char * Msg) {

        printf("Error: %u: %s\n", GetLastError(), Msg);
        fflush (stdout);
        ReturnValue = FALSE;
    }

    //
    // Close handles ans return.
    //

    if (ServiceHandle) {
        CloseServiceHandle (ServiceHandle);
    }

    if (ServiceManager) {
        CloseServiceHandle (ServiceManager);
    }

    return ReturnValue;
}

bool
TdDeleteService (

    LPCTSTR DriverName)
{
    SC_HANDLE ServiceManager = NULL;
    SC_HANDLE ServiceHandle = NULL;
    SERVICE_STATUS ServiceStatus;
    BOOL ReturnValue;

    try {

        //
        // Open the service control manager
        //

        ServiceManager = OpenSCManager (

            NULL,
            NULL,
            SC_MANAGER_ALL_ACCESS);

        if (ServiceManager == NULL) {
            throw "OpenSCManager()";
        }

        //
        // Open the service so we can stop it
        //

        ServiceHandle = OpenService (

            ServiceManager,
            DriverName,
            SERVICE_ALL_ACCESS);

        if (ServiceHandle == NULL) {
            throw "OpenService()";
        }

        //
        // Delete the service
        //

        if (! DeleteService (ServiceHandle)) {
            if (GetLastError() != ERROR_SERVICE_MARKED_FOR_DELETE) {
                throw "DeleteService()";
            }
        }

        ReturnValue = TRUE;
    }
    catch (char * Msg) {

        printf("Error: %u: %s\n", GetLastError(), Msg);
        fflush (stdout);
        ReturnValue = FALSE;
    }

    //
    // Close handles ans return.
    //

    if (ServiceHandle) {
        CloseServiceHandle (ServiceHandle);
    }

    if (ServiceManager) {
        CloseServiceHandle (ServiceManager);
    }

    return ReturnValue;
}

bool
TdOpenDevice (

    LPCTSTR DriverName,
    PHANDLE DeviceHandle)
{
    SC_HANDLE ServiceManager = NULL;
    SC_HANDLE ServiceHandle = NULL;
    BOOL ReturnValue;
    HANDLE Device;
    TCHAR ScratchBuffer [MAX_PATH];
    TCHAR DriverPath [MAX_PATH];
    TCHAR DevicePath [MAX_PATH];

    //
    // Sanity checks
    //

    if (DeviceHandle == NULL) {
        return FALSE;
    }

    try {

        GetSystemDirectory (ScratchBuffer, sizeof ScratchBuffer);
        _stprintf (DriverPath, "%s\\drivers\\%s.sys", ScratchBuffer, DriverName);
        _stprintf (DevicePath, "\\\\.\\%s", DriverName);

        //
        // Open the service control manager
        //

        ServiceManager = OpenSCManager (

            NULL,
            NULL,
            SC_MANAGER_ALL_ACCESS);

        if (ServiceManager == NULL) {
            throw "OpenScManager()";
        }

        //
        // Service should already exist.
        //

        ServiceHandle = OpenService (

            ServiceManager,
            DriverName,
            SERVICE_ALL_ACCESS);

        if (ServiceHandle == NULL) {
            throw "OpenService()";
        }

        //
        // Open the device
        //

        Device = CreateFile (

            DevicePath,
            GENERIC_READ|GENERIC_WRITE,
            0,
            NULL,
            OPEN_EXISTING,
            FILE_ATTRIBUTE_NORMAL,
            NULL);

        if (Device == INVALID_HANDLE_VALUE) {
            throw "CreateFile()";
        }

        ReturnValue = TRUE;
    }
    catch (char * Msg) {

        printf("Error: %u: %s\n", GetLastError(), Msg);
        fflush (stdout);
        ReturnValue = FALSE;
    }

    //
    // Close handles and return.
    //

    if (ServiceHandle) {
        CloseServiceHandle (ServiceHandle);
    }

    if (ServiceManager) {
        CloseServiceHandle (ServiceManager);
    }

    if (Device != INVALID_HANDLE_VALUE) {
        *DeviceHandle = Device;
    }

    return ReturnValue;

}

bool
TdCloseDevice (

    HANDLE Device)
{
    if (Device == INVALID_HANDLE_VALUE) {
        return false;
    }

    return CloseHandle(Device);
}

//
// Function:
//
//     SendIoctl
//
// Description:
//
//     This function sends an ioctl code to the driver.
//

bool
TdSendIoctl (

    IN HANDLE Driver,
    IN DWORD Ioctl,
    IN PVOID pData OPTIONAL, 
    IN ULONG uDataSize OPTIONAL )
{
    DWORD BytesReturned;
    BOOL Result;

    if (Driver == INVALID_HANDLE_VALUE) {
        return false;
    }

    Result = DeviceIoControl (

        Driver,
        Ioctl,
        pData,
        uDataSize,
        NULL,
        0,
        &BytesReturned,
        NULL);

    return Result == TRUE;
}

//
//
//
#if _MSC_FULL_VER >= 13008827
#pragma warning(push)
#pragma warning(disable:4715)			// Not all control paths return (due to infinite loop)
#endif

DWORD
MapProcessAddressSpaceThread( LPVOID lpData )
{
    HANDLE hDevice;
    DWORD dwTimeToSleep;

    hDevice = (HANDLE)lpData;

    while( TRUE )
    {
        dwTimeToSleep = rand() % 5000;

        Sleep( dwTimeToSleep );

        TdSendIoctl (hDevice, IOCTL_TD_SECTION_MAP_TEST_PROCESS_SPACE, NULL, 0);
    }

    return 0;
}

#if _MSC_FULL_VER >= 13008827
#pragma warning(pop)
#endif


//
//
//

#define TD_MAPSECT_TEST_THREADS 4

void TdSectMapProcessAddressSpaceTest()
{
    HANDLE Device;
    time_t theTime;
    int nCrtThread;
    DWORD dwThreadId;
    TCHAR strMessage[ 128 ];

    time( &theTime );

    _stprintf(
        strMessage,
        "Process %u, rand seed = %u\n",
        GetCurrentProcessId(),
        (unsigned int)theTime );

    OutputDebugString( strMessage );

    srand( (unsigned int)theTime );

    if( TdOpenDevice ("buggy", &Device) )
    {
        for( nCrtThread = 0; nCrtThread < TD_MAPSECT_TEST_THREADS - 1; nCrtThread++ )
        {
            CreateThread(
                NULL,
                0,
                MapProcessAddressSpaceThread,
                (LPVOID)Device,
                0,
                &dwThreadId );
        }

        //
        // reuse the main thread
        //

        MapProcessAddressSpaceThread( (LPVOID)Device );

        TdCloseDevice (Device);
    }
}

//
//
//

#if _MSC_FULL_VER >= 13008827
#pragma warning(push)
#pragma warning(disable:4715)			// Not all control paths return (due to infinite loop)
#endif
DWORD
MapSystemAddressSpaceThread( LPVOID lpData )
{
    HANDLE hDevice;
    DWORD dwTimeToSleep;

    hDevice = (HANDLE)lpData;

    while( TRUE )
    {
        dwTimeToSleep = rand() % 5000;

        Sleep( dwTimeToSleep );

        TdSendIoctl (hDevice, IOCTL_TD_SECTION_MAP_TEST_SYSTEM_SPACE, NULL, 0);
    }

    return 0;
}
#if _MSC_FULL_VER >= 13008827
#pragma warning(pop)
#endif


//
//
//

void TdSectMapSystemAddressSpaceTest()
{
    HANDLE Device;
    time_t theTime;
    int nCrtThread;
    DWORD dwThreadId;
    TCHAR strMessage[ 128 ];

    time( &theTime );

    _stprintf(
        strMessage,
        "Process %u, rand seed = %u\n",
        GetCurrentProcessId(),
        (unsigned int)theTime );

    OutputDebugString( strMessage );

    srand( (unsigned int)theTime );

    if( TdOpenDevice ("buggy", &Device) )
    {
        for( nCrtThread = 0; nCrtThread < TD_MAPSECT_TEST_THREADS - 1; nCrtThread++ )
        {
            CreateThread(
                NULL,
                0,
                MapProcessAddressSpaceThread,
                (LPVOID)Device,
                0,
                &dwThreadId );
        }

        //
        // reuse the main thread - only this thread will map into system address space
        //

        MapSystemAddressSpaceThread( (LPVOID)Device );

        TdCloseDevice (Device);
    }
}

//
// Convert a hex string from the command line to an UNLONG_PTR
//

ULONG_PTR
UtilHexStringToUlongPtr( char *szHexNumber )
{
    ULONG_PTR uNewDigit;
    ULONG_PTR uResult = 0;
    char *pCrtChar = szHexNumber;

    while( ( *pCrtChar ) != (char)0 )
    {
        uNewDigit = 0;

        if( ( *pCrtChar ) >= '0' && ( *pCrtChar ) <= '9' )
        {
            uNewDigit = ( *pCrtChar ) - '0';
        }
        else
        {
            if( ( *pCrtChar ) >= 'A' && ( *pCrtChar ) <= 'F' )
            {
                uNewDigit = ( *pCrtChar ) - 'A' + 10;
            }
            else
            {
                if( ( *pCrtChar ) >= 'a' && ( *pCrtChar ) <= 'f' )
                {
                    uNewDigit = ( *pCrtChar ) - 'a' + 10;
                }
            }
        }

        uResult = uResult * 16 + uNewDigit;

        pCrtChar++;
    }

    return uResult;
}

//
// Set the current reserved size and address as asked by the user
//


VOID
TdReservedMapSetSize( 
	int argc, 
	char *argv[] )
{
	SIZE_T NewSize;
    HANDLE Device;
    time_t theTime;
    TCHAR strMessage[ 128 ];

	if( argc >= 3 )
	{
		//
		// User-specified buffer size
		//

		NewSize = atoi( argv[ 2 ] );
	}
	else
	{
		//
		// Seed the random numbers generator 
		//

		time( &theTime );

		_stprintf(
			strMessage,
			"Process %u, rand seed = %u\n",
			GetCurrentProcessId(),
			(unsigned int)theTime );

		OutputDebugString( strMessage );

		srand( (unsigned int)theTime );

		//
		// New size is random, up to 10 pages
		//

		NewSize = ( abs( rand() ) % 10 + 1 ) * 0x1000;
	}

	if( TdOpenDevice ("buggy", &Device) )
	{
		printf( "TdReservedMapSetSize: sending size %p\n",
			NewSize );

        TdSendIoctl (
            Device, 
            IOCTL_TD_RESERVEDMAP_SET_SIZE,
            &NewSize,
            sizeof( NewSize ) );

        TdCloseDevice (Device);
	}
}

//
// Ask for a "read" operation from our driver
//

VOID
TdReservedMapRead( VOID )
{
    HANDLE Device;
    time_t theTime;
	SIZE_T ReadBufferSize;
	SIZE_T ReadPages;
	SIZE_T CrtReadPage;
	PSIZE_T CrtPageAddress;
	PVOID UserBuffer;
	BOOL Success;
	SYSTEM_INFO SystemInfo;
    TCHAR strMessage[ 128 ];

	//
	// Get the page size
	//

	GetSystemInfo( 
		&SystemInfo );

	//
	// Seed the random numbers generator 
	//

	time( &theTime );

	_stprintf(
		strMessage,
		"Process %u, rand seed = %u\n",
		GetCurrentProcessId(),
		(unsigned int)theTime );

	//OutputDebugString( strMessage );
	puts( strMessage );

	srand( (unsigned int)theTime );

	//
	// Choose a size >= PAGE_SIZE and <= ~1 Mb 
	//
	
	ReadBufferSize = abs( rand() * rand() * rand() ) % ( 1024 * 1024 ) + SystemInfo.dwPageSize;

	UserBuffer = VirtualAlloc( 
		NULL,
		ReadBufferSize,
		MEM_RESERVE | MEM_COMMIT,
		PAGE_READWRITE );

	if( NULL != UserBuffer )
	{
		if( TdOpenDevice ("buggy", &Device) )
		{
			//
			// Prepare the parameters to the driver
			//

			USER_READ_BUFFER UserReadBuffer;

			UserReadBuffer.UserBuffer = UserBuffer;
			UserReadBuffer.UserBufferSize = ReadBufferSize;

			_stprintf(
				strMessage,
				"TdReservedMapRead: sending buffer %p, size %p\n",
				UserReadBuffer.UserBuffer,
				UserReadBuffer.UserBufferSize );

			//OutputDebugString( strMessage );
			puts( strMessage );

			//
			// Send the request to the driver
			//

			Success = TdSendIoctl (
				Device, 
				IOCTL_TD_RESERVEDMAP_READ_OP,
				&UserReadBuffer,
				sizeof( UserReadBuffer ) );

			if( TRUE == Success )
			{
				//
				// If the call succeeded then we check the validity of data returned by the driver
				//

				ReadPages = ReadBufferSize / SystemInfo.dwPageSize;
				CrtPageAddress = (PSIZE_T)UserBuffer;

				for( CrtReadPage = 1; CrtReadPage <= ReadPages; CrtReadPage++ )
				{
					if( *CrtPageAddress != CrtReadPage )
					{
						_stprintf(
							strMessage,
							"Incorrect data received from buggy.sys: page %p, expected %p, actual data %p\n",
							CrtPageAddress,
							CrtReadPage,
							*CrtPageAddress );

						OutputDebugString( strMessage );

						DebugBreak();
					}
					
					CrtPageAddress = (PSIZE_T) ( (PCHAR)CrtPageAddress + SystemInfo.dwPageSize );
					ReadPages -= 1;
				}
				
			}

			TdCloseDevice (Device);
		}

		VirtualFree( 
			UserBuffer,
			0,
			MEM_RELEASE );
	}

}

//
// End of file
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\bin2c\bin2c.c ===
#include <windows.h>
#include <fcntl.h>
#include <io.h>
#include <sys\types.h>
#include <sys\stat.h>
#include <stdlib.h>
#include <string.h>
#include <stdio.h>

int
dump(
    char     *buffer,
    unsigned  buflen,
    FILE     *Out,
    char     *VarName
    );

int
DumpAscii(
    LPSTR   FileNameIn,
    LPSTR   FileNameOut,
    LPSTR   VarName
    );




// argv:
//
//  1 - in filename
//  2 - required length
//  3 - offset of region in question
//  4 - length of region in question
//  5 - out filename
//  6 - name of variable

int
__cdecl
main(
    int   argc,
    char *argv[]
    )
{
    int      In,rc;
    FILE    *Out;
    void    *buffer;
    unsigned ReqLen,RegStart,RegLen,FileLen;


    if (argc == 5 &&
        (argv[1][0] == '-' || argv[1][0] == '/') &&
        tolower(argv[1][1]) == 'a') {
            return DumpAscii( argv[2], argv[3], argv[4] );
    }

    if(argc != 7) {
        printf("Usage: %s <src file> <src file len> <region offset>\n",argv[0]);
        printf("       <region length> <dst file> <var name>\n");
        return(2);
    }

    ReqLen = atoi(argv[2]);
    RegStart = atoi(argv[3]);
    RegLen = atoi(argv[4]);

    In = _open(argv[1],O_RDONLY | O_BINARY);
    if(In == -1) {
        printf("%s: Unable to open file %s\n",argv[0],argv[1]);
        return(2);
    }

    FileLen = _lseek(In,0,SEEK_END);

    if(RegStart > FileLen) {
        _close(In);
        printf("%s: Desired region is out of range\n",argv[0]);
        return(2);
    }

    if((unsigned)_lseek(In,RegStart,SEEK_SET) != RegStart) {
        _close(In);
        printf("%s: Unable to seek in file %s\n",argv[0],argv[1]);
        return(2);
    }

    if((buffer = malloc(RegLen)) == NULL) {
        _close(In);
        printf("%s: Out of memory\n",argv[0]);
        return(2);
    }

    memset(buffer, 0, RegLen);

    if((unsigned)_read(In,buffer,RegLen) > RegLen) {
        _close(In);
        printf("%s: Unable to read file %s\n",argv[0],argv[1]);
        return(2);
    }

    _close(In);

    Out = fopen(argv[5],"wb");
    if(Out == NULL) {
        printf("%s: Unable to open file %s for writing\n",argv[0],argv[5]);
        free(buffer);
        return(2);
    }

    rc = dump(buffer,RegLen,Out,argv[6]);
    if(rc) {
        printf("%s: Unable to write file %s\n",argv[0],argv[5]);
    }

    fclose(Out);

    free(buffer);

    return(rc);
}


int
dump(
    char     *buffer,
    unsigned  buflen,
    FILE     *Out,
    char     *VarName
    )
{
    unsigned       major,minor;
    unsigned       i;
    unsigned char *bufptr = buffer;
    int            bw;
    char          *DefName;


    DefName = malloc(strlen(VarName) + 1 + 5);
    if(DefName == NULL) {
        return(2);
    }
    strcpy(DefName,VarName);
    _strupr(DefName);
    strcat(DefName,"_SIZE");

    bw = fprintf(Out,"#define %s %u\n\n\n",DefName,buflen);

    bw = fprintf(Out,"unsigned char %s[] = {\n",VarName);
    if(bw <= 0) {
        return(2);
    }

    major = buflen/16;
    minor = buflen%16;

    for(i=0; i<major; i++) {

        bw = fprintf(Out,
                    "%u,%u,%u,%u,%u,%u,%u,%u,%u,%u,%u,%u,%u,%u,%u,%u",
                     bufptr[ 0],
                     bufptr[ 1],
                     bufptr[ 2],
                     bufptr[ 3],
                     bufptr[ 4],
                     bufptr[ 5],
                     bufptr[ 6],
                     bufptr[ 7],
                     bufptr[ 8],
                     bufptr[ 9],
                     bufptr[10],
                     bufptr[11],
                     bufptr[12],
                     bufptr[13],
                     bufptr[14],
                     bufptr[15]
                    );

        if(bw <= 0) {
            return(2);
        }

        if((i == major-1) && !minor) {
            bw = fprintf(Out,"\n");
        } else {
            bw = fprintf(Out,",\n");
        }

        if(bw <= 0) {
            return(2);
        }

        bufptr += 16;
    }

    if(minor) {
        for(i=0; i<minor-1; i++) {
            bw = fprintf(Out,"%u,",*bufptr++);
            if(bw <= 0) {
                return(2);
            }
        }
        bw = fprintf(Out,"%u\n",*bufptr);
    }

    bw = fprintf(Out,"};\n");
    if(bw <= 0) {
        return(2);
    }
    return(0);
}

int
DumpAscii(
    LPSTR   FileNameIn,
    LPSTR   FileNameOut,
    LPSTR   VarName
    )
{
    HANDLE  hFileIn;
    HANDLE  hFileOut;
    HANDLE  hMapIn;
    HANDLE  hMapOut;
    LPVOID  DataIn;
    LPVOID  DataOut;
    LPSTR   din;
    LPSTR   dout;
    DWORD   FileSize;
    DWORD   Bytes;
    BOOL    LineBegin = TRUE;


    //
    // open the input file
    //

    hFileIn = CreateFile(
        FileNameIn,
        GENERIC_READ,
        FILE_SHARE_READ,
        NULL,
        OPEN_EXISTING,
        0,
        NULL
        );
    if (hFileIn == INVALID_HANDLE_VALUE) {
        return 1;
    }

    FileSize = GetFileSize( hFileIn, NULL );

    hMapIn = CreateFileMapping(
        hFileIn,
        NULL,
        PAGE_READONLY,
        0,
        0,
        NULL
        );
    if (!hMapIn) {
        return 1;
    }

    DataIn = (LPSTR) MapViewOfFile(
        hMapIn,
        FILE_MAP_READ,
        0,
        0,
        0
        );
    if (!DataIn) {
        return 1;
    }

    //
    // open the output file
    //

    hFileOut = CreateFile(
        FileNameOut,
        GENERIC_READ | GENERIC_WRITE,
        0,
        NULL,
        CREATE_ALWAYS,
        0,
        NULL
        );
    if (hFileOut == INVALID_HANDLE_VALUE) {
        return 1;
    }

    hMapOut = CreateFileMapping(
        hFileOut,
        NULL,
        PAGE_READWRITE,
        0,
        FileSize * 2,
        NULL
        );
    if (!hMapOut) {
        return 1;
    }

    DataOut = (LPSTR) MapViewOfFile(
        hMapOut,
        FILE_MAP_WRITE,
        0,
        0,
        0
        );
    if (!DataOut) {
        return 1;
    }

    din = DataIn;
    dout = DataOut;

    sprintf( dout, "char %s[] =\r\n", VarName );
    Bytes = strlen(dout);
    dout += Bytes;

    while( FileSize ) {
        if (LineBegin) {
            if (*din == ';') {
                while (*din != '\n') {
                    FileSize -= 1;
                    din += 1;
                }
                FileSize -= 1;
                din += 1;
                continue;
            }
            *dout++ = '\"';
            Bytes += 1;
            LineBegin = FALSE;
        }

        FileSize -= 1;

        if (*din == '\r') {
            din += 1;
            *dout++ = '\\';
            *dout++ = 'r';
            Bytes += 2;
            continue;
        }

        if (*din == '\n') {
            din += 1;
            *dout++ = '\\';
            *dout++ = 'n';
            *dout++ = '\"';
            *dout++ = '\r';
            *dout++ = '\n';
            Bytes += 5;
            LineBegin = TRUE;
            continue;
        }

        *dout++ = *din++;
        Bytes += 1;
    }

    *dout++ = ';';
    *dout++ = '\r';
    *dout++ = '\n';
    Bytes += 3;

    UnmapViewOfFile( DataIn );
    CloseHandle( hMapIn );
    CloseHandle( hFileIn );

    UnmapViewOfFile( DataOut );
    CloseHandle( hMapOut );
    SetFilePointer( hFileOut, Bytes, NULL, FILE_BEGIN );
    SetEndOfFile( hFileOut );
    CloseHandle( hFileOut );

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\buggy\driver\active.h ===
#ifndef _ACTIVE_H_INCLUDED_
#define _ACTIVE_H_INCLUDED_

#define CONTMEM_ACTIVE    0
#define SECTMAP_ACTIVE    0
#define TRACEDB_ACTIVE    0
#define PHYSMEM_ACTIVE    0
#define MMTESTS_ACTIVE    1
#define MAPVIEW_ACTIVE    1
#define LOCKTEST_ACTIVE   1
#define RESRVMAP_ACTIVE   1

#define NEWSTUFF_ACTIVE   0


#endif // #ifndef _ACTIVE_H_INCLUDED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\avrf\avrf.cxx ===
//
// Application verifier manager (command line version)
// Copyright (c) Microsoft Corporation, 2001
//

//
// module: avrf.cxx
// author: silviuc
// created: 02/14/2001
//

#include <stdio.h>
#include <stdlib.h>
#include <stdarg.h>
#include <malloc.h>
#include <tchar.h>
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <common.ver>

LPTSTR HelpText =
    TEXT("avrf - Application verifier settings --") BUILD_MACHINE_TAG TEXT("\n")
    VER_LEGALCOPYRIGHT_STR TEXT("\n") 
    TEXT("                                                                       \n")
    TEXT("avrf [OPTION ...]                                                      \n")
    TEXT("                                                                       \n")
    TEXT("    /enable PROGRAM     Enable verifier with default settings.         \n")
    TEXT("    /disable PROGRAM    Disable verifier.                              \n")
    TEXT("                                                                       \n")
    TEXT("    /pageheap           Enable full page heap (default).               \n")
    TEXT("    /lightheap          Enable light page heap.                        \n")
    TEXT("    /locks              Enable critical section verifier (default).    \n")
    TEXT("    /nolocks            Disable critical section verifier.             \n")
    TEXT("    /handles            Enable handle checking and tracking (default). \n")
    TEXT("    /nohandles          Disable handle checking.                       \n")
    TEXT("    /stacks             Stack overflow in low memory conditions checks.\n")
    TEXT("    /nostacks           Disable stack overflow checks (default).       \n")
    TEXT("                                                                       \n")
    TEXT("    /debug              Launch under debugger `ntsd -g -G -x'.         \n")
    TEXT("    /kdebug             Launch under debugger `ntsd -g -G -d -x'.      \n")
    TEXT("                                                                       \n")
    TEXT("    /verifier DLL ...   Specify additional verifier providers.         \n")
    TEXT("                                                                       \n")
    TEXT("PROGRAM     Name of the binary with extension (.exe or something else).\n")
    TEXT("DLL         Name of the binary with extension (.dll or something else).\n")
    TEXT("                                                                       \n")
    TEXT("If no option specified the program will print all verifier enabled     \n")
    TEXT("applications and their specific options.                               \n")
    TEXT("                                                                       \n")
    TEXT("The /verifier option is useful whenever additional verification layers \n")
    TEXT("must run on top of the core verification layer. The dlls specified     \n")
    TEXT("must obey the format for a verifier provider dll.                      \n")
    TEXT("                                                                       \n")
    TEXT("Note. Enabling application verifier does not affect currently running  \n")
    TEXT("processes. If you need to use verifier for processes that are          \n")
    TEXT("already running and cannot be restarted (csrss.exe, winlogon.exe),     \n")
    TEXT("a reboot is needed after the verifier has been enabled for             \n")
    TEXT("that process.                                                          \n")
    TEXT("                                                                       \n");

VOID
Help (
    )
{
    _tprintf (HelpText);
    exit(1);
}

VOID
PrintFlags (
    DWORD Flags
    )
{
    if ((Flags & RTL_VRF_FLG_FULL_PAGE_HEAP)) {
        printf("pageheap ");
    }
    else {
        printf("lightheap ");
    }

    if ((Flags & RTL_VRF_FLG_LOCK_CHECKS)) {
        printf("locks ");
    }
    
    if ((Flags & RTL_VRF_FLG_HANDLE_CHECKS)) {
        printf("handles ");
    }
    
    if ((Flags & RTL_VRF_FLG_STACK_CHECKS)) {
        printf("stacks ");
    }
}

BOOL
EnableVerifier (
    LPCTSTR Name,
    LPTSTR DebugString,
    char * * Args);

BOOL
DisableVerifier (
    LPCTSTR Name);

BOOL
IsVerifierEnabled (
    LPCTSTR Name);

BOOL
IsVerifierFlagsValueDefined (
    LPCTSTR Name,
    PDWORD Value);

BOOL
ReadGlobalFlagValue (
    HKEY Key,
    LPTSTR Buffer,
    ULONG Length);

BOOL
WriteGlobalFlagValue (
    HKEY Key,
    LPTSTR Buffer,
    ULONG Length);

BOOL
ReadVerifierValue (
    HKEY Key,
    LPTSTR Name,
    PDWORD Value
    );

BOOL
WriteVerifierValue (
    HKEY Key,
    LPTSTR Name,
    DWORD Value
    );

BOOL
DeleteVerifierFlagValue (
    HKEY Key);

BOOL
WriteDebuggerValue (
    HKEY Key,
    LPTSTR Buffer,
    ULONG Length);

BOOL
DeleteDebuggerValue (
    HKEY Key);

HKEY
OpenImageKey (
    LPCTSTR Name,
    BOOL ShouldExist);

VOID
CloseImageKey (
    HKEY Key);

VOID
CreateImageName (
    LPCTSTR Source,
    LPTSTR Name,
    ULONG Length);

VOID
PrintVerifierEnabledApplications (
    );

VOID
Help (
    );

VOID
__cdecl
Error (
    LPCTSTR Format,
    ...);

BOOL 
IsWow64Active (
    );

//////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////

char * * 
SearchOption (
    char * Args[],
    char * Option
    )
{
    while (*Args) {
        if (_stricmp(*Args, Option) == 0) {
            return Args;
        }

        Args++;
    }

    return NULL;
}


void _cdecl
main (int argc, char *argv[])
{
    TCHAR ImageName [MAX_PATH];
    char * * Option;

    if (IsWow64Active()) {
        _tprintf (TEXT ("Warning: avrf.exe is running inside WOW64. \n"
                        "This scenario can be used to test x86 binaries (running inside WOW64) \n"
                        "but not native (IA64) binaries. \n\n"));
    }
    
    if (argc == 2 && strstr (argv[1], TEXT("?")) != NULL) {

        Help ();
    }
    else if ((Option = SearchOption(argv + 1, "/enable"))) {

        PCHAR DebugString = NULL;

        if (SearchOption (argv + 1, "/debug") != NULL) {
            DebugString = "ntsd -g -G -x";
        }

        if (SearchOption (argv + 1, "/kdebug") != NULL) {
            DebugString = "ntsd -g -G -d -x";
        }

        if (Option[1] && Option[1][0] != '/') {
            CreateImageName (Option[1], ImageName, MAX_PATH);
            EnableVerifier (ImageName, DebugString, argv);
        }
        else {
            Help();
        }
    }
    else if ((Option = SearchOption(argv + 1, "/disable"))) {
        
        if (Option[1]) {
            CreateImageName (Option[1], ImageName, MAX_PATH);
            DisableVerifier (ImageName);
        }
        else {
            Help();
        }
    }
    else if (argc == 2) {

        CreateImageName (argv[1], ImageName, MAX_PATH);
        if (IsVerifierEnabled (ImageName) == FALSE) {
            _tprintf (TEXT("%s: verifier is not enabled for this application \n"), argv[1]);
        }
        else {

            DWORD Value;

            if (IsVerifierFlagsValueDefined (ImageName, &Value)) {
                
                _tprintf (TEXT("%s: verifier enabled with flags ("), argv[1]);
                PrintFlags (Value);
                _tprintf (TEXT(")\n"));
            }
            else {

                _tprintf (TEXT("%s: verifier enabled with default flags  \n"), argv[1]);
            }
        }
    }
    else {

        PrintVerifierEnabledApplications ();
    }
}


VOID
__cdecl
Error (

    LPCTSTR Format,
    ...)
{
    va_list Params;

    va_start (Params, Format);
    _tprintf (TEXT("Error: "));
    _vtprintf (Format, Params);
    _tprintf ( TEXT("\n "));
    exit (1);
}


//////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////

BOOL
IsVerifierEnabled (

    LPCTSTR Name)
{
    HKEY Key;
    TCHAR Buffer [128];
    DWORD Flags;

    if ((Key = OpenImageKey (Name, TRUE)) == NULL) {

        return FALSE;
    }

    if (ReadGlobalFlagValue (Key, Buffer, sizeof Buffer) == FALSE) {

        return FALSE;
    }

    if (_stscanf (Buffer, TEXT("%x"), &Flags) == 0) {

        return FALSE;
    }

    CloseImageKey (Key);

    return (Flags & FLG_APPLICATION_VERIFIER) ? TRUE : FALSE;
}


BOOL
IsVerifierFlagsValueDefined (
    LPCTSTR Name,
    PDWORD Value)
{
    HKEY Key;
    DWORD VerifierFlags = 0;

    if ((Key = OpenImageKey (Name, TRUE)) == NULL) {

        return FALSE;
    }

    if (ReadVerifierValue (Key, TEXT("VerifierFlags"), &VerifierFlags) == FALSE) {

        return FALSE;
    }

    CloseImageKey (Key);

    *Value = VerifierFlags;
    return TRUE;
}


BOOL
EnableVerifier (
    LPCTSTR Name,
    LPTSTR DebugString,
    char * * Args
    )
{
    HKEY Key;
    TCHAR Buffer [128];
    DWORD Flags;
    DWORD VerifierFlags;
    char * * Option;
    LONG Result;

    if ((Key = OpenImageKey (Name, FALSE)) == NULL) {

        Error (TEXT("Cannot open image registry key for %s"), Name);
    }

    if (ReadGlobalFlagValue (Key, Buffer, sizeof Buffer) == FALSE) {

        Flags = 0;
    }
    else {

        _stscanf (Buffer, TEXT("%x"), &Flags);
    }

    Flags |= FLG_APPLICATION_VERIFIER;
    _stprintf (Buffer, TEXT("0x%08X"), Flags);

    if (WriteGlobalFlagValue (Key, Buffer, _tcslen(Buffer)) == FALSE) {

        return FALSE;
    }

    //
    // Write `Debugger' value if needed.
    //

    if (DebugString != NULL) {

        if (WriteDebuggerValue (Key, DebugString, _tcslen(DebugString)) == FALSE) {

            return FALSE;
        }
    }

    //
    // Fill out default verifier settings.
    //

    VerifierFlags = RTL_VRF_FLG_FULL_PAGE_HEAP 
                  | RTL_VRF_FLG_LOCK_CHECKS
                  | RTL_VRF_FLG_HANDLE_CHECKS;

    //
    // Check for explicit feature requests.
    //

    if ((Option = SearchOption (Args, "/pageheap")) != NULL) {
        VerifierFlags |= RTL_VRF_FLG_FULL_PAGE_HEAP;
    }

    if ((Option = SearchOption (Args, "/lightheap")) != NULL) {
        VerifierFlags &= ~RTL_VRF_FLG_FULL_PAGE_HEAP;
    }

    if ((Option = SearchOption (Args, "/locks")) != NULL) {
        VerifierFlags |= RTL_VRF_FLG_LOCK_CHECKS;
    }
    
    if ((Option = SearchOption (Args, "/nolocks")) != NULL) {
        VerifierFlags &= ~RTL_VRF_FLG_LOCK_CHECKS;
    }
    
    if ((Option = SearchOption (Args, "/handles")) != NULL) {
        VerifierFlags |= RTL_VRF_FLG_HANDLE_CHECKS;
    }
    
    if ((Option = SearchOption (Args, "/nohandles")) != NULL) {
        VerifierFlags &= ~RTL_VRF_FLG_HANDLE_CHECKS;
    }
    
    if ((Option = SearchOption (Args, "/stacks")) != NULL) {
        VerifierFlags |= RTL_VRF_FLG_STACK_CHECKS;
    }
    
    if ((Option = SearchOption (Args, "/nostacks")) != NULL) {
        VerifierFlags &= ~RTL_VRF_FLG_STACK_CHECKS;
    }
    
    if ((Option = SearchOption (Args, "/_debug")) != NULL) {
        
        DWORD DebugFlags = 0;

        if (Option[1] && Option[1][0] != '/') {
            
            printf("Setting _debug to %s \n", Option[1]);

            if (_stscanf (Option[1], TEXT("%x"), &DebugFlags) == 0) {
                Error (TEXT("Failed to set internal debug flags."));
            }

            if (WriteVerifierValue (Key, TEXT("VerifierDebug"), DebugFlags) == FALSE) {
                Error (TEXT("Failed to write verifier internal debug registry value."));
            }
        }
    }
    
    //
    // Check /dlls option
    //

    Option = SearchOption (Args, "/verifier");

    if (Option != NULL) {

        TCHAR Dlls[512];
        ULONG Index;

        if (Option[1]) {

            for (Index = 1, Dlls[0] = '\0';
                Option[Index] && Option[Index][0] != '/';
                Index++) {

                _tcscat (Dlls, Option[Index]);
                _tcscat (Dlls, " ");

                //
                // We do not allow more than 200 characters because the verifier
                // support in loader (\nt\base\ntdll\verifier.c) does not handle
                // more characters anyway.
                //

                if (_tcslen (Dlls) > 200) {
                    break;
                }
            }

            //
            // SilviuC: the call to _tcslen below is not correct if we
            // ever will want to make this program Unicode.
            //

            Result = RegSetValueEx (
                Key, TEXT ("VerifierDlls"), 0, REG_SZ,
                (LPBYTE)(Dlls), _tcslen(Dlls) + 1);

            if (Result) {
                Error (TEXT("Failed to write VerifierDlls value: error %u"), Result);
            }
        }
    }

    //
    // Finally write the verifier flags value.
    //

    if (WriteVerifierValue (Key, TEXT("VerifierFlags"), VerifierFlags) == FALSE) {

        Error (TEXT("Failed to write VerifierFlags value."));
        return FALSE;
    }

    CloseImageKey (Key);
    return TRUE;
}

BOOL
DisableVerifier (

    LPCTSTR Name)
{
    HKEY Key;
    TCHAR Buffer [128];
    DWORD Flags;

    if ((Key = OpenImageKey (Name, TRUE)) == NULL) {

        //
        // There is no key therefore nothing to disable.
        //

        return TRUE;
    }

    if (ReadGlobalFlagValue (Key, Buffer, sizeof Buffer) == FALSE) {

        Flags = 0;
    }
    else {

        if (_stscanf (Buffer, TEXT("%x"), &Flags) == 0) {

            Flags = 0;;
        }
    }

    Flags &= ~FLG_APPLICATION_VERIFIER;
    _stprintf (Buffer, TEXT("0x%08X"), Flags);

    //
    // If by wiping the verifier bit from `GlobalFlags' we get a zero
    // value we will wipe out the value altogether. This is important
    // when we run the app under debugger. In this case it makes a 
    // difference if the value is not there or is all zeroes.
    //

    if (Flags != 0) {
        
        if (WriteGlobalFlagValue (Key, Buffer, _tcslen(Buffer)) == FALSE) {

            return FALSE;
        }
    }
    else {

        RegDeleteValue (Key, TEXT ("GlobalFlag"));
    }

    RegDeleteValue (Key, TEXT ("VerifierFlags"));
    RegDeleteValue (Key, TEXT ("VerifierDebug"));
    RegDeleteValue (Key, TEXT ("VerifierDlls"));
    RegDeleteValue (Key, TEXT ("Debugger"));

    CloseImageKey (Key);
    return TRUE;
}


BOOL
ReadGlobalFlagValue (

    HKEY Key,
    LPTSTR Buffer,
    ULONG Length)
{
    LONG Result;
    DWORD Type;
    DWORD ReadLength = Length;

    Result = RegQueryValueEx (

        Key,
        TEXT ("GlobalFlag"),
        0,
        &Type,
        (LPBYTE)Buffer,
        &ReadLength);

    if (Result != ERROR_SUCCESS || Type != REG_SZ) {

        return FALSE;
    }
    else {

        return TRUE;
    }
}

BOOL
WriteGlobalFlagValue (

    HKEY Key,
    LPTSTR Buffer,
    ULONG Length)
{
    LONG Result;

    Result = RegSetValueEx (

        Key,
        TEXT ("GlobalFlag"),
        0,
        REG_SZ,
        (LPBYTE)Buffer,
        Length);

    if (Result != ERROR_SUCCESS) {

        return FALSE;
    }
    else {

        return TRUE;
    }
}

BOOL
ReadVerifierValue (
    HKEY Key,
    LPTSTR Name,
    PDWORD Value
    )
{
    LONG Result;
    DWORD Type;
    DWORD ReadLength = sizeof *Value;

    Result = RegQueryValueEx (Key,
                              Name,
                              0,
                              &Type,
                              (LPBYTE)Value,
                              &ReadLength);

    if (Result != ERROR_SUCCESS || Type != REG_DWORD) {

        return FALSE;
    }
    else {

        return TRUE;
    }
}

BOOL
WriteVerifierValue (
    HKEY Key,
    LPTSTR Name,
    DWORD Value
    )
{
    LONG Result;

    Result = RegSetValueEx (Key,
                            Name,
                            0,
                            REG_DWORD,
                            (LPBYTE)(&Value),
                            sizeof Value);

    if (Result != ERROR_SUCCESS) {

        return FALSE;
    }
    else {

        return TRUE;
    }
}

BOOL
WriteDebuggerValue (

    HKEY Key,
    LPTSTR Buffer,
    ULONG Length)
{
    LONG Result;

    Result = RegSetValueEx (

        Key,
        TEXT ("Debugger"),
        0,
        REG_SZ,
        (LPBYTE)Buffer,
        Length);

    if (Result != ERROR_SUCCESS) {

        return FALSE;
    }
    else {

        return TRUE;
    }
}


BOOL
IsShutdownFlagsValueDefined (
    LPCTSTR KeyName
    )
{
    HKEY Key;
    LONG Result;
    DWORD Value;
    DWORD Type;
    DWORD ReadLength = sizeof (DWORD);

    if ((Key = OpenImageKey (KeyName, TRUE)) == NULL) {
        return FALSE;
    }
    
    Result = RegQueryValueEx (
        Key,
        TEXT ("ShutdownFlags"),
        0,
        &Type,
        (LPBYTE)(&Value),
        &ReadLength);

    CloseImageKey (Key);

    if (Result == ERROR_SUCCESS && (Value & 0x03) == 0x03) {
        return TRUE;
    }
    else {
        return FALSE;
    }
}

HKEY
OpenImageKey (

    LPCTSTR Name,
    BOOL ShouldExist)
{
    HKEY Key;
    LONG Result;
    TCHAR Buffer [MAX_PATH];

    _stprintf (
        Buffer,
        TEXT ("SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Image File Execution Options\\%s"),
        Name);

    if (ShouldExist) {

        Result = RegOpenKeyEx (

            HKEY_LOCAL_MACHINE,
            Buffer,
            0,
            KEY_ALL_ACCESS,
            &Key);
    }
    else {

        Result = RegCreateKeyEx (

            HKEY_LOCAL_MACHINE,
            Buffer,
            0,
            0,
            0,
            KEY_ALL_ACCESS,
            NULL,
            &Key,
            NULL);
    }

    if (Result != ERROR_SUCCESS) {

        return NULL;
    }
    else {

        return Key;
    }

}


VOID
CloseImageKey (

    HKEY Key)
{
    RegCloseKey (Key);
}


VOID
CreateImageName (

    LPCTSTR Source,
    LPTSTR Name,
    ULONG Length)
{

    UNREFERENCED_PARAMETER (Length);

    _tcscpy (Name, Source);
    _tcslwr (Name);

    if (_tcsstr (Name, TEXT(".")) == 0) {

        _tcscat (Name, TEXT(".exe"));
    }
}


VOID
PrintVerifierEnabledApplications (

    )
{
    LPCTSTR ImageFileExecutionOptionsKeyName =
        TEXT ("SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Image File Execution Options");

    HKEY OptionsKey;
    LONG Result;
    TCHAR KeyName [MAX_PATH];
    ULONG KeySize;
    BOOL FoundOne = FALSE;
    ULONG Index;
    FILETIME FileTime;

    Result = RegOpenKeyEx (

        HKEY_LOCAL_MACHINE,
        ImageFileExecutionOptionsKeyName,
        0,
        KEY_ALL_ACCESS,
        &OptionsKey);

    if (Result != ERROR_SUCCESS) {

        Error (TEXT("Cannot open registry key %s: error %u"),
               ImageFileExecutionOptionsKeyName,
               Result);
    }

    for (Index = 0; TRUE; Index++) {

        KeySize = MAX_PATH;

        Result = RegEnumKeyEx (

            OptionsKey,
            Index,
            KeyName,
            &KeySize,
            NULL,
            NULL,
            NULL,
            &FileTime);

        if (Result == ERROR_NO_MORE_ITEMS) {

            break;
        }

        if (Result != ERROR_SUCCESS) {

            Error (TEXT("Cannot enumerate registry key %s: error %u"),
               ImageFileExecutionOptionsKeyName,
               Result);
        }

        if (IsVerifierEnabled (KeyName)) {

            DWORD Value;

            FoundOne = TRUE;
            
            if (IsVerifierFlagsValueDefined (KeyName, &Value)) {
                _tprintf (TEXT("%s: verifier enabled with flags ("), KeyName);
                PrintFlags (Value);
                _tprintf (TEXT(")\n"));
            }
            else {
                _tprintf (TEXT("%s: verifier enabled with default flags \n"), KeyName);
            }
        }
    }

    if (FoundOne == FALSE) {

        _tprintf (TEXT("No application has verifier enabled.\n"));
    }
}


BOOL 
IsWow64Active (
    )                 
{

    ULONG_PTR       ul;
    NTSTATUS        st;

    //
    // If this call succeeds then we are on Windows 2000 or later.
    //

    st = NtQueryInformationProcess(NtCurrentProcess(), 
                                   ProcessWow64Information,
                                   &ul, 
                                   sizeof(ul), 
                                   NULL);

    if (NT_SUCCESS(st) && (0 != ul)) {
        // 32-bit code running on Win64
        return TRUE;
    }
    else {
        return FALSE;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\bootstat\bootstat.c ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    cdp.c

Abstract:

    A user mode app that allows simple commands to be sent to a
    selected scsi device.

Environment:

    User mode only

Revision History:

    03-26-96 : Created

--*/

//
// this module may be compiled at warning level 4 with the following
// warnings disabled:
//

#pragma warning(disable:4200) // array[0]
#pragma warning(disable:4201) // nameless struct/unions
#pragma warning(disable:4214) // bit fields other than int

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <string.h>
#include <stdio.h>
#include <stdlib.h>

#include <assert.h>

#include <windows.h>

// #include "bootstatus.h"

#ifdef DBG
#define dbg(x) x
#define HELP_ME() printf("Reached line %4d\n", __LINE__);
#else
#define dbg(x)    /* x */
#define HELP_ME() /* printf("Reached line %4d\n", __LINE__); */
#endif

#define ARGUMENT_USED(x)    (x == NULL)


//
// The default size of the safemode.dat file - it must be large enough that the 
// data stream isn't a resident attribute of the metadata or the loader's 
// NTFS implementation can't write to it.
//

#define DEFAULT_SAFEMODE_FILE_SIZE  0x800

typedef struct {
    PCHAR Name;
    PCHAR Description;
    BOOLEAN LockData;
    ULONG (*Function)(HANDLE BootStatusData, int argc, char *argv[]);
} COMMAND;

DWORD TestCommand(HANDLE BootStatusData, int argc, char *argv[]);
DWORD Disable(HANDLE BootStatusData, int argc, char *argv[]);
DWORD Enable(HANDLE BootStatusData, int argc, char *argv[]);
DWORD Create(HANDLE BootStatusData, int argc, char *argv[]);
DWORD SetFlags(HANDLE BootStatusData, int argc, char *argv[]);
DWORD ClearFlags(HANDLE BootStatusData, int argc, char *argv[]);
DWORD ListSettings(HANDLE BootStatusData, int argc, char *argv[]);

DWORD ListCommand(int argc, char *argv[]);

//
// List of commands
// all command names are case sensitive
// arguments are passed into command routines
// list must be terminated with NULL command
// command will not be listed in help if description == NULL
//

COMMAND CommandArray[] = {
    {"create",  "Creates the boot status data file",     FALSE, Create},
    {"disable", "Disables Auto Advanced Boot",           TRUE,  Disable},
    {"enable",  "Enables Auto Advanced Boot",            TRUE,  Enable},
    {"set",     "Sets the boot status flags",            TRUE,  SetFlags},
    {"settings","Lists the Auto Advanced Boot settings", TRUE,  ListSettings},
    {NULL, NULL, FALSE, NULL}
    };

int __cdecl main(int argc, char *argv[])
{
    int i = 0;
    HANDLE bootStatusData;

    if(argc < 2) {
        printf("Usage: %s <command> [parameters]\n", argv[0]);
        printf("possible commands: \n");
        ListCommand(argc, argv);
        printf("\n");
        return -1;
    }

    //
    // Iterate through the command array and find the correct function to
    // call.
    //

    while(CommandArray[i].Name != NULL) {

        if(strcmp(argv[1], CommandArray[i].Name) == 0) {

            NTSTATUS status;

            if(CommandArray[i].LockData) {
                status = RtlLockBootStatusData(&bootStatusData);
    
                if(!NT_SUCCESS(status)) {
                    printf("Error %#08lx opening boot status bootStatusData\n", 
                           status);
                    return -1;
                }
            } else {
                bootStatusData = NULL;
            }

            (CommandArray[i].Function)(bootStatusData, (argc - 1), &(argv[1]));

            break;
        }

        i++;
    }

    if(CommandArray[i].Name == NULL) {
        printf("Unknown command %s\n", argv[1]);
    }

    RtlUnlockBootStatusData(bootStatusData);
    return 0;
}



DWORD TestCommand(HANDLE BootStatusData, int argc, char *argv[])
/*++

Routine Description:

    Tests the command "parsing"

Arguments:
    device - a file handle to send the ioctl to

    argc - the number of additional arguments.  should be zero

    argv - the additional arguments

Return Value:

    STATUS_SUCCESS if successful
    The value of GetLastError() from the point of failure

--*/

{
    int i;

    UNREFERENCED_PARAMETER(BootStatusData);

    printf("Test - %d additional arguments\n", argc);

    for(i = 0; i < argc; i++) {
        printf("arg %d: %s\n", i, argv[i]);
    }

    return STATUS_SUCCESS;
}

DWORD ListCommand(int argc, char *argv[])
/*++

Routine Description:

    Prints out the command list

Arguments:
    device - unused

    argc - unused

    argv - unused

Return Value:

    STATUS_SUCCESS

--*/

{
    int i = 0;

    UNREFERENCED_PARAMETER(argc);
    UNREFERENCED_PARAMETER(argv);

    while(CommandArray[i].Name != NULL) {

        if(CommandArray[i].Description != NULL) {

            printf("\t%s - %s\n",
                   CommandArray[i].Name,
                   CommandArray[i].Description);
        }

        i++;
    }

    return STATUS_SUCCESS;
}

DWORD 
Create(
    HANDLE Unused, 
    int argc, 
    char *argv[]
    )
{
    BOOLEAN enabled;

    NTSTATUS status;

    status = RtlCreateBootStatusDataFile();

    if(!NT_SUCCESS(status)) {
        printf("Error %#08lx creating boot status data\n", status);
    }

    return status;
}

DWORD 
Enable(
    HANDLE BootStatusData, 
    int argc, 
    char *argv[]
    )
{
    BOOLEAN enabled;

    NTSTATUS status;

    status = RtlGetSetBootStatusData(BootStatusData,
                                     TRUE,
                                     RtlBsdItemAabEnabled,
                                     &enabled,
                                     sizeof(BOOLEAN),
                                     NULL);

    if(!NT_SUCCESS(status)) {
        printf("Error %#08lx reading boot status data\n", status);
        return status;
    }

    printf("Enabling Automatic Advanced Boot\n");
    printf("Previous setting was %s\n", enabled ? "enabled" : "disabled");

    enabled = TRUE;

    status = RtlGetSetBootStatusData(BootStatusData,
                                     FALSE,
                                     RtlBsdItemAabEnabled,
                                     &enabled,
                                     sizeof(BOOLEAN),
                                     NULL);

    if(!NT_SUCCESS(status)) {
        printf("Error %#08lx writing boot status data\n", status);
    }

    return status;
}

DWORD 
Disable(
    HANDLE BootStatusData, 
    int argc, 
    char *argv[]
    )
{
    BOOLEAN enabled;

    NTSTATUS status;

    status = RtlGetSetBootStatusData(BootStatusData,
                                     TRUE,
                                     RtlBsdItemAabEnabled,
                                     &enabled,
                                     sizeof(BOOLEAN),
                                     NULL);

    if(!NT_SUCCESS(status)) {
        printf("Error %#08lx reading boot status data\n", status);
        return status;
    }

    printf("Disabling Automatic Advanced Boot\n");
    printf("Previous setting was %s\n", enabled ? "enabled" : "disabled");

    enabled = FALSE;

    status = RtlGetSetBootStatusData(BootStatusData,
                                     FALSE,
                                     RtlBsdItemAabEnabled,
                                     &enabled,
                                     sizeof(BOOLEAN),
                                     NULL);

    if(!NT_SUCCESS(status)) {
        printf("Error %#08lx writing boot status data\n", status);
    }

    return status;
}

DWORD 
ListSettings(
    HANDLE BootStatusData, 
    int argc, 
    char *argv[]
    )
{
    BOOLEAN flag;

    NTSTATUS status;

    status = RtlGetSetBootStatusData(BootStatusData,
                                     TRUE,
                                     RtlBsdItemAabEnabled,
                                     &flag,
                                     sizeof(BOOLEAN),
                                     NULL);

    if(!NT_SUCCESS(status)) {
        printf("Error %#08lx reading boot status data\n", status);
        return status;
    }

    printf("Automatic Advanced Boot is %s\n", flag ? "enabled" : "disabled");

    status = RtlGetSetBootStatusData(BootStatusData,
                                     TRUE,
                                     RtlBsdItemAabTimeout,
                                     &flag,
                                     sizeof(BOOLEAN),
                                     NULL);

    if(!NT_SUCCESS(status)) {
        printf("Error %#08lx reading boot status data\n", status);
        return status;
    }

    printf("Automatic Advanced Boot timeout is %d seconds\n", (UCHAR) flag);

    status = RtlGetSetBootStatusData(BootStatusData,
                                     TRUE,
                                     RtlBsdItemBootGood,
                                     &flag,
                                     sizeof(BOOLEAN),
                                     NULL);

    if(!NT_SUCCESS(status)) {
        printf("Error %#08lx reading boot status data\n", status);
        return status;
    }

    printf("LastBootSucceeded = %#x\n", flag);

    status = RtlGetSetBootStatusData(BootStatusData,
                                     TRUE,
                                     RtlBsdItemBootShutdown,
                                     &flag,
                                     sizeof(BOOLEAN),
                                     NULL);

    if(!NT_SUCCESS(status)) {
        printf("Error %#08lx reading boot status data\n", status);
        return status;
    }

    printf("LastBootShutdown = %#x\n", flag);

    return STATUS_SUCCESS;
}

DWORD SetFlags(HANDLE BootStatusData, int argc, char *argv[])
{
    int count;

    if(argc <= 1) {
        printf("usage: autosafeboot set <Boot|Shutdown>=<value> ...");
        return 0;
    }

    for(count = 1; count < argc; count++) {
        PUCHAR nameString;
        PUCHAR valueString;

        ULONG index;
        UCHAR value;

        index = -1;

        //
        // match the string.
        //

        nameString = argv[count];
        valueString = strrchr(nameString, '=');

        if(valueString == NULL) {
            printf("** element \"%s\" not understood\n", nameString);
            continue;
        }

        valueString[0] = '\0';
        valueString += 1;

        value = (UCHAR) atoi(valueString);

        if(_stricmp(nameString, "boot") == 0) {
            printf("Setting LastBootSucceeded to %#x\n", value);
            index = RtlBsdItemBootGood;

        } else if(_stricmp(nameString, "shutdown") == 0) {

            printf("Setting LastBootShutdown to %#x\n", value);
            index = RtlBsdItemBootShutdown;
        }

        if(index != -1) {

            NTSTATUS status;

            status = RtlGetSetBootStatusData(BootStatusData,
                                             FALSE,
                                             index,
                                             &value,
                                             sizeof(UCHAR),
                                             NULL);

            if(!NT_SUCCESS(status)) {
                printf("Error %#08lx reading boot status data\n", status);
                continue;
            }
        } else {
            printf("** element \"%s=%s\" not understood\n", nameString, valueString);
        }
    }

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\buggy\driver\bugcheck.h ===
#ifndef _BUGCHECK_H_INCLUDED_
#define _BUGCHECK_H_INCLUDED_

/////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////// Bugcheck functions
/////////////////////////////////////////////////////////////////////

VOID
BgChkForceCustomBugcheck (
    PVOID
    );

VOID 
BgChkProcessHasLockedPages (
    PVOID
    );

VOID 
BgChkNoMoreSystemPtes (
    PVOID
    );

VOID 
BgChkBadPoolHeader (
    PVOID
    );

VOID 
BgChkDriverCorruptedSystemPtes (
    PVOID
    );

VOID 
BgChkDriverCorruptedExPool (
    PVOID
    );

VOID 
BgChkDriverCorruptedMmPool (
    PVOID
    );

VOID 
BgChkIrqlNotLessOrEqual (
    PVOID
    );

VOID 
BgChkPageFaultBeyondEndOfAllocation (
    PVOID
    );

VOID 
BgChkDriverVerifierDetectedViolation (
    PVOID
    );

VOID BgChkCorruptSystemPtes(
    PVOID
    );

VOID
BgChkHangCurrentProcessor (
    PVOID
    );



#endif // #ifndef _BUGCHECK_H_INCLUDED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\buggy\driver\bugcheck.c ===
#include <ntddk.h>

#include "tdriver.h"
#include "bugcheck.h"


/////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////// Bugcheck functions
/////////////////////////////////////////////////////////////////////

VOID
BgChkForceCustomBugcheck (
    PVOID NotUsed
    )
/*++

Routine Description:

    This function breaks into debugger and waits for the user to set the
    value for bugcheck data. Then it will bugcheck using the specified code
    and data. It is useful to test the mini triage feature.

Arguments:

    None.

Return Value:

    None.

Environment:

    Kernel mode.

--*/
{
    ULONG BugcheckData [5];

    DbgPrint ("Buggy: `ed %p' to enter the bugcheck code and data \n", BugcheckData );
    DbgBreakPoint();

    KeBugCheckEx (
        BugcheckData [ 0 ],
        BugcheckData [ 1 ],
        BugcheckData [ 2 ],
        BugcheckData [ 3 ],
        BugcheckData [ 4 ] );
}


VOID BgChkProcessHasLockedPages (
    PVOID NotUsed
    )
{
    PMDL Mdl;
    PVOID Address;

    DbgPrint ("Buggy: ProcessHasLockedPages \n");

    Mdl = IoAllocateMdl(

        (PVOID)0x10000,    // adress
        0x1000,            // size
        FALSE,             // not secondary buffer
        FALSE,             // do not charge quota
        NULL);             // no irp

    if (Mdl != NULL) {
        DbgPrint ("Buggy: mdl created \n");
    }
#if 0
    try {

        MmProbeAndLockPages (
            Mdl,
            KernelMode,
            IoReadAccess);

        DbgPrint ("Buggy: locked pages \n");
    }
    except (EXCEPTION_EXECUTE_HANDLER) {

        DbgPrint ("Buggy: exception raised while locking \n");
    }
#endif
}


VOID BgChkNoMoreSystemPtes (
    PVOID NotUsed
    )
{
    DWORDLONG Index;
    PHYSICAL_ADDRESS Address;
    ULONG Count = 0;
    char Buffer [1024];

    DbgPrint ("Buggy: NoMoresystemPtes\n");

    for (Index = 0; Index < (DWORDLONG)0x80000000 * 4; Index += 0x10000) {
        Address.QuadPart = (DWORDLONG)Index;
        if (MmMapIoSpace (Address, 0x10000, FALSE)) {
            Count += 0x10000;
        }
    }

    DbgPrint ("Finished eating system PTEs %08X ... \n", Count);
}


VOID BgChkBadPoolHeader (
    PVOID NotUsed
    )
{
    PULONG Block;

    DbgPrint ("Buggy: BadPoolHeader\n");

    Block = (PULONG) ExAllocatePoolWithTag (
        NonPagedPool,
        128,
        TD_POOL_TAG);

    //
    // Trash 4 bytes in the block header.
    //

    *(Block - 1) = 0xBADBAD01;

    //
    // This free operation should bugcheck.
    //

    ExFreePool (Block);
}


VOID BgChkDriverCorruptedSystemPtes (
    PVOID NotUsed
    )
{
    PVOID Block;

    DbgPrint ("Buggy: DriverCorruptedSystemPtes\n");

    Block = (PULONG) ExAllocatePoolWithTag (
        NonPagedPool,
        0x2000,
        TD_POOL_TAG);

    MmUnmapIoSpace (Block, 0x2000);

}


VOID BgChkDriverCorruptedExPool (
    PVOID NotUsed
    )
{
    PULONG Block;

    DbgPrint ("Buggy: DriverCorruptedExPool\n");

    Block = (PULONG) ExAllocatePoolWithTag (
        NonPagedPool,
        128,
        TD_POOL_TAG);

    //
    // Trash 8 bytes in the block header.
    //

    *(Block - 2) = 0xBADBAD01;
    *(Block - 1) = 0xBADBAD01;

    //
    // This free operation should bugcheck.
    //

    ExFreePool (Block);
}


VOID BgChkDriverCorruptedMmPool (
    PVOID NotUsed
    )
{
    DbgPrint ("Buggy: DriverCorruptedMmPool\n");

    ExFreePool (NULL);
}


VOID BgChkIrqlNotLessOrEqual (
    PVOID NotUsed
    )
{
    KIRQL irql;
    VOID *pPagedData;

    DbgPrint ("Buggy: IrqlNotLessOrEqual\n");

    pPagedData = ExAllocatePoolWithTag(
        PagedPool,
        16,
        TD_POOL_TAG);

    if( pPagedData == NULL )
    {
        DbgPrint( "Cannot allocate 16 bytes of paged pool\n" );
        return;
    }

    KeRaiseIrql( DISPATCH_LEVEL, &irql );

    *((ULONG*)pPagedData) = 16;

    KeLowerIrql( irql );
}


VOID BgChkPageFaultBeyondEndOfAllocation (
    PVOID NotUsed
    )
{
    PVOID *pHalfPage;
    PVOID *pLastUlongToWrite;
    ULONG *pCrtULONG;

    DbgPrint ("Buggy: PageFaultBeyondEndOfAllocation\n");

    //
    // allocate half a page
    //

    pHalfPage = ExAllocatePoolWithTag(
        NonPagedPool,
        PAGE_SIZE >> 1,
        TD_POOL_TAG);

    if( pHalfPage == NULL )
    {
        DbgPrint ("Buggy: cannot allocate half page of NP pool\n");
    }
    else
    {
        //
        // touch a page more
        //

        pCrtULONG = (ULONG*)pHalfPage;

        while( (ULONG_PTR)pCrtULONG < (ULONG_PTR)pHalfPage + (PAGE_SIZE >> 1) + 2 * PAGE_SIZE )
        {
            *pCrtULONG = PtrToUlong( pCrtULONG );
            pCrtULONG ++;
        }

        ExFreePool( pHalfPage );
    }
}


VOID BgChkDriverVerifierDetectedViolation (
    PVOID NotUsed
    )
{
    PVOID *pHalfPage;
    PVOID *pLastUlongToWrite;
    ULONG *pCrtULONG;

    DbgPrint ("Buggy: DriverVerifierDetectedViolation\n");

    //
    // allocate half a page
    //

    pHalfPage = ExAllocatePoolWithTag(
        NonPagedPool,
        PAGE_SIZE >> 1,
        TD_POOL_TAG);

    if( pHalfPage == NULL )
    {
        DbgPrint ("Buggy: cannot allocate half page of NP pool\n");
    }
    else
    {
        //
        // touch 1 ULONG more
        //

        pCrtULONG = (ULONG*)pHalfPage;

        while( (ULONG_PTR)pCrtULONG < (ULONG_PTR)pHalfPage + (PAGE_SIZE >> 1) + sizeof( ULONG) )
        {
            *pCrtULONG = PtrToUlong( pCrtULONG );
            pCrtULONG ++;
        }

        //
        // free -> BC
        //

        ExFreePool( pHalfPage );
    }
}


VOID
BgChkCorruptSystemPtes(
    PVOID NotUsed
    )
/*++

Routine Description:

    This function corrupts system PTEs area on purpose. This is
    done so that we can test if the crache is mini triaged correctly.

Arguments:

    None.

Return Value:

    None.

Environment:

    Kernel mode.

--*/

{
    PULONG puCrtAdress = (PULONG)LongToPtr(0xC0300000);
    ULONG uCrtValue;
    int nCrtStep;

#define NUM_ULONGS_TO_CORRUPT       0x100
#define FIRST_ULONG_VALUE           0xABCDDCBA
#define NUM_ULONGS_SKIP_EACH_STEP   16


    uCrtValue = FIRST_ULONG_VALUE;

    for( nCrtStep = 0; nCrtStep < NUM_ULONGS_TO_CORRUPT; nCrtStep++ )
    {
        *puCrtAdress = uCrtValue;

        puCrtAdress += NUM_ULONGS_SKIP_EACH_STEP;

        uCrtValue++;
    }
}


VOID
BgChkHangCurrentProcessor (
    PVOID NotUsed
    )
/*++

Routine Description:

    This routine will hang the current processor.

Arguments:

    None.

Return Value:

    None.

Environment:

    Kernel mode.

--*/
{
    KIRQL PreviousIrql;

    KeRaiseIrql( DISPATCH_LEVEL, &PreviousIrql );

    while ( TRUE ) {
        //
        // this will hang the current processor
        //
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\buggy\driver\deadlock.h ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

   vfpdlock.h

Abstract:

    Detect deadlocks in arbitrary synchronization objects.

Author:

    Jordan Tigani (jtigani) 2-May-2000
    Silviu Calinoiu (silviuc) 9-May-2000


Revision History:

--*/


#ifndef _VFDLOCK_H_
#define _VFDLOCK_H_


VOID 
VfDeadlockDetectionInitialize(
    VOID
    );


//
// Resource types supported by deadlock verifier.
//

typedef enum _VI_DEADLOCK_RESOURCE_TYPE {
    ViDeadlockUnknown = 0,
    ViDeadlockMutex,
    ViDeadlockFastMutex,    
    ViDeadlockTypeMaximum
} VI_DEADLOCK_RESOURCE_TYPE, *PVI_DEADLOCK_RESOURCE_TYPE;

//
// Deadlock detection package initialization.
//

VOID 
ViDeadlockDetectionInitialize(
    );

//
// Resource interfaces
//

BOOLEAN
ViDeadlockAddResource(
    IN PVOID Resource,
    IN VI_DEADLOCK_RESOURCE_TYPE Type
    );

BOOLEAN
ViDeadlockQueryAcquireResource(
    IN PVOID Resource,
    IN VI_DEADLOCK_RESOURCE_TYPE Type
    );
VOID
ViDeadlockAcquireResource(
    IN PVOID Resource,
    IN VI_DEADLOCK_RESOURCE_TYPE Type
    );

VOID
ViDeadlockReleaseResource(
    IN PVOID Resource
    );

//
// Used for resource garbage collection.
//

VOID 
ViDeadlockDeleteMemoryRange(
    IN PVOID Address,
    IN SIZE_T Size
    );


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\buggy\driver\deadlock.c ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

   vfpdlock.c

Abstract:

    Detect deadlocks in arbitrary synchronization objects.

Author:

    Jordan Tigani (jtigani) 2-May-2000
    Silviu Calinoiu (silviuc) 9-May-2000


Revision History:

--*/

//
// TO DO LIST
//
// - detect a resource allocated on the stack of current thread and give
//   warning about this.
// - clean deletion of resources, threads, nodes
// - get rid of FirstNode hack
// - create nodes based on (R, T, Stk).
// - keep deleted nodes around if other nodes in the path are still alive.
//   See ISSUE in ViDeadlockDeleteRange.
// - Make sure NodeCount is updated all over the place.
//

#define _BUGGY_ 1

//
// ISSUE -- 
// This ifdef lets us move the code back and forth between the kernel
// and the buggy driver -- the latter is for testing purposes
//

#if _BUGGY_

#include <ntddk.h>
#include "deadlock.h"

#else

#include "vfdef.h"
#endif

//#include "vfpdlock.h"

//
// Deadlock detection structures.
//
// There are three important structures involved: THREAD, RESOURCE, NODE.
//
// For every active thread in the system that holds at least one resource
// the package maintains a THREAD structure. This gets created when a thread 
// acquires first resource and gets destroyed when thread releases the last
// resource. If a thread does not hold any resource it will not have a
// corresponding THREAD structure.
//
// For every resource in the system there is a RESOURCE structure. A dead resource
// might still have a RESOURCE laying around because the algorithm to garbage
// collect old resources is of the lazy type. 
//
// Every acquisition of a resource is modeled by a NODE structure. When a thread 
// acquires resource B while holding A the package will create a NODE for B and link
// it to the node for A. Beware that this is a very general description of what 
// happens.
//
// There are three important functions that make the interface with the outside
// world.
//
//     ViDeadlockAddResource          hook for resource initialization
//     ViDeadlockQueryAcquireResource checks for deadlock before resource acquisition
//     ViDeadlockAcquireResource      hook for resource acquire
//     ViDeadlockReleaseResource      hook for resource release
//
// Unfortunately almost no kernel synchronization object has a delete routine
// therefore we need to lazily garbage collect any zombie resources from our
// structures.
//

//
// Did we initialize the verifier deadlock detection package?
// If this variable is false no detection will be done whatsoever.
//

BOOLEAN ViDeadlockDetectionInitialized = FALSE;

//
// Enable/disable the deadlock detection package. This can be used
// to disable temporarily the deadlock detection package.
//
                
BOOLEAN ViDeadlockDetectionEnabled = 
#if _BUGGY_
    TRUE;
#else
    FALSE;
#endif


#define VI_DEADLOCK_FLAG_RECURSIVE_ACQUISITION_OK       0x1 
#define VI_DEADLOCK_FLAG_NO_INITIALIZATION_FUNCTION     0x2

ULONG ViDeadlockResourceTypeInfo[ViDeadlockTypeMaximum] =
{
    // ViDeadlockUnknown //    
    0,   

    // ViDeadlockMutex//    
    VI_DEADLOCK_FLAG_RECURSIVE_ACQUISITION_OK,

    // ViDeadlockFastMutex //    
    VI_DEADLOCK_FLAG_NO_INITIALIZATION_FUNCTION,    
    
};


//
// Max depth of stack traces captured.
//

#define VI_MAX_STACK_DEPTH 8

NTSYSAPI
USHORT
NTAPI
RtlCaptureStackBackTrace(
   IN ULONG FramesToSkip,
   IN ULONG FramesToCapture,
   OUT PVOID *BackTrace,
   OUT PULONG BackTraceHash
   );

//
// Deadlock specific issues (bugs)
//
// SELF_DEADLOCK
//
//     Acquire resource recursively.
//
// DEADLOCK_DETECTED
//
//     Plain deadlock. Need the previous information
//     messages to build a deadlock proof.
//
// UNINITIALIZED_RESOURCE
//
//     Acquiring a resource that was never initialized.
//
// UNEXPECTED_RELEASE
//
//     Releasing a resource which is not the last one
//     acquired by the current thread. 
//
// UNEXPECTED_THREAD
//
//     Current thread does not have any resources
//     acquired.
//
// MULTIPLE_INITIALIZATION
//
//      Attempting to initialize a second time the same 
//      resource.
//

#define VI_DEADLOCK_ISSUE_DEADLOCK_SELF_DEADLOCK  0x1000
#define VI_DEADLOCK_ISSUE_DEADLOCK_DETECTED       0x1001
#define VI_DEADLOCK_ISSUE_UNINITIALIZED_RESOURCE  0x1002
#define VI_DEADLOCK_ISSUE_UNEXPECTED_RELEASE      0x1003
#define VI_DEADLOCK_ISSUE_UNEXPECTED_THREAD       0x1004
#define VI_DEADLOCK_ISSUE_MULTIPLE_INITIALIZATION 0x1005
#define VI_DEADLOCK_ISSUE_THREAD_HOLDS_RESOURCES  0x1006

//
// VI_DEADLOCK_NODE
//

typedef struct _VI_DEADLOCK_NODE {

    //
    // Node representing the acquisition of the previous resource.
    //

    struct _VI_DEADLOCK_NODE * Parent;

    //
    // Node representing the next resource acquisitions, that are
    // done after acquisition of the current resource.
    //

    struct _LIST_ENTRY ChildrenList;

    //
    // Field used to chain siblings in the tree. A parent node has the
    // ChildrenList field as the head of the children list that is chained
    // with the Siblings field.
    //

    struct _LIST_ENTRY SiblingsList;


    //
    // List of nodes representing the same resource acquisition 
    // as the current node but in different contexts (lock combinations).
    //

    struct _LIST_ENTRY ResourceList;

    //
    // Back pointer to the descriptor for this resource.
    // If the node has been marked for deletion then the
    // ResourceAddress field should be used and it has the address
    // of the kernel resource address involved. The Root pointer is
    // no longer valid because we deallocate the RESOURCE structure
    // when it gets deleted.
    //

    union {
        struct _VI_DEADLOCK_RESOURCE * Root;

        PVOID ResourceAddress;
    };

    //
    // The number of nodes that are below this one at any depth.
    // This counter is used in the node deletion algorithms. It is
    // incremented by one on all ancestors of a node created (resource
    // acquired) and decremented by one when resource gets deleted.
    // If a root of a tree has NodeCount equal to zero the whole tree
    // will be deleted.
    //

    ULONG NodeCount;

    //
    // When we find a deadlock, we keep this info around in order to 
    // be able to identify the parties involved who have caused 
    // the deadlock.
    //

    PKTHREAD Thread;
    
    PVOID StackTrace[VI_MAX_STACK_DEPTH];    

} VI_DEADLOCK_NODE, *PVI_DEADLOCK_NODE;


//
// VI_DEADLOCK_RESOURCE
//

typedef struct _VI_DEADLOCK_RESOURCE {

    //
    // Since we may need to clean up different kinds of resources
    // in different ways, keep track of what kind of resource
    // this is.
    //

    VI_DEADLOCK_RESOURCE_TYPE Type;

    //
    // The address of the synchronization object used by the kernel.
    //

    PVOID ResourceAddress;

    //
    // The thread that curently owns the resource
    // (null if no owner)
    //
    PKTHREAD ThreadOwner;   

    //
    // List of resource nodes representing acquisitions of this resource.
    //

    LIST_ENTRY ResourceList;

    //
    // Number of resource nodes created for this resource. 
    // ISSUE: Why do we need this counter ? (silviuc)
    //

    ULONG NodeCount;

    //
    // List used for chaining resources from a hash bucket.
    //

    LIST_ENTRY HashChainList;

    //
    // Stack trace of the resource creator.
    //

    PVOID InitializeStackTrace [VI_MAX_STACK_DEPTH];


} VI_DEADLOCK_RESOURCE, * PVI_DEADLOCK_RESOURCE;


//
// VI_DEADLOCK_THREAD
//

typedef struct _VI_DEADLOCK_THREAD {

    //
    // Kernel thread address
    //
    
    PKTHREAD Thread;

    //
    // The node representing the last resource acquisition made by
    // this thread.
    //

    PVI_DEADLOCK_NODE CurrentNode;

    //
    // Thread list. It is used for chaining into a hash bucket.
    //

    LIST_ENTRY ListEntry;

} VI_DEADLOCK_THREAD, *PVI_DEADLOCK_THREAD;

typedef struct _VI_DEADLOCK_PARTICIPANT {
    //
    // Address of participant -- could be a resource
    // address or a resource node, depending on whether
    // NodeInformation is set
    //
    // NULL participant means that there are no more
    // participants
    //

    PVOID Participant;

    //
    // True:  Participant is type VI_DEADLOCK_NODE
    // False: Participant is a PVOID and shouldn't be deref'd
    //
    BOOLEAN NodeInformation;
    
} VI_DEADLOCK_PARTICIPANT, *PVI_DEADLOCK_PARTICIPANT;

//
// Deadlock resource and thread databases.
//
//

#define VI_DEADLOCK_HASH_BINS 1

PLIST_ENTRY ViDeadlockResourceDatabase;
PLIST_ENTRY ViDeadlockThreadDatabase;

ULONG ViDeadlockNumberParticipants;

PVI_DEADLOCK_PARTICIPANT ViDeadlockParticipation;

//
// Performance counters
//

ULONG ViDeadlockNumberOfNodes;
ULONG ViDeadlockNumberOfResources;
ULONG ViDeadlockNumberOfThreads;

//
// Maximum recursion depth for deadlock detection algorithm.
//

#define VI_DEADLOCK_MAXIMUM_DEGREE 4

ULONG ViDeadlockMaximumDegree;

//
//  Verifier deadlock detection pool tag.
//

#define VI_DEADLOCK_TAG 'kclD' 

//
// Global `deadlock lock database' lock
//

KSPIN_LOCK ViDeadlockDatabaseLock;
PKTHREAD ViDeadlockDatabaseOwner;

#define LOCK_DEADLOCK_DATABASE(OldIrql)                     \
    KeAcquireSpinLock(&ViDeadlockDatabaseLock, (OldIrql));  \
    ViDeadlockDatabaseOwner = KeGetCurrentThread ();

#define UNLOCK_DEADLOCK_DATABASE(OldIrql)                   \
    ViDeadlockDatabaseOwner = NULL;                         \
    KeReleaseSpinLock(&ViDeadlockDatabaseLock, OldIrql);

//
// Internal deadlock detection functions
//

VOID 
ViDeadlockDetectionInitialize(
    );

PLIST_ENTRY
ViDeadlockDatabaseHash( 
    IN PLIST_ENTRY Database,
    IN PVOID Address
    );

PVI_DEADLOCK_RESOURCE 
ViDeadlockSearchResource(
    IN PVOID ResourceAddress
    );

BOOLEAN
ViDeadlockAddResource(
    IN PVOID Resource,
    IN VI_DEADLOCK_RESOURCE_TYPE Type
    );

BOOLEAN
ViDeadlockQueryAcquireResource(
    IN PVOID Resource,
    IN VI_DEADLOCK_RESOURCE_TYPE Type
    );

BOOLEAN 
ViDeadlockSimilarNode (
    IN PVOID Resource,
    IN PKTHREAD Thread,
    IN PVOID * Trace,
    IN PVI_DEADLOCK_NODE Node
    );

VOID
ViDeadlockAcquireResource(
    IN PVOID Resource,
    IN VI_DEADLOCK_RESOURCE_TYPE Type
    );


VOID 
ViDeadlockReleaseResource(
    IN PVOID Resource
    );

BOOLEAN
ViDeadlockAnalyze(
    IN PVOID ResourceAddress,  
    IN PVI_DEADLOCK_NODE CurrentNode,
    IN ULONG Degree
    );

PVI_DEADLOCK_THREAD
ViDeadlockSearchThread (
    PKTHREAD Thread
    );

PVI_DEADLOCK_THREAD
ViDeadlockAddThread (
    PKTHREAD Thread
    );

VOID
ViDeadlockDeleteThread (
    PVI_DEADLOCK_THREAD Thread
    );

PVOID
ViDeadlockAllocate (
    SIZE_T Size
    );

VOID
ViDeadlockFree (
    PVOID Object
    );

VOID
ViDeadlockReportIssue (
    ULONG_PTR Param1,
    ULONG_PTR Param2,
    ULONG_PTR Param3,
    ULONG_PTR Param4
    );

VOID
ViDeadlockAddParticipant(
    PVOID ResourceAddress,              
    PVI_DEADLOCK_NODE FirstParticipant, OPTIONAL
    PVI_DEADLOCK_NODE SecondParticipant, 
    ULONG Degree
    );

VOID
ViDeadlockDeleteResource (
    PVI_DEADLOCK_RESOURCE Resource
    );

VOID
ViDeadlockDeleteTree (
    PVI_DEADLOCK_NODE Root
    );

BOOLEAN
ViDeadlockIsNodeMarkedForDeletion (
    PVI_DEADLOCK_NODE Node
    );


PVOID
ViDeadlockGetNodeResourceAddress (
    PVI_DEADLOCK_NODE Node
    );

#ifdef ALLOC_PRAGMA

#if ! _BUGGY_
#pragma alloc_text(INIT, ViDeadlockDetectionInitialize)

#pragma alloc_text(PAGEVRFY, ViDeadlockAnalyze)
#pragma alloc_text(PAGEVRFY, ViDeadlockDatabaseHash)

#pragma alloc_text(PAGEVRFY, ViDeadlockSearchResource)
#pragma alloc_text(PAGEVRFY, ViDeadlockAddResource)
#pragma alloc_text(PAGEVRFY, ViDeadlockSimilarNode)
#pragma alloc_text(PAGEVRFY, ViDeadlockAcquireResource)
#pragma alloc_text(PAGEVRFY, ViDeadlockReleaseResource)

#pragma alloc_text(PAGEVRFY, ViDeadlockSearchThread)
#pragma alloc_text(PAGEVRFY, ViDeadlockAddThread)
#pragma alloc_text(PAGEVRFY, ViDeadlockDeleteThread)

#pragma alloc_text(PAGEVRFY, ViDeadlockAllocate)
#pragma alloc_text(PAGEVRFY, ViDeadlockFree)

#pragma alloc_text(PAGEVRFY, ViDeadlockReportIssue)
#pragma alloc_text(PAGEVRFY, ViDeadlockAddParticipant)

#pragma alloc_text(PAGEVRFY, ViDeadlockDeleteMemoryRange);
#pragma alloc_text(PAGEVRFY, ViDeadlockDeleteResource);
#pragma alloc_text(PAGEVRFY, ViDeadlockWholeTree);
#pragma alloc_text(PAGEVRFY, ViDeadlockIsNodeMarkedForDeletion);
#pragma alloc_text(PAGEVRFY, ViDeadlockGetNodeResourceAddress);

#endif
#endif

/////////////////////////////////////////////////////////////////////
///////////////////// Initialization and deadlock database management
/////////////////////////////////////////////////////////////////////


PLIST_ENTRY
ViDeadlockDatabaseHash( 
    IN PLIST_ENTRY Database,
    IN PVOID Address
    )
/*++

Routine Description:

    This routine determines hashes the resource address into the deadlock database.
    The hash bin is represented by a list entry
    
    silviuc: very simple minded hash table.

Arguments:

    ResourceAddress: Address of the resource that is being hashed
    
Return Value:

    PLIST_ENTRY -- the list entry associated with the hash bin we land in.
--*/    
{
    return Database + ((ULONG_PTR)Address % VI_DEADLOCK_HASH_BINS);
} 


VOID 
ViDeadlockDetectionInitialize(
    )
/*++

Routine Description:

    This routine initializes the data structures necessary for detecting
    deadlocks in kernel synchronization objects.

Arguments:

    None.

Return Value:

    None. Sets ViDeadlockDetectionInitialized to TRUE if successful.

Environment:

    System initialization only.

--*/    
{    
    ULONG I;
    SIZE_T TableSize;
    SIZE_T ParticipationTableSize;

    //
    // Allocate hash tables for resources and threads.
    //

    TableSize = sizeof (LIST_ENTRY) * VI_DEADLOCK_HASH_BINS;

    ViDeadlockResourceDatabase = ViDeadlockAllocate (TableSize);

    if (!ViDeadlockResourceDatabase) {
        return;
    }
        
    ViDeadlockThreadDatabase = ViDeadlockAllocate (TableSize);

    if (!ViDeadlockThreadDatabase) {
        ViDeadlockFree (ViDeadlockResourceDatabase);
        return;
    }

    //
    // Initialize all.
    //

    for (I = 0; I < VI_DEADLOCK_HASH_BINS; I += 1) {

        InitializeListHead(&ViDeadlockResourceDatabase[I]);    
        InitializeListHead(&ViDeadlockThreadDatabase[I]);    
    }

    KeInitializeSpinLock(&ViDeadlockDatabaseLock);

    ViDeadlockMaximumDegree = VI_DEADLOCK_MAXIMUM_DEGREE;

    ViDeadlockNumberParticipants = FALSE;    

    ViDeadlockDetectionInitialized = TRUE;
   //ViDeadlockDetectionEnabled = TRUE;
}


/////////////////////////////////////////////////////////////////////
//////////////////////////////////////////// Deadlock detection logic
/////////////////////////////////////////////////////////////////////

BOOLEAN
ViDeadlockAnalyze(
    IN PVOID ResourceAddress,  
    IN PVI_DEADLOCK_NODE AcquiredNode,
    IN ULONG Degree
    )
/*++

Routine Description:

    This routine determines whether the acquisition of a certain resource
    could result in a deadlock.

    The routine assumes the deadlock database lock is held.

Arguments:

    ResourceAddress - address of the resource that will be acquired
    
    AcquiredNode - a graph describing which resources have been acquired by
    the current thread.
      
Return Value:
        
    True if deadlock detected, false otherwise.
          
--*/    
{

    PVI_DEADLOCK_RESOURCE CurrentResource;
    PVI_DEADLOCK_NODE CurrentAcquiredNode;
    PVI_DEADLOCK_NODE CurrentNode;
    PVI_DEADLOCK_NODE CurrentParent;
    BOOLEAN FoundDeadlock;
    PLIST_ENTRY Current;
    
    ASSERT (ViDeadlockDatabaseOwner == KeGetCurrentThread ());
    ASSERT (AcquiredNode);
    
    //
    // Stop recursion if it gets to deep.
    //
    
    if (Degree > ViDeadlockMaximumDegree) {
        return FALSE;
    }
    
    
    
    FoundDeadlock = FALSE;
    
    
    
    CurrentAcquiredNode = AcquiredNode;
    
    //
    // Loop over all nodes containing same resource as all of the Acquired nodes
    // parameter. For each such node we will traverse the Parent chain
    // to check if ResourceAddress appears at some point. If it does
    // we found a two way deadlock (caused by two threads). 
    //
    while(CurrentAcquiredNode != NULL) {        
        
        //
        // Check for a self cycle.
        //
        if (ViDeadlockGetNodeResourceAddress(CurrentAcquiredNode) == ResourceAddress) {
            
            ViDeadlockAddParticipant(ResourceAddress, NULL, CurrentAcquiredNode, Degree);
            FoundDeadlock = TRUE;
            goto Exit;
            
        }

        CurrentResource = CurrentAcquiredNode->Root;
        
        Current = CurrentResource->ResourceList.Flink;
        
        while (Current != &(CurrentResource->ResourceList)) {
            
            CurrentNode = CONTAINING_RECORD (Current,
                VI_DEADLOCK_NODE,
                ResourceList);
            
            CurrentParent = CurrentNode->Parent;
            
            //
            // Traverse the parent chain looking for two-way deadlocks.
            //
            
            while (CurrentParent != NULL) {
                
                if (ViDeadlockGetNodeResourceAddress(CurrentParent) == ResourceAddress) {
                    
                    FoundDeadlock = TRUE;
                                        

                    if (! Degree) {

                        ViDeadlockAddParticipant(ResourceAddress, 
                            NULL, 
                            CurrentAcquiredNode, 
                            Degree);

                        ViDeadlockAddParticipant(ResourceAddress, 
                            CurrentNode, 
                            CurrentParent, 
                            Degree);


                    } else {

                        ViDeadlockAddParticipant(ResourceAddress, 
                            AcquiredNode, 
                            CurrentParent, 
                            Degree);
                    }


                    
                    goto Exit;
                }
                
                CurrentParent = CurrentParent->Parent;
            }
            
            //
            // Move on to the next node (AcquiredNode->Root type of nodes).
            //
            
            Current = Current->Flink;
        }
        CurrentAcquiredNode = CurrentAcquiredNode->Parent;
    }
    
    CurrentAcquiredNode = AcquiredNode;
    
    while(CurrentAcquiredNode != NULL) {
        
        //
        // In order to find multiway deadlocks we traverse the Parent chain 
        // a second time and enter into recursion. This way we can detect 
        // cycles in the graph that are caused by multiple threads (up to Degree).
        //
        
        CurrentResource = CurrentAcquiredNode->Root;
        
        Current = CurrentResource->ResourceList.Flink;
        
        while (Current != &(CurrentResource->ResourceList)) {
            
            CurrentNode = CONTAINING_RECORD (Current,
                VI_DEADLOCK_NODE,
                ResourceList);
            
            //
            // Loop again over parents but this time get into recursion.
            // We could have done this in the loop above but we want to first search
            // completely the existing graph (tree actually) and only after that 
            // traverse it recursively.
            //
            
            CurrentParent = CurrentNode->Parent;
            
            while (CurrentParent != NULL) {
                
                FoundDeadlock = ViDeadlockAnalyze (ResourceAddress,
                    CurrentParent,
                    Degree + 1);
                
                if (FoundDeadlock) {
                    

                    if (! Degree) {

                        ViDeadlockAddParticipant(ResourceAddress, 
                            CurrentNode, 
                            CurrentParent, 
                            Degree);

                        ViDeadlockAddParticipant(ResourceAddress, 
                            NULL, 
                            CurrentAcquiredNode, 
                            Degree);
                        
                    

                        
                    } else {

                        ViDeadlockAddParticipant(ResourceAddress, 
                            AcquiredNode, 
                            CurrentParent, 
                            Degree);

                    }
                    

                    
                    goto Exit;
                }
                
                CurrentParent = CurrentParent->Parent;
            }
            
            //
            // Move on to the next node (AcquiredNode->Root type of nodes).
            //
            
            Current = Current->Flink;
        }

        CurrentAcquiredNode = CurrentAcquiredNode->Parent;
        
    }

    Exit:

    if (FoundDeadlock && Degree == 0) {
        
        ViDeadlockReportIssue (VI_DEADLOCK_ISSUE_DEADLOCK_DETECTED,
                               (ULONG_PTR)ResourceAddress,
                               (ULONG_PTR)CurrentAcquiredNode,
                               0);
    }
 
    return FoundDeadlock;
#
}


/////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////// Resource management
/////////////////////////////////////////////////////////////////////


PVI_DEADLOCK_RESOURCE 
ViDeadlockSearchResource(
    IN PVOID ResourceAddress
    )
/*++

Routine Description:

    This routine finds the resource descriptor structure for a 
    resource if one exists. 

Arguments:

    ResourceAddress: Address of the resource in question (as used by
       the kernel).

Return Value:

    PVI_DEADLOCK_RESOURCE structure describing the resource, if available,
    or else NULL

    Note. The caller of the function should hold the database lock.
    
--*/    

{
    PLIST_ENTRY ListHead;
    PLIST_ENTRY Current;
    PVI_DEADLOCK_RESOURCE Resource;

    ASSERT (ViDeadlockDatabaseOwner == KeGetCurrentThread ());

    ListHead = ViDeadlockDatabaseHash (ViDeadlockResourceDatabase, ResourceAddress);    

    if (IsListEmpty(ListHead)) {

        return NULL;
    }

    Current = ListHead->Flink;

    while (Current != ListHead) {

        Resource = CONTAINING_RECORD(Current,
                                     VI_DEADLOCK_RESOURCE,
                                     HashChainList);

        if (Resource->ResourceAddress == ResourceAddress) {

            return Resource;
        }

        Current = Current->Flink;
    }

    return NULL;         
} 


BOOLEAN
ViDeadlockAddResource(
    IN PVOID Resource,
    IN VI_DEADLOCK_RESOURCE_TYPE Type
    )
/*++

Routine Description:

    This routine adds an entry for a new resource to our deadlock detection 
    database.

Arguments:

    Resource: Address of the resource in question as used by the kernel.
    
    Type: Type of the resource.

Return Value:

    True if we created and initialized a new RESOURCE structure.
    
    Note. The caller of the function should not hold the database
    lock.

--*/    
{
    PLIST_ENTRY hashBin;
    PVI_DEADLOCK_RESOURCE resourceRoot;
    PVI_DEADLOCK_NODE resourceNode;
    KIRQL OldIrql;
    ULONG HashValue;

    //
    // If we aren't initialized or package is not enabled
    // we return immediately.
    //

    if (! (ViDeadlockDetectionInitialized && ViDeadlockDetectionEnabled)) {
        return FALSE;
    }

    //
    // Check if this resource was initialized before. 
    // This would be a bug.
    //

    LOCK_DEADLOCK_DATABASE( &OldIrql );

    resourceRoot = ViDeadlockSearchResource (Resource);

    if (resourceRoot) {
            
        ViDeadlockReportIssue (VI_DEADLOCK_ISSUE_MULTIPLE_INITIALIZATION,
                               (ULONG_PTR)Resource,
                               (ULONG_PTR)resourceRoot,
                               0);

        UNLOCK_DEADLOCK_DATABASE( OldIrql);
        return TRUE;
    }

    UNLOCK_DEADLOCK_DATABASE( OldIrql);

    //
    // Allocate the memory for the root of the new resource's tree.
    //

    resourceRoot = ViDeadlockAllocate (sizeof(VI_DEADLOCK_RESOURCE));

    if (NULL == resourceRoot) {
        return FALSE;
    }

    RtlZeroMemory(resourceRoot, sizeof(VI_DEADLOCK_RESOURCE));

    //
    // Fill information about resource.
    //

    resourceRoot->Type = Type;
    resourceRoot->ResourceAddress = Resource;

    InitializeListHead (&resourceRoot->ResourceList);

    resourceRoot->NodeCount = 0;

    //
    // Capture the stack trace of the guy that creates the resource first.
    // This should happen when resource gets initialized.
    //

    RtlCaptureStackBackTrace (0, // silviuc: how many frames to skip?
                              VI_MAX_STACK_DEPTH,
                              resourceRoot->InitializeStackTrace,
                              &HashValue);

    //
    // Figure out which hash bin this resource corresponds to.
    //

    hashBin = ViDeadlockDatabaseHash(ViDeadlockResourceDatabase, Resource);
    
    //
    // Now add to the list corresponding to the current hash bin
    //  

    LOCK_DEADLOCK_DATABASE( &OldIrql );

    InsertHeadList(hashBin, 
                   &(resourceRoot->HashChainList));

    ViDeadlockNumberOfResources += 1;

    UNLOCK_DEADLOCK_DATABASE( OldIrql);

    return TRUE;    
}


BOOLEAN
ViDeadlockQueryAcquireResource(
    IN PVOID Resource,
    IN VI_DEADLOCK_RESOURCE_TYPE Type
    )
/*++

Routine Description:

    This routine makes sure that it is ok to acquire the resource without
    causing a deadlock. .

Arguments:

    Resource: Address of the resource in question as used by kernel.

    Type: Type of the resource.

Return Value:

    None.

--*/
{
    PKTHREAD CurrentThread;
    PVI_DEADLOCK_THREAD ThreadEntry;    
    KIRQL OldIrql;
    PVI_DEADLOCK_NODE CurrentNode;
    PVI_DEADLOCK_RESOURCE ResourceRoot;
    PLIST_ENTRY Current;
    BOOLEAN FoundDeadlock;
    ULONG DeadlockFlags;

    //
    // If we are not initialized or package is not enabled
    // we return immediately.
    //
    

    if (! (ViDeadlockDetectionInitialized && ViDeadlockDetectionEnabled)) {
        return FALSE;
    }
    
    FoundDeadlock = FALSE;

    CurrentThread = KeGetCurrentThread(); 

    DeadlockFlags = ViDeadlockResourceTypeInfo[Type];

    LOCK_DEADLOCK_DATABASE( &OldIrql );

    //
    // Look for this thread in our thread list. 
    // Add a new thread if it is not in the list.
    //

    ThreadEntry = ViDeadlockSearchThread (CurrentThread);

    if (ThreadEntry == NULL) {
        //
        // Threads without allocations can't cause deadlocks
        //
        goto Exit;
    }        

    //
    // Check if this resource is already in our database
    //
    
    ResourceRoot = ViDeadlockSearchResource (Resource);

    //
    // Resources that we haven't seen before can't cause deadlocks
    //
    if (ResourceRoot == NULL) {
        goto Exit;
    }


    ASSERT (ResourceRoot);
    ASSERT (ThreadEntry);

    //
    // Check if thread holds any resources.
    // Threads that don't have any resources
    // yet can't cause deadlocks
    //

    if (ThreadEntry->CurrentNode == NULL) {
        goto Exit;
    }


    //
    // If we get here, the current thread had already acquired resources.
    //
    
    //
    // Find whether the link already exists. We are looking for a direct
    // link between ThreadEntry->CurrentNode and Resource (parameter).
    //        
    
    Current = ThreadEntry->CurrentNode->ChildrenList.Flink;
    
    while (Current != &(ThreadEntry->CurrentNode->ChildrenList)) {
        
        CurrentNode = CONTAINING_RECORD (Current,
            VI_DEADLOCK_NODE,
            SiblingsList);
        
        if (ViDeadlockGetNodeResourceAddress(CurrentNode) == Resource) {
            
            //
            // We have found a link.
            // A link that already exists doesn't have to be
            // checked for a deadlock because it would have
            // been caught when the link was created...
            // so we can just update the pointers and exit.
            //
            
            ThreadEntry->CurrentNode = CurrentNode;
            
            goto Exit;
        }
        
        Current = Current->Flink;
    }
    
    //
    // Now we know that we're in it for the long haul .. 
    // doesn't cause a deadlock
    //
    
    CurrentNode = NULL;
    
    //
    // We will analyze deadlock if the resource just about to be acquired
    // was acquired before and there are nodes in the graph for the
    // resource.
    //
    
    
    
    if (ViDeadlockAnalyze(Resource,  ThreadEntry->CurrentNode, 0)) {
        
        //
        // Go back to ground 0 with this thread
        //
        ThreadEntry->CurrentNode = NULL;    
        FoundDeadlock = TRUE;
        
    }

    //
    //  Exit point.
    //

    Exit:     
    
    //
    // Release deadlock database and return.
    //

    UNLOCK_DEADLOCK_DATABASE( OldIrql );
    return FoundDeadlock;

}


BOOLEAN 
ViDeadlockSimilarNode (
    IN PVOID Resource,
    IN PKTHREAD Thread,
    IN PVOID * Trace,
    IN PVI_DEADLOCK_NODE Node
    )
{
    SIZE_T Index;

    if (Resource == ViDeadlockGetNodeResourceAddress(Node) &&
        Thread == Node->Thread) {

        Index = RtlCompareMemory (Trace, Node->StackTrace, sizeof (Node->StackTrace));

        if (Index == sizeof (Node->StackTrace)) {

            return TRUE;
        }
    }

    return FALSE;
}


VOID
ViDeadlockAcquireResource(
    IN PVOID Resource,
    IN VI_DEADLOCK_RESOURCE_TYPE Type        
    )
/*++

Routine Description:

    This routine makes sure that it is ok to acquire the resource without
    causing a deadlock. It will also update the resource graph with the new
    resource acquisition.

Arguments:

    Resource: Address of the resource in question as used by kernel.

    Type: Type of the resource.

Return Value:

    None.

--*/    
{
    PKTHREAD CurrentThread;
    PVI_DEADLOCK_THREAD ThreadEntry;    
    KIRQL OldIrql;
    PVI_DEADLOCK_NODE CurrentNode;
    PVI_DEADLOCK_RESOURCE ResourceRoot;
    PLIST_ENTRY Current;
    ULONG HashValue;
    ULONG DeadlockFlags;
    BOOLEAN CreatingRootNode = FALSE;
    PVOID Trace [VI_MAX_STACK_DEPTH];

    //
    // If we are not initialized or package is not enabled
    // we return immediately.
    //

    if (! (ViDeadlockDetectionInitialized && ViDeadlockDetectionEnabled)) {
        return;
    }
    
    CurrentThread = KeGetCurrentThread(); 

    DeadlockFlags = ViDeadlockResourceTypeInfo[Type];

    //
    // Capture stack trace. We will need it to figure out
    // if we've been in this state before. We will skip two frames
    // for ViDeadlockAcquireResource and the verifier thunk that
    // calls it.
    //


    RtlZeroMemory (Trace, sizeof Trace);

    RtlCaptureStackBackTrace (
        2,
        VI_MAX_STACK_DEPTH,
        Trace,
        &HashValue);

    //
    // Lock the deadlock database.
    //

    LOCK_DEADLOCK_DATABASE( &OldIrql );

    //
    // Look for this thread in our thread list. 
    // Add a new thread if it is not in the list.
    //

    ThreadEntry = ViDeadlockSearchThread (CurrentThread);

    if (ThreadEntry == NULL) {

        //
        // Note that ViDeadlockAddThread will drop the lock
        // while allocating memory and then reacquire it.
        //

        ThreadEntry = ViDeadlockAddThread (CurrentThread);

        if (ThreadEntry == NULL) {

            //
            // If we cannot allocate a new thread entry then 
            // no deadlock detection will happen.
            //

            UNLOCK_DEADLOCK_DATABASE( OldIrql );
            return;
        }
    }

    //
    // Check if this resource is already in our database
    //
    
    ResourceRoot = ViDeadlockSearchResource (Resource);

    if (ResourceRoot == NULL) {

        //
        // Could not find the resource descriptor.
        // 

        
        if ((DeadlockFlags & VI_DEADLOCK_FLAG_NO_INITIALIZATION_FUNCTION)) {

            //
            // Certain resource types have no initialization function ..
            // in which case we'll get an 'acquire' without an 'add' 
            // first -- this is entirely OK
            //            

            UNLOCK_DEADLOCK_DATABASE( OldIrql );

            if (FALSE == ViDeadlockAddResource(Resource, Type) ) {
                return;
            }            

            LOCK_DEADLOCK_DATABASE( &OldIrql );
            
            //
            // Note that even though we dropped the lock, we don't have 
            // to reobtain the thread entry pointer -- since thread
            // entry for the current thread can't have gone away.
            //

            ResourceRoot = ViDeadlockSearchResource (Resource);


        } else {
            
            // 
            // This resource type does have an initialization function --
            // and it wasn't called. This is bad.            
            //
            
            ViDeadlockReportIssue (VI_DEADLOCK_ISSUE_UNINITIALIZED_RESOURCE,
                                   (ULONG_PTR)Resource,
                                   0,
                                   0);

            //
            // ISSUE (silviuc) Difficult to recover from this failure.
            // We will complain during release that resource was not acquired.
            //

            ThreadEntry->CurrentNode = NULL;
            
            UNLOCK_DEADLOCK_DATABASE( OldIrql );            
            return;
        }
    }
    
    //
    // At this point we have a THREAD and a RESOURCE to play with.
    // In addition we are just about to acquire the resource which means
    // there should not be another thread owning it.
    //

    ASSERT (ResourceRoot);
    ASSERT (ThreadEntry);
    ASSERT (NULL == ResourceRoot->ThreadOwner);

    //
    // Check if thread holds any resources. If it does we will have to determine
    // at that local point in the dependency graph if we need to create a
    // new node. If this is the first resource acquired by the thread we need
    // to create a new root node or reuse one created in the past.
    //
    // A node created in the past will match the current situation if the same 
    // thread acquires, the same resource is acquired and the stack traces match.
    // A node represents a triad (Thread, Resource, StackTrace).
    //
    
    if (ThreadEntry->CurrentNode != NULL) {

        //
        // If we get here, the current thread had already acquired resources.
        // Must now do three things ... 
        //
        // 1. if link already exists, update pointers and exit
        // 2. otherwise create a new node
        // 3. check for deadlocks
        //

        //
        // Find whether the link already exists. We are looking for a direct
        // link between ThreadEntry->CurrentNode and Resource (parameter).
        //        

        Current = ThreadEntry->CurrentNode->ChildrenList.Flink;

        while (Current != &(ThreadEntry->CurrentNode->ChildrenList)) {

            CurrentNode = CONTAINING_RECORD (Current,
                                             VI_DEADLOCK_NODE,
                                             SiblingsList);

            Current = Current->Flink;
            
            if (ViDeadlockSimilarNode (Resource, CurrentThread, Trace, CurrentNode)) {

                //
                // We have found a link.
                // A link that already exists doesn't have to be
                // checked for a deadlock because it would have
                // been caught when the link was created...
                // so we can just update the pointers to reflect the new
                // resource acquired and exit.
                //

                ThreadEntry->CurrentNode = CurrentNode;

                goto Exit;
            }
        }

        //
        // Now we know that we're in it for the long haul .. we must create a new
        // link and make sure that it doesn't cause a deadlock
        //

        CurrentNode = NULL;

        //
        // We will analyze deadlock if the resource just about to be acquired
        // was acquired before and there are nodes in the graph for the
        // resource.
        //

        if (ResourceRoot->NodeCount > 0) {

            if (ViDeadlockAnalyze(Resource,  ThreadEntry->CurrentNode, 0)) {      

                //
                // Go back to ground 0 with this thread if a deadlock has been
                // detected.
                //

                ThreadEntry->CurrentNode = NULL;
                ResourceRoot->ThreadOwner = NULL;
                goto Exit;
            }
        }
    }
    else {

        //
        // Thread does not have any resources acquired. We have to figure out
        // if this is a scenario we have encountered in the past by looking
        // at all nodes (that are roots) for the resource to be acquired.
        //

        PLIST_ENTRY Current;
        PVI_DEADLOCK_NODE Node;
        BOOLEAN FoundNode = FALSE;

        Current = ResourceRoot->ResourceList.Flink;

        while (Current != &(ResourceRoot->ResourceList)) {

            Node = CONTAINING_RECORD (Current,
                                      VI_DEADLOCK_NODE,
                                      ResourceList);

            Current = Node->ResourceList.Flink;

            if (Node->Parent == NULL) {

                if (ViDeadlockSimilarNode (Resource, CurrentThread, Trace, Node)) {

                    FoundNode = TRUE;
                    break;
                }
            }
        }

        if (FoundNode) {

            ThreadEntry->CurrentNode = Node;
            goto Exit;
        }
        else {

            CreatingRootNode = TRUE;
        }

    }

    //
    // At this moment we know for sure the new link will not cause
    // a deadlock. We will create the new resource node.
    //

    CurrentNode = ViDeadlockAllocate (sizeof (VI_DEADLOCK_NODE));

    if (CurrentNode != NULL) {

        //
        // Initialize the new resource node
        //            

        RtlZeroMemory (CurrentNode, sizeof *CurrentNode);

        CurrentNode->Parent = ThreadEntry->CurrentNode;

        CurrentNode->Root = ResourceRoot;

        InitializeListHead (&(CurrentNode->ChildrenList));

        //
        // Add to the children list of the parent.
        //        

        if (! CreatingRootNode) {
            
            InsertHeadList(&(ThreadEntry->CurrentNode->ChildrenList), 
                           &(CurrentNode->SiblingsList));
        }

        //
        // Register the new resource node in the list of nodes maintained
        // for this resource.
        //

        InsertHeadList(&(ResourceRoot->ResourceList), 
                       &(CurrentNode->ResourceList));

        ResourceRoot->NodeCount += 1;

        //
        // Update NodeCount for all NODEs all the way up to the
        // root of the tree.
        //

        {
            PVI_DEADLOCK_NODE Parent;

            Parent = CurrentNode->Parent;

            while (Parent != NULL) {

                Parent->NodeCount += 1;

                Parent = Parent->Parent;
            }
        }
    }

    //
    // Update current resource held by thread.
    //
    // NOTE -- Do this even if the allocation FAILS --
    // Since when the resource is released, we won't
    // recognize it (since the node could not be allocated)
    // and we'll bugcheck. 
    //

    ThreadEntry->CurrentNode = CurrentNode;

    //
    //  Exit point.
    //

    Exit: 

    //
    // Add information we use to identify the culprit should
    // a deadlock occur
    //            

    if (CurrentNode) {
        
        CurrentNode->Thread = CurrentThread;
        ResourceRoot->ThreadOwner = CurrentThread;

        RtlCopyMemory (CurrentNode->StackTrace, Trace, sizeof Trace);
    }
    
    //
    // Release deadlock database and return.
    //

    UNLOCK_DEADLOCK_DATABASE( OldIrql );
    return;
}


VOID 
ViDeadlockReleaseResource(
    IN PVOID Resource
    )
/*++

Routine Description:

    This routine does the maintenance necessary to release resources from our 
    deadlock detection database.    

Arguments:

    Resource: Address of the resource in question.    

Return Value:

    None.
--*/    

{
    PKTHREAD CurrentThread;
    PVI_DEADLOCK_THREAD ThreadEntry;    
    KIRQL OldIrql;
    PVI_DEADLOCK_NODE CurrentNode;
    PVI_DEADLOCK_RESOURCE ResourceRoot;

    ASSERT (ViDeadlockDatabaseOwner != KeGetCurrentThread());
    
    //
    // If we aren't initialized or package is not enabled
    // we return immediately.
    //

    if (! (ViDeadlockDetectionInitialized && ViDeadlockDetectionEnabled)) {
        return;
    }

    CurrentThread = KeGetCurrentThread();

    LOCK_DEADLOCK_DATABASE( &OldIrql );

    ResourceRoot = ViDeadlockSearchResource (Resource);

    if (ResourceRoot == NULL) {
        //
        // This is probably bad but we con't complain since
        // we may have faild an allocation -- we don't want
        // to accuse somebody of foul play just because
        // our allocation function failed
        //
        // ISSUE (silviuc): should complain if no allocation ever failed.
        //
        UNLOCK_DEADLOCK_DATABASE( OldIrql );
        return;
    }
    
    if (ResourceRoot->ThreadOwner == NULL) {
        //
        // Most likely someone is releasing a resource that
        // was never acquired. However the other possibility
        // is that we have failed an allocation. So we can't 
        // complain -- but we can't really do anything either
        //
        // ISSUE (silviuc): should complain if no allocation ever failed.
        //
        UNLOCK_DEADLOCK_DATABASE( OldIrql );
        return;
    }

    //
    // Look for this thread in our thread list,
    // Note we are looking actually for the thread
    // that acquired the resource -- not the current one
    // It should, in fact be the current one, but if 
    // the resource is being released in a different thread 
    // from the one it was acquired in, we need the original.
    //
    
    ThreadEntry = ViDeadlockSearchThread (ResourceRoot->ThreadOwner);
    
    if (NULL == ThreadEntry) {
        //
        // This can happen when we recover from an unexpected release --
        // there is still a therad owner for the resource but we nuked the
        // thread entry.
        // Indicate that we no longer hold this resource.
        //
        // ISSUE (silviuc): So, we do not need to complain here ?
        //
        ResourceRoot->ThreadOwner = NULL;        
        UNLOCK_DEADLOCK_DATABASE( OldIrql );
        return;
    }


    if (ResourceRoot->ThreadOwner != CurrentThread) {
        
        //
        // Someone acquired a resource but it was
        // released in another thread. This is bad 
        // design.
        //                

        DbgPrint("Thread %p acquired resource %p but thread %p released it\n",            
           ThreadEntry->Thread, Resource, CurrentThread );        
       
        ViDeadlockReportIssue (VI_DEADLOCK_ISSUE_UNEXPECTED_THREAD,                               
                               (ULONG_PTR)ResourceRoot,
                               (ULONG_PTR)ThreadEntry,                               
                               (ULONG_PTR)ViDeadlockSearchThread(CurrentThread)
                               );
        //
        // If we don't want this to be fatal, in order to 
        // continue we must pretend that the current
        // thread is the resource's owner.
        //
        CurrentThread = ResourceRoot->ThreadOwner;
    

    }                

    //
    // Wipe out the resource owner since resource will be released.
    //
    
    ResourceRoot->ThreadOwner = NULL;

    //
    // Check the case where the thread does not appear to hold a resource.
    // ISSUE (silviuc): We kind of cluttered the code to make it restartable
    // after an error. It might be better to clean it up even if not restartable.
    //

    if(NULL == ThreadEntry->CurrentNode) {

        //
        // This will happen when we recover from a deadlock        
        //        

        UNLOCK_DEADLOCK_DATABASE( OldIrql );
        return;
    
    }    
    
    //
    // All nodes must have a root -- just make sure because we're deref'ing
    // it in a minute
    //
    
    ASSERT (ThreadEntry->CurrentNode->Root);    

    //
    // Found the thread list entry 
    //
    
    if (ViDeadlockGetNodeResourceAddress(ThreadEntry->CurrentNode) != Resource) {
        
        //
        // Getting here means that soembody acquires a then b then tries
        // to release b before a. This is bad.        
        //
        //
        // ISSUE (jtigani): -- flesh out reporting -- so we can prove that this
        // actually happenned.
        //        
        DbgPrint("ERROR: Must release resources in reverse-order\n");
        DbgPrint("Resource %p acquired before resource %p -- \n"
                 "Current thread is trying to release it first\n",
                 Resource, 
                 ViDeadlockGetNodeResourceAddress(ThreadEntry->CurrentNode));

        
        ViDeadlockReportIssue (VI_DEADLOCK_ISSUE_UNEXPECTED_RELEASE,
            (ULONG_PTR)Resource,
            (ULONG_PTR)ThreadEntry->CurrentNode,
            (ULONG_PTR)CurrentThread);

        //
        // The thread state is hosed. 
        // Try to keep going.
        // 
        
        ThreadEntry->CurrentNode = NULL;        

    } else {
        
        //
        // Indicate that we have released the curent node
        //
        ThreadEntry->CurrentNode = ThreadEntry->CurrentNode->Parent;    
        
    }
        
    //
    // If thread does not hold resources anymore we will destroy the
    // thread information.
    //
    
    if (ThreadEntry->CurrentNode == NULL) {
        
        ViDeadlockDeleteThread (ThreadEntry);
    }
    

    UNLOCK_DEADLOCK_DATABASE(OldIrql);
}


/////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////// Thread management
/////////////////////////////////////////////////////////////////////

PVI_DEADLOCK_THREAD
ViDeadlockSearchThread (
    PKTHREAD Thread
    )
/*++

Routine Description:

    This routine searches for a thread in the thread database.
    
    The function assumes the deadlock database lock is held.

Arguments:

    Thread - thread address

Return Value:

    Address of VI_DEADLOCK_THREAD structure if thread was found.
    Null otherwise.
    
--*/    
{
    PLIST_ENTRY Current;
    PVI_DEADLOCK_THREAD ThreadInfo;
    PLIST_ENTRY HashBin;

    ASSERT (ViDeadlockDatabaseOwner == KeGetCurrentThread ());

    ThreadInfo = NULL;

    HashBin = ViDeadlockDatabaseHash(ViDeadlockThreadDatabase, Thread);

    if (IsListEmpty(HashBin)) {
        return NULL;
    }

    Current = HashBin->Flink;

    while (Current != HashBin) {

        ThreadInfo = CONTAINING_RECORD (Current,
                                        VI_DEADLOCK_THREAD,
                                        ListEntry);

        if (ThreadInfo->Thread == Thread) {
            return ThreadInfo;
        }

        Current = Current->Flink;
    }

    return NULL;
}


PVI_DEADLOCK_THREAD
ViDeadlockAddThread (
    PKTHREAD Thread
    )
/*++

Routine Description:

    This routine adds a new thread to the thread database.
    
    The function assumes the deadlock database lock is held. It will
    drop the lock while allocating memory for the thread structure and
    then reacquire the lock. Special attention in the caller of this 
    function (ViDeadlockAcquireResource) because any internal pointer
    should be reobtained since the lock was dropped.

Arguments:

    Thread - thread address 

Return Value:

    Address of the VI_DEADLOCK_THREAD resource just added.
    Null if allocation failed.
--*/    
{
    KIRQL OldIrql;
    PVI_DEADLOCK_THREAD ThreadInfo;
    PLIST_ENTRY HashBin;

    ASSERT (ViDeadlockDatabaseOwner == KeGetCurrentThread ());

    //
    // It is safe to play with OldIrql like below because this function
    // is called from ViDeadlockAcquireResource with irql raised at DPC
    // level.
    //

    OldIrql = DISPATCH_LEVEL;

    UNLOCK_DEADLOCK_DATABASE (OldIrql);

    ThreadInfo = ViDeadlockAllocate (sizeof(VI_DEADLOCK_THREAD));

    LOCK_DEADLOCK_DATABASE (&OldIrql);

    if (ThreadInfo == NULL) {
        return NULL;
    }

    RtlZeroMemory (ThreadInfo, sizeof *ThreadInfo);

    ThreadInfo->Thread = Thread;

    HashBin = ViDeadlockDatabaseHash(ViDeadlockThreadDatabase, Thread);

    InsertHeadList (HashBin, 
                    &ThreadInfo->ListEntry);

    ViDeadlockNumberOfThreads += 1;

    return ThreadInfo;
}


VOID
ViDeadlockDeleteThread (
    PVI_DEADLOCK_THREAD Thread
    )
/*++

Routine Description:

    This routine deletes a thread.

Arguments:

    Thread - thread address

Return Value:

    None.
--*/    
{
    KIRQL OldIrql;
    VI_DEADLOCK_THREAD ThreadInfo;
    PLIST_ENTRY Current;
    BOOLEAN Result;
    PKTHREAD CurrentThread;
    PLIST_ENTRY HashBin;

    CurrentThread = KeGetCurrentThread ();

    ASSERT (ViDeadlockDatabaseOwner == CurrentThread);
    ASSERT (Thread && Thread->Thread == CurrentThread);
    ASSERT (Thread->CurrentNode == NULL);

    RemoveEntryList (&(Thread->ListEntry));

    ViDeadlockNumberOfThreads -= 1;
}

/////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////// Allocate/Free
/////////////////////////////////////////////////////////////////////

PVOID
ViDeadlockAllocate (
    SIZE_T Size
    )
{
    return ExAllocatePoolWithTag(NonPagedPool, Size, VI_DEADLOCK_TAG);
}

VOID
ViDeadlockFree (
    PVOID Object
    )
{
    ExFreePool (Object);
}

/////////////////////////////////////////////////////////////////////
/////////////////////////////////////// Error reporting and debugging
/////////////////////////////////////////////////////////////////////

ULONG ViDeadlockDebug = 0x01;

VOID
ViDeadlockReportIssue (
    ULONG_PTR Param1,
    ULONG_PTR Param2,
    ULONG_PTR Param3,
    ULONG_PTR Param4
    )
{
    

    if ((ViDeadlockDebug & 0x01)) {

        DbgPrint ("Verifier: deadlock: stop: %u %p %p %p %p \n",
                  DRIVER_VERIFIER_DETECTED_VIOLATION,
                  Param1,
                  Param2,
                  Param3,
                  Param4);

        DbgBreakPoint ();
    }
    else {

        KeBugCheckEx (DRIVER_VERIFIER_DETECTED_VIOLATION,
                      Param1,
                      Param2,
                      Param3,
                      Param4);
    }

    ViDeadlockNumberParticipants = FALSE;
}


VOID
ViDeadlockAddParticipant(
    PVOID ResourceAddress,              
    PVI_DEADLOCK_NODE FirstParticipant, OPTIONAL
    PVI_DEADLOCK_NODE SecondParticipant, 
    ULONG Degree
    )
{
    ULONG Participants;
    
    if (0 == ViDeadlockNumberParticipants) {        

        Participants = Degree + 2;        

        ViDeadlockParticipation = ViDeadlockAllocate(
            sizeof(VI_DEADLOCK_PARTICIPANT) * (2 * Participants + 1)
            );
        RtlZeroMemory(
            ViDeadlockParticipation, 
            sizeof(VI_DEADLOCK_PARTICIPANT) * (2 * Participants + 1)
            );        
            


        DbgPrint("|**********************************************************************\n");
        DbgPrint("|** \n");
        DbgPrint("|** Deadlock detected trying to acquire synchronization object at \n");
        DbgPrint("|** address %p (%d-way deadlock)\n",
            ResourceAddress,
            Participants            
            );

        if (ViDeadlockParticipation) {
            DbgPrint("|** For more information, type \n");            
            DbgPrint("|**    !deadlock\n");
            DbgPrint("|** \n");
            DbgPrint("|**********************************************************************\n");


        } else {
            DbgPrint("|** More information is not available because memory could\n");            
            DbgPrint("|**    not be allocated to save the state information");
            DbgPrint("|** \n");
            DbgPrint("|**********************************************************************\n");
            
            return;
        }

        
       
    }    
#if 0
    DbgPrint ("Verifier: deadlock: message: participant1 @ %p, participant2 @ %p, \n",
              (FirstParticipant) ?
                    ViDeadlockGetNodeResourceAddress(FirstParticipant) :
                    ResourceAddress, 
                    
              ViDeadlockGetNodeResourceAddress(SecondParticipant)
              );
#endif
    if (FirstParticipant) {
        
        ViDeadlockParticipation[ViDeadlockNumberParticipants].NodeInformation = 
            TRUE;
        ViDeadlockParticipation[ViDeadlockNumberParticipants].Participant = 
            FirstParticipant;

    } else {

        ViDeadlockParticipation[ViDeadlockNumberParticipants].NodeInformation = 
            FALSE;
        ViDeadlockParticipation[ViDeadlockNumberParticipants].Participant = 
            ViDeadlockSearchResource(ResourceAddress);

    }

    ViDeadlockParticipation[ViDeadlockNumberParticipants+1].NodeInformation = 
        TRUE;
    ViDeadlockParticipation[ViDeadlockNumberParticipants+1].Participant = 
        SecondParticipant;

    ViDeadlockNumberParticipants +=2;
}


/////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////// Resource cleanup
/////////////////////////////////////////////////////////////////////


VOID 
ViDeadlockDeleteMemoryRange(
    IN PVOID Address,
    IN SIZE_T Size
    )
/*++

Routine Description:

    This routine is called whenever some region of kernel virtual space
    is no longer valid. We need this hook because most kernel resources
    do not have a "delete resource" function and we need to figure out
    what resources are not valid. Otherwise our dependency graph will 
    become populated by many zombie resources.
    
    The important moments when the function gets called are ExFreePool
    (and friends) and driver unloading. Dynamic and static memory are the
    main regions where a resource gets allocated. There can be the possibility
    of a resource allocated on the stack but this is a very weird scenario.
    We might need to detect this and flag it as a potential issue. 
    
    If a resource or thread lives within the range specified then all graph
    paths with nodes reachable from the resource or thread will be wiped out.
    
    ISSUE (silviuc). This policy might lose some cases. 
    For instance if T1 acquires ABC,
    then C is deleted and then T2 acquires BA this is a potential deadlock but
    we will not catch it because when C gets deleted the whole ABC path will
    disappear. Right now we have no solution for that. If we do not delete there
    is no way we can decide when to wipe regions of the graph withouth creating
    accumulations of zombies. One solution would be to keep nodes around and delete
    them only if all nodes in the tree are supposed to be deleted.

Arguments:

    Address - start address of the range to be deleted.
    
    Size - size in bytes of the range to be deleted.

Return Value:

    None. 

--*/    
{
    ULONG Index;
    PLIST_ENTRY Current;
    PVI_DEADLOCK_RESOURCE Resource;
    PVI_DEADLOCK_THREAD Thread;
    KIRQL OldIrql;

    LOCK_DEADLOCK_DATABASE(&OldIrql)
    
    //
    // Iterate all resources and delete the ones contained in the
    // memory range.
    //

    for (Index = 0; Index < VI_DEADLOCK_HASH_BINS; Index += 1) {

        Current = ViDeadlockResourceDatabase[Index].Flink;

        while (Current != &(ViDeadlockResourceDatabase[Index])) {


            Resource = CONTAINING_RECORD (Current,
                                          VI_DEADLOCK_RESOURCE,
                                          HashChainList);

            Current = Current->Flink;

            if ((PVOID)(Resource->ResourceAddress) >= Address &&
                ((ULONG_PTR)(Resource->ResourceAddress) <= ((ULONG_PTR)Address + Size))) {

                ViDeadlockDeleteResource (Resource);
            }
        }
    }

    //
    // Iterate all threads and delete the ones contained in the 
    // memory range. Note that it is actually a bug if we find a
    // thread to be deleted because this means thread is dying while
    // holding some resources.
    //

    for (Index = 0; Index < VI_DEADLOCK_HASH_BINS; Index += 1) {

        Current = ViDeadlockThreadDatabase[Index].Flink;

        while (Current != &(ViDeadlockThreadDatabase[Index])) {


            Thread = CONTAINING_RECORD (Current,
                                        VI_DEADLOCK_THREAD,
                                        ListEntry);

            Current = Current->Flink;

            if ((PVOID)(Thread->Thread) >= Address &&
                ((ULONG_PTR)(Thread->Thread) <= ((ULONG_PTR)Address + Size))) {

                ViDeadlockReportIssue (VI_DEADLOCK_ISSUE_THREAD_HOLDS_RESOURCES,
                                       (ULONG_PTR)Thread,
                                       (ULONG_PTR)(Thread->CurrentNode),
                                       0); 
            }
        }
    }


    UNLOCK_DEADLOCK_DATABASE(OldIrql)
}


BOOLEAN
ViDeadlockIsNodeMarkedForDeletion (
    PVI_DEADLOCK_NODE Node
    )
{
    ASSERT (Node);

    if (Node->ResourceList.Flink == NULL) {
        return TRUE;
    }
    else {
        return FALSE;
    }
}


PVOID
ViDeadlockGetNodeResourceAddress (
    PVI_DEADLOCK_NODE Node
    )
{
    if (ViDeadlockIsNodeMarkedForDeletion(Node)) {
        return Node->ResourceAddress;
    }
    else {
        return Node->Root->ResourceAddress;
    }
}

VOID
ViDeadlockDeleteResource (
    PVI_DEADLOCK_RESOURCE Resource
    )
{
    PLIST_ENTRY Current;
    PVI_DEADLOCK_NODE Node;
    PVI_DEADLOCK_NODE Parent;
    PVI_DEADLOCK_NODE Root;

    ASSERT (Resource != NULL);

    //
    // Traverse the list of nodes representing acquisition of this resource
    // and mark them all as deleted. If the NodeCount of the root becomes zero
    // then we can delete the whole tree under the root.
    //

    Current = Resource->ResourceList.Flink;

    while (Current != &(Resource->ResourceList)) {

        Node = CONTAINING_RECORD (Current,
                                  VI_DEADLOCK_NODE,
                                  ResourceList);


        Current = Current->Flink;

        //
        //  Mark node as deleted
        //

        Node->ResourceList.Flink = NULL;
        Node->ResourceList.Blink = NULL;
        Node->ResourceAddress = Node->Root->ResourceAddress;

        //
        // Update NodeCount all the way to the root.
        //

        Parent = Node->Parent;
        Root = Node;

        while (Parent != NULL) {

            Parent->NodeCount -= 1;

            Root = Parent;
            Parent = Parent->Parent;
        }

        //
        // If all nodes in the tree have been marked as deleted
        // it is time to delete and deallocate the whole tree.
        //

        if (Root->NodeCount == 0) {

            ViDeadlockDeleteTree (Root);
        }
    }

    //
    // Delete the resource structure.
    //

    ViDeadlockFree (Node->Root);
}


VOID
ViDeadlockDeleteTree (
    PVI_DEADLOCK_NODE Root
    )
{
    PLIST_ENTRY Current;
    PVI_DEADLOCK_NODE Node;

    Current = Root->ChildrenList.Flink;

    while (Current != &(Root->ChildrenList)) {

        Node = CONTAINING_RECORD (Current,
                                  VI_DEADLOCK_NODE,
                       