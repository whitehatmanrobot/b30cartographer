_ONLY__
public:
#endif // __KDEXT_ONLY__
    PIKSTRANSPORT m_TransportSource;
    PIKSTRANSPORT m_TransportSink;
    CKsSplitter* m_Splitter;
    PKSPIN m_Pin;
    ULONG m_Offset;
    ULONG m_Size;
    KS_COMPRESSION m_Compression;
    LIST_ENTRY m_ListEntry;
    PLIST_ENTRY m_ListHead;
    INTERLOCKEDLIST_HEAD m_IrpsAvailable;
    ULONG m_IoControlCode;
    ULONG m_StackSize;
    ULONG m_OutstandingIrpCount;

    ULONG m_DataUsed;
    ULONG m_FrameExtent;
    ULONG m_Irps;

public:
    DEFINE_LOG_CONTEXT(m_Log);
    DEFINE_STD_UNKNOWN();

    CKsSplitterBranch(PUNKNOWN OuterUnknown):
        CBaseUnknown(OuterUnknown) {
    }
    ~CKsSplitterBranch();

    IMP_IKsTransport;

    NTSTATUS
    Init(
        IN CKsSplitter* Splitter,
        IN PLIST_ENTRY ListHead,
        IN PKSPIN Pin,
        IN const KSALLOCATOR_FRAMING_EX* AllocatorFraming OPTIONAL
        );
    PIKSTRANSPORT
    GetTransportSource(
        void
        )
    {
        return m_TransportSource;
    };
    PIKSTRANSPORT
    GetTransportSink(
        void
        )
    {
        return m_TransportSink;
    };
    void
    Orphan(
        void
        )
    {
        if (m_Splitter) {
            m_Splitter = NULL;
            RemoveEntryList(&m_ListEntry);
        }
    }
    NTSTATUS
    TransferSubframe(
        IN PKSPSUBFRAME_HEADER SubframeHeader
        );

private:
    PIRP
    AllocateIrp(
        void
        );
    void
    FreeIrp(
        IN PIRP Irp
        )
    {
        IoFreeIrp(Irp);
    }

    friend CKsSplitter;
};

NTSTATUS
KspCreateSplitterBranch(
    OUT CKsSplitterBranch** SplitterBranch,
    IN CKsSplitter* Splitter,
    IN PLIST_ENTRY ListHead,
    IN PKSPIN Pin,
    IN const KSALLOCATOR_FRAMING_EX* AllocatorFraming OPTIONAL
    );

#ifndef __KDEXT_ONLY__

IMPLEMENT_STD_UNKNOWN(CKsSplitter)


NTSTATUS
KspCreateSplitter(
    OUT PIKSSPLITTER* Splitter,
    IN PKSPIN Pin
    )

/*++

Routine Description:

    This routine creates a new splitter.

Arguments:

Return Value:

--*/

{
    _DbgPrintF(DEBUGLVL_BLAB,("[KspCreateSplitter]"));

    PAGED_CODE();

    ASSERT(Splitter);
    ASSERT(Pin);

    NTSTATUS status;

    CKsSplitter *splitter =
        new(NonPagedPool,POOLTAG_SPLITTER) CKsSplitter(NULL);

    if (splitter) {
        splitter->AddRef();

        status = splitter->Init(Pin);

        if (NT_SUCCESS(status)) {
            *Splitter = splitter;
        } else {
            splitter->Release();
        }
    } else {
        status = STATUS_INSUFFICIENT_RESOURCES;
    }

    return status;
}


NTSTATUS
CKsSplitter::
Init(
    IN PKSPIN Pin
    )

/*++

Routine Description:

    This routine initializes a splitter object.

Arguments:

Return Value:

--*/

{
    _DbgPrintF(DEBUGLVL_BLAB,("[CKsSplitter::Init]"));

    PAGED_CODE();

    ASSERT(Pin);

    m_State = KSSTATE_STOP;
    m_Flushing = FALSE;

    InitializeListHead(&m_BranchList);
    InitializeInterlockedListHead(&m_FrameHeadersAvailable);
    InitializeInterlockedListHead(&m_IrpsOutstanding);

    KsLogInitContext(&m_Log,Pin,this);
    KsLog(&m_Log,KSLOGCODE_SPLITTER_CREATE,NULL,NULL);

    return STATUS_SUCCESS;
}


CKsSplitter::
~CKsSplitter(
    void
    )

/*++

Routine Description:

    This routine destructs a splitter object.

Arguments:

    None.

Return Value:

    None.

--*/

{
    _DbgPrintF(DEBUGLVL_BLAB,("[CKsSplitter::~CKsSplitter(0x%08x)]",this));
    _DbgPrintF(DEBUGLVL_VERBOSE,("#### Split%p.~",this));

    PAGED_CODE();

    ASSERT(! m_TransportSink);
    ASSERT(! m_TransportSource);

    //
    // Release all the branches.
    //
    CKsSplitterBranch *prevBranch = NULL;
    while (! IsListEmpty(&m_BranchList)) {
        CKsSplitterBranch *branch =
            CONTAINING_RECORD(m_BranchList.Flink,CKsSplitterBranch,m_ListEntry);

        branch->Orphan();
        branch->Release();

        ASSERT(branch != prevBranch);
        prevBranch = branch;
    }

    KsLog(&m_Log,KSLOGCODE_SPLITTER_DESTROY,NULL,NULL);
}


STDMETHODIMP_(NTSTATUS)
CKsSplitter::
NonDelegatedQueryInterface(
    IN REFIID InterfaceId,
    OUT PVOID* InterfacePointer
    )

/*++

Routine Description:

    This routine obtains an interface to a splitter object.

Arguments:

Return Value:

--*/

{
    _DbgPrintF(DEBUGLVL_BLAB,("[CKsSplitter::NonDelegatedQueryInterface]"));

    PAGED_CODE();

    ASSERT(InterfacePointer);

    NTSTATUS status = STATUS_SUCCESS;

    if (IsEqualGUIDAligned(InterfaceId,__uuidof(IKsTransport)) ||
        IsEqualGUIDAligned(InterfaceId,__uuidof(IKsSplitter))) {
        *InterfacePointer = 
            reinterpret_cast<PVOID>(static_cast<PIKSSPLITTER>(this));
        AddRef();
    } else {
        status = 
            CBaseUnknown::NonDelegatedQueryInterface(
                InterfaceId,InterfacePointer);
    }

    return status;
}

#ifdef ALLOC_PRAGMA
#pragma code_seg()
#endif // ALLOC_PRAGMA


STDMETHODIMP_(NTSTATUS)
CKsSplitter::
TransferKsIrp(
    IN PIRP Irp,
    IN PIKSTRANSPORT* NextTransport
    )

/*++

Routine Description:

    This routine handles the arrival of a streaming IRP.

Arguments:

    Irp -
        Contains a pointer to the streaming IRP to be transferred.

    NextTransport -
        Contains a pointer to a location at which to deposit a pointer
        to the next transport interface to recieve the IRP.  May be set
        to NULL indicating the IRP should not be forwarded further.

Return Value:

    STATUS_PENDING or some error status.

--*/

{
    _DbgPrintF(DEBUGLVL_BLAB,("[CKsSplitter::TransferKsIrp]"));

    ASSERT(Irp);
    ASSERT(NextTransport);

    ASSERT(m_TransportSink);

    KsLog(&m_Log,KSLOGCODE_SPLITTER_RECV,Irp,NULL);

    if (m_State != KSSTATE_RUN) {
        _DbgPrintF(DEBUGLVL_VERBOSE,("#### Split%p.TransferKsIrp:  got IRP %p in state %d",this,Irp,m_State));
    }

    //
    // Shunt non-successful Irps.
    //
    if (!NT_SUCCESS (Irp->IoStatus.Status)) {
        _DbgPrintF(DEBUGLVL_FLOWEXCEPTIONS,("#### Splitter%p.TransferKsIrp:  shunting irp%p",this,Irp));
        KsLog(&m_Log,KSLOGCODE_SPLITTER_SEND,Irp,NULL);
        *NextTransport = m_TransportSink;

        return STATUS_SUCCESS;
    }

    //
    // Get a pointer to the stream header.
    //
    PKSSTREAM_HEADER streamHeader = 
        reinterpret_cast<PKSSTREAM_HEADER>(Irp->AssociatedIrp.SystemBuffer);

    //
    // Get a frame header.
    //
    PKSPPARENTFRAME_HEADER frameHeader = NewFrameHeader(streamHeader->Size);
    if (! frameHeader) {
        _DbgPrintF(DEBUGLVL_TERSE,("#### Split%p.TransferKsIrp:  failed to allocate frame header for IRP %p",this,Irp));
        Irp->IoStatus.Status = STATUS_INSUFFICIENT_RESOURCES;
        KsLog(&m_Log,KSLOGCODE_SPLITTER_SEND,Irp,NULL);
        KspDiscardKsIrp(m_TransportSink,Irp);
        *NextTransport = NULL;
        return STATUS_PENDING;
    }

    //
    // Attach the frame header to the IRP.
    //
    FRAME_HEADER_IRP_STORAGE(Irp) = frameHeader;

    //
    // Initialize the frame header.
    //
    frameHeader->Irp = Irp;
    frameHeader->StreamHeader = streamHeader;
    frameHeader->Data = 
        m_UseMdls ? 
            MmGetSystemAddressForMdl(Irp->MdlAddress) : streamHeader->Data;

    //
    // Initialize the subframe headers.
    //
    PKSSPLITPIN splitPin = frameHeader->SplitPins;
    for(PLIST_ENTRY listEntry = m_BranchList.Flink; 
        listEntry != &m_BranchList; 
        listEntry = listEntry->Flink, splitPin++) {
        CKsSplitterBranch *branch =
            CONTAINING_RECORD(listEntry,CKsSplitterBranch,m_ListEntry);

        RtlCopyMemory(splitPin->StreamHeader,streamHeader,streamHeader->Size);
        splitPin->StreamHeader->Data = frameHeader->Data;

        if (branch->m_Compression.RatioNumerator) {
            splitPin->StreamHeader->FrameExtent = 
                ULONG((ULONGLONG(splitPin->StreamHeader->FrameExtent - 
                                 branch->m_Compression.RatioConstantMargin) * 
                       ULONGLONG(branch->m_Compression.RatioDenominator)) / 
                      ULONGLONG(branch->m_Compression.RatioNumerator));
        }
    }

    //
    // TODO non-trivial subframe
    // TODO multiple frames per IRP
    //
    frameHeader->ChildrenOut = m_BranchCount + 2;

    //
    // Transfer subframes to each branch.
    //
    splitPin = frameHeader->SplitPins;
    for(listEntry = m_BranchList.Flink; 
        listEntry != &m_BranchList; 
        listEntry = listEntry->Flink, splitPin++) {
        CKsSplitterBranch *branch =
            CONTAINING_RECORD(listEntry,CKsSplitterBranch,m_ListEntry);

        branch->TransferSubframe(
            CONTAINING_RECORD(
                splitPin->StreamHeader,
                KSPSUBFRAME_HEADER,
                StreamHeader));
    }

    //
    // Remove the count which prevents parent IRP transfer during setup.  If
    // the result is one, all children have come back.
    //
    if (InterlockedDecrement(PLONG(&frameHeader->ChildrenOut)) == 1) {
        KsLog(&m_Log,KSLOGCODE_SPLITTER_SEND,Irp,NULL);
        DeleteFrameHeader(frameHeader);
        *NextTransport = m_TransportSink;
    } else {
        *NextTransport = NULL;

        //
        // Add the IRP to the list of oustanding parent IRPs.  After this call
        // the IRP is cancelable, but we still have one count on it.  The
        // cancel routine will not complete the IRP until the count is gone.
        //
        IoMarkIrpPending(Irp);
        KsAddIrpToCancelableQueue(
            &m_IrpsOutstanding.ListEntry,
            &m_IrpsOutstanding.SpinLock,
            Irp,
            KsListEntryTail,
            CKsSplitter::CancelRoutine);

        if (InterlockedDecrement(PLONG(&frameHeader->ChildrenOut)) == 0) {
            TransferParentIrp();
        }
    }
    
    return STATUS_PENDING;
}


PKSPPARENTFRAME_HEADER
CKsSplitter::
NewFrameHeader(
    IN ULONG HeaderSize
    )

/*++

Routine Description:

    This routine obtains a new frame header.

Arguments:

    HeaderSize -
        Contains the size in bytes of the KSSTREAM_HEADERs to be allocated
        for subframes.

Return Value:

    A new frame header or NULL if memory could not be allocated.

--*/

{
    _DbgPrintF(DEBUGLVL_BLAB,("[CKsSplitter::NewFrameHeader]"));

    ASSERT(HeaderSize >= sizeof(KSSTREAM_HEADER));
    ASSERT((HeaderSize & FILE_QUAD_ALIGNMENT) == 0);
    ASSERT((sizeof(KSPPARENTFRAME_HEADER) & FILE_QUAD_ALIGNMENT) == 0);
    ASSERT((sizeof(KSPSUBFRAME_HEADER) & FILE_QUAD_ALIGNMENT) == 0);

    //
    // See if there is a frame header already available.
    //
    PLIST_ENTRY listEntry = 
        ExInterlockedRemoveHeadList(
            &m_FrameHeadersAvailable.ListEntry,
            &m_FrameHeadersAvailable.SpinLock);
    //
    // Make sure the stream headers are large enough.
    //
    PKSPPARENTFRAME_HEADER frameHeader;
    if (listEntry) {
        frameHeader = CONTAINING_RECORD(listEntry,KSPPARENTFRAME_HEADER,ListEntry);
        if (frameHeader->StreamHeaderSize >= HeaderSize) {
            return frameHeader;
        }
        ExFreePool(frameHeader);
    }

    //
    // Calculate size of frame/subframes/index
    //
    ULONG subframeHeaderSize =
        sizeof(KSPSUBFRAME_HEADER) + 
        HeaderSize - 
        sizeof(KSSTREAM_HEADER);
    ULONG size =
        sizeof(KSPPARENTFRAME_HEADER) + 
        m_BranchCount * (subframeHeaderSize + sizeof(KSSPLITPIN));

    frameHeader = reinterpret_cast<PKSPPARENTFRAME_HEADER>(
        ExAllocatePoolWithTag(NonPagedPool,size,POOLTAG_FRAMEHEADER));

    if (! frameHeader) {
        return NULL;
    }

    //
    // Zero the whole thing.
    //
    RtlZeroMemory(frameHeader,size);

    //
    // Locate the first subframe header.
    //
    PKSPSUBFRAME_HEADER subframeHeader = 
        reinterpret_cast<PKSPSUBFRAME_HEADER>(frameHeader + 1);

    //
    // Initialize the frame header.
    //
    frameHeader->SplitPins =
        reinterpret_cast<PKSSPLITPIN>(
            reinterpret_cast<PUCHAR>(subframeHeader) + 
                subframeHeaderSize * m_BranchCount);
    frameHeader->StreamHeaderSize = HeaderSize;

    //
    // Initialize the subframe headers and the index.
    //
    PKSSPLITPIN splitPin = frameHeader->SplitPins;
    for(listEntry = m_BranchList.Flink; 
        listEntry != &m_BranchList; 
        listEntry = listEntry->Flink, splitPin++) {
        CKsSplitterBranch *branch =
            CONTAINING_RECORD(listEntry,CKsSplitterBranch,m_ListEntry);
        splitPin->Pin = branch->m_Pin;
        splitPin->StreamHeader = &subframeHeader->StreamHeader;
        subframeHeader->ParentFrameHeader = frameHeader;

        subframeHeader = 
            reinterpret_cast<PKSPSUBFRAME_HEADER>(
                reinterpret_cast<PUCHAR>(subframeHeader) + 
                    subframeHeaderSize);
    }

    return frameHeader;
}


void
CKsSplitter::
DeleteFrameHeader(
    IN PKSPPARENTFRAME_HEADER FrameHeader
    )

/*++

Routine Description:

    This routine releases a frame header.

Arguments:

    FrameHeader -
        Contains a pointer to the frame header to be deleted.

Return Value:

    None.

--*/

{
    _DbgPrintF(DEBUGLVL_BLAB,("[CKsSplitter::NewFrameDeleteFrameHeaderHeader]"));

    ExInterlockedInsertTailList(
        &m_FrameHeadersAvailable.ListEntry,
        &FrameHeader->ListEntry,
        &m_FrameHeadersAvailable.SpinLock);
}


STDMETHODIMP_(void)
CKsSplitter::
DiscardKsIrp(
    IN PIRP Irp,
    IN PIKSTRANSPORT* NextTransport
    )

/*++

Routine Description:

    This routine handles the arrival of a streaming IRP.

Arguments:

    Irp -
        Contains a pointer to the streaming IRP to be discarded.

    NextTransport -
        Contains a pointer to a location at which to deposit a pointer
        to the next transport interface to recieve the IRP.  May be set
        to NULL indicating the IRP should not be forwarded further.

Return Value:

    None.

--*/

{
    _DbgPrintF(DEBUGLVL_BLAB,("[CKsSplitter::DiscardKsIrp]"));

    ASSERT(Irp);
    ASSERT(NextTransport);

    ASSERT(m_TransportSink);

    *NextTransport = m_TransportSink;
}

#ifdef ALLOC_PRAGMA
#pragma code_seg("PAGE")
#endif // ALLOC_PRAGMA


STDMETHODIMP_(void)
CKsSplitter::
Connect(
    IN PIKSTRANSPORT NewTransport OPTIONAL,
    OUT PIKSTRANSPORT *OldTransport OPTIONAL,
    OUT PIKSTRANSPORT *BranchTransport OPTIONAL,
    IN KSPIN_DATAFLOW DataFlow
    )

/*++

Routine Description:

    This routine establishes a transport connection.

Arguments:

Return Value:

--*/

{
    _DbgPrintF(DEBUGLVL_BLAB,("[CKsSplitter::Connect]"));

    PAGED_CODE();

    if (BranchTransport) {
        if (IsListEmpty(&m_BranchList)) {
            *BranchTransport = NULL;
        } else if (DataFlow == KSPIN_DATAFLOW_OUT) {
            *BranchTransport =
                CONTAINING_RECORD(
                    m_BranchList.Flink,
                    CKsSplitterBranch,
                    m_ListEntry);
        } else {
            *BranchTransport =
                CONTAINING_RECORD(
                    m_BranchList.Blink,
                    CKsSplitterBranch,
                    m_ListEntry);
        }
    }

    KspStandardConnect(
        NewTransport,
        OldTransport,
        NULL,
        DataFlow,
        PIKSTRANSPORT(this),
        &m_TransportSource,
        &m_TransportSink);
}


STDMETHODIMP_(NTSTATUS)
CKsSplitter::
SetDeviceState(
    IN KSSTATE NewState,
    IN KSSTATE OldState,
    IN PIKSTRANSPORT* NextTransport
    ) 

/*++

Routine Description:

    This routine handles notification that the device state has changed.

Arguments:

Return Value:

--*/

{
    _DbgPrintF(DEBUGLVL_DEVICESTATE,("#### Split%p.SetDeviceState:  set from %d to %d",this,OldState,NewState));

    PAGED_CODE();

    ASSERT(NextTransport);

    NTSTATUS status;

    //
    // If this is a change of state, note the new state and indicate the next
    // recipient.
    //
    if (m_State != NewState) {
        //
        // The state has changed.
        //
        m_State = NewState;

        if (IsListEmpty(&m_BranchList)) {
            if (NewState > OldState) {
                *NextTransport = m_TransportSink;
            } else {
                *NextTransport = m_TransportSource;
            }
        } else {
            if (NewState > OldState) {
                *NextTransport =
                    CONTAINING_RECORD(
                        m_BranchList.Flink,
                        CKsSplitterBranch,
                        m_ListEntry)->GetTransportSink();
            } else {
                *NextTransport =
                    CONTAINING_RECORD(
                        m_BranchList.Blink,
                        CKsSplitterBranch,
                        m_ListEntry)->GetTransportSource();
            }
        }

        status = STATUS_SUCCESS;
    } else {
        status = STATUS_SUCCESS;
    }

    return status;
}


STDMETHODIMP_(void)
CKsSplitter::
GetTransportConfig(
    OUT PKSPTRANSPORTCONFIG Config,
    OUT PIKSTRANSPORT* NextTransport,
    OUT PIKSTRANSPORT* PrevTransport
    )

/*++

Routine Description:

    This routine gets transport configuration information.

Arguments:

    Config -
        Contains a pointer to the location where configuration requirements
        for this object should be depobranchd.

    NextTransport -
        Contains a pointer to the location at which the next transport
        interface should be depobranchd.

    PrevTransport -
        Contains a pointer to the location at which the previous transport
        interfaction should be depobranchd.

Return Value:

    None.

--*/

{
    _DbgPrintF(DEBUGLVL_BLAB,("[CKsSplitter::GetTransportConfig]"));

    PAGED_CODE();

    ASSERT(Config);
    ASSERT(NextTransport);
    ASSERT(PrevTransport);

    Config->TransportType = KSPTRANSPORTTYPE_SPLITTER;
    Config->IrpDisposition = KSPIRPDISPOSITION_NONE;
    Config->StackDepth = 1;

    if (IsListEmpty(&m_BranchList)) {
        *PrevTransport = m_TransportSource;
        *NextTransport = m_TransportSink;
    } else {
        *PrevTransport =
            CONTAINING_RECORD(
                m_BranchList.Blink,
                CKsSplitterBranch,
                m_ListEntry)->GetTransportSource();
        *NextTransport =
            CONTAINING_RECORD(
                m_BranchList.Flink,
                CKsSplitterBranch,
                m_ListEntry)->GetTransportSink();
    }
}


STDMETHODIMP_(void)
CKsSplitter::
SetTransportConfig(
    IN const KSPTRANSPORTCONFIG* Config,
    OUT PIKSTRANSPORT* NextTransport,
    OUT PIKSTRANSPORT* PrevTransport
    )

/*++

Routine Description:

    This routine sets transport configuration information.

Arguments:

    Config -
        Contains a pointer to the new configuration settings for this object.

    NextTransport -
        Contains a pointer to the location at which the next transport
        interface should be depobranchd.

    PrevTransport -
        Contains a pointer to the location at which the previous transport
        interfaction should be depobranchd.

Return Value:

    None.

--*/

{
    _DbgPrintF(DEBUGLVL_BLAB,("[CKsSplitter::SetTransportConfig]"));

    PAGED_CODE();

    ASSERT(Config);
    ASSERT(NextTransport);
    ASSERT(PrevTransport);

#if DBG
    if (Config->IrpDisposition == KSPIRPDISPOSITION_ROLLCALL) {
        ULONG references = AddRef() - 1; Release();
        DbgPrint("    Split%p refs=%d\n",this,references);
        if (Config->StackDepth) {
            DbgPrint("        IRPs waiting to transfer = %d\n",m_IrpsWaitingToTransfer);
            DbgPrint("        failed removes = %d\n",m_FailedRemoveCount);
            DbgPrint("        IRPs outstanding\n");
            KIRQL oldIrql;
            KeAcquireSpinLock(&m_IrpsOutstanding.SpinLock,&oldIrql);
            for(PLIST_ENTRY listEntry = m_IrpsOutstanding.ListEntry.Flink;
                listEntry != &m_IrpsOutstanding.ListEntry;
                listEntry = listEntry->Flink) {
                    PIRP irp = 
                        CONTAINING_RECORD(listEntry,IRP,Tail.Overlay.ListEntry);
                    PKSPPARENTFRAME_HEADER frameHeader = 
                        FRAME_HEADER_IRP_STORAGE(irp);
                    DbgPrint("            IRP %p, %d branches outstanding\n",irp,frameHeader->ChildrenOut);
                    PKSSPLITPIN splitPin = frameHeader->SplitPins;
                    for (ULONG count = m_BranchCount; count--; splitPin++) {
                        PKSPSUBFRAME_HEADER subframeHeader =
                            CONTAINING_RECORD(splitPin->StreamHeader,KSPSUBFRAME_HEADER,StreamHeader);
                        if (subframeHeader->Irp) {
                            DbgPrint("                branch IRP %p, pin%p\n",subframeHeader->Irp,splitPin->Pin);
                        }
                    }
            }
            KeReleaseSpinLock(&m_IrpsOutstanding.SpinLock,oldIrql);
        }
    } else 
#endif
    {
        m_UseMdls = (Config->IrpDisposition & KSPIRPDISPOSITION_USEMDLADDRESS) != 0;
    }

    if (IsListEmpty(&m_BranchList)) {
        *PrevTransport = m_TransportSource;
        *NextTransport = m_TransportSink;
    } else {
        *PrevTransport =
            CONTAINING_RECORD(
                m_BranchList.Blink,
                CKsSplitterBranch,
                m_ListEntry)->GetTransportSource();
        *NextTransport =
            CONTAINING_RECORD(
                m_BranchList.Flink,
                CKsSplitterBranch,
                m_ListEntry)->GetTransportSink();
    }
}



STDMETHODIMP_(void)
CKsSplitter::
ResetTransportConfig (
    OUT PIKSTRANSPORT* NextTransport,
    OUT PIKSTRANSPORT* PrevTransport
    )

/*++

Routine Description:

    Reset the transport configuration of the splitter.  This indicates that
    something is wrong with the pipe and the previously set configuration is
    no longer valid.

Arguments:

    None

Return Value:

    None

--*/

{

    _DbgPrintF(DEBUGLVL_BLAB,("[CKsSplitter::ResetTransportConfig]"));

    PAGED_CODE ();

    ASSERT (NextTransport);
    ASSERT (PrevTransport);

    m_UseMdls = 0;

    if (IsListEmpty(&m_BranchList)) {
        *PrevTransport = m_TransportSource;
        *NextTransport = m_TransportSink;
    } else {
        *PrevTransport =
            CONTAINING_RECORD(
                m_BranchList.Blink,
                CKsSplitterBranch,
                m_ListEntry)->GetTransportSource();
        *NextTransport =
            CONTAINING_RECORD(
                m_BranchList.Flink,
                CKsSplitterBranch,
                m_ListEntry)->GetTransportSink();
    }
}


STDMETHODIMP_(void)
CKsSplitter::
SetResetState(
    IN KSRESET ksReset,
    IN PIKSTRANSPORT* NextTransport
    )

/*++

Routine Description:

    This routine handles notification that the reset state has changed.

Arguments:

Return Value:

--*/

{
    _DbgPrintF(DEBUGLVL_VERBOSE,("[CKsSplitter::SetResetState] to %d",ksReset));

    PAGED_CODE();

    ASSERT(NextTransport);

    if (m_Flushing != (ksReset == KSRESET_BEGIN)) {
        if (IsListEmpty(&m_BranchList)) {
            *NextTransport = m_TransportSink;
        } else {
            *NextTransport =
                CONTAINING_RECORD(
                    m_BranchList.Flink,
                    CKsSplitterBranch,
                    m_ListEntry)->GetTransportSink();
        }
        m_Flushing = (ksReset == KSRESET_BEGIN);
    } else {
        *NextTransport = NULL;
    }
}

STDMETHODIMP_(NTSTATUS)
CKsSplitter::
AddBranch(
    IN PKSPIN Pin,
    IN const KSALLOCATOR_FRAMING_EX* AllocatorFraming OPTIONAL
    )

/*++

Routine Description:

    This routine adds a new branch (branch) to a splitter.

Arguments:

    Pin -
        Contains a pointer to the pin to be associated with the new branch.

    AllocatorFraming -
        Contains an optional pointer to allocator framing information for
        use in establishing default subframe allocation.

Return Value:

    STATUS_SUCCESS or STATUS_INSUFFICIENT_RESOURCES.

--*/

{
    _DbgPrintF(DEBUGLVL_BLAB,("[CKsSplitter::AddBranch]"));

    ASSERT(Pin);

    CKsSplitterBranch* branch;
    NTSTATUS status = 
        KspCreateSplitterBranch(
            &branch,
            this,
            &m_BranchList,
            Pin,
            AllocatorFraming);

    //
    // The branch is still referenced by the splitter.
    //
    if (NT_SUCCESS(status)) {
        branch->Release();
        m_BranchCount++;
    }

    return status;
}

#ifdef ALLOC_PRAGMA
#pragma code_seg()
#endif // ALLOC_PRAGMA


void
CKsSplitter::
TransferParentIrp(
    void
    )

/*++

Routine Description:

    This routine transfers parent IRPs whose children have all returned.  It
    starts at the head of the m_IrpsOutstanding queue and stops when it runs
    out of IRPs or returns as many IRPs as are waiting to transfer.

Arguments:

    None.

Return Value:

    None.

--*/

{
    _DbgPrintF(DEBUGLVL_BLAB,("[CKsSplitter::TransferParentIrp]"));

    ASSERT(m_TransportSink);
    InterlockedIncrement(&m_IrpsWaitingToTransfer);

    while (m_IrpsWaitingToTransfer) {
        //
        // Get an IRP from the head of the queue.
        //
        PIRP irp =
            KsRemoveIrpFromCancelableQueue(
                &m_IrpsOutstanding.ListEntry,
                &m_IrpsOutstanding.SpinLock,
                KsListEntryHead,
                KsAcquireOnly);

        //
        // If none were available, quit.
        //
        if (! irp) {
            InterlockedIncrement(&m_FailedRemoveCount);
            break;
        }

        //
        // Determine if the IRP is ready to be transferred.
        //
        PKSPPARENTFRAME_HEADER frameHeader = FRAME_HEADER_IRP_STORAGE(irp);
        if (InterlockedCompareExchange(PLONG(&frameHeader->ChildrenOut),1,0) == 0) {
            //
            // This IRP is ready to be transferred.  Remove it, delete its header,
            // transfer it, and decrement the waiting count.
            //
            KsRemoveSpecificIrpFromCancelableQueue(irp);
            DeleteFrameHeader(frameHeader);
            KsLog(&m_Log,KSLOGCODE_SPLITTER_SEND,irp,NULL);
            KspTransferKsIrp(m_TransportSink,irp);
            InterlockedDecrement(&m_IrpsWaitingToTransfer);
        } else {
            //
            // This IRP has children out.
            //
            KsReleaseIrpOnCancelableQueue(irp,CKsSplitter::CancelRoutine);
            break;
        }
    }
}


void
CKsSplitter::
CancelRoutine(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
{
    ASSERT(DeviceObject);
    ASSERT(Irp);

    //
    // Mark the IRP cancelled and call the standard routine.  Doing the
    // marking first has the effect of not completing the IRP in the standard
    // routine.  The standard routine removes the IRP from the queue and
    // releases the cancel spin lock.
    //
    Irp->IoStatus.Status = STATUS_CANCELLED;
    KsCancelRoutine(DeviceObject,Irp);

    //
    // TODO:  Cancel child IRPs
    //

    IoCompleteRequest(Irp,IO_NO_INCREMENT);
}

#ifdef ALLOC_PRAGMA
#pragma code_seg("PAGE")
#endif // ALLOC_PRAGMA

IMPLEMENT_STD_UNKNOWN(CKsSplitterBranch)


NTSTATUS
KspCreateSplitterBranch(
    OUT CKsSplitterBranch** SplitterBranch,
    IN CKsSplitter* Splitter,
    IN PLIST_ENTRY ListHead,
    IN PKSPIN Pin,
    IN const KSALLOCATOR_FRAMING_EX* AllocatorFraming OPTIONAL
    )

/*++

Routine Description:

    This routine creates a new splitter branch.

Arguments:

Return Value:

--*/

{
    _DbgPrintF(DEBUGLVL_BLAB,("[KspCreateSplitterBranch]"));

    PAGED_CODE();

    ASSERT(SplitterBranch);
    ASSERT(Splitter);
    ASSERT(ListHead);
    ASSERT(Pin);

    NTSTATUS status;

    CKsSplitterBranch *branch =
        new(NonPagedPool,POOLTAG_SPLITTERBRANCH) CKsSplitterBranch(NULL);

    if (branch) {
        branch->AddRef();

        status = branch->Init(Splitter,ListHead,Pin,AllocatorFraming);

        if (NT_SUCCESS(status)) {
            *SplitterBranch = branch;
        } else {
            branch->Release();
        }
    } else {
        status = STATUS_INSUFFICIENT_RESOURCES;
    }

    return status;
}


NTSTATUS
CKsSplitterBranch::
Init(
    IN CKsSplitter* Splitter,
    IN PLIST_ENTRY ListHead,
    IN PKSPIN Pin,
    IN const KSALLOCATOR_FRAMING_EX* AllocatorFraming OPTIONAL
    )

/*++

Routine Description:

    This routine initializes a splitter branch object.

Arguments:

Return Value:

--*/

{
    _DbgPrintF(DEBUGLVL_BLAB,("[CKsSplitterBranch::Init]"));

    PAGED_CODE();

    ASSERT(Splitter);
    ASSERT(ListHead);
    ASSERT(Pin);

    m_Splitter = Splitter;
    m_ListHead = ListHead;
    m_Pin = Pin;
    m_IoControlCode = 
        (Pin->DataFlow == KSPIN_DATAFLOW_IN) ? 
            IOCTL_KS_READ_STREAM : 
            IOCTL_KS_WRITE_STREAM;

    if (AllocatorFraming &&
        (AllocatorFraming->OutputCompression.RatioNumerator > 
         AllocatorFraming->OutputCompression.RatioDenominator)) {
        m_Compression = AllocatorFraming->OutputCompression;
    }

    InitializeInterlockedListHead(&m_IrpsAvailable);

    //
    // Add this branch to the list and add the resulting reference.
    //
    InsertTailList(ListHead,&m_ListEntry);
    AddRef();

    //
    // Connect to the pin in both directions.
    //
    PIKSTRANSPORT pinTransport =
        CONTAINING_RECORD(Pin,KSPIN_EXT,Public)->Interface;

    Connect(pinTransport,NULL,NULL,KSPIN_DATAFLOW_IN);
    Connect(pinTransport,NULL,NULL,KSPIN_DATAFLOW_OUT);

    KsLogInitContext(&m_Log,Pin,this);
    KsLog(&m_Log,KSLOGCODE_BRANCH_CREATE,NULL,NULL);

    return STATUS_SUCCESS;
}


CKsSplitterBranch::
~CKsSplitterBranch(
    void
    )

/*++

Routine Description:

    This routine destructs a splitter branch object.

Arguments:

Return Value:

--*/

{
    _DbgPrintF(DEBUGLVL_BLAB,("[CKsSplitterBranch::~CKsSplitterBranch(0x%08x)]",this));
    _DbgPrintF(DEBUGLVL_VERBOSE,("#### Branch%p.~",this));
    if (m_DataUsed) {
        _DbgPrintF(DEBUGLVL_VERBOSE,("#### Branch%p.~:  m_DataUsed=%d",this,m_DataUsed));
    }
    if (m_FrameExtent) {
        _DbgPrintF(DEBUGLVL_VERBOSE,("#### Branch%p.~:  m_FrameExtent=%d",this,m_FrameExtent));
    }
    if (m_Irps) {
        _DbgPrintF(DEBUGLVL_VERBOSE,("#### Branch%p.~:  m_Irps=%d",this,m_Irps));
    }

    PAGED_CODE();

    ASSERT(! m_TransportSink);
    ASSERT(! m_TransportSource);

    Orphan();

    //
    // Free all IRPs.
    //
    while (! IsListEmpty(&m_IrpsAvailable.ListEntry)) {
        PLIST_ENTRY listEntry = RemoveHeadList(&m_IrpsAvailable.ListEntry);
        PIRP irp = CONTAINING_RECORD(listEntry,IRP,Tail.Overlay.ListEntry);
        FreeIrp(irp);
        _DbgPrintF(DEBUGLVL_VERBOSE,("#### Branch%p.~:  freeing IRP %p",this,irp));
    }

    KsLog(&m_Log,KSLOGCODE_BRANCH_DESTROY,NULL,NULL);
}


STDMETHODIMP_(NTSTATUS)
CKsSplitterBranch::
NonDelegatedQueryInterface(
    IN REFIID InterfaceId,
    OUT PVOID* InterfacePointer
    )

/*++

Routine Description:

    This routine obtains an interface to a splitter branch object.

Arguments:

Return Value:

--*/

{
    _DbgPrintF(DEBUGLVL_BLAB,("[CKsSplitterBranch::NonDelegatedQueryInterface]"));

    PAGED_CODE();

    ASSERT(InterfacePointer);

    NTSTATUS status = STATUS_SUCCESS;

    if (IsEqualGUIDAligned(InterfaceId,__uuidof(IKsTransport))) {
        *InterfacePointer = 
            reinterpret_cast<PVOID>(static_cast<PIKSTRANSPORT>(this));
        AddRef();
    } else {
        status = 
            CBaseUnknown::NonDelegatedQueryInterface(
                InterfaceId,InterfacePointer);
    }

    return status;
}

#ifdef ALLOC_PRAGMA
#pragma code_seg()
#endif // ALLOC_PRAGMA


STDMETHODIMP_(NTSTATUS)
CKsSplitterBranch::
TransferKsIrp(
    IN PIRP Irp,
    IN PIKSTRANSPORT* NextTransport
    )

/*++

Routine Description:

    This routine handles the arrival of a streaming IRP.

Arguments:

    Irp -
        Contains a pointer to the streaming IRP to be transferred.

    NextTransport -
        Contains a pointer to a location at which to deposit a pointer
        to the next transport interface to recieve the IRP.  May be set
        to NULL indicating the IRP should not be forwarded further.

Return Value:

    STATUS_PENDING or some error status.

--*/

{
    _DbgPrintF(DEBUGLVL_BLAB,("[CKsSplitterBranch::TransferKsIrp]"));

    ASSERT(Irp);
    ASSERT(NextTransport);

    ASSERT(m_TransportSink);

    KsLog(&m_Log,KSLOGCODE_BRANCH_RECV,Irp,NULL);

    InterlockedDecrement(PLONG(&m_OutstandingIrpCount));

    //
    // Get the subframe header from the imbedded stream header.
    //
    PKSPSUBFRAME_HEADER subframeHeader = 
        CONTAINING_RECORD(
            Irp->AssociatedIrp.SystemBuffer,KSPSUBFRAME_HEADER,StreamHeader);

    //
    // Make sure the parent header's DataUsed is no smaller than the offset of
    // this subframe plus its DataUsed.
    //
    // TODO:  The client should be able to do this.  The default would be
    // cheaper to calculate if the subframe with the largest offset was
    // tagged in advance.
    //
    ULONG dataUsed =
        subframeHeader->StreamHeader.DataUsed +
        ULONG(
            PUCHAR(subframeHeader->StreamHeader.Data) - 
            PUCHAR(subframeHeader->ParentFrameHeader->Data));

    PKSSTREAM_HEADER parentHeader =
        subframeHeader->ParentFrameHeader->StreamHeader;
    if (parentHeader->DataUsed < dataUsed) {
        parentHeader->DataUsed = dataUsed;
    }

    parentHeader->OptionsFlags |= 
        subframeHeader->StreamHeader.OptionsFlags & 
            KSSTREAM_HEADER_OPTIONSF_ENDOFSTREAM;

    //
    // Free MDL(s).
    //
    PMDL nextMdl;
    for (PMDL mdl = Irp->MdlAddress; mdl != NULL; mdl = nextMdl) {
        nextMdl = mdl->Next;

        if (mdl->MdlFlags & MDL_PAGES_LOCKED) {
            MmUnlockPages(mdl);
        }
        IoFreeMdl(mdl);
    }

    Irp->MdlAddress = NULL;

    //
    // Put the IRP on the list of available IRPs.  Do this before transferring
    // the parent in case the transfer results in the arrival of another
    // parent.
    //
    ExInterlockedInsertTailList(
        &m_IrpsAvailable.ListEntry,
        &Irp->Tail.Overlay.ListEntry,
        &m_IrpsAvailable.SpinLock);

    subframeHeader->Irp = NULL;

    //
    // If this was the last subframe, the parent IRP must be transferred.
    //
    if (InterlockedDecrement(PLONG(&subframeHeader->ParentFrameHeader->ChildrenOut)) == 0) {
        m_Splitter->TransferParentIrp();
    }

    //
    // The child IRP is not going anywhere right now.
    //
    *NextTransport = NULL;

    return STATUS_PENDING;
}


STDMETHODIMP_(void)
CKsSplitterBranch::
DiscardKsIrp(
    IN PIRP Irp,
    IN PIKSTRANSPORT* NextTransport
    )

/*++

Routine Description:

    This routine handles the arrival of a streaming IRP.

Arguments:

    Irp -
        Contains a pointer to the streaming IRP to be discarded.

    NextTransport -
        Contains a pointer to a location at which to deposit a pointer
        to the next transport interface to recieve the IRP.  May be set
        to NULL indicating the IRP should not be forwarded further.

Return Value:

    None.

--*/

{
    _DbgPrintF(DEBUGLVL_BLAB,("[CKsSplitterBranch::DiscardKsIrp]"));
    _DbgPrintF(DEBUGLVL_VERBOSE,("#### Branch%p.DiscardKsIrp:  %p",this,Irp));

    ASSERT(Irp);
    ASSERT(NextTransport);

    TransferKsIrp(Irp,NextTransport);
}

#ifdef ALLOC_PRAGMA
#pragma code_seg("PAGE")
#endif // ALLOC_PRAGMA


STDMETHODIMP_(void)
CKsSplitterBranch::
Connect(
    IN PIKSTRANSPORT NewTransport OPTIONAL,
    OUT PIKSTRANSPORT *OldTransport OPTIONAL,
    OUT PIKSTRANSPORT *BranchTransport OPTIONAL,
    IN KSPIN_DATAFLOW DataFlow
    )

/*++

Routine Description:

    This routine establishes a transport connection.

Arguments:

Return Value:

--*/

{
    _DbgPrintF(DEBUGLVL_BLAB,("[CKsSplitterBranch::Connect]"));

    PAGED_CODE();

    if (BranchTransport) {
        if (! m_Splitter) {
            *BranchTransport = NULL;
        } else if (DataFlow == KSPIN_DATAFLOW_OUT) {
            if (m_ListEntry.Flink != m_ListHead) {
                *BranchTransport =
                    CONTAINING_RECORD(
                        m_ListEntry.Flink,
                        CKsSplitterBranch,
                        m_ListEntry);
            } else {
                *BranchTransport = NULL;
            }
        } else {
            if (m_ListEntry.Blink != m_ListHead) {
                *BranchTransport =
                    CONTAINING_RECORD(
                        m_ListEntry.Blink,
                        CKsSplitterBranch,
                        m_ListEntry);
            } else {
                *BranchTransport = NULL;
            }
        }
    }

    KspStandardConnect(
        NewTransport,
        OldTransport,
        NULL,
        DataFlow,
        PIKSTRANSPORT(this),
        &m_TransportSource,
        &m_TransportSink);
}


STDMETHODIMP_(NTSTATUS)
CKsSplitterBranch::
SetDeviceState(
    IN KSSTATE NewState,
    IN KSSTATE OldState,
    IN PIKSTRANSPORT* NextTransport
    ) 

/*++

Routine Description:

    This routine handles notification that the device state has changed.

Arguments:

Return Value:

--*/

{
    _DbgPrintF(DEBUGLVL_DEVICESTATE,("#### SplitBranch%p.SetDeviceState:  set from %d to %d",this,OldState,NewState));

    PAGED_CODE();

    ASSERT(NextTransport);

    //
    // Direction is based on sign of the state delta.
    //
    if (NewState > OldState) {
        //
        // If there is a next branch, go to its sink, otherwise go to the
        // splitter's sink.
        //
        if (m_ListEntry.Flink != m_ListHead) {
            *NextTransport =
                CONTAINING_RECORD(
                    m_ListEntry.Flink,
                    CKsSplitterBranch,
                    m_ListEntry)->GetTransportSink();
        } else {
            *NextTransport = m_Splitter->GetTransportSink();
        }
    } else {
        //
        // If there is a next branch, go to its source, otherwise go to the
        // splitter's source.
        //
        if (m_ListEntry.Blink != m_ListHead) {
            *NextTransport =
                CONTAINING_RECORD(
                    m_ListEntry.Blink,
                    CKsSplitterBranch,
                    m_ListEntry)->GetTransportSource();
        } else {
            *NextTransport = m_Splitter->GetTransportSource();
        }
    }

    return STATUS_SUCCESS;
}


STDMETHODIMP_(void)
CKsSplitterBranch::
GetTransportConfig(
    OUT PKSPTRANSPORTCONFIG Config,
    OUT PIKSTRANSPORT* NextTransport,
    OUT PIKSTRANSPORT* PrevTransport
    )

/*++

Routine Description:

    This routine gets transport configuration information.

Arguments:

    Config -
        Contains a pointer to the location where configuration requirements
        for this object should be depobranchd.

    NextTransport -
        Contains a pointer to the location at which the next transport
        interface should be depobranchd.

    PrevTransport -
        Contains a pointer to the location at which the previous transport
        interfaction should be depobranchd.

Return Value:

    None.

--*/

{
    _DbgPrintF(DEBUGLVL_BLAB,("[CKsSplitterBranch::GetTransportConfig]"));

    PAGED_CODE();

    ASSERT(Config);
    ASSERT(NextTransport);
    ASSERT(PrevTransport);

    Config->TransportType = KSPTRANSPORTTYPE_SPLITTERBRANCH;
    Config->IrpDisposition = KSPIRPDISPOSITION_NONE;
    Config->StackDepth = 1;

    if (m_ListEntry.Blink != m_ListHead) {
        *PrevTransport =
            CONTAINING_RECORD(
                m_ListEntry.Blink,
                CKsSplitterBranch,
                m_ListEntry)->GetTransportSource();
    } else {
        Config->StackDepth = KSPSTACKDEPTH_FIRSTBRANCH;
        *PrevTransport = m_Splitter->GetTransportSource();
    }

    if (m_ListEntry.Flink != m_ListHead) {
        *NextTransport =
            CONTAINING_RECORD(
                m_ListEntry.Flink,
                CKsSplitterBranch,
                m_ListEntry)->GetTransportSink();
    } else {
        Config->StackDepth = KSPSTACKDEPTH_LASTBRANCH;
        *NextTransport = m_Splitter->GetTransportSink();
    }
}


STDMETHODIMP_(void)
CKsSplitterBranch::
SetTransportConfig(
    IN const KSPTRANSPORTCONFIG* Config,
    OUT PIKSTRANSPORT* NextTransport,
    OUT PIKSTRANSPORT* PrevTransport
    )

/*++

Routine Description:

    This routine sets transport configuration information.

Arguments:

    Config -
        Contains a pointer to the new configuration settings for this object.

    NextTransport -
        Contains a pointer to the location at which the next transport
        interface should be depobranchd.

    PrevTransport -
        Contains a pointer to the location at which the previous transport
        interfaction should be depobranchd.

Return Value:

    None.

--*/

{
    _DbgPrintF(DEBUGLVL_BLAB,("[CKsSplitterBranch::SetTransportConfig]"));

    PAGED_CODE();

    ASSERT(Config);
    ASSERT(NextTransport);
    ASSERT(PrevTransport);

#if DBG
    if (Config->IrpDisposition == KSPIRPDISPOSITION_ROLLCALL) {
        ULONG references = AddRef() - 1; Release();
        DbgPrint("    Branch%p refs=%d\n",this,references);
    } else 
#endif
    {
        m_StackSize = Config->StackDepth;
        ASSERT(m_StackSize);
    }

    if (m_ListEntry.Blink != m_ListHead) {
        *PrevTransport =
            CONTAINING_RECORD(
                m_ListEntry.Blink,
                CKsSplitterBranch,
                m_ListEntry)->GetTransportSource();
    } else {
        *PrevTransport = m_Splitter->GetTransportSource();
    }

    if (m_ListEntry.Flink != m_ListHead) {
        *NextTransport =
            CONTAINING_RECORD(
                m_ListEntry.Flink,
                CKsSplitterBranch,
                m_ListEntry)->GetTransportSink();
    } else {
        *NextTransport = m_Splitter->GetTransportSink();
    }
}


STDMETHODIMP_(void)
CKsSplitterBranch::
ResetTransportConfig(
    OUT PIKSTRANSPORT* NextTransport,
    OUT PIKSTRANSPORT* PrevTransport
    )

/*++

Routine Description:

    Reset the transport configuration of the branch.  This indicates that
    something is wrong with the pipe and the previously set configuration is
    no longer valid.

Arguments:

    NextTransport -
        Contains a pointer to the location at which the next transport
        interface should be depobranchd.

    PrevTransport -
        Contains a pointer to the location at which the previous transport
        interfaction should be depobranchd.

Return Value:

    None

--*/

{

    _DbgPrintF(DEBUGLVL_BLAB,("[CKsSplitterBranch::ResetTransportConfig]"));

    PAGED_CODE ();

    ASSERT (NextTransport);
    ASSERT (PrevTransport);
    
    m_StackSize = 0;

    if (m_ListEntry.Blink != m_ListHead) {
        *PrevTransport =
            CONTAINING_RECORD(
                m_ListEntry.Blink,
                CKsSplitterBranch,
                m_ListEntry)->GetTransportSource();
    } else {
        *PrevTransport = m_Splitter->GetTransportSource();
    }

    if (m_ListEntry.Flink != m_ListHead) {
        *NextTransport =
            CONTAINING_RECORD(
                m_ListEntry.Flink,
                CKsSplitterBranch,
                m_ListEntry)->GetTransportSink();
    } else {
        *NextTransport = m_Splitter->GetTransportSink();
    }

}


STDMETHODIMP_(void)
CKsSplitterBranch::
SetResetState(
    IN KSRESET ksReset,
    IN PIKSTRANSPORT* NextTransport
    )

/*++

Routine Description:

    This routine handles notification that the reset state has changed.

Arguments:

Return Value:

--*/

{
    _DbgPrintF(DEBUGLVL_VERBOSE,("[CKsSplitterBranch::SetResetState] to %d",ksReset));

    PAGED_CODE();

    ASSERT(NextTransport);

    //
    // If there is a next branch, go to its sink, otherwise go to the
    // splitter's sink.
    //
    if (m_ListEntry.Flink != m_ListHead) {
        *NextTransport =
            CONTAINING_RECORD(
                m_ListEntry.Flink,
                CKsSplitterBranch,
                m_ListEntry)->GetTransportSink();
    } else {
        *NextTransport = m_Splitter->GetTransportSink();
    }
}

#ifdef ALLOC_PRAGMA
#pragma code_seg()
#endif // ALLOC_PRAGMA


NTSTATUS
CKsSplitterBranch::
TransferSubframe(
    IN PKSPSUBFRAME_HEADER SubframeHeader
    )

/*++

Routine Description:

    This routine transfers a subframe from a splitter branch.

Arguments:

    SubframeHeader -
        Contains a pointer to the header of the subframe to transfer.

Return Value:

    STATUS_SUCCESS or STATUS_INSUFFICIENT_RESOURCES.

--*/

{
    _DbgPrintF(DEBUGLVL_BLAB,("[CKsSplitterBranch::TransferSubframe]"));

    ASSERT(SubframeHeader);

    //
    // Count stuff.
    //
    m_DataUsed += SubframeHeader->StreamHeader.DataUsed;
    m_FrameExtent += SubframeHeader->StreamHeader.FrameExtent;
    m_Irps++;

    //
    // Get an IRP from the branch's lookaside list.
    //
    PLIST_ENTRY listEntry = 
        ExInterlockedRemoveHeadList(
            &m_IrpsAvailable.ListEntry,
            &m_IrpsAvailable.SpinLock);
    PIRP irp;
    if (listEntry) {
        irp = CONTAINING_RECORD(listEntry,IRP,Tail.Overlay.ListEntry);
    } else {
        //
        // Create the IRP now.
        //
        irp = AllocateIrp();

        if (! irp) {
            return STATUS_INSUFFICIENT_RESOURCES;
        }
        _DbgPrintF(DEBUGLVL_VERBOSE,("#### Branch%p.TransferSubframe:  allocated IRP %p",this,irp));
    }

    irp->IoStatus.Status = STATUS_SUCCESS;
    irp->IoStatus.Information = 0;
    irp->PendingReturned = 0;
    irp->Cancel = 0;

    //
    // Transfer the IRP to the next component.
    //
    SubframeHeader->Irp = irp;
    irp->AssociatedIrp.SystemBuffer =
        irp->UserBuffer = 
            &SubframeHeader->StreamHeader;
    IoGetCurrentIrpStackLocation(irp)->
        Parameters.DeviceIoControl.OutputBufferLength = 
            SubframeHeader->StreamHeader.Size;
    InterlockedIncrement(PLONG(&m_OutstandingIrpCount));

    KsLog(&m_Log,KSLOGCODE_BRANCH_SEND,irp,NULL);

    return KspTransferKsIrp(m_TransportSink,irp);
}


PIRP
CKsSplitterBranch::
AllocateIrp(
    void
    )

/*++

Routine Description:

    This routine allocates a new IRP for subframe transfer.

Arguments:

    None.

Return Value:

    The allocated IRP or NULL if an IRP could not be allocated.

--*/
{
    _DbgPrintF(DEBUGLVL_BLAB,("[CKsSplitterBranch::AllocateIrp]"));

    ASSERT(m_StackSize);
    PIRP irp = IoAllocateIrp(CCHAR(m_StackSize),FALSE);

    if (irp) {
        _DbgPrintF(DEBUGLVL_VERBOSE,("#### Branch%p.AllocateIrp:  %p",this,irp));
        irp->RequestorMode = KernelMode;
        irp->Flags = IRP_NOCACHE;

        //
        // Set the stack pointer to the first location and fill it in.
        //
        IoSetNextIrpStackLocation(irp);

        PIO_STACK_LOCATION irpSp = IoGetCurrentIrpStackLocation(irp);
        irpSp->MajorFunction = IRP_MJ_DEVICE_CONTROL;
        irpSp->Parameters.DeviceIoControl.IoControlCode = m_IoControlCode;
    }

    return irp;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\ksfilter\ks\guids\sources.inc ===
!IF 0

Copyright (C) Microsoft Corporation, 1999 - 1999

Module Name:

    sources.inc.

!ENDIF

TARGETPATH=obj
TARGETNAME=ksguid
TARGETTYPE=DRIVER_LIBRARY

SOURCES= \
    ..\$(TARGETNAME).c
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\ksfilter\ks\guids\ksguid.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       ksguid.c
//
//--------------------------------------------------------------------------

#include <wdm.h>
#include <windef.h>
#define NOBITMAP
#include <ksguid.h>
#include <mmreg.h>

//
// Create a separate library for the SDK which does not separate the
// guids out from the .text section.
//
#ifdef DDK_KS
#ifdef ALLOC_DATA_PRAGMA
#pragma const_seg("PAGECONST")
#endif // ALLOC_PRAGMA
#endif // SDK_KS

// include swenum.h first so that a separate guid entry is made for the BUSID.
#include <swenum.h>
#include <ks.h>
#include <ksi.h>
#include <ksmedia.h>
#include <ksmediap.h>
#include <ksproxy.h>
// remove this, since basetyps.h defines it again.
#undef DEFINE_GUID
#include <unknown.h>
// set the version to less than 1100 so that guids are defined for the library.
#ifdef _MSC_VER
#undef _MSC_VER
#endif // _MSC_VER
#define _MSC_VER 0
#include <kcom.h>
#include <stdarg.h>

#ifdef ALLOC_DATA_PRAGMA
#pragma const_seg()
#endif // ALLOC_DATA_PRAGMA
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\ksfilter\ks\topology.c ===
/*++

Copyright (C) Microsoft Corporation, 1996 - 1999

Module Name:

    topology.c

Abstract:

    This module contains the helper functions for topology nodes.

--*/

#include "ksp.h"

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, KsCreateTopologyNode)
#pragma alloc_text(PAGE, KspValidateTopologyNodeCreateRequest)
#pragma alloc_text(PAGE, KsValidateTopologyNodeCreateRequest)
#endif // ALLOC_PRAGMA

#ifdef ALLOC_DATA_PRAGMA
#pragma const_seg("PAGECONST")
#endif // ALLOC_DATA_PRAGMA
static const WCHAR NodeString[] = KSSTRING_TopologyNode;
#ifdef ALLOC_DATA_PRAGMA
#pragma const_seg()
#endif // ALLOC_DATA_PRAGMA


KSDDKAPI
NTSTATUS
NTAPI
KsCreateTopologyNode(
    IN HANDLE ParentHandle,
    IN PKSNODE_CREATE NodeCreate,
    IN ACCESS_MASK DesiredAccess,
    OUT PHANDLE NodeHandle
    )
/*++

Routine Description:

    Creates a handle to a topology node instance. This may only be called at
    PASSIVE_LEVEL.

Arguments:

    ParentHandle -
        Contains the handle to the parent on which the node is created.

    NodeCreate -
        Specifies topology node create parameters.

    DesiredAccess -
        Specifies the desired access to the object. This is normally GENERIC_READ
        and/or GENERIC_WRITE.

    NodeHandle -
        Place in which to put the topology node handle.

Return Value:

    Returns STATUS_SUCCESS, else an error on node creation failure.

--*/
{
    PAGED_CODE();
    return KsiCreateObjectType(
        ParentHandle,
        (PWCHAR)NodeString,
        NodeCreate,
        sizeof(*NodeCreate),
        DesiredAccess,
        NodeHandle);
}


KSDDKAPI
NTSTATUS
NTAPI
KspValidateTopologyNodeCreateRequest(
    IN PIRP Irp,
    IN ULONG TopologyNodesCount,
    OUT PKSNODE_CREATE* NodeCreate
    )
/*++

Routine Description:

    Validates the topology node creation request and returns the create
    structure associated with the request.

    This may only be called at PASSIVE_LEVEL.

Arguments:

    Irp -
        Contains the IRP with the node create request being handled.

    TopologyNodesCount -
        The number of topology nodes for the filter in question.
        This is used to validate the create request.

    NodeCreate -
        Place in which to put the node create structure pointer passed to
        the create request.

Return Value:

    Returns STATUS_SUCCESS, else an error.

--*/
{
    NTSTATUS Status;
    ULONG CreateParameterLength;

    PAGED_CODE();
    CreateParameterLength = sizeof(**NodeCreate);
    Status = KsiCopyCreateParameter(
        Irp,
        &CreateParameterLength,
        NodeCreate);
    if (!NT_SUCCESS(Status)) {
        return Status;
    }
    //
    // No flags have been defined yet. Also verify that the node
    // specified is within range.
    //
    if ((*NodeCreate)->CreateFlags ||
        (((*NodeCreate)->Node >= TopologyNodesCount) && ((*NodeCreate)->Node != (ULONG)-1))) {
        return STATUS_INVALID_PARAMETER;
    }
    return STATUS_SUCCESS;
}


KSDDKAPI
NTSTATUS
NTAPI
KsValidateTopologyNodeCreateRequest(
    IN PIRP Irp,
    IN PKSTOPOLOGY Topology,
    OUT PKSNODE_CREATE* NodeCreate
    )
/*++

Routine Description:

    Validates the topology node creation request and returns the create
    structure associated with the request.

    This may only be called at PASSIVE_LEVEL.

Arguments:

    Irp -
        Contains the IRP with the node create request being handled.

    Topology -
        Contains the topology structure associated with the parent object.
        This is used to validate the create request.

    NodeCreate -
        Place in which to put the node create structure pointer passed to
        the create request.

Return Value:

    Returns STATUS_SUCCESS, else an error.

--*/
{
    PAGED_CODE();
    return KspValidateTopologyNodeCreateRequest(
        Irp,
        Topology->TopologyNodesCount,
        NodeCreate);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\ksfilter\ks\sources.inc ===
!IF 0

Copyright (C) Microsoft Corporation, 1995 - 1999

Module Name:

    sources.inc.

!ENDIF

TARGETNAME=ks
TARGETPATH=obj
TARGETTYPE=EXPORT_DRIVER

TARGETLIBS=$(DDK_LIB_PATH)\ksguid.lib $(SDK_LIB_PATH)\wdmguid.lib

INCLUDES=..

MSC_WARNING_LEVEL=/W3 /WX
C_DEFINES=$(C_DEFINES) -D_WIN32 -D_KSDDK_ -D_COMDDK_ -D_UNICODE -DUNICODE -D_NO_SYS_GUID_OPERATOR_EQ_

LINKER_FLAGS =$(LINKER_FLAGS) -merge:PAGECONST=PAGE

DLLDEF=$(O)\$(TARGETNAME).def

#to avoid new compiler/linker tool to generate reference to_aulldvrm
#which is not supported in ntoskrnl of win2k
!if $(386)
LINKER_FLAGS=$(LINKER_FLAGS) $(SDK_LIB_PATH)\int64.lib
!endif

SOURCES=\
        ..\ks.rc\
        ..\alloc.c\
        ..\api.c\
        ..\automat.cpp\
        ..\busenum.c\
        ..\clock.c\
        ..\connect.c\
        ..\device.c\
        ..\event.c\
        ..\irp.c\
        ..\kcom.cpp\
        ..\method.c\
        ..\property.c\
        ..\shdevice.cpp\
        ..\shffact.cpp\
        ..\shfilt.cpp\
        ..\shmisc.cpp\
        ..\shpin.cpp\
        ..\shpipe.cpp\
        ..\shqueue.cpp\
        ..\shreq.cpp\
        ..\shsplit.cpp\
        ..\thread.c\
        ..\topology.c\
        ..\kslog.cpp
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\ksfilter\ks\kdexts\avsapi.cpp ===
/**************************************************************************

    avsapi.cpp

    --------------------------------------------------

    AVStream debugger extension API

    --------------------------------------------------

    Toss questions at wmessmer

    ==================================================

    Notes to future maintainers:

    1)

        This extension is designed to be usable and supportable under both
        Win9x (RTERM's KD-style extension support) and KD-style debuggers for
        NT.  Because of the differences in debugging information between 9x
        and the various flavors and versions of NT debuggers, I have made
        an attempt to minimize the amount of debug information required from
        the extension.  This has, however, created an interesting situation:

        Most of AVStream relies on C++; this means abstract base classes,
        COM style QI, etc...  Some of the lists maintained (circuits, etc...)
        are maintained through lists of abstract base class pointers.  Due
        to this and my desire to minimize bang (!) interface commands, I have
        written code to identify a class object from an interface pointer.
        This works differently between 9x and NT.  For 9x, it resolves the
        name (to the compiler's mangled name), demangles the name, and
        determines the base class and derived class; there is then an
        enormous switch and type cast from base classes to derived classes.
        KD on the other hand does not return the compiler's mangled name; it
        returns something like class__`vftable'.  Because of the way the
        AVStream classes are organized in that they derive multiply from
        all abstract classes until the last base which is non-abstract, I
        simply walk backwards resolving symbols until they do not resolve
        to a v-table for the current class type.  This works because and ONLY
        because of the layout of AVStream classes.

        If there is ever a time where we have RTTI available, someone should
        modify the code to use this type of information.  The old methodology
        should be kept intact for backwards compatability with previous
        debuggers.

    2)

        I have modified the routines to use a generic tabbing mechanism
        so that things can be printed with more readability.  If you add
        functions or features, please maintain this.

    3)

        Alright, I'm confused.  For one period of time, I had NT debuggers
        returning compiler mangled names instead of __`vftable'.  I guess
        this depends on the class of PDB?  In any case, if you define

            NT_USES_MANGLED_NAMES: use the fully mangled name as opposed 
                to backtracing the __`vftable' method

            NT_MAY_USE_MANGLED_NAMES: try the __`vftable' method first
                If this fails, try the fully mangled name.

**************************************************************************/

#include "kskdx.h"
#include "avsutil.h"

#include "..\shqueue.cpp"
#include "..\shfilt.cpp"
#include "..\shpin.cpp"
#include "..\shdevice.cpp"
#include "..\shreq.cpp"
#include "..\shsplit.cpp"
#include "..\shpipe.cpp"
#include "..\shffact.cpp"

/*************************************************

    UTILITY ROUTINES

        Function:

            HexDump

        Description:

            Hex dump a section of memory.

        Arguments:

            HostAddress -
                Address of the block on the host

            TargetAddress -
                Address of the block on the target

            BufferSize -
                Size of the block

*************************************************/

void
HexDump (
    IN PVOID HostAddress,
    IN ULONG TargetAddress,
    IN ULONG BufferSize
) {

    ULONG Psn;
    PULONG BufUL;

    char StringBuffer[17];

    BufUL = (PULONG)HostAddress;

    dprintf ("Dumping memory %08lx length %ld\n", TargetAddress, BufferSize);

    BufferSize = (BufferSize / 4) + (!!(BufferSize & 0x3));

    Psn = 0;
    while (Psn < BufferSize && !CheckControlC ()) {

        ULONG NPos;

        dprintf ("    0x%08lx : ", (Psn << 2) + (ULONG)TargetAddress);

        for (NPos = 0; NPos < 4 && Psn + NPos < BufferSize; NPos++) 
            dprintf ("0x%08lx ", *(BufUL + Psn + NPos));

        {
            PCHAR ch = (PCHAR)(BufUL + Psn);
            CHAR c;
            ULONG i = 0;

            for (i = 0; i < 16 && Psn + (i >> 2) < BufferSize; i++) {
                c = *(ch + i);
                if (isprint (c))
                    StringBuffer[i] = c;
                else
                    StringBuffer[i] = '.';
            }
            StringBuffer [i] = 0;

            dprintf ("%s", StringBuffer);

        }

        dprintf ("\n");

        Psn += NPos;

    }
}

/*************************************************

    Function:

        is_kernel_address

    Description:

        Check whether or not a specific address is a kernel address.  I
        place this here instead of a literal check to ease moving this
        to 64-bit.

    Arguments:

        Address -
            The address to check

    Return Value:

        TRUE / FALSE as to whether the address is a kernel address

*************************************************/

BOOLEAN
is_kernel_address (
    IN DWORD Address
    )

{

    if (Address >= 0x80000000)
        return TRUE;

    return FALSE;

}

/*************************************************

    Function:

        signature_check

    Description:

        Check for a specific signature in a location.  IE: check
        to see whether a given pointer points to an Irp.

    Arguments:

        Address -
            The address to check (on the target)

        Signature -
            The signature to check for

    Return Value:

        TRUE / FALSE as to whether the object matches the signature

*************************************************/

BOOLEAN
signature_check (
    IN DWORD Address,
    IN SIGNATURE_TYPE Signature
    )

{

    ULONG Result;

    switch (Signature) {

        case SignatureIrp:
        {

            CSHORT IrpSign;
            DWORD KAValidation;

            if (!ReadMemory (
                Address + FIELDOFFSET (IRP, Type),
                &IrpSign,
                sizeof (CSHORT),
                &Result)) return FALSE;

            if (IrpSign != IO_TYPE_IRP)
                return FALSE;

            //
            // Because of the context in which this is called, I'm going
            // to verify that the value at address isn't a kernel address.
            // This will hopefully eliminate false positives from 
            // identification.
            //
            if (!ReadMemory (
                Address,
                &KAValidation,
                sizeof (DWORD),
                &Result)) return FALSE;


            if (is_kernel_address (KAValidation))
                return FALSE;

            return TRUE;

            break;
        }

        case SignatureFile:
        {

            CSHORT FileSign;
            DWORD KAValidation;

            if (!ReadMemory (
                Address + FIELDOFFSET (FILE_OBJECT, Type),
                &FileSign,
                sizeof (CSHORT),
                &Result)) return FALSE;

            if (FileSign != IO_TYPE_FILE)
                return FALSE;

            //
            // See comments in SignatureIrp pertaining to this check
            //
            if (!ReadMemory (
                Address,
                &KAValidation,
                sizeof (DWORD),
                &Result)) return FALSE;

            if (is_kernel_address (KAValidation))
                return FALSE;

            return TRUE;

            break;
        }

        default:

            return FALSE;

    }

    return FALSE;

}

/*************************************************

    Function:

        irp_stack_match

    Description:

        Match the current irp stack location major/minor of the
        specified target irp against Major and Minor parameters.

    Arguments:

        Address -
            The address of the irp to match on the target

        Major -
            The major to check for
            (UCHAR)-1 == wildcard

        Minor -
            The minor to check for
            (UCHAR)-1 == wildcard
        

*************************************************/

BOOLEAN irp_stack_match (
    IN DWORD Address,
    IN UCHAR Major,
    IN UCHAR Minor
    )

{

    PIO_STACK_LOCATION IoStackAddr;
    IO_STACK_LOCATION IoStack;
    ULONG Result;
    
    if (!ReadMemory (
        Address + FIELDOFFSET (IRP, Tail.Overlay.CurrentStackLocation),
        &IoStackAddr,
        sizeof (PIO_STACK_LOCATION),
        &Result)) {

        dprintf ("%08lx: unable to read Irp's current stack location!\n",
            Address);
        return FALSE;
    }

    if (!ReadMemory (
        (DWORD)IoStackAddr,
        &IoStack,
        sizeof (IO_STACK_LOCATION),
        &Result)) {

        dprintf ("%08lx: unable to read Irp's current stack!\n", IoStackAddr);
        return FALSE;
    }

    //
    // Check to see whether io stack matches or the caller doesn't care.
    //
    if (
        (Major == IoStack.MajorFunction || Major == (UCHAR)-1) &&
        (Minor == IoStack.MinorFunction || Minor == (UCHAR)-1)
       )
        return TRUE;

    else
        return FALSE;

}

/*************************************************

    STUBS

    The following are stubs to make things work correctly.
    AVStream was not designed with the KD extension in mind.  The
    classes are stored in .CPP files; I need to include the .CPP files
    and because of the base classes, I need kcom.h which means there
    better be ExAllocatePool* and ExFreePool* functions linked somewhere.
    These stubs are specifically to make things work for class stubs to
    access variables from the extension.

*************************************************/

extern "C"
{
PVOID ExAllocatePool (
    IN POOL_TYPE PoolType,
    IN SIZE_T NumberOfBytes
) {

    //
    // This is a stub only to allow kcom.h to be included for a stub
    // of CBaseUnknown to make class variable access possible from the 
    // extension.  If anyone calls it, they are broken.
    //
    ASSERT (0);

    return NULL;

}

void ExFreePool (
    IN PVOID Address
) {

    //
    // This is a stub only to allow kcom.h to be included for a stub
    // of CBaseUnknown to make class variable access possible from the 
    // extension.  If anyone calls it, they are broken.
    //
    ASSERT (0);

}
}

/*************************************************

    HACKS ...  err make that INTERESTING WAYS TO GET AROUND
    THINGS WITHOUT MODIFYING PUBLIC HEADERS

*************************************************/

// 
// CFriendlyBaseUnknown is a CBaseUnknown (to the byte) that
// hacks access to m_RefCount.  I will not modify the public ks headers
// with #ifdef KDEXT_ONLY.  The privates is a different story.  The publics,
// well, I just won't.
//
// Note: this must align exactly (and I do mean exactly) with
// CBaseUnknown.  There can be no virtuals...  no data members...
// nothing...  In order to ensure that, every function will be
// static, non-virtual
//
class CFriendlyBaseUnknown : public CBaseUnknown {

public:

    static LONG GetRefCount (CFriendlyBaseUnknown *FriendlyUnknown) {
        return FriendlyUnknown -> m_RefCount;
    };

};

/*************************************************

    Function:

        GetObjectReferenceCount

    Description:

        Returns the reference count on a given CBaseUnknown on
        the target.  This is a hack since I can't change the public
        ks headers with KDEXT_ONLY.  

    Arguments:

        BaseUnknown -
            A base unknown on the target

    Return Value:

        The reference count of the base unknown


*************************************************/

LONG GetObjectReferenceCount (
    IN CBaseUnknown *BaseUnknown
) {

    ULONG Result;
    CMemory FriendlyUnknownMem (sizeof (CFriendlyBaseUnknown));
    CFriendlyBaseUnknown *FriendlyUnknown = 
        (CFriendlyBaseUnknown *)FriendlyUnknownMem.Get ();

    if (sizeof (CFriendlyBaseUnknown) !=
        sizeof (CBaseUnknown)) {
        dprintf ("FATAL: hacked base unknown doesn't align with non-hacked\n");
        return 0;
    }

    if (!ReadMemory (
        (DWORD)BaseUnknown,
        FriendlyUnknown,
        sizeof (CBaseUnknown),
        &Result)) {

        dprintf ("%08lX: cannot read base unknown!\n", BaseUnknown);
        return 0;
    }

    //
    // Use the hack to get the reference count and return.  The friendly
    // unknown's memory will be deallocated since it falls out of scope.
    //
    return CFriendlyBaseUnknown::GetRefCount (FriendlyUnknown);

}

/*************************************************

    Function:

        GetNodeAutomationTablePointer

    Description:

        Given a public address and a node id, find the automation table
        for the topology node.

    Arguments:

        Public -
            The target address of a public

        NodeId -
            The id of a node

    Return Value:

        A target pointer which points to the automation table for the
        given topology node.

*************************************************/

PKSAUTOMATION_TABLE 
GetNodeAutomationTablePointer (
    IN DWORD Public,
    IN ULONG NodeId
    )

{

    ULONG Result;

    PKSPX_EXT ExtAddr = (PKSPX_EXT)CONTAINING_RECORD (Public, KSPX_EXT, Public);
    KSPX_EXT Ext;

    ULONG NodesCount;
    PKSAUTOMATION_TABLE *NodeTables;

    if (!ReadMemory (
        (DWORD)ExtAddr,
        &Ext,
        sizeof (KSPX_EXT),
        &Result)) {

        dprintf ("%08lx: unable to read public's ext!\n", Public);
        return NULL;
    }

    switch (Ext.ObjectType) {

        case KsObjectTypeDevice:
            //
            // Devices don't have nodes!
            //
            return NULL;

        case KsObjectTypeFilterFactory:
        {

            CKsFilterFactory *Factory = (CKsFilterFactory *)
                CONTAINING_RECORD (ExtAddr, CKsFilterFactory, m_Ext);

            if (!ReadMemory (
                (DWORD)Factory + FIELDOFFSET(CKsFilterFactory, m_NodesCount),
                &NodesCount,
                sizeof (ULONG),
                &Result))
                return NULL;

            if (!ReadMemory (
                (DWORD)Factory + FIELDOFFSET(CKsFilterFactory, 
                    m_NodeAutomationTables),
                &NodeTables,
                sizeof (PKSAUTOMATION_TABLE *),
                &Result))
                return NULL;

            break;

        }

        case KsObjectTypeFilter:
        {

            CKsFilter *Filter = (CKsFilter *)
                CONTAINING_RECORD (ExtAddr, CKsFilter, m_Ext);

            if (!ReadMemory (
                (DWORD)Filter + FIELDOFFSET(CKsFilter, m_NodesCount),
                &NodesCount,
                sizeof (ULONG),
                &Result))
                return NULL;

            if (!ReadMemory (
                (DWORD)Filter + FIELDOFFSET(CKsFilter, 
                    m_NodeAutomationTables),
                &NodeTables,
                sizeof (PKSAUTOMATION_TABLE *),
                &Result))
                return NULL;

            break;

        }

        case KsObjectTypePin:
        {

            CKsPin *Pin = (CKsPin *)
                CONTAINING_RECORD (ExtAddr, CKsPin, m_Ext);

            if (!ReadMemory (
                (DWORD)Pin + FIELDOFFSET(CKsPin, m_NodesCount),
                &NodesCount,
                sizeof (ULONG),
                &Result))
                return NULL;

            if (!ReadMemory (
                (DWORD)Pin + FIELDOFFSET(CKsPin, 
                    m_NodeAutomationTables),
                &NodeTables,
                sizeof (PKSAUTOMATION_TABLE *),
                &Result))
                return NULL;

            break;

        }

        default:

            // ?
            return NULL;

    }

    if (NodeId >= NodesCount)
        return NULL;

    PKSAUTOMATION_TABLE AutomationTable;

    if (!ReadMemory (
        (DWORD)NodeTables + NodeId * sizeof (PKSAUTOMATION_TABLE),
        &AutomationTable,
        sizeof (PKSAUTOMATION_TABLE),
        &Result))
        return FALSE;

    return AutomationTable;

}

/*************************************************

    Function:

        DumpFrameHeader

    Description:

        Given an already read from the target frame header,
        dump it.

    Arguments:

        FrameHeader -
            The frame header to dump [on the host]

        FrameAddress-
            The address of the frame header on the target

        TabDepth -
            The tab depth at which to print the frame header


    Return Value:
        
        None

    Notes:

*************************************************/

void
DumpFrameHeader (
    IN PKSPFRAME_HEADER FrameHeader,
    IN DWORD FrameAddress,
    IN ULONG TabDepth
) 
{

    dprintf ("%sFrame Header %08lx:\n",  Tab (TabDepth), FrameAddress);
    TabDepth++;
    dprintf ("%sNextFrameHeaderInIrp = %08lx\n", 
        Tab (TabDepth),
        FrameHeader -> NextFrameHeaderInIrp);
    dprintf ("%sOriginalIrp = %08lx\n",
        Tab (TabDepth),
        FrameHeader -> OriginalIrp);
    dprintf ("%sMdl = %08lx\n", Tab (TabDepth), FrameHeader -> Mdl);
    dprintf ("%sIrp = %08lx\n", Tab (TabDepth), FrameHeader -> Irp);
    dprintf ("%sIrpFraming = %08lx\n", 
        Tab (TabDepth),
        FrameHeader -> IrpFraming);
    dprintf ("%sStreamHeader = %08lx\n", 
        Tab (TabDepth),
        FrameHeader -> StreamHeader);
    dprintf ("%sFrameBuffer = %08lx\n", 
        Tab (TabDepth),
        FrameHeader -> FrameBuffer);
    dprintf ("%sStreamHeaderSize = %08lx\n",
        Tab (TabDepth), 
        FrameHeader -> StreamHeaderSize);
    dprintf ("%sFrameBufferSize = %08lx\n", 
        Tab (TabDepth),
        FrameHeader -> FrameBufferSize);
    dprintf ("%sContext = %08lx\n", 
        Tab (TabDepth), 
        FrameHeader -> Context);
    dprintf ("%sRefcount = %ld\n", 
        Tab (TabDepth),
        FrameHeader -> RefCount);

}

/*************************************************

    Function:

        DumpStreamPointer

    Description:

        Dump an internal stream pointer structure

    Arguments:

        StreamPointer -
            Points to the stream pointer to dump

        StreamPointerAddress -
            The address of the structure on the target

        Level -
            The level to dump at

        TabDepth -
            The tab depth at which to print this

    Return Value:

        None

    Notes:

*************************************************/

char *StreamPointerStates [] = {
    "unlocked",
    "locked",
    "cancelled",
    "deleted",
    "cancel pending",
    "dead"
};

void
DumpStreamPointer (
    IN PKSPSTREAM_POINTER StreamPointer,
    IN DWORD StreamPointerAddress,
    IN ULONG Level,
    IN ULONG TabDepth
) {

    dprintf ("%sStream Pointer %08lx [Public %08lx]:\n",
        Tab (TabDepth),
        StreamPointerAddress, StreamPointerAddress + 
            FIELDOFFSET(KSPSTREAM_POINTER, Public));
    TabDepth++;
    dprintf ("%sState = %s\n", 
        Tab (TabDepth), 
        StreamPointerStates [StreamPointer -> State]);
    dprintf ("%sStride = %ld\n", Tab (TabDepth), StreamPointer -> Stride);
    dprintf ("%sFrame Header = %08lx\n", 
        Tab (TabDepth),
        StreamPointer -> FrameHeader);
    dprintf ("%sFrame Header Started = %08lx\n",
        Tab (TabDepth),
        StreamPointer -> FrameHeaderStarted);
    dprintf ("%sStream Header = %08lx\n",
        Tab (TabDepth),
        StreamPointer -> Public.StreamHeader);

    //
    // Determine whether or not the queue generates mappings...
    //
    BOOLEAN Mappings = FALSE;
    ULONG Result;
    PKSSTREAM_POINTER_OFFSET Offset;

    if (!ReadMemory (
        (DWORD)((CKsQueue *)StreamPointer -> Queue) +
            FIELDOFFSET (CKsQueue, m_GenerateMappings),
        &Mappings,
        sizeof (BOOLEAN),
        &Result)) {
        dprintf ("%08lx: unable to read queue mappings flag!\n",
            (CKsQueue *)StreamPointer -> Queue);
        return;
    }
    

    if ((DWORD)StreamPointer -> Public.Offset == StreamPointerAddress +
        FIELDOFFSET(KSPSTREAM_POINTER, Public) +
        FIELDOFFSET(KSSTREAM_POINTER, OffsetIn)) {

        Offset = &(StreamPointer -> Public.OffsetIn);

        dprintf ("%s%s = %08lx\n", 
            Tab (TabDepth),
            Mappings ? "Mappings" : "Data",
            StreamPointer -> Public.OffsetIn.Data);
        dprintf ("%sCount = %08lx\n",
            Tab (TabDepth),
            StreamPointer -> Public.OffsetIn.Count);
        dprintf ("%sRemaining = %08lx\n",
            Tab (TabDepth),
            StreamPointer -> Public.OffsetIn.Remaining);

    } else {

        Offset = &(StreamPointer -> Public.OffsetOut);

        dprintf ("%s%s = %08lx\n", 
            Tab (TabDepth),
            Mappings ? "Mappings" : "Data",
            StreamPointer -> Public.OffsetOut.Data);
        dprintf ("%sCount = %08lx\n",
            Tab (TabDepth),
            StreamPointer -> Public.OffsetOut.Count);
        dprintf ("%sRemaining = %08lx\n",
            Tab (TabDepth),
            StreamPointer -> Public.OffsetOut.Remaining);

    }

    //
    // If the dump level is high enough and the queue is a mapped queue,
    // dump out the physical address, byte counts, and alignment of all
    // mappings specified.
    //
    // NOTE: Always advance by the stream pointer's stride because the client
    // could have additional information with each mapping.
    //
    if (Level >= DUMPLVL_HIGHDETAIL && Mappings) {

        dprintf ("%sMappings Remaining:\n", Tab (TabDepth));
        TabDepth++;

        PKSMAPPING MappingAddr = Offset -> Mappings;
        KSMAPPING Mapping;
        ULONG i;

        for (i = 0; i < Offset -> Remaining; i++) {

            if (!ReadMemory (
                (DWORD)MappingAddr,
                &Mapping,
                sizeof (KSMAPPING),
                &Result)) {
                dprintf ("%08lx: could not read mapping!\n",
                    MappingAddr);
                return;
            }
            
            dprintf ("%sPhysical = %08lx, Count = %08lx, Alignment = %08lx\n",
                Tab (TabDepth),
                Mapping.PhysicalAddress.LowPart,
                Mapping.ByteCount,
                Mapping.Alignment
                );

            MappingAddr = (PKSMAPPING)(
                (PUCHAR)MappingAddr + StreamPointer -> Stride
                );

        }

        if (!Offset -> Remaining)
            dprintf ("%sNo mappings remain!\n", Tab (TabDepth));

    }

}

/*************************************************

    Function:

        DumpQueueContents

    Description:
        
        Given the address of a queue object on the target
        machine (QueueObject), dump out the key queue fields
        and the queue's contents.

    Arguments:

        QueueObject -
            The address of the queue object on the target machine

        Level -
            The 0-7 level to dump at

        TabDepth -
            The tab depth at which to print this

    Return Value:

        None

    Notes:

*************************************************/

void
DumpQueueContents (
    IN CKsQueue *QueueObject,
    IN ULONG Level,
    IN ULONG TabDepth
) {

    //
    // The template will do all necessary cleanup when the block falls
    // out of scope.
    //
    CMemoryBlock <CKsQueue> HostQueue;
    
    KSGATE Gate;
    ULONG Result;

    if (!ReadMemory (
        (DWORD)QueueObject,
        HostQueue.Get (),
        sizeof (CKsQueue),
        &Result
    )) {
        dprintf ("FATAL: unable to read queue!\n");
        return;
    }

    dprintf ("Queue %08lx:\n", QueueObject);

    //
    // Dump statistics
    //
    dprintf ("%sFrames Received  : %ld\n"
             "%sFrames Waiting   : %ld\n"
             "%sFrames Cancelled : %ld\n",
             Tab (TabDepth), HostQueue -> m_FramesReceived,
             Tab (TabDepth), HostQueue -> m_FramesWaiting,
             Tab (TabDepth), HostQueue -> m_FramesCancelled);

    if (Level >= DUMPLVL_BEYONDGENERAL)
        dprintf ("%sMaster Pin       : %08lx\n",
            Tab (TabDepth),
            HostQueue -> m_MasterPin);

    //
    // First dump each gate...
    //
    if (HostQueue -> m_AndGate) {
    
        if (!ReadMemory (
            (DWORD)HostQueue -> m_AndGate,
            &Gate,
            sizeof (KSGATE),
            &Result
        )) {
            dprintf ("FATAL: unable to read and gate!\n");
            return;
        }

        dprintf ("%sAnd Gate %08lx : count = %ld, next = %08lx\n",
            Tab (TabDepth),
            HostQueue -> m_AndGate, Gate.Count, Gate.NextGate);
    }
    else {
        dprintf ("%sAnd Gate NULL\n", Tab (TabDepth));
    }

    if (HostQueue -> m_FrameGate) {
        
        if (!ReadMemory (
            (DWORD)HostQueue -> m_FrameGate,
            &Gate,
            sizeof (KSGATE),
            &Result
        )) {
            dprintf ("FATAL: unable to read frame gate!\n");
            return;
        }

        if (HostQueue -> m_FrameGateIsOr) 
            dprintf ("%sFrame Gate [OR] %08lx : count = %ld, next = %08lx\n",
                Tab (TabDepth),
                HostQueue -> m_FrameGate, Gate.Count, Gate.NextGate);
        else
            dprintf ("%sFrame Gate [AND] %08lx : count = %ld, next = %08lx\n",
                Tab (TabDepth),
                HostQueue -> m_FrameGate, Gate.Count, Gate.NextGate);

    } 
    else {
        dprintf ("    Frame Gate NULL\n");
    }

    //
    // Iterate through each frame in the queue and print each frame.
    //
    if (Level >= DUMPLVL_GENERAL)
    {
        KSPFRAME_HEADER FrameHeader;
        DWORD FrameQueueAddress;
        DWORD FrameHeaderAddress;

        FrameQueueAddress = FIELDOFFSET (CKsQueue, m_FrameQueue) +
            (DWORD)QueueObject;

        if ((DWORD)(HostQueue -> m_FrameQueue.ListEntry.Flink) != 
            FrameQueueAddress) {

            FrameHeader.ListEntry.Flink = 
                HostQueue -> m_FrameQueue.ListEntry.Flink;
            do {

                if (!ReadMemory (
                    (FrameHeaderAddress = ((DWORD)FrameHeader.ListEntry.Flink)),
                    &FrameHeader,
                    sizeof (KSPFRAME_HEADER),
                    &Result
                )) {
                    dprintf ("FATAL: Unable to follow frame chain!\n");
                    return;
                }

                DumpFrameHeader (&FrameHeader, FrameHeaderAddress, TabDepth);

            } while ((DWORD)(FrameHeader.ListEntry.Flink) != FrameQueueAddress
                && !CheckControlC ());
        }
    }

    //
    // Iterate through all stream pointers on the queue and print each one.
    //
    if (Level >= DUMPLVL_INTERNAL) 
    {
        KSPSTREAM_POINTER StreamPointer;
        DWORD StreamPointersAddress;
        DWORD StreamPointerAddress;

        dprintf ("\n");

        if (HostQueue -> m_Leading) {
            if (!ReadMemory (
                (DWORD)HostQueue -> m_Leading,
                &StreamPointer,
                sizeof (KSPSTREAM_POINTER),
                &Result
            )) {
                dprintf ("%lx: cannot read leading edge!\n",
                    HostQueue -> m_Leading);
                return;
            }

            dprintf ("%sLeading Edge:\n", Tab (TabDepth));
            DumpStreamPointer (&StreamPointer, (DWORD)HostQueue -> m_Leading,
                Level, TabDepth);
        }
        if (HostQueue -> m_Trailing) {
            if (!ReadMemory (
                (DWORD)HostQueue -> m_Trailing,
                &StreamPointer,
                sizeof (KSPSTREAM_POINTER),
                &Result
            )) {
                dprintf ("%lx: cannot read trailing edge!\n",
                    HostQueue -> m_Trailing);
                return;
            }

            dprintf ("%sTrailing Edge:\n", Tab (TabDepth));
            DumpStreamPointer (&StreamPointer, (DWORD)HostQueue -> m_Trailing,
                Level, TabDepth);
        }

        StreamPointersAddress = FIELDOFFSET (CKsQueue, m_StreamPointers) +
            (DWORD)QueueObject;

        if ((DWORD)(HostQueue -> m_StreamPointers.Flink) !=
            StreamPointersAddress) {

            StreamPointer.ListEntry.Flink =
                HostQueue -> m_StreamPointers.Flink;
            do {

                StreamPointerAddress = (DWORD)CONTAINING_RECORD (
                    StreamPointer.ListEntry.Flink,
                    KSPSTREAM_POINTER,
                    ListEntry);

                if (!ReadMemory (
                    StreamPointerAddress,
                    &StreamPointer,
                    sizeof (KSPSTREAM_POINTER),
                    &Result
                )) {
                    dprintf ("FATAL: Unable to follow stream pointer chain!\n");
                    return;
                }

                DumpStreamPointer (&StreamPointer, StreamPointerAddress,
                    Level, TabDepth);

            } while ((DWORD)(StreamPointer.ListEntry.Flink) !=
                StreamPointersAddress && !CheckControlC ());
        }
    }

}

/*************************************************

    Function:

        DemangleAndAttemptIdentification

    Arguments:

        Address -
            The address of the unknown to attempt identification of

        ObjectAddress -
            The base address of the object adjusted to the descendent class
            ie: if we have an IFoo interface to a CGoo, this will return the
            base address of CGoo which may or not be the same as the base
            address of the IFoo part of CGoo depending on the inheritence
            tree.

        InterfaceType -
            What base class pointer type Address is, if detectable.  If
            it is not an abstract base class pointer, this will
            be InterfaceTypeUnknown

    Return Value:

        The type of Address if identifiable

    Notes:

        We even do it without the PDB....  how nice....

*************************************************/

//
// Just a note....  This is a **HUGE** hack...  The only reason I'm
// doing this is because it's extraordinarilly difficult to access things
// through interfaces from an NT debugger extension. 
//
// Should new object types be added to AVStream objects or new interfaces
// be added, these tables will need to be updated.  Such is the magic
// of trying to write an NT-style debugger extension that will also work
// with RTERM.  (Kick out that PDB info).
// 
typedef struct _OBJECT_MAPPING {

    char *Name;
    INTERNAL_OBJECT_TYPE ObjectType;

} OBJECT_MAPPING, *POBJECT_MAPPING;

OBJECT_MAPPING TypeNamesToIdTypes [] = {
    {"CKsQueue", ObjectTypeCKsQueue},
    {"CKsDevice", ObjectTypeCKsDevice},
    {"CKsFilterFactory", ObjectTypeCKsFilterFactory},
    {"CKsFilter", ObjectTypeCKsFilter},
    {"CKsPin", ObjectTypeCKsPin},
    {"CKsRequestor", ObjectTypeCKsRequestor},
    {"CKsSplitterBranch", ObjectTypeCKsSplitterBranch},
    {"CKsSplitter", ObjectTypeCKsSplitter},
    {"CKsPipeSection", ObjectTypeCKsPipeSection}
};

typedef struct _INTERFACE_MAPPING {
    
    char *Name;
    INTERNAL_INTERFACE_TYPE InterfaceType;

} INTERFACE_MAPPING, *PINTERFACE_MAPPING;

INTERFACE_MAPPING InterfaceNamesToIdTypes [] = {
    {"IKsTransport", InterfaceTypeIKsTransport},
    {"IKsRetireFrame", InterfaceTypeIKsRetireFrame},
    {"IKsPowerNotify", InterfaceTypeIKsPowerNotify},
    {"IKsProcessingObject", InterfaceTypeIKsProcessingObject},
    {"IKsConnection", InterfaceTypeIKsConnection},
    {"IKsDevice", InterfaceTypeIKsDevice},
    {"IKsFilterFactory", InterfaceTypeIKsFilterFactory},
    {"IKsFilter", InterfaceTypeIKsFilter},
    {"IKsPin", InterfaceTypeIKsPin},
    {"IKsPipeSection", InterfaceTypeIKsPipeSection},
    {"IKsRequestor", InterfaceTypeIKsRequestor},
    {"IKsQueue", InterfaceTypeIKsQueue},
    {"IKsSplitter", InterfaceTypeIKsSplitter},
    {"IKsControl", InterfaceTypeIKsControl},
    {"IKsWorkSink", InterfaceTypeIKsWorkSink},
    {"IKsReferenceClock", InterfaceTypeIKsReferenceClock},
    {"INonDelegatedUnknown", InterfaceTypeINonDelegatedUnknown},
    {"IIndirectedUnknown", InterfaceTypeIIndirectedUnknown}
};

char *ObjectNames [] = {
    "Unknown",
    "struct KSPIN",
    "struct KSFILTER",
    "struct KSDEVICE",
    "struct KSFILTERFACTORY",
    "class CKsQueue",
    "class CKsDevice",
    "class CKsFilterFactory",
    "class CKsFilter",
    "class CKsPin",
    "class CKsRequestor",
    "class CKsSplitter",
    "class CKsSplitterBranch",
    "class CKsPipeSection"
};

INTERNAL_OBJECT_TYPE
DemangleAndAttemptIdentification (
    IN DWORD Address,
    OUT PDWORD ObjectAddress,
    OUT PINTERNAL_INTERFACE_TYPE InterfaceType OPTIONAL
) {

    PVOID Vtbl;
    ULONG Result;
    CHAR Buffer[256];
    ULONG Displacement;
    PCHAR StrLoc, BufTrav;
    INTERNAL_OBJECT_TYPE BestGuess;
    INTERNAL_INTERFACE_TYPE IFGuess;
    ULONG i, ID, iID;
    DWORD AddressTrav;

    if (InterfaceType)
        *InterfaceType = InterfaceTypeUnknown;

    //
    // Assume we're looking at a C++ class.  There's gotta be a vtbl pointer
    // here.  Grab it.
    //
    if (!ReadMemory (
        Address,
        &Vtbl,
        sizeof (PVOID),
        &Result
    )) {
        dprintf ("%08lx: unable to read identifying marks!\n", Address);
        return ObjectTypeUnknown;
    }

    #ifdef DEBUG_EXTENSION
        dprintf ("Vtbl = %08lx\n", Vtbl);
    #endif // DEBUG_EXTENSION

    //
    // Here's the tricky part.  First, we resolve the symbol.  If it doesn't
    // resolve, we're done....
    //
    GetSymbol ((LPVOID)Vtbl, Buffer, &Displacement);

    #ifdef DEBUG_EXTENSION
        dprintf ("GetSymbol....  Buffer = [%s], Displacement = %ld\n",
            Buffer, Displacement);
        HexDump (Buffer, 0, 256);
    #endif // DEBUG_EXTENSION

    if (!Buffer [0] || Displacement != 0) {
        // dprintf ("%08lx: unable to identify object!\n", Address);
        return ObjectTypeUnknown;
    }

    //
    // So the symbol resolves...  this is absolutely key.
    //
    
    //
    // First, let's take a quick guess as to what we think this might be.
    //

    #ifdef DEBUG_EXTENSION
        dprintf ("DemangleAndAttemptIdentification: Mangled = [%s]\n", Buffer);
    #endif // DEBUG_EXTENSION

    BestGuess = ObjectTypeUnknown;
    for (i = 0; i < SIZEOF_ARRAY (TypeNamesToIdTypes); i++) 
        if (StrLoc = (strstr (Buffer, TypeNamesToIdTypes [i].Name))) {
            //
            // A key field has been detected.
            //
            BestGuess = TypeNamesToIdTypes [i].ObjectType;
            break;
        }

    //
    // If we didn't even find a key, we're out of luck in identifying this
    // object.
    //
    if (BestGuess == ObjectTypeUnknown) {
        // dprintf ("%08lx: unable to guess object type!\n", Address);
        return ObjectTypeUnknown;
    }

    ID = i;

    //
    // Check the NT methodology for resolution first.  It NT_USES_MANGLED_NAMES
    // is defined, do not make this check.  If NT_MAY_USE_MANGLED_NAMES
    // is defined, make the check.  These defines should be mutually
    // exclusive.
    //
    #if !defined(WIN9X_KS) && !defined(NT_USES_MANGLED_NAMES)

        //
        // Unfortunately, under NT, things work slightly differently.  Whereas
        // RTERM returns the compiler's mangled name, KD returns
        // module!Class__`vftable' for every v-table.  We cannot determine
        // what interface we're pointing at.  So we can't guess on the
        // interface, but we can play games to find the base address of
        // the class...  We're going to scan backwards from the current
        // address resolving names until we find something which isn't a
        // v-table.  The last successfully resolved v-table pointer will be
        // the base class: let's remember this is true because of the fact
        // that all the base classes except for CBaseUnknown are abstract;
        // they have no member data.  If we ever derive an AVStream class
        // from multiple non-abstract bases or derive from a non-abstract
        // base which isn't the last class in the base classes list, this
        // method of finding the base address will fail.  I'd love to know
        // if there's a way to get at the compiler's mangled name from KD.
        // Until then, this is the best I've got.  Yes -- it's chewing gum
        // and duct tape...  but it works....  and that's more than I can say
        // for any other debugging facility for AVStream.
        //

        //
        // ks!Class__`vftable'.  StrLoc points to the C in class.
        //

        //
        // For recent builds of Whistler, this is no longer necessary as the
        // debugger returns the fully mangled name as resolution.
        //

        if (!strstr (StrLoc, "__`vftable'")) {
            BestGuess = ObjectTypeUnknown;

            #ifdef DEBUG_EXTENSION
                dprintf ("%08lx: unable to scan for NT __`vftable' key!\n",
                    Address);
            #endif // DEBUG_EXTENSION

            //
            // Alright, I admit it...  I'm using one of those evil goto 
            // statements.  This happens to facilitate a quick "allow both
            // checks for __`vftable' and mangled resolution".
            //
            #if !defined(NT_MAY_USE_MANGLED_NAMES)
                return ObjectTypeUnknown;
            #else
                goto NTCheckMangledName;
            #endif // NT_MAY_USE_MANGLED_NAMES

        }

        AddressTrav = Address;
        do {

            //
            // Walk backwards....
            //
            AddressTrav -= sizeof (PVOID);

            //
            // If we couldn't successfully read, it's possible that we've gone
            // out of bounds of something and that AddressTrav + sizeof (PVOID)
            // is the base address
            //
            if (!ReadMemory (
                AddressTrav,
                &Vtbl,
                sizeof (PVOID),
                &Result
            )) 
                break;

            //
            // Now we need to check if this is still a v-table pointer.
            //
            GetSymbol ((LPVOID)Vtbl, Buffer, &Displacement);

            //
            // If it didn't resolve, it's not one of our v-table pointers.
            //
            if (!Buffer [0] || Displacement != 0)
                break;

            if (StrLoc = (strstr (Buffer, TypeNamesToIdTypes [ID].Name))) {

                //
                // If we aren't a v-table, we've walked backwards too far.
                //
                if (!strstr (StrLoc, "__`vftable'")) 
                    break;

            } else
                //
                // We couldn't resolve the type we think we are.  We've walked
                // backwards too far.
                //
                break;

            //
            // Continue the loop until something causes us to break out.  At 
            // the point we break, AddressTrav + sizeof (PVOID) should hold
            // the base address of the object we seek.
            //
        } while (1);

        *ObjectAddress = (DWORD)(AddressTrav + sizeof (PVOID));

        if (InterfaceType) {
            //
            // Until I can think of a way to extract this information without
            // being hideous about it, we cannot return IF type under NT
            //
            *InterfaceType = InterfaceTypeUnknown;
        }

        //
        // If we've already identified the class, we don't want to make the
        // attempt below.  
        //
        if (BestGuess != ObjectTypeUnknown)
            return BestGuess;

    #endif // WIN9X_KS etc...

NTCheckMangledName:

    // 
    // Hrmm...  On some machines I've been getting fully mangled names returned
    // and others the classic __`vftable' style of symbols.  See my comments
    // at the top.
    //
    #if defined(WIN9X_KS) || (!defined (WIN9X_KS) && (defined(NT_MAY_USE_MANGLED_NAMES) || defined(NT_USES_MANGLED_NAMES)))
    
        //
        // Ok, so we found a key in the name.  Now we need to ensure for C++
        // objects that this is some v-table and not some function pointer
        // inside the class.
        //
        // Scan backwards and make sure this is really a v-table pointer
        // Mangle syntax ... ??somethingKEY
        //
        i = StrLoc - Buffer;
        if (!i || i == 1) {
            //
            // This isn't really what we thought it was.  I have no clue why;
            // this is more of a sanity check.
            //
            // dprintf ("%08lx: object might have something to do with %s, "
            //    "but I am unsure!\n", Address, TypeNamesToIdTypes [ID].Name);
            return ObjectTypeUnknown;
        }
        do {
            if (Buffer [i] == '?' && Buffer [i - 1] == '?')
                break;
        } while (--i);
        if (i <= 1) {
            //
            // Same as above.  We didn't find the ?? key
            //
            //dprintf ("%08lx: object might have something to do with %s, "
            //    "but I am unsure!\n", Address, TypeNamesToIdTypes [ID].Name);
            return ObjectTypeUnknown;
        }
    
        // 
        // Next, make sure this is really a v-table pointer again by searching
        // for @@ after the CKs* key name
        //
        BufTrav = StrLoc + strlen (TypeNamesToIdTypes [ID].Name);
        if (*BufTrav == 0 || *(BufTrav + 1) == 0 || *(BufTrav + 2) == 0 || 
            *BufTrav != '@' || *(BufTrav + 1) != '@') {
            // dprintf ("%08lx: object might have something to do with %s, "
            //    "but I am unsure!\n", Address, TypeNamesToIdTypes [ID].Name);
            return ObjectTypeUnknown;
        }
    
        //
        // Ok ... we're relatively sure that we now have a **ONE** of the 
        // v-table pointers into a CKs* identified by BestGuess.  The key now 
        // is to determine whether we have the root pointer to CKs* or a 
        // pointer to a v-table of a base class of CKs*.  This is yet another 
        // layer of demangling.  Don't you love NT-style debugger extensions?
        //
        BufTrav++; BufTrav++;
    
        #ifdef DEBUG_EXTENSION
            dprintf ("Attempting interface identification : BufTrav = [%s]\n",
                BufTrav);
        #endif // DEBUG_EXTENSION
    
        IFGuess = InterfaceTypeUnknown;
        for (i = 0; i < SIZEOF_ARRAY (InterfaceNamesToIdTypes); i++) 
            if (StrLoc = (strstr (BufTrav, InterfaceNamesToIdTypes [i].Name))) {
                //
                // A key field has been detected.
                //
                IFGuess = InterfaceNamesToIdTypes [i].InterfaceType;
                break;
            }
    
        #ifdef DEBUG_EXTENSION
            dprintf ("IFGuess = %ld\n", IFGuess);
        #endif // DEBUG_EXTENSION
    
        if (IFGuess == InterfaceTypeUnknown) {
            //
            // If we didn't find an interface field, we're reasonably sure that
            // BestGuess is the object and that Address is truly the base 
            // pointer.
            //
            *ObjectAddress = Address;
            return BestGuess;
        }
    
        iID = i;
    
        //
        // Otherwise, we likely have found an interface pointer to some derived
        // class.  Let's pray I get this right....
        //
        i = StrLoc - BufTrav;
        while (i) {
            if (BufTrav [i] == '@') {
                // dprintf ("%08lx: object might have something to do with %s "
                // "and %s, but I am unsure", Address,
                //    TypeNamesToIdTypes [ID].Name,
                //    InterfaceNamesToIdTypes [iID].Name);
                return ObjectTypeUnknown;
            }
            i--;
        }
    
        //
        // At this point, we're reasonably sure that we have an IFGuess 
        // interface pointer to a BestGuess object.  Now here comes the 
        // switch statement: upcast the interface.
        //
        // MUSTCHECK: is there an issue with unknown pointers?  If we inherit
        // from two base interfaces which both inherit from the unknowns non
        // virtually...  will this work?
        // 
        switch (BestGuess) {
    
            //
            // Cast the appropriate interface to the base for
            // CKsQueue
            //
            case ObjectTypeCKsQueue:
    
                switch (IFGuess) {
    
                    case InterfaceTypeIKsQueue:
    
                        *ObjectAddress =
                            (DWORD)(
                                (CKsQueue *)(
                                    (IKsQueue *)Address
                                )
                            );
    
                        break;
    
                    case InterfaceTypeIKsTransport:
    
                        *ObjectAddress =
                            (DWORD)(
                                (CKsQueue *)(
                                    (IKsTransport *)Address
                                )
                            );
    
                        break;
    
                    case InterfaceTypeINonDelegatedUnknown:
    
                        *ObjectAddress =
                            (DWORD)(
                                (CKsQueue *)(
                                    (INonDelegatedUnknown *)Address
                                )
                            );
    
                        break;
    
                    case InterfaceTypeIIndirectedUnknown:
    
                        *ObjectAddress =
                            (DWORD)(
                                (CKsQueue *)(
                                    (IIndirectedUnknown *)Address
                                )
                            );
    
                        break;
    
                    
                    default:
    
                        BestGuess = ObjectTypeUnknown;
                        break;
    
                }
    
                break;
    
            //
            // Cast the appropriate interface to the base for
            // CKsDevice
            //
            case ObjectTypeCKsDevice:
    
                switch (IFGuess) {
    
                    case InterfaceTypeIKsDevice:
    
                        *ObjectAddress =
                            (DWORD)(
                                (CKsDevice *)(
                                    (IKsDevice *)Address
                                )
                            );
    
                        break;
    
                    case InterfaceTypeINonDelegatedUnknown:
    
                        *ObjectAddress =
                            (DWORD)(
                                (CKsDevice *)(
                                    (INonDelegatedUnknown *)Address
                                )
                            );
    
                        break;
    
                    case InterfaceTypeIIndirectedUnknown:
    
                        *ObjectAddress =
                            (DWORD)(
                                (CKsDevice *)(
                                    (IIndirectedUnknown *)Address
                                )
                            );
    
                        break;
    
    
                    default:
    
                        BestGuess = ObjectTypeUnknown;
                        break;
    
                }
    
                break;
    
            case ObjectTypeCKsFilterFactory:
    
                switch (IFGuess) {
    
                    case InterfaceTypeIKsFilterFactory:
    
                        *ObjectAddress =
                            (DWORD)(
                                (CKsFilterFactory *)(
                                    (IKsFilterFactory *)Address
                                )
                            );
    
                        break;
    
                    case InterfaceTypeIKsPowerNotify:
    
                        *ObjectAddress =
                            (DWORD)(
                                (CKsFilterFactory *)(
                                    (IKsPowerNotify *)Address
                                )
                            );
    
                        break;
    
                    case InterfaceTypeINonDelegatedUnknown:
    
                        *ObjectAddress =
                            (DWORD)(
                                (CKsFilterFactory *)(
                                    (INonDelegatedUnknown *)Address
                                )
                            );
    
                        break;
    
                    case InterfaceTypeIIndirectedUnknown:
    
                        *ObjectAddress =
                            (DWORD)(
                                (CKsFilterFactory *)(
                                    (IIndirectedUnknown *)Address
                                )
                            );
    
                        break;
    
                    default:
    
                        BestGuess = ObjectTypeUnknown;
                        break;
                }
    
                break;
    
            case ObjectTypeCKsFilter:
    
                switch (IFGuess) {
    
                    case InterfaceTypeIKsFilter:
    
                        *ObjectAddress =
                            (DWORD)(
                                (CKsFilter *)(
                                    (IKsFilter *)Address
                                )
                            );
    
                        break;
    
                    case InterfaceTypeIKsTransport:
    
                        *ObjectAddress =
                            (DWORD)(
                                (CKsFilter *)(
                                    (IKsTransport *)Address
                                )
                            );
    
                        break;
    
                    case InterfaceTypeIKsProcessingObject:
    
                        *ObjectAddress =
                            (DWORD)(
                                (CKsFilter *)(
                                    (IKsProcessingObject *)Address
                                )
                            );
    
                        break;
    
                    case InterfaceTypeIKsPowerNotify:
    
                        *ObjectAddress =
                            (DWORD)(
                                (CKsFilter *)(
                                    (IKsPowerNotify *)Address
                                )
                            );
    
                        break;
    
                    case InterfaceTypeIKsControl:
    
                        *ObjectAddress =
                            (DWORD)(
                                (CKsFilter *)(
                                    (IKsControl *)Address
                                )
                            );
    
                        break;
    
                    case InterfaceTypeINonDelegatedUnknown:
    
                        *ObjectAddress =
                            (DWORD)(
                                (CKsFilter *)(
                                    (INonDelegatedUnknown *)Address
                                )
                            );
    
                        break;
    
                    case InterfaceTypeIIndirectedUnknown:
    
                        *ObjectAddress =
                            (DWORD)(
                                (CKsFilter *)(
                                    (IIndirectedUnknown *)Address
                                )
                            );
    
                        break;
    
                    default:
    
                        BestGuess = ObjectTypeUnknown;
                        break;
    
                }
    
                break;
    
            case ObjectTypeCKsPin:
    
                switch (IFGuess) {
                    
                    case InterfaceTypeIKsPin:
    
                        *ObjectAddress =
                            (DWORD)(
                                (CKsPin *)(
                                    (IKsPin *)Address
                                )
                            );
    
                        break;
    
                    case InterfaceTypeIKsTransport:
    
                        *ObjectAddress =
                            (DWORD)(
                                (CKsPin *)(
                                    (IKsTransport *)Address
                                )
                            );
    
                        break;
    
                    case InterfaceTypeIKsProcessingObject:
    
                        *ObjectAddress =
                            (DWORD)(
                                (CKsPin *)(
                                    (IKsProcessingObject *)Address
                                )
                            );
    
                        break;
    
                    case InterfaceTypeIKsWorkSink:
    
                        *ObjectAddress =
                            (DWORD)(
                                (CKsPin *)(
                                    (IKsWorkSink *)Address
                                )
                            );
    
                        break;
    
                    case InterfaceTypeIKsConnection:
    
                        *ObjectAddress =
                            (DWORD)(
                                (CKsPin *)(
                                    (IKsConnection *)Address
                                )
                            );
    
                        break;
    
                    case InterfaceTypeIKsControl:
    
                        *ObjectAddress =
                            (DWORD)(
                                (CKsPin *)(
                                    (IKsControl *)Address
                                )
                            );
    
                        break;
    
                    case InterfaceTypeIKsReferenceClock:
    
                        *ObjectAddress =
                            (DWORD)(
                                (CKsPin *)(
                                    (IKsReferenceClock *)Address
                                )
                            );
    
                        break;
    
                    case InterfaceTypeIKsRetireFrame:
    
                        *ObjectAddress =
                            (DWORD)(
                                (CKsPin *)(
                                    (IKsRetireFrame *)Address
                                )
                            );
    
                        break;
    
                    case InterfaceTypeINonDelegatedUnknown:
    
                        *ObjectAddress =
                            (DWORD)(
                                (CKsPin *)(
                                    (INonDelegatedUnknown *)Address
                                )
                            );
    
                        break;
    
                    case InterfaceTypeIIndirectedUnknown:
    
                        *ObjectAddress =
                            (DWORD)(
                                (CKsPin *)(
                                    (IIndirectedUnknown *)Address
                                )
                            );
    
                        break;
    
    
                    default:
    
                        BestGuess = ObjectTypeUnknown;
                        break;
    
                }
    
                break;
    
            case ObjectTypeCKsRequestor:
    
                switch (IFGuess) {
    
                    case InterfaceTypeIKsRequestor:
    
                        *ObjectAddress =
                            (DWORD)(
                                (CKsRequestor *)(
                                    (IKsRequestor *)Address
                                )
                            );
    
                        break;
    
                    case InterfaceTypeIKsTransport:
    
                        *ObjectAddress =
                            (DWORD)(
                                (CKsRequestor *)(
                                    (IKsTransport *)Address
                                )
                            );
    
                        break;
    
                    case InterfaceTypeIKsWorkSink:
    
                        *ObjectAddress =
                            (DWORD)(
                                (CKsRequestor *)(
                                    (IKsWorkSink *)Address
                                )
                            );
    
                        break;
    
                    case InterfaceTypeINonDelegatedUnknown:
    
                        *ObjectAddress =
                            (DWORD)(
                                (CKsRequestor *)(
                                    (IKsRequestor *)Address
                                )
                            );
    
                        break;
    
                    case InterfaceTypeIIndirectedUnknown:
    
                        *ObjectAddress =
                            (DWORD)(
                                (CKsRequestor *)(
                                    (IIndirectedUnknown *)Address
                                )
                            );
    
                        break;
    
    
                    default:
    
                        BestGuess = ObjectTypeUnknown;
                        break;
    
                }
    
                break;
    
            case ObjectTypeCKsSplitter:
    
                switch (IFGuess) {
    
                    case InterfaceTypeIKsSplitter:
    
                        *ObjectAddress =
                            (DWORD)(
                                (CKsSplitter *)(
                                    (IKsSplitter *)Address
                                )
                            );
    
                        break;
    
                    case InterfaceTypeIKsTransport:
    
                        *ObjectAddress =
                            (DWORD)(
                                (CKsSplitter *)(
                                    (IKsTransport *)Address
                                )
                            );
    
                        break;
    
                    case InterfaceTypeINonDelegatedUnknown:
    
                        *ObjectAddress =
                            (DWORD)(
                                (CKsSplitter *)(
                                    (INonDelegatedUnknown *)Address
                                )
                            );
    
                        break;
    
                    case InterfaceTypeIIndirectedUnknown:
    
                        *ObjectAddress =
                            (DWORD)(
                                (CKsSplitter *)(
                                    (IIndirectedUnknown *)Address
                                )
                            );
    
                        break;
    
    
                    default:
    
                        BestGuess = ObjectTypeUnknown;
                        break;
    
                }
    
                break;
    
            case ObjectTypeCKsSplitterBranch:
    
                switch (IFGuess) {
    
                    case InterfaceTypeIKsTransport:
    
                        *ObjectAddress =
                            (DWORD)(
                                (CKsSplitterBranch *)(
                                    (IKsTransport *)Address
                                )
                            );
    
                        break;
    
                    case InterfaceTypeINonDelegatedUnknown:
    
                        *ObjectAddress =
                            (DWORD)(
                                (CKsSplitterBranch *)(
                                    (INonDelegatedUnknown *)Address
                                )
                            );
    
                        break;
    
                    case InterfaceTypeIIndirectedUnknown:
    
                        *ObjectAddress =
                            (DWORD)(
                                (CKsSplitterBranch *)(
                                    (IIndirectedUnknown *)Address
                                )
                            );
    
                        break;
    
                    default:
    
                        BestGuess = ObjectTypeUnknown;
                        break;
    
                }
    
                break;
    
            case ObjectTypeCKsPipeSection:
    
                switch (IFGuess) {
    
                    case InterfaceTypeIKsPipeSection:
    
                        *ObjectAddress =
                            (DWORD)(
                                (CKsPipeSection *)(
                                    (IKsPipeSection *)Address
                                )
                            );
    
                        break;
    
                    case InterfaceTypeINonDelegatedUnknown:
    
                        *ObjectAddress =
                            (DWORD)(
                                (CKsPipeSection *)(
                                    (INonDelegatedUnknown *)Address
                                )
                            );
    
                        break;
    
                    case InterfaceTypeIIndirectedUnknown:
    
                        *ObjectAddress =
                            (DWORD)(
                                (CKsPipeSection *)(
                                    (IIndirectedUnknown *)Address
                                )
                            );
    
                        break;
    
                    default:
    
                        BestGuess = ObjectTypeUnknown;
    
                }
    
                break;
    
            default:
    
                BestGuess = ObjectTypeUnknown;
                break;
        }
    
        //
        // Give them what they asked for.
        //
        if (BestGuess != ObjectTypeUnknown && InterfaceType) 
            *InterfaceType = IFGuess;

    #endif // WIN9X_KS etc...
    
    return BestGuess;

}

/*************************************************

    Function:

        IdentifyStructure

    Description:

        Attempt to identify a pointer to an object as a structure.  This
        does not identify class objects.  DemangleAndAttemptIdentification
        is required for that because of the potential of VTBL pointers
        that aren't the base pointer.  This identifies a structure
        via key fields.

    Arguments:

        Pointer -
            The pointer to identify

        BaseAddr -
            The base address of the object identified will be placed here.
            (For instance, sometimes we identify a private version, but
            adjust to the public for return -- this would contain the public
            address).

    Return Value:

        Structure Type

    NOTES:

        There are MANY helper functions below this comment

*************************************************/

BOOLEAN
IsStreamPointer (
    IN DWORD Pointer
    )

{

    CMemoryBlock <KSPSTREAM_POINTER> StreamPointer;
    ULONG Result;

    // 
    // This is a high-confidence identification.  We attempt to identify
    // whether pointer is a stream pointer by running tests against it.
    // If any one of the tests fails, it is not.  If all tests pass,
    // it is **LIKELY** a stream pointer.  This is not definite proof.
    //
    if (!ReadMemory (
        (DWORD)CONTAINING_RECORD (Pointer,
            KSPSTREAM_POINTER, Public),
        StreamPointer.Get (),
        sizeof (KSPSTREAM_POINTER),
        &Result)) 
        return FALSE;

    //
    // Supposedly, there's a pin structure where this is.  We're going
    // to read the complete EXT structure and guarantee that we've found a pin.
    //
    CMemoryBlock <KSPIN_EXT> PinExt;

    if (!ReadMemory (
        (DWORD)CONTAINING_RECORD (StreamPointer -> Public.Pin, 
            KSPIN_EXT, Public),
        PinExt.Get (),
        sizeof (KSPIN_EXT),
        &Result))
        return FALSE;

    //
    // Ensure that the EXT says it's a pin.
    //
    if (PinExt -> ObjectType != KsObjectTypePin)
        return FALSE;

    //
    // Ensure that the EXT has an interface pointer to a pin
    //
    DWORD Base;
    if (DemangleAndAttemptIdentification (
        (DWORD)PinExt -> Interface,
        &Base,
        NULL) != ObjectTypeCKsPin)
        return FALSE;

    //
    // At this point, we're fairly confident that *(Pointer + sizeof (*))
    // is a PKSPIN.  This does not guarantee that we're a stream pointer.
    //
    // Ensure that what we think is the private part of the stream pointer
    // really has a pointer to a queue.
    //
    if (DemangleAndAttemptIdentification (
        (DWORD)StreamPointer -> Queue,
        &Base,
        NULL) != ObjectTypeCKsQueue)
        return FALSE;

    //
    // Ensure that the stream pointer is in a valid state.
    //
    if (!(
        StreamPointer -> State >= KSPSTREAM_POINTER_STATE_UNLOCKED &&
        StreamPointer -> State <= KSPSTREAM_POINTER_STATE_DEAD
        ))
        return FALSE;

    //
    // If the stream pointer is locked or unlocked, validate that it points
    // to an Irp.
    //
    if (StreamPointer -> State == KSPSTREAM_POINTER_STATE_UNLOCKED ||
        StreamPointer -> State == KSPSTREAM_POINTER_STATE_LOCKED) {

        //
        // Validate that the frame header points to an Irp
        //
        CMemoryBlock <KSPFRAME_HEADER> FrameHeader;

        if (!ReadMemory (
            (DWORD)StreamPointer -> FrameHeader,
            FrameHeader.Get (),
            sizeof (KSPFRAME_HEADER),
            &Result))
            return FALSE;

        if (!signature_check (
            (DWORD)FrameHeader -> Irp, SignatureIrp
            )) 
            return FALSE;

    }

    //
    // At this point, we've made enough checks to say with a fair degree
    // of confidence that this IS a stream pointer
    //
    return TRUE;

}

INTERNAL_STRUCTURE_TYPE
IdentifyStructure (
    IN DWORD Pointer,
    OUT PDWORD BaseAddr
    )

{

    INTERNAL_STRUCTURE_TYPE StrucType = StructureTypeUnknown;
    INTERNAL_STRUCTURE_TYPE NewStrucType;

    *BaseAddr = Pointer;

    if (IsStreamPointer (Pointer)) StrucType = StructureType_KSSTREAM_POINTER;

    if (IsStreamPointer ((DWORD)
        (Pointer + FIELDOFFSET (KSPSTREAM_POINTER, Public)))) {
        NewStrucType = StructureType_KSSTREAM_POINTER;
        *BaseAddr = Pointer + FIELDOFFSET (KSPSTREAM_POINTER, Public);
        
        //
        // As with future additions, ensure this isn't a multiple match!
        //
        if (StrucType != StructureTypeUnknown)
            return StructureTypeUnknown;

        StrucType = NewStrucType;
    }

    return StrucType;

}

/*************************************************

    Function:

        DumpObjectQueueList

    Description:

        Dump an object queue list.  Note that if the caller specifies an 
        adjustment callback that returns NULL(0), the NULL pointer isn't
        printed.  This allows this function to be used as an iterator
        as well.

    Arguments:

        PLIST_HEAD -
            Points to the list head (InterlockedListHead.ListEntry)
            on the host

        TargetListStart -
            When ListEntry->Flink == TargetListStart, we are done. (Points
            to the top of the list on the target).  If this is 0, we assume
            a NULL terminated singly linked list; this also means that
            ObjHeadToListEntry is really FIELDOFFSET(object, Next)

        ObjHeadToListEntry -
            The distance between the object head and the list entry links.
            FIELDOFFSET(object, ListEntry)

        ObjEOL -
            Indicates termination between objects (on display), EOL or space.
            TRUE indicates EOL

        ObjAdjustmentCallback -
            A function that will adjust the acquired object pointer when
            displayed.

        ObjAdjustmentCallbackContext -
            A context blob which is passed to the object adjustment callback

    Return Value:

        Number of objects in the list


    Notes:

        - This function can be used as an iterator via an object adjustment
          function that returns NULL(0)

*************************************************/

ULONG
DumpObjQueueList (
    IN PLIST_ENTRY ListHead,
    IN DWORD TargetListStart,
    IN DWORD ObjHeadToListEntry,
    IN BOOLEAN ObjEOL,
    IN OBJECT_ADJUSTMENT_FUNCTION ObjAdjustmentCallback OPTIONAL,
    IN PVOID ObjAdjustmentCallbackContext OPTIONAL 
) {
    LIST_ENTRY ListEntry;
    DWORD PreviousObj;
    DWORD Obj, AdjustedObj;
    ULONG Count;
    ULONG Result;

    Count = 0;
    ListEntry = *ListHead;

    PreviousObj = 0;

    while ((DWORD)ListEntry.Flink != NULL && 
           (DWORD)ListEntry.Flink != TargetListStart &&
           !CheckControlC ()) {

        //
        // Grab an Irp out of the queue and dump it
        //
        if (TargetListStart != 0)
            Obj = (DWORD)ListEntry.Flink - ObjHeadToListEntry;
        else 
            Obj = (DWORD)ListEntry.Flink;

        if (Obj == PreviousObj) {
            dprintf (" LIST DUMP BUG: notify wmessmer please!\n");
            break;
        }

        if (!ReadMemory (
            (TargetListStart != 0) ?
                (DWORD)(ListEntry.Flink) :
                (DWORD)(Obj + ObjHeadToListEntry),
            &ListEntry,
            (TargetListStart != 0) ? sizeof (LIST_ENTRY) : sizeof (PVOID),
            &Result
        )) {
            dprintf ("%lx: unable to read object chain entry!\n",
                Obj);
            return Count;
        }

        if (ObjAdjustmentCallback) 
            AdjustedObj = ObjAdjustmentCallback (
                ObjAdjustmentCallbackContext, 
                Obj
                );
        else
            AdjustedObj = Obj;

        if (AdjustedObj != 0) {
            if (!ObjEOL) 
                dprintf ("%08lx ", AdjustedObj);
            else
                dprintf ("%08lx\n", AdjustedObj);
        }

        Count++;

        if (Count > DUMPOBJQUEUELIST_BAILOUT_COUNT)
            break;

        PreviousObj = Obj;

    }

    return Count;

}

/*************************************************

    Function:

        DumpPropertyItem

    Description:

        Dump a KSPROPERTY_ITEM.  This is a helper for DECLARE_API(automation)

    Arguments:

        Property -
            The property item to dump

        TabDepth -
            The tab depth to print this at

*************************************************/

void
DumpPropertyItem (
    IN PKSPROPERTY_ITEM Property,
    IN ULONG TabDepth,
    IN GUID *Set OPTIONAL
) {

    CHAR Buffer [1024];
    ULONG Displ;

    dprintf ("%sItem ID = ", Tab (TabDepth));
    if (!Set || 
        !DisplayNamedAutomationId (Set, Property -> PropertyId, "%s\n", NULL))
        dprintf ("%ld\n", Property -> PropertyId);

    if (Property -> GetPropertyHandler) {
        GetSymbol ((LPVOID)(Property -> GetPropertyHandler), Buffer, &Displ);
        if (Buffer [0] && Displ == 0) 
            dprintf ("%sGet Handler = %s\n", 
                Tab (TabDepth + 1),
                Buffer);
        else
            dprintf ("%sGet Handler = %08lx\n", 
                Tab (TabDepth + 1),
                Property -> GetPropertyHandler);
    } else 
        dprintf ("%sGet Handler = NULL\n", Tab (TabDepth + 1));

    if (Property -> SetPropertyHandler) {
        GetSymbol ((LPVOID)(Property -> SetPropertyHandler), Buffer, &Displ);
        if (Buffer [0] && Displ == 0)
            dprintf ("%sSet Handler = %s\n", 
                Tab (TabDepth + 1), Buffer);
        else
            dprintf ("%sSet Handler = %08lx\n",
                Tab (TabDepth + 1),
                Property -> SetPropertyHandler);
    } else 
        dprintf ("%sSet Handler = NULL\n", Tab (TabDepth + 1));


    dprintf ("%sMinProperty = %08lx\n",
        Tab (TabDepth + 1),
        Property -> MinProperty);
    dprintf ("%sMinData = %08lx\n",
        Tab (TabDepth + 1),
        Property -> MinData);

}

/*************************************************

    Function:

        DumpMethodItem

    Description:

        Dump a KSMETHOD_ITEM.  This is a helper for DECLARE_API(automation)

    Arguments:

        Method -
            The method item to dump

        TabDepth -
            The tab depth to print this at

*************************************************/

void
DumpMethodItem (
    IN PKSMETHOD_ITEM Method,
    IN ULONG TabDepth,
    IN GUID *Set OPTIONAL
) {

    CHAR Buffer [1024];
    ULONG Displ;

    dprintf ("%sItem ID = ", Tab (TabDepth));
    if (!Set || 
        !DisplayNamedAutomationId (Set, Method -> MethodId, "%s\n", NULL))
        dprintf ("%ld\n", Method -> MethodId);

    if (Method -> MethodHandler) {
        GetSymbol ((LPVOID)(Method -> MethodHandler), Buffer, &Displ);
        if (Buffer [0] && Displ == 0) 
            dprintf ("%sMethod Handler = %s\n", 
                Tab (TabDepth + 1), Buffer);
        else
            dprintf ("%sMethod Handler = %08lx\n", 
                Tab (TabDepth + 1),
                Method -> MethodHandler);
    } else 
        dprintf ("%sMethod Handler = NULL\n", Tab (TabDepth + 1));

    dprintf ("%sMinMethod = %08lx\n",
        Tab (TabDepth + 1),
        Method -> MinMethod);
    dprintf ("%sMinData = %08lx\n",
        Tab (TabDepth + 1),
        Method -> MinData);

}

/*************************************************

    Function:

        DumpEventItem

    Description:

        Dump a KSEVENT_ITEM.  This is a helper for DECLARE_API(automation)

    Arguments:

        Event -
            The event item to dump

        TabDepth -
            The tab depth to print this at

*************************************************/

void
DumpEventItem (
    IN PKSEVENT_ITEM Event,
    IN ULONG TabDepth,
    IN GUID *Set OPTIONAL
) {

    CHAR Buffer [1024];
    ULONG Displ;

    dprintf ("%sItem ID = ", Tab (TabDepth));
    if (!Set || 
        !DisplayNamedAutomationId (Set, Event -> EventId, "%s\n", NULL))
        dprintf ("%ld\n", Event -> EventId);

    if (Event -> AddHandler) {
        GetSymbol ((LPVOID)(Event -> AddHandler), Buffer, &Displ);
        if (Buffer [0] && Displ == 0) 
            dprintf ("%sAdd Handler = %s\n", Tab (TabDepth + 1), Buffer);
        else
            dprintf ("%sAdd Handler = %08lx\n", 
                Tab (TabDepth + 1),
                Event -> AddHandler);
    } else 
        dprintf ("%sAdd Handler = NULL\n");

    if (Event -> RemoveHandler) {
        GetSymbol ((LPVOID)(Event -> RemoveHandler), Buffer, &Displ);
        if (Buffer [0] && Displ == 0) 
            dprintf ("%sRemove Handler = %s\n", Tab (TabDepth + 1), Buffer);
        else
            dprintf ("%sRemove Handler = %08lx\n", 
                Tab (TabDepth + 1),
                Event -> RemoveHandler);
    } else 
        dprintf ("%sRemove Handler = NULL\n",
            Tab (TabDepth + 1));

    if (Event -> SupportHandler) {
        GetSymbol ((LPVOID)(Event -> SupportHandler), Buffer, &Displ);
        if (Buffer [0] && Displ == 0) 
            dprintf ("%sSupport Handler = %s\n", Tab (TabDepth + 1), Buffer);
        else
            dprintf ("%sSupport Handler = %08lx\n", 
                Tab (TabDepth + 1),
                Event -> SupportHandler);
    } else 
        dprintf ("%sSupport Handler = NULL\n", Tab (TabDepth + 1));

    dprintf ("%sDataInput = %08lx\n",
        Tab (TabDepth + 1),
        Event -> DataInput);
    dprintf ("%sExtraEntryData = %08lx\n",
        Tab (TabDepth + 1),
        Event -> ExtraEntryData);

}


/*************************************************

    Function:

        DumpExtEventList

    Description:

        Given an object EXT, dump the event list associated
        with that Ext.

    Arguments:

        ExtAddr -
            The address of the object ext

        TabDepth -
            The tab depth to print this at

    Return Value:

        Number of event items in the event list

    Notes:

*************************************************/

ULONG
DumpExtEventList (
    IN DWORD ExtAddr,
    IN ULONG TabDepth
) {

    KSPX_EXT Ext;
    ULONG Result;
    KSEVENT_ENTRY EventEntry;
    DWORD InitialList;
    ULONG EventCount = 0;

    if (!ReadMemory (
        ExtAddr,
        &Ext,
        sizeof (KSPX_EXT),
        &Result)) {

        dprintf ("%08lx: cannot read object ext!\n",
            ExtAddr);
        return EventCount;
    }

    EventEntry.ListEntry = Ext.EventList.ListEntry;

    InitialList = ExtAddr + 
        FIELDOFFSET (KSPX_EXT, EventList) +
        FIELDOFFSET (INTERLOCKEDLIST_HEAD, ListEntry);

    #ifdef DEBUG_EXTENSION
        dprintf ("EventEntry.ListEntry.Flink = %08lx\n",
            EventEntry.ListEntry.Flink);
        dprintf ("InitialList = %08lx\n", InitialList);
    #endif // DEBUG_EXTENSION

    //
    // Walk the event list, printing each entry as we go...
    //
    while ((DWORD)EventEntry.ListEntry.Flink != InitialList &&
        !CheckControlC ()) {

        PKSEVENT_ENTRY EntryAddr =
            (PKSEVENT_ENTRY)(CONTAINING_RECORD (
                EventEntry.ListEntry.Flink, KSEVENT_ENTRY, ListEntry));

        KSEVENT_SET Set;
        KSEVENT_ITEM Item;
        GUID Guid;

        if (!ReadMemory (
            (DWORD)EntryAddr,
            &EventEntry,
            sizeof (KSEVENT_ENTRY),
            &Result)) {

            dprintf ("%08lx: cannot read event entry!\n",
                EventEntry.ListEntry.Flink);
            return EventCount;
        }

        EventCount++;

        dprintf ("%sEvent Entry %08lx:\n", Tab (TabDepth), EntryAddr);
        dprintf ("%sFile Object       %08lx\n",
            Tab (TabDepth + 1), EventEntry.FileObject);
        dprintf ("%sNotification Type %08lx\n",
            Tab (TabDepth + 1), EventEntry.NotificationType);
        dprintf ("%sSet               %08lx : ", 
            Tab (TabDepth + 1), EventEntry.EventSet);

        if (!ReadMemory (
            (DWORD)EventEntry.EventSet,
            &Set,
            sizeof (KSEVENT_SET),
            &Result)) {

            dprintf ("%08lx: cannot read event set!\n",
                EventEntry.EventSet);
            return EventCount;
        }

        if (!ReadMemory (
            (DWORD)Set.Set,
            &Guid,
            sizeof (GUID),
            &Result)) {

            dprintf ("%08lx: cannot read event set guid!\n",
                Set.Set);
            return EventCount;
        }

        XTN_DUMPGUID ("\0", 0, Guid);

        if (!ReadMemory (
            (DWORD)EventEntry.EventItem,
            &Item,
            sizeof (KSEVENT_ITEM),
            &Result)) {

            dprintf ("%08lx: cannot read event item!\n",
                EventEntry.EventItem);
            return EventCount;
        }

        DumpEventItem (&Item, TabDepth  + 1, &Guid);

    }

    return EventCount;
}

/*************************************************

    Function:

        FindMatchAndDumpAutomationItem

    Description:

        Given an automation item, match it to the public object for
        a handler and dump it.

    Arguments:

        Item -
            Automation item

        Public -
            The public to match it to (target addr)

        AutomationType -
            The automation type to match against (property, method, event)

        TabDepth -
            The depth to print at

    Return Value:

        Successful / non successful match

*************************************************/

//
// Internal structures from automat.cpp; these are private.  Maybe I should
// move these to avstream.h or do some #include <automat.cpp>
//

typedef struct KSPAUTOMATION_SET_ { 
    GUID* Set;
    ULONG ItemsCount;
    PVOID Items;
    ULONG FastIoCount;
    PVOID FastIoTable;
} KSPAUTOMATION_SET, *PKSPAUTOMATION_SET;

typedef struct {
    ULONG SetsCount;
    ULONG ItemSize;
    PKSPAUTOMATION_SET Sets;
} KSPAUTOMATION_TYPE, *PKSPAUTOMATION_TYPE;

BOOLEAN
FindMatchAndDumpAutomationItem (
    IN PKSIDENTIFIER Item,
    IN DWORD Public,
    IN AUTOMATION_TYPE AutomationType,
    IN ULONG TabDepth,
    IN ULONG NodeId OPTIONAL
    )

{

    //
    // First, I need to adjust public to the public ext object.  Then I
    // need to ensure that the ext is at least vaguely resembling an ext.
    // Find the automation table, and search it for Item...  then dump
    // the matching item
    //
    PKSPX_EXT ExtAddr;
    KSPX_EXT Ext;
    ULONG Result;

    ExtAddr = (PKSPX_EXT)CONTAINING_RECORD (Public, KSPX_EXT, Public);
    if (!ReadMemory (
        (DWORD)ExtAddr,
        &Ext,
        sizeof (KSPX_EXT),
        &Result)) {

        dprintf ("%08lx: unable to read ext!\n", ExtAddr);
        return FALSE;
    }

    //
    // Only find and match automation items on filter (&fac), pin objects.
    //
    if (Ext.ObjectType != KsObjectTypeFilterFactory &&
        Ext.ObjectType != KsObjectTypeFilter &&
        Ext.ObjectType != KsObjectTypePin)
        return FALSE;

    KSAUTOMATION_TABLE Table;
    PKSAUTOMATION_TABLE NodeAutomationTable = NULL;

    //
    // topology flag better match on all 3 types....
    //
    if (Item->Flags & KSPROPERTY_TYPE_TOPOLOGY) {
        NodeAutomationTable = GetNodeAutomationTablePointer (
            Public, NodeId
            );
    }

    if (!ReadMemory (
        NodeAutomationTable ? 
            (DWORD)NodeAutomationTable : (DWORD)Ext.AutomationTable,
        &Table,
        sizeof (KSAUTOMATION_TABLE),
        &Result)) {

        dprintf ("%08lx: cannot read ext automation table!\n",
            Ext.AutomationTable);
        return FALSE;
    }

    PKSPAUTOMATION_TYPE KsAutomationType = NULL;

    switch (AutomationType) {
        case AutomationProperty:
            KsAutomationType = 
                (PKSPAUTOMATION_TYPE)(&(Table.PropertySetsCount));
            break;
        case AutomationMethod:
            KsAutomationType = (PKSPAUTOMATION_TYPE)(&(Table.MethodSetsCount));
            break;
        case AutomationEvent:
            KsAutomationType = (PKSPAUTOMATION_TYPE)(&(Table.EventSetsCount));
            break;
    }

    if (!KsAutomationType)
        return FALSE;

    //
    // foreach set...
    //
    PKSPAUTOMATION_SET AutomationSet = KsAutomationType->Sets;
    for (ULONG cset = 0; cset < KsAutomationType -> SetsCount; cset++,
        AutomationSet++) {

        KSPAUTOMATION_SET CurrentSet;
        GUID set;

        if (!ReadMemory (
            (DWORD)AutomationSet,
            &CurrentSet,
            sizeof (KSPAUTOMATION_SET),
            &Result))
            return FALSE;

        if (!ReadMemory (
            (DWORD)CurrentSet.Set,
            &set,
            sizeof (GUID),
            &Result))
            return FALSE;

        //
        // If the set guids don't match....  don't bother...
        //
        if (RtlCompareMemory (&Item->Set, &set, sizeof (GUID)) != sizeof (GUID))
            continue;

        //
        // foreach item
        //
        PVOID CurItem = (PVOID)CurrentSet.Items;
        for (ULONG citem = 0; citem < CurrentSet.ItemsCount; citem++) {
            //
            // Check whether or not this is a match based on automation type
            //
            switch (AutomationType) {

                case AutomationProperty:
                {
                    KSPROPERTY_ITEM PropertyItem;

                    if (!ReadMemory (
                        (DWORD)CurItem,
                        &PropertyItem,
                        sizeof (KSPROPERTY_ITEM),
                        &Result))
                        return FALSE;

                    if (PropertyItem.PropertyId == Item->Id) {

                        //
                        // Horrah... we have a match
                        //

                        dprintf ("%sMatching Property Handler:\n",
                            Tab (TabDepth));
                        DumpPropertyItem (&PropertyItem, TabDepth + 1,
                            &Item -> Set
                            );

                        //
                        // There will not be a second match...  can the
                        // search.
                        //
                        return TRUE;

                    }

                    break;
                }

                case AutomationMethod:
                {
                    KSMETHOD_ITEM MethodItem;

                    if (!ReadMemory (
                        (DWORD)CurItem,
                        &MethodItem,
                        sizeof (KSMETHOD_ITEM),
                        &Result))
                        return FALSE;

                    if (MethodItem.MethodId == Item->Id) {

                        dprintf ("%sMatching Method Handler:\n",
                            Tab (TabDepth));
                        DumpMethodItem (&MethodItem, TabDepth + 1,
                            &Item -> Set);

                        return TRUE;
                    }

                    break;


                }

                case AutomationEvent:
                {
                    KSEVENT_ITEM EventItem;

                    if (!ReadMemory (
                        (DWORD)CurItem,
                        &EventItem,
                        sizeof (KSEVENT_ITEM),
                        &Result))
                        return FALSE;

                    if (EventItem.EventId == Item->Id) {

                        dprintf ("%sMatching Event Handler:\n",
                            Tab (TabDepth));
                        DumpEventItem (&EventItem, TabDepth + 1, &Item -> Set);

                        return TRUE;

                    }

                    break;

                }

                default:
                    return FALSE;

            }

            CurItem = (PVOID)((PUCHAR)CurItem + KsAutomationType -> ItemSize);

        }
    }

    return FALSE;
}

/*************************************************

    Function:

        DumpAutomationIrp

    Description:

        Given an Irp that is IOCTL_KS_* [automation], dump the relevant
        information.

    Arguments:

        Irp -
            Points to an Irp on the HOST system, not the TARGET system

        IoStack -
            Points to the current io stack for Irp on the HOST system.

        TabDepth -
            The tab depth to print info at

        Public -
            The public object the Irp refers to.  This should never be
            the parent object (only for creates)

*************************************************/

//
// Lay out string tables for the property flag names, etc...  Just
// for debug output in a more readable form.
//
char AutomationFlags[][29][48] = {
    {
        "KSPROPERTY_TYPE_GET",              // 00000001
        "KSPROPERTY_TYPE_SET",              // 00000002
        "*** INVALID ***",                  // 00000004
        "*** INVALID ***",                  // 00000008
        "*** INVALID ***",                  // 00000010
        "*** INVALID ***",                  // 00000020
        "*** INVALID ***",                  // 00000040
        "*** INVALID ***",                  // 00000080
        "KSPROPERTY_TYPE_SETSUPPORT",       // 00000100
        "KSPROPERTY_TYPE_BASICSUPPORT",     // 00000200
        "KSPROPERTY_TYPE_RELATIONS",        // 00000400
        "KSPROPERTY_TYPE_SERIALIZESET",     // 00000800
        "KSPROPERTY_TYPE_UNSERIALIZESET",   // 00001000
        "KSPROPERTY_TYPE_SERIALIZERAW",     // 00002000
        "KSPROPERTY_TYPE_UNSERIALIZERAW",   // 00004000
        "KSPROPERTY_TYPE_SERIALIZESIZE",    // 00008000
        "KSPROPERTY_TYPE_DEFAULTVALUES",    // 00010000
        "*** INVALID ***",                  // 00020000
        "*** INVALID ***",                  // 00040000
        "*** INVALID ***",                  // 00080000
        "*** INVALID ***",                  // 00100000
        "*** INVALID ***",                  // 00200000
        "*** INVALID ***",                  // 00400000
        "*** INVALID ***",                  // 00800000
        "*** INVALID ***",                  // 01000000
        "*** INVALID ***",                  // 02000000
        "*** INVALID ***",                  // 04000000
        "*** INVALID ***",                  // 08000000
        "KSPROPERTY_TYPE_TOPOLOGY"          // 10000000
    },
    {
        "KSMETHOD_TYPE_READ [SEND]",        // 00000001
        "KSMETHOD_TYPE_WRITE",              // 00000002
        "KSMETHOD_TYPE_SOURCE",             // 00000004
        "*** INVALID ***",                  // 00000008
        "*** INVALID ***",                  // 00000010
        "*** INVALID ***",                  // 00000020
        "*** INVALID ***",                  // 00000040
        "*** INVALID ***",                  // 00000080
        "KSMETHOD_TYPE_SETSUPPORT",         // 00000100
        "KSMETHOD_TYPE_BASICSUPPORT",       // 00000200
        "*** INVALID ***",                  // 00000400
        "*** INVALID ***",                  // 00000800
        "*** INVALID ***",                  // 00001000
        "*** INVALID ***",                  // 00002000
        "*** INVALID ***",                  // 00004000
        "*** INVALID ***",                  // 00008000
        "*** INVALID ***",                  // 00010000
        "*** INVALID ***",                  // 00020000
        "*** INVALID ***",                  // 00040000
        "*** INVALID ***",                  // 00080000
        "*** INVALID ***",                  // 00100000
        "*** INVALID ***",                  // 00200000
        "*** INVALID ***",                  // 00400000
        "*** INVALID ***",                  // 00800000
        "*** INVALID ***",                  // 01000000
        "*** INVALID ***",                  // 02000000
        "*** INVALID ***",                  // 04000000
        "*** INVALID ***",                  // 08000000
        "KSMETHOD_TYPE_TOPOLOGY"            // 10000000
    },
    {
        "KSEVENT_TYPE_ENABLE",              // 00000001
        "KSEVENT_TYPE_ONESHOT",             // 00000002
        "KSEVENT_TYPE_ENABLEBUFFERED",      // 00000004
        "*** INVALID ***",                  // 00000008
        "*** INVALID ***",                  // 00000010
        "*** INVALID ***",                  // 00000020
        "*** INVALID ***",                  // 00000040
        "*** INVALID ***",                  // 00000080
        "KSEVENT_TYPE_SETSUPPORT",          // 00000100
        "KSEVENT_TYPE_BASICSUPPORT",        // 00000200
        "KSEVENT_TYPE_QUERYBUFFER",         // 00000400
        "*** INVALID ***",                  // 00000800
        "*** INVALID ***",                  // 00001000
        "*** INVALID ***",                  // 00002000
        "*** INVALID ***",                  // 00004000
        "*** INVALID ***",                  // 00008000
        "*** INVALID ***",                  // 00010000
        "*** INVALID ***",                  // 00020000
        "*** INVALID ***",                  // 00040000
        "*** INVALID ***",                  // 00080000
        "*** INVALID ***",                  // 00100000
        "*** INVALID ***",                  // 00200000
        "*** INVALID ***",                  // 00400000
        "*** INVALID ***",                  // 00800000
        "*** INVALID ***",                  // 01000000
        "*** INVALID ***",                  // 02000000
        "*** INVALID ***",                  // 04000000
        "*** INVALID ***",                  // 08000000
        "KSEVENT_TYPE_TOPOLOGY"             // 10000000
    }
};

char AutomationTypeNames[][32] = {
    "unknown",
    "property",
    "method",
    "event"
};

void
DumpAutomationIrp (
    IN PIRP Irp,
    IN PIO_STACK_LOCATION IoStack,
    IN AUTOMATION_TYPE AutomationType,
    IN ULONG TabDepth,
    IN DWORD Public OPTIONAL
    )

{

    PKSIDENTIFIER AutomationAddr = (PKSIDENTIFIER)
        IoStack->Parameters.DeviceIoControl.Type3InputBuffer;

    ULONG NodeId;

    //
    // Automation object information
    //
    KSIDENTIFIER AutomationObject;

    UCHAR Buffer [1024];
    ULONG Displ;
    ULONG Result;

    AUTOMATION_DUMP_HANDLER DumpHandler;

    if (!ReadMemory (
        (DWORD)AutomationAddr,
        &AutomationObject,
        sizeof (KSIDENTIFIER),
        &Result)) {

        dprintf ("%08lx: cannot read automation object!\n",
            AutomationAddr);
        return;
    }

    dprintf ("%sIRP has associated %s structure %ld:\n",
        Tab (TabDepth), AutomationTypeNames [AutomationType], AutomationType);

    dprintf ("%sSet", Tab (TabDepth + 1));
    if (!DisplayNamedAutomationSet (&AutomationObject.Set, " %s\n")) {
        XTN_DUMPGUID(" ", 0, (AutomationObject.Set));
    }

    dprintf ("%sItem ", Tab (TabDepth + 1));
    if (!DisplayNamedAutomationId (&AutomationObject.Set, AutomationObject.Id,
        "%s\n", &DumpHandler))
        dprintf ("%ld\n", AutomationObject.Id);

    //
    // Future expansion: should anyone want to add handlers for specific
    // properties...  This will cause them to be invoked.  The handlers are
    // all specified in the tables in strlib.c
    //
    if (DumpHandler)
        DumpHandler (AutomationAddr, TabDepth);

    //
    // Make sure I'm not being an idiot.
    //
    if (KSPROPERTY_TYPE_TOPOLOGY != KSMETHOD_TYPE_TOPOLOGY ||
        KSMETHOD_TYPE_TOPOLOGY != KSEVENT_TYPE_TOPOLOGY) {
        dprintf ("ERROR: someone needs to update the extension!  Topology\n"
                 "       flags no longer match property/method/event!\n");
        return;
    }

    //
    // If this really isn't automation on the object but on a topology node
    // instead, detect and dump relevant information regarding topology.
    //
    if (AutomationObject.Flags & KSPROPERTY_TYPE_TOPOLOGY) {

        //
        // Note that KSM_NODE, KSE_NODE, and KSP_NODE should have NodeId
        // at the same offset since KSPROPERTY, KSMETHOD, and KSEVENT are all
        // KSIDENTIFIERs.  The types should be identical which is why the
        // offset into KSP_NODE is used here.
        //
        if (!ReadMemory (
            (DWORD)AutomationAddr + FIELDOFFSET(KSP_NODE, NodeId),
            &NodeId,
            sizeof (ULONG),
            &Result)) {

            dprintf ("%08lx: unable to read node id!\n", AutomationAddr);
            return;

        }

        //
        // Dump information if the topology node is involved.
        // 
        // BUGBUG: detail this.
        //
        dprintf ("%sQuery for topology node id = %ld\n", Tab (TabDepth + 1), 
            NodeId);
    }

    dprintf ("%sFlags\n", Tab (TabDepth + 1));
    dprintf ("%s", Tab (TabDepth + 2));

    //
    // Dump out all flags...  Note that KS*_TYPE_TOPOLOGY are the same.
    //
    ULONG i = KSPROPERTY_TYPE_TOPOLOGY;
    ULONG aid = 28;
    ULONG flagcount = 0;

    do {
        if (AutomationObject.Flags & i) {
            dprintf ("%s ", AutomationFlags [AutomationType - 1][aid]);
            flagcount++;
        }

        if (i == 0)
            break;

        i >>= 1;
        aid--;

    } while (1);

    // 
    // This should never happen...  it's a bogus automation if it does.
    //
    if (!flagcount)
        dprintf ("%sNone (bogus %s!)", Tab (TabDepth + 2),
            AutomationTypeNames [AutomationType]);

    dprintf ("\n");

    if (Public) {
	dprintf ("\n");
        if (!FindMatchAndDumpAutomationItem (&AutomationObject, 
            Public, AutomationType, TabDepth, NodeId)) {
            dprintf ("%sThere is no handler for this %s!\n",
                Tab (TabDepth), AutomationTypeNames [AutomationType]);
        }
    }


    dprintf ("\n");

}

/*************************************************

    Function:

        DumpAssociatedIrpInfo

    Description:

        Given that a client has !ks.dump irp 7 (or something such as this),
        take the given Irp passed in and dump any associated information
        with the Irp.

    Arguments:

        IrpAddr -
            Points to the irp on the target system

        TabDepth -
            The tabbing depth to print this at

        Public -
            The public adjusted object for this Irp.  For a child
            object in the process of creation, this should be the parent
            object.

*************************************************/

void 
DumpAssociatedIrpInfo (
    IN PIRP IrpAddr,
    IN ULONG TabDepth,
    IN DWORD Public OPTIONAL
    )

{

    IRP Irp;
    IO_STACK_LOCATION IoStack;

    ULONG Result;

    #ifdef DEBUG_EXTENSION
        if (!signature_check ((DWORD)IrpAddr, SignatureIrp))
            return;
    #endif // DEBUG_EXTENSION

    //
    // Read the irp
    //
    if (!ReadMemory (
        (DWORD)IrpAddr,
        &Irp,
        sizeof (IRP),
        &Result)) {

        dprintf ("%08lx: cannot read Irp!\n", IrpAddr);
        return;
    }

    if (!ReadMemory (
        (DWORD)Irp.Tail.Overlay.CurrentStackLocation,
        &IoStack,
        sizeof (IO_STACK_LOCATION),
        &Result)) {

        dprintf ("%08lx: cannot read stack location of irp!\n",
            Irp.Tail.Overlay.CurrentStackLocation);
        return;
    }

    #ifdef DEBUG_EXTENSION
        dprintf ("associated irp io stack major func = %ld\n",
            (ULONG)IoStack.MajorFunction);
    #endif // DEBUG_EXTENSION

    //
    // Now, begin checking major/minor for things that we know information
    // about and can justify an extra dump for.
    //
    if (IoStack.MajorFunction == IRP_MJ_DEVICE_CONTROL) {
        
        //
        // It's a control IOCTL.  See if this is a method, property, or
        // event request.
        //
        switch (IoStack.Parameters.DeviceIoControl.IoControlCode) {

            case IOCTL_KS_PROPERTY:
                DumpAutomationIrp (&Irp, &IoStack, AutomationProperty, 
                    INITIAL_TAB, Public);
                break;
        
            case IOCTL_KS_METHOD:
                DumpAutomationIrp (&Irp, &IoStack, AutomationMethod,
                    INITIAL_TAB, Public);
                break;

            default:
                break;

        }
    }
}


/**************************************************************************

    Routines to dump private AVStream objects

**************************************************************************/

/*************************************************

    Function:

        DumpPrivateBranch

    Description:

        Given the address of a CKsSplitterBranch object on the target,
        duimp information about that branch object.

    Arguments:

        Private -
            The address of the CKsSplitterBranch

        Level -
            The 0-7 level of output

        TabDepth -
            The tab depth to print this at

    Return Value:

        None

*************************************************/

void
DumpPrivateBranch (
    IN DWORD Private,
    IN ULONG Level,
    IN ULONG TabDepth
    )

{

    CMemoryBlock <CKsSplitterBranch> BranchObject;
    ULONG Result;
    ULONG Count;

    if (!ReadMemory (
        Private,
        BranchObject.Get (),
        sizeof (CKsSplitterBranch),
        &Result)) {

        dprintf ("%08lx: cannot read branch object!\n", Private);
        return;
    }

    dprintf ("%sCKsSplitterBranch object %08lX\n", Tab (TabDepth), Private);
    TabDepth++;
    dprintf ("%sReference Count          %ld\n",
        Tab (TabDepth),
        GetObjectReferenceCount ((CBaseUnknown *)
            ((CKsSplitterBranch *)Private)));

    dprintf ("%sManaging Splitter        %08lx\n",
        Tab (TabDepth), BranchObject -> m_Splitter);

    dprintf ("%sBranch Pin               %08lx\n",
        Tab (TabDepth), BranchObject -> m_Pin);

    dprintf ("%sCompression/Expansion    %ld:%ld [constant margin = %ld]\n",
        Tab (TabDepth), BranchObject -> m_Compression.RatioNumerator,
        BranchObject -> m_Compression.RatioDenominator,
        BranchObject -> m_Compression.RatioConstantMargin
        );

    dprintf ("%sData Used                %ld bytes (0x%08lx)\n",
        Tab (TabDepth), BranchObject -> m_DataUsed,
        BranchObject -> m_DataUsed);

    dprintf ("%sFrame Extent             %ld bytes (0x%08lx)\n",
        Tab (TabDepth), BranchObject -> m_FrameExtent,
        BranchObject -> m_FrameExtent);

    if (Level >= DUMPLVL_HIGHDETAIL) {
    
        dprintf ("%sIrps Available:\n", Tab (TabDepth));
        dprintf ("%s", Tab (TabDepth + 1));
        Count = DumpObjQueueList (
            &(BranchObject -> m_IrpsAvailable.ListEntry),
            FIELDOFFSET (CKsSplitterBranch, m_IrpsAvailable) + Private +
                FIELDOFFSET (INTERLOCKEDLIST_HEAD, ListEntry),
            FIELDOFFSET (IRP, Tail.Overlay.ListEntry),
            FALSE,
            NULL,
            NULL
            );
    
        if (Count == 0)
            dprintf ("There are no Irps available!\n");
        else
            dprintf ("\n");
    }
    
}

/*************************************************

    Function:
        
        DumpPrivateSplitter

    Description:

        Given the address of a CKsSplitter object on the target,
        dump information about that splitter object.

    Arguments:

        Private -
            The address of the CKsSplitter

        Level -
            The 0-7 level of output

        TabDepth -
            The tab depth to print this at

    Return Value:

        None

    Notes:

*************************************************/

typedef struct _BRANCH_ITERATOR_CONTEXT {
    
    ULONG Level;
    ULONG TabDepth;

} BRANCH_ITERATOR_CONTEXT, *PBRANCH_ITERATOR_CONTEXT;

DWORD
BranchIteratorCallback (
    IN PVOID Context,
    IN DWORD Object
    )

{

    PBRANCH_ITERATOR_CONTEXT BranchContext = (PBRANCH_ITERATOR_CONTEXT)Context;

    DumpPrivateBranch (
        Object,
        BranchContext -> Level,
        BranchContext -> TabDepth
        );

    //
    // This return code instructs the iterator not to actually "dump" the
    // information.
    //
    return 0;

}

void
DumpPrivateSplitter (
    IN DWORD Private,
    IN ULONG Level,
    IN ULONG TabDepth
    )

{

    CMemoryBlock <CKsSplitter> SplitterObject;
    ULONG Result;
    ULONG Count, BranchCount;

    if (!ReadMemory (
        Private,
        SplitterObject.Get (),
        sizeof (CKsSplitter),
        &Result)) {

        dprintf ("%08lx: cannot read splitter object!\n", Private);
        return;
    }

    dprintf ("%sCKsSplitter object %08lX\n", Tab (TabDepth), Private);
    TabDepth++;
    dprintf ("%sReference Count          %ld\n",
        Tab (TabDepth),
        GetObjectReferenceCount ((CBaseUnknown *)((CKsSplitter *)Private)));

    dprintf ("%sBranches Managed By This Splitter:\n", Tab (TabDepth));
    dprintf ("%s", Tab (TabDepth + 1));
    BranchCount = DumpObjQueueList (
        &(SplitterObject -> m_BranchList),
        FIELDOFFSET (CKsSplitter, m_BranchList) + Private,
        FIELDOFFSET (CKsSplitterBranch, m_ListEntry),
        FALSE,
        NULL,
        NULL
        );
    if (BranchCount == 0) 
        dprintf ("There are no branches managed by this splitter yet!\n");
    else 
        dprintf ("\n");

    if (Level >= DUMPLVL_INTERNAL) {
        dprintf ("%sParent Frame Headers Available:\n", Tab (TabDepth));
        dprintf ("%s", Tab (TabDepth + 1));
        Count = DumpObjQueueList (
            &(SplitterObject -> m_FrameHeadersAvailable.ListEntry),
            FIELDOFFSET (CKsSplitter, m_FrameHeadersAvailable) + Private +
                FIELDOFFSET (INTERLOCKEDLIST_HEAD, ListEntry),
            FIELDOFFSET (KSPPARENTFRAME_HEADER, ListEntry),
            FALSE,
            NULL,
            NULL
            );

        if (Count == 0)
            dprintf ("There are no parent frame headers available!\n");
        else
            dprintf ("\n");
    }

    if (Level >= DUMPLVL_HIGHDETAIL) {
    
        dprintf ("%sIrps Outstanding:\n", Tab (TabDepth));
        dprintf ("%s", Tab (TabDepth + 1));
        Count = DumpObjQueueList (
            &(SplitterObject -> m_IrpsOutstanding.ListEntry),
            FIELDOFFSET (CKsSplitter, m_IrpsOutstanding) + Private +
                FIELDOFFSET (INTERLOCKEDLIST_HEAD, ListEntry),
            FIELDOFFSET (IRP, Tail.Overlay.ListEntry),
            FALSE,
            NULL,
            NULL
            );
    
    
        if (Count == 0)
            dprintf ("There are no Irps outstanding!\n");
        else
            dprintf ("\n");
    }

    if (Level >= DUMPLVL_EVERYTHING && BranchCount > 0) {

        dprintf ("\n%sManaged Branches :\n", Tab (TabDepth));

        BRANCH_ITERATOR_CONTEXT BranchContext;

        BranchContext.TabDepth = TabDepth + 1;
        BranchContext.Level = Level;

        Count = DumpObjQueueList (
            &(SplitterObject -> m_BranchList),
            FIELDOFFSET (CKsSplitter, m_BranchList) + Private,
            FIELDOFFSET (CKsSplitterBranch, m_ListEntry),
            FALSE,
            BranchIteratorCallback,
            (PVOID)&BranchContext
            );

    }

}

/*************************************************

    Function:

        DumpPrivateRequestor

    Description:

        Given the address of a CKsRequestor object on the target,
        dump information about that requestor object.

    Arguments:

        Private -
            The address of the CKsRequestor

        Level -
            The 0-7 level of output

        TabDepth -
            The tab depth to print this at

    Return Value:

        None

    Notes:

*************************************************/

void
DumpPrivateRequestor (
    IN DWORD Private,
    IN ULONG Level,
    IN ULONG TabDepth
) {

    CMemoryBlock <CKsRequestor> RequestorObject;
    ULONG Result;

    if (!ReadMemory (
        Private,
        RequestorObject.Get (),
        sizeof (CKsRequestor),
        &Result
    )) {
        dprintf ("%08lx: unable to read requestor object!\n",
            Private);
        return;
    }

    dprintf ("%sCKsRequestor object %08lX\n", Tab (TabDepth), Private);
    TabDepth++;
    dprintf ("%sReference Count          %ld\n",
        Tab (TabDepth),
        GetObjectReferenceCount ((CBaseUnknown *)((CKsRequestor *)Private)));
    dprintf ("%sOwning PIKSPIPESECTION   %08lx\n", 
        Tab (TabDepth),
        RequestorObject -> m_PipeSection);
    dprintf ("%sAssociated PIKSPIN       %08lx\n",
        Tab (TabDepth),
        RequestorObject -> m_Pin);
    dprintf ("%sAssociated Allocator     %08lx\n",
        Tab (TabDepth),
        RequestorObject -> m_AllocatorFileObject);

    dprintf ("%sState                    %ld\n", 
        Tab (TabDepth),
        RequestorObject -> m_State);
    dprintf ("%sFrame Size               %08lx\n", 
        Tab (TabDepth),
        RequestorObject -> m_FrameSize);
    dprintf ("%sFrame Count              %ld\n",
        Tab (TabDepth),
        RequestorObject -> m_FrameCount);
    dprintf ("%sActive Frame Count       %ld\n",
        Tab (TabDepth),
        RequestorObject -> m_ActiveFrameCountPlusOne - 1);
    
    if (Level >= DUMPLVL_HIGHDETAIL) {
        ULONG Count;

        dprintf ("%sIrps Available:\n", Tab (TabDepth));
        dprintf ("%s", Tab (TabDepth + 1));
        Count = DumpObjQueueList (
            &(RequestorObject -> m_IrpsAvailable.ListEntry),
            FIELDOFFSET(CKsRequestor, m_IrpsAvailable) + Private +
                FIELDOFFSET(INTERLOCKEDLIST_HEAD, ListEntry),
            FIELDOFFSET(IRP, Tail.Overlay.ListEntry),
            FALSE,
            NULL,
            NULL
        );
        if (Count == 0)
            dprintf ("There are no available Irps!\n");
        else
            dprintf ("\n");

    }

    if (Level >= DUMPLVL_INTERNALDETAIL) {
        ULONG Count;

        dprintf ("%sFrame Headers Available:\n", Tab (TabDepth));
        dprintf ("%s", Tab (TabDepth + 1));
        Count = DumpObjQueueList (
            &(RequestorObject -> m_FrameHeadersAvailable.ListEntry),
            FIELDOFFSET(CKsRequestor, m_FrameHeadersAvailable) + Private +
                FIELDOFFSET(INTERLOCKEDLIST_HEAD, ListEntry),
            FIELDOFFSET(KSPFRAME_HEADER, ListEntry),
            FALSE,
            NULL,
            NULL
        );
        if (Count == 0)
            dprintf ("There are no available frame headers!\n");
        else
            dprintf ("\n");

        dprintf ("%sFrame Headers Waiting To Be Retired:\n", Tab (TabDepth));
        dprintf ("%s", Tab (TabDepth + 1));
        Count = DumpObjQueueList (
            &(RequestorObject -> m_FrameHeadersToRetire.ListEntry),
            FIELDOFFSET(CKsRequestor, m_FrameHeadersToRetire) + Private +
                FIELDOFFSET(INTERLOCKEDLIST_HEAD, ListEntry),
            FIELDOFFSET(KSPFRAME_HEADER, ListEntry),
            FALSE,
            NULL,
            NULL
        );
        if (Count == 0)
            dprintf ("There are no frame headers waiting for retirement!\n");
        else
            dprintf ("\n");

    }

}

/*************************************************

    Function:

        DumpPrivatePin

    Description:

        Given the address of a CKsPin object on the target,
        dump information about that pin object.

    Arguments:

        Private -
            The address of the CKsPin

        Level -
            The 0-7 level of output

    Return Value:

        None

    Notes:

*************************************************/

DWORD AdjustIrpListEntryToIrp (
    IN PVOID Context,
    IN DWORD IrpListEntry
) {
    DWORD IrpAddress =
        IrpListEntry + FIELDOFFSET(IRPLIST_ENTRY, Irp);
    PIRP Irp;
    ULONG Result;

    if (!ReadMemory (
        IrpAddress,
        &Irp,
        sizeof (PIRP),
        &Result
    )) 
        return IrpListEntry;

    return (DWORD)Irp;

}

void
DumpPrivatePin (
    IN DWORD Private,
    IN ULONG Level,
    IN ULONG TabDepth
) {

    ULONG Result;

    CMemoryBlock <CKsPin> PinObject;

    if (!ReadMemory (
        Private,
        PinObject.Get (),
        sizeof (CKsPin),
        &Result
    )) {
        dprintf ("%lx: unable to read private pin object!\n",
            Private);
        return;
    }

    dprintf ("%sCKsPin object %08lX [corresponding EXT = %08lx, KSPIN = %08lx]"
        "\n", Tab (TabDepth),
        Private, FIELDOFFSET(CKsPin, m_Ext) + Private, 
        FIELDOFFSET(CKsPin, m_Ext) + FIELDOFFSET(KSPIN_EXT, Public) + Private
    );
    TabDepth++;
    dprintf ("%sReference Count          %ld\n",
        Tab (TabDepth),
        GetObjectReferenceCount ((CBaseUnknown *)((CKsPin *)Private)));

    //
    // Dump INTRA / EXTRA status.  If the pin is a source pin or an intra-
    // pin, dump the connected pin.
    //
    if (Level >= DUMPLVL_INTERNAL) {
        if (PinObject -> m_ConnectedPinInterface) {
            dprintf ("%sConnection Type          INTRA\n", Tab (TabDepth));
            dprintf ("%sConnected Intra-Pin      %08lx\n", 
                Tab (TabDepth), 
                (CKsPin *)(PinObject -> m_ConnectedPinInterface)
                );
        } else {
            dprintf ("%sConnection Type          EXTRA\n", Tab (TabDepth));
        }

        PFILE_OBJECT ConnectedFileObject = NULL;
        CKsPin *ConnectedPin = NULL;
        CMemoryBlock <CKsPin> ConnectedPinObject;

        //
        // Source pins have the sink file object.  Intra sinks have the
        // interface exchanged from which we can retrieve the pin object
        // and hence the connected pin object's internal file object.
        //
        if (PinObject -> m_ConnectionFileObject) 
            ConnectedFileObject = PinObject -> m_ConnectionFileObject;
        else {

            if (PinObject -> m_ConnectedPinInterface) {

                ConnectedPin = static_cast <CKsPin *> 
                    (PinObject -> m_ConnectedPinInterface);

                if (!ReadMemory (
                    (DWORD)ConnectedPin,
                    ConnectedPinObject.Get (),
                    sizeof (CKsPin),
                    &Result
                    )) {
                    dprintf ("%lx: unable to read connected pin object!\n",
                        ConnectedPin);
                    return;
                }

                ConnectedFileObject = ConnectedPinObject -> m_FileObject;

            }
        
        }

        //
        // If we have an extra-source or an intra-* pin, dump information about
        // the connected pin.
        //
        if (ConnectedFileObject) {

            FILE_OBJECT FileObject;

            if (!ReadMemory (
                (DWORD)ConnectedFileObject,
                &FileObject,
                sizeof (FILE_OBJECT),
                &Result
                )) {
                dprintf ("%lx: unable to read file object!\n",
                    ConnectedFileObject);
                return;
            }

            //
            // We don't really want to print the driver owning the PDO...
            // Walk to the top of the device stack and print the top
            // of the stack.  
            //
            PDEVICE_OBJECT DeviceObject = FileObject.DeviceObject;
            PDEVICE_OBJECT AttachedDevice = FileObject.DeviceObject;

            while (AttachedDevice) {
                if (!ReadMemory (
                    ((DWORD)DeviceObject) + 
                        FIELDOFFSET (DEVICE_OBJECT, AttachedDevice),
                    &AttachedDevice,
                    sizeof (PDEVICE_OBJECT),
                    &Result
                    )) {
                    dprintf ("%lx: cannot walk device stack!\n",
                        AttachedDevice);
                    return;
                }

                if (AttachedDevice)
                    DeviceObject = AttachedDevice;
            }

            //
            // Find out the owning driver.
            //
            DWORD DriverObjAddr, NameAddr;
            PDRIVER_OBJECT DriverObject;
            UNICODE_STRING Name;
    
            DriverObjAddr = (DWORD)DeviceObject +
                FIELDOFFSET(DEVICE_OBJECT, DriverObject);
    
            if (ReadMemory (
                DriverObjAddr,
                &DriverObject,
                sizeof (PDRIVER_OBJECT),
                &Result
            )) {
    
                NameAddr = (DWORD)DriverObject +
                    FIELDOFFSET(DRIVER_OBJECT, DriverName);
        
                if (ReadMemory (
                    NameAddr,
                    &Name,
                    sizeof (UNICODE_STRING),
                    &Result
                )) {
        
                    PWSTR Buffer = (PWSTR)malloc (
                        Name.MaximumLength * sizeof (WCHAR));
        
                    UNICODE_STRING HostString;
        
                    //
                    // We have the unicode string name...  Allocate 
                    // enough memory to read the thing.
                    //
        
                    if (!ReadMemory (
                        (DWORD)Name.Buffer,
                        Buffer,
                        sizeof (WCHAR) * Name.MaximumLength,
                        &Result
                    )) {
                        dprintf ("%08lx: unable to read unicode string"
                            "buffer!\n", Name.Buffer);
                        return;
                    }
        
                    HostString.MaximumLength = Name.MaximumLength;
                    HostString.Length = Name.Length;
                    HostString.Buffer = Buffer;
    
                    dprintf ("%sConnected Pin File       %08lx"
                        " [StackTop = %wZ]\n",
                        Tab (TabDepth), ConnectedFileObject, &HostString
                        );
        
                    free (Buffer);

                }
            }
        }
    }

    dprintf ("%sState                    %ld\n", 
        Tab (TabDepth),
        PinObject -> m_State);
    dprintf ("%sMaster Clock Object      %08lx\n", 
        Tab (TabDepth),
        PinObject -> m_MasterClockFileObject);
    if (Level >= DUMPLVL_INTERNAL) {
        dprintf ("%sOut of order completions %ld\n",
            Tab (TabDepth),
            PinObject -> m_IrpsCompletedOutOfOrder);
        dprintf ("%sSourced Irps             %ld\n",
            Tab (TabDepth),
            PinObject -> m_StreamingIrpsSourced);
        dprintf ("%sDispatched Irps          %ld\n",
            Tab (TabDepth),
            PinObject -> m_StreamingIrpsDispatched);
        dprintf ("%sSync. Routed Irps        %ld\n",
            Tab (TabDepth),
            PinObject -> m_StreamingIrpsRoutedSynchronously);
    }

    dprintf ("%sProcessing Mutex         %08lx [SignalState = %ld]\n",
        Tab (TabDepth),
        FIELDOFFSET(CKsPin, m_Mutex) + Private,
        PinObject -> m_Mutex.Header.SignalState
    );

    dprintf ("%sAnd Gate &               %08lx\n",
        Tab (TabDepth),
        FIELDOFFSET(CKsPin, m_AndGate) + Private);
    dprintf ("%sAnd Gate Count           %ld\n",
        Tab (TabDepth),
        PinObject -> m_AndGate.Count);

    //
    // Dump out the Irp lists.  If they want it all
    //
    if (Level >= DUMPLVL_HIGHDETAIL) {
        ULONG Count;

        dprintf ("%sIrps to send:\n", Tab (TabDepth));
        dprintf ("%s", Tab (TabDepth + 1));
        Count = DumpObjQueueList (
            &(PinObject -> m_IrpsToSend.ListEntry),
            FIELDOFFSET(CKsPin, m_IrpsToSend) + Private +
                FIELDOFFSET(INTERLOCKEDLIST_HEAD, ListEntry),
            FIELDOFFSET(IRP, Tail.Overlay.ListEntry),
            FALSE,
            NULL,
            NULL
        );
        if (Count == 0)
            dprintf ("There are no Irps waiting to be sent!\n");
        else
            dprintf ("\n");

        dprintf ("%sIrps outstanding (sent out but not completed):\n",
            Tab (TabDepth));
        dprintf ("%s", Tab (TabDepth + 1));
        Count  = DumpObjQueueList (
            &(PinObject -> m_IrpsOutstanding.ListEntry),
            FIELDOFFSET(CKsPin, m_IrpsOutstanding) + Private +
                FIELDOFFSET(INTERLOCKEDLIST_HEAD, ListEntry),
            FIELDOFFSET(IRPLIST_ENTRY, ListEntry),
            FALSE,
            AdjustIrpListEntryToIrp,
            NULL
        );
        if (Count == 0)
            dprintf ("There are no outstanding Irps!\n");
        else
            dprintf ("\n");
    }

}

/*************************************************

    Function:

        DumpPrivatePipeSection

    Description:

        Given the address of a CKsPipeSection object on the target,
        dump information about that pipe section object.

    Arguments:

        Private -
            The address of the CKsPipeSection object

        Level -
            The 0-7 dump level

        TabDepth -
            The tab depth to print this at

    Return Value:

    Notes:

*************************************************/

DWORD
AdjustProcessPinToKSPIN (
    IN PVOID Context,
    IN DWORD ProcessPinAddr
) {

    PKSPIN Pin;
    ULONG Result;

    if (!ReadMemory (
        ProcessPinAddr + FIELDOFFSET(KSPPROCESSPIN, Pin),
        &Pin,
        sizeof (PKSPIN),
        &Result
    )) {
        dprintf ("%08lx: unable to adjust process pin to KSPIN!\n",
            ProcessPinAddr);
        return ProcessPinAddr;
    }

    return (DWORD)Pin;

}

DWORD
AdjustProcessPipeToPipe (
    IN PVOID Context,
    IN DWORD ProcessPipeAddr
) {
    
    return (DWORD)(CONTAINING_RECORD ((PKSPPROCESSPIPESECTION)ProcessPipeAddr,
        CKsPipeSection, m_ProcessPipeSection));

}

void
DumpPrivatePipeSection (
    IN DWORD Private,
    IN ULONG Level,
    IN ULONG TabDepth
) {

    CMemoryBlock <CKsPipeSection> PipeObject;
    ULONG Result;

    if (!ReadMemory (
        Private,
        PipeObject.Get (),
        sizeof (CKsPipeSection),
        &Result
    )) {
        dprintf ("%08lx: cannot read pipe section object!\n",
            Private);
        return;
    }

    dprintf ("%sCKsPipeSection object %08lX:\n", Tab (TabDepth), Private);
    TabDepth++;
    dprintf ("%sReference Count          %ld\n",
        Tab (TabDepth),
        GetObjectReferenceCount ((CBaseUnknown *)((CKsPipeSection *)Private)));
    dprintf ("%sPipe Id                  %08lx\n",
        Tab (TabDepth),
        PipeObject -> m_Id);
    dprintf ("%sState                    %ld\n", 
        Tab (TabDepth),
        PipeObject -> m_DeviceState);
    dprintf ("%sOwning PIKSFILTER        %08lx\n",
        Tab (TabDepth),
        PipeObject -> m_Filter);
    dprintf ("%sOwning PIKSDEVICE        %08lx\n",
        Tab (TabDepth),
        PipeObject -> m_Device);
    dprintf ("%sMaster PIKSPIN           %08lx\n",
        Tab (TabDepth),
        PipeObject -> m_MasterPin);

    if (Level >= DUMPLVL_GENERAL) {
        ULONG Count;


        dprintf ("%sProcess Pipe Data [%08lx]:\n",
            Tab (TabDepth),
            FIELDOFFSET(CKsPipeSection, m_ProcessPipeSection) + Private);

        dprintf ("%sAssociated PIKSREQUESTOR %08lx\n",
            Tab (TabDepth + 1),
            PipeObject -> m_ProcessPipeSection.Requestor);
        dprintf ("%sAssociated PIKSQUEUE     %08lx\n",
            Tab (TabDepth + 1),
            PipeObject -> m_ProcessPipeSection.Queue);
        dprintf ("%sRequired for processing  %ld\n",
            Tab (TabDepth + 1),
            PipeObject -> m_ProcessPipeSection.RequiredForProcessing);

        dprintf ("%sInput Pins:\n", Tab (TabDepth + 1));
        dprintf ("%s", Tab (TabDepth + 2));
        
        //                
        // Here's a bit of fun trickery.  It's not really a list entry,
        // but what the heck.
        //
        Count = DumpObjQueueList (
            (PLIST_ENTRY)(&(PipeObject -> m_ProcessPipeSection.Inputs)),
            0,
            FIELDOFFSET(KSPPROCESSPIN, Next),
            FALSE,
            AdjustProcessPinToKSPIN,
            NULL
        );
        if (Count == 0)
            dprintf ("No input pins exist in this pipe section!\n");
        else
            dprintf ("\n");

        dprintf ("%sOutput Pins:\n", Tab (TabDepth + 1));
        dprintf ("%s", Tab (TabDepth + 2));
        
        Count = DumpObjQueueList (
            (PLIST_ENTRY)(&(PipeObject -> m_ProcessPipeSection.Outputs)),
            0,
            FIELDOFFSET(KSPPROCESSPIN, Next),
            FALSE,
            AdjustProcessPinToKSPIN,
            NULL
        );
        if (Count == 0)
            dprintf ("No output pins exist in this pipe section!\n");
        else
            dprintf ("\n");

        dprintf ("%sCopy Destinations:\n", Tab (TabDepth + 1));
        dprintf ("%s", Tab (TabDepth + 2));

        Count = DumpObjQueueList (
            (PLIST_ENTRY)(&(PipeObject -> 
                m_ProcessPipeSection.CopyDestinations)),
            FIELDOFFSET (KSPPROCESSPIPESECTION, CopyDestinations) + Private +
                FIELDOFFSET (CKsPipeSection, m_ProcessPipeSection),
            FIELDOFFSET (KSPPROCESSPIPESECTION, ListEntry),
            FALSE,
            AdjustProcessPipeToPipe,
            NULL
            );
        if  (Count == 0)
            dprintf ("No copy destinations exist for this pipe section!\n");
        else
            dprintf ("\n");

    }

}

/*************************************************

    Function:
        
        DumpPrivateFilter

    Description:

        Dump a CKsFilter object by address on the target

    Arguments:

        Private -
            Points to the CKsFilter object on the target

        Level -
            The 0-7 dump level

        TabDepth -
            The tab depth to print this at

    Return Value:

        None

    Notes:

*************************************************/

DWORD
AdjustPinExtToKSPIN (
    IN PVOID Context,
    IN DWORD PinExt
) {

    return (PinExt + FIELDOFFSET(KSPIN_EXT, Public));

}

void
DumpPrivateFilter (
    IN DWORD Private,
    IN ULONG Level,
    IN ULONG TabDepth
) {

    CMemoryBlock <CKsFilter> FilterObject;
    ULONG Result;

    if (!ReadMemory (
        Private,
        FilterObject.Get (),
        sizeof (CKsFilter),
        &Result
    )) {
        dprintf ("%08lx: unable to read CKsFilter object!\n",
            Private);
        return;
    }

    dprintf ("%sCKsFilter object %08lX [corresponding EXT = %08lx, "
        "KSFILTER = %08lx]\n",
        Tab (TabDepth),
        Private, FIELDOFFSET(CKsFilter, m_Ext) + Private, 
        FIELDOFFSET(CKsFilter, m_Ext) + FIELDOFFSET(KSFILTER_EXT, Public) + 
            Private
    );
    TabDepth++;
    dprintf ("%sReference Count          %ld\n",
        Tab (TabDepth),
        GetObjectReferenceCount ((CBaseUnknown *)((CKsFilter *)Private)));

    dprintf ("%sProcessing Mutex         %08lx [SignalState = %ld]\n",
        Tab (TabDepth),
        FIELDOFFSET(CKsFilter, m_Mutex) + Private,
        FilterObject -> m_Mutex.Header.SignalState
    );

    dprintf ("%sGate &                   %08lx\n",
        Tab (TabDepth),
        Private + FIELDOFFSET(CKsFilter,m_AndGate));
    dprintf ("%sGate.Count               %ld\n",
        Tab (TabDepth),
        FilterObject -> m_AndGate.Count);

    if (Level >= DUMPLVL_SPECIFIC) {

        CMemoryBlock <CKsPinFactory> PinFactories(
            FilterObject -> m_PinFactoriesCount);

        ULONG i;
        CKsPinFactory *Factory;

        if (!ReadMemory (
            (DWORD)FilterObject -> m_PinFactories,
            PinFactories.Get (),
            sizeof (CKsPinFactory) * FilterObject -> m_PinFactoriesCount,
            &Result
        )) {
            dprintf ("%08lx: unable to read pin factories!\n",
                Private);
            return;
        }

        dprintf ("%sPin Factories:\n", Tab (TabDepth));
    
        for (Factory = PinFactories.Get (), i = 0; 
             i < FilterObject -> m_PinFactoriesCount; 
             i++, Factory++) {

            ULONG Count;

            dprintf ("%sPin ID %ld:\n", Tab (TabDepth + 1), i);
            dprintf ("%sChild Count        %ld\n",
                Tab (TabDepth + 2),
                Factory -> m_PinCount);
            dprintf ("%sBound Child Count  %ld\n",
                Tab (TabDepth + 2),
                Factory -> m_BoundPinCount);
            dprintf ("%sNecessary Count    %ld\n",
                Tab (TabDepth + 2),
                Factory -> m_InstancesNecessaryForProcessing);
            dprintf ("%sSpecific Instances:\n", Tab (TabDepth + 2));
            dprintf ("%s", Tab (TabDepth + 3));

            Count = DumpObjQueueList (
                &(Factory -> m_ChildPinList),
                FIELDOFFSET(CKsPinFactory, m_ChildPinList) +
                    (DWORD)(FilterObject -> m_PinFactories + i),
                FIELDOFFSET(KSPIN_EXT, SiblingListEntry),
                FALSE,
                AdjustPinExtToKSPIN,
                NULL
            );

            if (Count == 0)
                dprintf ("No specific instances of this pin exist!\n");
            else
                dprintf ("\n");

        }
    }
}

/*************************************************

    Function:

        DumpPrivateFilterFactory

    Description:

        Given the address of a CKsFilterFactory on the target,
        dump information about that filter factory.

    Arguments:

        Private -
            The address of the CKsFilterFactory on the target

        Level -
            The 0-7 dump level

        TabDepth -
            The tab depth to print this at

    Return Value:

    Notes:


*************************************************/

void
DumpPrivateFilterFactory (
    IN DWORD Private,
    IN ULONG Level,
    IN ULONG TabDepth
) {

    CMemoryBlock <CKsFilterFactory> FactoryObject;
    ULONG Result;
    LIST_ENTRY ListEntry;
    DWORD InitialList;
    KSPDEVICECLASS DeviceClass;
    UNICODE_STRING SymbolicLink;

    if (!ReadMemory (
        Private,
        FactoryObject.Get (),
        sizeof (CKsFilterFactory),
        &Result
    )) {
        dprintf ("%08lx: unable to read CKsFilterFactory object!\n",
            Private);
        return;
    }

    dprintf ("%sCKsFilterFactory object %08lX [corresponding EXT = %08lx, "
        "KSFILTERFACTORY = %08lx]\n",
        Tab (TabDepth),
        Private, FIELDOFFSET(CKsFilterFactory, m_Ext) + Private, 
        FIELDOFFSET(CKsFilterFactory, m_Ext) + 
            FIELDOFFSET(KSFILTERFACTORY_EXT, Public) + 
            Private
    );
    TabDepth++;
    dprintf ("%sReference Count          %ld\n",
        Tab (TabDepth),
        GetObjectReferenceCount ((CBaseUnknown *)((CKsFilterFactory *)
            Private)));
    dprintf ("%sFilter Automation Table  %08lx\n",
        Tab (TabDepth),
        FactoryObject -> m_FilterAutomationTable);
    dprintf ("%sPin Automation Tables    %08lx\n",
        Tab (TabDepth),
        FactoryObject -> m_PinAutomationTables);
    dprintf ("%sNode Automation Tables   %08lx\n",
        Tab (TabDepth),
        FactoryObject -> m_NodeAutomationTables);
    dprintf ("%sNode Count               %ld\n",
        Tab (TabDepth),
        FactoryObject -> m_NodesCount);

    dprintf ("%sDevice Classes:\n", Tab (TabDepth));

    //
    // Walk the device classes list and print out all symbolic links that
    // are associated with this factory.
    //
    InitialList = FIELDOFFSET(CKsFilterFactory, m_DeviceClasses) + Private;
    DeviceClass.ListEntry = FactoryObject -> m_DeviceClasses;

    #ifdef DEBUG_EXTENSION
        dprintf ("Begin dump of device class list: list.fl=%08lx, init=%08lx"
            "\n", DeviceClass.ListEntry.Flink, InitialList);
    #endif // DEBUG_EXTENSION

    while ((DWORD)DeviceClass.ListEntry.Flink != InitialList &&
        !CheckControlC ()) {

        PWSTR Buffer;
        
        if (!ReadMemory (
            (DWORD)DeviceClass.ListEntry.Flink,
            &DeviceClass,
            sizeof (KSPDEVICECLASS),
            &Result
        )) {
            dprintf ("%08lx: unable to read device class!\n",
                DeviceClass.ListEntry.Flink);
            return;
        }

        Buffer = (PWSTR)malloc (
            sizeof (WCHAR) * DeviceClass.SymbolicLinkName.MaximumLength);

        if (!ReadMemory (
            (DWORD)DeviceClass.SymbolicLinkName.Buffer,
            Buffer,
            sizeof (WCHAR) * 
                DeviceClass.SymbolicLinkName.MaximumLength,
            &Result
        )) {
            dprintf ("%08lx: unable to read symbolic link name!\n",
                DeviceClass.SymbolicLinkName.Buffer);
            return;
        }

        DeviceClass.SymbolicLinkName.Buffer = Buffer;

        dprintf ("%s%wZ\n", Tab (TabDepth + 1), &DeviceClass.SymbolicLinkName);

        free (Buffer);

    }

    dprintf ("%sDevice Classes State     %s\n",
        Tab (TabDepth),
        FactoryObject -> m_DeviceClassesState ? "active" : "inactive");

}

/*************************************************

    Function:

        DumpPrivateDevice

    Description:

        Given the address of a CKsDevice on the target,
        dump information about that device.

    Arguments:

        Private -
            The address of the CKsDevice on the target

        Level -
            The 0-7 dump level

        TabDepth -
            The tab depth to print this at

    Return Value:

    Notes:

*************************************************/

void
DumpPrivateDevice (
    IN DWORD Private,
    IN ULONG Level,
    IN ULONG TabDepth
) {

    CMemoryBlock <CKsDevice> DeviceObject;
    ULONG Result;

    if (!ReadMemory (
        Private,
        DeviceObject.Get (),
        sizeof (CKsDevice),
        &Result
    )) {
        dprintf ("%08lx: unable to read CKsDevice object!\n",
            Private);
        return;
    }

    dprintf ("%sCKsDevice object %08lX [corresponding EXT = %08lx, "
        "KSDEVICE = %08lx]\n",
        Tab (TabDepth),
        Private, FIELDOFFSET(CKsDevice, m_Ext) + Private, 
        FIELDOFFSET(CKsDevice, m_Ext) + FIELDOFFSET(KSDEVICE_EXT, Public) + 
            Private
    );
    dprintf ("%sReference Count          %ld\n",
        Tab (TabDepth),
        GetObjectReferenceCount ((CBaseUnknown *)((CKsDevice *)Private)));

    dprintf ("%sDevice Mutex             %08lx is %s\n",
        Tab (TabDepth),
        FIELDOFFSET(CKsDevice, m_Mutex) + Private,
        DeviceObject -> m_Mutex.Header.SignalState != 1 ? "held" : "not held");
    dprintf ("%sCreatesMayProceed        %ld\n",
        Tab (TabDepth),
        DeviceObject -> m_CreatesMayProceed);
    dprintf ("%sRunsMayProceed           %ld\n",
        Tab (TabDepth),
        DeviceObject -> m_RunsMayProceed);
    dprintf ("%sAdapter Object           %08lx\n",
        Tab (TabDepth),
        DeviceObject -> m_AdapterObject);

    if (Level >= DUMPLVL_HIGHDETAIL) {
        ULONG Count;

        dprintf ("%sClose Irp List:\n", Tab (TabDepth));
        dprintf ("%s", Tab (TabDepth + 1));
        Count = DumpObjQueueList (
            &(DeviceObject -> m_CloseIrpList.ListEntry),
            FIELDOFFSET(CKsDevice, m_CloseIrpList) + Private +
                FIELDOFFSET(INTERLOCKEDLIST_HEAD, ListEntry),
            FIELDOFFSET(IRP, Tail.Overlay.ListEntry),
            FALSE,
            NULL,
            NULL
        );
        if (Count == 0) 
            dprintf ("No close irps pending!\n");
        else
            dprintf ("\n");

        dprintf ("%sPending Create Irps:\n", Tab (TabDepth));
        dprintf ("%s", Tab (TabDepth + 1));
        Count = DumpObjQueueList (
            &(DeviceObject -> m_PendingCreateIrpList.ListEntry),
            FIELDOFFSET(CKsDevice, m_PendingCreateIrpList) + Private +
                FIELDOFFSET(INTERLOCKEDLIST_HEAD, ListEntry),
            FIELDOFFSET(IRP, Tail.Overlay.ListEntry),
            FALSE,
            NULL,
            NULL
        );
        if (Count == 0)
            dprintf ("No create irps pending!\n");
        else
            dprintf ("\n");

        dprintf ("%sPending Run Irps:\n", Tab (TabDepth));
        dprintf ("%s", Tab (TabDepth + 1));
        Count = DumpObjQueueList (
            &(DeviceObject -> m_PendingRunIrpList.ListEntry),
            FIELDOFFSET(CKsDevice, m_PendingRunIrpList) + Private +
                FIELDOFFSET(INTERLOCKEDLIST_HEAD, ListEntry),
            FIELDOFFSET(IRP, Tail.Overlay.ListEntry),
            FALSE,
            NULL,
            NULL
        );
        if (Count == 0)
            dprintf ("No run irps pending!\n");
        else
            dprintf ("\n");
    }
}

/*************************************************

    Function:

        DumpPrivateBag

    Description:

        Given the address of a KSIOBJECTBAG on the target,
        dump the bag's contents.

    Arguments:

        Private -
            The address of the bag
        
        Level -
            The 0-7 dump level to dump at

        TabDepth -
            The tab depth to print this at

*************************************************/

void
DumpPrivateBag (
    IN DWORD Private,
    IN ULONG Level,
    IN ULONG TabDepth
) {

    KSIOBJECTBAG Bag;
    ULONG Result;

    CHAR Buffer [1024];
    ULONG Displ;

    if (!ReadMemory (
        Private,
        &Bag,
        sizeof (KSIOBJECTBAG),
        &Result)) {

        dprintf ("%08lx: unable to read bag!\n", Private);
        return;
    }

    dprintf ("%sObject Bag %08lx:\n", Tab (TabDepth), Private);
    TabDepth++;

    //
    // Scope out the hash table allocation.  The bag structure will end
    // up looking like
    // 
    // HASH TABLE:
    //      HASH ENTRY * -> HASH ENTRY * -> HASH ENTRY * -> /
    //      /
    //      HASH ENTRY * -> HASH ENTRY * -> /
    //      etc...
    //
    // Each HASH ENTRY contains a reference back to an entry in the device
    // bag where reference count, context info, etc... are held.  This allows
    // items to be in multiple bags and be reference counted through the
    // device bag.
    //
    // We have to walk the hash table, each hash chain...  get the device
    // bag entry, and then print.
    //
    {
        CMemory HashTableMem (
            sizeof (PLIST_ENTRY) *
            Bag.HashTableEntryCount
        );
        PLIST_ENTRY HashTable = 
            (PLIST_ENTRY)HashTableMem.Get ();

        KSIOBJECTBAG_ENTRY HashEntry;
        KSIDEVICEBAG_ENTRY DeviceBagEntry;
        PLIST_ENTRY HashChainPointer;

        ULONG HashChain;

        if (!ReadMemory (
            (DWORD)Bag.HashTable,
            HashTable,
            sizeof (LIST_ENTRY) *
                Bag.HashTableEntryCount,
            &Result)) {

            dprintf ("%08lx: unable to read hash table!\n", Bag.HashTable);
            return;

        }

        //
        // Iterate through hash chains in the bag.
        //
        for (HashChain = 0; HashChain < Bag.HashTableEntryCount &&
            !CheckControlC (); 
            HashChain++, HashTable++) {

            //
            // Iterate through the given hash chain.
            //
            HashChainPointer = HashTable -> Flink;
            while (HashChainPointer != 
                (PLIST_ENTRY)
                    (Private + FIELDOFFSET (KSIOBJECTBAG, HashTable) +
                        sizeof (LIST_ENTRY) * HashChain +
                        FIELDOFFSET (LIST_ENTRY, Flink)
                    ) && 
                !CheckControlC ()) {

                #ifdef DEBUG_EXTENSION
                    dprintf ("Reading object bag entry at %08lx [ch=%ld]\n",
                        HashChainPointer, HashChain);
                #endif // DEBUG_EXTENSION

                PKSIOBJECTBAG_ENTRY BagEntry = (PKSIOBJECTBAG_ENTRY)
                    CONTAINING_RECORD (
                        HashChainPointer,
                        KSIOBJECTBAG_ENTRY,
                        ListEntry
                        );

                //
                // Read the hash entry for this object bag item; then
                // fetch the device bag entry.
                //
                if (!ReadMemory (
                    (DWORD)BagEntry,
                    &HashEntry,
                    sizeof (KSIOBJECTBAG_ENTRY),
                    &Result)) {

                    dprintf ("%08lx: unable to read hash entry!\n", 
                        HashChainPointer);
                    return;
                }

                #ifdef DEBUG_EXTENSION
                    dprintf ("Reading device bag entry at %08lx\n",
                        HashEntry.DeviceBagEntry);
                #endif // DEBUG_EXTENSION

                if (!ReadMemory (
                    (DWORD)HashEntry.DeviceBagEntry,
                    &DeviceBagEntry,
                    sizeof (KSIDEVICEBAG_ENTRY),
                    &Result)) {

                    dprintf ("%08x: unable to read device bag entry!\n",
                        HashEntry.DeviceBagEntry);
                    return;
                }

                //
                // Aah...  we finally have enough information to print
                // a single bag item.
                //
                dprintf ("%sObject Bag Item %08lx:\n",
                    Tab (TabDepth),
                    DeviceBagEntry.Item);
                dprintf ("%sReference Count        : %ld\n",
                    Tab (TabDepth + 1),
                    DeviceBagEntry.ReferenceCount);

                Buffer [0] = 0;
                if (DeviceBagEntry.Free) {
                    GetSymbol ((LPVOID)(DeviceBagEntry.Free), Buffer, &Displ);
                    if (Buffer [0] && Displ == 0) {
                        dprintf ("%sItem Cleanup Handler   : %s\n",
                            Tab (TabDepth + 1),
                            Buffer);
                    } else {
                        dprintf ("%sItem Cleanup Handler   : %08lx\n",
                            Tab (TabDepth + 1),
                            DeviceBagEntry.Free);
                    }
                } else {
                    dprintf ("%sItem Cleanup Handler   : ExFreePool "
                        "[default]\n",
                        Tab (TabDepth + 1));
                }

                //
                // Dump out internally useful information.
                //
                if (Level >= DUMPLVL_INTERNAL) {
                    dprintf ("%sObject Bag Entry &     : %08lx\n",
                        Tab (TabDepth + 1),
                        HashChainPointer);
                    dprintf ("%sDevice Bag Entry &     : %08lx\n",
                        Tab (TabDepth + 1),
                        HashEntry.DeviceBagEntry);
                }

                HashChainPointer = HashEntry.ListEntry.Flink;

                #ifdef DEBUG_EXTENSION
                    dprintf ("Next item in hash chain = %08lx\n",
                        HashChainPointer);
                #endif // DEBUG_EXTENSION

            }
        }
    }
}

/**************************************************************************

    Routines to dump public AVStream objects

**************************************************************************/

/*************************************************

    Function:

        DumpPublicPin

    Description:

        Given the address of a KSPIN object on the target,
        dump information about that pin object.

    Arguments:

        Public -
            The address of the public pin (KSPIN) object

        Level -
            The 0-7 dump level to dump at

        TabDepth -
            The tab depth to print this at

    Return Value:

        None

*************************************************/

char *CommunicationNames [] = {
    "None",
    "Sink",
    "Source",
    "Both",
    "Bridge"
};

char *DataflowNames [] = {
    "Unknown",
    "In",
    "Out"
};

#define DumpRelatedPinInfo(Name, InternalPin, TabDepth) \
    { \
        KSPPROCESSPIN InternalPinData;\
\
        if (InternalPin) {\
            if (!ReadMemory (\
                (DWORD)InternalPin,\
                &InternalPinData,\
                sizeof (KSPPROCESSPIN),\
                &Result\
                )) {\
                dprintf ("%lx: unable to read related pin!\n", InternalPin);\
                return;\
            }\
\
            dprintf ("%s%s%08lx [PKSPIN = %08lx]\n",\
                Tab (TabDepth), Name, InternalPin, InternalPinData.Pin);\
        }\
        else \
            dprintf ("%s%s00000000 [PKSPIN = 00000000]\n",\
                Tab (TabDepth), Name);\
    }


void
DumpPublicPin (
    IN DWORD Public,
    IN ULONG Level,
    IN ULONG TabDepth
) {

    IN DWORD ExtAddr;
    KSPIN_EXT PinExt;
    DWORD ClassAddr;
    ULONG Result;

    ExtAddr = (DWORD)(CONTAINING_RECORD(Public, KSPIN_EXT, Public));
    ClassAddr = (DWORD)(CONTAINING_RECORD(ExtAddr, CKsPin, m_Ext));

    if (!ReadMemory (
        ExtAddr,
        &PinExt,
        sizeof (KSPIN_EXT),
        &Result
    )) {
        dprintf ("%lx: unable to read object!\n", Public);
        return;
    }

    dprintf ("%sPin object %08lX [corresponding EXT = %08lx, CKsPin = %08lx]\n",
        Tab (TabDepth),
        Public, ExtAddr, ClassAddr);
    TabDepth++;
    dprintf ("%sDescriptor     %08lx\n", 
        Tab (TabDepth), PinExt.Public.Descriptor);
    dprintf ("%sContext        %08lx\n", 
        Tab (TabDepth), PinExt.Public.Context);
    dprintf ("%sId             %d\n", 
        Tab (TabDepth), PinExt.Public.Id);

    if (Level >= DUMPLVL_GENERAL) {
        dprintf ("%sCommunication  %s\n", 
            Tab (TabDepth), 
            CommunicationNames [PinExt.Public.Communication]);
        dprintf ("%sDataFlow       %s\n", 
            Tab (TabDepth),
            DataflowNames [PinExt.Public.DataFlow]);

        XTN_DUMPGUID("Interface     ", TabDepth, 
            (PinExt.Public.ConnectionInterface));
        XTN_DUMPGUID("Medium        ", TabDepth, 
            (PinExt.Public.ConnectionMedium));

        dprintf ("%sStreamHdr Size %08lx\n", 
            Tab (TabDepth),
            PinExt.Public.StreamHeaderSize);
        dprintf ("%sDeviceState    %ld\n",
            Tab (TabDepth),
            PinExt.Public.DeviceState);
        dprintf ("%sResetState     %ld\n",
            Tab (TabDepth),
            PinExt.Public.ResetState);

    }

    if (Level >= DUMPLVL_INTERNAL) {
        DWORD FilterAddr;
        KMUTEX Mutex;

        FilterAddr = ((DWORD)FIELDOFFSET(KSFILTER_EXT, Public)) + 
            (DWORD)PinExt.Parent;

        dprintf ("%sINTERNAL INFORMATION:\n", Tab (TabDepth));
        dprintf ("%sPublic Parent Filter    %08lx\n", 
            Tab (TabDepth + 1), FilterAddr);
        dprintf ("%sAggregated Unknown      %08lx\n", 
            Tab (TabDepth + 1),
            PinExt.AggregatedClientUnknown);
        dprintf ("%sDevice Interface        %08lx\n",
            Tab (TabDepth + 1),
            PinExt.Device);

        if (ReadMemory (
            (DWORD)PinExt.FilterControlMutex,
            &Mutex,
            sizeof (KMUTEX),
            &Result
        )) {
            dprintf ("%sControl Mutex           %08lx is %s\n",
                Tab (TabDepth + 1),
                PinExt.FilterControlMutex,
                Mutex.Header.SignalState != 1 ? "held" : "not held");
        }
        
        if (Level >= DUMPLVL_HIGHDETAIL) {
            KSPPROCESSPIN ProcessPin;
            KSPPROCESSPIPESECTION ProcessPipe;

            dprintf ("%sProcess Pin             %08lx:\n",
                Tab (TabDepth + 1),
                PinExt.ProcessPin);

            if (!ReadMemory (
                (DWORD)PinExt.ProcessPin,
                &ProcessPin,
                sizeof (KSPPROCESSPIN),
                &Result
            )) {
                dprintf ("%lx: unable to read process pin!\n",
                    PinExt.ProcessPin);
                return;
            }

            if (!ReadMemory (
                (DWORD)ProcessPin.PipeSection,
                &ProcessPipe,
                sizeof (KSPPROCESSPIPESECTION),
                &Result
            )) {
                dprintf ("%lx: unable to read process pipe!\n",
                    (DWORD)ProcessPin.PipeSection);
                return;
            }

            dprintf ("%sPipe Section (if)   %08lx\n",
                Tab (TabDepth + 2),
                ProcessPipe.PipeSection);
            
            DumpRelatedPinInfo ("Inplace Counterpart ",
                ProcessPin.InPlaceCounterpart, TabDepth + 2);
            DumpRelatedPinInfo ("Copy Source         ",
                ProcessPin.CopySource, TabDepth + 2);
            DumpRelatedPinInfo ("Delegate Branch     ",
                ProcessPin.DelegateBranch, TabDepth + 2);

            dprintf ("%sNext Process Pin    %08lx\n",
                Tab (TabDepth + 2),
                ProcessPin.Next);
            dprintf ("%sPipe Id             %08lx\n",
                Tab (TabDepth + 2),
                ProcessPin.PipeId);
            dprintf ("%sAllocator           %08lx\n",
                Tab (TabDepth + 2),
                ProcessPin.AllocatorFileObject);
            dprintf ("%sFrameGate           %08lx\n",
                Tab (TabDepth + 2),
                ProcessPin.FrameGate);
            dprintf ("%sFrameGateIsOr       %ld\n",
                Tab (TabDepth + 2),
                ProcessPin.FrameGateIsOr);

        } else {

            dprintf ("%sProcess Pin             %08lx\n",
                Tab (TabDepth + 1),
                PinExt.ProcessPin);

        }

    }

    if (Level >= DUMPLVL_HIGHDETAIL) {
        dprintf ("%sObject Event List:\n", Tab (TabDepth));
        if (DumpExtEventList (ExtAddr, TabDepth + 1) == 0)
            dprintf ("%sNone\n", Tab (TabDepth + 1));
        DumpPrivatePin (ClassAddr, Level, TabDepth);
    }

}

/*************************************************

    Function:

        DumpPublicFilter

    Description:

        Dump a KSFILTER structure

    Arguments:

        Public -
            Points to the KSFILTER structure on the target

        Level -
            The 0-7 dump level

        TabDepth -
            The tab depth to print this at

    Return Value:

        None

    Notes:

*************************************************/

void
DumpPublicFilter (
    IN DWORD Public,
    IN ULONG Level,
    IN ULONG TabDepth
) {

    IN DWORD ExtAddr;
    KSFILTER_EXT FilterExt;
    DWORD ClassAddr;
    ULONG Result;

    ExtAddr = (DWORD)(CONTAINING_RECORD(Public, KSFILTER_EXT, Public));
    ClassAddr = (DWORD)(CONTAINING_RECORD(ExtAddr, CKsFilter, m_Ext));

    if (!ReadMemory (
        ExtAddr,
        &FilterExt,
        sizeof (KSFILTER_EXT),
        &Result
    )) {
        dprintf ("%lx: unable to read object!\n", Public);
        return;
    }

    dprintf ("%sFilter object %08lX [corresponding EXT = %08lx, "
        "CKsFilter = %08lx]\n", Tab (TabDepth), Public, ExtAddr, ClassAddr);
    TabDepth++;
    dprintf ("%sDescriptor     %08lx:\n", 
        Tab (TabDepth), FilterExt.Public.Descriptor);

    if (Level >= DUMPLVL_BEYONDGENERAL) {
        KSFILTER_DESCRIPTOR Descriptor;
        GUID *Categories, *CatTrav;
        ULONG i;

        if (!ReadMemory (
            (DWORD)FilterExt.Public.Descriptor,
            &Descriptor,
            sizeof (KSFILTER_DESCRIPTOR),
            &Result
        )) {
            dprintf ("%08lx: unable to read descriptor!\n",
                FilterExt.Public.Descriptor);
            return;
        }

        Categories = (GUID *)malloc (
            sizeof (GUID) * Descriptor.CategoriesCount);

        if (!ReadMemory (
            (DWORD)Descriptor.Categories,
            Categories,
            sizeof (GUID) * Descriptor.CategoriesCount,
            &Result
        )) {
            dprintf ("%08lx: unable to read category guids!\n",
                Descriptor.Categories);
            return;
        }

        dprintf ("%sFilter Category GUIDs:\n", Tab (TabDepth));
        CatTrav = Categories;
        i = Descriptor.CategoriesCount;
        while (i && !CheckControlC ()) {
            XTN_DUMPGUID ("\0", TabDepth + 1, *CatTrav);
            CatTrav++;
            i--;
        }

        free (Categories);

    }

    dprintf ("%sContext        %08lx\n", 
        Tab (TabDepth), FilterExt.Public.Context);

    if (Level >= DUMPLVL_INTERNAL) {
        
        DWORD FactoryAddr;
        KMUTEX Mutex;

        dprintf ("%sINTERNAL INFORMATION:\n", Tab (TabDepth));

        FactoryAddr = (DWORD)FilterExt.Parent + 
            FIELDOFFSET(KSFILTERFACTORY_EXT, Public);
        dprintf ("%sPublic Parent Factory   %08lx\n", 
            Tab (TabDepth + 1), FactoryAddr);
        dprintf ("%sAggregated Unknown      %08lx\n", 
            Tab (TabDepth + 1),
            FilterExt.AggregatedClientUnknown);
        dprintf ("%sDevice Interface        %08lx\n",
            Tab (TabDepth + 1),
            FilterExt.Device);

        if (ReadMemory (
            (DWORD)FilterExt.FilterControlMutex,
            &Mutex,
            sizeof (KMUTEX),
            &Result
        )) {
            dprintf ("%sControl Mutex           %08lx is %s\n",
                Tab (TabDepth + 1),
                FilterExt.FilterControlMutex,
                Mutex.Header.SignalState != 1 ? "held" : "not held");
        }
    }

    if (Level >= DUMPLVL_HIGHDETAIL) {
        dprintf ("%sObject Event List:\n", Tab (TabDepth));
        if (DumpExtEventList (ExtAddr, TabDepth + 1) == 0)
            dprintf ("%sNone\n", Tab (TabDepth + 1));
        DumpPrivateFilter (ClassAddr, Level, TabDepth);
    }

}

/*************************************************

    Function:

        DumpPublicFilterFactory

    Description:

        Given an address of a KSFILTERFACTORY on the target, dump it

    Arguments:

        Public -
            The address of the KSFILTERFACTORY on the target

        Level -
            The 0-7 dump level

        TabDepth -
            The tab depth to print this at

    Return Value:

    Notes:

*************************************************/

void 
DumpPublicFilterFactory (
    IN DWORD Public,
    IN ULONG Level,
    IN ULONG TabDepth
) {

    DWORD ExtAddr;
    DWORD ClassAddr;
    ULONG Result;
    KSFILTERFACTORY_EXT FactoryExt;

    ExtAddr = (DWORD)(CONTAINING_RECORD(Public, KSFILTERFACTORY_EXT, Public));
    ClassAddr = (DWORD)(CONTAINING_RECORD(ExtAddr, CKsFilterFactory, m_Ext));

    if (!ReadMemory (
        ExtAddr,
        &FactoryExt,
        sizeof (KSFILTERFACTORY_EXT),
        &Result
    )) {
        dprintf ("%lx: unable to read object!\n", Public);
        return;
    }

    dprintf ("%sFilter Factory object %08lX [corresponding EXT = %08lx, "
        "CKsDevice = %08lx]\n", Tab (TabDepth), Public, ExtAddr, ClassAddr);
    TabDepth++;
    dprintf ("%sDescriptor     %08lx\n", 
        Tab (TabDepth), FactoryExt.Public.FilterDescriptor);

    dprintf ("%sContext        %08lx\n", 
        Tab (TabDepth), FactoryExt.Public.Context);

    if (Level >= DUMPLVL_INTERNAL) {
        
        DWORD DeviceAddr;

        dprintf ("%sINTERNAL INFORMATION:\n", Tab (TabDepth));

        DeviceAddr = (DWORD)FactoryExt.Parent + 
            FIELDOFFSET(KSDEVICE_EXT, Public);
        dprintf ("%sPublic Parent Device    %08lx\n", 
            Tab (TabDepth + 1), DeviceAddr);
        dprintf ("%sAggregated Unknown      %08lx\n", 
            Tab (TabDepth + 1),
            FactoryExt.AggregatedClientUnknown);
        dprintf ("%sDevice Interface        %08lx\n",
            Tab (TabDepth + 1),
            FactoryExt.Device);

    }

    if (Level >= DUMPLVL_HIGHDETAIL) 
        DumpPrivateFilterFactory (ClassAddr, Level, TabDepth);

}

/*************************************************

    Function:

        DumpPublicDevice

    Description:

        Given an address of a KSDEVICE on the target, dump it

    Arguments:

        Public -
            The address of the KSDEVICE on the target

        Level -
            The 0-7 dump level

        TabDepth -
            The tab depth to print this at

    Return Value:

    Notes:

*************************************************/

void
DumpPublicDevice (
    IN DWORD Public,
    IN ULONG Level,
    IN ULONG TabDepth
) {

    IN DWORD ExtAddr;
    KSDEVICE_EXT DeviceExt;
    DWORD ClassAddr;
    ULONG Result;

    BOOLEAN Named = FALSE;

    ExtAddr = (DWORD)(CONTAINING_RECORD(Public, KSDEVICE_EXT, Public));
    ClassAddr = (DWORD)(CONTAINING_RECORD(ExtAddr, CKsDevice, m_Ext));

    if (!ReadMemory (
        ExtAddr,
        &DeviceExt,
        sizeof (KSDEVICE_EXT),
        &Result
    )) {
        dprintf ("%lx: unable to read object!\n", Public);
        return;
    }

    dprintf ("%sDevice object %08lX [corresponding EXT = %08lx, "
        "CKsDevice = %08lx]\n", Tab (TabDepth), Public, ExtAddr, ClassAddr);
    TabDepth++;
    dprintf ("%sDescriptor     %08lx\n", 
        Tab (TabDepth), DeviceExt.Public.Descriptor);

    Named = FALSE;

    // 
    // PDO
    //
    if (DeviceExt.Public.PhysicalDeviceObject) {
        //
        // Find out the owning driver.
        //
        DWORD DriverObjAddr, NameAddr;
        PDRIVER_OBJECT DriverObject;
        UNICODE_STRING Name;

        DriverObjAddr = (DWORD)DeviceExt.Public.PhysicalDeviceObject +
            FIELDOFFSET(DEVICE_OBJECT, DriverObject);

        if (ReadMemory (
            DriverObjAddr,
            &DriverObject,
            sizeof (PDRIVER_OBJECT),
            &Result
        )) {

            NameAddr = (DWORD)DriverObject +
                FIELDOFFSET(DRIVER_OBJECT, DriverName);
    
            if (ReadMemory (
                NameAddr,
                &Name,
                sizeof (UNICODE_STRING),
                &Result
            )) {
    
                PWSTR Buffer = (PWSTR)malloc (
                    Name.MaximumLength * sizeof (WCHAR));
    
                UNICODE_STRING HostString;
    
                //
                // We have the unicode string name...  Allocate enough memory to
                // read the thing.
                //
    
                if (!ReadMemory (
                    (DWORD)Name.Buffer,
                    Buffer,
                    sizeof (WCHAR) * Name.MaximumLength,
                    &Result
                )) {
                    dprintf ("%08lx: unable to read unicode string buffer!\n",
                        Name.Buffer);
                    return;
                }
    
                HostString.MaximumLength = Name.MaximumLength;
                HostString.Length = Name.Length;
                HostString.Buffer = Buffer;

                Named = TRUE;
    
                dprintf ("%sPDO            %08lx [%wZ]\n", 
                    Tab (TabDepth),
                    DeviceExt.Public.PhysicalDeviceObject,
                    &HostString);
    
                free (Buffer);
            }
        }
    }
    if (!Named) {
        dprintf ("%sPDO            %08lx\n", 
            Tab (TabDepth),
            DeviceExt.Public.PhysicalDeviceObject);
    }

    Named = FALSE;
    //
    // FDO
    //
    if (DeviceExt.Public.FunctionalDeviceObject) {
        //
        // Find out the owning driver.
        //
        DWORD DriverObjAddr, NameAddr;
        PDRIVER_OBJECT DriverObject;
        UNICODE_STRING Name;

        DriverObjAddr = (DWORD)DeviceExt.Public.FunctionalDeviceObject +
            FIELDOFFSET(DEVICE_OBJECT, DriverObject);

        if (ReadMemory (
            DriverObjAddr,
            &DriverObject,
            sizeof (PDRIVER_OBJECT),
            &Result
        )) {

            NameAddr = (DWORD)DriverObject +
                FIELDOFFSET(DRIVER_OBJECT, DriverName);
    
            if (ReadMemory (
                NameAddr,
                &Name,
                sizeof (UNICODE_STRING),
                &Result
            )) {
    
                PWSTR Buffer = (PWSTR)malloc (
                    Name.MaximumLength * sizeof (WCHAR));
    
                UNICODE_STRING HostString;
    
                //
                // We have the unicode string name...  Allocate enough memory to
                // read the thing.
                //
    
                if (!ReadMemory (
                    (DWORD)Name.Buffer,
                    Buffer,
                    sizeof (WCHAR) * Name.MaximumLength,
                    &Result
                )) {
                    dprintf ("%08lx: unable to read unicode string buffer!\n",
                        Name.Buffer);
                    return;
                }
    
                HostString.MaximumLength = Name.MaximumLength;
                HostString.Length = Name.Length;
                HostString.Buffer = Buffer;

                Named = TRUE;
    
                dprintf ("%sFDO            %08lx [%wZ]\n", 
                    Tab (TabDepth),
                    DeviceExt.Public.FunctionalDeviceObject,
                    &HostString);
    
                free (Buffer);
            }
        }
    }
    if (!Named) {
        dprintf ("%sFDO            %08lx\n",
            Tab (TabDepth),
            DeviceExt.Public.FunctionalDeviceObject);
    }

    Named = FALSE;
    //
    // NDO
    //
    if (DeviceExt.Public.NextDeviceObject) {
        //
        // Find out the owning driver.
        //
        DWORD DriverObjAddr, NameAddr;
        PDRIVER_OBJECT DriverObject;
        UNICODE_STRING Name;

        DriverObjAddr = (DWORD)DeviceExt.Public.NextDeviceObject +
            FIELDOFFSET(DEVICE_OBJECT, DriverObject);

        if (ReadMemory (
            DriverObjAddr,
            &DriverObject,
            sizeof (PDRIVER_OBJECT),
            &Result
        )) {

            NameAddr = (DWORD)DriverObject +
                FIELDOFFSET(DRIVER_OBJECT, DriverName);
    
            if (ReadMemory (
                NameAddr,
                &Name,
                sizeof (UNICODE_STRING),
                &Result
            )) {
    
                PWSTR Buffer = (PWSTR)malloc (
                    Name.MaximumLength * sizeof (WCHAR));
    
                UNICODE_STRING HostString;
    
                //
                // We have the unicode string name...  Allocate enough memory to
                // read the thing.
                //
    
                if (!ReadMemory (
                    (DWORD)Name.Buffer,
                    Buffer,
                    sizeof (WCHAR) * Name.MaximumLength,
                    &Result
                )) {
                    dprintf ("%08lx: unable to read unicode string buffer!\n",
                        Name.Buffer);
                    return;
                }
    
                HostString.MaximumLength = Name.MaximumLength;
                HostString.Length = Name.Length;
                HostString.Buffer = Buffer;

                Named = TRUE;
    
                dprintf ("%sNext DevObj    %08lx [%wZ]\n", 
                    Tab (TabDepth),
                    DeviceExt.Public.NextDeviceObject,
                    &HostString);
    
                free (Buffer);
            }
        }
    }
    if (!Named) {
        dprintf ("%sNext DevObj    %08lx\n",
            Tab (TabDepth),
            DeviceExt.Public.NextDeviceObject);
    }
    dprintf ("%sStarted        %ld\n",
        Tab (TabDepth),
        DeviceExt.Public.Started);
    dprintf ("%sSystemPower    %ld\n",
        Tab (TabDepth),
        DeviceExt.Public.SystemPowerState);
    dprintf ("%sDevicePower    %ld\n",
        Tab (TabDepth),
        DeviceExt.Public.DevicePowerState);

    if (Level >= DUMPLVL_HIGHDETAIL) 
        DumpPrivateDevice (ClassAddr, Level, TabDepth);

}

/*************************************************

    Function:

        DumpCircuitPipeRelevencies

    Description:

        Dump any information pertaining to a pipe section which is relevant
        to knowing in tracing a circuit.

    Arguments:

        TabDepth -
            The tab depth to print information at

        PipeSection -
            The target pointer for the pipe section which to dump

*************************************************/

void
DumpCircuitPipeRelevencies (
    IN ULONG TabDepth,
    IN CKsPipeSection *PipeSection
    )

{

    CMemoryBlock <CKsPipeSection> PipeObject;
    ULONG Result;

    if (!PipeSection) {
        dprintf ("%sCannot read associated pipe section!\n",
            Tab (TabDepth));
        return;
    }

    if (!ReadMemory (
        (DWORD)PipeSection,
        PipeObject.Get (),
        sizeof (CKsPipeSection),
        &Result)) {
        
        dprintf ("%08lx: cannot read pipe section!\n", PipeSection);
        return;
    }

    //
    // BUGBUG:
    //
    // Determine whether or not the pipe section is the owner of the pipe
    // and display this information.  Most people should be able to figure
    // this out easily, but it'd be nice to display
    //
    dprintf ("%sPipe%lx (PipeId = %lx, State = %ld, Reset State = %ld)\n",
        Tab (TabDepth),
        PipeSection,
        PipeObject -> m_Id,
        PipeObject -> m_DeviceState,
        PipeObject -> m_ResetState
        );

}

typedef struct _DUMP_CIRCUIT_CONTEXT {

    ULONG TabDepth;
    ULONG DumpLevel;

} DUMP_CIRCUIT_CONTEXT, *PDUMP_CIRCUIT_CONTEXT;

/*************************************************

    Function:

        DumpCircuitCallback

    Description:

        This is the WalkCircuit callback for !ks.dumpcircuit.  Display
        information about the circuit element.

    Arguments:

        Context -
            The context structure (DUMP_CIRCUIT_CONTEXT)

        Type -
            The type of object

        Base -
            The object (base address)

        Object -
            The object itself

    Return Value:

        FALSE : do not stop walking

*************************************************/

BOOLEAN
DumpCircuitCallback (
    IN PVOID Context,
    IN INTERNAL_OBJECT_TYPE Type,
    IN DWORD Base,
    IN PVOID Object
    )

{

#define FRIENDLY_BU(obj) \
    ((CFriendlyBaseUnknown *)((CBaseUnknown *)obj))

    PDUMP_CIRCUIT_CONTEXT DumpContext = (PDUMP_CIRCUIT_CONTEXT)Context;
    ULONG TabDepth = DumpContext -> TabDepth;
    ULONG DumpLevel = DumpContext -> DumpLevel;
    ULONG Result;
    ULONG RefCount;

    switch (Type) {

        case ObjectTypeCKsPin:
        {
            CKsPin *PinObject = (CKsPin *)Object;

            RefCount = CFriendlyBaseUnknown::GetRefCount (
                FRIENDLY_BU (PinObject)
                );

            if (PinObject -> m_TransportSink == NULL || 
                PinObject -> m_TransportSource == NULL) {

                //
                // We have a CKsPin which appears to have been bypassed
                // during circuit construction.  We will suggest that
                // they try the queue instead.
                //

                KSPPROCESSPIPESECTION PipeSection;

                if (ReadMemory (
                    (DWORD)PinObject -> m_Process.PipeSection,
                    &PipeSection,
                    sizeof (KSPPROCESSPIPESECTION),
                    &Result
                )) {
                    dprintf ("%sPin%lX appears bypassed, try Queue%lX\n",
                        Tab (TabDepth),
                        Base, PipeSection.Queue);
                } else {
                    dprintf ("%sPin%lX appears bypassed!\n",
                        Tab (TabDepth),
                        Base
                    );
                }
            } else {                        
                dprintf ("%sPin%lX %d (%s, %s) refs=%d\n", 
                    Tab (TabDepth),
                    Base,
                    PinObject -> m_Ext.Public.Id,
                    PinObject -> m_ConnectionFileObject ? "src" : "snk",
                    PinObject -> m_Ext.Public.DataFlow == 
                        KSPIN_DATAFLOW_OUT ? "out" : "in",
                    RefCount
                );
            };

            break;

        }

        case ObjectTypeCKsQueue:
        {
            CKsQueue *QueueObject = (CKsQueue *)Object;

            RefCount = CFriendlyBaseUnknown::GetRefCount (
                FRIENDLY_BU (QueueObject)
                );

            dprintf ("%sQueue%lX r/w/c=%d/%d/%d refs=%ld\n",
                Tab (TabDepth),
                Base,
                QueueObject -> m_FramesReceived,
                QueueObject -> m_FramesWaiting,
                QueueObject -> m_FramesCancelled,
                RefCount
            );

            //
            // If the dump level specifies more information, dump 
            // details about the pipe section.
            //
            if (DumpLevel >= DUMPLVL_SPECIFIC) 
                DumpCircuitPipeRelevencies (
                    TabDepth + 1,
                    (CKsPipeSection *)(QueueObject -> m_PipeSection)
                    );

            break;

        }

        case ObjectTypeCKsRequestor:
        {
            CKsRequestor *RequestorObject = (CKsRequestor *)Object;

            RefCount = CFriendlyBaseUnknown::GetRefCount (
                FRIENDLY_BU (RequestorObject)
                );

            dprintf ("%sReq%lX refs=%ld alloc=%lx size=%d count=%d\n",
                Tab (TabDepth),
                Base,
                RefCount,
                RequestorObject -> m_AllocatorFileObject,
                RequestorObject -> m_FrameSize,
                RequestorObject -> m_FrameCount
            );

            //
            // If the dump level specifies more information, dump
            // details about the pipe section.
            //
            if (DumpLevel >= DUMPLVL_SPECIFIC)
                DumpCircuitPipeRelevencies (
                    TabDepth + 1,
                    (CKsPipeSection *)(RequestorObject -> m_PipeSection)
                    );

            break;

        }

        case ObjectTypeCKsSplitter:
        {
            CKsSplitter *SplitterObject = (CKsSplitter *)Object;

            RefCount = CFriendlyBaseUnknown::GetRefCount (
                FRIENDLY_BU (SplitterObject)
                );

            dprintf ("%sSplit%lX refs=%ld\n",
                Tab (TabDepth),
                Base,
                RefCount
                );

            break;

        }

        case ObjectTypeCKsSplitterBranch:
        {
            CKsSplitterBranch *BranchObject = (CKsSplitterBranch *)Object;

            RefCount = CFriendlyBaseUnknown::GetRefCount (
                FRIENDLY_BU (BranchObject)
                );

            dprintf ("%sBranch%lX refs=%ld\n",
                Tab (TabDepth),
                Base,
                RefCount
                );

            break;
        }

        default:

            dprintf ("%lx: Detected a bad object [%s] in the circuit!\n",
                Base,
                ObjectNames [Type]);
            return TRUE;

    }

    return FALSE;

}

/*************************************************

    Function:

        WalkCircuit

    Description:

        Walk around a circuit, making a callback for each item in the
        circuit (base address and type)

    Arguments:

        Object -
            Starting object address of the walk

        Callback -
            The callback

        CallbackContext -
            The callback context

    Return Value:

        Number of items in the circuit

*************************************************/

ULONG
WalkCircuit (
    IN PVOID Object,
    IN PFNCIRCUIT_WALK_CALLBACK Callback,
    IN PVOID CallbackContext
    )

{

    DWORD Address, Base, TopBase;
    ULONG Result;
    PIKSTRANSPORT NextObj;
    INTERNAL_OBJECT_TYPE CurrentObjectType;
    INTERNAL_OBJECT_TYPE NextObjectType;

    ULONG WalkCount = 0;

    Address = (DWORD)Object;

    //
    // Identify what the heck the user is pointing us at.
    //
    CurrentObjectType = DemangleAndAttemptIdentification (
        Address, &Base, NULL);

    if (CurrentObjectType == ObjectTypeUnknown) {
        dprintf ("%lx: This object cannot be identified!\n", Address);
        return 0;
    }

    TopBase = Base;

    //
    // Walk around the circuit until we get back where we started.  Where
    // we started is TopBase.  Base will be the current base address of the
    // object in the circuit.
    //
    do {

        #ifdef DEBUG_EXTENSION
            dprintf ("Object in circuit: type = %ld, base = %lx\n",
                CurrentObjectType, Base);
        #endif // DEBUG_EXTENSION

        switch (CurrentObjectType) {

            case ObjectTypeCKsPin:
            {
                CMemoryBlock <CKsPin> PinObject;

                if (!ReadMemory (
                    Base,
                    PinObject.Get (),
                    sizeof (CKsPin),
                    &Result
                )) {
                    dprintf ("%lx: cannot read pin object!\n",
                        Base);
                    return WalkCount;
                }

                WalkCount++;

                if (Callback (CallbackContext, CurrentObjectType, 
                    Base, PinObject.Get ())) {
                    NextObj = NULL;
                    break;
                }

                NextObj = PinObject -> m_TransportSink;

                break;

            }

            case ObjectTypeCKsQueue:
            {
                CMemoryBlock <CKsQueue> QueueObject;

                if (!ReadMemory (
                    Base,
                    QueueObject.Get (),
                    sizeof (CKsQueue),
                    &Result
                )) {
                    dprintf ("%lx: cannot read queue object!\n",
                        Base);
                    return WalkCount;
                }

                WalkCount++;

                if (Callback (CallbackContext, CurrentObjectType, 
                    Base, QueueObject.Get ())) {
                    NextObj = NULL;
                    break;
                }

                NextObj = QueueObject -> m_TransportSink;

                break;

            }

            case ObjectTypeCKsRequestor:
            {
                CMemoryBlock <CKsRequestor> RequestorObject;

                if (!ReadMemory (
                    Base,
                    RequestorObject.Get (),
                    sizeof (CKsRequestor),
                    &Result
                )) {
                    dprintf ("%lx: cannot read requestor object!\n",
                        Base);
                    return WalkCount;
                }

                WalkCount++;

                if (Callback (CallbackContext, CurrentObjectType, 
                    Base, RequestorObject.Get ())) {
                    NextObj = NULL;
                    break;
                }

                NextObj = RequestorObject -> m_TransportSink;

                break;

            }

            case ObjectTypeCKsSplitter:
            {
                CMemoryBlock <CKsSplitter> SplitterObject;

                if (!ReadMemory (
                    Base,
                    SplitterObject.Get (),
                    sizeof (CKsSplitter),
                    &Result
                )) {
                    dprintf ("%lx: cannot read splitter object!\n",
                        Base);
                    return WalkCount;
                }

                WalkCount++;

                if (Callback (CallbackContext, CurrentObjectType,
                    Base, SplitterObject.Get ())) {
                    NextObj = NULL;
                    break;
                }

                NextObj = SplitterObject -> m_TransportSink;

                break;

            }

            case ObjectTypeCKsSplitterBranch:
            {
                CMemoryBlock <CKsSplitterBranch> BranchObject;

                if (!ReadMemory (
                    Base,
                    BranchObject.Get(),
                    sizeof (CKsSplitterBranch),
                    &Result)) {
                    dprintf ("%lx: cannot read branch object!\n",
                        Base);
                    return WalkCount;
                }

                WalkCount++;

                if (Callback (CallbackContext, CurrentObjectType,
                    Base, BranchObject.Get ())) {
                    NextObj = NULL;
                    break;
                }

                NextObj = BranchObject -> m_TransportSink;

                break;

            }

            default:

                dprintf ("%lx: Detected a bad object [%s] in the circuit!\n",
                    ObjectNames [CurrentObjectType]);
                return WalkCount;

        }

        #ifdef DEBUG_EXTENSION
            dprintf ("%lx: Next transport in circuit = %lx\n",
                Base, NextObj);
        #endif // DEBUG_EXTENSION

        //
        // NextObj now holds the transport sink of whatever object we're
        // done printing.  Now, we must determine what the heck kind of
        // object this IKsTransport* really is and we must get the base
        // address of it.  Again, DemangleAndAttemptIdentification comes
        // to the rescue.  (So would a PDB <cough cough>, unfortunately,
        // 9x dists don't use them)
        //

        if (NextObj != NULL) {	
    
            CurrentObjectType = DemangleAndAttemptIdentification (
                (DWORD)NextObj,
                &Base,
                NULL
            );
    
            if (CurrentObjectType == ObjectTypeUnknown) {
                dprintf ("%lx: cannot identify next object in circuit!\n",
                    NextObj);
                return WalkCount;
            }

        } else {
            
            Base = 0;

        }

    } while (Base != TopBase && Base != 0 && !CheckControlC ());

    return WalkCount;

}

/**************************************************************************

    AVStream API

**************************************************************************/

/*************************************************

    Function:

        AdjustFileToPublicObject

    Description:

        This is a helper function for the APIs to adjust a file object to
        a public AVStream object.

    Arguments:

        Address -
            The address of the file object

    Return Value:

        The address of the public object associated.  Note, we do not attempt
        to type identify the object

*************************************************/

DWORD 
AdjustFileToPublicObject (
    IN DWORD Address
    )

{
    PKSIOBJECT_HEADER *FSContext, ObjectHeader;
    PVOID Object;
    ULONG Result;

    #ifdef DEBUG_EXTENSION
        if (!signature_check (Address, SignatureFile))
            return Address;
    #endif // DEBUG_EXTENSION

    if (!ReadMemory (
        (DWORD)Address + FIELDOFFSET (FILE_OBJECT, FsContext),
        &FSContext,
        sizeof (PKSIOBJECT_HEADER *),
        &Result)) {

        dprintf ("%08lx: cannot read fscontext of file object!\n", Address);
        return Address;
    }

    if (!ReadMemory (
        (DWORD)FSContext,
        &ObjectHeader,
        sizeof (PKSIOBJECT_HEADER),
        &Result)) {

        dprintf ("%08lx: cannot read object header!\n", FSContext);
        return Address;
    }

    if (!ObjectHeader) {
        dprintf ("%08lx: this does not refer to an AVStream object!\n",
            ObjectHeader);
        return Address;
    }

    if (!ReadMemory (
        (DWORD)ObjectHeader + FIELDOFFSET (KSIOBJECT_HEADER, Object),
        &Object,
        sizeof (PVOID),
        &Result)) {

        dprintf ("%08x: cannot read object from header!\n", ObjectHeader);
        return Address;
    }

    if (!Object) {
        dprintf ("%08lx: this does not refer to an AVStream object!\n",
            Object);
        return Address;
    }

    return (DWORD)Object + FIELDOFFSET (KSPX_EXT, Public);

}

/*************************************************

    Function:

        AdjustIrpToPublicObject

    Description:

        This is a helper function for the APIs to adjust an Irp to a public
        AVStream object. 

    Arguments:

        Address -
            The address of the irp

    Return Value:

        The address of the public object associated.  Note, we do not attempt
        to type identify the object.

*************************************************/

DWORD
AdjustIrpToPublicObject (
    IN DWORD Address
    )

{

    PIO_STACK_LOCATION CurrentIrpStack;
    PFILE_OBJECT FileObject;
    ULONG Result;
    DWORD Public;

    #ifdef DEBUG_EXTENSION
        if (!signature_check (Address, SignatureIrp))
            return Address;
    #endif // DEBUG_EXTENSION

    //
    // Get the current Irp stack location...
    //
    if (!ReadMemory (
        Address + FIELDOFFSET (IRP, Tail.Overlay.CurrentStackLocation),
        &CurrentIrpStack,
        sizeof (PIO_STACK_LOCATION),
        &Result)) {

        dprintf ("%08lx: cannot read current irp stack!\n", Address);
        return Address;
    }

    //
    // Now get file object, and then use the adjuster for that to get
    // the address of the public.
    //
    if (!ReadMemory (
        (DWORD)CurrentIrpStack + FIELDOFFSET (IO_STACK_LOCATION, FileObject),
        &FileObject,
        sizeof (PFILE_OBJECT),
        &Result)) {

        dprintf ("%08lx: cannot read file object of irp stack!\n", 
            CurrentIrpStack);
        return Address;
    }

    //
    // Here's a tricky part.  If this happens to be a create Irp...  the 
    // file object will be the file object of the pin, not of the parent
    // performing the create.  That won't tell us lots on an uninitialized
    // child.  In this case, we adjust such that we dump the parent and inform
    // the user that we're doing this.
    //
    if (irp_stack_match (Address, IRP_MJ_CREATE, (UCHAR)-1)) {

        PFILE_OBJECT ChildFile = FileObject;
        PVOID ChildContext;

        if (!ReadMemory (
            (DWORD)ChildFile + FIELDOFFSET (FILE_OBJECT, RelatedFileObject),
            &FileObject,
            sizeof (PFILE_OBJECT),
            &Result)) {

            dprintf ("%08lx: cannot read parent file object from file object!"
                "\n", ChildFile);
            return Address;
        }

        //
        // Perhaps not the best place to do this informing as this function
        // is intended to adjust.  But it works and it's debug extension
        // code...
        //
        dprintf ("%sIRP %08lx is a create Irp.  Child file object = %08lx\n",
            Tab (INITIAL_TAB), Address, ChildFile);

        if (!ReadMemory (
            (DWORD)ChildFile + FIELDOFFSET (FILE_OBJECT, FsContext),
            &ChildContext,
            sizeof (PVOID),
            &Result)) {

            dprintf ("%08lx: cannot read child FsContext!\n",
                ChildFile);
            return Address;
        }

        //
        // Check to see if the child is before or after header creation.
        //
        if (ChildContext != NULL) {
            dprintf ("%sChild is at least partially created (!ks.dump %08lx "
                "for more).\n",
                Tab (INITIAL_TAB), ChildFile);
        } else {
            dprintf ("%sChild object header is not yet built (create not yet"
                " near complete).\n",
                Tab (INITIAL_TAB), ChildFile);
        }

        dprintf ("%sParent file object %08lx is being displayed!\n\n",
            Tab (INITIAL_TAB), FileObject);
    }

    Public = AdjustFileToPublicObject ((DWORD)FileObject);
    if (Public != (DWORD)FileObject)
        return Public;
    else
        return Address;

}

/*************************************************

    Function:

        dump

    Usage:

        !avstream.dump <Any valid AVStream object> <dump level>

    Description:

        Dump the object presented

*************************************************/

DECLARE_API(dump) {

    DWORD Public, ExtAddr;
    KSPX_EXT ObjExt;
    ULONG Result;
    char objStr[256], lvlStr[256], *pLvl;
    ULONG DumpLevel;

    PIRP IrpInfo = NULL;

    GlobInit ();

    #ifdef DEBUG_EXTENSION
        dprintf ("Attempting to dump structure args=[%s]!\n", args);
    #endif // DEBUG_EXTENSION

    if (!args || args [0] == 0) {
        dprintf ("Usage: !avstream.dump <object>\n");
        return;
    }

    objStr [0] = lvlStr [0] = 0;

    //
    // Get the object address and convert it to the private _EXT address.
    // Read in the KSPX_EXT structure to find out what the heck we're
    // referring to.
    //
    sscanf (args, "%s %s", objStr, lvlStr);

    if (!(Public = Evaluator (objStr)))
        return;

    if (lvlStr && lvlStr [0]) {
        pLvl = lvlStr; while (*pLvl && !isdigit (*pLvl)) pLvl++;

        #ifdef DEBUG_EXTENSION
            dprintf ("pLvl = [%s]\n", pLvl);
        #endif // DEBUG_EXTENSION

        if (*pLvl) {
            sscanf (pLvl, "%lx", &DumpLevel);
        } else {
            DumpLevel = 1;
        }
    } else {
        DumpLevel = 1;
    }

    #ifdef DEBUG_EXTENSION
        dprintf ("Dumping at level %ld\n", DumpLevel);
    #endif // DEBUG_EXTENSION

    //
    // Check first to see if the signature matches that of an irp.  If someone
    // does a !ks.dump irp #, we will end up adjusting the irp to the AVStream
    // object associated with that Irp.  This still requires identification, so
    // we perform the check first and then attempt the ID after that.
    //

    if (signature_check (Public, SignatureIrp)) {
        DWORD OldPublic = Public;

        Public = AdjustIrpToPublicObject (Public);
        if (Public != OldPublic) {
            dprintf ("%sIRP %08lx was adjusted to an object %08lx\n\n",
                Tab (INITIAL_TAB), OldPublic, Public);

            //
            // If the client wants to know everything, let them know
            // everything. 
            //
            if (DumpLevel >= DUMPLVL_EVERYTHING)
                DumpAssociatedIrpInfo ((PIRP)OldPublic, INITIAL_TAB, Public);

        } else {
            dprintf ("%sIRP %08lx could not be adjusted to an AVStream"
                "object!\n", Tab (INITIAL_TAB), OldPublic);
            return;
        }
    } else if (signature_check (Public, SignatureFile)) {
        DWORD OldPublic = Public;

        Public = AdjustFileToPublicObject (Public);
        if (Public != OldPublic) {
            dprintf ("%sFILE OBJECT %08lx was adjusted to an object %08lx\n\n",
                Tab (INITIAL_TAB), OldPublic, Public);
        } else {
            dprintf ("%sFILE OBJECT %08lx could not be adjusted to an AVStream"
                "object!\n", Tab (INITIAL_TAB), OldPublic);
            return;
        }
    }

    //
    // Check first to see if this is a C++ class object within AVStream.
    //
    {
        INTERNAL_OBJECT_TYPE ObjType;
        DWORD BaseAddr;

        ObjType = DemangleAndAttemptIdentification (
            Public,
            &BaseAddr,
            NULL
        );

        if (ObjType != ObjectTypeUnknown) {

            #ifdef DEBUG_EXTENSION
                dprintf ("%08lx: object is a [%s], base address = %08lx\n",
                    Public, ObjectNames [ObjType], BaseAddr);
            #endif // DEBUG_EXTENSION

            switch (ObjType) {

                case ObjectTypeCKsPin:

                    DumpPrivatePin (BaseAddr, DumpLevel, INITIAL_TAB);
                    break;

                case ObjectTypeCKsRequestor:
                    
                    DumpPrivateRequestor (BaseAddr, DumpLevel, INITIAL_TAB);
                    break;

                case ObjectTypeCKsPipeSection:

                    DumpPrivatePipeSection (BaseAddr, DumpLevel, INITIAL_TAB);
                    break;

                case ObjectTypeCKsFilter:
                    
                    DumpPrivateFilter (BaseAddr, DumpLevel, INITIAL_TAB);
                    break;

                case ObjectTypeCKsFilterFactory:

                    DumpPrivateFilterFactory (BaseAddr, DumpLevel, INITIAL_TAB);
                    break;

                case ObjectTypeCKsDevice:

                    DumpPrivateDevice (BaseAddr, DumpLevel, INITIAL_TAB);
                    break;

                case ObjectTypeCKsQueue:

                    DumpQueueContents ((CKsQueue *)BaseAddr, DumpLevel,
                        INITIAL_TAB);
                    break;

                case ObjectTypeCKsSplitter:

                    DumpPrivateSplitter (BaseAddr, DumpLevel, INITIAL_TAB);
                    break;

                case ObjectTypeCKsSplitterBranch:

                    DumpPrivateBranch (BaseAddr, DumpLevel, INITIAL_TAB);
                    break;

                default:

                    dprintf ("Sorry....  I haven't finished this yet!\n");
                    break;

            }

            //
            // We've completed the dump.  Get out.
            //
            return;
        }
    }

    //
    // Check to see whether or not this is another confidentally identifiable
    // object within AVStream.  EXTs are the riskiest to identify, so they're
    // identified last.
    //
    {
        INTERNAL_STRUCTURE_TYPE StrucType;
        DWORD BaseAddr;

        if ((StrucType = IdentifyStructure (Public, &BaseAddr)) != 
            StructureTypeUnknown) {
    
            switch (StrucType) {
    
                case StructureType_KSSTREAM_POINTER:
                {
                    //
                    // The routine expects to have the stream pointer brought
                    // over already.  This is for optimization on queue dumping.
                    // I'm reusing the same routine.
                    //
                    CMemoryBlock <KSPSTREAM_POINTER> StreamPointer;

                    DWORD PrivAddr = (DWORD)
                        CONTAINING_RECORD (BaseAddr,
                            KSPSTREAM_POINTER, Public);
    
                    if (!ReadMemory (
                        PrivAddr,
                        StreamPointer.Get (),
                        sizeof (KSPSTREAM_POINTER),
                        &Result)) {
                        dprintf ("%08lx: cannot read stream pointer!\n",  
                            BaseAddr);
                        return;
                    }
    
                    DumpStreamPointer (StreamPointer.Get (), 
                        PrivAddr, DumpLevel, INITIAL_TAB);

                    return;
    
    
                }
    
                default:
    
                    dprintf ("Sorry....  I haven't finished this yet!\n");
                    return;
    
            }
        }
    }

    //
    // This wasn't recognized as a C++ class object, assume it's a public
    // structure such as a KSPIN, KSFILTER, etc...  Scan for what the
    // heck it is.
    //
    #ifdef DEBUG_EXTENSION
        dprintf ("Attempting to identify %08lx at level %08lx\n", Public,
            DumpLevel);
    #endif // DEBUG_EXTENSION

    ExtAddr = (DWORD)(CONTAINING_RECORD(Public, KSPX_EXT, Public));

    if (!ReadMemory (
        ExtAddr,
        &ObjExt,
        sizeof (KSPX_EXT),
        &Result
    )) {
        dprintf ("%08lx: could not read object!\n", Public);
        return;
    }

    switch (ObjExt.ObjectType) {

        case KsObjectTypeDevice:
            dprintf ("%s%08lx: object is a KSDEVICE:\n", 
                Tab (INITIAL_TAB), Public);
            DumpPublicDevice (Public, DumpLevel, INITIAL_TAB);
            break;
        
        case KsObjectTypeFilterFactory:
            dprintf ("%s%08lx: object is a KSFILTERFACTORY\n", 
                Tab (INITIAL_TAB), Public);
            DumpPublicFilterFactory (Public, DumpLevel, INITIAL_TAB);
            break;

        case KsObjectTypeFilter:
            dprintf ("%s%08lx: object is a KSFILTER\n", 
                Tab (INITIAL_TAB), Public);
            DumpPublicFilter (Public, DumpLevel, INITIAL_TAB);
            break;

        case KsObjectTypePin:
            dprintf ("%s%08lx: object is a KSPIN\n", 
                Tab (INITIAL_TAB), Public);
            DumpPublicPin (Public, DumpLevel, INITIAL_TAB);
            break;

        default: {

            dprintf ("%s%08lx: object is not identifiable\n", 
                Tab (INITIAL_TAB), Public);
            break;

        }

    }

}

/*************************************************

    Function:

        dumpbag

    Usage:

        !avstream.dumpbag <device -> pin> [<dump level>]

    Description:

        Dump the object presented

*************************************************/

DECLARE_API(dumpbag) {

    DWORD Public, ExtAddr, PublicBagAddr;
    KSPX_EXT ObjExt;
    ULONG Result;
    char objStr[256], lvlStr[256], *pLvl;
    ULONG DumpLevel;
    PKSIOBJECTBAG BagAddr;

    GlobInit ();

    #ifdef DEBUG_EXTENSION
        dprintf ("Attempting to dump bag args=[%s]!\n", args);
    #endif // DEBUG_EXTENSION

    if (!args || args [0] == 0) {
        dprintf ("Usage: !avstream.dumpbag <object> [<level>]\n");
        return;
    }

    objStr [0] = lvlStr [0] = 0;

    //
    // Get the object address and convert it to the private _EXT address.
    // Read in the KSPX_EXT structure to find out what the heck we're
    // referring to.
    //
    sscanf (args, "%s %s", objStr, lvlStr);

    if (!(Public = Evaluator (objStr)))
        return;

    if (lvlStr && lvlStr [0]) {
        pLvl = lvlStr; while (*pLvl && !isdigit (*pLvl)) pLvl++;

        #ifdef DEBUG_EXTENSION
            dprintf ("pLvl = [%s]\n", pLvl);
        #endif // DEBUG_EXTENSION

        if (*pLvl) {
            sscanf (pLvl, "%lx", &DumpLevel);
        } else {
            DumpLevel = 1;
        }
    } else {
        DumpLevel = 1;
    }

    #ifdef DEBUG_EXTENSION
        dprintf ("Dumping at level %ld\n", DumpLevel);
    #endif // DEBUG_EXTENSION

    //
    // Check first to see if this is a C++ class object within AVStream.
    //
    {
        INTERNAL_OBJECT_TYPE ObjType;
        DWORD BaseAddr;

        ObjType = DemangleAndAttemptIdentification (
            Public,
            &BaseAddr,
            NULL
        );

        if (ObjType != ObjectTypeUnknown) {

            #ifdef DEBUG_EXTENSION
                dprintf ("%08lx: object is a [%s], base address = %08lx\n",
                    Public, ObjectNames [ObjType], BaseAddr);
            #endif // DEBUG_EXTENSION

            switch (ObjType) {

                case ObjectTypeCKsPin:

                    ExtAddr = FIELDOFFSET (CKsPin, m_Ext) + BaseAddr;
                    break;

                case ObjectTypeCKsFilter:

                    ExtAddr = FIELDOFFSET (CKsFilter, m_Ext) + BaseAddr;
                    break;

                case ObjectTypeCKsFilterFactory:

                    ExtAddr = FIELDOFFSET (CKsFilterFactory, m_Ext) +
                        BaseAddr;
                    break;

                case ObjectTypeCKsDevice:

                    ExtAddr = FIELDOFFSET (CKsDevice, m_Ext) + BaseAddr;
                    break;

                default:

                    dprintf ("%08lx: object has no bag!\n");
                    return;
                
            }

        } else {
            //
            // Try to identify the object as a public structure, not a private
            // AVStream class obj.
            //
            #ifdef DEBUG_EXTENSION
                dprintf ("Attempting to identify %08lx at level %08lx\n", Public,
                    DumpLevel);
            #endif // DEBUG_EXTENSION
        
            ExtAddr = (DWORD)(CONTAINING_RECORD(Public, KSPX_EXT, Public));

        }

    }

    #ifdef DEBUG_EXTENSION
        dprintf ("Bag: ExtAddr = %08lx\n", ExtAddr);
    #endif // DEBUG_EXTENSION

    if (!ReadMemory (
        ExtAddr,
        &ObjExt,
        sizeof (KSPX_EXT),
        &Result
    )) {
        dprintf ("%08lx: could not read object!\n", Public);
        return;
    }

    //
    // All Ext'ables have bags.  Find the bag
    //
    switch (ObjExt.ObjectType) {
        
        case KsObjectTypeDevice:

            PublicBagAddr = ExtAddr + FIELDOFFSET (KSDEVICE_EXT, Public) +
                FIELDOFFSET (KSDEVICE, Bag);

            dprintf ("%sDevice %08lx [Ext = %08lx, CKsDevice = %08lx]:\n",
                Tab (INITIAL_TAB),
                FIELDOFFSET (KSDEVICE_EXT, Public) + ExtAddr,
                ExtAddr,
                CONTAINING_RECORD (ExtAddr, CKsDevice, m_Ext)
            );

            break;
        
        case KsObjectTypeFilterFactory:

            PublicBagAddr = ExtAddr + FIELDOFFSET (KSFILTERFACTORY_EXT, 
                Public) + FIELDOFFSET (KSFILTERFACTORY, Bag);

            dprintf ("%sFilter Factory %08lx [Ext = %08lx, "
                "CKsFilterFactory = %08lx]:\n",
                Tab (INITIAL_TAB),
                FIELDOFFSET (KSFILTERFACTORY_EXT, Public) + ExtAddr,
                ExtAddr,
                CONTAINING_RECORD (ExtAddr, CKsFilterFactory, m_Ext)
            );
            break;

        case KsObjectTypeFilter:

            PublicBagAddr = ExtAddr + FIELDOFFSET (KSFILTER_EXT, Public) +
                FIELDOFFSET (KSFILTER, Bag);

            dprintf ("%sFilter %08lx [Ext = %08lx, CKsFilter = %08lx]:\n",
                Tab (INITIAL_TAB),
                FIELDOFFSET (KSFILTER_EXT, Public) + ExtAddr,
                ExtAddr,
                CONTAINING_RECORD (ExtAddr, CKsFilter, m_Ext)
            );
            break;

        case KsObjectTypePin:

            PublicBagAddr = ExtAddr + FIELDOFFSET(KSPIN_EXT, Public) +
                FIELDOFFSET (KSPIN, Bag);
            
            dprintf ("%sPin %08lx [Ext = %08lx, CKsPin = %08lx]:\n",
                Tab (INITIAL_TAB),
                FIELDOFFSET (KSFILTER_EXT, Public) + ExtAddr,
                ExtAddr,
                CONTAINING_RECORD (ExtAddr, CKsPin, m_Ext)
            );
            break;

        default:

            dprintf ("%08lx: unrecognized object!\n",
                Public);
            break;

    }

    if (!ReadMemory (
        PublicBagAddr,
        &BagAddr,
        sizeof (PKSIOBJECTBAG),
        &Result)) {

        dprintf ("%08lx: unable to read object bag pointer!\n", 
            PublicBagAddr);
        return;
    }

    #ifdef DEBUG_EXTENSION
        dprintf ("About to dump bag at %08lx\n", BagAddr);
    #endif // DEBUG_EXTENSION

    //
    // Dump the bag contents.
    //
    DumpPrivateBag ((DWORD)BagAddr, DumpLevel, INITIAL_TAB + 1);

}

/*************************************************

    Function:

        dumpcircuit

    Usage:

        !avstream.dumpcircuit <AVStream class>

    Description:

        Dump the circuit associated with a given AVStream object.
        We begin with the object specified and walk around the
        transport circuit.  This requires a special kind of magic
        since everything is done through abstract base classes and
        IKsTransport.  However, DemangleAndAttemptIdentification is the
        key to all of this magic.

*************************************************/

DECLARE_API (dumpcircuit) {

    DWORD Address, Base, TopBase;
    char objStr[256], lvlStr[256], *pLvl;
    ULONG DumpLevel;
    DUMP_CIRCUIT_CONTEXT DumpContext;

    ULONG TabDepth = INITIAL_TAB;

    GlobInit ();

    if (!args || args [0] == 0) {
        dprintf ("Usage: !avstream.dumpcircuit <AVStream class object>\n");
        return;
    }

    sscanf (args, "%s %s", objStr, lvlStr);

    if (!(Address = Evaluator (objStr)))
        return;

    if (lvlStr && lvlStr [0]) {
        pLvl = lvlStr; while (*pLvl && !isdigit (*pLvl)) pLvl++;

        #ifdef DEBUG_EXTENSION
            dprintf ("pLvl = [%s]\n", pLvl);
        #endif // DEBUG_EXTENSION

        if (*pLvl) {
            sscanf (pLvl, "%lx", &DumpLevel);
        } else {
            DumpLevel = 1;
        }
    } else {
        DumpLevel = 1;
    }

    #ifdef DEBUG_EXTENSION
        dprintf ("Dumping at level %ld\n", DumpLevel);
    #endif // DEBUG_EXTENSION

    DumpContext.TabDepth = INITIAL_TAB;
    DumpContext.DumpLevel = DumpLevel;

    WalkCircuit (
        (PVOID)Address, 
        DumpCircuitCallback,
        &DumpContext
        );

}

/*************************************************

    Function:

        EnumerateDeviceObject

    Description:

        Find the AVStream device object associated with the given
        WDM device object; enumerate all filter types and filters
        associated with it.

    Arguments:

        Address -
            The device object address on the target

        TabDepth -
            The tab depth to print this at

    Return Value:

        The next device object in the driver's chain.

*************************************************/

DWORD AdjustFilterExtToKSFILTER (
    IN PVOID Context,
    IN DWORD FilterExt
) {

    return (FilterExt + FIELDOFFSET (KSFILTER_EXT, Public));
}

PDEVICE_OBJECT
EnumerateDeviceObject (
    IN DWORD Address,
    IN ULONG TabDepth
) {

    DWORD ObjAddress;
    PKSIDEVICE_HEADER HeaderAddr;
    DEVICE_OBJECT DevObj;
    ULONG Result;
    PKSDEVICE DevAddr;
    KSDEVICE_EXT DeviceExt;
    DWORD ListBeginAddr, SubListBeginAddr;
    LIST_ENTRY ListEntry, SubListEntry;

    if (!ReadMemory (
        Address,
        &DevObj,
        sizeof (DEVICE_OBJECT),
        &Result
    )) {
        dprintf ("%08lx: unable to read WDM device object!\n",
            Address);
        return NULL;
    }

    if (DevObj.Type != IO_TYPE_DEVICE) {
        dprintf ("%08lx: this is **NOT** a WDM device object!\n",
            Address);
        return NULL;
    }

    if (!ReadMemory (
        (DWORD)DevObj.DeviceExtension,
        &HeaderAddr,
        sizeof (PKSIDEVICE_HEADER),
        &Result
    )) {
        dprintf ("%08lx: cannot read device header!\n",
            DevObj.DeviceExtension);
        return DevObj.NextDevice;
    }

    ObjAddress = (DWORD)HeaderAddr + FIELDOFFSET(KSIDEVICE_HEADER, Object);

    if (!ReadMemory (
        ObjAddress,
        &DevAddr,
        sizeof (PKSDEVICE),
        &Result
    )) {
        dprintf ("%08lx: cannot read object pointer!\n",
            ObjAddress);
        return DevObj.NextDevice;
    }

    if (!ReadMemory (
        (DWORD)DevAddr - FIELDOFFSET(KSDEVICE_EXT, Public), 
        &DeviceExt,
        sizeof (KSDEVICE_EXT),
        &Result
    )) {
        dprintf ("%08lx: cannot read KSDEVICE object!\n",
            DevAddr);
        return DevObj.NextDevice;
    }

    dprintf ("%sWDM device object %08lx:\n", 
        Tab (TabDepth), Address);
    TabDepth++;
    dprintf ("%sCorresponding KSDEVICE        %08lx\n", 
        Tab (TabDepth), DevAddr);

    //
    // Enumerate all filter factory types
    //
    ListBeginAddr = (DWORD)DevAddr - FIELDOFFSET(KSDEVICE_EXT, Public) +
        FIELDOFFSET(KSDEVICE_EXT, ChildList);
    ListEntry = DeviceExt.ChildList;
    while ((DWORD)ListEntry.Flink != ListBeginAddr && !CheckControlC ()) {
        
        DWORD ChildObjectAddr;
        KSFILTERFACTORY_EXT FactoryExt;
        ULONG Count;

        //
        // Get the address of the child's _EXT.
        //
        ChildObjectAddr = (DWORD)CONTAINING_RECORD (
            ListEntry.Flink,
            KSPX_EXT,
            SiblingListEntry
        );

        //
        // Read the factory.
        //
        if (!ReadMemory (
            ChildObjectAddr,
            &FactoryExt,
            sizeof (KSFILTERFACTORY_EXT),
            &Result
        )) {
            dprintf ("%08lx: unable to read factory!\n", ChildObjectAddr);
            return DevObj.NextDevice;
        }

        dprintf ("%sFactory %08lx [Descriptor %08lx] instances:\n",
            Tab (TabDepth),
            ChildObjectAddr,
            FactoryExt.Public.FilterDescriptor
        );
        dprintf ("%s", Tab (TabDepth + 1));

        //
        // Use the ever handy DumpObjQueueList to dump all filter instances
        // on this factory.
        //
        Count = DumpObjQueueList (
            &(FactoryExt.ChildList),
            FIELDOFFSET(KSFILTERFACTORY_EXT, ChildList) + 
                ChildObjectAddr,
            FIELDOFFSET(KSFILTER_EXT, SiblingListEntry),
            FALSE,
            AdjustFilterExtToKSFILTER,
            NULL
        );
        if (Count == 0) 
            dprintf ("No instantiated filters!\n");
        else
            dprintf ("\n");

        if (!ReadMemory (
            (DWORD)(ListEntry.Flink),
            &ListEntry,
            sizeof (LIST_ENTRY),
            &Result
        )) {
            dprintf ("%08lx: unable to follow object chain!\n",
                ChildObjectAddr);
            return DevObj.NextDevice;
        }

    }

    return DevObj.NextDevice;
}

/*************************************************

    Function:

        enumdevobj

    Usage:

        !avstream.enumdevobj <WDM device object>

    Description:

        Find the AVStream device object associated with the given WDM
        device object and enumerate all filter types and instantiated
        filters on the device.

*************************************************/

DECLARE_API(enumdevobj) {

    DWORD Address;

    GlobInit ();

    if (!args || args [0] == 0) {
        dprintf ("Usage: !avstream.enumdevobj <WDM device object>\n");
        return;
    }

    sscanf (args, "%lx", &Address);

    EnumerateDeviceObject (Address, INITIAL_TAB);

}

/*************************************************

    Function:

        enumdrvobj

    Usage:

        !avstream.enumdrvobj <WDM driver object>

    Description:

        Find the AVStream device object associated with the given WDM
        driver object and enumerate all filter types and instantiated
        filters on the device.

*************************************************/

DECLARE_API(enumdrvobj) {

    DWORD Address;
    DRIVER_OBJECT Driver;
    PDEVICE_OBJECT DeviceObject, NextDeviceObject;
    ULONG Result;

    ULONG TabDepth = INITIAL_TAB;

    GlobInit ();

    if (!args || args [0] == 0) {
        dprintf ("Usage: !avstream.enumdevobj <WDM device object>\n");
        return;
    }

    sscanf (args, "%lx", &Address);

    if (!ReadMemory (
        Address,
        &Driver,
        sizeof (DRIVER_OBJECT),
        &Result
    )) {
        dprintf ("%08lx: cannot read driver object!\n", Address);
        return;
    }

    if (Driver.Type != IO_TYPE_DRIVER) {
        dprintf ("%08lx: this is **NOT** a WDM driver object!\n",
            Address);
        return;
    }

    dprintf ("%sWDM driver object %08lx:\n", Tab (TabDepth), Address);
    TabDepth++;
    DeviceObject = Driver.DeviceObject;

    //
    // Walk the driver object's device list and enumerate each
    // device object for AVStream objects.
    //
    while (DeviceObject && !CheckControlC ()) {
        NextDeviceObject = EnumerateDeviceObject (
            (DWORD)DeviceObject,
            TabDepth
        );
        dprintf ("\n");

        DeviceObject = NextDeviceObject;
    }

}

/*************************************************

    Function:

        automation

    Usage:

        !avstream.automation <Filter | Pin>

    Description:

        Dump all automation objects associated with the specified filter
        or pin.  Clients can provide either a PKSFILTER, a PKSPIN,
        a CKsFilter*, or a CKsPin*

*************************************************/

DECLARE_API(automation) {

    DWORD Public, ExtAddr, BaseAddr;
    KSPX_EXT Ext;
    KSAUTOMATION_TABLE Automation;
    PKSPAUTOMATION_TYPE AutomationType;
    LONG TypeCount;
    ULONG Result, SetSize;
    CHAR Buffer [1024];
    ULONG Displ;

    ULONG TabDepth = INITIAL_TAB;

    GlobInit ();

    if (!args || args [0] == 0) {
        dprintf ("Usage: !avstream.automation <filter or pin or Irp>\n");
        return;
    }

    if (!(Public = Evaluator (args)))
        return;

    //
    // First, check to see whether this is an Irp for automation.  If it 
    // is, dump the automation information
    //
    if (signature_check (Public, SignatureIrp)) {

        //
        // If this is an Irp, verify it's an automation Irp.
        //
        PIO_STACK_LOCATION IoStackLocation;
        IO_STACK_LOCATION IoStack;

        if (!ReadMemory (
            (DWORD)Public + 
                FIELDOFFSET (IRP, Tail.Overlay.CurrentStackLocation),
            &IoStackLocation,
            sizeof (PIO_STACK_LOCATION),
            &Result)) {

            dprintf ("%08lx: cannot read current stack location!\n", Public);
            return;
        }

        if (!ReadMemory (
            (DWORD)IoStackLocation,
            &IoStack,
            sizeof (IO_STACK_LOCATION),
            &Result)) {

            dprintf ("%08lx: cannot read io stack location!\n", 
                IoStackLocation);
            return;

        }

        if (IoStack.MajorFunction != IRP_MJ_DEVICE_CONTROL ||
            (IoStack.Parameters.DeviceIoControl.IoControlCode !=
                IOCTL_KS_PROPERTY &&
            IoStack.Parameters.DeviceIoControl.IoControlCode !=
                IOCTL_KS_METHOD &&
            IoStack.Parameters.DeviceIoControl.IoControlCode !=
                IOCTL_KS_ENABLE_EVENT &&
            IoStack.Parameters.DeviceIoControl.IoControlCode !=
                IOCTL_KS_DISABLE_EVENT)) {

            dprintf ("%08lx: Irp is not an automation Irp!\n", Public);
            return;
        }

        //
        // At this point, we know we have an automation Irp; deal with
        // the information.
        //
        DWORD OldPublic = Public;

        Public = AdjustIrpToPublicObject (Public);
        if (Public != OldPublic) {
            //
            // If the client wants to know everything, let them know
            // everything. 
            //
            DumpAssociatedIrpInfo ((PIRP)OldPublic, INITIAL_TAB, Public);
        } else {
            dprintf ("%08lx: cannot figure out what public this is"
                "associated with!\n", OldPublic);
            return;
        }

        //
        // We only wanted to dump the associated automation information,
        // not the complete automation information associated with 
        // the object.
        //
        // BUGBUG: There should be a method of specifying dump level and
        // allowing a 7 to dump the entire automation lot.
        //
        return;

    }

    //
    // Check first to see if this is a C++ class object within AVStream.
    //
    {
        INTERNAL_OBJECT_TYPE ObjType;
        DWORD BaseAddr;

        ObjType = DemangleAndAttemptIdentification (
            Public,
            &BaseAddr,
            NULL
        );

        if (ObjType != ObjectTypeUnknown) {

            switch (ObjType) {

                case ObjectTypeCKsPin:

                    ExtAddr = BaseAddr + FIELDOFFSET(CKsPin, m_Ext);

                    break;

                case ObjectTypeCKsFilter:

                    ExtAddr = BaseAddr + FIELDOFFSET(CKsFilter, m_Ext);
                    
                    break;
                
                default:

                    dprintf ("%08lx: object is not a pin or filter!\n",
                        Public);
                    break;

            }
        } else 
            ExtAddr = (DWORD)(CONTAINING_RECORD(Public, KSPX_EXT, Public));
    }

    if (!ReadMemory (
        ExtAddr,
        &Ext,
        sizeof (KSPX_EXT),
        &Result)) {

        dprintf ("%08lx: unable to read Ext structure!\n", Public);
        return;
    }

    if (Ext.ObjectType != KsObjectTypePin && 
        Ext.ObjectType != KsObjectTypeFilter) {
        dprintf ("%08lx: object is not a pin or filter!\n",
            Public);
        return;
    }

    if (Ext.ObjectType == KsObjectTypePin) 
        dprintf ("%sPin %08lx has the following automation items:\n",
            Tab (TabDepth),
            ExtAddr + FIELDOFFSET(KSPIN_EXT, Public));
    else
        dprintf ("%sFilter %08lx has the following automation items:\n",
            Tab (TabDepth),
            ExtAddr + FIELDOFFSET(KSFILTER_EXT, Public));

    #ifdef DEBUG_EXTENSION
        dprintf ("%08lx: automation table at %08lx",
            ExtAddr, Ext.AutomationTable);
    #endif // DEBUG_EXTENSION

    TabDepth++;

    //
    // The EXT contains the automation table pointer.  Now, we have to read
    // in the automation table and then walk through each automation item.
    //
    if (!ReadMemory (
        (DWORD)Ext.AutomationTable,
        &Automation,
        sizeof(KSAUTOMATION_TABLE),
        &Result)) {

        dprintf ("%08lx: unable to read automation table!\n", 
            Ext.AutomationTable);
        return;
    }

    AutomationType = reinterpret_cast<PKSPAUTOMATION_TYPE>(&Automation);
    TypeCount = 3;
    while (TypeCount-- && !CheckControlC ()) {

        switch (TypeCount) {

            case 2:
                dprintf ("%sProperty Items:\n", Tab (TabDepth));
                SetSize = sizeof(KSPROPERTY_SET);
                break;
            case 1:
                dprintf ("%sMethod Items:\n", Tab (TabDepth));
                SetSize = sizeof(KSMETHOD_SET);
                break;
            case 0:
                dprintf ("%sEvent Items:\n", Tab (TabDepth));
                SetSize = sizeof(KSEVENT_SET);
                break;

        };

        //
        // Scope out the memory allocation and deallocation
        //
        if (AutomationType -> SetsCount != 0) 
        {
            CMemory AutomationSets (SetSize * AutomationType -> SetsCount);
            ULONG SetsCount = AutomationType -> SetsCount;
            PKSPAUTOMATION_SET AutomationSet = 
                (PKSPAUTOMATION_SET)AutomationSets.Get ();

            #ifdef DEBUG_EXTENSION
                dprintf ("%08lx: reading type set list [size=%ld]\n",
                    AutomationType -> Sets,
                    AutomationType -> SetsCount);
            #endif // DEBUG_EXTENSION

            if (!ReadMemory (
                (DWORD)AutomationType -> Sets,
                AutomationSet,
                SetSize * AutomationType -> SetsCount,
                &Result)) {

                dprintf ("%08lx: could not read automation sets!\n",
                    AutomationType -> Sets);
                return;
            }

            while (SetsCount-- && !CheckControlC ()) {

                ULONG ItemsCount;
                PVOID Items;
                GUID guid;

                if (!ReadMemory (
                    (DWORD)AutomationSet -> Set,
                    &guid,
                    sizeof (GUID),
                    &Result)) {

                    dprintf ("%08lx: cannot read set guid!\n",
                        AutomationSet -> Set);
                    return;
                }

                //
                // First display the information about this set.
                //
                dprintf ("%sSet", Tab (TabDepth + 1));
                if (!DisplayNamedAutomationSet (&guid, " %s\n")) {
                    GetSymbol ((LPVOID)(AutomationSet -> Set), Buffer, &Displ);
                    if (Buffer [0] && Displ == 0) 
                        dprintf (" [%s]", Buffer);
                    XTN_DUMPGUID(" ", 0, (guid));
                }

                if (AutomationSet -> ItemsCount)
                {

                    CMemory AutomationItems (AutomationSet -> ItemsCount *
                        AutomationType -> ItemSize);
                    ULONG ItemsCount = AutomationSet -> ItemsCount;
                    PVOID Item = AutomationItems.Get ();

                    #ifdef DEBUG_EXTENSION
                        dprintf ("%08lx: reading automation set item list "
                            "[size = %ld]\n",
                            AutomationSet -> Items, 
                            AutomationSet -> ItemsCount);
                    #endif // DEBUG_EXTENSION

                    if (!ReadMemory (
                        (DWORD)AutomationSet -> Items,
                        Item,
                        AutomationSet -> ItemsCount * 
                            AutomationType -> ItemSize,
                        &Result)) {

                        dprintf ("%08lx: could not read automation items!\n",
                            AutomationSet -> Items);
                        return;
                    }

                    while (ItemsCount-- && !CheckControlC ()) {

                        switch (TypeCount) {
                            
                            case 2:

                                DumpPropertyItem (
                                    reinterpret_cast<PKSPROPERTY_ITEM>(
                                        Item),
                                    TabDepth + 2,
                                    &guid
                                    );

                                break;

                            case 1:

                                DumpMethodItem (
                                    reinterpret_cast<PKSMETHOD_ITEM>(
                                        Item),
                                    TabDepth + 2,
                                    &guid
                                    );

                                break;

                            case 0:

                                DumpEventItem (
                                    reinterpret_cast<PKSEVENT_ITEM>(
                                        Item),
                                    TabDepth + 2,
                                    &guid
                                    );
                                
                                break;

                        }

                        Item = (PVOID)(((DWORD)Item) + AutomationType -> 
                            ItemSize);

                    }

                    AutomationSet = (PKSPAUTOMATION_SET)
                        (((DWORD)AutomationSet) + SetSize);
                }


            }
        } else 
            dprintf ("%sNO SETS FOUND!\n", Tab (TabDepth + 1));

        AutomationType++;
    
    }
}

/*************************************************

    Function:

        dumpqueue

    Usage:

        !avstream.dumpqueue <Filter | Pin | Queue>

    Description:

        Dump the queue(s) associated with a given AVStream object.  The
        object must be either a filter or a pin.  For a pin, a single
        queue will be dumped.  For a filter, multiple queues will be
        dumped.

*************************************************/

DECLARE_API(dumpqueue) {

    DWORD Public, ExtAddr;
    KSPX_EXT ObjExt;
    char objStr[256], lvlStr[256], *pLvl;
    ULONG Result;
    ULONG DumpLevel;

    ULONG TabDepth = INITIAL_TAB;

    GlobInit ();

    if (!args || args [0] == 0) {
        dprintf ("Usage: !avstream.dumpqueue <pin or filter>\n");
        return;
    }

    objStr [0] = lvlStr [0] = 0;

    //
    // Get the object address and convert it to the private _EXT address.
    // Read in the KSPX_EXT structure to find out what the heck we're
    // referring to.
    //
    sscanf (args, "%s %s", objStr, lvlStr);

    if (!(Public = Evaluator (objStr)))
        return;

    if (lvlStr && lvlStr [0]) {
        pLvl = lvlStr; while (*pLvl && !isdigit (*pLvl)) pLvl++;
        if (*pLvl) {
            sscanf (pLvl, "%lx", &DumpLevel);
        } else {
            DumpLevel = 1;
        }
    } else {
        DumpLevel = 1;
    }
    ExtAddr = (DWORD)(CONTAINING_RECORD (Public, KSPX_EXT, Public));

    //
    // First, we assume they handed us a CKsQueue to dump....  We must check
    // that.  If they didn't hand us a queue, check for a pin or a filter.
    //
    {
        INTERNAL_OBJECT_TYPE ObjType;
        DWORD BaseAddr;

        ObjType = DemangleAndAttemptIdentification (
            Public,
            &BaseAddr,
            NULL
        );

        if (ObjType == ObjectTypeCKsQueue) {

            DumpQueueContents ((CKsQueue *)BaseAddr, DumpLevel, TabDepth);
            return;

        }

        //
        // Check if they're passing us the privates before trying to guess
        // publics.
        //
        if (ObjType == ObjectTypeCKsPin) 
            ExtAddr = BaseAddr + FIELDOFFSET(CKsPin, m_Ext);

        if (ObjType == ObjectTypeCKsFilter)
            ExtAddr = BaseAddr + FIELDOFFSET(CKsFilter, m_Ext);


        //
        // Otherwise, fall through and continue trying to figure out
        // what the heck the user handed us.
        //

        #ifdef DEBUG_EXTENSION
            dprintf ("ObjType = %ld, BaseAddr = %08lX, ExtAddr = %08lX\n", 
                ObjType, BaseAddr, ExtAddr);
        #endif // DEBUG_EXTENSION

    }

    #ifdef DEBUG_EXTENSION
        dprintf ("Attempting to access EXT at %lx\n", ExtAddr);
    #endif // DEBUG_EXTENSION

    if (!ReadMemory (
        ExtAddr,
        &ObjExt,
        sizeof (KSPX_EXT),
        &Result
    )) {
        dprintf ("%08lx: Could not read object!\n", Public);
        return;
    }

      #ifdef DEBUG_EXTENSION
        dprintf ("Object %lx read, result = %ld\n", ExtAddr, Result); 
        HexDump ((PVOID)&ObjExt, ExtAddr, Result);
      #endif // DEBUG_EXTENSION

    if (ObjExt.ObjectType != KsObjectTypeFilter &&
        ObjExt.ObjectType != KsObjectTypePin) {

        dprintf ("%08lx: This object is not an AVStream filter or pin!\n",
            Public);
    
        #ifdef DEBUG_EXTENSION
            dprintf ("Object type %08lx = %ld\n", Public, ObjExt.ObjectType);
        #endif // DEBUG_EXTENSION

        return;
    }

    //
    // If we've been asked to dump the queue of a given pin, then
    // we only need to dump a single queue.  On the other hand, if we're
    // asked for the filter, then we iterate through all pipe sections on
    // the filter and dump all queues.
    //
    if (ObjExt.ObjectType == KsObjectTypePin) {

        DWORD Address;
        PKSPPROCESSPIN ProcessPin;
        PKSPPROCESSPIPESECTION ProcessPipe;
        PIKSQUEUE Queue;
        CKsQueue *QueueObject;

        Address = FIELDOFFSET (KSPIN_EXT, ProcessPin) + ExtAddr;

        #ifdef DEBUG_EXTENSION
            dprintf ("Process Pin Address = %08lx\n", Address);
        #endif // DEBUG_EXTENSION

        if (!ReadMemory (
            Address,
            &ProcessPin,
            sizeof (PKSPPROCESSPIN),
            &Result
        )) {
            dprintf ("FATAL: Cannot read process pin!\n");
            return;
        }

        //
        // We have the process pin address, now we need to grovel down into
        // the pipe section
        //
        Address = FIELDOFFSET (KSPPROCESSPIN, PipeSection) + (DWORD)ProcessPin;

        #ifdef DEBUG_EXTENSION
            dprintf ("Process Pipe Section Address = %08lx\n", Address);
        #endif // DEBUG_EXTENSION

        if (!ReadMemory (
            Address,
            &ProcessPipe,
            sizeof (PKSPPROCESSPIPESECTION),
            &Result
        )) {
            dprintf ("FATAL: Cannot read process pipe section!\n");
            return;
        }

        //
        // We have the process pipe, now we need to grovel down into the
        // queue.
        //
        Address = FIELDOFFSET (KSPPROCESSPIPESECTION, Queue) + 
            (DWORD)ProcessPipe;

        #ifdef DEBUG_EXTENSION
            dprintf ("IKsQueue address = %08lx\n", Address);
        #endif // DEBUG_EXTENSION

        if (!ReadMemory (
            Address,
            &Queue,
            sizeof (PIKSQUEUE),
            &Result
        )) {
            dprintf ("FATAL: Cannot read queue!\n");
            return;
        }

        //
        // Upcast the interface and dump the queue.
        //
        QueueObject = (CKsQueue *)(Queue);

        #ifdef DEBUG_EXTENSION
            dprintf ("QueueObject Address = %08lx\n", QueueObject);
        #endif // DEBUG_EXTENSION

        DumpQueueContents (QueueObject, DumpLevel, TabDepth);

    }

    //
    // We're not just dumping a single pin....  We're dumping every queue
    // on the filter.  We must get to the filter object and iterate through
    // the list of input and output pipes, dumping the queue for each.
    //
    else {

        DWORD FilterAddress, ListAddress, Address;
        LIST_ENTRY IterateEntry;
        PIKSQUEUE Queue;
        CKsQueue *QueueObject;

        FilterAddress = (DWORD)(CONTAINING_RECORD (ExtAddr, CKsFilter, m_Ext));

        //
        // First iterate through all the input pipes.
        //
        ListAddress = FIELDOFFSET (CKsFilter, m_InputPipes) + FilterAddress;

        #ifdef DEBUG_EXTENSION
            dprintf ("Filter Address=%08lx, ListAddress=%08lx\n",
                FilterAddress, ListAddress);
        #endif // DEBUG_EXTENSION

        if (!ReadMemory (
            ListAddress,
            &IterateEntry,
            sizeof (LIST_ENTRY),
            &Result
        )) {
            dprintf ("FATAL: Cannot read input pipes\n");
            return;
        }
        
        while ((DWORD)(IterateEntry.Flink) != ListAddress && 
            !CheckControlC ()) {

            #ifdef DEBUG_EXTENSION
                dprintf ("Current input queue %08lx, end = %08lx\n",
                    IterateEntry.Flink, ListAddress);
            #endif // DEBUG_EXTENSION

            Address = FIELDOFFSET (KSPPROCESSPIPESECTION, Queue) +
                (DWORD)IterateEntry.Flink;

            if (!ReadMemory (
                Address,
                &Queue,
                sizeof (PIKSQUEUE),
                &Result
            )) {
                dprintf ("FATAL: Cannot read queue!\n");
                return;
            }

            //
            // Upcast, print header, and dump the queue object.
            //
            QueueObject = (CKsQueue *)(Queue);

            dprintf ("%sFilter %08lx: Input Queue %08lx:\n",
                Tab (TabDepth),
                Public, QueueObject);

            DumpQueueContents (QueueObject, DumpLevel, TabDepth + 1);

            //
            // Get the next item in the list....
            //
            if (!ReadMemory (
                (DWORD)(IterateEntry.Flink),
                &IterateEntry,
                sizeof (LIST_ENTRY),
                &Result
            )) {
                dprintf ("FATAL: Cannot traverse input pipe chain\n");
                return;
            }
        }

        //
        // Next iterate through all output pipes.
        //
        ListAddress = FIELDOFFSET(CKsFilter, m_OutputPipes) + FilterAddress;

        if (!ReadMemory (
            ListAddress,
            &IterateEntry,
            sizeof (LIST_ENTRY),
            &Result
        )) {
            dprintf ("FATAL: Cannot read output pipe list!\n");
            return;
        }
        while ((DWORD)(IterateEntry.Flink) != ListAddress &&
            !CheckControlC ()) {

            #ifdef DEBUG_EXTENSION
                dprintf ("Current output queue %08lx, end = %08lx\n",
                    IterateEntry.Flink, ListAddress);
            #endif // DEBUG_EXTENSION

            Address = FIELDOFFSET (KSPPROCESSPIPESECTION, Queue) +
                (DWORD)IterateEntry.Flink;

            if (!ReadMemory (
                Address,
                &Queue,
                sizeof (PIKSQUEUE),
                &Result
            )) {
                dprintf ("FATAL: Cannot read queue!\n");
                return;
            }

            //
            // Upcast, print header, and dump the queue object.
            //
            QueueObject = (CKsQueue *)(Queue);

            dprintf ("%sFilter %08lx: Output Queue %08lx:\n",
                Tab (TabDepth),
                Public, QueueObject);

            DumpQueueContents (QueueObject, DumpLevel, TabDepth + 1);

            //
            // Get the next item in the list....
            //
            if (!ReadMemory (
                (DWORD)(IterateEntry.Flink),
                &IterateEntry,
                sizeof (LIST_ENTRY),
                &Result
            )) {
                dprintf ("FATAL: Cannot traverse output pipe chain\n");
                return;
            }
        }
    }
}

/*************************************************

    Function:

        forcedump

    Usage:

        !ks.forcedump <object> <type> [<level>]

    Description:

        This is used when the extension cannot recognize a given object
        type.  Because of certain flaws in the KD-style extension support
        within RTERM, this can be necessary.  Some versions of the debugger
        (the first 4.3) have a bug in that they cannot resolve symbols.  This
        renders !ks.dump unusable for class objects.  Further, no version
        of RTERM can resolve symbols that are loaded on the target side.  Since
        this isn't likely to be fixed soon and there's always the possibility
        of having to debug a machine fitting into the class above, this
        command is being added.

    Notes:

        Type must be the object type: ie: CKsQueue, CKsFilter, etc...
        It must be the **BASE** of the object, not a pointer to a base class
        which does not align with the pointer to the derived class.  You
        must trace back to the base yourself.

        You can very easily do something stupid with this command like
        !ks.forcedump <some CKsFilter> CKsPin 7.  This will force a dump of
        the memory as if the CKsFilter were a CKsPin; it may look very ugly!

*************************************************/

DECLARE_API(forcedump) {

    DWORD ForceAddr;
    ULONG Result, TabDepth;
    char objStr[256], typeStr[256], lvlStr[256], *pLvl;
    ULONG DumpLevel;
    INTERNAL_OBJECT_TYPE ObjType;
    ULONG i;

    GlobInit ();

    #ifdef DEBUG_EXTENSION
        dprintf ("Attempting to force dump structure args=[%s]!\n", args);
    #endif // DEBUG_EXTENSION

    if (!args || args [0] == 0) {
        dprintf ("Usage: !ks.forcedump <object> <type> [<level>]\n");
        return;
    }

    objStr [0] = lvlStr [0] = typeStr [0] = 0;

    //
    // Get all parameters converted as appropriate.
    //
    sscanf (args, "%s %s %s", objStr, typeStr, lvlStr);

    if (!(ForceAddr = Evaluator (objStr)))
        return;

    if (!typeStr [0]) {
        dprintf ("Usage: !ks.forcedump <object> <type> [<level>]\n");
        return;
    }

    if (lvlStr && lvlStr [0]) {
        pLvl = lvlStr; while (*pLvl && !isdigit (*pLvl)) pLvl++;

        #ifdef DEBUG_EXTENSION
            dprintf ("pLvl = [%s]\n", pLvl);
        #endif // DEBUG_EXTENSION

        if (*pLvl) {
            sscanf (pLvl, "%lx", &DumpLevel);
        } else {
            DumpLevel = 1;
        }
    } else {
        DumpLevel = 1;
    }

    #ifdef DEBUG_EXTENSION
        dprintf ("Dumping at level %ld\n", DumpLevel);
    #endif // DEBUG_EXTENSION

    //
    // The key is to determine what class the client gave us and use
    // the information.  Use the demangler array of type names and just
    // iterate through and straight strcmp for the type.
    //
    ObjType = ObjectTypeUnknown;
    for (i = 0; i < SIZEOF_ARRAY (TypeNamesToIdTypes); i++) 
        if (!strcmp (typeStr, TypeNamesToIdTypes [i].Name)) {
            ObjType = TypeNamesToIdTypes [i].ObjectType;
            break;
        }

    if (ObjType == ObjectTypeUnknown) {
        dprintf ("%s: unknown or currently unhandled type!\n", typeStr);
        return;
    }

    TabDepth = INITIAL_TAB;

    //
    // Warn the client that this is a forced dump and that no type checking
    // has been performed.
    //
    dprintf ("%sWARNING: I am dumping %08lx as a %s.\n"
        "%s         No checking has been performed to ensure that"
        " it is this type!!!\n\n",
        Tab (TabDepth), ForceAddr, typeStr, Tab(TabDepth));

    TabDepth++;

    //
    // Dump the private version of the object.  This is a forced dump.
    // Absolutely no checking is performed to ensure that ForceAddr is
    // really of type ObjType.
    //
    switch (ObjType) {

        case ObjectTypeCKsQueue:

            DumpQueueContents ((CKsQueue *)ForceAddr, DumpLevel, TabDepth);
            break;

        case ObjectTypeCKsDevice:

            DumpPrivateDevice (ForceAddr, DumpLevel, TabDepth);
            break;

        case ObjectTypeCKsFilterFactory:
            
            DumpPrivateFilterFactory (ForceAddr, DumpLevel, TabDepth);
            break;

        case ObjectTypeCKsFilter:

            DumpPrivateFilter (ForceAddr, DumpLevel, TabDepth);
            break;

        case ObjectTypeCKsPin:

            DumpPrivatePin (ForceAddr, DumpLevel, TabDepth);
            break;

        case ObjectTypeCKsPipeSection:

            DumpPrivatePipeSection (ForceAddr, DumpLevel, TabDepth);
            break;

        case ObjectTypeCKsRequestor:

            DumpPrivateRequestor (ForceAddr, DumpLevel, TabDepth);
            break;

        default:

            dprintf ("%s: I have not written support for this type yet!\n",
                typeStr);
            break;
    }

}

/*************************************************

    Function:

        enumerate

    Usage:

        !ks.enumerate <object>

    Description:

        Given any AVStream object, go to the parent device, find
        the FDO.  Walk up from the FDO to the driver.  Enumerate the
        driver as if you had done !ks.enumdrvobj

    Notes:

        - Some day I may add level to this as an indication of how
          far to trace down in the chain.

*************************************************/

DECLARE_API(enumerate) {

    DWORD Public, ExtAddr, ObjAddr;
    KSPX_EXT ObjExt;
    ULONG Result;
    char objStr[256], lvlStr[256], *pLvl;
    ULONG DumpLevel;

    GlobInit ();

    #ifdef DEBUG_EXTENSION
        dprintf ("Attempting to enumerate structure args=[%s]!\n", args);
    #endif // DEBUG_EXTENSION

    if (!args || args [0] == 0) {
        dprintf ("Usage: !ks.enumerate <object>\n");
        return;
    }

    objStr [0] = lvlStr [0] = 0;

    //
    // Get the object address and convert it to the private _EXT address.
    // Read in the KSPX_EXT structure to find out what the heck we're
    // referring to.
    //
    sscanf (args, "%s %s", objStr, lvlStr);

    if (!(Public = Evaluator (objStr)))
        return;

    if (lvlStr && lvlStr [0]) {
        pLvl = lvlStr; while (*pLvl && !isdigit (*pLvl)) pLvl++;

        #ifdef DEBUG_EXTENSION
            dprintf ("pLvl = [%s]\n", pLvl);
        #endif // DEBUG_EXTENSION

        if (*pLvl) {
            sscanf (pLvl, "%lx", &DumpLevel);
        } else {
            DumpLevel = 1;
        }
    } else {
        DumpLevel = 1;
    }

    #ifdef DEBUG_EXTENSION
        dprintf ("Enumerating at level %ld\n", DumpLevel);
    #endif // DEBUG_EXTENSION

    //
    // Check first to see if this is a C++ class object within AVStream.
    //
    {
        INTERNAL_OBJECT_TYPE ObjType;
        DWORD BaseAddr;

        ObjType = DemangleAndAttemptIdentification (
            Public,
            &BaseAddr,
            NULL
        );

        if (ObjType != ObjectTypeUnknown) {

            #ifdef DEBUG_EXTENSION
                dprintf ("%08lx: object is a [%s], base address = %08lx\n",
                    Public, ObjectNames [ObjType], BaseAddr);
            #endif // DEBUG_EXTENSION

            switch (ObjType) {

                case ObjectTypeCKsPin:

                    ExtAddr = BaseAddr + FIELDOFFSET (CKsPin, m_Ext);
                    break;

                case ObjectTypeCKsFilter:

                    ExtAddr = BaseAddr + FIELDOFFSET (CKsFilter, m_Ext);
                    break;

                case ObjectTypeCKsFilterFactory:

                    ExtAddr = BaseAddr + FIELDOFFSET (CKsFilterFactory, m_Ext);
                    break;

                case ObjectTypeCKsDevice:
                    
                    ExtAddr = BaseAddr + FIELDOFFSET (CKsDevice, m_Ext);
                    break;

                case ObjectTypeCKsQueue:
                {

                    PKSPIN MasterPin;

                    ObjAddr = BaseAddr + FIELDOFFSET (CKsQueue, m_MasterPin);
                    if (!ReadMemory (
                        ObjAddr,
                        &MasterPin,
                        sizeof (PKSPIN),
                        &Result)) {

                        dprintf ("%08lx: cannot read queue's master pin!\n",
                            ObjAddr);
                        return;
                    }
                    ExtAddr = (DWORD)CONTAINING_RECORD(
                        MasterPin, KSPIN_EXT, Public);
                    break;
                }

                case ObjectTypeCKsRequestor:
                {
                    PIKSPIN PinInterface;

                    ObjAddr = BaseAddr + FIELDOFFSET (CKsRequestor, m_Pin);
                    if (!ReadMemory (
                        ObjAddr,
                        &PinInterface,
                        sizeof (PIKSPIN),
                        &Result)) {

                        dprintf ("%08lx: cannot read requestor's pin!\n",
                            ObjAddr);
                        return;
                    }
                    ObjAddr = (DWORD)((CKsPin *)(PinInterface));
                    ExtAddr = ObjAddr + FIELDOFFSET (CKsPin, m_Ext);
                    break;
                }
                    
                case ObjectTypeCKsPipeSection:
                {
                    PIKSDEVICE DeviceInterface;

                    ObjAddr = BaseAddr + FIELDOFFSET (CKsPipeSection, 
                        m_Device);
                    if (!ReadMemory (
                        ObjAddr,
                        &DeviceInterface,
                        sizeof (PIKSDEVICE),
                        &Result)) {

                        dprintf ("%08lx: cannot read pipe's device!\n",
                            ObjAddr);
                        return;
                    }
                    ObjAddr = (DWORD)((CKsDevice *)(DeviceInterface));
                    ExtAddr = ObjAddr + FIELDOFFSET (CKsDevice, m_Ext);
                    break;

                }
                
                default:

                    dprintf ("Sorry....  I haven't finished this yet!\n");
                    break;

            }

        } else {

            ExtAddr = (DWORD)(CONTAINING_RECORD(Public, KSPX_EXT, Public));

        }

    }

    //
    // The above switch should give us an Ext somewhere in the hierarchy...
    // We really have no clue where.  Walk up the hierarchy until we hit
    // the device.
    //
    do {
    
        //
        // Read the Ext structure
        //
        if (!ReadMemory (
            ExtAddr,
            &ObjExt,
            sizeof (KSPX_EXT),
            &Result
        )) {
            dprintf ("%08lx: could not read object!\n", Public);
            return;
        }

        //
        // Ensure it's really Ok....
        //
        if (ObjExt.ObjectType != KsObjectTypeDevice &&
            ObjExt.ObjectType != KsObjectTypeFilterFactory &&
            ObjExt.ObjectType != KsObjectTypeFilter &&
            ObjExt.ObjectType != KsObjectTypePin) {

            dprintf ("%08lx: unknown object!\n", ExtAddr);
            return;
        }

    
        if (ObjExt.ObjectType != KsObjectTypeDevice)
            ExtAddr = (DWORD)ObjExt.Parent;

    } while (ObjExt.ObjectType != KsObjectTypeDevice && !CheckControlC ());

    //
    // Get the driver object and  enumerate it.
    //
    {
        KSDEVICE Device;
        PDRIVER_OBJECT DriverObjectAddr;
        DRIVER_OBJECT DriverObject;
        PDEVICE_OBJECT DeviceObject;
        PDEVICE_OBJECT NextDeviceObject;
        ULONG TabDepth = INITIAL_TAB;

        ObjAddr = ExtAddr + FIELDOFFSET (KSDEVICE_EXT, Public);

        if (!ReadMemory (
            ObjAddr,
            &Device,
            sizeof (KSDEVICE),
            &Result)) {

            dprintf ("%08lx: unable to read device!\n",
                ObjAddr);
            return;
        }

        ObjAddr = (DWORD)Device.FunctionalDeviceObject +
            FIELDOFFSET (DEVICE_OBJECT, DriverObject);
        
        if (!ReadMemory (
            ObjAddr,
            &DriverObjectAddr,
            sizeof (PDRIVER_OBJECT),
            &Result)) {

            dprintf ("%08lx: unable to read driver address!\n",
                ObjAddr);
            return;
        }

        if (!ReadMemory (
            (DWORD)DriverObjectAddr,
            &DriverObject,
            sizeof (DRIVER_OBJECT),
            &Result)) {

            dprintf ("%08lx: unable to read driver object!\n",
                DriverObjectAddr);
            return;
        }

        dprintf ("%sWDM driver object %08lx:\n", Tab (TabDepth), 
            DriverObjectAddr);
        TabDepth++;

        DeviceObject = DriverObject.DeviceObject;
        while (DeviceObject && !CheckControlC ()) {
            NextDeviceObject = EnumerateDeviceObject (
                (DWORD)DeviceObject,
                TabDepth
            );
            dprintf ("\n");
    
            DeviceObject = NextDeviceObject;
        }
    }
}

/**************************************************************************

    DEBUGGING API: 

        This is for debugging the extension and the kdext support in
        RTERM.

**************************************************************************/

/*************************************************

    Leave this in for debugging purposes.  IF 0 it, but
    DO **NOT** remove it.

*************************************************/

#if 0

DECLARE_API(resolve) {

    DWORD syma;
    CHAR buffer [1024];
    ULONG displ;

    GlobInit ();

    if (!args || args [0] == 0)
        return;

    sscanf(args, "%lx", &syma);

    dprintf ("Attempting to resolve %08lX\n", syma);

    GetSymbol ((LPVOID)syma, buffer, &displ);

    dprintf ("Called GetSymbol with the following parameters:\n"
        "1 [syma]: %08lx\n"
        "2 [buffer&]: %08lx\n"
        "3 [displ&]: %08lx\n",
        (LPVOID)syma,
        buffer,
        &displ
    );

    dprintf ("String buffer contents:\n");

    HexDump ((PVOID)buffer, (ULONG)buffer, 1024);

    dprintf ("buffer [%s], displ=%ld\n", buffer, displ);

}

#endif // 0

/*************************************************

    END DEBUG ONLY CODE

*************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\ksfilter\ks\thread.c ===
/*++

Copyright (C) Microsoft Corporation, 1997 - 1999

Module Name:

    thread.c

Abstract:

    This module contains the helper functions for worker threads. This
    allows clients to make a serialized work queue, and wait for the
    queue to be completed.
--*/

#include "ksp.h"

typedef struct {
    WORK_QUEUE_ITEM     WorkItem;
    KEVENT              CompletionEvent;
    LIST_ENTRY          WorkItemList;
    KSPIN_LOCK          WorkItemListLock;
    WORK_QUEUE_TYPE     WorkQueueType;
    LONG                ReferenceCount;
    BOOLEAN             UnregisteringWorker;
    ULONG               WorkCounter;
    PWORK_QUEUE_ITEM    CountedWorkItem;
#if (DBG)
    PETHREAD            WorkerThread;
#endif
} KSIWORKER, *PKSIWORKER;

#define KSSIGNATURE_LOCAL_WORKER 'wlSK'

#ifdef ALLOC_PRAGMA
VOID
WorkerThread(
    IN PVOID Context
    );
#pragma alloc_text(PAGE, WorkerThread)
#pragma alloc_text(PAGE, KsRegisterWorker)
#pragma alloc_text(PAGE, KsRegisterCountedWorker)
#pragma alloc_text(PAGE, KsUnregisterWorker)
#pragma alloc_text(PAGE, KsiQueryWorkQueueType)
#endif // ALLOC_PRAGMA


VOID
WorkerThread(
    IN PKSIWORKER Worker
    )
/*++

Routine Description:

    This is the thread routine for all worker threads.

Arguments:

    Worker -
        The worker which was queued.

Return Values:

    Nothing.

--*/
{
    for (;;) {
        PLIST_ENTRY         Entry;
        PWORK_QUEUE_ITEM    WorkItem;

        //
        // Get the first work item on this worker from off the list.
        // Only one work item at a time on this worker will be run.
        //
        Entry = ExInterlockedRemoveHeadList(
            &Worker->WorkItemList,
            &Worker->WorkItemListLock);
        ASSERT(Entry);
        WorkItem = CONTAINING_RECORD(Entry, WORK_QUEUE_ITEM, List);
#if (DBG)
        //
        // Clear for debug ASSERT()
        //
        WorkItem->List.Flink = NULL;
        Worker->WorkerThread = PsGetCurrentThread();
#endif
        WorkItem->WorkerRoutine(WorkItem->Parameter);
        if (KeGetCurrentIrql() != PASSIVE_LEVEL) {
            KeBugCheckEx(
                IRQL_NOT_LESS_OR_EQUAL,
                (ULONG_PTR)WorkItem->WorkerRoutine,
                (ULONG_PTR)KeGetCurrentIrql(),
                (ULONG_PTR)WorkItem->WorkerRoutine,
                (ULONG_PTR)WorkItem);
        }
#if (DBG)
        Worker->WorkerThread = NULL;
#endif
        //
        // Remove the reference count on the worker, noting that it has
        // now been completed.
        //
        // If this is the last reference count, then there are no more
        // items to process, and possibly a KsUnregisterWorker is waiting
        // to be signalled.
        //
        if (!InterlockedDecrement(&Worker->ReferenceCount)) {
            if (Worker->UnregisteringWorker) {
                KeSetEvent(&Worker->CompletionEvent, IO_NO_INCREMENT, FALSE);
            }
            break;
        }
    }
}


KSDDKAPI
NTSTATUS
NTAPI
KsRegisterWorker(
    IN WORK_QUEUE_TYPE WorkQueueType,
    OUT PKSWORKER* Worker
    )
/*++

Routine Description:

    Handles clients registering for use of a thread. This must be matched
    by a corresponding KsUnregisterWorker when thread use is completed.
    This may only be called at PASSIVE_LEVEL.

Arguments:

    WorkQueueType -
        Contains the priority of the work thread. This is normally one
        of CriticalWorkQueue, DelayedWorkQueue, or HyperCriticalWorkQueue.

    Worker -
        The place in which to put the opaque context which must be used
        when scheduling a work item. This contains the queue type, and
        is used to synchronize completion of work items.

Return Value:

    Returns STATUS_SUCCESS if a worker was initialized.

--*/
{
    PKSIWORKER  LocalWorker;
    NTSTATUS    Status;

    PAGED_CODE();
    if (WorkQueueType >= MaximumWorkQueue) {
        return STATUS_INVALID_PARAMETER;
    }
    LocalWorker = ExAllocatePoolWithTag(
        NonPagedPool, 
        sizeof(*LocalWorker), 
        KSSIGNATURE_LOCAL_WORKER);
    if (LocalWorker) {
        //
        // This contains the work item used to queue the worker
        // when items are queued to this object.
        //
        ExInitializeWorkItem(&LocalWorker->WorkItem, WorkerThread, LocalWorker);
        //
        // This event will be used when unregistering the worker. If the
        // item is in use, the call can wait for the event to be signalled.
        // It is only signalled if the work queue notices that the reference
        // count dropped to zero.
        //
        KeInitializeEvent(&LocalWorker->CompletionEvent, NotificationEvent, FALSE);
        //
        // This contains the list of worker items to serialize.
        //
        InitializeListHead(&LocalWorker->WorkItemList);
        //
        // This is used to serialize multiple threads queueing independent
        // work items to this worker. Each work item is placed on the
        // WorkItemList.
        //
        KeInitializeSpinLock(&LocalWorker->WorkItemListLock);
        //
        // This contains the queue type to use.
        //
        LocalWorker->WorkQueueType = WorkQueueType;
        //
        // The reference count starts at zero, and is incremented by scheduling
        // a work item, or decremented by completing it. On unregistering, this
        // is checked after setting UnregisteringWorker. This allows waiting for
        // outstanding work items, since the queue knows that the item is being
        // unregistered if it drops to zero and the flag is set.
        //
        LocalWorker->ReferenceCount = 0;
        LocalWorker->UnregisteringWorker = FALSE;
        //
        // This is the optional counter than can be used to control when a work
        // item is actually queued. It starts at zero, and is modified when a
        // work item is added, or when one is completed. A work item is distinct
        // from a worker.
        //
        LocalWorker->WorkCounter = 0;
        //
        // This is initialized by KsRegisterCountedWorker only, and is not
        // used in the uncounted worker situation.
        //
        LocalWorker->CountedWorkItem = NULL;
#if (DBG)
        LocalWorker->WorkerThread = NULL;
#endif
        *Worker = (PKSWORKER)LocalWorker;
        Status = STATUS_SUCCESS;
    } else {
        Status = STATUS_INSUFFICIENT_RESOURCES;
    }
    return Status;
}


KSDDKAPI
NTSTATUS
NTAPI
KsRegisterCountedWorker(
    IN WORK_QUEUE_TYPE WorkQueueType,
    IN PWORK_QUEUE_ITEM CountedWorkItem,
    OUT PKSWORKER* Worker
    )
/*++

Routine Description:

    Handles clients registering for use of a thread. This must be matched
    by a corresponding KsUnregisterWorker when thread use is completed.
    This function resembles KsRegisterWorker, with the addition of passing
    the work item that will always be queued. This is to be used with
    KsIncrementCountedWorker and KsDecrementCountedWorker in order to
    minimize the number of work items queued, and reduce mutual exclusion
    code necessary in a work item needed to serialize access against multiple
    work item threads. The worker queue can still be used to queue other
    work items. This may only be called at PASSIVE_LEVEL.

Arguments:

    WorkQueueType -
        Contains the priority of the work thread. This is normally one
        of CriticalWorkQueue, DelayedWorkQueue, or HyperCriticalWorkQueue.

    CountedWorkItem -
        Contains a pointer to the work queue item which will be queued
        as needed based on the current count value.

    Worker -
        The place in which to put the opaque context which must be used
        when scheduling a work item. This contains the queue type, and
        is used to synchronize completion of work items.

Return Value:

    Returns STATUS_SUCCESS if a worker was initialized.

--*/
{
    NTSTATUS    Status;

    PAGED_CODE();
    Status = KsRegisterWorker(WorkQueueType, Worker);
    if (NT_SUCCESS(Status)) {
        //
        // This assigns the work queue item which will always be used
        // in the case of KsIncrementCountedWorker.
        //
        ((PKSIWORKER)*Worker)->CountedWorkItem = CountedWorkItem;
    }
    return Status;
}


KSDDKAPI
VOID
NTAPI
KsUnregisterWorker(
    IN PKSWORKER Worker
    )
/*++

Routine Description:

    Handles clients unregistering a worker. This must only be used
    on a successful return from KsRegisterWorker or KsRegisterCountedWorker.
    The client must ensure that outstanding I/O initiated on any worker
    thread has been completed before unregistering the worker has been
    completed. This means cancelling or completing outstanding I/O either
    before unregistering the worker, or before the worker item returns from
    its callback for the last time and is unregistered. Unregistering
    of a worker will wait on any currently queued work items to complete
    before returning. This may only be called at PASSIVE_LEVEL.

Arguments:

    Worker -
        Contains the previously allocated worker which is to be unregistered.
        This will wait until any outstanding work item is completed.

Return Value:

    Nothing.

--*/
{
    PKSIWORKER  LocalWorker;

    PAGED_CODE();
    LocalWorker = (PKSIWORKER)Worker;
    ASSERT(LocalWorker->WorkerThread != PsGetCurrentThread());
    LocalWorker->UnregisteringWorker = TRUE;
    //
    // If no work item has been queued, then the item can just be deleted,
    // else this call must wait until it is no longer in use.
    //
    if (LocalWorker->ReferenceCount) {
        //
        // If a work item has been queued, then wait for it to complete.
        // On completion it will decrement the reference count and notice
        // that it must signal the event.
        //
        KeWaitForSingleObject(&LocalWorker->CompletionEvent, Executive, KernelMode, FALSE, NULL);
    }
    ASSERT(IsListEmpty(&LocalWorker->WorkItemList));
    ExFreePool(LocalWorker);
}


KSDDKAPI
NTSTATUS
NTAPI
KsQueueWorkItem(
    IN PKSWORKER Worker,
    IN PWORK_QUEUE_ITEM WorkItem
    )
/*++

Routine Description:

    Queues the specified work item with the worker previous created by
    KsRegisterWorker. The worker may only be on a queue in one place,
    so subsequent queuing of this worker must wait until the work item
    has completed executing. This means that all work items queued through
    a single registered worker are serialized. This may be called at
    DISPATCH_LEVEL.

Arguments:

    Worker -
        Contains the previously allocated worker.

    WorkItem -
        The initialized work item to queue. This work item is only
        associated with the worker as long as the worker is on a queue.
        The work item must have been initialized by ExInitializeWorkItem.

Return Value:

    Returns STATUS_SUCCESS if the work item was queued.

--*/
{
    PKSIWORKER  LocalWorker;

    ASSERT(KeGetCurrentIrql() <= DISPATCH_LEVEL);
    ASSERT(WorkItem->List.Flink == NULL);
    LocalWorker = (PKSIWORKER)Worker;
    ASSERT(!LocalWorker->UnregisteringWorker);
    ExInterlockedInsertTailList(
        &LocalWorker->WorkItemList,
        &WorkItem->List,
        &LocalWorker->WorkItemListLock);
    //
    // The initial reference count is zero, so a value of one would
    // indicate that this is the only item on the list now, or that
    // it is the first item to be put back on the list.
    //
    if (InterlockedIncrement(&LocalWorker->ReferenceCount) == 1) {
        //
        // Since there were no entries on this list, then it is OK
        // to queue the worker.
        //
        ExQueueWorkItem(&LocalWorker->WorkItem, LocalWorker->WorkQueueType);
    }
    return STATUS_SUCCESS;
}


KSDDKAPI
ULONG
NTAPI
KsIncrementCountedWorker(
    IN PKSWORKER Worker
    )
/*++

Routine Description:

    Increments the current worker count, and optionally queues the counted
    work item with the worker previous created by KsRegisterCountedWorker.
    This should be called after any list of tasks to perform by the worker
    has been added to. A corresponding KsDecrementCountedWorker should be
    called within the work item after each task has been completed. This
    may be called at DISPATCH_LEVEL.

Arguments:

    Worker -
        Contains the previously allocated worker.

Return Value:

    Returns the current counter. A count of one implies that a worker was
    actually scheduled.

--*/
{
    PKSIWORKER  LocalWorker;
    ULONG       WorkCounter;

    ASSERT(KeGetCurrentIrql() <= DISPATCH_LEVEL);
    LocalWorker = (PKSIWORKER)Worker;
    ASSERT(LocalWorker->CountedWorkItem);
    if ((WorkCounter = InterlockedIncrement(&LocalWorker->WorkCounter)) == 1) {
        KsQueueWorkItem(Worker, LocalWorker->CountedWorkItem);
    }
    return WorkCounter;
}


KSDDKAPI
ULONG
NTAPI
KsDecrementCountedWorker(
    IN PKSWORKER Worker
    )
/*++

Routine Description:

    Decrements the current worker count of a worker previous created by
    KsRegisterCountedWorker. This should be called after each task within
    a worker has been completed. A corresponding KsIncrementCountedWorker
    would have been previously called in order to increment the count. This
    may be called at DISPATCH_LEVEL.

Arguments:

    Worker -
        Contains the previously allocated worker.

Return Value:

    Returns the current counter. A count of zero implies that the task list
    has been completed.

--*/
{
    PKSIWORKER  LocalWorker;

    ASSERT(KeGetCurrentIrql() <= DISPATCH_LEVEL);
    LocalWorker = (PKSIWORKER)Worker;
    ASSERT(LocalWorker->CountedWorkItem);
    return InterlockedDecrement(&LocalWorker->WorkCounter);
}


WORK_QUEUE_TYPE
KsiQueryWorkQueueType(
    IN PKSWORKER Worker
    )
/*++

Routine Description:

    Returns the WORK_QUEUE_TYPE assigned to the worker when it was created.

Arguments:

    Worker -
        Contains the previously allocated worker.

Return Value:

    Returns the WORK_QUEUE_TYPE.

--*/
{
    return ((PKSIWORKER)Worker)->WorkQueueType;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\ksfilter\ks\kdexts\ksapi.c ===
/**************************************************************************

    Ks / AVStream debugging extensions	

    Copyright (C) Microsoft Corporation, 1997 - 2000


**************************************************************************/

#include "kskdx.h"

/**************************************************************************

    KS API

**************************************************************************/

#define MAX_CREATE_ITEMS    16

typedef struct {
    ULONG  Option;
    PSTR   Name;
} HEADER_OPTIONS_STRING;

HEADER_OPTIONS_STRING HeaderOptionStrings[] = {
    { 
        KSSTREAM_HEADER_OPTIONSF_SPLICEPOINT,
        "KSSTREAM_HEADER_OPTIONSF_SPLICEPOINT"
    },
    {
        KSSTREAM_HEADER_OPTIONSF_PREROLL,
        "KSSTREAM_HEADER_OPTIONSF_PREROLL"
    },
    {
        KSSTREAM_HEADER_OPTIONSF_DATADISCONTINUITY,
        "KSSTREAM_HEADER_OPTIONSF_DATADISCONTINUITY"
    },
    {
        KSSTREAM_HEADER_OPTIONSF_TYPECHANGED,
        "KSSTREAM_HEADER_OPTIONSF_TYPECHANGED"
    },
    {
        KSSTREAM_HEADER_OPTIONSF_TIMEVALID,
        "KSSTREAM_HEADER_OPTIONSF_TIMEVALID"
    },
    {
        KSSTREAM_HEADER_OPTIONSF_TIMEDISCONTINUITY,
        "KSSTREAM_HEADER_OPTIONSF_TIMEDISCONTINUITY"
    },
    {
        KSSTREAM_HEADER_OPTIONSF_FLUSHONPAUSE,
        "KSSTREAM_HEADER_OPTIONSF_FLUSHONPAUSE"
    },
    {
        KSSTREAM_HEADER_OPTIONSF_DURATIONVALID,
        "KSSTREAM_HEADER_OPTIONSF_DURATIONVALID"
    },
    {
        KSSTREAM_HEADER_OPTIONSF_ENDOFSTREAM,
        "KSSTREAM_HEADER_OPTIONSF_ENDOFSTREAM"
    },
    {
        KSSTREAM_HEADER_OPTIONSF_LOOPEDDATA,
        "KSSTREAM_HEADER_OPTIONSF_LOOPEDDATA" 
    }
};

static
VOID
DisplayKsTime(
    PSTR MemberName,
    PKSTIME Time
    )
{
    dprintf( 
        "%s.Time = %lu\n", MemberName, Time->Time );
    dprintf( 
        "%s.Numerator = %lu\n", MemberName, Time->Numerator );
    dprintf( 
        "%s.Denominator = %lu\n", MemberName, Time->Denominator );
}

static
void 
DisplayFunction(PVOID Address)
{
    UCHAR                CreateFunction[1024];
    ULONG                offset;
    
    if (Address == NULL) {
       dprintf("NULL\n");
    } else {
       GetSymbol(Address, CreateFunction, &offset);
       dprintf("%s+0x%02lx \n", CreateFunction, offset);
    }
}

static
void 
DisplayDispatchTable(ULONG Address)
{
    KSDISPATCH_TABLE  KsDispatchTable;
    DWORD             BytesRead;

    if (!ReadMemory( 
            (ULONG) Address, 
            &KsDispatchTable, 
            sizeof( KSDISPATCH_TABLE ), 
            &BytesRead)) {
        dprintf("????\n");
        return;
    }
 
    if (BytesRead < sizeof( KSDISPATCH_TABLE ) ) {
        dprintf( 
            "Only read %d bytes of DispatchTable, expected %d bytes\n", 
             BytesRead, 
             sizeof( KSDISPATCH_TABLE ) );
        return;
    }

    dprintf("    { DeviceIoControl = ");
    DisplayFunction(KsDispatchTable.DeviceIoControl);    

    dprintf("      Read = ");
    DisplayFunction(KsDispatchTable.Read);               

    dprintf("      Write = ");
    DisplayFunction(KsDispatchTable.Write);              

    dprintf("      Flush = ");
    DisplayFunction(KsDispatchTable.Flush);              

    dprintf("      Close = ");
    DisplayFunction(KsDispatchTable.Close);              

    dprintf("      QuerySecurity = ");
    DisplayFunction(KsDispatchTable.QuerySecurity);      

    dprintf("      SetSecurity = ");
    DisplayFunction(KsDispatchTable.SetSecurity);        

    dprintf("      FastDeviceIoControl = ");
    DisplayFunction(KsDispatchTable.FastDeviceIoControl);

    dprintf("      FastRead = ");
    DisplayFunction(KsDispatchTable.FastRead);           

    dprintf("      FastWrite = ");
    DisplayFunction(KsDispatchTable.FastWrite);          

    dprintf("     }\n");
}

static
void 
DisplayCreateItems(
                   ULONG Address, 
                   ULONG ItemsCount
                   )
{

                                                                                                                                                                                                                   
    KSOBJECT_CREATE_ITEM CreateItems[MAX_CREATE_ITEMS],
                         *pCreateItem;
    DWORD                BytesRead;
    WCHAR                Buffer[128];
    DWORD                BufferLength = sizeof( Buffer );
    ULONG                itemIdx;

    if ( ItemsCount == 0 ) {
        return;
    }
    
    if(ItemsCount > MAX_CREATE_ITEMS)
        ItemsCount = MAX_CREATE_ITEMS;
    
    if (!ReadMemory( 
            (ULONG) Address, 
            CreateItems, 
            sizeof( KSOBJECT_CREATE_ITEM ) * ItemsCount, 
            &BytesRead)) {
        dprintf("{ ???? }\n");
        return;
    }
 
    if (BytesRead < ItemsCount * sizeof( KSOBJECT_CREATE_ITEM ) ) {
        dprintf( 
            "Only read %d bytes of CreateItemList, expected %d bytes\n", 
             BytesRead, 
             ItemsCount * sizeof( KSOBJECT_CREATE_ITEM ) );
        ItemsCount = BytesRead / sizeof(KSOBJECT_CREATE_ITEM);
    }
    
    for( itemIdx = 0; itemIdx < ItemsCount; itemIdx++)
    {
        
        pCreateItem = &CreateItems[itemIdx];
        
        dprintf("    {\n        CreateFunction = ");
        DisplayFunction(pCreateItem->Create);

        dprintf("        ObjectClass = ");
        if (pCreateItem->ObjectClass.Length == 0) {
           dprintf("NULL\n");
        } else {
           if (BufferLength > pCreateItem->ObjectClass.MaximumLength ) {
              BufferLength = pCreateItem->ObjectClass.MaximumLength;
           }
           if (!ReadMemory( 
                   (ULONG) pCreateItem->ObjectClass.Buffer, 
                   Buffer, 
                   BufferLength, 
                   &BytesRead)) {
               dprintf("????\n");
           }
           if ( BufferLength <= pCreateItem->ObjectClass.Length ) {
               Buffer[sizeof(Buffer) / sizeof(WCHAR) - 1] = UNICODE_NULL;
           } else {
               Buffer[pCreateItem->ObjectClass.Length / sizeof(WCHAR)] = UNICODE_NULL;
           }
           
           dprintf("%S\n", Buffer);
        }
        
        dprintf("        Flags = %lx\n"
                "    }\n", 
                pCreateItem->Flags);
    }

}

static
void 
DisplayCreateList(
    PLIST_ENTRY ChildCreateHandlerList,
    DWORD OriginalAddress
    )
{
    KSICREATE_ENTRY CreateEntry;
    DWORD Address;
    ULONG Result;

    CreateEntry.ListEntry = *ChildCreateHandlerList;
    while ((DWORD)CreateEntry.ListEntry.Flink != OriginalAddress &&
        !CheckControlC() ) {

        Address = (DWORD) 
            CONTAINING_RECORD(CreateEntry.ListEntry.Flink, 
                KSICREATE_ENTRY, ListEntry);

        if (!ReadMemory (
            Address,
            &CreateEntry,
            sizeof (KSICREATE_ENTRY),
            &Result)) {

            dprintf ("%08lx: unable to read create entry!\n",
                Address);
            return;
        }

        DisplayCreateItems((ULONG)CreateEntry.CreateItem, 1);
    }

}

DECLARE_API(shdr)
{
    int                 i;
    DWORD               Address, BytesRead;
    KSSTREAM_HEADER     StreamHeader;
    
    if (0 == args[0])
    {
        dprintf("shdr <PKSSTREAM_HEADER>\n");
        return;
    }

    sscanf( args, "%lx", &Address );

    if (!ReadMemory( 
            Address, 
            &StreamHeader, 
            sizeof( KSSTREAM_HEADER ), 
            &BytesRead)) {
        return;     
    }
 
    if (BytesRead < sizeof( KSSTREAM_HEADER )) {
        dprintf( 
            "Only read %d bytes, expected %d bytes\n", 
             BytesRead, 
             sizeof( KSSTREAM_HEADER ) );
        return;     
    }
    
    dprintf(
        "Stream Header: 0x%08x\n\n", Address );
        
    DisplayKsTime( "PresentationTime", &StreamHeader.PresentationTime );
    dprintf( 
        "Duration = %lu\n", StreamHeader.Duration );
    dprintf( 
        "FrameExtent = %u\n", StreamHeader.FrameExtent );
    dprintf( 
        "DataUsed = %u\n", StreamHeader.DataUsed );
    dprintf( 
        "Data = 0x%08x\n", StreamHeader.Data );

    for (i = 0; i < SIZEOF_ARRAY( HeaderOptionStrings ); i++) {
        if (HeaderOptionStrings[ i ].Option & StreamHeader.OptionsFlags) {
            dprintf( "%s\n", HeaderOptionStrings[ i ].Name );
        }
    }
    
    return;
}

DECLARE_API(dhdr)
{
    DWORD                Address, BytesRead;    
    KSIDEVICE_HEADER     KsDeviceHeader;
    
    if (0 == args[0])
    {
        dprintf("dhdr <KSDEVICE_HEADER>\n");
        return;
    }

    sscanf( args, "%lx", &Address );

    if (!ReadMemory( 
            Address, 
            &KsDeviceHeader, 
            sizeof( KSIDEVICE_HEADER ), 
            &BytesRead)) {
        dprintf("Can not read KsDeviceHeader\n");
        return;     
    }
 
    if (BytesRead < sizeof( KSIDEVICE_HEADER )) {
        dprintf( 
            "Only read %d bytes of KsDeviceHeader, expected %d bytes\n", 
             BytesRead, 
             sizeof( KSIDEVICE_HEADER ) );
        return;     
    }
    
    
    dprintf(" KsDeviceHeader 0x%x {\n", Address);
    dprintf("     ChildCreateHandlerList\n");
    DisplayCreateList(&KsDeviceHeader.ChildCreateHandlerList,
        (DWORD)Address + FIELDOFFSET(KSIDEVICE_HEADER, ChildCreateHandlerList));
    dprintf(" }\n");
    return;
}

DECLARE_API(ohdr)
{
    DWORD                Address, BytesRead;    
    KSIOBJECT_HEADER     KsObjectHeader;
    
    if (0 == args[0])
    {
        dprintf("objhdr <PFILE_OBJECT>\n");
        return;
    }

    sscanf( args, "%lx", &Address );
    
    if (!ReadMemory( 
            Address, 
            &KsObjectHeader, 
            sizeof( KSIOBJECT_HEADER ), 
            &BytesRead)) {
        dprintf("Can not read KsObjectHeader\n");
        return;     
    }
 
    if (BytesRead < sizeof( KSIOBJECT_HEADER )) {
        dprintf( 
            "Only read %d bytes of KsObjectHeader, expected %d bytes\n", 
             BytesRead, 
             sizeof( KSIOBJECT_HEADER ) );
        return;     
    }
    
    
    dprintf(" KsObjectHeader 0x%x {\n", Address);
    
    dprintf("   Object's CreateItem:\n");
    DisplayCreateItems( (ULONG) KsObjectHeader.CreateItem,
                        1L);

    dprintf("   ChildCreateHandlerList:");
    DisplayCreateList( &KsObjectHeader.ChildCreateHandlerList,
        (DWORD)Address + 
        FIELDOFFSET (KSIOBJECT_HEADER, ChildCreateHandlerList));
    
    dprintf("   DispatchTable:\n");
    DisplayDispatchTable( (ULONG) KsObjectHeader.DispatchTable);

    if (KsObjectHeader.TargetState == KSTARGET_STATE_ENABLED) {
        dprintf("   TargetState: KSTARGET_STATE_ENABLED");
    } else {
        dprintf("   TargetState: KSTARGET_STATE_DISABLED");
    }

    dprintf("   TargetDevice: 0x%08lx", (ULONG) KsObjectHeader.TargetDevice);
    dprintf("   BaseDevice  : 0x%08lx", (ULONG) KsObjectHeader.BaseDevice);
    
    dprintf(" }\n");
    return;
}

DECLARE_API(devhdr)
{
    ULONG                i;
    DWORD                Address, BytesRead;    
    DEVICE_OBJECT        DeviceObject;
    PVOID                pHeader;
    KSIDEVICE_HEADER     KsDeviceHeader;
    KSOBJECT_CREATE_ITEM CreateItems[MAX_CREATE_ITEMS];
    ULONG                CreateItemsCnt;
    
    if (0 == args[0])
    {
        dprintf("devhdr <PDEVICE_OBJECT>\n");
        return;
    }

    sscanf( args, "%lx", &Address );

    if (!ReadMemory( 
            Address, 
            &DeviceObject, 
            sizeof( DEVICE_OBJECT ), 
            &BytesRead)) {
        dprintf("Can not read Device Object\n");
        return;     
    }
 
    if (BytesRead < sizeof( DEVICE_OBJECT )) {
        dprintf( 
            "Only read %d bytes of DeviceObject, expected %d bytes\n", 
             BytesRead, 
             sizeof( DEVICE_OBJECT ) );
        return;     
    }
    
    dprintf(" DeviceExtension 0x%x\n", (ULONG) DeviceObject.DeviceExtension);
    
    if (!ReadMemory( 
            (ULONG) DeviceObject.DeviceExtension, 
            &pHeader, 
            sizeof( PVOID ), 
            &BytesRead)) {
        dprintf("Can not read KsDeviceHeader address from Extension\n");
        return;     
    }
 
    if (BytesRead < sizeof( PVOID )) {
        dprintf( 
            "Only read %d bytes of DeviceExtension, expected %d bytes\n", 
             BytesRead, 
             sizeof( PVOID ) );
        return;     
    }
    
    if (!ReadMemory( 
            (ULONG) pHeader, 
            &KsDeviceHeader, 
            sizeof( KSIDEVICE_HEADER ), 
            &BytesRead)) {
        dprintf("Can not read KsDeviceHeader\n");
        return;     
    }
 
    if (BytesRead < sizeof( KSIDEVICE_HEADER )) {
        dprintf( 
            "Only read %d bytes of KsDeviceHeader, expected %d bytes\n", 
             BytesRead, 
             sizeof( KSIDEVICE_HEADER ) );
        return;     
    }
    
    
    dprintf(" KsDeviceHeader 0x%x {\n", (ULONG)pHeader);
    dprintf("     ChildCreateHandlerList");
    DisplayCreateList( &KsDeviceHeader.ChildCreateHandlerList,
        (DWORD)pHeader + FIELDOFFSET (KSIDEVICE_HEADER, 
        ChildCreateHandlerList));
    dprintf(" }\n");
    return;
}

DECLARE_API(objhdr)
{
    ULONG                i;
    DWORD                Address, BytesRead;    
    FILE_OBJECT          FileObject;
    PVOID                pHeader;
    KSIOBJECT_HEADER     KsObjectHeader;
    KSDISPATCH_TABLE     KsDiaptachTable;
    
    if (0 == args[0])
    {
        dprintf("objhdr <PFILE_OBJECT>\n");
        return;
    }

    sscanf( args, "%lx", &Address );

    if (!ReadMemory( 
            Address, 
            &FileObject, 
            sizeof( FILE_OBJECT ), 
            &BytesRead)) {
        dprintf("Can not read File Object\n");
        return;     
    }
 
    if (BytesRead < sizeof( FILE_OBJECT )) {
        dprintf( 
            "Only read %d bytes of File Object, expected %d bytes\n", 
             BytesRead, 
             sizeof( FILE_OBJECT ) );
        return;     
    }
    
    dprintf(" FsContext 0x%x\n", (ULONG) FileObject.FsContext);
    
    if (!ReadMemory( 
            (ULONG) FileObject.FsContext, 
            &pHeader, 
            sizeof( PVOID ), 
            &BytesRead)) {
        dprintf("Can not read KsObjectHeader address from FsContext\n");
        return;     
    }
 
    if (BytesRead < sizeof( PVOID )) {
        dprintf( 
            "Only read %d bytes of FsContext, expected %d bytes\n", 
             BytesRead, 
             sizeof( PVOID ) );
        return;     
    }
    
    if (!ReadMemory( 
            (ULONG) pHeader, 
            &KsObjectHeader, 
            sizeof( KSIOBJECT_HEADER ), 
            &BytesRead)) {
        dprintf("Can not read KsObjectHeader\n");
        return;     
    }
 
    if (BytesRead < sizeof( KSIOBJECT_HEADER )) {
        dprintf( 
            "Only read %d bytes of KsObjectHeader, expected %d bytes\n", 
             BytesRead, 
             sizeof( KSIOBJECT_HEADER ) );
        return;     
    }
    
    
    dprintf(" KsObjectHeader 0x%x {\n", (ULONG)pHeader);
    
    dprintf("   Object's CreateItem:\n");
    DisplayCreateItems( (ULONG) KsObjectHeader.CreateItem,
                        1L);

    dprintf("   ChildCreateHandlerList");
    DisplayCreateList( &KsObjectHeader.ChildCreateHandlerList,
        (DWORD)pHeader + FIELDOFFSET(KSIOBJECT_HEADER, ChildCreateHandlerList));
    
    dprintf("   DispatchTable:\n");
    DisplayDispatchTable( (ULONG) KsObjectHeader.DispatchTable);

    if (KsObjectHeader.TargetState == KSTARGET_STATE_ENABLED) {
        dprintf("   TargetState: KSTARGET_STATE_ENABLED");
    } else {
        dprintf("   TargetState: KSTARGET_STATE_DISABLED");
    }

    dprintf("   TargetDevice: 0x%08lx", (ULONG) KsObjectHeader.TargetDevice);
    dprintf("   BaseDevice  : 0x%08lx", (ULONG) KsObjectHeader.BaseDevice);
    
    dprintf(" }\n");
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\ksfilter\ks\kdexts\avsutil.h ===
/**************************************************************************

    AVStream extension utilities

**************************************************************************/

/*************************************************

    CMemoryBlock

    This is basically a smart pointer wrapper.  It allocates
    and deallocates memory to store the type as necessary.  The
    dereference operator is overloaded. 

*************************************************/

template <class TYPE> 
class CMemoryBlock {

private:
    
    TYPE *m_Memory;

public:

    CMemoryBlock () {
        m_Memory = (TYPE *)malloc (sizeof (TYPE));
    }

    CMemoryBlock (ULONG Quantity) {

        if (Quantity > 0)
            m_Memory = (TYPE *)malloc (Quantity * sizeof (TYPE));
        else
            m_Memory = NULL;
    }

    ~CMemoryBlock () {
        free (m_Memory);
        m_Memory = NULL;
    }

    TYPE *operator->() {
        return m_Memory;
    }

    TYPE *Get () {
        return m_Memory;
    }

};

/*************************************************

    CMemory

    This is an allocator / cleanup class for chunks of memory. 
    It is used as CMemoryBlock except that it only provides a
    chunk of memory.  It does not overload dereferences.  When
    it falls out of scope, the memory is deallocated.


*************************************************/

class CMemory {

private:

    void *m_Memory;

public:

    CMemory (ULONG Size) {

        if (Size > 0)
            m_Memory = (void *)malloc (Size);
        else
            m_Memory = NULL;
    }

    ~CMemory () {
        free (m_Memory);
        m_Memory = NULL;
    }

    void *Get () {
        return m_Memory;
    }

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\ksfilter\ks\kdexts\kskdx.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 2000
//
//  File:       kskdx.h
//
//--------------------------------------------------------------------------

#ifndef __KDEXT_ONLY__
#define __KDEXT_ONLY__
#endif // __KDEXT_ONLY__

#ifndef __KSKDX_H
#define __KSKDX_H

#ifdef __cplusplus
extern "C" {
#endif // __cplusplus

#include <nt.h>
#include <ntos.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <imagehlp.h>
#include <wdbgexts.h>
#include <stdio.h>
#include <stdlib.h>
#include <ntverp.h>

//
// Get rid of any cute definitions of ExAllocatePool and ExFreePool.  The
// linkages should never get called.  They're only here to appease the
// inclusion of .cpp files without a million more #ifndef KDEXT_ONLY 
// exclusions.
//
#ifdef ExAllocatePool
#undef ExAllocatePool
#endif // ExAllocatePool

#ifdef ExFreePool
#undef ExFreePool
#endif // ExFreePool

#include <ksp.h>
#ifdef __cplusplus
}
#endif // __cplusplus
#ifdef __cplusplus
#include <kcom.h>
extern "C" {
#endif // __cplusplus
#include <ks.h>
#include <ksmedia.h>
#ifdef __cplusplus
}
#endif // __cplusplus

#define HOSTPOINTER 
#define TARGETPOINTER

//
// Internal definitions
//

typedef DWORD (*OBJECT_ADJUSTMENT_FUNCTION)(PVOID, DWORD);

#define NOT_IMPLEMENTED     0xFACEFEED

#define DUMPOBJQUEUELIST_BAILOUT_COUNT 120

typedef enum _INTERNAL_OBJECT_TYPE {

    ObjectTypeUnknown = 0,

    //
    // Client viewable structures.
    //
    ObjectTypeKSPin,
    ObjectTypeKSFilter,
    ObjectTypeKSDevice,
    ObjectTypeKSFilterFactory,

    //
    // Non-client viewable structures.
    //
    ObjectTypeCKsQueue,
    ObjectTypeCKsDevice,
    ObjectTypeCKsFilterFactory,
    ObjectTypeCKsFilter,
    ObjectTypeCKsPin,
    ObjectTypeCKsRequestor,
    ObjectTypeCKsSplitter,
    ObjectTypeCKsSplitterBranch,

    ObjectTypeCKsPipeSection,

    ObjectType_MAX

} INTERNAL_OBJECT_TYPE, *PINTERNAL_OBJECT_TYPE;

typedef enum _INTERNAL_STRUCTURE_TYPE {
    
    StructureTypeUnknown = 0,
    StructureType_KSSTREAM_POINTER 

} INTERNAL_STRUCTURE_TYPE, *PINTERNAL_STRUCTURE_TYPE;

typedef enum _INTERNAL_INTERFACE_TYPE {

    InterfaceTypeUnknown = 0,

    //
    // These are mostly internal to AVStream.  Only the base unknowns are
    // not.
    //

    InterfaceTypeIKsTransport,              // 1
    InterfaceTypeIKsRetireFrame,            // 2
    InterfaceTypeIKsPowerNotify,            // 3
    InterfaceTypeIKsProcessingObject,       // 4
    InterfaceTypeIKsConnection,             // 5
    InterfaceTypeIKsDevice,                 // 6
    InterfaceTypeIKsFilterFactory,          // 7
    InterfaceTypeIKsFilter,                 // 8
    InterfaceTypeIKsPin,                    // 9
    InterfaceTypeIKsPipeSection,            // 10
    InterfaceTypeIKsRequestor,              // 11
    InterfaceTypeIKsQueue,                  // 12
    InterfaceTypeIKsSplitter,               // 13

    InterfaceTypeIKsControl,                // 14
    InterfaceTypeIKsWorkSink,               // 15
    InterfaceTypeIKsReferenceClock,         // 16

    InterfaceTypeINonDelegatedUnknown,      // 17
    InterfaceTypeIIndirectedUnknown,        // 18

    InterfaceType_MAX

} INTERNAL_INTERFACE_TYPE, *PINTERNAL_INTERFACE_TYPE;

typedef enum _SIGNATURE_TYPE {

    SignatureUnknown = 0,
    SignatureIrp,
    SignatureFile

} SIGNATURE_TYPE, *PSIGNATURE_TYPE;

typedef enum _AUTOMATION_ITEM {

    AutomationUnknown = 0,
    AutomationProperty,
    AutomationMethod,
    AutomationEvent

} AUTOMATION_TYPE, *PAUTOMATION_TYPE;

typedef void (*AUTOMATION_DUMP_HANDLER)(IN PKSIDENTIFIER Property,
                                      IN ULONG TabDepth);

typedef BOOLEAN (*PFNLOG_ITERATOR_CALLBACK)(IN PVOID Context, 
    IN PKSLOG_ENTRY Entry);

typedef BOOLEAN (*PFNCIRCUIT_WALK_CALLBACK)(IN PVOID Context,
    IN INTERNAL_OBJECT_TYPE Type, IN DWORD Base, IN PVOID Object);

//
// function prototypes
//

VOID
DisplayStreamingHeader(
    ULONG Address,
    PKSSTREAM_HEADER StreamHeader
    );

ULONG
WalkCircuit (
    IN PVOID Object,
    IN PFNCIRCUIT_WALK_CALLBACK Callback,
    IN PVOID CallbackContext
    );

void
HexDump (
    IN PVOID HostAddress,
    IN ULONG TargetAddress,
    IN ULONG BufferSize
    );

#ifdef __cplusplus
extern "C" {
#endif // __cplusplus

BOOLEAN
DisplayNamedAutomationSet (
    IN GUID *Set,
    IN char *String
    );

BOOLEAN
DisplayNamedAutomationId (
    IN GUID *Set,
    IN ULONG Id,
    IN char *String,
    IN OUT AUTOMATION_DUMP_HANDLER *DumpHandler
    );

int
ustrcmp (
    char *a,
    char *b
    );

DWORD 
Evaluator (
    IN const char *StringEval
    );

void
GlobInit (
    );

char *
Tab (
    IN ULONG Depth
    );

#ifdef __cplusplus
}
#endif // __cplusplus


#define FIELDOFFSET(struc,field) \
    (ULONG)(&(((struc *)0) -> field))

//
// Dump Levels
//
#define DUMPLVL_TERSE 0
#define DUMPLVL_GENERAL 1
#define DUMPLVL_BEYONDGENERAL 2
#define DUMPLVL_SPECIFIC 3
#define DUMPLVL_INTERNAL 4
#define DUMPLVL_INTERNALDETAIL 5
#define DUMPLVL_HIGHDETAIL 6
#define DUMPLVL_EVERYTHING 7

//
// Tabbing
//
#define INITIAL_TAB 0
#define TAB_SPACING 4

#define DBG_DUMPGUID(text,guid) \
   dprintf ("%s%08lx-%04x-%04x-%02x%02x-%02x%02x%08lx\n", \
   text, \
   *(((ULONG *)&(guid)) + 0), \
   *(((USHORT *)&(guid)) + 2), \
   *(((USHORT *)&(guid)) + 3), \
   *(((USHORT *)&(guid)) + 4) & 0xFF, \
   *(((USHORT *)&(guid)) + 4) >> 8, \
   *(((USHORT *)&(guid)) + 5) & 0xFF, \
   *(((USHORT *)&(guid)) + 5) >> 8, \
   ((*(((ULONG *)&(guid)) + 3)) & 0xFF) << 24 | \
   ((*(((ULONG *)&(guid)) + 3)) & 0xFF00) << 8 | \
   ((*(((ULONG *)&(guid)) + 3)) & 0xFF0000) >> 8 | \
   ((*(((ULONG *)&(guid)) + 3)) & 0xFF000000) >> 24); \

#define XTN_DUMPGUID(text,tab,guid) \
   if (!text [0])\
       dprintf ("%s%08lx-%04x-%04x-%02x%02x-%02x%02x%08lx\n", \
       Tab (tab), \
       *(((ULONG *)&(guid)) + 0), \
       *(((USHORT *)&(guid)) + 2), \
       *(((USHORT *)&(guid)) + 3), \
       *(((USHORT *)&(guid)) + 4) & 0xFF, \
       *(((USHORT *)&(guid)) + 4) >> 8, \
       *(((USHORT *)&(guid)) + 5) & 0xFF, \
       *(((USHORT *)&(guid)) + 5) >> 8, \
       ((*(((ULONG *)&(guid)) + 3)) & 0xFF) << 24 | \
       ((*(((ULONG *)&(guid)) + 3)) & 0xFF00) << 8 | \
       ((*(((ULONG *)&(guid)) + 3)) & 0xFF0000) >> 8 | \
       ((*(((ULONG *)&(guid)) + 3)) & 0xFF000000) >> 24); \
   else \
       dprintf ("%s%s %08lx-%04x-%04x-%02x%02x-%02x%02x%08lx\n", \
       Tab (tab), \
       text, \
       *(((ULONG *)&(guid)) + 0), \
       *(((USHORT *)&(guid)) + 2), \
       *(((USHORT *)&(guid)) + 3), \
       *(((USHORT *)&(guid)) + 4) & 0xFF, \
       *(((USHORT *)&(guid)) + 4) >> 8, \
       *(((USHORT *)&(guid)) + 5) & 0xFF, \
       *(((USHORT *)&(guid)) + 5) >> 8, \
       ((*(((ULONG *)&(guid)) + 3)) & 0xFF) << 24 | \
       ((*(((ULONG *)&(guid)) + 3)) & 0xFF00) << 8 | \
       ((*(((ULONG *)&(guid)) + 3)) & 0xFF0000) >> 8 | \
       ((*(((ULONG *)&(guid)) + 3)) & 0xFF000000) >> 24)

#endif // __AVSTREAM_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\ksfilter\ks\kdexts\logapi.cpp ===
/**************************************************************************

    logapi.cpp
   
    --------------------------------------------------

    Ks Logging access extension API

    --------------------------------------------------

    Toss questions at wmessmer
 
    ==================================================

    In debug mode, Ks keeps a log of events that happen (irp arrivals,
    transports, etc...).  Reading this without the aid of some type of
    extension is useless.  That's precisely what this section of the debug
    extension is designed to do.

    ==================================================

    Notes to future maintainers:

    1) 

        Unfortunately, as of the writing of this code, ks.sys does not
        track Irp movement in and out of certain types of objects 
        (requestors) and also does not track creation and destruction of
        certain types of objects.  This makes findlive a difficult command
        to accurately implement.

        I intend to eventually implement the logging of requestor motions
        and the creations/destructions which are not logged now, but this
        will not be in some releases (most notably DX8, but also WinME).  
        Once this is in, some of the code in FindLiveObject will become
        unnecessary...  PLEASE, maintain the support in case anything ever
        needs debugged with respect to DX8.  

**************************************************************************/

#include "kskdx.h"
#include "avsutil.h"

//
// Include class definitions for key parts.
//
#include "..\shpin.cpp"
#include "..\shfilt.cpp"
#include "..\shqueue.cpp"
#include "..\shreq.cpp"
#include "..\shdevice.cpp"

char *NounNames [] = {
    "Irp", // This isn't really a noun!
    "Graph",
    "Filter",
    "Pin",
    "Queue",
    "Requestor",
    "Splitter",
    "Branch"
    "Pipe Section"
};

#define NOUN_IDX_IRP 0
#define NOUN_IDX_FILTER 2
#define NOUN_IDX_PIN 3
#define NOUN_IDX_QUEUE 4
#define NOUN_IDX_REQUESTOR 5

char *VerbNames [] = {
    "Create",
    "Destroy",
    "Send",
    "Receive"
};

typedef enum _NODE_TYPE {

    NodeCreation,
    NodeDestruction

} NODE_TYPE, *PNODE_TYPE;

typedef struct _OBJECT_NODE {

    LIST_ENTRY ListEntry;
    
    //
    // What object are we looking at.  There can only be one node per object
    // in the list.
    //
    PVOID Object;

    //
    // Associated information out of the log information.  What is the filter
    // and what is the pin associated with this.  This may be the same as
    // object if the object is a filter or pin.
    //
    PVOID Filter;
    PVOID Pin;
    
    //
    // In all cases EXCEPT searching for Irps, this should match the context's
    // noun.  In IRP's we have to track all pins, queues, requestors 
    // (BUGBUG: splitters)
    //
    ULONG ObjectNoun;

    //
    // Is this a creation or destruction node?
    //
    NODE_TYPE NodeType;

    //
    // Indicates whether this entry is locked.  A locked entry is a guaranteed
    // match for a live object supposing the node is not a destruct node.
    //
    BOOLEAN Locked;

    //
    // Indicates whether or not the object is a sink.  All requestors are
    // sinks, some pins are sinks.
    //
    BOOLEAN Sink;

    //
    // Indicates whether or not the creation of the Irp was a receive.
    //
    BOOLEAN Received;

    //
    // Indicates whether we've passed the creation entry for this node (if
    // the node is a create node)
    //
    BOOLEAN PassedCreate;

    //
    // Indicates whether a creation for an Irp node referenced a component
    // which had already been destroyed in the log (temporally backwards,
    // I know...  obviously, the destruction would come in the future...
    // just remember that we're scanning the log backwards).
    //
    BOOLEAN CreationReferencedDestruction;

    //
    // What node is the parent node if we know
    //
    struct _OBJECT_NODE *ParentNode;
    
    //
    // What node created this node?  This is not the parent.  Only receivers
    // can be parents.
    //
    struct _OBJECT_NODE *CreatorNode;

} OBJECT_NODE, *POBJECT_NODE;

typedef struct _LIVE_OBJECT_CONTEXT {

    ULONG TabDepth;
    ULONG DumpLevel;
    ULONG ObjectNoun;

    PVOID PreviousObject;
    ULONG PreviousVerb;

    LIST_ENTRY ObjectNodes;

} LIVE_OBJECT_CONTEXT, *PLIVE_OBJECT_CONTEXT;

/*************************************************

    Function:

        IsSinkPin

    Description:

        Determine if a target side pin is a sink pin or a source
        pin.  Sinks return TRUE, sources FALSE.

    Arguments:

        Pin -
            The pin to question.

    Return Value:

        TRUE -
            The pin is a sink

        FALSE -
            The pin is a source / an error occurred

*************************************************/

BOOLEAN
IsSinkPin (
    IN CKsPin *Pin
    )

{

    PFILE_OBJECT *ConnectionAddress;
    PFILE_OBJECT ConnectionFile;
    ULONG Result;

    ConnectionAddress = (PFILE_OBJECT *)((PUCHAR)Pin + 
        FIELDOFFSET (CKsPin, m_ConnectionFileObject));

    if (!ReadMemory (
        (DWORD)ConnectionAddress,
        &ConnectionFile,
        sizeof (PFILE_OBJECT),
        &Result))
        return FALSE;

    return (ConnectionFile == NULL);

}

/*************************************************

    Function:

        DisplayOwningDriver

    Description:

        Find the owning driver for an object and display it.

    Arguments:

        Object -
            The object

        NounType -
            The object type (as a noun index)

    Return Value:

        Successful or not

*************************************************/

BOOLEAN
DisplayOwningDriver (
    IN PVOID Object,
    IN ULONG NounType
    )

{
    
    PKSPX_EXT ExtAddr;
    ULONG Result;

    switch (NounType) {

        case NOUN_IDX_PIN:
            ExtAddr = (PKSPX_EXT)((PUCHAR)Object + FIELDOFFSET (CKsPin, m_Ext));
            break;

        case NOUN_IDX_FILTER:
            ExtAddr = (PKSPX_EXT)((PUCHAR)Object + 
                FIELDOFFSET (CKsFilter, m_Ext));
            break;

        case NOUN_IDX_QUEUE:
        {
            PKSPIN *PinAddr = (PKSPIN *)((PUCHAR)Object +
                FIELDOFFSET (CKsQueue, m_MasterPin));

            if (!ReadMemory (
                (DWORD)PinAddr,
                (PVOID)&ExtAddr,
                sizeof (PVOID),
                &Result))
                return FALSE;

            ExtAddr = (PKSPX_EXT)CONTAINING_RECORD (
                ExtAddr, KSPIN_EXT, Public
                );

            break;
                
        }

        case NOUN_IDX_REQUESTOR:
        {
            PIKSPIN *PinIfAddr = (PIKSPIN *)((PUCHAR)Object +
                FIELDOFFSET (CKsRequestor, m_Pin));

            if (!ReadMemory (
                (DWORD)PinIfAddr,
                (PVOID)&ExtAddr,
                sizeof (PVOID),
                &Result))
                return FALSE;

            ExtAddr = (PKSPX_EXT)((PUCHAR)((CKsPin *)((PIKSPIN)ExtAddr)) + 
                FIELDOFFSET (CKsPin, m_Ext));

            break;

        }

    }

    //
    // We have some ext structure.  Now we need the device interface.
    //
    PIKSDEVICE DeviceIf;

    if (!ReadMemory (
        (DWORD)ExtAddr + FIELDOFFSET(KSPX_EXT, Device),
        &DeviceIf,
        sizeof (PIKSDEVICE),
        &Result)) {
        #ifdef DEBUG_EXTENSION
            dprintf ("%08lx: cannot read Ext's Device!\n", ExtAddr);
        #endif // DEBUG_EXTENSION
        return FALSE;
    }

    #ifdef DEBUG_EXTENSION
        dprintf ("DeviceIf = %08lx\n", DeviceIf);
    #endif // DEBUG_EXTENSION

    //
    // We have a device interface.  Now we need the address of the FDO.
    //
    PDEVICE_OBJECT *FDOAddr;
    PDEVICE_OBJECT FDO;

    FDOAddr = (PDEVICE_OBJECT *)((PUCHAR)((CKsDevice *)DeviceIf) + 
        FIELDOFFSET (CKsDevice, m_Ext) +
        FIELDOFFSET (KSDEVICE_EXT, Public) +
        FIELDOFFSET (KSDEVICE, FunctionalDeviceObject));

    if (!ReadMemory (
        (DWORD)FDOAddr,
        &FDO,
        sizeof (PDEVICE_OBJECT),
        &Result)) {
        #ifdef DEBUG_EXTENSION
            dprintf ("%08lx: cannot read FDO!\n", FDOAddr);
        #endif // DEBUG_EXTENSION
        return FALSE;
    }

    #ifdef DEBUG_EXTENSION
        dprintf ("FDO = %08lx\n", FDO);
    #endif // DEBUG_EXTENSION
        
    //
    // We have to read in the driver object from the FDO
    //
    PDRIVER_OBJECT DriverObject;

    if (!ReadMemory (
        (DWORD)FDO + FIELDOFFSET (DEVICE_OBJECT, DriverObject),
        &DriverObject,
        sizeof (PDRIVER_OBJECT),
        &Result)) {
        #ifdef DEBUG_EXTENSION
            dprintf ("%08lx: Cannot read FDO's driver object!\n", FDO);
        #endif // DEBUG_EXTENSION
        return FALSE;
    }

    #ifdef DEBUG_EXTENSION
        dprintf ("DriverObject = %08lx\n", DriverObject);
    #endif // DEBUG_EXTENSION

    //
    // Read in the string
    //
    UNICODE_STRING Name;

    if (!ReadMemory (
        (DWORD)DriverObject + FIELDOFFSET (DRIVER_OBJECT, DriverName),
        &Name,
        sizeof (UNICODE_STRING),
        &Result)) {
        #ifdef DEBUG_EXTENSION
            dprintf ("%08lx: Cannot read driver object's name!\n", 
                DriverObject);
        #endif // DEBUG_EXTENSION
        return FALSE;
    }

    #ifdef DEBUG_EXTENSION
        dprintf ("Read String!\n");
    #endif // DEBUG_EXTENSION

    PWSTR Buffer = (PWSTR)malloc (Name.MaximumLength * sizeof (WCHAR));

    #ifdef DEBUG_EXTENSION
        dprintf ("Allocated %ld bytes for buffer @ %08lx\n",
            Name.MaximumLength * sizeof (WCHAR), Buffer
            );
    #endif // DEBUG_EXTENSION

    if (Buffer) {

        #ifdef DEBUG_EXTENSION
            dprintf ("About to read memory %08lx, %08lx, %08lx, %08lx\n",
                Name.Buffer, Buffer, sizeof (WCHAR) * Name.MaximumLength,
                Result);
        #endif // DEBUG_EXTENSION

        if (!ReadMemory (
            (DWORD)Name.Buffer,
            Buffer,
            sizeof (WCHAR) * Name.MaximumLength,
            &Result
            )) {
            #ifdef DEBUG_EXTENSION
                dprintf ("%08lx: Cannot read name!\n", Name.Buffer);
            #endif // DEBUG_EXTENSION
            free (Buffer);
            return FALSE;
        }

        #ifdef DEBUG_EXTENSION
            dprintf ("Name.Length = %ld, Name.MaximumLength = %ld\n",
                Name.Length, Name.MaximumLength
                );

            HexDump (Buffer, (ULONG)Name.Buffer, 
                Name.MaximumLength * sizeof (WCHAR));

        #endif // DEBUG_EXTENSION

        Name.Buffer = Buffer;

        dprintf ("[%wZ]", &Name);

        free (Buffer);

    }

    #ifdef DEBUG_EXTENSION
        dprintf ("END OWNING DRIVER!\n");
    #endif // DEBUG_EXTENSION

    return TRUE;

}

char *States [] = {
    "STOP",
    "ACQUIRE",
    "PAUSE",
    "RUN"
};

/*************************************************

    Function:

        DisplayNodeAssociatedInfo

    Description:

        Display associated information with the node at a particular level.

    Arguments:

        TabDepth -
            The tab depth to display information at

        DumpLevel -
            The dump level to dump at

        Node -
            The node in question

*************************************************/

void
DisplayNodeAssociatedInfo (
    IN ULONG TabDepth,
    IN ULONG DumpLevel,
    IN POBJECT_NODE Node
    )

{

    ULONG Result;

    if (DumpLevel >= DUMPLVL_SPECIFIC && 
        Node -> ObjectNoun != NOUN_IDX_FILTER)
        dprintf ("%sParent Filter: %08lx\n", Tab (TabDepth), Node -> Filter);

    switch (Node -> ObjectNoun) {
        //
        // For a queue, we will display in/out state r/w/c
        //
        case NOUN_IDX_QUEUE:
        {
            CMemoryBlock <CKsQueue> QueueObject;

            if (!ReadMemory (
                (DWORD)Node -> Object,
                QueueObject.Get (),
                sizeof (CKsQueue),
                &Result)) {

                dprintf ("%08lx: unable to read queue!\n", Node -> Object);
                return;
            }

            if (DumpLevel >= DUMPLVL_SPECIFIC) {

                dprintf ("%s", Tab (TabDepth));

                if (QueueObject -> m_InputData) {
                    if (QueueObject -> m_OutputData)
                        dprintf ("in/out ");
                    else
                        dprintf ("in ");
                } else if (QueueObject -> m_OutputData) 
                    dprintf ("out ");

                dprintf ("%s ", States [QueueObject -> m_State]);

                dprintf ("r/w/c=%ld/%ld/%ld\n",
                    QueueObject -> m_FramesReceived,
                    QueueObject -> m_FramesWaiting,
                    QueueObject -> m_FramesCancelled
                    );

            }

            break;

        }
                
        //
        // For a pin, we will display state s/d/sy
        //
        case NOUN_IDX_PIN:
        {
            CMemoryBlock <CKsPin> PinObject;

            if (!ReadMemory (
                (DWORD)Node -> Object,
                PinObject.Get (),
                sizeof (CKsPin),
                &Result)) {

                dprintf ("%08lx: unable to read pin!\n", Node -> Object);
                return;
            }

            if (DumpLevel >= DUMPLVL_SPECIFIC) {
            
                dprintf ("%s%s s/d/sy=%ld/%ld/%ld\n", Tab (TabDepth),
                    States [PinObject -> m_Ext.Public.DeviceState],
                    PinObject -> m_StreamingIrpsSourced,
                    PinObject -> m_StreamingIrpsDispatched,
                    PinObject -> m_StreamingIrpsRoutedSynchronously
                    );

            }

            break;

        }

        //
        // For a requestor, we will display state size, count, active
        //
        case NOUN_IDX_REQUESTOR:
        {
            CMemoryBlock <CKsRequestor> RequestorObject;

            if (!ReadMemory (
                (DWORD)Node -> Object,
                RequestorObject.Get (),
                sizeof (CKsPin),
                &Result)) {

                dprintf ("%08lx: unable to read requestor!\n", Node -> Object);
                return;
            }

            if (DumpLevel >= DUMPLVL_SPECIFIC) {

                dprintf ("%s%s size=%ld count=%ld active=%ld\n",
                    Tab (TabDepth),
                    States [RequestorObject -> m_State],
                    RequestorObject -> m_FrameSize,
                    RequestorObject -> m_FrameCount,
                    RequestorObject -> m_ActiveFrameCountPlusOne - 1
                    );

            }

        }

        default:
            break;
    }

}

/*************************************************

    Function:

        DisplayAndCleanLiveObjects

    Description:

        Display any live objects as determined by the node list.  Clean
        up the memory used by the node list

    Arguments:

        LiveContext -
            The context information (containing the node list)

    Return Value:

        Number of live objects.

*************************************************/

ULONG
DisplayAndCleanLiveObjects (
    IN PLIVE_OBJECT_CONTEXT LiveContext
    )

{

    ULONG LivingCount = 0;
    PLIST_ENTRY Link, NextLink;

    for (Link = LiveContext -> ObjectNodes.Flink;
         Link != &(LiveContext -> ObjectNodes);
         Link = NextLink) {

        POBJECT_NODE Node = (POBJECT_NODE)CONTAINING_RECORD (
           Link, OBJECT_NODE, ListEntry
           );

        NextLink = Link -> Flink;

        if (Node -> NodeType == NodeCreation &&
            Node -> ObjectNoun == LiveContext -> ObjectNoun) {

            //
            // OPTIMIZATION RULE:
            //
            // Because of certain logging inadequacies, this rule helps to
            // eliminate bogus hits.  If we haven't found the parent and
            // the creation of the Irp node referenced a destruct node for
            // another component, ignore this object.
            //
            // NOTE: This only happens for Irp searches.  The frees will happen
            // in a second pass across the lists, so don't worry about the
            // continue.
            //
            if (LiveContext -> ObjectNoun == NOUN_IDX_IRP &&
                Node -> CreationReferencedDestruction)
                continue;

            LivingCount++;

            dprintf ("%s", Tab (LiveContext -> TabDepth));
            
            //
            // This shouldn't happen, but if the create isn't locked, it's
            // only a possible live.
            //
            // NOTE: due to a logging error in pre-Whistler ks.sys, this
            // can happen.  Filter destructions aren't logged which means
            // filters can come back bogus.  if WHISTLER is not defined,
            // filter nodes aren't locked ever.
            //
            if (!Node -> Locked)
                dprintf ("Possible ");

            dprintf ("Live %s %08lx ",
                NounNames [Node -> ObjectNoun],
                Node -> Object
                );
            
            //
            // Find the owning driver and display it.  Note that this may
            // fail for non-locked nodes....  but the extension SHOULD handle
            // that case.
            //
            if (Node -> ObjectNoun != NOUN_IDX_IRP)  {
                if (!DisplayOwningDriver (Node -> Object, Node -> ObjectNoun)) {
                    dprintf ("[unknown - POSSIBLY BOGUS!]");
                }
            }
            //
            // For Irps, we want to display the parent object and
            // the driver of the parent object.
            //
            else {
                if (Node -> ParentNode) {
                    dprintf ("in %s %08lx at ",
                        NounNames [Node -> ParentNode -> ObjectNoun],
                        Node -> ParentNode -> Object
                        );

                    if (!DisplayOwningDriver (Node -> ParentNode -> Object,
                        Node -> ParentNode -> ObjectNoun)) {
                        dprintf ("[unknown - POSSIBLY BOGUS!]");
                    }

                } else 
                    dprintf ("unknown parent!");
            }

            dprintf ("\n");

            //
            // If internal information is warranted, dump it.
            //
            if (LiveContext -> DumpLevel >= DUMPLVL_SPECIFIC) {
                if (Node -> ObjectNoun != NOUN_IDX_IRP)
                    DisplayNodeAssociatedInfo (LiveContext -> TabDepth + 1, 
                        LiveContext -> DumpLevel, Node);
                else {
                    if (Node -> ParentNode) {
                        dprintf ("%sParent %s information:\n",
                            Tab (LiveContext -> TabDepth + 1), 
                            NounNames [Node -> ParentNode -> ObjectNoun]
                            );
                        DisplayNodeAssociatedInfo (LiveContext -> TabDepth + 2,
                            LiveContext -> DumpLevel, Node -> ParentNode
                            );
                    }
                }
            }
        }

        //
        // We can't free nodes yet for Irps.  We must preserve parental
        // chains.  We'll make a second pass for Irp finding.
        //
        if (LiveContext -> ObjectNoun != NOUN_IDX_IRP)
            free (Node);

    }

    //
    // If we were searching for Irps, we had to preserve all nodes during
    // the first pass...  reason being that we have to know the parent node;
    // therefore, it cannot have been freed.
    //
    // In this case, we make a second pass across the node list and free 
    // everything.
    // 
    if (LiveContext -> ObjectNoun == NOUN_IDX_IRP) 
        for (Link = LiveContext -> ObjectNodes.Flink;
             Link != &(LiveContext -> ObjectNodes);
             Link = NextLink) {
    
            POBJECT_NODE Node = (POBJECT_NODE)CONTAINING_RECORD (
               Link, OBJECT_NODE, ListEntry
               );
    
            NextLink = Link -> Flink;

            free (Node);
        }

    return LivingCount;

}

/*************************************************

    Function:

        InsertNodeList

    Description:

        Insert a node into the node list in sorted order.  TODO: Make this
        hash!

    Arguments:

        List -
            The node list

        Node -
            The node to insert

    Return Value:

        None

*************************************************/

void
InsertNodeList (
    IN PLIST_ENTRY List,
    IN POBJECT_NODE Node
    )

{

    PLIST_ENTRY Searcher;
    PLIST_ENTRY NextSearcher;

    for (Searcher = List -> Flink;
         Searcher != List;
         Searcher = NextSearcher) {

        POBJECT_NODE NodeSought;

        NextSearcher = Searcher -> Flink;

        NodeSought = (POBJECT_NODE)CONTAINING_RECORD (
           Searcher, OBJECT_NODE, ListEntry
           );

        //
        // The list is kept in sorted order.  TODO: Hash this!
        //
        if (NodeSought -> Object > Node -> Object) {
            //
            // If there's an entry that's greater...  It means that we
            // can insert immediately before this entry and return.
            //
            InsertTailList (&(NodeSought -> ListEntry),
                &(Node -> ListEntry)
                );

            return;
        }

        if (NodeSought -> Object == Node -> Object) {
            dprintf ("ERROR: Duplicate node found in extension!  "
                "Inform component owner!\n");
            return;
        }
    }

    //
    // There is no greater.  Insert it at the tail of the list.
    //
    InsertTailList (List, &(Node -> ListEntry));

}

/*************************************************

    Function:

        FindNodeList

    Description:

        Find an object in the node list.  TODO: Make this hash!

    Arguments:

        List - 
            The node list

        Object -
            The object to find

    Return Value:

        The appropriate node or NULL if not found.

*************************************************/

POBJECT_NODE 
FindNodeList (
    IN PLIST_ENTRY List,
    IN PVOID Object
    )

{

    PLIST_ENTRY Searcher;
    PLIST_ENTRY NextSearcher;
    POBJECT_NODE Node;

    for (Searcher = List -> Flink;
         Searcher != List;
         Searcher = NextSearcher) {

        POBJECT_NODE Node;

        NextSearcher = Searcher -> Flink;

        Node = (POBJECT_NODE)CONTAINING_RECORD (
           Searcher, OBJECT_NODE, ListEntry
           );

        //
        // The list is kept in sorted order.  TODO: Hash this!
        //
        if (Node -> Object > Object)
            break;

        if (Node -> Object == Object)
            return Node;
    }

    return NULL;

}

/*************************************************

    Function:

        SearchForRequestor

    Description:

        Callback from the circuit walker to find a requestor.
        Since requestors aren't anywhere in the log, this is one
        way to find them.  I suppose the other would be digging
        through pipe sections.

    Arguments:

        Context -
            The live object context

        Type -
            The object type

        Base -
            The requestor's base address

        Object -
            The requestor data

    Return Value:

        FALSE (keep searching)

*************************************************/

BOOLEAN
SearchForRequestor (
    IN PVOID Context,
    IN INTERNAL_OBJECT_TYPE Type,
    IN DWORD Base,
    IN PVOID Object
    )

{

    POBJECT_NODE Node;
    PLIVE_OBJECT_CONTEXT LiveContext = (PLIVE_OBJECT_CONTEXT)Context;
    ULONG Result;

    if (Type != ObjectTypeCKsRequestor)
        return FALSE;

    //
    // Aha, we've found a requestor.  If such node doesn't already exist,
    // create one and lock it down.
    //
    Node = FindNodeList (&LiveContext -> ObjectNodes, (PVOID)Base);
    if (!Node) {

        CKsRequestor *RequestorObject = (CKsRequestor *)Object;

        //
        // We need the parent filter.  This means that we need to dig it up.
        //
        CKsPin *Pin = (CKsPin *)RequestorObject -> m_Pin;
        PKSFILTER_EXT FilterExt;

        if (!ReadMemory (
            (DWORD)Pin + FIELDOFFSET (CKsPin, m_Ext) +
                FIELDOFFSET (KSPIN_EXT, Parent),
            &FilterExt,
            sizeof (PKSFILTER_EXT),
            &Result)) {

            dprintf ("%08lx: Cannot read pin's parent filter!\n", Pin);
            return FALSE;
        }

        CKsFilter *Filter = (CKsFilter *)CONTAINING_RECORD (
            FilterExt, CKsFilter, m_Ext
            );

        Node = (POBJECT_NODE)malloc (sizeof (OBJECT_NODE));
        Node -> Object = (PVOID)Base;
        Node -> Filter = Node -> Pin = NULL;
        Node -> ObjectNoun = NOUN_IDX_REQUESTOR;
        Node -> NodeType = NodeCreation;
        Node -> Locked = TRUE;
        Node -> Sink = TRUE;
        Node -> Received = FALSE;
        Node -> PassedCreate = FALSE;
        Node -> CreationReferencedDestruction = FALSE;
        Node -> ParentNode = FALSE;
        Node -> CreatorNode = FALSE;
        Node -> Pin = (PVOID)Pin;
        Node -> Filter = (PVOID)Filter;

        InsertNodeList (&LiveContext -> ObjectNodes, Node);

    }

    return FALSE;

}
    
/*************************************************

    Function:

        FindLiveObject

    Description:

        Callback from the log iterator.  This is used to find live objects
        of a particular type.

    Arguments:

        Context -
            The live object context

        Entry -
            The entry we're iterating

    Notes:

        This routine is large and complex.  It probably could and should
        be simplified.  One of the major difficulties is that ks does not
        log movement of Irps through requestors and does not log certain
        object creations/destructions.  This means that I have to make 
        educated guesses about the Irp.  Hopefully, these are adequate.

*************************************************/

BOOLEAN
FindLiveObject (
    IN PVOID Context,
    IN PKSLOG_ENTRY Entry
    )

{

    PLIVE_OBJECT_CONTEXT LiveContext = (PLIVE_OBJECT_CONTEXT)Context;

    ULONG Noun = (Entry -> Code & KSLOGCODE_NOUN_MASK);
    ULONG Verb = (Entry -> Code & KSLOGCODE_VERB_MASK);
    ULONG PreviousVerb;

    PVOID Object, Irp;
    PVOID PreviousObject;
    NODE_TYPE ObjectNodeType;

    PLIST_ENTRY Searcher, NextSearcher;
    POBJECT_NODE Node;
    ULONG ObjectNoun;

    #ifdef DEBUG_EXTENSION
        dprintf ("[%s]Considering %s %08lx search is %s\n",
            VerbNames [Verb >> 16],
            NounNames [Noun >> 24], Entry -> Context.Component, 
            NounNames [LiveContext -> ObjectNoun]);
    #endif // DEBUG_EXTENSION

    //
    // Set previous information.
    //
    PreviousObject = LiveContext -> PreviousObject;
    PreviousVerb = LiveContext -> PreviousVerb;
    LiveContext -> PreviousObject = (PVOID)Entry -> Context.Component;
    LiveContext -> PreviousVerb = Verb;

    //
    // If the noun directly references the object we're talking about, the
    // component field should be what we want and the verbiage should
    // specify the type.
    //
    // If we're being asked to find live Irps, we must keep nodes for all
    // queues, pins, requestors (BUGBUG: splitters).  Note that we find only
    // streaming live Irps!
    //
    Irp = NULL;

    if (Noun >> 24 == LiveContext -> ObjectNoun ||
        (LiveContext -> ObjectNoun == NOUN_IDX_IRP &&
            (Noun == KSLOGCODE_NOUN_QUEUE ||
            Noun == KSLOGCODE_NOUN_REQUESTOR ||
            Noun == KSLOGCODE_NOUN_PIN)
            ) ||
        (LiveContext -> ObjectNoun == NOUN_IDX_REQUESTOR &&
            (Noun == KSLOGCODE_NOUN_QUEUE ||
            Noun == KSLOGCODE_NOUN_PIN)
            ) 
        ) {

        Object = (PVOID)Entry -> Context.Component;
        ObjectNoun = Noun >> 24;

        if (LiveContext -> ObjectNoun == NOUN_IDX_IRP && 
            (Verb == KSLOGCODE_VERB_RECV || Verb == KSLOGCODE_VERB_SEND)) {
            Irp = (PIRP)Entry -> Irp;
            
            #ifdef DEBUG_EXTENSION
                dprintf ("Considering potential Irp %08lx\n", Irp);
            #endif // DEBUG_EXTENSION

        }

        switch (Verb) {
            
            case KSLOGCODE_VERB_CREATE:
            case KSLOGCODE_VERB_RECV:
            case KSLOGCODE_VERB_SEND:
                ObjectNodeType = NodeCreation;
                break;

            case KSLOGCODE_VERB_DESTROY:
                ObjectNodeType = NodeDestruction;
                break;
    
            default:
                return FALSE;
        }
    } else {
        //
        // If we're not referring to the object in question, we may be
        // referring to it indirectly.
        //
        // This can only happen for pins and filters.  If it's not a pin
        // or filter, ignore it.
        //
        switch (LiveContext -> ObjectNoun) {
            case NOUN_IDX_FILTER:

                if (Entry -> Context.Filter) {
                    Object = (PVOID)Entry -> Context.Filter;

                    #ifdef DEBUG_EXTENSION
                        dprintf ("Considering indirect filter %08lx\n",
                            Object);
                    #endif // DEBUG_EXTENSION

                    //
                    // This is always creation.  The only way it'd be a
                    // destruction is if it were a filter.  In that case,
                    // the noun would match the search creterion and we'd
                    // not be in the else clause.
                    //
                    ObjectNodeType = NodeCreation;
                    ObjectNoun = NOUN_IDX_FILTER;
                }
                else
                    return FALSE;

                break;

            case NOUN_IDX_PIN:

                if (Entry -> Context.Pin) {
                    Object = (PVOID)Entry -> Context.Pin;

                    #ifdef DEBUG_EXTENSION
                        dprintf ("Considering indirect pin %08lx\n",
                            Object);
                    #endif // DEBUG_EXTENSION

                    //
                    // This is always creation.  The only way it'd be a
                    // destruction is if it were a pin.  In that case,
                    // the noun would match the search criterion and we'd
                    // not be in the else clause.
                    //
                    ObjectNodeType = NodeCreation;
                    ObjectNoun = NOUN_IDX_PIN;
                }
                else
                    return FALSE;

            default:

                return FALSE;
        }
    }

    //
    // Find out if this is a code we're interested in
    //
    switch (ObjectNodeType) {

        case NodeCreation:
            //
            // As far as we're concerned, creation, receiving, sending
            // all mean the same thing...  they all mean that the object
            // exists as of this timeslice.
            //

            //
            // If there's a destruction in the node list above this, the
            // object is gone...  Wipe the destruction node and continue
            //
            Node = FindNodeList (&LiveContext -> ObjectNodes, Object);

            if (Node) {
    
                //
                // Only a create can pop a destruct!  Multiple sends and
                // receives will just bail out.
                //
                if (Node -> NodeType == NodeDestruction &&
                    !Node -> Locked &&
                    Verb == KSLOGCODE_VERB_CREATE) {
    
                    #ifdef DEBUG_EXTENSION
                        dprintf ("[%08lx %08lx]Popping node for %08lx, "
                            "destruction above!\n", 
                            Noun, Verb,
                            Node -> Object
                        );
                    #endif // DEBUG_EXTENSION
    
                    RemoveEntryList (&(Node -> ListEntry));
    
                    free (Node);
    
                }
                else {
                    if (Verb == KSLOGCODE_VERB_CREATE &&
                        (PVOID)Entry -> Context.Component == Object)  {

                        #ifdef DEBUG_EXTENSION
                            dprintf ("Node for %s %08lx passed create!\n",
                                NounNames [Node -> ObjectNoun],
                                Node -> Object
                                );
                        #endif // DEBUG_EXTENSION

                        Node -> PassedCreate = TRUE;
                    }
                }

                //
                // We ignore multiple recv/send/create.  There's already
                // a node in the list corresponding to this object.
                //
                break;
            }

            //
            // If we found a matching node, we won't be here : we'll either
            // have popped the node and returned or done nothing and returned.
            // If we hit this, there is no creation node...  meaning that
            // there was no destruct above us.  Make a create node and 
            // lock it down.  This is a guaranteed live object.
            //
            #ifdef DEBUG_EXTENSION
                dprintf ("[%08lx %08lx]Pushing node for %s %08lx, locked "
                    "create!\n",
                    Noun, Verb,
                    NounNames [ObjectNoun],
                    Object
                    );
            #endif // DEBUG_EXTENSION

            Node = (POBJECT_NODE)malloc (sizeof (OBJECT_NODE));
            Node -> Object = (PVOID)Object;
            Node -> ObjectNoun = ObjectNoun;
            Node -> ParentNode = NULL;
            Node -> Received = FALSE;
            Node -> Filter = (PVOID)Entry -> Context.Filter;
            Node -> Pin = (PVOID)Entry -> Context.Pin;

            if (Verb == KSLOGCODE_VERB_CREATE &&
                (PVOID)Entry -> Context.Component == Object) {

                #ifdef DEBUG_EXTENSION
                    dprintf ("Node for %s %08lx passed create on node create!"
                        "\n",
                        NounNames [Node -> ObjectNoun],
                        Node -> Object
                        );
                #endif // DEBUG_EXTENSION 

                Node -> PassedCreate = TRUE;
            } else
                Node -> PassedCreate = FALSE;

            //
            // ks.sys prior to Whistler does not log filter creation and
            // destruction (it does every other object).  Any filters reported
            // are only possible on that.  Do NOT lock the entry.
            //
            #ifndef WHISTLER
                if (ObjectNoun == NOUN_IDX_FILTER)
                    Node -> Locked = FALSE;
                else
            #endif // WHISTLER
                    Node -> Locked = TRUE;

            Node -> NodeType = NodeCreation;
            
            if (Node -> ObjectNoun == NOUN_IDX_REQUESTOR)
                Node -> Sink = TRUE;
            else if (Node -> ObjectNoun == NOUN_IDX_PIN) {
                if (Node -> Locked) 
                    Node -> Sink = IsSinkPin ((CKsPin *)Object);
                else 
                    Node -> Sink = FALSE;
            } else
                Node -> Sink = FALSE;

            InsertNodeList (&LiveContext -> ObjectNodes, Node);

            //
            // Since ks doesn't log requestor creation, if we're looking
            // for live requestors, we're going to start walking circuits
            // if we just locked a pin or a queue.
            //
            if (LiveContext -> ObjectNoun == NOUN_IDX_REQUESTOR &&
                (Node -> ObjectNoun == NOUN_IDX_PIN ||
                Node -> ObjectNoun == NOUN_IDX_QUEUE) &&
                Node -> Locked) {

                WalkCircuit (
                    Node -> Object,
                    SearchForRequestor,
                    LiveContext
                    );
            }

            break;
            
        case NodeDestruction:

            //
            // We push a destroy if there's not already a node representing
            // this object.  The node musn't be locked; if a create node
            // is below a destruct node, the destruct node gets popped.
            //
            Node = FindNodeList (&LiveContext -> ObjectNodes, Object);

            if (!Node) {

                #ifdef DEBUG_EXTENSION
                    dprintf ("[%08lx %08lx]Pushing node for %s %08lx, unlocked"
                        " destruct!\n",
                        Noun, Verb,
                        NounNames [ObjectNoun],
                        Object
                        );
                #endif // DEBUG_EXTENSION

                Node = (POBJECT_NODE)malloc (sizeof (OBJECT_NODE));
                Node -> Object = Object;
                Node -> ObjectNoun = ObjectNoun;
                Node -> Sink = FALSE;
                Node -> ParentNode = NULL;
                Node -> PassedCreate = FALSE;
                Node -> Locked = FALSE;
                Node -> NodeType = NodeDestruction;
                Node -> Received = FALSE;
                Node -> Filter = (PVOID)Entry -> Context.Filter;
                Node -> Pin = (PVOID)Entry -> Context.Pin;
                
                InsertNodeList (&LiveContext -> ObjectNodes, Node);
            } 
            else {
                #ifdef DEBUG
                    dprintf ("On destruct push, found existing node for %s "
                        "%08lx (type = %ld)\n",
                        NounNames [Node -> ObjectNoun], Node -> Object,
                        Node -> NodeType
                        );
                #endif // DEBUG

            }

            break;

        default:

            break;
    }

    //
    // If we're hunting Irps, this is where we have to deal with them.  Irps
    // require special care.
    //
    if (LiveContext -> ObjectNoun == NOUN_IDX_IRP &&
        Irp != NULL) {

        //
        // MUSTCHECK: Not sure on the necessity of this!
        //
        POBJECT_NODE CurrentNode = FindNodeList (&LiveContext -> ObjectNodes,
            (PVOID)Entry -> Context.Component);

        if (!CurrentNode) {
            dprintf ("SERIOUS ERROR: Can't find component node!\n");
            return FALSE;
        }

        #ifdef DEBUG_EXTENSION
            if (CurrentNode != Node) dprintf ("DEV NOTE: nodes !=\n");

            dprintf ("For Irp %08lx, CompNode.Object = %08lx, Type = %ld\n", 
                Irp, CurrentNode -> Object, CurrentNode -> NodeType);
        #endif // DEBUG_EXTENSION

        //
        // If we're sinking the Irp, mark a destruct node
        //
        if (CurrentNode -> Sink &&
            Verb == KSLOGCODE_VERB_RECV) {

            POBJECT_NODE IrpNode;

            #ifdef DEBUG_EXTENSION
                dprintf ("Sinking Irp %08lx to parent %s %08lx\n",
                    Irp, NounNames [CurrentNode -> ObjectNoun],
                    CurrentNode -> Object);
            #endif // DEBUG_EXTENSION

            IrpNode = FindNodeList (&LiveContext -> ObjectNodes, (PVOID)Irp);
            if (!IrpNode) {
                //
                // If there's no node, and we're sinking the Irp, we need
                // a destruct node on the list.
                //
                IrpNode = (POBJECT_NODE)malloc (sizeof (OBJECT_NODE));
                IrpNode -> Object = (PVOID)Irp;
                IrpNode -> Locked = FALSE;
                IrpNode -> NodeType = NodeDestruction;
                IrpNode -> Sink = FALSE;
                IrpNode -> ObjectNoun = NOUN_IDX_IRP;
                IrpNode -> Received = TRUE;
                IrpNode -> CreatorNode = CurrentNode;

                //
                // We don't care about this information for destruct nodes.
                //
                IrpNode -> ParentNode = NULL;
                IrpNode -> CreationReferencedDestruction = FALSE;
                IrpNode -> PassedCreate = FALSE;

                //
                // Irp nodes...  we don't really care about this information.
                // The parent we might...  the Irp, we don't.
                //
                IrpNode -> Filter = NULL;
                IrpNode -> Pin = NULL;

                InsertNodeList (&LiveContext -> ObjectNodes, IrpNode);

            }
            else {
                //
                // If we're sinking to an object which has just "sent" the
                // Irp, this usually indicates Irp completion.  Mark the
                // Irp as a destruct node, not a create node.
                //
                if (IrpNode -> CreatorNode -> Received == FALSE &&
                    (PreviousObject == IrpNode -> CreatorNode -> Object &&
                     PreviousVerb == KSLOGCODE_VERB_SEND)
                   ) 
                   IrpNode -> NodeType = NodeDestruction;
            }

        } else {
            //
            // This may as well be a create.  The Irp is live as far as
            // we know as long as there's no destruct stacked above us.
            //
            // BUGBUG: The Irp destruct must get popped at the source...
            // This is not likely to cause problems except on reuse of memory
            // in some possible circumstances?
            //
            POBJECT_NODE IrpNode;

            IrpNode = FindNodeList (&LiveContext -> ObjectNodes, (PVOID)Irp);
            if (!IrpNode) {
                //
                // If there's no node, we can lock down the Irp as live.
                //
                IrpNode = (POBJECT_NODE)malloc (sizeof (OBJECT_NODE));
                IrpNode -> Object = (PVOID)Irp;

                //
                // Requestors don't log Irp receipt and transmission.
                //
                #ifdef WHISTLER
                    IrpNode -> Locked = TRUE;
                #else  // WHISTLER
                    IrpNode -> Locked = FALSE;
                #endif // WHISTLER

                IrpNode -> NodeType = NodeCreation;
                IrpNode -> Sink = FALSE;
                IrpNode -> ObjectNoun = NOUN_IDX_IRP;

                //
                // Irp nodes...  we don't really care about this information.
                // The parent we might...  the Irp, we don't.
                //
                IrpNode -> Filter = NULL;
                IrpNode -> Pin = NULL;
                IrpNode -> PassedCreate = NULL;

                if (CurrentNode -> NodeType == NodeDestruction ||
                    (CurrentNode -> NodeType == NodeCreation &&
                     CurrentNode -> PassedCreate))
                    IrpNode -> CreationReferencedDestruction = TRUE;
                else
                    IrpNode -> CreationReferencedDestruction = FALSE;

                IrpNode -> CreatorNode = CurrentNode;

                if (Verb == KSLOGCODE_VERB_RECV) {
                    IrpNode -> ParentNode = CurrentNode;
                    IrpNode -> Received = TRUE;
                }
                else {
                    IrpNode -> ParentNode = NULL;
                    IrpNode -> Received = FALSE;
                }

                #ifdef DEBUG_EXTENSION
                    dprintf ("Locking in Irp %08lx to parent %s %08lx\n",
                        Irp, IrpNode -> ParentNode ? 
                            NounNames [IrpNode -> ParentNode -> ObjectNoun] :
                            "NONE",
                        IrpNode -> ParentNode ?
                            IrpNode -> ParentNode -> Object :
                            NULL
                        );

                    dprintf ("    current node %s %08lx pc=%ld\n",
                        NounNames [CurrentNode -> ObjectNoun],
                        CurrentNode -> Object,
                        CurrentNode -> PassedCreate);

                #endif // DEBUG_EXTENSION

                InsertNodeList (&LiveContext -> ObjectNodes, IrpNode);

            } else {

                //
                // Multiple creates are ignored.  Only worry if there's a
                // destruct node around.  If this is the source and a destruct
                // node exists, pop it.
                //
                if (IrpNode -> NodeType == NodeDestruction) {

                    #ifdef DEBUG_EXTENSION
                        dprintf ("Irp %08lx hit with destruct stacked!\n",
                            Irp);
                    #endif // DEBUG_EXTENSION

                    //
                    // BUGBUG: If this is the source of the Irp, we must
                    // pop the destruct node here.
                    //
                } else {

                    #ifdef DEBUG_EXTENSION
                        dprintf ("Irp %08lx receives multiple create!\n",
                            Irp);
                    #endif // DEBUG_EXTENSION 

                    //
                    // If we haven't found the parent node yet, mark it now.
                    // The parent node will be the location that the Irp
                    // is currently at as far as this circuit is concerned.
                    //
                    if (IrpNode -> ParentNode == NULL &&
                        Verb == KSLOGCODE_VERB_RECV) {

                        IrpNode -> ParentNode = CurrentNode;

                        //
                        // Because ks.sys didn't originally log Irp movement
                        // through requestors, we can never determine when
                        // a sourced Irp is sinked back to the requestor.
                        // Istead, we make a very simple rule to deal with
                        // such cases.  If, when we find the parent node,
                        // the Irp node was created on a send, and the parent
                        // node is dead, mark the Irp dead.  This may leave
                        // out some weird shutdown case, but it will catch
                        // the majority of bogus Irps reported live.  Note
                        // that if we don't dump enough to find the parent
                        // node, the Irp gets reported anyway.
                        //
                        if (IrpNode -> Received == FALSE &&
                            CurrentNode -> NodeType == NodeDestruction ||
                            (CurrentNode -> NodeType == NodeCreation &&
                             CurrentNode -> PassedCreate)) 
                            //
                            // The sink was missing from the log.  Sink the
                            // Irp.
                            //
                            IrpNode -> NodeType = NodeDestruction;
                    }
                }
            }
        }
    }

    return FALSE;

}

/*************************************************

    Function:

        DumpLogEntry

    Description:

        Dump a particular log entry

    Arguments:

        Context -
            Context information for the dump (tab depth)

        Entry -
            The log entry to dump

    Return Value:

        Continuation indication (TRUE == stop)

*************************************************/

BOOLEAN
DumpLogEntry (
    IN PVOID Context,
    IN PKSLOG_ENTRY Entry
    )

{

    ULONG TabDepth = (ULONG)Context;

    dprintf ("%s", Tab (TabDepth));

    //
    // Check for special codes first.
    //
    if (Entry -> Code == 0 ||
        Entry -> Code == 1) {

        switch (Entry -> Code) {
            case 0:
                dprintf ("Text ");
                break;

            case 1:
                dprintf ("Start ");
                break;

        }
		
    } else {
        
        ULONG Verb;
        ULONG Noun;

        //
        // Each default entry has a noun and a verb associated with it
        // Display it gramatically as NOUN VERB.
        //
        Verb = (Entry -> Code & 0x00ff0000) >> 16;
        Noun = (Entry -> Code & 0xff000000) >> 24;

        if (Noun >= SIZEOF_ARRAY (NounNames))
            dprintf ("User Defined ");
        else
            dprintf ("%s ", NounNames [Noun]);

        if (Verb >= SIZEOF_ARRAY (VerbNames))
            dprintf ("User Defined ");
        else
            dprintf ("%s ", VerbNames [Verb]);

    }

    dprintf ("[Irp %08lx / Frame %08lx] @ %lx%08lx\n", 
        Entry -> Irp, Entry -> Frame,
        (ULONG)(Entry -> Time >> 32), (ULONG)(Entry -> Time & 0xFFFFFFFF));

    dprintf ("%s[Graph = %08lx, Filter = %08lx, Pin = %08lx, Component = "
        "%08lx\n\n", 
        Tab (TabDepth + 1),
        Entry -> Context.Graph,
        Entry -> Context.Filter,
        Entry -> Context.Pin,
        Entry -> Context.Component
        );

    //
    // Do not stop displaying!
    //
    return FALSE;

}

/*************************************************

    Function:

        IterateLogEntries

    Description:
        
        Iterate a specified number of log entries backwards in the log.  Note
        that this is rather complex for speed reasons.  It also makes the
        assumption that not many log entries have extended information.  If
        this assumption becomes bad at some later point in time, this needs
        to change.

        Further, if 1394 or faster interfaces begin to be used, this can
        go away and the entire log can be pulled across the link and parsed
        debugger side.

    Arguments:

        LogAddress -
            The target address of the logo
    
        LogSize -
            The size of the log in bytes

        Position -
            The position within the log that the next entry will be written
            to.  This may be an empty entry or the oldest entry about to
            be overwritten (or it may be in the middle of an entry depending
            on extended information tacked to entries).

        NumEntries -
            The number of entries to iterate through.  Zero indicates that
            we iterate the entire log.

        Callback -
            The iterator callback

        Context -
            The iterator callback context

    Return Value:

        The number of entries actually iterated.

*************************************************/

ULONG
IterateLogEntries (
    IN DWORD LogAddress,
    IN ULONG LogSize,
    IN ULONG Position,
    IN ULONG NumEntries,
    IN PFNLOG_ITERATOR_CALLBACK Callback,
    IN PVOID Context
    )

{

    ULONG IteratorCount = 0;
    BOOLEAN Complete = FALSE;
    BOOLEAN Wrap = FALSE;

    ULONG StartPosition = Position;

    //
    // BUGBUG:
    //
    // Yes, I don't support more than 1k entries...  No one in the universe
    // should be slapping entries larger than this anywhere.
    //
    UCHAR Buffer [1024];
    ULONG Result;
    PKSLOG_ENTRY LogEntry;

    //
    // Iterate while we're not up to the specified number of entries or
    // we've hit the start of the log.
    //
    while (
        ((!NumEntries) ||
        (NumEntries && (IteratorCount < NumEntries))) &&
        !Complete &&
        !CheckControlC()
        ) {

        ULONG Size;
        ULONG EntryPos;

        //
        // Guess the size of the previous log entry.  This makes the
        // implicit assumption that no information is tacked on the entry.
        // It will correct for the entry if there is such information, but
        // note that this SLLLOOOOWWWW in that case.
        //
        Size = (sizeof (KSLOG_ENTRY) + sizeof (ULONG) + FILE_QUAD_ALIGNMENT) 
            & ~FILE_QUAD_ALIGNMENT;

        if (Size > Position) {
            //
            // We've hit a wrap around.  Attempt to pull the entry from 
            // the other end of the log.
            //
            EntryPos = LogSize - Size;
            Wrap = TRUE;

        } else
            //
            // In the non wrap around case, just subtract off the size.
            //
            EntryPos = Position - Size;

        //
        // If there's a memory read error, bail out of the entire iterator.
        //
        if (!ReadMemory (
            (DWORD)(LogAddress + EntryPos),
            Buffer,
            Size,
            &Result)) 
            return NumEntries;

        LogEntry = (PKSLOG_ENTRY)Buffer;

        //
        // Check for additional information. 
        //
        // BUGBUG: Right now, this does **NOT** handle extended entries!
        //
        if (LogEntry -> Size < sizeof (KSLOG_ENTRY) ||
            LogEntry -> Size != *(PULONG)(Buffer + Size - sizeof (ULONG))) {

            //
            // BUGBUG: EXTENDED INFORMATION ENTRIES....
            //
            // We've either wrapped around to the end of the log or hit
            // an extended information entry.  Right now, I don't deal with
            // extended information entries because no one uses them.  Thus,
            // I assume it's the end of the log.
            //
            return IteratorCount;
        }

        //
        // Otherwise, we can feel safe displaying the information.
        //
        IteratorCount++;
        if (Callback (Context, LogEntry))
            Complete = TRUE;

        Position = EntryPos;

        //
        // If we've gotten back to where we started, we're done.  Also, we
        // need to check for wrapping and below where we started in case
        // the last entries are extended.
        //
        if (Position == StartPosition ||
            (Wrap && Position < StartPosition))
            Complete = TRUE;

    }

    return IteratorCount;

}

/*************************************************

    Function:

        InitLog

    Description:

        Initialize logging information.  Pass back key log pointers. 
        Return FALSE if not debug ks.sys or the log is invalid.

    Arguments:

        LogAddress -
            Log address will be deposited here on return TRUE

        LogSize -
            Log size will be deposited here on return TRUE

        LogPosition -
            Log position pointer will be deposited here on return TRUE

    Return Value:

        TRUE - 
            successful initialization

        FALSE -
            unsuccessful initialization (non debug ks.sys)

*************************************************/

BOOLEAN
InitLog (
    IN PVOID *LogAddress,
    IN PULONG LogSize,
    IN PULONG LogPosition
    )

{

    PVOID TargetLogAddress, TargetPositionAddress, TargetSizeAddress;
    ULONG Result;

    TargetLogAddress = (PVOID)GetExpression("ks!KsLog");
    TargetPositionAddress = (PVOID)GetExpression("ks!KsLogPosition");
    TargetSizeAddress = (PVOID)GetExpression("ks!KsLogSize");

    if (TargetLogAddress == 0 || TargetPositionAddress == 0 ||
        TargetSizeAddress == 0) {

        dprintf ("Cannot access the log; ensure you are running debug"
            " ks.sys!\n");
        return FALSE;
    }

    if (!ReadMemory (
        (DWORD)TargetLogAddress,
        (PVOID)LogAddress,
        sizeof (PVOID),
        &Result)) {

        dprintf ("%08lx: cannot read log!\n", TargetLogAddress);
        return FALSE;
    }

    if (!ReadMemory (
        (DWORD)TargetPositionAddress,
        (PVOID)LogPosition,
        sizeof (ULONG),
        &Result)) {

        dprintf ("%08lx: cannot read target position!\n", 
            TargetPositionAddress);
        return FALSE;
    }

    if (!ReadMemory (
        (DWORD)TargetSizeAddress,
        (PVOID)LogSize,
        sizeof (ULONG),
        &Result)) {

        dprintf ("%08lx: cannot read log size!\n",
            TargetSizeAddress);
        return FALSE;
    }

    return TRUE;

}

/**************************************************************************

    LOG API

**************************************************************************/

/*************************************************

    Function:

        findlive

    Usage:

        !ks.findlive Queue/Requestor/Pin/Filter/Irp [<# of objects>] [<level>]

    Description:

        Find all live objects of the specified type and print information
        about them.

*************************************************/

DECLARE_API(findlive) {

    char objName[256], lvlStr[256], numStr[256], *pLvl, *pNum;
    ULONG NumEntries, DumpLevel;
    ULONG i;
    PVOID LogAddress;
    ULONG TargetPosition, LogSize;
    LIVE_OBJECT_CONTEXT LiveContext;
    
    GlobInit();

    sscanf (args, "%s %s %s", objName, numStr, lvlStr);

    if (numStr && numStr [0]) {
        pNum = numStr; while (*pNum && !isdigit (*pNum)) pNum++;

        #ifdef DEBUG_EXTENSION
            dprintf ("pNum = [%s]\n", pNum);
        #endif // DEBUG_EXTENSION

        if (*pNum) {
            sscanf (pNum, "%lx", &NumEntries);
        } else {
            NumEntries = 0;
        }
    } else {
        NumEntries = 0;
    }

    if (lvlStr && lvlStr [0]) {
        pLvl = lvlStr; while (*pLvl && !isdigit (*pLvl)) pLvl++;

        #ifdef DEBUG_EXTENSION
            dprintf ("pLvl = [%s]\n", pLvl);
        #endif // DEBUG_EXTENSION

        if (*pLvl) {
            sscanf (pLvl, "%lx", &DumpLevel);
        } else {
            DumpLevel = 1;
        }
    } else {
        DumpLevel = 1;
    }

    for (i = 0; i < SIZEOF_ARRAY (NounNames); i++) 
        if (!ustrcmp (NounNames [i], objName))
            break;

    if (i >= SIZEOF_ARRAY (NounNames)) {
        dprintf ("Usage: !ks.findlive Queue|Requestor|Pin|Filter [<# entries>]"
            "\n\n");
        return;
    }

    LiveContext.ObjectNoun = i;
    LiveContext.DumpLevel = DumpLevel;
    LiveContext.PreviousObject = NULL;
    LiveContext.PreviousVerb = 0;
    InitializeListHead (&LiveContext.ObjectNodes);

    #ifndef WHISTLER
        if (LiveContext.ObjectNoun == NOUN_IDX_FILTER) {
            dprintf ("******************** READ THIS NOW ********************\n");
            dprintf ("ks.sys prior to Whistler will not log filter creation and\n");
            dprintf ("destruction.  This means that any filters reported are potentially\n");
            dprintf ("bogus.  !pool the filter to check.\n");
            dprintf ("******************** READ THIS NOW ********************\n\n");
        }
        if (LiveContext.ObjectNoun == NOUN_IDX_IRP) {
            dprintf ("******************** READ THIS NOW ********************\n");
            dprintf ("ks.sys prior to Whistler will not log Irp movement in and out\n");
            dprintf ("of requestors.  This leads the Irp dump to believe such Irps\n");
            dprintf ("are still live (meaning some Irps may be bogus!).  Check the\n");
            dprintf ("irps with !irp and/or !pool.\n");
            dprintf ("******************** READ THIS NOW ********************\n\n");
        }
    #endif // WHISTLER

    if (InitLog (&LogAddress, &LogSize, &TargetPosition)) {
        IterateLogEntries (
            (DWORD)LogAddress,
            LogSize,
            TargetPosition,
            NumEntries,
            FindLiveObject,
            &LiveContext
            );

        dprintf ("%sLive %s Objects:\n", Tab (INITIAL_TAB), NounNames [i]);
        LiveContext.TabDepth = INITIAL_TAB + 1;

        //
        // The above has only built the node list.  We now need to display
        // information that's on the node list and clean up memory used by
        // it.
        //
        if (i = DisplayAndCleanLiveObjects (&LiveContext)) 
            dprintf ("\n%s%ld total objects found.\n", 
                Tab (LiveContext.TabDepth),
                i);
        else
            dprintf ("\n%sNo such objects found.\n", 
                Tab (LiveContext.TabDepth));
    }

}

/*************************************************

    Function:

        dumplog

    Usage:

        !ks.dumplog [<# of entries>]

*************************************************/

DECLARE_API(dumplog) {

    ULONG NumEntries;
    PVOID LogAddress;
    ULONG TargetPosition, LogSize;
    ULONG Result;

    GlobInit();

    NumEntries = GetExpression (args);

    if (InitLog (&LogAddress, &LogSize, &TargetPosition)) 
        IterateLogEntries (
            (DWORD)LogAddress,
            LogSize,
            TargetPosition,
            NumEntries,
            DumpLogEntry,
            (PVOID)INITIAL_TAB
            );

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\ksfilter\ks\memphis\makefile.inc ===
!IF 0

Copyright (C) Microsoft Corporation, 1997 - 1998

Module Name:

    makefile.inc.

!ENDIF

!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\ksfilter\ks\kdexts\kskdx.c ===
/*++

Copyright (C) Microsoft Corporation, 1993 - 1997

Module Name:

    kskdx.c	


Abstract:

    This file contains the generic routines and initialization code
    for the kernel debugger extension dll for ks / AVStream

Author:


Environment:

    User Mode

--*/

#ifndef __KDEXT_ONLY__
#define __KDEXT_ONLY__
#endif // __KDEXT_ONLY__

#include "kskdx.h"

/**************************************************************************

    GLOBALS

**************************************************************************/

EXT_API_VERSION         ApiVersion = { 3, 5, EXT_API_VERSION_NUMBER, 0 };
WINDBG_EXTENSION_APIS   ExtensionApis;
USHORT                  SavedMajorVersion;
USHORT                  SavedMinorVersion;

PSTR    ApiDescriptions[] =
{
    "\nKS / AVStream Debugging Extension [AVStream extensions]\n\n",

    "help:\n",
    "     Displays this help screen\n\n",

    "kshelp:\n",
    "     Displays the commands available from the original Ks debug extension.\n\n",

    "automation <object>:\n",
    "     Dump any automation items associated with the given object.  The object\n",
    "     can be any one of the following: PKSPIN, PISFILTER, CKsPin*, CKsFilter*.\n",
    "     Automation item consist of properties, methods, and events.\n",
    "     Note that you can also use this on an Irp to find out property\n",
    "     information and handlers for automation Irps.\n\n",

    "dump <object> [<level>]:\n",
    "     Dump the given AVStream object.  This can be any valid client viewable\n",
    "     structure or any valid AVStream class object.  This can also be an Irp\n",
    "     or file object (in which case the associated AVStream object is dumped).\n\n",

    "dumpbag <object> [<level>]:\n",
    "     Dump the contents of the specified object's bag.  Object can be any valid\n",
    "     client viewable object structure or the private class object.\n\n",

    "dumpcircuit <object> [<level>]:\n",
    "     Dump the transport circuit associated with the given object.  Object can\n",
    "     be any one of the following: CKsPin*, CKsQueue*, CKsRequestor*,\n",
    "     CKsSplitter*, CKsSplitterBranch*.  Note that this starts walking the\n",
    "     circuit at the specified object; this is not necessarily the data source.\n\n",

    "dumplog [<# of entries>]:\n",
    "     Dump Ks's internal debug log.  Display up to # of entries.  If this\n",
    "     number is 0 or unspecified, the entire log is dumped.  This requires\n",
    "     debug ks.sys!\n\n"

    "dumpqueue <object> [<level>]:\n",
    "     Dump AVStream queue(s) associated with a given object.  Object can\n",

    "     be any of the following: PKSPIN, PKSFILTER, CKsPin*, CKsFilter*, CKsQueue*\n\n",

    "enumdevobj <WDM device object>:\n",
    "     Locate the AVStream device object associated with this WDM device object\n",
    "     and enumerate filter types and currently instantiated filters associated\n",
    "     with it  You must pass a device object which is for an AVStrema device!.\n\n",

    "enumdrvobj <WDM driver object>:\n",
    "     Locate the AVStream device object associated with this WDM driver object\n",
    "     and enumerate filter types and currently instantiated filters associated\n",
    "     with it.  You must pass a driver object which is an AVStream driver!\n\n"

    "forcedump <object> <type> [<level]:\n",
    "     Force a dump of the given AVStream object as a class object of the type\n",
    "     specified by type (CKsPin, CKsFilter, etc...)  No checking is performed\n",
    "     This is literally a totally dumb forced dump.\n\n",

    "findlive <type> [<# of entries>] [<level>]:\n",
    "     Search # of entries through the log attempting to find any live objects\n",
    "     of the specified type.  Type can be one of Queue, Requestor, Pin,\n",
    "     Filter, or Irp.  If # of entries is 0 or unspecified, the entire log is\n",
    "     searched.  Note that this does not guarantee to find all possible\n",
    "     specified live objects!\n\n"


};

PSTR KsHelpDescriptions[] = 
{
    "\nKS / AVStream Debugging Extension [KS 1.0 extensions]\n\n",
    "kshelp:\n",
    "     Displays this help screen\n\n",
    "help:\n",
    "     Displays the extension commands available for AVStream.\n\n",
    "shdr <PKSSTREAM_HEADER>:\n",
    "     Dump the contents of a stream header.  The object passed must currently\n",
    "     be a PKSSTREAM_HEADER.\n\n",
    "dhdr <KSDEVICE_HEADER>:\n",
    "     Dump the contents of a device header.  The object passed must currently\n",
    "     be a KSDEVICE_HEADER.\n\n",
    "ohdr <KSOBJECT_HEADER>:\n",
    "     Dump the contents of an object header.  The object passed must currently\n",
    "     be a KSOBJECT_HEADER.\n\n",
    "devhdr <PDEVICE_OBJECT>:\n",
    "     Dump the contents of the device header associated with the specified WDM\n",
    "     device object.\n\n",
    "objhdr <PFILE_OBJECT>:\n",
    "     Dump the contents of the object header associated with the specified file\n",
    "     object.\n\n"
};

#define MAX_APIS (SIZEOF_ARRAY( ApiDescriptions ) - 1)
#define KSMAX_APIS (SIZEOF_ARRAY( KsHelpDescriptions) - 1)

/**************************************************************************

    Extension Common Routines

**************************************************************************/

//
// THESE ARE NEEDED FOR THE KDEXT DLLs
//
BOOLEAN
DllInit(
    HANDLE hModule,
    DWORD  dwReason,
    DWORD  dwReserved
    )
{
    switch (dwReason) {
        case DLL_THREAD_ATTACH:
            DbgBreakPoint();
            break;

        case DLL_THREAD_DETACH:
            break;

        case DLL_PROCESS_DETACH:
            break;

        case DLL_PROCESS_ATTACH:
            break;
    }

    return TRUE;
}


//
// THESE ARE NEEDED FOR THE KDEXT DLLs
//
VOID
WinDbgExtensionDllInit(
    PWINDBG_EXTENSION_APIS lpExtensionApis,
    USHORT MajorVersion,
    USHORT MinorVersion
    )
{
    ExtensionApis = *lpExtensionApis;

    SavedMajorVersion = MajorVersion;
    SavedMinorVersion = MinorVersion;

    return;
}

//
// THESE ARE NEEDED FOR THE KDEXT DLLs
//
DECLARE_API( version )
{
#if DBG
    PCHAR DebuggerType = "Checked";
#else
    PCHAR DebuggerType = "Free";
#endif

    dprintf( "%s Extension dll for Build %d debugging %s kernel for Build %d\n",
             DebuggerType,
             VER_PRODUCTBUILD,
             SavedMajorVersion == 0x0c ? "Checked" : "Free",
             SavedMinorVersion
           );
}

//
// THESE ARE NEEDED FOR THE KDEXT DLLs
//
VOID
CheckVersion(
    VOID
    )
{
#if DBG
    if ((SavedMajorVersion != 0x0c) || (SavedMinorVersion != VER_PRODUCTBUILD)) {
        dprintf("\r\n*** Extension DLL(%d Checked) does not match target system(%d %s)\r\n\r\n",
                VER_PRODUCTBUILD, SavedMinorVersion, (SavedMajorVersion==0x0f) ? "Free" : "Checked" );
    }
#else
    if ((SavedMajorVersion != 0x0f) || (SavedMinorVersion != VER_PRODUCTBUILD)) {
        dprintf("\r\n*** Extension DLL(%d Free) does not match target system(%d %s)\r\n\r\n",
                VER_PRODUCTBUILD, SavedMinorVersion, (SavedMajorVersion==0x0f) ? "Free" : "Checked" );
    }
#endif
}

LPEXT_API_VERSION
ExtensionApiVersion(
    VOID
    )
{
    return &ApiVersion;
}

/*************************************************

    Function:

        ustrcmp

    Description:

        Case insensitive strcmp

*************************************************/

int
ustrcmp (
    char *a,
    char *b
    )

{

    int dif;

    while (!(dif = (toupper (*a) - toupper (*b++))) && *a++);
    return dif;

}

/*************************************************

    Function:

        Evaluator

    Description:

        Given a string, return the address evaluation

    Arguments:

        StringEval -
            The string to evaluate

*************************************************/

DWORD 
Evaluator (
    IN const char *StringEval
    )

{

    DWORD Addr = 0;

    Addr = GetExpression (StringEval);

    return Addr;

}

char g_TabString [513];
ULONG g_TabSize;

/*************************************************

    Function:

        GlobInit

    Description:

        Initialize global utilities

*************************************************/

void
GlobInit (
) {

    static BOOLEAN Init = FALSE;

    ULONG i;

    //
    // KD loads the extension DLL and keeps it loaded.  Each command
    // comes is just a GetProcAddress and call into the DLL.  We only need
    // to initialize once.
    //
    // RTERM on the other hand loads the extension DLL for each extension
    // DLL command used.  Therefore, each extension command needs to
    // initialize.
    //
    // This is the reason for the static Init.
    //
    if (!Init) {
        for (i = 0; i < 512; i++)
            g_TabString [i] = ' ';
        g_TabString [512] = 0;
    
        g_TabSize = TAB_SPACING;

        Init = TRUE;
    } 

}

/*************************************************

    Function:

        Tab

    Description:

        Return a pointer to a string tabbing the requesting
        number of tab markers.

    Arguments:

        Depth -
            The tab depth.

    Return Value:

        Pointer to a string of Depth * g_TabSize spaces

    Notes:
        
        This is a single threaded function only!

        This can only be used once in a given dprintf.  ie: You CANNOT do:
            dprintf ("%sfoo:\n%s", Tab (TabDepth), Tab (TabDepth + 1));

*************************************************/

char *
Tab (
    IN ULONG Depth
) {

    static ULONG OldPos = 0;

    if (Depth * g_TabSize > 512) 
        Depth = 512 / g_TabSize;

    g_TabString [OldPos] = ' ';
    g_TabString [Depth * g_TabSize] = 0;

    OldPos = Depth * g_TabSize;

    return g_TabString;

}


/**************************************************************************

    Help API

**************************************************************************/

DECLARE_API(help)
{
   UINT  c;

    if (0 == args[0]) {
        for (c = 0; c < MAX_APIS + 1; c++)
            dprintf( ApiDescriptions[ c ] );
        return;
    }
}

DECLARE_API(kshelp)
{
   UINT  c;

    if (0 == args[0]) {
        for (c = 0; c < KSMAX_APIS + 1; c++)
            dprintf( KsHelpDescriptions [ c ] );
        return;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\ksfilter\ks\test\makefile.inc ===
!IF 0

Copyright (C) Microsoft Corporation, 1998 - 1998

Module Name:

    makefile.inc.

!ENDIF

!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\ksfilter\ks\win98se\makefile.inc ===
!IF 0

Copyright (C) Microsoft Corporation, 1997 - 1998

Module Name:

    makefile.inc.

!ENDIF

!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\ksfilter\ks\millen\makefile.inc ===
!IF 0

Copyright (C) Microsoft Corporation, 1997 - 1998

Module Name:

    makefile.inc.

!ENDIF

!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\ksfilter\ks\test\ksmemtst.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1998
//
//  File:       ksmemtst.h
//
//--------------------------------------------------------------------------

PVOID 
KsiAllocatePool(
    IN POOL_TYPE PoolType,
    IN SIZE_T NumberOfBytes);
        
PVOID 
KsiAllocatePoolWithTag(
    IN POOL_TYPE PoolType,
    IN SIZE_T NumberOfBytes,
    IN ULONG Tag);
        
PVOID 
KsiAllocatePoolWithQuota(
    IN POOL_TYPE PoolType,
    IN SIZE_T NumberOfBytes);
        
PVOID 
KsiAllocatePoolWithQuotaTag(
    IN POOL_TYPE PoolType,
    IN SIZE_T NumberOfBytes,
    IN ULONG Tag);

#define KS_ALLOCATION_PASS_THROUGH          0
#define KS_ALLOCATION_FAIL_ALWAYS           1
#define KS_ALLOCATION_FAIL_PERIODICALLY     2
#define KS_ALLOCATION_FAIL_ON_TAG           3

KSDDKAPI
VOID
NTAPI
KsSetAllocationParameters(
    IN ULONG FailureType,
    IN ULONG TagValue,
    IN ULONG FailureCountRate);


#undef  ExAllocatePool
#define ExAllocatePool(a,b)                 KsiAllocatePool(a,b)

#undef  ExAllocatePoolWithTag
#define ExAllocatePoolWithTag(a,b,c)        KsiAllocatePoolWithTag(a,b,c)

#undef  ExAllocatePoolWithQuota
#define ExAllocatePoolWithQuota(a,b)        KsiAllocatePoolWithQuota(a,b)

#undef  ExAllocatePoolWithQuotaTag
#define ExAllocatePoolWithQuotaTag(a,b,c)   KsiAllocatePoolWithQuotaTag(a,b,c)
//#define ExAllocateFromNPagedLookasideList
//#define ExAllocateFromPagedLookasideList
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\ksfilter\ks\kdexts\strlib.c ===
/**************************************************************************

    This is the string library and guid library for the AVStream debug
    extension.

    NOTES:

        - This is hardly encompassing...  The few items I have placed here
          are common properties directly out of ks.h (via some vi macros).
         
        - If this turns out to be useful more than I think, a perl script
          can parse ksmedia.h for properties, methods, events, etc...

        - Dump handlers : don't have them...  don't use them...  consider
          this for future expansion if some items get hard to read...  You
          can add a handler which will dump the associated information
          as appropriate.

**************************************************************************/

#include "kskdx.h"
#include "ksmedia.h"

typedef struct _AUTOMATION_MAPPING {

    GUID Guid;
    char *Name;

    ULONG ItemMappingsCount;
    char **ItemMappingNames;

    AUTOMATION_DUMP_HANDLER *ItemDumpers;

} AUTOMATION_MAPPING, *PAUTOMATION_MAPPING;

char *PropertySetGeneralMappings[] = {
    "KSPROPERTY_GENERAL_COMPONENTID"
};

char *PropertySetMediaSeekingMappings[] = {
    "KSPROPERTY_MEDIASEEKING_CAPABILITIES",
    "KSPROPERTY_MEDIASEEKING_FORMATS",
    "KSPROPERTY_MEDIASEEKING_TIMEFORMAT",
    "KSPROPERTY_MEDIASEEKING_POSITION",
    "KSPROPERTY_MEDIASEEKING_STOPPOSITION",
    "KSPROPERTY_MEDIASEEKING_POSITIONS",
    "KSPROPERTY_MEDIASEEKING_DURATION",
    "KSPROPERTY_MEDIASEEKING_AVAILABLE",
    "KSPROPERTY_MEDIASEEKING_PREROLL",
    "KSPROPERTY_MEDIASEEKING_CONVERTTIMEFORMAT"
};

char *PropertySetTopologyMappings[] = {
    "KSPROPERTY_TOPOLOGY_CATEGORIES",
    "KSPROPERTY_TOPOLOGY_NODES",
    "KSPROPERTY_TOPOLOGY_CONNECTIONS",
    "KSPROPERTY_TOPOLOGY_NAME"
};

char *PropertySetGraphManagerMappings[] = {
    "KSPROPERTY_GM_GRAPHMANAGER", 
    "KSPROPERTY_GM_TIMESTAMP_CLOCK", 
    "KSPROPERTY_GM_RATEMATCH", 
    "KSPROPERTY_GM_RENDER_CLOCK"
};

char *PropertySetPinMappings[] = {
    "KSPROPERTY_PIN_CINSTANCES",
    "KSPROPERTY_PIN_CTYPES",
    "KSPROPERTY_PIN_DATAFLOW",
    "KSPROPERTY_PIN_DATARANGES",
    "KSPROPERTY_PIN_DATAINTERSECTION",
    "KSPROPERTY_PIN_INTERFACES",
    "KSPROPERTY_PIN_MEDIUMS",
    "KSPROPERTY_PIN_COMMUNICATION",
    "KSPROPERTY_PIN_GLOBALCINSTANCES",
    "KSPROPERTY_PIN_NECESSARYINSTANCES",
    "KSPROPERTY_PIN_PHYSICALCONNECTION",
    "KSPROPERTY_PIN_CATEGORY",
    "KSPROPERTY_PIN_NAME",
    "KSPROPERTY_PIN_CONSTRAINEDDATARANGES",
    "KSPROPERTY_PIN_PROPOSEDATAFORMAT"
};

char *PropertySetQualityMappings[] = {
    "KSPROPERTY_QUALITY_REPORT",
    "KSPROPERTY_QUALITY_ERROR"
};

char *PropertySetConnectionMappings[] = {
    "KSPROPERTY_CONNECTION_STATE",
    "KSPROPERTY_CONNECTION_PRIORITY",
    "KSPROPERTY_CONNECTION_DATAFORMAT",
    "KSPROPERTY_CONNECTION_ALLOCATORFRAMING",
    "KSPROPERTY_CONNECTION_PROPOSEDATAFORMAT",
    "KSPROPERTY_CONNECTION_ACQUIREORDERING",
    "KSPROPERTY_CONNECTION_ALLOCATORFRAMING_EX",
    "KSPROPERTY_CONNECTION_STARTAT"
};

char *PropertySetStreamAllocatorMappings[] = {
    "KSPROPERTY_STREAMALLOCATOR_FUNCTIONTABLE",
    "KSPROPERTY_STREAMALLOCATOR_STATUS"
};

char *PropertySetStreamInterfaceMappings[] = {
    "KSPROPERTY_STREAMINTERFACE_HEADERSIZE"
};

char *PropertySetStreamMappings[] = {
    "KSPROPERTY_STREAM_ALLOCATOR",
    "KSPROPERTY_STREAM_QUALITY",
    "KSPROPERTY_STREAM_DEGRADATION",
    "KSPROPERTY_STREAM_MASTERCLOCK",
    "KSPROPERTY_STREAM_TIMEFORMAT",
    "KSPROPERTY_STREAM_PRESENTATIONTIME",
    "KSPROPERTY_STREAM_PRESENTATIONEXTENT",
    "KSPROPERTY_STREAM_FRAMETIME",
    "KSPROPERTY_STREAM_RATECAPABILITY",
    "KSPROPERTY_STREAM_RATE",
    "KSPROPERTY_STREAM_PIPE_ID"
};

char *PropertySetClockMappings[] = {
    "KSPROPERTY_CLOCK_TIME",
    "KSPROPERTY_CLOCK_PHYSICALTIME",
    "KSPROPERTY_CLOCK_CORRELATEDTIME",
    "KSPROPERTY_CLOCK_CORRELATEDPHYSICALTIME",
    "KSPROPERTY_CLOCK_RESOLUTION",
    "KSPROPERTY_CLOCK_STATE",
    "KSPROPERTY_CLOCK_FUNCTIONTABLE"
};

AUTOMATION_MAPPING PropertyMappings[] = {

    // KSPROPSETID_General
    {
        STATIC_KSPROPSETID_General,
        "KSPROPSETID_General",
        SIZEOF_ARRAY (PropertySetGeneralMappings),
        PropertySetGeneralMappings,
        NULL
    },

    // KSPROPSETID_MediaSeeking
    {
        STATIC_KSPROPSETID_MediaSeeking,
        "KSPROPSETID_MediaSeeking",
        SIZEOF_ARRAY (PropertySetMediaSeekingMappings),
        PropertySetMediaSeekingMappings,
        NULL
    },

    // KSPROPSETID_Topology
    {
        STATIC_KSPROPSETID_Topology,
        "KSPROPSETID_Topology",
        SIZEOF_ARRAY (PropertySetTopologyMappings),
        PropertySetTopologyMappings,
        NULL
    },

    // KSPROPSETID_GM
    {
        STATIC_KSPROPSETID_GM,
        "KSPROPSETID_GM (graph management)",
        SIZEOF_ARRAY (PropertySetGraphManagerMappings),
        PropertySetGraphManagerMappings,
        NULL
    },

    // KSPROPSETID_Pin
    {
        STATIC_KSPROPSETID_Pin,
        "KSPROPSETID_Pin",
        SIZEOF_ARRAY (PropertySetPinMappings),
        PropertySetPinMappings,
        NULL
    },

    // KSPROPSETID_Quality
    {
        STATIC_KSPROPSETID_Quality,
        "KSPROPSETID_Quality",
        SIZEOF_ARRAY (PropertySetQualityMappings),
        PropertySetQualityMappings,
        NULL
    },

    // KSPROPSETID_Connection
    {
        STATIC_KSPROPSETID_Connection,
        "KSPROPSETID_Connection",
        SIZEOF_ARRAY (PropertySetConnectionMappings),
        PropertySetConnectionMappings,
        NULL
    },

    // KSPROPSETID_StreamAllocator
    {
        STATIC_KSPROPSETID_StreamAllocator,
        "KSPROPSETID_StreamAllocator",
        SIZEOF_ARRAY (PropertySetStreamAllocatorMappings),
        PropertySetStreamAllocatorMappings,
        NULL
    },

    // KSPROPSETID_StreamInterface
    {
        STATIC_KSPROPSETID_StreamInterface,
        "KSPROPSETID_StreamInterface",
        SIZEOF_ARRAY (PropertySetStreamInterfaceMappings),
        PropertySetStreamInterfaceMappings,
        NULL
    },

    // KSPROPSETID_Stream
    {
        STATIC_KSPROPSETID_Stream,
        "KSPROPSETID_Stream",
        SIZEOF_ARRAY (PropertySetStreamMappings),
        PropertySetStreamMappings,
        NULL
    },

    // KSPROPSETID_Clock
    {
        STATIC_KSPROPSETID_Clock,
        "KSPROPSETID_Clock",
        SIZEOF_ARRAY (PropertySetClockMappings),
        PropertySetClockMappings,
        NULL
    }
};

typedef struct _AUTOMATION_IDENT_TABLE {

    ULONG ItemsCount;
    PAUTOMATION_MAPPING Mapping;

    // ...

} AUTOMATION_IDENT_TABLE, *PAUTOMATION_IDENT_TABLE;

AUTOMATION_IDENT_TABLE AutomationIdentTables[] = {
    
    {
        SIZEOF_ARRAY (PropertyMappings),
        PropertyMappings
    }

};

/**************************************************************************

    Functions which use string information

**************************************************************************/

/*************************************************

    Function:

        DisplayNamedAutomationSet

    Description:

        Display an automation set guid by name.  The string inpassed will
        be used as format string.  It must contain one %s for string
        substitution (and no other %'s)

    Arguments:

        Set -
            The set guid to display a name for

        String -
            Format string

*************************************************/

BOOLEAN
DisplayNamedAutomationSet (
    IN GUID *Set,
    IN char *String
    )

{

    ULONG curTable, curItem;

    for (curTable = 0; curTable < SIZEOF_ARRAY (AutomationIdentTables);
        curTable++) {

        for (curItem = 0; curItem < AutomationIdentTables [curTable].
            ItemsCount; curItem++) {

            //
            // See if we have a set GUID match...
            //
            if (RtlCompareMemory (Set, &(AutomationIdentTables [curTable].
                Mapping[curItem].Guid), sizeof (GUID)) == sizeof (GUID)) {

                dprintf (String, AutomationIdentTables [curTable].
                    Mapping[curItem].Name);

                return TRUE;

            }
        }
    }

    return FALSE;
}

/*************************************************

    Function:

        DisplayNamedAutomationId

    Description:

        Display an automation id by name. 

    Arguments:

        Set -
            The set guid

        Item -
            The item in the set

        String - 
            The format string as in DisplayNamedAutomationSet

        DumpHandler -
            Optional pointer into which will be deposited any dump handler
            for the item in question.

*************************************************/

BOOLEAN
DisplayNamedAutomationId (
    IN GUID *Set,
    IN ULONG Id,
    IN char *String,
    IN OUT AUTOMATION_DUMP_HANDLER *DumpHandler OPTIONAL
    )

{

    ULONG curTable, curItem;

    if (DumpHandler)
        *DumpHandler = NULL;

    for (curTable = 0; curTable < SIZEOF_ARRAY (AutomationIdentTables);
        curTable++) {

        for (curItem = 0; curItem < AutomationIdentTables [curTable].
            ItemsCount; curItem++) {

            //
            // See if we have a set GUID match...
            //
            if (RtlCompareMemory (Set, &(AutomationIdentTables [curTable].
                Mapping[curItem].Guid), sizeof (GUID)) == sizeof (GUID)) {

                if (AutomationIdentTables [curTable].
                    Mapping[curItem].ItemMappingsCount > Id) {

                    dprintf (String, AutomationIdentTables [curTable].
                        Mapping[curItem].ItemMappingNames [Id]);

                    //
                    // Return the dumper information.
                    //
                    if (AutomationIdentTables [curTable].Mapping[curItem].
                        ItemDumpers && DumpHandler) {

                        *DumpHandler =
                            AutomationIdentTables [curTable].Mapping[curItem].
                                ItemDumpers[Id];

                    }

                }
                        

                return TRUE;

            }
        }
    }

    return FALSE;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\ksfilter\ksdsp\epd\cancl.c ===
/*++

    Copyright (c) 1998 Microsoft Corporation

Module Name:

    Cancl.c

Abstract:


Author:

--*/

#include "private.h"

VOID
EpdCancel
(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
)
{
    KIRQL Irql;
    PEPDCTL pEpdCtl;
    PEPDCTL pCancelEpdCtl;
    PEPDBUFFER EpdBuffer;
    PHOSTREQ_CANCEL pCancelData;

    // check this cancel irql in the case where EpdCancel is called explicitly.
    IoReleaseCancelSpinLock(Irp->CancelIrql);
    _DbgPrintF(DEBUGLVL_VERBOSE,("EpdCancel"));

    EpdBuffer = DeviceObject->DeviceExtension;

    // EpdCtl of irp to be cancelled
    pCancelEpdCtl = Irp->Tail.Overlay.DriverContext[0];

    // set up a control packet for the DSP
    pEpdCtl = EpdAllocEpdCtl(
        sizeof(HOSTREQ_CANCEL) + sizeof(EPDQUEUENODE) - sizeof(QUEUENODE),
        NULL, 
        EpdBuffer);
    if (pEpdCtl == NULL) 
    {
        _DbgPrintF(DEBUGLVL_VERBOSE,("EpdAllocEpdCtl failed in EpdCancel"));
        // this Irp is not going to get cancelled, nothing we can do.
        return;
    }

    pEpdCtl->RequestType = EPDCTL_CANCEL;
    pEpdCtl->pNode->VirtualAddress->ReturnQueue = 0;
    pEpdCtl->pNode->VirtualAddress->Request = HOSTREQ_TO_NODE_CANCEL;
    pEpdCtl->pNode->VirtualAddress->Result = 0;
    pEpdCtl->pNode->VirtualAddress->Destination = 
        pCancelEpdCtl->NodeDestination;

    pCancelData = (HOSTREQ_CANCEL *) pEpdCtl->pNode;
    pCancelData->pNodePhys = 
        (QUEUENODE *) pCancelEpdCtl->pNode->PhysicalAddress.LowPart;

    DspSendMessage( EpdBuffer, pEpdCtl->pNode, DSPMSG_OriginationHost );

    // nothing to complete, we're not an irp!

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\ksfilter\ksdsp\epd\filehndl.c ===
#include "private.h"

// all the file services are handled by the dedicated thread EpdDiskThread.

VOID
EpdDiskThread (
    PVOID Context
)
{
    PDEVICE_OBJECT DeviceObject;
    PEPDBUFFER EpdBuffer;
    LIST_ENTRY *pRequest;
    NTSTATUS Status;
    HANDLE FileHandle;
    QUEUENODE *pMessage;

    PEPDCTL pEpdCtl;

    DeviceObject = Context;
    EpdBuffer = DeviceObject->DeviceExtension;

    _DbgPrintF(DEBUGLVL_VERBOSE,("in the thread"));

    while(TRUE) 
    {
    // wait for a notice that there's something in the queue
    Status = KeWaitForSingleObject (
            &EpdBuffer->ThreadSemaphore, // IN PVOID  Object,
            Executive,               // IN KWAIT_REASON  WaitReason,
            KernelMode,              // IN KPROCESSOR_MODE  WaitMode,
            FALSE,                   // IN BOOLEAN  Alertable,
            NULL                     // IN PLARGE_INTEGER  Timeout /* optional */
         );
    while (pRequest = ExInterlockedRemoveHeadList(
                   &EpdBuffer->ListEntry, // IN PLIST_ENTRY  ListHead,
                   &EpdBuffer->ListSpinLock // IN PKSPIN_LOCK  Lock
              )) 
    {
        pEpdCtl = CONTAINING_RECORD (pRequest, EPDCTL, WorkItem.List);

        switch (pEpdCtl->RequestType) 
        {

        case EPDTHREAD_DSPREQ:
        // This is a request that originated on the dsp.  All the stuff we need is in the Message.
        pMessage = pEpdCtl->pDspNode;

        //
        // N.B.:
        // This EPDCTL structure is a special allocation, allocated by the DPC
        // for use by this thread.  It is not allocated from the I/O pool.
        //
        // Free up the control structure
        //
        
        ExFreePool (pEpdCtl);

        // Remember to send it back to originator
        // pMessage->Destination = pMessage->ReturnQueue;
        // NOTE: Don't have to do this- it's done by the DSP before sending the message.
        // Just remember not to write to the Destination or ReturnQueue params.

        switch (pMessage->Request) {

        case DSPMSG_Open:
            _DbgPrintF(DEBUGLVL_VERBOSE,("DSPMSG_Open"));
            EpdFileOpenFromMessage( EpdBuffer, pMessage );
            DspSendMessage( EpdBuffer, pMessage, DSPMSG_OriginationDSP );
            break;

        case DSPMSG_Close:
            _DbgPrintF(DEBUGLVL_VERBOSE,("DSPMSG_Close"));
            EpdFileCloseFromMessage( EpdBuffer, pMessage );
            DspSendMessage( EpdBuffer, pMessage, DSPMSG_OriginationDSP );
            break;

        case DSPMSG_Read:
            _DbgPrintF(DEBUGLVL_VERBOSE,("DSPMSG_Read"));
            EpdFileSeekAndReadFromMessage( EpdBuffer, pMessage);
            DspSendMessage( EpdBuffer, pMessage, DSPMSG_OriginationDSP );
            break;

        case DSPMSG_Write:
            _DbgPrintF(DEBUGLVL_VERBOSE,("DSPMSG_Write"));
            EpdFileSeekAndWriteFromMessage( EpdBuffer, pMessage);
            DspSendMessage( EpdBuffer, pMessage, DSPMSG_OriginationDSP );
            break;
            
        case DSPMSG_Seek:
            _DbgPrintF(DEBUGLVL_VERBOSE,("DSPMSG_Seek"));
            EpdFileSeekFromMessage( EpdBuffer, pMessage );
            DspSendMessage( EpdBuffer, pMessage, DSPMSG_OriginationDSP );
            break;

        case DSPMSG_FileLength:
            _DbgPrintF(DEBUGLVL_VERBOSE,("DSPMSG_FileLength"));
            EpdFileLengthFromMessage( EpdBuffer, pMessage );
            DspSendMessage( EpdBuffer, pMessage, DSPMSG_OriginationDSP );
            break;

        case DSPMSG_ExeSize:
            _DbgPrintF(DEBUGLVL_VERBOSE,("DSPMSG_ExeSize"));
            EpdExeSizeFromMessage( EpdBuffer, pMessage );
            DspSendMessage( EpdBuffer, pMessage, DSPMSG_OriginationDSP );
            break;

        case DSPMSG_ExeLoad:
            _DbgPrintF(DEBUGLVL_VERBOSE,("DSPMSG_ExeLoad"));
            EpdExeLoadFromMessage( EpdBuffer, pMessage );
            DspSendMessage( EpdBuffer, pMessage, DSPMSG_OriginationDSP );
            break;

        } // end switch on EPDTHREAD_DSPREQ RequestType
        break;

        case EPDTHREAD_KILL_THREAD:
        _DbgPrintF(DEBUGLVL_VERBOSE,("ready to terminate thread"));
        // this does not check the queue for other pending requests, just kills the thread
        ExFreePool(pEpdCtl);
        PsTerminateSystemThread (STATUS_SUCCESS);
        _DbgPrintF(DEBUGLVL_VERBOSE,("Shouldn't ever see this"));
        break;

        } // end switch

    } // end while remove item from list

    }// end infinite while loop
}

#if defined( _WIN64 )
ULONG32 
pMapHandle64to32( 
    IN PEPDBUFFER EpdBuffer,
    IN HANDLE Handle64
    )
{
    int         i, j;
    ULONG32     Handle32;
    
    //
    // N.B.: handle access is serialized by the thread.
    //
    
    for (i = 0; i < SIZEOF_ARRAY( EpdBuffer->HandleTableBitmap ); i++) {
        //
        // Scan for an empty slot
        //
        if (EpdBuffer->HandleTableBitmap[ i ] != (ULONG32) -1) {
            for (j = 0; j < 32; j++) {
                if (0 == (EpdBuffer->HandleTableBitmap[ i ] & (1 << j))) {
                    EpdBuffer->HandleTableBitmap[ i ] |= (1 << j);
                    Handle32 = (ULONG32) (i << 5) + j;
                    EpdBuffer->HandleTable64to32[ Handle32 ] = Handle64;
                    return Handle32;
                }
            }
        }
    }
    return (ULONG32) -1;    
}    
    
HANDLE 
pTranslateHandle32to64( 
    IN PEPDBUFFER EpdBuffer,
    IN ULONG32 Handle32
    )
{
    int i, j;
    
    i = Handle32 >> 5;
    j = Handle32 % 32;
    if ((Handle32 > (MAXLEN_TRANSLATION_TABLE - 1)) ||
        (0 == (EpdBuffer->HandleTableBitmap[ i ] & (1 << j)))) {
        return (HANDLE) -1;
    } else {
        return EpdBuffer->HandleTable64to32[ Handle32 ];
    }        
}    

VOID 
pUnmapHandle64to32( 
    IN PEPDBUFFER EpdBuffer,
    IN ULONG32 Handle32
    )
{
    int i, j;
    
    if (Handle32 < MAXLEN_TRANSLATION_TABLE) {
        i = Handle32 >> 5;
        j = Handle32 % 32;
        EpdBuffer->HandleTableBitmap[ i ] &= ~(1 << j);
    }        
}    

#endif    

NTSTATUS
EpdFileOpen (
    OUT HANDLE *pFileHandle,
    IN PUNICODE_STRING puniFileName,
    IN ULONG Flags
)
{
    // This code modified from example in ddk\src\general\zwcreate.

    OBJECT_ATTRIBUTES ObjectAttributes;
    IO_STATUS_BLOCK IoStatusBlock;
    NTSTATUS Status;

    ACCESS_MASK DesiredAccess;
    ULONG FileAttributes;
    ULONG CreateDisposition;
    ULONG fcreat, frdonly, frdwr, fwronly;

    // Parse out the flags using values from fcntl.h
    // We are interested in O_CREAT, O_RDONLY, O_RDWR, O_WRONLY
    // Always do binary, at least for now.

    fcreat = Flags & O_CREAT;
    frdonly = Flags & O_RDONLY;
    frdwr = Flags & O_RDWR;
    fwronly = Flags & O_WRONLY;

    DesiredAccess = SYNCHRONIZE;
    FileAttributes = FILE_ATTRIBUTE_NORMAL;

    if (fcreat) {
    CreateDisposition = FILE_OPEN_IF;
    }
    else {
    CreateDisposition = FILE_OPEN;
    }

    if (frdonly) {
    DesiredAccess |= GENERIC_READ;
    FileAttributes |= FILE_ATTRIBUTE_READONLY;
    }
    if (frdwr) {
    DesiredAccess |= GENERIC_ALL;
    }
    if (fwronly) {
    DesiredAccess |= GENERIC_WRITE;
    if (fcreat) {
        CreateDisposition = FILE_SUPERSEDE;
    }
    }

    InitializeObjectAttributes (
    &ObjectAttributes,    // output
    puniFileName,
    OBJ_CASE_INSENSITIVE, // IN ULONG  Attributes,
    NULL,                 // IN HANDLE  RootDirectory,
    NULL,                 // IN PSECURITY_DESCRIPTOR  SecurityDescriptor
    );

    Status = ZwCreateFile (
         pFileHandle,                  // OUT PHANDLE FileHandle,
         DesiredAccess,                // IN ACCESS_MASK DesiredAccess,
         &ObjectAttributes,            // IN POBJECT_ATTRIBUTES ObjectAttributes,
         &IoStatusBlock,               // OUT PIO_STATUS_BLOCK IoStatusBlock,
         NULL,                         // IN PLARGE_INTEGER AllocationSize,        /* optional */
         FileAttributes,               // IN ULONG FileAttributes,
         0L,                           // IN ULONG ShareAccess,  zero for exclusive access
         CreateDisposition,            // IN ULONG CreateDisposition
         FILE_SYNCHRONOUS_IO_NONALERT, // IN ULONG CreateOptions
         NULL,                         // IN PVOID  EaBuffer,                /* optional */
         0L                            // IN ULONG EaLength
         );
    if (!NT_SUCCESS (Status))
    {
    _DbgPrintF(DEBUGLVL_VERBOSE,("ZwCreateFile failed.  Look at status block"));
    }

    return Status;
}

/* Return the size of the file as an unsigned long */
ULONG 
EpdFileLength(
    HANDLE FileHandle
    )
{
    IO_STATUS_BLOCK IoStatusBlock;
    FILE_STANDARD_INFORMATION FileStdInfo;

    ZwQueryInformationFile(
        FileHandle,
    &IoStatusBlock,
    &FileStdInfo,
        sizeof(FileStdInfo),
        FileStandardInformation);

    return FileStdInfo.EndOfFile.LowPart;
}

/* Return the current position in the file as an unsigned long */
ULONG 
EpdFilePosition(
    HANDLE FileHandle
    )
{
    IO_STATUS_BLOCK IoStatusBlock;
    FILE_POSITION_INFORMATION FilePosInfo;

    ZwQueryInformationFile(
        FileHandle,
    &IoStatusBlock,
    &FilePosInfo,
        sizeof(FilePosInfo),
        FilePositionInformation);

    return FilePosInfo.CurrentByteOffset.LowPart;
}

/* Calculate the absolute offset to seek to */
ULONG EpdCalcSeekOffset(HANDLE File, LONG RelOffset, ULONG Origin)
{
    switch(Origin)
    {
    case SEEK_SET:
    return RelOffset;
    case SEEK_CUR:
    return EpdFilePosition(File) + RelOffset;
    case SEEK_END:
    return EpdFileLength(File) + RelOffset;
    }

    return 0;
};

NTSTATUS
EpdFileSeek(
    HANDLE File,
    LONG RelOffset,
    ULONG Origin,
    ULONG *pNewOffset
)
{
    PFILE_OBJECT FileObject;
    NTSTATUS Status;

    ULONG NewOffset;

    //
    // BUGBUG!  Need to synchronize access w/ other file routines HERE!
    //
    
    //
    // BUGBUG! Only 32-bit access here????
    //
    NewOffset = EpdCalcSeekOffset(File, RelOffset, Origin);
    
    Status =
        ObReferenceObjectByHandle( 
            File,
            0,
            *IoFileObjectType,
            KernelMode,
            (PVOID *)&FileObject,
            NULL );
    
    if (NT_SUCCESS( Status )) {
        FileObject->CurrentByteOffset.QuadPart = NewOffset;
        ObDereferenceObject( FileObject );
    }

    *pNewOffset = NewOffset;
    return Status;
}

NTSTATUS 
EpdFileSeekAndRead(
    HANDLE File, 
    LONG RelOffset, 
    ULONG Origin, 
    PVOID pBlock, 
    ULONG Size, 
    ULONG *pSizeAct
    )
{
    IO_STATUS_BLOCK IoStatusBlock;
    LARGE_INTEGER liOffset, *pliOffset;
    NTSTATUS Status;

    if ((RelOffset==0) && (Origin==SEEK_CUR)) {
        pliOffset = NULL;
    } else {
        liOffset.QuadPart = EpdCalcSeekOffset(File, RelOffset, Origin);
        pliOffset = &liOffset;
    }

    // Read the file!
    Status = ZwReadFile (
         File,  // File handle
         NULL,  // Event
         NULL,  // ApcRoutine
         NULL,  // ApcContext
         &IoStatusBlock,    // IoStatusBlock
         pBlock,            // Ptr to buffer
         Size,              // Size of data
         pliOffset,         // Offset of data
         NULL               // Key
         );

    *pSizeAct = (ULONG) IoStatusBlock.Information;
    return Status;
}

NTSTATUS 
EpdFileSeekAndWrite(
    HANDLE File, 
    LONG RelOffset, 
    ULONG Origin, 
    PVOID pBlock, 
    ULONG Size, 
    ULONG *pSizeAct
    )
{
    IO_STATUS_BLOCK IoStatusBlock;
    LARGE_INTEGER liOffset, *pliOffset;
    NTSTATUS Status;

    // _DbgPrintF(DEBUGLVL_VERBOSE,("EpdFileSeekAndWrite: File=0x%x, RelOffset = %d, Origin = %d, pBlock=0x%x, Size=0x%x",File,RelOffset, Origin, pBlock,Size));

    if ((RelOffset==0) && (Origin==SEEK_CUR)) {
        pliOffset = NULL;
    } else {
        liOffset.QuadPart = EpdCalcSeekOffset(File, RelOffset, Origin);
        pliOffset = &liOffset;
    }

    // Write to the file!
    Status = ZwWriteFile (
         File,  // File handle
         NULL,  // Event
         NULL,  // ApcRoutine
         NULL,  // ApcContext
         &IoStatusBlock,    // IoStatusBlock
         pBlock,            // Ptr to buffer
         Size,              // Size of data
         pliOffset,         // Offset of data
         NULL               // Key
         );

    *pSizeAct = (ULONG) IoStatusBlock.Information;
    return Status;
}

NTSTATUS
EpdFileOpenFromMessage(
    IN PEPDBUFFER EpdBuffer,
    IN OUT QUEUENODE *pMessage
    )
{
    QUEUENODE_OPEN *pMsgOpen;
    char* szFileName;
    UNICODE_STRING uniPath, uniFileName;
    NTSTATUS Status;

    HANDLE FileHandle;
    ULONG Flags;

    pMsgOpen=(QUEUENODE_OPEN *)pMessage;
    szFileName = pMsgOpen->FileName;
    _DbgPrintF(DEBUGLVL_VERBOSE,("EpdFileOpenFromMessage: Filename='%s'",szFileName));
    Status = EpdZeroTerminatedStringToUnicodeString (&uniFileName, szFileName, TRUE);
    Status = EpdAppendFileNameToTalismanDirName (&uniPath, &uniFileName);
    RtlFreeUnicodeString (&uniFileName);

    if (!NT_SUCCESS(Status)) {
        _DbgPrintF(DEBUGLVL_VERBOSE,("Fatal error uni"));
    }

    Flags = pMsgOpen->Flags;

    Status = EpdFileOpen (&FileHandle, &uniPath, Flags);

    // check status here
    RtlFreeUnicodeString (&uniPath);

    // fix up Message with answer to send back to the dsp
    if (!NT_SUCCESS (Status)) {
        pMsgOpen->Node.Result = (UINT32)-1;
    } else {
        pMsgOpen->Node.Result = MapHandle64to32( EpdBuffer, FileHandle );
    }
    return Status;
}

NTSTATUS
EpdFileCloseFromMessage(
    IN PEPDBUFFER EpdBuffer,
    IN OUT QUEUENODE *pMessage
    )
{
    HANDLE FileHandle;
    
    NTSTATUS Status;
    QUEUENODE_CLOSE *pMsgClose;
    pMsgClose = (QUEUENODE_CLOSE *)pMessage;
    FileHandle = TranslateHandle32to64( EpdBuffer, pMsgClose->FileDescriptor );
    UnmapHandle64to32( EpdBuffer, pMsgClose->FileDescriptor );
    Status = ZwClose( FileHandle );
    pMsgClose->Node.Result = Status;
    return Status;
}

NTSTATUS
EpdFileSeekFromMessage(
    IN PEPDBUFFER EpdBuffer,
    IN OUT QUEUENODE *pMessage
)
{
    QUEUENODE_SEEK *pMsgSeek;
    HANDLE FileHandle;
    LONG RelOffset;
    ULONG Origin;
    ULONG NewOffset;
    NTSTATUS Status;

    pMsgSeek = (QUEUENODE_SEEK *)pMessage;
    FileHandle = TranslateHandle32to64( EpdBuffer, pMsgSeek->FileDescriptor );
    RelOffset  = pMsgSeek->Offset;
    Origin     = pMsgSeek->Whence;

    Status = EpdFileSeek(FileHandle,RelOffset,Origin,&NewOffset);

    if (NT_SUCCESS(Status))
    {
    pMsgSeek->Node.Result =  NewOffset;
    // _DbgPrintF(DEBUGLVL_VERBOSE,("EpdFileSeekFromMessage: File=0x%x, RelOffset=%d, Origin=%x, AbsOffset=%x",FileHandle,RelOffset,Origin,NewOffset));
    }
    else
    {
    pMsgSeek->Node.Result = (UINT32)-1;
    _DbgPrintF(DEBUGLVL_VERBOSE,("Seek failed, Status = 0x%x, Offset Req = %d, Origin = %d",Status,RelOffset,Origin));
    }

    return Status;
}

NTSTATUS
EpdFileSeekAndReadFromMessage(
    IN PEPDBUFFER EpdBuffer,
    IN OUT QUEUENODE *pMessage
)
{
    QUEUENODE_SEEKREAD *pMsgSeekRead;
    HANDLE FileHandle;
    LONG RelOffset;
    ULONG Origin;
    PVOID Buffer;
    ULONG Size;
    ULONG SizeAct;
    NTSTATUS Status;
    ULONG Cksum;

    pMsgSeekRead = (QUEUENODE_SEEKREAD *)pMessage;
    FileHandle = TranslateHandle32to64( EpdBuffer, pMsgSeekRead->FileDescriptor );
    RelOffset  = pMsgSeekRead->Offset;
    Origin     = pMsgSeekRead->Whence;
    Buffer    = DspToHostMemAddress( EpdBuffer, pMsgSeekRead->Buf);
    Size       = pMsgSeekRead->Size;

    Status = EpdFileSeekAndRead(FileHandle, RelOffset, Origin, Buffer, Size, &SizeAct);
    if (NT_SUCCESS(Status))
    {
    pMsgSeekRead->Node.Result = SizeAct;
    }
    else
    {
    pMsgSeekRead->Node.Result = (UINT32)-1;
    _DbgPrintF(DEBUGLVL_VERBOSE,("EpdFileSeekAndReadFromMessage: Read failed, Status = 0x%x, Size Req = %d, Size Act = %d",Status,Size,SizeAct));
    }

    return Status;
}

NTSTATUS
EpdFileSeekAndWriteFromMessage(
    IN PEPDBUFFER EpdBuffer,
    IN OUT QUEUENODE *pMessage
)
{
    QUEUENODE_SEEKWRITE *pMsgSeekWrite;
    HANDLE FileHandle;
    LONG RelOffset;
    ULONG Origin;
    PVOID Buffer;
    ULONG Size;
    ULONG SizeAct;
    NTSTATUS Status;

    pMsgSeekWrite = (QUEUENODE_SEEKWRITE *)pMessage;
    FileHandle = TranslateHandle32to64( EpdBuffer, pMsgSeekWrite->FileDescriptor );
    RelOffset  = pMsgSeekWrite->Offset;
    Origin     = pMsgSeekWrite->Whence;
    Buffer    = DspToHostMemAddress(EpdBuffer, pMsgSeekWrite->Buf);
    Size       = pMsgSeekWrite->Size;

    Status = EpdFileSeekAndWrite(FileHandle, RelOffset, Origin, Buffer, Size, &SizeAct);
    if (NT_SUCCESS(Status))
    {
    pMsgSeekWrite->Node.Result = SizeAct;
    }
    else
    {
    pMsgSeekWrite->Node.Result = (UINT32)-1;
    _DbgPrintF(DEBUGLVL_VERBOSE,("Write failed, Status = 0x%x, Size Req = %d, Size Act = %d",Status,Size,SizeAct));
    }

    return Status;
}

NTSTATUS
EpdFileLengthFromMessage(
    IN PEPDBUFFER EpdBuffer,
    IN OUT QUEUENODE *pMessage
)
{
    QUEUENODE_FILELENGTH *pMsgFileLength;
    pMsgFileLength = (QUEUENODE_FILELENGTH *)pMessage;
    pMsgFileLength->Node.Result = 
        EpdFileLength( TranslateHandle32to64( EpdBuffer, pMsgFileLength->FileDescriptor ) );
    return STATUS_SUCCESS;
}

NTSTATUS
EpdExeSizeFromMessage(
    IN PEPDBUFFER EpdBuffer,
    IN OUT QUEUENODE *pMessage
)
{
    char                   *szFileName;
    NTSTATUS               Status;
    QUEUENODE_EXESIZELOAD  *pMsgExeSize;
    PVOID                  ImageBase;
    UNICODE_STRING         FileName, ImageName;
    ULONG                  ExeSize, ValueType;
    ULONG_PTR              ResourceId;

    pMsgExeSize=(QUEUENODE_EXESIZELOAD *)pMessage;
    szFileName = pMsgExeSize->FileName;
    _DbgPrintF(DEBUGLVL_VERBOSE,("EpdExeSizeFromMessage: Filename='%s'",szFileName));
    Status = EpdZeroTerminatedStringToUnicodeString( &FileName, szFileName, TRUE);

    if (!NT_SUCCESS(Status)) {
        _DbgPrintF(DEBUGLVL_VERBOSE,("Fatal error uni"));
        return Status;
    }

    ImageBase = NULL;

    Status =
        KsMapModuleName(
            EpdBuffer->PhysicalDeviceObject,
            &FileName,
            &ImageName,
            &ResourceId,
            &ValueType );

    if (NT_SUCCESS( Status )) {
        PVOID  FileBase;

        _DbgPrintF( DEBUGLVL_VERBOSE, ("mapped module: %S", ImageName.Buffer) );
        if (NT_SUCCESS( Status = LifeLdrLoadFile( &ImageName, &FileBase )  )) {
            Status = 
                KsLoadResource( 
                    FileBase, PagedPool, ResourceId, RT_RCDATA, &ImageBase, NULL );
            ExFreePool( FileBase );
        }
        if (ValueType == REG_SZ) {
            ExFreePool( (PVOID) ResourceId );
        }
        RtlFreeUnicodeString( &ImageName );
        if (NT_SUCCESS( Status )) {
            Status = 
                LifeLdrImageSize (
                    ImageBase,
                    &ExeSize );

            ExFreePool( ImageBase );
        }
    }

    RtlFreeUnicodeString( &FileName );

    // fix up Message with answer to send back to the dsp

    if (!NT_SUCCESS( Status )) {
        pMsgExeSize->Node.Result = 0;
    } else {
        pMsgExeSize->Node.Result = ExeSize;
    }

    return Status;
}

NTSTATUS
EpdExeLoadFromMessage(
    IN PEPDBUFFER EpdBuffer,
    IN OUT QUEUENODE *pMessage
)
{
    char                    *szFileName;
    NTSTATUS                Status;
    PWCHAR                  ModuleName;
    PVOID                   ImageBase;
    QUEUENODE_EXESIZELOAD   *pMsgExeLoad;
    UNICODE_STRING          FileName, ImageName;
    ULONG                   ValueType;
    ULONG_PTR               ResourceId;
 
    pMsgExeLoad=(QUEUENODE_EXESIZELOAD *)pMessage;
    szFileName = pMsgExeLoad->FileName;
    _DbgPrintF( DEBUGLVL_VERBOSE,("EpdExeSizeFromMessage: Filename='%s'",szFileName));

    Status = 
        EpdZeroTerminatedStringToUnicodeString(
            &FileName, szFileName, TRUE );

    if (!NT_SUCCESS(Status)) {
        _DbgPrintF(DEBUGLVL_VERBOSE,("Fatal error uni"));
        return Status;
    }

    ImageBase = NULL;

    Status =
        KsMapModuleName(
            EpdBuffer->PhysicalDeviceObject,
            &FileName,
            &ImageName,
            &ResourceId,
            &ValueType );

    if (NT_SUCCESS( Status )) {
        PVOID   FileBase;

        _DbgPrintF( DEBUGLVL_VERBOSE, ("mapped module: %S", ImageName.Buffer) );
        if (NT_SUCCESS( Status = LifeLdrLoadFile( &ImageName, &FileBase )  )) {
            Status = 
                KsLoadResource( 
                    FileBase, PagedPool, ResourceId, RT_RCDATA, &ImageBase, NULL );
            ExFreePool( FileBase );
        }
        if (ValueType == REG_SZ) {
            ExFreePool( (PVOID) ResourceId );
        }
        RtlFreeUnicodeString( &ImageName );
    }

    if (NT_SUCCESS( Status )) {
        Status = 
            LifeLdrImageLoad(
                EpdBuffer,
                ImageBase,
                DspToHostMemAddress(EpdBuffer, pMsgExeLoad->Buf),
                (ULONG *)DspToHostMemAddress(EpdBuffer, pMsgExeLoad->pRtlTable),
                &pMsgExeLoad->EntryPoint,
                NULL,
                &pMsgExeLoad->IsaDll );
    }

    if (ImageBase) {
        ExFreePool( ImageBase );
    }


    RtlFreeUnicodeString( &FileName );

    // fix up Message with answer to send back to the dsp

    if (!NT_SUCCESS (Status)) {
        pMsgExeLoad->Node.Result = (UINT32)-1;
    } else {
        pMsgExeLoad->Node.Result = 0;
    }

    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\ksfilter\ksdrmhlp\ksdrmhlp.c ===
#include <KsDrmHlp.h>

NTSTATUS 
KsPropertyHandleDrmSetContentId(
    IN PIRP Irp, 
    IN PFNKSHANDLERDRMSETCONTENTID pDrmSetContentId);

#pragma alloc_text(PAGE, KsPropertyHandleDrmSetContentId)

NTSTATUS 
KsPropertyHandleDrmSetContentId(
    IN PIRP Irp, 
    IN PFNKSHANDLERDRMSETCONTENTID pDrmSetContentId)
/*++

Routine Description:

    Handles KS property requests.  Responds only to 
    KSPROPERTY_DRMAUDIOSTREAM_ContentId with KSPROPERTY_TYPE_SET flag by
    calling the supplied PFNKSHANDLERDRMSETCONTENTID handler.  This function
    may only be called at PASSIVE_LEVEL.
    
    This is a stripped down version of KS's generic KsPropertyHandler.  When
    invoked on properties other than KSPROPERTY_DRMAUDIOSTREAM_ContentId
    or with invalid buffer sizes it attempts to preserve the same error results
    as KsPropertyHandler.

Arguments:

    Irp -
        Contains the IRP with the property request being handled.
        
    pDrmSetContentId -
        The handler for KSPROPERTY_DRMAUDIOSTREAM_ContentId
        
Return Value:

    Returns STATUS_SUCCESS, else an error specific to the property being
    handled. Always sets the IO_STATUS_BLOCK.Information field of the
    PIRP.IoStatus element within the IRP, either through setting it to zero
    because of an internal error, or through a property handler setting it.
    It does not set the IO_STATUS_BLOCK.Status field, nor complete the IRP,
    but the called handler should.

--*/
{
    PIO_STACK_LOCATION IrpStack;
    ULONG InputBufferLength;
    ULONG OutputBufferLength;
    ULONG AlignedBufferLength;
    PVOID UserBuffer;
    PKSPROPERTY Property;
    ULONG Flags;

    PAGED_CODE();
    //
    // Determine the offsets to both the Property and UserBuffer parameters based
    // on the lengths of the DeviceIoControl parameters. A single allocation is
    // used to buffer both parameters. The UserBuffer (or results on a support
    // query) is stored first, and the Property is stored second, on
    // FILE_QUAD_ALIGNMENT.
    //
    IrpStack = IoGetCurrentIrpStackLocation(Irp);
    InputBufferLength = IrpStack->Parameters.DeviceIoControl.InputBufferLength;
    OutputBufferLength = IrpStack->Parameters.DeviceIoControl.OutputBufferLength;
    AlignedBufferLength = (OutputBufferLength + FILE_QUAD_ALIGNMENT) & ~FILE_QUAD_ALIGNMENT;
    //
    // Determine if the parameters have already been buffered by a previous
    // call to this function.
    //
    if (!Irp->AssociatedIrp.SystemBuffer) {
        //
        // Initially just check for the minimal property parameter length. The
        // actual minimal length will be validated when the property item is found.
        // Also ensure that the output and input buffer lengths are not set so
        // large as to overflow when aligned or added.
        //
        if ((InputBufferLength < sizeof(*Property)) || (AlignedBufferLength < OutputBufferLength) || (AlignedBufferLength + InputBufferLength < AlignedBufferLength)) {
            return STATUS_INVALID_BUFFER_SIZE;
        }
        try {
            //
            // Validate the pointers if the client is not trusted.
            //
            if (Irp->RequestorMode != KernelMode) {
                ProbeForRead(IrpStack->Parameters.DeviceIoControl.Type3InputBuffer, InputBufferLength, sizeof(BYTE));
            }
            //
            // Capture flags first so that they can be used to determine allocation.
            //
            Flags = ((PKSPROPERTY)IrpStack->Parameters.DeviceIoControl.Type3InputBuffer)->Flags;
            
            //
            // Use pool memory for system buffer
            //
            Irp->AssociatedIrp.SystemBuffer = ExAllocatePoolWithQuotaTag(NonPagedPool, AlignedBufferLength + InputBufferLength, 'ppSK');
            if ( Irp->AssociatedIrp.SystemBuffer ) {
                Irp->Flags |= (IRP_BUFFERED_IO | IRP_DEALLOCATE_BUFFER);
            
                //
                // Copy the Property parameter.
                //
                RtlCopyMemory((PUCHAR)Irp->AssociatedIrp.SystemBuffer + AlignedBufferLength, IrpStack->Parameters.DeviceIoControl.Type3InputBuffer, InputBufferLength);
            
                //
                // Rewrite the previously captured flags.
                //
                ((PKSPROPERTY)((PUCHAR)Irp->AssociatedIrp.SystemBuffer + AlignedBufferLength))->Flags = Flags;
            
                //
                // Validate the request flags. At the same time set up the IRP flags
                // for an input operation if there is an input buffer available so
                // that Irp completion will copy the data to the client's original
                // buffer.
                //
                if (KSPROPERTY_TYPE_SET == Flags) {
                    //
                    // Thse are all output operations, and must be probed
                    // when the client is not trusted. All data passed is
                    // copied to the system buffer.
                    //
                    if (OutputBufferLength) {
                        if (Irp->RequestorMode != KernelMode) {
                            ProbeForRead(Irp->UserBuffer, OutputBufferLength, sizeof(BYTE));
                        }
                        RtlCopyMemory(Irp->AssociatedIrp.SystemBuffer, Irp->UserBuffer, OutputBufferLength);
                    }
                } else {
                    // We don't handle this.  Ensure this is caught belowl!!!
                }
            }

        } except (EXCEPTION_EXECUTE_HANDLER) {
            if ( Irp->AssociatedIrp.SystemBuffer ) {
                ExFreePool(Irp->AssociatedIrp.SystemBuffer);
            }
            return GetExceptionCode();
        }
        if ( !Irp->AssociatedIrp.SystemBuffer ) {
            return STATUS_INSUFFICIENT_RESOURCES;
        }
    }
    
    //
    // If there are property parameters, retrieve a pointer to the buffered copy
    // of it. This is the first portion of the SystemBuffer.
    //
    if (OutputBufferLength) {
        UserBuffer = Irp->AssociatedIrp.SystemBuffer;
    } else {
        UserBuffer = NULL;
    }

    Property = (PKSPROPERTY)((PUCHAR)Irp->AssociatedIrp.SystemBuffer + AlignedBufferLength);
    Flags = Property->Flags;
    
    if (!IsEqualGUIDAligned(&Property->Set,&KSPROPSETID_DrmAudioStream)) {
        return STATUS_PROPSET_NOT_FOUND;
    }
    
    if (Property->Id != KSPROPERTY_DRMAUDIOSTREAM_CONTENTID) {
        return STATUS_NOT_FOUND;
    }

    if (Irp->RequestorMode != KernelMode) {
        return STATUS_INVALID_DEVICE_REQUEST;
    }
    
    if (KSPROPERTY_TYPE_SET != Flags) {
        return STATUS_NOT_IMPLEMENTED;
    }

    if ((InputBufferLength < sizeof(KSP_DRMAUDIOSTREAM_CONTENTID)) ||
        (OutputBufferLength < sizeof(KSDRMAUDIOSTREAM_CONTENTID)))
    {
        return STATUS_BUFFER_TOO_SMALL;
    }
    
    return pDrmSetContentId(Irp, (PKSP_DRMAUDIOSTREAM_CONTENTID)Property, (PKSDRMAUDIOSTREAM_CONTENTID)UserBuffer);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\ksfilter\ksdsp\epd\epdstr.c ===
#include "private.h"

NTSTATUS
EpdAllocateAndCopyUnicodeString(
    OUT PUNICODE_STRING DestinationString,
    IN  PUNICODE_STRING SourceString
)
{

    DestinationString->Length = 0;
    DestinationString->Buffer = 
        ExAllocatePoolWithTag(
            PagedPool, 
            SourceString->Length, 
            EPD_UNICODE_STRING_SIGNATURE );

    if (DestinationString->Buffer == NULL) {
        DestinationString->MaximumLength = 0;
        return STATUS_UNSUCCESSFUL;
    }

    DestinationString->MaximumLength = SourceString->Length;

    RtlCopyUnicodeString (DestinationString, SourceString);

    return STATUS_SUCCESS;
}

NTSTATUS
EpdZeroTerminatedStringToUnicodeString(
    IN OUT PUNICODE_STRING puni,
    IN  char*           sz,
    IN BOOLEAN Allocate
)
{
    ANSI_STRING ansi;
    NTSTATUS Status;

    RtlInitAnsiString (&ansi, sz);

    Status = RtlAnsiStringToUnicodeString (
                 puni,
                 &ansi,
                 Allocate // allocate destination string
             );

    if (!NT_SUCCESS(Status))
    {
        _DbgPrintF(DEBUGLVL_VERBOSE,("Fatal error in EpdZeroTerminatedStringToUnicodeString"));
    }

    return Status;
}

NTSTATUS
EpdUnicodeStringToZeroTerminatedString(
    OUT char*           sz,
    IN  PUNICODE_STRING puni,
    IN  BOOLEAN Allocate
)
{
    ANSI_STRING ansi;
    NTSTATUS Status;

    Status = RtlUnicodeStringToAnsiString(
                 &ansi,
                 puni,
                 TRUE // allocate destination string
             );

    if (!NT_SUCCESS(Status))
    {
        _DbgPrintF(DEBUGLVL_VERBOSE,("Fatal error RtlUnicodeStringToAnsiString in EpdUnicodeStringToZeroTerminatedString"));
        return STATUS_UNSUCCESSFUL;
    }

    if (Allocate) {
        sz = ansi.Buffer;  // this should work, since RtlUnicodeStringToAnsiString puts a null at the end of the string.
    }
    else { // don't allocate, sz better be long enough!
        RtlCopyMemory (sz, ansi.Buffer, ansi.Length);
        sz[ansi.Length] = '\0';
        ExFreePool (ansi.Buffer);
    }

    return Status;
}


NTSTATUS
EpdAppendFileNameToTalismanDirName(
    UNICODE_STRING *puniPath,
    UNICODE_STRING *puniFileName
)
{
    UNICODE_STRING uniRoot;
    USHORT Length;
    NTSTATUS Status;

    RtlInitUnicodeString (&uniRoot, L"\\SystemRoot\\Talisman\\");

    Length = uniRoot.Length + puniFileName->Length + sizeof(UNICODE_NULL);

    puniPath->Buffer = 
        ExAllocatePoolWithTag(
            PagedPool, 
            (ULONG)Length, 
            EPD_UNICODE_PATH_SIGNATURE );
    if (puniPath->Buffer == NULL) {
        _DbgPrintF(DEBUGLVL_VERBOSE,("EpdAppendFileNameToTalismanDirName: Couldn't allocate %d bytes",Length));
        return STATUS_UNSUCCESSFUL;
    }

    puniPath->MaximumLength = Length;

    RtlCopyUnicodeString (puniPath, &uniRoot);

    Status = RtlAppendUnicodeStringToString (puniPath, puniFileName);
    if (!NT_SUCCESS(Status)) {
        _DbgPrintF(DEBUGLVL_VERBOSE,("EpdAppendFileNameToTalismanDirName: Couldn't do RtlAppendUnicodeStringToString"));
        return STATUS_UNSUCCESSFUL;
    }

    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\ksfilter\ksdsp\epd\epd.c ===
/*++

    Copyright (c) 1998 Microsoft Corporation

Module Name:

    Epd.c

Abstract:


Author:
    Steve Zabinsky (SteveZ) Unknown
    Andy Raffman (AndyRaf) Unknown
    Bryan A. Woodruff (BryanW) 25-Feb-1998

History:
    01/98 - BryanW - Make it WDM and support PnP
    06/98 - BryanW - Private I/O pool
    06/98 - BryanW - Bus enumerator (demand-load support)
    07/98 - BryanW - Win64 changes
    12/98 - BryanW - Bus interface

--*/

#define KSDEBUG_INIT
#include "private.h"

NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPathName
    )
/*++

Routine Description:

    Sets up the driver object by calling the default KCOM initialization.

Arguments:

    DriverObject -
        Driver object for this instance.

    RegistryPathName -
        Contains the registry path which was used to load this instance.

Return Values:

    Returns STATUS_SUCCESS if the driver was initialized.

--*/
{
    _DbgPrintF(DEBUGLVL_TERSE, ("DriverEntry"));
    
    //
    // Initialize the driver entry points to use the default Irp processing
    // code. Pass in the create handler for objects supported by this module.
    //
    
    DriverObject->MajorFunction[IRP_MJ_CREATE] = EpdOpen;
    DriverObject->MajorFunction[IRP_MJ_PNP] = DispatchPnp;
    DriverObject->MajorFunction[IRP_MJ_DEVICE_CONTROL] = EpdDeviceControl;
    DriverObject->MajorFunction[IRP_MJ_CLOSE] = EpdClose;
    DriverObject->DriverExtension->AddDevice = AddDevice;
    
    return STATUS_SUCCESS;
}

void EpdCleanup(
    IN PDEVICE_OBJECT FunctionalDeviceObject
    )
{
    NTSTATUS Status;
    PEPDCTL pEpdCtl;
    PCM_RESOURCE_LIST pLocalResources;
    PDEVICE_OBJECT DeviceObject;
    PEPDBUFFER EpdBuffer;
    UNICODE_STRING uniWin32NameString;

    _DbgPrintF(DEBUGLVL_VERBOSE,("EpdCleanup"));

    EpdBuffer = (PEPDBUFFER) FunctionalDeviceObject->DeviceExtension;

    if (EpdBuffer->DspRegisterVa) {
        //
        // If the registers have been mapped, stop the DSP and clear IRQ.
        //

        EpdResetDsp(EpdBuffer);
        ClearHostIrq( EpdBuffer ); // turn off interrupt
    }

    //
    // Disconnect the interrupt
    //

    if (EpdBuffer->InterruptObject) {
        IoDisconnectInterrupt (EpdBuffer->InterruptObject);
        EpdBuffer->InterruptObject = NULL;
    }

    //
    // Signal the thread to exit
    //
    if (EpdBuffer->ThreadObject) {
        pEpdCtl = 
            ExAllocatePoolWithTag(
                NonPagedPool, 
                sizeof(EPDCTL), 
                EPD_DSP_CONTROL_SIGNATURE );

        if (pEpdCtl == NULL) {
            _DbgPrintF(
                DEBUGLVL_VERBOSE,
                ("Could not alloc pEpdCtl, can not send kill thread msg to thread"));
        }
        else {
            EpdSendReqToThread( pEpdCtl, EPDTHREAD_KILL_THREAD, EpdBuffer );
            _DbgPrintF(DEBUGLVL_VERBOSE,("sent EPD_EXIT_KILL_THREAD msg, waiting for thread to die"));

            Status = 
                KeWaitForSingleObject (
                    EpdBuffer->ThreadObject,  // IN PVOID  Object,
                    Executive  ,              // IN KWAIT_REASON  WaitReason,
                    KernelMode,               // IN KPROCESSOR_MODE  WaitMode,
                    FALSE,                    // IN BOOLEAN  Alertable,
                    NULL );                   // IN PLARGE_INTEGER  Timeout OPTIONAL

            // Thread is gone, dereference the pointer so it can be deleted
            _DbgPrintF(DEBUGLVL_VERBOSE,("wait finished, continue unload"));
            ObDereferenceObject(EpdBuffer->ThreadObject);
            EpdBuffer->ThreadObject = NULL;
        }
    }
 
    // un-map the dsp memory and registers
    if (EpdBuffer->DspMemoryVa) {
        MmUnmapIoSpace (EpdBuffer->DspMemoryVa, EpdBuffer->MemLenDspMem);
        EpdBuffer->DspMemoryVa = NULL;
    }

    if (EpdBuffer->DspRegisterVa) {
        MmUnmapIoSpace (EpdBuffer->DspRegisterVa, EpdBuffer->MemLenDspReg);
        EpdBuffer->DspRegisterVa = NULL;
    }

    // Free the message queues
    
    if (EpdBuffer->pEDDCommBuf) {
        EpdFreeMessageQueue( EpdBuffer );
        EpdBuffer->pEDDCommBuf = NULL;
    }
}

NTSTATUS
AddDevice(
    IN PDRIVER_OBJECT   DriverObject,
    IN PDEVICE_OBJECT   PhysicalDeviceObject
    )
/*++

Routine Description:

    When a new device is detected, PnP calls this entry point with the
    new PhysicalDeviceObject (PDO). The driver creates an associated 
    FunctionalDeviceObject (FDO).

Arguments:

    DriverObject -
        Pointer to the driver object.

    PhysicalDeviceObject -
        Pointer to the new physical device object.

Return Values:

    STATUS_SUCCESS or an appropriate error condition.

--*/
{
    NTSTATUS            Status;
    PEPDBUFFER          EpdBuffer;
    PDEVICE_OBJECT      FunctionalDeviceObject;
    UNICODE_STRING      DeviceNameString;
    ULONG               ResultLength;
    WCHAR               DeviceName[ 256 ];
    
    PAGED_CODE();
    
    // A new physical device object (PDO) was created by the enumerator, 
    // create a functional device object (FDO) and attach it to the PDO
    // so that we will receive further notifications.
    
    Status = 
        IoGetDeviceProperty( 
            PhysicalDeviceObject,
            DevicePropertyPhysicalDeviceObjectName,
            sizeof( DeviceName ),
            DeviceName,
            &ResultLength );
    RtlInitUnicodeString( &DeviceNameString, DeviceName );

    if (!NT_SUCCESS( Status )) {
        _DbgPrintF( 
            DEBUGLVL_ERROR, 
            ("failed to retrieve PDO's device name: %x", Status) );
        return Status;
    }
    

    //
    // Create the FDO.
    //

    Status = 
        IoCreateDevice( 
            DriverObject,
            sizeof( EPDBUFFER ),
            NULL,                           // FDOs are unnamed
            FILE_DEVICE_KS,
            0,
            FALSE,
            &FunctionalDeviceObject );


    if (!NT_SUCCESS( Status )) {
        _DbgPrintF( DEBUGLVL_ERROR, ("failed to create FDO") );
        return Status;
    }

    EpdBuffer = (PEPDBUFFER) FunctionalDeviceObject->DeviceExtension;
    RtlZeroMemory( EpdBuffer, sizeof(EPDBUFFER) );

    EpdBuffer->PhysicalDeviceObject = PhysicalDeviceObject;
    
    EpdBuffer->PnpDeviceObject =
        IoAttachDeviceToDeviceStack(
            FunctionalDeviceObject, 
            PhysicalDeviceObject );
    
    Status = 
        KsCreateBusEnumObject( 
            L"EPD-TM1",
            FunctionalDeviceObject, 
            PhysicalDeviceObject,
            EpdBuffer->PnpDeviceObject,
            &TM1BusInterfaceId, // REFGUID InterfaceGuid
            L"Filters" );
            
    if (!NT_SUCCESS( Status )) {
        IoDetachDevice( EpdBuffer->PnpDeviceObject );
        IoDeleteDevice( FunctionalDeviceObject );
        return Status;
    }            
    
    //
    // BUGBUG! Fix for DO_DIRECT_IO
    //
    FunctionalDeviceObject->Flags |= DO_BUFFERED_IO ;
    FunctionalDeviceObject->Flags &= ~DO_DEVICE_INITIALIZING;

    // register the DpcForIsr routine
    
    IoInitializeDpcRequest( FunctionalDeviceObject, EpdDpcRoutine );
            
    EpdBuffer->FunctionalDeviceObject = FunctionalDeviceObject;

    // We'll do all disk access through a thread.  Set up the list and thread here.
    InitializeListHead( &EpdBuffer->ListEntry ); // set up the InterlockedList for the queue for the DiskThread
    KeInitializeSpinLock( &EpdBuffer->ListSpinLock ); // Also need a spinlock for the list
    
    KeInitializeSemaphore(
        &EpdBuffer->ThreadSemaphore, 
        0L, // IN LONG  Count
        MAXLONG );

    KeInitializeMutex( &EpdBuffer->ControlMutex, 1 );

    return STATUS_SUCCESS;
}

NTSTATUS 
EpdInitialize(
    PDEVICE_OBJECT PhysicalDeviceObject,
    PDEVICE_OBJECT FunctionalDeviceObject,
    PCM_RESOURCE_LIST AllocatedResources,
    PCM_RESOURCE_LIST TranslatedResources
    )
{
    DEVICE_DESCRIPTION              DeviceDescription;
    HANDLE                          SystemThread;
    PEPDBUFFER                      EpdBuffer;
    NTSTATUS                        Status;
    PCM_PARTIAL_RESOURCE_DESCRIPTOR ResDes, Mem[ 2 ], IRQ;
    PHYSICAL_ADDRESS                DspMemPhysAddr;
    ULONG                           MemCount, IRQCount, i, SizeOfCacheBoundary;

    EpdBuffer = (PEPDBUFFER) FunctionalDeviceObject->DeviceExtension;
    
    MemCount = IRQCount = 0;

    //
    // Count assigned resources and establish index tables.
    //

    for (i = 0,
         ResDes =
         AllocatedResources->List[ 0 ].PartialResourceList.PartialDescriptors;
         i < AllocatedResources->List[ 0 ].PartialResourceList.Count;
         i++, ResDes++) {
         
        switch (ResDes->Type)
        {
        
        case CmResourceTypeDevicePrivate:
            break;

        case CmResourceTypeMemory:
            switch (MemCount) {

            case 0:
                DspMemPhysAddr = 
                    AllocatedResources->List[ 0 ].PartialResourceList.PartialDescriptors[ i ].u.Memory.Start;
                break;

            case 2:
                return STATUS_DEVICE_CONFIGURATION_ERROR;

            default:
                break;

            }
            Mem[ MemCount++ ] = 
                &TranslatedResources->List[ 0 ].PartialResourceList.PartialDescriptors[ i ];
            break;

        case CmResourceTypeInterrupt:
            if (IRQCount == 1) {
                return STATUS_DEVICE_CONFIGURATION_ERROR;
            }
            IRQ = &TranslatedResources->List[ 0 ].PartialResourceList.PartialDescriptors[ i ];
            break;

        default:
            _DbgPrintF( 
                DEBUGLVL_ERROR, 
                ("unsupported resource type: %d", ResDes->Type) );

        }
    }

    //
    // These addresses have been mapped by Plug-And-Play.
    //    
    
    EpdBuffer->MemLenDspMem = Mem[ 0 ]->u.Memory.Length;
    EpdBuffer->DspMemoryVa = 
        MmMapIoSpace( 
            Mem[ 0 ]->u.Memory.Start, 
            EpdBuffer->MemLenDspMem, 
            FALSE ); // BOOLEAN CacheEnable

    _DbgPrintF( 
        DEBUGLVL_VERBOSE, 
        ("DSP memory: Va: %08x, Phys: %08x", EpdBuffer->DspMemoryVa, DspMemPhysAddr.LowPart) );

    EpdBuffer->MemLenDspReg = Mem[ 1 ]->u.Memory.Length;
    EpdBuffer->DspRegisterVa = 
        MmMapIoSpace( 
            Mem[ 1 ]->u.Memory.Start, 
            EpdBuffer->MemLenDspReg,
            FALSE ); // BOOLEAN CacheEnable
    
    // Initialize mapping between DSP physical mem addresses & 
    // host virtual mem addresses
    //
    // This sets global HostToDspMemOffset
    
    InitHostDspMemMapping( 
        EpdBuffer->DspMemoryVa, 
        DspMemPhysAddr.LowPart );

    // Test the amount of memory on the card
    
    EpdBuffer->MemLenDspMemActual = 
        EpdMemSizeTest( EpdBuffer->DspMemoryVa, EpdBuffer->MemLenDspMem );
    if (EpdBuffer->MemLenDspMemActual==0)
    {
        _DbgPrintF( DEBUGLVL_ERROR, ("No memory on DSP!") );
        EpdCleanup( FunctionalDeviceObject );
        return STATUS_DEVICE_CONFIGURATION_ERROR;
    }

    _DbgPrintF( DEBUGLVL_VERBOSE, ("DspRegisterVa 0x%x", EpdBuffer->DspRegisterVa) );
    
    if (!EpdBuffer->DspMemoryVa) {
        _DbgPrintF( DEBUGLVL_ERROR, ("failed to map dsp registers to kernel mode virtual address") );
        EpdCleanup( FunctionalDeviceObject );
        return STATUS_UNSUCCESSFUL;
    }
    //must un-map the dsp registers, marker is EpdBuffer->DspReg

    // Initialize mapping between DSP physical reg addresses & host virtual reg addresses
    // This sets global HostToDspRegOffset
    
    InitHostDspRegMapping(EpdBuffer, EpdBuffer->DspRegisterVa, Mem[ 1 ]->u.Memory.Start.LowPart);

    // Initialize ptr to mmio space for MMIO macro
    
    EpdBuffer->IoBaseTM1 = (PUINT) EpdBuffer->DspRegisterVa ;

    // DSP_STOP();
    EpdResetDsp(EpdBuffer);

    //interrupts are now enabled, marker is EpdBuffer->InterruptObject

    MMIO(EpdBuffer,DRAM_LIMIT) =
    MMIO(EpdBuffer,DRAM_CACHEABLE_LIMIT) = 
        HostToDspMemAddress(EpdBuffer, EpdBuffer->DspMemoryVa) + EpdBuffer->MemLenDspMemActual;

    _DbgPrintF(DEBUGLVL_VERBOSE,("MMIO(DRAM_BASE)  0x%x, MMIO(DRAM_LIMIT) 0x%x", MMIO(EpdBuffer,DRAM_BASE), MMIO(EpdBuffer,DRAM_LIMIT)));

    ClearHostIrq( EpdBuffer ); // turn off interrupt

    Status =
        IoConnectInterrupt( 
            &EpdBuffer->InterruptObject,
            EpdInterruptService,
            FunctionalDeviceObject,
            NULL,                               // IN PKSPIN_LOCK  SpinLock
            IRQ->u.Interrupt.Vector,
            (KIRQL) IRQ->u.Interrupt.Level,     // IN KIRQL  Irql
            (KIRQL) IRQ->u.Interrupt.Level,     // IN KIRQL  SynchronizeIrql
            ((IRQ->Flags & CM_RESOURCE_INTERRUPT_LATCHED) ? 
                Latched : LevelSensitive), 
            ((BOOLEAN) (IRQ->ShareDisposition != 
                            CmResourceShareDeviceExclusive)), 
            IRQ->u.Interrupt.Affinity, 
            FALSE );                            // IN BOOLEAN SaveFpuState
    
    if (!NT_SUCCESS( Status )) {
        _DbgPrintF( DEBUGLVL_ERROR, ("failed to connect interrupt") );
        EpdCleanup( FunctionalDeviceObject );
        return Status;
    }

    RtlZeroMemory( &DeviceDescription, sizeof( DEVICE_DESCRIPTION ) );
    DeviceDescription.Version = DEVICE_DESCRIPTION_VERSION;

    DeviceDescription.InterfaceType = PCIBus;
    DeviceDescription.Master = TRUE;
    DeviceDescription.DmaWidth = Width32Bits;

    //
    // Setup the BusMasterAdapterObject for our DMA transfers to/from the
    // device.  Note that this device can only handle segments up to 64k 
    // in length. Limit the transfers for this device to 1MB per adapter.
    //

    DeviceDescription.MaximumLength = 0x100000;
    DeviceDescription.ScatterGather = TRUE;
    DeviceDescription.Dma32BitAddresses = TRUE;
    
    EpdBuffer->BusMasterAdapterObject = 
        IoGetDmaAdapter( 
            PhysicalDeviceObject, 
            &DeviceDescription, 
            &EpdBuffer->NumberOfMapRegisters);
    _DbgPrintF(DEBUGLVL_VERBOSE,("NumberOfMapRegisters %d", EpdBuffer->NumberOfMapRegisters));
    
    EpdBuffer->IoPool = 
        CreateIoPool( EpdBuffer->BusMasterAdapterObject );
    SizeOfCacheBoundary = HalGetDmaAlignment( EpdBuffer->BusMasterAdapterObject );
    _DbgPrintF( DEBUGLVL_VERBOSE, ("SizeOfCacheBoundary 0x%x", SizeOfCacheBoundary) );
    
    //
    // Allocate message queues
    //
    
    EpdAllocateMessageQueue( EpdBuffer );
    
    EpdBuffer->DebugBufferVa =
        HalAllocateCommonBuffer( 
            EpdBuffer->BusMasterAdapterObject, 
            sizeof( EPD_DEBUG_BUFFER ),
            &EpdBuffer->DebugBufferPhysicalAddress,
            FALSE );
    
    //
    // BUGBUG! Check returns, clean up, etc.
    //         
    
    EpdBuffer->DebugBufferMdl =
        IoAllocateMdl( 
            EpdBuffer->DebugBufferVa, 
            sizeof( EPD_DEBUG_BUFFER ),
            FALSE,
            FALSE,
            NULL );
    MmBuildMdlForNonPagedPool( EpdBuffer->DebugBufferMdl );

    // Set up a system thread to handle disk access
    
    Status = 
        PsCreateSystemThread(
            &SystemThread,   
            (ACCESS_MASK) 0L,   // IN ACCESS_MASK DesiredAccess
            NULL,               // IN POBJECT_ATTRIBUTES ObjectAttributes
            NULL,               // IN HANDLE ProcessHandle
            NULL,               // OUT PCLIENT_ID ClientId
            EpdDiskThread,                     
            (PVOID) FunctionalDeviceObject ); 

    if (SystemThread) {
        Status = 
            ObReferenceObjectByHandle( 
                SystemThread, 
                THREAD_ALL_ACCESS, 
                NULL, 
                KernelMode, 
                &EpdBuffer->ThreadObject, 
                NULL );
    }

    if (!NT_SUCCESS(Status)) {
        _DbgPrintF( DEBUGLVL_ERROR, ("failed to create system thread") );

        // BUGBUG! clean up here.
        return Status;
    }
    ZwClose( SystemThread ); 

    // Load the kernel and start the DSP
    
    KernLdrLoadDspKernel( EpdBuffer );
    Status = EpdUnresetDsp( EpdBuffer );
    
    //kernel is started
    EpdBuffer->bDspStarted = TRUE;
    
//    RtlStringFromGUID( &KSNAME_Filter, &FilterCreateItems[ 0 ].ObjectClass );
    
    Status = 
        IoRegisterDeviceInterface(
            PhysicalDeviceObject,
            (GUID *) &KSCATEGORY_ESCALANTE_PLATFORM_DRIVER,
            NULL,
            &EpdBuffer->linkName);
    
    if (NT_SUCCESS( Status )) {
        _DbgPrintF( 
            DEBUGLVL_VERBOSE, 
            ("linkName = %S", EpdBuffer->linkName.Buffer) );

        Status = 
            IoSetDeviceInterfaceState( &EpdBuffer->linkName, TRUE );
        _DbgPrintF(               
            DEBUGLVL_VERBOSE, 
            ("IoSetDeviceInterfaceState = %x", Status) );
    
        if (!NT_SUCCESS( Status )) {
            ExFreePool( EpdBuffer->linkName.Buffer );
            EpdBuffer->linkName.Buffer = NULL;
        }        
    }
            
    
}

NTSTATUS
EpdTerminate(
    PDEVICE_OBJECT FunctionalDeviceObject
)
{
    PEPDBUFFER EpdBuffer;
    
    EpdBuffer = (PEPDBUFFER) FunctionalDeviceObject->DeviceExtension;
    if (EpdBuffer->linkName.Buffer) {
        IoSetDeviceInterfaceState( &EpdBuffer->linkName, FALSE );
        ExFreePool( EpdBuffer->linkName.Buffer );
        EpdBuffer->linkName.Buffer = NULL;
    }

    if (EpdBuffer->IoPool) {
        DestroyIoPool( EpdBuffer->IoPool );
        EpdBuffer->IoPool = NULL;
    }
    EpdCleanup( FunctionalDeviceObject );
    
    return STATUS_SUCCESS;
}

NTSTATUS 
DispatchPnp(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:
    This is the main PnP dispatch handler.  We receive notifications
    regarding our FDO here.  First, we must pass down the notifications
    to the PDO so that it can perform the necessary operations for enabling
    and disabling the resources via the bus driver.

Arguments:
    IN PDEVICE_OBJECT DeviceObject -
        pointer to our FDO

    IN PIRP Irp -
        pointer to the I/O request packet

Return:

--*/
{
    BOOLEAN             ChildDevice;
    NTSTATUS            Status;
    PEPDBUFFER          EpdBuffer;
    PIO_STACK_LOCATION  irpSp;
    
    
    Status = KsIsBusEnumChildDevice( DeviceObject, &ChildDevice );
    
    if (!NT_SUCCESS( Status )) {
        Irp->IoStatus.Status = Status;
        IoCompleteRequest( Irp, IO_NO_INCREMENT );
        return Status;
    }

    irpSp = IoGetCurrentIrpStackLocation( Irp );

    //
    // If this request is for a child PDO, let KS service the request.
    //
    
    if (ChildDevice) {
        Status = KsServiceBusEnumPnpRequest( DeviceObject, Irp );

        if (irpSp->MinorFunction == IRP_MN_QUERY_INTERFACE) {
            if (IsEqualGUID( 
                    irpSp->Parameters.QueryInterface.InterfaceType,
                    &BUSID_KSDSPPlatform) &&
                (irpSp->Parameters.QueryInterface.Size == 
                    sizeof( BUS_INTERFACE_KSDSPPLATFORM )) &&
                (irpSp->Parameters.QueryInterface.Version ==
                    BUS_INTERFACE_KSDSPPLATFORM_VERSION )) {
                    
                PBUS_INTERFACE_KSDSPPLATFORM BusInterface;
                PDEVICE_OBJECT FunctionalDeviceObject;

                Status =
                    KsGetBusEnumParentFDOFromChildPDO(
                        DeviceObject,
                        &FunctionalDeviceObject 
                        );

                if (NT_SUCCESS( Status )) {
                    BusInterface = 
                        (PBUS_INTERFACE_KSDSPPLATFORM)irpSp->Parameters.QueryInterface.Interface;
                        
                    BusInterface->Size = sizeof( *BusInterface );
                    BusInterface->Version = BUS_INTERFACE_KSDSPPLATFORM_VERSION;
                    //
                    // Retrieve the EPD instance from the FDO.
                    //
                    BusInterface->Context = FunctionalDeviceObject->DeviceExtension;
                    BusInterface->InterfaceReference = InterfaceReference;
                    BusInterface->InterfaceDereference = InterfaceDereference;
                    BusInterface->MapModuleName = KsDspMapModuleName;
                    BusInterface->PrepareChannelMessage = KsDspPrepareChannelMessage;
                    BusInterface->PrepareMessage = KsDspPrepareMessage;
                    BusInterface->MapDataTransfer = KsDspMapDataTransfer;
                    BusInterface->UnmapDataTransfer = KsDspUnmapDataTransfer;
                    BusInterface->SendMessage = KsDspSendMessage;
                    BusInterface->GetMessageResult = KsDspGetMessageResult;
                    BusInterface->AllocateMessageFrame = KsDspAllocateMessageFrame;
                    BusInterface->FreeMessageFrame = KsDspFreeMessageFrame;
                    BusInterface->GetControlChannel = KsDspGetControlChannel;
                    InterfaceReference( BusInterface->Context );
                    Status = STATUS_SUCCESS;
                }
            }
        }

        Irp->IoStatus.Status = Status;
        IoCompleteRequest( Irp, IO_NO_INCREMENT );
        return Status;
    }

    EpdBuffer = (PEPDBUFFER) DeviceObject->DeviceExtension;

    //
    // This request is directed towards the FDO.  Take the control mutex
    // and then perform the requested operation.
    //    

    KeWaitForSingleObject( 
        &EpdBuffer->ControlMutex,
        Executive,
        KernelMode,
        FALSE,                  // not alertable
        NULL );
    
    switch (irpSp->MinorFunction) {
    
    case IRP_MN_START_DEVICE:
        {
        PCM_RESOURCE_LIST   AllocatedResources, TranslatedResources;
        
        _DbgPrintF( 
            DEBUGLVL_BLAB, 
            ("DispatchPnP: IRP_MN_START_DEVICE") );
        
        Status = 
            KsForwardAndCatchIrp( 
                EpdBuffer->PnpDeviceObject, 
                Irp, 
                irpSp->FileObject,
                KsStackCopyToNewLocation );
        
        AllocatedResources = 
            irpSp->Parameters.StartDevice.AllocatedResources;
        TranslatedResources = 
            irpSp->Parameters.StartDevice.AllocatedResourcesTranslated;
            
        _DbgPrintF( 
            DEBUGLVL_BLAB,
            ("Resources: Allocated: %08x, Translated: %08x", 
                AllocatedResources, TranslatedResources) );
            
        if (NT_SUCCESS( Status )) {
            Status =
                EpdInitialize( 
                    EpdBuffer->PnpDeviceObject,
                    DeviceObject, 
                    AllocatedResources,
                    TranslatedResources );
        }
    
        //
        // Call SWENUM to enable child interfaces
        //
        if (NT_SUCCESS( Status )) {
            Status = KsServiceBusEnumPnpRequest( DeviceObject, Irp );
            if (!NT_SUCCESS( Status)) {
                EpdTerminate( DeviceObject );
            } 
        }    
        
        }
        break;
    
    case IRP_MN_QUERY_STOP_DEVICE:
    case IRP_MN_QUERY_REMOVE_DEVICE:    
    case IRP_MN_CANCEL_STOP_DEVICE:
    case IRP_MN_CANCEL_REMOVE_DEVICE:
        Status = 
            KsForwardAndCatchIrp( 
                EpdBuffer->PnpDeviceObject, 
                Irp, 
                irpSp->FileObject,
                KsStackCopyToNewLocation );

        if (NT_SUCCESS( Status )) {
            Status = KsServiceBusEnumPnpRequest( DeviceObject, Irp );        
        }
        break;    

    case IRP_MN_REMOVE_DEVICE:
    case IRP_MN_STOP_DEVICE:
        {
    
        //
        // Release resources and then forward request to the bus.
        //        
            
        EpdTerminate( DeviceObject );
        Status = 
            KsForwardAndCatchIrp( 
                EpdBuffer->PnpDeviceObject, 
                Irp, 
                irpSp->FileObject,
                KsStackCopyToNewLocation );

        ASSERT( Status == STATUS_SUCCESS );
        
        Status = KsServiceBusEnumPnpRequest( DeviceObject, Irp );        
        }       
        break;
    
    case IRP_MN_QUERY_DEVICE_RELATIONS:
        {
       
        DEVICE_RELATION_TYPE relationType;
        
        //
        // The TargetDeviceRelation for the FDO are handled by
        // forwarding the request to the bus.
        //
        
        relationType = irpSp->Parameters.QueryDeviceRelations.Type;
        if (relationType == TargetDeviceRelation) {
            PDEVICE_OBJECT PnpDeviceObject;
            
            //
            // Forward this IRP to the bus reusing the current
            // stack location.
            //
            
            Status = 
                KsGetBusEnumPnpDeviceObject( 
                    DeviceObject, 
                    &PnpDeviceObject );
            
            if (NT_SUCCESS( Status )) {                
                IoSkipCurrentIrpStackLocation(Irp);
                return IoCallDriver( PnpDeviceObject, Irp );
            }
            //
            // On error, fall through and complete the IRP with
            // the status.
            //    
        } else {
            Status = KsServiceBusEnumPnpRequest( DeviceObject, Irp );    
        }
        
        }            
        break;
        

    default:
        Status = KsServiceBusEnumPnpRequest( DeviceObject, Irp );    
        
        if ((Status == STATUS_NOT_SUPPORTED) || NT_SUCCESS( Status )) {
            KeReleaseMutex( &EpdBuffer->ControlMutex, FALSE );
            IoSkipCurrentIrpStackLocation(Irp);
            return IoCallDriver( EpdBuffer->PnpDeviceObject, Irp );
        }
        
    }

    KeReleaseMutex( &EpdBuffer->ControlMutex, FALSE );
    Irp->IoStatus.Status = Status;
    IoCompleteRequest( Irp, IO_NO_INCREMENT );
        
    return Status;        
}

NTSTATUS
EpdOpen(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
)
{
    NTSTATUS            Status;
    PEPDINSTANCE        EpdInstance;
    PIO_STACK_LOCATION  irpSp;

    _DbgPrintF(DEBUGLVL_VERBOSE,("EpdOpen"));

    irpSp = IoGetCurrentIrpStackLocation( Irp );
    
    //
    // If the open is directed to one of the child interfaces, 
    // let SWENUM handle the enumeration & reparse.
    //
    
    if (irpSp->FileObject->FileName.Length) {

        Status = KsServiceBusEnumCreateRequest( DeviceObject, Irp );    

        if (Status != STATUS_PENDING) {
            IoCompleteRequest( Irp, IO_NO_INCREMENT );
        }    
        return Status;    
    }

    EpdInstance = 
        ExAllocatePoolWithTag( 
            PagedPool, 
            sizeof( EPDINSTANCE ), 
            EPD_INSTANCE_SIGNATURE);

    if (!EpdInstance) {
        Status = STATUS_INSUFFICIENT_RESOURCES;
    } else {
        RtlZeroMemory( EpdInstance, sizeof( EPDINSTANCE ) );
        irpSp->FileObject->FsContext = EpdInstance;
        Status = STATUS_SUCCESS;
    }
    Irp->IoStatus.Status = Status;
    IoCompleteRequest (Irp, IO_NO_INCREMENT);
    return Status;
}

NTSTATUS
EpdClose(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
)
{
    PEPDBUFFER          EpdBuffer;
    PEPDINSTANCE        EpdInstance;
    PIO_STACK_LOCATION  irpSp;

    _DbgPrintF(DEBUGLVL_VERBOSE,("EpdClose"));

    irpSp = IoGetCurrentIrpStackLocation( Irp );
    EpdBuffer = (PEPDBUFFER) DeviceObject->DeviceExtension;
    EpdInstance = (PEPDINSTANCE) irpSp->FileObject->FsContext;
    if (EpdInstance->DebugBuffer) {
        MmUnmapLockedPages( EpdInstance->DebugBuffer, EpdBuffer->DebugBufferMdl );
    }
    ExFreePool( EpdInstance );

    Irp->IoStatus.Status = STATUS_SUCCESS;
    IoCompleteRequest (Irp, IO_NO_INCREMENT);
    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\ksfilter\ks\test\memtest.c ===
/*++

    Copyright (C) Microsoft Corporation, 1998 - 1998

Module Name:

    memtest.c

Abstract:

    This module contains the helper functions for memory testing.

--*/

#include <ksp.h>

#define KSI_ALLOC
#define ALLOCATION_FAILURE_RATE   6

#undef ExAllocatePool
#undef ExAllocatePoolWithTag
#undef ExAllocatePoolWithQuota
#undef ExAllocatePoolWithQuotaTag

ULONG KsiFailureType = KS_ALLOCATION_PASS_THROUGH;
ULONG KsiTagValue;
ULONG KsiFailureCountRate = ALLOCATION_FAILURE_RATE;
ULONG KsiFailureCountDown = ALLOCATION_FAILURE_RATE;


KSDDKAPI
VOID
NTAPI
KsSetAllocationParameters(
    IN ULONG FailureType,
    IN ULONG TagValue,
    IN ULONG FailureCountRate
    )
{
    KsiFailureType = FailureType;
    KsiTagValue = TagValue;
    KsiFailureCountRate = FailureCountRate;
    KsiFailureCountDown = FailureCountRate;
}


PVOID
KsiAllocatePool(
    IN POOL_TYPE PoolType,
    IN SIZE_T NumberOfBytes) 
{
    switch (KsiFailureType) {
    
    case KS_ALLOCATION_PASS_THROUGH:
    case KS_ALLOCATION_FAIL_ON_TAG:
        break;
    case KS_ALLOCATION_FAIL_ALWAYS:
        DbgPrint("KS: Forced ExAllocatePool failure\n");
        return NULL;
    case KS_ALLOCATION_FAIL_PERIODICALLY:
        
        if ( KsiFailureCountDown-- == 0 ) {
    
            DbgPrint("KS: Forced ExAllocatePool failure on counter 0\n");
            KsiFailureCountDown = KsiFailureCountRate;
            return NULL;
        }
        break;
    default:
        DbgPrint("KS: Invalid Allocation failure type: %lx", KsiFailureType);
        DbgBreakPoint();
    }       

    return ExAllocatePool(PoolType, NumberOfBytes);
}


PVOID
KsiAllocatePoolWithTag(
    IN POOL_TYPE PoolType,
    IN SIZE_T NumberOfBytes,
    IN ULONG Tag)
{
    switch (KsiFailureType) {
    
    case KS_ALLOCATION_PASS_THROUGH:
        break;
    case KS_ALLOCATION_FAIL_ALWAYS:
        DbgPrint("KS: Forced ExAllocatePoolTag failure\n");
        return NULL;
    case KS_ALLOCATION_FAIL_ON_TAG:
        if (Tag == KsiTagValue) {
            DbgPrint("KS: Forced ExAllocatePoolWithTag failure on tag %c%c%c%c\n",
                     (CHAR)(Tag & 0xFF),
                     (CHAR)((Tag >> 8) & 0xFF), 
                     (CHAR)((Tag >> 16) & 0xFF), 
                     (CHAR)((Tag >> 24) & 0xFF));
            return NULL;
        }
        break;
    case KS_ALLOCATION_FAIL_PERIODICALLY:
        
        if ( KsiFailureCountDown-- == 0 ) {
    
            DbgPrint("KS: Forced ExAllocatePoolWithTag failure on counter 0\n");
            KsiFailureCountDown = KsiFailureCountRate;
            return NULL;
        }
        break;
    default:
        DbgPrint("KS: Invalid Allocation failure type: %lx", KsiFailureType);
        DbgBreakPoint();
    }

    return ExAllocatePoolWithTag(PoolType, NumberOfBytes, Tag);
}


PVOID
KsiAllocatePoolWithQuota(
    IN POOL_TYPE PoolType,
    IN SIZE_T NumberOfBytes)
{
    switch (KsiFailureType) {
    
    case KS_ALLOCATION_PASS_THROUGH:
    case KS_ALLOCATION_FAIL_ON_TAG:
        break;
    case KS_ALLOCATION_FAIL_ALWAYS:
        DbgPrint("KS: Forced ExAllocatePoolWithQuota failure\n");
        ExRaiseStatus(STATUS_INSUFFICIENT_RESOURCES);
        break;
    case KS_ALLOCATION_FAIL_PERIODICALLY:
        
        if ( KsiFailureCountDown-- == 0 ) {
    
            DbgPrint("KS: Forced ExAllocatePoolWithQuota failure on counter 0\n");
            KsiFailureCountDown = KsiFailureCountRate;
            ExRaiseStatus(STATUS_INSUFFICIENT_RESOURCES);
        }
        break;
    default:
        DbgPrint("KS: Invalid Allocation failure type: %lx", KsiFailureType);
        DbgBreakPoint();
    }

    return ExAllocatePoolWithQuota(PoolType, NumberOfBytes);
}


PVOID
KsiAllocatePoolWithQuotaTag(
    IN POOL_TYPE PoolType,
    IN SIZE_T NumberOfBytes,
    IN ULONG Tag) 
{
    switch (KsiFailureType) {
    
    case KS_ALLOCATION_PASS_THROUGH:
        break;
    case KS_ALLOCATION_FAIL_ALWAYS:
        DbgPrint("KS: Forced ExAllocatePoolWithQuotaTag failure\n");
        ExRaiseStatus(STATUS_INSUFFICIENT_RESOURCES);
        break;
    case KS_ALLOCATION_FAIL_ON_TAG:
        if (Tag == KsiTagValue) {
            DbgPrint("KS: Forced ExAllocatePoolWithQuotaTag failure on tag %c%c%c%c\n",
                     (CHAR)(Tag & 0xFF),
                     (CHAR)((Tag >> 8) & 0xFF), 
                     (CHAR)((Tag >> 16) & 0xFF), 
                     (CHAR)((Tag >> 24) & 0xFF));
            ExRaiseStatus(STATUS_INSUFFICIENT_RESOURCES);
        }
        break;
    case KS_ALLOCATION_FAIL_PERIODICALLY:
        
        if ( KsiFailureCountDown-- == 0 ) {
    
            DbgPrint("KS: Forced ExAllocatePoolWithQuotaTag failure on counter 0\n");
            KsiFailureCountDown = KsiFailureCountRate;
            ExRaiseStatus(STATUS_INSUFFICIENT_RESOURCES);
        }
        break;
    default:
        DbgPrint("KS: Invalid Allocation failure type: %lx", KsiFailureType);
        DbgBreakPoint();
    }

    return ExAllocatePoolWithQuotaTag(PoolType, NumberOfBytes, Tag);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\ksfilter\ksdsp\epd\interface.c ===
/*++

    Copyright (c) 1998 Microsoft Corporation

Module Name:

    interface.c

Abstract:

    implements the KSDSP interfaces

Author:

    bryanw 08-Dec-1998

--*/

#include "private.h"
#include <stdarg.h>

#pragma alloc_text( PAGE, InterfaceReference )
#pragma alloc_text( PAGE, InterfaceDereference )


VOID 
InterfaceReference(
    IN PEPDBUFFER EpdBuffer
    )

/*++

Routine Description:
    This is the standard bus interface reference function.

Arguments:
    IN PEPDBUFFER EpdBuffer -
        pointer to the EPD instance buffer
        
Return:
    Nothing.

--*/

{
    PAGED_CODE();
    
    _DbgPrintF( DEBUGLVL_BLAB, ("Referencing interface") );
    InterlockedIncrement( &EpdBuffer->InterfaceReferenceCount );
}


VOID 
InterfaceDereference(
    IN PEPDBUFFER EpdBuffer
    )

/*++

Routine Description:
    This is the standard bus interface dereference function.

Arguments:
    IN PEPDBUFFER EpdBuffer -
        pointer to the EPD instance buffer
        
Return:
    Nothing.

--*/

{
    PAGED_CODE();
    _DbgPrintF( DEBUGLVL_BLAB,("Dereferencing interface") );
    InterlockedDecrement( &EpdBuffer->InterfaceReferenceCount );
}


NTSTATUS
KsDspMapModuleName(
    IN PEPDBUFFER EpdBuffer,
    IN PUNICODE_STRING ModuleName,
    OUT PUNICODE_STRING ImageName,
    OUT PULONG ResourceId,
    OUT PULONG ValueType
    )   
{
    //
    // BUGBUG! Need to validate EpdBuffer
    //

    return KsMapModuleName( 
                EpdBuffer->PhysicalDeviceObject,
                ModuleName,
                ImageName,
                ResourceId,
                ValueType );
}


NTSTATUS
KsDspPrepareChannelMessage(
    IN PEPDBUFFER EpdBuffer,
    IN PIRP Irp,
    IN KSDSPCHANNEL Channel,
    IN KSDSP_MSG MessageId,
    IN OUT PVOID MessageFrame,
    IN ULONG MessageDataLength,
    IN va_list ArgList
    )
{
    NTSTATUS    Status;
    PEPDCTL     EpdControl;

    EpdControl = (PEPDCTL) MessageFrame;
    EpdControl->RequestType = EPDCTL_KSDSP_MESSAGE;
    EpdControl->AssociatedIrp = Irp;
    EpdControl->MessageId = MessageId;
    
    switch (MessageId) {

    case KSDSP_MSG_OPEN_DATA_CHANNEL:
    {
        ULONG               PinId;
        EDD_KSDSP_MESSAGE   *OpenDataChannel;

        //
        // Params: ULONG PinId
        //

        PinId = va_arg( ArgList, ULONG );

        OpenDataChannel = 
            (EDD_KSDSP_MESSAGE *)EpdControl->pNode->VirtualAddress;
        OpenDataChannel->Node.Destination = Channel;
        OpenDataChannel->Node.ReturnQueue = 0;
        OpenDataChannel->Node.Request = MessageId;
        OpenDataChannel->Node.Result = 0;
        *(PULONG)(&OpenDataChannel->Data) = PinId;
        Status = STATUS_SUCCESS;
        break;
    }

    case KSDSP_MSG_CLOSE_DATA_CHANNEL:
    {
        EDD_KSDSP_MESSAGE *CloseDataChannel;

        CloseDataChannel = 
            (EDD_KSDSP_MESSAGE *)EpdControl->pNode->VirtualAddress;
        CloseDataChannel->Node.Destination = Channel;
        CloseDataChannel->Node.ReturnQueue = 0;
        CloseDataChannel->Node.Request = MessageId;
        CloseDataChannel->Node.Result = 0;
        Status = STATUS_SUCCESS;
        break;
    }

    case KSDSP_MSG_SET_CHANNEL_STATE:
    {
        KSSTATE             State;
        EDD_KSDSP_MESSAGE   *SetChannelState;

        //
        // Params: KSSTATE State
        //

        State = va_arg( ArgList, KSSTATE );

        SetChannelState = 
            (EDD_KSDSP_MESSAGE *)EpdControl->pNode->VirtualAddress;
        SetChannelState->Node.Destination = Channel;
        SetChannelState->Node.ReturnQueue = 0;
        SetChannelState->Node.Request = MessageId;
        SetChannelState->Node.Result = 0;
        *(PKSSTATE)(&SetChannelState->Data) = State;
        Status = STATUS_SUCCESS;
        break;
    }

    case KSDSP_MSG_SET_CHANNEL_FORMAT:
    {
        PKSDATAFORMAT       DataFormat;
        EDD_KSDSP_MESSAGE   *SetChannelFormat;

        //
        // Params: PKSDATAFORMAT DataFormat
        //

        DataFormat = va_arg( ArgList, PKSDATAFORMAT );

        SetChannelFormat = 
            (EDD_KSDSP_MESSAGE *)EpdControl->pNode->VirtualAddress;
        SetChannelFormat->Node.Destination = Channel;
        SetChannelFormat->Node.ReturnQueue = 0;
        SetChannelFormat->Node.Request = MessageId;
        SetChannelFormat->Node.Result = 0;
        RtlCopyMemory( &SetChannelFormat->Data, DataFormat, DataFormat->FormatSize );
        Status = STATUS_SUCCESS;
        break;
    }

    default:
        Status = STATUS_INVALID_PARAMETER_4;
        break;

    }
    return Status;
}
    

NTSTATUS
KsDspPrepareMessage(
    IN PEPDBUFFER EpdBuffer,
    IN PIRP Irp,
    IN KSDSP_MSG MessageId,
    IN OUT PVOID MessageFrame,
    IN ULONG MessageDataLength,
    va_list ArgList
    )
{
    NTSTATUS    Status;
    PEPDCTL     EpdControl;

    EpdControl = (PEPDCTL) MessageFrame;
    EpdControl->RequestType = EPDCTL_KSDSP_MESSAGE;
    EpdControl->AssociatedIrp = Irp;
    EpdControl->MessageId = MessageId;
    
    switch (MessageId) {

    case KSDSP_MSG_LOAD_TASK:
    {
        ANSI_STRING         AnsiTaskName;
        PUNICODE_STRING     TaskName;
        EDD_LOAD_LIBRARY    *LoadLibrary;

        //
        // Params: PUNICODE_STRING TaskName
        //

        TaskName = va_arg( ArgList, PUNICODE_STRING );
        RtlUnicodeStringToAnsiString( &AnsiTaskName, TaskName, TRUE );

        LoadLibrary = 
            (EDD_LOAD_LIBRARY *)EpdControl->pNode->VirtualAddress;
        LoadLibrary->Node.Destination = EDD_REQUEST_QUEUE;
        LoadLibrary->Node.ReturnQueue = 0;
        LoadLibrary->Node.Request = EDD_LOAD_LIBRARY_REQUEST;
        LoadLibrary->Node.Result = 0;
        LoadLibrary->IUnknown = 0;
        LoadLibrary->IQueue = 0;
        strcpy( LoadLibrary->Name, AnsiTaskName.Buffer );
        RtlFreeAnsiString( &AnsiTaskName );
        Status = STATUS_SUCCESS;
    }
    break;

    case KSDSP_MSG_FREE_TASK:
    {
        EDD_FREE_LIBRARY    *FreeLibrary;
        PEPDTASKCONTEXT     TaskContext;

        //
        // Params: PVOID TaskContext
        //

        TaskContext = va_arg( ArgList, PEPDTASKCONTEXT );

        FreeLibrary = 
            (EDD_FREE_LIBRARY *)EpdControl->pNode->VirtualAddress;

        FreeLibrary->Node.Destination = EDD_REQUEST_QUEUE;
        FreeLibrary->Node.ReturnQueue = 0;
        FreeLibrary->Node.Request = EDD_FREE_LIBRARY_REQUEST;
        FreeLibrary->Node.Result = 0;
        FreeLibrary->IUnknown = TaskContext->IUnknown;
        FreeLibrary->IQueue = TaskContext->IQueue;
        Status = STATUS_SUCCESS;
    }
    break;
    
    case KSDSP_MSG_PROPERTY:
    case KSDSP_MSG_METHOD:
    case KSDSP_MSG_SET_TARGET_CHANNEL:
        Status = STATUS_NOT_IMPLEMENTED;
        break;

    default:
        Status = STATUS_INVALID_PARAMETER_3;
    }

    return Status;
}

NTSTATUS
KsDspStreamMapping(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp, 
    IN PVOID MapRegisterBase,
    IN PVOID Context
    )
{
    EDD_STREAM_IO       *StreamIo;
    PEPDBUFFER          EpdBuffer;
    PEPDCTL             EpdControl;
    PHYSICAL_ADDRESS    PhysAddr;
    PVOID               CurrentVa;
    ULONG               i, TotalLength, MappingLength, MaxEntries;

    EpdControl = (PEPDCTL) Context;
    EpdBuffer = DeviceObject->DeviceExtension;

    StreamIo = (EDD_STREAM_IO *) (EpdControl->pNode->VirtualAddress);
    EpdControl->MapRegisterBase = MapRegisterBase;

    CurrentVa = MmGetMdlVirtualAddress( EpdControl->Mdl );

    EpdControl->CurrentVa  = CurrentVa;
    MappingLength = StreamIo->Length;
    MaxEntries = MappingLength / PAGE_SIZE + 1;

    TotalLength = MappingLength;
    for (i = 0; TotalLength &&  (i < MaxEntries); i++) {
        PhysAddr = 
            IoMapTransfer(
                EpdBuffer->BusMasterAdapterObject,
                EpdControl->Mdl,
                MapRegisterBase,
                CurrentVa,
                &MappingLength, 
                (BOOLEAN)(EpdControl->MessageId == KSDSP_MSG_WRITE_STREAM));

        StreamIo->ScatterGatherTable[ i ].PhysAddr = PhysAddr.LowPart;
        StreamIo->ScatterGatherTable[ i ].ByteCount = MappingLength;
        _DbgPrintF( 
            DEBUGLVL_VERBOSE, 
            ("dword (@%x): %x", PhysAddr.LowPart, *(PULONG)CurrentVa) );
        CurrentVa = (PCHAR)CurrentVa + MappingLength;
        TotalLength -= MappingLength;
        MappingLength = TotalLength;
    }

    StreamIo->Entries = i - 1;

    // call KeFlushIoBuffers BEFORE a write

    if (EpdControl->MessageId == KSDSP_MSG_WRITE_STREAM) {
        KeFlushIoBuffers( EpdControl->Mdl, TRUE, TRUE );
    }

    return DeallocateObjectKeepRegisters;
}

NTSTATUS
KsDspMapDataTransfer(
    IN PEPDBUFFER EpdBuffer,
    IN PIRP Irp,
    IN KSDSPCHANNEL Channel,
    IN KSDSP_MSG MessageId,
    IN OUT PVOID MessageFrame,
    IN PMDL Mdl
    )
{
    EDD_STREAM_IO   *StreamIo;
    KIRQL           irqlOld;
    NTSTATUS        Status;
    PEPDCTL         EpdControl;

    EpdControl = (PEPDCTL) MessageFrame;
    StreamIo = (EDD_STREAM_IO *)EpdControl->pNode->VirtualAddress;

    EpdControl->RequestType = EPDCTL_KSDSP_MESSAGE;
    EpdControl->AssociatedIrp = Irp;
    EpdControl->MessageId = MessageId;
    EpdControl->Mdl = Mdl;

    EpdControl->MapRegisters = 0;
    StreamIo->Length = 0;
    while (Mdl) {
        StreamIo->Length += MmGetMdlByteCount( Mdl );
        EpdControl->MapRegisters +=
            ADDRESS_AND_SIZE_TO_SPAN_PAGES( 
                MmGetSystemAddressForMdl( Mdl ),
                MmGetMdlByteCount( Mdl ) );
        Mdl = Mdl->Next;
    }
    Mdl = EpdControl->Mdl;

    StreamIo->Node.Destination = Channel;
    StreamIo->Node.ReturnQueue = 0;
    StreamIo->Node.Request = MessageId;
    StreamIo->Node.Result = 0;

    //
    // Map the I/O buffers, filling the scatter/gather table.
    //

    KeRaiseIrql( DISPATCH_LEVEL, &irqlOld );

    Status = 
        IoAllocateAdapterChannel(
            EpdBuffer->BusMasterAdapterObject,  
            EpdBuffer->FunctionalDeviceObject,
            EpdControl->MapRegisters,
            KsDspStreamMapping,
            EpdControl );

    KeLowerIrql( irqlOld );

    if (!NT_SUCCESS( Status )) {
        _DbgPrintF(DEBUGLVL_VERBOSE,("IoAllocateAdapterChannel failed"));
        return Status;
    }

    return Status;
}

NTSTATUS
KsDspUnmapDataTransfer(
    IN PEPDBUFFER EpdBuffer,
    IN PVOID MessageFrame
    )
{
    BOOLEAN         Result;
    EDD_STREAM_IO   *StreamIo;
    PEPDCTL         EpdControl;

    EpdControl = (PEPDCTL) MessageFrame;
    StreamIo = (EDD_STREAM_IO *)EpdControl->pNode->VirtualAddress;

    // call KeFlushIoBuffers AFTER a read

    if (EpdControl->MessageId == KSDSP_MSG_READ_STREAM) {
        KeFlushIoBuffers( EpdControl->Mdl, TRUE, TRUE );
    }

    // Clean out the adapter map registers 

    Result = 
        IoFlushAdapterBuffers(
            EpdBuffer->BusMasterAdapterObject,
            EpdControl->Mdl,
            EpdControl->MapRegisterBase,
            EpdControl->CurrentVa,
            StreamIo->Length, 
            (BOOLEAN)(EpdControl->MessageId == KSDSP_MSG_WRITE_STREAM) );

    ASSERT( Result );

    IoFreeMapRegisters( 
        EpdBuffer->BusMasterAdapterObject,
        EpdControl->MapRegisterBase,
        EpdControl->MapRegisters );

    return STATUS_SUCCESS;
}


NTSTATUS
KsDspSendMessage(
    IN PEPDBUFFER EpdBuffer,
    IN PIRP Irp
    )
{
    return IoCallDriver( EpdBuffer->FunctionalDeviceObject, Irp );
}


NTSTATUS
KsDspAllocateMessageFrame(
    IN PEPDBUFFER EpdBuffer,
    IN KSDSP_MSG MessageId,
    OUT PVOID *MessageFrame,
    IN OUT PULONG MessageDataLength    
    )
{
    PEPDCTL EpdControl;

    //
    // Compute the maximum length for input/output data for this
    // message.
    // 

    switch (MessageId) {

        //
        // include the size of the EDD structure, subtract out the
        // size of a QUEUENODE, this is replaced by the EPDQUEUENODE
        // header.
        //

    case KSDSP_MSG_WRITE_STREAM:
    case KSDSP_MSG_READ_STREAM:
        *MessageDataLength +=
            FIELD_OFFSET( EDD_STREAM_IO, ScatterGatherTable ) - sizeof( QUEUENODE );
            break;

    case KSDSP_MSG_SET_CHANNEL_STATE:
    case KSDSP_MSG_SET_CHANNEL_FORMAT:
    case KSDSP_MSG_OPEN_DATA_CHANNEL:
    case KSDSP_MSG_CLOSE_DATA_CHANNEL:
        *MessageDataLength +=
            FIELD_OFFSET( EDD_KSDSP_MESSAGE, Data ) - sizeof( QUEUENODE );
        break;

    case KSDSP_MSG_LOAD_TASK:
        *MessageDataLength += 
            sizeof( EDD_LOAD_LIBRARY ) - sizeof( QUEUENODE );
        break;

    case KSDSP_MSG_FREE_TASK:
        *MessageDataLength = 
            sizeof( EDD_FREE_LIBRARY ) - sizeof( QUEUENODE );
        break;
    }

    //
    // Allocate an EPD control structure (e.g. MessageFrame)
    //

    EpdControl = 
        EpdAllocEpdCtl(
            *MessageDataLength + sizeof( EPDQUEUENODE ),
            NULL,
            EpdBuffer );

    if (!EpdControl) {
        _DbgPrintF(
            DEBUGLVL_VERBOSE,("EpdAllocEpdCtl failed in KsDspAllocateMessageFrame"));
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    *MessageFrame = EpdControl;

    return STATUS_SUCCESS;
}


NTSTATUS 
MapMsgResultToNtStatus( 
    IN UINT32 MsgResult 
    )
{
    //
    // BUGBUG! May need a more sophisticated lookup table here...
    //

    //
    // SCODEs are defunct and are simply HRESULTS.
    //
    return (NTSTATUS) MsgResult;
}


NTSTATUS
KsDspGetControlChannel(
    IN PEPDBUFFER EpdBuffer,
    IN PVOID TaskContext,
    OUT PKSDSPCHANNEL ControlChannel
    )

/*++

Routine Description:
    returns the control channel identifier for a given task context

Arguments:
    IN PEPDBUFFER EpdBuffer
        EPD instance context

    IN PVOID TaskContext -
        task context as returned from GetMessageResult() for the
        KSDSP_MSG_LOAD_TASK message

    OUT PKSDSPCHANNEL ControlChannel -
        pointer to resultant control channel identifier

Return:

--*/

{
    NTSTATUS Status;

    try {
        *ControlChannel = ((PEPDTASKCONTEXT)TaskContext)->IQueue;
        Status = STATUS_SUCCESS;
    } except (EXCEPTION_EXECUTE_HANDLER) {
        Status = GetExceptionCode();
    }
    return Status;
}
    

NTSTATUS
KsDspGetMessageResult(
    IN PEPDBUFFER EpdBuffer,
    IN PVOID MessageFrame,
    OUT PVOID Result OPTIONAL
    )
{

    NTSTATUS    Status;
    PEPDCTL     EpdControl;

    EpdControl = (PEPDCTL) MessageFrame;

    switch (EpdControl->MessageId) {

    case KSDSP_MSG_LOAD_TASK:
    {
        EDD_LOAD_LIBRARY    *LoadLibrary;

        if (ARGUMENT_PRESENT( Result )) {
            *(PVOID *)Result = NULL;
        }

        LoadLibrary = 
            (EDD_LOAD_LIBRARY *)EpdControl->pNode->VirtualAddress;

        Status = MapMsgResultToNtStatus( LoadLibrary->Node.Result );
        if (NT_SUCCESS( Status )) {
            PEPDTASKCONTEXT EpdTaskContext;

            EpdTaskContext =
                ExAllocatePoolWithTag( 
                    PagedPool,
                    sizeof( EPDTASKCONTEXT ),
                    EPD_TASKCONTEXT_SIGNATURE );
            if (!EpdTaskContext) {
                Status = STATUS_INSUFFICIENT_RESOURCES;
            } else {
                EpdTaskContext->IUnknown = LoadLibrary->IUnknown;
                EpdTaskContext->IQueue = LoadLibrary->IQueue;
                *(PVOID *)Result = EpdTaskContext;
            }
        }
    }
    break;

    case KSDSP_MSG_OPEN_DATA_CHANNEL:
    {
        EDD_KSDSP_MESSAGE   *OpenDataChannel;

        OpenDataChannel =
            (EDD_KSDSP_MESSAGE *)EpdControl->pNode->VirtualAddress;
        Status = MapMsgResultToNtStatus( OpenDataChannel->Node.Result );
        if (NT_SUCCESS( Status )) {
            *(PKSDSPCHANNEL)Result = *(PKSDSPCHANNEL)&OpenDataChannel->Data;
        }
    }
    break;

    case KSDSP_MSG_SET_CHANNEL_STATE:
    case KSDSP_MSG_SET_CHANNEL_FORMAT:
    case KSDSP_MSG_FREE_TASK:
    case KSDSP_MSG_CLOSE_DATA_CHANNEL:
    {
        EDD_KSDSP_MESSAGE   *KsDspMessage;

        //
        // These messages do not have data associated, just translate
        // the return code.
        //

        KsDspMessage =
            (EDD_KSDSP_MESSAGE *)EpdControl->pNode->VirtualAddress;
        Status = MapMsgResultToNtStatus( KsDspMessage->Node.Result );
    }
    break;

    default:
        Status = STATUS_INVALID_DEVICE_REQUEST;
    }

    return Status;
    
}


VOID
KsDspFreeMessageFrame(
    IN PEPDBUFFER EpdBuffer,
    IN PVOID MessageFrame
    )
{
    FreeIoPool( MessageFrame );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\ksfilter\ksdsp\epd\loader.c ===
/*
 * MMLite loader for TM1, Life image format.
 */

#include "private.h"
#include "dspkinit.h"

#if 1
#define C4ToNum(_c4_,_n_) (_n_) = ( ((_c4_)[3]      ) \
                                  | ((_c4_)[2] << 8 ) \
                                  | ((_c4_)[1] << 16) \
                                  | ((_c4_)[0] << 24) )

#define C3ToNum(_c4_,_n_) (_n_) = ( ((_c4_)[2]      ) \
                                  | ((_c4_)[1] << 8 ) \
                                  | ((_c4_)[0] << 16) )

#define C2ToNum(_c4_,_n_) (_n_) = ( ((_c4_)[1]      ) \
                                  | ((_c4_)[0] << 8 ) )

#define NumToC4(_n_,_c4_) { (_c4_)[3] = (BYTE)(((_n_)      ) & 0xff); \
                            (_c4_)[2] = (BYTE)(((_n_) >>  8) & 0xff); \
                            (_c4_)[1] = (BYTE)(((_n_) >> 16) & 0xff); \
                            (_c4_)[0] = (BYTE)(((_n_) >> 24) & 0xff); \
                          }
#else   /* This doesn't work due to endianness problem. Look into bswap instruction? */
#define C4ToNum(_c4_,_n_) (_n_) =*(ULONG *)(_c4_)
#define C3ToNum(_c4_,_n_) (_n_) = *(ULONG *)(_c4_) & 0x00FFFFFF
#define C2ToNum(_c4_,_n_) (_n_) = *(USHORT *)(_c4_)
#define NumToC4(_n_,_c4_) *(ULONG *)(_c4_) = (_n_)
#endif

typedef struct _LIFE_HEADER {
    BYTE Signature[8];  /*  "LIFE_Obj"  */
    BYTE Version[2];
    BYTE VersionStr[3];
    BYTE MachineStr[3];
    BYTE Check[4];
    BYTE Flags[2];
    BYTE StartSection;
    BYTE StartHigh[4];
    BYTE StartLow[4];
    BYTE BinaryOffset[4];
    BYTE SourceOffset[4];
    BYTE Length[4];
    BYTE StrTableOffset[4];
    BYTE StrTableSize[3];
    BYTE SctTableOffset[4];
    BYTE SctTableSize[1];
    BYTE SymTableOffset[4];
    BYTE SymTableSize[3];
    BYTE HistoryOffset[4];
    BYTE HistorySize[4];
    BYTE SrcTableOffset[4];
    BYTE SrcTableSize[2];
    BYTE ScatterTableOffset[4];
    BYTE ScatterTableSize[4];
    BYTE pad[44]; /* that makes it 128 bytes total */
} LIFE_HEADER;

typedef struct _LIFE_SECTION {
    BYTE Name[3];
    BYTE BaseAddrHigh[4];
    BYTE BaseAddrLow[4];
    BYTE SizeHigh[4];
    BYTE SizeLow[4];
    BYTE BlockSize[4];
    BYTE MemWidth[2];
    BYTE BitsOffset[4];
    BYTE BitsSize[4];
    BYTE RefTableOffset[4];
    BYTE RefTableSize[4];
} LIFE_SECTION;

typedef struct _LIFE_SYMBOL {
    BYTE Name[3];
    BYTE RelType[1];
    BYTE Section[1];
    BYTE Alignment[4];
    BYTE ValueHigh[4];
    BYTE ValueLow[4];
} LIFE_SYMBOL;

typedef struct _LIFE_SOURCE {
    BYTE Name[3];
    BYTE LmapOffset[4];
    BYTE LmapSize[1];
    BYTE SymtOffset[4];
    BYTE SymtSize[3];
    BYTE DebugOffset[4];
    BYTE DebugSize[4];
} LIFE_SOURCE;

typedef struct _LIFE_TRIPLE {
    BYTE DstOffset[4];
    BYTE Width[4];
    BYTE SrcOffset[4];
} LIFE_TRIPLE;

typedef struct _LIFE_SCATTER_ENTRY {
    BYTE NumTriples[4];
    LIFE_TRIPLE Triples[1];
} LIFE_SCATTER_ENTRY;

typedef struct _LIFE_SCATTER {
    BYTE NumDescriptors[4];
    LIFE_SCATTER_ENTRY Entries[1];
} LIFE_SCATTER;

typedef struct _LIFE_LINK_MAP {
    BYTE Section[1];
    BYTE BaseAddrHigh[4];
    BYTE BaseAddrLow[4];
    BYTE SizeAddrHigh[4];
    BYTE SizeAddrLow[4];
} LIFE_LINK_MAP;

typedef struct _LIFE_DEBUG_HEADER {
    BYTE Version[1];
    BYTE Reserved[3];
    BYTE StringTableSize[4];
    BYTE StabsTableSize[4];
    BYTE LinesTableSize[4];
    BYTE RefTableSize[4];
} LIFE_DEBUG_HEADER;

typedef struct _LIFE_REF_TABLE {
    BYTE Position[4];
    BYTE ScatterId[4];
    BYTE RelocationType[1];
    BYTE Section[1];
    BYTE Symbol[3];
    BYTE Source [2];
} LIFE_REF_TABLE;

NTSTATUS 
LifeLdrImageSize(
    PUCHAR ImageBase,
    ULONG *pImageSize
    )

/*++

Routine Description:


Arguments:
    PUCHAR ImageBase -

    ULONG *pImageSize -

Return:

--*/

{
    NTSTATUS Status;        /* Return code */
    HANDLE FileHandle;      /* Handle to image file */
    ULONG ScnOffset;        /* Offset to section table */
    INT   nSections;        /* Number of sections in section table */
    ULONG ImageBaseAddr;    /* Base address of image */
    ULONG LastScnBaseAddr;  /* Base address of last section in image */
    ULONG LastScnSize;      /* Size of last section in image */
    LIFE_SECTION *pScn;     /* Pointer to section table */
    ULONG BytesRead;        /* BytesRead (for reading header) */

    LIFE_HEADER Hdr;        /* 128 byte image header (on stack) */
    /* Read in the file header */

    Hdr = *(LIFE_HEADER *)ImageBase;

    /* How many sections do we have */
    nSections = Hdr.SctTableSize[0];

    /* Get offset to section table */
    C4ToNum(Hdr.SctTableOffset,ScnOffset);
    ScnOffset += sizeof(LIFE_HEADER); /* relative to header */

    _DbgPrintF(DEBUGLVL_VERBOSE,("Section Table at file x%x, x%x entries", ScnOffset, nSections));

    /* Read section table */
    pScn  = (LIFE_SECTION *) &ImageBase[ ScnOffset ];

    /* Get base address of first, last sections & size of last section */
    C4ToNum(pScn[    0      ].BaseAddrLow,ImageBaseAddr);
    C4ToNum(pScn[nSections-1].BaseAddrLow,LastScnBaseAddr );
    C4ToNum(pScn[nSections-1].SizeLow    ,LastScnSize     );

    /* Compute how much memory we need for this image. */
    *pImageSize = (LastScnBaseAddr - ImageBaseAddr) + LastScnSize;
    _DbgPrintF(DEBUGLVL_VERBOSE,("Image needs %d bytes",*pImageSize));

    return STATUS_SUCCESS;
}

/* Init Scatter Entry Map
 */
LIFE_SCATTER_ENTRY **LifeLdrInitScatterEntryMap(LIFE_SCATTER *pS)
{
  ULONG i, n, NumDescriptors;
  LIFE_SCATTER_ENTRY *pSe;
  LIFE_SCATTER_ENTRY **pScatMap;

  /* Find out how many scatter table entries there are */
  C4ToNum(pS->NumDescriptors,NumDescriptors);

  /* Allocate an array to hold a ptr to each entry */
  pScatMap = 
    ExAllocatePoolWithTag(
        PagedPool,
        NumDescriptors * sizeof(LIFE_SCATTER_ENTRY *), 
        EPD_LDR_SIGNATURE );
  if (!pScatMap) 
      return NULL;

  /* Initialize the array */
  pScatMap[0] = pSe = &pS->Entries[0];
  for (i = 1; i < NumDescriptors; i++) 
  {
    C4ToNum(pSe->NumTriples,n);
    pScatMap[i] = pSe = (LIFE_SCATTER_ENTRY *)(&pSe->Triples[n]);
  }
  return pScatMap;
}

/* Relocate one section.
 */
INT LifeLdrPerformLifeRelocs(
    int Addendum,
    ULONG RelSize,
    LIFE_REF_TABLE *pRefTab,
    LIFE_SCATTER_ENTRY **pScatMap,
    BYTE *pBits,
    ULONG *pRtlTable)
{
    ULONG pos, idx, nTrip;
    ULONG i, j;
    LIFE_SCATTER_ENTRY *pSe;
    LIFE_TRIPLE *pT;
    ULONG Value;

    //_DbgPrintF(DEBUGLVL_VERBOSE,("Relocating bits at x%x by x%x", pBits, Addendum));

    /* Read one relocation at a time, and do it.
    */
    for (i = 0; i < RelSize; i++,pRefTab++) 
    {
        C4ToNum(pRefTab->Position,pos);
        C4ToNum(pRefTab->ScatterId,idx);

        pSe = pScatMap[idx];

        C4ToNum(pSe->NumTriples,nTrip);
        //_DbgPrintF(DEBUGLVL_VERBOSE,(" Rel %d at x%x, scattid %d, %d triples.", i, pos, idx, nTrip));

        /* Poor man's DLL mechanism for the kernel.
        */
#define MAGIC_SECTION 0xff
        if (pRefTab->Section[0] == MAGIC_SECTION) 
        {

            /* This is a kernel reference. The ordinal of this RTL reference
             * is found in the Source field. Lookup in the RtlTable the
             * address that this ordinal should expand to.
             */
            if (pRtlTable)
            {
                C2ToNum(pRefTab->Source,j);
                Value = pRtlTable[j];
            }
            else
            {
                _DbgPrintF(DEBUGLVL_VERBOSE,("!!!No RTL Table specified!!!"));
            }
            // _DbgPrintF(DEBUGLVL_VERBOSE,("Found an RTL patch entry, patching entry %d to 0x%x...",j,Value));

        }
        else 
        {
            /* This is a regular reference. Pick up them bitsies and relocate.
            */
            Value = 0;
            pT = &pSe->Triples[0];

            /* Go through all triples
            */
            for (j = 0; j < nTrip; j++) 
            {

                ULONG dst, w, src;
                ULONG tmp, mask;
                BYTE *pTmp;

                C4ToNum(pT->DstOffset,dst);
                C4ToNum(pT->Width,w);
                C4ToNum(pT->SrcOffset,src);

                src += pos;            /* in bits  */
                pTmp = &pBits[src >> 3];    /* in bytes */
                C4ToNum(pTmp,tmp);        /* 32 bits sorrounding */

                /* Build mask
                * NB: bit '0' is infact the MSB.
                */
                mask = 0xffffffff >> (32 - w);     /* w == 0 cantbe */
                mask <<= (32 - w) - (src & 7);    /* mask in place */

                tmp = tmp & mask;        /* pick them up */
                tmp >>= (32 - w) - (src & 7);    /* line them up */
                Value |= tmp << ((32 - w) - dst);/* stick them in */

                /* Done with this triple
                */
                pT++;
            }

            //_DbgPrintF(DEBUGLVL_VERBOSE,("(value in bitfield)             0x%08x    %8.d  (32 bits)",Value,Value));

            /* Now we got the original value, relocate it.
            */
            Value += Addendum;
        }

        /* Now we do it all over again, in reverse
        */
        pT = &pSe->Triples[0];

        for (j = 0; j < nTrip; j++) 
        {
            ULONG dst, w, src;
            ULONG tmp, tmp1, mask, mask1;
            BYTE *pTmp;

            C4ToNum(pT->DstOffset,dst);
            C4ToNum(pT->Width,w);
            C4ToNum(pT->SrcOffset,src);
            src += pos;            /* in bits  */
            pTmp = &pBits[src >> 3];    /* in bytes */
            C4ToNum(pTmp,tmp);        /* 32 bits sorrounding */

            /* Build masks
             * NB: bit '0' is infact the MSB.
             */
            mask = 0xffffffff >> (32 - w);     /* w == 0 cantbe */
            mask1 = mask << ((32 - w) - dst);
            mask <<= (32 - w) - (src & 7);    /* masks in place */

            tmp &= ~mask;            /* drop them olds */

                            /* add them new */
            tmp1 = (Value & mask1) >> ((32 - w) - dst);
            tmp1 <<= (32 - w) - (src & 7);

            tmp |= tmp1;            /* added in */

            /* Now for writing them back...
             */
            NumToC4(tmp,pTmp);

            /* Done with this triple
            */
            pT++;
        }
    }

    return 0;
}

NTSTATUS 
LifeLdrImageLoad(
    PEPDBUFFER EpdBuffer,
    PUCHAR ImageBase,
    char *pImage,
    ULONG *pRtlTable,
    PULONG32 ImageEntryPointPtr,
    PCHAR *DataSectionVa,
    int *pIsDLL
    )

/*++

Routine Description:

    [in] host virt ptr to DSP mem
    [in] ptr to RTL table. NULL if no RTL Table 
    [out] DSP ptr to location to return entry point 
    [out] host Va to location to return data section
    [out] ptr to location to return bool (1->is a dll)


Arguments:
    PEPDBUFFER EpdBuffer -

    PUCHAR ImageBase -

    char *pImage -

    ULONG *pRtlTable -

    PULONG32 ImageEntryPointPtr -

    PCHAR *DataSectionVa -

    int *pIsDLL -

Return:

--*/
{

    NTSTATUS Status;    /* Status return code */
    INT nSections;      /* Number of sections in image */
    ULONG SectionTableOffset;    /* Offset to section table */
    ULONG ScatterTableOffset;    /* Offset to scatter table */
    ULONG SctSize;      /* Size of scatter table */
    ULONG BinpOffset;   /* Offset to binary partition */
    LIFE_SECTION *SectionTable;     /* Pointer to section table */
    LIFE_SCATTER *ScatterTable;    /* Pointer to scatter table */
    LIFE_SCATTER_ENTRY **ScatterMap; /* Map into scatter table */
    ULONG ImageBaseAddr;    /* Image base address */
    LONG32 iScn;               /* Iterator over sections */
    LONG32 Relocation;         /* Difference between link & actual base address */
    ULONG32 pImageEntryPoint;   /* Image entry point */
    PCHAR pDataSection;       /* Host Va to data section */
    int IsDLL;              /* Bool, TRUE->image is a DLL */
    ULONG BytesRead;

    LIFE_HEADER Hdr;    /* 128 byte image header (on stack) */
    int i;

    Hdr = *(LIFE_HEADER *)ImageBase;

    C2ToNum(Hdr.Flags,i);
    IsDLL = ((i & 0x0001) != 0);

    /* How many sections do we have */
    nSections = Hdr.SctTableSize[0];

    /* Get offset to section table */
    C4ToNum(Hdr.SctTableOffset,SectionTableOffset);
    SectionTableOffset += sizeof(LIFE_HEADER); /* relative to header */

    _DbgPrintF(DEBUGLVL_VERBOSE,("Section Table at file x%x, x%x entries", SectionTableOffset, nSections));

    /* Get offset to scatter table */
    C4ToNum(Hdr.ScatterTableOffset,ScatterTableOffset);
    ScatterTableOffset += sizeof(LIFE_HEADER);
    C4ToNum(Hdr.ScatterTableSize,SctSize);
    _DbgPrintF(DEBUGLVL_VERBOSE,("Scatter Table at file x%x, x%x bytes", ScatterTableOffset, SctSize));

    /* Get offset to binary partition   */
    C4ToNum(Hdr.BinaryOffset,BinpOffset);
    _DbgPrintF(DEBUGLVL_VERBOSE,("Binary section at file x%x", BinpOffset));

    /* Where is the program's entry point */
    C4ToNum(Hdr.StartLow,(int)pImageEntryPoint);
    _DbgPrintF(DEBUGLVL_VERBOSE,("Entry point at x%x", pImageEntryPoint));
    
    /* Read section table & scatter table */
    SectionTable  = (LIFE_SECTION *) &ImageBase[ SectionTableOffset ];
    ScatterTable = (LIFE_SCATTER *) &ImageBase[ ScatterTableOffset ];

    ScatterMap = LifeLdrInitScatterEntryMap(ScatterTable);
    if (!ScatterMap) {
        return STATUS_UNSUCCESSFUL;
    }

    /* Get base address of first, last sections & size of last section */
    C4ToNum(SectionTable[0].BaseAddrLow,ImageBaseAddr);

    /* Assume base link address is start of first section (text) */
    Relocation = HostToDspMemAddress(EpdBuffer, pImage) - ImageBaseAddr;

    /* Read Image in, one section at a time, and relocate */
    for (iScn = 0; iScn < nSections; iScn++) 
    {
        ULONG ScnBaseAddr;  /* Link base address of this section */
        PCHAR ScnLoadAddr;  /* Relocated load address of this section */
        ULONG BitsSize;     /* Section data in file */
        ULONG ScnSize;      /* Size of section footprint in exe */

        // Get section base address and convert to 
        // relocated host virtual address

        C4ToNum(SectionTable[iScn].BaseAddrLow,ScnBaseAddr);
        ScnLoadAddr = pImage + (ScnBaseAddr - ImageBaseAddr);

        C4ToNum(SectionTable[iScn].BitsSize,BitsSize);
        C4ToNum(SectionTable[iScn].SizeLow, ScnSize);

        if (BitsSize) {
            // If section has data, read it in

            ULONG RefTableSize, RefTableOffset;
            LIFE_REF_TABLE  *pRefTab;
            ULONG BitsOffset;

            C4ToNum(SectionTable[iScn].BitsOffset,BitsOffset);
            _DbgPrintF(DEBUGLVL_VERBOSE,("Section %d, copying %d bytes at x%x file@ x%x",iScn, ScnSize, ScnLoadAddr, BitsOffset + BinpOffset));

            RtlCopyMemory( 
                ScnLoadAddr, &ImageBase[ BitsOffset + BinpOffset ], ScnSize );

            if (iScn==2) {
                pDataSection=ScnLoadAddr;
            }

            /* Now relocate the section we just read in */
            _DbgPrintF(DEBUGLVL_VERBOSE,("Relocating section %d:", iScn));

            /* Only relocate if we have to */
            C4ToNum(SectionTable[iScn].RefTableSize,RefTableSize);
            if (RefTableSize)
            {
                C4ToNum(SectionTable[iScn].RefTableOffset,RefTableOffset);
                RefTableOffset += BinpOffset;
                _DbgPrintF(DEBUGLVL_VERBOSE,(" RefTable at file x%x, x%x entries", RefTableOffset, RefTableSize));

                pRefTab = 
                    (LIFE_REF_TABLE *) &ImageBase[ RefTableOffset ];

                LifeLdrPerformLifeRelocs(Relocation, RefTableSize, pRefTab, ScatterMap, ScnLoadAddr, pRtlTable);
            }
        }
        else if (ScnSize) /* No data in file, must be bss, zero memory */
        {
            _DbgPrintF(DEBUGLVL_VERBOSE,("Section %d, zeroing %d bytes at x%x",iScn, ScnSize, ScnLoadAddr));
            RtlZeroMemory (ScnLoadAddr, ScnSize);
        }
        /* else empty section */
    }

    if (ImageEntryPointPtr) {
        *ImageEntryPointPtr = pImageEntryPoint + Relocation;
    }        

    if (DataSectionVa) {
       *DataSectionVa = pDataSection;
    }        

    if (pIsDLL) {
        *pIsDLL = IsDLL;
    }

    Status = STATUS_SUCCESS;

    return Status;
}


NTSTATUS
LifeLdrLoadFile( 
    IN PUNICODE_STRING FileName,
    OUT PVOID *ImageBase
    )

/*++

Routine Description:


Arguments:
    IN PUNICODE_STRING FileName -

    OUT PVOID *ImageBase -

Return:

--*/

{
    HANDLE          FileHandle;
    NTSTATUS        Status;
    ULONG           FileLength;

    Status = EpdFileOpen( &FileHandle, FileName, O_RDONLY );
    if (!NT_SUCCESS (Status)) {
        return Status;
    }

    FileLength = EpdFileLength( FileHandle );
    *ImageBase = NULL;

    if (FileLength) {
        if (*ImageBase = ExAllocatePoolWithTag( PagedPool, FileLength, EPD_LDR_SIGNATURE )) {
            ULONG BytesRead;

            Status =
                EpdFileSeekAndRead( FileHandle, 0, SEEK_SET, *ImageBase, FileLength, &BytesRead );

            _DbgPrintF( DEBUGLVL_VERBOSE,("LifeLdrLoadFile: read returned %x", Status) );
            
            if (NT_SUCCESS( Status )) {
                if (BytesRead != FileLength) {
                    Status = STATUS_DATA_ERROR;
                }
            } 
            
            if (!NT_SUCCESS( Status )) {
                ExFreePool( *ImageBase );
                *ImageBase = NULL;
            }

        } else {
            Status = STATUS_INSUFFICIENT_RESOURCES;
        }
    }

    ZwClose( FileHandle );

    return Status;

}


NTSTATUS 
KernLdrLoadDspKernel(
    PEPDBUFFER EpdBuffer
    )
{
    UNICODE_STRING FileName, ImageName;
    DSPKERNEL_INITDATA *DspKerInitData;
    NTSTATUS Status;
    PHYSICAL_ADDRESS addrDebugBuf;
    PVOID ImageBase;
    ULONG32 DspImageSize, DspMemPhys, DspRegPhys;
    ULONG32 FileLength, ValueType;
    ULONG_PTR ResourceId;

    StopDSP( EpdBuffer );

    _DbgPrintF(DEBUGLVL_VERBOSE,("Ready to call LoadLifeImage"));

    RtlInitUnicodeString( &FileName, L"mmosa.exe" );

    ImageBase = NULL;

    Status =
        KsMapModuleName(
            EpdBuffer->PhysicalDeviceObject,
            &FileName,
            &ImageName,
            &ResourceId,
            &ValueType );

    if (NT_SUCCESS( Status )) {
        PVOID  FileBase;

        _DbgPrintF( DEBUGLVL_VERBOSE, ("mapped module: %S", ImageName.Buffer) );
        if (NT_SUCCESS( Status = LifeLdrLoadFile( &ImageName, &FileBase )  )) {
            Status = 
                KsLoadResource( 
                    FileBase, PagedPool, ResourceId, RT_RCDATA, &ImageBase, NULL );
            ExFreePool( FileBase );
        }
        if (ValueType == REG_SZ) {
            ExFreePool( (PVOID) ResourceId );
        }
        RtlFreeUnicodeString( &ImageName );
    }
        
    if (NT_SUCCESS( Status )) {
        Status = 
            LifeLdrImageSize (
                ImageBase,
                &DspImageSize );
    } else {
        _DbgPrintF( DEBUGLVL_ERROR, ("resource load failed: %08x", Status) );
        return Status;
    }

    if (NT_SUCCESS( Status )) {

        Status = 
            LifeLdrImageLoad (
                EpdBuffer,
                ImageBase,
                EpdBuffer->DspMemoryVa,
                NULL,   /* No RTL table */
                NULL,   /* Don't care about entry point */
                (PDSPMEM *)&DspKerInitData,
                NULL ); /* Don't care about dll flag */
    }

    ExFreePool( ImageBase );

    if (!NT_SUCCESS (Status)) {
        _DbgPrintF( DEBUGLVL_ERROR, ("image load failed: %08x", Status) );
        return Status;
    }        

    // Round up to nearest cache line?
    
    DspImageSize = (DspImageSize + 0x3F) & ~0x3F;

    DspMemPhys = HostToDspMemAddress( EpdBuffer, EpdBuffer->DspMemoryVa );
    DspRegPhys = HostToDspRegAddress( EpdBuffer, EpdBuffer->DspRegisterVa );

    // get the address of the board memory used to pass data
    DspKerInitData->end_bss    = DspMemPhys + DspImageSize;
    DspKerInitData->MMIO_base  = DspRegPhys;

    // Tell the DSP where the comm buffers are
    DspKerInitData->EPDRecvBuf    = (ULONG)EpdBuffer->pRecvBufHdr;
    DspKerInitData->EPDSendBuf    = (ULONG)EpdBuffer->pSendBufHdr;
    DspKerInitData->pDebugOutBuffer = EpdBuffer->pDebugOutBuffer;
    DspKerInitData->pDebugBuffer  = EpdBuffer->DebugBufferPhysicalAddress.LowPart;
 
    EpdBuffer->pRtlTable = 
        (ULONG *) DspToHostMemAddress( EpdBuffer, DspKerInitData->pRtlTable);
        
    DspKerInitData->HostVaBias = (LONGLONG) EpdBuffer->HostToDspMemOffset;
    
    // Tell the DSP what its clock frequency is (we should probably get this from the registry!)
    DspKerInitData->clock_freq    = 80000000;

    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\ksfilter\ksdsp\epd\ioctl.c ===
#include "private.h"

#ifndef max
#define max(_a_,_b_) ((_a_>_b_) ? (_a_) : (_b_))
#endif

// Allocates sizeof(EPDCTL) + Number of bytes passed in

PEPDCTL
EpdAllocEpdCtl (
    IN ULONG Size,
    IN PIRP Irp,        // stored in the EpdCtl
    IN EPDBUFFER *pBuff // needed to allocate the common buffer
)
{
    PEPDCTL pEpdCtl;
    PHYSICAL_ADDRESS PhysicalAddress;
    ULONG TotalSize;

    //
    // Must allocate a common buffer OR use IoMapTransfer()... the physical
    // address must be BUS-relative for the device.
    //

    TotalSize = sizeof(EPDCTL) + Size;

    _DbgPrintF( 
        DEBUGLVL_VERBOSE, 
        ("EpdAllocEpdCtl common buffer %d 0x%08x", TotalSize, TotalSize) );

    pEpdCtl = 
        AllocateIoPool( pBuff->IoPool, TotalSize, 'ltCE', &PhysicalAddress );
        
    if (pEpdCtl == NULL) 
    {
        _DbgPrintF(DEBUGLVL_VERBOSE,("AllocIoPool() failed in EpdAllocEpdCtl."));
        return NULL;
    }
        
    RtlZeroMemory(pEpdCtl, TotalSize);

    pEpdCtl->PhysicalAddress = PhysicalAddress;
    pEpdCtl->pNode = (PEPDQUEUENODE) (pEpdCtl + 1);
    pEpdCtl->pNode->VirtualAddress = &pEpdCtl->pNode->Node;
    pEpdCtl->pNode->PhysicalAddress.QuadPart = 
        pEpdCtl->PhysicalAddress.QuadPart + 
            sizeof( EPDCTL ) + 
            FIELD_OFFSET( EPDQUEUENODE, Node );

    pEpdCtl->cbLength = TotalSize;
    pEpdCtl->AssociatedIrp = Irp;

    _DbgPrintF( 
        DEBUGLVL_VERBOSE, 
        ("pEpdCtl allocated: %08x", pEpdCtl) );


    return pEpdCtl;
}

NTSTATUS
EpdResetDsp( 
    PEPDBUFFER EpdBuffer 
    ) 
// that is, stop the dsp
{
    // initialize BIU_CTL to reset state
    MMIO(EpdBuffer, BIU_CTL)     = 0x010A0A01;

    // disable the memory hole (erratum 34)
    MMIO(EpdBuffer, DC_LOCK_CTL) = 0x00000020;

    // clear the IMask & IClear register 
    MMIO(EpdBuffer, IMASK)       = 0x00000000;
    MMIO(EpdBuffer, ICLEAR)      = 0xffffffff;

    return STATUS_SUCCESS;
}

NTSTATUS
EpdUnresetDsp( 
    PEPDBUFFER EpdBuffer 
    )
// that is, start the dsp
{
    // Make sure the DSP is in reset first
    EpdResetDsp( EpdBuffer );

    MMIO( EpdBuffer, BIU_CTL ) = 0x01060601;

    _DbgPrintF(DEBUGLVL_VERBOSE,("BIU_CTL 0x%08x", MMIO(EpdBuffer, BIU_CTL)));

    return STATUS_SUCCESS;
}

NTSTATUS
EpdDeviceControl(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
)
{
    NTSTATUS Status;
    PEPDBUFFER EpdBuffer;
    PEPDCTL pEpdCtl;
    PIO_STACK_LOCATION  irpSp;
    ULONG ul;
    KIRQL OldIrql;

    irpSp = IoGetCurrentIrpStackLocation(Irp);

    Status = STATUS_UNSUCCESSFUL;
    Irp->IoStatus.Information = 0;
    EpdBuffer = DeviceObject->DeviceExtension;

    // this if/else is because dspmon polls and there's no way to step through this routine.
    if (irpSp->Parameters.DeviceIoControl.IoControlCode == IOCTL_EPD_GET_CONSOLE_CHARS) {
        Irp->IoStatus.Information = 
            DspReadDebugStr(
                EpdBuffer,
                (char *)Irp->AssociatedIrp.SystemBuffer, 
                irpSp->Parameters.DeviceIoControl.OutputBufferLength);

        Status = STATUS_SUCCESS;
        Irp->IoStatus.Status = Status;
        IoCompleteRequest (Irp, IO_NO_INCREMENT);
        return Status;
    }
    else
    // end of the if/else kludge

    switch (irpSp->Parameters.DeviceIoControl.IoControlCode) {

    case IOCTL_KSDSP_MESSAGE:
    {
        //
        // Note the assumption here, the caller is expected to be Kernel Mode.
        //

        if (Irp->RequestorMode != KernelMode) {
            Status = STATUS_INVALID_DEVICE_REQUEST; 
            break;
        }

        pEpdCtl = irpSp->Parameters.DeviceIoControl.Type3InputBuffer;

        // Save the node where we're sending this thing so we can 
        // send msg to the dsp to cancel it later. Node.Destination 
        // is overloaded on the dsp and we can't count on getting it 
        // from the queuenode

        pEpdCtl->NodeDestination = 
            pEpdCtl->pNode->VirtualAddress->Destination;

        // Save the pEpdCtl in the Irp so we can find everything later.

        Irp->Tail.Overlay.DriverContext[0] = pEpdCtl;

        IoMarkIrpPending( Irp );

        //
        // BUGBUG!  This needs to use cancelable queue stuff from KS.
        //

        pEpdCtl->PrevCancelRoutine = IoSetCancelRoutine( Irp, EpdCancel );

        if ((pEpdCtl->pNode->VirtualAddress->Destination == 0) && 
            (pEpdCtl->pNode->VirtualAddress->Request == 0)) {
            _DbgPrintF( 
                DEBUGLVL_ERROR, 
                ("pEpdCtl (%x) sending test message??", pEpdCtl) );
            
        }

        DspSendMessage( EpdBuffer, pEpdCtl->pNode, DSPMSG_OriginationHost );

        // return from here, since we do not call IoCompleteRequest

        return STATUS_PENDING;
    }

    case IOCTL_EPD_MSG:
    {
        char *pInputData;
        ULONG InputLength, OutputLength;
        ULONG TotalLength;

        pInputData   = Irp->AssociatedIrp.SystemBuffer;
        InputLength  = irpSp->Parameters.DeviceIoControl.InputBufferLength;
        OutputLength = irpSp->Parameters.DeviceIoControl.OutputBufferLength;

        // Allocate a control structure
        pEpdCtl = 
            EpdAllocEpdCtl(
                max(InputLength,OutputLength) + 
                    sizeof( EPDQUEUENODE ) - sizeof(QUEUENODE),
                Irp, 
                EpdBuffer);
        if (pEpdCtl == NULL) 
        {
            _DbgPrintF(DEBUGLVL_VERBOSE,("EpdAllocEpdCtl failed in IOCTL_EPD_MSG"));
            break;
        }
                        
        pEpdCtl->RequestType = EPDCTL_MSG;

        // The first part of the input structure must be a Queuenode
        // The user-define part of the input structure immediately follows the queuenode
        RtlCopyMemory (pEpdCtl->pNode->VirtualAddress, pInputData, InputLength);
        pEpdCtl->pNode->VirtualAddress->ReturnQueue = 0; // user should have done this

        // Save the node where we're sending this thing so we can send msg to the dsp to cancel it later.
        // Node.Destination is overloaded on the dsp and we can't count on getting it from the queuenode
        pEpdCtl->NodeDestination = pEpdCtl->pNode->VirtualAddress->Destination;

        // Save the pEpdCtl in the Irp so we can find everything later.
        Irp->Tail.Overlay.DriverContext[0] = pEpdCtl;

        // At this point, we know that we'll pass the request to the hardware.
        // Mark the irp pending so that NT can correctly handle any race conditions.
        IoMarkIrpPending (Irp);

        // If the irp was cancelled before the cancel routine was set, the cancellation request will
        // be ignored. This should be a rare case.
        // If the irp is cancelled between IoSetCancelRoutine and the time that the irp is placed in the
        // dsp queue, the cancel request will reach the board before the actual job does, and it will not
        // be cancelled on the dsp. This should also be a rare case.
        // A model of a thorough (and complex) way to handle this correctly is in ntos\ks\irp.c
        pEpdCtl->PrevCancelRoutine = IoSetCancelRoutine (Irp, EpdCancel);

        DspSendMessage( EpdBuffer, pEpdCtl->pNode, DSPMSG_OriginationHost );

        // return from here, since we do not call IoCompleteRequest
        return STATUS_PENDING;
    } // IOCTL_EPD_MSG

    case IOCTL_EPD_GET_DEBUG_BUFFER:
    {
        PEPDINSTANCE  EpdInstance;
        PEPD_GET_DEBUG_BUFFER pDebugData;

        EpdInstance = (PEPDINSTANCE) irpSp->FileObject->FsContext;

        _DbgPrintF(DEBUGLVL_VERBOSE,("map a user address to the buffer and return it"));
        pDebugData = (PEPD_GET_DEBUG_BUFFER) Irp->AssociatedIrp.SystemBuffer;
        Irp->IoStatus.Information = sizeof (EPD_GET_DEBUG_BUFFER);
        
        EpdInstance->DebugBuffer =
            MmMapLockedPages( EpdBuffer->DebugBufferMdl, UserMode );

        pDebugData->pDebugBuffer = 
            (PVOID)
                (((UINT_PTR)EpdInstance->DebugBuffer & ~0xFFF) + 
                 ((UINT_PTR)EpdBuffer->DebugBufferVa & 0xFFF));

        Irp->IoStatus.Information = sizeof(EPD_GET_DEBUG_BUFFER);

        _DbgPrintF(
            DEBUGLVL_VERBOSE,
            ("mapped buffer: %08x, SysVa: %08x", 
            pDebugData->pDebugBuffer, EpdBuffer->DebugBufferVa) );
        Status = STATUS_SUCCESS;
        break;
    } // IOCTL_EPD_GET_DEBUG_BUFFER

    case IOCTL_EPD_GET_CONSOLE_CHARS:
        Irp->IoStatus.Information = 
            DspReadDebugStr(
                EpdBuffer,
                (char *)Irp->AssociatedIrp.SystemBuffer, 
                irpSp->Parameters.DeviceIoControl.OutputBufferLength);

        Status = STATUS_SUCCESS;
        break;

    case IOCTL_EPD_LOAD:
        KernLdrLoadDspKernel(EpdBuffer);
        Status = STATUS_SUCCESS;
        break;

    case IOCTL_EPD_CLR_RESET: // start
        Status = EpdUnresetDsp( EpdBuffer );
        break;

    case IOCTL_EPD_SET_RESET: // stop
        Status = EpdResetDsp( EpdBuffer );
        break;
     
    case IOCTL_SWENUM_INSTALL_INTERFACE:
        Status = KsInstallBusEnumInterface( Irp );
        break;

    case IOCTL_SWENUM_GET_BUS_ID:
        Status = KsGetBusEnumIdentifier( Irp );
        break;

    default:
        _DbgPrintF(DEBUGLVL_VERBOSE,("Unrecognized IOCTL in EpdDeviceControl 0x%08x", irpSp->Parameters.DeviceIoControl.IoControlCode));
        break;

    } // end switch

    // Irp->IoStatus.Information must be set to correct value at this point
    Irp->IoStatus.Status = Status;
    IoCompleteRequest (Irp, IO_NO_INCREMENT);
    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\ksfilter\ksdsp\epd\pool.h ===
/*++

    Copyright (c) 1998 Microsoft Corporation

Module Name:

    pool.h

Abstract:

    header file for private pool handling routines

Author:

    bryanw 24-Jun-1998

--*/


//
// structure defintions
//

typedef struct _IO_POOL
{
    ULONG           Signature;
    ULONG           AllocCount;
    BOOL            WorkItemQueued;
    KSPIN_LOCK      WorkListLock;
    WORK_QUEUE_ITEM WorkItem;
    LIST_ENTRY      WorkList;
    LIST_ENTRY      FreeList;
    FAST_MUTEX      PoolMutex;
    PKEVENT         SyncEvent;
    PADAPTER_OBJECT AdapterObject;
    
} IO_POOL, *PIO_POOL;

typedef struct _IO_POOL_HEADER
{
    union {
        LIST_ENTRY      ListEntry;
        struct {
            PIO_POOL    OwnerPool;
            ULONG       Tag;
#if defined( _WIN64 )            
            ULONG       Reserved;
#endif            
        };
    };
    PHYSICAL_ADDRESS    PhysicalAddress;
    ULONG               OriginalSize;
    ULONG               Size;
    
} IO_POOL_HEADER, *PIO_POOL_HEADER;

#define POOLTAG_IO_POOL             'pIsK'

//
// function prototypes
//

PIO_POOL
CreateIoPool(
    IN PADAPTER_OBJECT AdapterObject
    );
    
BOOLEAN
DestroyIoPool(
    IN PIO_POOL IoPool
    );

PVOID
AllocateIoPool(
    IN PIO_POOL IoPool,
    IN ULONG NumberOfBytes,
    IN ULONG Tag,    
    OUT PPHYSICAL_ADDRESS PhysicalAddress
    );
    
VOID
FreeIoPool(
    IN PVOID PoolMemory
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\ksfilter\ksdsp\epd\intrp.c ===
#include "private.h"

BOOLEAN
EpdInterruptService (
    PKINTERRUPT Interrupt,
    PVOID ServiceContext // this will be the device object
    )
{
    ULONG   InterruptStatus, InterruptMask;

    PDEVICE_OBJECT DeviceObject;
    PEPDBUFFER EpdBuffer;
    
    DeviceObject = ServiceContext;
    EpdBuffer = (PEPDBUFFER) DeviceObject->DeviceExtension;

    InterruptStatus = MMIO( EpdBuffer, INT_CTL );
    InterruptMask = (InterruptStatus & 0xF0) << 4;
    if (0 == (InterruptStatus & InterruptMask)) {
        return FALSE;
    }

    _DbgPrintF( DEBUGLVL_VERBOSE, ("<i>") );

    ClearHostIrq( EpdBuffer ); // turn off interrupt

    IoRequestDpc (DeviceObject, DeviceObject->CurrentIrp, NULL);

    return TRUE;
}

void EpdCompleteCancelledIrp (PEPDCTL pEpdCtl)
{
    PIRP Irp;

    Irp = pEpdCtl->AssociatedIrp;
    Irp->IoStatus.Information = 0; 
    Irp->IoStatus.Status = STATUS_CANCELLED; 
    IoCompleteRequest (Irp, IO_NO_INCREMENT);
}

VOID
EpdDpcRoutine(
    IN PKDPC Dpc,
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
)
{
    QUEUENODE *pNode;
    PEPDBUFFER EpdBuffer;
    PEPDCTL pEpdCtl;
    PIRP AssociatedIrp;

    _DbgPrintF( DEBUGLVL_VERBOSE, ("<d>") );
    EpdBuffer = DeviceObject->DeviceExtension;

    while (pNode = DspReceiveMessage( EpdBuffer )) 
    {
        // New DSP requests are handled by the service thread
        if (pNode->ReturnQueue!=0) 
        {
            EpdSendDspReqToThread (EpdBuffer, (PQUEUENODE) pNode);
        } // end if DSPREQ
        // Response to HOST requests
        else
        {
            // host request has a EPD control structure in front of it
            pEpdCtl = 
                (PEPDCTL)
                    ((PCHAR) CONTAINING_RECORD( 
                                pNode,
                                EPDQUEUENODE, 
                                Node ) - 
                         sizeof( EPDCTL ));

            _DbgPrintF( 
                DEBUGLVL_VERBOSE, 
                ("pEpdCtl %08x from pNode %08x", pEpdCtl, pNode) );
                    
            AssociatedIrp = pEpdCtl->AssociatedIrp;
            // Clear the cancel routine (if any), it can't be cancelled after this point
            // If it was cancelled after we received the interrupt, it's not a disaster, since
            // the thread will get a cancel request it can't handle and will ignore it.
            IoSetCancelRoutine (AssociatedIrp, NULL);

            switch (pEpdCtl->RequestType) 
            {
            case EPDCTL_MSG:
            {
                PIO_STACK_LOCATION  irpSp;
                ULONG nOutputData;

                _DbgPrintF( 
                    DEBUGLVL_VERBOSE,
                    ("In DPC to finish the buffered IO msg") );

                // If it was cancelled successfully on the dsp, finish the cancellation, clean up, and return
                if (pEpdCtl->pNode->VirtualAddress->Result == NODERETURN_CANCEL) {
                    EpdCompleteCancelledIrp (pEpdCtl);
                    FreeIoPool(pEpdCtl);
                    break;
                }

                // Copy the returned data from the queuenode to the output buffer
                irpSp = IoGetCurrentIrpStackLocation(AssociatedIrp);
                nOutputData = irpSp->Parameters.DeviceIoControl.OutputBufferLength;
                RtlCopyMemory (AssociatedIrp->AssociatedIrp.SystemBuffer, pNode, nOutputData);
                AssociatedIrp->IoStatus.Information = nOutputData; 
                AssociatedIrp->IoStatus.Status = STATUS_SUCCESS; 
                IoCompleteRequest (AssociatedIrp, IO_NO_INCREMENT);

                FreeIoPool(pEpdCtl);

                break;
            } // EPDCTL_MSG

            case EPDCTL_KSDSP_MESSAGE:
            {
                PIO_STACK_LOCATION irpSp;
                ULONG OutputData;

                _DbgPrintF( 
                    DEBUGLVL_VERBOSE, ("DPC for EPDCTL_KSDSP_MESSAGE") );

                // If it was cancelled successfully on the DSP, 
                // finish the cancellation, clean up, and return

                if (pEpdCtl->pNode->VirtualAddress->Result == 
                        NODERETURN_CANCEL) {
                    EpdCompleteCancelledIrp( pEpdCtl );
                    break;
                }

                irpSp = IoGetCurrentIrpStackLocation(AssociatedIrp);

                //
                // BUGBUG! Shouldn't .Information be set to the size as
                // completed by the DSP???
                //

                AssociatedIrp->IoStatus.Information = 
                    irpSp->Parameters.DeviceIoControl.OutputBufferLength;
                AssociatedIrp->IoStatus.Status = STATUS_SUCCESS; 

                //
                // Once completed, the IRP is no longer accessible.
                //
                pEpdCtl->AssociatedIrp = NULL;
                IoCompleteRequest( AssociatedIrp, IO_NO_INCREMENT );
                break;

            } // EPDCTL_KSDSP_MESSAGE

            case EPDCTL_CANCEL:
            {
                PIO_STACK_LOCATION  irpSp;
                ULONG nOutputData;
                PHOSTREQ_CANCEL pCancelData;

                _DbgPrintF( DEBUGLVL_VERBOSE,("In DPC to finish cancel request"));

                pCancelData = (PHOSTREQ_CANCEL) pNode;

                if (pNode->Result == EPD_SUCCESS) {
                    _DbgPrintF( DEBUGLVL_VERBOSE,("Dsp cancel successful"));
                }
                else {
                    _DbgPrintF( DEBUGLVL_VERBOSE,("Dsp cancel not successful"));
                }

                // Clean up the packet containing the cancel request 
                FreeIoPool(pEpdCtl);
                break;
            } // EPDCTL_CANCEL


            default:
                _DbgPrintF( DEBUGLVL_ERROR,("Unrecognized case in HOSTREQ in dpc"));
                break;
            } // end switch
        } // end if HOSTREQ
    } // end while
}


VOID 
EpdSendReqToThread(
    PEPDCTL pEpdCtl,
    ULONG RequestType,
    PEPDBUFFER EpdBuffer
)
{
    pEpdCtl->RequestType = RequestType;

    // send it to the thread
    ExInterlockedInsertTailList(
        &EpdBuffer->ListEntry,   // IN PLIST_ENTRY  ListHead,
        &pEpdCtl->WorkItem.List, // IN PLIST_ENTRY  ListEntry,
        &EpdBuffer->ListSpinLock // IN PKSPIN_LOCK  Lock
    );

    // let the thread know we're ready
    KeReleaseSemaphore(
        &EpdBuffer->ThreadSemaphore,
        (KPRIORITY) 0,
        1,
        FALSE 
    );
}

VOID 
EpdSendDspReqToThread(
    EPDBUFFER *EpdBuffer, 
    PQUEUENODE pNode
)
{
    PEPDCTL pEpdCtl;
    NTSTATUS Status;

    pEpdCtl = 
        ExAllocatePoolWithTag(
            NonPagedPool, 
            sizeof(EPDCTL), 
            EPD_DSP_CONTROL_SIGNATURE );

    if (pEpdCtl == NULL) {
        _DbgPrintF(DEBUGLVL_VERBOSE,("IOCTL_EPD_SEND_TEST_MESSAGE EpdAllocEpcCtl failed, message not sent"));
        Status = STATUS_UNSUCCESSFUL;
        return;
    }
    RtlZeroMemory( pEpdCtl, sizeof( EPDCTL ));    
    // save the pointer to the queuenode
    pEpdCtl->pDspNode = pNode;

    EpdSendReqToThread (pEpdCtl, EPDTHREAD_DSPREQ, EpdBuffer);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\ksfilter\ksdsp\epd\memtest.c ===
#include "private.h"

ULONG EpdMemSizeTest(char *pMem, ULONG MaxMemSize)
{
    volatile ULONG *pTestAddr;
    ULONG MemSize;

    /* Starting at the first byte in the highest memory block,
     * write a test number to each block, halving the block size
     * on each iteration, e.g. offset=32MB,16MB,8MB,4MB,2MB,1MB,0MB
     */
    for ( MemSize = MaxMemSize/2;
          MemSize >= MINMEMSIZE/2;
          MemSize >>= 1
        )
    {
        pTestAddr = (ULONG *)(pMem + MemSize);
        *pTestAddr = MemSize;
    }

    /* Now move back up the blocks and verify the test number
     * previously written to each block until the test fails.
     * At that point, you will have reached the end of actual
     * memory.
     */
    for ( MemSize = MINMEMSIZE/2; 
          MemSize <= MaxMemSize/2;
          MemSize <<= 1 
        )
    {
        pTestAddr = (ULONG *)(pMem + MemSize);
        if (*pTestAddr != MemSize)
        {
            break;
        }
    }

    if (MemSize < MINMEMSIZE)
    {
        MemSize=0;
        _DbgPrintF(DEBUGLVL_VERBOSE,("No memory on board!"));
    }

    return MemSize;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\ksfilter\ksdsp\epd\message.c ===
/*++

    Copyright (c) 1998 Microsoft Corporation

Module Name:

    Message.c

Abstract:


Author:

    bryanw 08-Jul-1998

--*/


#include "private.h"

// Max # of nodes in each queue

#define MSGQUEUESIZE 1023
#define DEBUGOUTBUFSIZE 32000

typedef struct _MSGQUEUE
{
    DSPMSG_QUEUEPTR     SendQueueHeader;
    DSPMSG_QUEUEPTR     ReceiveQueueHeader;
    DSPMSG_DEBUGFIFO    DebugOutHeader;
    ULONG32             SendQueue[MSGQUEUESIZE+1];
    ULONG64             ReceiveQueue[MSGQUEUESIZE+1];
    char                DebugOutBuffer[DEBUGOUTBUFSIZE];
} MSGQUEUE;

NTSTATUS 
EpdAllocateMessageQueue(
    EPDBUFFER *EpdBuffer
    )
{
    ULONG       PhysAddr32;
    MSGQUEUE    *MsgQueue;
    
    MsgQueue =
        HalAllocateCommonBuffer( 
            EpdBuffer->BusMasterAdapterObject, 
            sizeof( MSGQUEUE ),
            &EpdBuffer->EDDCommBufPhysicalAddress, 
            FALSE );
    
    KeInitializeSpinLock( &EpdBuffer->ReceiveQueueLock );
    KeInitializeSpinLock( &EpdBuffer->SendQueueLock );
    
    PhysAddr32 = EpdBuffer->EDDCommBufPhysicalAddress.LowPart;
    
    //
    // Compute the translation bias
    //
    
    EpdBuffer->QueueTranslationBias = (INT_PTR) MsgQueue - (LONG) PhysAddr32;

    // Initialize queue headers
    
    EpdBuffer->SendQueuePtr = 
        &MsgQueue->SendQueueHeader;
    EpdBuffer->SendQueuePtr->StartPtr = 
        PhysAddr32 + FIELD_OFFSET( MSGQUEUE, SendQueue ); 
    EpdBuffer->SendQueuePtr->ReadPtr = 
        EpdBuffer->SendQueuePtr->StartPtr;
    EpdBuffer->SendQueuePtr->WritePtr = 
        EpdBuffer->SendQueuePtr->StartPtr + sizeof( ULONG32 );
    EpdBuffer->SendQueuePtr->EndPtr = 
        EpdBuffer->SendQueuePtr->StartPtr + sizeof( ULONG32 ) * MSGQUEUESIZE;

    EpdBuffer->ReceiveQueuePtr  = 
        &MsgQueue->ReceiveQueueHeader;
    EpdBuffer->ReceiveQueuePtr->StartPtr = 
        PhysAddr32 + FIELD_OFFSET( MSGQUEUE, ReceiveQueue ); 
    EpdBuffer->ReceiveQueuePtr->ReadPtr = 
        EpdBuffer->ReceiveQueuePtr->StartPtr;
    EpdBuffer->ReceiveQueuePtr->WritePtr = 
        EpdBuffer->ReceiveQueuePtr->StartPtr + sizeof( ULONG64 );
    EpdBuffer->ReceiveQueuePtr->EndPtr = 
        EpdBuffer->ReceiveQueuePtr->StartPtr + sizeof( ULONG64 ) * MSGQUEUESIZE;

    EpdBuffer->DebugOutFifo = &MsgQueue->DebugOutHeader;
    EpdBuffer->DebugOutFifo->StartPtr = 
        PhysAddr32 + FIELD_OFFSET( MSGQUEUE, DebugOutBuffer ); 
    EpdBuffer->DebugOutFifo->ReadPtr  = 
        EpdBuffer->DebugOutFifo->StartPtr;
    EpdBuffer->DebugOutFifo->WritePtr = 
        EpdBuffer->DebugOutFifo->StartPtr + 1;
    EpdBuffer->DebugOutFifo->EndPtr   = 
        EpdBuffer->DebugOutFifo->StartPtr + DEBUGOUTBUFSIZE;

    EpdBuffer->pSendBufHdr = PhysAddr32 + FIELD_OFFSET( MSGQUEUE, SendQueueHeader ); 
    EpdBuffer->pRecvBufHdr = PhysAddr32 + FIELD_OFFSET( MSGQUEUE, ReceiveQueueHeader ); 
    EpdBuffer->pDebugOutBuffer = PhysAddr32 + FIELD_OFFSET( MSGQUEUE, DebugOutHeader ); 
    EpdBuffer->pEDDCommBuf = MsgQueue;

    return 0;
}

void EpdFreeMessageQueue(
    PEPDBUFFER EpdBuffer
    )
{
    if (EpdBuffer->pEDDCommBuf) {
        HalFreeCommonBuffer(
            EpdBuffer->BusMasterAdapterObject, 
            sizeof( MSGQUEUE ),
            EpdBuffer->EDDCommBufPhysicalAddress,
            EpdBuffer->pEDDCommBuf,
            FALSE  );
        
        EpdBuffer->pEDDCommBuf = NULL;
    }
    return;
}

int DspSendMessage(
    PEPDBUFFER EpdBuffer,
    PVOID Node,
    DSPMSG_ORIGINATION MessageOrigination
    )
{
    int     RetVal;
    KIRQL   irqlOld;
    ULONG32 WritePtr, *WritePtrVa;
    
    KeAcquireSpinLock( &EpdBuffer->SendQueueLock, &irqlOld );

    WritePtr = EpdBuffer->SendQueuePtr->WritePtr;

    if (WritePtr == EpdBuffer->SendQueuePtr->ReadPtr) {
        RetVal = 0;
    } else {
        //
        // Put the node into the send queue.  Translate the node address 
        // to DSP memory address space if this node originates on the DSP.
        //
        WritePtrVa = (PULONG32) (EpdBuffer->QueueTranslationBias + WritePtr);

        if (MessageOrigination == DSPMSG_OriginationDSP) {
            *WritePtrVa = HostToDspMemAddress( EpdBuffer, Node );
        } else {
            *WritePtrVa = ((PEPDQUEUENODE)Node)->PhysicalAddress.LowPart;
        }

        WritePtr += sizeof( ULONG32 );

        //
        // If the pointer has advanced past the end of the queue, reset it.
        //
        
        if (WritePtr >= EpdBuffer->SendQueuePtr->EndPtr) {
            WritePtr=EpdBuffer->SendQueuePtr->StartPtr;
        }
    
        //
        // Update the write pointer.
        //
        EpdBuffer->SendQueuePtr->WritePtr = WritePtr;

        //
        // Signal the interrupt notifying the DSP of the queue change.
        //
        
        SetDspIrq( EpdBuffer );

        RetVal = 1;
    }

    KeReleaseSpinLock( &EpdBuffer->SendQueueLock, irqlOld );

    if (!RetVal) {
        _DbgPrintF( DEBUGLVL_ERROR, ("DspSendMessage() failed!"));
    }

    return RetVal;
}

PQUEUENODE DspReceiveMessage( 
    PEPDBUFFER EpdBuffer 
    )
{
    ULONG32     PrevReadPtr, ReadPtr;
    PQUEUENODE  Node;
    PULONG64    ReadPtrVa;
    KIRQL       irqlOld;

    KeAcquireSpinLock( &EpdBuffer->ReceiveQueueLock, &irqlOld );
    
    //
    // ReadPtr points to the last packet read, copy it for later.
    //
    
    PrevReadPtr = EpdBuffer->ReceiveQueuePtr->ReadPtr;

    // The new node is in the next location.
    
    ReadPtr = PrevReadPtr + sizeof( ULONG64 );

    // If the pointer has advanced past the end of the queue, reset it.
    
    if (ReadPtr >= EpdBuffer->ReceiveQueuePtr->EndPtr) {
        ReadPtr = EpdBuffer->ReceiveQueuePtr->StartPtr;
    }

    // If the read pointer is the same as the write pointer, 
    // the queue is empty.
    
    if (ReadPtr == EpdBuffer->ReceiveQueuePtr->WritePtr) {
        Node = NULL;
    } else {
        ReadPtrVa = (PULONG64) (EpdBuffer->QueueTranslationBias + ReadPtr);
        
        Node = (PQUEUENODE) *ReadPtrVa;

        //
        // Safe to update the read pointer
        //
        EpdBuffer->ReceiveQueuePtr->ReadPtr = ReadPtr;

        //
        // Was the queue previously full, if so, signal the DSP so
        // that it can send any waiting messages.
        //
        
        if (PrevReadPtr == EpdBuffer->ReceiveQueuePtr->WritePtr) {
            SetDspIrq( EpdBuffer );
        }

    }
    
    KeReleaseSpinLock( &EpdBuffer->ReceiveQueueLock, irqlOld );
    
    //
    // Note!  The DSP kernel returns the actual host Va of the 
    // memory.  This may be the Va as provided by the host in the
    // EPDQUEUENODE or it may be computed by the DSP given the Host Va bias.
    //
    
    return Node;
}

/***************************************************************/
/* Receive a debug string */
ULONG 
DspReadDebugStr( 
    PEPDBUFFER EpdBuffer, 
    char *String, 
    ULONG Bytes
    )
{
    ULONG   Count=0;
    ULONG32 ReadPtr;

    while (Count < Bytes)
    {
        //
        // Advance to the next character in the debug buffer.
        //
        
        ReadPtr = EpdBuffer->DebugOutFifo->ReadPtr + 1;
        
        
        // If the pointer has advanced past the end of the buffer, reset it.

        if (ReadPtr >= EpdBuffer->DebugOutFifo->EndPtr) {
            ReadPtr = EpdBuffer->DebugOutFifo->StartPtr;
        }            

        //
        // Is the buffer empty?  If so, break out...
        //    
        
        if (ReadPtr == EpdBuffer->DebugOutFifo->WritePtr) {
            break;
        }                

        // Read the next character from the buffer
            
        *String++ = *(char *) (EpdBuffer->QueueTranslationBias + ReadPtr);
        Count++;
        EpdBuffer->DebugOutFifo->ReadPtr = ReadPtr;
    }

    return Count;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\ksfilter\ksdsp\epd\pool.c ===
/*++

    Copyright (c) 1998 Microsoft Corporation

Module Name:

    pool.c

Abstract:

    private pool handling routines for device I/O 

Author:

    bryanw 24-Jun-1998

--*/

#include "private.h"

#ifdef ALLOC_PRAGMA
VOID
FreeWorker(
    IN PVOID Context
    );
    
VOID 
InsertFreeBlock(
    IN PIO_POOL IoPool,
    IN PIO_POOL_HEADER PoolHeader
    );
    
#pragma alloc_text(PAGE, AllocateIoPool)
#pragma alloc_text(PAGE, CreateIoPool)
#pragma alloc_text(PAGE, DestroyIoPool)
#pragma alloc_text(PAGE, FreeWorker)
#pragma alloc_text(PAGE, InsertFreeBlock)
#endif

VOID 
InsertFreeBlock(
    IN PIO_POOL IoPool,
    IN PIO_POOL_HEADER PoolHeader
    )

/*++

Routine Description:
    Internal function which inserts a free block into the given pool in 
    sorted order.  Coalesces contiguous sequential blocks and compacts
    the heap (returning common buffer memory to the system) when segments
    have been completely returned to the free list.

Arguments:
    IN PIO_POOL IoPool -
        pointer to the IoPool as returned by CreateIoPool()

    IN PIO_POOL_HEADER PoolHeader -
        pointer to the header to insert on the free list

Return:
    None.

--*/

{    
    PIO_POOL_HEADER Node, NextNode;
    
    ASSERT( KeGetCurrentIrql() == PASSIVE_LEVEL );
    
    _DbgPrintF( 
        DEBUGLVL_BLAB, 
        ("adding block %x(%x) to the free list", PoolHeader, PoolHeader->Size) );
    
#if (DBG)
    //
    // Clear this memory to try to trap anyone using this memory
    // after it has been freed.
    //
    RtlZeroMemory( PoolHeader + 1, PoolHeader->Size );
#endif
    
    //
    // If the free list is empty, no sorting required.
    //
    
    if (IsListEmpty( &IoPool->FreeList )) {
        InsertHeadList( &IoPool->FreeList, &PoolHeader->ListEntry );
    } else {
        
        //
        // Walk the free list and insert this free block in sorted order.
        //
        
        Node = 
            CONTAINING_RECORD( 
                IoPool->FreeList.Flink, IO_POOL_HEADER, ListEntry );
            
        while (Node->ListEntry.Flink != &IoPool->FreeList) {
            if (PoolHeader > Node) {
                Node = 
                    CONTAINING_RECORD( 
                        Node->ListEntry.Flink, IO_POOL_HEADER, ListEntry );
            } else {
                break;
            }
        }
        
        //
        // Insert this pool header in the list BEFORE the current node.
        //
        
        PoolHeader->ListEntry.Blink = Node->ListEntry.Blink;
        PoolHeader->ListEntry.Blink->Flink = &PoolHeader->ListEntry;
        PoolHeader->ListEntry.Flink = &Node->ListEntry;
        Node->ListEntry.Blink = &PoolHeader->ListEntry;
        
        //
        // Coalesce consecutive free blocks
        //
        
        if ((PoolHeader->OriginalSize) &&
            (((PUCHAR) (PoolHeader +  1) + PoolHeader->Size) == (PUCHAR) Node)) {
            
            _DbgPrintF( 
                DEBUGLVL_BLAB, 
                ("Coalescing block %x with next %x", PoolHeader, Node) );
            PoolHeader->ListEntry.Flink = Node->ListEntry.Flink;
            Node->ListEntry.Flink->Blink = &PoolHeader->ListEntry;
            PoolHeader->Size += Node->Size + sizeof( IO_POOL_HEADER );
        }

        Node = 
            CONTAINING_RECORD( 
                PoolHeader->ListEntry.Blink, IO_POOL_HEADER, ListEntry );
                
        if ((&Node->ListEntry != &IoPool->FreeList) &&
            (Node->OriginalSize) &&
            (((PUCHAR) (Node + 1) + Node->Size) == (PUCHAR) PoolHeader)) {
            _DbgPrintF( 
                DEBUGLVL_VERBOSE, 
                ("Coalescing block %x with prev %x", PoolHeader, Node) );
            Node->ListEntry.Flink = PoolHeader->ListEntry.Flink;
            PoolHeader->ListEntry.Flink->Blink = &Node->ListEntry;
            Node->Size += PoolHeader->Size + sizeof( IO_POOL_HEADER );
        }            
    }    
    
    //
    // Compaction. Walk the free list and if any full segments are found,
    // free them back to the system.  
    //
    // Note, there is always at least one entry on the free list after the
    // above processing has completed.
    //
    
    Node = 
        CONTAINING_RECORD( 
            IoPool->FreeList.Flink, IO_POOL_HEADER, ListEntry );
        
    for (;;) {
    
        if (Node->ListEntry.Flink == &IoPool->FreeList) {
            NextNode = NULL;
        } else {
            NextNode = 
                CONTAINING_RECORD( 
                    Node->ListEntry.Flink, IO_POOL_HEADER, ListEntry );
        } 
                           
        //
        // Compare the original allocation size to the current size of this
        // node.  If all suballocations have been coalesced back into this 
        // segment then remove it from the free list and return the common
        // buffer memory to the system.
        //    
        
        if ((Node->OriginalSize) && (Node->OriginalSize == Node->Size)) {
            RemoveEntryList( &Node->ListEntry );
            
            HalFreeCommonBuffer( 
                IoPool->AdapterObject, 
                Node->OriginalSize + sizeof( IO_POOL_HEADER ),
                Node->PhysicalAddress,
                Node,
                FALSE );
        } 
        if (!NextNode) {
            break;
        }
        Node = NextNode;    
    }
}    

PVOID
AllocateIoPool(
    IN PIO_POOL IoPool,
    IN ULONG NumberOfBytes,
    IN ULONG Tag,    
    OUT PPHYSICAL_ADDRESS PhysicalAddress
    )

/*++

Routine Description:

    Allocates NumberOfBytes memory from the specified I/O memory pool.

    Callers AllocateIoPool() must be running at IRQL == PASSIVE_LEVEL.

Arguments:
    IN PIO_POOL IoPool -
        pointer to the IoPool as returned by CreateIoPool()

    IN ULONG NumberOfBytes -
        number of bytes to allocate

    IN ULONG Tag -
        tag to mark allocation

    OUT PPHYSICAL_ADDRESS PhysicalAddress -
        points to a variable to receive the logical address of the memory

Return:
    Returns the base virtual address of the allocation.  If the buffer can
    not be allocated, it returns NULL.

--*/

{
    PIO_POOL_HEADER PoolHeader;
    PVOID           Va;
    ULONG           Size;
    
    
    ASSERT( KeGetCurrentIrql() == PASSIVE_LEVEL );
    
    ASSERT( IoPool );
    ASSERT( IoPool->Signature == POOLTAG_IO_POOL );
    
    //
    // Granularity is a quad-word.
    //
    
    NumberOfBytes = 
        (NumberOfBytes + FILE_QUAD_ALIGNMENT) & ~FILE_QUAD_ALIGNMENT;
    
    KeEnterCriticalRegion();
    ExAcquireFastMutexUnsafe( &IoPool->PoolMutex );
    
    //
    // IO_POOL_HEADER (allocated):
    //
    //     OwnerPool        - owning pool
    //     Tag              - specified tag
    //     PhysicalAddress  - physical address of the pool header
    //     OriginalSize     - size of the segment
    //     Size             - size of the pool body
    //
    
    PoolHeader = NULL;
    if (!IsListEmpty( &IoPool->FreeList )) {
        //
        // Walk the list in search of a candidate
        //
        
        PoolHeader = 
            CONTAINING_RECORD( 
                IoPool->FreeList.Flink, IO_POOL_HEADER, ListEntry );
            
        while (TRUE) {
            if (NumberOfBytes <= PoolHeader->Size) {
                RemoveEntryList( &PoolHeader->ListEntry );
                break;
            }
            if (PoolHeader->ListEntry.Flink == &IoPool->FreeList) {
                PoolHeader = NULL;
                break;
            }
            PoolHeader = 
                CONTAINING_RECORD( 
                    PoolHeader->ListEntry.Flink, IO_POOL_HEADER, ListEntry );
        }
    }

    if (!PoolHeader) {
        //
        // A free entry was not located in the free list.  Allocate
        // from Hal common buffer space rounded to the nearest page.
        //
        
        Size = 
            (NumberOfBytes + sizeof( IO_POOL_HEADER ) + PAGE_SIZE) & 
                ~(PAGE_SIZE - 1);
                
        PoolHeader =
            HalAllocateCommonBuffer( 
                IoPool->AdapterObject, 
                Size,
                PhysicalAddress,
                FALSE );
                
        if (!PoolHeader) {
            //
            // Failed to allocate common buffer -- out of I/O pool.
            //
            
            ExReleaseFastMutexUnsafe( &IoPool->PoolMutex );
            KeLeaveCriticalRegion();
            return NULL;
        }                    
    
        PoolHeader->PhysicalAddress = *PhysicalAddress;    
        PoolHeader->Size = Size - sizeof( IO_POOL_HEADER );
        PoolHeader->OriginalSize = PoolHeader->Size;
    }
    
    //
    // PoolHeader now points to a piece of memory for a pool header. 
    // Prepare the return values, set the pool header owner, 
    // and other header initialization.
    //
    
    PoolHeader->OwnerPool = IoPool;
    PoolHeader->Tag = Tag;
    (*PhysicalAddress).QuadPart = 
        PoolHeader->PhysicalAddress.QuadPart + sizeof( IO_POOL_HEADER );
    Va = PoolHeader + 1;
    
    //
    // Compute the extent of the remaining portion of this segment, if 
    // the segment is not large enough to hold a pool header and a 
    // quadword, it's left alone.
    //
    
    Size = (PoolHeader->Size - NumberOfBytes);
    
    if (Size > (sizeof( IO_POOL_HEADER ) + sizeof( LONGLONG ))) {
        PoolHeader->Size = NumberOfBytes;
        PoolHeader = (PIO_POOL_HEADER) ((PUCHAR) Va + NumberOfBytes);
        PoolHeader->Size = Size - sizeof( IO_POOL_HEADER );
        PoolHeader->OriginalSize = 0;
        
        //
        // Note:
        //
        // PoolHeader->PhysicalAddress points to the pool header and in this
        // case, *PhysicalAddress has already been bumped to point to the
        // pool body, thus is it only necessary to add the size of the body.
        //
        
        PoolHeader->PhysicalAddress.QuadPart = 
            (*PhysicalAddress).QuadPart + PoolHeader->Size;
        
        InsertFreeBlock( IoPool, PoolHeader );
    } 

    IoPool->AllocCount++;
    
    ExReleaseFastMutexUnsafe( &IoPool->PoolMutex );
    KeLeaveCriticalRegion();
    
    return Va;    
    
}

VOID
FreeIoPool(
    IN PVOID PoolMemory
    )

/*++

Routine Description:
    Frees pool memory previously allocated by AllocateIoPool().
    
    Callers of FreeIoPool() must be running at IRQL <= DISPATCH_LEVEL.

Arguments:
    IN PVOID PoolMemory -
        pointer to memory as returned by AllocateIoPool().  
        
Return:
    None.

--*/

{
    PIO_POOL        IoPool;
    PIO_POOL_HEADER PoolHeader;
    
    ASSERT( PoolMemory );
    
    PoolHeader = 
        (PIO_POOL_HEADER) ((PUCHAR)PoolMemory - (ULONG_PTR)sizeof( IO_POOL_HEADER ));
    ASSERT( PoolHeader );
    
    IoPool = PoolHeader->OwnerPool;
    ASSERT( IoPool );
    ASSERT( IoPool->Signature == POOLTAG_IO_POOL );
    
    if (KeGetCurrentIrql() > PASSIVE_LEVEL) {
        KIRQL  irqlOld;
    
        KeAcquireSpinLock( &IoPool->WorkListLock, &irqlOld );
        InsertTailList( 
            &IoPool->WorkList, &PoolHeader->ListEntry );
        if (!InterlockedExchange( &IoPool->WorkItemQueued, TRUE )) {
            ExQueueWorkItem( &IoPool->WorkItem, DelayedWorkQueue );
        }
        KeReleaseSpinLock( &IoPool->WorkListLock, irqlOld );
        return;    
    }

    //
    // A passive caller... free the block now.
    //    
    
    KeEnterCriticalRegion();
    ExAcquireFastMutexUnsafe( &IoPool->PoolMutex );
    InsertFreeBlock( IoPool, PoolHeader );
    IoPool->AllocCount--;
    ExReleaseFastMutexUnsafe( &IoPool->PoolMutex );
    KeLeaveCriticalRegion();
}

VOID
FreeWorker(
    IN PVOID Context
    )

/*++

Routine Description:
    Processes the work list for the given I/O pool. Each pool header on
    the work list is returned to the free list and the alloc count is 
    decremented accordingly.

Arguments:
    IN PVOID Context -
        pointer to the I/O pool for which the worker was dispatched.

Return:
    None.
    
--*/

{
    KIRQL           irqlOld;
    PIO_POOL        IoPool = Context;
    PIO_POOL_HEADER PoolHeader;
    
    ASSERT( KeGetCurrentIrql() == PASSIVE_LEVEL );
    
    ASSERT( IoPool );
    
    //
    // Acquire the worker list lock.  
    //
    // Note: Access to the WorkItemQueued member is also controlled through 
    // this spinlock.
    //
    
    KeAcquireSpinLock( &IoPool->WorkListLock, &irqlOld );
    
    while (!IsListEmpty( &IoPool->WorkList )) {
        PLIST_ENTRY  ListEntry;
        
        ListEntry = RemoveHeadList( &IoPool->WorkList )
        PoolHeader = 
            CONTAINING_RECORD( 
                ListEntry, IO_POOL_HEADER, ListEntry );
        KeReleaseSpinLock( &IoPool->WorkListLock, irqlOld );
        
        //
        // Acquire the pool mutex and put the item on the free list.
        //
        
        KeEnterCriticalRegion();
        ExAcquireFastMutexUnsafe( &IoPool->PoolMutex );
        InsertFreeBlock( IoPool, PoolHeader );
        IoPool->AllocCount--;
        ExReleaseFastMutexUnsafe( &IoPool->PoolMutex );
        KeLeaveCriticalRegion();
        
        //
        // Re-acquire the work list mutex and try for another item.
        //
            
        KeAcquireSpinLock( &IoPool->WorkListLock, &irqlOld );
    }

    //
    // If a sync event is specified, signal it and reset the pointer.
    //    
    if (IoPool->SyncEvent) {
        KeSetEvent( IoPool->SyncEvent, IO_NO_INCREMENT, FALSE );
        IoPool->SyncEvent = NULL;
    }    

    //
    // At this point, there is no more work to do on the list, reset
    // the WorkerItemQueued flag and release the spinlock.
    //    

    InterlockedExchange( &IoPool->WorkItemQueued, FALSE );
    
    KeReleaseSpinLock( &IoPool->WorkListLock, irqlOld );
}    

PIO_POOL
CreateIoPool(
    IN PADAPTER_OBJECT AdapterObject
    )

/*++

Routine Description:
    Creates an I/O pool memory object.  Subsequent allocations from this
    pool use the given adapter object to allocate common buffer memory
    suitable for device transactions (DMA) with this I/O memory.

    Callers of CreateIoPool() must be running at IRQL <= PASSIVE_LEVEL.
    
Arguments:
    IN PADAPTER_OBJECT AdapterObject -
        associated HAL adapter object to use when allocating memory for
        this pool.

Return:
    Returns a pointer to an I/O pool object.

--*/

{
    PIO_POOL NewPool;
    
    PAGED_CODE();
    
    NewPool = 
        (PIO_POOL)ExAllocatePoolWithTag( 
            NonPagedPool, 
            sizeof( IO_POOL ), 
            POOLTAG_IO_POOL );
        
    if (NewPool) {
        InitializeListHead( &NewPool->FreeList );
        ExInitializeFastMutex( &NewPool->PoolMutex );
        InitializeListHead( &NewPool->WorkList );
        KeInitializeSpinLock( &NewPool->WorkListLock );
        ExInitializeWorkItem( &NewPool->WorkItem, FreeWorker, NewPool );
        NewPool->Signature = POOLTAG_IO_POOL;
        NewPool->AdapterObject = AdapterObject;
        NewPool->AllocCount = 0;
        NewPool->WorkItemQueued = FALSE;
        NewPool->SyncEvent = NULL;
    }
    return NewPool;    
}

BOOLEAN
DestroyIoPool(
    IN PIO_POOL IoPool
    )

/*++

Routine Description:
    Destroys the I/O pool object as created by CreateIoPool().  

Arguments:
    IN PIO_POOL IoPool -
        pointer to the IoPool as returned by CreateIoPool()

Return:
    TRUE if pool was destroyed, FALSE if allocations from this pool are still
    active.

--*/

{
    KIRQL   irqlOld;
    
    ASSERT( KeGetCurrentIrql() == PASSIVE_LEVEL );
    
    ASSERT( IoPool );
    
    //
    // Synchronize with the worker list and free pool functions.
    //
    KeAcquireSpinLock( &IoPool->WorkListLock, &irqlOld );
    
    if (IoPool->WorkItemQueued) {
        KEVENT  Event;
        
        //
        // Let the worker know that we want a signal when it has completed
        // its task.
        //
        
        KeInitializeEvent( &Event, NotificationEvent, FALSE );
        IoPool->SyncEvent = &Event;
        KeReleaseSpinLock( &IoPool->WorkListLock, irqlOld );    
        
        //
        // This waits using KernelMode, so that the stack, and therefore the
        // event on that stack, is not paged out.
        //
        KeWaitForSingleObject(&Event, Executive, KernelMode, FALSE, NULL);
        
    } else {
        KeReleaseSpinLock( &IoPool->WorkListLock, irqlOld );    
    }

    //
    // Synchronize with alloc/free to retrieve the remaining allocations.
    //    

    KeEnterCriticalRegion();
    ExAcquireFastMutexUnsafe( &IoPool->PoolMutex );
    
    if (IoPool->AllocCount) {
        ExReleaseFastMutexUnsafe( &IoPool->PoolMutex );
        KeLeaveCriticalRegion();
        return FALSE;
    }
    
    ASSERT( IsListEmpty( &IoPool->FreeList ) );
    
    ExReleaseFastMutexUnsafe( &IoPool->PoolMutex );
    KeLeaveCriticalRegion();
    
    ExFreePool( IoPool );    
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\ksfilter\ksdsp\firmware\tm1\inc\resource.h ===
/*++

    Copyright (c) 1998 Microsoft Corporation

Module Name:

    tm1res.h

Abstract:

    TM1 resource definitions for DSP kernel images

Author:

    bryanw 14-Dec-1998

--*/

#if defined( RC_INVOKED )

#define IMAGE_MMOSA     100
#define IMAGE_CMDLINE   101
#define IMAGE_KSAUDIO   102
#define IMAGE_HOSTDMA   103
#define IMAGE_AUDIODRV  104
#define IMAGE_TMIIC     105

#define FILTDESC_AUDIO  200

#endif // RC_INVOKED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\ksfilter\ksdsp\firmware\tm1\audiodrv\makefile.inc ===
!ifdef PASS0ONLY
.SUFFIXES: .c
!endif

obj\$(TARGET_DIRECTORY)\genfd.obj: genfd.c

obj\$(TARGET_DIRECTORY)\filtdesc.obj: filtdesc.c

obj\$(TARGET_DIRECTORY)\genfd.exe: obj\$(TARGET_DIRECTORY)\genfd.obj obj\$(TARGET_DIRECTORY)\filtdesc.obj

bin\fd-audio.bin: obj\$(TARGET_DIRECTORY)\genfd.exe
    obj\$(TARGET_DIRECTORY)\genfd.exe $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\ksfilter\ksdsp\firmware\tm1\audiodrv\filtdesc.c ===
/*++

    Copyright (c) 1999 Microsoft Corporation

Module Name:

    filtdesc.c

Abstract:


Author:

    bryanw 14-Jan-1999

--*/

#include <wdm.h>
#include <windef.h>
#define NOBITMAP
#include <mmreg.h>
#undef NOBITMAP
#include <ks.h>
#include <ksmedia.h>

typedef struct _FILTER_DESCRIPTORS
{
    KSFILTER_DESCRIPTOR     FilterDescriptors[ 1 ];
    GUID                    ReferenceGuid;
    GUID                    FilterCategories[ 3 ];
    GUID                    FilterNodeGuids[ 1 ];
    KSNODE_DESCRIPTOR       FilterNodeDescriptors[ 1 ];
    KSPIN_DESCRIPTOR_EX     PinDescriptors[ 2 ];
    KSPIN_INTERFACE         PinInterfaces[ 1 ];
    KSPIN_MEDIUM            PinMediums[ 1 ];
    KSTOPOLOGY_CONNECTION   FilterConnections[ 2 ];
    PKSDATARANGE            PinFormatRanges[ 2 ];
    KSDATARANGE_AUDIO       DigitalAudioDataRanges[ 1 ];
    KSDATARANGE             AnalogAudioDataRanges[ 1 ];

} FILTER_DESCRIPTORS, *PFILTER_DESCRIPTORS;


//
// Define the wildcard data format.
//

FILTER_DESCRIPTORS FilterDescriptors =
{
    //
    // Filter descriptor
    //

    {
        NULL, // FilterDispatch,
        NULL, // const KSAUTOMATION_TABLE* AutomationTable;
        KSFILTER_DESCRIPTOR_VERSION,
        KSFILTER_FLAG_CRITICAL_PROCESSING,
        (GUID *) FIELD_OFFSET( FILTER_DESCRIPTORS, ReferenceGuid ),
        SIZEOF_ARRAY(FilterDescriptors.PinDescriptors),
        sizeof(KSPIN_DESCRIPTOR_EX),
        (PKSPIN_DESCRIPTOR_EX) FIELD_OFFSET( FILTER_DESCRIPTORS, PinDescriptors ),
        SIZEOF_ARRAY(FilterDescriptors.FilterCategories),
        (GUID *) FIELD_OFFSET( FILTER_DESCRIPTORS, FilterCategories ),
        SIZEOF_ARRAY( FilterDescriptors.FilterNodeDescriptors ),
        sizeof(KSNODE_DESCRIPTOR),
        (PKSNODE_DESCRIPTOR) FIELD_OFFSET( FILTER_DESCRIPTORS, FilterNodeDescriptors ),
        SIZEOF_ARRAY( FilterDescriptors.FilterConnections ),
        (PKSTOPOLOGY_CONNECTION) FIELD_OFFSET( FILTER_DESCRIPTORS, FilterConnections ),
        NULL // ComponentId
    },


    //
    // Reference GUID (translated to reference string by KS)
    //

    STATICGUIDOF(KSNAME_Filter),

    //
    // Filter categories
    //

    {
        STATICGUIDOF(KSCATEGORY_AUDIO),
        STATICGUIDOF(KSCATEGORY_RENDER),
        STATICGUIDOF(KSCATEGORY_CAPTURE)
    },

    //
    // Filter node GUIDs
    //

    STATICGUIDOF( KSNODETYPE_DAC ),

    //
    // Filter node descriptors
    //
    {   
        NULL,       // Dispatch
        NULL,       // PKSAUTOMATION_TABLE     AutomationTable;
        (GUID *) (FIELD_OFFSET( FILTER_DESCRIPTORS, FilterNodeGuids[ 0 ] )),
        NULL
    },

    //
    // Pin descriptors
    //
    {
        {   
            NULL, // PinDispatch
            NULL, // Automation
            {
                SIZEOF_ARRAY( FilterDescriptors.PinInterfaces ),
                (PKSPIN_INTERFACE) FIELD_OFFSET( FILTER_DESCRIPTORS, PinInterfaces ),
                SIZEOF_ARRAY( FilterDescriptors.PinMediums ),
                (PKSPIN_MEDIUM) FIELD_OFFSET( FILTER_DESCRIPTORS, PinMediums ),
                1,
                (PKSDATARANGE *) FIELD_OFFSET( FILTER_DESCRIPTORS, PinFormatRanges[ 0 ] ),
                KSPIN_DATAFLOW_IN,
                KSPIN_COMMUNICATION_BOTH,
                // Name (KSCATEGORY_AUDIO)
                (GUID *) FIELD_OFFSET( FILTER_DESCRIPTORS, FilterCategories[ 0 ] ), 
                // Category
                NULL,
                0
            },
            KSPIN_FLAG_RENDERER |
                KSPIN_FLAG_ENFORCE_FIFO, //Flags
            1,
            1,
            NULL, // Pin intersect handler
            NULL  // Allocator framing
        },
        {   
            NULL, // PinDispatch
            NULL, // Automation
            {
                SIZEOF_ARRAY( FilterDescriptors.PinInterfaces ),
                (PKSPIN_INTERFACE) FIELD_OFFSET( FILTER_DESCRIPTORS, PinInterfaces ),
                SIZEOF_ARRAY( FilterDescriptors.PinMediums ),
                (PKSPIN_MEDIUM) FIELD_OFFSET( FILTER_DESCRIPTORS, PinMediums ),
                1,
                (PKSDATARANGE *) FIELD_OFFSET( FILTER_DESCRIPTORS, PinFormatRanges[ 1 ] ),
                KSPIN_DATAFLOW_OUT,
                KSPIN_COMMUNICATION_NONE,
                // Name (KSCATEGORY_AUDIO)
                (GUID *) FIELD_OFFSET( FILTER_DESCRIPTORS, FilterCategories[ 0 ] ), 
                // Category                            
                NULL,
                0
            },
            0, // Flags
            1,
            1,
            NULL, // Pin intersect handler
            NULL  // Allocator framing
        }
    },

    //
    // Pin interfaces
    //

    {
        STATICGUIDOF(KSINTERFACESETID_Standard),
        KSINTERFACE_STANDARD_STREAMING,
        0
    },

    //
    // Pin mediums
    //

    {
        STATICGUIDOF(KSMEDIUMSETID_Standard),
        KSMEDIUM_STANDARD_DEVIO,
        0
    },

    //
    // Filter connections (toplogy connections)
    //

    {
        { KSFILTER_NODE, 1, 0, 1 },
        { 0, 0, KSFILTER_NODE, 0 }
    },

    {
        //
        // Pin format ranges (dataflow in) 
        //

        (PKSDATARANGE)FIELD_OFFSET( FILTER_DESCRIPTORS, DigitalAudioDataRanges ),

        //
        // Pin format ranges (dataflow out)
        //
        (PKSDATARANGE)FIELD_OFFSET( FILTER_DESCRIPTORS, AnalogAudioDataRanges ),
    },

    //
    // Digital audio data range (PCM)
    //
    {
        {
            {
                sizeof(KSDATARANGE_AUDIO),
                0,
                0,
                0,
                STATICGUIDOF(KSDATAFORMAT_TYPE_AUDIO),
                STATICGUIDOF(KSDATAFORMAT_SUBTYPE_PCM),
                STATICGUIDOF(KSDATAFORMAT_SPECIFIER_WAVEFORMATEX)
            },
            2,      // Max number of channels.
            8,      // Minimum number of bits per sample.
            16,     // Maximum number of bits per channel.
            5510,   // Minimum rate.
            48000   // Maximum rate.
        }
    },

    //
    // Analog audio data range
    //
    {
        sizeof(KSDATARANGE),
        0,
        0,
        0,
        STATICGUIDOF(KSDATAFORMAT_TYPE_AUDIO),
        STATICGUIDOF(KSDATAFORMAT_SUBTYPE_ANALOG),
        STATICGUIDOF(KSDATAFORMAT_SPECIFIER_NONE)
    }

    
};

ULONG FilterDescriptorsSize = sizeof( FilterDescriptors );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\ksfilter\ksdsp\epd\private.h ===
/*++

    Copyright (c) 1998 Microsoft Corporation

Module Name:

    Private.h

Abstract:

    private header file for the Escalante Platform Driver

Author:

    bryanw 19-Jan-1998  
        created, working with sources from AndyRaf, SteveZ
        
    bryanw 10-Jul-1998  
        major rework from original sources, merged many headers,
        removed globals, made Win64 compatible

--*/


#if !defined( _PRIVATE_ )
#define _PRIVATE_

#include <wdm.h>
#include <windef.h>
#include <stdio.h>
#include <fcntl.h>
#include <ks.h>
#include <swenum.h>
#include <ksmedia.h>
#include <ksdsp.h>
#define STR_MODULENAME "epd: "
#define DEBUG_VARIABLE EPDDebug
#include <ksdebug.h>
#include "epd.h"
#include "pool.h"
#include "mmio.h"
#include "memtest.h"

#define EPDVERSION          30 // BryanW: use version structs.

// Handy macros
#define BIT(_x_) (1 << (_x_))

#define EPD_HOST_CONTROL_SIGNATURE      'hCsE'
#define EPD_DSP_CONTROL_SIGNATURE       'dCsE'
#define EPD_UNICODE_STRING_SIGNATURE    'sUsE'
#define EPD_UNICODE_PATH_SIGNATURE      'pUsE'
#define EPD_INSTANCE_SIGNATURE          'nIsE'
#define EPD_LDR_SIGNATURE               'dLsE'
#define EPD_TASKCONTEXT_SIGNATURE       'cTsE'

#include "irq.h"

#define SetHostIrq(x)   MMIO(x,INT_CTL) = 0x11;
#define ClearHostIrq(x) MMIO(x,INT_CTL) = 0x00;
#define SetDspIrq(x)    MMIO(x,IPENDING) = 1 << IRQ_ID_HOST
#define StopDSP(x)      MMIO(x,BIU_CTL) = 0x010A0A01
#define StartDSP(x)     MMIO(x,BIU_CTL) = 0x01060601

#include <ksguid.h>

#define STATIC_TM1BusInterfaceId \
    0x588fcce4L, 0x63b6, 0x11d2, 0x85, 0x13, 0x00, 0xc0, 0x4f, 0xb9, 0x1b, 0xc4
DEFINE_GUIDSTRUCT( "588fcce4-63b6-11d2-8513-00c04fb91bc4", TM1BusInterfaceId );


// Private epd prototypes, structures and types

// data types
// dsp memory
typedef unsigned char DSPMEM;
typedef DSPMEM *PDSPMEM;

typedef struct _DSPMSG_DEBUGFIFO
{
    ULONG32 StartPtr;
    ULONG32 EndPtr;
    ULONG32 volatile ReadPtr;
    ULONG32 volatile WritePtr;
} DSPMSG_DEBUGFIFO, *PDSPMSG_DEBUGFIFO;

typedef struct _DSPMSG_QUEUEPTR
{
    ULONG32 StartPtr;
    ULONG32 EndPtr;
    ULONG32 volatile ReadPtr;
    ULONG32 volatile WritePtr;
    
} DSPMSG_QUEUEPTR, *PDSPMSG_QUEUEPTR;

typedef struct _EPDQUEUENODE
{
    PHYSICAL_ADDRESS    PhysicalAddress;
    
    //
    // The DSP looks at the 64-bits preceding the queue node to obtain 
    // the host virtual address of the queuenode.  For Win32, the upper
    // 32 bits are zero.
    //
    
    PQUEUENODE          VirtualAddress;
#if !defined( _WIN64 )
    PVOID               Reserved;   // For Win32, this must always be 0.
#endif    
    
    QUEUENODE           Node;
} EPDQUEUENODE, *PEPDQUEUENODE;

#define MAXLEN_TRANSLATION_TABLE 256

// device extension
typedef struct _EPDBUFFER 
{
    PVOID           SwenumContext;
    PDEVICE_OBJECT  FunctionalDeviceObject;
    PDEVICE_OBJECT  PhysicalDeviceObject;
    PDEVICE_OBJECT  PnpDeviceObject;
    PKINTERRUPT     InterruptObject;
    KMUTEX          ControlMutex;
    
    PDSPMEM         DspMemoryVa;
    PDSPMEM         DspRegisterVa;
    
    ULONG MemLenDspMem;
    ULONG MemLenDspMemActual;
    ULONG MemLenDspReg;
    
    LIST_ENTRY ListEntry;
    UNICODE_STRING linkName;
    
    KSPIN_LOCK ListSpinLock;
    KSEMAPHORE ThreadSemaphore;
    PETHREAD ThreadObject;
    PADAPTER_OBJECT BusMasterAdapterObject;
    PIO_POOL IoPool;
    PUINT   IoBaseTM1;
    ULONG NumberOfMapRegisters;
    ULONG *pRtlTable;
    BOOL bDspStarted;

    EPD_DEBUG_BUFFER *DebugBufferVa;
    PMDL DebugBufferMdl;
    PHYSICAL_ADDRESS DebugBufferPhysicalAddress;
    
    KSPIN_LOCK ReceiveQueueLock; 
    KSPIN_LOCK SendQueueLock;

    PDSPMSG_QUEUEPTR SendQueuePtr;
    PDSPMSG_QUEUEPTR ReceiveQueuePtr;
    
    PDSPMSG_DEBUGFIFO DebugOutFifo;
    
    INT_PTR QueueTranslationBias;
    INT_PTR HostToDspMemOffset;
    INT_PTR HostToDspRegOffset;
    
    PVOID pEDDCommBuf;
    PHYSICAL_ADDRESS EDDCommBufPhysicalAddress;
    ULONG32 pSendBufHdr;
    ULONG32 pRecvBufHdr;
    ULONG32 pDebugOutBuffer;
    
    ULONG InterfaceReferenceCount;
    
#if defined( _WIN64 )
    HANDLE HandleTable64to32[ MAXLEN_TRANSLATION_TABLE ];
    ULONG32 HandleTableBitmap[ MAXLEN_TRANSLATION_TABLE / 32 ];
#endif    

} EPDBUFFER, *PEPDBUFFER;

#define InitHostDspMemMapping(HostVa, DspPhys) EpdBuffer->HostToDspMemOffset = ((INT_PTR)HostVa - (ULONG32)DspPhys)
#define InitHostDspRegMapping(EpdBuffer, HostVa, DspPhys) EpdBuffer->HostToDspRegOffset = ((INT_PTR)HostVa - (ULONG32)DspPhys)
#define HostToDspMemAddress(EpdBuffer, HostVa) ((ULONG32) PtrToUlong( (PUCHAR) HostVa - EpdBuffer->HostToDspMemOffset ))
#define DspToHostMemAddress(EpdBuffer, DspPhys) ((PDSPMEM) (EpdBuffer->HostToDspMemOffset + (ULONG) DspPhys))
#define HostToDspRegAddress(EpdBuffer, HostVa) ((ULONG32) PtrToUlong( (PUCHAR) HostVa - EpdBuffer->HostToDspRegOffset ))
#define DspToHostRegAddress(EpdBuffer, DspPhys) ((PDSPMEM) (EpdBuffer->HostToDspRegOffset + (ULONG) DspPhys))

typedef struct _EPDINSTANCE {
    PVOID   DebugBuffer;
    
} EPDINSTANCE, *PEPDINSTANCE;

#define EPDCTL_BASE                0x300
// #define EPDCTL_SEND_TEST_MESSAGE    0x1 + EPDCTL_BASE
#define EPDCTL_LOAD_LIBRARY         0x2 + EPDCTL_BASE
#define EPDCTL_MSG                  0x3 + EPDCTL_BASE
#define EPDCTL_DMA_READ             0x4 + EPDCTL_BASE
#define EPDCTL_DMA_WRITE            0x5 + EPDCTL_BASE
#define EPDCTL_CANCEL               0x6 + EPDCTL_BASE
#define EPDCTL_KSDSP_MESSAGE        0x7 + EPDCTL_BASE

typedef struct _EPDCTL
{
    //
    // N.B.:  Remember Zp8
    //
    
    WORK_QUEUE_ITEM WorkItem; // 16
    
    ULONG RequestType; // 4
    ULONG cbLength; // 4

    PIRP  AssociatedIrp; // 4
    PMDL  Mdl;

    PVOID CurrentVa; // 4
    PVOID MapRegisterBase; // 4

    ULONG MapRegisters; // count of map registers
    ULONG MessageId; // for KSDSP messages // 4
    
    PHYSICAL_ADDRESS PhysicalAddress; // 8

    PDRIVER_CANCEL PrevCancelRoutine;   // 4
    ULONG NodeDestination;              // save this for cancellation // 4
    
    PQUEUENODE    pDspNode;             // dsp queuenode mapped Va 4
    PEPDQUEUENODE pNode;                // host Queuenode virtual address // 4

} EPDCTL, *PEPDCTL;

enum {
    DSPMSG_Open,
    DSPMSG_Close,
    DSPMSG_Read,
    DSPMSG_Write,
    DSPMSG_Seek,
    DSPMSG_FileLength,
    DSPMSG_ExeSize,
    DSPMSG_ExeLoad,
    DSPMSG_Max = DSPMSG_ExeLoad
    
} DSPMSG;

typedef struct _QUEUENODE_OPEN
{
    QUEUENODE   Node;
    ULONG32     Flags;
    char        FileName[1];
} QUEUENODE_OPEN;

typedef struct _QUEUENODE_CLOSE
{
    QUEUENODE   Node;
    ULONG32     FileDescriptor;
} QUEUENODE_CLOSE;

typedef struct _QUEUENODE_SEEKREAD
{
    QUEUENODE   Node;
    ULONG32     FileDescriptor;
    ULONG32     Offset;
    ULONG32     Whence;
    ULONG32     Buf;
    ULONG       Size;
} QUEUENODE_SEEKREAD;

typedef struct _QUEUENODE_SEEKWRITE
{
    QUEUENODE       Node;
    ULONG32         FileDescriptor;
    ULONG32         Offset;
    ULONG32         Whence;
    const ULONG32   Buf;
    ULONG32         Size;
} QUEUENODE_SEEKWRITE;

typedef struct _QUEUENODE_SEEK
{
    QUEUENODE   Node;
    ULONG32     FileDescriptor;
    ULONG32     Offset;
    ULONG32     Whence;
} QUEUENODE_SEEK;

typedef struct _QUEUENODE_FILELENGTH
{
    QUEUENODE   Node;
    ULONG32     FileDescriptor;
} QUEUENODE_FILELENGTH;

typedef struct _QUEUENODE_EXESIZELOAD
{
    QUEUENODE   Node;
    ULONG32     Buf;
    ULONG32     pRtlTable;
    ULONG32     EntryPoint;
    BOOL        IsaDll;
    char        FileName[1];
} QUEUENODE_EXESIZELOAD;

typedef enum {
    DSPMSG_OriginationDSP,
    DSPMSG_OriginationHost
} DSPMSG_ORIGINATION;

typedef struct _EPDTASKCONTEXT
{
    UINT32 IUnknown;
    UINT32 IQueue;
} EPDTASKCONTEXT, *PEPDTASKCONTEXT;    
 
#define EPDTHREAD_BASE                0x200
#define EPDTHREAD_KILL_THREAD           0 + EPDTHREAD_BASE
#define EPDTHREAD_FREECB                1 + EPDTHREAD_BASE
#define EPDTHREAD_DSPREQ                2 + EPDTHREAD_BASE

// Function prototypes for epd

#ifdef __cplusplus
extern "C" {
#endif

NTSTATUS
AddDevice(
    IN PDRIVER_OBJECT   DriverObject,
    IN PDEVICE_OBJECT   PhysicalDeviceObject
    );
    
NTSTATUS 
EpdAllocateMessageQueue(
    PEPDBUFFER EpdBuffer
    );

void EpdFreeMessageQueue( 
    PEPDBUFFER EpdBuffer 
    );

NTSTATUS 
DispatchPnp(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );
    
VOID
EpdDpcRoutine(
    IN PKDPC Dpc,
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    );

NTSTATUS
EpdOpen(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
);

NTSTATUS
EpdClose(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
);

NTSTATUS
EpdWrite(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
);

NTSTATUS
EpdRead(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
);

NTSTATUS
EpdDeviceControl(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
);

VOID
EpdUnload(
    IN PDRIVER_OBJECT DriverObject
);

BOOLEAN
EpdInterruptService (
    IN PKINTERRUPT InterruptObject,
    IN PVOID ServiceContext
);

NTSTATUS
EpdAllocateAndCopyUnicodeString(
    OUT PUNICODE_STRING DestinationString,
    IN PUNICODE_STRING SourceString
);

BOOLEAN
EpdInterruptService (
    IN PKINTERRUPT Interrupt,
    IN PVOID ServiceContext
);

VOID
EpdStartIo (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
);

NTSTATUS 
EpdFileOpen (
    OUT HANDLE *pFileHandle,
    IN PUNICODE_STRING puniFileName, 
    IN ULONG Flags
);

VOID
EpdDiskThread (
    PVOID Context
);

VOID 
EpdSendDspReqToThread(
    EPDBUFFER *pBuff, 
    PQUEUENODE pNode
);

#if defined( _WIN64 )
ULONG32 
pMapHandle64to32( 
    IN PEPDBUFFER EpdBuffer,
    IN HANDLE Handle64
    );
    
HANDLE 
pTranslateHandle32to64( 
    IN PEPDBUFFER EpdBuffer,
    IN ULONG32 Handle32
    );
    

VOID 
pUnmapHandle64to32( 
    IN PEPDBUFFER EpdBuffer,
    IN ULONG32 Handle32
    );    

#define MapHandle64to32( EpdBuffer, Handle64 ) pMapHandle64to32( EpdBuffer, Handle64 )
#define TranslateHandle32to64( EpdBuffer, Handle32 ) pTranslateHandle32to64( EpdBuffer, Handle32 )
#define UnmapHandle64to32( EpdBuffer, Handle32 ) pUnmapHandle64to32( EpdBuffer, Handle32 )
#else
#define MapHandle64to32( EpdBuffer, Handle64 ) ((ULONG32) Handle64)
#define TranslateHandle32to64( EpdBuffer, Handle32 ) ((HANDLE) Handle32)
#define UnmapHandle64to32( EpdBuffer, Handle32 )
#endif

NTSTATUS
EpdFileOpenFromMessage(
    IN PEPDBUFFER EpdBuffer,
    IN OUT QUEUENODE *pMessage
    );

NTSTATUS
EpdFileCloseFromMessage(
    IN PEPDBUFFER EpdBuffer,
    IN OUT QUEUENODE *pMessage
);

NTSTATUS 
EpdFileOpen (
    OUT HANDLE *pFileHandle,
    IN PUNICODE_STRING puniFileName, 
    IN ULONG Flags
);

NTSTATUS 
EpdFileSeekAndRead(
    IN  HANDLE File, 
    IN  LONG RelOffset, 
    IN  ULONG Origin,
    IN OUT PVOID pBlock, 
    IN  ULONG Size, 
    OUT ULONG *pSizeAct
);

NTSTATUS 
EpdFileSeekAndWrite(
    IN  HANDLE File, 
    IN  LONG RelOffset, 
    IN  ULONG Origin,
    IN OUT PVOID pBlock, 
    IN  ULONG Size, 
    OUT ULONG *pSizeAct
);

NTSTATUS
EpdFileSeekAndReadFromMessage(
    IN PEPDBUFFER EpdBuffer,
    IN OUT QUEUENODE *pMessage
);

NTSTATUS
EpdFileSeekAndWriteFromMessage(
    IN PEPDBUFFER EpdBuffer,
    IN OUT QUEUENODE *pMessage
);

ULONG 
EpdFileLength(
    HANDLE FileHandle
    );

NTSTATUS
EpdFileSeek(
    HANDLE File, 
    LONG RelOffset, 
    ULONG Origin,
    ULONG *pNewOffset
);

NTSTATUS
EpdFileSeekFromMessage(
    IN PEPDBUFFER EpdBuffer,
    IN OUT QUEUENODE *pMessage
);

NTSTATUS
EpdFileLengthFromMessage(
    IN PEPDBUFFER EpdBuffer,
    IN OUT QUEUENODE *pMessage
);

NTSTATUS
EpdExeSizeFromMessage(
    IN PEPDBUFFER EpdBuffer,
    IN OUT QUEUENODE *pMessage
);

NTSTATUS
EpdExeLoadFromMessage(
    IN PEPDBUFFER EpdBuffer,
    IN OUT QUEUENODE *pMessage
);


VOID 
EpdFreeAnsiString(
    ANSI_STRING *pansi
);

NTSTATUS
EpdAllocateAndCopyUnicodeString(
    OUT PUNICODE_STRING DestinationString,
    IN  PUNICODE_STRING SourceString
);

NTSTATUS
EpdZeroTerminatedStringToUnicodeString(
    OUT PUNICODE_STRING puni,
    IN  char*           sz,
    IN BOOLEAN Allocate
);

NTSTATUS
EpdUnicodeStringToZeroTerminatedString(
    OUT char*           sz,
    IN  PUNICODE_STRING puni,
    IN  BOOLEAN Allocate
);

NTSTATUS
EpdAppendFileNameToTalismanDirName(
    UNICODE_STRING *puniPath,
    UNICODE_STRING *puniFileName
);

IO_ALLOCATION_ACTION
EpdDmaRead (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID MapRegisterBase,
    IN PVOID Context
);

IO_ALLOCATION_ACTION
EpdDmaWrite (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID MapRegisterBase,
    IN PVOID Context
);

PEPDCTL
EpdAllocEpdCtl (
    IN ULONG Size,      // size of extra data
    IN PIRP Irp,        // stored in the EpdCtl
    IN EPDBUFFER *pBuff // needed to allocate the common buffer
);

ULONG DspReadDebugStr( PEPDBUFFER EpdBuffer, char *String, ULONG Bytes);

VOID 
EpdSendReqToThread(
    PEPDCTL pEpdCtl,
    ULONG RequestType,
    EPDBUFFER *pBuff
);

NTSTATUS EpdResetDsp( PEPDBUFFER EpdBuffer );
NTSTATUS EpdUnresetDsp( PEPDBUFFER EpdBuffer );

VOID 
EpdCancel(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
);

int DspSendMessage(
    PEPDBUFFER EpdBuffer,
    PVOID Node,
    DSPMSG_ORIGINATION MessageOrigination
    );
    
PQUEUENODE DspReceiveMessage(
    PEPDBUFFER EpdBuffer
    );

NTSTATUS KernLdrLoadDspKernel(
    PEPDBUFFER EpdBuffer
    );

NTSTATUS 
LifeLdrImageSize(
    PUCHAR ImageBase,
    ULONG *pImageSize
    );

NTSTATUS    
LifeLdrImageLoad(
    PEPDBUFFER EpdBuffer,
    PUCHAR ImageBase,
    char *pImage,
    ULONG *pRtlTable,
    PULONG32 ImageEntryPointPtr,
    PCHAR *DataSectionVa,
    int *pIsDLL
    );
    
NTSTATUS
LifeLdrLoadFile( 
    IN PUNICODE_STRING FileName,
    OUT PVOID *ImageBase
    );
    
//
// KSDSP Support Interface
//    

NTSTATUS 
MapMsgResultToNtStatus( 
    IN UINT32 MsgResult 
    );

VOID 
InterfaceReference(
    IN PEPDBUFFER EpdBuffer
    );
VOID 
InterfaceDereference(
    IN PEPDBUFFER EpdBuffer
    );
    
NTSTATUS
KsDspMapModuleName(
    IN PEPDBUFFER EpdBuffer,
    IN PUNICODE_STRING ModuleName,
    OUT PUNICODE_STRING ImageName,
    OUT PULONG ResourceId,
    OUT PULONG ValueType
    );
    
NTSTATUS
KsDspPrepareChannelMessage(
    IN PEPDBUFFER EpdBuffer,
    IN PIRP Irp,
    IN KSDSPCHANNEL Channel,
    IN KSDSP_MSG MessageId,
    IN OUT PVOID MessageFrame,
    IN ULONG MessageDataLength,
    va_list ArgList
    );
    
NTSTATUS
KsDspPrepareMessage(
    IN PEPDBUFFER EpdBuffer,
    IN PIRP Irp,
    IN KSDSP_MSG MessageId,
    IN OUT PVOID MessageFrame,
    IN ULONG MessageDataLength,
    va_list ArgList
    );
    
NTSTATUS
KsDspMapDataTransfer(
    IN PEPDBUFFER EpdBuffer,
    IN PIRP Irp,
    IN KSDSPCHANNEL Channel,
    IN KSDSP_MSG MessageId,
    IN OUT PVOID MessageFrame,
    IN PMDL Mdl
    );
    
NTSTATUS
KsDspUnmapDataTransfer(
    IN PEPDBUFFER EpdBuffer,
    IN PVOID MessageFrame
    );
    
NTSTATUS
KsDspSendMessage(
    IN PEPDBUFFER EpdBuffer,
    IN PIRP Irp
    );    
    
NTSTATUS
KsDspAllocateMessageFrame(
    IN PEPDBUFFER EpdBuffer,
    IN KSDSP_MSG MessageId,
    OUT PVOID *MessageFrame,
    IN OUT PULONG MessageFrameLength
    );
    
NTSTATUS
KsDspGetMessageResult(
    IN PEPDBUFFER EpdBuffer,
    IN PVOID MessageFrame,
    OUT PVOID Result
    );    
    
VOID
KsDspFreeMessageFrame(
    IN PEPDBUFFER EpdBuffer,
    IN PVOID MessageFrame
    );
    
NTSTATUS
KsDspGetControlChannel(
    IN PEPDBUFFER EpdBuffer,
    IN PVOID TaskContext,
    OUT PKSDSPCHANNEL ControlChannel
    );    

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\ksfilter\ksdsp\firmware\tm1\audiodrv\genfd.c ===
/*++

    Copyright (c) 1999 Microsoft Corporation

Module Name:

    genfd.c

Abstract:


Author:

    bryanw 14-Jan-1999

--*/

#include <windows.h>
#include <stdio.h>

extern ULONG FilterDescriptorsSize;
extern PVOID FilterDescriptors;

int 
_cdecl 
main( 
    int argc, 
    void **argv 
) 
{
    BOOL    Result;
    HANDLE  FileHandle;
    ULONG   Error, BytesWritten;

    if (argc < 2) {
        printf( "GenFD: generates a filter descriptor file\nusage: GenFD <filename>\n" );
        return -1;
    }
    printf( "GenFD: Generating filter descriptor resource: %s\n", argv[ 1 ] );

    FileHandle =
        CreateFile( 
            argv[ 1 ],
            GENERIC_WRITE,
            0,      // no sharing
            NULL,   // LPSECURITY_ATTRIBUTES lpSecurityAttributes
            CREATE_ALWAYS,
            FILE_ATTRIBUTE_NORMAL,
            NULL    // HANDLE hTemplateFile
            );
    if (FileHandle == INVALID_HANDLE_VALUE) {
        return -1;
    }
    printf( "GenFD: writing %d bytes\n", FilterDescriptorsSize );

    Result =
        WriteFile(
            FileHandle,
            &FilterDescriptors,
            FilterDescriptorsSize,
            &BytesWritten,
            NULL    // LPOVERLAPPED lpOverlapped
            );
    printf( "GenFD: %s", Result ? "successful." : "failed." ) ;
    CloseHandle( FileHandle );

    return 0;
    
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\ksfilter\ksdsp\inc\dspkinit.h ===
#ifndef __dspkinit_h__
#define __dspkinit_h__

typedef struct _DSPKERNEL_INITDATA
{
    ULONG       end_bss;
    ULONG       clock_freq;
    ULONG       MMIO_base;
    ULONG       pRtlTable;

    ULONG       EPDRecvBuf;
    ULONG       EPDSendBuf;
    
    LONGLONG    HostVaBias;

    ULONG       pDebugBuffer;
    ULONG       pDebugOutBuffer;

} DSPKERNEL_INITDATA;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\ksfilter\ksdsp\inc\memtest.h ===
#ifndef __memtest_h__
#define __memtest_h__
#include "ntddk.h"

#define MINMEMSIZE 0x100000
ULONG EpdMemSizeTest(char *pMem, ULONG MaxMemSize);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\ksfilter\ksdsp\inc\irq.h ===
#ifndef _irq_h_
#define _irq_h_

#define IRQ_PCI_INTA            (0)
#define IRQ_PCI_INTB            (1)
#define IRQ_PCI_INTC            (2)
#define IRQ_PCI_INTD            (3)
#define IRQ_ID_TILER            (4)    /* TRI_USERIRQ */
#define IRQ_ID_TIMER0           (5)    /* Edge triggered */
#define IRQ_ID_TIMER1           (6)    /* Edge triggered */
#define IRQ_ID_TIMER2           (7)    /* Edge triggered */
#define IRQ_ID_TIMER3           (8)    /* Edge triggered */
#define IRQ_ID_DMA_VIDEOIN      (9)
#define IRQ_ID_DMA_VIDEOOUT     (10)
#define IRQ_ID_DMA_AUDIO_IN     (11)
#define IRQ_ID_DMA_AUDIO_OUT    (12)
#define IRQ_ID_ICP              (13)
#define IRQ_ID_VLD              (14)
#define IRQ_ID_MODEM            (15)
#define IRQ_ID_DMA_HOST         (16)
#define IRQ_ID_IIC              (17)
#define IRQ_ID_JTAG             (18)

/* 19 reserved */

#define IRQ_ID_THERM            (20)
#define IRQ_ID_GIOMAT           (21)
#define IRQ_ID_VFB              (22)    /* Edge triggered */

/* 23-28 reserved */

#define IRQ_ID_HOST             (28)    /* Edge triggered */
#define IRQ_ID_APP              (29)
#define IRQ_ID_DEBUGGER         (30)
#define IRQ_ID_RTOS             (31)

#define IRQ_ID_COUNT            (32)

#endif /* _irq_h_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\ksfilter\ksdsp\inc\ksdsp.h ===
/*++                            

    Copyright (c) 1998 Microsoft Corporation

Module Name:

    ksdsp.h

Abstract:    
    
    interface definitions for KSDSP

Author:

    bryanw 29-Sep-1998

--*/

#define STATIC_CLSID_KsDsp \
    0xfa577bdeL, 0x57c8, 0x11d2, 0x85, 0x0b, 0x00, 0xc0, 0x4f, 0xb9, 0x1b, 0xc4
DEFINE_GUIDSTRUCT( "fa577bde-57c8-11d2-850b-00c04fb91bc4", CLSID_KsDsp );

#define STATIC_IID_IKsDspIo \
    0xfd4b4550l, 0x57c8, 0x11d2, 0x85, 0x0b, 0x00, 0xc0, 0x4f, 0xb9, 0x1b, 0xc4
DEFINE_GUIDSTRUCT( "fd4b4550-57c8-11d2-850b-00c04fb91bc4", IID_IKsDspIo );

#define STATIC_IID_IKsDspControlChannel \
    0x3cce799cl, 0x57e5, 0x11d2, 0x85, 0x0b, 0x00, 0xc0, 0x4f, 0xb9, 0x1b, 0xc4
DEFINE_GUIDSTRUCT( "3cce799c-57e5-11d2-850b-00c04fb91bc4", IID_IKsDspControlChannel );

#define STATIC_BUSID_KSDSPPlatform \
    0x89927179l, 0x89ff, 0x11d2, 0x98, 0x3a, 0x00, 0xa0, 0xc9, 0x5e, 0xc2, 0x2e
DEFINE_GUIDSTRUCT( "89927179-89ff-11d2-983a-00a0c95ec22e", BUSID_KSDSPPlatform );

typedef ULONG32 KSDSPCHANNEL;
typedef KSDSPCHANNEL *PKSDSPCHANNEL;

#define KSDSP_HOST
#include <ksdspmsg.h>

typedef
NTSTATUS
(*PFNKSDSPMAPMODULENAME)(
    IN PVOID Context,
    IN PUNICODE_STRING ModuleName,
    OUT PUNICODE_STRING ImageName,
    OUT PULONG ResourceId,
    OUT PULONG ValueType
    );                
    
typedef
NTSTATUS
(*PFNKSDSPPREPARECHANNELMESSAGE)(
    IN PVOID Context,
    IN PIRP Irp,
    IN KSDSPCHANNEL Channel,
    IN KSDSP_MSG MessageId,
    IN OUT PVOID MessageFrame,
    IN ULONG MessageDataLength,
    va_list ArgPtr
    );
    
typedef
NTSTATUS
(*PFNKSDSPPREPAREMESSAGE)(
    IN PVOID Context,
    IN PIRP Irp,
    IN KSDSP_MSG MessageId,
    IN OUT PVOID MessageFrame,
    IN ULONG MessageDataLength,
    va_list ArgPtr
    );
    
typedef
NTSTATUS
(*PFNKSDSPMAPDATATRANSFER)(
    IN PVOID Context,
    IN PIRP Irp,
    IN KSDSPCHANNEL Channel,
    IN KSDSP_MSG MessageId,
    IN OUT PVOID MessageFrame,
    IN PMDL Mdl
    );
    
typedef
NTSTATUS
(*PFNKSDSPUNMAPDATATRANSFER)(
    IN PVOID Context,
    IN PVOID MessageFrame
    );

typedef
NTSTATUS
(*PFNKSDSPALLOCATEMESSAGEFRAME)(
    IN PVOID Context,
    IN KSDSP_MSG MessageId,
    OUT PVOID *MessageFrame,
    IN OUT PULONG MessageDataLength    
    );
    
typedef
NTSTATUS
(*PFNKSDSPSENDMESSAGE)(
    IN PVOID Context,
    IN PIRP Irp
    );    
    
typedef
NTSTATUS
(*PFNKSDSPGETMESSAGERESULT)(
    IN PVOID Context,
    IN PVOID MessageFrame,
    OUT PVOID Result
    );    
    
typedef
VOID
(*PFNKSDSPFREEMESSAGEFRAME)(
    IN PVOID Context,
    IN PVOID MessageFrame
    );
    
typedef
NTSTATUS
(*PFNKSDSPGETCONTROLCHANNEL)(
    IN PVOID Context,
    IN PVOID TaskContext,
    OUT PKSDSPCHANNEL ControlChannel
    );    
    
#define BUS_INTERFACE_KSDSPPLATFORM_VERSION    0x100

typedef struct _BUS_INTERFACE_KSDSPPLATFORM{
    //
    // Standard interface header
    //
    
    USHORT                          Size;
    USHORT                          Version;
    PVOID                           Context;
    PINTERFACE_REFERENCE            InterfaceReference;
    PINTERFACE_DEREFERENCE          InterfaceDereference;

    //
    // KSDSP Platform bus interfaces
    //
    
    PFNKSDSPMAPMODULENAME           MapModuleName;
    PFNKSDSPPREPARECHANNELMESSAGE   PrepareChannelMessage;
    PFNKSDSPPREPAREMESSAGE          PrepareMessage;
    PFNKSDSPMAPDATATRANSFER         MapDataTransfer;
    PFNKSDSPUNMAPDATATRANSFER       UnmapDataTransfer;
    PFNKSDSPALLOCATEMESSAGEFRAME    AllocateMessageFrame;
    PFNKSDSPSENDMESSAGE             SendMessage;
    PFNKSDSPGETMESSAGERESULT        GetMessageResult;
    PFNKSDSPFREEMESSAGEFRAME        FreeMessageFrame;
    PFNKSDSPGETCONTROLCHANNEL       GetControlChannel;
        
} BUS_INTERFACE_KSDSPPLATFORM, *PBUS_INTERFACE_KSDSPPLATFORM;

typedef struct tagKSGUIDTRANSLATION
{
    GUID    Set;
    ULONG   Base;
    ULONG   TranslationBase;
    
} KSGUIDTRANSLATION, *PKSGUIDTRANSLATION;

#define IOCTL_KSDSP_MESSAGE CTL_CODE(FILE_DEVICE_KS, 0x80, METHOD_NEITHER, FILE_ANY_ACCESS)

#if defined( DECLARE_INTERFACE_ )

#undef INTERFACE
#define INTERFACE IKsDspControlChannel
DECLARE_INTERFACE_(IKsDspControlChannel, IUnknown)
{
    STDMETHOD( SetGuidTranslationTable )(
        THIS_
        PKSGUIDTRANSLATION GuidTranslationTable,
        ULONG TableEntryCount
        ) PURE;
        
    STDMETHOD( OpenDataChannel )(
        THIS_
        IN ULONG32 PinId,
        OUT PKSDSPCHANNEL DataChannel 
        ) PURE;
        
    STDMETHOD( CloseDataChannel )(
        THIS_
        IN KSDSPCHANNEL DataChannel
        ) PURE;        
        
    STDMETHOD( SendPropertyRequest )(
        THIS_
        IN KSPROPERTY Property,
        IN PVOID DataBuffer,
        IN OUT PULONG DataLength
        ) PURE;
        
    STDMETHOD( SendMethodRequest )(        
        THIS_
        IN KSMETHOD Method,
        IN PVOID DataBuffer,
        IN OUT PULONG DataLength
        ) PURE;
        
    STDMETHOD( SetTargetChannel )(
        THIS_
        IN KSDSPCHANNEL DataChannel,
        IN KSDSPCHANNEL TargetChannel
        ) PURE;
        
    STDMETHOD( SetChannelFormat )(
        THIS_
        IN KSDSPCHANNEL DataChannel,
        IN PKSDATAFORMAT DataFormat
        ) PURE;
                
    STDMETHOD( SetChannelState )(
        THIS_
        IN KSDSPCHANNEL DataChannel,
        IN KSSTATE State
        ) PURE;
};

typedef IKsDspControlChannel *PIKSDSPCONTROLCHANNEL;

typedef struct IKsDspIo *PIKSDSPIO;

#define KSDSP_SENDMESSAGEF_KEVENT       0x00000001L
#define KSDSP_SENDMESSAGEF_SYNCHRONOUS  0x00000002L

#define KSDSP_MESSAGEF_ALLOCATE_IRP     0x00000001L
#define KSDSP_MESSAGEF_ALLOCATE_FRAME   0x00000002L

#undef INTERFACE
#define INTERFACE IKsDspIo
DECLARE_INTERFACE_(IKsDspIo, IUnknown)
{
    STDMETHOD( Initialize )(
        THIS_
        IN PDEVICE_OBJECT PhysicalDeviceObject,
        IN PDEVICE_OBJECT NextDeviceObject
        ) PURE;
        
    STDMETHOD( CreateDspControlChannel )( 
        THIS_
        OUT PIKSDSPCONTROLCHANNEL *ControlChannel,
        IN PUNKNOWN UnkOuter OPTIONAL
        ) PURE;
    
    STDMETHOD( AllocateMessageFrame )(
        THIS_
        IN KSDSP_MSG MessageId,
        OUT PVOID *MessageFrame,
        IN OUT PULONG MessageDataLength
        ) PURE;
        
    STDMETHODV( PrepareChannelMessage )(
        THIS_
        IN OUT PIRP *Irp,
        IN KSDSPCHANNEL Channel,
        IN KSDSP_MSG MessageId,
        IN OUT PVOID *MessageFrame,
        IN OUT PULONG MessageDataLength,
        IN ULONG Flags,    
        ...
        ) PURE;        
        
    STDMETHODV( PrepareMessage )(
        THIS_
        IN OUT PIRP *Irp,
        IN KSDSP_MSG MessageId,
        IN OUT PVOID *MessageFrame,
        IN OUT PULONG MessageDataLength,
        IN ULONG Flags,    
        ...
        ) PURE;
        
    STDMETHOD( MapDataTransfer )(
        THIS_
        IN OUT PIRP *Irp,
        IN KSDSPCHANNEL DataChannel,
        IN KSDSP_MSG MessageId,
        IN OUT PVOID *MessageFrame,
        IN PMDL Mdl,
        IN ULONG Flags
        ) PURE;
        
    STDMETHOD( UnmapDataTransfer )(
        THIS_
        IN PVOID MessageFrame
        ) PURE;        
        
    STDMETHOD( SendMessage )( 
        THIS_
        IN PIRP Irp,
        IN PKEVENT Event,    
        IN PIO_STATUS_BLOCK IoStatus,
        IN ULONG Flags    
        ) PURE;
        
    STDMETHOD( GetMessageResult )(
        THIS_
        IN PVOID MessageFrame,
        IN OUT PVOID Result
        ) PURE;
        
    STDMETHOD_( VOID, FreeMessageFrame )(
        THIS_
        IN PVOID MessageFrame 
        ) PURE;
        
    STDMETHOD( LoadResource )(
        THIS_
        IN POOL_TYPE PoolType,
        IN PUNICODE_STRING FileName,
        IN ULONG_PTR ResourceName,
        IN ULONG ResourceType,
        OUT PVOID *Resource,
        OUT PULONG ResourceSize
        ) PURE;
        
    STDMETHOD( GetFilterDescriptor )(
        THIS_
        IN POOL_TYPE PoolType,
        IN PKSFILTER_DISPATCH FilterDispatch,
        IN PKSPIN_DISPATCH PinDispatch,    
        OUT PKSFILTER_DESCRIPTOR *FilterDescriptor
        ) PURE;
};

#endif // DECLARE_INTERFACE_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\ksfilter\ksdsp\inc\epd.h ===
#if !defined( _EPD_H_ )
#define _EPD_H_

// Structures and constants used by EPD apps.

typedef struct  _QUEUENODE
{
    ULONG32  Destination;    // Queue to send node to
    ULONG32  ReturnQueue;    // Queue to return node to
    ULONG32  Request;        // Request type
    ULONG32  Result;         // Result from request
} QUEUENODE, *PQUEUENODE;

// IOCTL codes.
#define FILE_DEVICE_EPD 0x8001
#define EPD_CODE(_function_,_method_)  CTL_CODE(FILE_DEVICE_EPD, 0x800 | (_function_), (_method_), FILE_ANY_ACCESS)

#define IOCTL_EPD_MSG               EPD_CODE(0x0,METHOD_BUFFERED)
#if 0
#define IOCTL_EPD_DMA_READ          EPD_CODE(0x1,METHOD_IN_DIRECT)
#define IOCTL_EPD_DMA_WRITE         EPD_CODE(0x2,METHOD_OUT_DIRECT)
#endif
#define IOCTL_EPD_CLR_RESET         EPD_CODE(0x3,METHOD_BUFFERED)
#define IOCTL_EPD_SET_RESET         EPD_CODE(0x4,METHOD_BUFFERED)
#define IOCTL_EPD_GET_CONSOLE_CHARS EPD_CODE(0x5,METHOD_BUFFERED)
#define IOCTL_EPD_LOAD              EPD_CODE(0x6,METHOD_BUFFERED) 
#define IOCTL_EPD_GET_DEBUG_BUFFER  EPD_CODE(0x7,METHOD_BUFFERED)
#define IOCTL_EPD_TEST              EPD_CODE(0x9,METHOD_BUFFERED)
#define IOCTL_EPD_CANCEL            EPD_CODE(0xA,METHOD_BUFFERED)
#define IOCTL_EPD_DEADENDTEST       EPD_CODE(0xB,METHOD_BUFFERED)

/* Host reserves Node.Return return codes above 0xFFFFF000 */
#define NODERETURN_BASE   0xFFFFF000
#define NODERETURN_CANCEL 0xFFFFF000

/* System defined host to dsp nodes request types and structures */
#define HOSTREQ_TO_NODE_BASE                  0xFFFFF000
#define HOSTREQ_TO_NODE_CANCEL                0xFFFFF000
#define HOSTREQ_TO_NODE_CANCEL_REQ_NOT_FOUND  0xFFFFF001

#define EPD_SUCCESS             0
#define EPD_CANCELLED           1
#define EPD_UNSUCCESSFUL       -1

// This works with the definition in mmosa.h, and is the return code for
// 'request type not recognized'
#ifndef _MMOSA_H_
#define E_INVALID_METHOD 0x800700B6
#endif

typedef struct _HOSTREQ_CANCEL
{
    QUEUENODE Node;
    QUEUENODE *pNodePhys; // physical address pointer to queuenode to be cancelled
    // Following used internally by epd
} HOSTREQ_CANCEL, *PHOSTREQ_CANCEL;

/* EDD request types and structures */
#define EDD_REQUEST_QUEUE                0
#define EDD_TEST_REQUEST                 0
#define EDD_LOAD_LIBRARY_REQUEST         1
#define EDD_RELEASE_INTERFACE_REQUEST    2
#define EDD_FREE_LIBRARY_REQUEST         3

typedef struct _EDD_TEST
{
    QUEUENODE Node;
} EDD_TEST;

typedef struct _EDD_LOAD_LIBRARY
{
    QUEUENODE Node;
    UINT32 IUnknown;
    UINT32 IQueue;
    char Name[1];
} EDD_LOAD_LIBRARY;

typedef struct _EDD_FREE_LIBRARY
{
    QUEUENODE Node;
    UINT32 IUnknown;
    UINT32 IQueue;
} EDD_FREE_LIBRARY;

typedef struct _EDD_RELEASE_INTERFACE
{
    QUEUENODE Node;
    UINT32 IUnknown;
} EDD_RELEASE_INTERFACE;

typedef struct _EDD_KSDSP_MESSAGE
{
    QUEUENODE Node;
    char      Data[1];
    
} EDD_KSDSP_MESSAGE;

typedef struct _SCATTER_GATHER_ENTRY
{
    UINT32 PhysAddr;
    UINT32 ByteCount;
    
} SCATTER_GATHER_ENTRY, *PSCATTER_GATHER_ENTRY;

typedef struct _EDD_STREAM_IO
{
    QUEUENODE               Node;
    ULONG                   Length;
    ULONG                   Entries;
    ULONG                   ReferenceCount; // For DSP use
    ULONG                   Reserved;
    SCATTER_GATHER_ENTRY    ScatterGatherTable[1];
    
} EDD_STREAM_IO, *PEDD_STREAM_IO;

typedef struct _EPD_DEBUG_BUFFER
{
    ULONG DebugInVal;
    ULONG DebugInScanCode;
} EPD_DEBUG_BUFFER;

typedef struct _EPD_GET_DEBUG_BUFFER {
    EPD_DEBUG_BUFFER *pDebugBuffer;
} EPD_GET_DEBUG_BUFFER, *PEPD_GET_DEBUG_BUFFER;

#endif // _EPD_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\ksfilter\ksdsp\tests\dspmon\dspmon.c ===
#include <windows.h>
#include <objbase.h>
#include <setupapi.h>
#include <devioctl.h>
#include <stdio.h>
#include <conio.h>
#include <ks.h>
#include <ksmedia.h>
#include "io.h"
#include "epd.h"

#define DSPMONVERSION "dspmon 4\n"

HANDLE 
OpenDefaultDevice(
    REFGUID InterfaceGUID
    )
{
    PSP_DEVICE_INTERFACE_DETAIL_DATA DeviceInterfaceDetails;
    SP_DEVICE_INTERFACE_DATA    DeviceInterfaceData;
    BYTE                        Storage[ 256 * sizeof( WCHAR ) + 
                                    sizeof( *DeviceInterfaceDetails ) ];
    HANDLE                      DeviceHandle;
    HDEVINFO                    Set;
    DWORD                       Error;

    Set = 
        SetupDiGetClassDevs( 
            (GUID *) InterfaceGUID,
            NULL,
            NULL,
            DIGCF_PRESENT | DIGCF_DEVICEINTERFACE );

    if (!Set) {
        printf( "error: NULL set returned (%u).\n", GetLastError());
        return 0;
    }       

    DeviceInterfaceData.cbSize = sizeof( DeviceInterfaceData );
    DeviceInterfaceDetails = (PSP_DEVICE_INTERFACE_DETAIL_DATA) Storage;

    SetupDiEnumDeviceInterfaces(
        Set,
        NULL,                       // PSP_DEVINFO_DATA DevInfoData
        (GUID *) InterfaceGUID,
        0,                          // DWORD MemberIndex
        &DeviceInterfaceData );

    DeviceInterfaceDetails->cbSize = sizeof( *DeviceInterfaceDetails );
    if (!SetupDiGetDeviceInterfaceDetail(
             Set,
             &DeviceInterfaceData,
             DeviceInterfaceDetails,
             sizeof( Storage ),
             NULL,                           // PDWORD RequiredSize
             NULL )) {                       // PSP_DEVINFO_DATA DevInfoData

        printf( 
            "error: unable to retrieve device details for set item (%u).\n",
            GetLastError() );
        DeviceHandle = INVALID_HANDLE_VALUE;
    } else {

        DeviceHandle = CreateFile(
            DeviceInterfaceDetails->DevicePath,
            GENERIC_READ | GENERIC_WRITE,
            0,
            NULL,
            OPEN_EXISTING,
            FILE_ATTRIBUTE_NORMAL | FILE_FLAG_OVERLAPPED,
            NULL);
    }
    SetupDiDestroyDeviceInfoList(Set);

    return DeviceHandle;
}


BOOL done = FALSE;
HANDLE hTest;

LONG WaitForChar( void *dummy )
{
    BOOL bRet;
    EPD_GET_DEBUG_BUFFER GetDebugBuffer;
    volatile EPD_DEBUG_BUFFER *pDebugBuffer;
    ULONG nBytes;
    int c;

    // get the debug buffer
    bRet = DeviceIoControl (
               hTest,
               (DWORD) IOCTL_EPD_GET_DEBUG_BUFFER,    // instruction to execute
               NULL, 0,    // no input buffer
               &GetDebugBuffer, sizeof (EPD_GET_DEBUG_BUFFER),    // no output buffer
               &nBytes, 0
           );
    printf ("Return 0x%08x\n", bRet);
    pDebugBuffer = GetDebugBuffer.pDebugBuffer;
    printf ("IOCTL_EPD_GET_DEBUG_BUFFER: GetDebugBuffer.pDebugBuffer 0x%x\n", pDebugBuffer);

    for (;;)
    {
        c = getchar();
        if (c=='~') break;

        while (pDebugBuffer->DebugInVal!=0) ;
    	pDebugBuffer->DebugInVal = c;
	}

    done = TRUE;

    return 0;
}

int __cdecl main(int argc, char **argv) 
{
    HANDLE      WaitThread;
    ULONG       WaitThreadId;
    ULONG       nBytes;
    static char DebugStr[4096];
    BOOL        bRet;

    printf (DSPMONVERSION);

    hTest = 
        OpenDefaultDevice( &KSCATEGORY_ESCALANTE_PLATFORM_DRIVER );
 
    if (hTest == (HANDLE) -1) {
        printf ("Could not get handle for EPD (%08x)\n", GetLastError());
        return 0;
    }

    // spin and monitor the debug buffer, ^c to stop :))
    
    WaitThread = CreateThread( NULL, 0, WaitForChar, 0, 0, &WaitThreadId );

    while (!done) 
    {

        // get the debug buffer
        bRet = DeviceIoControl (
               hTest,
               (DWORD) IOCTL_EPD_GET_CONSOLE_CHARS,    // instruction to execute
               NULL, 0,    // no input buffer
               DebugStr, 256,
               &nBytes, 0
           );
        fwrite(DebugStr,1,nBytes,stdout);
	}

    //
    // Wait for thread to complete
    //    
    WaitForSingleObject( WaitThread, INFINITE );    

	// be a nice program and close up shop
    CloseHandle(hTest);
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\ksfilter\ksdsp\inc\tm\mmio.h ===
/*      Master TM-1 MMIO location definition & access file.
 *
 *        this include file is THE master reference for names and
 *        addresses of TM-1 MMIO locations. The file also provides
 *        an access macro for MMIO locations. This is the recommended
 *        C program way to access any MMIO locations on TM-1. C-code using
 *        this access mechanism will be forward portable.
 *
 *                USAGE OF THE MACROS
 *                ===================
 *
 *      ---------------- example code begin -------------------
 *      #include <tm1/mmio.h>
 *      ...
 *      unsigned value_of_vi_status, value_of_vi_control;
 *      ...
 *
 *      value_of_vi_status = MMIO(VI_STATUS);
 *      MMIO(VI_CTL    )   = value_of_vi_control;
 *
 *      ---------------- example code end -------------------
 *      In the above code, VI_STATUS and VI_CTL     are #define's
 *      defined in this file. These are the offsets of the corresponding
 *      registers with respect to MMIO_base. The #define MMIO is also
 *      defined in this file and does the necessary computations to add 
 *      the MMIO_base value and the given offset (VI_STATUS and VI_CTL    
 *      in the example).
 *      On stand alone systems, value of MMIO_base is 0xEFE00000. To get
 *      this value, the compilation command should supply -DSTAND_ALONE
 *      to the compiler. 
 */

#ifndef __mmio_h__
#define __mmio_h__

#define MMIO(x, offset)    (((volatile unsigned int *)x->IoBaseTM1)[(offset) >> 2])


/***********************************************************************/
/*
            The #define's in this file are in grouped into sections.
            The sections are made (roughly) according to the appearances
            of the definitions in TM-1 Preliminary Data Book of
            September 1995.
            
            Section I has general register definitions from Chapter 
            "TM-1 CPU Architecture". This includes timers, interrupt
            vectors, interrupt control registers, and debug support
            registers.

            Section II has cache related definitions from 
            "Eino's cache/memory architecture spec" document 
            available on mosaic:
              TriMedia Development Internal Documents
                 -> TriMedia Hardware/VLSI Desgin Documents
                   -> Eino's cache/memory architecture spec 

            Section III has Video In definitions from Chapter 
            "TM-1 Video In".

            Section IV has Video Out definitions from Chapter 
            "TM-1 Video Out".

            Section V has Audio In definitions from  Chapter 
            "TM-1 Audio In".

            Section VI has Audio Out definitions from Chapter 
            "TM-1 Audio Out".

            Section VII has PCI related definitions. These are based
            on an email from  Ken-Su Tan. 
/*
 *                 Section I
 *                 =========
 *         General register definitions from 
 *         chapter "TM-1 Architecture"  TM-1 Preliminary Data Book
 *         of September 1995. 
 */

#define DRAM_BASE               (0x100000)
#define DRAM_LIMIT              (0x100004)
#define TILER_END               (0x100030)
#define MMIO_BASE               (0x100400)
#define EXCVEC                  (0x100800)
#define ISETTING(_n_)           (0x100810 + (_n_<<2))
#define ISETTING0               (0x100810)
#define ISETTING1               (0x100814)
#define ISETTING2               (0x100818)
#define ISETTING3               (0x10081c)
#define IPENDING                (0x100820)
#define ICLEAR                  (0x100824)
#define IMASK                   (0x100828)
#define INTVEC(_n_)             (0x100880 + (_n_<<2))
#define INTVEC0                 (0x100880)
#define INTVEC1                 (0x100884)
#define INTVEC2                 (0x100888)
#define INTVEC3                 (0x10088c)
#define INTVEC4                 (0x100890)
#define INTVEC5                 (0x100894)
#define INTVEC6                 (0x100898)
#define INTVEC7                 (0x10089c)
#define INTVEC8                 (0x1008a0)
#define INTVEC9                 (0x1008a4)
#define INTVEC10                (0x1008a8)
#define INTVEC11                (0x1008ac)
#define INTVEC12                (0x1008b0)
#define INTVEC13                (0x1008b4)
#define INTVEC14                (0x1008b8)
#define INTVEC15                (0x1008bc)
#define INTVEC16                (0x1008c0)
#define INTVEC17                (0x1008c4)
#define INTVEC18                (0x1008c8)
#define INTVEC19                (0x1008cc)
#define INTVEC20                (0x1008d0)
#define INTVEC21                (0x1008d4)
#define INTVEC22                (0x1008d8)
#define INTVEC23                (0x1008dc)
#define INTVEC24                (0x1008e0)
#define INTVEC25                (0x1008e4)
#define INTVEC26                (0x1008e8)
#define INTVEC27                (0x1008ec)
#define INTVEC28                (0x1008f0)
#define INTVEC29                (0x1008f4)
#define INTVEC30                (0x1008f8)
#define INTVEC31                (0x1008fc)
#define TIMER_TMODULUS(_n_)     (0x100C00 + (_n_*0x20))
#define TIMER_TVALUE(_n_)       (0x100C04 + (_n_*0x20))
#define TIMER_TCTL(_n_)         (0x100C08 + (_n_*0x20))
#define TIMER1                  (0x100C00)
#define TIMER1_TMODULUS         (0x100C00)
#define TIMER1_TVALUE           (0x100C04)
#define TIMER1_TCTL             (0x100C08)
#define TIMER2                  (0x100C20)
#define TIMER2_TMODULUS         (0x100C20)
#define TIMER2_TVALUE           (0x100C24)
#define TIMER2_TCTL             (0x100C28)
#define TIMER3                  (0x100C40)
#define TIMER3_TMODULUS         (0x100C40)
#define TIMER3_TVALUE           (0x100C44)
#define TIMER3_TCTL             (0x100C48)
#define SYSTIMER                (0x100C60)
#define SYSTIMER_TMODULUS       (0x100C60)
#define SYSTIMER_TVALUE         (0x100C64)
#define SYSTIMER_TCTL           (0x100C68)
#define BICTL                   (0x101000)
#define BINSTLOW                (0x101004)
#define BINSTHIGH               (0x101008)
#define BDCTL                   (0x101020)
#define BDATAALOW               (0x101030)
#define BDATAAHIGH              (0x101034)
#define BDATAVAL                (0x101038)
#define BDATAMASK               (0x10103c)

/*
 *                   Section II
 *                   ==========
 *         MMIO register definitions for icache and dcache.
 *         These definitions are taken from Table 2 of
 *         "Eino's cache/memory architecture spec" document 
 *          available on mosaic:
 *             TriMedia Development Internal Documents
 *                -> TriMedia Hardware/VLSI Desgin Documents
 *                  -> Eino's cache/memory architecture spec 
 * 
 */

/*  See Section I  above for DRAM_BASE, DRAM_LIMIT and MMIO_BASE */

#define DRAM_CACHEABLE_LIMIT          (0x100008)
#define MEMORY_EVENTS                 (0x10000c)
#define DC_LOCK_CTL                   (0x100010)
#define DC_LOCK_LOW                   (0x100014)
#define DC_LOCK_HIGH                  (0x100018)
#define DC_PARAMS                     (0x10001c)

#define IC_PARAMS                     (0x100020)
#define MM_CONFIG                     (0x100100)
#define ARB_BW_CTL                    (0x100104)
#define POWER_DOWN                    (0x100108)
#define IC_LOCK_CTRL                  (0x100210)
#define IC_LOCK_LOW                   (0x100214)
#define IC_LOCK_HIGH                  (0x100218)
#define PLL_RATIOS                    (0x100300)


/*
 *                   Section III
 *                   ==========
 *        MMIO register definitions for Video In. 
 *        These definitions are from Chapter on Video In  
 *        in the data book. 
 */

#define VI_STATUS         (0x101400)
#define VI_CTL            (0x101404)
#define VI_CLOCK          (0x101408)
#define VI_CAP_START      (0x10140c)
#define VI_CAP_SIZE       (0x101410)
#define VI_BASE1          (0x101414)
#define VI_Y_BASE_ADR     (0x101414)
#define VI_BASE2          (0x101418)
#define VI_U_BASE_ADR     (0x101418)
#define VI_SIZE1          (0x10141c)
#define VI_V_BASE_ADR     (0x10141c)
#define VI_SIZE2          (0x101420)
#define VI_UV_DELTA       (0x101420)
#define VI_Y_DELTA        (0x101424)

/*
 *                   Section IV.
 *                   ==========
 *       MMIO register definitions for Video Out.
 *       These definitions are taken from Chapter on Video Out
 *       of the data book. 
 */

#define VO_STATUS          (0x101800)
#define VO_CTL             (0x101804)
#define VO_CLOCK           (0x101808)
#define VO_FRAME           (0x10180c)
#define VO_FIELD           (0x101810)
#define VO_LINE            (0x101814)
#define VO_IMAGE           (0x101818)
#define VO_YTHR            (0x10181c)
#define VO_OLSTART         (0x101820)
#define VO_OLHW            (0x101824)
#define VO_YADD            (0x101828)
#define VO_UADD            (0x10182c)
#define VO_VADD            (0x101830)
#define VO_OLADD           (0x101834)
#define VO_VUF             (0x101838)
#define VO_YOLF            (0x10183c)
 
/*
 *                   Section V
 *                   =========
 *       MMIO register definitions for Audio In.
 *       These definitions are from chapter  
 *       "TM-1 Audio In" of the data book. 
 *       
 *       
 */

#define AI_STATUS         (0x101c00)
#define AI_CTL            (0x101c04)
#define AI_SERIAL         (0x101c08)
#define AI_FRAMING        (0x101c0c)
#define AI_FREQ           (0x101c10)
#define AI_BASE1          (0x101c14)
#define AI_BASE2          (0x101c18)
#define AI_SIZE           (0x101c1c)

/*
 *                   Section VI
 *                   ==========
 *       MMIO register definitions for Audio Out.
 *       These definitions are from chapter 
 *       "TM-1 Audio Out" of the data book.
 *       
 */

#define AO_STATUS         (0x102000)
#define AO_CTL            (0x102004)
#define AO_SERIAL         (0x102008)
#define AO_FRAMING        (0x10200c)
#define AO_FREQ           (0x102010)
#define AO_BASE1          (0x102014)
#define AO_BASE2          (0x102018)
#define AO_SIZE           (0x10201c)
#define AO_CC             (0x102020)
#define AO_CFC            (0x102024)

/*
 *                   Section VII
 *                   ===========
 *         These are PCI related definitions. This is based
 *         on information provided by Ken-Su Tan.
 */

#define  BIU_STATUS   (0x103004)
#define  BIU_CTL      (0x103008)
#define  PCI_ADR      (0x10300C)
#define  PCI_DATA     (0x103010)
#define  CONFIG_ADR   (0x103014)
#define  CONFIG_DATA  (0x103018)
#define  CONFIG_CTL   (0x10301C)
#define  IO_ADR       (0x103020)
#define  IO_DATA      (0x103024)
#define  IO_CTL       (0x103028)
#define  SRC_ADR      (0x10302C)
#define  DEST_ADR     (0x103030)
#define  DMA_CTL      (0x103034)
#define  INT_CTL      (0x103038)
 

/*
 *
 *                   Section VIII
 *                   ============
 *
 *         The SEM device. To be added to databook.
*/

#define  SEM          (0x100500)

/*
 *
 *                 Section IX
 *                 ==========
 *
 *               JTAG registers - values from renga's mail
 */


#define  JTAG_DATA_IN	(0x103800)
#define  JTAG_DATA_OUT	(0x103804)
#define  JTAG_CTL		(0x103808)

/*
 *
 *                 Section X
 *                 =========
 *
 *               ICP Registers
 */

#define  ICP_MPC		(0x102400)
#define  ICP_MIR		(0x102404)
#define  ICP_DP			(0x102408)
#define  ICP_DR			(0x102410)
#define  ICP_SR			(0x102414)

/*
 *
 *                 Section X
 *                 =========
 *
 *               VLD Registers
 */

#define  VLD_COMMAND	(0x102800)
#define  VLD_SR			(0x102804)
#define  VLD_QS			(0x102808)
#define  VLD_PI			(0x10280c)
#define  VLD_STATUS		(0x102810)
#define  VLD_IMASK		(0x102814)
#define  VLD_CTL		(0x102818)
#define  VLD_BIT_ADR	(0x10281c)
#define  VLD_BIT_CNT	(0x102820)
#define  VLD_MBH_ADR	(0x102824)
#define  VLD_MBH_CNT	(0x102828)
#define  VLD_RL_ADR		(0x10282c)
#define  VLD_RL_CNT		(0x102830)

/*
 *
 *                 Section XI
 *                 ==========
 *
 *               I2C Registers
 */

#define  IIC_AR			(0x103400)
#define  IIC_DR			(0x103404)
#define  IIC_STATUS		(0x103408)
#define  IIC_CTL		(0x10340c)

/*
 *
 *                 Section XII
 *                 ===========
 *
 *               SSI Registers
 */

#define  SSI_CTL		(0x102c00)
#define  SSI_CSR		(0x102c04)
#define  SSI_TXDR		(0x102c10)
#define  SSI_RXDR		(0x102c20)
#define  SSI_RXACK		(0x102c24)

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\ksfilter\ksdsp\inc\ksdspmsg.h ===
/*++

    Copyright (c) 1999 Microsoft Corporation

Module Name:

    ksdspmsg.h

Abstract:
    
    message identifiers and parameters


Author:

    bryanw 05-Mar-1999
        pulled from ksdsp.h

--*/

//
// Define message parameters.  Note that enums are translated to specific
// platform independant structures (e.g. UINT32).
//

typedef enum {
    KSDSP_MSG_LOAD_TASK,
    KSDSP_MSG_FREE_TASK,
    KSDSP_MSG_OPEN_DATA_CHANNEL,
    KSDSP_MSG_CLOSE_DATA_CHANNEL,
    KSDSP_MSG_SET_CHANNEL_FORMAT,
    KSDSP_MSG_SET_CHANNEL_STATE,
    KSDSP_MSG_PROPERTY,
    KSDSP_MSG_METHOD,
    KSDSP_MSG_EVENT,
    KSDSP_MSG_SET_TARGET_CHANNEL,
    KSDSP_MSG_WRITE_STREAM,
    KSDSP_MSG_READ_STREAM
} KSDSP_MSG, *PKSDSP_MSG;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\ksfilter\ksdsp\tests\epdtest\cobtest.h ===
#ifndef __cobtest_h__
#define __cobtest_h__

typedef struct _COBTEST_CONTROL_BUFFER
{
    // required part
    QUEUENODE QueueNode;
    // user data to pass to the routine on the DSP
    ULONG ul0, ul1;
} COBTEST_CONTROL_BUFFER, *PCOBTEST_CONTROL_BUFFER;

#endif // __cobtest_h__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\ksfilter\midipass\guids.c ===
/*	-	-	-	-	-	-	-	-	*/
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) Microsoft Corporation, 1995 - 1996  All Rights Reserved.
//
/*	-	-	-	-	-	-	-	-	*/

#include <ntddk.h>
#include <windef.h>
#include <avguid.h>
#include "guids.h"

/*	-	-	-	-	-	-	-	-	*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\ksfilter\midipass\common.h ===
/*	-	-	-	-	-	-	-	-	*/
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) Microsoft Corporation, 1995 - 1997  All Rights Reserved.
//
/*	-	-	-	-	-	-	-	-	*/

#include <ntddk.h>
#include <windef.h>
#include <tchar.h>
#include <avddk.h>
#include "guids.h"
#include "private.h"

/*	-	-	-	-	-	-	-	-	*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\ksfilter\ksdsp\tests\epdtest\epdtest.c ===
#include <windows.h>
#include <objbase.h>
#include <setupapi.h>
#include <devioctl.h>
#include <stdio.h>
#include <conio.h>
#include <ks.h>
#include <ksmedia.h>
#include "epd.h"
#include "cobtest.h"

#define EPDTESTVERSION "EPDtest 2/11/97\n"

#define INSTRUCTIONS "\nCommands:\n" \
"\t?,h Display this message\n" \
"\tc Load a cob library\n" \
"\td Release an interface\n" \
"\te Run the cancel test\n" \
"\tl Load mmosa kernel\n" \
"\tr Do the BIU_CTL clear reset thing (Start tht DSP)\n" \
"\ts Do the BIU_CTL set reset thing (Stop the DSP)\n" \
"\tt Do the current miscellaneous test\n" \
"\tT Put an irp into the cobtest deadend queue\n" \
"\tx Exit\n"

#define PROMPT "EPDtest>"

HANDLE 
OpenDefaultDevice(
    REFGUID InterfaceGUID
    )
{
    PSP_DEVICE_INTERFACE_DETAIL_DATA DeviceInterfaceDetails;
    SP_DEVICE_INTERFACE_DATA    DeviceInterfaceData;
    BYTE                        Storage[ 256 * sizeof( WCHAR ) + 
                                    sizeof( *DeviceInterfaceDetails ) ];
    HANDLE                      DeviceHandle;
    HDEVINFO                    Set;
    DWORD                       Error;

    Set = 
        SetupDiGetClassDevs( 
            InterfaceGUID,
            NULL,
            NULL,
            DIGCF_PRESENT | DIGCF_DEVICEINTERFACE );

    if (!Set) {
        printf( "error: NULL set returned (%u).\n", GetLastError());
        return 0;
    }       

    DeviceInterfaceData.cbSize = sizeof( DeviceInterfaceData );
    DeviceInterfaceDetails = (PSP_DEVICE_INTERFACE_DETAIL_DATA) Storage;

    SetupDiEnumDeviceInterfaces(
        Set,
        NULL,                       // PSP_DEVINFO_DATA DevInfoData
        InterfaceGUID,
        0,                          // DWORD MemberIndex
        &DeviceInterfaceData );

    DeviceInterfaceDetails->cbSize = sizeof( *DeviceInterfaceDetails );
    if (!SetupDiGetDeviceInterfaceDetail(
             Set,
             &DeviceInterfaceData,
             DeviceInterfaceDetails,
             sizeof( Storage ),
             NULL,                           // PDWORD RequiredSize
             NULL )) {                       // PSP_DEVINFO_DATA DevInfoData

        printf( 
            "error: unable to retrieve device details for set item (%u).\n",
            GetLastError() );
        DeviceHandle = INVALID_HANDLE_VALUE;
    } else {

        DeviceHandle = CreateFile(
            DeviceInterfaceDetails->DevicePath,
            GENERIC_READ | GENERIC_WRITE,
            0,
            NULL,
            OPEN_EXISTING,
            FILE_ATTRIBUTE_NORMAL | FILE_FLAG_OVERLAPPED,
            NULL);
    }
    SetupDiDestroyDeviceInfoList(Set);

    return DeviceHandle;
}


int __cdecl main(int argc, char **argv) {

    HANDLE hTest;
    ULONG nBytes;

    BOOL bRet;

    int iRead;
    BOOL fDone = FALSE;
    char sz[256], cCode;
    char szFileName[256];

    EDD_LOAD_LIBRARY        *pMsgLoadLibrary;
    EDD_RELEASE_INTERFACE   MsgReleaseInterface;

    ULONG ulSize;

    printf (EPDTESTVERSION);

    hTest = 
        OpenDefaultDevice( &KSCATEGORY_ESCALANTE_PLATFORM_DRIVER );
 
    if (hTest != INVALID_HANDLE_VALUE) {

        printf("Got handle for EPD.\n");

        printf (INSTRUCTIONS);
        while (!fDone) {
            printf (PROMPT);
            if (gets (sz) == NULL) strcpy (sz, "x");
            cCode = sz[0];    // if user types a blank before the command, too bad

            switch (cCode) {

            case 'c':
            case 'C':
                printf ("Enter filename of DSP library>");
                gets (szFileName);
                printf ("FileName >%s<\n", szFileName);
                ulSize = sizeof(EDD_LOAD_LIBRARY) + strlen(szFileName);
                printf ("sizeof(EDD_LOAD_LIBRARY) %d\n", sizeof(EDD_LOAD_LIBRARY)); 
                printf ("size is %d\n", ulSize);
                pMsgLoadLibrary = malloc (ulSize);
                pMsgLoadLibrary->Node.Destination = EDD_REQUEST_QUEUE;
                pMsgLoadLibrary->Node.ReturnQueue = 0;
                pMsgLoadLibrary->Node.Request = EDD_LOAD_LIBRARY_REQUEST;
                pMsgLoadLibrary->Node.Result = 0;
                pMsgLoadLibrary->IUnknown = 0;
                pMsgLoadLibrary->IQueue = 0;
                strcpy (pMsgLoadLibrary->Name, szFileName);

                bRet = 0;
                nBytes = 0;
                bRet = DeviceIoControl (
                    hTest,
                    (DWORD) IOCTL_EPD_MSG,    // instruction to execute
                    pMsgLoadLibrary, ulSize,    // input buffer
                    pMsgLoadLibrary, ulSize,    // output buffer
                    &nBytes, 0);
                printf ("Return 0x%08x\n", bRet);
                if (!bRet) {
                    printf ("Error return, last error 0x%08x\n", GetLastError());
                }
                printf ("nBytes %d\n", nBytes);
                printf ("Result 0x%08x\n", pMsgLoadLibrary->Node.Result);
                printf ("IUnknown 0x%08x\n", pMsgLoadLibrary->IUnknown);
                printf ("IQueue   0x%08x\n", pMsgLoadLibrary->IQueue);

                free (pMsgLoadLibrary);
                break;

            case 'd':
            case 'D':
            {
                char szInterface[16], *pszEnd;
                printf ("Enter interface ID in hex:");
                gets (szInterface);
                MsgReleaseInterface.IUnknown = strtoul(szInterface, &pszEnd, 16);
                printf ("Interface ID = %s (0x%x)\n",szInterface,MsgReleaseInterface.IUnknown);
                printf ("releasing...\n");

                MsgReleaseInterface.Node.Destination = EDD_REQUEST_QUEUE;
                MsgReleaseInterface.Node.ReturnQueue = 0;
                MsgReleaseInterface.Node.Request = EDD_RELEASE_INTERFACE_REQUEST;
                MsgReleaseInterface.Node.Result = 0;

                bRet = 0;
                nBytes = 0;
                bRet = DeviceIoControl (
                    hTest,
                    (DWORD) IOCTL_EPD_MSG,    // instruction to execute
                    &MsgReleaseInterface, sizeof(EDD_RELEASE_INTERFACE),    // input buffer
                    &MsgReleaseInterface, sizeof(EDD_RELEASE_INTERFACE),    // output buffer
                    &nBytes, 0);
                printf ("Return 0x%08x\n", bRet);
                if (!bRet) {
                    printf ("Error return, last error 0x%08x\n", GetLastError());
                }
                printf ("nBytes %d\n", nBytes);
                printf("result 0x%08x\n", MsgReleaseInterface.Node.Result);
                break;
            }

            case 'e':
            case 'E':
            {
                printf ("Call the cancel ioctl\n");

                bRet = DeviceIoControl (
                    hTest,
                    (DWORD) IOCTL_EPD_CANCEL,    // instruction to execute
                    NULL, 0, // no input or output buffers
                    NULL, 0,
                    &nBytes, 0);
                printf ("Return 0x%08x\n", bRet);
                if (!bRet) {
                    printf ("Error return, last error 0x%08x\n", GetLastError());
                }
                printf ("nBytes %d\n", nBytes);
                break;
            }

            case 'l':
            case 'L':
                printf ("Load Kernel!\n");
                bRet = DeviceIoControl (
                    hTest,
                    (DWORD) IOCTL_EPD_LOAD,    // instruction to execute
                    NULL, 0,    // no input buffer
                    NULL, 0,    // no output buffer
                    &nBytes, 0);
                printf ("Return 0x%08x\n", bRet);
                if (!bRet) {
                    printf ("Error return, last error 0x%08x\n", GetLastError());
                }
                printf ("nBytes %d\n", nBytes);
                break;

            case 'r':
            case 'R':
                printf ("Reset!\n");
                bRet = DeviceIoControl (
                    hTest,
                    (DWORD) IOCTL_EPD_CLR_RESET,    // instruction to execute
                    NULL, 0,    // no input buffer
                    NULL, 0,    // no output buffer
                    &nBytes, 0);
                printf ("Return 0x%08x\n", bRet);
                if (!bRet) {
                    printf ("Error return, last error 0x%08x\n", GetLastError());
                }
                printf ("nBytes %d\n", nBytes);
                break;

            case 's':
            case 'S':
                printf ("Set the reset\n");
                bRet = DeviceIoControl (
                    hTest,
                    (DWORD) IOCTL_EPD_SET_RESET,    // instruction to execute
                    NULL, 0,    // no input buffer
                    NULL, 0,    // no output buffer
                    &nBytes, 0);
                printf ("Return 0x%08x\n", bRet);
                if (!bRet) {
                    printf ("Error return, last error 0x%08x\n", GetLastError());
                }
                printf ("nBytes %d\n", nBytes);
                break;

            case 't':
            {
                ULONG rgulArray[100];
                ULONG i;

                printf ("Do miscellaneous test\n");
                for (i=0; i<100; i++) {
                    rgulArray[i] = i;
                }

                bRet = DeviceIoControl (
                    hTest,
                    (DWORD) IOCTL_EPD_TEST,    // instruction to execute
                    rgulArray, 10*sizeof(ULONG),  // input buffer
                    rgulArray, 100*sizeof(ULONG),  // output buffer
                    &nBytes, 0);
                printf ("Return 0x%08x\n", bRet);
                if (!bRet) {
                    printf ("Error return, last error 0x%08x\n", GetLastError());
                }
                printf ("nBytes %d\n", nBytes);
                break;
            } // test1

            case 'T':
            {
                QUEUENODE *pNode;

                // Load cobtest1
                printf ("Put an irp into cobtest's dead-end queue\n");
                strcpy (szFileName, "cobtest1.cob");
                printf ("FileName >%s<\n", szFileName);
                ulSize = sizeof(EDD_LOAD_LIBRARY) + strlen(szFileName);
                pMsgLoadLibrary = malloc (ulSize);
                pMsgLoadLibrary->Node.Destination = EDD_REQUEST_QUEUE;
                pMsgLoadLibrary->Node.ReturnQueue = 0;
                pMsgLoadLibrary->Node.Request = EDD_LOAD_LIBRARY_REQUEST;
                pMsgLoadLibrary->Node.Result = 0;
                pMsgLoadLibrary->IUnknown = 0;
                pMsgLoadLibrary->IQueue = 0;
                strcpy (pMsgLoadLibrary->Name, szFileName);
                bRet = 0;
                nBytes = 0;
                bRet = DeviceIoControl (
                    hTest,
                    (DWORD) IOCTL_EPD_MSG,    // instruction to execute
                    pMsgLoadLibrary, ulSize,    // input buffer
                    pMsgLoadLibrary, ulSize,    // output buffer
                    &nBytes, 0);
                printf ("Return 0x%08x\n", bRet);
                if (!bRet) {
                    printf ("Error return, last error 0x%08x\n", GetLastError());
                }
                printf ("nBytes %d\n", nBytes);
                printf ("Result 0x%08x\n", pMsgLoadLibrary->Node.Result);
                printf ("IUnknown 0x%08x\n", pMsgLoadLibrary->IUnknown);
                printf ("IQueue   0x%08x\n", pMsgLoadLibrary->IQueue);

                // Send an irp to the dead-end queue
                pNode = malloc(sizeof(QUEUENODE));
                pNode->Destination = pMsgLoadLibrary->IQueue;
                pNode->Destination = pMsgLoadLibrary->IQueue;
                pNode->ReturnQueue = 0;
                pNode->Request = 3; // put this irp into the dead-end queue
                pNode->Result = 0;
                bRet = DeviceIoControl (
                    hTest,
                    (DWORD) IOCTL_EPD_MSG,    // instruction to execute
                    pNode, sizeof(QUEUENODE),    // input buffer
                    pNode, sizeof(QUEUENODE),    // output buffer
                    &nBytes, 0);
                printf ("Return 0x%08x\n", bRet);
                printf ("nBytes %d\n", nBytes);

                printf ("pNode->Result %d 0x%08x\n", pNode->Result, pNode->Result);
                free(pNode);

                printf ("release the library\n");
                printf ("release the iqueue\n");
                MsgReleaseInterface.Node.Destination = EDD_REQUEST_QUEUE;
                MsgReleaseInterface.Node.ReturnQueue = 0;
                MsgReleaseInterface.Node.Request = EDD_RELEASE_INTERFACE_REQUEST;
                MsgReleaseInterface.Node.Result = 0;
                MsgReleaseInterface.IUnknown = pMsgLoadLibrary->IQueue;

                bRet = 0;
                nBytes = 0;
                bRet = DeviceIoControl (
                    hTest,
                    (DWORD) IOCTL_EPD_MSG,    // instruction to execute
                    &MsgReleaseInterface, sizeof(EDD_RELEASE_INTERFACE),    // input buffer
                    &MsgReleaseInterface, sizeof(EDD_RELEASE_INTERFACE),    // output buffer
                    &nBytes, 0);
                printf ("Return 0x%08x\n", bRet);
                if (!bRet) {
                    printf ("Error return, last error 0x%08x\n", GetLastError());
                }
                printf ("nBytes %d\n", nBytes);
                printf("result 0x%08x\n", MsgReleaseInterface.Node.Result);


                printf ("release the iunknown\n");
                MsgReleaseInterface.Node.Destination = EDD_REQUEST_QUEUE;
                MsgReleaseInterface.Node.ReturnQueue = 0;
                MsgReleaseInterface.Node.Request = EDD_RELEASE_INTERFACE_REQUEST;
                MsgReleaseInterface.Node.Result = 0;
                MsgReleaseInterface.IUnknown = pMsgLoadLibrary->IUnknown;

                bRet = 0;
                nBytes = 0;
                bRet = DeviceIoControl (
                    hTest,
                    (DWORD) IOCTL_EPD_MSG,    // instruction to execute
                    &MsgReleaseInterface, sizeof(EDD_RELEASE_INTERFACE),    // input buffer
                    &MsgReleaseInterface, sizeof(EDD_RELEASE_INTERFACE),    // output buffer
                    &nBytes, 0);
                printf ("Return 0x%08x\n", bRet);
                if (!bRet) {
                    printf ("Error return, last error 0x%08x\n", GetLastError());
                }
                printf ("nBytes %d\n", nBytes);
                printf("result 0x%08x\n", MsgReleaseInterface.Node.Result);
                printf("released both interface pointers\n");

                free (pMsgLoadLibrary);
                break;
            } // Test2

            case 'x':
            case 'X':
                fDone = TRUE;
                break;

            default:
                printf ("Huh? >%c<\n", cCode);
            case 'h':
            case 'H':
            case '?':
                printf (INSTRUCTIONS);
                break;

            } // end switch on command

        } // end while next instruction

        printf ("Done\n");


        // Be a nice program and close up shop.
        CloseHandle(hTest);

    } else {
        printf("Can't get a handle to EPD\n");
    }
    return 1;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\ksfilter\midipass\guids.h ===
/*	-	-	-	-	-	-	-	-	*/
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) Microsoft Corporation, 1995 - 1996  All Rights Reserved.
//
/*	-	-	-	-	-	-	-	-	*/

DEFINE_GUID(AVPROVIDER_Microsoft, 0x675502A0L, 0x83ED, 0x101B, 0x95, 0x59, 0xFE, 0x17, 0xED, 0xBD, 0x33, 0x50);
DEFINE_GUID(AVPRODUCT_Microsoft, 0xF9B8EC80L, 0x1432, 0x11CF, 0xA5, 0xD6, 0x28, 0xDB, 0x04, 0xC1, 0x00, 0x00);

/*	-	-	-	-	-	-	-	-	*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\ksfilter\midipass\private.h ===
/*	-	-	-	-	-	-	-	-	*/
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) Microsoft Corporation, 1995 - 1996  All Rights Reserved.
//
/*	-	-	-	-	-	-	-	-	*/

#if (DBG)
#define STR_MODULENAME "midipass: "
#endif

#define USTR_INSTANCE_NAME TEXT("midipass")
#define USTR_CONNECTION_NAME TEXT("midipass.%u")

typedef struct {
	AVPIN_COMMUNICATION	Communication;
	PDEVICE_OBJECT		pdoConnection;
	PFILE_OBJECT		pfileobjectConnection;
} PIN_INFO, PPIN_INFO;

typedef struct {
	PAVDEVICE_INSTANCE	pdi;
	PDEVICE_OBJECT		pdoFunctional;
	PFILE_OBJECT		pfileobjectFunctional;
	PDEVICE_OBJECT		pdoConnection;
	PFILE_OBJECT		pfileobjectConnection;
	AVPIN_COMMUNICATION	Communication;
	FAST_MUTEX		fmutexConnect;
	LIST_ENTRY		leEventQueue;
	KSPIN_LOCK		spinEventQueue;
	FAST_MUTEX		fmutexDataQueue;
	LIST_ENTRY		leDataQueue;
} CONNECTION_INSTANCE, *PCONNECTION_INSTANCE;

typedef struct {
	PAVDEVICE_INSTANCE	pdi;
	PAVDATAFORMAT		pDataFormat;
	FAST_MUTEX		fmutexPin;
	WORK_QUEUE_ITEM		WorkQueueItem;
	KEVENT			eventWorkQueueItem;
	PIN_INFO		aPinInfo[];
} FUNCTIONAL_INSTANCE, *PFUNCTIONAL_INSTANCE;

/*	-	-	-	-	-	-	-	-	*/

//func.c
PDEVICE_OBJECT FindConnectionDeviceByDataFlow(
	IN PFUNCTIONAL_INSTANCE	pfi,
	IN AVPIN_DATAFLOW	DataFlow);
NTSTATUS funcConnect(
	IN PIRP			pIrp,
	IN PAVPIN_CONNECT	pConnect,
	OUT HANDLE*		phConnection);
NTSTATUS funcDispatch(
	IN PDEVICE_OBJECT	pDo,
	IN PIRP			pIrp);
NTSTATUS funcDispatchControl(
	IN PDEVICE_OBJECT	pDo,
	IN PIRP			pIrp);
NTSTATUS funcDispatch(
	IN PDEVICE_OBJECT	pDo,
	IN PIRP			pIrp);
VOID GenerateEvent(
	IN PFUNCTIONAL_INSTANCE	pfi,
	IN REFGUID		rguidEventSet,
	IN ULONG		idEvent,
	IN PVOID		pvEventData);

//connect.c
NTSTATUS connectDispatchCreate(
	IN PDEVICE_OBJECT	pDo,
	IN PIRP			pIrp);
NTSTATUS connectDispatchClose(
	IN PDEVICE_OBJECT	pDo,
	IN PIRP			pIrp);
NTSTATUS connectDispatchWrite(
	IN PDEVICE_OBJECT	pDo,
	IN PIRP			pIrp);
NTSTATUS connectDispatchRead(
	IN PDEVICE_OBJECT	pDo,
	IN PIRP			pIrp);
NTSTATUS connectDispatchControl(
	IN PDEVICE_OBJECT	pDo,
	IN PIRP			pIrp);

/*	-	-	-	-	-	-	-	-	*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\ksfilter\midipass\connect.c ===
/*	-	-	-	-	-	-	-	-	*/
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) Microsoft Corporation, 1995 - 1996  All Rights Reserved.
//
/*	-	-	-	-	-	-	-	-	*/

#include "common.h"

/*	-	-	-	-	-	-	-	-	*/
VOID CompleteIo(
	PCONNECTION_INSTANCE	pci,
	PKIRQL			pirqlOld)
{
	for (; !IsListEmpty(&pci->leDataQueue);) {
		PIRP	pIrp;

		pIrp = (PIRP)CONTAINING_RECORD(pci->leDataQueue.Flink, IRP, Tail.Overlay.ListEntry);
		if (pIrp->IoStatus.Status == STATUS_PENDING)
			break;
		RemoveHeadList(&pci->leDataQueue);
		IoSetCancelRoutine(pIrp, NULL);
		IoReleaseCancelSpinLock(*pirqlOld);
		IoCompleteRequest(pIrp, IO_SOUND_INCREMENT);
		IoAcquireCancelSpinLock(pirqlOld);
	}
}

/*	-	-	-	-	-	-	-	-	*/
VOID ReadQueueWorker(
	IN PVOID pvContext)
{
	PFUNCTIONAL_INSTANCE	pfi;
	PDEVICE_OBJECT		pdoRead;
	PDEVICE_OBJECT		pdoWrite;

	pfi = pvContext;
	ExAcquireFastMutex(&pfi->fmutexPin);
	if (!(pdoRead = FindConnectionDeviceByDataFlow(pfi, AVPIN_DATAFLOW_OUT)) || !(pdoWrite = FindConnectionDeviceByDataFlow(pfi, AVPIN_DATAFLOW_IN))) {
		KeSetEvent(&pfi->eventWorkQueueItem, IO_NO_INCREMENT, FALSE);
		ExReleaseFastMutex(&pfi->fmutexPin);
	} else {
		PCONNECTION_INSTANCE	pciRead;
		PCONNECTION_INSTANCE	pciWrite;
		KIRQL			irqlOld;
		ULONG			cbReadLength;
		ULONG			cbWriteLength;
		PUCHAR			pbReadBuffer;
		PUCHAR			pbWriteBuffer;
		PIRP			pirpRead;
		PIRP			pirpWrite;
		PLIST_ENTRY		pleRead;
		PLIST_ENTRY		pleWrite;

		pciRead = (PCONNECTION_INSTANCE)pdoRead->DeviceExtension;
		pciWrite = (PCONNECTION_INSTANCE)pdoWrite->DeviceExtension;
		ExAcquireFastMutex(&pciRead->fmutexConnect);
		ExAcquireFastMutex(&pciRead->fmutexDataQueue);
		ExAcquireFastMutex(&pciWrite->fmutexConnect);
		ExAcquireFastMutex(&pciWrite->fmutexDataQueue);
		ExReleaseFastMutex(&pfi->fmutexPin);
		IoAcquireCancelSpinLock(&irqlOld);
		cbReadLength = 0;
		cbWriteLength = 0;
		pleRead = pciRead->leDataQueue.Flink;
		pleWrite = pciWrite->leDataQueue.Flink;
		for (;;) {
			ULONG	cbMinCopy;

			if (!cbReadLength) {
				if (pleRead == &pciRead->leDataQueue)
					pleRead = NULL;
				else {
					PIO_STACK_LOCATION	pIrpStack;

					pirpRead = (PIRP)CONTAINING_RECORD(pleRead, IRP, Tail.Overlay.ListEntry);
					pleRead = pleRead->Flink;
					pIrpStack = IoGetCurrentIrpStackLocation(pirpRead);
					cbReadLength = pIrpStack->Parameters.Read.Length - pirpRead->IoStatus.Information;
					pbReadBuffer = (PBYTE)MmGetSystemAddressForMdl(pirpRead->MdlAddress) + pirpRead->IoStatus.Information;
				}
			}
			if (!cbWriteLength) {
				if (pleWrite == &pciWrite->leDataQueue)
					pleWrite = NULL;
				else {
					PIO_STACK_LOCATION	pIrpStack;

					pirpWrite = (PIRP)CONTAINING_RECORD(pleWrite, IRP, Tail.Overlay.ListEntry);
					pleWrite = pleWrite->Flink;
					pIrpStack = IoGetCurrentIrpStackLocation(pirpWrite);
					cbWriteLength = pIrpStack->Parameters.Write.Length - pirpWrite->IoStatus.Information;
					pbWriteBuffer = (PBYTE)MmGetSystemAddressForMdl(pirpWrite->MdlAddress) + pirpWrite->IoStatus.Information;
				}
			}
			if (!pleRead || pleWrite)
				break;
			cbMinCopy = min(cbReadLength, cbWriteLength);
			RtlCopyMemory(pbReadBuffer, pbWriteBuffer, cbMinCopy);
			cbReadLength -= cbMinCopy;
			pirpRead->IoStatus.Information += cbMinCopy;
			if (!cbReadLength)
				pirpRead->IoStatus.Status = STATUS_SUCCESS;
			else
				pbReadBuffer += cbMinCopy;
			pirpWrite->IoStatus.Information += cbMinCopy;
			if (!cbWriteLength)
				pirpWrite->IoStatus.Status = STATUS_SUCCESS;
			else
				pbWriteBuffer += cbMinCopy;
		}
		CompleteIo(pciRead, &irqlOld);
		CompleteIo(pciWrite, &irqlOld);
		IoReleaseCancelSpinLock(irqlOld);
		KeSetEvent(&pfi->eventWorkQueueItem, IO_NO_INCREMENT, FALSE);
		ExReleaseFastMutex(&pciWrite->fmutexDataQueue);
		ExReleaseFastMutex(&pciWrite->fmutexConnect);
		ExReleaseFastMutex(&pciRead->fmutexDataQueue);
		ExReleaseFastMutex(&pciRead->fmutexConnect);
	}
}

/*	-	-	-	-	-	-	-	-	*/
NTSTATUS eventAddHandlerData(
	IN PDEVICE_OBJECT	pDeviceObject,
	IN PAVEVENT_ENTRY	pEventEntry)
{
	PCONNECTION_INSTANCE	pci;
	KIRQL			irqlOld;

	pci = (PCONNECTION_INSTANCE)pDeviceObject->DeviceExtension;
	KeAcquireSpinLock(&pci->spinEventQueue, &irqlOld);
	InsertHeadList(&pci->leEventQueue, &pEventEntry->ListEntry);
	KeReleaseSpinLock(&pci->spinEventQueue, irqlOld);
	return STATUS_SUCCESS;
}

/*	-	-	-	-	-	-	-	-	*/
NTSTATUS eventRemoveHandlerData(
	IN PDEVICE_OBJECT	pDeviceObject,
	IN PAVEVENT_ENTRY	pEventEntry)
{
	PCONNECTION_INSTANCE	pci;
	KIRQL			irqlOld;

	pci = (PCONNECTION_INSTANCE)pDeviceObject->DeviceExtension;
	KeAcquireSpinLock(&pci->spinEventQueue, &irqlOld);
	RemoveEntryList(&pEventEntry->ListEntry);
	KeReleaseSpinLock(&pci->spinEventQueue, irqlOld);
	return STATUS_SUCCESS;
}

/*	-	-	-	-	-	-	-	-	*/
AVEVENT_ITEM gaDataItems[] = {
	{AVEVENT_DATA_INTERVAL_MARK, sizeof(AVEVENT_DATA_MARK)},
	{AVEVENT_DATA_POSITION_UPDATE, sizeof(AVEVENTDATA)},
	{AVEVENT_DATA_POSITION_MARK, sizeof(AVEVENT_DATA_MARK)},
	{AVEVENT_DATA_PRIORITY, sizeof(AVEVENTDATA)},
};

AVEVENT_SET gaEventSets[] = {
	{&AVEVENTSETID_Data, eventAddHandlerData, eventRemoveHandlerData, SIZEOF_ARRAY(gaDataItems), gaDataItems},
};

/*	-	-	-	-	-	-	-	-	*/
NTSTATUS propBufferAlignment(
	IN PIRP		pIrp,
	IN PAVPROPERTY	pProperty,
	IN OUT PVOID	pvData)
{
	*(PULONG)pvData = FILE_BYTE_ALIGNMENT;
	pIrp->IoStatus.Information = sizeof(ULONG);
	return STATUS_SUCCESS;
}

/*	-	-	-	-	-	-	-	-	*/
NTSTATUS propPosition(
	IN PIRP		pIrp,
	IN PAVPROPERTY	pProperty,
	IN OUT PVOID	pvData)
{
//!!	*(PLONGLONG)pvData = ((PCONNECTION_INSTANCE)IoGetCurrentIrpStackLocation(pIrp)->DeviceObject->DeviceExtension)->llByteIo;
	pIrp->IoStatus.Information = sizeof(LONGLONG);
	return STATUS_SUCCESS;
}

/*	-	-	-	-	-	-	-	-	*/
NTSTATUS propPriority(
	IN PIRP		pIrp,
	IN PAVPROPERTY	pProperty,
	IN OUT PVOID	pvData)
{
//!!	*(PAVPRIORITY)pvData = ((PCONNECTION_INSTANCE)IoGetCurrentIrpStackLocation(pIrp)->DeviceObject->DeviceExtension)->Priority;
	pIrp->IoStatus.Information = sizeof(AVPRIORITY);
	return STATUS_SUCCESS;
}

/*	-	-	-	-	-	-	-	-	*/
NTSTATUS propTimeDelta(
	IN PIRP		pIrp,
	IN PAVPROPERTY	pProperty,
	IN OUT PVOID	pvData)
{
#if 0
	PCONNECTION_INSTANCE	pci;
	KIRQL			irqlOld;

	pci = (PCONNECTION_INSTANCE)IoGetCurrentIrpStackLocation(pIrp)->DeviceObject->DeviceExtension;
	KeAcquireSpinLock(&pci->spinState, &irqlOld);
	switch (pci->State) {
	case AVSTATE_STOP:
	case AVSTATE_IDLE:
		*(PLONGLONG)pvData = pci->llTimeBase;
		break;
	case AVSTATE_RUN:
		*(PLONGLONG)pvData = KeQueryPerformanceCounter(NULL).QuadPart - pci->llTimeBase;
		break;
	}
	KeReleaseSpinLock(&pci->spinState, irqlOld);
#endif
	pIrp->IoStatus.Information = sizeof(LONGLONG);
	return STATUS_SUCCESS;
}

/*	-	-	-	-	-	-	-	-	*/
NTSTATUS propTimeBase(
	IN PIRP		pIrp,
	IN PAVPROPERTY	pProperty,
	IN OUT PVOID	pvData)
{
#if 0
	PCONNECTION_INSTANCE	pci;
	KIRQL			irqlOld;

	pci = (PCONNECTION_INSTANCE)IoGetCurrentIrpStackLocation(pIrp)->DeviceObject->DeviceExtension;
	KeAcquireSpinLock(&pci->spinState, &irqlOld);
	switch (pci->State) {
	case AVSTATE_STOP:
	case AVSTATE_IDLE:
		*(PLONGLONG)pvData = KeQueryPerformanceCounter(NULL).QuadPart - pci->llTimeBase;
		break;
	case AVSTATE_RUN:
		*(PLONGLONG)pvData = pci->llTimeBase;
		break;
	}
	KeReleaseSpinLock(&pci->spinState, irqlOld);
#endif
	pIrp->IoStatus.Information = sizeof(LONGLONG);
	return STATUS_SUCCESS;
}

/*	-	-	-	-	-	-	-	-	*/
AVPROPERTY_ITEM	gaControlItems[] = {
	{
		AVPROPERTY_CONTROL_BUFFERALIGNMENT,
		propBufferAlignment,
		sizeof(AVPROPERTY),
		sizeof(ULONG),
		NULL,
		0,
		0
	},
//!!	{AVPROPERTY_CONTROL_DATAFORMAT
	{
		AVPROPERTY_CONTROL_POSITION,
		propPosition,
		sizeof(AVPROPERTY),
		sizeof(LONGLONG),
		NULL,
		0,
		0
	},
	{
		AVPROPERTY_CONTROL_PRIORITY,
		propPriority,
		sizeof(AVPROPERTY),
		sizeof(AVPRIORITY),
		NULL,
		0,
		0
	},
//!!	{AVPROPERTY_CONTROL_SAMPLE
	{
		AVPROPERTY_CONTROL_TIMEBASE,
		propTimeBase,
		sizeof(AVPROPERTY),
		sizeof(LONGLONG),
		NULL,
		0,
		0
	},
	{
		AVPROPERTY_CONTROL_TIMEDELTA,
		propTimeDelta,
		sizeof(AVPROPERTY),
		sizeof(LONGLONG),
		NULL,
		0,
		0
	},
};

AVPROPERTY_SET	gaConnectPropertySets[] = {
	{&AVPROPSETID_Control, SIZEOF_ARRAY(gaControlItems), gaControlItems},
};

/*	-	-	-	-	-	-	-	-	*/
NTSTATUS CancelIo(
	IN PDEVICE_OBJECT	pDo)
{
	PCONNECTION_INSTANCE	pci;

	pci = (PCONNECTION_INSTANCE)pDo->DeviceExtension;
	ExAcquireFastMutex(&pci->fmutexDataQueue);
	AvCancelIo(&pci->leDataQueue);
	ExReleaseFastMutex(&pci->fmutexDataQueue);
	return STATUS_SUCCESS;
}

/*	-	-	-	-	-	-	-	-	*/
NTSTATUS connectDispatchCreate(
	IN PDEVICE_OBJECT	pDo,
	IN PIRP			pIrp)
{
	pIrp->IoStatus.Information = 0;
	ObReferenceObjectByPointer(((PCONNECTION_INSTANCE)pDo->DeviceExtension)->pfileobjectFunctional, 0, NULL, KernelMode);
	pIrp->IoStatus.Status = STATUS_SUCCESS;
	IoCompleteRequest(pIrp, IO_NO_INCREMENT);
	return STATUS_SUCCESS;
}

/*	-	-	-	-	-	-	-	-	*/
VOID QueueDataItem(
	IN PIRP			pIrp,
	IN PCONNECTION_INSTANCE	pci)
{
	KIRQL	irqlOld;

	ExAcquireFastMutex(&pci->fmutexDataQueue);
	IoMarkIrpPending(pIrp);
	pIrp->IoStatus.Status = STATUS_PENDING;
	IoAcquireCancelSpinLock(&irqlOld);
	IoSetCancelRoutine(pIrp, AvCancelRoutine);
	InsertTailList(&pci->leDataQueue, &pIrp->Tail.Overlay.ListEntry);
	IoReleaseCancelSpinLock(irqlOld);
	ExReleaseFastMutex(&pci->fmutexDataQueue);
}

/*	-	-	-	-	-	-	-	-	*/
VOID QueueWorkerItem(
	IN PFUNCTIONAL_INSTANCE	pfi,
	IN PCONNECTION_INSTANCE	pci)
{
	KIRQL	irqlOld;

	IoAcquireCancelSpinLock(&irqlOld);
	if (!IsListEmpty(&pci->leDataQueue) && KeReadStateEvent(&pfi->eventWorkQueueItem)) {
		KeClearEvent(&pfi->eventWorkQueueItem);
		ExInitializeWorkItem(&pfi->WorkQueueItem, ReadQueueWorker, pfi);
		ExQueueWorkItem(&pfi->WorkQueueItem, CriticalWorkQueue);
	}
	IoReleaseCancelSpinLock(irqlOld);
}

/*	-	-	-	-	-	-	-	-	*/
NTSTATUS connectDispatchWrite(
	IN PDEVICE_OBJECT	pDo,
	IN PIRP			pIrp)
{
	PFUNCTIONAL_INSTANCE	pfi;
	PCONNECTION_INSTANCE	pci;
	PDEVICE_OBJECT		pdoDataFlow;

	pIrp->IoStatus.Information = 0;
	if (!IoGetCurrentIrpStackLocation(pIrp)->Parameters.Write.Length) {
		pIrp->IoStatus.Status = STATUS_SUCCESS;
		IoCompleteRequest(pIrp, IO_NO_INCREMENT);
		return STATUS_SUCCESS;
	}
	pci = (PCONNECTION_INSTANCE)pDo->DeviceExtension;
	QueueDataItem(pIrp, pci);
	pfi = (PFUNCTIONAL_INSTANCE)pci->pdoFunctional->DeviceExtension;
	ExAcquireFastMutex(&pfi->fmutexPin);
	if (pdoDataFlow = FindConnectionDeviceByDataFlow(pfi, AVPIN_DATAFLOW_OUT)) {
		pci = (PCONNECTION_INSTANCE)pdoDataFlow->DeviceExtension;
		ExAcquireFastMutex(&pci->fmutexConnect);
		ExAcquireFastMutex(&pci->fmutexDataQueue);
		QueueWorkerItem(pfi, pci);
		ExReleaseFastMutex(&pci->fmutexDataQueue);
		ExReleaseFastMutex(&pci->fmutexConnect);
	}
	ExReleaseFastMutex(&pfi->fmutexPin);
	return STATUS_PENDING;
}

/*	-	-	-	-	-	-	-	-	*/
NTSTATUS connectDispatchRead(
	IN PDEVICE_OBJECT	pDo,
	IN PIRP			pIrp)
{
	PFUNCTIONAL_INSTANCE	pfi;
	PCONNECTION_INSTANCE	pci;
	PDEVICE_OBJECT		pdoDataFlow;

	pIrp->IoStatus.Information = 0;
	if (!IoGetCurrentIrpStackLocation(pIrp)->Parameters.Read.Length) {
		pIrp->IoStatus.Status = STATUS_SUCCESS;
		IoCompleteRequest(pIrp, IO_NO_INCREMENT);
		return STATUS_SUCCESS;
	}
	pci = (PCONNECTION_INSTANCE)pDo->DeviceExtension;
	QueueDataItem(pIrp, pci);
	pfi = (PFUNCTIONAL_INSTANCE)pci->pdoFunctional->DeviceExtension;
	ExAcquireFastMutex(&pfi->fmutexPin);
	if (pdoDataFlow = FindConnectionDeviceByDataFlow(pfi, AVPIN_DATAFLOW_IN))
		QueueWorkerItem(pfi, (PCONNECTION_INSTANCE)pdoDataFlow->DeviceExtension);
	ExReleaseFastMutex(&pfi->fmutexPin);
	return STATUS_PENDING;
}

/*	-	-	-	-	-	-	-	-	*/
NTSTATUS connectDispatchControl(
	IN PDEVICE_OBJECT	pDo,
	IN PIRP			pIrp)
{
	NTSTATUS		Status;
	PCONNECTION_INSTANCE	pci;

	pci = (PCONNECTION_INSTANCE)pDo->DeviceExtension;
	if (pci->Communication & AVPIN_COMMUNICATION_SOURCE)
		return AvForwardIrp(pIrp, pci->pdoConnection, pci->pfileobjectConnection);
	switch (IoGetCurrentIrpStackLocation(pIrp)->Parameters.DeviceIoControl.IoControlCode) {
	case IOCTL_AV_GET_PROPERTY:
	case IOCTL_AV_SET_PROPERTY:
		Status = AvPropertyHandler(pIrp, SIZEOF_ARRAY(gaConnectPropertySets), gaConnectPropertySets);
		break;
	case IOCTL_AV_ENABLE_EVENT:
		Status = AvEventEnable(pIrp, SIZEOF_ARRAY(gaEventSets), gaEventSets);
		break;
	case IOCTL_AV_DISABLE_EVENT:
		Status = AvEventDisable(pIrp);
		break;
	case IOCTL_AV_CANCEL_IO:
		pIrp->IoStatus.Information = 0;
		Status = CancelIo(pDo);
		break;
	default:
		Status = STATUS_INVALID_DEVICE_REQUEST;
		break;
	}
	if (Status != STATUS_PENDING) {
		pIrp->IoStatus.Status = Status;
		IoCompleteRequest(pIrp, IO_NO_INCREMENT);
	}
	return Status;
}

/*	-	-	-	-	-	-	-	-	*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\ksfilter\midipass\func.c ===
/*	-	-	-	-	-	-	-	-	*/
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) Microsoft Corporation, 1995 - 1996  All Rights Reserved.
//
/*	-	-	-	-	-	-	-	-	*/

#include "common.h"

/*	-	-	-	-	-	-	-	-	*/
#ifdef ALLOC_PRAGMA
NTSTATUS DriverEntry(
	IN PDRIVER_OBJECT       pDriverObject,
	IN PUNICODE_STRING      suRegistryPathName);
#pragma alloc_text(INIT, DriverEntry)
#endif

/*	-	-	-	-	-	-	-	-	*/
AVPIN_PROTOCOL	gaProtocols[] = {
	{STATIC_AVPROTOCOLSETID_Standard, AVPROTOCOL_STANDARD_MUSIC},
};

AVPIN_TRANSPORT	gaTransports[] = {
	{STATIC_AVTRANSPORTSETID_Standard, AVTRANSPORT_STANDARD_DEVIO}, 
};

/*	-	-	-	-	-	-	-	-	*/
AVDATAFORMAT_MUSIC gDataFormatNONE = {
	{STATIC_AVDATAFORMAT_TYPE_MUSIC, sizeof(AVDATAFORMAT_MUSIC)},
	AVDATAFORMAT_MUSIC_NONE
};
AVDATAFORMAT_MUSIC gDataFormatMIDI = {
	{STATIC_AVDATAFORMAT_TYPE_MUSIC, sizeof(AVDATAFORMAT_MUSIC)},
	AVDATAFORMAT_MUSIC_MIDI
};
AVDATAFORMAT_MUSIC gDataFormatZIPI = {
	{STATIC_AVDATAFORMAT_TYPE_MUSIC, sizeof(AVDATAFORMAT_MUSIC)},
	AVDATAFORMAT_MUSIC_ZIPI
};
AVDATAFORMAT_MUSIC gDataFormatNONETimeStamped = {
	{STATIC_AVDATAFORMAT_TYPE_MUSIC_TIMESTAMPED, sizeof(AVDATAFORMAT_MUSIC)},
	AVDATAFORMAT_MUSIC_NONE
};
AVDATAFORMAT_MUSIC gDataFormatMIDITimeStamped = {
	{STATIC_AVDATAFORMAT_TYPE_MUSIC_TIMESTAMPED, sizeof(AVDATAFORMAT_MUSIC)},
	AVDATAFORMAT_MUSIC_MIDI
};
AVDATAFORMAT_MUSIC gDataFormatZIPITimeStamped = {
	{STATIC_AVDATAFORMAT_TYPE_MUSIC_TIMESTAMPED, sizeof(AVDATAFORMAT_MUSIC)},
	AVDATAFORMAT_MUSIC_ZIPI
};

/*	-	-	-	-	-	-	-	-	*/
PVOID gaDataFormats[] = {
	&gDataFormatNONE,
	&gDataFormatMIDI,
	&gDataFormatZIPI,
	&gDataFormatNONETimeStamped,
	&gDataFormatMIDITimeStamped,
	&gDataFormatZIPITimeStamped
};

/*	-	-	-	-	-	-	-	-	*/
AVPIN_HANDLER gConnectionIn = {
	AVPIN_DATAFLOW_IN,
	AVPIN_COMMUNICATION_BOTH,
	{STATIC_AVTRANSFORMSETID_Standard, AVTRANSFORM_STANDARD_CONVERTER},
	funcConnect
};
AVPIN_HANDLER gConnectionOut = {
	AVPIN_DATAFLOW_OUT,
	AVPIN_COMMUNICATION_BOTH,
	{STATIC_AVTRANSFORMSETID_Standard, AVTRANSFORM_STANDARD_CONVERTER},
	funcConnect
};

/*	-	-	-	-	-	-	-	-	*/
AVPIN_DESCRIPTOR gaDescriptors[] = {
	{
		SIZEOF_ARRAY(gaProtocols),
		gaProtocols,
		SIZEOF_ARRAY(gaTransports),
		gaTransports,
		SIZEOF_ARRAY(gaDataFormats),
		gaDataFormats,
		&gConnectionIn
	},
	{
		SIZEOF_ARRAY(gaProtocols),
		gaProtocols,
		SIZEOF_ARRAY(gaTransports),
		gaTransports,
		SIZEOF_ARRAY(gaDataFormats),
		gaDataFormats,
		&gConnectionOut
	},
};

/*	-	-	-	-	-	-	-	-	*/
PDEVICE_OBJECT FindConnectionDeviceByCommunication(
	IN PFUNCTIONAL_INSTANCE	pfi,
	IN AVPIN_COMMUNICATION	Communication)
{
	ULONG	idPin;

	for (idPin = 0; idPin < SIZEOF_ARRAY(gaDescriptors); idPin++)
		if (pfi->aPinInfo[idPin].Communication == Communication)
			return pfi->aPinInfo[idPin].pdoConnection;
	return NULL;
}

/*	-	-	-	-	-	-	-	-	*/
PDEVICE_OBJECT FindConnectionDeviceByDataFlow(
	IN PFUNCTIONAL_INSTANCE	pfi,
	IN AVPIN_DATAFLOW	DataFlow)
{
	ULONG	idPin;

	for (idPin = 0; idPin < SIZEOF_ARRAY(gaDescriptors); idPin++)
		if (gaDescriptors[idPin].pHandler->DataFlow == DataFlow)
			return pfi->aPinInfo[idPin].pdoConnection;
	return NULL;
}

/*	-	-	-	-	-	-	-	-	*/
ULONG FindConnectionPinByFile(
	IN PFUNCTIONAL_INSTANCE	pfi,
	IN PFILE_OBJECT		pfileobjectPin)
{
	ULONG	idPin;

	for (idPin = 0; idPin < SIZEOF_ARRAY(gaDescriptors); idPin++)
		if (pfi->aPinInfo[idPin].pfileobjectConnection == pfileobjectPin)
			return idPin;
	_DbgPrintF(DEBUGLVL_ERROR, ("Did not find idPin"));
}

/*	-	-	-	-	-	-	-	-	*/
PDEVICE_OBJECT FindConnectionDeviceByPin(
	IN PFUNCTIONAL_INSTANCE	pfi,
	IN ULONG		idPin)
{
	return pfi->aPinInfo[idPin].pdoConnection;
}

/*	-	-	-	-	-	-	-	-	*/
AVPIN_COMMUNICATION FindCommunicationByPin(
	IN PFUNCTIONAL_INSTANCE	pfi,
	IN ULONG		idPin)
{
	return pfi->aPinInfo[idPin].Communication;
}

/*	-	-	-	-	-	-	-	-	*/
NTSTATUS propCInstances(
	IN PIRP		pIrp,
	IN PAVPROPERTY	pProperty,
	IN OUT PVOID	pvData)
{
	ULONG			idPin;
	PAVPIN_CINSTANCES	pCInstances;

	idPin = ((PAVP_PIN)pProperty)->idPin;
	if (idPin >= SIZEOF_ARRAY(gaDescriptors))
		return STATUS_INVALID_PARAMETER;
	pCInstances = (PAVPIN_CINSTANCES)pvData;
	pCInstances->cPossible = 1;
	pCInstances->cCurrent = FindConnectionDeviceByPin((PFUNCTIONAL_INSTANCE)IoGetCurrentIrpStackLocation(pIrp)->DeviceObject->DeviceExtension, idPin) ? 1 : 0;
	pIrp->IoStatus.Information = sizeof(AVPIN_CINSTANCES);
	return STATUS_SUCCESS;

}

/*	-	-	-	-	-	-	-	-	*/
NTSTATUS FindSupportedDataFormat(
	IN ULONG		idPin,
	IN ULONG		cbInputBufferLength,
	IN PAVDATAFORMAT	pDataFormat,
	OUT PAVDATAFORMAT*	ppDataFormat)
{
	ULONG	cDataFormat;
	PVOID*	ppvDataFormats;

	ppvDataFormats = gaDescriptors[idPin].ppvDataRanges;
	for (cDataFormat = gaDescriptors[idPin].cDataRanges; cDataFormat--;) {
		PAVDATAFORMAT	pDataFormatItem;

		pDataFormatItem = (PAVDATAFORMAT)ppvDataFormats[cDataFormat];
		if ((cbInputBufferLength >= pDataFormatItem->cbFormat) && RtlEqualMemory(pDataFormatItem, pDataFormat, pDataFormatItem->cbFormat)) {
			if (ppDataFormat)
				*ppDataFormat = pDataFormatItem;
			return STATUS_SUCCESS;
		}
	}
	return STATUS_INVALID_DEVICE_REQUEST;
}

/*	-	-	-	-	-	-	-	-	*/
NTSTATUS propDataRouting(
	IN PIRP		pIrp,
	IN PAVPROPERTY	pProperty,
	IN OUT PVOID	pvData)
{
	ULONG			idPin;
	PAVP_PIN		pPin;
	ULONG			cbOutputBufferLength;
	ULONG			cbDataRanges;
	NTSTATUS		Status;
	PIO_STACK_LOCATION	pIrpStack;
	AVPIN_DATAFLOW		DataFlow;

	idPin = ((PAVP_PIN)pProperty)->idPin;
	if (idPin >= SIZEOF_ARRAY(gaDescriptors))
		return STATUS_INVALID_PARAMETER;
	pPin = (PAVP_PIN)pProperty;
	pIrpStack = IoGetCurrentIrpStackLocation(pIrp);
	cbOutputBufferLength = pIrpStack->Parameters.DeviceIoControl.OutputBufferLength;
	if (NT_ERROR(Status = FindSupportedDataFormat(idPin, pIrpStack->Parameters.DeviceIoControl.InputBufferLength - sizeof(AVP_PIN), (PAVDATAFORMAT)(pPin + 1), NULL)))
		return Status;
	DataFlow = gaDescriptors[idPin].pHandler->DataFlow;
	for (idPin = 0;; idPin++)
		if (DataFlow != gaDescriptors[idPin].pHandler->DataFlow)
			break;
	cbDataRanges = sizeof(AVPIN_DATAROUTING) + ((PAVDATAFORMAT)(pPin + 1))->cbFormat;
	if (cbOutputBufferLength == sizeof(ULONG)) {
		*(PULONG)pvData = cbDataRanges;
		pIrp->IoStatus.Information = sizeof(ULONG);
	} else if (cbOutputBufferLength < cbDataRanges)
		return STATUS_BUFFER_TOO_SMALL;
	else {
		PAVPIN_DATAROUTING	pDataRouting;

		pDataRouting = (PAVPIN_DATAROUTING)pvData;
		pDataRouting->idPin = idPin;
		pDataRouting->cDataRanges = 1;
		RtlCopyMemory(pDataRouting + 1, pPin + 1, cbDataRanges - sizeof(AVPIN_DATAROUTING));
		pIrp->IoStatus.Information = cbDataRanges;
	}
	return STATUS_SUCCESS;
}

/*	-	-	-	-	-	-	-	-	*/
propPinPropertyHandler(
	IN PIRP		pIrp,
	IN PAVPROPERTY	pProperty,
	IN OUT PVOID	pvData)
{
	return AvPinPropertyHandler(pIrp, pProperty, pvData, SIZEOF_ARRAY(gaDescriptors), gaDescriptors);
}

/*	-	-	-	-	-	-	-	-	*/
AVPROPERTY_ITEM	gaConnectItems[] = {
	{
		AVPROPERTY_PIN_CINSTANCES,
		propCInstances,
		sizeof(AVP_PIN),
		sizeof(AVPIN_CINSTANCES),
		NULL,
		0,
		0
	},
	{
		AVPROPERTY_PIN_CTYPES,
		propPinPropertyHandler,
		sizeof(AVPROPERTY),
		sizeof(ULONG),
		NULL,
		0,
		0
	},
	{
		AVPROPERTY_PIN_DATAFLOW,
		propPinPropertyHandler,
		sizeof(AVP_PIN),
		sizeof(AVPIN_DATAFLOW),
		NULL,
		0,
		0
	},
	{
		AVPROPERTY_PIN_DATARANGES,
		propPinPropertyHandler,
		sizeof(AVP_PIN),
		sizeof(ULONG),
		NULL,
		0,
		0
	},
	{
		AVPROPERTY_PIN_DATAROUTING,
		propDataRouting,
		sizeof(AVP_PIN),
		sizeof(ULONG),
		NULL,
		0,
		0
	},
	{
		AVPROPERTY_PIN_TRANSFORM,
		propPinPropertyHandler,
		sizeof(AVP_PIN),
		sizeof(AVPIN_TRANSFORM),
		NULL,
		0,
		0
	},
	{
		AVPROPERTY_PIN_PROTOCOLS,
		propPinPropertyHandler,
		sizeof(AVP_PIN),
		sizeof(ULONG),
		NULL,
		0,
		0
	},
	{
		AVPROPERTY_PIN_TRANSPORTS,
		propPinPropertyHandler,
		sizeof(AVP_PIN),
		sizeof(ULONG),
		NULL,
		0,
		0
	},
	{
		AVPROPERTY_PIN_COMMUNICATION,
		propPinPropertyHandler,
		sizeof(AVP_PIN),
		sizeof(AVPIN_COMMUNICATION),
		NULL,
		0,
		0
	},
};

/*	-	-	-	-	-	-	-	-	*/
NTSTATUS propProvider(
	IN PIRP		pIrp,
	IN PAVPROPERTY	pProperty,
	IN OUT PVOID	pvData)
{
	PAVPROVIDER	pProvider;

	pProvider = (PAVPROVIDER)pvData;
	pProvider->guidProvider = AVPROVIDER_Microsoft;
	pProvider->guidProduct = AVPRODUCT_Microsoft;
	pProvider->Version.bVersion = 0;
	pProvider->Version.bRevision = 0;
	pProvider->Version.uBuild = 0;
	pIrp->IoStatus.Information = sizeof(AVPROVIDER);
	return STATUS_SUCCESS;
}

/*	-	-	-	-	-	-	-	-	*/
AVPROPERTY_ITEM	gaGeneralItems[] = {
	{
		AVPROPERTY_GENERAL_PROVIDER,
		propProvider,
		sizeof(AVPROPERTY),
		sizeof(AVPROVIDER),
		NULL,
		0
	},
};

/*	-	-	-	-	-	-	-	-	*/
AVPROPERTY_SET	gaFuncPropertySets[] = {
	{&AVPROPSETID_Pin, SIZEOF_ARRAY(gaConnectItems), gaConnectItems},
	{&AVPROPSETID_General, SIZEOF_ARRAY(gaGeneralItems), gaGeneralItems},
};

/*	-	-	-	-	-	-	-	-	*/
NTSTATUS CreateConnect(
	IN PAVPIN_CONNECT	pConnect,
	IN PCONNECTION_INSTANCE	pci)
{
	PAVPIN_CONNECT	pConnectTo;
	ULONG		cbConnectTo;
	NTSTATUS	Status;

	cbConnectTo = sizeof(AVPIN_CONNECT) + ((PAVDATAFORMAT)(pConnect + 1))->cbFormat;
	if (pConnectTo = ExAllocatePool(PagedPool, cbConnectTo)) {
		HANDLE	hConnection;

		*pConnectTo = *pConnect;
		pConnectTo->idPin = pConnect->idPinTo;
		pConnectTo->idPinTo = 0;
		pConnectTo->hConnectTo = NULL;
		RtlCopyMemory(pConnectTo + 1, pConnect + 1, cbConnectTo);
		Status = AvConnect(pConnect->hConnectTo, cbConnectTo, pConnectTo, &hConnection);
		ExFreePool(pConnectTo);
		if (NT_SUCCESS(Status)) {
			Status = ObReferenceObjectByHandle(hConnection, 0, NULL, KernelMode, &pci->pfileobjectConnection, NULL);
			ZwClose(hConnection);
			if (NT_SUCCESS(Status))
				pci->pdoConnection = IoGetRelatedDeviceObject(pci->pfileobjectConnection);
		}
	} else
		Status = STATUS_NO_MEMORY;
	return Status;
}

/*	-	-	-	-	-	-	-	-	*/
NTSTATUS CreatePin(
	IN PFILE_OBJECT		pfileobjectFunctional,
	IN PDEVICE_OBJECT	pdoFunctional,
	IN PAVPIN_CONNECT	pConnect,
	IN PAVDATAFORMAT	pDataFormat,
	IN ULONG		idPin,
	OUT PDEVICE_OBJECT*	ppdoConnection)
{
	WCHAR			acDeviceName[64];
	PCONNECTION_INSTANCE	pci;
	NTSTATUS		Status;

	_stprintf(acDeviceName, USTR_CONNECTION_NAME, idPin);
	if (NT_ERROR(Status = AvCreateDevice(pdoFunctional->DriverObject, sizeof(CONNECTION_INSTANCE), acDeviceName, ppdoConnection)))
		return Status;
	pci = (PCONNECTION_INSTANCE)(*ppdoConnection)->DeviceExtension;
	pci->pdoFunctional = pdoFunctional;
	pci->pfileobjectFunctional = pfileobjectFunctional;
	ExInitializeFastMutex(&pci->fmutexConnect);
	InitializeListHead(&pci->leEventQueue);
	KeInitializeSpinLock(&pci->spinEventQueue);
	ExInitializeFastMutex(&pci->fmutexDataQueue);
	InitializeListHead(&pci->leDataQueue);
	AvSetMajorFunction(*ppdoConnection, IRP_MJ_DEVICE_CONTROL, connectDispatchControl);
	AvSetMajorFunction(*ppdoConnection, IRP_MJ_CLOSE, connectDispatchClose);
	AvSetMajorFunction(*ppdoConnection, IRP_MJ_CREATE, connectDispatchCreate);
	(*ppdoConnection)->Flags |= (DO_DIRECT_IO | DO_NEVER_LAST_DEVICE);
	(*ppdoConnection)->Flags &= ~DO_DEVICE_INITIALIZING;
	return STATUS_SUCCESS;
}

/*	-	-	-	-	-	-	-	-	*/
NTSTATUS CreateSourceConnection(
	IN PFILE_OBJECT		pfileobjectFunctional,
	IN PFUNCTIONAL_INSTANCE	pfi,
	IN PDEVICE_OBJECT	pdoFunctional,
	IN PAVPIN_CONNECT	pConnect,
	IN PAVDATAFORMAT	pDataFormat,
	IN ULONG		idPin,
	OUT HANDLE*		phConnection)
{
	NTSTATUS		Status;
	PDEVICE_OBJECT		pdoConnection;
	PCONNECTION_INSTANCE	pci;

	if (NT_SUCCESS(Status = CreatePin(pfileobjectFunctional, pdoFunctional, pConnect, pDataFormat, idPin, &pdoConnection))) {
		pfi->pDataFormat = pDataFormat;
		pci = (PCONNECTION_INSTANCE)pdoConnection->DeviceExtension;
		if (NT_SUCCESS(Status = CreateConnect(pConnect, pci))) {
			if (NT_SUCCESS(Status = AvCreateFile(pdoConnection, phConnection))) {
				pci->Communication = AVPIN_COMMUNICATION_SOURCE;
				pfi->aPinInfo[idPin].Communication = AVPIN_COMMUNICATION_SOURCE;
				pfi->aPinInfo[idPin].pdoConnection = pdoConnection;
				ObReferenceObjectByHandle(*phConnection, 0, NULL, KernelMode, &pfi->aPinInfo[idPin].pfileobjectConnection, NULL);
				ObDereferenceObject(pfi->aPinInfo[idPin].pfileobjectConnection);
				return STATUS_SUCCESS;
			}
			ObDereferenceObject(pci->pfileobjectConnection);
			pci->pfileobjectConnection = NULL;
		}
		AvCleanupDevice(pdoConnection);
		IoDeleteDevice(pdoConnection);
		pfi->pDataFormat = NULL;
	}
	return Status;
}
/*	-	-	-	-	-	-	-	-	*/
NTSTATUS ConnectSinkToPipe(
	IN PFUNCTIONAL_INSTANCE	pfi,
	IN PDEVICE_OBJECT	pdoConnection,
	IN PAVPIN_CONNECT	pConnect,
	IN PAVDATAFORMAT	pDataFormat,
	IN ULONG		idPin,
	OUT HANDLE*		phConnection)
{
	PCONNECTION_INSTANCE	pci;
	NTSTATUS		Status;

	pci = (PCONNECTION_INSTANCE)pdoConnection->DeviceExtension;
	ExAcquireFastMutex(&pci->fmutexConnect);
	if (pfi->pDataFormat != pDataFormat)
		Status = STATUS_CONNECTION_REFUSED;
	else if (NT_SUCCESS(Status = AvCreateFile(pdoConnection, phConnection))) {
		if (gaDescriptors[idPin].pHandler->DataFlow == AVPIN_DATAFLOW_IN)
			AvSetMajorFunction(pdoConnection, IRP_MJ_WRITE, connectDispatchWrite);
		else
			AvSetMajorFunction(pdoConnection, IRP_MJ_READ, connectDispatchRead);
		pci->Communication |= AVPIN_COMMUNICATION_SINK;
		pfi->aPinInfo[idPin].Communication = AVPIN_COMMUNICATION_SINK;
		pfi->aPinInfo[idPin].pdoConnection = pdoConnection;
		ObReferenceObjectByHandle(*phConnection, 0, NULL, KernelMode, &pfi->aPinInfo[idPin].pfileobjectConnection, NULL);
		ObDereferenceObject(pfi->aPinInfo[idPin].pfileobjectConnection);
		Status = STATUS_SUCCESS;
	}
	ExReleaseFastMutex(&pci->fmutexConnect);
	return Status;
}

/*	-	-	-	-	-	-	-	-	*/
NTSTATUS CreateSinkConnection(
	IN PFILE_OBJECT		pfileobjectFunctional,
	IN PFUNCTIONAL_INSTANCE	pfi,
	IN PDEVICE_OBJECT	pdoFunctional,
	IN PAVPIN_CONNECT	pConnect,
	IN PAVDATAFORMAT	pDataFormat,
	IN ULONG		idPin,
	OUT HANDLE*		phConnection)
{
	NTSTATUS	Status;
	PDEVICE_OBJECT	pdoConnection;

	if (pfi->pDataFormat && (pfi->pDataFormat != pDataFormat))
		return STATUS_CONNECTION_REFUSED;
	if (NT_SUCCESS(Status = CreatePin(pfileobjectFunctional, pdoFunctional, pConnect, pDataFormat, idPin, &pdoConnection))) {
		if (!pfi->pDataFormat) {
			pfi->pDataFormat = pDataFormat;
			pDataFormat = NULL;
		}
		if (NT_ERROR(Status = ConnectSinkToPipe(pfi, pdoConnection, pConnect, pfi->pDataFormat, idPin, phConnection))) {
			AvCleanupDevice(pdoConnection);
			IoDeleteDevice(pdoConnection);
			pfi->pDataFormat = pDataFormat;
		}
	}
	return Status;
}

/*	-	-	-	-	-	-	-	-	*/
NTSTATUS funcConnect(
	IN PIRP			pIrp,
	IN PAVPIN_CONNECT	pConnect,
	OUT HANDLE*		phConnection)
{
	ULONG			idPin;
	PIO_STACK_LOCATION	pIrpStack;
	PFUNCTIONAL_INSTANCE	pfi;
	NTSTATUS		Status;
	PDEVICE_OBJECT		pdoFunctional;
	PDEVICE_OBJECT		pdoConnection;
	PAVDATAFORMAT		pDataFormat;

	idPin = pConnect->idPin;
	if (idPin >= SIZEOF_ARRAY(gaDescriptors))
		return STATUS_INVALID_PARAMETER;
	pIrpStack = IoGetCurrentIrpStackLocation(pIrp);
	pdoFunctional = pIrpStack->DeviceObject;
	pfi = (PFUNCTIONAL_INSTANCE)pdoFunctional->DeviceExtension;
	if (NT_ERROR(Status = FindSupportedDataFormat(idPin, pIrpStack->Parameters.DeviceIoControl.InputBufferLength - sizeof(AVPIN_CONNECT), (PAVDATAFORMAT)(pConnect + 1), &pDataFormat)))
		return Status;
	ExAcquireFastMutex(&pfi->fmutexPin);
	if (FindConnectionDeviceByPin(pfi, idPin)) {
		ExReleaseFastMutex(&pfi->fmutexPin);
		return STATUS_CONNECTION_REFUSED;
	}
	pdoConnection = FindConnectionDeviceByCommunication(pfi, AVPIN_COMMUNICATION_SOURCE);
	if (pConnect->hConnectTo) {
		if (pdoConnection || FindConnectionDeviceByCommunication(pfi, AVPIN_COMMUNICATION_SINK))
			Status = STATUS_CONNECTION_REFUSED;
		else
			Status = CreateSourceConnection(pIrpStack->FileObject, pfi, pdoFunctional, pConnect, pDataFormat, idPin, phConnection);
	} else if (pdoConnection)
		Status = ConnectSinkToPipe(pfi, pdoConnection, pConnect, pDataFormat, idPin, phConnection);
	else
		Status = CreateSinkConnection(pIrpStack->FileObject, pfi, pdoFunctional, pConnect, pDataFormat, idPin, phConnection);
	ExReleaseFastMutex(&pfi->fmutexPin);
	return Status;
}

/*	-	-	-	-	-	-	-	-	*/
NTSTATUS funcDispatch(
	IN PDEVICE_OBJECT	pDo,
	IN PIRP			pIrp)
{
	pIrp->IoStatus.Information = 0;
	pIrp->IoStatus.Status = STATUS_SUCCESS;
	IoCompleteRequest(pIrp, IO_NO_INCREMENT);
	return STATUS_SUCCESS;
}

/*	-	-	-	-	-	-	-	-	*/
NTSTATUS funcDispatchControl(
	IN PDEVICE_OBJECT	pDo,
	IN PIRP			pIrp)
{
	NTSTATUS	Status;

	switch (IoGetCurrentIrpStackLocation(pIrp)->Parameters.DeviceIoControl.IoControlCode) {
	case IOCTL_AV_GET_PROPERTY:
	case IOCTL_AV_SET_PROPERTY:
		Status = AvPropertyHandler(pIrp, SIZEOF_ARRAY(gaFuncPropertySets), gaFuncPropertySets);
		break;
	case IOCTL_AV_CONNECT:
		Status = AvConnectHandler(pIrp, SIZEOF_ARRAY(gaDescriptors), gaDescriptors);
		break;
	default:
		Status = STATUS_INVALID_DEVICE_REQUEST;
		break;
	}
	if (Status != STATUS_PENDING) {
		pIrp->IoStatus.Status = Status;
		IoCompleteRequest(pIrp, IO_NO_INCREMENT);
	}
	return Status;
}

/*	-	-	-	-	-	-	-	-	*/
VOID GenerateEvent(
	IN PFUNCTIONAL_INSTANCE	pfi,
	IN REFGUID		rguidEventSet,
	IN ULONG		idEvent,
	IN PVOID		pvEventData)
{
	PLIST_ENTRY		ple;
	ULONG			idPin;

	ExAcquireFastMutex(&pfi->fmutexPin);
	for (idPin = 0; idPin < SIZEOF_ARRAY(gaDescriptors); idPin++) {
		PCONNECTION_INSTANCE	pci;
		KIRQL			irqlOld;

		if (!pfi->aPinInfo[idPin].pdoConnection)
			continue;
		pci = (PCONNECTION_INSTANCE)pfi->aPinInfo[idPin].pdoConnection->DeviceExtension;
		KeAcquireSpinLock(&pci->spinEventQueue, &irqlOld);
		for (ple = pci->leEventQueue.Flink; ple != &pci->leEventQueue; ple = ple->Flink) {
			PAVEVENT_ENTRY	pee;

			pee = (PAVEVENT_ENTRY)CONTAINING_RECORD(ple, AVEVENT_ENTRY, ListEntry);
			if (IsEqualGUID(rguidEventSet, &pee->guidEventSet))
				if (idEvent == pee->idEvent)
					switch (idEvent) {
					case AVEVENT_DATA_POSITION_UPDATE:
						AvEventGenerate(pee);
						break;
					}
		}
		KeReleaseSpinLock(&pci->spinEventQueue, irqlOld);
	}
	ExReleaseFastMutex(&pfi->fmutexPin);
}

/*	-	-	-	-	-	-	-	-	*/
NTSTATUS connectDispatchClose(
	IN PDEVICE_OBJECT	pDo,
	IN PIRP			pIrp)
{
	PCONNECTION_INSTANCE	pci;
	PFUNCTIONAL_INSTANCE	pfi;
	ULONG			idPin;
	PFILE_OBJECT		pfileobjectFunctional;

	pIrp->IoStatus.Information = 0;
	pIrp->IoStatus.Status = STATUS_SUCCESS;
	pci = (PCONNECTION_INSTANCE)pDo->DeviceExtension;
	pfi = (PFUNCTIONAL_INSTANCE)pci->pdoFunctional->DeviceExtension;
	idPin = FindConnectionPinByFile(pfi, IoGetCurrentIrpStackLocation(pIrp)->FileObject);
	pfileobjectFunctional = pci->pfileobjectFunctional;
	ExAcquireFastMutex(&pfi->fmutexPin);
	if (FindCommunicationByPin(pfi, idPin) == AVPIN_COMMUNICATION_SOURCE) {
		ObDereferenceObject(pci->pfileobjectConnection);
		pci->Communication &= ~AVPIN_COMMUNICATION_SOURCE;
	} else {
		if (gaDescriptors[idPin].pHandler->DataFlow == AVPIN_DATAFLOW_IN)
			AvSetMajorFunction(pDo, IRP_MJ_WRITE, NULL);
		else
			AvSetMajorFunction(pDo, IRP_MJ_READ, NULL);
		AvEventFreeList(pDo, &pci->leEventQueue, &pci->spinEventQueue);
		pci->Communication &= ~AVPIN_COMMUNICATION_SINK;
	}
	if (!pci->Communication)
		AvCleanupDevice(pDo);
	pfi->aPinInfo[idPin].Communication = 0;
	pfi->aPinInfo[idPin].pdoConnection = NULL;
	pfi->aPinInfo[idPin].pfileobjectConnection = NULL;
	ExReleaseFastMutex(&pfi->fmutexPin);
//!!	KeWaitForSingleObject(&pfi->eventWorkQueueItem, Executive, KernelMode, FALSE, NULL);
	IoCompleteRequest(pIrp, IO_NO_INCREMENT);
	ObDereferenceObject(pfileobjectFunctional);
	return STATUS_SUCCESS;
}

/*	-	-	-	-	-	-	-	-	*/
VOID DriverUnload(
	IN PDRIVER_OBJECT	pDriverObject)
{
	if (pDriverObject->DeviceObject) {
		AvCleanupDevice(pDriverObject->DeviceObject);
		IoDeleteDevice(pDriverObject->DeviceObject);
	}
}

/*	-	-	-	-	-	-	-	-	*/
NTSTATUS DriverEntry(
	IN PDRIVER_OBJECT       pDriverObject,
	IN PUNICODE_STRING      suRegistryPathName)
{
	PDEVICE_OBJECT	pDo;
	NTSTATUS	Status;

	pDriverObject->DriverUnload = DriverUnload;
	Status = AvCreateDevice(pDriverObject, sizeof(FUNCTIONAL_INSTANCE) + SIZEOF_ARRAY(gaDescriptors) * sizeof(PIN_INFO), USTR_INSTANCE_NAME, &pDo);
	if (NT_SUCCESS(Status)) {
		Status = AvCreateSymbolicLink(pDo, USTR_INSTANCE_NAME);
		if (NT_SUCCESS(Status)) {
			PFUNCTIONAL_INSTANCE	pfi;

			pfi = (PFUNCTIONAL_INSTANCE)(pDo)->DeviceExtension;
			ExInitializeFastMutex(&pfi->fmutexPin);
			KeInitializeEvent(&pfi->eventWorkQueueItem, SynchronizationEvent, TRUE);
			AvSetMajorFunction(pDo, IRP_MJ_CLOSE, funcDispatch);
			AvSetMajorFunction(pDo, IRP_MJ_CREATE, funcDispatch);
			AvSetMajorFunction(pDo, IRP_MJ_DEVICE_CONTROL, funcDispatchControl);
			pDo->Flags |= DO_DIRECT_IO;
			pDo->Flags &= ~DO_DEVICE_INITIALIZING;
			return STATUS_SUCCESS;
		}
		AvCleanupDevice(pDo);
		IoDeleteDevice(pDo);
	}
	return Status;
}

/*	-	-	-	-	-	-	-	-	*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\ksfilter\miniport\freedom\dsp\debug.c ===
/*++

    Copyright (C) Microsoft Corporation, 1996 - 1996

Module Name:

    debug.c

Abstract:

    Debug interface using message port.

Author:
    Bryan A. Woodruff (bryanw) 14-Nov-1996

--*/

#include <def2181.h>
#include <circ.h>
#include <signal.h>
#include <sport.h>
#include <string.h>

#include "ntdefs.h"
#include "freedom.h"
#include "private.h"

void dprintf(
    PCHAR   String
)
{
    int      i;
    MESSAGE  Message;
    USHORT   Length, MsgLength;

    MsgLength = 1;

    Length = strlen( String );
    for (i = 0; i < Length; i += 2) {
        if ((i + 1) < Length) {
            Message.Data[ MsgLength ] = String[ i ] | (String[ i + 1 ] << 8);
        } else {
            Message.Data[ MsgLength ] = String[ i ];
        }

        MsgLength++;

        /*
        // If we have reached the end of this message, send it.
        */

        if (MsgLength == 8) {
            Message.Data[ 0 ] = HM_DEBUG_STRING;
            Message.Length = MsgLength;
            Message.Destination = FREEDOM_MESSAGE_CONTROL_IRQ_HOST;
            PostMessage( &Message );

            /*
            // Wait for this message to be delivered.
            */

            WaitMessage( &Message );
            MsgLength = 1;
        }
    }

    /*
    // Finally, clean up any debris
    */

    if (MsgLength > 1) {
        Message.Data[ 0 ] = HM_DEBUG_STRING;
        Message.Length = MsgLength;
        Message.Destination = FREEDOM_MESSAGE_CONTROL_IRQ_HOST;
        PostMessage( &Message );

        /*
        // Wait for this message to be delivered.
        */

        WaitMessage( &Message );
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\ksfilter\miniport\freedom\dsp\ad1843.h ===
/*++

    Copyright (C) Microsoft Corporation, 1996 - 1996

Module Name:

    ad1843.h

Abstract:

    AD1843 register definitions

Author:
    Bryan A. Woodruff (bryanw) 27-Nov-1996

--*/

#define AD1843_CPD_DFREE    0x8000
#define AD1843_CPD_DDMEN    0x1000
#define AD1843_CPD_DA2EN    0x0200
#define AD1843_CPD_DA1EN    0x0100
#define AD1843_CPD_ANAEN    0x0080
#define AD1843_CPD_HPEN     0x0040
#define AD1843_CPD_AAMEN    0x0010
#define AD1843_CPD_ADREN    0x0002
#define AD1843_CPD_ADLEN    0x0001
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\ksfilter\miniport\freedom\dsp\freedom.h ===
/*++

    Copyright (C) Microsoft Corporation, 1996 - 1997

Module Name:

    freedom.h

Abstract:

    Header file for Diamond Multimedia's Freedom ASIC

Author:

    Bryan A. Woodruff (bryanw) 14-Oct-1996

--*/

/*
// Pipe defintions
//
// A pipe is defined as a bulk data transfer path (as opposed to simple
// messaging) between the host and DSP and vice-versa.
//
// The maximum number of paths is 24, limited by the total number of 
// FIFOs available.
*/

#define FREEDOM_DEVICE_SAMPLE_RATE      48000
#define FREEDOM_MAXNUM_PIPES            24
#define FREEDOM_MAXNUM_PIPES_ALLOC_MASK 0x000FFFFF

typedef struct {
    
    USHORT  PingBuffer;
    USHORT  PongBuffer;
    USHORT  Size;

} FREEDOM_DSP_PIPE_INFO, *PFREEDOM_DSP_PIPE_INFO;

/*
// The following register definitions are defined as 
// offsets from the base.
*/

#define FREEDOM_MAXNUM_BTU              48

#define FREEDOM_HOST_BTU_BASE_INDEX     0
#define FREEDOM_DSP_BTU_BASE_INDEX      24

#define FREEDOM_MAXNUM_GPIP             6
#define FREEDOM_MAXNUM_FIFO             24

#define FREEDOM_REG_INDEX               10
#define FREEDOM_REG_DATA_LOWORD         12
#define FREEDOM_REG_DATA_HIWORD         14

#define FREEDOM_INDEX_AUTO_INCREMENT    0x8000

/*
// IRQ processing
*/

#define FREEDOM_REG_IRQ_DSP1_OFFSET     0x3A0
#define FREEDOM_REG_IRQ_DSP2_OFFSET     0x3B0

#define FREEDOM_REG_IRQ_GROUP           0
#define FREEDOM_REG_IRQ_DEVICE          2
#define FREEDOM_REG_IRQ_GPIP            4
#define FREEDOM_REG_IRQ_BTU             6
#define FREEDOM_REG_IRQ_CONTROL         8

/*
// Group interrupts
*/

#define FREEDOM_IRQ_GROUP_BTU           0x0001
#define FREEDOM_IRQ_GROUP_DEVICE        0x0002
#define FREEDOM_IRQ_GROUP_MESSAGE       0x0004
#define FREEDOM_IRQ_GROUP_GPIP          0x0008
#define FREEDOM_IRQ_GROUP_TIMER         0x0010

#define FREEDOM_IRQMASK_GROUP_BTU       (FREEDOM_IRQ_GROUP_BTU << 8)
#define FREEDOM_IRQMASK_GROUP_DEVICE    (FREEDOM_IRQ_GROUP_DEVICE << 8)
#define FREEDOM_IRQMASK_GROUP_MESSAGE   (FREEDOM_IRQ_GROUP_MESSAGE << 8)
#define FREEDOM_IRQMASK_GROUP_GPIP      (FREEDOM_IRQ_GROUP_GPIP << 8)
#define FREEDOM_IRQMASK_GROUP_TIMER     (FREEDOM_IRQ_GROUP_TIMER << 8)

/*
// Peripheral interrupts
*/

#define FREEDOM_IRQ_DEVICE_MIDI         0x0001
#define FREEDOM_IRQ_DEVICE_GPIO         0x0002
#define FREEDOM_IRQ_DEVICE_DEVICE0      0x0004
#define FREEDOM_IRQ_DEVICE_DEVICE1      0x0008
#define FREEDOM_IRQ_DEVICE_DEVICE2      0x0010
#define FREEDOM_IRQ_DEVICE_DEVICE3      0x0020
#define FREEDOM_IRQ_DEVICE_DEVICE4      0x0040

#define FREEDOM_IRQMASK_DEVICE_MIDI     (FREEDOM_IRQ_DEVICE_MIDI << 8)
#define FREEDOM_IRQMASK_DEVICE_GPIO     (FREEDOM_IRQ_DEVICE_GPIO << 8)
#define FREEDOM_IRQMASK_DEVICE_DEVICE0  (FREEDOM_IRQ_DEVICE_DEVICE0 << 8)
#define FREEDOM_IRQMASK_DEVICE_DEVICE1  (FREEDOM_IRQ_DEVICE_DEVICE1 << 8)
#define FREEDOM_IRQMASK_DEVICE_DEVICE2  (FREEDOM_IRQ_DEVICE_DEVICE2 << 8)
#define FREEDOM_IRQMASK_DEVICE_DEVICE3  (FREEDOM_IRQ_DEVICE_DEVICE3 << 8)
#define FREEDOM_IRQMASK_DEVICE_DEVICE4  (FREEDOM_IRQ_DEVICE_DEVICE4 << 8)

/*
// GPIP/BTU interrupts
*/

#define FREEDOM_IRQ_GPIP_INVALID        0x0080
#define FREEDOM_IRQ_GPIP_INDEX_MASK     0x0003

#define FREEDOM_IRQ_BTU_INVALID         0x0080
#define FREEDOM_IRQ_BTU_TRANSFER_DONE   0x0040
#define FREEDOM_IRQ_BTU_INDEX_MASK      0x003F

/*
// Interrupt control
*/

#define FREEDOM_IRQ_CONTROL_HOST_PING   0x0001
#define FREEDOM_IRQ_CONTROL_DSP1_PING   0x0002
#define FREEDOM_IRQ_CONTROL_DSP2_PING   0x0004
#define FREEDOM_IRQ_CONTROL_HOST_RESET  0x0008
#define FREEDOM_IRQ_CONTROL_DSP1_RESET  0x0010
#define FREEDOM_IRQ_CONTROL_DSP2_RESET  0x0020

/*
// BTU control
*/

#define FREEDOM_INDEX_BTU_RAM_BASE          0x0000
#define FREEDOM_INDEX_BTU_CONTROL           0x0300
#define FREEDOM_INDEX_BTU_HOST_BASE_LINK    (FREEDOM_INDEX_BTU_CONTROL + 2)
#define FREEDOM_INDEX_BTU_HOST_BEST         (FREEDOM_INDEX_BTU_CONTROL + 4)
#define FREEDOM_INDEX_BTU_HOST_CURRENT      (FREEDOM_INDEX_BTU_CONTROL + 6)
#define FREEDOM_INDEX_BTU_HOST_SCAN         (FREEDOM_INDEX_BTU_CONTROL + 8)
#define FREEDOM_INDEX_BTU_DSP_BEST          (FREEDOM_INDEX_BTU_CONTROL + 10)
#define FREEDOM_INDEX_BTU_DSP_CURRENT       (FREEDOM_INDEX_BTU_CONTROL + 12)
#define FREEDOM_INDEX_BTU_DSP_SCAN          (FREEDOM_INDEX_BTU_CONTROL + 14)

#define FREEDOM_BTU_CONTROL_ENABLE          0x0001
#define FREEDOM_BTU_CONTROL_ALWAYS_V4P      0x0002
#define FREEDOM_BTU_CONTROL_PULSE_ENABLE    0x0100
#define FREEDOM_BTU_CONTROL_RESET           0x0200

#if defined( _NTDDK_ )
#include <pshpack1.h>
#endif

typedef struct _FREEDOM_PHYSBTU {

    ULONG   Address;
    USHORT  TransferLength;
    USHORT  LinkDescriptor;
    USHORT  Control;
    USHORT  Status;
    ULONG   Reserved;
    
} FREEDOM_PHYSBTU, *PFREEDOM_PHYSBTU;

#if defined( _NTDDK_ )
#include <poppack.h>
#endif

typedef struct _FREEDOM_BTU {

    USHORT              Index;
    USHORT              Address;
    FREEDOM_PHYSBTU     Registers;

} FREEDOM_BTU, *PFREEDOM_BTU;

#define FREEDOM_BTU_SIZE    sizeof( FREEDOM_PHYSBTU )

/*
// BTU register offsets
*/

#if defined( _NTDDK )

#define FREEDOM_BTU_OFFSET_ADDRESS          FIELD_OFFSET( FREEDOM_PHYSBTU, Address )
#define FREEDOM_BTU_OFFSET_TRANSFERLENGTH   FIELD_OFFSET( FREEDOM_PHYSBTU, TransferLength )
#define FREEDOM_BTU_OFFSET_LINKDESCRIPTOR   FIELD_OFFSET( FREEDOM_PHYSBTU, LinkDescriptor )
#define FREEDOM_BTU_OFFSET_CONTROL          FIELD_OFFSET( FREEDOM_PHYSBTU, Control )
#define FREEDOM_BTU_OFFSET_STATUS           FIELD_OFFSET( FREEDOM_PHYSBTU, Status )

#define FREEDOM_BTU_RAM_BASE( i ) (FREEDOM_INDEX_BTU_RAM_BASE + ((i) * sizeof( FREEDOM_PHYSBTU )))

#else
 
/*
// The DSP compiler uses word addressing when we really mean byte addressing.
*/

#define FREEDOM_BTU_OFFSET_ADDRESS          0
#define FREEDOM_BTU_OFFSET_TRANSFERLENGTH   4
#define FREEDOM_BTU_OFFSET_LINKDESCRIPTOR   6
#define FREEDOM_BTU_OFFSET_CONTROL          8
#define FREEDOM_BTU_OFFSET_STATUS           10

#define FREEDOM_BTU_RAM_BASE( i ) (FREEDOM_INDEX_BTU_RAM_BASE + ((i) * 16))

#endif


/*
// BTU Address bits (DSP only)
*/

#define FREEDOM_BTU_ADDRESS_DATAMEMORY  0x40000000
#define FREEDOM_BTU_ADDRESS_DSP2        0x80000000

/*
// BTU Control bits
*/

#define FREEDOM_BTU_CONTROL_FIFOSEL     0x001F      /* FIFO selection (5 bits) */
#define FREEDOM_BTU_CONTROL_RESERVED    0x0020      /* Reserved                */
#define FREEDOM_BTU_CONTROL_WRITE_FIFO  0x0040      /* BTU write to FIFO       */
#define FREEDOM_BTU_CONTROL_BURST32     0x0080      /* Burst 32 not 16 bytes   */
#define FREEDOM_BTU_CONTROL_BYTE_SWAP   0x0100      /* swap byte order on xfer */
#define FREEDOM_BTU_CONTROL_WORD_SWAP   0x0200      /* Swap word order on xfer */
#define FREEDOM_BTU_CONTROL_HOST_LINK   0x0400      /* link from host memory   */
#define FREEDOM_BTU_CONTROL_DSP1_LINK   0x0800      /* link from DSP1 memory   */
#define FREEDOM_BTU_CONTROL_DSP2_LINK   0x0C00      /* link from DSP2 memory   */
#define FREEDOM_BTU_CONTROL_LINKDEFINED 0x1000      /* link defined            */
#define FREEDOM_BTU_CONTROL_HOST_IRQ    0x2000      /* IRQ Host on completion  */
#define FREEDOM_BTU_CONTROL_DSP1_IRQ    0x4000      /* IRQ DSP1 on completion  */
#define FREEDOM_BTU_CONTROL_DSP2_IRQ    0x6000      /* IRQ DSP2 on completion  */
#define FREEDOM_BTU_CONTROL_DSP_MASTER  0x8000      /* DSP bus master vs. host */

/*
// BTU Status bits
*/

#define FREEDOM_BTU_STATUS_ENABLE       0x0001
#define FREEDOM_BTU_STATUS_BUSY         0x0002

/*
// GPIP Control
*/

#define FREEDOM_INDEX_GPIP_BASE         0x0340

#if defined( _NTDDK_ )
#include <pshpack1.h>
#endif

typedef struct _FREEDOM_PHYSGPIP {

    USHORT  Control;
    USHORT  Data;

} FREEDOM_PHYSGPIP, *PFREEDOM_PHYSGPIP;

#if defined( _NTDDK_ )
#include <poppack.h>
#endif

typedef struct _FREEDOM_GPIP {

    USHORT              Index;
    USHORT              Address;
    FREEDOM_PHYSGPIP    Registers;

} FREEDOM_GPIP, *PFREEDOM_GPIP;

#if defined( _NTDDK_ )

#define FREEDOM_GPIP_OFFSET_CONTROL FIELD_OFFSET( FREEDOM_PHYSGPIP, Control )
#define FREEDOM_GPIP_OFFSET_DATA    FIELD_OFFSET( FREEDOM_PHYSGPIP, Data )

#define FREEDOM_GPIP_BASE( i ) (FREEDOM_INDEX_GPIP_BASE + (i * sizeof( FREEDOM_PHYSGPIP )))

#else

/*
// The DSP compiler uses word addressing when we really mean byte addressing.
*/

#define FREEDOM_GPIP_OFFSET_CONTROL     0
#define FREEDOM_GPIP_OFFSET_DATA        2

#define FREEDOM_GPIP_BASE( i ) (FREEDOM_INDEX_GPIP_BASE + ((i) * 4))

#endif


/*
// GPIP Control bits
*/

#define FREEDOM_GPIP_CONTROL_AVAILABLE  0x8000   /* space or data available  */
#define FREEDOM_GPIP_CONTROL_ENABLE     0x4000   /* GPIP is enabled          */
#define FREEDOM_GPIP_CONTROL_RESET      0x2000   /* Reset GPIP               */
#define FREEDOM_GPIP_CONTROL_WIDTH16    0x0200   /* 16-bit access else 8-bit */
#define FREEDOM_GPIP_CONTROL_WRITE_FIFO 0x0100   /* GPIP write to FIFO, else */
                                                 /*      GPIP read from FIFO */
#define FREEDOM_GPIP_CONTROL_HOST_IRQ   0x0040   /* IRQ Host on avaialable   */
#define FREEDOM_GPIP_CONTROL_DSP1_IRQ   0x0080   /* IRQ DSP1 on avaialable   */
#define FREEDOM_GPIP_CONTROL_DSP2_IRQ   0x00C0   /* IRQ DSP2 on avaialable   */
#define FREEDOM_GPIP_CONTROL_FIFOSEL    0x001F   /* FIFO selection           */

/*
// FIFO Control
*/

#define FREEDOM_INDEX_FIFO_RAM_BASE             0x0400
#define FREEDOM_INDEX_FIFO_CONTROL_STORE_BASE   0x0700
#define FREEDOM_INDEX_FIFO_FLAGS_BASE           0x0780

#if defined( _NTDDK_ )
#include <pshpack1.h>
#endif

typedef struct _FREEDOM_PHYSFIFO {

    USHORT  Control;

} FREEDOM_PHYSFIFO, *PFREEDOM_PHYSFIFO;

#if defined( _NTDDK_ )
#include <poppack.h>
#endif

typedef struct _FREEDOM_FIFO {

    USHORT              Index;
    USHORT              Address;
    FREEDOM_PHYSFIFO    Registers;

} FREEDOM_FIFO, *PFREEDOM_FIFO;

#if defined( _NTDDK_ )

#define FREEDOM_FIFO_OFFSET_CONTROL FIELD_OFFSET( FREEDOM_PHYSFIFO, Control )

#define FREEDOM_FIFO_CONTROL_BASE( i ) (FREEDOM_INDEX_FIFO_CONTROL_STORE_BASE + ((i) * sizeof( FREEDOM_PHYSFIFO )))
#define FREEDOM_FIFO_FLAGS_BASE( i ) (FREEDOM_INDEX_FIFO_FLAGS_BASE + ((i) * sizeof( FREEDOM_PHYSFIFO )))

#else

/*
// The DSP compiler uses word addressing when we really mean byte addressing.
*/

#define FREEDOM_FIFO_OFFSET_CONTROL 0

#define FREEDOM_FIFO_CONTROL_BASE( i ) (FREEDOM_INDEX_FIFO_CONTROL_STORE_BASE + ((i) * 2))
#define FREEDOM_FIFO_FLAGS_BASE( i ) (FREEDOM_INDEX_FIFO_FLAGS_BASE + ((i) * 2))

/*
// The DSP compiler uses word addressing when we really mean byte addressing.
*/

#endif

#define FREEDOM_FIFO_CONTROL_SIZE16         0x0000
#define FREEDOM_FIFO_CONTROL_SIZE32         0x0001
#define FREEDOM_FIFO_CONTROL_SIZE64         0x0002

/*
// Message control
*/

#define FREEDOM_INDEX_MESSAGE_BASE          0x0380

#define FREEDOM_INDEX_MESSAGE_CONTROL_HOST  (FREEDOM_INDEX_MESSAGE_BASE + 0)
#define FREEDOM_INDEX_MESSAGE_DATA_HOST     (FREEDOM_INDEX_MESSAGE_BASE + 2)
#define FREEDOM_INDEX_MESSAGE_CONTROL_DSP1  (FREEDOM_INDEX_MESSAGE_BASE + 4)
#define FREEDOM_INDEX_MESSAGE_DATA_DSP1     (FREEDOM_INDEX_MESSAGE_BASE + 6)
#define FREEDOM_INDEX_MESSAGE_CONTROL_DSP2  (FREEDOM_INDEX_MESSAGE_BASE + 8)
#define FREEDOM_INDEX_MESSAGE_DATA_DSP2     (FREEDOM_INDEX_MESSAGE_BASE + 10)

#define FREEDOM_MESSAGE_CONTROL_RESET       0x8000
#define FREEDOM_MESSAGE_CONTROL_IRQ_MASK    0x6000
#define FREEDOM_MESSAGE_CONTROL_IRQ_DSP2    0x6000
#define FREEDOM_MESSAGE_CONTROL_IRQ_DSP1    0x4000
#define FREEDOM_MESSAGE_CONTROL_IRQ_HOST    0x2000
#define FREEDOM_MESSAGE_CONTROL_PTR         0x000F

/*
// Max length of message is 8 words
*/

#define FREEDOM_MESSAGE_MAXLEN              0x0008

/*
// MIDI Control
*/

#define FREEDOM_INDEX_MIDI_BASE             0x0390

#define FREEDOM_INDEX_MIDI_TRANSMIT        (FREEDOM_INDEX_MIDI_BASE + 0)
#define FREEDOM_INDEX_MIDI_RECEIVE         (FREEDOM_INDEX_MIDI_BASE + 4)

#define FREEDOM_MIDI_CONTROL_TX_DISCLOOP    0x0200
#define FREEDOM_MIDI_CONTROL_TX_TESTMODE    0x0100
#define FREEDOM_MIDI_CONTROL_TX_ENABLE      0x0080
#define FREEDOM_MIDI_CONTROL_TX_RESET       0x0040
#define FREEDOM_MIDI_CONTROL_TX_FIFOSEL     0x001F

#define FREEDOM_MIDI_CONTROL_RX_IRQ_DSP2    0x0300
#define FREEDOM_MIDI_CONTROL_RX_IRQ_DSP1    0x0200
#define FREEDOM_MIDI_CONTROL_RX_IRQ_HOST    0x0100
#define FREEDOM_MIDI_CONTROL_RX_ENABLE      0x0080
#define FREEDOM_MIDI_CONTROL_RX_RESET       0x0040
#define FREEDOM_MIDI_CONTROL_RX_FIFOSEL     0x001F

/*
// General Control
*/

#define FREEDOM_INDEX_GENERAL_CONTROL       0x0320
#define FREEDOM_INDEX_SOFTWARE_RESET        (FREEDOM_INDEX_GENERAL_CONTROL + 0)
#define FREEDOM_INDEX_TIMER_SOURCE_COUNT    (FREEDOM_INDEX_GENERAL_CONTROL + 6)
#define FREEDOM_INDEX_TIMER_SOURCE_VALUE    (FREEDOM_INDEX_GENERAL_CONTROL + 4)
#define FREEDOM_INDEX_TIMER0_COUNT          (FREEDOM_INDEX_GENERAL_CONTROL + 8)
#define FREEDOM_INDEX_TIMER0_CONTROL        (FREEDOM_INDEX_GENERAL_CONTROL + 10)
#define FREEDOM_INDEX_TIMER_HOST_LATENCY    (FREEDOM_INDEX_GENERAL_CONTROL + 12)
#define FREEDOM_INDEX_GPIO_MODE             (FREEDOM_INDEX_GENERAL_CONTROL + 16)
#define FREEDOM_INDEX_GPIO_DATA             (FREEDOM_INDEX_GENERAL_CONTROL + 18)
#define FREEDOM_INDEX_GPIO_CONTROL          (FREEDOM_INDEX_GENERAL_CONTROL + 20)
#define FREEDOM_INDEX_GPIO_STATUS           (FREEDOM_INDEX_GENERAL_CONTROL + 22)

/*
// Software reset
*/

#define FREEDOM_RESET_WAVETABLE             0x0008
#define FREEDOM_RESET_CODEC                 0x0004
#define FREEDOM_RESET_DSP2                  0x0002
#define FREEDOM_RESET_DSP1                  0x0001

/*
// Freedom setup macros
*/

#define FREEDOM_SETUP_FIFO( fifo, index, control )\
{\
    (fifo)->Index = index;\
    (fifo)->Address = FREEDOM_FIFO_CONTROL_BASE( index );\
    (fifo)->Registers.Control = control;\
}

#define FREEDOM_SETUP_GPIP( gpip, index, control, fifo )\
{\
    (gpip)->Index = index;\
    (gpip)->Address = FREEDOM_GPIP_BASE( index );\
    (gpip)->Registers.Data = 0;\
    (gpip)->Registers.Control = control | ((fifo)->Index & FREEDOM_GPIP_CONTROL_FIFOSEL);\
}

#define FREEDOM_SETUP_BTU( btu, index, address, length, link, control, status, fifo )\
{\
    (btu)->Index = index;\
    (btu)->Address = FREEDOM_BTU_RAM_BASE( index );\
    (btu)->Registers.Address = address;\
    (btu)->Registers.TransferLength = length;\
    (btu)->Registers.LinkDescriptor = link;\
    (btu)->Registers.Control = control | ((fifo)->Index & FREEDOM_BTU_CONTROL_FIFOSEL);\
    (btu)->Registers.Status = status;\
    (btu)->Registers.Reserved = 0;\
}

#define FREEDOM_SETUP_VBTU( vbtu, address, length, link, control, status, fifo )\
{\
    (vbtu)->Address = address;\
    (vbtu)->TransferLength = length;\
    (vbtu)->LinkDescriptor = link;\
    (vbtu)->Control = control | ((fifo)->Index & FREEDOM_BTU_CONTROL_FIFOSEL);\
    (vbtu)->Status = status;\
    (vbtu)->Reserved = 0;\
}


#if defined( _NTDDK_ )

/*
// Host specific setup macros
*/

#define FREEDOM_DSP_VBTU_LINK( dc, index )\
    LOWORD( dc->physHostBTULinkPages.LowPart + ((index + DSP_LINK_DESCRIPTORS_INDEX) * sizeof( FREEDOM_PHYSBTU )) )

#define FREEDOM_HOST_VBTU_LINK( dc, vbtu )\
    LOWORD( dc->physHostBTULinkPages.LowPart + ((PUCHAR) vbtu - (PUCHAR) dc->HostVBTUsVa) )

#endif


/*--------------------------------------------------------------------------*/

/*
// Host link descriptors length is 12288 (768 VBTUs total),
// 32 link descriptors are reserved for the DSP (2 per pipe).
*/

#define HOST_LINK_DESCRIPTORS_BUFFER_LENGTH     12288
#define DSP_LINK_DESCRIPTORS_INDEX              ((HOST_LINK_DESCRIPTORS_BUFFER_LENGTH / sizeof( FREEDOM_PHYSBTU )) - (2 * FREEDOM_MAXNUM_PIPES))
#define HOST_AVG_LINK_DESCRIPTORS_PER_PIPE      30

/*
// Host messages
*/

/* general debugging message, variable length */

#define HM_DEBUG_STRING     0x0000

/*
// DSP messages
*/

#define DM_ALLOC_PIPE               0x0000
#define DM_GET_PIPE_INFO            0x0001
#define DM_SET_BUFFER_SIZES         0x0002
#define DM_RESET_PIPE               0x0003
#define DM_FREE_PIPE                0x0004
#define DM_START_PIPE               0x0005
#define DM_PAUSE_PIPE               0x0006
#define DM_RESUME_PIPE              0x0007
#define DM_STOP_PIPE                0x0008

/*--------------------------------------------------------------------------*/

/*
// Host interface specific defines
*/

#if defined( _NTDDK_ )

/*
// Freedom register macros
*/

#define WRITE_FREEDOM_INDEXED_REG_LOWORD( DeviceContext, Idx, Data )\
{\
    WRITE_PORT_USHORT( (PUSHORT)(DeviceContext->portFreedom + FREEDOM_REG_INDEX),\
                       Idx );\
    WRITE_PORT_USHORT( (PUSHORT)(DeviceContext->portFreedom + FREEDOM_REG_DATA_LOWORD),\
                       Data );\
}

#define WRITE_FREEDOM_INDEXED_REG_HIWORD( DeviceContext, Idx, Data )\
{\
    WRITE_PORT_USHORT( (PUSHORT)(DeviceContext->portFreedom + FREEDOM_REG_INDEX),\
                       Idx );\
    WRITE_PORT_USHORT( (PUSHORT)(DeviceContext->portFreedom + FREEDOM_REG_DATA_HIWORD),\
                       Data );\
}

#define WRITE_FREEDOM_INDEXED_REG_ULONG( DeviceContext, Idx, Data )\
{\
    WRITE_PORT_USHORT( (PUSHORT)(DeviceContext->portFreedom + FREEDOM_REG_INDEX),\
                       Idx );\
    WRITE_PORT_USHORT( (PUSHORT)(DeviceContext->portFreedom + FREEDOM_REG_DATA_LOWORD),\
                       LOWORD( Data ) );\
    WRITE_PORT_USHORT( (PUSHORT)(DeviceContext->portFreedom + FREEDOM_REG_DATA_HIWORD),\
                       HIWORD( Data ) );\
}

__inline USHORT READ_FREEDOM_INDEXED_REG_LOWORD(
    PDEVICE_INSTANCE DeviceContext,
    USHORT Idx
    )
{
    WRITE_PORT_USHORT( (PUSHORT)(DeviceContext->portFreedom + FREEDOM_REG_INDEX),\
                       Idx );\
    return READ_PORT_USHORT( (PUSHORT)(DeviceContext->portFreedom + FREEDOM_REG_DATA_LOWORD) );
}

__inline USHORT READ_FREEDOM_INDEXED_REG_HIWORD(
    PDEVICE_INSTANCE DeviceContext,
    USHORT Idx
    )
{
    WRITE_PORT_USHORT( (PUSHORT)(DeviceContext->portFreedom + FREEDOM_REG_INDEX),\
                       Idx );\
    return READ_PORT_USHORT( (PUSHORT)(DeviceContext->portFreedom + FREEDOM_REG_DATA_HIWORD) );
}

__inline ULONG READ_FREEDOM_INDEXED_REG_ULONG(
    PDEVICE_INSTANCE DeviceContext,
    USHORT Idx
)
{
    WRITE_PORT_USHORT( (PUSHORT)(DeviceContext->portFreedom + FREEDOM_REG_INDEX),\
                       Idx );\
    return MAKELONG( READ_PORT_USHORT( (PUSHORT)(DeviceContext->portFreedom + FREEDOM_REG_DATA_LOWORD) ),
                     READ_PORT_USHORT( (PUSHORT)(DeviceContext->portFreedom + FREEDOM_REG_DATA_HIWORD) ) );
}

/*
// ADSP-2181 defines
*/

#define ADSP2181_PAD_SIZE       (16*1024)
#define ADSP2181_CODESPACE_SIZE (48*1024)
#define ADSP2181_DATASPACE_SIZE (32*1024)

#define ADSP2181_REGION_MEM_END 0
#define ADSP2181_REGION_MEM_PA  1
#define ADSP2181_REGION_MEM_PO  2
#define ADSP2181_REGION_MEM_DA  3
#define ADSP2181_REGION_MEM_DO  4
#define ADSP2181_REGION_MEM_BO  5

typedef struct _ADSP2181_IMAGE {
    USHORT  Type;
    USHORT  Address;
    USHORT  MaxDataAddress;
    USHORT  MaxCodeAddress;
    PUCHAR  CodeSpace;
    PUCHAR  DataSpace;
    USHORT  Length;
    
} ADSP2181_IMAGE, *PADSP2181_IMAGE;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\ksfilter\miniport\freedom\dsp\message.c ===
/*++

    Copyright (C) Microsoft Corporation, 1996 - 1997

Module Name:

    message.c

Abstract:

    Interface to Diamond Multimedia's Freedom ASIC message port

Author:
    Bryan A. Woodruff (bryanw) 14-Nov-1996

--*/

#include <def2181.h>
#include <circ.h>
#include <signal.h>
#include <sport.h>
#include <string.h>

#include "ntdefs.h"
#include "freedom.h"
#include "private.h"

PMESSAGE MessageQueue;

void SendMessage(
    PMESSAGE Message
)
{
    int     i;
    USHORT  Control;

    /*
    // Reset the message pointer and write the message to the port.
    */

    Control = 
        inpw( FREEDOM_INDEX_MESSAGE_CONTROL_DSP1 ) & 
            FREEDOM_MESSAGE_CONTROL_IRQ_MASK;
    outpw( FREEDOM_INDEX_MESSAGE_CONTROL_DSP1, Control );

    for (i = 0; i < Message->Length; i++) {
        outpw( FREEDOM_INDEX_MESSAGE_DATA_DSP1, Message->Data[ i ] );
    }

    /*
    // Notify the receiver of a message pending.  This generates an
    // interrupt on the destination.
    */

    Control = Message->Length | Message->Destination;
    outpw( FREEDOM_INDEX_MESSAGE_CONTROL_DSP1, Control );

}


void PostMessage( 
    PMESSAGE Message 
)
{
    USHORT  IrqsEnabled;

    /*
    // If we have message in the queue, add this one to the queue,
    // otherwise, put it at the head of the list and send it off
    // immediately.
    */

    IrqsEnabled = IrqEnable;
    disable();

    Message->Completed = FALSE;
    Message->Next = NULL;

    if (!MessageQueue) {
        MessageQueue = Message;
        SendMessage( MessageQueue );
    } else {

        PMESSAGE Node;

        /*
        // Attach message to the end of the queue
        */

        for (Node = MessageQueue; Node->Next; Node = Node->Next);

        Node->Next = Message;
    }

    if (IrqsEnabled) {
        enable();
    }

}

void MsHostIncoming(
    void
)
{
    int     i;
    USHORT  Control, Length, Message[ 8 ];


    /*
    // Determine message length, reset the FIFO pointer, but keep IRQ high.
    */

    Control =  inpw( FREEDOM_INDEX_MESSAGE_CONTROL_HOST );
    Length = Control & FREEDOM_MESSAGE_CONTROL_PTR;
    outpw( FREEDOM_INDEX_MESSAGE_CONTROL_HOST,
           Control & FREEDOM_MESSAGE_CONTROL_IRQ_MASK );

    /*
    // Retrieve message
    */

    for (i = 0; i < Length; i++) {
        Message[ i ] = inpw( FREEDOM_INDEX_MESSAGE_DATA_HOST );
    }

    /*
    // Reset FIFO pointer for response.
    */

    outpw( FREEDOM_INDEX_MESSAGE_CONTROL_HOST,
           Control & FREEDOM_MESSAGE_CONTROL_IRQ_MASK );

    switch (Message[ 0 ]) {
                    
    case DM_ALLOC_PIPE:
        {
            USHORT  Pipe;

            if (FreedomAllocateDSPPipe( &Pipe )) {

                outpw( FREEDOM_INDEX_MESSAGE_DATA_HOST, Pipe  );

                Length = 1;
            } else {
                Length = 0;
            }
        }
        break;

    case DM_GET_PIPE_INFO:
        {
            USHORT  Pipe;

            Pipe = Message[ 1 ];

            if (Pipe > FREEDOM_MAXNUM_PIPES) {
                Length = 0;
            } else {

                if (0 == (Pipes[ Pipe ].Flags & PIPE_FLAG_ALLOCATED)) {
                    Length = 0;
                    break;
                }

                outpw( FREEDOM_INDEX_MESSAGE_DATA_HOST, 
                       (USHORT) Pipes[ Pipe ].BufferAddress );
                outpw( FREEDOM_INDEX_MESSAGE_DATA_HOST, 
                       (USHORT) &Pipes[ Pipe ].BufferAddress[ PIPE_BUFFER_SIZE / 2 ] );
                outpw( FREEDOM_INDEX_MESSAGE_DATA_HOST, 
                       Pipes[ Pipe ].BufferSize );
                Length = 3;
            }
        }
        break;

    case DM_START_PIPE:
        {
            USHORT  Pipe;

            Pipe = Message[ 1 ];

            if (Pipe > FREEDOM_MAXNUM_PIPES) {
                Message[ 0 ] = FALSE;
            } else {
                USHORT  Base, Control;

                if (0 == (Pipes[ Pipe ].Flags & PIPE_FLAG_ALLOCATED)) {
                    Message[ 0 ] = FALSE;
                    break;
                }

                Pipes[ Pipe ].Flags |= PIPE_FLAG_ACTIVE;

                Base = 
                    FREEDOM_BTU_RAM_BASE( Pipe + FREEDOM_DSP_BTU_BASE_INDEX );

                Control = inpw( Base + FREEDOM_BTU_OFFSET_CONTROL );
                outpw( Base + FREEDOM_BTU_OFFSET_CONTROL, 
                       Control | FREEDOM_BTU_CONTROL_LINKDEFINED );
                Message[ 0 ] = TRUE;
            }
            Length = 1;
        }
        break;

    }

    /*
    // Acknowledge reset of message and return length of response.
    */

    Control = Length;
    outpw( FREEDOM_INDEX_MESSAGE_CONTROL_HOST,
           Control | FREEDOM_MESSAGE_CONTROL_IRQ_HOST );
}

void MsDSP1Acknowledge(
    void
)
{
    if (MessageQueue)
    {
        PMESSAGE Current;

        Current = MessageQueue;
        MessageQueue = MessageQueue->Next;
        Current->Next = NULL;
        Current->Completed = TRUE;

        /*
        // Send the next message in the queue, if any
        */

        if (MessageQueue) {

            SendMessage( MessageQueue );

        } else {

            /*
            // Clear the interrupt
            */

            outpw( FREEDOM_INDEX_MESSAGE_CONTROL_DSP1, 0 );
        }

    } else {

        /*
        // N.B.  If the queue is maintained correctly,
        // this branch should not be possible.
        */ 
    }

}

void MsDSP2Incoming( 
    void 
)
{
    outpw( FREEDOM_INDEX_MESSAGE_CONTROL_DSP2, 0 );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\ksfilter\miniport\freedom\dsp\codec.c ===
/*++

    Copyright (C) Microsoft Corporation, 1996 - 1997

Module Name:

    codec.c

Abstract:

    AD1843 coder/decoder interface from ADSP2181

Author:
    Bryan A. Woodruff (bryanw) 12-Nov-1996

--*/

#include "ntdefs.h"
#include "freedom.h"
#include "ad1843.h"
#include "private.h"
#include <string.h>

USHORT CdInit[] =
{
    1,  0x0000,
    2,  0x3030,     /* MIC to ADC */
    3,  0x8888,     /* DAC2 to mixer */
    4,  0x0808,     /* AUX1 to mixer */
    5,  0x8888,     /* AUX2 to mixer */
    6,  0x8888,     /* AUX3 to mixer */
    7,  0x8888,     /* MIC to mixer */
    8,  0x8818,     /* Mono input muted, headphone out mute */
    11, 0x0000,     /* DAC1 digital attenuation */
    12, 0x8888,     /* DAC2 digital attenuation */
    13, 0x8888,     /* ADC to DAC1 mixing */
    14, 0x8888,     /* ADC to DAC2 mixing */
    15, 0x0505,
    16, 0x0000,
    17, FREEDOM_DEVICE_SAMPLE_RATE,
    18, 0x0000,
    19, 0x0000,
    20, FREEDOM_DEVICE_SAMPLE_RATE,
    21, 0x0000,
    22, 0x0000,
    23, FREEDOM_DEVICE_SAMPLE_RATE,
    24, 0x0000,
    25, 0x4000
};

#if defined( DEBUG )

void ToHexStr( PCHAR Str, USHORT Hex )
{
    UCHAR  Nibble;
    int    i;

    Str += 3;

    for (i = 0; i < 4; i++) {
        
        Nibble = Hex & 0x0F;
        Hex >>= 4;
        if ((*Str = Nibble + 0x30) > 0x39)
            *Str = *Str - 0x3A + 'a';
        Str--;
    }
}

#endif

void CODEC_CopyFrom(
    void                                                         
)
{
    RxPayload.Buffer[ 0 ] = RxBuffer[ 0 ];
    RxPayload.Buffer[ 1 ] = RxBuffer[ 1 ];
    RxPayload.Buffer[ 2 ] = RxBuffer[ 2 ];
    RxPayload.Buffer[ 3 ] = RxBuffer[ 3 ];
}

void CODEC_CopyTo(
    void                                                         
)
{
    TxBuffer[ 0 ] = TxPayload.Buffer[ 0 ];
    TxBuffer[ 1 ] = TxPayload.Buffer[ 1 ];
    TxBuffer[ 2 ] = TxPayload.Buffer[ 2 ];
    TxBuffer[ 3 ] = TxPayload.Buffer[ 3 ];
    TxBuffer[ 4 ] = TxPayload.Buffer[ 4 ];
    TxBuffer[ 5 ] = TxPayload.Buffer[ 5 ];
}



USHORT CODEC_Read(
    USHORT  reg
)
{
    TxPayload.Buffer[ 0 ] = reg | 0x80;
    Sport0SignalTx( CODEC_CopyTo );
    Sport0WaitTxClear();
    Sport0WaitRxFrame( CODEC_CopyFrom );
    return RxPayload.Buffer[ 1 ];
}

void CODEC_Write( 
    USHORT reg, 
    USHORT val 
)
{
    TxPayload.Buffer[ 0 ] = reg;
    TxPayload.Buffer[ 1 ] = val;
    Sport0SignalTx( CODEC_CopyTo );
    Sport0WaitTxClear();
}

void CdInitialize(
    void 
)
{
    int    i;
    USHORT Value;

    /*
    // Wait for INIT to go to 0
    */

    dprintf( "ADSP2181: waiting for INIT to go 0\n" );

    while (CODEC_Read( 0 ) & 0x8000) {
        asm( "idle; ");
    }

    /* 
    // Power up, autocalibrate and put conversion resources into standby
    */

    CODEC_Write( 28, 0x4800 );

    /*
    // Wait for PDNO to go to 0
    */

    dprintf( "waiting for PDNO to go 0\n" );

    while (CODEC_Read( 0 ) & 0x4000) {
        asm( "idle; ");
    }

    /*
    // Second phase delay (see AD1843 spec. on power-up).
    // Wait for resources and enable mixer registers.
    */

    for (;;)
    {
        CODEC_Write( 27, AD1843_CPD_DDMEN |
                         AD1843_CPD_ANAEN |
                         AD1843_CPD_AAMEN );
        if (CODEC_Read( 27 ) == (AD1843_CPD_DDMEN | 
                                 AD1843_CPD_ANAEN |
                                 AD1843_CPD_AAMEN ))
            break;
    }

    /*
    // Serial interface configuration
    */

    for (;;)
    {
        CODEC_Write( 26, 0x0505 );
        if (CODEC_Read( 26 ) == 0x0505)
            break;
    }

    /*
    // Configure resources
    */

    for (i = 0; i < sizeof( CdInit ); i += 2) {
        CODEC_Write( CdInit[ i ], CdInit[ i + 1 ] );
    }

    /*
    // Bring DAC1 and ADCL/ADCR out of standby, enable headphones
    */

                       
    Value = 
        AD1843_CPD_DDMEN |
        AD1843_CPD_DA1EN | 
        AD1843_CPD_ANAEN |
        AD1843_CPD_HPEN |
        AD1843_CPD_AAMEN |
        AD1843_CPD_ADREN |
        AD1843_CPD_ADLEN;

    for (;;)
    {
        CODEC_Write( 27, Value );
        if (CODEC_Read( 27 ) == Value)
            break;
        asm( "idle;");
    }

    /*
    // Set DAC1 output level
    */

    CODEC_Write( 9, 0x0808 );

    dprintf( "ADSP2181: codec power up completed.\n" );
}

void CdDisable(
    void 
)
{
    USHORT  Reset;

    /*
    // Reset CODEC
    */

    Reset = inpw( FREEDOM_INDEX_SOFTWARE_RESET );
    outpw( FREEDOM_INDEX_SOFTWARE_RESET, Reset | FREEDOM_RESET_CODEC );
}

void CdEnable(
    void 
)
{
    USHORT  Reset;

    /*
    // Re-enable CODEC, SPORT0 will become active.
    */

    Reset = inpw( FREEDOM_INDEX_SOFTWARE_RESET );
    outpw( FREEDOM_INDEX_SOFTWARE_RESET, Reset & ~FREEDOM_RESET_CODEC );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\ksfilter\miniport\freedom\dsp\freedom.c ===
/*++

    Copyright (C) Microsoft Corporation, 1996 - 1997

Module Name:

    freedom.c

Abstract:

    Diamond Multimedia's Freedom board, main loop and initialization.

Author:
    Bryan A. Woodruff (bryanw) 14-Oct-1996

--*/

#include <def2181.h>
#include <circ.h>
#include <math.h>
#include <signal.h>
#include <sport.h>
#include <string.h>

#include "ntdefs.h"
#include "freedom.h"
#include "private.h"

/*
// The hard returns in the in-line asm below are for the listing file
// and don't have any other significant meaning.
*/

asm( ".global TxBuffer_;\n\
      .var/dm/ram/circ TxBuffer_[ 6 ];\n\
      .global RxBuffer_;\n\
      .var/dm/ram/circ RxBuffer_[ 6 ];" );

/*
// SPORT0 buffer interface
//
// Note that SPORT_PAYLOAD is used to communicate with the SPORT ISRs,
// the SPORT ISRs use RxBuffer and TxBuffer to transmit/receive data in
// synchronized fashion.
*/

extern volatile USHORT RxBuffer[ 6 ], TxBuffer[ 6 ];
SPORT_PAYLOAD RxPayload, TxPayload;
PVOID_PM TxHandler = 0, RxHandler = 0;

static USHORT AdcL, AdcR;

/*
// DSP pipe, VBTU allocations
*/

ULONG PipeAllocMap = 0;

/*
// Physical DSP pipe structures
*/

PIPE    Pipes[ FREEDOM_MAXNUM_PIPES ];
USHORT  PipeBuffers[ FREEDOM_MAXNUM_PIPES ][ PIPE_BUFFER_SIZE ];

/*
// Local function prototypes
*/

void Sp0Setup( 
    void 
);

void FaReset(
    void
);

void SineWave(
    void 
);

void Capture(
    void
);

void Feedback(
    void
);

void OutputPipes(
    void
);

void FreedomKickPipe( 
    USHORT Pipe 
);

/*
//---------------------------------------------------------------------------
*/

USHORT IrqEnable;

void main()
{
    long    i;
    double  x;

    disable();

    /*
    // Initialize ADSP2181 and reset the Freedom interface from the
    // DSP to the ASIC.
    */

    DspInit();

#if 0
    TestSrc();
#else

    FaReset();

    enable();

    dprintf( "ADSP2181: DSP core active.\n" );

    /*
    // Send DSP handshake to HOST port.
    */

    outpw( FREEDOM_INDEX_MESSAGE_CONTROL_HOST, 0x0000 );
    outpw( FREEDOM_INDEX_MESSAGE_DATA_HOST, 0xABCD );

    /*
    // Initialize the CODEC
    */

    CdInitialize();


/*
//    RxHandler = Capture;
//    TxHandler = Feedback;
*/

/*
//    TxHandler = SineWave;
*/


    TxHandler = OutputPipes;

    for(;;) {
        asm( "idle;" );
/*
//        if (Pipes[ 0 ].Flags & PIPE_FLAG_PING_DONE) {
//            dprintf( "pipe[ 0 ] ping done\n" );
//        }
//        if (Pipes[ 0 ].Flags & PIPE_FLAG_PONG_DONE) {
//            dprintf( "pipe[ 0 ] pong done\n" );
//        }
*/
    }
#endif    

}

void disable()
{
    asm( "dis ints;" );
    IrqEnable = FALSE;
}

void enable()
{
    asm( "ena ints;" );
    IrqEnable = TRUE;
}


void SineWave(
    void 
)
{
    static  USHORT i = 0, freq, sampling_freq;
    double  x;

    freq = 800;
    sampling_freq = 48000;

    if (RxBuffer[ 0 ] & 0x0001) {
        x = sin( (double) freq * (double) i / (double) sampling_freq * (double) 6.28318530718 );
        TxBuffer[ 2 ] = TxBuffer[ 3 ] = 
            (SHORT) (x * (double) 0x1000);
        TxBuffer[ 0 ] = 0x100;
        if (i++ >= (sampling_freq/freq)) {
            i = 0;
        }
    }
}

void Capture(
    void
)
{
    if (RxBuffer[ 0 ] & 0x300) {
        if (RxBuffer[ 0 ] & 0x100) {
            AdcL = RxBuffer[ 2 ];
        }
        if (RxBuffer[ 0 ] & 0x200) {
            AdcR = RxBuffer[ 3 ];
        }
    }
}

void Feedback(
    void
)
{
    if (RxBuffer[ 0 ] & 0x0001) {
        TxBuffer[ 2 ] = AdcL;
        TxBuffer[ 3 ] = AdcR;
        TxBuffer[ 0 ] = 0x100;
    }
}

void OutputPipes( 
    void 
)
{
    int     i, j;
    USHORT  Buffer, Offset;

    if (RxBuffer[ 0 ] & 0x0001) {
        TxBuffer[ 2 ] = TxBuffer[ 3 ] = 0;
        for (i = 0; i < FREEDOM_MAXNUM_PIPES; i++) {
            if (Pipes[ i ].Flags & PIPE_FLAG_ACTIVE) {

                /* 
                // Check for starvation 
                */

                Buffer = Pipes[ i ].CurrentBuffer;
                if (0 == (Pipes[ i ].Flags & (1 << Buffer))) {
                    continue;
                }

                /*
                // simple additive mixing 
                //
                // (should really use the accumlator and 
                // saturate when mixing is complete)
                */

                Offset = 
                    (Pipes[ 0 ].SrcTime / SRC_SCALING_FACTOR) * 
                        Pipes[ 0 ].Channels;
                Offset += (Buffer * PIPE_BUFFER_SIZE / 2);

                Pipes[ 0 ].BufferOffset = Offset;
                    
#if 0
                TxBuffer[ 2 ] += SrcFilter( &Pipes[ i ] );
                if (Pipes[ i ].Channels > 1) {

                    Pipes[ i ].BufferOffset++;
                    TxBuffer[ 3 ] += SrcFilter( &Pipes[ i ] );
                }
#else
                TxBuffer[ 2 ] += 
                    Pipes[ i ].BufferAddress[ Offset++ ];
                if (Pipes[ i ].Channels > 1) {
                    TxBuffer[ 3 ] +=
                        Pipes[ i ].BufferAddress[ Offset ];
                }
#endif


                Pipes[ i ].SrcTime += Pipes[ i ].SrcDataInc;

                /* 
                // If we have incremented our position then we need to 
                // slide the data window 
                */

                if (Pipes[ 0 ].SrcTime >= Pipes[ 0 ].SrcEndBuffer) {

                    Pipes[ 0 ].SrcTime -= Pipes[ 0 ].SrcEndBuffer;

                    /*
                    // Clear the buffer done flag to allow the
                    // BTU to get kicked in the ISR.
                    */

                    Pipes[ i ].Flags &= ~(1 << Buffer);
                    Pipes[ i ].CurrentBuffer = (Buffer + 1) & 1;

                    if (Pipes[ i ].Flags & PIPE_FLAG_NEEDKICK) {
                        FreedomKickPipe( i );
                    }
                }
            }

        }
        TxBuffer[ 0 ] = 0x100;
    }
}

void Sp0Setup(
    void 
)
{

    USHORT  SysCtrlReg;

    /*  
    // receive and transmit autobuffering, receive m1, receive i2,
    // transmit m1, transmit i3
    */

    *((PUSHORT) Sport0_Autobuf_Ctrl) = 0x6A7;

    /*
    // Sport0_Rfsdiv = 0 
    */

    *((PUSHORT) Sport0_Rfsdiv) = (USHORT) 0;

    /*
    // Sport0_Sclkdiv = 0 
    */

    *((PUSHORT) Sport0_Sclkdiv) = (USHORT) 0;

    /*
    // multichannel, ISCLK external, frame sync to occur 1 clock
    // cycle before first bit, multichannel length is 32 words,
    // RFS external, receive framing and transmit valid positive,
    // right justify, 16 bits per word (16-1).
    */

    *((PUSHORT) Sport0_Ctrl_Reg) = (USHORT) 0x860f;

    /*
    // Channels 1-6
    */

    *((PUSHORT) Sport0_Rx_Words0) = (USHORT) 0x3f;
    *((PUSHORT) Sport0_Rx_Words1) = (USHORT) 0x3f;
    *((PUSHORT) Sport0_Tx_Words0) = (USHORT) 0x3f;
    *((PUSHORT) Sport0_Tx_Words1) = (USHORT) 0x3f;

    /*
    // Enable SPORT0 in the system control register.
    */

    /*
    // N.B.: This NOP is strategically placed to force the
    //       compiler to maintain the I/O order such that Sport0
    //       is enabled after it has been configured.
    */

    asm( "nop;" );

    SysCtrlReg = *(PUSHORT)(Sys_Ctrl_Reg);
    *(PUSHORT)(Sys_Ctrl_Reg) = SysCtrlReg | 0x1000;
}

void FaReset(
    void
)
{
    /*
    // Disable IRQ generation.
    */

    outpw( FREEDOM_REG_IRQ_DSP1_OFFSET + FREEDOM_REG_IRQ_GROUP, 0 );

    /*
    // Disable CODEC
    */

    CdDisable();

    /*
    // Setup registers for ADSP2181 auto-buffering of serial port 0.
    */

    asm( "m1 = 1;\n" );
    asm( "i2 = ^RxBuffer_; l2 = %RxBuffer_;\n" );
    asm( "i3 = ^TxBuffer_+1; l3 = %TxBuffer_;\n" );

    /*
    // Initialize serial port 0.
    */ 
    
    Sp0Setup();

    /*
    // Enable wanted interrupts from ASIC 
    */

    outpw( FREEDOM_REG_IRQ_DSP1_OFFSET + FREEDOM_REG_IRQ_GROUP, 
           FREEDOM_IRQMASK_GROUP_MESSAGE |
               FREEDOM_IRQMASK_GROUP_BTU );

    /*
    // Reset message ports
    */

    outpw( FREEDOM_INDEX_MESSAGE_CONTROL_HOST, FREEDOM_MESSAGE_CONTROL_RESET );
    outpw( FREEDOM_INDEX_MESSAGE_CONTROL_HOST, 0x0000 );

    outpw( FREEDOM_INDEX_MESSAGE_CONTROL_DSP1, FREEDOM_MESSAGE_CONTROL_RESET );
    outpw( FREEDOM_INDEX_MESSAGE_CONTROL_DSP1, 0x0000 );

    outpw( FREEDOM_INDEX_MESSAGE_CONTROL_DSP2, FREEDOM_MESSAGE_CONTROL_RESET );
    outpw( FREEDOM_INDEX_MESSAGE_CONTROL_DSP2, 0x0000 );

    interrupt( SIGINT2, FreedomIRQ );

    /*
    // Enable the Sport0 Tx and Rx interrupts
    */

    asm( "ar=IMASK;ay0 = b#0001100000;ar = ar or ay0;IMASK=ar;":::"ar", "ay0" );
/*  asm( "ar=IMASK;ay0 = b#0001000000;ar = ar or ay0;IMASK=ar;":::"ar", "ay0" );*/

    clear_interrupt( SIGINT2 );
    clear_interrupt( SIGSPORT0XMIT );
    clear_interrupt( SIGSPORT0RECV );

    /*
    // Enable CODEC
    */

    CdEnable();
}

void
FreedomResetDSPPipe(
    USHORT Pipe
)
{
    Pipes[ Pipe ].BufferAddress = &PipeBuffers[ Pipe ][ 0 ];
    Pipes[ Pipe ].BufferSize = PIPE_BUFFER_SIZE;  /* size in bytes */

    Pipes[ Pipe ].SampleRate = 44100;
    Pipes[ Pipe ].BitsPerSample = 16;
    Pipes[ Pipe ].Channels = 2;

    /*
    // FCutoff is the number of look-up values available for the 
    // lowpass filter between the beginning of its impulse response 
    // and the "cutoff time" of the filter.  The cutoff time is defined 
    // as the reciprocal of the lowpass-filter cut off frequency in Hz.  
    // For example, if the lowpass filter were a sinc function, FCutoff would 
    // be the index of the impulse-response lookup-table corresponding to 
    // the first zero-crossing of the sinc function.  (The inverse first 
    // zero-crossing time of a sinc function equals its nominal cutoff 
    // frequency in Hz.)
    */

    #define SRC_FCUTOFF 256
    
    Pipes[ Pipe ].SrcCoeffInc = 
        (ULONG) FREEDOM_DEVICE_SAMPLE_RATE * 
            (ULONG) SRC_FCUTOFF / 
                Pipes[ Pipe ].SampleRate;

    Pipes[ Pipe ].SrcCoeffInc = min( Pipes[ Pipe ].SrcCoeffInc, SRC_FCUTOFF );

    Pipes[ Pipe ].SrcDataInc = 
        	(ULONG) Pipes[ Pipe ].SampleRate * 
                (ULONG) SRC_SCALING_FACTOR / 
                    FREEDOM_DEVICE_SAMPLE_RATE;

    Pipes[ Pipe ].SrcFilterSize = 
        (SRC_FILTER_SIZE / Pipes[ Pipe ].SrcCoeffInc);

    Pipes[ Pipe ].SrcTime = 0;
    Pipes[ Pipe ].SrcEndBuffer = 
        PIPE_BUFFER_SIZE / (2 * Pipes[ Pipe ].Channels) * SRC_SCALING_FACTOR;

    /*
    // Volume not yet implemented, this is currently considered
    // attenuation and in dB units.
    */
    
    Pipes[ Pipe ].VolumeL = 0;
    Pipes[ Pipe ].VolumeR = 0;

    /*
    // Current and transfer buffers for CODEC processing.
    */

    Pipes[ Pipe ].CurrentBuffer = 
        Pipes[ Pipe ].TransferBuffer = PIPE_CURRENTBUFFER_PING;

    Pipes[ Pipe ].Flags = 0;

    /*
    // The filter chain is a chain of digital filters which
    // will be established by the host.  
    */

    Pipes[ Pipe ].FilterChain = NULL;
}

BOOL
FreedomAllocateDSPPipe(
    PUSHORT Pipe
)
{
    int  i;

    for (i = 0; i < FREEDOM_MAXNUM_PIPES; i++) {
        if (0 == (PipeAllocMap & ((ULONG) 1 << i))) {

            /*
            // Note that we are currently using two VBTUs 
            // per pipe and using a ping-pong data access 
            // method.
            */

            PipeAllocMap |= ((ULONG) 1 << i);
            *Pipe = i;
            FreedomResetDSPPipe( *Pipe );
            Pipes[ *Pipe ].Flags |= PIPE_FLAG_ALLOCATED;
            return TRUE;
        }
    }
    return FALSE;
}

BOOL
FreedomFreeDSPPipe(
    USHORT Pipe
)
{
    int   i;
    BOOL  Allocated;

    Allocated = (PipeAllocMap & (1 << i));
    PipeAllocMap &= ~(1 << i);

    return Allocated;
}

void FreedomKickPipe( 
    USHORT Pipe 
)
{
    USHORT Base, Control;

    /*
    // Let the BTU run...
    */

    Pipes[ Pipe ].Flags &= ~PIPE_FLAG_NEEDKICK;
    Base = 
        FREEDOM_BTU_RAM_BASE( Pipe + FREEDOM_DSP_BTU_BASE_INDEX );

    Control = inpw( Base + FREEDOM_BTU_OFFSET_CONTROL );
    outpw( Base + FREEDOM_BTU_OFFSET_CONTROL, 
            Control | FREEDOM_BTU_CONTROL_LINKDEFINED );
}

/*
//---------------------------------------------------------------------------
*/

void FreedomIRQ(
    int Argument 
)
{
    USHORT Source;

    /*
    // Determine the IRQ source
    */

    Source = inpw( FREEDOM_REG_IRQ_DSP1_OFFSET + FREEDOM_REG_IRQ_GROUP );
    
    while (Source & 
           (FREEDOM_IRQ_GROUP_MESSAGE | FREEDOM_IRQ_GROUP_BTU)) {

        /*
        // Process BTU interrupts
        */

        if (Source & FREEDOM_IRQ_GROUP_BTU) {
            USHORT Pipe;

            Pipe = 
                inpw( FREEDOM_REG_IRQ_DSP1_OFFSET + FREEDOM_REG_IRQ_BTU ) &
                    FREEDOM_IRQ_BTU_INDEX_MASK;

            Pipe = Pipe - FREEDOM_DSP_BTU_BASE_INDEX;
            
            Pipes[ Pipe ].Flags |= (1 << Pipes[ Pipe ].TransferBuffer);

            /*
            // Increment transfer buffer pointer
            */

            Pipes[ Pipe ].TransferBuffer = 
                (Pipes[ Pipe ].TransferBuffer + 1) & 1;

            /*
            // If the other buffer is not already completed, let the BTU
            // run, otherwise we'll kick it in the main loop.
            */

            if (Pipes[ Pipe ].Flags & (1 << Pipes[ Pipe ].TransferBuffer))
            {
                Pipes[ Pipe ].Flags |= PIPE_FLAG_NEEDKICK;
            } else {
                FreedomKickPipe( Pipe );
            }

            /*
            // Acknowledge the IRQ
            */

            outpw( FREEDOM_REG_IRQ_DSP1_OFFSET + FREEDOM_REG_IRQ_BTU, 0 );
        }

        /*
        // Dispatch each message interrupt to the appropriate
        // handler. Note that interrupts for this DSP and from 
        // the DSP message port are acknowledgements.
        */

        if (Source & FREEDOM_IRQ_GROUP_MESSAGE) {

            USHORT  i, Port;

            for (i = 0, Port = FREEDOM_INDEX_MESSAGE_CONTROL_HOST;
                 Port <= FREEDOM_INDEX_MESSAGE_CONTROL_DSP2;
                 i++, Port += 4) {
                if (FREEDOM_MESSAGE_CONTROL_IRQ_DSP1 == 
                        (inpw( Port ) & FREEDOM_MESSAGE_CONTROL_IRQ_MASK)) {
                    switch (i) {

                        case 0:
                            MsHostIncoming();
                            break;

                        case 1:
                            MsDSP1Acknowledge();
                            break;

                        case 2:
                            MsDSP2Incoming();
                            break;
                    }
                }
            }

            /*
            //  Message interrupt is cleared
            */
        }

        /*
        // Loop for more IRQs...
        */

        Source = inpw( FREEDOM_REG_IRQ_DSP1_OFFSET + FREEDOM_REG_IRQ_GROUP );
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\ksfilter\miniport\freedom\dsp\ntdefs.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1997
//
//  File:       ntdefs.h
//
//--------------------------------------------------------------------------

#define TRUE 1
#define FALSE 0

typedef char CHAR;
typedef char *PCHAR;
typedef unsigned char UCHAR;
typedef unsigned char *PUCHAR;
typedef void *PVOID;
typedef unsigned short USHORT;
typedef short SHORT;
typedef USHORT *PUSHORT;
typedef SHORT *PSHORT;
typedef long LONG;
typedef unsigned long ULONG;
typedef int BOOL;

typedef void pm *PVOID_PM;

#define min( a, b ) (((a) < (b)) ? (a) : (b))
#define max( a, b ) (((a) > (b)) ? (a) : (b))

#if 0

/*
// N.B. FIELD_OFFSET() requires that we shift left 1 for byte addresses
*/

#define FIELD_OFFSET(type, field) ((USHORT)&(((type *)0)->field) << 1)

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\ksfilter\miniport\freedom\dsp\private.h ===
/*++

    Copyright (C) Microsoft Corporation, 1996 - 1997

Module Name:

    private.h

Abstract:

    Private references

Author:

    Bryan A. Woodruff (bryanw) 14-Oct-1996

--*/

/*
// Type definitions
*/

typedef struct {

    volatile void pm *  PayloadHandler;
    volatile USHORT     Buffer[ 6 ];

} SPORT_PAYLOAD;

typedef struct _MESSAGE {

    volatile USHORT Completed;
    USHORT          Destination;
    USHORT          Length, Data[ 8 ];
    struct _MESSAGE *Next;

} MESSAGE, *PMESSAGE;

#define PIPE_FLAG_PING_DONE     0x0001
#define PIPE_FLAG_PONG_DONE     0x0002
#define PIPE_FLAG_ALLOCATED     0x0004
#define PIPE_FLAG_ACTIVE        0x0008
#define PIPE_FLAG_NEEDKICK      0x0010

#define PIPE_CURRENTBUFFER_PING 0x0000
#define PIPE_CURRENTBUFFER_PONG 0x0001

typedef (*PFNFILTER)( PUSHORT Data );

#define PIPE_BUFFER_SIZE    32

#define SRC_SCALING_FACTOR  256
#define SRC_FILTER_SIZE     3071

typedef struct _PIPE {

    PSHORT          BufferAddress;
    USHORT          BufferSize;
    USHORT          BufferOffset;
    USHORT          Channels;
    USHORT          SrcCoeffInc;
    USHORT          SrcFilterSize;
    USHORT          SrcDataInc;
    USHORT          SrcTime;
    USHORT          SrcEndBuffer;

    PFNFILTER       FilterChain;

    USHORT          SampleRate;
    USHORT          BitsPerSample;
    UCHAR           VolumeL, VolumeR;

    USHORT          TransferBuffer;
    USHORT          CurrentBuffer;
    USHORT          Flags;

} PIPE, *PPIPE;

/*
// external references
*/

extern volatile USHORT  RxBuffer[ 6 ], TxBuffer[ 6 ];
extern SPORT_PAYLOAD    RxPayload, TxPayload;
extern PIPE             Pipes[ FREEDOM_MAXNUM_PIPES ];
extern USHORT           PipeBuffers[ FREEDOM_MAXNUM_PIPES ][ PIPE_BUFFER_SIZE ];

/*
// macros
*/

#define Sport0WaitRxClear()\
{\
    while (RxPayload.PayloadHandler) {\
        asm( "idle;" );\
    }\
}

#define Sport0SignalRx( function ) RxPayload.PayloadHandler = function

#define Sport0WaitRxFrame( function )\
{\
    Sport0SignalRx( function );\
    Sport0WaitRxClear();\
}

#define Sport0WaitTxClear()\
{\
    while (TxPayload.PayloadHandler) {\
        asm( "idle;" );\
    }\
}

#define Sport0SignalTx( function ) TxPayload.PayloadHandler = function

/*
// codec.c:
*/

void CdDisable( 
    void 
);

void CdEnable( 
    void 
);

void CdInitialize(
    void 
);

void CODEC_CopyTo(
    void 
);

void CODEC_CopyFrom(
    void 
);

/*
// debug.c:
*/

#if defined( DEBUG )
void dprintf(
    PCHAR   String
);
#else
#define dprintf( x )
#endif

/*
// freedom.c:
*/ 

void disable( void );
void enable( void );

void
FreedomResetDSPPipe(
    USHORT Pipe
);

BOOL
FreedomAllocateDSPPipe(
    PUSHORT Pipe
);

void
FreedomIRQ(
    int Argument
);

extern USHORT IrqEnable;

/*
// message.c:
*/

void MsHostIncoming( void );
void MsDSP1Acknowledge( void );
void MsDSP2Incoming( void );

void PostMessage( 
    PMESSAGE Message 
);

#define WaitMessage( Message )\
{\
    while (FALSE == (Message)->Completed) {\
        asm( "idle;" );\
    }\
}

/*
// init.dsp:
*/

void DspInit( void );

/*
// portio.dsp:
*/

void outpw( 
    USHORT IoAddress,
    USHORT Data
);

USHORT inpw( 
    USHORT IoAddress
);

/*
// src.dsp:
*/

SHORT SrcFilter(
    PPIPE PipeInfo
);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\ksfilter\miniport\freedom\dsp\blsrc\test.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1997
//
//  File:       test.c
//
//--------------------------------------------------------------------------

#include <def2181.h>
#include <circ.h>
#include <math.h>
#include <signal.h>
#include <sport.h>
#include <string.h>

#include "ntdefs.h"
#include "freedom.h"
#include "private.h"

void TestSrc()
{
    int     i ;
    SHORT   Buffer, Offset;

    FreedomResetDSPPipe( 0 );

    for (i = 0; i < PIPE_BUFFER_SIZE; i++) {
        Pipes[ 0 ].BufferAddress[ i ] = inpw( 0x800 );
    }

    for (i = 0; i < PIPE_BUFFER_SIZE / 2; i++) {
        Buffer = Pipes[ 0 ].CurrentBuffer;

        Offset = 
            (Pipes[ 0 ].SrcTime / SRC_SCALING_FACTOR) * Pipes[ 0 ].Channels;
        Offset += (Buffer * PIPE_BUFFER_SIZE / 2);

        Pipes[ 0 ].BufferOffset = Offset;
        outpw( 0x800, SrcFilter( &Pipes[ 0 ] ) );
        if (Pipes[ 0 ].Channels > 1) {
            Pipes[ 0 ].BufferOffset++;
            outpw( 0x800, SrcFilter( &Pipes[ 0 ] ) );
        }

        Pipes[ 0 ].SrcTime += Pipes[ 0 ].SrcDataInc;

        /* 
        // If we have incremented our position then we need to 
        // slide the data window 
        */

        if (Pipes[ 0 ].SrcTime >= Pipes[ 0 ].SrcEndBuffer) {

            Pipes[ 0 ].SrcTime -= Pipes[ 0 ].SrcEndBuffer;
            Pipes[ 0 ].CurrentBuffer = (Buffer + 1) & 1;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\ksfilter\miniport\freedom\dsp\blsrc\srccoef.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1997
//
//  File:       srccoef.h
//
//--------------------------------------------------------------------------

#define Nhc       8
#define Na        7
#define Np       (Nhc+Na)
#define Npc      (1<<Nhc)
#define Amask    ((1<<Na)-1)
#define Pmask    (((LONG)1<<Np)-1)
#define Nh       16
#define Nb       16
#define Nhxn     14
#define Nhg      (Nh-Nhxn)
#define NLpScl   13

/* Description of constants:
 *
 * Npc - is the number of look-up values available for the lowpass filter
 *    between the beginning of its impulse response and the "cutoff time"
 *    of the filter.  The cutoff time is defined as the reciprocal of the
 *    lowpass-filter cut off frequence in Hz.  For example, if the
 *    lowpass filter were a sinc function, Npc would be the index of the
 *    impulse-response lookup-table corresponding to the first zero-
 *    crossing of the sinc function.  (The inverse first zero-crossing
 *    time of a sinc function equals its nominal cutoff frequency in Hz.)
 *    Npc must be a power of 2 due to the details of the current
 *    implementation. The default value of 512 is sufficiently high that
 *    using linear interpolation to fill in between the table entries
 *    gives approximately 16-bit accuracy in filter coefficients.
 *
 * Nhc - is log base 2 of Npc.
 *
 * Na - is the number of bits devoted to linear interpolation of the
 *    filter coefficients.
 *
 * Np - is Na + Nhc, the number of bits to the right of the binary point
 *    in the integer "time" variable. To the left of the point, it indexes
 *    the input array (X), and to the right, it is interpreted as a number
 *    between 0 and 1 sample of the input X.  Np must be less than 16 in
 *    this implementation.
 *
 * Nh - is the number of bits in the filter coefficients. The sum of Nh and
 *    the number of bits in the input data (typically 16) cannot exceed 32.
 *    Thus Nh should be 16.  The largest filter coefficient should nearly
 *    fill 16 bits (32767).
 *
 * Nb - is the number of bits in the input data. The sum of Nb and Nh cannot
 *    exceed 32.
 *
 * Nhxn - is the number of bits to right shift after multiplying each input
 *    sample times a filter coefficient. It can be as great as Nh and as
 *    small as 0. Nhxn = Nh-2 gives 2 guard bits in the multiply-add
 *    accumulation.  If Nhxn=0, the accumulation will soon overflow 32 bits.
 *
 * Nhg - is the number of guard bits in mpy-add accumulation (equal to Nh-Nhxn)
 *
 * NLpScl - is the number of bits allocated to the unity-gain normalization
 *    factor.  The output of the lowpass filter is multiplied by LpScl and
 *    then right-shifted NLpScl bits. To avoid overflow, we must have 
 *    Nb+Nhg+NLpScl < 32.
 */

#define IMPULSE_RESPONSE_NMULT ((SHORT)13)

/* Unity-gain scale factor */
#define IMPULSE_RESPONSE_SCALING_FACTOR 13128 
#define IMPULSE_RESPONSE_TABLE_LENGTH 1536

static SHORT ImpulseResponse[] = {

    32767, 32766, 32764, 32760, 32755, 32749, 32741, 32731, 32721, 32708, 32695,
    32679, 32663, 32645, 32625, 32604, 32582, 32558, 32533, 32506, 32478, 32448,
    32417, 32385, 32351, 32316, 32279, 32241, 32202, 32161, 32119, 32075, 32030,
    31984, 31936, 31887, 31836, 31784, 31731, 31676, 31620, 31563, 31504, 31444,
    31383, 31320, 31256, 31191, 31124, 31056, 30987, 30916, 30845, 30771, 30697,
    30621, 30544, 30466, 30387, 30306, 30224, 30141, 30057, 29971, 29884, 29796,
    29707, 29617, 29525, 29433, 29339, 29244, 29148, 29050, 28952, 28852, 28752,
    28650, 28547, 28443, 28338, 28232, 28125, 28017, 27908, 27797, 27686, 27574,
    27461, 27346, 27231, 27115, 26998, 26879, 26760, 26640, 26519, 26398, 26275,
    26151, 26027, 25901, 25775, 25648, 25520, 25391, 25262, 25131, 25000, 24868,
    24735, 24602, 24467, 24332, 24197, 24060, 23923, 23785, 23647, 23507, 23368,
    23227, 23086, 22944, 22802, 22659, 22515, 22371, 22226, 22081, 21935, 21789,
    21642, 21494, 21346, 21198, 21049, 20900, 20750, 20600, 20449, 20298, 20146,
    19995, 19842, 19690, 19537, 19383, 19230, 19076, 18922, 18767, 18612, 18457,
    18302, 18146, 17990, 17834, 17678, 17521, 17365, 17208, 17051, 16894, 16737,
    16579, 16422, 16264, 16106, 15949, 15791, 15633, 15475, 15317, 15159, 15001,
    14843, 14685, 14527, 14369, 14212, 14054, 13896, 13739, 13581, 13424, 13266,
    13109, 12952, 12795, 12639, 12482, 12326, 12170, 12014, 11858, 11703, 11548,
    11393, 11238, 11084, 10929, 10776, 10622, 10469, 10316, 10164, 10011, 9860,
    9708, 9557, 9407, 9256, 9106, 8957, 8808, 8659, 8511, 8364, 8216,
    8070, 7924, 7778, 7633, 7488, 7344, 7200, 7057, 6914, 6773, 6631,
    6490, 6350, 6210, 6071, 5933, 5795, 5658, 5521, 5385, 5250, 5115,
    4981, 4848, 4716, 4584, 4452, 4322, 4192, 4063, 3935, 3807, 3680,
    3554, 3429, 3304, 3180, 3057, 2935, 2813, 2692, 2572, 2453, 2335,
    2217, 2101, 1985, 1870, 1755, 1642, 1529, 1418, 1307, 1197, 1088,
    979, 872, 765, 660, 555, 451, 348, 246, 145, 44, -54,
    -153, -250, -347, -443, -537, -631, -724, -816, -908, -998, -1087,
    -1175, -1263, -1349, -1435, -1519, -1603, -1685, -1767, -1848, -1928, -2006,
    -2084, -2161, -2237, -2312, -2386, -2459, -2531, -2603, -2673, -2742, -2810,
    -2878, -2944, -3009, -3074, -3137, -3200, -3261, -3322, -3381, -3440, -3498,
    -3554, -3610, -3665, -3719, -3772, -3824, -3875, -3925, -3974, -4022, -4069,
    -4116, -4161, -4205, -4249, -4291, -4333, -4374, -4413, -4452, -4490, -4527,
    -4563, -4599, -4633, -4666, -4699, -4730, -4761, -4791, -4820, -4848, -4875,
    -4901, -4926, -4951, -4974, -4997, -5019, -5040, -5060, -5080, -5098, -5116,
    -5133, -5149, -5164, -5178, -5192, -5205, -5217, -5228, -5238, -5248, -5257,
    -5265, -5272, -5278, -5284, -5289, -5293, -5297, -5299, -5301, -5303, -5303,
    -5303, -5302, -5300, -5298, -5295, -5291, -5287, -5282, -5276, -5270, -5263,
    -5255, -5246, -5237, -5228, -5217, -5206, -5195, -5183, -5170, -5157, -5143,
    -5128, -5113, -5097, -5081, -5064, -5047, -5029, -5010, -4991, -4972, -4952,
    -4931, -4910, -4889, -4867, -4844, -4821, -4797, -4774, -4749, -4724, -4699,
    -4673, -4647, -4620, -4593, -4566, -4538, -4510, -4481, -4452, -4422, -4393,
    -4363, -4332, -4301, -4270, -4238, -4206, -4174, -4142, -4109, -4076, -4042,
    -4009, -3975, -3940, -3906, -3871, -3836, -3801, -3765, -3729, -3693, -3657,
    -3620, -3584, -3547, -3510, -3472, -3435, -3397, -3360, -3322, -3283, -3245,
    -3207, -3168, -3129, -3091, -3052, -3013, -2973, -2934, -2895, -2855, -2816,
    -2776, -2736, -2697, -2657, -2617, -2577, -2537, -2497, -2457, -2417, -2377,
    -2337, -2297, -2256, -2216, -2176, -2136, -2096, -2056, -2016, -1976, -1936,
    -1896, -1856, -1817, -1777, -1737, -1698, -1658, -1619, -1579, -1540, -1501,
    -1462, -1423, -1384, -1345, -1306, -1268, -1230, -1191, -1153, -1115, -1077,
    -1040, -1002, -965, -927, -890, -854, -817, -780, -744, -708, -672,
    -636, -600, -565, -530, -494, -460, -425, -391, -356, -322, -289,
    -255, -222, -189, -156, -123, -91, -59, -27, 4, 35, 66,
    97, 127, 158, 188, 218, 247, 277, 306, 334, 363, 391,
    419, 447, 474, 501, 528, 554, 581, 606, 632, 657, 683,
    707, 732, 756, 780, 803, 827, 850, 872, 895, 917, 939,
    960, 981, 1002, 1023, 1043, 1063, 1082, 1102, 1121, 1139, 1158,
    1176, 1194, 1211, 1228, 1245, 1262, 1278, 1294, 1309, 1325, 1340,
    1354, 1369, 1383, 1397, 1410, 1423, 1436, 1448, 1461, 1473, 1484,
    1496, 1507, 1517, 1528, 1538, 1548, 1557, 1566, 1575, 1584, 1592,
    1600, 1608, 1616, 1623, 1630, 1636, 1643, 1649, 1654, 1660, 1665,
    1670, 1675, 1679, 1683, 1687, 1690, 1694, 1697, 1700, 1702, 1704,
    1706, 1708, 1709, 1711, 1712, 1712, 1713, 1713, 1713, 1713, 1712,
    1711, 1710, 1709, 1708, 1706, 1704, 1702, 1700, 1697, 1694, 1691,
    1688, 1685, 1681, 1677, 1673, 1669, 1664, 1660, 1655, 1650, 1644,
    1639, 1633, 1627, 1621, 1615, 1609, 1602, 1596, 1589, 1582, 1575,
    1567, 1560, 1552, 1544, 1536, 1528, 1520, 1511, 1503, 1494, 1485,
    1476, 1467, 1458, 1448, 1439, 1429, 1419, 1409, 1399, 1389, 1379,
    1368, 1358, 1347, 1337, 1326, 1315, 1304, 1293, 1282, 1271, 1260,
    1248, 1237, 1225, 1213, 1202, 1190, 1178, 1166, 1154, 1142, 1130,
    1118, 1106, 1094, 1081, 1069, 1057, 1044, 1032, 1019, 1007, 994,
    981, 969, 956, 943, 931, 918, 905, 892, 879, 867, 854,
    841, 828, 815, 802, 790, 777, 764, 751, 738, 725, 713,
    700, 687, 674, 662, 649, 636, 623, 611, 598, 585, 573,
    560, 548, 535, 523, 510, 498, 486, 473, 461, 449, 437,
    425, 413, 401, 389, 377, 365, 353, 341, 330, 318, 307,
    295, 284, 272, 261, 250, 239, 228, 217, 206, 195, 184,
    173, 163, 152, 141, 131, 121, 110, 100, 90, 80, 70,
    60, 51, 41, 31, 22, 12, 3, -5, -14, -23, -32,
    -41, -50, -59, -67, -76, -84, -93, -101, -109, -117, -125,
    -133, -140, -148, -156, -163, -170, -178, -185, -192, -199, -206,
    -212, -219, -226, -232, -239, -245, -251, -257, -263, -269, -275,
    -280, -286, -291, -297, -302, -307, -312, -317, -322, -327, -332,
    -336, -341, -345, -349, -354, -358, -362, -366, -369, -373, -377,
    -380, -384, -387, -390, -394, -397, -400, -402, -405, -408, -411,
    -413, -416, -418, -420, -422, -424, -426, -428, -430, -432, -433,
    -435, -436, -438, -439, -440, -442, -443, -444, -445, -445, -446,
    -447, -447, -448, -448, -449, -449, -449, -449, -449, -449, -449,
    -449, -449, -449, -449, -448, -448, -447, -447, -446, -445, -444,
    -443, -443, -442, -441, -440, -438, -437, -436, -435, -433, -432,
    -430, -429, -427, -426, -424, -422, -420, -419, -417, -415, -413,
    -411, -409, -407, -405, -403, -400, -398, -396, -393, -391, -389,
    -386, -384, -381, -379, -376, -374, -371, -368, -366, -363, -360,
    -357, -355, -352, -349, -346, -343, -340, -337, -334, -331, -328,
    -325, -322, -319, -316, -313, -310, -307, -304, -301, -298, -294,
    -291, -288, -285, -282, -278, -275, -272, -269, -265, -262, -259,
    -256, -252, -249, -246, -243, -239, -236, -233, -230, -226, -223,
    -220, -217, -213, -210, -207, -204, -200, -197, -194, -191, -187,
    -184, -181, -178, -175, -172, -168, -165, -162, -159, -156, -153,
    -150, -147, -143, -140, -137, -134, -131, -128, -125, -122, -120,
    -117, -114, -111, -108, -105, -102, -99, -97, -94, -91, -88,
    -86, -83, -80, -78, -75, -72, -70, -67, -65, -62, -59,
    -57, -55, -52, -50, -47, -45, -43, -40, -38, -36, -33,
    -31, -29, -27, -25, -22, -20, -18, -16, -14, -12, -10,
    -8, -6, -4, -2, 0, 0, 2, 4, 6, 8, 9,
    11, 13, 14, 16, 17, 19, 21, 22, 24, 25, 27,
    28, 29, 31, 32, 33, 35, 36, 37, 38, 40, 41,
    42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52,
    53, 54, 55, 56, 56, 57, 58, 59, 59, 60, 61,
    62, 62, 63, 63, 64, 64, 65, 66, 66, 66, 67,
    67, 68, 68, 69, 69, 69, 70, 70, 70, 70, 71,
    71, 71, 71, 71, 72, 72, 72, 72, 72, 72, 72,
    72, 72, 72, 72, 72, 72, 72, 72, 72, 72, 72,
    72, 72, 72, 72, 72, 71, 71, 71, 71, 71, 70,
    70, 70, 70, 69, 69, 69, 69, 68, 68, 68, 67,
    67, 67, 66, 66, 66, 65, 65, 64, 64, 64, 63,
    63, 62, 62, 62, 61, 61, 60, 60, 59, 59, 58,
    58, 58, 57, 57, 56, 56, 55, 55, 54, 54, 53,
    53, 52, 52, 51, 51, 50, 50, 49, 48, 48, 47,
    47, 46, 46, 45, 45, 44, 44, 43, 43, 42, 42,
    41, 41, 40, 39, 39, 38, 38, 37, 37, 36, 36,
    35, 35, 34, 34, 33, 33, 32, 32, 31, 31, 30,
    30, 29, 29, 28, 28, 27, 27, 26, 26, 25, 25,
    24, 24, 23, 23, 23, 22, 22, 21, 21, 20, 20,
    20, 19, 19, 18, 18, 17, 17, 17, 16, 16, 15,
    15, 15, 14, 14, 14, 13, 13, 12, 12, 12, 11,
    11, 11, 10, 10, 10, 9, 9, 9, 9, 8, 8,
    8, 7, 7, 7, 7, 6, 6, 6, 6, 5, 5,
    5, 5, 4, 4, 4, 4, 3, 3, 3, 3, 3,
    2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, -1, -1, -1, -1, -1, -1,
    -1, -1, -1, -1, -1, -1, -1, -2, -2, -2, -2,
    -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2,
    -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2,
    -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2,
    -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2,
    -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2,
    -2, -2, -2, -2, -2, -2, -2, -1, -1, -1, -1,
    -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
    -1, -1, -1, -1, -1, -1, -1
};

static SHORT ImpulseResponseDeltas[] = {
    -1, -2, -4, -5, -6, -8, -10, -10, -13, -13, -16,
    -16, -18, -20, -21, -22, -24, -25, -27, -28, -30, -31,
    -32, -34, -35, -37, -38, -39, -41, -42, -44, -45, -46,
    -48, -49, -51, -52, -53, -55, -56, -57, -59, -60, -61,
    -63, -64, -65, -67, -68, -69, -71, -71, -74, -74, -76,
    -77, -78, -79, -81, -82, -83, -84, -86, -87, -88, -89,
    -90, -92, -92, -94, -95, -96, -98, -98, -100, -100, -102,
    -103, -104, -105, -106, -107, -108, -109, -111, -111, -112, -113,
    -115, -115, -116, -117, -119, -119, -120, -121, -121, -123, -124,
    -124, -126, -126, -127, -128, -129, -129, -131, -131, -132, -133,
    -133, -135, -135, -135, -137, -137, -138, -138, -140, -139, -141,
    -141, -142, -142, -143, -144, -144, -145, -145, -146, -146, -147,
    -148, -148, -148, -149, -149, -150, -150, -151, -151, -152, -151,
    -153, -152, -153, -154, -153, -154, -154, -155, -155, -155, -155,
    -156, -156, -156, -156, -157, -156, -157, -157, -157, -157, -158,
    -157, -158, -158, -157, -158, -158, -158, -158, -158, -158, -158,
    -158, -158, -158, -157, -158, -158, -157, -158, -157, -158, -157,
    -157, -157, -156, -157, -156, -156, -156, -156, -155, -155, -155,
    -155, -154, -155, -153, -154, -153, -153, -152, -153, -151, -152,
    -151, -150, -151, -150, -149, -149, -149, -148, -147, -148, -146,
    -146, -146, -145, -145, -144, -144, -143, -143, -141, -142, -141,
    -140, -140, -139, -138, -138, -137, -137, -136, -135, -135, -134,
    -133, -132, -132, -132, -130, -130, -129, -128, -128, -127, -126,
    -125, -125, -124, -123, -122, -122, -121, -120, -119, -118, -118,
    -116, -116, -115, -115, -113, -113, -111, -111, -110, -109, -109,
    -107, -107, -105, -105, -104, -103, -102, -101, -101, -98, -99,
    -97, -97, -96, -94, -94, -93, -92, -92, -90, -89, -88,
    -88, -86, -86, -84, -84, -82, -82, -81, -80, -78, -78,
    -77, -76, -75, -74, -73, -72, -72, -70, -69, -68, -68,
    -66, -65, -65, -63, -63, -61, -61, -59, -59, -58, -56,
    -56, -55, -54, -53, -52, -51, -50, -49, -48, -47, -47,
    -45, -44, -44, -42, -42, -41, -39, -39, -38, -37, -36,
    -36, -34, -33, -33, -31, -31, -30, -29, -28, -27, -26,
    -25, -25, -23, -23, -22, -21, -20, -20, -18, -18, -17,
    -16, -15, -14, -14, -13, -12, -11, -10, -10, -9, -8,
    -7, -6, -6, -5, -4, -4, -2, -2, -2, 0, 0,
    1, 2, 2, 3, 4, 4, 5, 6, 6, 7, 8,
    9, 9, 9, 11, 11, 11, 12, 13, 13, 14, 15,
    15, 16, 16, 17, 17, 18, 19, 19, 19, 20, 21,
    21, 21, 22, 23, 23, 24, 23, 25, 25, 25, 26,
    26, 27, 27, 27, 28, 28, 29, 29, 30, 29, 30,
    31, 31, 31, 32, 32, 32, 32, 33, 33, 34, 33,
    34, 35, 34, 35, 35, 35, 36, 36, 36, 36, 37,
    36, 37, 37, 38, 37, 38, 37, 38, 39, 38, 38,
    39, 39, 38, 39, 39, 40, 39, 39, 40, 39, 40,
    40, 39, 40, 40, 40, 40, 40, 40, 40, 40, 40,
    40, 41, 40, 40, 40, 40, 40, 40, 40, 40, 40,
    40, 39, 40, 40, 39, 40, 39, 40, 39, 39, 39,
    39, 39, 39, 39, 38, 38, 39, 38, 38, 38, 37,
    38, 37, 38, 37, 36, 37, 37, 36, 36, 36, 36,
    36, 35, 35, 36, 34, 35, 34, 35, 34, 33, 34,
    33, 33, 33, 33, 32, 32, 32, 31, 31, 31, 31,
    30, 31, 30, 30, 29, 30, 29, 28, 29, 28, 28,
    28, 27, 27, 27, 26, 27, 25, 26, 25, 26, 24,
    25, 24, 24, 23, 24, 23, 22, 23, 22, 22, 21,
    21, 21, 21, 20, 20, 19, 20, 19, 18, 19, 18,
    18, 17, 17, 17, 17, 16, 16, 15, 16, 15, 14,
    15, 14, 14, 13, 13, 13, 12, 13, 12, 11, 12,
    11, 10, 11, 10, 10, 9, 9, 9, 9, 8, 8,
    8, 8, 7, 7, 6, 7, 6, 5, 6, 5, 5,
    5, 4, 4, 4, 3, 4, 3, 3, 2, 2, 2,
    2, 1, 2, 1, 0, 1, 0, 0, 0, -1, -1,
    -1, -1, -1, -2, -2, -2, -2, -3, -3, -3, -3,
    -3, -4, -4, -4, -4, -5, -4, -5, -5, -6, -5,
    -6, -6, -6, -6, -6, -7, -6, -7, -7, -7, -8,
    -7, -8, -8, -8, -8, -8, -9, -8, -9, -9, -9,
    -9, -9, -10, -9, -10, -10, -10, -10, -10, -10, -11,
    -10, -11, -10, -11, -11, -11, -11, -11, -11, -11, -12,
    -11, -12, -12, -11, -12, -12, -12, -12, -12, -12, -12,
    -12, -12, -13, -12, -12, -13, -12, -13, -12, -13, -13,
    -12, -13, -13, -12, -13, -13, -13, -13, -12, -13, -13,
    -13, -13, -13, -12, -13, -13, -13, -13, -13, -12, -13,
    -13, -13, -12, -13, -13, -13, -12, -13, -13, -12, -13,
    -12, -13, -12, -13, -12, -12, -13, -12, -12, -12, -12,
    -12, -12, -12, -12, -12, -12, -12, -11, -12, -11, -12,
    -11, -12, -11, -11, -11, -11, -11, -11, -11, -11, -11,
    -10, -11, -11, -10, -10, -11, -10, -10, -10, -10, -10,
    -9, -10, -10, -9, -10, -9, -8, -9, -9, -9, -9,
    -9, -9, -8, -9, -8, -9, -8, -8, -8, -8, -8,
    -7, -8, -8, -7, -7, -8, -7, -7, -7, -7, -6,
    -7, -7, -6, -7, -6, -6, -6, -6, -6, -6, -5,
    -6, -5, -6, -5, -5, -5, -5, -5, -5, -5, -4,
    -5, -4, -4, -5, -4, -4, -4, -3, -4, -4, -3,
    -4, -3, -3, -4, -3, -3, -2, -3, -3, -3, -2,
    -3, -2, -2, -2, -2, -2, -2, -2, -2, -1, -2,
    -1, -2, -1, -1, -2, -1, -1, -1, 0, -1, -1,
    0, -1, 0, -1, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 1, 0, 1, 0, 1, 1, 1, 1,
    0, 1, 1, 1, 2, 1, 1, 1, 2, 1, 2,
    1, 2, 1, 2, 2, 2, 1, 2, 2, 2, 2,
    2, 2, 2, 2, 3, 2, 2, 3, 2, 2, 3,
    2, 3, 2, 3, 2, 3, 3, 2, 3, 3, 3,
    2, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
    3, 3, 3, 3, 3, 3, 3, 3, 3, 4, 3,
    3, 3, 3, 4, 3, 3, 3, 4, 3, 3, 3,
    4, 3, 3, 3, 4, 3, 3, 3, 4, 3, 3,
    3, 4, 3, 3, 3, 4, 3, 3, 3, 4, 3,
    3, 3, 3, 3, 4, 3, 3, 3, 3, 3, 3,
    3, 4, 3, 3, 3, 3, 3, 3, 3, 2, 3,
    3, 3, 3, 3, 3, 3, 2, 3, 3, 3, 2,
    3, 3, 2, 3, 3, 2, 3, 2, 3, 3, 2,
    2, 3, 2, 3, 2, 2, 3, 2, 2, 3, 2,
    2, 2, 2, 3, 2, 2, 2, 2, 2, 2, 2,
    2, 2, 2, 2, 0, 2, 2, 2, 2, 1, 2,
    2, 1, 2, 1, 2, 2, 1, 2, 1, 2, 1,
    1, 2, 1, 1, 2, 1, 1, 1, 2, 1, 1,
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
    1, 1, 1, 0, 1, 1, 1, 0, 1, 1, 1,
    0, 1, 0, 1, 0, 1, 1, 0, 0, 1, 0,
    1, 0, 1, 0, 0, 1, 0, 0, 0, 1, 0,
    0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, -1, 0, 0, 0, 0, -1, 0,
    0, 0, -1, 0, 0, 0, -1, 0, 0, -1, 0,
    0, -1, 0, 0, -1, 0, -1, 0, 0, -1, 0,
    -1, 0, 0, -1, 0, -1, 0, -1, 0, -1, 0,
    0, -1, 0, -1, 0, -1, 0, -1, 0, -1, 0,
    -1, 0, -1, 0, -1, 0, -1, -1, 0, -1, 0,
    -1, 0, -1, 0, -1, 0, -1, 0, -1, 0, -1,
    0, -1, -1, 0, -1, 0, -1, 0, -1, 0, -1,
    0, -1, 0, -1, 0, -1, 0, -1, 0, -1, 0,
    -1, 0, -1, 0, -1, 0, -1, 0, -1, 0, -1,
    0, -1, 0, 0, -1, 0, -1, 0, -1, 0, 0,
    -1, 0, -1, 0, -1, 0, 0, -1, 0, -1, 0,
    0, -1, 0, 0, -1, 0, -1, 0, 0, -1, 0,
    0, -1, 0, 0, -1, 0, 0, 0, -1, 0, 0,
    -1, 0, 0, 0, -1, 0, 0, 0, -1, 0, 0,
    0, -1, 0, 0, 0, -1, 0, 0, 0, 0, -1,
    0, 0, 0, 0, -1, 0, 0, 0, 0, 0, -1,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, -1, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, -1, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 1, -1, -2, -4, -5,
    -6, -8, -10, -10, -13, -13, -16, -16, -18, -20, -21,
    -22, -24, -25, -27, -28, -30, -31, -32, -34, -35, -37,
    -38, -39, -41, -42, -44, -45, -46, -48, -49, -51, -52,
    -53, -55, -56, -57, -59, -60, -61, -63, -64, -65, -67,
    -68, -69, -71, -71, -74, -74, -76, -77, -78, -79, -81,
    -82, -83, -84, -86, -87, -88, -89, -90, -92, -92, -94,
    -95, -96, -98, -98, -100, -100, -102, -103, -104, -105, -106,
    -107, -108, -109, -111, -111, -112, -113, -115, -115, -116, -117,
    -119, -119, -120, -121, -121, -123, -124, -124, -126, -126, -127,
    -128, -129, -129, -131, -131, -132, -133, -133, -135, -135, -135,
    -137, -137, -138, -138, -140, -139, -141, -141, -142, -142, -143,
    -144, -144, -145, -145, -146, -146, -147, -148, -148, -148, -149,
    -149, -150, -150, -151, -151, -152, -151, -153, -152, -153, -154,
    -153, -154, -154, -155, -155, -155, -155, -156, -156, -156, -156,
    -157, -156, -157, -157, -157, -157, -158, -157, -158, -158, -157,
    -158, -158, -158, -158, -158, -158, -158, -158, -158, -158, -157,
    -158, -158, -157, -158, -157, -158, -157, -157, -157, -156, -157,
    -156, -156, -156, -156, -155, -155, -155, -155, -154, -155, -153,
    -154, -153, -153, -152, -153, -151, -152, -151, -150, -151, -150,
    -149, -149, -149, -148, -147, -148, -146, -146, -146, -145, -145,
    -144, -144, -143, -143, -141, -142, -141, -140, -140, -139, -138,
    -138, -137, -137, -136, -135, -135, -134, -133, -132, -132, -132,
    -130, -130, -129, -128, -128, -127, -126, -125, -125, -124, -123,
    -122, -122, -121, -120, -119, -118, -118, -116, -116, -115, -115,
    -113, -113, -111, -111, -110, -109, -109, -107, -107, -105, -105,
    -104, -103, -102, -101, -101, -98, -99, -97, -97, -96, -94,
    -94, -93, -92, -92, -90, -89, -88, -88, -86, -86, -84,
    -84, -82, -82, -81, -80, -78, -78, -77, -76, -75, -74,
    -73, -72, -72, -70, -69, -68, -68, -66, -65, -65, -63,
    -63, -61, -61, -59, -59, -58, -56, -56, -55, -54, -53,
    -52, -51, -50, -49, -48, -47, -47, -45, -44, -44, -42,
    -42, -41, -39, -39, -38, -37, -36, -36, -34, -33, -33,
    -31, -31, -30, -29, -28, -27, -26, -25, -25, -23, -23,
    -22, -21, -20, -20, -18, -18, -17, -16, -15, -14, -14,
    -13, -12, -11, -10, -10, -9, -8, -7, -6, -6, -5,
    -4, -4, -2, -2, -2, 0, 0, 1, 2, 2, 3,
    4, 4, 5, 6, 6, 7, 8, 9, 9, 9, 11,
    11, 11, 12, 13, 13, 14, 15, 15, 16, 16, 17,
    17, 18, 19, 19, 19, 20, 21, 21, 21, 22, 23,
    23, 24, 23, 25, 25, 25, 26, 26, 27, 27, 27,
    28, 28, 29, 29, 30, 29, 30, 31, 31, 31, 32,
    32, 32, 32, 33, 33, 34, 33, 34, 35, 34, 35,
    35, 35, 36, 36, 36, 36, 37, 36, 37, 37, 38,
    37, 38, 37, 38, 39, 38, 38, 39, 39, 38, 39,
    39, 40, 39, 39, 40, 39, 40, 40, 39, 40, 40,
    40, 40, 40, 40, 40, 40, 40, 40, 41, 40, 40,
    40, 40, 40, 40, 40, 40, 40, 40, 39, 40, 40,
    39, 40, 39, 40, 39, 39, 39, 39, 39, 39, 39,
    38, 38, 39, 38, 38, 38, 37, 38, 37, 38, 37,
    36, 37, 37, 36, 36, 36, 36, 36, 35, 35, 36,
    34, 35, 34, 35, 34, 33, 34, 33, 33, 33, 33,
    32, 32, 32, 31, 31, 31, 31, 30, 31, 30, 30,
    29, 30, 29, 28, 29, 28, 28, 28, 27, 27, 27,
    26, 27, 25, 26, 25, 26, 24, 25, 24, 24, 23,
    24, 23, 22, 23, 22, 22, 21, 21, 21, 21, 20,
    20, 19, 20, 19, 18, 19, 18, 18, 17, 17, 17,
    17, 16, 16, 15, 16, 15, 14, 15, 14, 14, 13,
    13, 13, 12, 13, 12, 11, 12, 11, 10, 11, 10,
    10, 9, 9, 9, 9, 8, 8, 8, 8, 7, 7,
    6, 7, 6, 5, 6, 5, 5, 5, 4, 4, 4,
    3, 4, 3, 3, 2, 2, 2, 2, 1, 2, 1,
    0, 1, 0, 0, 0, -1, -1, -1, -1, -1, -2,
    -2, -2, -2, -3, -3, -3, -3, -3, -4, -4, -4,
    -4, -5, -4, -5, -5, -6, -5, -6, -6, -6, -6,
    -6, -7, -6, -7, -7, -7, -8, -7, -8, -8, -8,
    -8, -8, -9, -8, -9, -9, -9, -9, -9, -10, -9,
    -10, -10, -10, -10, -10, -10, -11, -10, -11, -10, -11,
    -11, -11, -11, -11, -11, -11, -12, -11, -12, -12, -11,
    -12, -12, -12, -12, -12, -12, -12, -12, -12, -13, -12,
    -12, -13, -12, -13, -12, -13, -13, -12, -13, -13, -12,
    -13, -13, -13, -13, -12, -13, -13, -13, -13, -13, -12,
    -13, -13, -13, -13, -13, -12, -13, -13, -13, -12, -13,
    -13, -13, -12, -13, -13, -12, -13, -12, -13, -12, -13,
    -12, -12, -13, -12, -12, -12, -12, -12, -12, -12, -12,
    -12, -12, -12, -11, -12, -11, -12, -11, -12, -11, -11,
    -11, -11, -11, -11, -11, -11, -11, -10, -11, -11, -10,
    -10, -11, -10, -10, -10, -10, -10, -9, -10, -10, -9,
    -10, -9, -8, -9, -9, -9, -9, -9, -9, -8, -9,
    -8, -9, -8, -8, -8, -8, -8, -7, -8, -8, -7,
    -7, -8, -7, -7, -7, -7, -6, -7, -7, -6, -7,
    -6, -6, -6, -6, -6, -6, -5, -6, -5, -6, -5,
    -5, -5, -5, -5, -5, -5, -4, -5, -4, -4, -5,
    -4, -4, -4, -3, -4, -4, -3, -4, -3, -3, -4,
    -3, -3, -2, -3, -3, -3, -2, -3, -2, -2, -2,
    -2, -2, -2, -2, -2, -1, -2, -1, -2, -1, -1,
    -2, -1, -1, -1, 0, -1, -1, 0, -1, 0, -1,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1,
    0, 1, 0, 1, 1, 1, 1, 0, 1, 1, 1,
    2, 1, 1, 1, 2, 1, 2, 1, 2, 1, 2,
    2, 2, 1, 2, 2, 2, 2, 2, 2, 2, 2,
    3, 2, 2, 3, 2, 2, 3, 2, 3, 2, 3,
    2, 3, 3, 2, 3, 3, 3, 2, 3, 3, 3,
    3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
    3, 3, 3, 3, 3, 4, 3, 3, 3, 3, 4,
    3, 3, 3, 4, 3, 3, 3, 4, 3, 3, 3,
    4, 3, 3, 3, 4, 3, 3, 3, 4, 3, 3,
    3, 4, 3, 3, 3, 4, 3, 3, 3, 3, 3,
    4, 3, 3, 3, 3, 3, 3, 3, 4, 3, 3,
    3, 3, 3, 3, 3, 2, 3, 3, 3, 3, 3,
    3, 3, 2, 3, 3, 3, 2, 3, 3, 2, 3,
    3, 2, 3, 2, 3, 3, 2, 2, 3, 2, 3,
    2, 2, 3, 2, 2, 3, 2, 2, 2, 2, 3,
    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
    0, 2, 2, 2, 2, 1, 2, 2, 1, 2, 1,
    2, 2, 1, 2, 1, 2, 1, 1, 2, 1, 1,
    2, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1,
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0,
    1, 1, 1, 0, 1, 1, 1, 0, 1, 0, 1,
    0, 1, 1, 0, 0, 1, 0, 1, 0, 1, 0,
    0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 1,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    -1, 0, 0, 0, 0, -1, 0, 0, 0, -1, 0,
    0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0,
    -1, 0, -1, 0, 0, -1, 0, -1, 0, 0, -1,
    0, -1, 0, -1, 0, -1, 0, 0, -1, 0, -1,
    0, -1, 0, -1, 0, -1, 0, -1, 0, -1, 0,
    -1, 0, -1, -1, 0, -1, 0, -1, 0, -1, 0,
    -1, 0, -1, 0, -1, 0, -1, 0, -1, -1, 0,
    -1, 0, -1, 0, -1, 0, -1, 0, -1, 0, -1,
    0, -1, 0, -1, 0, -1, 0, -1, 0, -1, 0,
    -1, 0, -1, 0, -1, 0, -1, 0, -1, 0, 0,
    -1, 0, -1, 0, -1, 0, 0, -1, 0, -1, 0,
    -1, 0, 0, -1, 0, -1, 0, 0, -1, 0, 0,
    -1, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0,
    -1, 0, 0, 0, -1, 0, 0, -1, 0, 0, 0,
    -1, 0, 0, 0, -1, 0, 0, 0, -1, 0, 0,
    0, -1, 0, 0, 0, 0, -1, 0, 0, 0, 0,
    -1, 0, 0, 0, 0, 0, -1, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    -1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, -1, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 1
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\ksfilter\miniport\msg711\msg711.cpp ===
/*++

Copyright (C) Microsoft Corporation, 1998 - 1998

Module Name:

    msg711.cpp

Abstract:

    Kernel G711 Mini-port

--*/

#include <unknown.h>
#include <kcom.h>
#include <kport.h>
#define NOBITMAP
#include <mmreg.h>
#include <ksmedia.h>
#include <limits.h>
#if (DBG)
#define STR_MODULENAME "msg711: "
#endif
#include <ksdebug.h>

DEFINE_GUIDSTRUCT("70F06807-B54E-11D1-8072-00A0C9223196", MiniPortClass);

//#define _ANY_
#ifndef _ANY_
typedef
NTSTATUS
(*PFNTRANSFORM)(
    IN PVOID SourceBuffer,
    IN OUT PULONG SourceLength,
    OUT PVOID DestinationBuffer,
    IN OUT PULONG DestinationLength
    );
#endif // !_ANY_

class CMiniPort :
    CBaseUnknown,
    public IPmMiniPort {
public:
    CMiniPort(
        IN REFGUID ReferenceId,
        IN IUnknown* UnkOuter OPTIONAL,
        OUT NTSTATUS* Status);
    ~CMiniPort();

    // Implement IUnknown
    DEFINE_STD_UNKNOWN();

    // Implement IPmMiniPort
    STDMETHODIMP InitializeMiniPort(
        IN PDEVICE_OBJECT DeviceObject,
        IN IUnknown* UnkPort
        );
    STDMETHODIMP CreateMiniPortInstance(
        IN IUnknown* UnkPortInstance,
        OUT IUnknown** UnkMiniInstance
        );

public:
    IUnknown* m_UnkPort;
};

class CMiniPortInstance :
    CBaseUnknown,
    public IPmMiniTransform {
public:
    CMiniPortInstance(
        IN IUnknown* UnkOuter OPTIONAL,
        IN CMiniPort* MiniPort,
        IN IUnknown* UnkPortInstance,
        OUT NTSTATUS* Status);
    ~CMiniPortInstance();

#ifdef _ANY_
    STDMETHODIMP PcmToALaw(
        IN PVOID SourceBuffer,
        IN OUT PULONG SourceLength,
        OUT PVOID DestinationBuffer,
        IN OUT PULONG DestinationLength
        );
    STDMETHODIMP ALawToPcm(
        IN PVOID SourceBuffer,
        IN OUT PULONG SourceLength,
        OUT PVOID DestinationBuffer,
        IN OUT PULONG DestinationLength
        );
    STDMETHODIMP PcmToMuLaw(
        IN PVOID SourceBuffer,
        IN OUT PULONG SourceLength,
        OUT PVOID DestinationBuffer,
        IN OUT PULONG DestinationLength
        );
    STDMETHODIMP MuLawToPcm(
        IN PVOID SourceBuffer,
        IN OUT PULONG SourceLength,
        OUT PVOID DestinationBuffer,
        IN OUT PULONG DestinationLength
        );
    STDMETHODIMP ALawToMuLaw(
        IN PVOID SourceBuffer,
        IN OUT PULONG SourceLength,
        OUT PVOID DestinationBuffer,
        IN OUT PULONG DestinationLength
        );
    STDMETHODIMP MuLawToALaw(
        IN PVOID SourceBuffer,
        IN OUT PULONG SourceLength,
        OUT PVOID DestinationBuffer,
        IN OUT PULONG DestinationLength
        );
#endif // _ANY_

    // Implement IUnknown
    DEFINE_STD_UNKNOWN();

    // Implement IPmMiniTransform
    STDMETHODIMP QueryTransformAttributes(
        IN KSPIN_DATAFLOW DataFlow,
        OUT PPMTRANSFORMATTRIBUTES TransformAttributes
        );
    STDMETHODIMP InitializeStream(
        IN KSPIN_DATAFLOW DataFlow,
        IN IUnknown* UnkStreamInput
        );
    STDMETHODIMP DataIntersect(
        IN KSPIN_DATAFLOW DataFlow,
        IN PKSDATARANGE DataRange,
        IN OUT PULONG DataLength,
        OUT PKSDATAFORMAT Data OPTIONAL
        );
    STDMETHODIMP DeliverTransformPacket(
        IN IPmBasicPacket* TransformPacket
        );

private:
    CMiniPort* m_MiniPort;
    IUnknown* m_UnkPortInstance;
    IUnknown* m_UnkStream[2];
    PKSDATAFORMAT_WAVEFORMATEX m_StreamFormat[2];
    const KSDATARANGE_AUDIO* m_StreamRange[2];
    const PMTRANSFORMATTRIBUTES* m_TransformAttributes[2];
#ifdef _ANY_
    HRESULT (STDMETHODCALLTYPE CMiniPortInstance::*m_Transform)(
        IN PVOID SourceBuffer,
        IN OUT PULONG SourceLength,
        OUT PVOID DestinationBuffer,
        IN OUT PULONG DestinationLength
        );
#else // !_ANY_
    PFNTRANSFORM m_Transform;
#endif // !_ANY_
};

#define MINIPORTINSTANCE_TAG 'imsk'
#define MINIPORT_TAG 'pmsk'

#define PCM_BLOCKALIGNMENT(pwf)     (UINT)(((pwf)->wBitsPerSample >> 3) << ((pwf)->wf.nChannels >> 1))
#define PCM_AVGBYTESPERSEC(pwf)     (DWORD)((pwf)->wf.nSamplesPerSec * (pwf)->wf.nBlockAlign)

#ifdef ALLOC_DATA_PRAGMA
#pragma const_seg("PAGECONST")
#endif // ALLOC_DATA_PRAGMA

//
// These are the conversion tables as defined by the CCITT standard.
//

static const SHORT AlawToPcmTable[256] = {
    -5504,         // y[00]=   -688
    -5248,         // y[01]=   -656
    -6016,         // y[02]=   -752
    -5760,         // y[03]=   -720
    -4480,         // y[04]=   -560
    -4224,         // y[05]=   -528
    -4992,         // y[06]=   -624
    -4736,         // y[07]=   -592
    -7552,         // y[08]=   -944
    -7296,         // y[09]=   -912
    -8064,         // y[0a]=  -1008
    -7808,         // y[0b]=   -976
    -6528,         // y[0c]=   -816
    -6272,         // y[0d]=   -784
    -7040,         // y[0e]=   -880
    -6784,         // y[0f]=   -848
    -2752,         // y[10]=   -344
    -2624,         // y[11]=   -328
    -3008,         // y[12]=   -376
    -2880,         // y[13]=   -360
    -2240,         // y[14]=   -280
    -2112,         // y[15]=   -264
    -2496,         // y[16]=   -312
    -2368,         // y[17]=   -296
    -3776,         // y[18]=   -472
    -3648,         // y[19]=   -456
    -4032,         // y[1a]=   -504
    -3904,         // y[1b]=   -488
    -3264,         // y[1c]=   -408
    -3136,         // y[1d]=   -392
    -3520,         // y[1e]=   -440
    -3392,         // y[1f]=   -424
    -22016,         // y[20]=  -2752
    -20992,         // y[21]=  -2624
    -24064,         // y[22]=  -3008
    -23040,         // y[23]=  -2880
    -17920,         // y[24]=  -2240
    -16896,         // y[25]=  -2112
    -19968,         // y[26]=  -2496
    -18944,         // y[27]=  -2368
    -30208,         // y[28]=  -3776
    -29184,         // y[29]=  -3648
    -32256,         // y[2a]=  -4032
    -31232,         // y[2b]=  -3904
    -26112,         // y[2c]=  -3264
    -25088,         // y[2d]=  -3136
    -28160,         // y[2e]=  -3520
    -27136,         // y[2f]=  -3392
    -11008,         // y[30]=  -1376
    -10496,         // y[31]=  -1312
    -12032,         // y[32]=  -1504
    -11520,         // y[33]=  -1440
    -8960,         // y[34]=  -1120
    -8448,         // y[35]=  -1056
    -9984,         // y[36]=  -1248
    -9472,         // y[37]=  -1184
    -15104,         // y[38]=  -1888
    -14592,         // y[39]=  -1824
    -16128,         // y[3a]=  -2016
    -15616,         // y[3b]=  -1952
    -13056,         // y[3c]=  -1632
    -12544,         // y[3d]=  -1568
    -14080,         // y[3e]=  -1760
    -13568,         // y[3f]=  -1696
    -344,         // y[40]=    -43
    -328,         // y[41]=    -41
    -376,         // y[42]=    -47
    -360,         // y[43]=    -45
    -280,         // y[44]=    -35
    -264,         // y[45]=    -33
    -312,         // y[46]=    -39
    -296,         // y[47]=    -37
    -472,         // y[48]=    -59
    -456,         // y[49]=    -57
    -504,         // y[4a]=    -63
    -488,         // y[4b]=    -61
    -408,         // y[4c]=    -51
    -392,         // y[4d]=    -49
    -440,         // y[4e]=    -55
    -424,         // y[4f]=    -53
    -88,         // y[50]=    -11
    -72,         // y[51]=     -9
    -120,         // y[52]=    -15
    -104,         // y[53]=    -13
    -24,         // y[54]=     -3
    -8,         // y[55]=     -1
    -56,         // y[56]=     -7
    -40,         // y[57]=     -5
    -216,         // y[58]=    -27
    -200,         // y[59]=    -25
    -248,         // y[5a]=    -31
    -232,         // y[5b]=    -29
    -152,         // y[5c]=    -19
    -136,         // y[5d]=    -17
    -184,         // y[5e]=    -23
    -168,         // y[5f]=    -21
    -1376,         // y[60]=   -172
    -1312,         // y[61]=   -164
    -1504,         // y[62]=   -188
    -1440,         // y[63]=   -180
    -1120,         // y[64]=   -140
    -1056,         // y[65]=   -132
    -1248,         // y[66]=   -156
    -1184,         // y[67]=   -148
    -1888,         // y[68]=   -236
    -1824,         // y[69]=   -228
    -2016,         // y[6a]=   -252
    -1952,         // y[6b]=   -244
    -1632,         // y[6c]=   -204
    -1568,         // y[6d]=   -196
    -1760,         // y[6e]=   -220
    -1696,         // y[6f]=   -212
    -688,         // y[70]=    -86
    -656,         // y[71]=    -82
    -752,         // y[72]=    -94
    -720,         // y[73]=    -90
    -560,         // y[74]=    -70
    -528,         // y[75]=    -66
    -624,         // y[76]=    -78
    -592,         // y[77]=    -74
    -944,         // y[78]=   -118
    -912,         // y[79]=   -114
    -1008,         // y[7a]=   -126
    -976,         // y[7b]=   -122
    -816,         // y[7c]=   -102
    -784,         // y[7d]=    -98
    -880,         // y[7e]=   -110
    -848,         // y[7f]=   -106
    5504,         // y[80]=    688
    5248,         // y[81]=    656
    6016,         // y[82]=    752
    5760,         // y[83]=    720
    4480,         // y[84]=    560
    4224,         // y[85]=    528
    4992,         // y[86]=    624
    4736,         // y[87]=    592
    7552,         // y[88]=    944
    7296,         // y[89]=    912
    8064,         // y[8a]=   1008
    7808,         // y[8b]=    976
    6528,         // y[8c]=    816
    6272,         // y[8d]=    784
    7040,         // y[8e]=    880
    6784,         // y[8f]=    848
    2752,         // y[90]=    344
    2624,         // y[91]=    328
    3008,         // y[92]=    376
    2880,         // y[93]=    360
    2240,         // y[94]=    280
    2112,         // y[95]=    264
    2496,         // y[96]=    312
    2368,         // y[97]=    296
    3776,         // y[98]=    472
    3648,         // y[99]=    456
    4032,         // y[9a]=    504
    3904,         // y[9b]=    488
    3264,         // y[9c]=    408
    3136,         // y[9d]=    392
    3520,         // y[9e]=    440
    3392,         // y[9f]=    424
    22016,         // y[a0]=   2752
    20992,         // y[a1]=   2624
    24064,         // y[a2]=   3008
    23040,         // y[a3]=   2880
    17920,         // y[a4]=   2240
    16896,         // y[a5]=   2112
    19968,         // y[a6]=   2496
    18944,         // y[a7]=   2368
    30208,         // y[a8]=   3776
    29184,         // y[a9]=   3648
    32256,         // y[aa]=   4032
    31232,         // y[ab]=   3904
    26112,         // y[ac]=   3264
    25088,         // y[ad]=   3136
    28160,         // y[ae]=   3520
    27136,         // y[af]=   3392
    11008,         // y[b0]=   1376
    10496,         // y[b1]=   1312
    12032,         // y[b2]=   1504
    11520,         // y[b3]=   1440
    8960,         // y[b4]=   1120
    8448,         // y[b5]=   1056
    9984,         // y[b6]=   1248
    9472,         // y[b7]=   1184
    15104,         // y[b8]=   1888
    14592,         // y[b9]=   1824
    16128,         // y[ba]=   2016
    15616,         // y[bb]=   1952
    13056,         // y[bc]=   1632
    12544,         // y[bd]=   1568
    14080,         // y[be]=   1760
    13568,         // y[bf]=   1696
    344,         // y[c0]=     43
    328,         // y[c1]=     41
    376,         // y[c2]=     47
    360,         // y[c3]=     45
    280,         // y[c4]=     35
    264,         // y[c5]=     33
    312,         // y[c6]=     39
    296,         // y[c7]=     37
    472,         // y[c8]=     59
    456,         // y[c9]=     57
    504,         // y[ca]=     63
    488,         // y[cb]=     61
    408,         // y[cc]=     51
    392,         // y[cd]=     49
    440,         // y[ce]=     55
    424,         // y[cf]=     53
    88,         // y[d0]=     11
    72,         // y[d1]=      9
    120,         // y[d2]=     15
    104,         // y[d3]=     13
    24,         // y[d4]=      3
    8,         // y[d5]=      1
    56,         // y[d6]=      7
    40,         // y[d7]=      5
    216,         // y[d8]=     27
    200,         // y[d9]=     25
    248,         // y[da]=     31
    232,         // y[db]=     29
    152,         // y[dc]=     19
    136,         // y[dd]=     17
    184,         // y[de]=     23
    168,         // y[df]=     21
    1376,         // y[e0]=    172
    1312,         // y[e1]=    164
    1504,         // y[e2]=    188
    1440,         // y[e3]=    180
    1120,         // y[e4]=    140
    1056,         // y[e5]=    132
    1248,         // y[e6]=    156
    1184,         // y[e7]=    148
    1888,         // y[e8]=    236
    1824,         // y[e9]=    228
    2016,         // y[ea]=    252
    1952,         // y[eb]=    244
    1632,         // y[ec]=    204
    1568,         // y[ed]=    196
    1760,         // y[ee]=    220
    1696,         // y[ef]=    212
    688,         // y[f0]=     86
    656,         // y[f1]=     82
    752,         // y[f2]=     94
    720,         // y[f3]=     90
    560,         // y[f4]=     70
    528,         // y[f5]=     66
    624,         // y[f6]=     78
    592,         // y[f7]=     74
    944,         // y[f8]=    118
    912,         // y[f9]=    114
    1008,         // y[fa]=    126
    976,         // y[fb]=    122
    816,         // y[fc]=    102
    784,         // y[fd]=     98
    880,         // y[fe]=    110
    848          // y[ff]=    106
};

static const SHORT UlawToPcmTable[256] = {
    -32124,         // y[00]=  -8031
    -31100,         // y[01]=  -7775
    -30076,         // y[02]=  -7519
    -29052,         // y[03]=  -7263
    -28028,         // y[04]=  -7007
    -27004,         // y[05]=  -6751
    -25980,         // y[06]=  -6495
    -24956,         // y[07]=  -6239
    -23932,         // y[08]=  -5983
    -22908,         // y[09]=  -5727
    -21884,         // y[0a]=  -5471
    -20860,         // y[0b]=  -5215
    -19836,         // y[0c]=  -4959
    -18812,         // y[0d]=  -4703
    -17788,         // y[0e]=  -4447
    -16764,         // y[0f]=  -4191
    -15996,         // y[10]=  -3999
    -15484,         // y[11]=  -3871
    -14972,         // y[12]=  -3743
    -14460,         // y[13]=  -3615
    -13948,         // y[14]=  -3487
    -13436,         // y[15]=  -3359
    -12924,         // y[16]=  -3231
    -12412,         // y[17]=  -3103
    -11900,         // y[18]=  -2975
    -11388,         // y[19]=  -2847
    -10876,         // y[1a]=  -2719
    -10364,         // y[1b]=  -2591
    -9852,         // y[1c]=  -2463
    -9340,         // y[1d]=  -2335
    -8828,         // y[1e]=  -2207
    -8316,         // y[1f]=  -2079
    -7932,         // y[20]=  -1983
    -7676,         // y[21]=  -1919
    -7420,         // y[22]=  -1855
    -7164,         // y[23]=  -1791
    -6908,         // y[24]=  -1727
    -6652,         // y[25]=  -1663
    -6396,         // y[26]=  -1599
    -6140,         // y[27]=  -1535
    -5884,         // y[28]=  -1471
    -5628,         // y[29]=  -1407
    -5372,         // y[2a]=  -1343
    -5116,         // y[2b]=  -1279
    -4860,         // y[2c]=  -1215
    -4604,         // y[2d]=  -1151
    -4348,         // y[2e]=  -1087
    -4092,         // y[2f]=  -1023
    -3900,         // y[30]=   -975
    -3772,         // y[31]=   -943
    -3644,         // y[32]=   -911
    -3516,         // y[33]=   -879
    -3388,         // y[34]=   -847
    -3260,         // y[35]=   -815
    -3132,         // y[36]=   -783
    -3004,         // y[37]=   -751
    -2876,         // y[38]=   -719
    -2748,         // y[39]=   -687
    -2620,         // y[3a]=   -655
    -2492,         // y[3b]=   -623
    -2364,         // y[3c]=   -591
    -2236,         // y[3d]=   -559
    -2108,         // y[3e]=   -527
    -1980,         // y[3f]=   -495
    -1884,         // y[40]=   -471
    -1820,         // y[41]=   -455
    -1756,         // y[42]=   -439
    -1692,         // y[43]=   -423
    -1628,         // y[44]=   -407
    -1564,         // y[45]=   -391
    -1500,         // y[46]=   -375
    -1436,         // y[47]=   -359
    -1372,         // y[48]=   -343
    -1308,         // y[49]=   -327
    -1244,         // y[4a]=   -311
    -1180,         // y[4b]=   -295
    -1116,         // y[4c]=   -279
    -1052,         // y[4d]=   -263
    -988,         // y[4e]=   -247
    -924,         // y[4f]=   -231
    -876,         // y[50]=   -219
    -844,         // y[51]=   -211
    -812,         // y[52]=   -203
    -780,         // y[53]=   -195
    -748,         // y[54]=   -187
    -716,         // y[55]=   -179
    -684,         // y[56]=   -171
    -652,         // y[57]=   -163
    -620,         // y[58]=   -155
    -588,         // y[59]=   -147
    -556,         // y[5a]=   -139
    -524,         // y[5b]=   -131
    -492,         // y[5c]=   -123
    -460,         // y[5d]=   -115
    -428,         // y[5e]=   -107
    -396,         // y[5f]=    -99
    -372,         // y[60]=    -93
    -356,         // y[61]=    -89
    -340,         // y[62]=    -85
    -324,         // y[63]=    -81
    -308,         // y[64]=    -77
    -292,         // y[65]=    -73
    -276,         // y[66]=    -69
    -260,         // y[67]=    -65
    -244,         // y[68]=    -61
    -228,         // y[69]=    -57
    -212,         // y[6a]=    -53
    -196,         // y[6b]=    -49
    -180,         // y[6c]=    -45
    -164,         // y[6d]=    -41
    -148,         // y[6e]=    -37
    -132,         // y[6f]=    -33
    -120,         // y[70]=    -30
    -112,         // y[71]=    -28
    -104,         // y[72]=    -26
    -96,         // y[73]=    -24
    -88,         // y[74]=    -22
    -80,         // y[75]=    -20
    -72,         // y[76]=    -18
    -64,         // y[77]=    -16
    -56,         // y[78]=    -14
    -48,         // y[79]=    -12
    -40,         // y[7a]=    -10
    -32,         // y[7b]=     -8
    -24,         // y[7c]=     -6
    -16,         // y[7d]=     -4
    -8,         // y[7e]=     -2
    0,         // y[7f]=      0
    32124,         // y[80]=   8031
    31100,         // y[81]=   7775
    30076,         // y[82]=   7519
    29052,         // y[83]=   7263
    28028,         // y[84]=   7007
    27004,         // y[85]=   6751
    25980,         // y[86]=   6495
    24956,         // y[87]=   6239
    23932,         // y[88]=   5983
    22908,         // y[89]=   5727
    21884,         // y[8a]=   5471
    20860,         // y[8b]=   5215
    19836,         // y[8c]=   4959
    18812,         // y[8d]=   4703
    17788,         // y[8e]=   4447
    16764,         // y[8f]=   4191
    15996,         // y[90]=   3999
    15484,         // y[91]=   3871
    14972,         // y[92]=   3743
    14460,         // y[93]=   3615
    13948,         // y[94]=   3487
    13436,         // y[95]=   3359
    12924,         // y[96]=   3231
    12412,         // y[97]=   3103
    11900,         // y[98]=   2975
    11388,         // y[99]=   2847
    10876,         // y[9a]=   2719
    10364,         // y[9b]=   2591
    9852,         // y[9c]=   2463
    9340,         // y[9d]=   2335
    8828,         // y[9e]=   2207
    8316,         // y[9f]=   2079
    7932,         // y[a0]=   1983
    7676,         // y[a1]=   1919
    7420,         // y[a2]=   1855
    7164,         // y[a3]=   1791
    6908,         // y[a4]=   1727
    6652,         // y[a5]=   1663
    6396,         // y[a6]=   1599
    6140,         // y[a7]=   1535
    5884,         // y[a8]=   1471
    5628,         // y[a9]=   1407
    5372,         // y[aa]=   1343
    5116,         // y[ab]=   1279
    4860,         // y[ac]=   1215
    4604,         // y[ad]=   1151
    4348,         // y[ae]=   1087
    4092,         // y[af]=   1023
    3900,         // y[b0]=    975
    3772,         // y[b1]=    943
    3644,         // y[b2]=    911
    3516,         // y[b3]=    879
    3388,         // y[b4]=    847
    3260,         // y[b5]=    815
    3132,         // y[b6]=    783
    3004,         // y[b7]=    751
    2876,         // y[b8]=    719
    2748,         // y[b9]=    687
    2620,         // y[ba]=    655
    2492,         // y[bb]=    623
    2364,         // y[bc]=    591
    2236,         // y[bd]=    559
    2108,         // y[be]=    527
    1980,         // y[bf]=    495
    1884,         // y[c0]=    471
    1820,         // y[c1]=    455
    1756,         // y[c2]=    439
    1692,         // y[c3]=    423
    1628,         // y[c4]=    407
    1564,         // y[c5]=    391
    1500,         // y[c6]=    375
    1436,         // y[c7]=    359
    1372,         // y[c8]=    343
    1308,         // y[c9]=    327
    1244,         // y[ca]=    311
    1180,         // y[cb]=    295
    1116,         // y[cc]=    279
    1052,         // y[cd]=    263
    988,         // y[ce]=    247
    924,         // y[cf]=    231
    876,         // y[d0]=    219
    844,         // y[d1]=    211
    812,         // y[d2]=    203
    780,         // y[d3]=    195
    748,         // y[d4]=    187
    716,         // y[d5]=    179
    684,         // y[d6]=    171
    652,         // y[d7]=    163
    620,         // y[d8]=    155
    588,         // y[d9]=    147
    556,         // y[da]=    139
    524,         // y[db]=    131
    492,         // y[dc]=    123
    460,         // y[dd]=    115
    428,         // y[de]=    107
    396,         // y[df]=     99
    372,         // y[e0]=     93
    356,         // y[e1]=     89
    340,         // y[e2]=     85
    324,         // y[e3]=     81
    308,         // y[e4]=     77
    292,         // y[e5]=     73
    276,         // y[e6]=     69
    260,         // y[e7]=     65
    244,         // y[e8]=     61
    228,         // y[e9]=     57
    212,         // y[ea]=     53
    196,         // y[eb]=     49
    180,         // y[ec]=     45
    164,         // y[ed]=     41
    148,         // y[ee]=     37
    132,         // y[ef]=     33
    120,         // y[f0]=     30
    112,         // y[f1]=     28
    104,         // y[f2]=     26
    96,         // y[f3]=     24
    88,         // y[f4]=     22
    80,         // y[f5]=     20
    72,         // y[f6]=     18
    64,         // y[f7]=     16
    56,         // y[f8]=     14
    48,         // y[f9]=     12
    40,         // y[fa]=     10
    32,         // y[fb]=      8
    24,         // y[fc]=      6
    16,         // y[fd]=      4
    8,         // y[fe]=      2
    0          // y[ff]=      0
};
        
static const BYTE AlawToUlawTable[256] = {
    0x2a,           // A-law[00] ==> u-law[2a]
    0x2b,           // A-law[01] ==> u-law[2b]
    0x28,           // A-law[02] ==> u-law[28]
    0x29,           // A-law[03] ==> u-law[29]
    0x2e,           // A-law[04] ==> u-law[2e]
    0x2f,           // A-law[05] ==> u-law[2f]
    0x2c,           // A-law[06] ==> u-law[2c]
    0x2d,           // A-law[07] ==> u-law[2d]
    0x22,           // A-law[08] ==> u-law[22]
    0x23,           // A-law[09] ==> u-law[23]
    0x20,           // A-law[0a] ==> u-law[20]
    0x21,           // A-law[0b] ==> u-law[21]
    0x26,           // A-law[0c] ==> u-law[26]
    0x27,           // A-law[0d] ==> u-law[27]
    0x24,           // A-law[0e] ==> u-law[24]
    0x25,           // A-law[0f] ==> u-law[25]
    0x39,           // A-law[10] ==> u-law[39]
    0x3a,           // A-law[11] ==> u-law[3a]
    0x37,           // A-law[12] ==> u-law[37]
    0x38,           // A-law[13] ==> u-law[38]
    0x3d,           // A-law[14] ==> u-law[3d]
    0x3e,           // A-law[15] ==> u-law[3e]
    0x3b,           // A-law[16] ==> u-law[3b]
    0x3c,           // A-law[17] ==> u-law[3c]
    0x31,           // A-law[18] ==> u-law[31]
    0x32,           // A-law[19] ==> u-law[32]
    0x30,           // A-law[1a] ==> u-law[30]
    0x30,           // A-law[1b] ==> u-law[30]
    0x35,           // A-law[1c] ==> u-law[35]
    0x36,           // A-law[1d] ==> u-law[36]
    0x33,           // A-law[1e] ==> u-law[33]
    0x34,           // A-law[1f] ==> u-law[34]
    0x0a,           // A-law[20] ==> u-law[0a]
    0x0b,           // A-law[21] ==> u-law[0b]
    0x08,           // A-law[22] ==> u-law[08]
    0x09,           // A-law[23] ==> u-law[09]
    0x0e,           // A-law[24] ==> u-law[0e]
    0x0f,           // A-law[25] ==> u-law[0f]
    0x0c,           // A-law[26] ==> u-law[0c]
    0x0d,           // A-law[27] ==> u-law[0d]
    0x02,           // A-law[28] ==> u-law[02]
    0x03,           // A-law[29] ==> u-law[03]
    0x00,           // A-law[2a] ==> u-law[00]
    0x01,           // A-law[2b] ==> u-law[01]
    0x06,           // A-law[2c] ==> u-law[06]
    0x07,           // A-law[2d] ==> u-law[07]
    0x04,           // A-law[2e] ==> u-law[04]
    0x05,           // A-law[2f] ==> u-law[05]
    0x1a,           // A-law[30] ==> u-law[1a]
    0x1b,           // A-law[31] ==> u-law[1b]
    0x18,           // A-law[32] ==> u-law[18]
    0x19,           // A-law[33] ==> u-law[19]
    0x1e,           // A-law[34] ==> u-law[1e]
    0x1f,           // A-law[35] ==> u-law[1f]
    0x1c,           // A-law[36] ==> u-law[1c]
    0x1d,           // A-law[37] ==> u-law[1d]
    0x12,           // A-law[38] ==> u-law[12]
    0x13,           // A-law[39] ==> u-law[13]
    0x10,           // A-law[3a] ==> u-law[10]
    0x11,           // A-law[3b] ==> u-law[11]
    0x16,           // A-law[3c] ==> u-law[16]
    0x17,           // A-law[3d] ==> u-law[17]
    0x14,           // A-law[3e] ==> u-law[14]
    0x15,           // A-law[3f] ==> u-law[15]
    0x62,           // A-law[40] ==> u-law[62]
    0x63,           // A-law[41] ==> u-law[63]
    0x60,           // A-law[42] ==> u-law[60]
    0x61,           // A-law[43] ==> u-law[61]
    0x66,           // A-law[44] ==> u-law[66]
    0x67,           // A-law[45] ==> u-law[67]
    0x64,           // A-law[46] ==> u-law[64]
    0x65,           // A-law[47] ==> u-law[65]
    0x5d,           // A-law[48] ==> u-law[5d]
    0x5d,           // A-law[49] ==> u-law[5d]
    0x5c,           // A-law[4a] ==> u-law[5c]
    0x5c,           // A-law[4b] ==> u-law[5c]
    0x5f,           // A-law[4c] ==> u-law[5f]
    0x5f,           // A-law[4d] ==> u-law[5f]
    0x5e,           // A-law[4e] ==> u-law[5e]
    0x5e,           // A-law[4f] ==> u-law[5e]
    0x74,           // A-law[50] ==> u-law[74]
    0x76,           // A-law[51] ==> u-law[76]
    0x70,           // A-law[52] ==> u-law[70]
    0x72,           // A-law[53] ==> u-law[72]
    0x7c,           // A-law[54] ==> u-law[7c]
    0x7e,           // A-law[55] ==> u-law[7e]
    0x78,           // A-law[56] ==> u-law[78]
    0x7a,           // A-law[57] ==> u-law[7a]
    0x6a,           // A-law[58] ==> u-law[6a]
    0x6b,           // A-law[59] ==> u-law[6b]
    0x68,           // A-law[5a] ==> u-law[68]
    0x69,           // A-law[5b] ==> u-law[69]
    0x6e,           // A-law[5c] ==> u-law[6e]
    0x6f,           // A-law[5d] ==> u-law[6f]
    0x6c,           // A-law[5e] ==> u-law[6c]
    0x6d,           // A-law[5f] ==> u-law[6d]
    0x48,           // A-law[60] ==> u-law[48]
    0x49,           // A-law[61] ==> u-law[49]
    0x46,           // A-law[62] ==> u-law[46]
    0x47,           // A-law[63] ==> u-law[47]
    0x4c,           // A-law[64] ==> u-law[4c]
    0x4d,           // A-law[65] ==> u-law[4d]
    0x4a,           // A-law[66] ==> u-law[4a]
    0x4b,           // A-law[67] ==> u-law[4b]
    0x40,           // A-law[68] ==> u-law[40]
    0x41,           // A-law[69] ==> u-law[41]
    0x3f,           // A-law[6a] ==> u-law[3f]
    0x3f,           // A-law[6b] ==> u-law[3f]
    0x44,           // A-law[6c] ==> u-law[44]
    0x45,           // A-law[6d] ==> u-law[45]
    0x42,           // A-law[6e] ==> u-law[42]
    0x43,           // A-law[6f] ==> u-law[43]
    0x56,           // A-law[70] ==> u-law[56]
    0x57,           // A-law[71] ==> u-law[57]
    0x54,           // A-law[72] ==> u-law[54]
    0x55,           // A-law[73] ==> u-law[55]
    0x5a,           // A-law[74] ==> u-law[5a]
    0x5b,           // A-law[75] ==> u-law[5b]
    0x58,           // A-law[76] ==> u-law[58]
    0x59,           // A-law[77] ==> u-law[59]
    0x4f,           // A-law[78] ==> u-law[4f]
    0x4f,           // A-law[79] ==> u-law[4f]
    0x4e,           // A-law[7a] ==> u-law[4e]
    0x4e,           // A-law[7b] ==> u-law[4e]
    0x52,           // A-law[7c] ==> u-law[52]
    0x53,           // A-law[7d] ==> u-law[53]
    0x50,           // A-law[7e] ==> u-law[50]
    0x51,           // A-law[7f] ==> u-law[51]
    0xaa,           // A-law[80] ==> u-law[aa]
    0xab,           // A-law[81] ==> u-law[ab]
    0xa8,           // A-law[82] ==> u-law[a8]
    0xa9,           // A-law[83] ==> u-law[a9]
    0xae,           // A-law[84] ==> u-law[ae]
    0xaf,           // A-law[85] ==> u-law[af]
    0xac,           // A-law[86] ==> u-law[ac]
    0xad,           // A-law[87] ==> u-law[ad]
    0xa2,           // A-law[88] ==> u-law[a2]
    0xa3,           // A-law[89] ==> u-law[a3]
    0xa0,           // A-law[8a] ==> u-law[a0]
    0xa1,           // A-law[8b] ==> u-law[a1]
    0xa6,           // A-law[8c] ==> u-law[a6]
    0xa7,           // A-law[8d] ==> u-law[a7]
    0xa4,           // A-law[8e] ==> u-law[a4]
    0xa5,           // A-law[8f] ==> u-law[a5]
    0xb9,           // A-law[90] ==> u-law[b9]
    0xba,           // A-law[91] ==> u-law[ba]
    0xb7,           // A-law[92] ==> u-law[b7]
    0xb8,           // A-law[93] ==> u-law[b8]
    0xbd,           // A-law[94] ==> u-law[bd]
    0xbe,           // A-law[95] ==> u-law[be]
    0xbb,           // A-law[96] ==> u-law[bb]
    0xbc,           // A-law[97] ==> u-law[bc]
    0xb1,           // A-law[98] ==> u-law[b1]
    0xb2,           // A-law[99] ==> u-law[b2]
    0xb0,           // A-law[9a] ==> u-law[b0]
    0xb0,           // A-law[9b] ==> u-law[b0]
    0xb5,           // A-law[9c] ==> u-law[b5]
    0xb6,           // A-law[9d] ==> u-law[b6]
    0xb3,           // A-law[9e] ==> u-law[b3]
    0xb4,           // A-law[9f] ==> u-law[b4]
    0x8a,           // A-law[a0] ==> u-law[8a]
    0x8b,           // A-law[a1] ==> u-law[8b]
    0x88,           // A-law[a2] ==> u-law[88]
    0x89,           // A-law[a3] ==> u-law[89]
    0x8e,           // A-law[a4] ==> u-law[8e]
    0x8f,           // A-law[a5] ==> u-law[8f]
    0x8c,           // A-law[a6] ==> u-law[8c]
    0x8d,           // A-law[a7] ==> u-law[8d]
    0x82,           // A-law[a8] ==> u-law[82]
    0x83,           // A-law[a9] ==> u-law[83]
    0x80,           // A-law[aa] ==> u-law[80]
    0x81,           // A-law[ab] ==> u-law[81]
    0x86,           // A-law[ac] ==> u-law[86]
    0x87,           // A-law[ad] ==> u-law[87]
    0x84,           // A-law[ae] ==> u-law[84]
    0x85,           // A-law[af] ==> u-law[85]
    0x9a,           // A-law[b0] ==> u-law[9a]
    0x9b,           // A-law[b1] ==> u-law[9b]
    0x98,           // A-law[b2] ==> u-law[98]
    0x99,           // A-law[b3] ==> u-law[99]
    0x9e,           // A-law[b4] ==> u-law[9e]
    0x9f,           // A-law[b5] ==> u-law[9f]
    0x9c,           // A-law[b6] ==> u-law[9c]
    0x9d,           // A-law[b7] ==> u-law[9d]
    0x92,           // A-law[b8] ==> u-law[92]
    0x93,           // A-law[b9] ==> u-law[93]
    0x90,           // A-law[ba] ==> u-law[90]
    0x91,           // A-law[bb] ==> u-law[91]
    0x96,           // A-law[bc] ==> u-law[96]
    0x97,           // A-law[bd] ==> u-law[97]
    0x94,           // A-law[be] ==> u-law[94]
    0x95,           // A-law[bf] ==> u-law[95]
    0xe2,           // A-law[c0] ==> u-law[e2]
    0xe3,           // A-law[c1] ==> u-law[e3]
    0xe0,           // A-law[c2] ==> u-law[e0]
    0xe1,           // A-law[c3] ==> u-law[e1]
    0xe6,           // A-law[c4] ==> u-law[e6]
    0xe7,           // A-law[c5] ==> u-law[e7]
    0xe4,           // A-law[c6] ==> u-law[e4]
    0xe5,           // A-law[c7] ==> u-law[e5]
    0xdd,           // A-law[c8] ==> u-law[dd]
    0xdd,           // A-law[c9] ==> u-law[dd]
    0xdc,           // A-law[ca] ==> u-law[dc]
    0xdc,           // A-law[cb] ==> u-law[dc]
    0xdf,           // A-law[cc] ==> u-law[df]
    0xdf,           // A-law[cd] ==> u-law[df]
    0xde,           // A-law[ce] ==> u-law[de]
    0xde,           // A-law[cf] ==> u-law[de]
    0xf4,           // A-law[d0] ==> u-law[f4]
    0xf6,           // A-law[d1] ==> u-law[f6]
    0xf0,           // A-law[d2] ==> u-law[f0]
    0xf2,           // A-law[d3] ==> u-law[f2]
    0xfc,           // A-law[d4] ==> u-law[fc]
    0xfe,           // A-law[d5] ==> u-law[fe]
    0xf8,           // A-law[d6] ==> u-law[f8]
    0xfa,           // A-law[d7] ==> u-law[fa]
    0xea,           // A-law[d8] ==> u-law[ea]
    0xeb,           // A-law[d9] ==> u-law[eb]
    0xe8,           // A-law[da] ==> u-law[e8]
    0xe9,           // A-law[db] ==> u-law[e9]
    0xee,           // A-law[dc] ==> u-law[ee]
    0xef,           // A-law[dd] ==> u-law[ef]
    0xec,           // A-law[de] ==> u-law[ec]
    0xed,           // A-law[df] ==> u-law[ed]
    0xc8,           // A-law[e0] ==> u-law[c8]
    0xc9,           // A-law[e1] ==> u-law[c9]
    0xc6,           // A-law[e2] ==> u-law[c6]
    0xc7,           // A-law[e3] ==> u-law[c7]
    0xcc,           // A-law[e4] ==> u-law[cc]
    0xcd,           // A-law[e5] ==> u-law[cd]
    0xca,           // A-law[e6] ==> u-law[ca]
    0xcb,           // A-law[e7] ==> u-law[cb]
    0xc0,           // A-law[e8] ==> u-law[c0]
    0xc1,           // A-law[e9] ==> u-law[c1]
    0xbf,           // A-law[ea] ==> u-law[bf]
    0xbf,           // A-law[eb] ==> u-law[bf]
    0xc4,           // A-law[ec] ==> u-law[c4]
    0xc5,           // A-law[ed] ==> u-law[c5]
    0xc2,           // A-law[ee] ==> u-law[c2]
    0xc3,           // A-law[ef] ==> u-law[c3]
    0xd6,           // A-law[f0] ==> u-law[d6]
    0xd7,           // A-law[f1] ==> u-law[d7]
    0xd4,           // A-law[f2] ==> u-law[d4]
    0xd5,           // A-law[f3] ==> u-law[d5]
    0xda,           // A-law[f4] ==> u-law[da]
    0xdb,           // A-law[f5] ==> u-law[db]
    0xd8,           // A-law[f6] ==> u-law[d8]
    0xd9,           // A-law[f7] ==> u-law[d9]
    0xcf,           // A-law[f8] ==> u-law[cf]
    0xcf,           // A-law[f9] ==> u-law[cf]
    0xce,           // A-law[fa] ==> u-law[ce]
    0xce,           // A-law[fb] ==> u-law[ce]
    0xd2,           // A-law[fc] ==> u-law[d2]
    0xd3,           // A-law[fd] ==> u-law[d3]
    0xd0,           // A-law[fe] ==> u-law[d0]
    0xd1            // A-law[ff] ==> u-law[d1]
};
    
static const BYTE UlawToAlawTable[256] = {
    0x2a,           // u-law[00] ==> A-law[2a]
    0x2b,           // u-law[01] ==> A-law[2b]
    0x28,           // u-law[02] ==> A-law[28]
    0x29,           // u-law[03] ==> A-law[29]
    0x2e,           // u-law[04] ==> A-law[2e]
    0x2f,           // u-law[05] ==> A-law[2f]
    0x2c,           // u-law[06] ==> A-law[2c]
    0x2d,           // u-law[07] ==> A-law[2d]
    0x22,           // u-law[08] ==> A-law[22]
    0x23,           // u-law[09] ==> A-law[23]
    0x20,           // u-law[0a] ==> A-law[20]
    0x21,           // u-law[0b] ==> A-law[21]
    0x26,           // u-law[0c] ==> A-law[26]
    0x27,           // u-law[0d] ==> A-law[27]
    0x24,           // u-law[0e] ==> A-law[24]
    0x25,           // u-law[0f] ==> A-law[25]
    0x3a,           // u-law[10] ==> A-law[3a]
    0x3b,           // u-law[11] ==> A-law[3b]
    0x38,           // u-law[12] ==> A-law[38]
    0x39,           // u-law[13] ==> A-law[39]
    0x3e,           // u-law[14] ==> A-law[3e]
    0x3f,           // u-law[15] ==> A-law[3f]
    0x3c,           // u-law[16] ==> A-law[3c]
    0x3d,           // u-law[17] ==> A-law[3d]
    0x32,           // u-law[18] ==> A-law[32]
    0x33,           // u-law[19] ==> A-law[33]
    0x30,           // u-law[1a] ==> A-law[30]
    0x31,           // u-law[1b] ==> A-law[31]
    0x36,           // u-law[1c] ==> A-law[36]
    0x37,           // u-law[1d] ==> A-law[37]
    0x34,           // u-law[1e] ==> A-law[34]
    0x35,           // u-law[1f] ==> A-law[35]
    0x0a,           // u-law[20] ==> A-law[0a]
    0x0b,           // u-law[21] ==> A-law[0b]
    0x08,           // u-law[22] ==> A-law[08]
    0x09,           // u-law[23] ==> A-law[09]
    0x0e,           // u-law[24] ==> A-law[0e]
    0x0f,           // u-law[25] ==> A-law[0f]
    0x0c,           // u-law[26] ==> A-law[0c]
    0x0d,           // u-law[27] ==> A-law[0d]
    0x02,           // u-law[28] ==> A-law[02]
    0x03,           // u-law[29] ==> A-law[03]
    0x00,           // u-law[2a] ==> A-law[00]
    0x01,           // u-law[2b] ==> A-law[01]
    0x06,           // u-law[2c] ==> A-law[06]
    0x07,           // u-law[2d] ==> A-law[07]
    0x04,           // u-law[2e] ==> A-law[04]
    0x05,           // u-law[2f] ==> A-law[05]
    0x1b,           // u-law[30] ==> A-law[1b]
    0x18,           // u-law[31] ==> A-law[18]
    0x19,           // u-law[32] ==> A-law[19]
    0x1e,           // u-law[33] ==> A-law[1e]
    0x1f,           // u-law[34] ==> A-law[1f]
    0x1c,           // u-law[35] ==> A-law[1c]
    0x1d,           // u-law[36] ==> A-law[1d]
    0x12,           // u-law[37] ==> A-law[12]
    0x13,           // u-law[38] ==> A-law[13]
    0x10,           // u-law[39] ==> A-law[10]
    0x11,           // u-law[3a] ==> A-law[11]
    0x16,           // u-law[3b] ==> A-law[16]
    0x17,           // u-law[3c] ==> A-law[17]
    0x14,           // u-law[3d] ==> A-law[14]
    0x15,           // u-law[3e] ==> A-law[15]
    0x6a,           // u-law[3f] ==> A-law[6a]
    0x68,           // u-law[40] ==> A-law[68]
    0x69,           // u-law[41] ==> A-law[69]
    0x6e,           // u-law[42] ==> A-law[6e]
    0x6f,           // u-law[43] ==> A-law[6f]
    0x6c,           // u-law[44] ==> A-law[6c]
    0x6d,           // u-law[45] ==> A-law[6d]
    0x62,           // u-law[46] ==> A-law[62]
    0x63,           // u-law[47] ==> A-law[63]
    0x60,           // u-law[48] ==> A-law[60]
    0x61,           // u-law[49] ==> A-law[61]
    0x66,           // u-law[4a] ==> A-law[66]
    0x67,           // u-law[4b] ==> A-law[67]
    0x64,           // u-law[4c] ==> A-law[64]
    0x65,           // u-law[4d] ==> A-law[65]
    0x7a,           // u-law[4e] ==> A-law[7a]
    0x78,           // u-law[4f] ==> A-law[78]
    0x7e,           // u-law[50] ==> A-law[7e]
    0x7f,           // u-law[51] ==> A-law[7f]
    0x7c,           // u-law[52] ==> A-law[7c]
    0x7d,           // u-law[53] ==> A-law[7d]
    0x72,           // u-law[54] ==> A-law[72]
    0x73,           // u-law[55] ==> A-law[73]
    0x70,           // u-law[56] ==> A-law[70]
    0x71,           // u-law[57] ==> A-law[71]
    0x76,           // u-law[58] ==> A-law[76]
    0x77,           // u-law[59] ==> A-law[77]
    0x74,           // u-law[5a] ==> A-law[74]
    0x75,           // u-law[5b] ==> A-law[75]
    0x4b,           // u-law[5c] ==> A-law[4b]
    0x49,           // u-law[5d] ==> A-law[49]
    0x4f,           // u-law[5e] ==> A-law[4f]
    0x4d,           // u-law[5f] ==> A-law[4d]
    0x42,           // u-law[60] ==> A-law[42]
    0x43,           // u-law[61] ==> A-law[43]
    0x40,           // u-law[62] ==> A-law[40]
    0x41,           // u-law[63] ==> A-law[41]
    0x46,           // u-law[64] ==> A-law[46]
    0x47,           // u-law[65] ==> A-law[47]
    0x44,           // u-law[66] ==> A-law[44]
    0x45,           // u-law[67] ==> A-law[45]
    0x5a,           // u-law[68] ==> A-law[5a]
    0x5b,           // u-law[69] ==> A-law[5b]
    0x58,           // u-law[6a] ==> A-law[58]
    0x59,           // u-law[6b] ==> A-law[59]
    0x5e,           // u-law[6c] ==> A-law[5e]
    0x5f,           // u-law[6d] ==> A-law[5f]
    0x5c,           // u-law[6e] ==> A-law[5c]
    0x5d,           // u-law[6f] ==> A-law[5d]
    0x52,           // u-law[70] ==> A-law[52]
    0x52,           // u-law[71] ==> A-law[52]
    0x53,           // u-law[72] ==> A-law[53]
    0x53,           // u-law[73] ==> A-law[53]
    0x50,           // u-law[74] ==> A-law[50]
    0x50,           // u-law[75] ==> A-law[50]
    0x51,           // u-law[76] ==> A-law[51]
    0x51,           // u-law[77] ==> A-law[51]
    0x56,           // u-law[78] ==> A-law[56]
    0x56,           // u-law[79] ==> A-law[56]
    0x57,           // u-law[7a] ==> A-law[57]
    0x57,           // u-law[7b] ==> A-law[57]
    0x54,           // u-law[7c] ==> A-law[54]
    0x54,           // u-law[7d] ==> A-law[54]
    0x55,           // u-law[7e] ==> A-law[55]
    0x55,           // u-law[7f] ==> A-law[55]
    0xaa,           // u-law[80] ==> A-law[aa]
    0xab,           // u-law[81] ==> A-law[ab]
    0xa8,           // u-law[82] ==> A-law[a8]
    0xa9,           // u-law[83] ==> A-law[a9]
    0xae,           // u-law[84] ==> A-law[ae]
    0xaf,           // u-law[85] ==> A-law[af]
    0xac,           // u-law[86] ==> A-law[ac]
    0xad,           // u-law[87] ==> A-law[ad]
    0xa2,           // u-law[88] ==> A-law[a2]
    0xa3,           // u-law[89] ==> A-law[a3]
    0xa0,           // u-law[8a] ==> A-law[a0]
    0xa1,           // u-law[8b] ==> A-law[a1]
    0xa6,           // u-law[8c] ==> A-law[a6]
    0xa7,           // u-law[8d] ==> A-law[a7]
    0xa4,           // u-law[8e] ==> A-law[a4]
    0xa5,           // u-law[8f] ==> A-law[a5]
    0xba,           // u-law[90] ==> A-law[ba]
    0xbb,           // u-law[91] ==> A-law[bb]
    0xb8,           // u-law[92] ==> A-law[b8]
    0xb9,           // u-law[93] ==> A-law[b9]
    0xbe,           // u-law[94] ==> A-law[be]
    0xbf,           // u-law[95] ==> A-law[bf]
    0xbc,           // u-law[96] ==> A-law[bc]
    0xbd,           // u-law[97] ==> A-law[bd]
    0xb2,           // u-law[98] ==> A-law[b2]
    0xb3,           // u-law[99] ==> A-law[b3]
    0xb0,           // u-law[9a] ==> A-law[b0]
    0xb1,           // u-law[9b] ==> A-law[b1]
    0xb6,           // u-law[9c] ==> A-law[b6]
    0xb7,           // u-law[9d] ==> A-law[b7]
    0xb4,           // u-law[9e] ==> A-law[b4]
    0xb5,           // u-law[9f] ==> A-law[b5]
    0x8a,           // u-law[a0] ==> A-law[8a]
    0x8b,           // u-law[a1] ==> A-law[8b]
    0x88,           // u-law[a2] ==> A-law[88]
    0x89,           // u-law[a3] ==> A-law[89]
    0x8e,           // u-law[a4] ==> A-law[8e]
    0x8f,           // u-law[a5] ==> A-law[8f]
    0x8c,           // u-law[a6] ==> A-law[8c]
    0x8d,           // u-law[a7] ==> A-law[8d]
    0x82,           // u-law[a8] ==> A-law[82]
    0x83,           // u-law[a9] ==> A-law[83]
    0x80,           // u-law[aa] ==> A-law[80]
    0x81,           // u-law[ab] ==> A-law[81]
    0x86,           // u-law[ac] ==> A-law[86]
    0x87,           // u-law[ad] ==> A-law[87]
    0x84,           // u-law[ae] ==> A-law[84]
    0x85,           // u-law[af] ==> A-law[85]
    0x9b,           // u-law[b0] ==> A-law[9b]
    0x98,           // u-law[b1] ==> A-law[98]
    0x99,           // u-law[b2] ==> A-law[99]
    0x9e,           // u-law[b3] ==> A-law[9e]
    0x9f,           // u-law[b4] ==> A-law[9f]
    0x9c,           // u-law[b5] ==> A-law[9c]
    0x9d,           // u-law[b6] ==> A-law[9d]
    0x92,           // u-law[b7] ==> A-law[92]
    0x93,           // u-law[b8] ==> A-law[93]
    0x90,           // u-law[b9] ==> A-law[90]
    0x91,           // u-law[ba] ==> A-law[91]
    0x96,           // u-law[bb] ==> A-law[96]
    0x97,           // u-law[bc] ==> A-law[97]
    0x94,           // u-law[bd] ==> A-law[94]
    0x95,           // u-law[be] ==> A-law[95]
    0xea,           // u-law[bf] ==> A-law[ea]
    0xe8,           // u-law[c0] ==> A-law[e8]
    0xe9,           // u-law[c1] ==> A-law[e9]
    0xee,           // u-law[c2] ==> A-law[ee]
    0xef,           // u-law[c3] ==> A-law[ef]
    0xec,           // u-law[c4] ==> A-law[ec]
    0xed,           // u-law[c5] ==> A-law[ed]
    0xe2,           // u-law[c6] ==> A-law[e2]
    0xe3,           // u-law[c7] ==> A-law[e3]
    0xe0,           // u-law[c8] ==> A-law[e0]
    0xe1,           // u-law[c9] ==> A-law[e1]
    0xe6,           // u-law[ca] ==> A-law[e6]
    0xe7,           // u-law[cb] ==> A-law[e7]
    0xe4,           // u-law[cc] ==> A-law[e4]
    0xe5,           // u-law[cd] ==> A-law[e5]
    0xfa,           // u-law[ce] ==> A-law[fa]
    0xf8,           // u-law[cf] ==> A-law[f8]
    0xfe,           // u-law[d0] ==> A-law[fe]
    0xff,           // u-law[d1] ==> A-law[ff]
    0xfc,           // u-law[d2] ==> A-law[fc]
    0xfd,           // u-law[d3] ==> A-law[fd]
    0xf2,           // u-law[d4] ==> A-law[f2]
    0xf3,           // u-law[d5] ==> A-law[f3]
    0xf0,           // u-law[d6] ==> A-law[f0]
    0xf1,           // u-law[d7] ==> A-law[f1]
    0xf6,           // u-law[d8] ==> A-law[f6]
    0xf7,           // u-law[d9] ==> A-law[f7]
    0xf4,           // u-law[da] ==> A-law[f4]
    0xf5,           // u-law[db] ==> A-law[f5]
    0xcb,           // u-law[dc] ==> A-law[cb]
    0xc9,           // u-law[dd] ==> A-law[c9]
    0xcf,           // u-law[de] ==> A-law[cf]
    0xcd,           // u-law[df] ==> A-law[cd]
    0xc2,           // u-law[e0] ==> A-law[c2]
    0xc3,           // u-law[e1] ==> A-law[c3]
    0xc0,           // u-law[e2] ==> A-law[c0]
    0xc1,           // u-law[e3] ==> A-law[c1]
    0xc6,           // u-law[e4] ==> A-law[c6]
    0xc7,           // u-law[e5] ==> A-law[c7]
    0xc4,           // u-law[e6] ==> A-law[c4]
    0xc5,           // u-law[e7] ==> A-law[c5]
    0xda,           // u-law[e8] ==> A-law[da]
    0xdb,           // u-law[e9] ==> A-law[db]
    0xd8,           // u-law[ea] ==> A-law[d8]
    0xd9,           // u-law[eb] ==> A-law[d9]
    0xde,           // u-law[ec] ==> A-law[de]
    0xdf,           // u-law[ed] ==> A-law[df]
    0xdc,           // u-law[ee] ==> A-law[dc]
    0xdd,           // u-law[ef] ==> A-law[dd]
    0xd2,           // u-law[f0] ==> A-law[d2]
    0xd2,           // u-law[f1] ==> A-law[d2]
    0xd3,           // u-law[f2] ==> A-law[d3]
    0xd3,           // u-law[f3] ==> A-law[d3]
    0xd0,           // u-law[f4] ==> A-law[d0]
    0xd0,           // u-law[f5] ==> A-law[d0]
    0xd1,           // u-law[f6] ==> A-law[d1]
    0xd1,           // u-law[f7] ==> A-law[d1]
    0xd6,           // u-law[f8] ==> A-law[d6]
    0xd6,           // u-law[f9] ==> A-law[d6]
    0xd7,           // u-law[fa] ==> A-law[d7]
    0xd7,           // u-law[fb] ==> A-law[d7]
    0xd4,           // u-law[fc] ==> A-law[d4]
    0xd4,           // u-law[fd] ==> A-law[d4]
    0xd5,           // u-law[fe] ==> A-law[d5]
    0xd5            // u-law[ff] ==> A-law[d5]
};

//
// This represents the list of standard frequencies which a range would
// normally map to. The table ends in ULONG_MAX, which provides for a
// successful comparison with the "next" value when looking for a range.
// This is sorted from lowest to highest.
//
static const ULONG FrequencyTable[] = {
    8000,
    11025,
    22050,
    44100,
    48000,
    96000,
    ULONG_MAX
};

//
// These contains the types of buffer attributes needed for the various
// kinds of compression/decompress/transform processes available.
//
static const PMTRANSFORMATTRIBUTES CompressionAttrib = {
    PMTRANSFORM_ATTRIB_CANDOINPLACE,
    1,
    FILE_WORD_ALIGNMENT,
    0,
    ULONG_MAX,
    2,
    0,
    ULONG_MAX,
    2,
    1,
    2,
    0
};
static const PMTRANSFORMATTRIBUTES DecompressionAttrib = {
    0,
    1,
    FILE_WORD_ALIGNMENT,
    0,
    ULONG_MAX,
    2,
    0,
    ULONG_MAX,
    2,
    2,
    1,
    0
};
static const PMTRANSFORMATTRIBUTES TransformAttrib = {
    PMTRANSFORM_ATTRIB_CANDOINPLACE,
    1,
    FILE_BYTE_ALIGNMENT,
    0,
    ULONG_MAX,
    1,
    0,
    ULONG_MAX,
    1,
    1,
    1,
    0
};

//
// These define the various ranges available on both ends of the stream.
// they are also used to determine which type of transform attributes to
// return.
//

static const KSDATARANGE_AUDIO PcmDataRange = {
    {
        sizeof(KSDATARANGE_AUDIO),
        0,
        0,
        0,
        STATICGUIDOF(KSDATAFORMAT_TYPE_AUDIO),
        STATICGUIDOF(KSDATAFORMAT_SUBTYPE_PCM),
        STATICGUIDOF(KSDATAFORMAT_SPECIFIER_WAVEFORMATEX)
    },
    2,
    16,
    16,
    1,
    ULONG_MAX
};

static const KSDATARANGE_AUDIO ALawDataRange = {
    {
        sizeof(KSDATARANGE_AUDIO),
        0,
        0,
        0,
        STATICGUIDOF(KSDATAFORMAT_TYPE_AUDIO),
        STATICGUIDOF(KSDATAFORMAT_SUBTYPE_ALAW),
        STATICGUIDOF(KSDATAFORMAT_SPECIFIER_WAVEFORMATEX)
    },
    2,
    8,
    8,
    1,
    ULONG_MAX
};

static const KSDATARANGE_AUDIO MuLawDataRange = {
    {
        sizeof(KSDATARANGE_AUDIO),
        0,
        0,
        0,
        STATICGUIDOF(KSDATAFORMAT_TYPE_AUDIO),
        STATICGUIDOF(KSDATAFORMAT_SUBTYPE_MULAW),
        STATICGUIDOF(KSDATAFORMAT_SPECIFIER_WAVEFORMATEX)
    },
    2,
    8,
    8,
    1,
    ULONG_MAX
};

static const PKSDATARANGE DataRanges[] = {
    const_cast<PKSDATARANGE>(reinterpret_cast<const KSDATARANGE*>(&PcmDataRange)),
    const_cast<PKSDATARANGE>(reinterpret_cast<const KSDATARANGE*>(&ALawDataRange)),
    const_cast<PKSDATARANGE>(reinterpret_cast<const KSDATARANGE*>(&MuLawDataRange))
};

#ifdef ALLOC_DATA_PRAGMA
#pragma const_seg()
#endif // ALLOC_DATA_PRAGMA

#ifdef ALLOC_PRAGMA
#pragma code_seg("PAGE")
#endif // ALLOC_PRAGMA


#ifdef _ANY_
STDMETHODIMP
CMiniPortInstance::PcmToALaw(
#else
extern "C"
NTSTATUS
PcmToALaw(
#endif
    IN PVOID SourceBuffer,
    IN OUT PULONG SourceLength,
    OUT PVOID DestinationBuffer,
    IN OUT PULONG DestinationLength
    )
/*++

Routine Description:

    Performs a PCM to A-Law conversion of a stream. This is used as one of
    the m_Transform values by the mini-port.

Arguments:

    SourceBuffer -
        Points to the source stream to convert.

    SourceLength -
        Contains a pointer to the size in bytes of the source stream,
        and on return should be updated with the actual number of bytes
        used.

    DestinationBuffer -
        Points to the destination buffer for the stream conversion.

    DestinationLength -
        The place in which to put the number of bytes used in the
        destination buffer.

Return Values:

    Returns STATUS_SUCCESS.

--*/
{
    ULONG   cb;
    ULONG   i;
    SHORT   wSample;
    PUSHORT pwSrc;
    BYTE    alaw;
    PBYTE   pbDst;

    //
    // Compression from 16-bit PCM
    //
    cb = *SourceLength;
    pwSrc = (PUSHORT)SourceBuffer;
    pbDst = (PBYTE)DestinationBuffer;
    //
    // Walk thru the source buffer.  Since the source buffer has 16-bit PCM we
    // need to convert cb/2 samples.
    //
    for (i=cb/2; i>0; i--) {
        //
        //  Get a signed 16-bit PCM sample from the src buffer
        //
        wSample = (SHORT)*(pwSrc++);
        //
        // We'll init our A-law value per the sign of the PCM sample.  A-law
        // characters have the MSB=1 for positive PCM data.  Also, we'll
        // convert our signed 16-bit PCM value to it's absolute value and
        // then work on that to get the rest of the A-law character bits.
        //
        if (wSample < 0) {
            alaw = 0x00;
            wSample = -wSample;
           
            if (wSample < 0) {
                wSample = 0x7FFF;
            }
        } else {
            alaw = 0x80;
        }
        //
        // Now we test the PCM sample amplitude and create the A-law character.
        // Study the CCITT A-law for more detail.
        //
        if (wSample >= 2048) {
            // 2048 <= wSample < 32768
            if (wSample >= 8192) {
                // 8192 <= wSample < 32768
                if (wSample >= 16384) {
                    // 16384 <= wSample < 32768
                    alaw |= 0x70 | ((wSample >> 10) & 0x0F);
                } else {
                    // 8192 <= wSample < 16384
                    alaw |= 0x60 | ((wSample >> 9) & 0x0F);
                }
            } else {
                // 2048 <= wSample < 8192
                if (wSample >= 4096) {
                    // 4096 <= wSample < 8192
                    alaw |= 0x50 | ((wSample >> 8) & 0x0F);
                } else {
                    // 2048 <= wSample < 4096
                    alaw |= 0x40 | ((wSample >> 7) & 0x0F);
                }
            }
        } else {
            // 0 <= wSample < 2048
            if (wSample >= 512) {
                // 512 <= wSample < 2048
                if (wSample >= 1024) {
                    // 1024 <= wSample < 2048
                    alaw |= 0x30 | ((wSample >> 6) & 0x0F);
                } else {
                    // 512 <= wSample < 1024
                    alaw |= 0x20 | ((wSample >> 5) & 0x0F);
                }
            } else {
                // 0 <= wSample < 512
                alaw |= 0x00 | ((wSample >> 4) & 0x1F);
            }
        }
        *(pbDst++) = alaw ^ 0x55;      // Invert even bits
    }
    *DestinationLength = cb / 2;
    return STATUS_SUCCESS;
}


#ifdef _ANY_
STDMETHODIMP
CMiniPortInstance::ALawToPcm(
#else
extern "C"
NTSTATUS
ALawToPcm(
#endif
    IN PVOID SourceBuffer,
    IN OUT PULONG SourceLength,
    OUT PVOID DestinationBuffer,
    IN OUT PULONG DestinationLength
    )
/*++

Routine Description:

    Performs an A-Law to PCM conversion of a stream. This is used as one of
    the m_Transform values by the mini-port.

Arguments:

    SourceBuffer -
        Points to the source stream to convert.

    SourceLength -
        Contains a pointer to the size in bytes of the source stream,
        and on return should be updated with the actual number of bytes
        used.

    DestinationBuffer -
        Points to the destination buffer for the stream conversion.

    DestinationLength -
        The place in which to put the number of bytes used in the
        destination buffer.

Return Values:

    Returns STATUS_SUCCESS.

--*/
{
    PWORD   pwDst;
    PBYTE   pbSrc;
    DWORD   cb;
    DWORD   cSamples;
    DWORD   i;

    cb = *SourceLength;
    pbSrc = (PBYTE)SourceBuffer;
    pwDst = (PWORD)DestinationBuffer;
    for ( i=cb; i>0; i--) {
        *(pwDst++) = AlawToPcmTable[*(pbSrc++)];
    }
    *DestinationLength = cb * 2;
    return STATUS_SUCCESS;
}


#ifdef _ANY_
STDMETHODIMP
CMiniPortInstance::PcmToMuLaw(
#else
extern "C"
NTSTATUS
PcmToMuLaw(
#endif
    IN PVOID SourceBuffer,
    IN OUT PULONG SourceLength,
    OUT PVOID DestinationBuffer,
    IN OUT PULONG DestinationLength
    )
/*++

Routine Description:

    Performs a PCM to Mu-Law conversion of a stream. This is used as one of
    the m_Transform values by the mini-port.

Arguments:

    SourceBuffer -
        Points to the source stream to convert.

    SourceLength -
        Contains a pointer to the size in bytes of the source stream,
        and on return should be updated with the actual number of bytes
        used.

    DestinationBuffer -
        Points to the destination buffer for the stream conversion.

    DestinationLength -
        The place in which to put the number of bytes used in the
        destination buffer.

Return Values:

    Returns STATUS_SUCCESS.

--*/
{
    PUSHORT pwSrc;
    PBYTE   pbDst;
    ULONG   cb;
    ULONG   cSamples;
    ULONG   i;
    SHORT   wSample;
    BYTE    ulaw;
    
    //
    // For now we are using a straight-forward/brute-force method
    // for converting from 16-bit PCM to u-law.  This can probably
    // be made more efficient if some thought is put into it...
    //
    cb = *SourceLength;
    pwSrc = (PUSHORT)SourceBuffer;
    pbDst = (PBYTE)DestinationBuffer;
    //
    // Handle compression from 16-bit PCM
    //
    // Walk thru the source buffer.  Since the source buffer has 16-bit PCM we
    // need to convert cb/2 samples.
    for (i=cb/2; i>0; i--) {
        //
        // Get a signed 16-bit PCM sample from the src buffer
        //
        wSample = (SHORT)*(pwSrc++);
        //
        // We'll init our u-law value per the sign of the PCM sample.  u-law
        // characters have the MSB=1 for positive PCM data.  Also, we'll
        // convert our signed 16-bit PCM value to it's absolute value and
        // then work on that to get the rest of the u-law character bits.
        //
        if (wSample < 0) {
            ulaw = 0x00;
            wSample = -wSample;
            if (wSample < 0){
                wSample = 0x7FFF;
            }
        } else {
            ulaw = 0x80;
        }
        //
        // For now, let's shift this 16-bit value
        // so that it is within the range defined
        // by CCITT u-law.
        //
        wSample = wSample >> 2;
        //
        // Now we test the PCM sample amplitude and create the u-law character.
        // Study the CCITT u-law for more details.
        //
        if (wSample < 8159) {
            if (wSample >= 4063) {
                ulaw |= 0x00 + 15-((wSample-4063)/256);
            } else if (wSample >= 2015) {
                ulaw |= 0x10 + 15-((wSample-2015)/128);
            } else if (wSample >= 991) {
                ulaw |= 0x20 + 15-((wSample-991)/64);
            } else if (wSample >= 479) {
                ulaw |= 0x30 + 15-((wSample-479)/32);
            } else if (wSample >= 223) {
                ulaw |= 0x40 + 15-((wSample-223)/16);
            } else if (wSample >= 95) {
                ulaw |= 0x50 + 15-((wSample-95)/8);
            } else if (wSample >= 31) {
                ulaw |= 0x60 + 15-((wSample-31)/4);
            } else {
                ulaw |= 0x70 + 15-((wSample)/2);
            }
        }        
        *(pbDst++) = ulaw;
    }
    *DestinationLength = cb / 2;
    return STATUS_SUCCESS;
}


#ifdef _ANY_
STDMETHODIMP
CMiniPortInstance::MuLawToPcm(
#else
extern "C"
NTSTATUS
MuLawToPcm(
#endif
    IN PVOID SourceBuffer,
    IN OUT PULONG SourceLength,
    OUT PVOID DestinationBuffer,
    IN OUT PULONG DestinationLength
    )
/*++

Routine Description:

    Performs a Mu-Law to PCM conversion of a stream. This is used as one of
    the m_Transform values by the mini-port.

Arguments:

    SourceBuffer -
        Points to the source stream to convert.

    SourceLength -
        Contains a pointer to the size in bytes of the source stream,
        and on return should be updated with the actual number of bytes
        used.

    DestinationBuffer -
        Points to the destination buffer for the stream conversion.

    DestinationLength -
        The place in which to put the number of bytes used in the
        destination buffer.

Return Values:

    Returns STATUS_SUCCESS.

--*/
{
    PWORD   pwDst;
    PBYTE   pbSrc;
    DWORD   cb;
    DWORD   cSamples;
    DWORD   i;

    cb = *SourceLength;
    pbSrc = (PBYTE)SourceBuffer;
    pwDst = (PWORD)DestinationBuffer;
    for ( i=cb; i>0; i--) {
        *(pwDst++) = UlawToPcmTable[*(pbSrc++)];
    }
    *DestinationLength = cb * 2;
    return STATUS_SUCCESS;
}


#ifdef _ANY_
STDMETHODIMP
CMiniPortInstance::ALawToMuLaw(
#else
extern "C"
NTSTATUS
ALawToMuLaw(
#endif
    IN PVOID SourceBuffer,
    IN OUT PULONG SourceLength,
    OUT PVOID DestinationBuffer,
    IN OUT PULONG DestinationLength
    )
/*++

Routine Description:

    Performs an A-Law to Mu-Law conversion of a stream. This is used as one of
    the m_Transform values by the mini-port.

Arguments:

    SourceBuffer -
        Points to the source stream to convert.

    SourceLength -
        Contains a pointer to the size in bytes of the source stream,
        and on return should be updated with the actual number of bytes
        used.

    DestinationBuffer -
        Points to the destination buffer for the stream conversion.

    DestinationLength -
        The place in which to put the number of bytes used in the
        destination buffer.

Return Values:

    Returns STATUS_SUCCESS.

--*/
{
    PBYTE   pbSrc;
    PBYTE   pbDst;
    DWORD   cb;
    DWORD   i;

    cb = *SourceLength;
    pbSrc = (PBYTE)SourceBuffer;
    pbDst = (PBYTE)DestinationBuffer;
    for (i=cb; i>0; i--) {
        *(pbDst++) = AlawToUlawTable[*(pbSrc++)];
    }
    *DestinationLength = cb;
    return STATUS_SUCCESS;
}


#ifdef _ANY_
STDMETHODIMP
CMiniPortInstance::MuLawToALaw(
#else
extern "C"
NTSTATUS
MuLawToALaw(
#endif
    IN PVOID SourceBuffer,
    IN OUT PULONG SourceLength,
    OUT PVOID DestinationBuffer,
    IN OUT PULONG DestinationLength
    )
/*++

Routine Description:

    Performs a Mu-Law to A-Law conversion of a stream. This is used as one of
    the m_Transform values by the mini-port.

Arguments:

    SourceBuffer -
        Points to the source stream to convert.

    SourceLength -
        Contains a pointer to the size in bytes of the source stream,
        and on return should be updated with the actual number of bytes
        used.

    DestinationBuffer -
        Points to the destination buffer for the stream conversion.

    DestinationLength -
        The place in which to put the number of bytes used in the
        destination buffer.

Return Values:

    Returns STATUS_SUCCESS.

--*/
{
    PBYTE   pbSrc;
    PBYTE   pbDst;
    DWORD   cb;
    DWORD   i;

    cb = *SourceLength;
    pbSrc = (PBYTE)SourceBuffer;
    pbDst = (PBYTE)DestinationBuffer;
    for (i=cb; i>0; i--) {
        *(pbDst++) = UlawToAlawTable[*(pbSrc++)];
    }
    *DestinationLength = cb;
    return STATUS_SUCCESS;
}


CMiniPort::CMiniPort(
    IN REFGUID ReferenceId,
    IN IUnknown* UnkOuter OPTIONAL,
    OUT NTSTATUS* Status
    ) :
    CBaseUnknown(
        UnkOuter)
/*++

Routine Description:

    The constructor for this object class. Initializes the object.

Arguments:

    ReferenceId -
        Contains MiniPortClass.

    UnkOuter -
        Optionally contains the outer IUnknown to use when querying
        for interfaces.

    Status -
        The place in which to put the final status of initialization.

Return Values:

    Returns a pointer to the object.

--*/
{
    PAGED_CODE();
    _DbgPrintF(DEBUGLVL_TERSE, ("CMiniPort"));
    //
    // Member variables are initialized to zero by the new operator.
    //
    *Status = STATUS_SUCCESS;
}


CMiniPort::~CMiniPort(
    )
/*++

Routine Description:

    The destructor for this object class.

Arguments:

    None.

Return Values:

    Nothing.

--*/
{
    PAGED_CODE();
    _DbgPrintF(DEBUGLVL_TERSE, ("~CMiniPort"));
}


STDMETHODIMP
CMiniPort::NonDelegatedQueryInterface(
    IN REFIID InterfaceId,
    OUT PVOID* Interface
    )
/*++

Routine Description:

    Overrides CBaseUnknown::NonDelegatedQueryInterface. Queries for the specified
    interface, and increments the reference count on the object.

Arguments:

    InterfaceId -
        The identifier of the interface to return.

    Interface -
        The place in which to put the interface being returned.

Return Values:

    Returns STATUS_SUCCESS if the interface requested is supported, else
    STATUS_NO_INTERFACE.

--*/
{
    PAGED_CODE();
    //
    // Other interfaces are supported here, and just use AddRef().
    // IUnknown is not directly supported through this method, only
    // through the CBaseUnknown::NonDelegatedQueryInterface. This
    // means that if aggregated, the reference count on this object
    // is only incremented through a query on IUnknown, which would
    // only be performed by the owning object. All other reference
    // counting is passed back to the owning object in that scenario.
    //
    if (InterfaceId == __uuidof(IPmMiniPort)) {
        *Interface = reinterpret_cast<PVOID>(static_cast<IPmMiniPort*>(this));
    } else {
        return CBaseUnknown::NonDelegatedQueryInterface(InterfaceId, Interface);
    }
    AddRef();
    return STATUS_SUCCESS;
}


IMPLEMENT_STD_UNKNOWN(CMiniPort)


STDMETHODIMP
CMiniPort::InitializeMiniPort(
    IN PDEVICE_OBJECT DeviceObject,
    IN IUnknown* UnkPort
    )
/*++

Routine Description:

    Implements IPmMiniPort::InitializeMiniPort. This allows the mini-port to
    add set extensions during initialization to the port instance, and perform
    other initialization.

Arguments:

    DeviceObject -
        Contains the device object associated with the mini-port.

    UnkPort -
        Contains an IUnknown to the port attached to this mini-port instance.
        Although interfaces can be queried from this object, the mini-port
        must not leave a reference count on the port.

Return Values:

    Returns STATUS_SUCCESS if the mini-port was initialized.

--*/
{
    IPmRegisterMiniTransform*   MiniTransform;
    NTSTATUS                    Status;
#if 0
    KSCOMPONENTID               Component;
#endif
    PMSIMPLECONNECTOR           Connector;

    //
    // Save the port, but do not reference it, as the port has a reference
    // on the mini-port.
    //
    m_UnkPort = UnkPort;
    //
    // Register the information about the mini-port by using the
    // port-specific registration interface.
    //
    Status = m_UnkPort->QueryInterface(
        __uuidof(IPmRegisterMiniTransform),
        reinterpret_cast<PVOID*>(&MiniTransform));
    if (!NT_SUCCESS(Status)) {
        return Status;
    }
#if 0
    Status = MiniTransform->ComponentDescription(&Component, 0);
#endif
    Connector.DataRangesCount =  SIZEOF_ARRAY(DataRanges);
    Connector.DataRanges = const_cast<PKSDATARANGE*>(DataRanges);
    Connector.Category = NULL;
    Connector.Name = NULL;
    //
    // This transform can convert from any of the listed inputs formats
    // to any of the listed output formats, so the support is the same
    // for both input and output.
    Status = MiniTransform->PinDescriptors(&Connector, &Connector);
    MiniTransform->Release();

//!!set up added sets

    return Status;
}


STDMETHODIMP
CMiniPort::CreateMiniPortInstance(
    IN IUnknown* UnkPortInstance,
    OUT IUnknown** UnkMiniInstance
    )
/*++

Routine Description:

    Implements IPmMiniPort::CreateMiniPortInstance. Opens the mini-port instance
    for file I/O. This is called from in response to an IRP_MJ_CREATE being sent
    to the port create handler.

Arguments:

    UnkPortInstance -
        Contains an IUnknown interface on the port instance which will be
        associated with this mini-port instance.

    UnkMiniInstance -
        The place in which to return the AddRef'd interface on the mini-port
        instance.

Return Values:

    Returns STATUS_SUCCESS if the instance was created.

--*/
{
    CMiniPortInstance*  MiniPortInstance;
    NTSTATUS            Status;

    PAGED_CODE();
    MiniPortInstance = new(PagedPool, MINIPORTINSTANCE_TAG) CMiniPortInstance(NULL, this, UnkPortInstance, &Status);
    if (MiniPortInstance) {
        //
        // The object was allocated, but initialization may have
        // failed.
        //
        if (NT_SUCCESS(Status)) {
            //
            // Add a reference count to the mini-port instance.
            //
            MiniPortInstance->NonDelegatedQueryInterface(
                __uuidof(*UnkMiniInstance),
                reinterpret_cast<PVOID*>(UnkMiniInstance));
        } else {
            //
            // Object initialization failed. Just delete the
            // object without calling Release().
            //
            delete MiniPortInstance;
        }
    } else {
        //
        // The mini-port instance could not be allocated.
        //
        Status = STATUS_INSUFFICIENT_RESOURCES;
    }
    return Status;
}


CMiniPortInstance::CMiniPortInstance(
    IN IUnknown* UnkOuter OPTIONAL,
    IN CMiniPort* MiniPort,
    IN IUnknown* UnkPortInstance,
    OUT NTSTATUS* Status
    ) :
    CBaseUnknown(UnkOuter),
    m_MiniPort(MiniPort),
    m_UnkPortInstance(UnkPortInstance)
/*++

Routine Description:

    The constructor for this object class. Initializes the object.

Arguments:

    UnkOuter -
        Optionally contains an outer IUnknown.

    MiniPort -
        Contains the mini port object from which this request came.

    UnkPortInstance -
        Contains the IUnknown of the port instance which is attached to
        this mini-port.

    Status -
        The place in which to put the final status of initialization.

Return Values:

    Returns a pointer to the object.

--*/
{
    PAGED_CODE();
    _DbgPrintF(DEBUGLVL_TERSE, ("CMiniPortInstance"));
    //
    // Member variables are initialized to zero by the new operator.
    //
    *Status = STATUS_SUCCESS;
}


CMiniPortInstance::~CMiniPortInstance(
    )
/*++

Routine Description:

    The destructor for this object class.

Arguments:

    None.

Return Values:

    Nothing.

--*/
{
    PAGED_CODE();
    if (m_StreamFormat[KSPIN_DATAFLOW_IN - 1]) {
        ExFreePool(m_StreamFormat[KSPIN_DATAFLOW_IN - 1]);
    }
    if (m_StreamFormat[KSPIN_DATAFLOW_OUT - 1]) {
        ExFreePool(m_StreamFormat[KSPIN_DATAFLOW_OUT - 1]);
    }
    _DbgPrintF(DEBUGLVL_TERSE, ("~CMiniPortInstance"));
}


STDMETHODIMP
CMiniPortInstance::NonDelegatedQueryInterface(
    IN REFIID InterfaceId,
    OUT PVOID* Interface
    )
/*++

Routine Description:

    Overrides CBaseUnknown::NonDelegatedQueryInterface. Queries for the specified
    interface, and increments the reference count on the object.

Arguments:

    InterfaceId -
        The identifier of the interface to return.

    Interface -
        The place in which to put the interface being returned.

Return Values:

    Returns STATUS_SUCCESS if the interface requested is supported, else
    STATUS_NO_INTERFACE.

--*/
{
    PAGED_CODE();
    //
    // Other interfaces are supported here, and just use AddRef().
    // IUnknown is not directly supported through this method, only
    // through the CBaseUnknown::NonDelegatedQueryInterface. This
    // means that if aggregated, the reference count on this object
    // is only incremented through a query on IUnknown, which would
    // only be performed by the owning object. All other reference
    // counting is passed back to the owning object in that scenario.
    //
    if (InterfaceId == __uuidof(IPmMiniTransform)) {
        *Interface = reinterpret_cast<PVOID>(static_cast<IPmMiniTransform*>(this));
    } else {
        return CBaseUnknown::NonDelegatedQueryInterface(InterfaceId, Interface);
    }
    AddRef();
    return STATUS_SUCCESS;
}


IMPLEMENT_STD_UNKNOWN(CMiniPortInstance)


STDMETHODIMP
CMiniPortInstance::QueryTransformAttributes(
    IN KSPIN_DATAFLOW DataFlow,
    OUT PPMTRANSFORMATTRIBUTES TransformAttributes
    )
/*++

Routine Description:

    Implements IPmMiniTransform::QueryTransformAttributes. This is called by
    the port driver in response to queries on allocator attributes. This is
    synchronized with any connection requests.

Arguments:

    DataFlow -
        Contains either KSPIN_DATAFLOW_IN or KSPIN_DATAFLOW_OUT, indicating
        which end of the stream is being queried.

    TransformAttributes -
        The place in which to return the transform attributes.

Return Values:

    Returns STATUS_SUCCESS.

--*/
{
    //
    // These attributes are set up during IPmMiniTransform::InitializeStream.
    //
    *TransformAttributes = *m_TransformAttributes[DataFlow - 1];
    return STATUS_SUCCESS;
}


STDMETHODIMP
CMiniPortInstance::InitializeStream(
    IN KSPIN_DATAFLOW DataFlow,
    IN IUnknown* UnkStream OPTIONAL
    )
/*++

Routine Description:

    Implements IPmMiniTransform::InitializeStream. This is called by the
    port driver while attaching the input or output stream instance to the
    mini-port instance. It also may be called when detaching the stream
    instance in order to reset the format. This is synchronized with any
    call to IPmMiniTransform::DataIntersect.

Arguments:

    DataFlow -
        Contains either KSPIN_DATAFLOW_IN or KSPIN_DATAFLOW_OUT, indicating
        which end of the stream is being initalized.

    UnkStream -
        Optionally contains the provider of the stream data format and stream
        instance information. Any current information is to be discarded before
        applying the new information. If this is NULL no new information is to
        be applied.

Return Values:

    Returns STATUS_SUCCESS if the instance was initialized.

--*/
{
    NTSTATUS    Status;

    //
    // Capture the provider of the stream data format, but do not reference it.
    //
    m_UnkStream[DataFlow - 1] = UnkStream;
    //
    // Capture the data format, discarding any previous format. If the
    // IUnknown is NULL, any current format will be discarded without
    // capturing a new format.
    //
    Status = PmResetDataFormat(UnkStream, reinterpret_cast<PKSDATAFORMAT*>(&m_StreamFormat[DataFlow - 1]));
    if (!NT_SUCCESS(Status)) {
        return Status;
    }
    //
    // Validate the format.
    //
    if (UnkStream) {
        PKSDATAFORMAT_WAVEFORMATEX  NewFormat;
        PKSDATAFORMAT_WAVEFORMATEX  StreamFormat;
        ULONG                       Ranges;

        NewFormat = m_StreamFormat[DataFlow - 1];
        for (Ranges = 0;; Ranges++) {
            const KSDATARANGE_AUDIO*    CurRange;

            if (Ranges == SIZEOF_ARRAY(DataRanges)) {
                PmResetDataFormat(NULL, reinterpret_cast<PKSDATAFORMAT*>(&m_StreamFormat[DataFlow - 1]));
                return STATUS_NO_MATCH;
            }
            CurRange = reinterpret_cast<const KSDATARANGE_AUDIO*>(DataRanges[Ranges]);
            if (NewFormat->DataFormat.SubFormat == CurRange->DataRange.SubFormat) {
                //
                // Sample frequency does not matter.
                //
                if ((NewFormat->WaveFormatEx.wFormatTag != EXTRACT_WAVEFORMATEX_ID(&NewFormat->DataFormat.SubFormat)) ||
                    (NewFormat->WaveFormatEx.nChannels > CurRange->MaximumChannels) ||
                    (NewFormat->WaveFormatEx.wBitsPerSample != CurRange->MaximumBitsPerSample) ||
                    NewFormat->WaveFormatEx.cbSize) {
                    PmResetDataFormat(NULL, reinterpret_cast<PKSDATAFORMAT*>(&m_StreamFormat[DataFlow - 1]));
                    return STATUS_NO_MATCH;
                }
                //
                // Found the range. There is only a single SubFormat of each
                // type, so the first one found must be correct. Save the
                // range pointer so that it can be used to determine what the
                // filter is actually doing.
                //
                m_StreamRange[DataFlow - 1] = CurRange;
                break;
            }
        }
        //
        // If there already is a stream format for the other end of the
        // stream, verify that it is compatible.
        //
        StreamFormat = m_StreamFormat[(DataFlow - 1) ^ 1];
        //
        // The SubFormat cannot be identical since a transform must
        // occur, and the number of channels must match.
        //
        if (StreamFormat && ((StreamFormat->DataFormat.SubFormat == NewFormat->DataFormat.SubFormat) ||
            (StreamFormat->WaveFormatEx.nChannels != NewFormat->WaveFormatEx.nChannels))) {
            PmResetDataFormat(NULL, reinterpret_cast<PKSDATAFORMAT*>(&m_StreamFormat[DataFlow - 1]));
            return STATUS_NO_MATCH;
        }
        //
        // These are just calculated items, and there is no reason to believe
        // a client can get it right.
        //
        NewFormat->WaveFormatEx.nBlockAlign = (NewFormat->WaveFormatEx.wBitsPerSample / 8) <<
            (NewFormat->WaveFormatEx.nChannels >> 1);
        NewFormat->WaveFormatEx.nAvgBytesPerSec = NewFormat->WaveFormatEx.nSamplesPerSec *
            NewFormat->WaveFormatEx.nBlockAlign;
        //
        // If both ends of the stream have been initialized, determine which
        // conversion function to use. Also determine which transform attibutes
        // to return from a query.
        //
        if (StreamFormat) {
            const KSDATARANGE_AUDIO*    StreamRange;

            //
            // Retrieve the range which matched for the connection on the other
            // end of the of the stream. This pointer can be used to determine
            // what type of conversion is happening based on which range was
            // used. This then determines the type of transform, and therefore
            // which attributes to set.
            //
            StreamRange = m_StreamRange[(DataFlow - 1) ^ 1];
            if (m_StreamRange[DataFlow - 1] == &PcmDataRange) {
                m_TransformAttributes[DataFlow - 1] = &CompressionAttrib;
                m_TransformAttributes[(DataFlow - 1) ^ 1] = &DecompressionAttrib;
                if (StreamRange == &ALawDataRange) {
                    m_Transform = PcmToALaw;
                } else {
                    m_Transform = PcmToMuLaw;
                }
            } else if (m_StreamRange[DataFlow - 1] == &ALawDataRange) {
                if (StreamRange == &PcmDataRange) {
                    m_TransformAttributes[DataFlow - 1] = &DecompressionAttrib;
                    m_TransformAttributes[(DataFlow - 1) ^ 1] = &CompressionAttrib;
                    m_Transform = ALawToPcm;
                } else {
                    m_TransformAttributes[DataFlow - 1] = &TransformAttrib;
                    m_TransformAttributes[(DataFlow - 1) ^ 1] = &TransformAttrib;
                    m_Transform = ALawToMuLaw;
                }
            } else if (m_StreamRange[DataFlow - 1] == &MuLawDataRange) {
                if (StreamRange == &PcmDataRange) {
                    m_TransformAttributes[DataFlow - 1] = &DecompressionAttrib;
                    m_TransformAttributes[(DataFlow - 1) ^ 1] = &CompressionAttrib;
                    m_Transform = MuLawToPcm;
                } else {
                    m_TransformAttributes[DataFlow - 1] = &TransformAttrib;
                    m_TransformAttributes[(DataFlow - 1) ^ 1] = &TransformAttrib;
                    m_Transform = MuLawToALaw;
                }
            }
        }
    }
    return STATUS_SUCCESS;
}


STDMETHODIMP
CMiniPortInstance::DataIntersect(
    IN KSPIN_DATAFLOW DataFlow,
    IN PKSDATARANGE DataRange,
    IN OUT PULONG DataLength,
    OUT PKSDATAFORMAT Data OPTIONAL
    )
/*++

Routine Description:

    Implements IPmMiniTransform::DataIntersect. This is called by the
    port driver while processing a data intersection request. This is
    synchronized with any call to IPmMiniTransform::InitializeStream.

    This intersect method will only be called when a match of a data
    range in the previously registered connection information is found.
    This includes matches based on wildcards. Therefore the major, minor,
    and format types will have already been validated.

Arguments:

    DataFlow -
        Contains either KSPIN_DATAFLOW_IN or KSPIN_DATAFLOW_OUT, indicating
        which end of the stream is being queried.

    DataRange -
        Contains the data range to perform a data intersection on with
        the data range list used by this filter.

    DataLength -
        Contains a pointer to the size of the Data buffer parameter, and
        is updated with the size of the buffer used on successful return.
        If this is set to zero on entry, only the necessary size is to be
        returned.

    Data -
        Optionally contains a buffer in which to place the resulting data
        format. If DataLength is set to zero on entry, this buffer is NULL,
        and is not used.

Return Values:

    Returns STATUS_SUCCESS if a data format is returned, STATUS_BUFFER_OVERFLOW
    if the length needed is returned, else STATUS_NO_MATCH if the range did not
    intersect any data range in the list for this stream, or STATUS_BUFFER_TOO_SMALL
    if a match was found, but the buffer provided was not large enough to
    return the data format.

--*/
{
    PKSDATAFORMAT_WAVEFORMATEX  StreamFormat;
    PKSDATARANGE_AUDIO          TestRange;
    ULONG                       Ranges;

//!!deal with extensible waveformat.
    //
    // In order to make the size query fast, just do this first, even
    // though the documentation says that the range should be validated
    // first.
    //
    if (!*DataLength) {
        *DataLength = sizeof(KSDATAFORMAT_WAVEFORMATEX);
        return STATUS_BUFFER_OVERFLOW;
    } else if (*DataLength < sizeof(KSDATAFORMAT_WAVEFORMATEX)) {
        return STATUS_BUFFER_TOO_SMALL;
    }
    //
    // Acquire the current format of the opposite end of the stream, if any.
    // If there is a format, then this will restrict the range.
    //
    StreamFormat = m_StreamFormat[(DataFlow - 1) ^ 1];
    //
    // All ranges are the same size, so this must match. The sample size
    // is variable, and therefore must be zero.
    //
    if ((DataRange->FormatSize != sizeof(*TestRange)) || DataRange->SampleSize) {
        return STATUS_NO_MATCH;
    }
    TestRange = reinterpret_cast<PKSDATARANGE_AUDIO>(DataRange);
    //
    // Validate the ranges specified are really ranges.
    //
    if (!TestRange->MaximumChannels ||
        (TestRange->MinimumBitsPerSample > TestRange->MaximumBitsPerSample) ||
        (TestRange->MinimumSampleFrequency > TestRange->MaximumSampleFrequency)) {
        return STATUS_NO_MATCH;
    }
    //
    // If there is a format on the opposite end of the stream, then
    // validate this range includes that format's channels and frequency.
    // 
    if (StreamFormat && ((TestRange->MaximumChannels < StreamFormat->WaveFormatEx.nChannels) ||
        (TestRange->MaximumSampleFrequency < StreamFormat->WaveFormatEx.nSamplesPerSec) ||
        (TestRange->MinimumSampleFrequency > StreamFormat->WaveFormatEx.nSamplesPerSec))) {
        return STATUS_NO_MATCH;
    }
    //
    // The channel maximum and frequency range is the same for all formats,
    // so it need not be checked against any current format on the other
    // end of the stream. This only checks that the intersection produces
    // a non-NULL set.
    //
    if ((TestRange->MaximumSampleFrequency < PcmDataRange.MinimumSampleFrequency) &&
        (TestRange->MinimumSampleFrequency > PcmDataRange.MaximumSampleFrequency)) {
        return STATUS_NO_MATCH;
    }
    //
    // Find the first Audio range the proposed range intersects with, possibly
    // further restricted by any current format on the opposite end of the stream.
    // The additional restrictions would be Channels and Samples/Second intersecting
    // with the format.
    //
    for (Ranges = 0;; Ranges++) {
        const KSDATARANGE_AUDIO*    CurRange;

        if (Ranges == SIZEOF_ARRAY(DataRanges)) {
            return STATUS_NO_MATCH;
        }
        CurRange = reinterpret_cast<const KSDATARANGE_AUDIO*>(DataRanges[Ranges]);
        //
        // If there is a format on the other end of the stream, then the
        // SubFormat cannot match this range's SubFormat, since a conversion
        // must always be from one type to another.
        //
        if (StreamFormat && (StreamFormat->DataFormat.SubFormat == CurRange->DataRange.SubFormat)) {
            continue;
        }
        //
        // The MajorFormat and Specifier are the same for all ranges. Only the
        // SubFormat need be matched.
        //
        if ((CurRange->DataRange.SubFormat == TestRange->DataRange.SubFormat) ||
            (TestRange->DataRange.SubFormat == KSDATAFORMAT_SUBTYPE_WILDCARD)) {
            //
            // Ensure that the intersection produces a non-NULL set with this
            // data range in terms of Bits/Sample, which varies for each range.
            //
            if ((TestRange->MaximumBitsPerSample > CurRange->MinimumBitsPerSample) ||
                (TestRange->MinimumBitsPerSample < CurRange->MaximumBitsPerSample)) {
                PKSDATAFORMAT_WAVEFORMATEX  AudioFormat;

                //
                // Fill in the audio format and exit with STATUS_SUCCESS.
                //
                AudioFormat = reinterpret_cast<PKSDATAFORMAT_WAVEFORMATEX>(Data);
                AudioFormat->DataFormat = CurRange->DataRange;
                AudioFormat->WaveFormatEx.wFormatTag = EXTRACT_WAVEFORMATEX_ID(&CurRange->DataRange.SubFormat);
                if (StreamFormat) {
                    //
                    // Since the other end of the stream has a format, everything
                    // is already determined. It is either copied from the format
                    // selected, or from the current data range.
                    //
                    AudioFormat->WaveFormatEx.nChannels = StreamFormat->WaveFormatEx.nChannels;
                    AudioFormat->WaveFormatEx.nSamplesPerSec = StreamFormat->WaveFormatEx.nSamplesPerSec;
                    AudioFormat->WaveFormatEx.wBitsPerSample = static_cast<USHORT>(TestRange->MaximumBitsPerSample);
                } else {
                    //
                    // There is no stream format, so only the current data range
                    // provides any limitations.
                    //
                    AudioFormat->WaveFormatEx.nChannels = static_cast<USHORT>(min(TestRange->MaximumChannels, CurRange->MaximumChannels));
                    //
                    // Map the given frequency range to something more standard.
                    // Maximize the frequency produced. There is no need to bound
                    // this by the current range, since frequency has an infinite
                    // degree of freedom, and is only bounded by the range passed.
                    //
                    // A mapping will always be found, and the table is non-zero.
                    //
                    for (Ranges = 0;; Ranges++) {
                        if (Ranges == SIZEOF_ARRAY(FrequencyTable) - 1) {
                            //
                            // Skip the last entry, since it is just a filler.
                            // Give up and just use the maximum provided in the
                            // range, since there is nothing within the range
                            // which can map to a standard value.
                            //
                            AudioFormat->WaveFormatEx.nSamplesPerSec = TestRange->MaximumSampleFrequency;
                            break;
                        }
                        //
                        // If the range overlaps the current table entry, and
                        // does not reach the next entry, then use this entry,
                        // else push on to the next higher frequency.
                        //
                        if ((TestRange->MinimumSampleFrequency <= FrequencyTable[Ranges]) &&
                            (TestRange->MaximumSampleFrequency < FrequencyTable[Ranges + 1])) {
                            AudioFormat->WaveFormatEx.nSamplesPerSec = FrequencyTable[Ranges];
                            break;
                        }
                    }
                    AudioFormat->WaveFormatEx.wBitsPerSample = static_cast<USHORT>(CurRange->MaximumBitsPerSample);
                }
                //
                // These are just calculated items.
                //
                AudioFormat->WaveFormatEx.nBlockAlign = (AudioFormat->WaveFormatEx.wBitsPerSample / 8) <<
                    (AudioFormat->WaveFormatEx.nChannels >> 1);
                AudioFormat->WaveFormatEx.nAvgBytesPerSec = AudioFormat->WaveFormatEx.nSamplesPerSec *
                    AudioFormat->WaveFormatEx.nBlockAlign;
                //
                // No extra data in the format block.
                //
                AudioFormat->WaveFormatEx.cbSize = 0;
                //
                // Return STATUS_SUCCESS.
                //
                break;
            }
            //
            // If the SubFormat is not a wildcard, then this should be exiting,
            // but that would be another check for the error case, rather than
            // assuming eventual success.
            //
        }
    }
    return STATUS_SUCCESS;
}


STDMETHODIMP
CMiniPortInstance::DeliverTransformPacket(
    IN IPmBasicPacket* TransformPacket
    )
/*++

Routine Description:

    Implements IPmMiniTransform::DeliverTransformPacket. Performs the data
    transform.

Arguments:

    TransformPacket -
        Contains the interface to the packet being delivered.

Return Values:

    Returns STATUS_SUCCESS if the transform was successful, else an error.

--*/
{
    NTSTATUS    Status;
    PVOID       SourceBuffer;
    PVOID       DestinationBuffer;
    ULONG       SourceLength;
    ULONG       DestinationLength;

    TransformPacket->GetPacketInfo(
        &SourceBuffer,
        &SourceLength,
        &DestinationBuffer,
        &DestinationLength);
    //
    // The specific transform was set up when initializing the stream.
    //
#ifdef _ANY_
    Status = (this->*m_Transform)(SourceBuffer, &SourceLength, DestinationBuffer, &DestinationLength);
#else
    Status = m_Transform(SourceBuffer, &SourceLength, DestinationBuffer, &DestinationLength);
#endif
    //
    // If the transform was successful, then set the actual sizes used.
    //
    if (NT_SUCCESS(Status)) {
        TransformPacket->SetPacketInfo(SourceLength, DestinationLength);
    }
    return Status;
}


extern "C"
NTSTATUS
CreateHandler(
    IN PDEVICE_OBJECT DeviceObject,
    IN REFCLSID ClassId
    )
/*++

Routine Description:

    When a new device is detected, PnP the AddDevice entry point, which
    has been set to use the KPORT default entry. That entry uses PmCreateDevice
    to create a default FDO and attach it to the PDO. PnP then sends a Start
    Device, which spawns a thread to handle it asynchronously. During the handling,
    this entry point is called, which was set up during the PmDriverInitialize.

Arguments:

    DeviceObject -
        Pointer to the functional device object.

    ClassId -
        Contains the reference Guid. This module only supports a single type
        of object, so this is not really used.

Return Values:

    STATUS_SUCCESS or an appropriate error condition.

--*/
{
    NTSTATUS        Status;
    CMiniPort*      MiniPort;

    //
    // Distinguish which type of object is being created, a compressor
    // or a decompressor. Ensure the query is sent to the top of the
    // current stack, in case there is some stack filter is inserted.
    //
    MiniPort = new(PagedPool, MINIPORT_TAG) CMiniPort(ClassId, NULL, &Status);
    if (MiniPort) {
        //
        // The object was allocated, but initialization may have
        // failed.
        //
        if (NT_SUCCESS(Status)) {
            IUnknown*   UnkMiniPort;

            //
            // Add a reference count to the mini-port instance.
            //
            MiniPort->NonDelegatedQueryInterface(
                __uuidof(UnkMiniPort),
                reinterpret_cast<PVOID*>(&UnkMiniPort));
            Status = PmAttachDevice(
                DeviceObject,
                ClassId,
                PMPORT_Transform,
                UnkMiniPort);
            //
            // The attachment to the port driver will have acquired
            // a reference count on the mini-port. If the attachment
            // failed, then this will destroy the mini-port object.
            //
            UnkMiniPort->Release();
        } else {
            //
            // Object initialization failed. Just delete the
            // object without calling Release().
            //
            delete MiniPort;
        }
    } else {
        //
        // The mini-port instance could not be allocated.
        //
        Status = STATUS_INSUFFICIENT_RESOURCES;
    }
    return Status;
}

#ifdef ALLOC_PRAGMA
#pragma code_seg("INIT")
#endif // ALLOC_PRAGMA


extern "C"
NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPathName
    )
/*++

Routine Description:

    Sets up the driver object by calling the default KCOM initialization.

Arguments:

    DriverObject -
        Driver object for this instance.

    RegistryPathName -
        Contains the registry path which was used to load this instance.

Return Values:

    Returns STATUS_SUCCESS if the driver was initialized.

--*/
{
    _DbgPrintF(DEBUGLVL_TERSE, ("DriverEntry"));
    //
    // Initialize the driver entry points to use the default Irp processing
    // code. Pass in the CreateHandler for objects supported by this module.
    //
    return PmDriverInitialize(
        DriverObject,
        RegistryPathName,
        CreateHandler,
        NULL,
        NULL,
        NULL,
        NULL);
}

#ifdef ALLOC_PRAGMA
#pragma code_seg()
#endif // ALLOC_PRAGMA
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\ksfilter\miniport\soundprt\common.h ===
/*++

    Copyright (C) Microsoft Corporation, 1996 - 1997

Module Name:

    Common.h

Abstract:


Author:

    Bryan A. Woodruff (bryanw) 17-Sep-1996

--*/

#include <ntddk.h>
#include <windef.h>

#include <memory.h>
#include <stddef.h>
#include <stdio.h>
#include <stdlib.h>
#include <tchar.h>
#include <conio.h>

#define NOBITMAP
#include <mmreg.h>
#undef NOBITMAP
#include <ks.h>
#include <ksmedia.h>
#include <drvhelp.h>
#include <waveport.h>

#include "private.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\ksfilter\miniport\soundprt\device.c ===
/*++

    Copyright (C) Microsoft Corporation, 1996 - 1996

Module Name:

    Device.c

Abstract:


Author:

    Bryan A. Woodruff (bryanw) 16-Sep-1996

--*/

#include "common.h"

PDEVICE_OBJECT  MiniportDeviceObject;

#if 0
VOID 
DriverUnload(
    IN PDRIVER_OBJECT DriverObject
    )
{
   _DbgPrintF( DEBUGLVL_BLAB, ("DriverUnload") );

   if (MiniportDeviceObject)
      IoDeleteDevice( MiniportDeviceObject );
}
#endif

NTSTATUS 
DriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPathName
    )
{
    BOOLEAN                 OverrideConflict, Conflicted;
    NTSTATUS                Status;
    PCM_RESOURCE_LIST       AllocatedResources, 
                            CODECResources,
                            FMResources;
    PDEVICE_INSTANCE        DeviceContext;
    ULONG                   ResourceListSize;
    WAVEPORT_REGISTRATION   WavePortRegistration;

//    DriverObject->DriverUnload = DriverUnload;

    AllocatedResources = 
        CODECResources =
        FMResources = NULL;

    // Load resource set from registry...

    if (!NT_SUCCESS(Status = KsAllocateConfig( RegistryPathName, 
                                               &AllocatedResources, 
                                               &ResourceListSize ))) {
        _DbgPrintF( DEBUGLVL_ERROR, ("Unable to obtain device configuration.") ) ;

        return Status ;
    }

    OverrideConflict = FALSE;

    if (!NT_SUCCESS(Status = 
        IoReportResourceUsage( NULL,
                               DriverObject,
                               AllocatedResources,
                               ResourceListSize,
                               NULL,
                               NULL,
                               0,
                               OverrideConflict,
                               &Conflicted ))) {
                               
        if (AllocatedResources) {
            ExFreePool( AllocatedResources );
        }
        return Status;
    }

    WavePortRegistration.DeviceContextSize = sizeof( DEVICE_INSTANCE );
    WavePortRegistration.HwClose = HwClose;
    WavePortRegistration.HwGetPosition = HwGetPosition;
    WavePortRegistration.HwGetVolume = NULL;
    WavePortRegistration.HwOpen = HwOpen;
    WavePortRegistration.HwPause = HwPause;
    WavePortRegistration.HwRead = HwRead;
    WavePortRegistration.HwRun = HwRun;
    WavePortRegistration.HwSetFormat = HwSetFormat;
    WavePortRegistration.HwSetNotificationFrequency = HwSetNotificationFrequency;
    WavePortRegistration.HwSetVolume = NULL;
    WavePortRegistration.HwStop = HwStop;
    WavePortRegistration.HwTestFormat = HwTestFormat;
    WavePortRegistration.HwWrite = HwWrite;

    if (NT_SUCCESS(Status = WavePortRegisterDevice( DriverObject, 
                                                    RegistryPathName,
                                                    &WavePortRegistration,
                                                    &MiniportDeviceObject,
                                                    &DeviceContext ))) {

        // Device specific initialization

        // Currently, this device will allow rates within +/- 2.5% 
        // of nominal rate.

        DeviceContext->AllowableFreqPctgError = 5;
        HwInitialize( MiniportDeviceObject, DeviceContext, AllocatedResources );
        return Status;
    }

    if (AllocatedResources) {
        ExFreePool( AllocatedResources );
    }

    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\ksfilter\miniport\freedom\dsp\blsrc\src.c ===
/*++

    Copyright (C) Microsoft Corporation, 1996 - 1997

Module Name:

    src.c

Abstract:

    Sample Rate Converter using Bandlimited Interpolation 

    The algorithm was first published in:

    Smith, Julius O. and Phil Gossett. "A Flexible Sampling-Rate Conversion
    Method," Proceedings (2): 19.4.1-19.4.4, IEEE Conference on Acoustics,
    Speech, and Signal Processing, San Diego, March 1984.

    An expanded version of this paper is available via ftp (file
    BandlimitedInterpolation.eps.Z in directory 
    ftp://ccrma-ftp.stanford.edu/pub/DSP/Tutorials). 

    The first version of this software was finished by Julius O. Smith 
    at CCRMA in 1981.  It was called SRCONV and was written in SAIL for 
    PDP-10 compatible machines.  

    The SRCONV program was translated from SAIL to C by Christopher
    Lee Fraley working with Roger Dannenberg at CMU.  Since then, the C 
    version has been maintained by JOS.

    Bryan Woodruff at Microsoft Corp. made the necessary modifications for
    use in the ADSP2181-based Diamond Multimedia Freedom card.

Author:
    Julius O. Smith III (jos@ccrma.stanford.edu)

    Bryan A. Woodruff (bryanw@microsoft.com) 20-Dec-1996

--*/

#include <limits.h>

#include "ntdefs.h"
#include "freedom.h"
#include "private.h"

#include "srccoef.h"

void SrcInit(
    USHORT  Pipe,
    USHORT  FsOutput,
    USHORT  FsInput
    )
{
    double   OutputSamplingRate, FilterSamplingRate;

    Pipes[ Pipe ].SrcFactor = (double) FsOutput / (double) FsInput;

    Pipes[ Pipe ].SrcLpScaleFactor = IMPULSE_RESPONSE_SCALING_FACTOR;

    if (Pipes[ Pipe ].SrcFactor < 1) {
        Pipes[ Pipe ].SrcLpScaleFactor = 
            (double) Pipes[ Pipe ].SrcLpScaleFactor * 
                Pipes[ Pipe ].SrcFactor + 0.5;
    }

    Pipes[ Pipe ].SrcWing = 
        ((IMPULSE_RESPONSE_NMULT+1)/2.0) * 
            max(1.0,1.0/Pipes[ Pipe ].SrcFactor) + 10;

    OutputSamplingRate = 
        1.0 / Pipes[ Pipe ].SrcFactor;
    FilterSamplingRate = 
        min( (double) Npc, Pipes[ Pipe ].SrcFactor * (double) Npc );

    Pipes[ Pipe ].SrcDataInc = 
        OutputSamplingRate * (double)((LONG)1<<Np) + 0.5;
    Pipes[ Pipe ].SrcCoeffInc = 
        FilterSamplingRate * (double)(1<<Na) + 0.5;

    Pipes[ Pipe ].SrcTime = 0;
    Pipes[ Pipe ].SrcOffset = 0;
}

static __inline SHORT ftos(
    LONG v,
    int scl
    )
{
    SHORT llsb = (1<<(scl-1));

    /* round */
    v += llsb;
    v >>= scl;
    if (v > (LONG) SHRT_MAX) {
        v = (LONG) SHRT_MAX;
    } else if (v < (LONG) SHRT_MIN) {
        v = (LONG) SHRT_MIN;
    }   
    return (SHORT) v;
}


LONG iFilter(
    SHORT Data[],
    SHORT DataIndex,
    SHORT Coeffs[],
    SHORT CoeffDeltas[],
    USHORT Nwing,
    SHORT Phase,
    SHORT DataInc,
    ULONG CoeffInc
    )
{
    SHORT   a;
    SHORT   *Hp, *Hdp;
    LONG    v, t;
    ULONG   CoIndex, EndIndex;

    v = 0;
    CoIndex = (Phase*(ULONG)CoeffInc)>>Np;
    EndIndex = Nwing;

    /* 
    // If doing right wing drop extra coeff, so when Phase is 0.5, we don't 
    // do too many mult's.
    // 
    // If the phase is zero then we've already skipped the first sample, 
    // so we must also  skip ahead in Coeffs[] and CoeffDeltas[] 
    */

    if (DataInc == 1) {
        EndIndex--;          
        if (Phase == 0) {
            CoIndex += CoeffInc;
        }
    }               
                    
    EndIndex = EndIndex<<Na;

    while (CoIndex < EndIndex) {

        /* Get coefficient */
        t = Coeffs[ CoIndex>>Na ];

        /* Interpolate and multiply coefficient by input sample */

        t += (CoeffDeltas[ CoIndex>>Na ] * (CoIndex & Amask))>>Na;

        t *= Data[ DataIndex ];

        /* Round, if needed */
        if (t & (LONG)1<<(Nhxn-1)) {          
            t += (LONG)1<<(Nhxn-1);
        }

        /* Leave some guard bits, but come back some */
        t >>= Nhxn;       

        v += t;           

        CoIndex += CoeffInc;        

        DataIndex += DataInc;

    }

    return v;

} 
                                                             
void SrcGetSamples( 
    USHORT  Pipe,
    PSHORT Samples 
    )
{
    
    int     i, j;
    LONG    v;
    USHORT  Buffer, DataIndex;

    /* 
    // Check to see if we have enough data to run the filter to
    // generate samples, if so, generate the samples with the 
    // current tap delay line, otherwise fill it with data and
    // then proceed with filter.
    */

    /* 
    // Check for starvation 
    */

    Buffer = Pipes[ Pipe ].CurrentBuffer;
    if (0 == (Pipes[ Pipe ].Flags & (1 << Buffer))) {
        for (i = 0; i < Pipes[ Pipe ].Channels; i++) {
            Samples[ i ] = 0;
        }
        return;
    }


    DataIndex = (Pipes[ Pipe ].SrcTime>>Np) * Pipes[ Pipe ].Channels;

/*
//    DataIndex = Pipes[ Pipe ].SrcOffset * Pipes[ Pipe ].Channels;
*/

    for (i = 0; i < Pipes[ Pipe ].Channels; i++) {

#if 0
        /* Perform left-wing inner product */     
        v = iFilter( Pipes[ Pipe ].Working[ i ], 
                     DataIndex, 
                     ImpulseResponse,
                     ImpulseResponseDeltas,
                     IMPULSE_RESPONSE_TABLE_LENGTH, 
                     (SHORT)(Pipes[ Pipe ].SrcTime & Pmask),
                     -1, 
                     Pipes[ Pipe ].SrcCoeffInc ); 

        /* Perform right-wing inner product */
        v += iFilter( Pipes[ Pipe ].Working[ i ],
                      DataIndex + 1,
                      ImpulseResponse,
                      ImpulseResponseDeltas,
                      IMPULSE_RESPONSE_TABLE_LENGTH,
                      (SHORT)((-Pipes[ Pipe ].SrcTime) & Pmask),
                      1, 
                      Pipes[ Pipe ].SrcCoeffInc );  

        /* Make guard bits */
        v >>= Nhg;    

        /* Normalize for unity filter gain */
        v *= Pipes[ Pipe ].SrcLpScaleFactor;     

        /* strip guard bits, deposit output */
        Samples[ i ] = ftos( v, NLpScl );   
#endif
        Samples[ i ] = 
            Pipes[ Pipe ].Buffers[ Buffer ][ DataIndex++ ];
    }


    Pipes[ Pipe ].SrcTime += Pipes[ Pipe ].SrcDataInc;

/*
//    Pipes[ Pipe ].SrcOffset++;
*/
    /* 
    // If we have incremented our position then we need to 
    // slide the data window 
    */

    if (DataIndex >= SRC_TAPS_SIZE) {

        Pipes[ Pipe ].SrcTime -= 
           (ULONG)(SRC_TAPS_SIZE / Pipes[ Pipe ].Channels)<<Np;

/*
//        Pipes[ Pipe ].SrcOffset -= (SRC_TAPS_SIZE / Pipes[ Pipe ].Channels);
*/
        /*
        // Clear the buffer done flag to allow the
        // BTU to get kicked in the ISR.
        */

        Pipes[ Pipe ].Flags &= ~(1 << Buffer);
        Pipes[ Pipe ].CurrentBuffer = (Buffer + 1) & 1;

        if (Pipes[ Pipe ].Flags & PIPE_FLAG_NEEDKICK) {
            FreedomKickPipe( Pipe );
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\ksfilter\miniport\soundprt\hardware.c ===
/*++

    Copyright (C) Microsoft Corporation, 1996 - 1996

Module Name:

    Hardware.c

Abstract:


Author:

    Bryan A. Woodruff (bryanw) 16-Sep-1996

--*/

#include "common.h"

//
// initial register state
//

static BYTE InitRegs[] =
{
   0x00,   // input control - left
   0x00,   // input control - right
//   0x9F,   // AUX1 input control - left
//   0x9F,   // AUX1 input control - right
   0x08,   // AUX1 input control - left
   0x08,   // AUX1 input control - right
   0x9F,   // AUX2 input control - left
   0x9F,   // AUX2 input control - right
   0x08,   // DAC control - left
   0x08,   // DAC control - right
   0x4B,   // clock/format reg - st,22kHz
   0x00,   // interface reg
   0x00,   // pin control reg
   0x00,   // test/init reg
   0x00,   // miscellaneous reg
   0xFC,   // digital mix disabled - full atten
   0xFF,   // sample counter - upper base
   0xFF    // sample counter - lower base
};

//
// rate selection tables
//

static BYTE RateSelect[] =
{
   0x01, 0x0f,
   0x00, 0x0e,
   0x03, 0x02,
   0x05, 0x07,
   0x04, 0x06,
   0x0d, 0x09,
   0x0b, 0x0c
};

static ULONG NearestRate[] =
{
   (5510 + 6620) / 2, (6620 + 8000) / 2,
   (8000 + 9600) / 2, (9600 + 11025) / 2,
   (WORD)(( 11025 +  16000) / 2), (WORD)((16000L + 18900L) / 2),
   (WORD)((18900L + 22050L) / 2), (WORD)((22050L + 27420L) / 2),
   (WORD)((27420L + 32000L) / 2), (WORD)((32000L + 33075L) / 2),
   (WORD)((33075L + 37800L) / 2), (WORD)((37800L + 44100L) / 2),
   (WORD)((44100L + 48000L) / 2)
};

static ULONG ActualRate[] =
{
   5510, 6620, 8000, 9600, 11025, 16000, 18900, 22050,
   27420, 32000, 33075, 37800, 44100, 48000
};

static BYTE CrystalKey[] =
{
    0x96, 0x35, 0x9a, 0xcd, 0xe6, 0xf3, 0x79, 0xbc,
    0x5e, 0xaf, 0x57, 0x2b, 0x15, 0x8a, 0xc5, 0xe2,
    0xf1, 0xf8, 0x7c, 0x3e, 0x9f, 0x4f, 0x27, 0x13,
    0x09, 0x84, 0x42, 0xa1, 0xd0, 0x68, 0x34, 0x1a        
};

#define CS423X_CONFIGURATION_WSS_BASE_HI    5
#define CS423X_CONFIGURATION_WSS_BASE_LO    6
#define CS423X_CONFIGURATION_SYN_BASE_HI    8
#define CS423X_CONFIGURATION_SYN_BASE_LO    9
#define CS423X_CONFIGURATION_SB_BASE_HI     11
#define CS423X_CONFIGURATION_SB_BASE_LO     12
#define CS423X_CONFIGURATION_WSS_IRQ        14
#define CS423X_CONFIGURATION_WSS_PLAYBACK   16
#define CS423X_CONFIGURATION_WSS_CAPTURE    18

#define SET_CS423X_CONFIGURATION_WSS_BASE( Port ) {\
    CS423XConfiguration[ CS423X_CONFIGURATION_WSS_BASE_HI ] = HIBYTE( Port );\
    CS423XConfiguration[ CS423X_CONFIGURATION_WSS_BASE_LO ] = LOBYTE( Port );}

#define SET_CS423X_CONFIGURATION_SYN_BASE( Port ) {\
    CS423XConfiguration[ CS423X_CONFIGURATION_SYN_BASE_HI ] = HIBYTE( Port );\
    CS423XConfiguration[ CS423X_CONFIGURATION_SYN_BASE_LO ] = LOBYTE( Port );}

#define SET_CS423X_CONFIGURATION_SB_BASE( Port ) {\
    CS423XConfiguration[ CS423X_CONFIGURATION_SB_BASE_HI ] = HIBYTE( Port );\
    CS423XConfiguration[ CS423X_CONFIGURATION_SB_BASE_LO ] = LOBYTE( Port );}

#define SET_CS423X_CONFIGURATION_WSS_IRQ( Interrupt ) {\
    CS423XConfiguration[ CS423X_CONFIGURATION_WSS_IRQ ] = Interrupt;}

#define SET_CS423X_CONFIGURATION_WSS_PLAYBACK( Dma ) {\
    CS423XConfiguration[ CS423X_CONFIGURATION_WSS_PLAYBACK ] = Dma;}

#define SET_CS423X_CONFIGURATION_WSS_CAPTURE( Dma ) {\
    CS423XConfiguration[ CS423X_CONFIGURATION_WSS_CAPTURE ] = Dma;}

VOID
DELAYED_WRITE_PORT_UCHAR(
    ULONG MicroSeconds,
    PUCHAR Port,
    UCHAR Value
    )
{
    KeStallExecutionProcessor( MicroSeconds );
    WRITE_PORT_UCHAR( Port, Value ) ;
}

VOID
HwSendCrystalKey(
    PUCHAR portConfigure
    )
{
    int     i;

    DELAYED_WRITE_PORT_UCHAR( CS423X_CONFIGURATION_DELAY, portConfigure, 0x00 );
    DELAYED_WRITE_PORT_UCHAR( CS423X_CONFIGURATION_DELAY, portConfigure, 0x00 );

    for (i = 0; i < sizeof( CrystalKey ); i++) {
        DELAYED_WRITE_PORT_UCHAR( CS423X_CONFIGURATION_DELAY, 
                                  portConfigure, 
                                  CrystalKey[ i ] );
        KeStallExecutionProcessor( 1 );
    }
}


BOOLEAN
HwSetCS4232Configuration(
    INTERFACE_TYPE InterfaceType,
    ULONG BusNumber,
    IN ULONG portCodec,
    IN ULONG portFM,
    IN ULONG portSoundBlaster,
    IN ULONG Interrupt,
    IN ULONG PlaybackDMA,
    IN ULONG CaptureDMA
    )
{
    int                 i;
    PUCHAR              portConfigure;
    PHYSICAL_ADDRESS    physMapped, physPort;
    ULONG               MemType = 1; 

    BYTE CS423XConfiguration[] = {

    0x06, 0x01,             // CSN = 1

    0x15, 0x00,             // Logical Device 0
    0x47, 0x05, 0x34,       // WSSbase = 0x534
    0x48, 0x03, 0x88,       // SYNbase = 0x388
    0x42, 0x02, 0x20,       // SBbase = 0x220
    0x22, 0x05,             // WSS & SB IRQ = 5
    0x2A, 0x01,             // WSS & SB DMA (playback) = 1
    0x25, 0x00,             // WSS DMA (capture) = 0
    0x33, 0x01,             // activate logical device 0

    // Currently not enabling the Joystick

#if 0
    0x15, 0x01,             // Logical Device 1
    0x47, 0x02, 0x00,       // GAMEbase = 0x200
    0x33, 0x01,             // activate logical device 1
#endif

    0x15, 0x02,             // Logical Device 2
    0x47, 0x01, 0x20,       // CTRLbase = 0x120
    0x33, 0x01,             // activate logical device 2

    // Currently not enabling the MPU-401

#if 0
    0x15, 0x03,             // Logical Device 3
    0x47, 0x03, 0x30,       // MPUbase = 0x330
    0x22, 0x09,             // MPU IRQ = 9
    0x33, 0x01,             // activate logical device 3
#endif

    0x79                    // activate the part

    };

    physPort.QuadPart = CS423X_CONFIGURATION_PORT;

    if (!HalTranslateBusAddress( InterfaceType,
                                 BusNumber, 
                                 physPort,
                                 &MemType, 
                                 &physMapped ))
        return FALSE;

    //
    // map memory type IO space into address space (non-cached)
    //

    SET_CS423X_CONFIGURATION_WSS_BASE( portCodec );
    SET_CS423X_CONFIGURATION_SYN_BASE( portFM );
    SET_CS423X_CONFIGURATION_SB_BASE( portSoundBlaster );
    SET_CS423X_CONFIGURATION_WSS_IRQ( (UCHAR) Interrupt );
    SET_CS423X_CONFIGURATION_WSS_PLAYBACK( (UCHAR) PlaybackDMA );
    SET_CS423X_CONFIGURATION_WSS_CAPTURE( (UCHAR) CaptureDMA );

    portConfigure = (PUCHAR) physMapped.LowPart;

    DELAYED_WRITE_PORT_UCHAR( CS423X_CONFIGURATION_DELAY, portConfigure, 0x02 );
    DELAYED_WRITE_PORT_UCHAR( CS423X_CONFIGURATION_DELAY, portConfigure, 0x02 );

    KeStallExecutionProcessor( CS423X_CONFIGURATION_DELAY );
    HwSendCrystalKey( portConfigure );
    KeStallExecutionProcessor( CS423X_CONFIGURATION_DELAY );

    for (i = 0; i < sizeof( CS423XConfiguration ); i++) {
        DELAYED_WRITE_PORT_UCHAR( CS423X_CONFIGURATION_DELAY, 
                                  portConfigure, 
                                  CS423XConfiguration[ i ] );
    }

    KeStallExecutionProcessor( CS423X_CONFIGURATION_DELAY );

    return TRUE;
}

BOOLEAN 
HwConfigureAutoSel(
    IN PUCHAR portAutoSel,
    IN ULONG Interrupt,
    IN ULONG PlaybackDMA,
    IN ULONG CaptureDMA
    )
{
   int    i;
   BYTE   Config;

   ULONG  ValidDMA[] = { 0, 1, 3 };
   ULONG  ValidIRQ[] = { 7, 9, 10, 11 };
   BYTE   DMAConfig[] = { 1, 2, 3 };
   BYTE   IRQConfig[] = { 0x08, 0x10, 0x18, 0x20 };

   for (i = 0; i < SIZEOF_ARRAY( ValidIRQ ); i++) {
      if (Interrupt == ValidIRQ[ i ]) {
         break;
      }
   }
   if (i == SIZEOF_ARRAY( ValidIRQ )) {
      return FALSE;
   }

   Config = IRQConfig[ i ];

   for (i = 0; i < SIZEOF_ARRAY( ValidDMA ); i++) {
      if (PlaybackDMA == ValidDMA[ i ])
      {
         break;
      }
   }
   if (i == SIZEOF_ARRAY( ValidDMA ))
   {
      return FALSE;
   }

   Config |= DMAConfig[ i ];

#pragma message( REMIND( "need to validate that 0 or 1 is the capture" ) )

   if (PlaybackDMA != CaptureDMA)
   {
      Config |= 0x04;
   }

   WRITE_PORT_UCHAR( portAutoSel, Config );

   return TRUE;

}

ULONG 
HwNearestRate(
    IN ULONG SamplingFrequency
    )
{
   int  i;

   for (i = 0; i < SIZEOF_ARRAY( NearestRate ) - 1; i++) {

      if (SamplingFrequency < (DWORD) NearestRate[ i ]) {
         return ActualRate[ i ];
      }
   }

   return ActualRate[ SIZEOF_ARRAY( ActualRate ) - 1 ];
}

VOID 
HwExtMute(
    IN PDEVICE_INSTANCE DeviceContext,
    IN BOOLEAN fOn
    )
{
   BYTE  Prev;

   if (DeviceContext->Flags & HARDWAREF_COMPAQBA) {
      Prev = READ_PORT_UCHAR( DeviceContext->portAGA + 3 );

      if (!fOn) {
         // Wait 10 ms before turning off the external mute - avoid
         // click with mute circuitry.

         Delay( TIME_MUTE_DELAY );
      }
      WRITE_PORT_UCHAR( DeviceContext->portAGA + 3,
                        (BYTE) ((Prev & 0xF0) | (fOn ? 0x0A : 0x08)) );
      Delay( TIME_MUTE_DELAY / 2 );
   }
   else {
      Prev = (BYTE) (CODEC_RegRead( DeviceContext, REGISTER_DSP ) &
          ~(SOUNDPORT_PINCTL_XTL0 | SOUNDPORT_PINCTL_XTL1)  );

      if (fOn) {
         DeviceContext->Mute |= (BYTE) SOUNDPORT_PINCTL_XTL0;
         CODEC_RegWrite( DeviceContext, REGISTER_DSP, (BYTE)(Prev | DeviceContext->Mute) );
      }
      else {
         // Wait 10 ms before turning off the external mute - avoid
         // click with mute circuitry.

         Delay( TIME_MUTE_DELAY );
         DeviceContext->Mute &= (BYTE) ~SOUNDPORT_PINCTL_XTL0;
         CODEC_RegWrite( DeviceContext, REGISTER_DSP, (BYTE)(Prev | DeviceContext->Mute) );
      }
   }

} // HwExtMute()

VOID 
HwEnterMCE(
    IN PDEVICE_INSTANCE DeviceContext,
    IN BOOL fAuto
    )
{
   BYTE    i;
   BYTE    bTemp;

   // Only perform muting when J-Class is used
   // or when autocalibrating

   if ((fAuto) || (DeviceContext->CODECClass == CODEC_AD1848J)) {
      // Remember the old volume registers and then
      // mute each one of them...

      for (i = REGISTER_LEFTAUX1; i <= REGISTER_RIGHTOUTPUT; i++)
      {
         DeviceContext->MCEState[i] =
            bTemp = (BYTE) CODEC_RegRead( DeviceContext, i );
         CODEC_RegWrite( DeviceContext, i, (BYTE)(bTemp | 0x80) );
      }

      // Make sure the record gain is not too high 'cause if
      // it is strange clipping problems result.

      for (i = REGISTER_LEFTINPUT; i <= REGISTER_RIGHTINPUT; i++)
      {
         DeviceContext->MCEState[i] = bTemp =
            (BYTE) CODEC_RegRead( DeviceContext, i );
         if ((bTemp & 0x0f) > 13) {
            bTemp = (bTemp & (BYTE)0xf0) | (BYTE)13;
         }
         CODEC_RegWrite( DeviceContext, i, bTemp );
      }
   }

   // Turn on MCE

   DeviceContext->ModeChange = SOUNDPORT_MODE_MCE;

   // Make sure that we're not initializing

   CODEC_WaitForReady( DeviceContext );
   WRITE_PORT_UCHAR( DeviceContext->portCODEC + CODEC_ADDRESS,
                     (BYTE) DeviceContext->ModeChange );

} // HwEnterMCE()

VOID 
HwLeaveMCE(
    IN PDEVICE_INSTANCE DeviceContext,
    IN BOOL Auto
    )
{
   DWORD  Time;
   BYTE   i, Interface;

   DeviceContext->ModeChange &= ~SOUNDPORT_MODE_MCE;

   // Make sure we're not initializing

   CODEC_WaitForReady( DeviceContext );

   // See if we're going to autocalibrate

   WRITE_PORT_UCHAR( DeviceContext->portCODEC + CODEC_ADDRESS,
                     (BYTE) (DeviceContext->ModeChange | REGISTER_INTERFACE) );
   Interface = (BYTE) READ_PORT_UCHAR( DeviceContext->portCODEC + CODEC_DATA );

   // If we're going to autocalibrate then wait for it

   if (Interface & 0x08) {
      WRITE_PORT_UCHAR( DeviceContext->portCODEC + CODEC_ADDRESS,
                        (BYTE) (DeviceContext->ModeChange | REGISTER_TEST) );

      // NOTE: Hardware dependant timing loop

      // Wait for autocalibration to start and then stop.

      Time = 100;
      while (( (~READ_PORT_UCHAR( DeviceContext->portCODEC + CODEC_DATA )) & 0x20) && (Time--));
      Time = DeviceContext->WaitLoop;
      while (( (READ_PORT_UCHAR( DeviceContext->portCODEC + CODEC_DATA )) & 0x20) && (Time--));
   }

   // Delay for clicks

   Delay( TIME_MUTE_DELAY );

   // Only perform un-muting when J-Class is used

   if ((Auto) || (DeviceContext->CODECClass == CODEC_AD1848J)) {
      // Restore the old volume registers...

      for (i = REGISTER_LEFTINPUT; i <= REGISTER_RIGHTOUTPUT; i++)
         CODEC_RegWrite( DeviceContext, i, DeviceContext->MCEState[i] );
   }

} // HwLeaveMCE()

VOID 
HwAcknowledgeIRQ(
    IN PDEVICE_INSTANCE DeviceContext
    )
{
   WRITE_PORT_UCHAR( DeviceContext->portCODEC + CODEC_STATUS, 0 );
}

BOOLEAN 
CODEC_WaitForReady(
    IN PDEVICE_INSTANCE DeviceContext
    )
{
    PUCHAR  port;
    DWORD   Count = 0x18000;

    if (DeviceContext->BoardNotResponsive) {
        return FALSE;
    }

    port = DeviceContext->portCODEC + CODEC_ADDRESS;

    do
    {
       if (0 == (READ_PORT_UCHAR( port ) & 0x80)) {
          return TRUE;
       }
       KeStallExecutionProcessor( 10 );
    }
    while (Count--);

    _DbgPrintF( DEBUGLVL_ERROR, ("CODEC_WaitForReady: TIMEOUT!") );
    DeviceContext->BoardNotResponsive = TRUE;
    return FALSE;

}

BYTE 
CODEC_RegRead(
    IN PDEVICE_INSTANCE DeviceContext,
    BYTE Reg
    )
{
   if (!CODEC_WaitForReady( DeviceContext )) {
      return 0xFF;
   }

#pragma message( REMIND( "this needs to be an atomic operation" ) )

   WRITE_PORT_UCHAR( DeviceContext->portCODEC + CODEC_ADDRESS,
                     (BYTE) (DeviceContext->ModeChange | Reg) );

   return READ_PORT_UCHAR( DeviceContext->portCODEC + CODEC_DATA );

}

BOOLEAN
CODEC_RegWrite(
    IN PDEVICE_INSTANCE DeviceContext,
    IN BYTE Reg,
    IN BYTE Value
    )
{
   if (!CODEC_WaitForReady( DeviceContext ))
   {
      return FALSE;
   }

   WRITE_PORT_UCHAR( DeviceContext->portCODEC + CODEC_ADDRESS,
                     (BYTE) (DeviceContext->ModeChange | Reg) );

   WRITE_PORT_UCHAR( DeviceContext->portCODEC + CODEC_DATA,
                     Value );

   return TRUE;

}

VOID 
CODEC_Reset(
    IN PDEVICE_INSTANCE DeviceContext
    )
{
   BYTE  Reg, bVal;

   _DbgPrintF( DEBUGLVL_BLAB, ("CODEC_Reset") );

#pragma message( REMIND( "need mutex here..." ) )

   if (DeviceContext->CODECClass == CODEC_AD1848J) {
      HwExtMute( DeviceContext, TRUE );
   }

   HwEnterMCE( DeviceContext, FALSE );

   for (Reg = REGISTER_LOWERBASE; Reg <= REGISTER_DATAFORMAT; Reg--)
   {
      bVal = DeviceContext->SavedState[ Reg ];
      switch (Reg)
      {
         case REGISTER_DSP:
            bVal |= DeviceContext->Mute;
            bVal &= ~(SOUNDPORT_PINCTL_IEN);
            break;

         case REGISTER_INTERFACE:
            bVal &= (SOUNDPORT_CONFIG_SDC | SOUNDPORT_CONFIG_ACAL);
            break;
      }
      CODEC_RegWrite( DeviceContext, Reg, bVal );
   }

   HwLeaveMCE( DeviceContext, FALSE );

   for (Reg = REGISTER_LEFTINPUT; Reg <= REGISTER_RIGHTOUTPUT; Reg++)
      CODEC_RegWrite( DeviceContext, Reg, DeviceContext->SavedState[ Reg ] );

   if (DeviceContext->CODECClass == CODEC_AD1848J) {
      HwExtMute( DeviceContext, FALSE );
   }

   //
   // clear SRAM on PCMCIA here...
   //
}

VOID 
CODEC_Save(
    IN PDEVICE_INSTANCE DeviceContext
    )
{
   BYTE Reg;

   _DbgPrintF( DEBUGLVL_BLAB, ("CODEC_Save") );

   for (Reg = REGISTER_LEFTINPUT; Reg <= REGISTER_LOWERBASE; Reg++)
      DeviceContext->SavedState[ Reg ] = CODEC_RegRead( DeviceContext, Reg );
}

NTSTATUS 
HwProcessResources(
    IN PDEVICE_OBJECT MiniportDeviceObject,
    IN PDEVICE_INSTANCE  DeviceContext,
    IN PCM_RESOURCE_LIST AllocatedResources
    )
{
    NTSTATUS                        Status;
    PCM_PARTIAL_RESOURCE_DESCRIPTOR pResDes,
                                    IO[ MAXRES_IO ],
                                    IRQ[ MAXRES_IRQ ],
                                    DMA[ MAXRES_DMA ];
    ULONG                           DMACount,
                                    IOCount,
                                    IRQCount,
                                    Interrupt,
                                    PlaybackDMA,
                                    CaptureDMA,
                                    i;

    DMACount =
        IOCount =
        IRQCount = 0;

    Interrupt =
        PlaybackDMA =
        CaptureDMA = (ULONG) -1;

    // count resources and establish index tables

    for (i = 0,
         pResDes =
         AllocatedResources->List[ 0 ].PartialResourceList.PartialDescriptors;
         i < AllocatedResources->List[ 0 ].PartialResourceList.Count;
         i++, pResDes++) {

        switch (pResDes->Type) {

        case CmResourceTypePort:

            if (MAXRES_IO == IOCount) {
                return STATUS_DEVICE_CONFIGURATION_ERROR;
            }
            IO[ IOCount++ ] = pResDes;
            break;

        case CmResourceTypeInterrupt:

            if (MAXRES_IRQ == IRQCount) {
                return STATUS_DEVICE_CONFIGURATION_ERROR;
            }
            IRQ[ IRQCount++ ] = pResDes;
            break;

        case CmResourceTypeDma:

            if (MAXRES_DMA == DMACount) {
                return STATUS_DEVICE_CONFIGURATION_ERROR;
            }
            DMA[ DMACount++ ] = pResDes;
            break;

        default:

            return STATUS_DEVICE_CONFIGURATION_ERROR;

        }
    }

    _DbgPrintF( DEBUGLVL_VERBOSE,
                ("processed resource list: IOCount = %d, IRQCount = %d, DMACount = %d",
                IOCount, IRQCount, DMACount) );

    switch (IOCount) {

    case 1:
    case 2:

        // CoDec OR (CoDec with AutoSel) {+ Synthesis}

        // If number of port == 4, then there is no auto-select,
        // otherwise nPorts is 8.

        if (IRQCount < 1 || DMACount < 1) {
            return STATUS_DEVICE_CONFIGURATION_ERROR;
        }

        switch (IO[ 0 ]->u.Port.Length) {

        case 8:

            // CoDec with AutoSel

            DeviceContext->Flags |= HARDWAREF_AUTOSEL;

            DeviceContext->portAutoSel =
                TranslateBusAddress( AllocatedResources->List[ 0 ].InterfaceType,
                                     AllocatedResources->List[ 0 ].BusNumber,
                                     IO[ 0 ] );
            DeviceContext->portCODEC = DeviceContext->portAutoSel + AUTOSEL_NUM_PORTS;
            break;

        case 4:
            // CoDec only

            DeviceContext->portAutoSel = (PUCHAR) -1;
            DeviceContext->portCODEC =
                TranslateBusAddress( AllocatedResources->List[ 0 ].InterfaceType,
                                     AllocatedResources->List[ 0 ].BusNumber,
                                     IO[ 0 ] );
            break;

        default:
            _DbgPrintF( DEBUGLVL_ERROR,  ("unknown I/O configuraton") );
            return STATUS_DEVICE_CONFIGURATION_ERROR;

        }
        break;

    case 3:

        // CoDec + Synth + Sound Blaster (for now, assume CS4232/CS4236)

        if (IRQCount < 1 || DMACount < 1) {
            return STATUS_DEVICE_CONFIGURATION_ERROR;
        }

        if ((IO[ 0 ]->u.Port.Length != 4) || 
            (IO[ 1 ]->u.Port.Length != 4) ||
            (IO[ 2 ]->u.Port.Length != 16))
        {
            _DbgPrintF( DEBUGLVL_ERROR,  ("unknown I/O configuraton (3 I/O res)") );
            return STATUS_DEVICE_CONFIGURATION_ERROR;
        }

        DeviceContext->Flags |= HARDWAREF_CRYSTALKEY;

        DeviceContext->portAutoSel = (PUCHAR) -1;
        DeviceContext->portCODEC =
            TranslateBusAddress( AllocatedResources->List[ 0 ].InterfaceType,
                                 AllocatedResources->List[ 0 ].BusNumber,
                                 IO[ 0 ] );
        break;

    default:
        _DbgPrintF( DEBUGLVL_ERROR,  ("unknown I/O configuraton") );
        return STATUS_DEVICE_CONFIGURATION_ERROR;

    }

    if (DMACount) {
        if (Status =
                DmaAllocateChannel( AllocatedResources->List[ 0 ].InterfaceType,
                                    AllocatedResources->List[ 0 ].BusNumber,
                                    DMA[ 0 ],
                                    TRUE,  /* demand mode */
                                    TRUE,  /* auto init */
                                    MAXLEN_DMA_BUFFER,
                                    &DeviceContext->PlaybackAdapter )) {
            _DbgPrintF( DEBUGLVL_ERROR,  ("unable to allocate playback channel") );
            return Status;
        }
        PlaybackDMA = DMA[ 0 ]->u.Dma.Channel;

        if (DMACount > 1) {
            if (Status =
                DmaAllocateChannel( AllocatedResources->List[ 0 ].InterfaceType,
                                    AllocatedResources->List[ 0 ].BusNumber,
                                    DMA[ 1 ],
                                    TRUE,  /* demand mode */
                                    TRUE,  /* auto init */
                                    MAXLEN_DMA_BUFFER,
                                    &DeviceContext->CaptureAdapter )) {
                _DbgPrintF( DEBUGLVL_ERROR,  ("unable to allocate capture channel") );
                DmaFreeChannel( &DeviceContext->PlaybackAdapter, TRUE );
                return Status;
            }
            CaptureDMA = DMA[ 1 ]->u.Dma.Channel;
            DeviceContext->Flags |= HARDWAREF_DUALDMA;
        }
        else {
            DeviceContext->CaptureAdapter = DeviceContext->PlaybackAdapter;
            CaptureDMA = PlaybackDMA;
        }
    }
    else {
        // won't work without DMA, no PCMCIA support yet...

        return STATUS_DEVICE_CONFIGURATION_ERROR;
    }

    if (Status =
            ConnectInterrupt( AllocatedResources->List[ 0 ].InterfaceType,
                              AllocatedResources->List[ 0 ].BusNumber,
                              IRQ[ 0 ],
                              DeviceIsr,
                              DeviceContext,
                              FALSE,
                              NULL,
                              &DeviceContext->InterruptInfo )) {
        _DbgPrintF( DEBUGLVL_ERROR, ("failed to connect interrupt") );
        DmaFreeChannel( &DeviceContext->PlaybackAdapter, TRUE );
        DmaFreeChannel( &DeviceContext->CaptureAdapter, FALSE );
        return Status;
    }

    // Allocate DMA buffer(s)

    if (Status = 
        DmaAllocateBuffer( &DeviceContext->PlaybackAdapter )) {

        IoDisconnectInterrupt( DeviceContext->InterruptInfo.Interrupt );
        DmaFreeChannel( &DeviceContext->PlaybackAdapter, TRUE );
        DmaFreeChannel( &DeviceContext->CaptureAdapter, FALSE );
        return Status;
    }

    if (Status = 
        DmaAllocateBuffer( &DeviceContext->CaptureAdapter )) {

        IoDisconnectInterrupt( DeviceContext->InterruptInfo.Interrupt );
        DmaFreeChannel( &DeviceContext->PlaybackAdapter, TRUE );
        DmaFreeChannel( &DeviceContext->CaptureAdapter, FALSE );
        return Status;
    }

    Interrupt = IRQ[ 0 ]->u.Interrupt.Level;

    if (DeviceContext->Flags & HARDWAREF_AUTOSEL) {
        if (!HwConfigureAutoSel( DeviceContext->portAutoSel, Interrupt,
                                 PlaybackDMA, CaptureDMA )) {
            Status = STATUS_DEVICE_CONFIGURATION_ERROR;
        }
    }

    if (DeviceContext->Flags & HARDWAREF_CRYSTALKEY) {
        if (!HwSetCS4232Configuration( AllocatedResources->List[ 0 ].InterfaceType,
                                       AllocatedResources->List[ 0 ].BusNumber,
                                       IO[ 0 ]->u.Port.Start.LowPart,
                                       IO[ 1 ]->u.Port.Start.LowPart,
                                       IO[ 2 ]->u.Port.Start.LowPart,
                                       Interrupt,
                                       PlaybackDMA,
                                       CaptureDMA )) {
            Status = STATUS_DEVICE_CONFIGURATION_ERROR;
        }
    }

    if (!NT_SUCCESS( Status ))
    {
        IoDisconnectInterrupt( DeviceContext->InterruptInfo.Interrupt );
        DmaFreeChannel( &DeviceContext->PlaybackAdapter, TRUE );
        DmaFreeChannel( &DeviceContext->CaptureAdapter, FALSE );
    }

    return Status;

}

//===========================================================================
//===========================================================================

VOID 
HwGetCODECClass(
    IN PDEVICE_INSTANCE DeviceContext
    )
{
    BYTE  bVersion ;

    bVersion = 
        (BYTE) CODEC_RegRead( DeviceContext, REGISTER_MISC ) & 0x8F;

    // clear CS42XX_MISC_MODE2 bit, if set

    CODEC_RegWrite( DeviceContext, REGISTER_MISC, bVersion );

    switch (bVersion) {

    case VER_AD1848K:

        DeviceContext->CODECClass = CODEC_AD1848K;
        break;

    case VER_CS42XX:
        CODEC_RegWrite( DeviceContext, 
                        REGISTER_MISC, CS42XX_MISC_MODE2 );
        if (CODEC_RegRead( DeviceContext, REGISTER_MISC ) &  CS42XX_MISC_MODE2) {

            BYTE bProductId;

            bProductId = CODEC_RegRead( DeviceContext, 
                                        REGISTER_CSVERID );
                                        
            switch (bProductId & CS42XX_ID_MASK) {

            case CS42XX_ID_CS4236:
                if ((bProductId & CS42XX_REV_MASK) == CS4236_REVISION_C)
                    DeviceContext->CODECClass = CODEC_CS4236C;
                else
                    DeviceContext->CODECClass = CODEC_CS4236;
                break;

            case CS42XX_ID_CS4232:

                DeviceContext->CODECClass = CODEC_CS4232;
                break;

            default:
                DeviceContext->CODECClass = CODEC_CS4231;
                break;
            }
        }
        else {
            DeviceContext->CODECClass = CODEC_AD1848K;
        }
        break;
            

    default:

        DeviceContext->CODECClass = CODEC_AD1848J;
        break;

    }
}

NTSTATUS 
HwInitialize(
    IN PDEVICE_OBJECT MiniportDeviceObject,
    IN PDEVICE_INSTANCE  DeviceContext,
    IN PCM_RESOURCE_LIST AllocatedResources
    )
{
    int                 i;
    NTSTATUS            Status;

    Status = STATUS_SUCCESS;

    // save device object and initialize Dpc request

    DeviceContext->MiniportDeviceObject = MiniportDeviceObject;

    if (!NT_SUCCESS( Status = HwProcessResources( MiniportDeviceObject,
                                                  DeviceContext,
                                                  AllocatedResources ) )) {
        return Status;
    }

    HwGetCODECClass( DeviceContext ) ;

    for (i = 0; i < SIZEOF_ARRAY( InitRegs ); i++)
        DeviceContext->SavedState[ i ] = InitRegs[ i ];


    DeviceContext->LeftDAC = 0x08;
    DeviceContext->RightDAC = 0x08;

    // HACK! Automatically enable AUX2 for CS4232 parts (Toshiba Tecra T720)

    if (DeviceContext->CODECClass >= CODEC_CS4232) {
        DeviceContext->SavedState[ REGISTER_LEFTAUX2 ] = 0x04;
        DeviceContext->SavedState[ REGISTER_RIGHTAUX2 ] = 0x04;
    }

    CODEC_Reset( DeviceContext );

    //
    // Enter MODE 2 for CS42XX parts...
    //

    if (DeviceContext->CODECClass >= CODEC_CS4231) {
        BYTE bMisc ;

        bMisc = (BYTE) CODEC_RegRead( DeviceContext, REGISTER_MISC) ;
        CODEC_RegWrite( DeviceContext, REGISTER_MISC, 
                        (BYTE) (bMisc  | CS42XX_MISC_MODE2) ) ;

        CODEC_RegWrite( DeviceContext, REGISTER_FEATEN_I, 0 ) ;
        CODEC_RegWrite( DeviceContext, REGISTER_FEATEN_II, 0 ) ;
    }

    DeviceContext->FormatSelect = InitRegs[ REGISTER_DATAFORMAT ];

    return Status;
}

NTSTATUS HwOpen(
    IN PDEVICE_INSTANCE DeviceContext,
    IN PKSDATAFORMAT_WAVEFORMATEX DataFormat,
    IN BOOLEAN Playback,
    IN OUT PWAVEPORT_DMAMAPPING DmaMapping,
    OUT PVOID *InstanceContext
    )
{
    *InstanceContext = NULL;

    if (DeviceContext->Flags & 
        (Playback ? HARDWAREF_PLAYBACK_ALLOCATED :
                    HARDWAREF_CAPTURE_ALLOCATED)) {
        return STATUS_INVALID_DEVICE_REQUEST;
    }

    if (Playback) {

        DmaMapping->DeviceBufferSize = 
            DmaMapping->AllocatedSize = 
            DeviceContext->PlaybackAdapter.MaxBufferSize;
        DmaMapping->SystemAddress =
            DeviceContext->PlaybackAdapter.VirtualAddress;
        DmaMapping->PhysicalAddress=
            DeviceContext->PlaybackAdapter.PhysicalAddress;
    }
    else {
        DmaMapping->DeviceBufferSize = 
            DmaMapping->AllocatedSize = 
            DeviceContext->CaptureAdapter.MaxBufferSize;
        DmaMapping->SystemAddress = 
            DeviceContext->CaptureAdapter.VirtualAddress;
        DmaMapping->PhysicalAddress=
            DeviceContext->CaptureAdapter.PhysicalAddress;
    }

    DeviceContext->Flags |= 
       (Playback ? HARDWAREF_PLAYBACK_ALLOCATED : HARDWAREF_CAPTURE_ALLOCATED);
    *InstanceContext = (PVOID) Playback;

    return STATUS_SUCCESS;
}

NTSTATUS
HwClose(
    IN PDEVICE_INSTANCE DeviceContext,
    IN PWAVE_INSTANCE InstanceContext
    )
{
    BOOLEAN Playback;

    Playback = (BOOLEAN)InstanceContext;

    if (0 == (DeviceContext->Flags & 
                (Playback ? HARDWAREF_PLAYBACK_ALLOCATED :
                            HARDWAREF_CAPTURE_ALLOCATED))) {
        return STATUS_INVALID_DEVICE_REQUEST;
    }

    DeviceContext->Flags &= 
       ~(Playback ? HARDWAREF_PLAYBACK_ALLOCATED : 
                    HARDWAREF_CAPTURE_ALLOCATED);

    return STATUS_SUCCESS;
}

ULONG
HwSetNotificationFrequency(
    IN PDEVICE_INSTANCE  DeviceContext,
    IN PWAVE_INSTANCE InstanceContext,
    IN ULONG Interval
    )
{
    if (0 ==
           (DeviceContext->Flags &
               (HARDWAREF_PLAYBACK_ACTIVE | HARDWAREF_CAPTURE_ACTIVE))) {
        DeviceContext->NotificationFrequency = Interval;
    }
    return DeviceContext->NotificationFrequency;
}

NTSTATUS 
HwRead(
    IN PDEVICE_INSTANCE DeviceContext,
    IN PWAVE_INSTANCE InstanceContext,
    IN PVOID BufferAddress,
    IN ULONGLONG ByteOffset,
    IN ULONG Length
    )
{
   try 
   {
      RtlCopyMemory( BufferAddress,
                     (PBYTE) DeviceContext->CaptureAdapter.VirtualAddress + ByteOffset,   
                     Length );

   } 
   except(EXCEPTION_EXECUTE_HANDLER) 
   {

      //
      // An exception occurred while attempting to copy the
      // system buffer contents to the caller's buffer.  Set
      // a new I/O completion status.
      //

      return GetExceptionCode();
   }

   return STATUS_SUCCESS;

} // HwRead()


NTSTATUS 
HwWrite(
    IN PDEVICE_INSTANCE DeviceContext,
    IN PWAVE_INSTANCE InstanceContext,
    IN IN PVOID pvBuffer,
    IN ULONGLONG ullByteOffset,
    IN ULONG cbLength
    )
{
   try 
   {
      RtlCopyMemory( (PBYTE) DeviceContext->PlaybackAdapter.VirtualAddress + ullByteOffset,
                    pvBuffer, cbLength );

   } 
   except(EXCEPTION_EXECUTE_HANDLER) 
   {

      //
      // An exception occurred while attempting to copy the
      // system buffer contents to the caller's buffer.  Set
      // a new I/O completion status.
      //

      return GetExceptionCode();
   }

   return STATUS_SUCCESS;

}

NTSTATUS 
HwTestFormat(
    IN PDEVICE_INSTANCE DeviceContext,
    IN PKSDATAFORMAT_WAVEFORMATEX DataFormat,
    IN BOOLEAN Playback
    )
{
    int   i;
    ULONG ActualFrequency, Error;

    _DbgPrintF( DEBUGLVL_BLAB,
                ("HwTestFormat: frequency: %d, channels: %d, bps: %d",
                    DataFormat->WaveFormatEx.nSamplesPerSec,
                    DataFormat->WaveFormatEx.nChannels,
                    DataFormat->WaveFormatEx.wBitsPerSample) );

    if (!IsEqualGUID( &DataFormat->DataFormat.MajorFormat, 
                      &KSDATAFORMAT_TYPE_AUDIO ) ||
        !IsEqualGUID( &DataFormat->DataFormat.SubFormat,
                      &KSDATAFORMAT_SUBTYPE_PCM )) {
        return STATUS_INVALID_PARAMETER;
    }

    // sampling rate...

    for (i = 0,
         ActualFrequency = ActualRate[ SIZEOF_ARRAY( ActualRate ) -1 ];
         i < SIZEOF_ARRAY( ActualRate );
         i++)
    {
        if (DataFormat->WaveFormatEx.nSamplesPerSec < NearestRate[ i ]) {
            ActualFrequency = ActualRate[ i ];
            break;
        }
    }

    Error =
        DataFormat->WaveFormatEx.nSamplesPerSec * 
            DeviceContext->AllowableFreqPctgError / 200;

    if ((DataFormat->WaveFormatEx.nSamplesPerSec > 
            (ActualFrequency + Error)) ||
        (DataFormat->WaveFormatEx.nSamplesPerSec < 
            (ActualFrequency - Error))) {
        _DbgPrintF( DEBUGLVL_VERBOSE, ("sampling frequency out of supported range") );
        return STATUS_INVALID_PARAMETER;
    }

    // data format

    switch (DataFormat->WaveFormatEx.wFormatTag)
    {
        case WAVE_FORMAT_PCM:
        {
            _DbgPrintF( DEBUGLVL_BLAB, ("PCM specified") );

            if (DataFormat->DataFormat.FormatSize != 
                sizeof( KSDATAFORMAT_WAVEFORMATEX )) {
                _DbgPrintF( DEBUGLVL_ERROR, ("format specifier invalid") );
                return STATUS_INVALID_PARAMETER;
            }

            switch (DataFormat->WaveFormatEx.wBitsPerSample)
            {
                case 8:
                case 16:
                    break;

                default:
                    return STATUS_INVALID_PARAMETER;
            }
        }
        break;

        default:
            return STATUS_INVALID_PARAMETER;
    }

    // NEED to verify format here when FULL-DUPLEX...

    return STATUS_SUCCESS;

}

NTSTATUS 
HwSetFormat(
    IN PDEVICE_INSTANCE DeviceContext,
    IN PWAVE_INSTANCE InstanceContext,
    IN PKSDATAFORMAT_WAVEFORMATEX DataFormat,
    IN BOOLEAN Playback
    )
{
    int                   i;
    BYTE                  FormatSelect;
    NTSTATUS              Status;
    ULONG                 ActualFrequency;

   
    if (Status = HwTestFormat( DeviceContext, DataFormat, Playback )) {
        return Status;
    }

    for (i = 0,
         FormatSelect = RateSelect[ SIZEOF_ARRAY( RateSelect ) - 1 ],
         ActualFrequency = ActualRate[ SIZEOF_ARRAY( ActualRate ) - 1 ];
         i < (SIZEOF_ARRAY( RateSelect ) - 1);
         i++)
    {
        if (DataFormat->WaveFormatEx.nSamplesPerSec < NearestRate[ i ]) {
            ActualFrequency = ActualRate[ i ];
            FormatSelect = RateSelect[ i ];
            break;
        }
    }

    // data format

    DeviceContext->SampleSize = 1;
    switch (DataFormat->WaveFormatEx.wFormatTag)
    {
        case WAVE_FORMAT_PCM:
        {
            if (DataFormat->DataFormat.FormatSize != 
                sizeof( KSDATAFORMAT_WAVEFORMATEX )) {
                _DbgPrintF( DEBUGLVL_ERROR, ("format specifier invalid") );
                return STATUS_INVALID_PARAMETER;
            }

            switch (DataFormat->WaveFormatEx.wBitsPerSample)
            {
                case 8:
                    FormatSelect |= (BYTE) SOUNDPORT_FORMAT_8BIT;
                    break;

                case 16:
                    FormatSelect |= (BYTE) SOUNDPORT_FORMAT_16BIT;
                    (DeviceContext->SampleSize) <<= 1;
                    break;

                default:
                    return STATUS_INVALID_PARAMETER;
            }
        }
        break;

        default:
            return STATUS_INVALID_PARAMETER;
    }

    // channels

    DeviceContext->SampleSize *= DataFormat->WaveFormatEx.nChannels;
    FormatSelect |= (BYTE) ((DataFormat->WaveFormatEx.nChannels - 1) << 4);
    DeviceContext->SamplingFrequency =
        DataFormat->WaveFormatEx.nSamplesPerSec;

    //
    // Format change if necessary...
    //

    if (FormatSelect != DeviceContext->FormatSelect) {
        if (DeviceContext->CODECClass == CODEC_AD1848J) {
            HwExtMute( DeviceContext, TRUE );
        }

        HwEnterMCE( DeviceContext, FALSE );

        CODEC_RegWrite( DeviceContext, REGISTER_DATAFORMAT, FormatSelect );
        if (DeviceContext->CODECClass >= CODEC_CS4231) {
            CODEC_RegWrite( DeviceContext, REGISTER_CAP_DATAFORMAT,
                            (BYTE) (FormatSelect & 0xF0) );
        }

        HwLeaveMCE( DeviceContext, FALSE );

        if (DeviceContext->CODECClass == CODEC_AD1848J) {
            HwExtMute( DeviceContext, FALSE );
        }

        DeviceContext->FormatSelect = FormatSelect;
    }
    else {
        //
        // If we've underrun/overrun then the CODEC is in
        // a bad state... clear it up by going through MCE &
        // recalibrating.
        //

        BYTE  bStatus;

        bStatus = READ_PORT_UCHAR( DeviceContext->portCODEC + CODEC_STATUS );

        if (0x1F == (bStatus & 0x1F)) {
            if (DeviceContext->CODECClass == CODEC_AD1848J) {
                HwExtMute( DeviceContext, TRUE );
            }

            HwEnterMCE( DeviceContext, FALSE );

            CODEC_RegWrite( DeviceContext, REGISTER_DATAFORMAT, 
                            (BYTE) DeviceContext->FormatSelect );
            if (DeviceContext->CODECClass >= CODEC_CS4231) {
                CODEC_RegWrite( DeviceContext, REGISTER_CAP_DATAFORMAT,
                            (BYTE) (DeviceContext->FormatSelect & 0xF0) );
            }

            HwLeaveMCE( DeviceContext, FALSE );

            if (DeviceContext->CODECClass == CODEC_AD1848J) {
                HwExtMute( DeviceContext, FALSE );
            }

        }
    }

    return STATUS_SUCCESS;


} // HwSetFormat()

NTSTATUS 
HwGetPosition(
    IN PDEVICE_INSTANCE DeviceContext,
    IN PWAVE_INSTANCE InstanceContext,
    IN BOOLEAN Playback,
    OUT PULONGLONG Position
    )
{
    PADAPTER_INFO   AdapterInfo;

    // this needs to expand to synchronize with interrupt
    // and get a count of interrupts * samples per interrupt +
    // current position.

    AdapterInfo = NULL;
    if (Playback) {
        if (DeviceContext->Flags & HARDWAREF_PLAYBACK_ACTIVE) {
            AdapterInfo = &DeviceContext->PlaybackAdapter;
        }
    }
    else {
        if (DeviceContext->Flags & HARDWAREF_CAPTURE_ACTIVE) {
            AdapterInfo= &DeviceContext->CaptureAdapter;
        }
    }

    if (AdapterInfo && AdapterInfo->TransferCount) {
        *Position = 
            HalReadDmaCounter( AdapterInfo->AdapterObject );

        ASSERT( (*Position <= AdapterInfo->TransferCount) );

        *Position = AdapterInfo->TransferCount - *Position;
    }
    else {
        *Position = 0;
    }

   return STATUS_SUCCESS;

}

NTSTATUS 
HwPause(
    IN PDEVICE_INSTANCE DeviceContext,
    IN PWAVE_INSTANCE InstanceContext,
    IN PWAVEPORT_DMAMAPPING DmaMapping,
    IN BOOLEAN Playback
    )
{
    BOOLEAN                Active;
    BYTE                   Interface, Prev;
    NTSTATUS               Status;
    PADAPTER_INFO          AdapterInfo;

    _DbgPrintF( DEBUGLVL_VERBOSE, ("Pause") );

    Status = STATUS_SUCCESS;

    AdapterInfo = NULL;
    if (Playback) {
        if (DeviceContext->Flags & HARDWAREF_PLAYBACK_ALLOCATED) {
            AdapterInfo = &DeviceContext->PlaybackAdapter;
        }
        Active =
            (BOOLEAN) DeviceContext->Flags & HARDWAREF_PLAYBACK_ACTIVE;
    }
    else
    {
        if (DeviceContext->Flags & HARDWAREF_CAPTURE_ALLOCATED) {
            AdapterInfo= &DeviceContext->CaptureAdapter;
        }
        Active =
            (BOOLEAN) DeviceContext->Flags & HARDWAREF_CAPTURE_ACTIVE;
    }

    if (!AdapterInfo) {
        return STATUS_DEVICE_NOT_READY;
    }

    // map to user's process space...

    if (!DmaMapping->UserAddress) {
        if (Status =
            MapPhysicalToUserSpace( &DmaMapping->PhysicalAddress,
                                    DmaMapping->DeviceBufferSize,
                                    &DmaMapping->UserAddress )) {
            return Status;
        }
    }

    if (Active) {
        DeviceContext->Flags &= 
            ~(Playback ? HARDWAREF_PLAYBACK_ACTIVE : HARDWAREF_CAPTURE_ACTIVE);

        if (0 == (DeviceContext->Flags & HARDWAREF_FULLDUPLEX_ACTIVE)) {
            Prev = (BYTE) (CODEC_RegRead( DeviceContext, REGISTER_DSP ) & 0xC0);
            CODEC_RegWrite( DeviceContext, REGISTER_DSP,
                            (BYTE)(DeviceContext->Mute | Prev | (BYTE) 0x00) );

#pragma message( REMIND( "Synchronize with ISR" ) )

            // Clear any pending IRQs

            HwAcknowledgeIRQ( DeviceContext );

        }

        if (DeviceContext->CODECClass >= CODEC_CS4232) {

            int  i;

            // Workaround a timing bug in the CS4232

            DmaStop( AdapterInfo, Playback );

            //
            // This is one possible solution but when running full-duplex,
            // both state machines may not have requested a transfer at this
            // point.
            //
            // However, to guarantee that the device has requested for this
            // channel when running in full-duplex mode, we need to watch
            // the DMA counter for the other channel.  When a transfer has
            // completed, we can guarantee that this channel now has a
            // pending request.
            //

            for (i = 0; i < 10; i++)
            {
                if (CODEC_RegRead( DeviceContext, REGISTER_TEST ) & 
                    SOUNDPORT_TEST_DRS) {
                    break;
                }
                Delay( 10 ); // delay 10 ms
            }
        }

        if (Playback) {
            // stop playback

            CODEC_RegWrite( DeviceContext, REGISTER_LEFTOUTPUT, 0x3f );
            CODEC_RegWrite( DeviceContext, REGISTER_RIGHTOUTPUT, 0x3f );

            // Tell the CODEC to pause

            Interface = 
                (BYTE) CODEC_RegRead( DeviceContext, REGISTER_INTERFACE );
            Interface &= ~SOUNDPORT_CONFIG_PEN;
            CODEC_RegWrite( DeviceContext, REGISTER_INTERFACE, Interface );
        }
        else {
            // stop capture

            // Only mute on J class CODECs

            if (DeviceContext->CODECClass == CODEC_AD1848J) {
                HwExtMute( DeviceContext, TRUE );
            }

            // Minimize ADC gain

            CODEC_RegWrite( DeviceContext, REGISTER_LEFTINPUT, 0x00 );
            CODEC_RegWrite( DeviceContext, REGISTER_RIGHTINPUT, 0x00 );

            HwEnterMCE( DeviceContext, FALSE );

            // Kill DMA

            Interface = (BYTE) CODEC_RegRead( DeviceContext, REGISTER_INTERFACE );
            Interface &= ~(SOUNDPORT_CONFIG_PPIO | SOUNDPORT_CONFIG_CEN);
            CODEC_RegWrite( DeviceContext, REGISTER_INTERFACE, Interface );

            HwLeaveMCE( DeviceContext, FALSE );

            if (DeviceContext->CODECClass == CODEC_AD1848J) {
                HwExtMute( DeviceContext, FALSE );
            }
        }

        // Wait for device to stop requesting (waiting up to 5ms)

        if (DeviceContext->CODECClass >= CODEC_CS4232) {
            // One more sample to go...

            DmaStart( DeviceContext->MiniportDeviceObject, 
                      AdapterInfo, 
                      1,
                      Playback );
        }

        DmaWaitForTc( AdapterInfo, 5000 );

        DmaStop( AdapterInfo, Playback );
    }

    return Status;

} 

NTSTATUS 
HwRun(
    IN PDEVICE_INSTANCE DeviceContext,
    IN PWAVE_INSTANCE InstanceContext,
    IN PWAVEPORT_DMAMAPPING DmaMapping,
    IN BOOLEAN Playback
    )
{
    BYTE                Interface, Prev, Mode;
    ULONG               ByteCount;
    PADAPTER_INFO       AdapterInfo;
   
    _DbgPrintF( DEBUGLVL_VERBOSE, ("Run") );

    if (Playback) {
        if (DeviceContext->Flags & HARDWAREF_PLAYBACK_ALLOCATED) {
            AdapterInfo = &DeviceContext->PlaybackAdapter;
        }
    }
    else {
        if (DeviceContext->Flags & HARDWAREF_CAPTURE_ALLOCATED) {
            AdapterInfo= &DeviceContext->CaptureAdapter;
        }
    }

    if (!AdapterInfo) {
        return STATUS_DEVICE_NOT_READY;
    }

    DeviceContext->SampleCount =
        min( DmaMapping->AllocatedSize / DeviceContext->SampleSize,
            DeviceContext->SamplingFrequency * 
                DeviceContext->NotificationFrequency / 1000 );
    DeviceContext->SampleCount--;

    _DbgPrintF( DEBUGLVL_BLAB, ("SampleCount: 0x%x, NotificationFreq: %d",
                                DeviceContext->SampleCount,
                                DeviceContext->NotificationFrequency) );

    if (0 ==(DeviceContext->Flags & HARDWAREF_FULLDUPLEX_ACTIVE)) {
        // Clear any pending interrupts

        Prev = 
            (BYTE) (CODEC_RegRead( DeviceContext, REGISTER_DSP ) & 0xC0) ;
        CODEC_RegWrite( DeviceContext, REGISTER_DSP, 
                        (BYTE) (DeviceContext -> Mute | Prev) ) ;
        WRITE_PORT_UCHAR( DeviceContext->portCODEC + CODEC_STATUS, 0 ) ;
   }


    DeviceContext->Flags |= 
       (Playback) ? HARDWAREF_PLAYBACK_ACTIVE : HARDWAREF_CAPTURE_ACTIVE;

    // Start DMA

    ByteCount = DmaMapping->AllocatedSize;

    DmaStart( DeviceContext->MiniportDeviceObject, 
              AdapterInfo, 
              ByteCount, 
              Playback );

    if (Playback) {
        // Enable DAC outputs

        CODEC_RegWrite( DeviceContext,
                        REGISTER_LEFTOUTPUT,
                        DeviceContext->LeftDAC );
        CODEC_RegWrite( DeviceContext,
                        REGISTER_RIGHTOUTPUT,
                        DeviceContext->RightDAC );
    }
    else {
        CODEC_RegWrite( DeviceContext, REGISTER_LEFTINPUT,
                        (2 << 6) | 0x0C );
//                        (2 << 6) | (1 << 5) | 8 );
//                          MIC        +20dB    +8*1.5dB
        CODEC_RegWrite( DeviceContext, REGISTER_RIGHTINPUT,
                        (2 << 6) | (1 << 5) | 8 );
    }

    if (!Playback) {
        if (DeviceContext->CODECClass == CODEC_AD1848J) {
            HwExtMute( DeviceContext, TRUE );
        }
        HwEnterMCE( DeviceContext, FALSE );
    }

    if (DeviceContext->CODECClass >= CODEC_CS4231) {
        if (HARDWAREF_FULLDUPLEX_ACTIVE != 
                (DeviceContext->Flags & HARDWAREF_FULLDUPLEX_ACTIVE)) {
            CODEC_RegWrite( DeviceContext, REGISTER_LOWERBASE,
                            (BYTE) (DeviceContext->SampleCount) );
            CODEC_RegWrite( DeviceContext, REGISTER_UPPERBASE,
                            (BYTE) (DeviceContext->SampleCount >> 8) );
        }
        if (!Playback) {
            CODEC_RegWrite( DeviceContext, REGISTER_CAP_LOWERBASE,
                            (BYTE) (DeviceContext->SampleCount) );
            CODEC_RegWrite( DeviceContext, REGISTER_CAP_UPPERBASE,
                            (BYTE) (DeviceContext->SampleCount >> 8) );
        }
    }
    else {
        if (HARDWAREF_FULLDUPLEX_ACTIVE != 
                (DeviceContext->Flags & HARDWAREF_FULLDUPLEX_ACTIVE)) {
            // Tell the codec's DMA how many samples

            CODEC_RegWrite( DeviceContext, REGISTER_LOWERBASE,
                            (BYTE) (DeviceContext->SampleCount) );
            CODEC_RegWrite( DeviceContext, REGISTER_UPPERBASE,
                            (BYTE) (DeviceContext->SampleCount >> 8) );
        }
    }

    // program the CODEC

    Interface =
        (BYTE) CODEC_RegRead( DeviceContext, REGISTER_INTERFACE ) & 
            (~SOUNDPORT_CONFIG_SDC);
    if (Playback) {
        Interface |= SOUNDPORT_CONFIG_PEN;

        if (0 == (DeviceContext->Flags & HARDWAREF_DUALDMA)) {
            Interface |= SOUNDPORT_CONFIG_SDC;
        }
    }
    else {
        if ((CODEC_AD1848J == DeviceContext->CODECClass) &&
            (0 == (DeviceContext->Flags & HARDWAREF_DUALDMA))) {
            Interface |=
                SOUNDPORT_CONFIG_PPIO | SOUNDPORT_CONFIG_CEN | SOUNDPORT_CONFIG_ACAL;
        }
        else {
            Interface &= ~(SOUNDPORT_CONFIG_CPIO | SOUNDPORT_CONFIG_PPIO);
            Interface |= SOUNDPORT_CONFIG_CEN | SOUNDPORT_CONFIG_ACAL;
        }
    }
    CODEC_RegWrite( DeviceContext, REGISTER_INTERFACE, Interface );

    if (HARDWAREF_FULLDUPLEX_ACTIVE != 
            (DeviceContext->Flags & HARDWAREF_FULLDUPLEX_ACTIVE)) {
        // start interrupts

        Prev = CODEC_RegRead( DeviceContext, REGISTER_DSP );
        CODEC_RegWrite( DeviceContext, REGISTER_DSP,
                        (BYTE) (Prev | SOUNDPORT_PINCTL_IEN) );
    }

    if (!Playback) {
        HwLeaveMCE( DeviceContext, FALSE );
        if (DeviceContext->CODECClass == CODEC_AD1848J) {
            HwExtMute( DeviceContext, FALSE );
        }
    }

    return STATUS_SUCCESS;

} // HwRun()

NTSTATUS 
HwStop(
    IN PDEVICE_INSTANCE DeviceContext,
    IN PWAVE_INSTANCE InstanceContext,
    IN PWAVEPORT_DMAMAPPING DmaMapping
    )
{
    _DbgPrintF( DEBUGLVL_VERBOSE, ("Stop") );

    if (DmaMapping->UserAddress) {
        UnmapUserSpace( DmaMapping->UserAddress );
        DmaMapping->UserAddress = NULL;
    }

    return STATUS_SUCCESS;

}

//===========================================================================
//===========================================================================

BOOLEAN 
DeviceIsr(
    IN PKINTERRUPT Interrupt,
    IN PVOID Context
    )
{
    PDEVICE_INSTANCE DeviceContext = (PDEVICE_INSTANCE) Context;

    //
    // Acknowledge the interrupt
    //

    HwAcknowledgeIRQ( DeviceContext );
    WavePortRequestDpc( DeviceContext->MiniportDeviceObject );

    return TRUE;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\ksfilter\msdalloc\msdalloc.h ===
/*++

Copyright (C) Microsoft Corporation, 1996 - 1997

Module Name:

	msdalloc.h

Abstract:

	Internal header file for filter.

--*/

#include <wdm.h>
#include <windef.h>

#include <memory.h>
#include <stddef.h>
#include <stdio.h>
#include <limits.h>
#include <stdlib.h>
#include <tchar.h>
#include <conio.h>

#include <ks.h>

#if (DBG)
#define STR_MODULENAME  "msdalloc: "
#endif // DBG

NTSTATUS
PnpAddDevice(
    IN PDRIVER_OBJECT   DriverObject,
    IN PDEVICE_OBJECT   PhysicalDeviceObject
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\ksfilter\msdalloc\device.c ===
/*++

Copyright (C) Microsoft Corporation, 1996 - 1998

Module Name:

    device.c

Abstract:

    Device entry point and hardware validation.

--*/

#include "msdalloc.h"

#ifdef ALLOC_PRAGMA
NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT   DriverObject,
    IN PUNICODE_STRING  RegistryPathName
    );

#pragma alloc_text(INIT, DriverEntry)
#endif // ALLOC_PRAGMA


NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT   DriverObject,
    IN PUNICODE_STRING  RegistryPathName
    )
/*++

Routine Description:

    Sets up the driver object to handle the KS interface and PnP Add Device
    request. Does not set up a handler for PnP Irp's, as they are all dealt
    with directly by the PDO.

Arguments:

    DriverObject -
        Driver object for this instance.

    RegistryPathName -
        Contains the registry path which was used to load this instance.

Return Values:

    Returns STATUS_SUCCESS.

--*/
{
    DriverObject->MajorFunction[IRP_MJ_PNP] = KsDefaultDispatchPnp;
    DriverObject->MajorFunction[IRP_MJ_POWER] = KsDefaultDispatchPower;
    DriverObject->MajorFunction[IRP_MJ_SYSTEM_CONTROL] = KsDefaultForwardIrp;
    DriverObject->DriverExtension->AddDevice = PnpAddDevice;
    DriverObject->DriverUnload = KsNullDriverUnload;
    KsSetMajorFunctionHandler(DriverObject, IRP_MJ_CREATE);
    KsSetMajorFunctionHandler(DriverObject, IRP_MJ_CLOSE);
    KsSetMajorFunctionHandler(DriverObject, IRP_MJ_DEVICE_CONTROL);
    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\ksfilter\msfsio\device.cpp ===
/*++

Copyright (C) Microsoft Corporation, 1998 - 1999

Module Name:

    device.cpp

Abstract:

    Device driver core, initialization, etc.
    
--*/

#include "msfsio.h"

#ifdef ALLOC_PRAGMA
#pragma code_seg("INIT")
#endif // ALLOC_PRAGMA


extern "C"
NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPathName
    )
/*++

Routine Description:

    Sets up the driver object.

Arguments:

    DriverObject -
        Driver object for this instance.

    RegistryPathName -
        Contains the registry path which was used to load this instance.

Return Values:

    Returns STATUS_SUCCESS if the driver was initialized.

--*/
{
    _DbgPrintF(DEBUGLVL_VERBOSE,("DriverEntry"));

    return
        KsInitializeDriver(
            DriverObject,
            RegistryPathName,
            &DeviceDescriptor);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\ksfilter\miniport\soundprt\private.h ===
/*++

    Copyright (C) Microsoft Corporation, 1996 - 1996

Module Name:

    Private.h

Abstract:


Author:

    Bryan A. Woodruff (bryanw) 16-Sep-1996

--*/

//
// constants
//

#if (DBG)
#define STR_MODULENAME  "soundprt: "
#endif

#define MAXRES_IO   3
#define MAXRES_IRQ  1
#define MAXRES_DMA  2

#define TIME_MUTE_DELAY  10

#define AUTOSEL_CONFIG              0x00
#define AUTOSEL_ID                  0x03
#define AUTOSEL_NUM_PORTS           0x04

#define CODEC_ADDRESS               0x00
#define CODEC_DATA                  0x01
#define CODEC_STATUS                0x02
#define CODEC_DIRECT                0x03
#define CODEC_NUM_PORTS             0x04

#define CODEC_IS_BUSY               0x80

#define REGISTER_LEFTINPUT          0x00
#define REGISTER_RIGHTINPUT         0x01
#define REGISTER_LEFTAUX1           0x02
#define REGISTER_RIGHTAUX1          0x03
#define REGISTER_LEFTAUX2           0x04
#define REGISTER_RIGHTAUX2          0x05
#define REGISTER_LEFTOUTPUT         0x06
#define REGISTER_RIGHTOUTPUT        0x07
#define REGISTER_DATAFORMAT         0x08
#define REGISTER_INTERFACE          0x09
#define REGISTER_DSP                0x0a
#define REGISTER_TEST               0x0b
#define REGISTER_MISC               0x0c
#define REGISTER_LOOPBACK           0x0d
#define REGISTER_UPPERBASE          0x0e
#define REGISTER_LOWERBASE          0x0f

// CS42XX extended registers

#define REGISTER_FEATEN_I           0x10
#define REGISTER_FEATEN_II          0x11
#define REGISTER_LEFTLINE           0x12
#define REGISTER_RIGHTLINE          0x13
#define REGISTER_CSVERID            0x19
#define REGISTER_MONOINPUT          0x1A
#define REGISTER_LEFTMASTER         0x1B
#define REGISTER_CAP_DATAFORMAT     0x1C
#define REGISTER_RIGHTMASTER        0x1D
#define REGISTER_CAP_UPPERBASE      0x1E
#define REGISTER_CAP_LOWERBASE      0x1F

#define MAXLEN_SOUNDPORT_REGISTERS  0x20

#define SOUNDPORT_FORMAT_8BIT       0x00
#define SOUNDPORT_FORMAT_MULAW      0x20
#define SOUNDPORT_FORMAT_16BIT      0x40
#define SOUNDPORT_FORMAT_ALAW       0x60
#define CS423X_FORMAT_IMA_ADPCM     0xA0

#define SOUNDPORT_CONFIG_PEN        0x01            // Playback Enable
#define SOUNDPORT_CONFIG_CEN        0x02            // Capture Enable
#define SOUNDPORT_CONFIG_SDC        0x04            // Single DMA Channel
#define SOUNDPORT_CONFIG_ACAL       0x08            // Auto-Calibrate
#define SOUNDPORT_CONFIG_RESERVED   0x30            // Reserved
#define SOUNDPORT_CONFIG_PPIO       0x40            // Playback PIO Enable
#define SOUNDPORT_CONFIG_CPIO       0x80            // Capture PIO Enable

#define SOUNDPORT_PINCTL_IEN        0x02
#define SOUNDPORT_PINCTL_XTL0       0x40
#define SOUNDPORT_PINCTL_XTL1       0x80

#define SOUNDPORT_MODE_TRD          0x20            // transfer request disable
#define SOUNDPORT_MODE_MCE          0x40            // mode change enable

#define SOUNDPORT_TEST_DRS          0x10            // DRQ status
#define SOUNDPORT_TEST_PUR          0x40            // Playback underrun
#define SOUNDPORT_TEST_COR          0x80            // Capture overrun

#define CS42XX_MISC_MODE2           0x40            // MODE 2 select/detect

#define CS42XX_ID_MASK              0x07            // CS42XX ID mask
#define CS42XX_ID_CS4231            0x00            // ID: CS4231
#define CS42XX_ID_CS4232            0x02            // ID: CS4232
#define CS42XX_ID_CS4236            0x03            // ID: CS4236

#define CS42XX_REV_MASK             0xE0            // CS42XX revision mask
#define CS4236_REVISION_C           0x80            // CS4236 Revision C

#define VER_AD1848J                 0x09            // version marker of CODEC
#define VER_AD1848K                 0x0A

#define VER_CSPROTO                 0x81            // prototype, treat as 'J'
#define VER_CS42XX                  0x8A

#define CODEC_AD1848J               0x00            // AD1848J
#define CODEC_AD1848K               0x01            // AD1848K & CS4248
#define CODEC_AD1845                0x02            // AD1845
#define CODEC_CS4231                0x03            // CS4231
#define CODEC_CS4232                0x04            // CS4232
#define CODEC_CS4236                0x05            // CS4236
#define CODEC_CS4236C               0x06            // CS4236 revision C

#define CS423X_CONFIGURATION_PORT   0x279
#define CS423X_CONFIGURATION_DELAY  10              // 10 microsecond delay 
                                                    //    between writes

#define MAXLEN_DMA_BUFFER           0x2000

//
// data structures
//

#define HARDWAREF_COMPAQBA              0x00000001
#define HARDWAREF_DUALDMA               0x00000002
#define HARDWAREF_AUTOSEL               0x00000004
#define HARDWAREF_CRYSTALKEY            0x00000008

#define HARDWAREF_PLAYBACK_ALLOCATED    0x00000010
#define HARDWAREF_PLAYBACK_ACTIVE       0x00000020
#define HARDWAREF_CAPTURE_ALLOCATED     0x00000040
#define HARDWAREF_CAPTURE_ACTIVE        0x00000080
#define HARDWAREF_FULLDUPLEX_ACTIVE     (HARDWAREF_CAPTURE_ACTIVE | HARDWAREF_PLAYBACK_ACTIVE)

//
// data structures
//

typedef struct {
   ULONG  PortBase;
   ULONG  PortLength;

} IO_RESOURCE;

typedef struct {
   ULONG InterruptLevel;
   UCHAR Flags;
   UCHAR ShareDisposition;

} IRQ_RESOURCE;

typedef struct {
   ULONG DMAChannel;
   UCHAR Flags;
   
} DMA_RESOURCE;

//---------------------------------------------------------------------------
//---------------------------------------------------------------------------

typedef struct {
    PDEVICE_OBJECT      MiniportDeviceObject;
    PUCHAR              portAutoSel,
                        portCODEC,
                        portAGA;
    ULONG               Flags;
    ULONG               CODECClass;
    ULONG               WaitLoop;
    ULONG               NotificationFrequency;
    KMUTEX              ControlMutex;
    KSPIN_LOCK          HardwareLock;

    BOOLEAN             BoardNotResponsive;
    BOOLEAN             Reserved1;

    ULONG               AllowableFreqPctgError;
    ULONG               SamplingFrequency;
    ULONG               SampleCount, SampleSize;

    BYTE                ModeChange;
    BYTE                Mute;
    BYTE                FormatSelect;
    BYTE                Reserved2;

    //
    // active mixer settings
    //

    BYTE                LeftDAC, RightDAC;


    //
    // CODEC register states
    //

    BYTE                MCEState[ MAXLEN_SOUNDPORT_REGISTERS ],
                        SavedState[ MAXLEN_SOUNDPORT_REGISTERS ];

    //
    // Interrupt and DMA objects
    //
   
    INTERRUPT_INFO      InterruptInfo;
    ADAPTER_INFO        CaptureAdapter, PlaybackAdapter;

} DEVICE_INSTANCE, *PDEVICE_INSTANCE;

typedef struct {

    KSDATAFORMAT_WAVEFORMATEX   DataFormat;
    PDEVICE_INSTANCE            DeviceContext;

    ULONG                       Flags;

    KMUTEX                      ControlMutex;
    BOOLEAN                     Active;

} WAVE_INSTANCE, *PWAVE_INSTANCE;

//---------------------------------------------------------------------------
//---------------------------------------------------------------------------

//
// local prototypes
//

//---------------------------------------------------------------------------
// hardware.c:

BYTE 
CODEC_RegRead(
    IN PDEVICE_INSTANCE DeviceContext,
    IN BYTE Reg
    );

BOOLEAN 
CODEC_WaitForReady(
    IN PDEVICE_INSTANCE DeviceContext
    );

BOOLEAN 
CODEC_RegWrite(
    IN PDEVICE_INSTANCE DeviceContext,
    IN BYTE Reg,
    IN BYTE Value
    );

BOOLEAN 
DeviceIsr(
    IN PKINTERRUPT Interrupt,
    IN PVOID Context
    );

VOID 
HwAcknowledgeIRQ(
    IN PDEVICE_INSTANCE DeviceContext
    );

BOOLEAN 
HwConfigureAutoSel(
    IN PUCHAR portAutoSel,
    IN ULONG Interrupt,
    IN ULONG PlaybackDMA,
    IN ULONG CaptureDMA
    );

NTSTATUS
HwClose(
    IN PDEVICE_INSTANCE DeviceContext,
    IN PWAVE_INSTANCE InstanceContext
    );

NTSTATUS 
HwGetPosition(
    IN PDEVICE_INSTANCE DeviceContext,
    IN PWAVE_INSTANCE InstanceContext,
    IN BOOLEAN Playback,
    OUT PULONGLONG Position
    );

NTSTATUS 
HwInitialize(
    IN PDEVICE_OBJECT DeviceObject,
    IN PDEVICE_INSTANCE DeviceContext,
    IN PCM_RESOURCE_LIST AllocatedResources
    );

NTSTATUS
HwOpen(
    IN PDEVICE_INSTANCE DeviceContext,
    IN PKSDATAFORMAT_WAVEFORMATEX DataFormat,
    IN BOOLEAN Playback,
    IN OUT PWAVEPORT_DMAMAPPING DmaMapping,
    OUT PVOID *InstanceContext
    );

NTSTATUS 
HwPause(
    IN PDEVICE_INSTANCE DeviceContext,
    IN PWAVE_INSTANCE InstanceContext,
    IN PWAVEPORT_DMAMAPPING DmaMapping,
    IN BOOLEAN Playback
    );

NTSTATUS 
HwRun(
    IN PDEVICE_INSTANCE DeviceContext,
    IN PWAVE_INSTANCE InstanceContext,
    IN PWAVEPORT_DMAMAPPING DmaMapping,
    IN BOOLEAN Playback
    );

ULONG
HwSetNotificationFrequency(
    IN PVOID DeviceContext,
    IN PVOID InstanceContext,   
    IN ULONG Interval
    );

NTSTATUS 
HwTestFormat(
    IN PDEVICE_INSTANCE DeviceContext,
    IN PKSDATAFORMAT_WAVEFORMATEX DataFormat,
    IN BOOLEAN Playback
    );

NTSTATUS 
HwSetFormat(
    IN PDEVICE_INSTANCE DeviceContext,
    IN PWAVE_INSTANCE InstanceContext,
    IN PKSDATAFORMAT_WAVEFORMATEX DataFormat,
    IN BOOLEAN Playback
    );

NTSTATUS 
HwStop(
    IN PDEVICE_INSTANCE DeviceContext,
    IN PWAVE_INSTANCE InstanceContext,
    IN PWAVEPORT_DMAMAPPING DmaMapping
    );

NTSTATUS 
HwRead(
    IN PDEVICE_INSTANCE DeviceContext,
    IN PWAVE_INSTANCE InstanceContext,
    IN IN PVOID BufferAddress,
    IN ULONGLONG ByteOffset,
    IN ULONG Length
    );

NTSTATUS 
HwWrite(
    IN PDEVICE_INSTANCE DeviceContext,
    IN PWAVE_INSTANCE InstanceContext,
    IN PVOID BufferAddress,
    IN ULONGLONG ByteOffset,
    IN ULONG Length
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\ksfilter\msdalloc\msdalloc.c ===
/*++

Copyright (C) Microsoft Corporation, 1996 - 1998

Module Name:

    msdalloc.c

Abstract:

    Kernel Default Allocator.

--*/

#include "msdalloc.h"

typedef struct {
    KSDEVICE_HEADER     Header;
} DEVICE_INSTANCE, *PDEVICE_INSTANCE;

NTSTATUS
AllocDispatchCreate(
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, PnpAddDevice)
#pragma alloc_text(PAGE, AllocDispatchCreate)
#endif // ALLOC_PRAGMA

static const WCHAR DeviceTypeName[] = KSSTRING_Allocator;

static const DEFINE_KSCREATE_DISPATCH_TABLE(CreateItems) {
    DEFINE_KSCREATE_ITEM(AllocDispatchCreate, DeviceTypeName, 0)
};


NTSTATUS
PnpAddDevice(
    IN PDRIVER_OBJECT   DriverObject,
    IN PDEVICE_OBJECT   PhysicalDeviceObject
    )
/*++

Routine Description:

    When a new device is detected, PnP calls this entry point with the
    new PhysicalDeviceObject (PDO). The driver creates an associated 
    FunctionalDeviceObject (FDO).

Arguments:

    DriverObject -
        Pointer to the driver object.

    PhysicalDeviceObject -
        Pointer to the new physical device object.

Return Values:

    STATUS_SUCCESS or an appropriate error condition.

--*/
{
    PDEVICE_OBJECT      FunctionalDeviceObject;
    PDEVICE_INSTANCE    DeviceInstance;
    NTSTATUS            Status;
    ULONG               ResultLength;

    Status = IoCreateDevice(
        DriverObject,
        sizeof(DEVICE_INSTANCE),
        NULL,                           // FDOs are unnamed
        FILE_DEVICE_KS,
        0,
        FALSE,
        &FunctionalDeviceObject);
    if (!NT_SUCCESS(Status)) {
        return Status;
    }
    DeviceInstance = (PDEVICE_INSTANCE)FunctionalDeviceObject->DeviceExtension;
    //
    // This object uses KS to perform access through the DeviceCreateItems.
    //
    Status = KsAllocateDeviceHeader(
        &DeviceInstance->Header,
        SIZEOF_ARRAY(CreateItems),
        (PKSOBJECT_CREATE_ITEM)CreateItems);
    if (NT_SUCCESS(Status)) {
        KsSetDevicePnpAndBaseObject(
            DeviceInstance->Header,
            IoAttachDeviceToDeviceStack(
                FunctionalDeviceObject, 
                PhysicalDeviceObject),
            FunctionalDeviceObject );
        FunctionalDeviceObject->Flags |= DO_POWER_PAGABLE;
        FunctionalDeviceObject->Flags &= ~DO_DEVICE_INITIALIZING;
        return STATUS_SUCCESS;
    }
    IoDeleteDevice(FunctionalDeviceObject);
    return Status;
}


NTSTATUS
AllocDispatchCreate(
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp
    )
/*++

Routine Description:

    The IRP handler for IRP_MJ_CREATE for the Allocator. Hands off the
    request to the default allocator function.

Arguments:

    DeviceObject -
        The device object to which the Allocator is attached. This is not used.

    Irp -
        The specific close IRP to be processed.

Return Value:

    Returns STATUS_SUCCESS, else a memory allocation error.

--*/
{
    NTSTATUS Status;
    
    Status = KsCreateDefaultAllocator(Irp);
    Irp->IoStatus.Status = Status;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);
    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\ksfilter\msfsio\msfsio.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1998
//
//  File:       msfsio.h
//
//--------------------------------------------------------------------------

extern "C" {
#include <wdm.h>
#include <windef.h>
}
#include <ks.h>
#include <unknown.h>
#include <kcom.h>

#if (DBG)
#define STR_MODULENAME "msfsio: "
#endif
#include <ksdebug.h>

#define ID_DEVIO_PIN 0
#define ID_FILEIO_PIN 1

extern const KSDEVICE_DESCRIPTOR DeviceDescriptor;

class CFilter
{
public:
    HANDLE m_FileHandle;
    PFILE_OBJECT m_FileObject;
    static
    STDMETHODIMP
    Process(
        IN PKSFILTER Filter,
        IN PKSPROCESSPIN_INDEXENTRY ProcessPinsIndex
        );
    static
    STDMETHODIMP_(NTSTATUS)
    FilterCreate(
        IN OUT PKSFILTER Filter,
        IN PIRP Irp
        );
    static
    STDMETHODIMP_(NTSTATUS)
    FilterClose(
        IN OUT PKSFILTER Filter,
        IN PIRP Irp
        );
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\ksfilter\msfsio\filter.cpp ===
/*++

Copyright (C) Microsoft Corporation, 1998 - 1999

Module Name:

    filter.cpp

Abstract:

    Filter core, initialization, etc.
    
--*/

#include "msfsio.h"

#ifdef ALLOC_DATA_PRAGMA
#pragma const_seg("PAGECONST")
#endif // ALLOC_DATA_PRAGMA

#ifdef ALLOC_PRAGMA
#pragma code_seg("PAGE")
#endif // ALLOC_PRAGMA


STDMETHODIMP
CFilter::
Process(
    IN PKSFILTER Filter,
    IN PKSPROCESSPIN_INDEXENTRY ProcessPinsIndex
    )
{
// This is commented out because of a linker bug.
//    PAGED_CODE();
    _DbgPrintF(DEBUGLVL_VERBOSE,("Process"));

    CFilter* filter = reinterpret_cast<CFilter*>(Filter->Context);

    PKSPROCESSPIN ProcessPin = ProcessPinsIndex[ID_DEVIO_PIN].Pins[0];
    ASSERT(ProcessPin);
    
    IO_STATUS_BLOCK IoStatusBlock;
    NTSTATUS Status;

    //
    // This will never be called when BytesAvailable is zero, because no
    // flag has been set on the descriptor to force calling of the Process
    // function in that case.
    //
    if (ProcessPin->Pin->DataFlow == KSPIN_DATAFLOW_OUT) {
        //
        // Set the position to the current file position before the read.
        //
        ASSERT(filter->m_FileObject);
        ProcessPin->StreamPointer->StreamHeader->PresentationTime.Time = filter->m_FileObject->CurrentByteOffset.QuadPart;
        //
        // The file was opened for Synchronous I/O, so there is no reason
        // to wait for completion.
        //
        Status = KsReadFile(
            filter->m_FileObject,
            NULL,
            NULL,
            &IoStatusBlock,
            ProcessPin->Data,
            ProcessPin->BytesAvailable,
            0,
            KernelMode);
        if (NT_SUCCESS(Status) || (Status == STATUS_END_OF_FILE)) {
            //
            // Always use 1/1 time format. The Interface is byte based, so time
            // is based on byte position of actual bytes read. The offset was
            // updated above if needed.
            //
            ProcessPin->StreamPointer->StreamHeader->PresentationTime.Numerator = 1;
            ProcessPin->StreamPointer->StreamHeader->PresentationTime.Denominator = 1;
            ProcessPin->StreamPointer->StreamHeader->Duration = IoStatusBlock.Information;
            ProcessPin->StreamPointer->StreamHeader->OptionsFlags |= (KSSTREAM_HEADER_OPTIONSF_TIMEVALID | KSSTREAM_HEADER_OPTIONSF_DURATIONVALID);
            if (Status == STATUS_END_OF_FILE) {
                //
                // We will actually get this status only when reads go precisely
                // to the end of file.  In other cases, the last read will be
                // short, and the status will be STATUS_SUCCESS.  Because we
                // indicate end-of-stream, there will be no subsequent reads.  If
                // STATUS_END_OF_FILE is returned, IoStatusBlock.Information is
                // bogus.
                //
                IoStatusBlock.Information = 0;
                Status = STATUS_SUCCESS;
            }
            if (IoStatusBlock.Information < ProcessPin->BytesAvailable) {
                //
                // Only when the end of the file is reached should an end-of-stream
                // be specified. Adding this flag has the effect of terminating this
                // packet, plus setting it in the stream header.
                //
                ProcessPin->Flags |= KSSTREAM_HEADER_OPTIONSF_ENDOFSTREAM;
            }
        }
    } else if ((ProcessPin->StreamPointer->StreamHeader->OptionsFlags & KSSTREAM_HEADER_OPTIONSF_DURATIONVALID) &&
        (ProcessPin->StreamPointer->StreamHeader->Duration != ProcessPin->BytesAvailable)) {
        //
        // If a duration is specified, then it must be the same byte duration
        // as the actual data size. The expectation is that this packet will
        // only be processed once, and will either succeed or fail, so
        // BytesAvailable should represent the entire packet.
        //
        Status = STATUS_INVALID_PARAMETER;
    } else {
        //
        // Determine if the current file position needs to be set.
        //
        if (ProcessPin->StreamPointer->StreamHeader->OptionsFlags & KSSTREAM_HEADER_OPTIONSF_TIMEVALID) {
            //
            // A 1/1 time mode is the only acceptable one.
            //
            if ((ProcessPin->StreamPointer->StreamHeader->PresentationTime.Numerator != 1) || (ProcessPin->StreamPointer->StreamHeader->PresentationTime.Denominator != 1)) {
                return STATUS_INVALID_PARAMETER;
            }
            filter->m_FileObject->CurrentByteOffset.QuadPart = ProcessPin->StreamPointer->StreamHeader->PresentationTime.Time;
        }
        Status = KsWriteFile(
            filter->m_FileObject,
            NULL,
            NULL,
            &IoStatusBlock,
            ProcessPin->Data,
            ProcessPin->BytesAvailable,
            0,
            KernelMode);
    }    
    //
    // If the I/O succeeded, then update the BytesUsed with
    // however large the transaction actually was.
    //
    if (NT_SUCCESS(Status)) {
        ProcessPin->BytesUsed = (ULONG)IoStatusBlock.Information;
    }
    return Status;
}

//
// Topology
//

DEFINE_KSPIN_INTERFACE_TABLE(PinFileIoInterfaces) {
    {
        STATICGUIDOF(KSINTERFACESETID_FileIo),
        KSINTERFACE_FILEIO_STREAMING,
        0
    }
};

//
// Data Formats
//

const KSDATARANGE PinFileIoRange = {
    sizeof(PinFileIoRange),
    0,
    0,
    0,
    STATICGUIDOF(KSDATAFORMAT_TYPE_STREAM),
    STATICGUIDOF(KSDATAFORMAT_SUBTYPE_NONE),
    STATICGUIDOF(KSDATAFORMAT_SPECIFIER_FILENAME)
};

const PKSDATARANGE PinFileIoRanges[] = {
    (PKSDATARANGE)&PinFileIoRange
};

const KSDATARANGE PinDevIoRange = {
    sizeof(PinDevIoRange),
    0,
    0,
    0,
    STATICGUIDOF(KSDATAFORMAT_TYPE_STREAM),
    STATICGUIDOF(KSDATAFORMAT_SUBTYPE_WILDCARD),
    STATICGUIDOF(KSDATAFORMAT_SPECIFIER_NONE)
};

const PKSDATARANGE PinDevIoRanges[] = {
    (PKSDATARANGE)&PinDevIoRange
};

DECLARE_SIMPLE_FRAMING_EX(
    AllocatorFraming,
    STATICGUIDOF(KSMEMORY_TYPE_KERNEL_PAGED),
    0,
    1,
    0,
    0,//MinPage
    ULONG(-1));//MaxPage


STDMETHODIMP_(NTSTATUS)
CFilter::
FilterCreate(
    IN OUT PKSFILTER Filter,
    IN PIRP Irp
    )
{
    _DbgPrintF(DEBUGLVL_VERBOSE,("FilterCreate"));

    ASSERT(Filter);
    ASSERT(Irp);
    
    NTSTATUS Status;

    if (Filter->Context = PVOID(new(PagedPool,'IFsK') CFilter)) {
        //
        // This is used in places to quickly determine whether or not the pin is
        // connected.  Processing cannot happen 'til we have one of these.
        //
        reinterpret_cast<CFilter*>(Filter->Context)->m_FileObject = NULL;
        Status = STATUS_SUCCESS;
    } else {
        Status = STATUS_INSUFFICIENT_RESOURCES;
    }
                    
    return Status;
}


STDMETHODIMP_(NTSTATUS)
CFilter::
FilterClose(
    IN OUT PKSFILTER Filter,
    IN PIRP Irp
    )
{
    _DbgPrintF(DEBUGLVL_VERBOSE,("FilterClose"));

    ASSERT(Filter);
    ASSERT(Irp);
    
    CFilter* filter = reinterpret_cast<CFilter*>(Filter->Context);
    ASSERT(filter);

    delete filter;
                    
    return STATUS_SUCCESS;
}


NTSTATUS
PinFileIoSetDataFormat(
    IN PKSPIN Pin,
    IN PKSDATAFORMAT OldFormat OPTIONAL,
    IN PKSMULTIPLE_ITEM OldAttributeList OPTIONAL,
    IN const KSDATARANGE* DataRange,
    IN const KSATTRIBUTE_LIST* AttributeRange OPTIONAL
    )
{
    //
    // Just check for a NULL terminated string.
    //
    PWCHAR FileName = PWCHAR(Pin->ConnectionFormat + 1);
    if ((Pin->ConnectionFormat->FormatSize > sizeof(*Pin->ConnectionFormat)) &&
        !(Pin->ConnectionFormat->FormatSize % sizeof(*FileName)) &&
        (FileName[(Pin->ConnectionFormat->FormatSize - sizeof(*Pin->ConnectionFormat)) / sizeof(FileName[0]) - 1] == UNICODE_NULL)) {
        return STATUS_SUCCESS;
    }
    return STATUS_OBJECT_NAME_INVALID;
}


NTSTATUS
PinFileIoCreate(
    IN OUT PKSPIN Pin,
    IN PIRP Irp
    )
{
    _DbgPrintF(DEBUGLVL_VERBOSE,("PinFileIoCreate filter %d as %s",Pin->Id,(Pin->Communication == KSPIN_COMMUNICATION_SOURCE) ? "SOURCE" : "SINK"));

    ASSERT(Pin);
    ASSERT(Irp);

    CFilter* filter = reinterpret_cast<CFilter*>(Pin->Context);

    //
    // The string has already been validated by this point.
    //
    PWCHAR FileName = PWCHAR(Pin->ConnectionFormat + 1);
    //
    // Attempt to open the file based on the access rights of the caller.
    // Note that the SYNCHRONIZE flag must be set on the Create even
    // though this is contained in the translated GENERIC_READ attributes.
    // This is because the bit is tested before the Generic attributes
    // are translated. This filter only does synchronous I/O on stream
    // Read requests.
    //
    UNICODE_STRING FileNameString;

    RtlInitUnicodeString(&FileNameString, FileName);

    OBJECT_ATTRIBUTES ObjectAttributes;

    InitializeObjectAttributes(
        &ObjectAttributes,
        &FileNameString,
        OBJ_CASE_INSENSITIVE,
        NULL,
        NULL);
    //
    // Set the access desired based on the type of filter which was
    // actually created.
    //
    ACCESS_MASK DesiredHandleAccess;
    ACCESS_MASK DesiredObjectAccess;
    ULONG ShareAccess;
    ULONG Disposition;

    switch (Pin->DataFlow) {
    case KSPIN_DATAFLOW_IN:
        DesiredHandleAccess = GENERIC_READ | SYNCHRONIZE;
        DesiredObjectAccess = FILE_READ_DATA;
        ShareAccess = FILE_SHARE_READ;
        Disposition = FILE_OPEN;
        break;
    case KSPIN_DATAFLOW_OUT:
        DesiredHandleAccess = GENERIC_WRITE | SYNCHRONIZE;
        DesiredObjectAccess = FILE_WRITE_DATA;
        ShareAccess = 0;
        Disposition = FILE_OPEN_IF;
        break;
    }
    //
    // The only reason the file handle is kept is that the file system keeps track
    // of locks based on handles, and assumes the file is closing if no handles are
    // opened on a file object, which results in I/O to that file object failing.
    //
    IO_STATUS_BLOCK IoStatusBlock;

    NTSTATUS Status = IoCreateFile(
        &filter->m_FileHandle,
        DesiredHandleAccess,
        &ObjectAttributes,
        &IoStatusBlock,
        NULL,
        0,
        ShareAccess,
        Disposition,
        FILE_SYNCHRONOUS_IO_NONALERT,
        NULL,
        0,
        CreateFileTypeNone,
        NULL,
        IO_FORCE_ACCESS_CHECK | IO_NO_PARAMETER_CHECKING);
    if (NT_SUCCESS(Status)) {
        Status = ObReferenceObjectByHandle(
            filter->m_FileHandle,
            DesiredObjectAccess,
            *IoFileObjectType,
            ExGetPreviousMode(),
            reinterpret_cast<PVOID*>(&filter->m_FileObject),
            NULL);
        if (! NT_SUCCESS(Status)) {
            ZwClose(filter->m_FileHandle);
        }
    }
    return Status;
}


NTSTATUS
PinFileIoClose(
    IN OUT PKSPIN Pin,
    IN PIRP Irp
    )
{
    _DbgPrintF(DEBUGLVL_VERBOSE,("PinFileIoClose %d",Pin->Id));

    ASSERT(Pin);
    ASSERT(Irp);

    CFilter* filter = reinterpret_cast<CFilter*>(Pin->Context);

    ObDereferenceObject(filter->m_FileObject);
    //
    // This is used in places to quickly determine whether or not the pin is
    // connected. So it must be reset on disconnection.
    //
    filter->m_FileObject = NULL;
    ZwClose(filter->m_FileHandle);
    return STATUS_SUCCESS;
}

const
KSPIN_DISPATCH
PinFileIoDispatch =
{
    PinFileIoCreate,
    PinFileIoClose,
    NULL,// Process
    NULL,// Reset
    PinFileIoSetDataFormat,
    NULL,// SetDeviceState
    NULL,// Connect
    NULL// Disconnect
};

const
GUID
SubTypeNone = {STATICGUIDOF(KSDATAFORMAT_SUBTYPE_NONE)};

const
GUID
SubTypeWildcard = {STATICGUIDOF(KSDATAFORMAT_SUBTYPE_WILDCARD)};


NTSTATUS
PinIntersectHandler(
    IN PVOID Filter,
    IN PIRP Irp,
    IN PKSP_PIN PinInstance,
    IN PKSDATARANGE CallerDataRange,
    IN PKSDATARANGE DescriptorDataRange,
    IN ULONG BufferSize,
    OUT PVOID Data OPTIONAL,
    OUT PULONG DataSize
    )
{
    ASSERT(Filter);
    ASSERT(Irp);
    ASSERT(PinInstance);
    ASSERT(CallerDataRange);
    ASSERT(DescriptorDataRange);
    ASSERT(DataSize);
    
    _DbgPrintF(DEBUGLVL_BLAB,("PinIntersectHandler"));

    if ((PinInstance->PinId == ID_DEVIO_PIN) && (CallerDataRange->FormatSize != DescriptorDataRange->FormatSize)) {
        return STATUS_NO_MATCH;
    }
    *DataSize = sizeof(KSDATAFORMAT);
    if (!BufferSize) {
        //
        // Size only query.
        //
        return STATUS_BUFFER_OVERFLOW;
    }
    //
    // Copy over the KSDATAFORMAT. The buffer size will be at least as large
    // as a data format structure.
    //
    ASSERT(BufferSize >= sizeof(KSDATAFORMAT));
    RtlCopyMemory(
        Data,
        CallerDataRange,
        sizeof(*CallerDataRange));
    if ((PinInstance->PinId == ID_DEVIO_PIN) && (CallerDataRange->SubFormat == SubTypeWildcard)) {
        PKSDATAFORMAT(Data)->SubFormat = SubTypeNone;
    }
    return STATUS_SUCCESS;
}

const
GUID
TimeFormatByte = {STATICGUIDOF(KSTIME_FORMAT_BYTE)};


NTSTATUS
Property_GetTimeFormat(
    IN PIRP Irp,
    IN PKSPROPERTY Property,
    OUT GUID* TimeFormat
    )
/*++

Routine Description:

    Handles the KSPROPERTY_STREAM_TIMEFORMAT property Get in the Stream property
    set. Returns the time format on the Dev I/O Pin so that positional
    translations can be performed.

Arguments:

    Irp -
        Device control Irp.

    Property -
        Specific property request.

    TimeFormat -
        The place in which to put the time format.

Return Values:

    Returns STATUS_SUCCESS.

--*/
{
    *TimeFormat = TimeFormatByte;
//    Irp->IoStatus.Information = sizeof(*TimeFormat);
    return STATUS_SUCCESS;
}


NTSTATUS
Property_GetPresentationTime(
    IN PIRP Irp,
    IN PKSPROPERTY Property,
    OUT PKSTIME PresentationTime
    )
/*++

Routine Description:

    Handles the KSPROPERTY_STREAM_PRESENTATIONTIME property Get in the Stream property
    set. Retrieves the current file position if there is a File I/O Pin instance.

Arguments:

    Irp -
        Device control Irp.

    Property -
        Specific property request.

    PresentationTime -
        The place in which to put the current file position in native units.

Return Values:

    Returns STATUS_SUCCESS, else STATUS_DEVICE_NOT_CONNECTED if there is no File I/O Pin.

--*/
{

    PKSPIN Pin= KsGetPinFromIrp(Irp);
    if ( NULL == Pin ) {
        ASSERT( Pin && "Irp has no pin" );
        return STATUS_INVALID_PARAMETER;
    }
    
    PKSFILTER Filter = KsPinGetParentFilter(Pin);
    CFilter* filter = reinterpret_cast<CFilter*>(Filter->Context);
    NTSTATUS Status;

    KsFilterAcquireControl(Filter);
    if (filter->m_FileObject) {
        //
        // The file is locked, so this can be accessed directly.
        //
        PresentationTime->Time = filter->m_FileObject->CurrentByteOffset.QuadPart;
        PresentationTime->Numerator = 1;
        PresentationTime->Denominator = 1;
//        Irp->IoStatus.Information = sizeof(*PresentationTime);
        Status = STATUS_SUCCESS;
    } else {
        Status = STATUS_DEVICE_NOT_CONNECTED;
    }
    KsFilterReleaseControl(Filter);
    return Status;
}


NTSTATUS
Property_SetPresentationTime(
    IN PIRP Irp,
    IN PKSPROPERTY Property,
    IN PKSTIME PresentationTime
    )
/*++

Routine Description:

    Handles the KSPROPERTY_STREAM_PRESENTATIONTIME property Set in the Stream property
    set. Sets the current file position if there is a File I/O Pin instance.

Arguments:

    Irp -
        Device control Irp.

    Property -
        Specific property request.

    PresentationTime -
        Points to the new file position expressed in native units.

Return Values:

    Returns STATUS_SUCCESS, else STATUS_DEVICE_NOT_CONNECTED if there is no File I/O Pin.

--*/
{
    //
    // The data source specifies the valid Numerator/Denominator. Also, negative
    // values for position are illegal for file systems.
    //
    if ((PresentationTime->Numerator != 1) || (PresentationTime->Denominator != 1) || ((LONGLONG)PresentationTime->Time < 0)) {
        return STATUS_INVALID_PARAMETER_MIX;
    }

	PKSPIN Pin= KsGetPinFromIrp(Irp);
	if ( NULL == Pin ) {
		ASSERT( Pin && "Irp has no pin" );
		return STATUS_INVALID_PARAMETER;
	}
	
    PKSFILTER Filter = KsPinGetParentFilter(Pin);
    CFilter* filter = reinterpret_cast<CFilter*>(Filter->Context);
    NTSTATUS Status;

    KsFilterAcquireControl(Filter);
    if (filter->m_FileObject) {
        FILE_STANDARD_INFORMATION StandardInformation;

        //
        // Retrieve the actual length of the file.
        //
        Status = KsQueryInformationFile(
            filter->m_FileObject,
            &StandardInformation,
            sizeof(StandardInformation),
            FileStandardInformation);
        if (NT_SUCCESS(Status)) {
            //
            // Don't allow the caller to seek off the end of the file.
            //
            if (StandardInformation.EndOfFile.QuadPart >= (LONGLONG)PresentationTime->Time) {
                //
                // The file is locked, so this can be accessed directly.
                //
                filter->m_FileObject->CurrentByteOffset.QuadPart = PresentationTime->Time;
            } else {
                Status = STATUS_END_OF_FILE;
            }
        }
    } else {
        Status = STATUS_DEVICE_NOT_CONNECTED;
    }
    KsFilterReleaseControl(Filter);
    return Status;
}


NTSTATUS
Property_GetPresentationExtent(
    IN PIRP Irp,
    IN PKSPROPERTY Property,
    OUT PULONGLONG PresentationExtent
    )
/*++

Routine Description:

    Handles the KSPROPERTY_STREAM_PRESENTATIONEXTENT property Get in the Stream property
    set. Retrieves the current file extent if there is a File I/O Pin instance.

Arguments:

    Irp -
        Device control Irp.

    Property -
        Specific property request.

    PresentationExtent -
        The place in which to put the file length in native units.

Return Values:

    Returns STATUS_SUCCESS, else STATUS_DEVICE_NOT_CONNECTED if there is no File I/O Pin.

--*/
{
    PKSFILTER Filter = KsPinGetParentFilter(KsGetPinFromIrp(Irp));
    CFilter* filter = reinterpret_cast<CFilter*>(Filter->Context);
    NTSTATUS Status;

    KsFilterAcquireControl(Filter);
    if (filter->m_FileObject) {
        FILE_STANDARD_INFORMATION StandardInformation;

        Status = KsQueryInformationFile(
            filter->m_FileObject,
            &StandardInformation,
            sizeof(StandardInformation),
            FileStandardInformation);
        if (NT_SUCCESS(Status)) {
            *PresentationExtent = StandardInformation.EndOfFile.QuadPart;
//            Irp->IoStatus.Information = sizeof(*PresentationExtent);
        }
    } else {
        Status = STATUS_DEVICE_NOT_CONNECTED;
    }
    KsFilterReleaseControl(Filter);
    return Status;
}

DEFINE_KSPROPERTY_TABLE(PinStreamProperties) {
    DEFINE_KSPROPERTY_ITEM_STREAM_TIMEFORMAT(Property_GetTimeFormat),
    DEFINE_KSPROPERTY_ITEM_STREAM_PRESENTATIONTIME(Property_GetPresentationTime, Property_SetPresentationTime),
    DEFINE_KSPROPERTY_ITEM_STREAM_PRESENTATIONEXTENT(Property_GetPresentationExtent)
};

const
GUID
PropSetStream = {STATICGUIDOF(KSPROPSETID_Stream)};

DEFINE_KSPROPERTY_SET_TABLE(PinPropertySets) {
    DEFINE_KSPROPERTY_SET(
        &PropSetStream,
        SIZEOF_ARRAY(PinStreamProperties),
        PinStreamProperties,
        0,
        NULL)
};


NTSTATUS
Method_StreamIoRead(
    IN PIRP Irp,
    IN PKSMETHOD Method,
    OUT PBYTE Buffer
    )
{
    PKSFILTER Filter = KsPinGetParentFilter(KsGetPinFromIrp(Irp));
    NTSTATUS Status;

    KsFilterAcquireControl(Filter);
    //
    // Ensure that the caller actually has Read access.
    //
    if (Filter->Descriptor->PinDescriptors[ID_DEVIO_PIN].PinDescriptor.DataFlow == KSPIN_DATAFLOW_OUT) {
        CFilter* filter = reinterpret_cast<CFilter*>(Filter->Context);
        PFILE_OBJECT FileObject;

        if (filter->m_FileObject) {
            //
            // The file was opened for Synchronous I/O, so there is no reason
            // to wait for completion.
            //
            Status = KsReadFile(
                filter->m_FileObject,
                NULL,
                NULL,
                &Irp->IoStatus,
                Buffer,
                IoGetCurrentIrpStackLocation(Irp)->Parameters.DeviceIoControl.OutputBufferLength,
                0,
                KernelMode);
        } else {
            Status = STATUS_DEVICE_NOT_CONNECTED;
        }
    } else {
        Status = STATUS_ACCESS_DENIED;
    }
    KsFilterReleaseControl(Filter);
    return Status;
}


NTSTATUS
Method_StreamIoWrite(
    IN PIRP Irp,
    IN PKSMETHOD Method,
    IN PBYTE Buffer
    )
{
    PKSFILTER Filter = KsPinGetParentFilter(KsGetPinFromIrp(Irp));
    NTSTATUS Status;

    KsFilterAcquireControl(Filter);
    //
    // Ensure that the caller actually has Write access.
    //
    if (Filter->Descriptor->PinDescriptors[ID_DEVIO_PIN].PinDescriptor.DataFlow == KSPIN_DATAFLOW_IN) {
        CFilter* filter = reinterpret_cast<CFilter*>(Filter->Context);
        PFILE_OBJECT FileObject;

        if (filter->m_FileObject) {
            //
            // The file was opened for Synchronous I/O, so there is no reason
            // to wait for completion.
            //
            Status = KsWriteFile(
                filter->m_FileObject,
                NULL,
                NULL,
                &Irp->IoStatus,
                Buffer,
                IoGetCurrentIrpStackLocation(Irp)->Parameters.DeviceIoControl.OutputBufferLength,
                0,
                KernelMode);
        } else {
            Status = STATUS_DEVICE_NOT_CONNECTED;
        }
    } else {
        Status = STATUS_ACCESS_DENIED;
    }
    KsFilterReleaseControl(Filter);
    return Status;
}

DEFINE_KSMETHOD_TABLE(PinStreamIoMethods) {
    DEFINE_KSMETHOD_ITEM_STREAMIO_READ(Method_StreamIoRead),
    DEFINE_KSMETHOD_ITEM_STREAMIO_WRITE(Method_StreamIoWrite)
};

const
GUID
MethSetStreamIo = {STATICGUIDOF(KSMETHODSETID_StreamIo)};

DEFINE_KSMETHOD_SET_TABLE(PinMethodSets) {
    DEFINE_KSMETHOD_SET(
        &MethSetStreamIo,
        SIZEOF_ARRAY(PinStreamIoMethods),
        PinStreamIoMethods,
        0,
        NULL)
};

DEFINE_KSAUTOMATION_TABLE(PinAutomation) {
    DEFINE_KSAUTOMATION_PROPERTIES(PinPropertySets),
    DEFINE_KSAUTOMATION_METHODS(PinMethodSets),
    DEFINE_KSAUTOMATION_EVENTS_NULL
};

const
KSPIN_DESCRIPTOR_EX
KsPinReaderDescriptors[] =
{
    {
        NULL,
        &PinAutomation,
        {
            DEFINE_KSPIN_DEFAULT_INTERFACES,
            DEFINE_KSPIN_DEFAULT_MEDIUMS,
            SIZEOF_ARRAY(PinDevIoRanges),
            PinDevIoRanges,
            KSPIN_DATAFLOW_OUT,
            KSPIN_COMMUNICATION_BOTH,
            NULL,//Name
            NULL,//Category
            0
        },
        KSPIN_FLAG_ASYNCHRONOUS_PROCESSING | KSPIN_FLAG_FIXED_FORMAT ,//| KSPIN_FLAG_ENFORCE_FIFO,
        1,
        1,
        &AllocatorFraming,
        PinIntersectHandler
    },
    {
        &PinFileIoDispatch,
        NULL,//Automation
        {
            SIZEOF_ARRAY(PinFileIoInterfaces),
            PinFileIoInterfaces,
            DEFINE_KSPIN_DEFAULT_MEDIUMS,
            SIZEOF_ARRAY(PinFileIoRanges),
            PinFileIoRanges,
            KSPIN_DATAFLOW_IN,
            KSPIN_COMMUNICATION_BRIDGE,
            NULL,//Name
            NULL,//Category
            0
        },
        KSPIN_FLAG_FIXED_FORMAT,
        1,
        1,
        NULL,//AllocatorFraming
        PinIntersectHandler
    }
};

const
KSPIN_DESCRIPTOR_EX
KsPinWriterDescriptors[] =
{
    {
        NULL,
        &PinAutomation,
        {
            DEFINE_KSPIN_DEFAULT_INTERFACES,
            DEFINE_KSPIN_DEFAULT_MEDIUMS,
            SIZEOF_ARRAY(PinDevIoRanges),
            PinDevIoRanges,
            KSPIN_DATAFLOW_IN,
            KSPIN_COMMUNICATION_BOTH,
            NULL,//Name
            NULL,//Category
            0
        },
        KSPIN_FLAG_RENDERER | KSPIN_FLAG_ASYNCHRONOUS_PROCESSING | KSPIN_FLAG_FIXED_FORMAT ,//| KSPIN_FLAG_ENFORCE_FIFO,
        1,
        1,
        &AllocatorFraming,
        PinIntersectHandler
    },
    {
        &PinFileIoDispatch,
        NULL,//Automation
        {
            SIZEOF_ARRAY(PinFileIoInterfaces),
            PinFileIoInterfaces,
            DEFINE_KSPIN_DEFAULT_MEDIUMS,
            SIZEOF_ARRAY(PinFileIoRanges),
            PinFileIoRanges,
            KSPIN_DATAFLOW_OUT,
            KSPIN_COMMUNICATION_BRIDGE,
            NULL,//Name
            NULL,//Category
            0
        },
        KSPIN_FLAG_FIXED_FORMAT,
        1,
        1,
        NULL,//AllocatorFraming
        PinIntersectHandler
    }
};

//
// This type of definition is required because the compiler will not otherwise
// put these GUIDs in a paged segment.
//
const
GUID
NodeType = {STATICGUIDOF(KSCATEGORY_MEDIUMTRANSFORM)};

const
KSNODE_DESCRIPTOR
KsNodeDescriptors[] =
{
    DEFINE_NODE_DESCRIPTOR(NULL,&NodeType,NULL)
};

const
KSTOPOLOGY_CONNECTION
KsReaderConnections[] =
{
    { KSFILTER_NODE, ID_FILEIO_PIN, 0, 0 },
    { 0, 1, KSFILTER_NODE, ID_DEVIO_PIN }
};

const
KSTOPOLOGY_CONNECTION
KsWriterConnections[] =
{
    { KSFILTER_NODE, ID_DEVIO_PIN, 0, 1 },
    { 0, 0, KSFILTER_NODE, ID_FILEIO_PIN }
};

const
KSFILTER_DISPATCH
FilterDispatch =
{
    CFilter::FilterCreate,
    CFilter::FilterClose,
    CFilter::Process,
    NULL // Reset
};

const
GUID
DeviceTypeReader = {0x760FED5C,0x9357,0x11D0,0xA3,0xCC,0x00,0xA0,0xC9,0x22,0x31,0x96};

const
GUID
DeviceTypeWriter = {0x760FED5D,0x9357,0x11D0,0xA3,0xCC,0x00,0xA0,0xC9,0x22,0x31,0x96};

const
GUID
FormatMediaTime = {STATICGUIDOF(KSTIME_FORMAT_MEDIA_TIME)};


NTSTATUS
Property_SeekingFormats(
    IN PIRP Irp,
    IN PKSPROPERTY Property,
    OUT PVOID Data
    )
/*++

Routine Description:

    Handles the KSPROPERTY_MEDIASEEKING_FORMATS property in the MediaSeeking property
    set. This is only implemented so that ActiveMovie graph control thinks that
    this filter can generate EC_COMPLETE.

Arguments:

    Irp -
        Device control Irp.

    Property -
        Specific property request.

    Data -
        The place in which to return the media seeking formats handled.

Return Values:

    returns STATUS_SUCCESS, else STATUS_INVALID_PARAMETER,
    STATUS_BUFFER_TOO_SMALL, or STATUS_INVALID_BUFFER_SIZE.

--*/
{
    return KsHandleSizedListQuery(Irp, 1, sizeof(GUID), &FormatMediaTime);
}

DEFINE_KSPROPERTY_TABLE(FilterSeekingProperties) {
    DEFINE_KSPROPERTY_ITEM_MEDIASEEKING_FORMATS(Property_SeekingFormats)
};

const
GUID
PropSetMediaSeeking = {STATICGUIDOF(KSPROPSETID_MediaSeeking)};

DEFINE_KSPROPERTY_SET_TABLE(FilterPropertySets) {
    DEFINE_KSPROPERTY_SET(
        &PropSetMediaSeeking,
        SIZEOF_ARRAY(FilterSeekingProperties),
        FilterSeekingProperties,
        0,
        NULL)
};

DEFINE_KSAUTOMATION_TABLE(FilterAutomation) {
    DEFINE_KSAUTOMATION_PROPERTIES(FilterPropertySets),
    DEFINE_KSAUTOMATION_METHODS_NULL,
    DEFINE_KSAUTOMATION_EVENTS_NULL
};

DEFINE_KSFILTER_DESCRIPTOR(ReaderFilterDescriptor)
{   
    &FilterDispatch,
    &FilterAutomation,
    KSFILTER_DESCRIPTOR_VERSION,
    0,//Flags
    &DeviceTypeReader,
    DEFINE_KSFILTER_PIN_DESCRIPTORS(KsPinReaderDescriptors),
    DEFINE_KSFILTER_CATEGORIES_NULL,
    DEFINE_KSFILTER_NODE_DESCRIPTORS(KsNodeDescriptors),
    DEFINE_KSFILTER_CONNECTIONS(KsReaderConnections),
    NULL // ComponentId
};

DEFINE_KSFILTER_DESCRIPTOR(WriterFilterDescriptor)
{   
    &FilterDispatch,
    &FilterAutomation,
    KSFILTER_DESCRIPTOR_VERSION,
    0,//Flags
    &DeviceTypeWriter,
    DEFINE_KSFILTER_PIN_DESCRIPTORS(KsPinWriterDescriptors),
    DEFINE_KSFILTER_CATEGORIES_NULL,
    DEFINE_KSFILTER_NODE_DESCRIPTORS(KsNodeDescriptors),
    DEFINE_KSFILTER_CONNECTIONS(KsWriterConnections),
    NULL // ComponentId
};

DEFINE_KSFILTER_DESCRIPTOR_TABLE(FilterDescriptors)
{
    &ReaderFilterDescriptor,
    &WriterFilterDescriptor
};

extern
const
KSDEVICE_DESCRIPTOR 
DeviceDescriptor =
{   
    NULL,
    SIZEOF_ARRAY(FilterDescriptors),
    FilterDescriptors
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\ksfilter\msmpu401\common.h ===
/*++

Copyright (C) Microsoft Corporation, 1996 - 1997

Module Name:

	common.h

Abstract:

	Internal header file for filter.

--*/

#include <ntddk.h>
#include <windef.h>
#include <tchar.h>
#include <ks.h>
#include <ksmedia.h>
#include <drvhelp.h>
#include "private.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\ksfilter\mskssrv\mskssrv.h ===
/*++

Copyright (C) Microsoft Corporation, 1996 - 1997

Module Name:

    mskssrv.h

Abstract:

    Internal header file for filter.

--*/

#include <wdm.h>
#include <windef.h>

#include <memory.h>
#include <stddef.h>
#include <stdio.h>
#include <limits.h>
#include <stdlib.h>
#include <tchar.h>
#include <conio.h>

#include <ks.h>
#include <swenum.h>
#include <ksi.h>
#include <ksdebug.h>

#if (DBG)
#define STR_MODULENAME  "mskssrv: "
#endif // DBG

NTSTATUS
PnpAddDevice(
    IN PDRIVER_OBJECT   DriverObject,
    IN PDEVICE_OBJECT   PhysicalDeviceObject
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\ksfilter\mskssrv\mskssrv.c ===
/*++

Copyright (C) Microsoft Corporation, 1997 - 1999

Module Name:

    mskssrv.c

Abstract:

    Kernel Server Driver

--*/

#include "mskssrv.h"

typedef struct {
    KSDEVICE_HEADER     Header;
} DEVICE_INSTANCE, *PDEVICE_INSTANCE;

typedef struct {
    KSOBJECT_HEADER     Header;
    ULONG               Reserved;
} INSTANCE, *PINSTANCE;

#define FCC(ch4) ((((DWORD)(ch4) & 0xFF) << 24) |     \
                  (((DWORD)(ch4) & 0xFF00) << 8) |    \
                  (((DWORD)(ch4) & 0xFF0000) >> 8) |  \
                  (((DWORD)(ch4) & 0xFF000000) >> 24))

// OK to have zero instances of pin In this case you will have to
// Create a pin to have even one instance
#define REG_PIN_B_ZERO 0x1

// The filter renders this input
#define REG_PIN_B_RENDERER 0x2

// OK to create many instance of  pin
#define REG_PIN_B_MANY 0x4

// This is an Output pin
#define REG_PIN_B_OUTPUT 0x8

typedef struct {
    ULONG   Version;
    ULONG   Merit;
    ULONG   Pins;
    ULONG   Reserved;
} REGFILTER_REG;

typedef struct {
    ULONG   Signature;
    ULONG   Flags;
    ULONG   PossibleInstances;
    ULONG   MediaTypes;
    ULONG   MediumTypes;
    ULONG   Category;
} REGFILTERPINS_REG2;

typedef struct {
    ULONG   Signature;
    ULONG   Reserved;
    ULONG   MajorType;
    ULONG   MinorType;
} REGPINTYPES_REG2;

NTSTATUS
PropertySrv(
    IN PIRP Irp,
    IN PKSPROPERTY Property,
    IN PBYTE Data
    );
NTSTATUS
SrvDispatchCreate(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );
NTSTATUS
SrvDispatchIoControl(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );
NTSTATUS
SrvDispatchClose(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

#ifdef ALLOC_PRAGMA
NTSTATUS
GetFilterPinCount(
    IN PFILE_OBJECT FilterObject,
    OUT PULONG PinCount
    );
NTSTATUS
GetPinTypes(
    IN PFILE_OBJECT FilterObject,
    IN ULONG Pin,
    IN ULONG Id,
    OUT PULONG Types
    );
NTSTATUS
GetPinFlags(
    IN PFILE_OBJECT FilterObject,
    IN ULONG Pin,
    OUT PULONG Flags
    );
NTSTATUS
GetPinInstances(
    IN PFILE_OBJECT FilterObject,
    IN ULONG Pin,
    OUT PULONG PossibleInstances
    );
NTSTATUS
GetPinTypeList(
    IN PFILE_OBJECT FilterObject,
    IN ULONG Pin,
    IN ULONG Id,
    OUT PKSMULTIPLE_ITEM* MultipleItem
    );
NTSTATUS
GetPinCategory(
    IN PFILE_OBJECT FilterObject,
    IN ULONG Pin,
    OUT GUID* Category
    );
VOID
InsertCacheItem(
    IN PVOID Item,
    IN ULONG ItemSize,
    IN PVOID OffsetBase,
    IN PVOID CacheBase,
    IN OUT PULONG ItemsCached,
    OUT PULONG ItemOffset
    );
VOID
ExtractMediaTypes(
    IN PKSMULTIPLE_ITEM MediaTypeList,
    IN ULONG MediaType,
    OUT GUID* MajorType,
    OUT GUID* MinorType
    );
NTSTATUS
BuildFilterData(
    IN PFILE_OBJECT FilterObject,
    IN ULONG Merit,
    OUT PUCHAR* FilterData,
    OUT ULONG* FilterDataLength
    );
#pragma alloc_text(PAGE, PnpAddDevice)
#pragma alloc_text(PAGE, GetFilterPinCount)
#pragma alloc_text(PAGE, GetPinTypes)
#pragma alloc_text(PAGE, GetPinFlags)
#pragma alloc_text(PAGE, GetPinInstances)
#pragma alloc_text(PAGE, GetPinTypeList)
#pragma alloc_text(PAGE, GetPinCategory)
#pragma alloc_text(PAGE, InsertCacheItem)
#pragma alloc_text(PAGE, ExtractMediaTypes)
#pragma alloc_text(PAGE, BuildFilterData)
#pragma alloc_text(PAGE, PropertySrv)
#pragma alloc_text(PAGE, SrvDispatchCreate)
#pragma alloc_text(PAGE, SrvDispatchIoControl)
#pragma alloc_text(PAGE, SrvDispatchClose)
#endif // ALLOC_PRAGMA

static const WCHAR DosPrefix[] = L"\\DosDevices";
static const WCHAR DeviceTypeName[] = KSSTRING_Server;

static const DEFINE_KSCREATE_DISPATCH_TABLE(CreateItems) {
    DEFINE_KSCREATE_ITEM(SrvDispatchCreate, DeviceTypeName, 0)
};

static DEFINE_KSDISPATCH_TABLE(
    SrvDispatchTable,
    SrvDispatchIoControl,
    NULL,
    NULL,
    NULL,
    SrvDispatchClose,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL);

static DEFINE_KSPROPERTY_TABLE(SrvPropertyItems) {
    DEFINE_KSPROPERTY_ITEM_SERVICE_BUILDCACHE(PropertySrv),
    DEFINE_KSPROPERTY_ITEM_SERVICE_MERIT(PropertySrv)
};

static DEFINE_KSPROPERTY_SET_TABLE(SrvPropertySets) {
    DEFINE_KSPROPERTY_SET(
        &KSPROPSETID_Service,
        SIZEOF_ARRAY(SrvPropertyItems),
        SrvPropertyItems,
        0, NULL
    )
};


NTSTATUS
PnpAddDevice(
    IN PDRIVER_OBJECT   DriverObject,
    IN PDEVICE_OBJECT   PhysicalDeviceObject
    )
/*++

Routine Description:

    When a new device is detected, PnP calls this entry point with the
    new PhysicalDeviceObject (PDO). The driver creates an associated 
    FunctionalDeviceObject (FDO).

Arguments:

    DriverObject -
        Pointer to the driver object.

    PhysicalDeviceObject -
        Pointer to the new physical device object.

Return Values:

    STATUS_SUCCESS or an appropriate error condition.

--*/
{
    PDEVICE_OBJECT      FunctionalDeviceObject;
    PDEVICE_INSTANCE    DeviceInstance;
    NTSTATUS            Status;

    Status = IoCreateDevice(
        DriverObject,
        sizeof(DEVICE_INSTANCE),
        NULL,                           // FDOs are unnamed
        FILE_DEVICE_KS,
        0,
        FALSE,
        &FunctionalDeviceObject);
    if (!NT_SUCCESS(Status)) {
        return Status;
    }
    DeviceInstance = (PDEVICE_INSTANCE)FunctionalDeviceObject->DeviceExtension;
    //
    // This object uses KS to perform access through the DeviceCreateItems.
    //
    Status = KsAllocateDeviceHeader(
        &DeviceInstance->Header,
        SIZEOF_ARRAY(CreateItems),
        (PKSOBJECT_CREATE_ITEM)CreateItems);
    if (NT_SUCCESS(Status)) {
        KsSetDevicePnpAndBaseObject(
            DeviceInstance->Header,
            IoAttachDeviceToDeviceStack(
                FunctionalDeviceObject, 
                PhysicalDeviceObject),
            FunctionalDeviceObject );
        FunctionalDeviceObject->Flags |= KsQueryDevicePnpObject(DeviceInstance->Header)->Flags & DO_POWER_PAGABLE;
        FunctionalDeviceObject->Flags &= ~DO_DEVICE_INITIALIZING;
        return STATUS_SUCCESS;
    }
    IoDeleteDevice(FunctionalDeviceObject);
    return Status;
}


NTSTATUS
GetFilterPinCount(
    IN PFILE_OBJECT FilterObject,
    OUT PULONG PinCount
    )
/*++

Routine Description:

    Queries the count of pin factories provided by the specified filter.

Arguments:

    FilterObject -
        The filter to query.

    PinCount -
        The place in which to return the pin factory count.

Return Values:

    Returns STATUS_SUCCESS, else some critical error.

--*/
{
    KSPROPERTY  Property;
    ULONG       BytesReturned;

    Property.Set = KSPROPSETID_Pin;
    Property.Id = KSPROPERTY_PIN_CTYPES;
    Property.Flags = KSPROPERTY_TYPE_GET;
    return KsSynchronousIoControlDevice(
        FilterObject,
        KernelMode,
        IOCTL_KS_PROPERTY,
        &Property,
        sizeof(Property),
        PinCount,
        sizeof(*PinCount),
        &BytesReturned);
}


NTSTATUS
GetPinTypes(
    IN PFILE_OBJECT FilterObject,
    IN ULONG Pin,
    IN ULONG Id,
    OUT PULONG Types
    )
/*++

Routine Description:

    Queries the count of "types" from the Pin property set. This is used
    to query the count of either Mediums or DataRanges, which use the same
    format for returning current count.

Arguments:

    FilterObject -
        The filter to query.

    Pin -
        The pin factory to query either Mediums or DataRanges of.

    Id -
        The property to query. This is either Mediums or DataRanges.

    Types -
        The place in which to return the number of types.

Return Values:

    Returns STATUS_SUCCESS, else some critical error.

--*/
{
    KSP_PIN         PinProp;
    KSMULTIPLE_ITEM MultipleItem;
    ULONG           BytesReturned;
    NTSTATUS        Status;

    PinProp.Property.Set = KSPROPSETID_Pin;
    PinProp.Property.Id = Id;
    PinProp.Property.Flags = KSPROPERTY_TYPE_GET;
    PinProp.PinId = Pin;
    PinProp.Reserved = 0;
    Status = KsSynchronousIoControlDevice(
        FilterObject,
        KernelMode,
        IOCTL_KS_PROPERTY,
        &PinProp,
        sizeof(PinProp),
        &MultipleItem,
        sizeof(MultipleItem),
        &BytesReturned);
    if (NT_SUCCESS(Status)) {
        *Types = MultipleItem.Count;
    }
    return Status;
}


NTSTATUS
GetPinFlags(
    IN PFILE_OBJECT FilterObject,
    IN ULONG Pin,
    OUT PULONG Flags
    )
/*++

Routine Description:

    Determines which flags to set based on the number of necessary instances
    a pin factory must create, and the data flow of the pin factory. It does
    not attempt to determine if the pin factory topologically connected to a
    Bridge.

Arguments:

    FilterObject -
        The filter to query.

    Pin -
        The pin factory to query.

    Flags -
        The place in which to return the flags.

Return Values:

    Returns STATUS_SUCCESS, else some critical error.

--*/
{
    KSP_PIN         PinProp;
    ULONG           Instances;
    KSPIN_DATAFLOW  DataFlow;
    ULONG           BytesReturned;
    NTSTATUS        Status;

    *Flags = 0;
    PinProp.Property.Set = KSPROPSETID_Pin;
    PinProp.Property.Id = KSPROPERTY_PIN_NECESSARYINSTANCES;
    PinProp.Property.Flags = KSPROPERTY_TYPE_GET;
    PinProp.PinId = Pin;
    PinProp.Reserved = 0;
    Status = KsSynchronousIoControlDevice(
        FilterObject,
        KernelMode,
        IOCTL_KS_PROPERTY,
        &PinProp,
        sizeof(PinProp),
        &Instances,
        sizeof(Instances),
        &BytesReturned);
    //
    // The property need not be supported.
    //
    if (NT_SUCCESS(Status) && !Instances) {
        *Flags |= REG_PIN_B_ZERO;
    }
    PinProp.Property.Id = KSPROPERTY_PIN_DATAFLOW;
    Status = KsSynchronousIoControlDevice(
        FilterObject,
        KernelMode,
        IOCTL_KS_PROPERTY,
        &PinProp,
        sizeof(PinProp),
        &DataFlow,
        sizeof(DataFlow),
        &BytesReturned);
    if (NT_SUCCESS(Status) && (DataFlow == KSPIN_DATAFLOW_OUT)) {
        *Flags |= REG_PIN_B_OUTPUT;
    }
    //
    // REG_PIN_B_RENDERER is not filled in at this time.
    //
    return Status;
}


NTSTATUS
GetPinInstances(
    IN PFILE_OBJECT FilterObject,
    IN ULONG Pin,
    OUT PULONG PossibleInstances
    )
/*++

Routine Description:

    Queries the number of possible instances a pin factory may create.
    This is used to set one of the flags.

Arguments:

    FilterObject -
        The filter to query.

    Pin -
        The pin factory to query.

    PossibleInstances -
        The place in which to return the possible instances.

Return Values:

    Returns STATUS_SUCCESS, else some critical error.

--*/
{
    KSP_PIN             PinProp;
    KSPIN_CINSTANCES    Instances;
    ULONG               BytesReturned;
    NTSTATUS            Status;

    PinProp.Property.Set = KSPROPSETID_Pin;
    PinProp.Property.Id = KSPROPERTY_PIN_CINSTANCES;
    PinProp.Property.Flags = KSPROPERTY_TYPE_GET;
    PinProp.PinId = Pin;
    PinProp.Reserved = 0;
    Status = KsSynchronousIoControlDevice(
        FilterObject,
        KernelMode,
        IOCTL_KS_PROPERTY,
        &PinProp,
        sizeof(PinProp),
        &Instances,
        sizeof(Instances),
        &BytesReturned);
    if (NT_SUCCESS(Status)) {
        *PossibleInstances = Instances.PossibleCount;
    }
    return Status;
}


NTSTATUS
GetPinTypeList(
    IN PFILE_OBJECT FilterObject,
    IN ULONG Pin,
    IN ULONG Id,
    OUT PKSMULTIPLE_ITEM* MultipleItem
    )
/*++

Routine Description:

    Queries multiple item properties from the Pin property set. This is
    used to query either the Mediums or DataRanges, which use the same
    format for returning data.

Arguments:

    FilterObject -
        The filter to query.

    Pin -
        The pin factory to query either Mediums or DataRanges of.

    Id -
        The property to query. This is either Mediums or DataRanges.

    MultipleItems -
        The place in which to return the pointer to the buffer allocated
        to contain the items.

Return Values:

    Returns STATUS_SUCCESS, else some critical error.

--*/
{
    KSP_PIN     PinProp;
    ULONG       BytesReturned;
    NTSTATUS    Status;

    //
    // First query for the size needed.
    //
    PinProp.Property.Set = KSPROPSETID_Pin;
    PinProp.Property.Id = Id;
    PinProp.Property.Flags = KSPROPERTY_TYPE_GET;
    PinProp.PinId = Pin;
    PinProp.Reserved = 0;
    Status = KsSynchronousIoControlDevice(
        FilterObject,
        KernelMode,
        IOCTL_KS_PROPERTY,
        &PinProp,
        sizeof(PinProp),
        NULL,
        0,
        &BytesReturned);
    //
    // This query must not success, else the filter is broken.
    //
    ASSERT(!NT_SUCCESS(Status));
    //
    // An overflow is expected, so that the size needed can be returned.
    //
    if (Status != STATUS_BUFFER_OVERFLOW) {
        return Status;
    }
    *MultipleItem = ExAllocatePoolWithTag(PagedPool, BytesReturned, 'tpSK');
    if (!*MultipleItem) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }
    Status = KsSynchronousIoControlDevice(
        FilterObject,
        KernelMode,
        IOCTL_KS_PROPERTY,
        &PinProp,
        sizeof(PinProp),
        *MultipleItem,
        BytesReturned,
        &BytesReturned);
    if (!NT_SUCCESS(Status)) {
        ExFreePool(*MultipleItem);
    }
    return Status;
}


NTSTATUS
GetPinCategory(
    IN PFILE_OBJECT FilterObject,
    IN ULONG Pin,
    OUT GUID* Category
    )
/*++

Routine Description:

    Queries the category of a pin. This may not be supported, which can
    be expected.

Arguments:

    FilterObject -
        The filter to query.

    Pin -
        The pin factory to query.

    Category -
        The place in which to return the category

Return Values:

    Returns STATUS_SUCCESS, STATUS_NOT_FOUND, else some critical error.

--*/
{
    KSP_PIN     PinProp;
    ULONG       BytesReturned;

    PinProp.Property.Set = KSPROPSETID_Pin;
    PinProp.Property.Id = KSPROPERTY_PIN_CATEGORY;
    PinProp.Property.Flags = KSPROPERTY_TYPE_GET;
    PinProp.PinId = Pin;
    PinProp.Reserved = 0;
    return KsSynchronousIoControlDevice(
        FilterObject,
        KernelMode,
        IOCTL_KS_PROPERTY,
        &PinProp,
        sizeof(PinProp),
        Category,
        sizeof(*Category),
        &BytesReturned);
}


VOID
InsertCacheItem(
    IN PVOID Item,
    IN ULONG ItemSize,
    IN PVOID OffsetBase,
    IN PVOID CacheBase,
    IN OUT PULONG ItemsCached,
    OUT PULONG ItemOffset
    )
/*++

Routine Description:

    Return an OffsetBase'd offset into the specified cache for the item
    passed in. If the item is already in the cache, return an offset to
    that item, else add the item to the cache by copying its contents,
    and return an offset to the new item.

Arguments:

    Item -
        Points to the item to insert into the specified cache.

    ItemSize -
        Contains the size of both the item passed, and the items in the
        specified cache.

    OffsetBase -
        Contains the pointer on which to base the offset returned.

    CacheBase -
        Contains a pointer to the beginning of the cache, which is greater
        than the OffsetBase.

    ItemsCached -
        Points to a counter of the total items currently in the cache. This
        is updated if a new item is added.

    ItemOffset -
        The place in which to put the offset to the item added to the cache.

Return Values:

    Nothing.

--*/
{
    ULONG   CurrentItem;

    //
    // Search the list of cache items for one which is equivalent.
    //
    for (CurrentItem = 0; CurrentItem < *ItemsCached; CurrentItem++) {
        if (RtlCompareMemory(
            Item,
            (PUCHAR)CacheBase + (CurrentItem * ItemSize),
            ItemSize) == ItemSize) {
            //
            // This item is equal to a cached item.
            //
            break;
        }
    }
    //
    // If an equal cached item was not found, make a new entry.
    //
    if (CurrentItem == *ItemsCached) {
        //
        // Increment the number of items currently cached.
        //
        (*ItemsCached)++;
        RtlMoveMemory(
            (PUCHAR)CacheBase + (CurrentItem * ItemSize),
            Item,
            ItemSize);
    }
    //
    // Return an offset to this cached item. This is the difference
    // of the current item to the OffsetBase.
    //
    *ItemOffset = 
        PtrToUlong( 
            (PVOID)((PUCHAR)CacheBase + 
                (CurrentItem * ItemSize) - 
                (PUCHAR)OffsetBase) );
}


VOID
ExtractMediaTypes(
    IN PKSMULTIPLE_ITEM MediaTypeList,
    IN ULONG MediaType,
    OUT GUID* MajorType,
    OUT GUID* MinorType
    )
/*++

Routine Description:

    Extract the major and minor Guids from a particular item in the list
    of media types.

Arguments:

    MediaTypeList -
        Points to the list of media types.

    MediaType -
        Specifies which item in the list to extract the Guids from.

    MajorType -
        The place in which to put the major Guid.

    MinorType -
        The place in which to put the minor Guid.

Return Values:

    Nothing.

--*/
{
    PVOID   DataRange;
    ULONG   DataRanges;

    DataRange = MediaTypeList + 1;
    //
    // Advance to the right data range.
    //
    for (DataRanges = 0; DataRanges < MediaType; DataRanges++) {
        (PUCHAR)DataRange += ((((PKSDATARANGE)DataRange)->FormatSize + FILE_QUAD_ALIGNMENT) & ~FILE_QUAD_ALIGNMENT);
    }
    *MajorType = ((PKSDATARANGE)DataRange)->MajorFormat;
    *MinorType = ((PKSDATARANGE)DataRange)->SubFormat;
}


NTSTATUS
BuildFilterData(
    IN PFILE_OBJECT FilterObject,
    IN ULONG Merit,
    OUT PUCHAR* FilterData,
    OUT ULONG* FilterDataLength
    )
/*++

Routine Description:

    Allocate memory and build the filter cache information to be stored in
    the registry for the particular interface.

Arguments:

    FilterObject -
        The file object of the filter to query.

    Merit -
        The merit to use in the cache.

    FilterData -
        The place in which to put the pointer to the cache data.

    FilterDataLength -
        The place in which to put the size of the cache data.

Return Values:

    STATUS_SUCCESS or an appropriate error condition.

--*/
{
    NTSTATUS            Status;
    ULONG               PinCount;
    ULONG               CurrentPin;
    ULONG               TotalMediaTypes;
    ULONG               TotalMediumTypes;
    REGFILTER_REG*      RegFilter;
    REGFILTERPINS_REG2* RegPin;
    GUID*               GuidCache;
    ULONG               GuidsCached;
    PKSPIN_MEDIUM       MediumCache;
    ULONG               MediumsCached;
    ULONG               TotalPossibleGuids;

    //
    // Calculate the maximum amount of space which could be taken up by
    // this cache data. This is before any collapsing which might occur.
    //
    if (!NT_SUCCESS(Status = GetFilterPinCount(FilterObject, &PinCount))) {
        return Status;
    }
    TotalMediaTypes = 0;
    TotalMediumTypes = 0;
    for (CurrentPin = PinCount; CurrentPin;) {
        ULONG   Types;

        CurrentPin--;
        if (!NT_SUCCESS(Status = GetPinTypes(FilterObject, CurrentPin, KSPROPERTY_PIN_DATARANGES, &Types))) {
            return Status;
        }
        TotalMediaTypes += Types;
        if (!NT_SUCCESS(Status = GetPinTypes(FilterObject, CurrentPin, KSPROPERTY_PIN_MEDIUMS, &Types))) {
            return Status;
        }
        TotalMediumTypes += Types;
    }
    //
    // The total is the size of all the structures, plus the maximum
    // number of Guids and Mediums which might be present before
    // collapsing.
    //
    TotalPossibleGuids = PinCount * 3 + TotalMediaTypes * 2;
    *FilterDataLength = sizeof(REGFILTER_REG) +
        PinCount * sizeof(REGFILTERPINS_REG2) +
        TotalMediaTypes * sizeof(REGPINTYPES_REG2) +
        TotalMediumTypes * sizeof(PKSPIN_MEDIUM) +
        TotalPossibleGuids * sizeof(GUID) +
        TotalMediumTypes * sizeof(KSPIN_MEDIUM);
    *FilterData = ExAllocatePoolWithTag(PagedPool, *FilterDataLength, 'dfSK');
    if (!*FilterData) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }
    //
    // Place the header in the data.
    //
    RegFilter = (REGFILTER_REG*)*FilterData;
    RegFilter->Version = 2;
    RegFilter->Merit = Merit;
    RegFilter->Pins = PinCount;
    RegFilter->Reserved = 0;
    //
    // Calculate the offset to the list of pins, and to each of the
    // cache positions at the end of the buffer. These follow the
    // structures containing the filter header, and the pin headers,
    // along with each pins media types and medium types. Initialize
    // the count of used guids and mediums in each cache. This is used
    // to compare when adding a new item to each cache, and in
    // compressing at the end.
    //
    RegPin = (REGFILTERPINS_REG2*)(RegFilter + 1);
    GuidCache = (GUID*)((PUCHAR)(RegPin + PinCount) +
        TotalMediaTypes * sizeof(REGPINTYPES_REG2) +
        TotalMediumTypes * sizeof(PKSPIN_MEDIUM));
    GuidsCached = 0;
    MediumCache = (PKSPIN_MEDIUM)(GuidCache + TotalPossibleGuids);
    MediumsCached = 0;
    //
    // Create each pin header, followed by the list of media types,
    // followed by the list of mediums.
    //
    for (CurrentPin = 0; CurrentPin < PinCount; CurrentPin++) {
        PKSMULTIPLE_ITEM    MediaTypeList;
        PKSMULTIPLE_ITEM    MediumTypeList;
        GUID                Guid;
        ULONG               CurrentType;
        REGPINTYPES_REG2*   PinType;
        PULONG              PinMedium;

        //
        // Initialize the pin header.
        //
        RegPin->Signature = FCC('0pi3');
        (*(PUCHAR)&RegPin->Signature) += (BYTE)CurrentPin;
        if (!NT_SUCCESS(Status = GetPinFlags(FilterObject, CurrentPin, &RegPin->Flags))) {
            break;
        }
        if (!NT_SUCCESS(Status = GetPinInstances(FilterObject, CurrentPin, &RegPin->PossibleInstances))) {
            break;
        }
        //
        // This flag must also be set, so just use the previously acquired value.
        //
        if (RegPin->PossibleInstances > 1) {
            RegPin->Flags |= REG_PIN_B_MANY;
        }
        if (!NT_SUCCESS(Status = GetPinTypeList(FilterObject, CurrentPin, KSPROPERTY_PIN_DATARANGES, &MediaTypeList))) {
            break;
        }
        RegPin->MediaTypes = MediaTypeList->Count;
        if (!NT_SUCCESS(Status = GetPinTypeList(FilterObject, CurrentPin, KSPROPERTY_PIN_MEDIUMS, &MediumTypeList))) {
            ExFreePool(MediaTypeList);
            break;
        }
        RegPin->MediumTypes = MediumTypeList->Count;
        if (NT_SUCCESS(Status = GetPinCategory(FilterObject, CurrentPin, &Guid))) {
            InsertCacheItem(&Guid, sizeof(*GuidCache), RegFilter, GuidCache, &GuidsCached, &RegPin->Category);
        } else if (Status == STATUS_NOT_FOUND) {
            //
            // Category may not be supported by a particular pin.
            //
            RegPin->Category = 0;
            Status = STATUS_SUCCESS;
        } else {
            ASSERT(FALSE && "The driver is broken and returned a completely unexpected failure status. Check owner of FilterObject above.");
            ExFreePool(MediaTypeList);
            ExFreePool(MediumTypeList);
            break;
        }
        //
        // Append the media types.
        //
        PinType = (REGPINTYPES_REG2*)(RegPin + 1);
        for (CurrentType = 0; CurrentType < MediaTypeList->Count; CurrentType++) {
            GUID    MajorType;
            GUID    MinorType;

            PinType->Signature = FCC('0ty3');
            (*(PUCHAR)&PinType->Signature) += (BYTE)CurrentType;
            PinType->Reserved = 0;
            ExtractMediaTypes(MediaTypeList, CurrentType, &MajorType, &MinorType);
            InsertCacheItem(&MajorType, sizeof(*GuidCache), RegFilter, GuidCache, &GuidsCached, &PinType->MajorType);
            InsertCacheItem(&MinorType, sizeof(*GuidCache), RegFilter, GuidCache, &GuidsCached, &PinType->MinorType);
            PinType++;
        }
        ExFreePool(MediaTypeList);
        //
        // Append the mediums.
        //
        PinMedium = (PULONG)PinType;
        for (CurrentType = 0; CurrentType < MediumTypeList->Count; CurrentType++) {
            PKSPIN_MEDIUM   Medium;

            Medium = (PKSPIN_MEDIUM)(MediumTypeList + 1) + CurrentType;
            InsertCacheItem(Medium, sizeof(*MediumCache), RegFilter, MediumCache, &MediumsCached, PinMedium);
            PinMedium++;
        }
        ExFreePool(MediumTypeList);
        //
        // Increment to the next pin header position.
        //
        RegPin = (REGFILTERPINS_REG2*)PinMedium;
    }
    if (NT_SUCCESS(Status)) {
        ULONG   OffsetAdjustment;

        //
        // If any duplicate guids were removed, the list of Mediums needs
        // to be shifted, and each pointer to a Medium needs to be adjusted.
        //
        OffsetAdjustment = (TotalPossibleGuids - GuidsCached) * sizeof(GUID);
        if (OffsetAdjustment) {
            RegPin = (REGFILTERPINS_REG2*)(RegFilter + 1);
            for (CurrentPin = PinCount; CurrentPin ; CurrentPin--) {
                ULONG               CurrentType;
                PULONG              PinMedium;

                //
                // Skip past the media types on to the mediums.
                //
                PinMedium = (PULONG)((REGPINTYPES_REG2*)(RegPin + 1) + RegPin->MediaTypes);
                //
                // Adjust each medium offset.
                //
                for (CurrentType = RegPin->MediumTypes; CurrentType; CurrentType--) {
                    *PinMedium -= OffsetAdjustment;
                    PinMedium++;
                }
                //
                // Increment to the next pin header position.
                //
                RegPin = (REGFILTERPINS_REG2*)PinMedium;
            }
            //
            // Move the medium entries down, and adjust the overall size.
            //
            RtlMoveMemory(
                (PUCHAR)MediumCache - OffsetAdjustment,
                MediumCache,
                MediumsCached * sizeof(KSPIN_MEDIUM));
            *FilterDataLength -= OffsetAdjustment;
        }
        //
        // Adjust the size by the number of duplicates removed.
        //
        *FilterDataLength -= ((TotalMediumTypes - MediumsCached) * sizeof(KSPIN_MEDIUM));
    } else {
        ExFreePool(RegFilter);
    }
    return Status;
}


NTSTATUS
UpdateMediumCache (
    IN HANDLE FilterObject,
    IN PUNICODE_STRING FilterSymbolicLink
    )

/*++

Routine Description:

    Go through and update the mediums cache for all non-public mediums
    that exist on pins on the given filter.

Arguments:

    FilterObject -
        The handle to the filter

    FilterSymbolicLink -
        The symlink to the filter (placed in the mediums cache)

Return Value:

    Success / Failure

--*/

{
    ULONG PinCount, CurPin;
    NTSTATUS Status = STATUS_SUCCESS;

    if (!NT_SUCCESS(Status = GetFilterPinCount(FilterObject, &PinCount))) {
        return Status;
    }

    for (CurPin = 0; CurPin < PinCount && NT_SUCCESS (Status); CurPin++) {
        PKSMULTIPLE_ITEM MediumTypeList;
        PKSPIN_MEDIUM Medium;
        ULONG CurMedium;
        KSPIN_DATAFLOW DataFlow;
        KSP_PIN PinProp;
        ULONG BytesReturned;

        PinProp.Property.Set = KSPROPSETID_Pin;
        PinProp.Property.Id = KSPROPERTY_PIN_DATAFLOW;
        PinProp.Property.Flags = KSPROPERTY_TYPE_GET;
        PinProp.PinId = CurPin;
        PinProp.Reserved = 0;

        Status = KsSynchronousIoControlDevice(
            FilterObject,
            KernelMode,
            IOCTL_KS_PROPERTY,
            &PinProp,
            sizeof(PinProp),
            &DataFlow,
            sizeof(DataFlow),
            &BytesReturned);

        if (!NT_SUCCESS (Status)) {
            break;
        }

        if (!NT_SUCCESS(Status = GetPinTypeList(
            FilterObject, CurPin, KSPROPERTY_PIN_MEDIUMS, &MediumTypeList))) {

            break;
        }

        //
        // Go through and only cache the private mediums on each pin. 
        //
        Medium = (PKSPIN_MEDIUM)(MediumTypeList + 1);
        for (CurMedium = 0; CurMedium < MediumTypeList -> Count; CurMedium++) {
            if (!IsEqualGUIDAligned (&Medium -> Set, &KSMEDIUMSETID_Standard)) {
                Status = KsCacheMedium (
                    FilterSymbolicLink,
                    Medium,
                    DataFlow == KSPIN_DATAFLOW_OUT ? 1 : 0
                    );

                if (!NT_SUCCESS (Status)) break;
            }

            Medium++;
        }

        ExFreePool (MediumTypeList);
    
    }

    return Status;

}


NTSTATUS
PropertySrv(
    IN PIRP         Irp,
    IN PKSPROPERTY  Property,
    IN PBYTE        Data
    )
/*++

Routine Description:

    Handles the Build Cache and Merit properties. Opens the interface registry
    key location, and queries the properties from the object to build the
    cache information structure. Or sets the specified Merit value, optionally
    propagating this to the Cache. This gives WRITE access to the interface
    registry location, while not allowing unauthorized access to the
    filter.

Arguments:

    Irp -
        Contains the Build Cache or Merit property IRP.

    Property -
        Contains the property identifier parameter.

    Data -
        Contains the data for the particular property.

Return Value:

    Return STATUS_SUCCESS if the cache was built or merit set, else some
    access or IO error.

--*/
{
    PIO_STACK_LOCATION  IrpStack;
    ULONG               OutputBufferLength;
    ULONG               Merit;
    PWCHAR              SymbolicLink;
    PWCHAR              LocalSymbolicLink;
    UNICODE_STRING      SymbolicString;
    NTSTATUS            Status;
    HANDLE              InterfaceKey;

    IrpStack = IoGetCurrentIrpStackLocation(Irp);
    OutputBufferLength = IrpStack->Parameters.DeviceIoControl.OutputBufferLength;
    SymbolicLink = (PWCHAR)Data;
    //
    // Ensure the string is terminated.
    //
    if (SymbolicLink[OutputBufferLength / sizeof(*SymbolicLink) - 1]) {
        _DbgPrintF(DEBUGLVL_ERROR, ("Invalid Symbolic Link [len=%u]", OutputBufferLength));
        return STATUS_INVALID_PARAMETER;
    }
    //
    // Since this handler deals with both properties, extract the specified
    // Merit value if necessary, and fix the pointer to the symbolic link.
    //
    if (Property->Id == KSPROPERTY_SERVICE_BUILDCACHE) {
        //
        // The default value for Merit is "unused". This can be modified
        // by the presence of a "Merit" value.
        //
        Merit = 0x200000;
    } else {
        ASSERT(Property->Id == KSPROPERTY_SERVICE_MERIT);
        Merit = *(PULONG)Data;
        SymbolicLink += (sizeof(Merit) / sizeof(*SymbolicLink));
        OutputBufferLength -= sizeof(Merit);
    }
    //
    // Make a copy of the incoming string in all cases, in case it needs to be modified.
    // Add on the length of the long prefix, in case it is needed.
    //
    LocalSymbolicLink = 
        ExAllocatePoolWithTag(
            PagedPool, OutputBufferLength + sizeof(DosPrefix), 'lsSK');
    if (!LocalSymbolicLink) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }
    RtlCopyMemory(LocalSymbolicLink, SymbolicLink, OutputBufferLength);
    //
    // Change a usermode string to kernelmode format. The string will be
    // at least 5 characters in length. This translates '\\?\' --> '\??\',
    // and '\\.\' --> '\DosDevices\'.
    //
    if ((LocalSymbolicLink[0] == '\\') && (LocalSymbolicLink[1] == '\\') && (LocalSymbolicLink[3] == '\\')) {
        if (LocalSymbolicLink[2] == '?') {
            LocalSymbolicLink[1] = '?';
        } else if (LocalSymbolicLink[2] == '.') {
            RtlCopyMemory(LocalSymbolicLink, DosPrefix, sizeof(DosPrefix));
            RtlCopyMemory(
                LocalSymbolicLink + (sizeof(DosPrefix) - sizeof(DosPrefix[0])) / sizeof(*LocalSymbolicLink),
                SymbolicLink + 3,
                OutputBufferLength - 3 * sizeof(*SymbolicLink));
        }
    }
    RtlInitUnicodeString(&SymbolicString, LocalSymbolicLink);
    //
    // Open the interface key which is where the cache data and merit is placed.
    //
    Status = IoOpenDeviceInterfaceRegistryKey(
        &SymbolicString,
        KEY_WRITE,
        &InterfaceKey);
    if (NT_SUCCESS(Status)) {
        UNICODE_STRING  KeyString;

        RtlInitUnicodeString(&KeyString, L"Merit");
        //
        // Building the cache is being requested. First read the current
        // Merit value, and use it when assigning the Merit in the
        // cache data.
        //
        if (Property->Id == KSPROPERTY_SERVICE_BUILDCACHE) {
            PKEY_VALUE_PARTIAL_INFORMATION PartialInfo;
            BYTE                PartialInfoBuffer[sizeof(*PartialInfo) + sizeof(Merit) - 1];
            ULONG               BytesReturned;
            HANDLE              FilterHandle;
            OBJECT_ATTRIBUTES   ObjectAttributes;
            IO_STATUS_BLOCK     IoStatusBlock;

            PartialInfo = (PKEY_VALUE_PARTIAL_INFORMATION)PartialInfoBuffer;
            //
            // Since old setupapi.dll could not handle REG_DWORD values,
            // allow REG_BINARY also.
            //
            if (NT_SUCCESS(ZwQueryValueKey(
                InterfaceKey,
                &KeyString,
                KeyValuePartialInformation,
                PartialInfoBuffer,
                sizeof(PartialInfoBuffer),
                &BytesReturned)) &&
                (PartialInfo->DataLength == sizeof(Merit)) &&
                ((PartialInfo->Type == REG_BINARY) ||
                (PartialInfo->Type == REG_DWORD))) {
                Merit = *(PULONG)PartialInfo->Data;
            }
            InitializeObjectAttributes(
                &ObjectAttributes,
                &SymbolicString,
                OBJ_CASE_INSENSITIVE,
                NULL,
                NULL);
            Status = IoCreateFile(
                &FilterHandle,
                GENERIC_READ | SYNCHRONIZE,
                &ObjectAttributes,
                &IoStatusBlock,
                NULL,
                0,
                0,
                FILE_OPEN,
                0,
                NULL,
                0,
                CreateFileTypeNone,
                NULL,
                IO_FORCE_ACCESS_CHECK | IO_NO_PARAMETER_CHECKING);
            if (NT_SUCCESS(Status)) {
                PFILE_OBJECT    FilterObject;
        
                Status = ObReferenceObjectByHandle(
                    FilterHandle,
                    FILE_GENERIC_READ,
                    *IoFileObjectType,
                    Irp->RequestorMode,
                    &FilterObject,
                    NULL);
                ZwClose(FilterHandle);
                if (NT_SUCCESS(Status)) {
                    ULONG   FilterDataLength;
                    PUCHAR  FilterData;

                    //
                    // Allocate room for the data, and build it.
                    //
                    Status = BuildFilterData(FilterObject, Merit, &FilterData, &FilterDataLength);
                    if (NT_SUCCESS(Status)) {
                        RtlInitUnicodeString(&KeyString, L"FilterData");
                        Status = ZwSetValueKey(
                            InterfaceKey,
                            &KeyString,
                            0,
                            REG_BINARY,
                            FilterData,
                            FilterDataLength);
                        ExFreePool(FilterData);
                    }

                    //
                    // Cache all non-public mediums.
                    //
                    if (NT_SUCCESS (Status)) {
                        Status = UpdateMediumCache(FilterObject, &SymbolicString);
                    }
                }
                ObDereferenceObject(FilterObject);
            }
        } else {
            //
            // The Merit value is being set. Try to set with the value
            // which was passed in, then determine if the cache needs
            // to be modified with the new value.
            //
            Status = ZwSetValueKey(
                InterfaceKey,
                &KeyString,
                0,
                REG_DWORD,
                &Merit,
                sizeof(Merit));
            if (NT_SUCCESS(Status)) {
                ULONG       FilterDataLength;
                KEY_VALUE_PARTIAL_INFORMATION   PartialInfoHeader;

                RtlInitUnicodeString(&KeyString, L"FilterData");
                //
                // Determine if the cache needs to be modified to fix the
                // Merit value. Only if it is present should it be rebuilt.
                //
                Status = ZwQueryValueKey(
                    InterfaceKey,
                    &KeyString,
                    KeyValuePartialInformation,
                    &PartialInfoHeader,
                    sizeof(PartialInfoHeader),
                    &FilterDataLength);
                if ((Status == STATUS_BUFFER_OVERFLOW) || NT_SUCCESS(Status)) {
                    PKEY_VALUE_PARTIAL_INFORMATION  PartialInfo;

                    //
                    // Allocate a buffer for the actual size of data needed.
                    //
                    PartialInfo = 
                        ExAllocatePoolWithTag( PagedPool, FilterDataLength, 'dfSK');
                    if (PartialInfo) {
                        //
                        // Retrieve the cache.
                        //
                        Status = ZwQueryValueKey(
                            InterfaceKey,
                            &KeyString,
                            KeyValuePartialInformation,
                            PartialInfo,
                            FilterDataLength,
                            &FilterDataLength);
                        if (NT_SUCCESS(Status)) {
                            if ((PartialInfo->DataLength >= sizeof(REGFILTER_REG)) &&
                                (PartialInfo->Type == REG_BINARY)) {
                                //
                                // Modify the Merit value and write it back.
                                //
                                ((REGFILTER_REG*)PartialInfo->Data)->Merit = Merit;
                                Status = ZwSetValueKey(
                                    InterfaceKey,
                                    &KeyString,
                                    0,
                                    REG_BINARY,
                                    PartialInfo->Data,
                                    PartialInfo->DataLength);
                            }
                        } else {
                            //
                            // Maybe it was just deleted. No need to modify it.
                            //
                            Status = STATUS_SUCCESS;
                        }
                        ExFreePool(PartialInfo);
                    }
                } else {
                    //
                    // The cache does not exist, so no need to modify it.
                    //
                    Status = STATUS_SUCCESS;
                }
            }
        }
        ZwClose(InterfaceKey);
    }
    ExFreePool(LocalSymbolicLink);
    return Status;
}


NTSTATUS
SrvDispatchCreate(
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp
    )
/*++

Routine Description:

    The IRP handler for IRP_MJ_CREATE for the Server. Just validates that no
    random parameters are being passed.

Arguments:

    DeviceObject -
        The device object to which the Server is attached. This is not used.

    Irp -
        The specific close IRP to be processed.

Return Value:

    Returns STATUS_SUCCESS, else a memory allocation error.

--*/
{
    NTSTATUS                Status;

    //
    // Notify the software bus that this device is in use.
    //
    Status = KsReferenceSoftwareBusObject(((PDEVICE_INSTANCE)DeviceObject->DeviceExtension)->Header);
    if (NT_SUCCESS(Status)) {
        PIO_STACK_LOCATION      IrpStack;
        PKSOBJECT_CREATE_ITEM   CreateItem;
        PINSTANCE               SrvInst;

        IrpStack = IoGetCurrentIrpStackLocation(Irp);
        CreateItem = KSCREATE_ITEM_IRP_STORAGE(Irp);
        if (IrpStack->FileObject->FileName.Length != sizeof(OBJ_NAME_PATH_SEPARATOR) + CreateItem->ObjectClass.Length) {
            Status = STATUS_INVALID_PARAMETER;
        } else if (SrvInst = (PINSTANCE)ExAllocatePoolWithTag(NonPagedPool, sizeof(*SrvInst), 'IFsK')) {
            Status = KsAllocateObjectHeader(
                &SrvInst->Header,
                0,
                NULL,
                Irp,
                (PKSDISPATCH_TABLE)&SrvDispatchTable);
            if (NT_SUCCESS(Status)) {
                IrpStack->FileObject->FsContext = SrvInst;
            } else {
                ExFreePool(SrvInst);
            }
        } else {
            Status = STATUS_INSUFFICIENT_RESOURCES;
        }
        if (!NT_SUCCESS(Status)) {
            KsDereferenceSoftwareBusObject(((PDEVICE_INSTANCE)DeviceObject->DeviceExtension)->Header);
        }
    }
    Irp->IoStatus.Status = Status;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);
    return Status;
}


NTSTATUS
SrvDispatchClose(
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp
    )
/*++

Routine Description:

    The IRP handler for IRP_MJ_CLOSE for the Server. Cleans up object.

Arguments:

    DeviceObject -
        The device object to which the Server is attached. This is not used.

    Irp -
        The specific close IRP to be processed.

Return Value:

    Returns STATUS_SUCCESS.

--*/
{
    PIO_STACK_LOCATION  IrpStack;
    PINSTANCE           SrvInst;

    IrpStack = IoGetCurrentIrpStackLocation(Irp);
    SrvInst = (PINSTANCE)IrpStack->FileObject->FsContext;
    KsFreeObjectHeader(SrvInst->Header);
    ExFreePool(SrvInst);
    //
    // Notify the software bus that the device has been closed.
    //
    KsDereferenceSoftwareBusObject(((PDEVICE_INSTANCE)DeviceObject->DeviceExtension)->Header);
    Irp->IoStatus.Status = STATUS_SUCCESS;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);
    return STATUS_SUCCESS;
}


NTSTATUS
SrvDispatchIoControl(
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp
    )
/*++

Routine Description:

    The IRP handler for IRP_MJ_DEVICE_CONTROL for the Server. Handles
    the properties supported by this implementation using the
    default handlers provided by KS.

Arguments:

    DeviceObject -
        The device object to which the Server is attached. This is not used.

    Irp -
        The specific device control IRP to be processed.

Return Value:

    Returns the status of the processing.

--*/
{
    PIO_STACK_LOCATION  IrpStack;
    NTSTATUS            Status;

    IrpStack = IoGetCurrentIrpStackLocation(Irp);
    switch (IrpStack->Parameters.DeviceIoControl.IoControlCode) {
    case IOCTL_KS_PROPERTY:
        Status = KsPropertyHandler(
            Irp,
            SIZEOF_ARRAY(SrvPropertySets),
            (PKSPROPERTY_SET)SrvPropertySets);
        break;
    default:
        Status = STATUS_INVALID_DEVICE_REQUEST;
        break;
    }
    Irp->IoStatus.Status = Status;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);
    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\ksfilter\mskssrv\device.c ===
/*++

Copyright (C) Microsoft Corporation, 1996 - 1998

Module Name:

    device.c

Abstract:

    Device entry point and hardware validation.

--*/

#include "mskssrv.h"

#ifdef ALLOC_PRAGMA
NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT   DriverObject,
    IN PUNICODE_STRING  RegistryPathName
    );

#pragma alloc_text(INIT, DriverEntry)
#endif // ALLOC_PRAGMA


NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT   DriverObject,
    IN PUNICODE_STRING  RegistryPathName
    )
/*++

Routine Description:

    Sets up the driver object to handle the KS interface and PnP Add Device
    request. Does not set up a handler for PnP Irp's, as they are all dealt
    with directly by the PDO.

Arguments:

    DriverObject -
        Driver object for this instance.

    RegistryPathName -
        Contains the registry path which was used to load this instance.

Return Values:

    Returns STATUS_SUCCESS.

--*/
{
    DriverObject->MajorFunction[IRP_MJ_PNP] = KsDefaultDispatchPnp;
    DriverObject->MajorFunction[IRP_MJ_POWER] = KsDefaultDispatchPower;
    DriverObject->MajorFunction[IRP_MJ_SYSTEM_CONTROL] = KsDefaultForwardIrp;
    DriverObject->DriverExtension->AddDevice = PnpAddDevice;
    DriverObject->DriverUnload = KsNullDriverUnload;
    KsSetMajorFunctionHandler(DriverObject, IRP_MJ_CREATE);
    KsSetMajorFunctionHandler(DriverObject, IRP_MJ_CLOSE);
    KsSetMajorFunctionHandler(DriverObject, IRP_MJ_DEVICE_CONTROL);
    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\ksfilter\msmpu401\device.c ===
/*++

Copyright (C) Microsoft Corporation, 1996 - 1996

Module Name:

	device.c

Abstract:

	Device entry point and hardware validation.

--*/

#include "common.h"

#ifdef ALLOC_PRAGMA
NTSTATUS
DriverEntry(
	IN PDRIVER_OBJECT       DriverObject,
	IN PUNICODE_STRING      RegistryPathName
	);
static
NTSTATUS
ProcessResources(
	IN PDEVICE_OBJECT		DeviceObject,
	IN PDEVICE_INSTANCE		DeviceInstance,
	IN PCM_RESOURCE_LIST	Resources,
	IN ULONG				ResourcesSize
	);
static
NTSTATUS
PnpAddDevice(
	IN PDRIVER_OBJECT		DriverObject,
	IN PDEVICE_OBJECT		DeviceObject
	);
#ifdef PNP
static
NTSTATUS
DispatchPnp(
	IN PDEVICE_OBJECT		DeviceObject,
	IN PIRP					Irp
	);
#else // !PNP
static
VOID
DriverUnload(
	IN PDRIVER_OBJECT		DriverObject
	);
#endif // !PNP

#pragma alloc_text(INIT, DriverEntry)
#pragma alloc_text(PAGE, ProcessResources)
#pragma alloc_text(PAGE, PnpAddDevice)
#ifdef PNP
#pragma alloc_text(PAGE, DispatchPnp)
#else // !PNP
#pragma alloc_text(PAGE, DriverUnload)
#endif // !PNP
#endif // ALLOC_PRAGMA

#ifdef ALLOC_DATA_PRAGMA
#pragma data_seg("PAGEDATA")
#endif // ALLOC_DATA_PRAGMA

static const WCHAR	LinkName[] = L"\\DosDevices\\msmpu401";
static const WCHAR	DeviceName[] = L"\\Device\\msmpu401";

static const WCHAR DeviceTypeName[] = L"{xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx}";

static const KSOBJECT_CREATE_ITEM CreateItems[] = {
	{
		FilterDispatchCreate,
        {
			sizeof(DeviceTypeName) - sizeof(UNICODE_NULL),
			sizeof(DeviceTypeName),
            (PWCHAR)DeviceTypeName
		},
		0
	}
};

#ifdef ALLOC_DATA_PRAGMA
#pragma data_seg()
#endif // ALLOC_DATA_PRAGMA

static
BOOL
DataReadReady(
	IN PDEVICE_INSTANCE	DeviceInstance
	)
{
	ULONG	TimeOutCount;

	for (TimeOutCount = MPU_TIMEOUT; TimeOutCount; TimeOutCount--) {
		if (!(READ_STATUS_PORT(DeviceInstance) & MPU401_DRR))
			return TRUE;
		READ_DATA_PORT(DeviceInstance);
	}
	return FALSE;
}

static
BOOL
DataSetReady(
	IN PDEVICE_INSTANCE	DeviceInstance
	)
{
	ULONG	TimeOutCount;

	for (TimeOutCount = MPU_TIMEOUT; READ_STATUS_PORT(DeviceInstance) & MPU401_DSR; TimeOutCount--) {
		if (!TimeOutCount)
			return FALSE;
		KeStallExecutionProcessor(1);
	}
	return TRUE;
}

static
BOOLEAN
ValidateHardwareSynchronize(
	IN PVOID SynchronizeContext
	)
{
	PDEVICE_INSTANCE	DeviceInstance;

	DeviceInstance = (PDEVICE_INSTANCE)SynchronizeContext;
	WRITE_COMMAND_PORT(DeviceInstance, MPU401_CMD_RESET);
	if (DataReadReady(DeviceInstance) && (READ_DATA_PORT(DeviceInstance) == MPU401_ACK) && DataReadReady(DeviceInstance)) {
		WRITE_COMMAND_PORT(DeviceInstance, MPU401_CMD_UART_MODE);
		if (DataSetReady(DeviceInstance) && (READ_DATA_PORT(DeviceInstance) == MPU401_ACK))
			return TRUE;
	}
	return FALSE;
}

static
NTSTATUS
ProcessResources(
	IN PDEVICE_OBJECT		DeviceObject,
	IN PDEVICE_INSTANCE		DeviceInstance,
	IN PCM_RESOURCE_LIST	Resources,
	IN ULONG				ResourcesSize
	)
{
	PCM_PARTIAL_RESOURCE_DESCRIPTOR	ResDes;
	ULONG							ResCount;
	BOOLEAN							Conflicted;
	NTSTATUS						Status;

	if (!NT_SUCCESS(Status = IoReportResourceUsage(NULL, DeviceObject->DriverObject, Resources, ResourcesSize, NULL, NULL, 0, FALSE, &Conflicted)))
		return Status;
	ResDes = Resources->List[0].PartialResourceList.PartialDescriptors;
	for (ResCount = 0; ResCount < Resources->List[0].PartialResourceList.Count; ResCount++, ResDes++)
		switch (ResDes->Type) {
		case CmResourceTypePort:
			if (ResDes->u.Port.Length == MPU401_REG_EXTENT) {
				DeviceInstance->PortBase = TranslateBusAddress(Resources->List[0].InterfaceType, Resources->List[0].BusNumber, ResDes);
				break;
			}
			return STATUS_DEVICE_CONFIGURATION_ERROR;
		case CmResourceTypeInterrupt:
		{
			NTSTATUS	Status;

			IoInitializeDpcRequest(DeviceObject, HwDeferredRead);
			DeviceInstance->DpcCount = 0;
			KeInitializeSpinLock(&DeviceInstance->IrqLock);
			if (!NT_SUCCESS(Status = ConnectInterrupt(Resources->List[0].InterfaceType, Resources->List[0].BusNumber, ResDes, HwDeviceIsr, DeviceObject, FALSE, &DeviceInstance->IrqLock, &DeviceInstance->InterruptInfo)))
				return Status;
			break;
		}
		default:
			return STATUS_DEVICE_CONFIGURATION_ERROR;
		}
	if (!KeSynchronizeExecution(DeviceInstance->InterruptInfo.Interrupt, ValidateHardwareSynchronize, DeviceInstance)) {
		IoDisconnectInterrupt(DeviceInstance->InterruptInfo.Interrupt);
		return STATUS_DEVICE_CONFIGURATION_ERROR;
	}
	return STATUS_SUCCESS;
}

static
NTSTATUS
PnpAddDevice(
	IN PDRIVER_OBJECT	DriverObject,
	IN PDEVICE_OBJECT	PhysicalDeviceObject
	)
{
	UNICODE_STRING			DeviceNameString;
	PDEVICE_OBJECT			FunctionalDeviceObject;
	PDEVICE_INSTANCE		DeviceInstance;
	NTSTATUS				Status;
	PCM_RESOURCE_LIST		Resources;
	ULONG					ResourcesSize;

#ifdef PNP
	//!! Get resources through PnP;
#else // !PNP
	if (!NT_SUCCESS(Status = KsAllocateConfig((PUNICODE_STRING)PhysicalDeviceObject, &Resources, &ResourcesSize)))
		return Status;
#endif // !PNP
	RtlInitUnicodeString(&DeviceNameString, DeviceName);
	if (NT_SUCCESS(Status = IoCreateDevice(DriverObject, sizeof(DEVICE_INSTANCE), &DeviceNameString, FILE_DEVICE_KS, 0, FALSE, &FunctionalDeviceObject))) {
		DeviceInstance = (PDEVICE_INSTANCE)FunctionalDeviceObject->DeviceExtension;
		if (NT_SUCCESS(Status = RtlCreateSymbolicLink(&DeviceInstance->LinkName, (PWCHAR)LinkName, &DeviceNameString))) {
			if (NT_SUCCESS(Status = ProcessResources(FunctionalDeviceObject, DeviceInstance, Resources, ResourcesSize))) {
				DeviceInstance->ObjectCreate.CreateItemsCount = SIZEOF_ARRAY(CreateItems);
				DeviceInstance->ObjectCreate.CreateItemsList = (PKSOBJECT_CREATE_ITEM)CreateItems;
				ExInitializeFastMutex(&DeviceInstance->ControlMutex);
				DeviceInstance->PhysicalDeviceObject = PhysicalDeviceObject;
				FunctionalDeviceObject->Flags &= ~DO_DEVICE_INITIALIZING;
				return STATUS_SUCCESS;
			}
			IoDeleteSymbolicLink(&DeviceInstance->LinkName);
			ExFreePool(DeviceInstance->LinkName.Buffer);
		}
		IoDeleteDevice(FunctionalDeviceObject);
	}
#ifdef PNP
	//!! Release resource structure;
#else // !PNP
	ExFreePool(Resources);
#endif // !PNP
	return Status;
}

#ifdef PNP
static
NTSTATUS
DispatchPnp(
	IN PDEVICE_OBJECT	DeviceObject,
	IN PIRP				Irp
	)
{
	return STATUS_SUCCESS;
}
#else // !PNP
static
VOID
DriverUnload(
	IN PDRIVER_OBJECT	DriverObject
	)
{
	while (DriverObject->DeviceObject) {
		PDEVICE_INSTANCE	DeviceInstance;

		DeviceInstance = (PDEVICE_INSTANCE)DriverObject->DeviceObject->DeviceExtension;
		IoDeleteSymbolicLink(&DeviceInstance->LinkName);
		ExFreePool(DeviceInstance->LinkName.Buffer);
		IoDisconnectInterrupt(DeviceInstance->InterruptInfo.Interrupt);
		IoDeleteDevice(DriverObject->DeviceObject);
	}
}
#endif // !PNP

NTSTATUS
DriverEntry(
	IN PDRIVER_OBJECT       DriverObject,
	IN PUNICODE_STRING      RegistryPathName
	)
{
	KsSetMajorFunctionHandler(DriverObject, IRP_MJ_CREATE);
	KsSetMajorFunctionHandler(DriverObject, IRP_MJ_CLOSE);
	KsSetMajorFunctionHandler(DriverObject, IRP_MJ_DEVICE_CONTROL);
#ifdef PNP
	DriverObject->MajorFunction[IRP_MJ_PNP] = DispatchPnp;
	DriverObject->DriverExtension->AddDevice = PnpAddDevice;
	return STATUS_SUCCESS;
#else // !PNP
	DriverObject->DriverUnload = DriverUnload;
	return PnpAddDevice(DriverObject, (PDEVICE_OBJECT)RegistryPathName);
#endif // !PNP
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\ksfilter\msmpu401\filter.c ===
/*++

Copyright (C) Microsoft Corporation, 1996 - 1996

Module Name:

	filter.c

Abstract:

	Filter property sets.

--*/

#include "common.h"

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, FilterDispatchCreate)
#pragma alloc_text(PAGE, FilterDispatchClose)
#pragma alloc_text(PAGE, FilterDispatchIoControl)
#pragma alloc_text(PAGE, FilterPinPropertyHandler)
#pragma alloc_text(PAGE, FilterPinInstances)
#pragma alloc_text(PAGE, FilterPinDataRouting)
#pragma alloc_text(PAGE, FilterPinDataIntersection)
#pragma alloc_text(PAGE, FilterProvider)
#endif // ALLOC_PRAGMA

#ifdef ALLOC_DATA_PRAGMA
#pragma data_seg("PAGEDATA")
#endif // ALLOC_DATA_PRAGMA

static const PDRIVER_DISPATCH CreateHandlers[] = {
	NULL,
	PinDispatchCreate
};

static const KSDISPATCH_TABLE FilterDispatchTable = {
	SIZEOF_ARRAY(CreateHandlers),
	(PDRIVER_DISPATCH*)CreateHandlers,
	FilterDispatchIoControl,
	NULL,
	NULL,
	FilterDispatchClose
};

DEFINE_KSPROPERTY_PINSET(PinPropertyHandlers,
    FilterPinPropertyHandler, FilterPinInstances,
    FilterPinDataRouting, sizeof(KSP_PIN) + sizeof(KSDATAFORMAT),
    FilterPinDataIntersection, sizeof(KSP_PIN) + sizeof(KSDATAFORMAT) + sizeof(KSPIN_DATAROUTING) + sizeof(KSDATARANGE))

static const KSPROPERTY_ITEM PinGeneralHandlers[] = {
	{
		KSPROPERTY_GENERAL_PROVIDER,
		FilterProvider,
		sizeof(KSPROPERTY),
		sizeof(KSPROVIDER),
		NULL, 0, 0, NULL, 0, NULL, NULL
	},
};

static const KSPROPERTY_SET FilterPropertySets[] = {
	{
		&KSPROPSETID_Pin,
		SIZEOF_ARRAY(PinPropertyHandlers),
		(PKSPROPERTY_ITEM)PinPropertyHandlers,
		0, NULL, 0, 0
	},
	{
		&KSPROPSETID_General,
		SIZEOF_ARRAY(PinGeneralHandlers),
		(PKSPROPERTY_ITEM)PinGeneralHandlers,
		0, NULL, 0, 0
	},
};

static const KSPIN_INTERFACE FilterPinDataInterfaces[] = {
	{
		STATIC_KSINTERFACESETID_Standard,
		KSINTERFACE_STANDARD_STREAMING
	},
};

static const KSPIN_INTERFACE FilterPinPortInterfaces[] = {
	{
		STATIC_KSINTERFACESETID_Media,
		KSINTERFACE_MEDIA_MUSIC
	},
};

static const KSPIN_MEDIUM FilterPinDataMediums[] = {
	{
		STATIC_KSMEDIUMSETID_Standard,
		KSMEDIUM_STANDARD_DEVIO
	},
};

static const KSPIN_MEDIUM FilterPinPortMediums[] = {
	{
		STATIC_KSMEDIUMSETID_Media,
		KSMEDIUM_MEDIA_MIDIBUS
	},
};

static const KSDATARANGE FilterPinDataRangeMIDI = {
	sizeof(KSDATARANGE),
	0,
	STATIC_KSDATAFORMAT_TYPE_MUSIC,
	STATIC_KSDATAFORMAT_SUBTYPE_MIDI,
	STATIC_KSDATAFORMAT_FORMAT_NONE
};

static const PKSDATARANGE FilterPinDataPlaybackRanges[] = {
	(PKSDATARANGE)&FilterPinDataRangeMIDI
};

static const PKSDATARANGE FilterPinDataCaptureRanges[] = {
	(PKSDATARANGE)&FilterPinDataRangeMIDI
};

static const KSDATARANGE FilterPinPortRange = {
	sizeof(KSDATARANGE),
	0,
	STATIC_KSDATAFORMAT_TYPE_MUSIC,
	STATIC_KSDATAFORMAT_SUBTYPE_MIDI_BUS,
	STATIC_KSDATAFORMAT_FORMAT_NONE
};

static const PKSDATARANGE FilterPinPortRanges[] = {
	(PKSDATARANGE)&FilterPinPortRange
};

const KSPIN_DESCRIPTOR FilterPinDescriptors[] = {
#if ID_MUSICPLAYBACK_PIN != 0
#error ID_MUSICPLAYBACK_PIN incorrect
#endif // ID_MUSICPLAYBACK_PIN != 0
	{
		SIZEOF_ARRAY(FilterPinDataInterfaces),
		(PKSPIN_INTERFACE)FilterPinDataInterfaces,
		SIZEOF_ARRAY(FilterPinDataMediums),
		(PKSPIN_MEDIUM)FilterPinDataMediums,
		SIZEOF_ARRAY(FilterPinDataPlaybackRanges),
		(PKSDATARANGE*)FilterPinDataPlaybackRanges,
		KSPIN_DATAFLOW_IN,
		KSPIN_COMMUNICATION_SINK,
		{
			STATIC_KSTRANSFORMSETID_Standard,
			KSTRANSFORM_STANDARD_CONVERTER
		}
	},
#if ID_MUSICCAPTURE_PIN != 1
#error ID_MUSICCAPTURE_PIN incorrect
#endif // ID_MUSICCAPTURE_PIN != 1
	{
		SIZEOF_ARRAY(FilterPinDataInterfaces),
		(PKSPIN_INTERFACE)FilterPinDataInterfaces,
		SIZEOF_ARRAY(FilterPinDataMediums),
		(PKSPIN_MEDIUM)FilterPinDataMediums,
		SIZEOF_ARRAY(FilterPinDataCaptureRanges),
		(PKSDATARANGE*)FilterPinDataCaptureRanges,
		KSPIN_DATAFLOW_OUT,
		KSPIN_COMMUNICATION_SINK,
		{
			STATIC_KSTRANSFORMSETID_Standard,
			KSTRANSFORM_STANDARD_CONVERTER
		}
	},
#if ID_PORTPLAYBACK_PIN != 2
#error ID_PORTPLAYBACK_PIN incorrect
#endif // ID_PORTPLAYBACK_PIN != 2
	{
		SIZEOF_ARRAY(FilterPinPortInterfaces),
		(PKSPIN_INTERFACE)FilterPinPortInterfaces,
		SIZEOF_ARRAY(FilterPinPortMediums),
		(PKSPIN_MEDIUM)FilterPinPortMediums,
		SIZEOF_ARRAY(FilterPinPortRanges),
		(PKSDATARANGE*)FilterPinPortRanges,
		KSPIN_DATAFLOW_OUT,
		KSPIN_COMMUNICATION_NONE,
		{
			STATIC_KSTRANSFORMSETID_Standard,
			KSTRANSFORM_STANDARD_BRIDGE
		}
	},
#if ID_PORTCAPTURE_PIN != 3
#error ID_PORTCAPTURE_PIN incorrect
#endif // ID_PORTCAPTURE_PIN != 3
	{
		SIZEOF_ARRAY(FilterPinPortInterfaces),
		(PKSPIN_INTERFACE)FilterPinPortInterfaces,
		SIZEOF_ARRAY(FilterPinPortMediums),
		(PKSPIN_MEDIUM)FilterPinPortMediums,
		SIZEOF_ARRAY(FilterPinPortRanges),
		(PKSDATARANGE*)FilterPinPortRanges,
		KSPIN_DATAFLOW_IN,
		KSPIN_COMMUNICATION_NONE,
		{
			STATIC_KSTRANSFORMSETID_Standard,
			KSTRANSFORM_STANDARD_BRIDGE
		}
	},
};

#ifdef ALLOC_DATA_PRAGMA
#pragma data_seg()
#endif // ALLOC_DATA_PRAGMA

NTSTATUS
FilterDispatchCreate(
	IN PDEVICE_OBJECT	DeviceObject,
	IN PIRP				Irp
	)
{
	PIO_STACK_LOCATION	IrpStack;
	PDEVICE_INSTANCE	DeviceInstance;
	PFILTER_INSTANCE	FilterInstance;
	NTSTATUS			Status;

	Irp->IoStatus.Information = 0;
	IrpStack = IoGetCurrentIrpStackLocation(Irp);
	DeviceInstance = (PDEVICE_INSTANCE)IrpStack->DeviceObject->DeviceExtension;
	if (FilterInstance = (PFILTER_INSTANCE)ExAllocatePool(NonPagedPool, sizeof(FILTER_INSTANCE))) {
		FilterInstance->DispatchTable = (PKSDISPATCH_TABLE)&FilterDispatchTable;
		IrpStack->FileObject->FsContext = FilterInstance;
		Status = STATUS_SUCCESS;
	} else
		Status = STATUS_NO_MEMORY;
	Irp->IoStatus.Status = Status;
	IoCompleteRequest(Irp, IO_NO_INCREMENT);
	return Status;
}

NTSTATUS
FilterDispatchClose(
	IN PDEVICE_OBJECT	DeviceObject,
	IN PIRP				Irp
	)
{
	PIO_STACK_LOCATION	IrpStack;

	IrpStack = IoGetCurrentIrpStackLocation(Irp);
	ExFreePool(IrpStack->FileObject->FsContext);
	Irp->IoStatus.Information = 0;
	Irp->IoStatus.Status = STATUS_SUCCESS;
	IoCompleteRequest(Irp, IO_NO_INCREMENT);
	return STATUS_SUCCESS;
}

NTSTATUS
FilterDispatchIoControl(
	IN PDEVICE_OBJECT	DeviceObject,
	IN PIRP				Irp
	)
{
	PIO_STACK_LOCATION	IrpStack;
	NTSTATUS			Status;

	IrpStack = IoGetCurrentIrpStackLocation(Irp);
	switch (IrpStack->Parameters.DeviceIoControl.IoControlCode) {
	case IOCTL_KS_GET_PROPERTY:
	case IOCTL_KS_SET_PROPERTY:
		Status = KsPropertyHandler(Irp, SIZEOF_ARRAY(FilterPropertySets), (PKSPROPERTY_SET)FilterPropertySets);
		break;
	default:
		Status = STATUS_INVALID_DEVICE_REQUEST;
		break;
	}
	Irp->IoStatus.Status = Status;
	IoCompleteRequest(Irp, IO_NO_INCREMENT);
	return Status;
}

NTSTATUS
FilterPinPropertyHandler(
	IN PIRP			Irp,
	IN PKSPROPERTY	Property,
	IN OUT PVOID	Data
	)
{
	return KsPinPropertyHandler(Irp, Property, Data, SIZEOF_ARRAY(FilterPinDescriptors), (PKSPIN_DESCRIPTOR)FilterPinDescriptors);
}

NTSTATUS
FilterPinInstances(
	IN PIRP					Irp,
	IN PKSPROPERTY			Property,
	OUT PKSPIN_CINSTANCES	CInstancess
	)
{
	ULONG				PinId;
	PIO_STACK_LOCATION	IrpStack;
	PDEVICE_INSTANCE	DeviceInstance;

	PinId = ((PKSP_PIN)Property)->PinId;
	if (PinId >= SIZEOF_ARRAY(FilterPinDescriptors))
		return STATUS_INVALID_PARAMETER;
	IrpStack = IoGetCurrentIrpStackLocation(Irp);
	DeviceInstance = (PDEVICE_INSTANCE)IrpStack->DeviceObject->DeviceExtension;
	CInstancess->CurrentCount = 0;
	switch (PinId) {
	case ID_MUSICPLAYBACK_PIN:
	case ID_MUSICCAPTURE_PIN:
		CInstancess->PossibleCount = 1;
		if (((PDEVICE_INSTANCE)IrpStack->DeviceObject->DeviceExtension)->PinFileObjects[PinId])
			CInstancess->CurrentCount = 1;
		break;
	case ID_PORTPLAYBACK_PIN:
	case ID_PORTCAPTURE_PIN:
		CInstancess->PossibleCount = 0;
		break;
	}
	Irp->IoStatus.Information = sizeof(KSPIN_CINSTANCES);
	return STATUS_SUCCESS;
}

NTSTATUS
FilterPinDataRouting(
	IN PIRP			Irp,
	IN PKSPROPERTY	Property,
	IN OUT PVOID	Data
	)
{
	ULONG				PinId;
	PKSP_PIN			Pin;
	ULONG				OutputBufferLength;
	ULONG				DataRangesSize;
	PKSDATAFORMAT		DataFormat;
	PKSDATARANGE*		DataRanges;
	ULONG				DataRangesCount;
	NTSTATUS			Status;
	PIO_STACK_LOCATION	IrpStack;

	Pin = (PKSP_PIN)Property;
	if (Pin->PinId >= SIZEOF_ARRAY(FilterPinDescriptors))
		return STATUS_INVALID_PARAMETER;
	IrpStack = IoGetCurrentIrpStackLocation(Irp);
	DataFormat = (PKSDATAFORMAT)(Pin + 1);
	if (DataFormat->FormatSize + sizeof(KSP_PIN) > IrpStack->Parameters.DeviceIoControl.InputBufferLength)
		return STATUS_BUFFER_TOO_SMALL;
	for (DataRangesCount = FilterPinDescriptors[Pin->PinId].DataRangesCount, DataRanges = FilterPinDescriptors[Pin->PinId].DataRanges;; DataRangesCount--, DataRanges++)
		if (!DataRangesCount)
			return STATUS_INVALID_DEVICE_REQUEST;
		else if ((DataFormat->FormatSize == sizeof(KSDATAFORMAT)) && IsEqualGUIDAligned(&DataRanges[0]->MajorFormat, &DataFormat->MajorFormat) && IsEqualGUIDAligned(&DataRanges[0]->SubFormat, &DataFormat->SubFormat) && IsEqualGUIDAligned(&DataRanges[0]->Specifier, &DataFormat->Specifier))
			break;
	switch (Pin->PinId) {
	case ID_MUSICPLAYBACK_PIN:
		PinId = ID_PORTPLAYBACK_PIN;
		break;
	case ID_PORTPLAYBACK_PIN:
		PinId = ID_MUSICPLAYBACK_PIN;
		break;
	case ID_MUSICCAPTURE_PIN:
		PinId = ID_PORTCAPTURE_PIN;
		break;
	case ID_PORTCAPTURE_PIN:
		PinId = ID_MUSICCAPTURE_PIN;
		break;
	}
	DataRanges = FilterPinDescriptors[PinId].DataRanges;
	DataRangesSize = sizeof(KSPIN_DATAROUTING);
	for (DataRangesCount = FilterPinDescriptors[Pin->PinId].DataRangesCount, DataRanges = FilterPinDescriptors[Pin->PinId].DataRanges; DataRangesCount; DataRangesCount--, DataRanges++)
		DataRangesSize += DataRanges[0]->FormatSize;
	OutputBufferLength = IrpStack->Parameters.DeviceIoControl.OutputBufferLength;
	if (OutputBufferLength == sizeof(ULONG)) {
		*(PULONG)Data = DataRangesSize;
		Irp->IoStatus.Information = sizeof(ULONG);
	} else if (OutputBufferLength < DataRangesSize)
		return STATUS_BUFFER_TOO_SMALL;
	else {
		PKSPIN_DATAROUTING	pDataRouting;

		pDataRouting = (PKSPIN_DATAROUTING)Data;
		DataRanges = FilterPinDescriptors[PinId].DataRanges;
		pDataRouting->PinId = PinId;
		pDataRouting->DataRanges = FilterPinDescriptors[PinId].DataRangesCount;
		Data = pDataRouting + 1;
		for (DataRangesCount = FilterPinDescriptors[PinId].DataRangesCount; DataRangesCount; DataRangesCount--, DataRanges++) {
			RtlCopyMemory(Data, DataRanges[0], DataRanges[0]->FormatSize);
			(PUCHAR)Data += DataRanges[0]->FormatSize;
		}
		Irp->IoStatus.Information = DataRangesSize;
	}
	return STATUS_SUCCESS;
}

NTSTATUS
FilterPinDataIntersection(
	IN PIRP			Irp,
	IN PKSPROPERTY	Property,
	IN OUT PVOID	Data
	)
{
	return STATUS_SUCCESS;
}

NTSTATUS
FilterProvider(
	IN PIRP			Irp,
	IN PKSPROPERTY	Property,
	IN OUT PVOID	Data
	)
{
	PKSPROVIDER	Provider;

	Provider = (PKSPROVIDER)Data;
	Provider->Provider = KSPROVIDER_Microsoft;
	Provider->Product = KSPRODUCT_Microsoft;
	Provider->Version.Version = 0;
	Provider->Version.Revision = 0;
	Provider->Version.Build = 0;
	Irp->IoStatus.Information = sizeof(KSPROVIDER);
	return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\ksfilter\msmpu401\hardware.c ===
/*++

Copyright (C) Microsoft Corporation, 1996 - 1996

Module Name:

	hardware.c

Abstract:

	Hardware I/O.

--*/

#include "common.h"

VOID
HwCancelRoutine(
	IN PDEVICE_OBJECT	DeviceObject,
	IN PIRP				Irp
	)
{
	RemoveEntryList(&Irp->Tail.Overlay.ListEntry);
	Irp->IoStatus.Status = STATUS_CANCELLED;
	Irp->Tail.Overlay.AuxiliaryBuffer = NULL;
	IoReleaseCancelSpinLock(Irp->CancelIrql);
	IoCompleteRequest(Irp, IO_NO_INCREMENT);
}

BOOLEAN
HwDeviceIsr(
	IN PKINTERRUPT		Interrupt,
	IN PDEVICE_OBJECT	DeviceObject
	)
{
	PDEVICE_INSTANCE	DeviceInstance;

	DeviceInstance = (PDEVICE_INSTANCE)DeviceObject->DeviceExtension;
	if (READ_STATUS_PORT(DeviceInstance) & MPU401_DSR)
		return FALSE;
	if (IoRequestDpc(DeviceObject, NULL, NULL))
		InterlockedIncrement(&DeviceInstance->DpcCount);
	return TRUE;
}

static
VOID
CompletePendingIrp(
	IN PIRP			Irp,
	IN OUT PKIRQL	IrqlOld
	)
{
	RemoveEntryList(&Irp->Tail.Overlay.ListEntry);
	IoSetCancelRoutine(Irp, NULL);
	Irp->IoStatus.Status = STATUS_SUCCESS;
	Irp->Tail.Overlay.AuxiliaryBuffer = NULL;
	IoReleaseCancelSpinLock(*IrqlOld);
	IoCompleteRequest(Irp, IO_SOUND_INCREMENT);
	IoAcquireCancelSpinLock(IrqlOld);
}

VOID
HwDeferredRead(
	IN PKDPC			Dpc,
	IN PDEVICE_OBJECT	DeviceObject,
	IN ULONGLONG		SystemTime
	)
{
	PDEVICE_INSTANCE	DeviceInstance;
	PPIN_INSTANCE		PinInstance;
	BOOLEAN				FifoEmpty;

	FifoEmpty = FALSE;
	DeviceInstance = (PDEVICE_INSTANCE)DeviceObject->DeviceExtension;
	PinInstance = (PPIN_INSTANCE)DeviceInstance->PinFileObjects[ID_MUSICCAPTURE_PIN]->FsContext;
	if (PinInstance && (PinInstance->State == KSSTATE_RUN)) {
		ULONG		TimeStamp;
		PLIST_ENTRY	IrpListEntry;
		KIRQL		IrqlOld;

		TimeStamp = (ULONG)((KeQueryPerformanceCounter(NULL).QuadPart - PinInstance->TimeBase) * 1000 / PinInstance->Frequency);
		IoAcquireCancelSpinLock(&IrqlOld);
		for (IrpListEntry = PinInstance->IoQueue.Flink; IrpListEntry != &PinInstance->IoQueue; IrpListEntry = PinInstance->IoQueue.Flink) {
			PIO_STACK_LOCATION	IrpStack;
			PIRP				Irp;
			PCHAR				ReadParam;
			PCHAR				Buffer;
			ULONG				ReadSize;
			PKSSTREAM_HEADER	StreamHdr;

			Irp = (PIRP)CONTAINING_RECORD(IrpListEntry->Flink, IRP, Tail.Overlay.ListEntry);
			IrpStack = IoGetCurrentIrpStackLocation(Irp);
			ReadParam = MmGetSystemAddressForMdl(Irp->MdlAddress);
			StreamHdr = (PKSSTREAM_HEADER)Irp->AssociatedIrp.SystemBuffer;
			Buffer = ReadParam + StreamHdr->DataSize;
			if (!StreamHdr->DataSize || (StreamHdr->PresentationTime.Time / 10000 + *(PULONG)Irp->Tail.Overlay.AuxiliaryBuffer != TimeStamp)) {
				PCHAR	NextChunk;

				NextChunk = (PCHAR)(((ULONG)Buffer + FILE_LONG_ALIGNMENT) & ~FILE_LONG_ALIGNMENT);
				if (!StreamHdr->DataSize) {
					StreamHdr->PresentationTime.Time = TimeStamp * 10000;
					*(PULONG)NextChunk = 0;
				} else if ((ULONG)(NextChunk + 2 * sizeof(ULONG) - ReadParam) >= IrpStack->Parameters.DeviceIoControl.InputBufferLength) {
					CompletePendingIrp(Irp, &IrqlOld);
					continue;
				} else
					*(PULONG)NextChunk = (ULONG)(TimeStamp - StreamHdr->PresentationTime.Time / 10000);
				*((PULONG)NextChunk + 1) = 0;
				Irp->Tail.Overlay.AuxiliaryBuffer = NextChunk;
				NextChunk += (2 * sizeof(ULONG));
				PinInstance->ByteIo += NextChunk - Buffer;
				Buffer = NextChunk;
			}
			ReadSize = 0;
			do {
				*Buffer++ = READ_DATA_PORT(DeviceInstance);
				ReadSize++;
				if (READ_STATUS_PORT(DeviceInstance) & MPU401_DSR) {
					FifoEmpty = TRUE;
					break;
				}
			} while ((ULONG)(Buffer - ReadParam) < IrpStack->Parameters.DeviceIoControl.InputBufferLength);
			*((PULONG)Irp->Tail.Overlay.AuxiliaryBuffer + 1) += ReadSize;
			PinInstance->ByteIo += ReadSize;
			StreamHdr->DataSize = Buffer - ReadParam;
			if ((ULONG)(Buffer - ReadParam) == IrpStack->Parameters.DeviceIoControl.InputBufferLength)
				CompletePendingIrp(Irp, &IrqlOld);
			if (FifoEmpty)
				break;
		}
		IoReleaseCancelSpinLock(IrqlOld);
		PinGenerateEvent(PinInstance, &KSEVENTSETID_Connection, KSEVENT_CONNECTION_POSITIONUPDATE);
	}
	if (!FifoEmpty) {
		KIRQL	IrqlOld;

		IoAcquireCancelSpinLock(&IrqlOld);
		do
			READ_DATA_PORT(DeviceInstance);
		while (!(READ_STATUS_PORT(DeviceInstance) & MPU401_DSR));
		IoReleaseCancelSpinLock(IrqlOld);
	}
	InterlockedDecrement(&DeviceInstance->DpcCount);
}

VOID
HwDeferredWrite(
	IN PKDPC			Dpc,
	IN PDEVICE_OBJECT	DeviceObject,
	IN ULONGLONG		SystemTime
	)
{
	PDEVICE_INSTANCE	DeviceInstance;
	PPIN_INSTANCE		PinInstance;

	DeviceInstance = (PDEVICE_INSTANCE)DeviceObject->DeviceExtension;
	PinInstance = (PPIN_INSTANCE)DeviceInstance->PinFileObjects[ID_MUSICCAPTURE_PIN]->FsContext;
	if (PinInstance->State == KSSTATE_RUN) {
		ULONG		TimeStamp;
		PLIST_ENTRY	IrpListEntry;
		KIRQL		IrqlOld;

		TimeStamp = (ULONG)((KeQueryPerformanceCounter(NULL).QuadPart - PinInstance->TimeBase) * 1000 / PinInstance->Frequency);
		IoAcquireCancelSpinLock(&IrqlOld);
		for (IrpListEntry = PinInstance->IoQueue.Flink; IrpListEntry != &PinInstance->IoQueue; IrpListEntry = PinInstance->IoQueue.Flink) {
			PIRP				Irp;
			PCHAR				ReadParam;
			PKSSTREAM_HEADER	StreamHdr;
			ULONG				Continue;

			Irp = (PIRP)CONTAINING_RECORD(IrpListEntry->Flink, IRP, Tail.Overlay.ListEntry);
			StreamHdr = (PKSSTREAM_HEADER)Irp->AssociatedIrp.SystemBuffer;
			ReadParam = MmGetSystemAddressForMdl(Irp->MdlAddress);
			Continue = TRUE;
			for (;;) {
				PCHAR	Buffer;
				ULONG	WriteSize;
				ULONG	WrittenSize;

				if (StreamHdr->PresentationTime.Time / 10000 + *(PULONG)Irp->Tail.Overlay.AuxiliaryBuffer > TimeStamp) {
					LARGE_INTEGER	liTime;

					liTime.QuadPart = -(LONG)(StreamHdr->PresentationTime.Time / 10000 + *(PULONG)Irp->Tail.Overlay.AuxiliaryBuffer - TimeStamp);
					if (!PinInstance->QueueTimer.Header.Inserted && !KeSetTimerEx(&PinInstance->QueueTimer, liTime, 0, &PinInstance->QueueDpc))
						InterlockedIncrement(&PinInstance->TimerCount);
					Continue = FALSE;
					break;
				}
				WriteSize = *(((PULONG)Irp->Tail.Overlay.AuxiliaryBuffer) + 1);
				WrittenSize = Irp->IoStatus.Information;
				WriteSize -= (WrittenSize - (Irp->Tail.Overlay.AuxiliaryBuffer - ReadParam));
				if (WriteSize > StreamHdr->DataSize - WrittenSize)
					WriteSize = StreamHdr->DataSize - WrittenSize;
				for (; WriteSize; WriteSize--) {
					for (Continue = MPU_TIMEOUT; Continue && (READ_STATUS_PORT(DeviceInstance) & MPU401_DRR); Continue--)
						KeStallExecutionProcessor(1);
					if (!Continue)
						break;
					WRITE_DATA_PORT(DeviceInstance, ReadParam[WrittenSize++]);
				}
				if (!WriteSize || (WrittenSize - Irp->IoStatus.Information)) {
					if (Irp->IoStatus.Information == Irp->Tail.Overlay.AuxiliaryBuffer - ReadParam + 2 * sizeof(ULONG))
						PinInstance->ByteIo += 2 * sizeof(ULONG);
					PinInstance->ByteIo += (WrittenSize - Irp->IoStatus.Information);
					if (!WriteSize) {
						PCHAR	NextChunk;

						NextChunk = (PCHAR)(((ULONG)Irp->Tail.Overlay.AuxiliaryBuffer + FILE_LONG_ALIGNMENT) & ~FILE_LONG_ALIGNMENT);
						Irp->IoStatus.Information = NextChunk - ReadParam + 2 * sizeof(ULONG);
						if (Irp->IoStatus.Information >= StreamHdr->DataSize) {
							Irp->IoStatus.Information = StreamHdr->DataSize;
							CompletePendingIrp(Irp, &IrqlOld);
							break;
						}
						PinInstance->ByteIo += (NextChunk - Irp->Tail.Overlay.AuxiliaryBuffer);
						Irp->Tail.Overlay.AuxiliaryBuffer = NextChunk;
					} else {
						Irp->IoStatus.Information = WrittenSize;
						if (!Continue)
							break;
					}
				}
			}
			if (!Continue)
				break;
		}
		IoReleaseCancelSpinLock(IrqlOld);
		PinGenerateEvent(PinInstance, &KSEVENTSETID_Connection, KSEVENT_CONNECTION_POSITIONUPDATE);
	}
	InterlockedDecrement(&PinInstance->TimerCount);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\ksfilter\msmpu401\private.h ===
/*++

Copyright (C) Microsoft Corporation, 1996 - 1996

Module Name:

	private.h

Abstract:

	Internal header file for filter.

--*/

#if (DBG)
#define	STR_MODULENAME	"msmpu401: "
#endif

extern const KSPIN_DESCRIPTOR FilterPinDescriptors[4];

#define	ID_MUSICPLAYBACK_PIN	0
#define	ID_MUSICCAPTURE_PIN		1
#define	ID_PORTPLAYBACK_PIN		2
#define	ID_PORTCAPTURE_PIN		3

typedef struct {
	KSOBJECT_CREATE	ObjectCreate;
	UNICODE_STRING	LinkName;
	PUCHAR			PortBase;
	INTERRUPT_INFO	InterruptInfo;
	KSPIN_LOCK		IrqLock;
	FAST_MUTEX		ControlMutex;
	ULONG			StatusFlags;
	ULONG			DpcCount;
	PDEVICE_OBJECT	PhysicalDeviceObject;
#if ID_MUSICPLAYBACK_PIN != 0
#error ID_MUSICPLAYBACK_PIN incorrect
#endif // ID_MUSICPLAYBACK_PIN != 0
#if ID_MUSICCAPTURE_PIN != 1
#error ID_MUSICCAPTURE_PIN incorrect
#endif // ID_MUSICCAPTURE_PIN != 1
	PFILE_OBJECT	PinFileObjects[2];
} DEVICE_INSTANCE, *PDEVICE_INSTANCE;

typedef struct {
	PKSDISPATCH_TABLE	DispatchTable;
} FILTER_INSTANCE, *PFILTER_INSTANCE;

typedef struct {
	PKSDISPATCH_TABLE	DispatchTable;
	KSSTATE				State;
	LIST_ENTRY			IoQueue;
	LIST_ENTRY			EventQueue;
	KSPIN_LOCK			EventQueueLock;
	ULONGLONG			Frequency;
	ULONGLONG			TimeBase;
	ULONGLONG			ByteIo;
	KSPIN_LOCK			StateLock;
	PFILE_OBJECT		FilterFileObject;
	KSPRIORITY			Priority;
	KTIMER				QueueTimer;
	KDPC				QueueDpc;
	ULONG				TimerCount;
	ULONG				PinId;
} PIN_INSTANCE, *PPIN_INSTANCE;

#define	MPU_STATUS_DEVICEFAILURE	0x00000001

#define	MPU_TIMEOUT				0x8000

#define	MPU401_DRR				0x40	//Data Receive Ready: 0 == ready
#define	MPU401_DSR				0x80	//Data Set Ready: 0 == bytes ready

#define	MPU401_ACK				0xfe	//Ack

#define	MPU401_REG_DATA			0x00
#define	MPU401_REG_STATUS		0x01
#define	MPU401_REG_COMMAND		0x01

#define	WRITE_COMMAND_PORT(p, Data)	WRITE_PORT_UCHAR((p)->PortBase + MPU401_REG_COMMAND, (Data))
#define	READ_STATUS_PORT(p)			READ_PORT_UCHAR((p)->PortBase + MPU401_REG_STATUS)
#define	WRITE_DATA_PORT(p, Data)	WRITE_PORT_UCHAR((p)->PortBase + MPU401_REG_DATA, (Data))
#define	READ_DATA_PORT(p)			READ_PORT_UCHAR((p)->PortBase + MPU401_REG_DATA)

#define	MPU401_REG_EXTENT		2

#define	MPU401_CMD_UART_MODE	0x3f	//put card in 'UART' mode
#define	MPU401_CMD_RESET		0xff	//reset command

#define	IRA_MODE_POWERON		0
#define	IRA_MODE_UART			1


#define	IS_STATUS(b)		((b) & 0x80)
#define	MSG_EVENT(b)		((b) & 0xF0)
#define	MSG_CHAN(b)			((b) & 0x0F)

#define	MIDI_NOTEOFF		((BYTE)0x80)
#define	MIDI_NOTEON			((BYTE)0x90)
#define	MIDI_POLYPRESSURE	((BYTE)0xA0)
#define	MIDI_CONTROLCHANGE	((BYTE)0xB0)
#define	MIDI_PROGRAMCHANGE	((BYTE)0xC0)
#define	MIDI_CHANPRESSURE	((BYTE)0xD0)
#define	MIDI_PITCHBEND		((BYTE)0xE0)
#define	MIDI_META			((BYTE)0xFF)
#define	MIDI_SYSEX			((BYTE)0xF0)
#define	MIDI_SYSEXEND		((BYTE)0xF7)

NTSTATUS
FilterDispatchCreate(
	IN PDEVICE_OBJECT	DeviceObject,
	IN PIRP				Irp
	);
NTSTATUS
FilterDispatchIoControl(
	IN PDEVICE_OBJECT	DeviceObject,
	IN PIRP				Irp
	);
NTSTATUS
FilterDispatchClose(
	IN PDEVICE_OBJECT	DeviceObject,
	IN PIRP				Irp
	);
NTSTATUS
FilterPinPropertyHandler(
	IN PIRP			Irp,
	IN PKSPROPERTY	Property,
	IN OUT PVOID	pvData
	);
NTSTATUS
FilterPinInstances(
	IN PIRP					Irp,
	IN PKSPROPERTY			Property,
	OUT PKSPIN_CINSTANCES	CInstancess
	);
NTSTATUS
FilterPinDataRouting(
	IN PIRP			Irp,
	IN PKSPROPERTY	Property,
	IN OUT PVOID	Data
	);
NTSTATUS
FilterPinDataIntersection(
	IN PIRP			Irp,
	IN PKSPROPERTY	Property,
	IN OUT PVOID	Data
	);
NTSTATUS
FilterProvider(
	IN PIRP			Irp,
	IN PKSPROPERTY	Property,
	IN OUT PVOID	Data
	);
NTSTATUS
PropertyConnectionGetState(
	IN PIRP			Irp,
	IN PKSPROPERTY	Property,
	OUT PKSSTATE	State
	);
NTSTATUS
PropertyConnectionSetState(
	IN PIRP			Irp,
	IN PKSPROPERTY	Property,
	IN PKSSTATE		State
	);
NTSTATUS
PropertyConnectionGetPriority(
	IN PIRP			Irp,
	IN PKSPROPERTY	Property,
	OUT PKSPRIORITY	Priority
	);
NTSTATUS
PropertyConnectionSetPriority(
	IN PIRP			Irp,
	IN PKSPROPERTY	Property,
	IN PKSPRIORITY	Priority
	);
NTSTATUS
PropertyConnectionGetDataFormat(
	IN PIRP				Irp,
	IN PKSPROPERTY		Property,
	OUT PKSDATAFORMAT	DataFormat
	);
NTSTATUS
PropertyLinearGetPosition(
	IN PIRP			Irp,
	IN PKSPROPERTY	Property,
	OUT PULONGLONG	Position
	);
NTSTATUS
PnpAddDevice(
	IN PDRIVER_OBJECT		DriverObject,
	IN OUT PDEVICE_OBJECT	DeviceObject
	);
NTSTATUS
MethodConnectionCancelIo(
	IN PIRP			Irp,
	IN PKSMETHOD	Method,
	IN OUT PVOID	Data
	);
NTSTATUS
PinDispatchCreate(
	IN PDEVICE_OBJECT	DeviceObject,
	IN PIRP				Irp
	);
NTSTATUS
PinDispatchIoControl(
	IN PDEVICE_OBJECT	DeviceObject,
	IN PIRP				Irp
	);
NTSTATUS
PinDispatchClose(
	IN PDEVICE_OBJECT	DeviceObject,
	IN PIRP				Irp
	);
VOID
PinGenerateEvent(
	IN PPIN_INSTANCE	PinInstance,
	IN REFGUID			EventSet,
	IN ULONG			EventId
	);
VOID
HwCancelRoutine(
	IN PDEVICE_OBJECT	DeviceObject,
	IN PIRP				Irp
	);
BOOLEAN
HwDeviceIsr(
	IN PKINTERRUPT		Interrupt,
	IN PDEVICE_OBJECT	DeviceObject
	);
VOID
HwDeferredRead(
	IN PKDPC			Dpc,
	IN PDEVICE_OBJECT	DeviceObject,
	IN ULONGLONG		SystemTime
	);
VOID
HwDeferredWrite(
	IN PKDPC			Dpc,
	IN PDEVICE_OBJECT	DeviceObject,
	IN ULONGLONG		SystemTime
	);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\ksfilter\msmpu401\msmpu401.c ===
/*++

Copyright (C) Microsoft Corporation, 1996 - 1996

Module Name:

    msmpu401.c

Abstract:

    Pin property sets.

--*/

#include "common.h"

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, PropertyConnectionGetState)
#pragma alloc_text(PAGE, PropertyConnectionGetPriority)
#pragma alloc_text(PAGE, PropertyConnectionSetPriority)
#pragma alloc_text(PAGE, PropertyConnectionGetDataFormat)
#pragma alloc_text(PAGE, MethodConnectionCancelIo)
#pragma alloc_text(PAGE, PinDispatchClose)
#pragma alloc_text(PAGE, PinDispatchCreate)
#pragma alloc_text(PAGE, PinDispatchIoControl)
#endif // ALLOC_PRAGMA

#ifdef ALLOC_DATA_PRAGMA
#pragma data_seg("PAGEDATA")
#endif // ALLOC_DATA_PRAGMA

static const KSDISPATCH_TABLE PinDispatchTable = {
    0,
    NULL,
    PinDispatchIoControl,
    NULL,
    NULL,
    PinDispatchClose
};

static const KSPROPERTY_ITEM ConnectionPropertyHandlers[] = {
    {
        KSPROPERTY_CONNECTION_STATE,
        (PFNKSPROPERTYHANDLER)PropertyConnectionGetState,
        sizeof(KSPROPERTY),
        sizeof(KSSTATE),
        (PFNKSPROPERTYHANDLER)PropertyConnectionSetState,
        sizeof(KSPROPERTY),
        sizeof(KSSTATE),
        NULL, 0, NULL, NULL
    },
    {
        KSPROPERTY_CONNECTION_PRIORITY,
        (PFNKSPROPERTYHANDLER)PropertyConnectionGetPriority,
        sizeof(KSPROPERTY),
        sizeof(KSPRIORITY),
        (PFNKSPROPERTYHANDLER)PropertyConnectionSetPriority,
        sizeof(KSPROPERTY),
        sizeof(KSPRIORITY),
        NULL, 0, NULL, NULL
    },
    {
        KSPROPERTY_CONNECTION_DATAFORMAT,
        (PFNKSPROPERTYHANDLER)PropertyConnectionGetDataFormat,
        sizeof(KSPROPERTY),
        sizeof(KSDATAFORMAT),
        NULL, 0, 0, NULL, 0, NULL, NULL
    }
};

static const KSPROPERTY_ITEM LinearPropertyHandlers[] = {
    {
        KSPROPERTY_LINEAR_POSITION,
        (PFNKSPROPERTYHANDLER)PropertyLinearGetPosition,
        sizeof(KSPROPERTY),
        sizeof(ULONGLONG),
        NULL, 0, 0, NULL, 0, NULL, NULL
    }
};

static const KSPROPERTY_SET PinPropertySets[] = {
    {
        &KSPROPSETID_Connection,
        SIZEOF_ARRAY(ConnectionPropertyHandlers),
        (PKSPROPERTY_ITEM)ConnectionPropertyHandlers,
        0, NULL, 0, 0
    },
    {
        &KSPROPSETID_Linear,
        SIZEOF_ARRAY(LinearPropertyHandlers),
        (PKSPROPERTY_ITEM)LinearPropertyHandlers,
        0, NULL, 0, 0
    }
};

static const KSEVENT_ITEM ConnectionEventItems[] = {
    {
        KSEVENT_CONNECTION_POSITIONUPDATE,
        sizeof(KSEVENTDATA),
        0, NULL, NULL, NULL
    }
};

static const KSEVENT_SET EventSets[] = {
    {
        &KSEVENTSETID_Connection,
        SIZEOF_ARRAY(ConnectionEventItems),
        (PKSEVENT_ITEM)ConnectionEventItems
    }
};

static const KSMETHOD_ITEM ConnectionMethodItems[] = {
    {
        KSMETHOD_CONNECTION_CANCELIO + KSMETHOD_TYPE_NONE,
        MethodConnectionCancelIo,
        sizeof(KSMETHOD),
        0, NULL
    },
};

static const KSMETHOD_SET MethodSets[] = {
    {
        &KSMETHODSETID_Connection,
        SIZEOF_ARRAY(ConnectionMethodItems),
        (PVOID)ConnectionMethodItems,
        0, NULL, 0, 0
    },
};

#ifdef ALLOC_DATA_PRAGMA
#pragma data_seg()
#endif // ALLOC_DATA_PRAGMA

VOID
PinGenerateEvent(
    IN PPIN_INSTANCE    PinInstance,
    IN REFGUID          EventSet,
    IN ULONG            EventId
    )
{
    PLIST_ENTRY ListEntry;

    for (ListEntry = PinInstance->EventQueue.Flink; ListEntry != &PinInstance->EventQueue; ListEntry = ListEntry->Flink) {
        PKSEVENT_ENTRY  EventEntry;

        EventEntry = (PKSEVENT_ENTRY)CONTAINING_RECORD(ListEntry, KSEVENT_ENTRY, ListEntry);
        if (IsEqualGUIDAligned(EventSet, EventEntry->EventSet->Set))
            if (EventId == EventEntry->EventItem->EventId)
                switch (EventId) {
                case KSEVENT_CONNECTION_POSITIONUPDATE:
                    KsEventGenerate(EventEntry);
                    break;
                }
    }
}

static
BOOLEAN
DpcCountSynchronize(
    IN PDEVICE_INSTANCE DeviceInstance
    )
{
    return !DeviceInstance->DpcCount;
}

static
VOID
RundownProcessing(
    IN PDEVICE_INSTANCE DeviceInstance,
    IN PPIN_INSTANCE    PinInstance
    )
{
    switch (PinInstance->PinId) {
    case ID_MUSICCAPTURE_PIN:
        while (!KeSynchronizeExecution(DeviceInstance->InterruptInfo.Interrupt, DpcCountSynchronize, DeviceInstance))
            KeStallExecutionProcessor(1);
        break;
    case ID_MUSICPLAYBACK_PIN:
        if (KeCancelTimer(&PinInstance->QueueTimer))
            InterlockedDecrement(&PinInstance->TimerCount);
        while (PinInstance->TimerCount)
            KeStallExecutionProcessor(1);
        break;
    }
}

static
NTSTATUS
SetState(
    IN PPIN_INSTANCE    PinInstance,
    IN KSSTATE          State
    )
{
    ULONGLONG           Time;
    PDEVICE_INSTANCE    DeviceInstance;

    if (PinInstance->State == State)
        return STATUS_SUCCESS;
    DeviceInstance = (PDEVICE_INSTANCE)IoGetRelatedDeviceObject(PinInstance->FilterFileObject)->DeviceExtension;
    switch (State) {
    case KSSTATE_STOP:
        InterlockedExchange((PLONG)&PinInstance->State, (LONG)KSSTATE_STOP);
        RundownProcessing(DeviceInstance, PinInstance);
        PinInstance->TimeBase = 0;
        PinInstance->ByteIo = 0;
        break;
    case KSSTATE_PAUSE:
        if (PinInstance->State == KSSTATE_RUN) {
            InterlockedExchange((PLONG)&PinInstance->State, (LONG)KSSTATE_PAUSE);
            RundownProcessing(DeviceInstance, PinInstance);
            PinInstance->TimeBase = KeQueryPerformanceCounter(NULL).QuadPart - PinInstance->TimeBase;
        } else
            InterlockedExchange((PLONG)&PinInstance->State, (LONG)KSSTATE_PAUSE);
        break;
    case KSSTATE_RUN:
        Time = KeQueryPerformanceCounter(NULL).QuadPart;
        if (PinInstance->State == KSSTATE_STOP)
            PinInstance->TimeBase = Time;
        else
            PinInstance->TimeBase = Time - PinInstance->TimeBase;
        InterlockedExchange((PLONG)&PinInstance->State, (LONG)KSSTATE_RUN);
        Time = 0;
        if (!PinInstance->QueueTimer.Header.Inserted && !KeSetTimerEx(&PinInstance->QueueTimer, *(PLARGE_INTEGER)&Time, 0, &PinInstance->QueueDpc))
            InterlockedIncrement(&PinInstance->TimerCount);
        break;
    }
    return STATUS_SUCCESS;
}

NTSTATUS
PropertyConnectionGetState(
    IN PIRP         Irp,
    IN PKSPROPERTY  Property,
    OUT PKSSTATE    State
    )
{
    *State = ((PPIN_INSTANCE)IoGetCurrentIrpStackLocation(Irp)->FileObject->FsContext)->State;
    Irp->IoStatus.Information = sizeof(KSSTATE);
    return STATUS_SUCCESS;
}

NTSTATUS
PropertyConnectionSetState(
    IN PIRP         Irp,
    IN PKSPROPERTY  Property,
    IN PKSSTATE     State
    )
{
    NTSTATUS        Status;
    PPIN_INSTANCE   PinInstance;
    KIRQL           IrqlOld;

    PinInstance = (PPIN_INSTANCE)IoGetCurrentIrpStackLocation(Irp)->FileObject->FsContext;
    KeAcquireSpinLock(&PinInstance->StateLock, &IrqlOld);
    Status = SetState(PinInstance, *State);
    KeReleaseSpinLock(&PinInstance->StateLock, IrqlOld);
    return Status;
}

NTSTATUS
PropertyConnectionGetPriority(
    IN PIRP         Irp,
    IN PKSPROPERTY  Property,
    OUT PKSPRIORITY Priority
    )
{
    *Priority = ((PPIN_INSTANCE)IoGetCurrentIrpStackLocation(Irp)->FileObject->FsContext)->Priority;
    Irp->IoStatus.Information = sizeof(KSPRIORITY);
    return STATUS_SUCCESS;
}

NTSTATUS
PropertyConnectionSetPriority(
    IN PIRP         Irp,
    IN PKSPROPERTY  Property,
    IN PKSPRIORITY  Priority
    )
{
    ((PPIN_INSTANCE)IoGetCurrentIrpStackLocation(Irp)->FileObject->FsContext)->Priority = *Priority;
    return STATUS_SUCCESS;
}

NTSTATUS
PropertyConnectionGetDataFormat(
    IN PIRP             Irp,
    IN PKSPROPERTY      Property,
    OUT PKSDATAFORMAT   DataFormat
    )
{
    DataFormat->MajorFormat = KSDATAFORMAT_TYPE_MUSIC;
    DataFormat->SubFormat = KSDATAFORMAT_SUBTYPE_MIDI;
    DataFormat->Specifier = KSDATAFORMAT_FORMAT_NONE;
    DataFormat->FormatSize = sizeof(KSDATAFORMAT);
    Irp->IoStatus.Information = sizeof(KSDATAFORMAT);
    return STATUS_SUCCESS;
}

NTSTATUS
PropertyLinearGetPosition(
    IN PIRP         Irp,
    IN PKSPROPERTY  Property,
    OUT PULONGLONG  Position
    )
{
    KIRQL       IrqlOld;

    IoAcquireCancelSpinLock(&IrqlOld);
    *Position = ((PPIN_INSTANCE)IoGetCurrentIrpStackLocation(Irp)->FileObject->FsContext)->ByteIo;
    IoReleaseCancelSpinLock(IrqlOld);
    Irp->IoStatus.Information = sizeof(ULONGLONG);
    return STATUS_SUCCESS;
}

#if 0
NTSTATUS
propTimeBase(
    IN PIRP         Irp,
    IN PKSPROPERTY  Property,
    IN OUT PVOID    Data
    )
{
    PPIN_INSTANCE   PinInstance;
    KIRQL           IrqlOld;

    PinInstance = (PPIN_INSTANCE)IoGetCurrentIrpStackLocation(Irp)->FileObject->FsContext;
    KeAcquireSpinLock(&PinInstance->StateLock, &IrqlOld);
    switch (PinInstance->State) {
    case KSSTATE_STOP:
    case KSSTATE_PAUSE:
        *(PULONGLONG)Data = KeQueryPerformanceCounter(NULL).QuadPart - pci->TimeBase;
        break;
    case KSSTATE_RUN:
        *(PULONGLONG)Data = pci->TimeBase;
        break;
    }
    KeReleaseSpinLock(&PinInstance->StateLock, IrqlOld);
    Irp->IoStatus.Information = sizeof(ULONGLONG);
    return STATUS_SUCCESS;
}
#endif // 0

NTSTATUS
MethodConnectionCancelIo(
    IN PIRP         Irp,
    IN PKSMETHOD    Method,
    IN OUT PVOID    Data
    )
{
    KsCancelIo(&((PPIN_INSTANCE)IoGetCurrentIrpStackLocation(Irp)->FileObject->FsContext)->IoQueue);
    return STATUS_SUCCESS;
}

NTSTATUS PinDispatchClose(
    IN PDEVICE_OBJECT   pDeviceObject,
    IN PIRP         Irp)
{
    PIO_STACK_LOCATION  IrpStack;
    PDEVICE_INSTANCE    DeviceInstance;
    PPIN_INSTANCE       PinInstance;

    IrpStack = IoGetCurrentIrpStackLocation(Irp);
    PinInstance = (PPIN_INSTANCE)IrpStack->FileObject->FsContext;
    SetState(PinInstance, KSSTATE_STOP);
    KsEventFreeList(Irp, &PinInstance->EventQueue, KSEVENTS_SPINLOCK, &PinInstance->EventQueueLock);
    DeviceInstance = (PDEVICE_INSTANCE)IrpStack->DeviceObject->DeviceExtension;
    DeviceInstance->PinFileObjects[PinInstance->PinId] = NULL;
    ObDereferenceObject(PinInstance->FilterFileObject);
    ExFreePool(PinInstance);
    Irp->IoStatus.Information = 0;
    Irp->IoStatus.Status = STATUS_SUCCESS;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);
    return STATUS_SUCCESS;
}

NTSTATUS
PinDispatchCreate(
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp
    )
{
    PIO_STACK_LOCATION  IrpStack;
    PKSPIN_CONNECT      Connect;
    PFILE_OBJECT        FilterFileObject;
    NTSTATUS            Status;

    Irp->IoStatus.Information = 0;
    IrpStack = IoGetCurrentIrpStackLocation(Irp);
    if (NT_SUCCESS(Status = KsValidateConnectRequest(Irp, SIZEOF_ARRAY(FilterPinDescriptors), (PKSPIN_DESCRIPTOR)FilterPinDescriptors, &Connect, &FilterFileObject))) {
        PDEVICE_INSTANCE    DeviceInstance;

        DeviceInstance = (PDEVICE_INSTANCE)DeviceObject->DeviceExtension;
        ExAcquireFastMutexUnsafe(&DeviceInstance->ControlMutex);
        if (!DeviceInstance->PinFileObjects[Connect->PinId]) {
            PPIN_INSTANCE   PinInstance;

            if (PinInstance = (PPIN_INSTANCE)ExAllocatePool(NonPagedPool, sizeof(PIN_INSTANCE))) {
                IrpStack->FileObject->FsContext = (PVOID)PinInstance;
                PinInstance->DispatchTable = (PKSDISPATCH_TABLE)&PinDispatchTable;
                KeQueryPerformanceCounter((PLARGE_INTEGER)&PinInstance->Frequency);
                PinInstance->State = KSSTATE_STOP;
                PinInstance->PinId = Connect->PinId;
                InitializeListHead(&PinInstance->IoQueue);
                InitializeListHead(&PinInstance->EventQueue);
                KeInitializeSpinLock(&PinInstance->EventQueueLock);
                PinInstance->TimeBase = 0;
                PinInstance->ByteIo = 0;
                KeInitializeSpinLock(&PinInstance->StateLock);
                if (Connect->PinId == ID_MUSICPLAYBACK_PIN) {
                    KeInitializeTimerEx(&PinInstance->QueueTimer, NotificationTimer);
                    KeInitializeDpc(&PinInstance->QueueDpc, (PKDEFERRED_ROUTINE)HwDeferredWrite, DeviceObject);
                    PinInstance->TimerCount = 0;
                }
                PinInstance->FilterFileObject = FilterFileObject;
                ObReferenceObject(FilterFileObject);
                PinInstance->Priority = Connect->Priority;
                DeviceInstance->PinFileObjects[Connect->PinId] = IrpStack->FileObject;
            } else
                Status = STATUS_NO_MEMORY;
        } else
            Status = STATUS_CONNECTION_REFUSED;
        ExReleaseFastMutexUnsafe(&DeviceInstance->ControlMutex);
    }
    Irp->IoStatus.Status = Status;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);
    return Status;
}

static
NTSTATUS
WriteStream(
    IN PIRP     Irp
    )
{
    PIO_STACK_LOCATION  IrpStack;
    NTSTATUS            Status;
    PULONG              UserBuffer;
    KIRQL               IrqlOld;
    PPIN_INSTANCE       PinInstance;

    IrpStack = IoGetCurrentIrpStackLocation(Irp);
    Irp->IoStatus.Information = 0;
    if (!IrpStack->Parameters.DeviceIoControl.InputBufferLength)
        return STATUS_SUCCESS;
    if (!NT_SUCCESS(Status = KsProbeStreamIrp(Irp, KSPROBE_ALLOCATEMDL | KSPROBE_PROBEANDLOCK)))
        return Status;
    UserBuffer = MmGetSystemAddressForMdl(Irp->MdlAddress);
    if ((ULONG)UserBuffer & FILE_LONG_ALIGNMENT)
        return STATUS_DATATYPE_MISALIGNMENT;
    if (((PKSSTREAM_HEADER)Irp->AssociatedIrp.SystemBuffer)->DataSize < 2 * sizeof(ULONG) + sizeof(UCHAR))
        return STATUS_BUFFER_TOO_SMALL;
    Irp->Tail.Overlay.AuxiliaryBuffer = (PUCHAR)UserBuffer;
    Irp->IoStatus.Information = 2 * sizeof(ULONG);
    IoMarkIrpPending(Irp);
    Irp->IoStatus.Status = STATUS_PENDING;
    IoAcquireCancelSpinLock(&IrqlOld);
    IoSetCancelRoutine(Irp, HwCancelRoutine);
    PinInstance = (PPIN_INSTANCE)IrpStack->FileObject->FsContext;
    InsertTailList(&PinInstance->IoQueue, &Irp->Tail.Overlay.ListEntry);
    KeAcquireSpinLockAtDpcLevel(&PinInstance->StateLock);
    if ((PinInstance->State == KSSTATE_RUN) && !PinInstance->QueueTimer.Header.Inserted) {
        ULONGLONG   CurrentTime;
        ULONGLONG   NextTime;

        CurrentTime = (KeQueryPerformanceCounter(NULL).QuadPart - PinInstance->TimeBase) * 10000000 / PinInstance->Frequency;
        NextTime = ((PKSSTREAM_HEADER)Irp->AssociatedIrp.SystemBuffer)->PresentationTime.Time + *UserBuffer * 10000;
        if (NextTime < CurrentTime)
            NextTime = 0;
        else
            NextTime = (ULONGLONG)-(LONGLONG)(NextTime - CurrentTime);
        if (!KeSetTimerEx(&PinInstance->QueueTimer, *(PLARGE_INTEGER)&NextTime, 0, &PinInstance->QueueDpc))
            InterlockedIncrement(&PinInstance->TimerCount);
    }
    KeReleaseSpinLockFromDpcLevel(&PinInstance->StateLock);
    IoReleaseCancelSpinLock(IrqlOld);
    return STATUS_PENDING;
}

static
NTSTATUS
ReadStream(
    IN PIRP     Irp
    )
{
    PIO_STACK_LOCATION  IrpStack;
    NTSTATUS            Status;
    PULONG              UserBuffer;
    PKSSTREAM_HEADER    StreamHdr;
    PPIN_INSTANCE       PinInstance;

    IrpStack = IoGetCurrentIrpStackLocation(Irp);
    if (IrpStack->Parameters.DeviceIoControl.InputBufferLength < 2 * sizeof(ULONG) + sizeof(UCHAR))
        return STATUS_BUFFER_TOO_SMALL;
    if (!NT_SUCCESS(Status = KsProbeStreamIrp(Irp, KSPROBE_ALLOCATEMDL | KSPROBE_PROBEANDLOCK)))
        return Status;
    UserBuffer = MmGetSystemAddressForMdl(Irp->MdlAddress);
    if ((ULONG)UserBuffer & FILE_LONG_ALIGNMENT)
        return STATUS_DATATYPE_MISALIGNMENT;
    MmGetSystemAddressForMdl(Irp->MdlAddress);
    Irp->IoStatus.Information = sizeof(KSSTREAM_HEADER);
    StreamHdr = (PKSSTREAM_HEADER)Irp->AssociatedIrp.SystemBuffer;
    StreamHdr->PresentationTime.Time = 0;
    StreamHdr->PresentationTime.Numerator = 1;
    StreamHdr->PresentationTime.Denominator = 1;
    StreamHdr->DataSize = 0;
    StreamHdr->OptionsFlags = 0;
    PinInstance = (PPIN_INSTANCE)IrpStack->FileObject->FsContext;
    KsAddIrpToCancelableQueue(&PinInstance->IoQueue, Irp, FALSE, HwCancelRoutine);
    return STATUS_PENDING;
}

NTSTATUS
PinDispatchIoControl(
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp
    )
{
    PIO_STACK_LOCATION  IrpStack;
    NTSTATUS            Status;
    PPIN_INSTANCE       PinInstance;

    IrpStack = IoGetCurrentIrpStackLocation(Irp);
    PinInstance = (PPIN_INSTANCE)IrpStack->FileObject->FsContext;
    switch (IrpStack->Parameters.DeviceIoControl.IoControlCode) {
    case IOCTL_KS_GET_PROPERTY:
    case IOCTL_KS_SET_PROPERTY:
        Status = KsPropertyHandler(Irp, SIZEOF_ARRAY(PinPropertySets), (PKSPROPERTY_SET)PinPropertySets);
        break;
    case IOCTL_KS_ENABLE_EVENT:
        Status = KsEventEnable(Irp, SIZEOF_ARRAY(EventSets), (PKSEVENT_SET)EventSets, &PinInstance->EventQueue, KSEVENTS_SPINLOCK, &PinInstance->EventQueueLock);
        break;
    case IOCTL_KS_DISABLE_EVENT:
        Status = KsEventDisable(Irp, &PinInstance->EventQueue, KSEVENTS_SPINLOCK, &PinInstance->EventQueueLock);
        break;
    case IOCTL_KS_METHOD:
        Status = KsMethodHandler(Irp, SIZEOF_ARRAY(MethodSets), (PKSMETHOD_SET)MethodSets);
        break;
    case IOCTL_KS_READ_STREAM:
        if (PinInstance->PinId == ID_MUSICCAPTURE_PIN)
            Status = ReadStream(Irp);
        else
            Status = STATUS_INVALID_DEVICE_REQUEST;
        break;
    case IOCTL_KS_WRITE_STREAM:
        if (PinInstance->PinId == ID_MUSICPLAYBACK_PIN)
            Status = WriteStream(Irp);
        else
            Status = STATUS_INVALID_DEVICE_REQUEST;
        break;
    default:
        Status = STATUS_INVALID_DEVICE_REQUEST;
        break;
    }
    if (Status != STATUS_PENDING) {
        Irp->IoStatus.Status = Status;
        IoCompleteRequest(Irp, IO_NO_INCREMENT);
    }
    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\ksfilter\mspclock\device.c ===
/*++

Copyright (C) Microsoft Corporation, 1996 - 1998

Module Name:

    device.c

Abstract:

    Device entry point and hardware validation.

--*/

#include "mspclock.h"

#ifdef ALLOC_PRAGMA
NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT   DriverObject,
    IN PUNICODE_STRING  RegistryPathName
    );

#pragma alloc_text(INIT, DriverEntry)
#endif // ALLOC_PRAGMA


NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT   DriverObject,
    IN PUNICODE_STRING  RegistryPathName
    )
/*++

Routine Description:

    Sets up the driver object to handle the KS interface and PnP Add Device
    request. Does not set up a handler for PnP Irp's, as they are all dealt
    with directly by the PDO.

Arguments:

    DriverObject -
        Driver object for this instance.

    RegistryPathName -
        Contains the registry path which was used to load this instance.

Return Values:

    Returns STATUS_SUCCESS.

--*/
{
    DriverObject->MajorFunction[IRP_MJ_PNP] = KsDefaultDispatchPnp;
    DriverObject->MajorFunction[IRP_MJ_POWER] = KsDefaultDispatchPower;
    DriverObject->MajorFunction[IRP_MJ_SYSTEM_CONTROL] = KsDefaultForwardIrp;
    DriverObject->DriverExtension->AddDevice = PnpAddDevice;
    DriverObject->DriverUnload = KsNullDriverUnload;
    KsSetMajorFunctionHandler(DriverObject, IRP_MJ_CREATE);
    KsSetMajorFunctionHandler(DriverObject, IRP_MJ_CLOSE);
    KsSetMajorFunctionHandler(DriverObject, IRP_MJ_DEVICE_CONTROL);
    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\ksfilter\mspclock\mspclock.c ===
/*++

Copyright (C) Microsoft Corporation, 1996 - 1999

Module Name:

    mspclock.c

Abstract:

    Kernel proxy for external clock.

--*/

#include "mspclock.h"

#ifdef WIN98GOLD
#define KeEnterCriticalRegion()
#define KeLeaveCriticalRegion()
#endif

typedef struct {
    KSDEVICE_HEADER     Header;
} DEVICE_INSTANCE, *PDEVICE_INSTANCE;

typedef struct {
    KSCLOCKINSTANCE     Base;
    FAST_MUTEX          StateMutex;
} INSTANCE, *PINSTANCE;

NTSTATUS
PropertyClockSetTime(
    IN PIRP         Irp,
    IN PKSPROPERTY  Property,
    IN PLONGLONG    Time
    );
NTSTATUS
PropertyClockSetState(
    IN PIRP         Irp,
    IN PKSPROPERTY  Property,
    IN PKSSTATE     State
    );
NTSTATUS
ClockDispatchCreate(
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp
    );
NTSTATUS
ClockDispatchIoControl(
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp
    );
NTSTATUS
ClockDispatchClose(
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, PnpAddDevice)
#pragma alloc_text(PAGE, PropertyClockSetTime)
#pragma alloc_text(PAGE, PropertyClockSetState)
#pragma alloc_text(PAGE, ClockDispatchCreate)
#pragma alloc_text(PAGE, ClockDispatchClose)
#pragma alloc_text(PAGE, ClockDispatchIoControl)
#endif // ALLOC_PRAGMA

static const WCHAR DeviceTypeName[] = KSSTRING_Clock;

static const DEFINE_KSCREATE_DISPATCH_TABLE(CreateItems) {
    DEFINE_KSCREATE_ITEM(ClockDispatchCreate, DeviceTypeName, 0)
};

static DEFINE_KSDISPATCH_TABLE(
    ClockDispatchTable,
    ClockDispatchIoControl,
    NULL,
    NULL,
    NULL,
    ClockDispatchClose,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL);

//
// The standard clock property set is modified to add writable properties
// which are used as the method to set the time and state of the clock.
// Any querying of properties is handled by the internal default clock
// functions. Routing them through this module allows the addition of
// extra functionality to the clock
//
static DEFINE_KSPROPERTY_TABLE(ClockPropertyItems) {
    DEFINE_KSPROPERTY_ITEM(
        KSPROPERTY_CLOCK_TIME,
        KsiPropertyDefaultClockGetTime,
        sizeof(KSPROPERTY),
        sizeof(LONGLONG),
        PropertyClockSetTime,
        NULL, 0, NULL, NULL, 0
    ),
    DEFINE_KSPROPERTY_ITEM_CLOCK_PHYSICALTIME(KsiPropertyDefaultClockGetPhysicalTime),
    DEFINE_KSPROPERTY_ITEM_CLOCK_CORRELATEDTIME(KsiPropertyDefaultClockGetCorrelatedTime),
    DEFINE_KSPROPERTY_ITEM_CLOCK_CORRELATEDPHYSICALTIME(KsiPropertyDefaultClockGetCorrelatedPhysicalTime),
    DEFINE_KSPROPERTY_ITEM_CLOCK_RESOLUTION(KsiPropertyDefaultClockGetResolution),
    DEFINE_KSPROPERTY_ITEM(
        KSPROPERTY_CLOCK_STATE,
        KsiPropertyDefaultClockGetState,
        sizeof(KSPROPERTY),
        sizeof(KSSTATE),
        PropertyClockSetState,
        NULL, 0, NULL, NULL, 0
    ),
    DEFINE_KSPROPERTY_ITEM_CLOCK_FUNCTIONTABLE(KsiPropertyDefaultClockGetFunctionTable)
};

static DEFINE_KSPROPERTY_SET_TABLE(ClockPropertySets) {
    DEFINE_KSPROPERTY_SET(
        &KSPROPSETID_Clock,
        SIZEOF_ARRAY(ClockPropertyItems),
        ClockPropertyItems,
        0, NULL
    )
};

static DEFINE_KSEVENT_TABLE(ClockEventItems) {
    DEFINE_KSEVENT_ITEM(
        KSEVENT_CLOCK_INTERVAL_MARK,
        sizeof(KSEVENT_TIME_INTERVAL),
        sizeof(KSINTERVAL),
        (PFNKSADDEVENT)KsiDefaultClockAddMarkEvent,
        NULL,
        NULL),
    DEFINE_KSEVENT_ITEM(
        KSEVENT_CLOCK_POSITION_MARK,
        sizeof(KSEVENT_TIME_MARK),
        sizeof(LONGLONG),
        (PFNKSADDEVENT)KsiDefaultClockAddMarkEvent,
        NULL,
        NULL)
};

static DEFINE_KSEVENT_SET_TABLE(ClockEventSets) {
    DEFINE_KSEVENT_SET(
        &KSEVENTSETID_Clock,
        SIZEOF_ARRAY(ClockEventItems),
        ClockEventItems
    )
};


NTSTATUS
PnpAddDevice(
    IN PDRIVER_OBJECT   DriverObject,
    IN PDEVICE_OBJECT   PhysicalDeviceObject
    )
/*++

Routine Description:

    When a new device is detected, PnP calls this entry point with the
    new PhysicalDeviceObject (PDO). The driver creates an associated 
    FunctionalDeviceObject (FDO).

Arguments:

    DriverObject -
        Pointer to the driver object.

    PhysicalDeviceObject -
        Pointer to the new physical device object.

Return Values:

    STATUS_SUCCESS or an appropriate error condition.

--*/
{
    PDEVICE_OBJECT      FunctionalDeviceObject;
    PDEVICE_INSTANCE    DeviceInstance;
    NTSTATUS            Status;

    Status = IoCreateDevice(
        DriverObject,
        sizeof(DEVICE_INSTANCE),
        NULL,                           // FDOs are unnamed
        FILE_DEVICE_KS,
        0,
        FALSE,
        &FunctionalDeviceObject);
    if (!NT_SUCCESS(Status)) {
        return Status;
    }
    DeviceInstance = (PDEVICE_INSTANCE)FunctionalDeviceObject->DeviceExtension;
    //
    // This object uses KS to perform access through the DeviceCreateItems.
    //
    Status = KsAllocateDeviceHeader(
        &DeviceInstance->Header,
        SIZEOF_ARRAY(CreateItems),
        (PKSOBJECT_CREATE_ITEM)CreateItems);
    if (NT_SUCCESS(Status)) {
        KsSetDevicePnpAndBaseObject(
            DeviceInstance->Header,
            IoAttachDeviceToDeviceStack(
                FunctionalDeviceObject, 
                PhysicalDeviceObject),
            FunctionalDeviceObject );
        FunctionalDeviceObject->Flags |= DO_POWER_PAGABLE;
        FunctionalDeviceObject->Flags &= ~DO_DEVICE_INITIALIZING;
        return STATUS_SUCCESS;
    }
    IoDeleteDevice(FunctionalDeviceObject);
    return Status;
}


NTSTATUS
PropertyClockSetTime(
    IN PIRP         Irp,
    IN PKSPROPERTY  Property,
    IN PLONGLONG    Time
    )
/*++

Routine Description:

    Handles the Set Time property.

Arguments:

    Irp -
        Contains the Set Time property IRP.

    Property -
        Contains the property identifier parameter.

    Time -
        Contains a pointer to the new time value.

Return Value:

    Return STATUS_SUCCESS.

--*/
{
    PINSTANCE   ClockInst;

    ClockInst = (PINSTANCE)IoGetCurrentIrpStackLocation(Irp)->FileObject->FsContext;
    //
    // Serialize setting of time and state so that the client does not have to.
    //
    KeEnterCriticalRegion();
    ExAcquireFastMutexUnsafe(&ClockInst->StateMutex);
    KsSetDefaultClockTime(ClockInst->Base.DefaultClock, *Time);
    ExReleaseFastMutexUnsafe(&ClockInst->StateMutex);
    KeLeaveCriticalRegion();
    return STATUS_SUCCESS;
}


NTSTATUS
PropertyClockSetState(
    IN PIRP         Irp,
    IN PKSPROPERTY  Property,
    IN PKSSTATE     State
    )
/*++

Routine Description:

    Handles the Set State property.

Arguments:

    Irp -
        Contains the Set State property IRP.

    Property -
        Contains the property identifier parameter.

    State -
        Contains a pointer to the new state.

Return Value:

    Return STATUS_SUCCESS.

--*/
{
    PINSTANCE   ClockInst;

    ClockInst = (PINSTANCE)IoGetCurrentIrpStackLocation(Irp)->FileObject->FsContext;
    //
    // Serialize setting of time and state so that the client does not have to.
    //
    KeEnterCriticalRegion();
    ExAcquireFastMutexUnsafe(&ClockInst->StateMutex);
    KsSetDefaultClockState(ClockInst->Base.DefaultClock, *State);
    ExReleaseFastMutexUnsafe(&ClockInst->StateMutex);
    KeLeaveCriticalRegion();
    return STATUS_SUCCESS;
}


NTSTATUS
ClockDispatchCreate(
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp
    )
/*++

Routine Description:

    The IRP handler for IRP_MJ_CREATE for the Clock. Initializes data structures
    and associates the IoGetCurrentIrpStackLocation(Irp)->FileObject with this
    clock using a dispatch table (KSDISPATCH_TABLE).

Arguments:

    DeviceObject -
        The device object to which the Clock is attached. This is not used.

    Irp -
        The specific close IRP to be processed.

Return Value:

    Returns STATUS_SUCCESS, else a memory allocation error.

--*/
{
    NTSTATUS            Status;

    //
    // Notify the software bus that this device is in use.
    //
    Status = KsReferenceSoftwareBusObject(((PDEVICE_INSTANCE)DeviceObject->DeviceExtension)->Header);
    if (NT_SUCCESS(Status)) {
        PINSTANCE           ClockInst;

        //
        // The proxy clock just uses a default clock to interpolate between
        // time updates from the client, and to provide notification services.
        //
        if (ClockInst = (PINSTANCE)ExAllocatePoolWithTag(NonPagedPool, sizeof(INSTANCE), 'IFsK')) {
            //
            // Allocate the internal structure and reference count it. This just
            // uses the Default Clock structures, which use the system time to
            // keep time. This proxy then interpolates between settings using the
            // system time.
            //
            if (NT_SUCCESS(Status = KsAllocateDefaultClock(&ClockInst->Base.DefaultClock))) {
                KsAllocateObjectHeader(&ClockInst->Base.Header,
                0,
                NULL,
                Irp,
                (PKSDISPATCH_TABLE)&ClockDispatchTable);
                //
                // This is the lock used to serialize setting state calls and setting
                // time calls, so that a client of this proxy need not worry about
                // serializing calls to this module.
                //
                ExInitializeFastMutex(&ClockInst->StateMutex);
                IoGetCurrentIrpStackLocation(Irp)->FileObject->FsContext = ClockInst;
                Status = STATUS_SUCCESS;
            } else {
                ExFreePool(ClockInst);
            }
        } else {
            Status = STATUS_INSUFFICIENT_RESOURCES;
        }
        if (!NT_SUCCESS(Status)) {
            KsDereferenceSoftwareBusObject(((PDEVICE_INSTANCE)DeviceObject->DeviceExtension)->Header);
        }
    }
    Irp->IoStatus.Status = Status;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);
    return Status;
}


NTSTATUS
ClockDispatchClose(
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp
    )
/*++

Routine Description:

    The IRP handler for IRP_MJ_CLOSE for the Clock. Cleans up the
    event list, and instance data, and cancels notification timer if no longer
    needed.

Arguments:

    DeviceObject -
        The device object to which the Clock is attached. This is not used.

    Irp -
        The specific close IRP to be processed.

Return Value:

    Returns STATUS_SUCCESS.

--*/
{
    PIO_STACK_LOCATION  IrpStack;
    PINSTANCE           ClockInst;

    IrpStack = IoGetCurrentIrpStackLocation(Irp);
    ClockInst = (PINSTANCE)IrpStack->FileObject->FsContext;
    //
    // There are only events based on this FileObject, so free any left enabled,
    // and kill the default clock object.
    //
    KsFreeEventList(
        IrpStack->FileObject,
        &ClockInst->Base.DefaultClock->EventQueue,
        KSEVENTS_SPINLOCK,
        &ClockInst->Base.DefaultClock->EventQueueLock);
    //
    // Dereference the internal structure, which also includes cancelling any
    // outstanding Dpc, and possibly freeing the data.
    //
    KsFreeDefaultClock(ClockInst->Base.DefaultClock);
    KsFreeObjectHeader(ClockInst->Base.Header);
    ExFreePool(ClockInst);
    //
    // Notify the software bus that the device has been closed.
    //
    KsDereferenceSoftwareBusObject(((PDEVICE_INSTANCE)DeviceObject->DeviceExtension)->Header);
    Irp->IoStatus.Status = STATUS_SUCCESS;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);
    return STATUS_SUCCESS;
}


NTSTATUS
ClockDispatchIoControl(
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp
    )
/*++

Routine Description:

    The IRP handler for IRP_MJ_DEVICE_CONTROL for the Clock. Handles
    the properties and events supported by this implementation using the
    default handlers provided by KS.

Arguments:

    DeviceObject -
        The device object to which the Clock is attached. This is not used.

    Irp -
        The specific device control IRP to be processed.

Return Value:

    Returns the status of the processing.

--*/
{
    PIO_STACK_LOCATION  IrpStack;
    NTSTATUS            Status;

    IrpStack = IoGetCurrentIrpStackLocation(Irp);
    switch (IrpStack->Parameters.DeviceIoControl.IoControlCode) {
    case IOCTL_KS_PROPERTY:
        Status = KsPropertyHandler(
            Irp,
            SIZEOF_ARRAY(ClockPropertySets),
            (PKSPROPERTY_SET)ClockPropertySets);
        break;
    case IOCTL_KS_ENABLE_EVENT:
        Status = KsEnableEvent(
            Irp,
            SIZEOF_ARRAY(ClockEventSets),
            (PKSEVENT_SET)ClockEventSets,
            NULL,
            0,
            NULL);
        break;
    case IOCTL_KS_DISABLE_EVENT:
    {
        PINSTANCE       ClockInst;

        ClockInst = (PINSTANCE)IrpStack->FileObject->FsContext;
        Status = KsDisableEvent(
            Irp,
            &ClockInst->Base.DefaultClock->EventQueue,
            KSEVENTS_SPINLOCK,
            &ClockInst->Base.DefaultClock->EventQueueLock);
        break;
    }
    default:
        Status = STATUS_INVALID_DEVICE_REQUEST;
        break;
    }
    Irp->IoStatus.Status = Status;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);
    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\ksfilter\mspclock\mspclock.h ===
/*++

Copyright (C) Microsoft Corporation, 1996 - 1997

Module Name:

	mspclock.h

Abstract:

	Internal header file for filter.

--*/

#include <wdm.h>
#include <windef.h>

#include <memory.h>
#include <stddef.h>
#include <stdio.h>
#include <limits.h>
#include <stdlib.h>
#include <tchar.h>
#include <conio.h>

#include <ks.h>
#include <swenum.h>
#include <ksi.h>

#if (DBG)
#define STR_MODULENAME  "mspclock: "
#endif // DBG

NTSTATUS
PnpAddDevice(
    IN PDRIVER_OBJECT   DriverObject,
    IN PDEVICE_OBJECT   PhysicalDeviceObject
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\ksfilter\mspclock\sources.inc ===
!IF 0

Copyright (C) Microsoft Corporation, 1996 - 1999

Module Name:

    sources.

!ENDIF

MAJORCOMP=ntos
MINORCOMP=dd

TARGETNAME=mspclock
TARGETPATH=obj
TARGETTYPE=DRIVER
TARGETLIBS=$(DDK_LIB_PATH)\ks.lib\
    $(DDK_LIB_PATH)\ksguid.lib

DRIVERTYPE=WDM

MSC_WARNING_LEVEL=/W3 /WX
C_DEFINES=$(C_DEFINES) -D_WIN32 -DUNICODE -D_UNICODE -DDEBUG_LEVEL=DEBUGLVL_BLAB

VC40_HACK=1
LINKER_FLAGS =$(LINKER_FLAGS) -map -merge:.rdata=PAGE -merge:PAGECONST=PAGE

SOURCES=\
        $(TARGETNAME).rc \
        $(TARGETNAME).c \
        device.c
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\ksfilter\mspqm\sources.inc ===
!IF 0

Copyright (C) Microsoft Corporation, 1997 - 1999

Module Name:

    sources.

!ENDIF

MAJORCOMP=ntos
MINORCOMP=dd

TARGETNAME=mspqm
TARGETPATH=obj
TARGETTYPE=DRIVER
TARGETLIBS=$(DDK_LIB_PATH)\ks.lib\
    $(DDK_LIB_PATH)\ksguid.lib

DRIVERTYPE=WDM

MSC_WARNING_LEVEL=/W3 /WX
C_DEFINES=$(C_DEFINES) -D_WIN32 -DUNICODE -D_UNICODE -DDEBUG_LEVEL=DEBUGLVL_BLAB

VC40_HACK=1
LINKER_FLAGS =$(LINKER_FLAGS) -map -merge:.rdata=PAGE -merge:PAGECONST=PAGE

SOURCES=\
        $(TARGETNAME).rc \
        $(TARGETNAME).c \
        device.c
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\ksfilter\mspqm\mspqm.h ===
/*++

Copyright (C) Microsoft Corporation, 1996 - 1997

Module Name:

	mspqm.h

Abstract:

	Internal header file for device.

--*/

#include <wdm.h>
#include <windef.h>

#include <memory.h>
#include <stddef.h>
#include <stdio.h>
#include <limits.h>
#include <stdlib.h>
#include <tchar.h>
#include <conio.h>

#include <ks.h>
#include <swenum.h>

#if (DBG)
#define STR_MODULENAME  "mspqm: "
#endif // DBG

NTSTATUS
PnpAddDevice(
    IN PDRIVER_OBJECT   DriverObject,
    IN PDEVICE_OBJECT   PhysicalDeviceObject
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\ksfilter\mspqm\mspqm.c ===
/*++

Copyright (C) Microsoft Corporation, 1996 - 1999

Module Name:

    mspqm.c

Abstract:

    Kernel proxy for Quality Manager.

--*/

#include "mspqm.h"

#ifdef WIN98GOLD
#define KeEnterCriticalRegion()
#define KeLeaveCriticalRegion()
#endif

typedef struct {
    KSDEVICE_HEADER     Header;
} DEVICE_INSTANCE, *PDEVICE_INSTANCE;

typedef struct {
    LIST_ENTRY  Queue;
    KSQUALITY   Quality;
} QUALITYITEM, *PQUALITYITEM;

typedef struct {
    LIST_ENTRY  Queue;
    KSERROR     Error;
} ERRORITEM, *PERRORITEM;

#define QUALITYREPORT 0
#define ERRORREPORT 1
#define REPORTTYPES 2

typedef struct {
    KSOBJECT_HEADER     Header;
    KSPIN_LOCK          ClientReportLock[REPORTTYPES];
    LIST_ENTRY          ClientReportQueue[REPORTTYPES];
    FAST_MUTEX          Mutex[REPORTTYPES];
    LIST_ENTRY          Queue[REPORTTYPES];
    ULONG               QueueLimit[REPORTTYPES];
} INSTANCE, *PINSTANCE;

//
// Limit the number of items which can stack up on the complaint/error
// queue in case the client stops processing complaints/errors.
//
#define QUEUE_LIMIT     256

//
// Represents the location at which a pointer to a quality complaint/error
// is temporarily stored when completing an old client Irp with a
// new complaint/error.
//
#define REPORT_IRP_STORAGE(Irp) (Irp)->Tail.Overlay.DriverContext[3]

NTSTATUS
PropertyGetReportComplete(
    IN PIRP Irp,
    IN PKSPROPERTY Property,
    OUT PVOID Report
    );
NTSTATUS
PropertySetReport(
    IN PIRP Irp,
    IN PKSPROPERTY Property,
    IN PVOID Report
    );
NTSTATUS
PropertyGetReport(
    IN PIRP Irp,
    IN PKSPROPERTY Property,
    OUT PVOID Report
    );
NTSTATUS
QualityDispatchCreate(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );
NTSTATUS
QualityDispatchIoControl(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );
NTSTATUS
QualityDispatchClose(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, PnpAddDevice)
#pragma alloc_text(PAGE, PropertyGetReportComplete)
#pragma alloc_text(PAGE, PropertySetReport)
#pragma alloc_text(PAGE, PropertyGetReport)
#pragma alloc_text(PAGE, QualityDispatchCreate)
#pragma alloc_text(PAGE, QualityDispatchClose)
#pragma alloc_text(PAGE, QualityDispatchIoControl)
#endif // ALLOC_PRAGMA

static const WCHAR DeviceTypeName[] = L"{97EBAACB-95BD-11D0-A3EA-00A0C9223196}";

static const DEFINE_KSCREATE_DISPATCH_TABLE(CreateItems) {
    DEFINE_KSCREATE_ITEM(QualityDispatchCreate, DeviceTypeName, 0)
};

static DEFINE_KSDISPATCH_TABLE(
    QualityDispatchTable,
    QualityDispatchIoControl,
    NULL,
    NULL,
    NULL,
    QualityDispatchClose,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL);

DEFINE_KSPROPERTY_TABLE(QualityPropertyItems) {
    DEFINE_KSPROPERTY_ITEM_QUALITY_REPORT(PropertyGetReport, PropertySetReport),
    DEFINE_KSPROPERTY_ITEM_QUALITY_ERROR(PropertyGetReport, PropertySetReport)
};

DEFINE_KSPROPERTY_SET_TABLE(QualityPropertySets) {
    DEFINE_KSPROPERTY_SET(
        &KSPROPSETID_Quality,
        SIZEOF_ARRAY(QualityPropertyItems),
        QualityPropertyItems,
        0, NULL
    )
};


NTSTATUS
PnpAddDevice(
    IN PDRIVER_OBJECT DriverObject,
    IN PDEVICE_OBJECT PhysicalDeviceObject
    )
/*++

Routine Description:

    When a new device is detected, PnP calls this entry point with the
    new PhysicalDeviceObject (PDO). The driver creates an associated 
    FunctionalDeviceObject (FDO).

Arguments:

    DriverObject -
        Pointer to the driver object.

    PhysicalDeviceObject -
        Pointer to the new physical device object.

Return Values:

    STATUS_SUCCESS or an appropriate error condition.

--*/
{
    PDEVICE_OBJECT      FunctionalDeviceObject;
    PDEVICE_INSTANCE    DeviceInstance;
    NTSTATUS            Status;

    Status = IoCreateDevice(
        DriverObject,
        sizeof(*DeviceInstance),
        NULL,
        FILE_DEVICE_KS,
        0,
        FALSE,
        &FunctionalDeviceObject);
    if (!NT_SUCCESS(Status)) {
        return Status;
    }
    DeviceInstance = (PDEVICE_INSTANCE)FunctionalDeviceObject->DeviceExtension;
    //
    // This object uses KS to perform access through the DeviceCreateItems.
    //
    Status = KsAllocateDeviceHeader(
        &DeviceInstance->Header,
        SIZEOF_ARRAY(CreateItems),
        (PKSOBJECT_CREATE_ITEM)CreateItems);
    if (NT_SUCCESS(Status)) {
        KsSetDevicePnpAndBaseObject(
            DeviceInstance->Header,
            IoAttachDeviceToDeviceStack(
                FunctionalDeviceObject, 
                PhysicalDeviceObject),
            FunctionalDeviceObject);
        FunctionalDeviceObject->Flags |= DO_POWER_PAGABLE;
        FunctionalDeviceObject->Flags &= ~DO_DEVICE_INITIALIZING;
        return STATUS_SUCCESS;
    }
    IoDeleteDevice(FunctionalDeviceObject);
    return Status;
}


NTSTATUS
PropertyGetReportComplete(
    IN PIRP Irp,
    IN PKSPROPERTY Property,
    OUT PVOID Report
    )
/*++

Routine Description:

    Completes the Get Report property after it has been previously
    queued. Assumes that REPORT_IRP_STORAGE(Irp) points to a new quality/error
    complaint report to copy to the client's buffer.

Arguments:

    Irp -
        Contains the Get Report property IRP.

    Property -
        Contains the property identifier parameter.

    Report -
        Contains a pointer in which to put the client report.

Return Value:

    Return STATUS_SUCCESS.

--*/
{
    switch (Property->Id) {
    case KSPROPERTY_QUALITY_REPORT:
        //
        // Assumes that the QUALITY_IRP_STORAGE(Irp) has been filled in with
        // a pointer to a quality complaint.
        //
        *(PKSQUALITY)Report = *(PKSQUALITY)REPORT_IRP_STORAGE(Irp);
        Irp->IoStatus.Information = sizeof(KSQUALITY);
        break;
    case KSPROPERTY_QUALITY_ERROR:
        //
        // Assumes that the ERROR_IRP_STORAGE(Irp) has been filled in with
        // a pointer to a quality complaint.
        //
        *(PKSERROR)Report = *(PKSERROR)REPORT_IRP_STORAGE(Irp);
        Irp->IoStatus.Information = sizeof(KSERROR);
        break;
    }
    Irp->IoStatus.Status = STATUS_SUCCESS;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);
    return STATUS_SUCCESS;
}


NTSTATUS
PropertySetReport(
    IN PIRP Irp,
    IN PKSPROPERTY Property,
    IN PVOID Report
    )
/*++

Routine Description:

    Handles the Set Report property

Arguments:

    Irp -
        Contains the Set Quality/Error Report property IRP.

    Property -
        Contains the property identifier parameter.

    Report -
        Contains a pointer to the quality/error report.

Return Value:

    Return STATUS_SUCCESS if the report was made, else an error.

--*/
{
    PINSTANCE       QualityInst;
    ULONG           ReportType;

    //
    // There are only two types of reports at this time.
    //
    ASSERT((Property->Id == KSPROPERTY_QUALITY_REPORT) || (Property->Id == KSPROPERTY_QUALITY_ERROR));
    ReportType = (Property->Id == KSPROPERTY_QUALITY_REPORT) ? QUALITYREPORT : ERRORREPORT;
    QualityInst = (PINSTANCE)IoGetCurrentIrpStackLocation(Irp)->FileObject->FsContext;
    //
    // Acquire the list lock for the queue before checking the Irp queue.
    // This allows synchronization with placing Irp's on the queue so that
    // all complaints will be serviced if there is a client Irp on the
    // queue.
    //
    KeEnterCriticalRegion();
    ExAcquireFastMutexUnsafe(&QualityInst->Mutex[ReportType]);
    //
    // Check to see if there is a pending client Irp which can be completed
    // with this quality complaint. If so, remove it from the list.
    // 
    Irp = KsRemoveIrpFromCancelableQueue(
        &QualityInst->ClientReportQueue[ReportType],
        &QualityInst->ClientReportLock[ReportType],
        KsListEntryHead,
        KsAcquireAndRemove);
    ExReleaseFastMutexUnsafe(&QualityInst->Mutex[ReportType]);
    KeLeaveCriticalRegion();
    if (Irp) {
        //
        // Complete this old Irp with the new quality/error complaint information.
        //
        REPORT_IRP_STORAGE(Irp) = Report;
        return KsDispatchSpecificProperty(Irp, PropertyGetReportComplete);
    }
    //
    // Acquire the list lock before adding the item to the end of the
    // list.
    //
    KeEnterCriticalRegion();
    ExAcquireFastMutexUnsafe(&QualityInst->Mutex[ReportType]);
    //
    // If the client has just let things build up, then make sure the list
    // length is limited so as to not use up infinite resources.
    //
    if (QualityInst->QueueLimit[ReportType] == QUEUE_LIMIT) {
        ExReleaseFastMutexUnsafe(&QualityInst->Mutex[ReportType]);
        KeLeaveCriticalRegion();
        return STATUS_INSUFFICIENT_RESOURCES;
    }
    //
    // The bad case is wherein the client is behind in queuing Irp's to
    // cover the number of quality complaints. In this case allocate a list
    // item and make a copy of the complaint. This will be retrieved on
    // receiving a new client Irp.
    //
    switch (ReportType) {
        PQUALITYITEM    QualityItem;
        PERRORITEM      ErrorItem;

    case QUALITYREPORT:
        if (!(QualityItem = 
                ExAllocatePoolWithTag( PagedPool, sizeof(*QualityItem), 'rqSK' ))) {
            return STATUS_INSUFFICIENT_RESOURCES;
        }
        QualityItem->Quality = *(PKSQUALITY)Report;
        InsertTailList(&QualityInst->Queue[QUALITYREPORT], &QualityItem->Queue);
        break;
    case ERRORREPORT:
        if (!(ErrorItem = 
                ExAllocatePoolWithTag( PagedPool, sizeof(*ErrorItem), 'reSK' ))) {
            return STATUS_INSUFFICIENT_RESOURCES;
        }
        ErrorItem->Error = *(PKSERROR)Report;
        InsertTailList(&QualityInst->Queue[ERRORREPORT], &ErrorItem->Queue);
        break;
    }
    QualityInst->QueueLimit[ReportType]++;
    ExReleaseFastMutexUnsafe(&QualityInst->Mutex[ReportType]);
    KeLeaveCriticalRegion();
    return STATUS_SUCCESS;
}


NTSTATUS
PropertyGetReport(
    IN PIRP Irp,
    IN PKSPROPERTY Property,
    OUT PVOID Report
    )
/*++

Routine Description:

    Handles the Get Report property. If there are no outstanding complaints,
    queues the request so that it may be used to fulfill a later quality
    management complaint.

Arguments:

    Irp -
        Contains the Get Quality Report property IRP to complete or queue.

    Property -
        Contains the property identifier parameter.

    Report -
        Contains a pointer to the quality/error report.

Return Value:

    Return STATUS_SUCCESS if a report was immediately returned, else
    STATUS_PENDING.

--*/
{
    PINSTANCE       QualityInst;
    ULONG           ReportType;

    //
    // There are only two types of reports at this time.
    //
    ASSERT((Property->Id == KSPROPERTY_QUALITY_REPORT) || (Property->Id == KSPROPERTY_QUALITY_ERROR));
    ReportType = (Property->Id == KSPROPERTY_QUALITY_REPORT) ? QUALITYREPORT : ERRORREPORT;
    QualityInst = (PINSTANCE)IoGetCurrentIrpStackLocation(Irp)->FileObject->FsContext;
    //
    // Acquire the list lock before checking to determine if there are any
    // outstanding items on the list which can be serviced with this Irp.
    //
    KeEnterCriticalRegion();
    ExAcquireFastMutexUnsafe(&QualityInst->Mutex[ReportType]);
    if (!IsListEmpty(&QualityInst->Queue[ReportType])) {
        PLIST_ENTRY     ListEntry;

        //
        // The client is behind, and needs to grab the top item from the
        // list of complaints. They are serviced in FIFO order, since a
        // new complaint may supercede an old one.
        //
        ListEntry = RemoveHeadList(&QualityInst->Queue[ReportType]);
        //
        // Adjust the number of items on the queue which is used to limit
        // outstanding items so they won't build up forever.
        //
        QualityInst->QueueLimit[ReportType]--;
        ExReleaseFastMutexUnsafe(&QualityInst->Mutex[ReportType]);
        KeLeaveCriticalRegion();
        switch (ReportType) {
            PQUALITYITEM    QualityItem;
            PERRORITEM      ErrorItem;

        case QUALITYREPORT:
            QualityItem = (PQUALITYITEM)CONTAINING_RECORD(ListEntry, QUALITYITEM, Queue);
            *(PKSQUALITY)Report = QualityItem->Quality;
            //
            // All quality complaints on the queue have been previously allocated
            // from a pool, and must be freed here.
            //
            ExFreePool(QualityItem);
            Irp->IoStatus.Information = sizeof(KSQUALITY);
            break;
        case ERRORREPORT:
            ErrorItem = (PERRORITEM)CONTAINING_RECORD(ListEntry, ERRORITEM, Queue);
            *(PKSERROR)Report = ErrorItem->Error;
            //
            // All error complaints on the queue have been previously allocated
            // from a pool, and must be freed here.
            //
            ExFreePool(ErrorItem);
            Irp->IoStatus.Information = sizeof(KSERROR);
            break;
        }
        return STATUS_SUCCESS;
    }
    //
    // Else just add the client Irp to the queue which can be used to
    // immediately service any new quality complaints.
    //
    KsAddIrpToCancelableQueue(&QualityInst->ClientReportQueue[ReportType],
        &QualityInst->ClientReportLock[ReportType],
        Irp,
        KsListEntryTail,
        NULL);
    //
    // The list lock must be released after adding the Irp to the list
    // so that complaints looking for an Irp can synchronize with any
    // new Irp being placed on the list.
    //
    ExReleaseFastMutexUnsafe(&QualityInst->Mutex[ReportType]);
    KeLeaveCriticalRegion();
    return STATUS_PENDING;
}


NTSTATUS
QualityDispatchCreate(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++

Routine Description:

    The IRP handler for IRP_MJ_CREATE for the Quality Manager. Initializes data
    structures and associates the IoGetCurrentIrpStackLocation(Irp)->FileObject
    with this Quality Manager using a dispatch table (KSDISPATCH_TABLE).

Arguments:

    DeviceObject -
        The device object to which the Quality Manager is attached. This is not
        used.

    Irp -
        The specific close IRP to be processed.

Return Value:

    Returns STATUS_SUCCESS, else a memory allocation error.

--*/
{
    NTSTATUS            Status;

    //
    // Notify the software bus that this device is in use.
    //
    Status = KsReferenceSoftwareBusObject(((PDEVICE_INSTANCE)DeviceObject->DeviceExtension)->Header);
    if (NT_SUCCESS(Status)) {
        PINSTANCE           QualityInst;

        if (QualityInst = (PINSTANCE)ExAllocatePoolWithTag(NonPagedPool, sizeof(*QualityInst), 'IFsK')) {
            //
            // Allocate the header structure.
            //
            if (NT_SUCCESS(Status = KsAllocateObjectHeader(&QualityInst->Header,
                0,
                NULL,
                Irp,
                (PKSDISPATCH_TABLE)&QualityDispatchTable))) {
                ULONG   ReportType;

                for (ReportType = 0; ReportType < REPORTTYPES; ReportType++) {
                    KeInitializeSpinLock(&QualityInst->ClientReportLock[ReportType]);
                    InitializeListHead(&QualityInst->ClientReportQueue[ReportType]);
                    ExInitializeFastMutex(&QualityInst->Mutex[ReportType]);
                    InitializeListHead(&QualityInst->Queue[ReportType]);
                    QualityInst->QueueLimit[ReportType] = 0;
                }
                IoGetCurrentIrpStackLocation(Irp)->FileObject->FsContext = QualityInst;
                Status = STATUS_SUCCESS;
            } else {
                ExFreePool(QualityInst);
            }
        } else {
            Status = STATUS_INSUFFICIENT_RESOURCES;
        }
        if (!NT_SUCCESS(Status)) {
            KsDereferenceSoftwareBusObject(((PDEVICE_INSTANCE)DeviceObject->DeviceExtension)->Header);
        }
    }
    Irp->IoStatus.Status = Status;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);
    return Status;
}


NTSTATUS
QualityDispatchClose(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++

Routine Description:

    The IRP handler for IRP_MJ_CLOSE for the Quality Manager.

Arguments:

    DeviceObject -
        The device object to which the Quality Manager is attached. This is
        not used.

    Irp -
        The specific close IRP to be processed.

Return Value:

    Returns STATUS_SUCCESS.

--*/
{
    PIO_STACK_LOCATION  IrpStack;
    PINSTANCE           QualityInst;
    ULONG               ReportType;

    IrpStack = IoGetCurrentIrpStackLocation(Irp);
    QualityInst = (PINSTANCE)IrpStack->FileObject->FsContext;
    for (ReportType = 0; ReportType < REPORTTYPES; ReportType++) {
        //
        // There may be client Irp's on the queue still that need to be
        // cancelled.
        //
        KsCancelIo(&QualityInst->ClientReportQueue[ReportType], &QualityInst->ClientReportLock[ReportType]);
        //
        // Or there may be old quality complaints still outstanding.
        //
        while (!IsListEmpty(&QualityInst->Queue[ReportType])) {
            PLIST_ENTRY     ListEntry;

            ListEntry = RemoveHeadList(&QualityInst->Queue[ReportType]);
            switch (ReportType) {
                PQUALITYITEM    QualityItem;
                PERRORITEM      ErrorItem;

            case QUALITYREPORT:
                QualityItem = (PQUALITYITEM)CONTAINING_RECORD(ListEntry, QUALITYITEM, Queue);
                ExFreePool(QualityItem);
                break;
            case ERRORREPORT:
                ErrorItem = (PERRORITEM)CONTAINING_RECORD(ListEntry, ERRORITEM, Queue);
                ExFreePool(ErrorItem);
                break;
            }
        }
    }
    //
    // The header was allocated when the object was created.
    //
    KsFreeObjectHeader(QualityInst->Header);
    //
    // As was the FsContext.
    //
    ExFreePool(QualityInst);
    //
    // Notify the software bus that the device has been closed.
    //
    KsDereferenceSoftwareBusObject(((PDEVICE_INSTANCE)DeviceObject->DeviceExtension)->Header);
    Irp->IoStatus.Status = STATUS_SUCCESS;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);
    return STATUS_SUCCESS;
}


NTSTATUS
QualityDispatchIoControl(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++

Routine Description:

    The IRP handler for IRP_MJ_DEVICE_CONTROL for the Quality Manager. Handles
    the properties and events supported by this implementation.

Arguments:

    DeviceObject -
        The device object to which the Quality Manager is attached. This is not
        used.

    Irp -
        The specific device control IRP to be processed.

Return Value:

    Returns the status of the processing.

--*/
{
    PIO_STACK_LOCATION  IrpStack;
    NTSTATUS            Status;

    IrpStack = IoGetCurrentIrpStackLocation(Irp);
    switch (IrpStack->Parameters.DeviceIoControl.IoControlCode) {
    case IOCTL_KS_PROPERTY:
        Status = KsPropertyHandler(Irp,
            SIZEOF_ARRAY(QualityPropertySets),
            (PKSPROPERTY_SET)QualityPropertySets);
        break;
    default:
        Status = STATUS_INVALID_DEVICE_REQUEST;
        break;
    }
    //
    // A client Irp may be queued if there are no quality complaints in
    // the list to service.
    //
    if (Status != STATUS_PENDING) {
        Irp->IoStatus.Status = Status;
        IoCompleteRequest(Irp, IO_NO_INCREMENT);
    }
    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\ksfilter\mspqm\device.c ===
/*++

Copyright (C) Microsoft Corporation, 1996 - 1998

Module Name:

    device.c

Abstract:

    Device entry point and hardware validation.

--*/

#include "mspqm.h"

#ifdef ALLOC_PRAGMA
NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT   DriverObject,
    IN PUNICODE_STRING  RegistryPathName
    );

#pragma alloc_text(INIT, DriverEntry)
#endif // ALLOC_PRAGMA


NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT   DriverObject,
    IN PUNICODE_STRING  RegistryPathName
    )
/*++

Routine Description:

    Sets up the driver object to handle the KS interface and PnP Add Device
    request. Does not set up a handler for PnP Irp's, as they are all dealt
    with directly by the PDO.

Arguments:

    DriverObject -
        Driver object for this instance.

    RegistryPathName -
        Contains the registry path which was used to load this instance.

Return Values:

    Returns STATUS_SUCCESS.

--*/
{
    DriverObject->MajorFunction[IRP_MJ_PNP] = KsDefaultDispatchPnp;
    DriverObject->MajorFunction[IRP_MJ_POWER] = KsDefaultDispatchPower;
    DriverObject->MajorFunction[IRP_MJ_SYSTEM_CONTROL] = KsDefaultForwardIrp;
    DriverObject->DriverExtension->AddDevice = PnpAddDevice;
    DriverObject->DriverUnload = KsNullDriverUnload;
    KsSetMajorFunctionHandler(DriverObject, IRP_MJ_CREATE);
    KsSetMajorFunctionHandler(DriverObject, IRP_MJ_CLOSE);
    KsSetMajorFunctionHandler(DriverObject, IRP_MJ_DEVICE_CONTROL);
    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\ksfilter\msriffwv\msriffwv.c ===
/*++

Copyright (C) Microsoft Corporation, 1996 - 1998

Module Name:

    msriffwv.c

Abstract:

    Pin property support.

--*/

#include "msriffwv.h"

#define riffWAVE    mmioFOURCC('W','A','V','E')
#define riffFMT     mmioFOURCC('f','m','t',' ')
#define riffDATA    mmioFOURCC('d','a','t','a')

#ifdef ALLOC_PRAGMA
NTSTATUS
riffRead(
    IN PFILE_OBJECT     FileObject,
    IN PVOID            Buffer,
    IN ULONG            BufferSize
    );
NTSTATUS
riffGetExtent(
    IN PFILE_OBJECT     FileObject,
    OUT PULONGLONG      Extent
    );
NTSTATUS
riffGetPosition(
    IN PFILE_OBJECT     FileObject,
    OUT PULONGLONG      Position
    );
NTSTATUS
riffDescend(
    IN PFILE_OBJECT     FileObject,
    IN OUT LPMMCKINFO   MmckInfo,
    IN const MMCKINFO*  MmckInfoParent,
    IN ULONG            DescendFlags
    );
NTSTATUS
riffAscend(
    IN PFILE_OBJECT     FileObject,
    IN LPMMCKINFO       MmckInfo
    );
NTSTATUS
riffReadWaveFormat(
    IN PFILE_OBJECT                 FileObject,
    OUT PKSDATAFORMAT_WAVEFORMATEX* WaveFormat,
    OUT ULONGLONG*                  DataOffset,
    OUT ULONGLONG*                  DataLength
    );
NTSTATUS
InitializeRiffIoPin(
    IN PIRP             Irp,
    IN PKSPIN_CONNECT   Connect
    );
NTSTATUS
InitializeWaveIoPin(
    IN PIRP             Irp,
    IN PKSDATAFORMAT    DataFormat
    );
NTSTATUS
PinDispatchClose(
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp
    );
NTSTATUS
ReadStream(
    IN PIRP     Irp
    );
NTSTATUS
PinWaveDispatchIoControl(
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp
    );
NTSTATUS
PinRiffDispatchIoControl(
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp
    );
NTSTATUS
GetTimeFormat(
    IN PIRP Irp,
    IN PKSPROPERTY Property,
    OUT GUID* TimeFormat
    );
NTSTATUS
GetPresentationTime(
    IN PIRP         Irp,
    IN PKSPROPERTY  Property,
    OUT PKSTIME     PresentationTime
    );
NTSTATUS
SetPresentationTime(
    IN PIRP         Irp,
    IN PKSPROPERTY  Property,
    IN PKSTIME      PresentationTime
    );
NTSTATUS
GetPresentationExtent(
    IN PIRP         Irp,
    IN PKSPROPERTY  Property,
    OUT PULONGLONG  PresentationExtent
    );
NTSTATUS
SetState(
    IN PIRP         Irp,
    IN PKSPROPERTY  Property,
    IN PKSSTATE     State
    );
NTSTATUS
GetAcquireOrdering(
    IN PIRP         Irp,
    IN PKSPROPERTY  Property,
    OUT BOOL*       AcquireOrdering
    );
NTSTATUS 
GetAllocatorFraming(
    IN PIRP                     Irp,
    IN PKSPROPERTY              Property,
    OUT PKSALLOCATOR_FRAMING    Framing
    );
NTSTATUS 
SetStreamAllocator(
    IN PIRP Irp,
    IN PKSPROPERTY Property,
    IN PHANDLE AllocatorHandle
    );

#pragma alloc_text(PAGE, riffRead)
#pragma alloc_text(PAGE, riffGetExtent)
#pragma alloc_text(PAGE, riffGetPosition)
#pragma alloc_text(PAGE, riffSetPosition)
#pragma alloc_text(PAGE, riffDescend)
#pragma alloc_text(PAGE, riffAscend)
#pragma alloc_text(PAGE, riffReadWaveFormat)
#pragma alloc_text(PAGE, InitializeRiffIoPin)
#pragma alloc_text(PAGE, InitializeWaveIoPin)
#pragma alloc_text(PAGE, PinDispatchCreate)
#pragma alloc_text(PAGE, PinDispatchClose)
#pragma alloc_text(PAGE, ReferenceRiffIoObject)
#pragma alloc_text(PAGE, ReadStream)
#pragma alloc_text(PAGE, PinWaveDispatchIoControl)
#pragma alloc_text(PAGE, PinRiffDispatchIoControl)
#pragma alloc_text(PAGE, GetTimeFormat)
#pragma alloc_text(PAGE, GetPresentationTime)
#pragma alloc_text(PAGE, SetPresentationTime)
#pragma alloc_text(PAGE, GetPresentationExtent)
#pragma alloc_text(PAGE, SetState)
#pragma alloc_text(PAGE, GetAcquireOrdering)
#pragma alloc_text(PAGE, GetAllocatorFraming)
#pragma alloc_text(PAGE, SetStreamAllocator)
#endif // ALLOC_PRAGMA

#ifdef ALLOC_DATA_PRAGMA
#pragma const_seg("PAGECONST")
#endif // ALLOC_DATA_PRAGMA
static DEFINE_KSDISPATCH_TABLE(
    PinWaveIoDispatchTable,
    PinWaveDispatchIoControl,
    NULL,
    NULL,
    NULL,
    PinDispatchClose,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL);

static DEFINE_KSDISPATCH_TABLE(
    PinRiffIoDispatchTable,
    PinRiffDispatchIoControl,
    NULL,
    NULL,
    NULL,
    PinDispatchClose,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL);

DEFINE_KSPROPERTY_TABLE(WaveIoStreamProperties) {
    DEFINE_KSPROPERTY_ITEM_STREAM_PRESENTATIONTIME(GetPresentationTime, SetPresentationTime),
    DEFINE_KSPROPERTY_ITEM_STREAM_PRESENTATIONEXTENT(GetPresentationExtent)
};

DEFINE_KSPROPERTY_TABLE(WaveIoConnectionProperties) {
    DEFINE_KSPROPERTY_ITEM_CONNECTION_STATE(NULL, SetState),
    DEFINE_KSPROPERTY_ITEM_CONNECTION_ACQUIREORDERING(GetAcquireOrdering)
};

DEFINE_KSPROPERTY_SET_TABLE(WaveIoPropertySets) {
    DEFINE_KSPROPERTY_SET(
        &KSPROPSETID_Stream,
        SIZEOF_ARRAY(WaveIoStreamProperties),
        WaveIoStreamProperties,
        0,
        NULL),
    DEFINE_KSPROPERTY_SET(
        &KSPROPSETID_Connection,
        SIZEOF_ARRAY(WaveIoConnectionProperties),
        WaveIoConnectionProperties,
        0,
        NULL)
};

DEFINE_KSPROPERTY_TABLE(RiffIoStreamProperties) {
    DEFINE_KSPROPERTY_ITEM_STREAM_TIMEFORMAT(GetTimeFormat),
    DEFINE_KSPROPERTY_ITEM_STREAM_ALLOCATOR(NULL, SetStreamAllocator)
};

DEFINE_KSPROPERTY_TABLE(RiffIoConnectionProperties) {
    DEFINE_KSPROPERTY_ITEM_CONNECTION_ALLOCATORFRAMING(GetAllocatorFraming)
};

DEFINE_KSPROPERTY_SET_TABLE(RiffIoPropertySets) {
    DEFINE_KSPROPERTY_SET(
        &KSPROPSETID_Stream,
        SIZEOF_ARRAY(RiffIoStreamProperties),
        RiffIoStreamProperties,
        0,
        NULL),
    DEFINE_KSPROPERTY_SET(
        &KSPROPSETID_Connection,
        SIZEOF_ARRAY(RiffIoConnectionProperties),
        RiffIoConnectionProperties,
        0,
        NULL)
};
#ifdef ALLOC_DATA_PRAGMA
#pragma const_seg()
#endif // ALLOC_DATA_PRAGMA


NTSTATUS
riffRead(
    IN PFILE_OBJECT FileObject,
    IN PVOID Buffer,
    IN ULONG BufferSize
    )
{
    NTSTATUS        Status;
    KSMETHOD        Method;
    ULONG           BytesReturned;

    Method.Set = KSMETHODSETID_StreamIo;
    Method.Id = KSMETHOD_STREAMIO_READ;
    Method.Flags = KSMETHOD_TYPE_SEND;
    Status = KsSynchronousIoControlDevice(
        FileObject,
        KernelMode,
        IOCTL_KS_METHOD,
        &Method,
        sizeof(Method),
        Buffer,
        BufferSize,
        &BytesReturned);
    if (NT_SUCCESS(Status) && (BytesReturned < BufferSize)) {
        Status = STATUS_END_OF_FILE;
    }
    return Status;
}


NTSTATUS
riffGetExtent(
    IN PFILE_OBJECT FileObject,
    OUT PULONGLONG Extent
    )
{
    KSPROPERTY      Property;
    ULONG           BytesReturned;

    Property.Set = KSPROPSETID_Stream;
    Property.Id = KSPROPERTY_STREAM_PRESENTATIONEXTENT;
    Property.Flags = KSPROPERTY_TYPE_GET;
    return KsSynchronousIoControlDevice(
        FileObject,
        KernelMode,
        IOCTL_KS_PROPERTY,
        &Property,
        sizeof(Property),
        Extent,
        sizeof(*Extent),
        &BytesReturned);
}


NTSTATUS
riffGetPosition(
    IN PFILE_OBJECT     FileObject,
    OUT PULONGLONG      Position
    )
{
    NTSTATUS        Status;
    KSPROPERTY      Property;
    ULONG           BytesReturned;
    KSTIME          Time;

    Property.Set = KSPROPSETID_Stream;
    Property.Id = KSPROPERTY_STREAM_PRESENTATIONTIME;
    Property.Flags = KSPROPERTY_TYPE_GET;
    Status = KsSynchronousIoControlDevice(
        FileObject,
        KernelMode,
        IOCTL_KS_PROPERTY,
        &Property,
        sizeof(Property),
        &Time,
        sizeof(Time),
        &BytesReturned);
    *Position = Time.Time;
    return Status;
}


NTSTATUS
riffSetPosition(
    IN PFILE_OBJECT     FileObject,
    IN ULONGLONG        Position
    )
{
    KSPROPERTY      Property;
    ULONG           BytesReturned;
    KSTIME          Time;

    Property.Set = KSPROPSETID_Stream;
    Property.Id = KSPROPERTY_STREAM_PRESENTATIONTIME;
    Property.Flags = KSPROPERTY_TYPE_SET;
    Time.Time = Position;
    Time.Numerator = 1;
    Time.Denominator = 1;
    return KsSynchronousIoControlDevice(
        FileObject,
        KernelMode,
        IOCTL_KS_PROPERTY,
        &Property,
        sizeof(Property),
        &Time,
        sizeof(Time),
        &BytesReturned);
}


NTSTATUS
riffDescend(
    IN PFILE_OBJECT     FileObject,
    IN OUT LPMMCKINFO   MmckInfo,
    IN const MMCKINFO*  MmckInfoParent,
    IN ULONG            DescendFlags
    )
{
    FOURCC          ckidFind;
    FOURCC          fccTypeFind;

    if (DescendFlags & MMIO_FINDCHUNK) {
        ckidFind = MmckInfo->ckid, fccTypeFind = 0;
    } else if (DescendFlags & MMIO_FINDRIFF) {
        ckidFind = FOURCC_RIFF, fccTypeFind = MmckInfo->fccType;
    } else if (DescendFlags & MMIO_FINDLIST) {
        ckidFind = FOURCC_LIST, fccTypeFind = MmckInfo->fccType;
    } else {
        ckidFind = fccTypeFind = 0;
    }
    MmckInfo->dwFlags = 0;
    while (TRUE) {
        NTSTATUS        Status;
        ULONGLONG       Position;

        //
        // Read the chunk header.
        //
        Status = riffRead(FileObject, MmckInfo, sizeof(FOURCC) + sizeof(DWORD));
        if (!NT_SUCCESS(Status)) {
            return Status;
        }
        //
        // Store the offset of the data part of the chunk.
        //
        Status = riffGetPosition(FileObject, &Position);
        if (!NT_SUCCESS(Status)) {
            return Status;
        }
        if (Position > (ULONG)-1) {
            return STATUS_DATA_NOT_ACCEPTED;
        }
        MmckInfo->dwDataOffset = (ULONG)Position;
        //
        // Check for unreasonable chunk size. See if the chunk is within
        // the parent chunk (if given).
        //
        if ((LONG)MmckInfo->cksize < 0) {
            return STATUS_DATA_NOT_ACCEPTED;
        }
        if ((MmckInfoParent != NULL) && ((MmckInfo->dwDataOffset - 8) >= (MmckInfoParent->dwDataOffset + MmckInfoParent->cksize))) {
            return STATUS_DATA_NOT_ACCEPTED;
        }
        //
        // If the chunk if a 'RIFF' or 'LIST' chunk, read the form type or
        // list type
        //
        if ((MmckInfo->ckid == FOURCC_RIFF) || (MmckInfo->ckid == FOURCC_LIST)) {
            Status = riffRead(FileObject, &MmckInfo->fccType, sizeof(DWORD));
            if (!NT_SUCCESS(Status)) {
                return Status;
            }
        } else {
            MmckInfo->fccType = 0;
        }
        //
        // If this is the chunk, stop looking.
        //
        if ((!ckidFind || (ckidFind == MmckInfo->ckid)) && (!fccTypeFind || (fccTypeFind == MmckInfo->fccType))) {
            break;
        }
        //
        // Ascend out of the chunk and try again.
        //
        if (!NT_SUCCESS(Status = riffAscend(FileObject, MmckInfo))) {
            return Status;
        }
    }
    return STATUS_SUCCESS;
}


NTSTATUS
riffAscend(
    IN PFILE_OBJECT     FileObject,
    IN LPMMCKINFO       MmckInfo
    )
/*++

Routine Description:

    Ascend out of a RIFF chunk, seeking to the end of that chunk.

Arguments:

    FileObject -
        The stream source.

    MmckInfo -
        Contains the chunk which is being ascended out of.

Return Values:

    Returns STATUS_SUCCESS if the RIFF ascend was successful, else
    STATUS_DATA_NOT_ACCEPTED.

--*/
{
    //
    // Seek to the end of the chunk, past the null pad byte which is only there
    // if chunk size is odd.
    //
    return riffSetPosition(FileObject, MmckInfo->dwDataOffset + MmckInfo->cksize + (MmckInfo->cksize & 1));
}


NTSTATUS
riffReadWaveFormat(
    IN PFILE_OBJECT                 FileObject,
    OUT PKSDATAFORMAT_WAVEFORMATEX* WaveFormat,
    OUT ULONGLONG*                  DataOffset,
    OUT ULONGLONG*                  DataLength
    )
/*++

Routine Description:

    Read the wave format from the Riff stream. Resets the file position.

Arguments:

    FileObject -
        The stream source.

    WaveFormat -
        The place in which to put the pointer allocated to hold the Wave format
        retrieved from the stream.

    DataOffset -
        The place in which to put the Wave data offset in the stream.

    DataLength -
        The place in which to put the Wave data length.

Return Values:

    Returns STATUS_SUCCESS if the format was read, else and error.

--*/
{
    ULONGLONG                   Extent;
    MMCKINFO                    MmckRIFF;
    MMCKINFO                    Mmck;
    NTSTATUS                    Status;
    ULONG                       FormatSize;
    PKSDATAFORMAT_WAVEFORMATEX  LocalWaveFormat;

_DbgPrintF(DEBUGLVL_TERSE, ("riffReadWaveFormat"));
    //
    // Always reset the position to the beginning of the stream.
    //
    riffSetPosition(FileObject, 0);
    Status = riffGetExtent(FileObject, &Extent);
_DbgPrintF(DEBUGLVL_TERSE, ("\triffGetExtent=%x, Extent=%I64u", Status, Extent));
    if (!NT_SUCCESS(Status)) {
        return Status;
    }
    MmckRIFF.fccType = riffWAVE;
    Status = riffDescend(FileObject, &MmckRIFF, NULL, MMIO_FINDRIFF);
_DbgPrintF(DEBUGLVL_TERSE, ("\triffDescend=%x", Status));
    if (!NT_SUCCESS(Status)) {
        return Status;
    }
    Mmck.ckid = riffFMT;
    Status = riffDescend(FileObject, &Mmck, &MmckRIFF, MMIO_FINDCHUNK);
_DbgPrintF(DEBUGLVL_TERSE, ("\triffDescend=%x", Status));
    if (!NT_SUCCESS(Status)) {
        return Status;
    }
    if (Mmck.cksize < sizeof(PCMWAVEFORMAT)) {
        return STATUS_DATA_NOT_ACCEPTED;
    }
    FormatSize = sizeof(KSDATAFORMAT) + max(Mmck.cksize, sizeof(WAVEFORMATEX));
_DbgPrintF(DEBUGLVL_TERSE, ("\tFormatSize=%u", FormatSize));
    //
    // Don't allow unlimited memory allocation by the calling process.
    //
    try {
        LocalWaveFormat = (PKSDATAFORMAT_WAVEFORMATEX)ExAllocatePoolWithQuotaTag(PagedPool, FormatSize, 'evaW');
    } except (EXCEPTION_EXECUTE_HANDLER) {
        return GetExceptionCode();
    }
    //
    // The header may not be in extended format, so ensure this is zeroed.
    //
    LocalWaveFormat->WaveFormatEx.cbSize = 0;
    Status = riffRead(FileObject, &LocalWaveFormat->WaveFormatEx, Mmck.cksize);
_DbgPrintF(DEBUGLVL_TERSE, ("\triffRead=%x", Status));
    if (!NT_SUCCESS(Status)) {
        ExFreePool(LocalWaveFormat);
        return Status;
    }
_DbgPrintF(DEBUGLVL_TERSE, ("\tWaveFormatEx="));
_DbgPrintF(DEBUGLVL_TERSE, ("\t\twFormatTag=%x\n\t\tnChannels=%u\n", LocalWaveFormat->WaveFormatEx.wFormatTag, LocalWaveFormat->WaveFormatEx.nChannels));
_DbgPrintF(DEBUGLVL_TERSE, ("\t\tnAvgBytesPerSec=%x\n\t\tnBlockAlign=%u\n", LocalWaveFormat->WaveFormatEx.nAvgBytesPerSec, LocalWaveFormat->WaveFormatEx.nBlockAlign));
_DbgPrintF(DEBUGLVL_TERSE, ("\t\twBitsPerSample=%x\n\t\tcbSize=%u\n", LocalWaveFormat->WaveFormatEx.wBitsPerSample, LocalWaveFormat->WaveFormatEx.cbSize));
    if (Mmck.cksize < sizeof(WAVEFORMATEX)) {
        LocalWaveFormat->WaveFormatEx.cbSize = 0;
    } else if (LocalWaveFormat->WaveFormatEx.cbSize > Mmck.cksize - sizeof(WAVEFORMATEX)) {
        ExFreePool(LocalWaveFormat);
        return STATUS_DATA_NOT_ACCEPTED;
    }
    LocalWaveFormat->DataFormat.FormatSize = FormatSize;
    if (LocalWaveFormat->WaveFormatEx.wFormatTag == WAVE_FORMAT_PCM) {
        LocalWaveFormat->DataFormat.Flags = 0;
    } else {
        LocalWaveFormat->DataFormat.Flags = KSDATAFORMAT_TEMPORAL_COMPRESSION;
    }
    LocalWaveFormat->DataFormat.SampleSize = LocalWaveFormat->WaveFormatEx.nBlockAlign;
    LocalWaveFormat->DataFormat.Reserved = 0;
    LocalWaveFormat->DataFormat.MajorFormat = KSDATAFORMAT_TYPE_AUDIO;
    INIT_WAVEFORMATEX_GUID(&LocalWaveFormat->DataFormat.SubFormat, LocalWaveFormat->WaveFormatEx.wFormatTag);
    LocalWaveFormat->DataFormat.Specifier = KSDATAFORMAT_SPECIFIER_WAVEFORMATEX;
    if (!NT_SUCCESS(Status = riffAscend(FileObject, &Mmck))) {
        ExFreePool(LocalWaveFormat);
        return Status;
    }
    Mmck.ckid = riffDATA;
    if (!NT_SUCCESS(Status = riffDescend(FileObject, &Mmck, &MmckRIFF, MMIO_FINDCHUNK))) {
        ExFreePool(LocalWaveFormat);
        return Status;
    }
    if (Mmck.dwDataOffset + Mmck.cksize > Extent) {
        ExFreePool(LocalWaveFormat);
        return STATUS_DATA_NOT_ACCEPTED;
    }
    *WaveFormat = LocalWaveFormat;
    *DataLength = Mmck.cksize;
    *DataOffset = Mmck.dwDataOffset;
_DbgPrintF(DEBUGLVL_TERSE, ("\tSTATUS_SUCCESS"));
    return STATUS_SUCCESS;
}


NTSTATUS
InitializeRiffIoPin(
    IN PIRP             Irp,
    IN PKSPIN_CONNECT   Connect
    )
/*++

Routine Description:

    Allocates the Riff I/O Pin specific structure and initializes it. This includes
    connecting to the specified file name in the data format.

Arguments:

    Irp -
        Creation Irp.

    DataFormat -
        The proposed data format.

Return Values:

    Returns STATUS_SUCCESS if everything could be allocated and opened, else an error.

--*/
{
    PKSDATAFORMAT               DataFormat;
    PFILE_OBJECT                FileObject;
    PIO_STACK_LOCATION          IrpStack;
    PFILTER_INSTANCE            FilterInstance;
    PKSDATAFORMAT_WAVEFORMATEX  WaveFormat;
    PPIN_INSTANCE_RIFFIO        PinInstance;
    NTSTATUS                    Status;
    ULONGLONG                   DataOffset;
    ULONGLONG                   DataLength;

_DbgPrintF(DEBUGLVL_TERSE, ("InitializeRiffIoPin"));
    DataFormat = (PKSDATAFORMAT)(Connect + 1);
    //
    // The rest of the data format has already been verified by KsValidateConnectRequest,
    // however the FormatSize may be longer than what it should be.
    //
    if (DataFormat->FormatSize != sizeof(KSDATAFORMAT)) {
        return STATUS_NO_MATCH;
    }
    //
    // Ensure that the handle passed is valid. Note that the Previous Mode is used,
    // since the Irp->RequestorMode is always set to KernelMode on a create.
    //
    Status = ObReferenceObjectByHandle(
        Connect->PinToHandle,
        FILE_READ_DATA,
        *IoFileObjectType,
        ExGetPreviousMode(),
        &FileObject,
        NULL);
    if (!NT_SUCCESS(Status)) {
        _DbgPrintF( 
            DEBUGLVL_ERROR, 
            ("unable to reference object: %08x", Status) );
        return Status;
    }
    //
    // Parse the data stream to ensure that it is a valid Riff Wave stream, and return
    // useful information on it.
    //
    Status = riffReadWaveFormat(FileObject, &WaveFormat, &DataOffset, &DataLength);
    if (!NT_SUCCESS(Status)) {
        ObDereferenceObject(FileObject);
        _DbgPrintF( 
            DEBUGLVL_ERROR, 
            ("unable to read wave file format: %08x", Status) );
        return Status;
    }
    IrpStack = IoGetCurrentIrpStackLocation(Irp);
    FilterInstance = (PFILTER_INSTANCE)IrpStack->FileObject->RelatedFileObject->FsContext;
    if (FilterInstance->WaveFormat) {
_DbgPrintF(DEBUGLVL_TERSE, ("\tInitializeRiffIoPin: Wave pin already connected"));
        //
        // There is already another connection on this filter, and so a wave format
        // has been selected. This means that the one read must match that
        // format. Ensure that the comparison won't fault in random memory, then
        // do the actual compare.
        //
        if ((WaveFormat->DataFormat.FormatSize != FilterInstance->WaveFormat->DataFormat.FormatSize) ||
            !RtlEqualMemory(WaveFormat, FilterInstance->WaveFormat, FilterInstance->WaveFormat->DataFormat.FormatSize)) {
            return STATUS_NO_MATCH;
        }
        //
        // No new wave format is allocated in this instance.
        //
        ExFreePool(WaveFormat);
        WaveFormat = NULL;
    } else {
        FilterInstance->WaveFormat = WaveFormat;
    }
    //
    // Create the instance information. This contains the Pin factory identifier, file
    // handle, file object, and mutex for accessing the file. The only reason the file
    // handle is kept is that the file system keeps track of locks based on handles,
    // and assumes the file is closing if no handles are opened on a file object, which
    // results in I/O to that file object failing.
    //
    PinInstance = (PPIN_INSTANCE_RIFFIO)ExAllocatePoolWithTag(
        PagedPool,
        sizeof(PIN_INSTANCE_RIFFIO),
        'IPsK');
    if (PinInstance) {
        //
        // This object uses KS to perform access through the PinRiffIoDispatchTable. There
        // are no create items attached to this object because it does not support a
        // clock or allocator.
        //
        Status = KsAllocateObjectHeader(
            &PinInstance->InstanceHdr.Header,
            0,
            NULL,
            Irp,
            &PinRiffIoDispatchTable);
        if (NT_SUCCESS(Status)) {
            PinInstance->PresentationByteTime = 0;
            PinInstance->DataOffset = DataOffset;
            PinInstance->DataLength = DataLength;
            PinInstance->FileObject = FileObject;
            PinInstance->Denominator =
                FilterInstance->WaveFormat->WaveFormatEx.wBitsPerSample *
                FilterInstance->WaveFormat->WaveFormatEx.nChannels *
                FilterInstance->WaveFormat->WaveFormatEx.nSamplesPerSec;
            PinInstance->State = KSSTATE_STOP;
            //
            // KS expects that the object data is in FsContext.
            //
            IrpStack->FileObject->FsContext = PinInstance;
            //
            // Add the Pin's target to the list of targets for recalculating
            // stack depth.
            //
            KsSetTargetDeviceObject(
                PinInstance->InstanceHdr.Header,
                IoGetRelatedDeviceObject(FileObject));
            return STATUS_SUCCESS;
        } else {
            _DbgPrintF( 
                DEBUGLVL_ERROR, 
                ("unable to allocate object header: %08x", Status) );
        }
        ExFreePool(PinInstance);
    } else {
        Status = STATUS_INSUFFICIENT_RESOURCES;
    }
    //
    // This is only the failure case, so free any possible new wave format structure
    // that has been allocated.
    //
    if (WaveFormat) {
        FilterInstance->WaveFormat = NULL;
        ExFreePool(WaveFormat);
    }
    ObDereferenceObject(FileObject);
    return Status;
}


NTSTATUS
InitializeWaveIoPin(
    IN PIRP             Irp,
    IN PKSDATAFORMAT    DataFormat
    )
/*++

Routine Description:

    Allocates the Wave I/O Pin specific structure and initializes it.

Arguments:

    Irp -
        Creation Irp.

    DataFormat -
        The proposed data format.

Return Values:

    Returns STATUS_SUCCESS if everything could be allocated and opened, else an error.

--*/
{
    PIO_STACK_LOCATION          IrpStack;
    PFILTER_INSTANCE            FilterInstance;
    PKSDATAFORMAT_WAVEFORMATEX  WaveFormat;
    PPIN_INSTANCE_WAVEIO        PinInstance;
    NTSTATUS                    Status;

_DbgPrintF(DEBUGLVL_TERSE, ("InitializeWaveIoPin"));
    IrpStack = IoGetCurrentIrpStackLocation(Irp);
    FilterInstance = (PFILTER_INSTANCE)IrpStack->FileObject->RelatedFileObject->FsContext;
    if (FilterInstance->WaveFormat) {
        //
        // There is already another connection on this filter, and so a wave format
        // has been selected. This means that the one passed here must match that
        // format. Ensure that the comparison won't fault in random memory, then
        // do the actual compare.
        //
_DbgPrintF(DEBUGLVL_TERSE, ("\tInitializeWaveIoPin: Riff side is already connected"));
        if (DataFormat->FormatSize != FilterInstance->WaveFormat->DataFormat.FormatSize) {
            return STATUS_NO_MATCH;
        }
        ((PKSDATAFORMAT_WAVEFORMATEX)DataFormat)->DataFormat.Flags |= FilterInstance->WaveFormat->DataFormat.Flags;
        ((PKSDATAFORMAT_WAVEFORMATEX)DataFormat)->DataFormat.SampleSize = FilterInstance->WaveFormat->DataFormat.SampleSize;
        if (!RtlEqualMemory(DataFormat, FilterInstance->WaveFormat, FilterInstance->WaveFormat->DataFormat.FormatSize)) {
            return STATUS_NO_MATCH;
        }
        //
        // No new wave format is allocated in this instance.
        //
        WaveFormat = NULL;
    } else {
_DbgPrintF(DEBUGLVL_TERSE, ("\tInitializeWaveIoPin: brand new format"));
        //
        // Don't allow unlimited memory allocation by the calling process.
        //
        try {
            WaveFormat = (PKSDATAFORMAT_WAVEFORMATEX)ExAllocatePoolWithQuotaTag(PagedPool, sizeof(DataFormat->FormatSize), 'evaW');
        } except (EXCEPTION_EXECUTE_HANDLER) {
            return GetExceptionCode();
        }
        RtlCopyMemory(WaveFormat, DataFormat, DataFormat->FormatSize);
    }
    //
    // Create the instance information. This contains the Pin factory identifier.
    //
    PinInstance = (PPIN_INSTANCE_WAVEIO)ExAllocatePoolWithTag(
        PagedPool,
        sizeof(PIN_INSTANCE_WAVEIO),
        'IPsK');
    if (PinInstance) {
        //
        // This object uses KS to perform access through the PinWaveIoDispatchTable. There
        // are no create items attached to this object because it does not support a
        // clock or allocator.
        //
        Status = KsAllocateObjectHeader(
            &PinInstance->InstanceHdr.Header,
            0,
            NULL,
            Irp,
            &PinWaveIoDispatchTable);
        if (NT_SUCCESS(Status)) {
            //
            // Assign the new format passed to this call. Else there must already be
            // a connection, and this format matches the format already selected.
            //
            if (!FilterInstance->WaveFormat) {
                FilterInstance->WaveFormat = WaveFormat;
            }
            //
            // KS expects that the object data is in FsContext.
            //
            IrpStack->FileObject->FsContext = PinInstance;
            return STATUS_SUCCESS;
        }
        ExFreePool(PinInstance);
    } else {
        Status = STATUS_INSUFFICIENT_RESOURCES;
    }
    //
    // This is only the failure case, so free any possible new wave format structure
    // that has been allocated.
    //
    if (WaveFormat) {
        ExFreePool(WaveFormat);
    }
    return Status;
}


NTSTATUS
PinDispatchCreate(
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp
    )
/*++

Routine Description:

    Dispatches the creation of a Pin instance. Allocates the object header and initializes
    the data for this Pin instance.

Arguments:

    DeviceObject -
        Device object on which the creation is occuring.

    Irp -
        Creation Irp.

Return Values:

    Returns STATUS_SUCCESS on success, or an error.

--*/
{
    PIO_STACK_LOCATION  IrpStack;
    PKSPIN_CONNECT      Connect;
    NTSTATUS            Status;

_DbgPrintF(DEBUGLVL_TERSE, ("PinDispatchCreate"));
    IrpStack = IoGetCurrentIrpStackLocation(Irp);
    //
    // Determine if this request is being sent to a valid Pin factory with valid
    // connection parameters. All the descriptors are the same except for the
    // data flow description, which is not specified in a connection request.
    //
    if (NT_SUCCESS(Status = KsValidateConnectRequest(Irp, SIZEOF_ARRAY(PinDescriptors), PinDescriptors, &Connect))) {
        PFILTER_INSTANCE    FilterInstance;

        FilterInstance = (PFILTER_INSTANCE)IrpStack->FileObject->RelatedFileObject->FsContext;
        //
        // Exclude other Pin creation at this point.
        //
        ExAcquireFastMutexUnsafe(&FilterInstance->ControlMutex);
        if (!FilterInstance->PinFileObjects[Connect->PinId]) {
            switch (Connect->PinId) {
            case ID_RIFFIO_PIN:
                Status = InitializeRiffIoPin(Irp, Connect);
                break;
            case ID_WAVEIO_PIN:
                Status = InitializeWaveIoPin(Irp, (PKSDATAFORMAT)(Connect + 1));
                break;
            }
            if (NT_SUCCESS(Status)) {
                PPIN_INSTANCE_HEADER    PinInstance;

                //
                // Store the common Pin information and increment the reference
                // count on the parent Filter.
                //
                PinInstance = (PPIN_INSTANCE_HEADER)IrpStack->FileObject->FsContext;
                PinInstance->PinId = Connect->PinId;
                ObReferenceObject(IrpStack->FileObject->RelatedFileObject);
                FilterInstance->PinFileObjects[Connect->PinId] = IrpStack->FileObject;
            }
        } else {
            Status = STATUS_CONNECTION_REFUSED;
        }
        ExReleaseFastMutexUnsafe(&FilterInstance->ControlMutex);
    }
    Irp->IoStatus.Status = Status;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);
_DbgPrintF(DEBUGLVL_TERSE, ("PinDispatchCreate=%x", Status));
    return Status;
}


NTSTATUS
PinDispatchClose(
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp
    )
/*++

Routine Description:

    Closes a previously opened Pin instance. This can occur at any time in any order.

Arguments:

    DeviceObject -
        Device object on which the close is occuring.

    Irp -
        Close Irp.

Return Values:

    Returns STATUS_SUCCESS.

--*/
{
    PIO_STACK_LOCATION      IrpStack;
    PFILTER_INSTANCE        FilterInstance;
    PPIN_INSTANCE_HEADER    PinInstance;
    ULONG                   PinId;

    IrpStack = IoGetCurrentIrpStackLocation(Irp);
    PinInstance = (PPIN_INSTANCE_HEADER)IrpStack->FileObject->FsContext;
    FilterInstance = (PFILTER_INSTANCE)IrpStack->FileObject->RelatedFileObject->FsContext;
    //
    // The closing of the Pin instances must be synchronized with any access to
    // that object.
    //
    ExAcquireFastMutexUnsafe(&FilterInstance->ControlMutex);
    //
    // These were allocated during the creation of the Pin instance. Specifically
    // access to the target file object and the PinFileObjects array.
    //
    KsFreeObjectHeader(PinInstance->Header);
    switch (PinInstance->PinId) {
    case ID_RIFFIO_PIN:
        ObDereferenceObject(((PPIN_INSTANCE_RIFFIO)PinInstance)->FileObject);
        //
        // After removing this item from the list of object during
        // KsFreeObjectHeader, try to shrink the stack depth.
        //
        KsRecalculateStackDepth(((PDEVICE_INSTANCE)DeviceObject->DeviceExtension)->Header, FALSE);
        PinId = ID_WAVEIO_PIN;
        break;
    case ID_WAVEIO_PIN:
        PinId = ID_RIFFIO_PIN;
        break;
    }
    //
    // As soon as the entry has been set to NULL, the mutex can allow access again.
    //
    FilterInstance->PinFileObjects[PinInstance->PinId] = NULL;
    //
    // When both connections are removed, then the data format is free to change.
    //
    if (!FilterInstance->PinFileObjects[PinId]) {
        ExFreePool(FilterInstance->WaveFormat);
        FilterInstance->WaveFormat = NULL;
    }
    ExReleaseFastMutexUnsafe(&FilterInstance->ControlMutex);
    //
    // All Pins are created with a root file object, which is the Filter, and was
    // previously referenced during creation.
    //
    ObDereferenceObject(IrpStack->FileObject->RelatedFileObject);
    ExFreePool(PinInstance);
    Irp->IoStatus.Status = STATUS_SUCCESS;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);
    return STATUS_SUCCESS;
}


PFILE_OBJECT
ReferenceRiffIoObject(
    PFILE_OBJECT FileObject
    )
/*++

Routine Description:

    This acquires the Filter mutex, references and returns the Riff I/O Pin instance so
    that the Wave I/O Pin or Filter instance can access the structures. The mutex is
    released before returning, but since the file object has been referenced, this
    ensures that the Riff I/O Pin is not closed while such accessing is occuring. If
    the Riff I/O Pin has been closed, this releases the mutex and returns NULL.

Arguments:

    FileObject -
        The file object of the parent Filter.

Return Values:

    Returns a Riff I/O Pin object, or NULL if there is none on the parent Filter.

--*/
{
    PFILTER_INSTANCE    FilterInstance;

    FilterInstance = (PFILTER_INSTANCE)FileObject->FsContext;
    //
    // Synchronize with any close, and exclude other changes from happening.
    //
    ExAcquireFastMutexUnsafe(&FilterInstance->ControlMutex);
    FileObject = FilterInstance->PinFileObjects[ID_RIFFIO_PIN];
    if (FileObject) {
        //
        // Only reference if the Riff I/O Pin instance is present.
        //
        ObReferenceObject(FileObject);
    }
    ExReleaseFastMutexUnsafe(&FilterInstance->ControlMutex);
    return FileObject;
}


NTSTATUS
ReadStream(
    IN PIRP     Irp
    )
/*++

Routine Description:

    Handles IOCTL_KS_READ_STREAM by reading data from the current file position.

Arguments:

    Irp -
        Streaming Irp.

Return Values:

    Returns STATUS_SUCCESS if the request was fulfilled, which includes reaching the end
    of file. Else returns STATUS_DEVICE_NOT_CONNECTED if the Riff I/O Pin has been closed,
    some read error, or some parameter validation error.

--*/
{
    NTSTATUS    Status;

    Status = KsProbeStreamIrp(Irp, KSPROBE_STREAMREAD, sizeof(KSSTREAM_HEADER));
    if (NT_SUCCESS(Status)) {
        PIO_STACK_LOCATION      IrpStack;
        PPIN_INSTANCE_RIFFIO    PinInstance;
        PFILE_OBJECT            FileObject;
        ULONG                   BufferLength;
        PKSSTREAM_HEADER        StreamHdr;

        IrpStack = IoGetCurrentIrpStackLocation(Irp);
        BufferLength = IrpStack->Parameters.DeviceIoControl.OutputBufferLength;
        StreamHdr = (PKSSTREAM_HEADER)Irp->AssociatedIrp.SystemBuffer;
        //
        // Retrieve the RIFF I/O Pin instance and reference it.
        //
        if (!(FileObject = ReferenceRiffIoObject(IrpStack->FileObject->RelatedFileObject))) {
            return STATUS_DEVICE_NOT_CONNECTED;
        }
        PinInstance = (PPIN_INSTANCE_RIFFIO)FileObject->FsContext;
        //
        // Enumerate the stream headers, filling in each one.
        //
        for (; BufferLength; BufferLength -= sizeof(KSSTREAM_HEADER), StreamHdr++) {
            IO_STATUS_BLOCK         IoStatusBlock;

            //
            // If a stream time was not set, then use the current position, else use
            // the position specified. The file is locked, so this can be accessed
            // directly to set the start time of this block.
            //
            if (StreamHdr->OptionsFlags & KSSTREAM_HEADER_OPTIONSF_TIMEVALID) {
                //
                // The data source specifies the Numerator/Denominator
                //
                if ((StreamHdr->PresentationTime.Numerator != 80000000) || (StreamHdr->PresentationTime.Denominator != PinInstance->Denominator)) {
                    Status = STATUS_INVALID_PARAMETER;
                    break;
                }
                //
                // Because of the Numerator/Denominator chosen, the time is already
                // equivalent to the byte position. This assumes a constant bit rate
                // compression, which is all that can normally be handled by RIFF
                // Wave anyway.
                //
                StreamHdr->PresentationTime.Numerator = 1;
                StreamHdr->PresentationTime.Denominator = 1;
            }
        }
        if (NT_SUCCESS(Status)) {
            //
            // Need to catch the Irp on the way back in order to put the correct
            // Numerator and Denominator back. To be cheap, this is a synchronous
            // call.
            //
            BufferLength = IrpStack->Parameters.DeviceIoControl.OutputBufferLength;
            Status = KsForwardAndCatchIrp(
                IoGetRelatedDeviceObject(PinInstance->FileObject),
                Irp,
                PinInstance->FileObject,
                KsStackReuseCurrentLocation);
            if (NT_SUCCESS(Status)) {
                for (StreamHdr = (PKSSTREAM_HEADER)Irp->AssociatedIrp.SystemBuffer;
                     BufferLength;
                     BufferLength -= sizeof(KSSTREAM_HEADER), StreamHdr++) {
                    if (StreamHdr->OptionsFlags & KSSTREAM_HEADER_OPTIONSF_TIMEVALID) {
                        StreamHdr->PresentationTime.Numerator = 80000000;
                        StreamHdr->PresentationTime.Denominator = PinInstance->Denominator;
                    }
                }
            }
        }
        ObDereferenceObject(FileObject);
    }
    return Status;
}


NTSTATUS
PinWaveDispatchIoControl(
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp
    )
/*++

Routine Description:

    Dispatches property, event, and streaming requests on the Wave I/O Pin instance.

Arguments:

    DeviceObject -
        Device object on which the device control is occuring.

    Irp -
        Device control Irp.

Return Values:

    Returns STATUS_SUCCESS if the property was successfully manipulated, else an error.

--*/
{
    NTSTATUS            Status;
    CCHAR               PriorityBoost;

    PriorityBoost = IO_NO_INCREMENT;
    switch (IoGetCurrentIrpStackLocation(Irp)->Parameters.DeviceIoControl.IoControlCode) {
    case IOCTL_KS_PROPERTY:
        Status = KsPropertyHandler(
            Irp,
            SIZEOF_ARRAY(WaveIoPropertySets),
            WaveIoPropertySets);
        break;
    case IOCTL_KS_READ_STREAM:
        if (NT_SUCCESS(Status = ReadStream(Irp))) {
            PriorityBoost = IO_DISK_INCREMENT;
        }
        break;
    default:
        return KsDefaultDeviceIoCompletion(DeviceObject, Irp);
    }
    Irp->IoStatus.Status = Status;
    IoCompleteRequest(Irp, PriorityBoost);
    return Status;
}


NTSTATUS
PinRiffDispatchIoControl(
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp
    )
/*++

Routine Description:

    Dispatches property, event, and streaming requests on the Riff I/O Pin instance.

Arguments:

    DeviceObject -
        Device object on which the device control is occuring.

    Irp -
        Device control Irp.

Return Values:

    Returns STATUS_SUCCESS if the property was successfully manipulated, else an error.

--*/
{
    NTSTATUS            Status;
    CCHAR               PriorityBoost;

    PriorityBoost = IO_NO_INCREMENT;
    switch (IoGetCurrentIrpStackLocation(Irp)->Parameters.DeviceIoControl.IoControlCode) {
    case IOCTL_KS_PROPERTY:
        Status = KsPropertyHandler(
            Irp,
            SIZEOF_ARRAY(RiffIoPropertySets),
            RiffIoPropertySets);
        break;
    default:
        return KsDefaultDeviceIoCompletion(DeviceObject, Irp);
    }
    Irp->IoStatus.Status = Status;
    IoCompleteRequest(Irp, PriorityBoost);
    return Status;
}


NTSTATUS
GetTimeFormat(
    IN PIRP Irp,
    IN PKSPROPERTY Property,
    OUT GUID* TimeFormat
    )
/*++

Routine Description:

    Handles the KSPROPERTY_STREAM_TIMEFORMAT property Get in the Stream property
    set. Returns the time format on the Riff I/O Pin so that positional
    translations can be performed.

Arguments:

    Irp -
        Device control Irp.

    Property -
        Specific property request.

    TimeFormat -
        The place in which to put the time format.

Return Values:

    Returns STATUS_SUCCESS.

--*/
{
    *TimeFormat = KSTIME_FORMAT_BYTE;
    Irp->IoStatus.Information = sizeof(*TimeFormat);
    return STATUS_SUCCESS;
}


NTSTATUS
GetPresentationTime(
    IN PIRP         Irp,
    IN PKSPROPERTY  Property,
    OUT PKSTIME     PresentationTime
    )
/*++

Routine Description:

    Handles the KSPROPERTY_STREAM_PRESENTATIONTIME property Get in the Stream property
    set. Retrieves the current file position if there is a Riff I/O Pin instance.

Arguments:

    Irp -
        Device control Irp.

    Property -
        Specific property request.

    PresentationTime -
        The place in which to put the current file position in native units.

Return Values:

    Returns STATUS_SUCCESS, else STATUS_DEVICE_NOT_CONNECTED if there is no Riff I/O Pin.

--*/
{
    PFILE_OBJECT            FileObject;
    PPIN_INSTANCE_RIFFIO    PinInstance;

    //
    // Retrieve the RIFF I/O Pin instance and reference it.
    //
    if (!(FileObject = ReferenceRiffIoObject(IoGetCurrentIrpStackLocation(Irp)->FileObject->RelatedFileObject))) {
        return STATUS_DEVICE_NOT_CONNECTED;
    }
    PinInstance = (PPIN_INSTANCE_RIFFIO)FileObject->FsContext;
    //
    // The pin is locked, so this can be accessed directly.
    //
    PresentationTime->Time = PinInstance->PresentationByteTime;
    PresentationTime->Numerator = 80000000;
    PresentationTime->Denominator = PinInstance->Denominator;
    ObDereferenceObject(FileObject);
    Irp->IoStatus.Information = sizeof(*PresentationTime);
    return STATUS_SUCCESS;
}


NTSTATUS
SetPresentationTime(
    IN PIRP         Irp,
    IN PKSPROPERTY  Property,
    IN PKSTIME      PresentationTime
    )
/*++

Routine Description:

    Handles the KSPROPERTY_STREAM_PRESENTATIONTIME property Set in the Stream property
    set. Sets the current file position if there is a Riff I/O Pin instance.

Arguments:

    Irp -
        Device control Irp.

    Property -
        Specific property request.

    PresentationTime -
        Points to the new file position expressed in native units.

Return Values:

    Returns STATUS_SUCCESS, else STATUS_DEVICE_NOT_CONNECTED if there is no Riff I/O Pin.

--*/
{
    PFILE_OBJECT                FileObject;
    PPIN_INSTANCE_RIFFIO        PinInstance;
    NTSTATUS                    Status;

    //
    // Retrieve the RIFF I/O Pin instance and reference it.
    //
    if (!(FileObject = ReferenceRiffIoObject(IoGetCurrentIrpStackLocation(Irp)->FileObject->RelatedFileObject))) {
        return STATUS_DEVICE_NOT_CONNECTED;
    }
    PinInstance = (PPIN_INSTANCE_RIFFIO)FileObject->FsContext;
    //
    // The pin is locked, so this can be accessed directly. Don't allow
    // a seek off the end of the chunk.
    //
    if ((ULONGLONG)PresentationTime->Time <= PinInstance->DataLength) {
        //
        // The data source specifies the Numerator/Denominator.
        //
        if ((PresentationTime->Numerator == 80000000) &&
            (PresentationTime->Denominator == PinInstance->Denominator)) {
            Status = riffSetPosition(
                PinInstance->FileObject,
                PresentationTime->Time + PinInstance->DataOffset);
            if (NT_SUCCESS(Status)) {
                PinInstance->PresentationByteTime = PresentationTime->Time;
            }
        } else {
            Status = STATUS_INVALID_PARAMETER_MIX;
        }
    } else {
        Status = STATUS_END_OF_FILE;
    }
    ObDereferenceObject(FileObject);
    return Status;
}


NTSTATUS
GetPresentationExtent(
    IN PIRP         Irp,
    IN PKSPROPERTY  Property,
    OUT PULONGLONG  PresentationExtent
    )
/*++

Routine Description:

    Handles the KSPROPERTY_STREAM_PRESENTATIONEXTENT property Get in the Stream property
    set. Retrieves the current file extent if there is a Riff I/O Pin instance.

Arguments:

    Irp -
        Device control Irp.

    Property -
        Specific property request.

    PresentationExtent -
        The place in which to put the file length in native units.

Return Values:

    Returns STATUS_SUCCESS, else STATUS_DEVICE_NOT_CONNECTED if there is no Riff I/O Pin.

--*/
{
    PFILE_OBJECT                FileObject;
    PPIN_INSTANCE_RIFFIO        PinInstance;
    FILE_STANDARD_INFORMATION   StandardInformation;
    IO_STATUS_BLOCK             IoStatus;

    //
    // Retrieve the RIFF I/O Pin instance and reference it.
    //
    if (!(FileObject = ReferenceRiffIoObject(IoGetCurrentIrpStackLocation(Irp)->FileObject->RelatedFileObject))) {
        return STATUS_DEVICE_NOT_CONNECTED;
    }
    PinInstance = (PPIN_INSTANCE_RIFFIO)FileObject->FsContext;
    *PresentationExtent = PinInstance->DataLength;
    ObDereferenceObject(FileObject);
    Irp->IoStatus.Information = sizeof(*PresentationExtent);
    return STATUS_SUCCESS;
}


NTSTATUS
SetState(
    IN PIRP         Irp,
    IN PKSPROPERTY  Property,
    IN PKSSTATE     State
    )
/*++

Routine Description:

    Handles the KSPROPERTY_CONNECTION_STATE property Set in the Connection property
    set. Deals with transitions from the Stop state by recalculating stack depth.

Arguments:

    Irp -
        Device control Irp.

    Property -
        Specific property request.

    State -
        Points to the new state.

Return Values:

    Returns STATUS_SUCCESS, else STATUS_DEVICE_NOT_CONNECTED if there is no Riff I/O Pin.
--*/
{
    PIO_STACK_LOCATION          IrpStack;
    PFILE_OBJECT                FileObject;
    PPIN_INSTANCE_RIFFIO        PinInstance;

    IrpStack = IoGetCurrentIrpStackLocation(Irp);
    //
    // Retrieve the RIFF I/O Pin instance and reference it.
    //
    FileObject = ReferenceRiffIoObject(IrpStack->FileObject->RelatedFileObject);
    if (FileObject) {
        PinInstance = (PPIN_INSTANCE_RIFFIO)FileObject->FsContext;
    }
    //
    // Only transitions out of Stop state are interesting, except for removing
    // the extra target object from the active list.
    //
    if (*State == KSSTATE_STOP) {
        if (FileObject) {
            KsSetTargetState(PinInstance->InstanceHdr.Header, KSTARGET_STATE_DISABLED);
            PinInstance->State = *State;
            ObDereferenceObject(FileObject);
        }
        return STATUS_SUCCESS;
    }
    //
    // Can't make it go if the file is not connected.
    //
    if (!FileObject) {
        return STATUS_DEVICE_NOT_CONNECTED;
    }
    if (PinInstance->State == KSSTATE_STOP) {
        //
        // Enable the target device object so that it can be counted in recalculations.
        //
        KsSetTargetState(PinInstance->InstanceHdr.Header, KSTARGET_STATE_ENABLED);
        KsRecalculateStackDepth(((PDEVICE_INSTANCE)IrpStack->DeviceObject->DeviceExtension)->Header, FALSE);
    }
    //
    // No attempt at serialization is made here. The worst that can happen is
    // that Irp's fail because multiple changes were sent.
    //
    PinInstance->State = *State;
    ObDereferenceObject(FileObject);
    return STATUS_SUCCESS;
}


NTSTATUS
GetAcquireOrdering(
    IN PIRP         Irp,
    IN PKSPROPERTY  Property,
    OUT BOOL*       AcquireOrdering
    )
/*++

Routine Description:

    Handles the KSPROPERTY_CONNECTION_ACQUIREORDERING property Set in the Connection
    property set. Returns TRUE to indicate that this Communication Sink does require
    an ordered transition from Stop to Acquire state. This means that a client must
    follow the connection path to the filter which is connected to this filter's
    Connection Source (ID_RIFF_IO_PIN), to change the state of pins on that filter
    first (or follow the graph further if so indicated by the Communication Sink on
    that filter).

Arguments:

    Irp -
        Device control Irp.

    Property -
        Specific property request.

    AcquireOrdering -
        The place in which to return indication that this Communication Sink is
        interested in an ordered transition from Stop to Acquire state.

Return Values:

    Returns STATUS_SUCCESS.
--*/
{
    *AcquireOrdering = TRUE;
    Irp->IoStatus.Information = sizeof(*AcquireOrdering);
    return STATUS_SUCCESS;
}


NTSTATUS 
GetAllocatorFraming(
    IN PIRP                     Irp,
    IN PKSPROPERTY              Property,
    OUT PKSALLOCATOR_FRAMING    Framing
    )
/*++

Routine Description:

    Returns the allocator framing preferences for this object. For this stream
    the size is chosen based on PAGE_SIZE and block alignment of the data.

Arguments:

    Irp -
        Device control Irp.

    Property -
        Specific property request.

    Framing -
        The place in which to put the allocator preferences.

Return:

    Returns STATUS_SUCCESS.
--*/

{
    PIO_STACK_LOCATION      IrpStack;
    PFILTER_INSTANCE        FilterInstance;
    ULONG                   BlockAlign;

    IrpStack = IoGetCurrentIrpStackLocation(Irp);
    FilterInstance = (PFILTER_INSTANCE)IrpStack->FileObject->RelatedFileObject->FsContext;
    if (FilterInstance->WaveFormat) {
        BlockAlign = FilterInstance->WaveFormat->WaveFormatEx.nBlockAlign;
    } else {
        BlockAlign = 1;
    }
    Framing->RequirementsFlags =
        KSALLOCATOR_REQUIREMENTF_SYSTEM_MEMORY | KSALLOCATOR_REQUIREMENTF_PREFERENCES_ONLY;
    Framing->PoolType = PagedPool;
    Framing->Frames = 1;
    Framing->FrameSize = BlockAlign * PAGE_SIZE;
    Framing->FileAlignment = PAGE_SIZE - 1;
    Framing->Reserved = 0;
    Irp->IoStatus.Information = sizeof(*Framing);
    return STATUS_SUCCESS;
}


NTSTATUS 
SetStreamAllocator(
    IN PIRP Irp,
    IN PKSPROPERTY Property,
    IN PHANDLE AllocatorHandle
    )
/*++

Routine Description:

    Handles the KSPROPERTY_STREAM_ALLOCATOR property Set in the Stream
    property set. Does not actually use the allocator, so just returns
    STATUS_SUCCESS.

Arguments:

    Irp -
        Device control Irp.

    Property -
        Specific property request.

    AllocatorHandle -
        Points to the handle of the new allocator to use, or NULL if none
        is being assigned. Since this filter does not allocate memory, the
        new handle is ignored.

Return:

    Returns STATUS_SUCCESS.

--*/
{
    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\ksfilter\msriffwv\msriffwv.h ===
/*++

Copyright (C) Microsoft Corporation, 1996 - 1997

Module Name:

    msriffwv.h

Abstract:

    Internal header file for filter.

--*/

#include <wdm.h>
#include <windef.h>
#include <limits.h>
#include <ks.h>
#define NOBITMAP
#include <mmsystem.h>
#include <mmreg.h>
#include <ksmedia.h>
#include <swenum.h>
#include <ksdebug.h>

#if (DBG)
#define STR_MODULENAME  "msriffwv: "
#endif // DBG

extern const KSPIN_DESCRIPTOR PinDescriptors[2];

#define ID_RIFFIO_PIN 0
#define ID_WAVEIO_PIN 1

typedef struct {
    KSDEVICE_HEADER     Header;
} DEVICE_INSTANCE, *PDEVICE_INSTANCE;

typedef struct {
    KSOBJECT_HEADER             Header;
    FAST_MUTEX                  ControlMutex;
    PKSDATAFORMAT_WAVEFORMATEX  WaveFormat;
    PFILE_OBJECT                PinFileObjects[SIZEOF_ARRAY(PinDescriptors)];
} FILTER_INSTANCE, *PFILTER_INSTANCE;

typedef struct {
    KSOBJECT_HEADER     Header;
    ULONG               PinId;
} PIN_INSTANCE_HEADER, *PPIN_INSTANCE_HEADER;

typedef struct {
    PIN_INSTANCE_HEADER     InstanceHdr;
    ULONGLONG               PresentationByteTime;
    ULONGLONG               DataOffset;
    ULONGLONG               DataLength;
    PFILE_OBJECT            FileObject;
    ULONG                   Denominator;
    KSSTATE                 State;
} PIN_INSTANCE_RIFFIO, *PPIN_INSTANCE_RIFFIO;

typedef struct {
    PIN_INSTANCE_HEADER     InstanceHdr;
} PIN_INSTANCE_WAVEIO, *PPIN_INSTANCE_WAVEIO;

NTSTATUS
PnpAddDevice(
    IN PDRIVER_OBJECT   DriverObject,
    IN PDEVICE_OBJECT   PhysicalDeviceObject
    );
NTSTATUS
PinDispatchCreate(
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp
    );
PFILE_OBJECT
ReferenceRiffIoObject(
    PFILE_OBJECT FileObject
    );
NTSTATUS
riffSetPosition(
    IN PFILE_OBJECT     FileObject,
    IN ULONGLONG        Position
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\ksfilter\mstee\device.c ===
/*++

    Copyright (C) Microsoft Corporation, 1997 - 1998

Module Name:

    device.c

Abstract:
    
    This module implements the device object interface.

Author:

    Bryan A. Woodruff (bryanw) 13-Mar-1997

--*/

#define KSDEBUG_INIT

#include "private.h"

#ifdef ALLOC_PRAGMA
NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPathName
    );

#pragma alloc_text(INIT, DriverEntry)
#endif // ALLOC_PRAGMA

//---------------------------------------------------------------------------
//---------------------------------------------------------------------------

NTSTATUS 
DriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPathName
    )
{
    return 
        KsInitializeDriver(
            DriverObject,
            RegistryPathName,
            &DeviceDescriptor);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\ksfilter\msriffwv\device.c ===
/*++

Copyright (C) Microsoft Corporation, 1996 - 1997

Module Name:

    device.c

Abstract:

    Device entry point and hardware validation.

--*/

#include "msriffwv.h"

#ifdef ALLOC_PRAGMA
NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT   DriverObject,
    IN PUNICODE_STRING  RegistryPathName
    );

#pragma alloc_text(INIT, DriverEntry)
#endif // ALLOC_PRAGMA


NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT   DriverObject,
    IN PUNICODE_STRING  RegistryPathName
    )
/*++

Routine Description:

    Sets up the driver object to handle the KS interface and PnP Add Device
    request. Does not set up a handler for PnP Irp's, as they are all dealt
    with directly by the PDO.

Arguments:

    DriverObject -
        Driver object for this instance.

    RegistryPathName -
        Contains the registry path which was used to load this instance.

Return Values:

    Returns STATUS_SUCCESS.

--*/
{
    DriverObject->MajorFunction[IRP_MJ_PNP] = KsDefaultDispatchPnp;
    DriverObject->MajorFunction[IRP_MJ_POWER] = KsDefaultDispatchPower;
    DriverObject->DriverExtension->AddDevice = PnpAddDevice;
    DriverObject->DriverUnload = KsNullDriverUnload;
    KsSetMajorFunctionHandler(DriverObject, IRP_MJ_CREATE);
    KsSetMajorFunctionHandler(DriverObject, IRP_MJ_CLOSE);
    KsSetMajorFunctionHandler(DriverObject, IRP_MJ_DEVICE_CONTROL);
    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\ksfilter\msriffwv\filter.c ===
/*++

Copyright (C) Microsoft Corporation, 1996 - 1998

Module Name:

    filter.c

Abstract:

    Filter property sets.

--*/

#include "msriffwv.h"

#ifdef ALLOC_PRAGMA
NTSTATUS
FilterDispatchCreate(
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp
    );
NTSTATUS
FilterDispatchClose(
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp
    );
NTSTATUS
FilterDispatchIoControl(
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp
    );
NTSTATUS
FilterTopologyPropertyHandler(
    IN PIRP         Irp,
    IN PKSPROPERTY  Property,
    IN OUT PVOID    Data
    );
NTSTATUS
FilterPinPropertyHandler(
    IN PIRP         Irp,
    IN PKSPROPERTY  Property,
    IN OUT PVOID    Data
    );
NTSTATUS
FilterPinInstances(
    IN PIRP                 Irp,
    IN PKSP_PIN             Pin,
    OUT PKSPIN_CINSTANCES   Instances
    );
NTSTATUS
IntersectHandler(
    IN PIRP             Irp,
    IN PKSP_PIN         Pin,
    IN PKSDATARANGE     DataRange,
    OUT PVOID           Data
    );
NTSTATUS
FilterPinIntersection(
    IN PIRP     Irp,
    IN PKSP_PIN Pin,
    OUT PVOID   Data
    );
NTSTATUS
SeekingCapabilities(
    IN PIRP Irp,
    IN PKSPROPERTY Property,
    OUT KS_SEEKING_CAPABILITIES* Capabilities
    );
NTSTATUS
SeekingFormats(
    IN PIRP Irp,
    IN PKSPROPERTY Property,
    OUT PVOID Data
    );
NTSTATUS
GetSeekingTimeFormat(
    IN PIRP Irp,
    IN PKSPROPERTY Property,
    OUT GUID* TimeFormat
    );
NTSTATUS
SetSeekingTimeFormat(
    IN PIRP Irp,
    IN PKSPROPERTY Property,
    IN GUID* TimeFormat
    );
NTSTATUS
SeekingPosition(
    IN PIRP Irp,
    IN PKSPROPERTY Property,
    OUT LONGLONG* Position
    );
NTSTATUS
SeekingPositions(
    IN PIRP Irp,
    IN PKSPROPERTY Property,
    IN PKSPROPERTY_POSITIONS Positions
    );
NTSTATUS
SeekingDuration(
    IN PIRP Irp,
    IN PKSPROPERTY Property,
    OUT LONGLONG* Duration
    );
NTSTATUS
SeekingAvailable(
    IN PIRP Irp,
    IN PKSPROPERTY Property,
    OUT PKSPROPERTY_MEDIAAVAILABLE Available
    );
#pragma alloc_text(PAGE, PnpAddDevice)
#pragma alloc_text(PAGE, FilterDispatchCreate)
#pragma alloc_text(PAGE, FilterDispatchClose)
#pragma alloc_text(PAGE, FilterDispatchIoControl)
#pragma alloc_text(PAGE, FilterTopologyPropertyHandler)
#pragma alloc_text(PAGE, FilterPinPropertyHandler)
#pragma alloc_text(PAGE, FilterPinInstances)
#pragma alloc_text(PAGE, IntersectHandler)
#pragma alloc_text(PAGE, FilterPinIntersection)
#pragma alloc_text(PAGE, SeekingCapabilities)
#pragma alloc_text(PAGE, SeekingFormats)
#pragma alloc_text(PAGE, GetSeekingTimeFormat)
#pragma alloc_text(PAGE, SetSeekingTimeFormat)
#pragma alloc_text(PAGE, SeekingPosition)
#pragma alloc_text(PAGE, SeekingPositions)
#pragma alloc_text(PAGE, SeekingDuration)
#pragma alloc_text(PAGE, SeekingAvailable)
#endif // ALLOC_PRAGMA

#ifdef ALLOC_DATA_PRAGMA
#pragma const_seg("PAGECONST")
#endif // ALLOC_DATA_PRAGMA
static const WCHAR DeviceTypeName[] = KSSTRING_Filter;

static const DEFINE_KSCREATE_DISPATCH_TABLE(DeviceCreateItems) {
    DEFINE_KSCREATE_ITEM(FilterDispatchCreate, DeviceTypeName, 0)
};

static const WCHAR PinTypeName[] = KSSTRING_Pin;

static const DEFINE_KSCREATE_DISPATCH_TABLE(FilterCreateItems) {
    DEFINE_KSCREATE_ITEM(PinDispatchCreate, PinTypeName, 0),
};

static DEFINE_KSDISPATCH_TABLE(
    FilterDispatchTable,
    FilterDispatchIoControl,
    NULL,
    NULL,
    NULL,
    FilterDispatchClose,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL);

//
// This can go away when put into the INF file
//
static const GUID FunctionalCategories[] = {
    STATICGUIDOF(KSCATEGORY_INTERFACETRANSFORM),
    STATICGUIDOF(KSCATEGORY_AUDIO)
};

static const GUID Nodes[] = {
    STATICGUIDOF(KSCATEGORY_MEDIUMTRANSFORM)
};

static const KSTOPOLOGY_CONNECTION Connections[] = {
    { KSFILTER_NODE, ID_RIFFIO_PIN, 0, 0 },
    { 0, 1, KSFILTER_NODE, ID_WAVEIO_PIN }
};

static const KSTOPOLOGY FilterTopology = {
    SIZEOF_ARRAY(FunctionalCategories),
    (GUID*)FunctionalCategories,
    SIZEOF_ARRAY(Nodes),
    (GUID*)Nodes,
    SIZEOF_ARRAY(Connections),
    Connections
};

static DEFINE_KSPROPERTY_PINSET(
    FilterPinProperties,
    FilterPinPropertyHandler,
    FilterPinInstances,
    FilterPinIntersection);

static DEFINE_KSPROPERTY_TABLE(FilterSeekingProperties) {
    DEFINE_KSPROPERTY_ITEM_MEDIASEEKING_CAPABILITIES(SeekingCapabilities),
    DEFINE_KSPROPERTY_ITEM_MEDIASEEKING_FORMATS(SeekingFormats),
    DEFINE_KSPROPERTY_ITEM_MEDIASEEKING_TIMEFORMAT(GetSeekingTimeFormat, SetSeekingTimeFormat),
    DEFINE_KSPROPERTY_ITEM_MEDIASEEKING_POSITION(SeekingPosition),
    DEFINE_KSPROPERTY_ITEM_MEDIASEEKING_POSITIONS(SeekingPositions),
    DEFINE_KSPROPERTY_ITEM_MEDIASEEKING_DURATION(SeekingDuration),
    DEFINE_KSPROPERTY_ITEM_MEDIASEEKING_AVAILABLE(SeekingAvailable),
};

static DEFINE_KSPROPERTY_TOPOLOGYSET(
    FilterTopologyProperties,
    FilterTopologyPropertyHandler);

static DEFINE_KSPROPERTY_SET_TABLE(FilterPropertySets) {
    DEFINE_KSPROPERTY_SET(
        &KSPROPSETID_Pin,
        SIZEOF_ARRAY(FilterPinProperties),
        FilterPinProperties,
        0,
        NULL),
    DEFINE_KSPROPERTY_SET(
        &KSPROPSETID_MediaSeeking,
        SIZEOF_ARRAY(FilterSeekingProperties),
        FilterSeekingProperties,
        0,
        NULL),
    DEFINE_KSPROPERTY_SET(
        &KSPROPSETID_Topology,
        SIZEOF_ARRAY(FilterTopologyProperties),
        FilterTopologyProperties,
        0,
        NULL)
};

static DEFINE_KSPIN_INTERFACE_TABLE(PinInterfaces) {
    DEFINE_KSPIN_INTERFACE_ITEM(
        KSINTERFACESETID_Standard,
        KSINTERFACE_STANDARD_STREAMING)
};

static DEFINE_KSPIN_MEDIUM_TABLE(PinMediums) {
    DEFINE_KSPIN_MEDIUM_ITEM(
        KSMEDIUMSETID_Standard,
        KSMEDIUM_TYPE_ANYINSTANCE)
};

static const KSDATARANGE PinRiffIoRange = {
    sizeof(KSDATARANGE),
    0,
    0,
    0,
    STATICGUIDOF(KSDATAFORMAT_TYPE_STREAM),
    STATICGUIDOF(KSDATAFORMAT_SUBTYPE_RIFFWAVE),
    STATICGUIDOF(KSDATAFORMAT_SPECIFIER_NONE)
};

static const PKSDATARANGE PinRiffIoRanges[] = {
    (PKSDATARANGE)&PinRiffIoRange
};

static const KSDATARANGE_AUDIO PinWaveIoRange = {
    {
        sizeof(KSDATARANGE_AUDIO),
        0,
        0,
        0,
        STATICGUIDOF(KSDATAFORMAT_TYPE_AUDIO),
        STATICGUIDOF(KSDATAFORMAT_SUBTYPE_WILDCARD),
        STATICGUIDOF(KSDATAFORMAT_SPECIFIER_WAVEFORMATEX)
    },
    ULONG_MAX,
    1,
    ULONG_MAX,
    1,
    ULONG_MAX
};

static const PKSDATARANGE PinWaveIoRanges[] = {
    (PKSDATARANGE)&PinWaveIoRange
};

DEFINE_KSPIN_DESCRIPTOR_TABLE(PinDescriptors) {
#if ID_RIFFIO_PIN != 0
#error ID_RIFFIO_PIN incorrect
#endif // ID_RIFFIO_PIN != 0
    DEFINE_KSPIN_DESCRIPTOR_ITEM(
        SIZEOF_ARRAY(PinInterfaces),
        PinInterfaces,
        SIZEOF_ARRAY(PinMediums),
        PinMediums,
        SIZEOF_ARRAY(PinRiffIoRanges),
        (PKSDATARANGE*)PinRiffIoRanges,
        KSPIN_DATAFLOW_IN,
        KSPIN_COMMUNICATION_SOURCE),
#if ID_WAVEIO_PIN != 1
#error ID_WAVEIO_PIN incorrect
#endif // ID_WAVEIO_PIN != 1
    DEFINE_KSPIN_DESCRIPTOR_ITEM(
        SIZEOF_ARRAY(PinInterfaces),
        PinInterfaces,
        SIZEOF_ARRAY(PinMediums),
        PinMediums,
        SIZEOF_ARRAY(PinWaveIoRanges),
        (PKSDATARANGE*)PinWaveIoRanges,
        KSPIN_DATAFLOW_OUT,
        KSPIN_COMMUNICATION_SINK)
};
#ifdef ALLOC_DATA_PRAGMA
#pragma const_seg()
#endif // ALLOC_DATA_PRAGMA


NTSTATUS
PnpAddDevice(
    IN PDRIVER_OBJECT   DriverObject,
    IN PDEVICE_OBJECT   PhysicalDeviceObject
    )
/*++

Routine Description:

    When a new device is detected, PnP calls this entry point with the
    new PhysicalDeviceObject (PDO). The driver creates an associated 
    FunctionalDeviceObject (FDO).

Arguments:

    DriverObject -
        Pointer to the driver object.

    PhysicalDeviceObject -
        Pointer to the new physical device object.

Return Values:

    STATUS_SUCCESS or an appropriate error condition.

--*/
{
    PDEVICE_OBJECT      FunctionalDeviceObject;
    PDEVICE_INSTANCE    DeviceInstance;
    NTSTATUS            Status;

    _DbgPrintF(DEBUGLVL_TERSE, ("PnpAddDevice"));
    Status = IoCreateDevice(
        DriverObject,
        sizeof(DEVICE_INSTANCE),
        NULL,
        FILE_DEVICE_KS,
        0,
        FALSE,
        &FunctionalDeviceObject);
    if (!NT_SUCCESS(Status)) {
        return Status;
    }
    DeviceInstance = (PDEVICE_INSTANCE)FunctionalDeviceObject->DeviceExtension;
    //
    // This object uses KS to perform access through the DeviceCreateItems.
    //
    Status = KsAllocateDeviceHeader(
        &DeviceInstance->Header,
        SIZEOF_ARRAY(DeviceCreateItems),
        (PKSOBJECT_CREATE_ITEM)DeviceCreateItems);
    if (NT_SUCCESS(Status)) {
        KsSetDevicePnpAndBaseObject(
            DeviceInstance->Header,
            IoAttachDeviceToDeviceStack(FunctionalDeviceObject, PhysicalDeviceObject),
            FunctionalDeviceObject);
        FunctionalDeviceObject->Flags |= DO_POWER_PAGABLE;
        FunctionalDeviceObject->Flags &= ~DO_DEVICE_INITIALIZING;
        return STATUS_SUCCESS;
    }
    IoDeleteDevice(FunctionalDeviceObject);
_DbgPrintF(DEBUGLVL_TERSE, ("PnpAddDevice=%x", Status));
    return Status;
}


NTSTATUS
FilterDispatchCreate(
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp
    )
/*++

Routine Description:

    Dispatches the creation of a Filter instance. Allocates the object header and initializes
    the data for this Filter instance.

Arguments:

    DeviceObject -
        Device object on which the creation is occuring.

    Irp -
        Creation Irp.

Return Values:

    Returns STATUS_SUCCESS on success, STATUS_INSUFFICIENT_RESOURCES or some related error
    on failure.

--*/
{
    NTSTATUS            Status;

_DbgPrintF(DEBUGLVL_TERSE, ("FilterDispatchCreate"));
    //
    // Notify the software bus that this device is in use.
    //
    Status = KsReferenceSoftwareBusObject(((PDEVICE_INSTANCE)DeviceObject->DeviceExtension)->Header);
    if (NT_SUCCESS(Status)) {
        PFILTER_INSTANCE    FilterInstance;

        //
        // Create the instance information. This contains the list of current Pins, and
        // the mutex used when modifying pins.
        //
        if (FilterInstance = (PFILTER_INSTANCE)ExAllocatePoolWithTag(NonPagedPool, sizeof(FILTER_INSTANCE), 'IFsK')) {
            //
            // This object uses KS to perform access through the FilterCreateItems and
            // FilterDispatchTable.
            //
            Status = KsAllocateObjectHeader(&FilterInstance->Header,
                SIZEOF_ARRAY(FilterCreateItems),
                (PKSOBJECT_CREATE_ITEM)FilterCreateItems,
                Irp,
                &FilterDispatchTable);
            if (NT_SUCCESS(Status)) {
                ULONG       PinCount;

                ExInitializeFastMutex(&FilterInstance->ControlMutex);
                //
                // This is the shared wave data format structure. The first pin connected
                // allocates it, and the last pin closed frees it. It limits the format
                // which a subsequent connection can be made with, and the data format
                // returned from a DataIntersection query.
                //
                FilterInstance->WaveFormat = NULL;
                //
                // Initialize the list of Pins on this Filter to an unconnected state.
                //
                for (PinCount = SIZEOF_ARRAY(FilterInstance->PinFileObjects); PinCount;) {
                    FilterInstance->PinFileObjects[--PinCount] = NULL;
                }
                //
                // KS expects that the object data is in FsContext.
                //
                IoGetCurrentIrpStackLocation(Irp)->FileObject->FsContext = FilterInstance;
            } else {
                ExFreePool(FilterInstance);
                KsDereferenceSoftwareBusObject(((PDEVICE_INSTANCE)DeviceObject->DeviceExtension)->Header);
            }
        } else {
            KsDereferenceSoftwareBusObject(((PDEVICE_INSTANCE)DeviceObject->DeviceExtension)->Header);
            Status = STATUS_INSUFFICIENT_RESOURCES;
        }
    }
    Irp->IoStatus.Status = Status;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);
_DbgPrintF(DEBUGLVL_TERSE, ("FilterDispatchCreate=%x", Status));
    return Status;
}


NTSTATUS
FilterDispatchClose(
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp
    )
/*++

Routine Description:

    Closes a previously opened Filter instance. This can only occur after the Pins have been
    closed, as they reference the Filter object when created. This also implies that all the
    resources the Pins use have been released or cleaned up.

Arguments:

    DeviceObject -
        Device object on which the close is occuring.

    Irp -
        Close Irp.

Return Values:

    Returns STATUS_SUCCESS.

--*/
{
    PFILTER_INSTANCE    FilterInstance;

    FilterInstance = (PFILTER_INSTANCE)IoGetCurrentIrpStackLocation(Irp)->FileObject->FsContext;
    //
    // These were allocated during the creation of the Filter instance.
    //
    KsFreeObjectHeader(FilterInstance->Header);
    ExFreePool(FilterInstance);
    //
    // Notify the software bus that the device has been closed.
    //

    KsDereferenceSoftwareBusObject(((PDEVICE_INSTANCE)DeviceObject->DeviceExtension)->Header);
    Irp->IoStatus.Status = STATUS_SUCCESS;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);
    return STATUS_SUCCESS;
}


NTSTATUS
FilterDispatchIoControl(
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp
    )
/*++

Routine Description:

    Dispatches property requests on a Filter instance. These are enumerated in the
    FilterPropertySets list.

Arguments:

    DeviceObject -
        Device object on which the device control is occuring.

    Irp -
        Device control Irp.

Return Values:

    Returns STATUS_SUCCESS if the property was successfully manipulated, else an error.

--*/
{
    PIO_STACK_LOCATION  IrpStack;
    NTSTATUS            Status;

    IrpStack = IoGetCurrentIrpStackLocation(Irp);
    switch (IrpStack->Parameters.DeviceIoControl.IoControlCode) {
    case IOCTL_KS_PROPERTY:
        Status = KsPropertyHandler(Irp, SIZEOF_ARRAY(FilterPropertySets), FilterPropertySets);
        break;
    default:
        return KsDefaultDeviceIoCompletion(DeviceObject, Irp);
    }
    Irp->IoStatus.Status = Status;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);
    return Status;
}


NTSTATUS
FilterTopologyPropertyHandler(
    IN PIRP         Irp,
    IN PKSPROPERTY  Property,
    IN OUT PVOID    Data
    )
/*++

Routine Description:

    This is the general handler for all Topology property requests, and is used to route
    the request to the KsTopologyPropertyHandler using the FilterTopology
    information. This request would have been routed through FilterDispatchIoControl,
    then KsPropertyHandler, which would have then called the handler for the property
    item, which is this function.

Arguments:

    Irp -
        Device control Irp.

    Property -
        Specific property request.

    Data -
        Property data.

Return Values:

    Returns STATUS_SUCCESS if the property was successfully manipulated, else an error.

--*/
{
    return KsTopologyPropertyHandler(Irp, Property, Data, &FilterTopology);
}


NTSTATUS
FilterPinPropertyHandler(
    IN PIRP         Irp,
    IN PKSPROPERTY  Property,
    IN OUT PVOID    Data
    )
/*++

Routine Description:

    This is the general handler for most Pin property requests, and is used to route
    the request to the KsPinPropertyHandler using the PinDescriptors
    information. This request would have been routed through FilterDispatchIoControl,
    then KsPropertyHandler, which would have then called the handler for the property
    item, which is this function.

Arguments:

    Irp -
        Device control Irp.

    Property -
        Specific property request. This actually contains a PKSP_PIN pointer in
        most cases.

    Data -
        Property data.

Return Values:

    Returns STATUS_SUCCESS if the property was successfully manipulated, else an error.

--*/
{
    return KsPinPropertyHandler(Irp, Property, Data, SIZEOF_ARRAY(PinDescriptors), PinDescriptors);
}


NTSTATUS
FilterPinInstances(
    IN PIRP                 Irp,
    IN PKSP_PIN             Pin,
    OUT PKSPIN_CINSTANCES   Instances
    )
/*++

Routine Description:

    Handles the KSPROPERTY_PIN_CINSTANCES property in the Pin property set. Returns the
    total possible and current number of Pin instances available for a Pin factory.

Arguments:

    Irp -
        Device control Irp.

    Pin -
        Specific property request followed by Pin factory identifier.

    Instances -
        The place in which to return the instance information of the specified Pin factory.

Return Values:

    returns STATUS_SUCCESS, else STATUS_INVALID_PARAMETER.

--*/
{
    PFILTER_INSTANCE    FilterInstance;

    //
    // Ensure that the Pin factory being queried is valid.
    //
    if (Pin->PinId >= SIZEOF_ARRAY(PinDescriptors)) {
        return STATUS_INVALID_PARAMETER;
    }
    //
    // There is always only one instance total, but the current number depends on whether
    // there is a file object in this slot in the Filter instance. This does not take the
    // filter mutex, since it is just retrieving whether or not the value is NULL at that
    // particular instant, and it does not matter if the value subsequently changes.
    //
    Instances->PossibleCount = 1;
    FilterInstance = (PFILTER_INSTANCE)IoGetCurrentIrpStackLocation(Irp)->FileObject->FsContext;
    Instances->CurrentCount = FilterInstance->PinFileObjects[Pin->PinId] ? 1 : 0;
    Irp->IoStatus.Information = sizeof(*Instances);
    return STATUS_SUCCESS;
}


NTSTATUS
IntersectHandler(
    IN PIRP             Irp,
    IN PKSP_PIN         Pin,
    IN PKSDATARANGE     DataRange,
    OUT PVOID           Data
    )
/*++

Routine Description:

    This is the data range callback for KsPinDataIntersection, which is called by
    FilterPinIntersection to enumerate the given list of data ranges, looking for
    an acceptable match. If a data range is acceptable, a data format is copied
    into the return buffer. If there is a wave format selected in a current pin
    connection, and it is contained within the data range passed in, it is chosen
    as the data format to return. A STATUS_NO_MATCH continues the enumeration.

Arguments:

    Irp -
        Device control Irp.

    Pin -
        Specific property request followed by Pin factory identifier, followed by a
        KSMULTIPLE_ITEM structure. This is followed by zero or more data range structures.
        This enumeration callback does not need to look at any of this though. It need
        only look at the specific pin identifier.

    DataRange -
        Contains a specific data range to validate.

    Data -
        The place in which to return the data format selected as the first intersection
        between the list of data ranges passed, and the acceptable formats.

Return Values:

    returns STATUS_SUCCESS or STATUS_NO_MATCH, else STATUS_INVALID_PARAMETER,
    STATUS_BUFFER_TOO_SMALL, or STATUS_INVALID_BUFFER_SIZE.

--*/
{
    PIO_STACK_LOCATION  IrpStack;
    NTSTATUS            Status;
    PFILTER_INSTANCE    FilterInstance;

    IrpStack = IoGetCurrentIrpStackLocation(Irp);
    FilterInstance = (PFILTER_INSTANCE)IrpStack->FileObject->FsContext;
    //
    // Assume failure and set this in one place.
    //
    Status = STATUS_NO_MATCH;
    //
    // Acquire the filter lock so that the connection cannot be ripped out
    // from under this call. This filter does not perform mid-stream data
    // format changes without reconnection, so there is no other way the
    // data format can be changed. This allows the valid format returned
    // to be restricted to the current data format.
    //
    ExAcquireFastMutexUnsafe(&FilterInstance->ControlMutex);
    if (Pin->PinId == ID_WAVEIO_PIN) {
        //
        // First check the constants: size, major format, specifier.
        //
        if ((DataRange->FormatSize == sizeof(KSDATARANGE_AUDIO)) &&
            IsEqualGUIDAligned(&DataRange->MajorFormat, &PinWaveIoRange.DataRange.MajorFormat) &&
            IsEqualGUIDAligned(&DataRange->Specifier, &PinWaveIoRange.DataRange.Specifier)) {
            if (FilterInstance->WaveFormat) {
                PKSDATARANGE_AUDIO  AudioRange;

                AudioRange = (PKSDATARANGE_AUDIO)DataRange;
                if
                    //
                    // If the SubFormat is a wildcard or the specific type
                    // already selected.
                    //
                    ((IsEqualGUIDAligned(&AudioRange->DataRange.SubFormat,
                    &PinWaveIoRange.DataRange.SubFormat) ||
                    IsEqualGUIDAligned(&AudioRange->DataRange.SubFormat,
                    &FilterInstance->WaveFormat->DataFormat.SubFormat)) &&
                    //
                    // And the ranges specified all overlap with the current
                    // data type.
                    //
                    (AudioRange->MaximumChannels >= 
                    FilterInstance->WaveFormat->WaveFormatEx.nChannels) &&
                    (AudioRange->MaximumSampleFrequency >= 
                    FilterInstance->WaveFormat->WaveFormatEx.nSamplesPerSec) &&
                    (AudioRange->MinimumSampleFrequency <= 
                    FilterInstance->WaveFormat->WaveFormatEx.nSamplesPerSec) &&
                    (AudioRange->MaximumBitsPerSample >= 
                    FilterInstance->WaveFormat->WaveFormatEx.wBitsPerSample) &&
                    (AudioRange->MinimumBitsPerSample <= 
                    FilterInstance->WaveFormat->WaveFormatEx.wBitsPerSample)) {
                    //
                    // Since there is a connection, match on the specific stream
                    // format connected to.
                    //
                    Status = STATUS_SUCCESS;
                }

            } else if (IsEqualGUIDAligned(&DataRange->SubFormat, &PinWaveIoRange.DataRange.SubFormat) ||
                IS_VALID_WAVEFORMATEX_GUID(&DataRange->SubFormat)) {
                //
                // There is no connection present, so just match on the wildcard
                // or a valid WaveFormatEx format type.
                //
                Status = STATUS_SUCCESS;
            }
        }
    } else if (RtlEqualMemory(DataRange, &PinRiffIoRange, sizeof(KSDATARANGE))) {
        //
        // Since the range and format are the same, a simple comparison is all
        // that is needed for this pin.
        //
        Status = STATUS_SUCCESS;
    }
    //
    // If the range matched, then return the information requested.
    //
    if (NT_SUCCESS(Status)) {
        ULONG           OutputBufferLength;

        //
        // Determine whether the data format itself is to be returned, or just the size
        // of the data format so that the client can allocate memory for the full range.
        //
        OutputBufferLength = IrpStack->Parameters.DeviceIoControl.OutputBufferLength;
        if (Pin->PinId == ID_RIFFIO_PIN) {
            if (!OutputBufferLength) {
                //
                // Assumes that the data range structures are the same size as data formats.
                //
                Irp->IoStatus.Information = DataRange->FormatSize;
                Status = STATUS_BUFFER_OVERFLOW;
            } else if (OutputBufferLength < DataRange->FormatSize) {
                Status = STATUS_BUFFER_TOO_SMALL;
            } else {
                //
                // Note that the format and the range are identical in this simple situation.
                //
                RtlCopyMemory(Data, DataRange, DataRange->FormatSize);
                Irp->IoStatus.Information = DataRange->FormatSize;
            }
        } else if (FilterInstance->WaveFormat) {
            if (!OutputBufferLength) {
                Irp->IoStatus.Information = FilterInstance->WaveFormat->DataFormat.FormatSize;
                Status = STATUS_BUFFER_OVERFLOW;
            } else if (OutputBufferLength < FilterInstance->WaveFormat->DataFormat.FormatSize) {
                Status = STATUS_BUFFER_TOO_SMALL;
            } else {
                RtlCopyMemory(Data, FilterInstance->WaveFormat, FilterInstance->WaveFormat->DataFormat.FormatSize);
                Irp->IoStatus.Information = FilterInstance->WaveFormat->DataFormat.FormatSize;
            }           
        } else {
            if (!OutputBufferLength) {
                Irp->IoStatus.Information = sizeof(KSDATAFORMAT_WAVEFORMATEX);
                Status = STATUS_BUFFER_OVERFLOW;
            } else if (OutputBufferLength < sizeof(KSDATAFORMAT_WAVEFORMATEX)) {
                Status = STATUS_BUFFER_TOO_SMALL;
            } else {
                PKSDATAFORMAT_WAVEFORMATEX  WaveFormat;
                PKSDATARANGE_AUDIO          AudioRange;

                //
                // This is a generic format.
                //
                WaveFormat = (PKSDATAFORMAT_WAVEFORMATEX)Data;
                AudioRange = (PKSDATARANGE_AUDIO)DataRange;
                WaveFormat->DataFormat = AudioRange->DataRange;
                WaveFormat->DataFormat.FormatSize = sizeof(KSDATAFORMAT_WAVEFORMATEX);
                if (IsEqualGUIDAligned(&DataRange->SubFormat, &PinWaveIoRange.DataRange.SubFormat)) {
                    //
                    // The range just contained a wildcard, so default to PCM.
                    //
                    WaveFormat->WaveFormatEx.wFormatTag = WAVE_FORMAT_PCM;
                    WaveFormat->DataFormat.SubFormat = KSDATAFORMAT_SUBTYPE_PCM;
                } else {
                    //
                    // Else use the type passed in.
                    //
                    WaveFormat->WaveFormatEx.wFormatTag = EXTRACT_WAVEFORMATEX_ID(&DataRange->SubFormat);
                    if (WaveFormat->WaveFormatEx.wFormatTag != WAVE_FORMAT_PCM) {
                        WaveFormat->DataFormat.Flags |= KSDATAFORMAT_TEMPORAL_COMPRESSION;
                    }
                }
                WaveFormat->WaveFormatEx.nChannels = (USHORT)AudioRange->MaximumChannels;
                WaveFormat->WaveFormatEx.nSamplesPerSec = AudioRange->MaximumSampleFrequency;
                WaveFormat->WaveFormatEx.wBitsPerSample = (USHORT)AudioRange->MaximumBitsPerSample;
                WaveFormat->WaveFormatEx.nBlockAlign =
                    (WaveFormat->WaveFormatEx.wBitsPerSample *
                     WaveFormat->WaveFormatEx.nChannels) / 8;
                WaveFormat->WaveFormatEx.nAvgBytesPerSec = 
                    WaveFormat->WaveFormatEx.nSamplesPerSec * 
                    WaveFormat->WaveFormatEx.nBlockAlign;
                WaveFormat->WaveFormatEx.cbSize = 0;
                WaveFormat->DataFormat.SampleSize = WaveFormat->WaveFormatEx.nBlockAlign;
                Irp->IoStatus.Information = sizeof(KSDATAFORMAT_WAVEFORMATEX);
            }
        }
    }
    ExReleaseFastMutexUnsafe(&FilterInstance->ControlMutex);
    return Status;
}


NTSTATUS
FilterPinIntersection(
    IN PIRP     Irp,
    IN PKSP_PIN Pin,
    OUT PVOID   Data
    )
/*++

Routine Description:

    Handles the KSPROPERTY_PIN_DATAINTERSECTION property in the Pin property set.
    Returns the first acceptable data format given a list of data ranges for a specified
    Pin factory. Actually just calls the Intersection Enumeration helper, which then
    calls the IntersectHandler callback with each data range.

Arguments:

    Irp -
        Device control Irp.

    Pin -
        Specific property request followed by Pin factory identifier, followed by a
        KSMULTIPLE_ITEM structure. This is followed by zero or more data range structures.

    Data -
        The place in which to return the data format selected as the first intersection
        between the list of data ranges passed, and the acceptable formats.

Return Values:

    returns STATUS_SUCCESS or STATUS_NO_MATCH, else STATUS_INVALID_PARAMETER,
    STATUS_BUFFER_TOO_SMALL, or STATUS_INVALID_BUFFER_SIZE.

--*/
{
    return KsPinDataIntersection(
        Irp,
        Pin,
        Data,
        SIZEOF_ARRAY(PinDescriptors),
        PinDescriptors,
        IntersectHandler);
}


NTSTATUS
SeekingCapabilities(
    IN PIRP Irp,
    IN PKSPROPERTY Property,
    OUT KS_SEEKING_CAPABILITIES* Capabilities
    )
{
    *Capabilities = 
        KS_SEEKING_CanSeekAbsolute |
        KS_SEEKING_CanSeekForwards |
        KS_SEEKING_CanSeekBackwards |
        KS_SEEKING_CanGetCurrentPos |
        KS_SEEKING_CanGetDuration;
    Irp->IoStatus.Information = sizeof(*Capabilities);
    return STATUS_SUCCESS;
}


NTSTATUS
SeekingFormats(
    IN PIRP Irp,
    IN PKSPROPERTY Property,
    OUT PVOID Data
    )
{
    return KsHandleSizedListQuery(Irp, 1, sizeof(GUID), &KSTIME_FORMAT_MEDIA_TIME);
}


NTSTATUS
GetSeekingTimeFormat(
    IN PIRP Irp,
    IN PKSPROPERTY Property,
    OUT GUID* TimeFormat
    )
{
    *TimeFormat = KSTIME_FORMAT_MEDIA_TIME;
    Irp->IoStatus.Information = sizeof(*TimeFormat);
    return STATUS_SUCCESS;
}


NTSTATUS
SetSeekingTimeFormat(
    IN PIRP Irp,
    IN PKSPROPERTY Property,
    IN GUID* TimeFormat
    )
{
    if (!IsEqualGUIDAligned(TimeFormat, &KSTIME_FORMAT_MEDIA_TIME)) {
        return STATUS_INVALID_PARAMETER;
    }
    return STATUS_SUCCESS;
}


NTSTATUS
SeekingPosition(
    IN PIRP Irp,
    IN PKSPROPERTY Property,
    OUT LONGLONG* Position
    )
{
    NTSTATUS                Status;
    PFILE_OBJECT            FileObject;
    PPIN_INSTANCE_RIFFIO    PinInstance;

    if (!(FileObject = ReferenceRiffIoObject(IoGetCurrentIrpStackLocation(Irp)->FileObject))) {
        return STATUS_DEVICE_NOT_CONNECTED;
    }
    PinInstance = (PPIN_INSTANCE_RIFFIO)FileObject->FsContext;
    //
    // The pin is locked, so this can be accessed directly.
    //
    *Position = PinInstance->PresentationByteTime * 80000000 / PinInstance->Denominator;
    ObDereferenceObject(FileObject);
    Irp->IoStatus.Information = sizeof(*Position);
    return STATUS_SUCCESS;
}


NTSTATUS
SeekingPositions(
    IN PIRP Irp,
    IN PKSPROPERTY Property,
    IN PKSPROPERTY_POSITIONS Positions
    )
{
    NTSTATUS                Status;
    PFILE_OBJECT            FileObject;
    PPIN_INSTANCE_RIFFIO    PinInstance;
    LONGLONG                NewPosition;

    if (Positions->StopFlags) {
        return STATUS_INVALID_PARAMETER;
    }
    if (!(FileObject = ReferenceRiffIoObject(IoGetCurrentIrpStackLocation(Irp)->FileObject))) {
        return STATUS_DEVICE_NOT_CONNECTED;
    }
    PinInstance = (PPIN_INSTANCE_RIFFIO)FileObject->FsContext;
    switch (Positions->CurrentFlags & KS_SEEKING_PositioningBitsMask) {
    case KS_SEEKING_NoPositioning:
    case KS_SEEKING_IncrementalPositioning:
        ObDereferenceObject(FileObject);
        return STATUS_INVALID_PARAMETER;
    case KS_SEEKING_AbsolutePositioning:
        NewPosition = Positions->Current;
        break;
    case KS_SEEKING_RelativePositioning:
        NewPosition = PinInstance->PresentationByteTime + Positions->Current;
        break;
    }
    if (Positions->Current > (LONGLONG)PinInstance->DataLength) {
        Status = STATUS_END_OF_FILE;
    } else {
        NewPosition = Positions->Current;
        Status = riffSetPosition(
            PinInstance->FileObject,
            NewPosition + PinInstance->DataOffset);
        if (NT_SUCCESS(Status)) {
            PinInstance->PresentationByteTime = NewPosition;
        }
    }
    ObDereferenceObject(FileObject);
    return Status;
}


NTSTATUS
SeekingDuration(
    IN PIRP Irp,
    IN PKSPROPERTY Property,
    OUT LONGLONG* Duration
    )
{
    NTSTATUS                Status;
    PFILE_OBJECT            FileObject;
    PPIN_INSTANCE_RIFFIO    PinInstance;

    if (!(FileObject = ReferenceRiffIoObject(IoGetCurrentIrpStackLocation(Irp)->FileObject))) {
        return STATUS_DEVICE_NOT_CONNECTED;
    }
    PinInstance = (PPIN_INSTANCE_RIFFIO)FileObject->FsContext;
    //
    // The pin is locked, so this can be accessed directly.
    //
    *Duration = PinInstance->DataLength * 80000000 / PinInstance->Denominator;
    ObDereferenceObject(FileObject);
    Irp->IoStatus.Information = sizeof(*Duration);
    return STATUS_SUCCESS;
}


NTSTATUS
SeekingAvailable(
    IN PIRP Irp,
    IN PKSPROPERTY Property,
    OUT PKSPROPERTY_MEDIAAVAILABLE Available
    )
{
    NTSTATUS                Status;
    PFILE_OBJECT            FileObject;
    PPIN_INSTANCE_RIFFIO    PinInstance;

    if (!(FileObject = ReferenceRiffIoObject(IoGetCurrentIrpStackLocation(Irp)->FileObject))) {
        return STATUS_DEVICE_NOT_CONNECTED;
    }
    PinInstance = (PPIN_INSTANCE_RIFFIO)FileObject->FsContext;
    //
    // The pin is locked, so this can be accessed directly.
    //
    Available->Earliest = PinInstance->PresentationByteTime * 80000000 / PinInstance->Denominator;
    Available->Latest = PinInstance->DataLength * 80000000 / PinInstance->Denominator;
    ObDereferenceObject(FileObject);
    Irp->IoStatus.Information = sizeof(*Available);
    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\ksfilter\mstee\private.h ===
/*++

    Copyright (C) Microsoft Corporation, 1997 - 1999

Module Name:

    Private.h

Abstract:


Author:

    Bryan A. Woodruff (bryanw) 13-Mar-1997

--*/


#if !defined( _PRIVATE_ )
#define _PRIVATE_

#include <wdm.h>
#include <windef.h>

#include <memory.h>
#include <stddef.h>
#include <stdio.h>
#include <limits.h>
#include <stdlib.h>
#include <tchar.h>
#include <conio.h>

#define NOBITMAP
#include <mmsystem.h>
#include <mmreg.h>
#undef NOBITMAP
#include <unknown.h>
#include <ks.h>
#include <ksmedia.h>
#if (DBG)
//
// debugging specific constants
//
#define STR_MODULENAME "mstee: "
#define DEBUG_VARIABLE MSTEEDebug
#endif
#include <ksdebug.h>

//---------------------------------------------------------------------------
//---------------------------------------------------------------------------

//
// constant definitions
//

#define ID_DATA_DESTINATION_PIN     0
#define ID_DATA_SOURCE_PIN          1

#define POOLTAG_ALLOCATORFRAMING 'ETSM'

//---------------------------------------------------------------------------
//---------------------------------------------------------------------------

//
// global data
//
                    
// filter.c:

extern const KSDEVICE_DESCRIPTOR DeviceDescriptor;
extern const KSALLOCATOR_FRAMING_EX AllocatorFraming;

//
// local prototypes
//

//---------------------------------------------------------------------------
// filter.c:

NTSTATUS
FilterProcess(
    IN PKSFILTER Filter,
    IN PKSPROCESSPIN_INDEXENTRY ProcessPinsIndex
    );

//---------------------------------------------------------------------------
// pins.c:

NTSTATUS
PinCreate(
    IN PKSPIN Pin,
    IN PIRP Irp
    );
NTSTATUS
PinClose(
    IN PKSPIN Pin,
    IN PIRP Irp
    );
NTSTATUS PinAllocatorFraming(
    IN PIRP Irp,
    IN PKSPROPERTY Property,
    IN OUT PKSALLOCATOR_FRAMING Framing
);

#endif // _PRIVATE_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\ksfilter\swenum\sources.inc ===
!IF 0

Copyright (C) Microsoft Corporation, 1997 - 1999

Module Name:

    sources.

!ENDIF

MAJORCOMP=ntos
MINORCOMP=dd

TARGETNAME=swenum
TARGETPATHLIB=$(DDK_LIB_DEST)
TARGETTYPE=DRIVER
TARGETPATH=obj
TARGETLIBS=$(DDK_LIB_PATH)\ks.lib\
    $(DDK_LIB_PATH)\ksguid.lib

DRIVERTYPE=WDM

MSC_WARNING_LEVEL=/W3 /WX

C_DEFINES=$(C_DEFINES) -DUNICODE -D_UNICODE
#C_DEFINES=$(C_DEFINES) -DUNICODE -D_UNICODE -DDEBUG_LEVEL=DEBUGLVL_BLAB

LINKER_FLAGS =$(LINKER_FLAGS) -map -merge:PAGECONST=PAGE

SOURCES=\
        $(TARGETNAME).rc    \
        $(TARGETNAME).c
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\ksfilter\swenum\private.h ===
/*++

    Copyright (C) Microsoft Corporation, 1997 - 1998

Module Name:

    private.h

Abstract:
    Private header file for SWENUM.

Author:

    Bryan A. Woodruff (bryanw) 20-Feb-1997

--*/

#if !defined( _PRIVATE_ )
#define _PRIVATE_

#include <wdm.h>
#include <windef.h>
#include <ks.h>
#include <swenum.h>
#if (DBG)
//
// debugging specific constants
//
#define STR_MODULENAME "swenum: "
#define DEBUG_VARIABLE SWENUMDebug
#endif
#include <ksdebug.h>

//
// Macros
//

NTSTATUS __inline
CompleteIrp(
    PIRP Irp,
    NTSTATUS Status,
    CCHAR PriorityBoost
    )
{
    Irp->IoStatus.Status = Status;
    IoCompleteRequest( Irp, PriorityBoost );
    return Status;
}


//
// Function prototypes
//

NTSTATUS
AddDevice(
    IN PDRIVER_OBJECT DriverObject,
    IN PDEVICE_OBJECT PhysicalDeviceObject
    );

NTSTATUS
DispatchCreate(
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    );
    
NTSTATUS
DispatchClose(
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    );
    
NTSTATUS
DispatchIoControl(
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    );
    
NTSTATUS
DispatchPnP(
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    );

NTSTATUS
DispatchPower(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );
    
NTSTATUS
DispatchSystemControl(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );
    
NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    );

VOID
DriverUnload(
    IN PDRIVER_OBJECT   DriverObject
    );
    
#endif // _PRIVATE_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\ksfilter\mstee\pins.c ===
/*++

    Copyright (C) Microsoft Corporation, 1997 - 1999

Module Name:

    pins.c

Abstract:

    This module handles the communication transform filters
    (e.g. source to source connections).

Author:

    Bryan A. Woodruff (bryanw) 13-Mar-1997

--*/

#include "private.h"

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, PinCreate)
#pragma alloc_text(PAGE, PinClose)
#pragma alloc_text(PAGE, PinAllocatorFraming)
#endif // ALLOC_PRAGMA

//===========================================================================
//===========================================================================


NTSTATUS
PinCreate(
    IN PKSPIN Pin,
    IN PIRP Irp
    )

/*++

Routine Description:

    Validates pin format on creation.

Arguments:

    Pin -
        Contains a pointer to the  pin structure.

    Irp -
        Contains a pointer to the create IRP.

Return:

    STATUS_SUCCESS or an appropriate error code

--*/

{
    PKSFILTER filter;
    PKSPIN otherPin;
    NTSTATUS status;
    BOOLEAN distribute = FALSE;
    PIKSCONTROL control;

    PAGED_CODE();

    ASSERT(Pin);
    ASSERT(Irp);

    //
    // Find another pin instance if there is one.
    //
    filter = KsPinGetParentFilter(Pin);
    otherPin = KsFilterGetFirstChildPin(filter,Pin->Id ^ 1);
    if (! otherPin) {
        otherPin = KsFilterGetFirstChildPin(filter,Pin->Id);
        if (otherPin == Pin) {
            otherPin = KsPinGetNextSiblingPin(otherPin);
        }
    }

    //
    // Verify the formats are the same if there is another pin.
    //
    if (otherPin) {
        if ((Pin->ConnectionFormat->FormatSize != 
             otherPin->ConnectionFormat->FormatSize) ||
            (Pin->ConnectionFormat->FormatSize != 
             RtlCompareMemory(
                Pin->ConnectionFormat,
                otherPin->ConnectionFormat,
                Pin->ConnectionFormat->FormatSize))) {
            _DbgPrintF(DEBUGLVL_TERSE,("format does not match existing pin's format") );
            return STATUS_INVALID_PARAMETER;
        }
    }

    //
    // Try to obtain the header size from the connected pin.
    //
    status = KsPinGetConnectedPinInterface(Pin,&IID_IKsControl,(PVOID *) &control);
    if (NT_SUCCESS(status)) {
        KSPROPERTY property;
        ULONG bytesReturned;
        
        property.Set = KSPROPSETID_StreamInterface;
        property.Id = KSPROPERTY_STREAMINTERFACE_HEADERSIZE;
        property.Flags = KSPROPERTY_TYPE_GET;
        
        status = 
            control->lpVtbl->KsProperty(
                control,
                &property,
                sizeof(property),
                &Pin->StreamHeaderSize,
                sizeof(Pin->StreamHeaderSize),
                &bytesReturned);
        if ((status == STATUS_NOT_FOUND) || 
            (status == STATUS_PROPSET_NOT_FOUND)) {
            //
            // If the connected pin did not supply a header size, use another
            // pin's value or the default.
            //
            Pin->StreamHeaderSize = otherPin ? otherPin->StreamHeaderSize : 0;
        } else if (NT_SUCCESS(status)) {
            //
            // The property worked.  The resulting value is just the additional
            // size, so add in the standard size.
            //
            Pin->StreamHeaderSize += sizeof(KSSTREAM_HEADER);

            //
            // If there are other pins, figure out if we need to update their
            // header sizes.  Other pins may have the default size (indicated
            // by a zero StreamHeaderSize), but disagreements otherwise are
            // not a good thing.
            //
            if (otherPin) {
                if (! otherPin->StreamHeaderSize) {
                    //
                    // The other 
                    //
                    distribute = TRUE;
                } else {
                    if (otherPin->StreamHeaderSize < Pin->StreamHeaderSize) {
                        distribute = TRUE;
                    } else {
                        Pin->StreamHeaderSize = otherPin->StreamHeaderSize;
                    }
                    if (otherPin->StreamHeaderSize != Pin->StreamHeaderSize) {
                        _DbgPrintF( 
                            DEBUGLVL_TERSE, 
                            ("stream header size disagreement (%d != %d)",
                            otherPin->StreamHeaderSize,
                            Pin->StreamHeaderSize) );
                    }
                }
            }
        }
    } else {
        //
        // This is a sink pin, so we inherit the header size or go with the 
        // default if there are no other pins.
        //
        control = NULL;
        Pin->StreamHeaderSize = otherPin ? otherPin->StreamHeaderSize : 0;
    }

    //
    // Copy allocator framing from the filter if it's there.  Otherwise, if
    // this is a source pin, try to get allocator framing from the connected 
    // pin.
    //
    if (Pin->Context) {
        status = KsEdit(Pin,&Pin->Descriptor,'ETSM');
        if (NT_SUCCESS(status)) {
            ((PKSPIN_DESCRIPTOR_EX)(Pin->Descriptor))->AllocatorFraming = 
                (PKSALLOCATOR_FRAMING_EX) Pin->Context;
        }
    } else if (control) {
        //
        // Sink pin.  Try the extended allocator framing property first.
        //
        KSPROPERTY property;
        ULONG bufferSize;
        
        property.Set = KSPROPSETID_Connection;
        property.Id = KSPROPERTY_CONNECTION_ALLOCATORFRAMING_EX;
        property.Flags = KSPROPERTY_TYPE_GET;
        
        status = 
            control->lpVtbl->KsProperty(
                control,
                &property,
                sizeof(property),
                NULL,
                0,
                &bufferSize);

        if (status == STATUS_BUFFER_OVERFLOW) {
            //
            // It worked!  Now we need to get the actual value into a buffer.
            //
            filter->Context = 
                ExAllocatePoolWithTag(PagedPool,bufferSize,POOLTAG_ALLOCATORFRAMING);

            if (filter->Context) {
                PKSALLOCATOR_FRAMING_EX framingEx = 
                    (PKSALLOCATOR_FRAMING_EX) filter->Context;

                status = 
                    control->lpVtbl->KsProperty(
                        control,
                        &property,
                        sizeof(property),
                        filter->Context,
                        bufferSize,
                        &bufferSize);

                //
                // Sanity check.
                //
                if (NT_SUCCESS(status) && 
                    (bufferSize != 
                        ((framingEx->CountItems) * sizeof(KS_FRAMING_ITEM)) + 
                        sizeof(KSALLOCATOR_FRAMING_EX) - 
                        sizeof(KS_FRAMING_ITEM))) {
                    _DbgPrintF( 
                        DEBUGLVL_TERSE, 
                        ("connected pin's allocator framing property size disagrees with item count"));
                    status = STATUS_UNSUCCESSFUL;
                }

                if (NT_SUCCESS(status)) {
                    //
                    // Mark all the items 'in-place'.
                    //
                    ULONG item;
                    for (item = 0; item < framingEx->CountItems; item++) {
                        framingEx->FramingItem[item].Flags |= 
                            KSALLOCATOR_REQUIREMENTF_INPLACE_MODIFIER |
                            KSALLOCATOR_FLAG_INSIST_ON_FRAMESIZE_RATIO |
                            KSALLOCATOR_REQUIREMENTF_PREFERENCES_ONLY;
                    }
                } else {
                    ExFreePool(filter->Context);
                    filter->Context = NULL;
                }
            } else {
                status = STATUS_INSUFFICIENT_RESOURCES;
            }
        } else {
            //
            // No extended framing.  Try regular framing next.
            //
            KSALLOCATOR_FRAMING framing;
            property.Id = KSPROPERTY_CONNECTION_ALLOCATORFRAMING;

            status = 
                control->lpVtbl->KsProperty(
                    control,
                    &property,
                    sizeof(property),
                    &framing,
                    sizeof(framing),
                    &bufferSize);

            if (NT_SUCCESS(status)) {
                //
                // It worked!  Now we make a copy of the default framing and
                // modify it.
                //
                filter->Context = 
                    ExAllocatePoolWithTag(
                        PagedPool,
                        sizeof(AllocatorFraming),
                        POOLTAG_ALLOCATORFRAMING);

                if (filter->Context) {
                    PKSALLOCATOR_FRAMING_EX framingEx = 
                        (PKSALLOCATOR_FRAMING_EX) filter->Context;

                    //
                    // Use the old-style framing acquired from the connected
                    // pin to modify the framing from the descriptor.
                    //
                    RtlCopyMemory(
                        framingEx,
                        &AllocatorFraming,
                        sizeof(AllocatorFraming));

                    framingEx->FramingItem[0].MemoryType = 
                        (framing.PoolType == NonPagedPool) ? 
                            KSMEMORY_TYPE_KERNEL_NONPAGED : 
                            KSMEMORY_TYPE_KERNEL_PAGED;
                    framingEx->FramingItem[0].Flags = 
                        framing.RequirementsFlags | 
                        KSALLOCATOR_REQUIREMENTF_INPLACE_MODIFIER |
                        KSALLOCATOR_FLAG_INSIST_ON_FRAMESIZE_RATIO |
                        KSALLOCATOR_REQUIREMENTF_PREFERENCES_ONLY;
                    framingEx->FramingItem[0].Frames = framing.Frames;
                    framingEx->FramingItem[0].FileAlignment = 
                        framing.FileAlignment;
                    framingEx->FramingItem[0].FramingRange.Range.MaxFrameSize = 
                    framingEx->FramingItem[0].FramingRange.Range.MinFrameSize = 
                        framing.FrameSize;
                    if (framing.RequirementsFlags & 
                        KSALLOCATOR_REQUIREMENTF_PREFERENCES_ONLY) {
                        framingEx->FramingItem[0].FramingRange.InPlaceWeight = 0;
                        framingEx->FramingItem[0].FramingRange.NotInPlaceWeight = 0;
                    } else {
                        framingEx->FramingItem[0].FramingRange.InPlaceWeight = (ULONG) -1;
                        framingEx->FramingItem[0].FramingRange.NotInPlaceWeight = (ULONG) -1;
                    }
                } else {
                    status = STATUS_INSUFFICIENT_RESOURCES;
                }
            } else {
                //
                // No framing at all.  Oh well.
                //
                status = STATUS_SUCCESS;
            }
        }

        //
        // If we got a good framing structure, tell all the existing pins.
        //
        if (filter->Context) {
            distribute = TRUE;
        }
    } else {
        //
        // This is a sink.
        //
        status = STATUS_SUCCESS;
    }

    //
    // Distribute allocator and header size information to all the pins.
    //
    if (NT_SUCCESS(status) && distribute) {
        ULONG pinId;
        for(pinId = 0; 
            NT_SUCCESS(status) && 
                (pinId < filter->Descriptor->PinDescriptorsCount); 
            pinId++) {
            otherPin = KsFilterGetFirstChildPin(filter,pinId);
            while (otherPin && NT_SUCCESS(status)) {
                status = KsEdit(otherPin,&otherPin->Descriptor,'ETSM');
                if (NT_SUCCESS(status)) {
                    ((PKSPIN_DESCRIPTOR_EX)(otherPin->Descriptor))->
                        AllocatorFraming = 
                            filter->Context;
                }
                otherPin->StreamHeaderSize = Pin->StreamHeaderSize;
                otherPin = KsPinGetNextSiblingPin(otherPin);
            }
        }
    }

    //
    // Release the control interface if there is one.
    //
    if (control) {
        control->lpVtbl->Release(control);
    }

    return status;
}


NTSTATUS
PinClose(
    IN PKSPIN Pin,
    IN PIRP Irp
    )

/*++

Routine Description:
    Called when a pin closes.

Arguments:
    Pin -
        Contains a pointer to the  pin structure.

    Irp -
        Contains a pointer to the create IRP.

Return:
    STATUS_SUCCESS or an appropriate error code

--*/

{
    PKSFILTER filter;

    PAGED_CODE();

    ASSERT(Pin);
    ASSERT(Irp);

    //
    // If the filter has the allocator framing and this is the last pin, free
    // the structure.
    //
    filter = KsPinGetParentFilter(Pin);
    if (filter->Context) {
        ULONG pinId;
        ULONG pinCount = 0;
        for(pinId = 0; 
            pinId < filter->Descriptor->PinDescriptorsCount; 
            pinId++) {
            pinCount += KsFilterGetChildPinCount(filter,pinId);
        }

        //
        // Free the allocator framing attached to the filter if this is the last
        // pin.
        //
        if (pinCount == 1) {
            ExFreePool(filter->Context);
            filter->Context = NULL;
        }
    }

    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\ksfilter\mstee\filter.c ===
/*++

    Copyright (C) Microsoft Corporation, 1997 - 1999

Module Name:

    filter.c

Abstract:

    This module implements the filter object interface.

Author:

    Bryan A. Woodruff (bryanw) 13-Mar-1997

--*/


#include "private.h"

#ifdef ALLOC_PRAGMA
NTSTATUS
IntersectHandler(
    IN PVOID Filter,
    IN PIRP Irp,
    IN PKSP_PIN PinInstance,
    IN PKSDATARANGE CallerDataRange,
    IN PKSDATARANGE DescriptorDataRange,
    IN ULONG BufferSize,
    OUT PVOID Data OPTIONAL,
    OUT PULONG DataSize
    );

#pragma alloc_text(PAGE, FilterProcess)
#pragma alloc_text(PAGE, IntersectHandler)
#endif // ALLOC_PRAGMA

//---------------------------------------------------------------------------
//---------------------------------------------------------------------------

#ifdef ALLOC_DATA_PRAGMA
#pragma const_seg("PAGECONST")
#endif // ALLOC_DATA_PRAGMA

//
// This type of definition is required because the compiler will not otherwise
// put these GUIDs in a paged segment.
//
const
GUID
NodeType0 = {STATICGUIDOF(KSCATEGORY_COMMUNICATIONSTRANSFORM)};
const
GUID
NodeType1 = {STATICGUIDOF(KSCATEGORY_SPLITTER)};

//
// Define the topologies for this filter
//
const
KSNODE_DESCRIPTOR
NodeDescriptors[] =
{
    DEFINE_NODE_DESCRIPTOR(NULL,&NodeType0,NULL),
    DEFINE_NODE_DESCRIPTOR(NULL,&NodeType1,NULL)
};

//
// Topology connections for the splitter includes the communications transform.
//
// Filter In (FN,0)
//      (0,0) Communication Transform (0,1)
//      (1,0) Splitter (1,1)
// Filter Out (FN,1)
//


const KSTOPOLOGY_CONNECTION ConnectionsSplitter[] = {
    { KSFILTER_NODE,    ID_DATA_SOURCE_PIN, 0,              0 },
    { 0,                1,                  1,              0 },
    { 1,                0,                  KSFILTER_NODE,  ID_DATA_DESTINATION_PIN  }
};

//
// Topology connections for the communication transform
//
// Filter In (FN,0)
//      (0,0) Communication Transform (0,1)
// Filter Out (FN,1)
//

const KSTOPOLOGY_CONNECTION ConnectionsCommTransform[] = {
    { KSFILTER_NODE,    ID_DATA_SOURCE_PIN, 0,              0 },
    { 0,                1,                  KSFILTER_NODE,  ID_DATA_DESTINATION_PIN  }
};    

//
// Define the wildcard data format.
//

const KSDATARANGE WildcardDataFormat =
{
    sizeof( WildcardDataFormat ),
    0, // ULONG Flags
    0, // ULONG SampleSize
    0, // ULONG Reserved
    STATICGUIDOF( KSDATAFORMAT_TYPE_WILDCARD ),
    STATICGUIDOF( KSDATAFORMAT_SUBTYPE_WILDCARD ),
    STATICGUIDOF( KSDATAFORMAT_SPECIFIER_WILDCARD )
};


const PKSDATARANGE PinFormatRanges[] =
{
    (PKSDATARANGE)&WildcardDataFormat
};


//
// Define pin allocator framing.
//

DECLARE_SIMPLE_FRAMING_EX(
    AllocatorFraming, 
    STATIC_KSMEMORY_TYPE_KERNEL_PAGED, 
    KSALLOCATOR_REQUIREMENTF_SYSTEM_MEMORY | 
    KSALLOCATOR_REQUIREMENTF_INPLACE_MODIFIER |
    KSALLOCATOR_FLAG_INSIST_ON_FRAMESIZE_RATIO |
    KSALLOCATOR_REQUIREMENTF_PREFERENCES_ONLY,
    3,
    0,
    2 * PAGE_SIZE,
    2 * PAGE_SIZE
);

//
// Define splitter pins.
//

const
KSPIN_DISPATCH
PinDispatch =
{
    PinCreate,
    PinClose,
    NULL,// Process
    NULL,// Reset
    NULL,// SetDataFormat
    NULL,// SetDeviceState
    NULL,// Connect
    NULL// Disconnect
};

const
KSPIN_DESCRIPTOR_EX
PinDescriptorsSplitter[] =
{
    {   
        &PinDispatch,
        NULL,
        {
            DEFINE_KSPIN_DEFAULT_INTERFACES,
            DEFINE_KSPIN_DEFAULT_MEDIUMS,
            SIZEOF_ARRAY(PinFormatRanges),
            PinFormatRanges,
            KSPIN_DATAFLOW_OUT,
            KSPIN_COMMUNICATION_BOTH,
            NULL,//Name
            NULL,//Category
            0
        },
        KSPIN_FLAG_SPLITTER,//Flags
        KSINSTANCE_INDETERMINATE,
        1,
        &AllocatorFraming,//AllocatorFraming,
        IntersectHandler
    },
    {   
        &PinDispatch,
        NULL,
        {
            DEFINE_KSPIN_DEFAULT_INTERFACES,
            DEFINE_KSPIN_DEFAULT_MEDIUMS,
            SIZEOF_ARRAY(PinFormatRanges),
            PinFormatRanges,
            KSPIN_DATAFLOW_IN,
            KSPIN_COMMUNICATION_BOTH,
            NULL,//Name
            NULL,//Category
            0
        },
        0,//Flags
        1,
        1,
        &AllocatorFraming,//AllocatorFraming,
        IntersectHandler
    }
};


//
// Define communication transform pins.
//

const
KSPIN_DESCRIPTOR_EX
PinDescriptorsCommTransform[] =
{
    {   
        &PinDispatch,
        NULL,
        {
            DEFINE_KSPIN_DEFAULT_INTERFACES,
            DEFINE_KSPIN_DEFAULT_MEDIUMS,
            SIZEOF_ARRAY(PinFormatRanges),
            PinFormatRanges,
            KSPIN_DATAFLOW_OUT,
            KSPIN_COMMUNICATION_BOTH,
            NULL,
            NULL,
            0
        },
        0,//Flags
        1,
        1,
        &AllocatorFraming,//AllocatorFraming,
        IntersectHandler
    },
    {   
        &PinDispatch,
        NULL,
        {
            DEFINE_KSPIN_DEFAULT_INTERFACES,
            DEFINE_KSPIN_DEFAULT_MEDIUMS,
            SIZEOF_ARRAY(PinFormatRanges),
            PinFormatRanges,
            KSPIN_DATAFLOW_IN,
            KSPIN_COMMUNICATION_BOTH,
            NULL,
            NULL,
            0
        },
        0,//Flags
        1,
        1,
        &AllocatorFraming,//AllocatorFraming,
        IntersectHandler
    }
};


//
// Define filter dispatch table.
//

const
KSFILTER_DISPATCH
FilterDispatch =
{
    NULL, // Create
    NULL, // Close
    FilterProcess,
    NULL // Reset
};


//
// Define filters.
//

DEFINE_KSFILTER_DESCRIPTOR(FilterDescriptorSplitter)
{   
    &FilterDispatch,
    NULL,//AutomationTable;
    KSFILTER_DESCRIPTOR_VERSION,
    0,//Flags
    &KSCATEGORY_SPLITTER,
    DEFINE_KSFILTER_PIN_DESCRIPTORS(PinDescriptorsSplitter),
    DEFINE_KSFILTER_CATEGORY(KSCATEGORY_SPLITTER),
    DEFINE_KSFILTER_NODE_DESCRIPTORS(NodeDescriptors),
    DEFINE_KSFILTER_CONNECTIONS(ConnectionsSplitter),
    NULL // ComponentId
};

DEFINE_KSFILTER_DESCRIPTOR(FilterDescriptorCommTransform)
{   
    &FilterDispatch,
    NULL,//AutomationTable;
    KSFILTER_DESCRIPTOR_VERSION,
    0,//Flags
    &KSCATEGORY_COMMUNICATIONSTRANSFORM,
    DEFINE_KSFILTER_PIN_DESCRIPTORS(PinDescriptorsCommTransform),
    DEFINE_KSFILTER_CATEGORY(KSCATEGORY_COMMUNICATIONSTRANSFORM),
    DEFINE_KSFILTER_NODE_DESCRIPTORS(NodeDescriptors),
    DEFINE_KSFILTER_CONNECTIONS(ConnectionsCommTransform),
    NULL // ComponentId
};

DEFINE_KSFILTER_DESCRIPTOR_TABLE(FilterDescriptors)
{
    &FilterDescriptorSplitter,
    &FilterDescriptorCommTransform
};

//
// Define device.
//

const
KSDEVICE_DESCRIPTOR 
DeviceDescriptor =
{   
    NULL,
    SIZEOF_ARRAY(FilterDescriptors),
    FilterDescriptors
};

#ifdef ALLOC_DATA_PRAGMA
#pragma const_seg()
#endif // ALLOC_DATA_PRAGMA


NTSTATUS
IntersectHandler(
    IN PVOID Filter,
    IN PIRP Irp,
    IN PKSP_PIN PinInstance,
    IN PKSDATARANGE CallerDataRange,
    IN PKSDATARANGE DescriptorDataRange,
    IN ULONG BufferSize,
    OUT PVOID Data OPTIONAL,
    OUT PULONG DataSize
    )

/*++

Routine Description:

    This routine handles pin intersection queries by determining the
    intersection between two data ranges.

Arguments:

    Filter -
        Contains a void pointer to the  filter structure.

    Irp -
        Contains a pointer to the data intersection property request.

    PinInstance -
        Contains a pointer to a structure indicating the pin in question.

    CallerDataRange -
        Contains a pointer to one of the data ranges supplied by the client
        in the data intersection request.  The format type, subtype and
        specifier are compatible with the DescriptorDataRange.

    DescriptorDataRange -
        Contains a pointer to one of the data ranges from the pin descriptor
        for the pin in question.  The format type, subtype and specifier are
        compatible with the CallerDataRange.

    BufferSize -
        Contains the size in bytes of the buffer pointed to by the Data
        argument.  For size queries, this value will be zero.

    Data -
        Optionally contains a pointer to the buffer to contain the data format
        structure representing the best format in the intersection of the
        two data ranges.  For size queries, this pointer will be NULL.

    DataSize -
        Contains a pointer to the location at which to deposit the size of the
        data format.  This information is supplied by the function when the
        format is actually delivered and in response to size queries.

Return Value:

    STATUS_SUCCESS if there is an intersection and it fits in the supplied
    buffer, STATUS_BUFFER_OVERFLOW for successful size queries, STATUS_NO_MATCH
    if the intersection is empty, or STATUS_BUFFER_TOO_SMALL if the supplied
    buffer is too small.

--*/

{
    PKSFILTER filter = (PKSFILTER) Filter;
    PKSPIN pin;
    NTSTATUS status;

    _DbgPrintF(DEBUGLVL_BLAB,("[IntersectHandler]"));

    PAGED_CODE();

    ASSERT(Filter);
    ASSERT(Irp);
    ASSERT(PinInstance);
    ASSERT(CallerDataRange);
    ASSERT(DescriptorDataRange);
    ASSERT(DataSize);

    //
    // Find a pin instance if there is one.  Try the supplied pin type first.
    // If there is no pin, we fail to force the graph builder to try the
    // other filter.  We need to acquire control because we will be looking
    // at other pins.
    //
    pin = KsFilterGetFirstChildPin(filter,PinInstance->PinId);
    if (! pin) {
        pin = KsFilterGetFirstChildPin(filter,PinInstance->PinId ^ 1);
    }

    if (! pin) {
        status = STATUS_NO_MATCH;
    } else {
        //
        // Verify that the correct subformat and specifier are (or wildcards)
        // in the intersection.
        //
        
        if ((!IsEqualGUIDAligned( 
                &CallerDataRange->SubFormat,
                &pin->ConnectionFormat->SubFormat ) &&
             !IsEqualGUIDAligned( 
                &CallerDataRange->SubFormat,
                &KSDATAFORMAT_SUBTYPE_WILDCARD )) || 
            (!IsEqualGUIDAligned(  
                &CallerDataRange->Specifier, 
                &pin->ConnectionFormat->Specifier ) &&
             !IsEqualGUIDAligned( 
                &CallerDataRange->Specifier,
                &KSDATAFORMAT_SPECIFIER_WILDCARD ))) {
            _DbgPrintF( 
                DEBUGLVL_VERBOSE, 
                ("range does not match current format") );
            status = STATUS_NO_MATCH;
        } else {
            //
            // Validate return buffer size, if the request is only for the
            // size of the resultant structure, return it now.
            //    
            if (!BufferSize) {
                *DataSize = pin->ConnectionFormat->FormatSize;
                status = STATUS_BUFFER_OVERFLOW;
            } else if (BufferSize < pin->ConnectionFormat->FormatSize) {
                status =  STATUS_BUFFER_TOO_SMALL;
            } else {
                *DataSize = pin->ConnectionFormat->FormatSize;
                RtlCopyMemory( Data, pin->ConnectionFormat, *DataSize );
                status = STATUS_SUCCESS;
            }
        }
    } 

    return status;
}


NTSTATUS
FilterProcess(
    IN PKSFILTER Filter,
    IN PKSPROCESSPIN_INDEXENTRY ProcessPinsIndex
    )

/*++

Routine Description:

    This routine is called when there is data to be processed.

Arguments:

    Filter -
        Contains a pointer to the  filter structure.

    ProcessPinsIndex -
        Contains a pointer to an array of process pin index entries.  This
        array is indexed by pin ID.  An index entry indicates the number 
        of pin instances for the corresponding pin type and points to the
        array of pointers to process pins.
        This allows process pin structures to be quickly accessed by pin ID
        when the number of instances per type is not known in advance.

Return Value:

    Indication of whether more processing should be done if frames are 
    available.  A value of STATUS_PENDING indicates that processing should not
    continue even if frames are available on all required queues.  
    STATUS_SUCCESS indicates processing should continue if frames are
    available on all required queues.

--*/

{
    PKSPROCESSPIN *processPin;
    ULONG byteCount;
    PVOID data;
    PKSSTREAM_HEADER header;

    PAGED_CODE();

    //
    // Determine how much data we can process this time.
    //
    ASSERT(ProcessPinsIndex[ID_DATA_SOURCE_PIN].Count == 1);
    processPin = &ProcessPinsIndex[ID_DATA_SOURCE_PIN].Pins[0];

    byteCount = (*processPin)->BytesAvailable;
    data = (*processPin)->Data;
    header = (*processPin)->StreamPointer->StreamHeader;
    (*processPin)->BytesUsed = byteCount;

    if ((*processPin)->InPlaceCounterpart) {
        //
        // A pipe goes through the filter.  All we need to do is indicated
        // number of bytes used on the output pin.
        //
        if ((*processPin)->InPlaceCounterpart->BytesAvailable < byteCount) {
            return STATUS_UNSUCCESSFUL;
        }
        (*processPin)->InPlaceCounterpart->BytesUsed = byteCount;
    } else {
        //
        // The pipe does not go through, so the first pin will be the delegate
        // or copy source for all the others.  A copy is required.
        //
        PKSSTREAM_HEADER destHeader;

        processPin = ProcessPinsIndex[ID_DATA_DESTINATION_PIN].Pins;
        while ((*processPin)->CopySource) {
            processPin++;
        }
        if ((*processPin)->BytesAvailable < byteCount) {
            return STATUS_UNSUCCESSFUL;
        }
        (*processPin)->BytesUsed = byteCount;
        (*processPin)->Terminate = TRUE;

        destHeader = (*processPin)->StreamPointer->StreamHeader;
        ASSERT(header->Size == destHeader->Size);
        destHeader->TypeSpecificFlags = header->TypeSpecificFlags;
        destHeader->PresentationTime = header->PresentationTime;
        destHeader->Duration = header->Duration;
        destHeader->OptionsFlags = header->OptionsFlags & ~KSSTREAM_HEADER_OPTIONSF_ENDOFSTREAM;
        if (destHeader->Size > sizeof(KSSTREAM_HEADER) &&
            destHeader->Size >= header->Size) {
            RtlCopyMemory(destHeader + 1,header + 1,header->Size - sizeof(KSSTREAM_HEADER));
        }
        RtlCopyMemory((*processPin)->Data,data,byteCount);
    }

    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\ksfilter\tests\avshws\avshws.h ===
/**************************************************************************

    AVStream Simulated Hardware Sample

    Copyright (c) 2001, Microsoft Corporation.

    File:

        avshws.h

    Abstract:

        AVStream Simulated Hardware Sample header file.  This is the 
        main header.

    History:

        created 3/12/2001

**************************************************************************/

/*************************************************

    Standard Includes

*************************************************/

extern "C" {
#include <wdm.h>
}

#include <windef.h>
#include <stdio.h>
#include <stdlib.h>
#include <windef.h>
#define NOBITMAP
#include <mmreg.h>
#undef NOBITMAP
#include <unknown.h>
#include <ks.h>
#include <ksmedia.h>
#include <kcom.h>

/*************************************************

    Misc Definitions

*************************************************/

#define ABS(x) ((x) < 0 ? (-(x)) : (x))

#ifndef mmioFOURCC    
#define mmioFOURCC( ch0, ch1, ch2, ch3 )                \
        ( (DWORD)(BYTE)(ch0) | ( (DWORD)(BYTE)(ch1) << 8 ) |    \
        ( (DWORD)(BYTE)(ch2) << 16 ) | ( (DWORD)(BYTE)(ch3) << 24 ) )
#endif

#define FOURCC_YUV422       mmioFOURCC('U', 'Y', 'V', 'Y')

//
// CAPTURE_PIN_DATA_RANGE_COUNT:
//
// The number of ranges supported on the capture pin.
//
#define CAPTURE_PIN_DATA_RANGE_COUNT 2

//
// CAPTURE_FILTER_PIN_COUNT:
//
// The number of pins on the capture filter.
//
#define CAPTURE_FILTER_PIN_COUNT 1

//
// CAPTURE_FILTER_CATEGORIES_COUNT:
//
// The number of categories for the capture filter.
//
#define CAPTURE_FILTER_CATEGORIES_COUNT 2

/*************************************************

    Externed information

*************************************************/

//
// filter.cpp externs:
//
extern
const
KSFILTER_DISPATCH
CaptureFilterDispatch;

extern
const
KSFILTER_DESCRIPTOR
CaptureFilterDescriptor;

extern
const
KSPIN_DESCRIPTOR_EX
CaptureFilterPinDescriptors [CAPTURE_FILTER_PIN_COUNT];

extern
const
GUID
CaptureFilterCategories [CAPTURE_FILTER_CATEGORIES_COUNT];

//
// capture.cpp externs:
//
extern 
const
KSALLOCATOR_FRAMING_EX
CapturePinAllocatorFraming;

extern 
const
KSPIN_DISPATCH
CapturePinDispatch;

extern
const
PKSDATARANGE
CapturePinDataRanges [CAPTURE_PIN_DATA_RANGE_COUNT];

/*************************************************

    Enums / Typedefs

*************************************************/

typedef enum _HARDWARE_STATE {

    HardwareStopped = 0,
    HardwarePaused,
    HardwareRunning

} HARDWARE_STATE, *PHARDWARE_STATE;

/*************************************************

    Class Definitions

*************************************************/

//
// IHardwareSink:
//
// This interface is used by the hardware simulation to fake interrupt
// service routines.  The Interrupt method is called at DPC as a fake
// interrupt.
//
class IHardwareSink {

public:

    virtual
    void
    Interrupt (
        ) = 0;

};

//
// ICaptureSink:
//
// This is a capture sink interface.  The device level calls back the
// CompleteMappings method passing the number of completed mappings for
// the capture pin.  This method is called during the device DPC.
//
class ICaptureSink {

public:

    virtual
    void
    CompleteMappings (
        IN ULONG NumMappings
        ) = 0;

};

/*************************************************

    Internal Includes

*************************************************/

#include "image.h"
#include "hwsim.h"
#include "device.h"
#include "filter.h"
#include "capture.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\ksfilter\tests\avshws\capture.cpp ===
/**************************************************************************

    AVStream Simulated Hardware Sample

    Copyright (c) 2001, Microsoft Corporation.

    File:

        capture.cpp

    Abstract:

        This file contains source for the video capture pin on the capture
        filter.  The capture sample performs "fake" DMA directly into
        the capture buffers.  Common buffer DMA will work slightly differently.

        For common buffer DMA, the general technique would be DPC schedules
        processing with KsPinAttemptProcessing.  The processing routine grabs
        the leading edge, copies data out of the common buffer and advances.
        Cloning would not be necessary with this technique.  It would be 
        similiar to the way "AVSSamp" works, but it would be pin-centric.

    History:

        created 3/8/2001

**************************************************************************/

#include "avshws.h"

/**************************************************************************

    PAGEABLE CODE

**************************************************************************/

#ifdef ALLOC_PRAGMA
#pragma code_seg("PAGE")
#endif // ALLOC_PRAGMA


CCapturePin::
CCapturePin (
    IN PKSPIN Pin
    ) :
    m_Pin (Pin)

/*++

Routine Description:

    Construct a new capture pin.

Arguments:

    Pin -
        The AVStream pin object corresponding to the capture pin

Return Value:

    None

--*/

{

    PAGED_CODE();

    PKSDEVICE Device = KsPinGetDevice (Pin);

    //
    // Set up our device pointer.  This gives us access to "hardware I/O"
    // during the capture routines.
    //
    m_Device = reinterpret_cast <CCaptureDevice *> (Device -> Context);

}

/*************************************************/


NTSTATUS
CCapturePin::
DispatchCreate (
    IN PKSPIN Pin,
    IN PIRP Irp
    )

/*++

Routine Description:

    Create a new capture pin.  This is the creation dispatch for
    the video capture pin.

Arguments:

    Pin -
        The pin being created

    Irp -
        The creation Irp

Return Value:

    Success / Failure

--*/

{

    PAGED_CODE();

    NTSTATUS Status = STATUS_SUCCESS;

    CCapturePin *CapPin = new (NonPagedPool) CCapturePin (Pin);

    if (!CapPin) {
        //
        // Return failure if we couldn't create the pin.
        //
        Status = STATUS_INSUFFICIENT_RESOURCES;

    } else {
        //
        // Add the item to the object bag if we we were successful. 
        // Whenever the pin closes, the bag is cleaned up and we will be
        // freed.
        //
        Status = KsAddItemToObjectBag (
            Pin -> Bag,
            reinterpret_cast <PVOID> (CapPin),
            reinterpret_cast <PFNKSFREE> (CCapturePin::Cleanup)
            );

        if (!NT_SUCCESS (Status)) {
            delete CapPin;
        } else {
            Pin -> Context = reinterpret_cast <PVOID> (CapPin);
        }

    }

    //
    // If we succeeded so far, stash the video info header away and change
    // our allocator framing to reflect the fact that only now do we know
    // the framing requirements based on the connection format.
    //
    PKS_VIDEOINFOHEADER VideoInfoHeader = NULL;

    if (NT_SUCCESS (Status)) {

        VideoInfoHeader = CapPin -> CaptureVideoInfoHeader ();
        if (!VideoInfoHeader) {
            Status = STATUS_INSUFFICIENT_RESOURCES;
        }
    }

    if (NT_SUCCESS (Status)) {
        
        //
        // We need to edit the descriptor to ensure we don't mess up any other
        // pins using the descriptor or touch read-only memory.
        //
        Status = KsEdit (Pin, &Pin -> Descriptor, 'aChS');

        if (NT_SUCCESS (Status)) {
            Status = KsEdit (
                Pin, 
                &(Pin -> Descriptor -> AllocatorFraming),
                'aChS'
                );
        }

        //
        // If the edits proceeded without running out of memory, adjust 
        // the framing based on the video info header.
        //
        if (NT_SUCCESS (Status)) {

            //
            // We've KsEdit'ed this...  I'm safe to cast away constness as
            // long as the edit succeeded.
            //
            PKSALLOCATOR_FRAMING_EX Framing =
                const_cast <PKSALLOCATOR_FRAMING_EX> (
                    Pin -> Descriptor -> AllocatorFraming
                    );

            Framing -> FramingItem [0].Frames = 2;

            //
            // The physical and optimal ranges must be biSizeImage.  We only
            // support one frame size, precisely the size of each capture
            // image.
            //
            Framing -> FramingItem [0].PhysicalRange.MinFrameSize =
                Framing -> FramingItem [0].PhysicalRange.MaxFrameSize =
                Framing -> FramingItem [0].FramingRange.Range.MinFrameSize =
                Framing -> FramingItem [0].FramingRange.Range.MaxFrameSize =
                VideoInfoHeader -> bmiHeader.biSizeImage;

            Framing -> FramingItem [0].PhysicalRange.Stepping = 
                Framing -> FramingItem [0].FramingRange.Range.Stepping =
                0;

        }

    }

    return Status;

}

/*************************************************/


PKS_VIDEOINFOHEADER 
CCapturePin::
CaptureVideoInfoHeader (
    )

/*++

Routine Description:

    Capture the video info header out of the connection format.  This
    is what we use to base synthesized images off.

Arguments:

    None

Return Value:

    The captured video info header or NULL if there is insufficient
    memory.

--*/

{

    PAGED_CODE();

    PKS_VIDEOINFOHEADER ConnectionHeader =
        &((reinterpret_cast <PKS_DATAFORMAT_VIDEOINFOHEADER> 
            (m_Pin -> ConnectionFormat)) -> 
            VideoInfoHeader);

    m_VideoInfoHeader = reinterpret_cast <PKS_VIDEOINFOHEADER> (
        ExAllocatePool (
            NonPagedPool,
            KS_SIZE_VIDEOHEADER (ConnectionHeader)
            )
        );

    if (!m_VideoInfoHeader)
        return NULL;

    //
    // Bag the newly allocated header space.  This will get cleaned up
    // automatically when the pin closes.
    //
    NTSTATUS Status =
        KsAddItemToObjectBag (
            m_Pin -> Bag,
            reinterpret_cast <PVOID> (m_VideoInfoHeader),
            NULL
            );

    if (!NT_SUCCESS (Status)) {

        ExFreePool (m_VideoInfoHeader);
        return NULL;

    } else {

        //
        // Copy the connection format video info header into the newly 
        // allocated "captured" video info header.
        //
        RtlCopyMemory (
            m_VideoInfoHeader,
            ConnectionHeader,
            KS_SIZE_VIDEOHEADER (ConnectionHeader)
            );

    }

    return m_VideoInfoHeader;

}

/*************************************************/


NTSTATUS
CCapturePin::
Process (
    )

/*++

Routine Description:

    The process dispatch for the pin bridges to this location.
    We handle setting up scatter gather mappings, etc...

Arguments:

    None

Return Value:

    Success / Failure

--*/

{

    PAGED_CODE();

    NTSTATUS Status = STATUS_SUCCESS;
    PKSSTREAM_POINTER Leading;

    Leading = KsPinGetLeadingEdgeStreamPointer (
        m_Pin,
        KSSTREAM_POINTER_STATE_LOCKED
        );

    while (NT_SUCCESS (Status) && Leading) {

        PKSSTREAM_POINTER ClonePointer;
        PSTREAM_POINTER_CONTEXT SPContext;

        //
        // For optimization sake in this particular sample, I will only keep
        // one clone stream pointer per frame.  This complicates the logic
        // here but simplifies the completions.
        //
        // I'm also choosing to do this since I need to keep track of the
        // virtual addresses corresponding to each mapping since I'm faking
        // DMA.  It simplifies that too.
        //
        if (!m_PreviousStreamPointer) {
            //
            // First thing we need to do is clone the leading edge.  This allows
            // us to keep reference on the frames while they're in DMA.
            //
            Status = KsStreamPointerClone (
                Leading,
                NULL,
                sizeof (STREAM_POINTER_CONTEXT),
                &ClonePointer
                );

            //
            // I use this for easy chunking of the buffer.  We're not really
            // dealing with physical addresses.  This keeps track of what 
            // virtual address in the buffer the current scatter / gather 
            // mapping corresponds to for the fake hardware.
            //
            if (NT_SUCCESS (Status)) {

                //
                // Set the stream header data used to 0.  We update this 
                // in the DMA completions.  For queues with DMA, we must
                // update this field ourselves.
                //
                ClonePointer -> StreamHeader -> DataUsed = 0;

                SPContext = reinterpret_cast <PSTREAM_POINTER_CONTEXT> 
                    (ClonePointer -> Context);

                SPContext -> BufferVirtual = 
                    reinterpret_cast <PUCHAR> (
                        ClonePointer -> StreamHeader -> Data
                        );
            }

        } else {

            ClonePointer = m_PreviousStreamPointer;
            SPContext = reinterpret_cast <PSTREAM_POINTER_CONTEXT> 
                (ClonePointer -> Context);
            Status = STATUS_SUCCESS;
        }

        //
        // If the clone failed, likely we're out of resources.  Break out
        // of the loop for now.  We may end up starving DMA.
        //
        if (!NT_SUCCESS (Status)) {
            KsStreamPointerUnlock (Leading, FALSE);
            break;
        }

        //
        // Program the fake hardware.  I would use Clone -> OffsetOut.*, but
        // because of the optimization of one stream pointer per frame, it
        // doesn't make complete sense.
        //
        ULONG MappingsUsed =
            m_Device -> ProgramScatterGatherMappings (
                &(SPContext -> BufferVirtual),
                Leading -> OffsetOut.Mappings,
                Leading -> OffsetOut.Remaining
                );

        //
        // In order to keep one clone per frame and simplify the fake DMA
        // logic, make a check to see if we completely used the mappings in
        // the leading edge.  Set a flag.
        //
        if (MappingsUsed == Leading -> OffsetOut.Remaining) {
            m_PreviousStreamPointer = NULL;
        } else {
            m_PreviousStreamPointer = ClonePointer;
        }

        if (MappingsUsed) {
            //
            // If any mappings were added to scatter / gather queues, 
            // advance the leading edge by that number of mappings.  If 
            // we run off the end of the queue, Status will be 
            // STATUS_DEVICE_NOT_READY.  Otherwise, the leading edge will
            // point to a new frame.  The previous one will not have been
            // dismissed (unless "DMA" completed) since there's a clone
            // pointer referencing the frames.
            //
            Status =
                KsStreamPointerAdvanceOffsets (
                    Leading,
                    0,
                    MappingsUsed,
                    FALSE
                    );
        } else {

            //
            // The hardware was incapable of adding more entries.  The S/G
            // table is full.
            //
            Status = STATUS_PENDING;
            break;

        }

    }

    //
    // If the leading edge failed to lock (this is always possible, remember
    // that locking CAN occassionally fail), don't blow up passing NULL
    // into KsStreamPointerUnlock.  Also, set m_PendIo to kick us later...
    //
    if (!Leading) {

        m_PendIo = TRUE;

        //
        // If the lock failed, there's no point in getting called back 
        // immediately.  The lock could fail due to insufficient memory,
        // etc...  In this case, we don't want to get called back immediately.
        // Return pending.  The m_PendIo flag will cause us to get kicked
        // later.
        //
        Status = STATUS_PENDING;
    }

    //
    // If we didn't run the leading edge off the end of the queue, unlock it.
    //
    if (NT_SUCCESS (Status) && Leading) {
        KsStreamPointerUnlock (Leading, FALSE);
    } else {
        //
        // DEVICE_NOT_READY indicates that the advancement ran off the end
        // of the queue.  We couldn't lock the leading edge.
        //
        if (Status == STATUS_DEVICE_NOT_READY) Status = STATUS_SUCCESS;
    }

    //
    // If we failed with something that requires pending, set the pending I/O
    // flag so we know we need to start it again in a completion DPC.
    //
    if (!NT_SUCCESS (Status) || Status == STATUS_PENDING) {
        m_PendIo = TRUE;
    }

    return Status;

}

/*************************************************/


NTSTATUS
CCapturePin::
CleanupReferences (
    )

/*++

Routine Description:

    Clean up any references we're holding on frames after we abruptly
    stop the hardware.

Arguments:

    None

Return Value:

    Success / Failure

--*/

{

    PAGED_CODE();

    PKSSTREAM_POINTER Clone = KsPinGetFirstCloneStreamPointer (m_Pin);
    PKSSTREAM_POINTER NextClone = NULL;

    //
    // Walk through the clones, deleting them, and setting DataUsed to
    // zero since we didn't use any data!
    //
    while (Clone) {

        NextClone = KsStreamPointerGetNextClone (Clone);

        Clone -> StreamHeader -> DataUsed = 0;
        KsStreamPointerDelete (Clone);

        Clone = NextClone;

    }

    return STATUS_SUCCESS;

}

/*************************************************/


NTSTATUS
CCapturePin::
SetState (
    IN KSSTATE ToState,
    IN KSSTATE FromState
    )

/*++

Routine Description:

    This is called when the caputre pin transitions state.  The routine
    attempts to acquire / release any hardware resources and start up
    or shut down capture based on the states we are transitioning to
    and away from.

Arguments:

    ToState -
        The state we're transitioning to

    FromState -
        The state we're transitioning away from

Return Value:

    Success / Failure

--*/

{

    PAGED_CODE();

    NTSTATUS Status = STATUS_SUCCESS;

    switch (ToState) {

        case KSSTATE_STOP:

            //
            // First, stop the hardware if we actually did anything to it.
            //
            if (m_HardwareState != HardwareStopped) {
                Status = m_Device -> Stop ();
                ASSERT (NT_SUCCESS (Status));

                m_HardwareState = HardwareStopped;
            }

            //
            // We've stopped the "fake hardware".  It has cleared out
            // it's scatter / gather tables and will no longer be 
            // completing clones.  We had locks on some frames that were,
            // however, in hardware.  This will clean them up.  An
            // alternative location would be in the reset dispatch.
            // Note, however, that the reset dispatch can occur in any
            // state and this should be understood.
            //
            // Some hardware may fill all S/G mappings before stopping...
            // in this case, you may not have to do this.  The 
            // "fake hardware" here simply stops filling mappings and 
            // cleans its scatter / gather tables out on the Stop call.
            //
            Status = CleanupReferences ();

            //
            // Release any hardware resources related to this pin.
            //
            if (m_AcquiredResources) {
                //
                // If we got an interface to the clock, we must release it.
                //
                if (m_Clock) {
                    m_Clock -> Release ();
                    m_Clock = NULL;
                }

                m_Device -> ReleaseHardwareResources (
                    );

                m_AcquiredResources = FALSE;
            }

            break;

        case KSSTATE_ACQUIRE:
            //
            // Acquire any hardware resources related to this pin.  We should
            // only acquire them here -- **NOT** at filter create time. 
            // This means we do not fail creation of a filter because of
            // limited hardware resources.
            //
            if (FromState == KSSTATE_STOP) {
                Status = m_Device -> AcquireHardwareResources (
                    this,
                    m_VideoInfoHeader
                    );

                if (NT_SUCCESS (Status)) {
                    m_AcquiredResources = TRUE;

                    //
                    // Attempt to get an interface to the master clock.
                    // This will fail if one has not been assigned.  Since
                    // one must be assigned while the pin is still in 
                    // KSSTATE_STOP, this is a guranteed method of getting
                    // the clock should one be assigned.
                    //
                    if (!NT_SUCCESS (
                        KsPinGetReferenceClockInterface (
                            m_Pin,
                            &m_Clock
                            )
                        )) {

                        //
                        // If we could not get an interface to the clock,
                        // don't use one.  
                        //
                        m_Clock = NULL;

                    }

                } else {
                    m_AcquiredResources = FALSE;
                }

            } else {
                //
                // Standard transport pins will always receive transitions in
                // +/- 1 manner.  This means we'll always see a PAUSE->ACQUIRE
                // transition before stopping the pin.  
                //
                // The below is done because on DirectX 8.0, when the pin gets
                // a message to stop, the queue is inaccessible.  The reset 
                // which comes on every stop happens after this (at which time
                // the queue is inaccessible also).  So, for compatibility with
                // DirectX 8.0, I am stopping the "fake" hardware at this
                // point and cleaning up all references we have on frames.  See
                // the comments above regarding the CleanupReferences call.
                //
                // If this sample were targeting XP only, the below code would
                // not be here.  Again, I only do this so the sample does not
                // hang when it is stopped running on a configuration such as
                // Win2K + DX8. 
                //
                if (m_HardwareState != HardwareStopped) {
                    Status = m_Device -> Stop ();
                    ASSERT (NT_SUCCESS (Status));

                    m_HardwareState = HardwareStopped;
                }

                Status = CleanupReferences ();
            }

            break;

        case KSSTATE_PAUSE:
            //
            // Stop the hardware simulation if we're coming down from run.
            //
            if (FromState == KSSTATE_RUN) {

                Status = m_Device -> Pause (TRUE);

                if (NT_SUCCESS (Status)) {
                    m_HardwareState = HardwarePaused;
                }

            }
            break;

        case KSSTATE_RUN:
            //
            // Start the hardware simulation or unpause it depending on
            // whether we're initially running or we've paused and restarted.
            //
            if (m_HardwareState == HardwarePaused) {
                Status = m_Device -> Pause (FALSE);
            } else {
                Status = m_Device -> Start ();
            }

            if (NT_SUCCESS (Status)) {
                m_HardwareState = HardwareRunning;
            }

            break;

    }

    return Status;

}

/*************************************************/


NTSTATUS
CCapturePin::
IntersectHandler (
    IN PKSFILTER Filter,
    IN PIRP Irp,
    IN PKSP_PIN PinInstance,
    IN PKSDATARANGE CallerDataRange,
    IN PKSDATARANGE DescriptorDataRange,
    IN ULONG BufferSize,
    OUT PVOID Data OPTIONAL,
    OUT PULONG DataSize
    )

/*++

Routine Description:

    This routine handles video pin intersection queries by determining the
    intersection between two data ranges.

Arguments:

    Filter -
        Contains a void pointer to the  filter structure.

    Irp -
        Contains a pointer to the data intersection property request.

    PinInstance -
        Contains a pointer to a structure indicating the pin in question.

    CallerDataRange -
        Contains a pointer to one of the data ranges supplied by the client
        in the data intersection request.  The format type, subtype and
        specifier are compatible with the DescriptorDataRange.

    DescriptorDataRange -
        Contains a pointer to one of the data ranges from the pin descriptor
        for the pin in question.  The format type, subtype and specifier are
        compatible with the CallerDataRange.

    BufferSize -
        Contains the size in bytes of the buffer pointed to by the Data
        argument.  For size queries, this value will be zero.

    Data -
        Optionally contains a pointer to the buffer to contain the data 
        format structure representing the best format in the intersection 
        of the two data ranges.  For size queries, this pointer will be 
        NULL.

    DataSize -
        Contains a pointer to the location at which to deposit the size 
        of the data format.  This information is supplied by the function 
        when the format is actually delivered and in response to size 
        queries.

Return Value:

    STATUS_SUCCESS if there is an intersection and it fits in the supplied
    buffer, STATUS_BUFFER_OVERFLOW for successful size queries, 
    STATUS_NO_MATCH if the intersection is empty, or 
    STATUS_BUFFER_TOO_SMALL if the supplied buffer is too small.

--*/

{
    PAGED_CODE();

    const GUID VideoInfoSpecifier = 
        {STATICGUIDOF(KSDATAFORMAT_SPECIFIER_VIDEOINFO)};
    
    ASSERT(Filter);
    ASSERT(Irp);
    ASSERT(PinInstance);
    ASSERT(CallerDataRange);
    ASSERT(DescriptorDataRange);
    ASSERT(DataSize);
    
    ULONG DataFormatSize;
    
    //
    // Specifier FORMAT_VideoInfo for VIDEOINFOHEADER
    //
    if (IsEqualGUID(CallerDataRange->Specifier, VideoInfoSpecifier)) {
            
        PKS_DATARANGE_VIDEO callerDataRange = 
            reinterpret_cast <PKS_DATARANGE_VIDEO> (CallerDataRange);

        PKS_DATARANGE_VIDEO descriptorDataRange = 
            reinterpret_cast <PKS_DATARANGE_VIDEO> (DescriptorDataRange);

        PKS_DATAFORMAT_VIDEOINFOHEADER FormatVideoInfoHeader;

        //
        // Check that the other fields match
        //
        if ((callerDataRange->bFixedSizeSamples != 
                descriptorDataRange->bFixedSizeSamples) ||
            (callerDataRange->bTemporalCompression != 
                descriptorDataRange->bTemporalCompression) ||
            (callerDataRange->StreamDescriptionFlags != 
                descriptorDataRange->StreamDescriptionFlags) ||
            (callerDataRange->MemoryAllocationFlags != 
                descriptorDataRange->MemoryAllocationFlags) ||
            (RtlCompareMemory (&callerDataRange->ConfigCaps,
                    &callerDataRange->ConfigCaps,
                    sizeof (KS_VIDEO_STREAM_CONFIG_CAPS)) != 
                    sizeof (KS_VIDEO_STREAM_CONFIG_CAPS))) 
        {
            return STATUS_NO_MATCH;
        }
        
        DataFormatSize = 
            sizeof (KSDATAFORMAT) + 
            KS_SIZE_VIDEOHEADER (&callerDataRange->VideoInfoHeader);
            
        //
        // If the passed buffer size is 0, it indicates that this is a size
        // only query.  Return the size of the intersecting data format and
        // pass back STATUS_BUFFER_OVERFLOW.
        //
        if (BufferSize == 0) {

            *DataSize = DataFormatSize;
            return STATUS_BUFFER_OVERFLOW;

        }
        
        //
        // Verify that the provided structure is large enough to
        // accept the result.
        //
        if (BufferSize < DataFormatSize) 
        {
            return STATUS_BUFFER_TOO_SMALL;
        }

        //
        // Copy over the KSDATAFORMAT, followed by the actual VideoInfoHeader
        //
        *DataSize = DataFormatSize;
            
        FormatVideoInfoHeader = PKS_DATAFORMAT_VIDEOINFOHEADER( Data );

        //
        // Copy over the KSDATAFORMAT.  This is precisely the same as the
        // KSDATARANGE (it's just the GUIDs, etc...  not the format information
        // following any data format.
        // 
        RtlCopyMemory (
            &FormatVideoInfoHeader->DataFormat, 
            DescriptorDataRange, 
            sizeof (KSDATAFORMAT));

        FormatVideoInfoHeader->DataFormat.FormatSize = DataFormatSize;

        //
        // Copy over the callers requested VIDEOINFOHEADER
        //

        RtlCopyMemory (
            &FormatVideoInfoHeader->VideoInfoHeader, 
            &callerDataRange->VideoInfoHeader,
            KS_SIZE_VIDEOHEADER (&callerDataRange->VideoInfoHeader) 
            );

        //
        // Calculate biSizeImage for this request, and put the result in both
        // the biSizeImage field of the bmiHeader AND in the SampleSize field
        // of the DataFormat.
        //
        // Note that for compressed sizes, this calculation will probably not
        // be just width * height * bitdepth
        //
        FormatVideoInfoHeader->VideoInfoHeader.bmiHeader.biSizeImage =
            FormatVideoInfoHeader->DataFormat.SampleSize = 
            KS_DIBSIZE (FormatVideoInfoHeader->VideoInfoHeader.bmiHeader);

        //
        // REVIEW - Perform other validation such as cropping and scaling checks
        // 
        
        return STATUS_SUCCESS;
        
    } // End of VIDEOINFOHEADER specifier
    
    return STATUS_NO_MATCH;
}

/*************************************************/


NTSTATUS
CCapturePin::
DispatchSetFormat (
    IN PKSPIN Pin,
    IN PKSDATAFORMAT OldFormat OPTIONAL,
    IN PKSMULTIPLE_ITEM OldAttributeList OPTIONAL,
    IN const KSDATARANGE *DataRange,
    IN const KSATTRIBUTE_LIST *AttributeRange OPTIONAL
    )

/*++

Routine Description:

    This is the set data format dispatch for the capture pin.  It is called
    in two circumstances.

        1: before Pin's creation dispatch has been made to verify that
           Pin -> ConnectionFormat is an acceptable format for the range
           DataRange.  In this case OldFormat is NULL.

        2: after Pin's creation dispatch has been made and an initial format
           selected in order to change the format for the pin.  In this case,
           OldFormat will not be NULL.

    Validate that the format is acceptible and perform the actions necessary
    to change format if appropriate.

Arguments:

    Pin -
        The pin this format is being set on.  The format itself will be in
        Pin -> ConnectionFormat.

    OldFormat -
        The previous format used on this pin.  If this is NULL, it is an
        indication that Pin's creation dispatch has not yet been made and
        that this is a request to validate the initial format and not to
        change formats.

    OldAttributeList -
        The old attribute list for the prior format

    DataRange -
        A range out of our list of data ranges which was determined to be
        at least a partial match for Pin -> ConnectionFormat.  If the format
        there is unacceptable for the range, STATUS_NO_MATCH should be
        returned.

    AttributeRange -
        The attribute range

Return Value:

    Success / Failure

        STATUS_SUCCESS -
            The format is acceptable / the format has been changed

        STATUS_NO_MATCH -
            The format is not-acceptable / the format has not been changed

--*/

{

    PAGED_CODE();

    NTSTATUS Status = STATUS_NO_MATCH;

    const GUID VideoInfoSpecifier = 
        {STATICGUIDOF(KSDATAFORMAT_SPECIFIER_VIDEOINFO)};

    CCapturePin *CapPin = NULL;

    //
    // Find the pin, if it exists yet.  OldFormat will be an indication of 
    // this.  If we're changing formats, OldFormat will be non-NULL.
    //
    // You cannot use Pin -> Context to make the determination.  AVStream
    // preinitializes this to the filter's context.
    //
    if (OldFormat) {
        CapPin = reinterpret_cast <CCapturePin *> (Pin -> Context);
    }

    if (IsEqualGUID (Pin -> ConnectionFormat -> Specifier,
        VideoInfoSpecifier)) {

        PKS_DATAFORMAT_VIDEOINFOHEADER ConnectionFormat =
            reinterpret_cast <PKS_DATAFORMAT_VIDEOINFOHEADER> 
                (Pin -> ConnectionFormat);

        //
        // DataRange comes out of OUR data range list.  I know the range
        // is valid as such.
        //
        const KS_DATARANGE_VIDEO *VIRange =
            reinterpret_cast <const KS_DATARANGE_VIDEO *>
                (DataRange);

        //
        // Check that the format is a match for the selected range. 
        //
        if (
            (ConnectionFormat -> VideoInfoHeader.bmiHeader.biWidth !=
                VIRange -> VideoInfoHeader.bmiHeader.biWidth) ||

            (ConnectionFormat -> VideoInfoHeader.bmiHeader.biHeight !=
                VIRange -> VideoInfoHeader.bmiHeader.biHeight) ||

            (ConnectionFormat -> VideoInfoHeader.bmiHeader.biCompression !=
                VIRange -> VideoInfoHeader.bmiHeader.biCompression) 

            ) {

            Status = STATUS_NO_MATCH;

        } else {

            //
            // We can accept the format. 
            //
            Status = STATUS_SUCCESS;

            //
            // OldFormat is an indication that this is a format change.  Since
            // I do not implement the KSPROPERTY_CONNECTION_PROPOSEDATAFORMAT,
            // by default, I do not handle dynamic format changes.
            //
            // If something changes while we're in the stop state, we're fine
            // to handle it since we haven't "configured the hardware" yet.
            //
            if (OldFormat) {
                //
                // If we're in the stop state, we can handle just about any
                // change.  We don't support dynamic format changes. 
                //
                if (Pin -> DeviceState == KSSTATE_STOP) {
                    if (!CapPin -> CaptureVideoInfoHeader ()) {
                        Status = STATUS_INSUFFICIENT_RESOURCES;
                    }
                } else {
                    //
                    // Because we don't accept dynamic format changes, we
                    // should never get here.  Just being over-protective.
                    //
                    Status = STATUS_INVALID_DEVICE_STATE;
                }

            }

        }

    }

    return Status;

}

/**************************************************************************

    LOCKED CODE

**************************************************************************/

#ifdef ALLOC_PRAGMA
#pragma code_seg()
#endif // ALLOC_PRAGMA


void
CCapturePin::
CompleteMappings (
    IN ULONG NumMappings
    )

/*++

Routine Description:

    Called to notify the pin that a given number of scatter / gather
    mappings have completed.  Let the buffers go if possible.
    We're called at DPC.

Arguments:

    NumMappings -
        The number of mappings that have completed.

Return Value:

    None

--*/

{

    ULONG MappingsRemaining = NumMappings;

    //
    // Walk through the clones list and delete clones whose time has come.
    // The list is guaranteed to be kept in the order they were cloned.
    //
    PKSSTREAM_POINTER Clone = KsPinGetFirstCloneStreamPointer (m_Pin);

    while (MappingsRemaining && Clone) {

        PKSSTREAM_POINTER NextClone = KsStreamPointerGetNextClone (Clone);

        //
        // Count up the number of bytes we've completed and mark this
        // in the Stream Header.  In mapped queues 
        // (KSPIN_FLAG_GENERATE_MAPPINGS), this is the responsibility of
        // the minidriver.  In non-mapped queues, AVStream performs this.
        //
        ULONG MappingsToCount = 
            (MappingsRemaining > Clone -> OffsetOut.Remaining) ?
                 Clone -> OffsetOut.Remaining :
                 MappingsRemaining;

        //
        // Update DataUsed according to the mappings.
        //
        for (ULONG CurMapping = 0; CurMapping < MappingsToCount; CurMapping++) {
            Clone -> StreamHeader -> DataUsed +=
                Clone -> OffsetOut.Mappings [CurMapping].ByteCount;
        }

        // 
        // If we have completed all remaining mappings in this clone, it
        // is an indication that the clone is ready to be deleted and the
        // buffer released.  Set anything required in the stream header which
        // has not yet been set.  If we have a clock, we can timestamp the
        // sample.
        //
        if (MappingsRemaining >= Clone -> OffsetOut.Remaining) {

            Clone -> StreamHeader -> Duration =
                m_VideoInfoHeader -> AvgTimePerFrame;

            Clone -> StreamHeader -> PresentationTime.Numerator =
                Clone -> StreamHeader -> PresentationTime.Denominator = 1;

            //
            // If a clock has been assigned, timestamp the packets with the
            // time shown on the clock. 
            //
            if (m_Clock) {

                LONGLONG ClockTime = m_Clock -> GetTime ();

                Clone -> StreamHeader -> PresentationTime.Time = ClockTime;

                Clone -> StreamHeader -> OptionsFlags =
                    KSSTREAM_HEADER_OPTIONSF_TIMEVALID |
                    KSSTREAM_HEADER_OPTIONSF_DURATIONVALID;

            } else {
                //
                // If there is no clock, don't time stamp the packets.
                //
                Clone -> StreamHeader -> PresentationTime.Time = 0;

            }

            //
            // If all of the mappings in this clone have been completed,
            // delete the clone.  We've already updated DataUsed above.
            //
            KsStreamPointerDelete (Clone);

            MappingsRemaining -= Clone -> OffsetOut.Remaining;

        } else {
            //
            // If only part of the mappings in this clone have been completed,
            // update the pointers.  Since we're guaranteed this won't advance
            // to a new frame by the check above, it won't fail.
            //
            KsStreamPointerAdvanceOffsets (
                Clone,
                0,
                MappingsRemaining,
                FALSE
                );

            MappingsRemaining = 0;

        }

        //
        // Go to the next clone.
        //
        Clone = NextClone;

    }

    //
    // If we've used all the mappings in hardware and pended, we can kick
    // processing to happen again if we've completed mappings.
    //
    if (m_PendIo) {
        m_PendIo = TRUE;
        KsPinAttemptProcessing (m_Pin, TRUE);
    }

}

/**************************************************************************

    DISPATCH AND DESCRIPTOR LAYOUT

**************************************************************************/

#define D_X 320
#define D_Y 240

//
// FormatRGB24Bpp_Capture:
//
// This is the data range description of the RGB24 capture format we support.
//
const 
KS_DATARANGE_VIDEO 
FormatRGB24Bpp_Capture = {

    //
    // KSDATARANGE
    //
    {   
        sizeof (KS_DATARANGE_VIDEO),                // FormatSize
        0,                                          // Flags
        D_X * D_Y * 3,                              // SampleSize
        0,                                          // Reserved

        STATICGUIDOF (KSDATAFORMAT_TYPE_VIDEO),     // aka. MEDIATYPE_Video
        0xe436eb7d, 0x524f, 0x11ce, 0x9f, 0x53, 0x00, 0x20, 
            0xaf, 0x0b, 0xa7, 0x70,                 // aka. MEDIASUBTYPE_RGB24,
        STATICGUIDOF (KSDATAFORMAT_SPECIFIER_VIDEOINFO) // aka. FORMAT_VideoInfo
    },

    TRUE,               // BOOL,  bFixedSizeSamples (all samples same size?)
    TRUE,               // BOOL,  bTemporalCompression (all I frames?)
    0,                  // Reserved (was StreamDescriptionFlags)
    0,                  // Reserved (was MemoryAllocationFlags   
                        //           (KS_VIDEO_ALLOC_*))

    //
    // _KS_VIDEO_STREAM_CONFIG_CAPS  
    //
    {
        STATICGUIDOF( KSDATAFORMAT_SPECIFIER_VIDEOINFO ), // GUID
        KS_AnalogVideo_NTSC_M |
        KS_AnalogVideo_PAL_B,                    // AnalogVideoStandard
        720,480,        // InputSize, (the inherent size of the incoming signal
                        //             with every digitized pixel unique)
        160,120,        // MinCroppingSize, smallest rcSrc cropping rect allowed
        720,480,        // MaxCroppingSize, largest  rcSrc cropping rect allowed
        8,              // CropGranularityX, granularity of cropping size
        1,              // CropGranularityY
        8,              // CropAlignX, alignment of cropping rect 
        1,              // CropAlignY;
        160, 120,       // MinOutputSize, smallest bitmap stream can produce
        720, 480,       // MaxOutputSize, largest  bitmap stream can produce
        8,              // OutputGranularityX, granularity of output bitmap size
        1,              // OutputGranularityY;
        0,              // StretchTapsX  (0 no stretch, 1 pix dup, 2 interp...)
        0,              // StretchTapsY
        0,              // ShrinkTapsX 
        0,              // ShrinkTapsY 
        333667,         // MinFrameInterval, 100 nS units
        640000000,      // MaxFrameInterval, 100 nS units
        8 * 3 * 30 * 160 * 120,  // MinBitsPerSecond;
        8 * 3 * 30 * 720 * 480   // MaxBitsPerSecond;
    }, 
        
    //
    // KS_VIDEOINFOHEADER (default format)
    //
    {
        0,0,0,0,                            // RECT  rcSource; 
        0,0,0,0,                            // RECT  rcTarget; 
        D_X * D_Y * 3 * 30,                 // DWORD dwBitRate;
        0L,                                 // DWORD dwBitErrorRate; 
        333667,                             // REFERENCE_TIME  AvgTimePerFrame;   
        sizeof (KS_BITMAPINFOHEADER),       // DWORD biSize;
        D_X,                                // LONG  biWidth;
        -D_Y,                               // LONG  biHeight;
        1,                                  // WORD  biPlanes;
        24,                                 // WORD  biBitCount;
        KS_BI_RGB,                          // DWORD biCompression;
        D_X * D_Y * 3,                      // DWORD biSizeImage;
        0,                                  // LONG  biXPelsPerMeter;
        0,                                  // LONG  biYPelsPerMeter;
        0,                                  // DWORD biClrUsed;
        0                                   // DWORD biClrImportant;
    }
}; 

#undef D_X
#undef D_Y

#define D_X 320
#define D_Y 240

//
// FormatUYU2_Capture:
//
// This is the data range description of the UYVY format we support.
//
const 
KS_DATARANGE_VIDEO 
FormatUYU2_Capture = {

    //
    // KSDATARANGE
    //
    {   
        sizeof (KS_DATARANGE_VIDEO),            // FormatSize
        0,                                      // Flags
        D_X * D_Y * 2,                          // SampleSize
        0,                                      // Reserved
        STATICGUIDOF (KSDATAFORMAT_TYPE_VIDEO), // aka. MEDIATYPE_Video
        0x59565955, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 
            0x00, 0x38, 0x9b, 0x71,             // aka. MEDIASUBTYPE_UYVY,
        STATICGUIDOF (KSDATAFORMAT_SPECIFIER_VIDEOINFO) // aka. FORMAT_VideoInfo
    },

    TRUE,               // BOOL,  bFixedSizeSamples (all samples same size?)
    TRUE,               // BOOL,  bTemporalCompression (all I frames?)
    0,                  // Reserved (was StreamDescriptionFlags)
    0,                  // Reserved (was MemoryAllocationFlags   
                        //           (KS_VIDEO_ALLOC_*))

    //
    // _KS_VIDEO_STREAM_CONFIG_CAPS  
    //
    {
        STATICGUIDOF( KSDATAFORMAT_SPECIFIER_VIDEOINFO ), // GUID
        KS_AnalogVideo_NTSC_M |
        KS_AnalogVideo_PAL_B,                    // AnalogVideoStandard
        720,480,        // InputSize, (the inherent size of the incoming signal
                    //             with every digitized pixel unique)
        160,120,        // MinCroppingSize, smallest rcSrc cropping rect allowed
        720,480,        // MaxCroppingSize, largest  rcSrc cropping rect allowed
        8,              // CropGranularityX, granularity of cropping size
        1,              // CropGranularityY
        8,              // CropAlignX, alignment of cropping rect 
        1,              // CropAlignY;
        160, 120,       // MinOutputSize, smallest bitmap stream can produce
        720, 480,       // MaxOutputSize, largest  bitmap stream can produce
        8,              // OutputGranularityX, granularity of output bitmap size
        1,              // OutputGranularityY;
        0,              // StretchTapsX  (0 no stretch, 1 pix dup, 2 interp...)
        0,              // StretchTapsY
        0,              // ShrinkTapsX 
        0,              // ShrinkTapsY 
        333667,         // MinFrameInterval, 100 nS units
        640000000,      // MaxFrameInterval, 100 nS units
        8 * 2 * 30 * 160 * 120,  // MinBitsPerSecond;
        8 * 2 * 30 * 720 * 480   // MaxBitsPerSecond;
    }, 
        
    //
    // KS_VIDEOINFOHEADER (default format)
    //
    {
        0,0,0,0,                            // RECT  rcSource; 
        0,0,0,0,                            // RECT  rcTarget; 
        D_X * D_Y * 2 * 30,                 // DWORD dwBitRate;
        0L,                                 // DWORD dwBitErrorRate; 
        333667,                             // REFERENCE_TIME  AvgTimePerFrame;   
        sizeof (KS_BITMAPINFOHEADER),       // DWORD biSize;
        D_X,                                // LONG  biWidth;
        D_Y,                                // LONG  biHeight;
        1,                                  // WORD  biPlanes;
        16,                                 // WORD  biBitCount;
        FOURCC_YUV422,                      // DWORD biCompression;
        D_X * D_Y * 2,                      // DWORD biSizeImage;
        0,                                  // LONG  biXPelsPerMeter;
        0,                                  // LONG  biYPelsPerMeter;
        0,                                  // DWORD biClrUsed;
        0                                   // DWORD biClrImportant;
    }
}; 

//
// CapturePinDispatch:
//
// This is the dispatch table for the capture pin.  It provides notifications
// about creation, closure, processing, data formats, etc...
//
const
KSPIN_DISPATCH
CapturePinDispatch = {
    CCapturePin::DispatchCreate,            // Pin Create
    NULL,                                   // Pin Close
    CCapturePin::DispatchProcess,           // Pin Process
    NULL,                                   // Pin Reset
    CCapturePin::DispatchSetFormat,         // Pin Set Data Format
    CCapturePin::DispatchSetState,          // Pin Set Device State
    NULL,                                   // Pin Connect
    NULL,                                   // Pin Disconnect
    NULL,                                   // Clock Dispatch
    NULL                                    // Allocator Dispatch
};

//
// CapturePinAllocatorFraming:
//
// This is the simple framing structure for the capture pin.  Note that this
// will be modified via KsEdit when the actual capture format is determined.
//
DECLARE_SIMPLE_FRAMING_EX (
    CapturePinAllocatorFraming,
    STATICGUIDOF (KSMEMORY_TYPE_KERNEL_NONPAGED),
    KSALLOCATOR_REQUIREMENTF_SYSTEM_MEMORY |
        KSALLOCATOR_REQUIREMENTF_PREFERENCES_ONLY,
    2,
    0,
    2 * PAGE_SIZE,
    2 * PAGE_SIZE
    );

//
// CapturePinDataRanges:
//
// This is the list of data ranges supported on the capture pin.  We support
// two: one RGB24, and one UYVY.
//
const 
PKSDATARANGE 
CapturePinDataRanges [CAPTURE_PIN_DATA_RANGE_COUNT] = {
    (PKSDATARANGE) &FormatRGB24Bpp_Capture,
    (PKSDATARANGE) &FormatUYU2_Capture
    };
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\ksfilter\swenum\swenum.c ===
/*++

    Copyright (C) Microsoft Corporation, 1997 - 2001

Module Name:

    swenum.c

Abstract:

    Demand load software device enumerator.

Author:

    Bryan A. Woodruff (bryanw) 20-Feb-1997

--*/

#define KSDEBUG_INIT

#include "private.h"

#ifdef ALLOC_PRAGMA
#pragma alloc_text( PAGE, AddDevice )
#pragma alloc_text( PAGE, DispatchCreate )
#pragma alloc_text( PAGE, DispatchClose )
#pragma alloc_text( PAGE, DispatchIoControl )
#pragma alloc_text( PAGE, DispatchPnP )
#pragma alloc_text( INIT, DriverEntry )
#endif


NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    )

/*++

Routine Description:
    Main driver entry, sets up the bus device object and performs
    first enumeration.

Arguments:
    IN PDRIVER_OBJECT DriverObject -
        pointer to driver object

    IN PUNICODE_STRING RegistryPath -
        pointer to registry path

Return:
    STATUS_SUCCESS else an appropriate error code

--*/

{

    //
    // win98gold ntkern does not fill in the Service name in our
    // driver extension. but we depend on the name to have correct
    // KsCreateBusEnumObject. Try to add the Service name here.
    // Since we are statically loaded, freeing the memory is rarely
    // necessary.
    //
    #ifdef WIN98GOLD
    if ( NULL == DriverObject->DriverExtension->ServiceKeyName.Buffer ) {
        UNICODE_STRING ServiceNameU;
        ULONG          cb;

        cb = RegistryPath->Length;
        ServiceNameU.Buffer = ExAllocatePool( NonPagedPool, cb );
        if ( NULL == ServiceNameU.Buffer ) {
            return STATUS_INSUFFICIENT_RESOURCES;
        }
        RtlCopyMemory( ServiceNameU.Buffer, RegistryPath->Buffer, cb );
        ServiceNameU.MaximumLength = ServiceNameU.Length = (USHORT)cb;
        DriverObject->DriverExtension->ServiceKeyName = ServiceNameU;
    }
    #endif
    
    _DbgPrintF(
        DEBUGLVL_VERBOSE,
        ("DriverEntry, registry path = %S", RegistryPath->Buffer) );

    //
    // Fill in the driver object
    //

    DriverObject->MajorFunction[ IRP_MJ_PNP ] = DispatchPnP;
    DriverObject->MajorFunction[ IRP_MJ_POWER ] = DispatchPower;
    DriverObject->MajorFunction[ IRP_MJ_CREATE ] = DispatchCreate;
    DriverObject->MajorFunction[ IRP_MJ_DEVICE_CONTROL ] = DispatchIoControl;
    DriverObject->MajorFunction[ IRP_MJ_SYSTEM_CONTROL ] = DispatchSystemControl;
    DriverObject->MajorFunction[ IRP_MJ_CLOSE ] = DispatchClose;
    DriverObject->DriverExtension->AddDevice = AddDevice;
    DriverObject->DriverUnload = DriverUnload;

    return STATUS_SUCCESS;
}


VOID
DriverUnload(
    IN PDRIVER_OBJECT   DriverObject
    )

/*++

Routine Description:
    This is the driver unload routine for SWENUM.  It does nothing.


Arguments:
    IN PDRIVER_OBJECT DriverObject -
        pointer to the driver object

Return:
    Nothing.

--*/

{
    return;
}


NTSTATUS
AddDevice(
    IN PDRIVER_OBJECT DriverObject,
    IN PDEVICE_OBJECT PhysicalDeviceObject
    )

/*++

Routine Description:
    Called by the PnP manager when a new device is instantiated.

Arguments:
    IN PDRIVER_OBJECT DriverObject -
        pointer to the driver object

    IN PDEVICE_OBJECT PhysicalDeviceObject -
        pointer to the physical device object

Return:
    STATUS_SUCCESS else an appropriate error code

--*/

{
    PDEVICE_OBJECT      FunctionalDeviceObject;
    NTSTATUS            Status;

    PAGED_CODE();

    //
    // On AddDevice, we are given the physical device object (PDO)
    // for the bus.  Create the associcated functional device object (FDO).
    //

    _DbgPrintF( DEBUGLVL_VERBOSE, ("AddDevice") );

    //
    // Note, there is only one instance of this device allowed.  The
    // static device name will guarantee an object name collision if
    // another instance is already installed.
    //

    Status = IoCreateDevice(
                DriverObject,               // our driver object
                sizeof( PVOID ),            // size of our extension
                NULL,                       // our name for the FDO
                FILE_DEVICE_BUS_EXTENDER,   // device type
                0,                          // device characteristics
                FALSE,                      // not exclusive
                &FunctionalDeviceObject     // store new device object here
                );

    if(!NT_SUCCESS( Status )) {
        _DbgPrintF(
            DEBUGLVL_ERROR,
            ("failed to create FDO, status = %x.", Status) );

        return Status;
    }

    //
    // Clear the device extension
    //
    *(PVOID *)FunctionalDeviceObject->DeviceExtension = NULL;

    //
    // Create the bus enumerator object
    //

    Status =
        KsCreateBusEnumObject(
            L"SW",
            FunctionalDeviceObject,
            PhysicalDeviceObject,
            NULL, // PDEVICE_OBJECT PnpDeviceObject
            &BUSID_SoftwareDeviceEnumerator,
            L"Devices" );

    if (!NT_SUCCESS( Status )) {
        _DbgPrintF(
            DEBUGLVL_ERROR,
            ("failed KsCreateBusEnumObject: %08x", Status) );
        IoDeleteDevice( FunctionalDeviceObject );
        return Status;
    }

    FunctionalDeviceObject->Flags |= DO_POWER_PAGABLE;
    FunctionalDeviceObject->Flags &= ~DO_DEVICE_INITIALIZING;

    return STATUS_SUCCESS;
}

NTSTATUS
DispatchPnP(
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    )

/*++

Routine Description:
    This is the main entry point for the IRP_MJ_PNP dispatch, the exported
    service is used for processing.

Arguments:
    IN PDEVICE_OBJECT DeviceObject -
        pointer to the device object

    IN OUT PIRP Irp -
        pointer to the associated Irp

Return:
    NTSTATUS code

--*/

{
    BOOLEAN                 ChildDevice;
    PIO_STACK_LOCATION      irpSp;
    NTSTATUS                Status;
    PDEVICE_OBJECT          PnpDeviceObject;

    irpSp = IoGetCurrentIrpStackLocation( Irp );

    //
    // Get the PnpDeviceObject and determine FDO/PDO.
    //

    Status = KsIsBusEnumChildDevice( DeviceObject, &ChildDevice );

    //
    // If we're unable to obtain any of this information, fail now.
    //

    if (!NT_SUCCESS( Status )) {
        return CompleteIrp( Irp, Status, IO_NO_INCREMENT );
    }

    Status = KsServiceBusEnumPnpRequest( DeviceObject, Irp );

    //
    // FDO processing may return STATUS_NOT_SUPPORTED or may require
    // overrides.
    //

    if (!ChildDevice) {
        NTSTATUS tempStatus;

        //
        // FDO case
        //
        // First retrieve the DO we will forward everything to...
        //
        tempStatus = KsGetBusEnumPnpDeviceObject( DeviceObject, &PnpDeviceObject );

        if (!NT_SUCCESS( tempStatus )) {
            //
            // No DO to forward to. Actually a fatal error, but just complete
            // with an error status.
            //
            return CompleteIrp( Irp, tempStatus, IO_NO_INCREMENT );
        }

        switch (irpSp->MinorFunction) {

        case IRP_MN_QUERY_RESOURCES:
        case IRP_MN_QUERY_RESOURCE_REQUIREMENTS:
            //
            // This is normally passed on to the PDO, but since this is a
            // software only device, resources are not required.
            //
            Irp->IoStatus.Information = (ULONG_PTR)NULL;
            Status = STATUS_SUCCESS;
            break;

        case IRP_MN_QUERY_PNP_DEVICE_STATE:
            {
                //
                // Mark the device as not disableable.
                //
                PPNP_DEVICE_STATE DeviceState;

                DeviceState = (PPNP_DEVICE_STATE) &Irp->IoStatus.Information;
                *DeviceState |= PNP_DEVICE_NOT_DISABLEABLE;
                Status = STATUS_SUCCESS;
            }
            break;

        case IRP_MN_QUERY_DEVICE_RELATIONS:

            //
            // Forward everything...
            //
            break;

        case IRP_MN_REMOVE_DEVICE:
            //
            // The KsBusEnum services cleaned up attachments, etc. However,
            // we must remove our own FDO.
            //
            Status = STATUS_SUCCESS;
            IoDeleteDevice( DeviceObject );
            break;
        }

        if (Status != STATUS_NOT_SUPPORTED) {

            //
            // Set the Irp status only if we have something to add.
            //
            Irp->IoStatus.Status = Status;
        }


        //
        // Forward this IRP down the stack only if we are successful or
        // we don't know how to handle this Irp.
        //
        if (NT_SUCCESS( Status ) || (Status == STATUS_NOT_SUPPORTED)) {

            IoSkipCurrentIrpStackLocation(Irp);
            return IoCallDriver( PnpDeviceObject, Irp );
        }

        //
        // On error, fall through and complete the IRP with the status.
        //
    }


    //
    // KsServiceBusEnumPnpRequest() handles all other child PDO requests.
    //

    if (Status != STATUS_NOT_SUPPORTED) {
        Irp->IoStatus.Status = Status;
    } else {
        Status = Irp->IoStatus.Status;
    }
    IoCompleteRequest( Irp, IO_NO_INCREMENT );
    return Status;
}


NTSTATUS
DispatchSystemControl(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:
    Handler for system control IRPs.

Arguments:
    IN PDEVICE_OBJECT DeviceObject -
        pointer to the device object

    IN PIRP Irp -
        pointer to the I/O request packet for IRP_MJ_SYSTEM_CONTROL

Return:
    NTSTATUS code

--*/

{
    BOOLEAN                 ChildDevice;
    PIO_STACK_LOCATION      irpSp;
    NTSTATUS                Status;
    PDEVICE_OBJECT          PnpDeviceObject;

    //
    // Get the PnpDeviceObject and determine FDO/PDO.
    //

    Status = KsIsBusEnumChildDevice( DeviceObject, &ChildDevice );

    //
    // If we're unable to obtain any of this information, fail now.
    //

    if (!NT_SUCCESS( Status )) {
        return CompleteIrp( Irp, Status, IO_NO_INCREMENT );
    }

    if (!ChildDevice) {

        //
        // FDO case
        //
        // We will need the DO we will forward everything to...
        //
        Status = KsGetBusEnumPnpDeviceObject( DeviceObject, &PnpDeviceObject );

        if (!NT_SUCCESS( Status )) {
            //
            // No DO to forward to. Actually a fatal error, but just complete
            // with an error status.
            //
            return CompleteIrp( Irp, Status, IO_NO_INCREMENT );
        }

        //
        // Forward this IRP down the stack.
        //
        IoSkipCurrentIrpStackLocation(Irp);
        return IoCallDriver( PnpDeviceObject, Irp );
    }

    Status = Irp->IoStatus.Status;
    return CompleteIrp( Irp, Status, IO_NO_INCREMENT );
}


NTSTATUS
DispatchPower(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:
    Dispatch handler for IRP_MJ_POWER

Arguments:
    IN PDEVICE_OBJECT DeviceObject -
        pointer to the device object

    IN PIRP Irp -
        pointer to the I/O request packet

Return:
    NTSTATUS code

--*/

{
    BOOLEAN                 ChildDevice;
    PIO_STACK_LOCATION      irpSp;
    NTSTATUS                Status;
    PDEVICE_OBJECT          PnpDeviceObject;

    irpSp = IoGetCurrentIrpStackLocation( Irp );

    //
    // Get the PnpDeviceObject and determine FDO/PDO.
    //

    Status = KsIsBusEnumChildDevice( DeviceObject, &ChildDevice );

    //
    // If we're unable to obtain any of this information, fail now.
    //

    if (!NT_SUCCESS( Status )) {
        PoStartNextPowerIrp(Irp);
        return CompleteIrp( Irp, Status, IO_NO_INCREMENT );
    }

    if (!ChildDevice) {

        NTSTATUS tempStatus;

        //
        // FDO case
        //
        // We will need the DO we will forward everything to...
        //
        tempStatus = KsGetBusEnumPnpDeviceObject( DeviceObject, &PnpDeviceObject );

        if (!NT_SUCCESS( tempStatus )) {
            //
            // No DO to forward to. Actually a fatal error, but just complete
            // with an error status.
            //
            PoStartNextPowerIrp(Irp);
            return CompleteIrp( Irp, tempStatus, IO_NO_INCREMENT );
        }
    }

    switch (irpSp->MinorFunction) {

    case IRP_MN_QUERY_POWER:
    case IRP_MN_SET_POWER:

        switch (irpSp->Parameters.Power.Type) {

        case DevicePowerState:
        case SystemPowerState:

            Status = STATUS_SUCCESS;
            break;

        default:
            Status = STATUS_NOT_SUPPORTED;
            break;

        }
        break;

    default:
        Status = STATUS_NOT_SUPPORTED;
        break;
    }

    if (Status != STATUS_NOT_SUPPORTED) {

        Irp->IoStatus.Status = Status;
    }

    if ((!ChildDevice) && (NT_SUCCESS(Status) || (Status == STATUS_NOT_SUPPORTED))) {

        PoStartNextPowerIrp(Irp);
        IoSkipCurrentIrpStackLocation(Irp);
        return PoCallDriver( PnpDeviceObject, Irp );

    } else {
        Status = Irp->IoStatus.Status;
        PoStartNextPowerIrp( Irp );
        return CompleteIrp( Irp, Status, IO_NO_INCREMENT );
    }
}

NTSTATUS
DispatchCreate(
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    )

/*++

Routine Description:
    Processes the create request for the SWENUM device.

Arguments:
    IN PDEVICE_OBJECT DeviceObject -
        pointer to the device object

    IN OUT PIRP Irp -
        pointer to the I/O request packet

Return:
    NTSTATUS code

--*/

{
    BOOLEAN             ChildDevice;
    NTSTATUS            Status;
    PIO_STACK_LOCATION  irpSp;

    PAGED_CODE();

    Status = KsIsBusEnumChildDevice( DeviceObject, &ChildDevice );
    if (NT_SUCCESS( Status )) {

        irpSp = IoGetCurrentIrpStackLocation( Irp );

        if (!ChildDevice) {
            if (!irpSp->FileObject->FileName.Length) {
                //
                // This is a request for the bus, if and only if there
                // is no filename specified.
                //
                Status = STATUS_SUCCESS;
            } else {
                //
                // Redirection to the child PDO.
                //
                Status = KsServiceBusEnumCreateRequest( DeviceObject, Irp );
            }
        } else {
            Status = STATUS_OBJECT_NAME_NOT_FOUND;
        }
    }

    if (Status != STATUS_PENDING) {
        Irp->IoStatus.Status = Status;
        IoCompleteRequest( Irp, IO_NO_INCREMENT );
    }
    return Status;
}


NTSTATUS
DispatchIoControl(
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    )

/*++

Routine Description:
    Process I/O control requests for the SWENUM device.

Arguments:
    IN PDEVICE_OBJECT DeviceObject -
        pointer to the device object

    IN OUT PIRP Irp -
        pointer to the I/O request packet

Return:
    STATUS_SUCCESS or STATUS_INVALID_DEVICE_REQUEST

--*/

{
    NTSTATUS            Status;
    PIO_STACK_LOCATION  irpSp;

    PAGED_CODE();

    irpSp = IoGetCurrentIrpStackLocation( Irp );

    _DbgPrintF( DEBUGLVL_BLAB, ("DispatchIoControl") );

    switch (irpSp->Parameters.DeviceIoControl.IoControlCode) {

    case IOCTL_SWENUM_INSTALL_INTERFACE:
        Status = KsInstallBusEnumInterface( Irp );
        break;

    case IOCTL_SWENUM_GET_BUS_ID:
        Status = KsGetBusEnumIdentifier( Irp );
        break;

    case IOCTL_SWENUM_REMOVE_INTERFACE:
        Status = KsRemoveBusEnumInterface( Irp );
        break;

    default:
        Status = STATUS_INVALID_DEVICE_REQUEST;
        break;

    }

    return CompleteIrp( Irp, Status, IO_NO_INCREMENT );
}


NTSTATUS
DispatchClose(
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    )

/*++

Routine Description:
    Processes the close request for the SWENUM device.

Arguments:
    IN PDEVICE_OBJECT DeviceObject -
        pointer to the device object

    IN OUT PIRP Irp -
        pointer to the I/O request packet

Return:
    STATUS_SUCCESS

--*/

{
    PAGED_CODE();

    _DbgPrintF( DEBUGLVL_BLAB, ("DispatchClose") );

    return CompleteIrp( Irp, STATUS_SUCCESS, IO_NO_INCREMENT );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\ksfilter\tests\avshws\filter.cpp ===
/**************************************************************************

    AVStream Simulated Hardware Sample

    Copyright (c) 2001, Microsoft Corporation.

    File:

        filter.cpp

    Abstract:

        This file contains the filter level implementation for the 
        capture filter.

    History:

        created 3/12/2001

**************************************************************************/

#include "avshws.h"

/**************************************************************************

    PAGEABLE CODE

**************************************************************************/

#ifdef ALLOC_PRAGMA
#pragma code_seg("PAGE")
#endif // ALLOC_PRAGMA


NTSTATUS
CCaptureFilter::
DispatchCreate (
    IN PKSFILTER Filter,
    IN PIRP Irp
    )

/*++

Routine Description:

    This is the creation dispatch for the capture filter.  It creates
    the CCaptureFilter object, associates it with the AVStream filter
    object, and bag the CCaptureFilter for later cleanup.

Arguments:

    Filter -
        The AVStream filter being created

    Irp -
        The creation Irp

Return Value:
    
    Success / failure

--*/

{

    PAGED_CODE();

    NTSTATUS Status = STATUS_SUCCESS;

    CCaptureFilter *CapFilter = new (NonPagedPool) CCaptureFilter (Filter);

    if (!CapFilter) {
        //
        // Return failure if we couldn't create the filter.
        //
        Status = STATUS_INSUFFICIENT_RESOURCES;

    } else {
        //
        // Add the item to the object bag if we we were successful. 
        // Whenever the filter closes, the bag is cleaned up and we will be
        // freed.
        //
        Status = KsAddItemToObjectBag (
            Filter -> Bag,
            reinterpret_cast <PVOID> (CapFilter),
            reinterpret_cast <PFNKSFREE> (CCaptureFilter::Cleanup)
            );

        if (!NT_SUCCESS (Status)) {
            delete CapFilter;
        } else {
            Filter -> Context = reinterpret_cast <PVOID> (CapFilter);
        }

    }

    return Status;

}

/**************************************************************************

    DESCRIPTOR AND DISPATCH LAYOUT

**************************************************************************/

GUID g_PINNAME_VIDEO_CAPTURE = {STATIC_PINNAME_VIDEO_CAPTURE};

//
// CaptureFilterCategories:
//
// The list of category GUIDs for the capture filter.
//
const
GUID
CaptureFilterCategories [CAPTURE_FILTER_CATEGORIES_COUNT] = {
    STATICGUIDOF (KSCATEGORY_VIDEO),
    STATICGUIDOF (KSCATEGORY_CAPTURE)
};

//
// CaptureFilterPinDescriptors:
//
// The list of pin descriptors on the capture filter.  
//
const 
KSPIN_DESCRIPTOR_EX
CaptureFilterPinDescriptors [CAPTURE_FILTER_PIN_COUNT] = {
    //
    // Capture Pin
    //
    {
        &CapturePinDispatch,
        NULL,             
        {
            NULL,                           // Interfaces (NULL, 0 == default)
            0,
            NULL,                           // Mediums (NULL, 0 == default)
            0,
            SIZEOF_ARRAY (CapturePinDataRanges), // Range Count
            CapturePinDataRanges,           // Ranges
            KSPIN_DATAFLOW_OUT,             // Dataflow
            KSPIN_COMMUNICATION_BOTH,       // Communication
            &KSCATEGORY_VIDEO,              // Category
            &g_PINNAME_VIDEO_CAPTURE,       // Name
            0                               // Reserved
        },
        
        KSPIN_FLAG_GENERATE_MAPPINGS |      // Pin Flags
            KSPIN_FLAG_DISPATCH_LEVEL_PROCESSING |
            KSPIN_FLAG_PROCESS_IN_RUN_STATE_ONLY,
        1,                                  // Instances Possible
        1,                                  // Instances Necessary
        &CapturePinAllocatorFraming,        // Allocator Framing
        reinterpret_cast <PFNKSINTERSECTHANDLEREX> 
            (CCapturePin::IntersectHandler)
    }
    
};

//
// CaptureFilterDispatch:
//
// This is the dispatch table for the capture filter.  It provides notification
// of creation, closure, processing (for filter-centrics, not for the capture
// filter), and resets (for filter-centrics, not for the capture filter).
//
const 
KSFILTER_DISPATCH
CaptureFilterDispatch = {
    CCaptureFilter::DispatchCreate,         // Filter Create
    NULL,                                   // Filter Close
    NULL,                                   // Filter Process
    NULL                                    // Filter Reset
};

//
// CaptureFilterDescription:
//
// The descriptor for the capture filter.  We don't specify any topology
// since there's only one pin on the filter.  Realistically, there would
// be some topological relationships here because there would be input 
// pins from crossbars and the like.
//
const 
KSFILTER_DESCRIPTOR 
CaptureFilterDescriptor = {
    &CaptureFilterDispatch,                 // Dispatch Table
    NULL,                                   // Automation Table
    KSFILTER_DESCRIPTOR_VERSION,            // Version
    0,                                      // Flags
    &KSNAME_Filter,                         // Reference GUID
    DEFINE_KSFILTER_PIN_DESCRIPTORS (CaptureFilterPinDescriptors),
    DEFINE_KSFILTER_CATEGORIES (CaptureFilterCategories),

    0,
    sizeof (KSNODE_DESCRIPTOR),
    NULL,
    0,
    NULL,

    NULL                                    // Component ID
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\ksfilter\tests\avshws\device.cpp ===
/**************************************************************************

    AVStream Simulated Hardware Sample

    Copyright (c) 2001, Microsoft Corporation.

    File:

        device.cpp

    Abstract:

        This file contains the device level implementation of the AVStream
        hardware sample.  Note that this is not the "fake" hardware.  The
        "fake" hardware is in hwsim.cpp.

    History:

        created 3/9/2001

**************************************************************************/

#include "avshws.h"

/**************************************************************************

    PAGEABLE CODE

**************************************************************************/

#ifdef ALLOC_PRAGMA
#pragma code_seg("PAGE")
#endif // ALLOC_PRAGMA


NTSTATUS
CCaptureDevice::
DispatchCreate (
    IN PKSDEVICE Device
    )

/*++

Routine Description:

    Create the capture device.  This is the creation dispatch for the
    capture device.

Arguments:

    Device -
        The AVStream device being created.

Return Value:

    Success / Failure

--*/

{

    PAGED_CODE();

    NTSTATUS Status;

    CCaptureDevice *CapDevice = new (NonPagedPool) CCaptureDevice (Device);

    if (!CapDevice) {
        //
        // Return failure if we couldn't create the pin.
        //
        Status = STATUS_INSUFFICIENT_RESOURCES;

    } else {

        //
        // Add the item to the object bag if we were successful.
        // Whenever the device goes away, the bag is cleaned up and
        // we will be freed.
        //
        // For backwards compatibility with DirectX 8.0, we must grab
        // the device mutex before doing this.  For Windows XP, this is
        // not required, but it is still safe.
        //
        KsAcquireDevice (Device);
        Status = KsAddItemToObjectBag (
            Device -> Bag,
            reinterpret_cast <PVOID> (CapDevice),
            reinterpret_cast <PFNKSFREE> (CCaptureDevice::Cleanup)
            );
        KsReleaseDevice (Device);

        if (!NT_SUCCESS (Status)) {
            delete CapDevice;
        } else {
            Device -> Context = reinterpret_cast <PVOID> (CapDevice);
        }

    }

    return Status;

}

/*************************************************/


NTSTATUS
CCaptureDevice::
PnpStart (
    IN PCM_RESOURCE_LIST TranslatedResourceList,
    IN PCM_RESOURCE_LIST UntranslatedResourceList
    )

/*++

Routine Description:

    Called at Pnp start.  We start up our virtual hardware simulation.

Arguments:

    TranslatedResourceList -
        The translated resource list from Pnp

    UntranslatedResourceList -
        The untranslated resource list from Pnp

Return Value:

    Success / Failure

--*/

{

    PAGED_CODE();

    //
    // Normally, we'd do things here like parsing the resource lists and
    // connecting our interrupt.  Since this is a simulation, there isn't
    // much to parse.  The parsing and connection should be the same as
    // any WDM driver.  The sections that will differ are illustrated below
    // in setting up a simulated DMA.
    //

    NTSTATUS Status = STATUS_SUCCESS;

    //
    // By PnP, it's possible to receive multiple starts without an intervening
    // stop (to reevaluate resources, for example).  Thus, we only perform
    // creations of the simulation on the initial start and ignore any 
    // subsequent start.  Hardware drivers with resources should evaluate
    // resources and make changes on 2nd start.
    //
    if (!m_Device -> Started) {

        m_HardwareSimulation = new (NonPagedPool) CHardwareSimulation (this);
            if (!m_HardwareSimulation) {
            //
            // If we couldn't create the hardware simulation, fail.
            //
            Status = STATUS_INSUFFICIENT_RESOURCES;
    
        }
    
        INTERFACE_TYPE InterfaceBuffer;
        ULONG InterfaceLength;
        DEVICE_DESCRIPTION DeviceDescription;
        NTSTATUS IfStatus;
    
        if (NT_SUCCESS (Status)) {
            //
            // Set up DMA...
            //
            IfStatus = IoGetDeviceProperty (
                m_Device -> PhysicalDeviceObject,
                DevicePropertyLegacyBusType,
                sizeof (INTERFACE_TYPE),
                &InterfaceBuffer,
                &InterfaceLength
                );

            //
            // Initialize our fake device description.  We claim to be a 
            // bus-mastering 32-bit scatter/gather capable piece of hardware.
            //
            // Ordinarilly, we'd be using InterfaceBuffer or 
            // InterfaceTypeUndefined if !NT_SUCCESS (IfStatus) as the 
            // InterfaceType below; however, for the purposes of this sample, 
            // we lie and say we're on the PCI Bus.  Otherwise, we're using map
            // registers on x86 32 bit physical to 32 bit logical and this isn't
            // what I want to show in this sample.
            //
            DeviceDescription.Version = DEVICE_DESCRIPTION_VERSION;
            DeviceDescription.DmaChannel = ((ULONG) ~0);
            DeviceDescription.InterfaceType = PCIBus;
            DeviceDescription.DmaWidth = Width32Bits;
            DeviceDescription.DmaSpeed = Compatible;
            DeviceDescription.ScatterGather = TRUE;
            DeviceDescription.Master = TRUE;
            DeviceDescription.Dma32BitAddresses = TRUE;
            DeviceDescription.AutoInitialize = FALSE;
            DeviceDescription.MaximumLength = (ULONG) -1;
    
            //
            // Get a DMA adapter object from the system.
            //
            m_DmaAdapterObject = IoGetDmaAdapter (
                m_Device -> PhysicalDeviceObject,
                &DeviceDescription,
                &m_NumberOfMapRegisters
                );
    
            if (!m_DmaAdapterObject) {
                Status = STATUS_UNSUCCESSFUL;
            }
    
        }
    
        if (NT_SUCCESS (Status)) {
            //
            // Initialize our DMA adapter object with AVStream.  This is 
            // **ONLY** necessary **IF** you are doing DMA directly into
            // capture buffers as this sample does.  For this,
            // KSPIN_FLAG_GENERATE_MAPPINGS must be specified on a queue.
            //
    
            //
            // The (1 << 20) below is the maximum size of a single s/g mapping
            // that this hardware can handle.  Note that I have pulled this
            // number out of thin air for the "fake" hardware.
            //
            KsDeviceRegisterAdapterObject (
                m_Device,
                m_DmaAdapterObject,
                (1 << 20),
                sizeof (KSMAPPING)
                );
    
        }

    }
    
    return Status;

}

/*************************************************/


void
CCaptureDevice::
PnpStop (
    )

/*++

Routine Description:

    This is the pnp stop dispatch for the capture device.  It releases any
    adapter object previously allocated by IoGetDmaAdapter during Pnp Start.

Arguments:

    None

Return Value:

    None

--*/

{

    if (m_DmaAdapterObject) {
        //
        // Return the DMA adapter back to the system.
        //
        m_DmaAdapterObject -> DmaOperations -> 
            PutDmaAdapter (m_DmaAdapterObject);

        m_DmaAdapterObject = NULL;
    }

}

/*************************************************/


NTSTATUS
CCaptureDevice::
AcquireHardwareResources (
    IN ICaptureSink *CaptureSink,
    IN PKS_VIDEOINFOHEADER VideoInfoHeader
    )

/*++

Routine Description:

    Acquire hardware resources for the capture hardware.  If the 
    resources are already acquired, this will return an error.
    The hardware configuration must be passed as a VideoInfoHeader.

Arguments:

    CaptureSink -
        The capture sink attempting to acquire resources.  When scatter /
        gather mappings are completed, the capture sink specified here is
        what is notified of the completions.

    VideoInfoHeader -
        Information about the capture stream.  This **MUST** remain
        stable until the caller releases hardware resources.  Note
        that this could also be guaranteed by bagging it in the device
        object bag as well.

Return Value:

    Success / Failure

--*/

{

    PAGED_CODE();

    NTSTATUS Status = STATUS_SUCCESS;

    //
    // If we're the first pin to go into acquire (remember we can have
    // a filter in another graph going simultaneously), grab the resources.
    //
    if (InterlockedCompareExchange (
        &m_PinsWithResources,
        1,
        0) == 0) {

        m_VideoInfoHeader = VideoInfoHeader;

        //
        // If there's an old hardware simulation sitting around for some
        // reason, blow it away.
        //
        if (m_ImageSynth) {

            KsRemoveItemFromObjectBag (
                m_Device -> Bag,
                m_ImageSynth,
                TRUE
                );

            m_ImageSynth = NULL;
        }
    
        //
        // Create the necessary type of image synthesizer.
        //
        if (m_VideoInfoHeader -> bmiHeader.biBitCount == 24 &&
            m_VideoInfoHeader -> bmiHeader.biCompression == KS_BI_RGB) {
    
            //
            // If we're RGB24, create a new RGB24 synth.  RGB24 surfaces
            // can be in either orientation.  The origin is lower left if
            // height < 0.  Otherwise, it's upper left.
            //
            m_ImageSynth = new (NonPagedPool, 'RysI') 
                CRGB24Synthesizer (
                    m_VideoInfoHeader -> bmiHeader.biHeight >= 0
                    );
    
        } else
        if (m_VideoInfoHeader -> bmiHeader.biBitCount == 16 &&
            m_VideoInfoHeader -> bmiHeader.biCompression == FOURCC_YUV422) {
    
            //
            // If we're UYVY, create the YUV synth.
            //
            m_ImageSynth = new(NonPagedPool, 'YysI') CYUVSynthesizer;
    
        }
        else
            //
            // We don't synthesize anything but RGB 24 and UYVY.
            //
            Status = STATUS_INVALID_PARAMETER;
    
        if (NT_SUCCESS (Status) && !m_ImageSynth) {
    
            Status = STATUS_INSUFFICIENT_RESOURCES;
    
        } 

        //
        // Bag the image synthesizer.
        //
        if (NT_SUCCESS (Status)) {

            Status = KsAddItemToObjectBag (
                m_Device -> Bag,
                m_ImageSynth,
                reinterpret_cast <PFNKSFREE> (CCaptureDevice::CleanupSynth)
                );

            if (!NT_SUCCESS (Status)) {

                delete m_ImageSynth;
                m_ImageSynth = NULL;

            } else {

                //
                // If everything has succeeded thus far, set the capture sink.
                //
                m_CaptureSink = CaptureSink;

            }

        } else {
            //
            // If anything failed in here, we release the resources we've
            // acquired.
            //
            ReleaseHardwareResources ();
        }
    
    } else {

        //
        // TODO: Better status code?
        //
        Status = STATUS_SHARING_VIOLATION;

    }

    return Status;

}

/*************************************************/


void
CCaptureDevice::
ReleaseHardwareResources (
    )

/*++

Routine Description:

    Release hardware resources.  This should only be called by
    an object which has acquired them.

Arguments:

    None

Return Value:

    None

--*/

{

    PAGED_CODE();

    //
    // Blow away the image synth.
    //
    if (m_ImageSynth) {

        KsRemoveItemFromObjectBag (
            m_Device -> Bag,
            m_ImageSynth,
            TRUE
            );

        m_ImageSynth = NULL;

    }

    m_VideoInfoHeader = NULL;
    m_CaptureSink = NULL;

    //
    // Release our "lock" on hardware resources.  This will allow another
    // pin (perhaps in another graph) to acquire them.
    //
    InterlockedExchange (
        &m_PinsWithResources,
        0
        );

}

/*************************************************/


NTSTATUS
CCaptureDevice::
Start (
    )

/*++

Routine Description:

    Start the capture device based on the video info header we were told
    about when resources were acquired.

Arguments:

    None

Return Value:

    Success / Failure

--*/

{

    PAGED_CODE();

    m_LastMappingsCompleted = 0;
    m_InterruptTime = 0;

    return
        m_HardwareSimulation -> Start (
            m_ImageSynth,
            m_VideoInfoHeader -> AvgTimePerFrame,
            m_VideoInfoHeader -> bmiHeader.biWidth,
            ABS (m_VideoInfoHeader -> bmiHeader.biHeight),
            m_VideoInfoHeader -> bmiHeader.biSizeImage
            );


}

/*************************************************/


NTSTATUS
CCaptureDevice::
Pause (
    IN BOOLEAN Pausing
    )

/*++

Routine Description:

    Pause or unpause the hardware simulation.  This is an effective start
    or stop without resetting counters and formats.  Note that this can
    only be called to transition from started -> paused -> started.  Calling
    this without starting the hardware with Start() does nothing.

Arguments:

    Pausing -
        An indicatation of whether we are pausing or unpausing

        TRUE -
            Pause the hardware simulation

        FALSE -
            Unpause the hardware simulation

Return Value:

    Success / Failure

--*/

{

    PAGED_CODE();

    return
        m_HardwareSimulation -> Pause (
            Pausing
            );

}

/*************************************************/


NTSTATUS
CCaptureDevice::
Stop (
    )

/*++

Routine Description:

    Stop the capture device.

Arguments:

    None

Return Value:

    Success / Failure

--*/

{

    PAGED_CODE();

    return
        m_HardwareSimulation -> Stop ();

}

/*************************************************/


ULONG
CCaptureDevice::
ProgramScatterGatherMappings (
    IN PUCHAR *Buffer,
    IN PKSMAPPING Mappings,
    IN ULONG MappingsCount
    )

/*++

Routine Description:

    Program the scatter / gather mappings for the "fake" hardware.

Arguments:

    Buffer -
        Points to a pointer to the virtual address of the topmost
        scatter / gather chunk.  The pointer will be updated as the
        device "programs" mappings.  Reason for this is that we get
        the physical addresses and sizes, but must calculate the virtual
        addresses...  This is used as scratch space for that.

    Mappings -
        An array of mappings to program

    MappingsCount -
        The count of mappings in the array

Return Value:

    The number of mappings successfully programmed

--*/

{

    PAGED_CODE();

    return 
        m_HardwareSimulation -> ProgramScatterGatherMappings (
            Buffer,
            Mappings,
            MappingsCount,
            sizeof (KSMAPPING)
            );

}

/*************************************************************************

    LOCKED CODE

**************************************************************************/

#ifdef ALLOC_PRAGMA
#pragma code_seg()
#endif // ALLOC_PRAGMA


ULONG
CCaptureDevice::
QueryInterruptTime (
    )

/*++

Routine Description:

    Return the number of frame intervals that have elapsed since the
    start of the device.  This will be the frame number.

Arguments:

    None

Return Value:

    The interrupt time of the device (the number of frame intervals that
    have elapsed since the start of the device).

--*/

{

    return m_InterruptTime;

}

/*************************************************/


void
CCaptureDevice::
Interrupt (
    )

/*++

Routine Description:

    This is the "faked" interrupt service routine for this device.  It
    is called at dispatch level by the hardware simulation.

Arguments:

    None

Return Value:

    None

--*/

{

    m_InterruptTime++;

    //
    // Realistically, we'd do some hardware manipulation here and then queue
    // a DPC.  Since this is fake hardware, we do what's necessary here.  This
    // is pretty much what the DPC would look like short of the access
    // of hardware registers (ReadNumberOfMappingsCompleted) which would likely
    // be done in the ISR.
    //
    ULONG NumMappingsCompleted = 
        m_HardwareSimulation -> ReadNumberOfMappingsCompleted ();

    //
    // Inform the capture sink that a given number of scatter / gather
    // mappings have completed.
    //
    m_CaptureSink -> CompleteMappings (
        NumMappingsCompleted - m_LastMappingsCompleted
        );

    m_LastMappingsCompleted = NumMappingsCompleted;

}

/**************************************************************************

    DESCRIPTOR AND DISPATCH LAYOUT

**************************************************************************/

//
// CaptureFilterDescriptor:
//
// The filter descriptor for the capture device.
DEFINE_KSFILTER_DESCRIPTOR_TABLE (FilterDescriptors) { 
    &CaptureFilterDescriptor
};

//
// CaptureDeviceDispatch:
//
// This is the dispatch table for the capture device.  Plug and play
// notifications as well as power management notifications are dispatched
// through this table.
//
const
KSDEVICE_DISPATCH
CaptureDeviceDispatch = {
    CCaptureDevice::DispatchCreate,         // Pnp Add Device
    CCaptureDevice::DispatchPnpStart,       // Pnp Start
    NULL,                                   // Post-Start
    NULL,                                   // Pnp Query Stop
    NULL,                                   // Pnp Cancel Stop
    NULL,                                   // Pnp Query Remove
    NULL,                                   // Pnp Cancel Remove
    NULL,                                   // Pnp Remove
    NULL,                                   // Pnp Query Capabilities
    NULL,                                   // Pnp Surprise Removal
    NULL,                                   // Power Query Power
    NULL,                                   // Power Set Power
    NULL                                    // Pnp Query Interface
};

//
// CaptureDeviceDescriptor:
//
// This is the device descriptor for the capture device.  It points to the
// dispatch table and contains a list of filter descriptors that describe
// filter-types that this device supports.  Note that the filter-descriptors
// can be created dynamically and the factories created via 
// KsCreateFilterFactory as well.  
//
const
KSDEVICE_DESCRIPTOR
CaptureDeviceDescriptor = {
    &CaptureDeviceDispatch,
    SIZEOF_ARRAY (FilterDescriptors),
    FilterDescriptors,
    KSDEVICE_DESCRIPTOR_VERSION
};

/**************************************************************************

    INITIALIZATION CODE

**************************************************************************/


extern "C"
NTSTATUS
DriverEntry (
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    )

/*++

Routine Description:

    Driver entry point.  Pass off control to the AVStream initialization
    function (KsInitializeDriver) and return the status code from it.

Arguments:

    DriverObject -
        The WDM driver object for our driver

    RegistryPath -
        The registry path for our registry info

Return Value:

    As from KsInitializeDriver

--*/

{

    //
    // Simply pass the device descriptor and parameters off to AVStream
    // to initialize us.  This will cause filter factories to be set up
    // at add & start.  Everything is done based on the descriptors passed
    // here.
    //
    return 
        KsInitializeDriver (
            DriverObject,
            RegistryPath,
            &CaptureDeviceDescriptor
            );

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\ksfilter\tests\avshws\filter.h ===
/**************************************************************************

    AVStream Simulated Hardware Sample

    Copyright (c) 2001, Microsoft Corporation.

    File:

        filter.h

    Abstract:

        This file contains the filter level header for the capture filter.

    History:

        created 3/12/2001

**************************************************************************/

class CCaptureFilter {

private:

    //
    // The AVStream filter object associated with this CCaptureFilter.
    //
    PKSFILTER m_Filter;

    //
    // Cleanup():
    //
    // This is the bag cleanup callback for the CCaptureFilter.  Not providing
    // one would cause ExFreePool to be used.  This is not good for C++
    // constructed objects.  We simply delete the object here.
    //
    static
    void
    Cleanup (
        IN CCaptureFilter *CapFilter
        )
    {
        delete CapFilter;
    }

public:

    //
    // CCaptureFilter():
    //
    // The capture filter object constructor.  Since the new operator will
    // have zeroed the memory, do not bother initializing any NULL or 0
    // fields.  Only initialize non-NULL, non-0 fields.
    //
    CCaptureFilter (
        IN PKSFILTER Filter
        ) :
        m_Filter (Filter)
    {
    }

    //
    // ~CCaptureFilter():
    //
    // The capture filter destructor.
    //
    ~CCaptureFilter (
        )
    {
    }

    //
    // DispatchCreate():
    //
    // This is the filter creation dispatch for the capture filter.  It
    // creates the CCaptureFilter object, associates it with the AVStream
    // object, and bags it for easy cleanup later.
    //
    static
    NTSTATUS
    DispatchCreate (
        IN PKSFILTER Filter,
        IN PIRP Irp
        );

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\ksfilter\tests\avshws\device.h ===
/**************************************************************************

    AVStream Simulated Hardware Sample

    Copyright (c) 2001, Microsoft Corporation.

    File:

        device.h

    Abstract:

        The header for the device level of the simulated hardware.  This is
        not actually the hardware simulation itself.  The hardware simulation
        is contained in hwsim.*, image.*.
        
    History:

        created 3/9/2001

**************************************************************************/

class CCaptureDevice :
    public IHardwareSink {

private:

    //
    // The AVStream device we're associated with.
    //
    PKSDEVICE m_Device;

    //
    // Number of pins with resources acquired.  This is used as a locking
    // mechanism for resource acquisition on the device.
    //
    LONG m_PinsWithResources;

    //
    // Since we don't have physical hardware, this provides the hardware
    // simulation.  m_HardwareSimulation provides the fake ISR, fake DPC,
    // etc...  m_ImageSynth provides RGB24 and UYVY image synthesis and
    // overlay in software.
    //
    CHardwareSimulation *m_HardwareSimulation;
    CImageSynthesizer *m_ImageSynth;

    //
    // The number of ISR's that have occurred since capture started.
    //
    ULONG m_InterruptTime;

    //
    // The last reading of mappings completed.
    //
    ULONG m_LastMappingsCompleted;

    //
    // The Dma adapter object we acquired through IoGetDmaAdapter() during
    // Pnp start.  This must be initialized with AVStream in order to perform
    // Dma directly into the capture buffers.
    //
    PADAPTER_OBJECT m_DmaAdapterObject;

    //
    // The number of map registers returned from IoGetDmaAdapter().
    //
    ULONG m_NumberOfMapRegisters;

    //
    // The capture sink.  When we complete scatter / gather mappings, we
    // notify the capture sink.
    //
    ICaptureSink *m_CaptureSink;

    //
    // The video info header we're basing hardware settings on.  The pin
    // provides this to us when acquiring resources and must guarantee its
    // stability until resources are released.
    //
    PKS_VIDEOINFOHEADER m_VideoInfoHeader;

    //
    // Cleanup():
    //
    // This is the free callback for the bagged capture device.  Not providing
    // one will call ExFreePool, which is not what we want for a constructed
    // C++ object.  This simply deletes the capture device.
    //
    static
    void
    Cleanup (
        IN CCaptureDevice *CapDevice
        )
    {
        delete CapDevice;
    }

    //
    // CleanupSynth():
    //
    // Cleanup the image synth associated with this device.  This is the
    // free callback for the bagged image synth.
    //
    static
    void
    CleanupSynth (
        IN CImageSynthesizer *ImageSynth
        )
    {
        delete ImageSynth;
    }

    //
    // PnpStart():
    //
    // This is the Pnp start routine for our simulated hardware.  Note that
    // DispatchStart bridges to here in the context of the CCaptureDevice.
    //
    NTSTATUS
    PnpStart (
        IN PCM_RESOURCE_LIST TranslatedResourceList,
        IN PCM_RESOURCE_LIST UntranslatedResourceList
        );

    //
    // PnpStop():
    //
    // This is the Pnp stop routine for our simulated hardware.  Note that
    // DispatchStop bridges to here in the context of the CCaptureDevice.
    //
    void
    PnpStop (
        );

public:

    //
    // CCaptureDevice():
    //
    // The capture device class constructor.  Since everything should have
    // been zero'ed by the new operator, don't bother setting anything to
    // zero or NULL.  Only initialize non-NULL, non-0 fields.
    //
    CCaptureDevice (
        IN PKSDEVICE Device
        ) :
        m_Device (Device)
    {
    }

    //
    // ~CCaptureDevice():
    //
    // The capture device destructor.
    //
    ~CCaptureDevice (
        )
    {
    }

    //
    // DispatchCreate():
    //
    // This is the Add Device dispatch for the capture device.  It creates
    // the CCaptureDevice and associates it with the device via the bag.
    //
    static
    NTSTATUS
    DispatchCreate (
        IN PKSDEVICE Device
        );
    //
    // DispatchPnpStart():
    //
    // This is the Pnp Start dispatch for the capture device.  It simply
    // bridges to PnpStart() in the context of the CCaptureDevice.
    //
    static
    NTSTATUS
    DispatchPnpStart (
        IN PKSDEVICE Device,
        IN PIRP Irp,
        IN PCM_RESOURCE_LIST TranslatedResourceList,
        IN PCM_RESOURCE_LIST UntranslatedResourceList
        )
    {
        return 
            (reinterpret_cast <CCaptureDevice *> (Device -> Context)) ->
            PnpStart (
                TranslatedResourceList,
                UntranslatedResourceList
                );
    }

    //
    // DispatchPnpStop():
    //
    // This is the Pnp stop dispatch for the capture device.  It simply
    // bridges to PnpStop() in the context of the CCaptureDevice.
    //
    static
    void
    DispatchPnpStop (
        IN PKSDEVICE Device,
        IN PIRP Irp
        )
    {
        return
            (reinterpret_cast <CCaptureDevice *> (Device -> Context)) ->
            PnpStop (
                );
    }

    //
    // AcquireHardwareResources():
    //
    // Called to acquire hardware resources for the device based on a given
    // video info header.  This will fail if another object has already
    // acquired hardware resources since we emulate a single capture
    // device.
    //
    NTSTATUS
    AcquireHardwareResources (
        IN ICaptureSink *CaptureSink,
        IN PKS_VIDEOINFOHEADER VideoInfoHeader
        );

    //
    // ReleaseHardwareResources():
    //
    // Called to release hardware resources for the device.
    //
    void
    ReleaseHardwareResources (
        );

    //
    // Start():
    //
    // Called to start the hardware simulation.  This causes us to simulate
    // interrupts, simulate filling buffers with synthesized data, etc...
    //
    NTSTATUS
    Start (
        );

    //
    // Pause():
    //
    // Called to pause or unpause the hardware simulation.  This will be
    // indentical to a start or stop but it will not reset formats and 
    // counters.
    //
    NTSTATUS
    Pause (
        IN BOOLEAN Pausing
        );

    //
    // Stop():
    //
    // Called to stop the hardware simulation.  This causes interrupts to
    // stop issuing.  When this call returns, the "fake" hardware has
    // stopped accessing all s/g buffers, etc...
    //
    NTSTATUS
    Stop (
        );

    //
    // ProgramScatterGatherMappings():
    //
    // Called to program the hardware simulation's scatter / gather table.
    // This synchronizes with the "fake" ISR and hardware simulation via
    // a spinlock.
    //
    ULONG
    ProgramScatterGatherMappings (
        IN PUCHAR *Buffer,
        IN PKSMAPPING Mappings,
        IN ULONG MappingsCount
        );

    //
    // QueryInterruptTime():
    //
    // Determine the frame number that this frame corresponds to.  
    //
    ULONG
    QueryInterruptTime (
        );

    //
    // IHardwareSink::Interrupt():
    //
    // The interrupt service routine as called through the hardware sink
    // interface.  The "fake" hardware uses this method to inform the device
    // of a "fake" ISR.  The routine is called at dispatch level and must
    // be in locked code.
    //
    virtual
    void
    Interrupt (
        );

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\ksfilter\tests\avshws\hwsim.cpp ===
/**************************************************************************

    AVStream Simulated Hardware Sample

    Copyright (c) 2001, Microsoft Corporation.

    File:

        hwsim.cpp

    Abstract:
        
        This file contains the hardware simulation.  It fakes "DMA" transfers,
        scatter gather mapping handling, ISR's, etc...  The ISR routine in
        here will be called when an ISR would be generated by the fake hardware
        and it will directly call into the device level ISR for more accurate
        simulation.

    History:

        created 3/9/2001

**************************************************************************/

#include "avshws.h"

/**************************************************************************

    PAGEABLE CODE

**************************************************************************/

#ifdef ALLOC_PRAGMA
#pragma code_seg("PAGE")
#endif // ALLOC_PRAGMA


CHardwareSimulation::
CHardwareSimulation (
    IN IHardwareSink *HardwareSink
    ) :
    m_HardwareSink (HardwareSink),
    m_ScatterGatherMappingsMax (SCATTER_GATHER_MAPPINGS_MAX)

/*++

Routine Description:

    Construct a hardware simulation

Arguments:

    HardwareSink -
        The hardware sink interface.  This is used to trigger
        fake interrupt service routines from.

Return Value:

    Success / Failure

--*/

{

    PAGED_CODE();

    //
    // Initialize the DPC's, timer's, and locks necessary to simulate
    // this capture hardware.
    //
    KeInitializeDpc (
        &m_IsrFakeDpc, 
        reinterpret_cast <PKDEFERRED_ROUTINE> 
            (CHardwareSimulation::SimulatedInterrupt),
        this
        );

    KeInitializeEvent (
        &m_HardwareEvent,
        SynchronizationEvent,
        FALSE
        );

    KeInitializeTimer (&m_IsrTimer);

    KeInitializeSpinLock (&m_ListLock);

}

/*************************************************/


CHardwareSimulation *
CHardwareSimulation::
Initialize (
    IN KSOBJECT_BAG Bag,
    IN IHardwareSink *HardwareSink
    )

/*++

Routine Description:

    Initialize the hardware simulation

Arguments:

    HardwareSink -
        The hardware sink interface.  This is what ISR's will be
        triggered through.

Return Value:

    A fully initialized hardware simulation or NULL if the simulation
    could not be initialized.

--*/

{

    PAGED_CODE();

    CHardwareSimulation *HwSim = 
        new (NonPagedPool) CHardwareSimulation (HardwareSink);

    return HwSim;

}

/*************************************************/


NTSTATUS
CHardwareSimulation::
Start (
    IN CImageSynthesizer *ImageSynth,
    IN LONGLONG TimePerFrame,
    IN ULONG Width,
    IN ULONG Height,
    IN ULONG ImageSize
    )

/*++

Routine Description:

    Start the hardware simulation.  This will kick the interrupts on,
    begin issuing DPC's, filling in capture information, etc...
    We keep track of starvation starting at this point.

Arguments:

    ImageSynth -
        The image synthesizer to use to generate pictures to display
        on the capture buffer.

    TimePerFrame -
        The time per frame...  we issue interrupts this often.

    Width -
        The image width

    Height -
        The image height

    ImageSize - 
        The size of the image.  We allocate a temporary scratch buffer
        based on this size to fake hardware.

Return Value:

    Success / Failure (typical failure will be out of memory on the 
    scratch buffer, etc...)

--*/

{

    PAGED_CODE();

    NTSTATUS Status = STATUS_SUCCESS;

    m_ImageSynth = ImageSynth;
    m_TimePerFrame = TimePerFrame;
    m_ImageSize = ImageSize;
    m_Height = Height;
    m_Width = Width;

    InitializeListHead (&m_ScatterGatherMappings);
    m_NumMappingsCompleted = 0;
    m_ScatterGatherMappingsQueued = 0;
    m_NumFramesSkipped = 0;
    m_InterruptTime = 0;

    KeQuerySystemTime (&m_StartTime);

    //
    // Allocate a scratch buffer for the synthesizer.
    //
    m_SynthesisBuffer = reinterpret_cast <PUCHAR> (
        ExAllocatePool (
            NonPagedPool,
            m_ImageSize
            )
        );

    if (!m_SynthesisBuffer) {
        Status = STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    // If everything is ok, start issuing interrupts.
    //
    if (NT_SUCCESS (Status)) {

        //
        // Initialize the entry lookaside.
        //
        ExInitializeNPagedLookasideList (
            &m_ScatterGatherLookaside,
            NULL,
            NULL,
            0,
            sizeof (SCATTER_GATHER_ENTRY),
            'nEGS',
            0
            );

        //
        // Set up the synthesizer with the width, height, and scratch buffer.
        //
        m_ImageSynth -> SetImageSize (m_Width, m_Height);
        m_ImageSynth -> SetBuffer (m_SynthesisBuffer);

        LARGE_INTEGER NextTime;
        NextTime.QuadPart = m_StartTime.QuadPart + m_TimePerFrame;

        m_HardwareState = HardwareRunning;
        KeSetTimer (&m_IsrTimer, NextTime, &m_IsrFakeDpc);

    }

    return Status;
        
}

/*************************************************/


NTSTATUS
CHardwareSimulation::
Pause (
    BOOLEAN Pausing
    )

/*++

Routine Description:

    Pause the hardware simulation...  When the hardware simulation is told
    to pause, it stops issuing interrupts, etc...  but it does not reset
    the counters 

Arguments:

    Pausing -
        Indicates whether the hardware is pausing or not. 

        TRUE -
            Pause the hardware

        FALSE -
            Unpause the hardware from a previous pause


Return Value:

    Success / Failure

--*/

{

    PAGED_CODE();

    if (Pausing && m_HardwareState == HardwareRunning) {
        //
        // If we were running, stop completing mappings, etc...
        //
        m_StopHardware = TRUE;
    
        KeWaitForSingleObject (
            &m_HardwareEvent,
            Suspended,
            KernelMode,
            FALSE,
            NULL
            );

        ASSERT (m_StopHardware == FALSE);

        m_HardwareState = HardwarePaused; 

    } else if (!Pausing && m_HardwareState == HardwarePaused) {

        //
        // For unpausing the hardware, we need to compute the relative time
        // and restart interrupts.
        //
        LARGE_INTEGER UnpauseTime;

        KeQuerySystemTime (&UnpauseTime);
        m_InterruptTime = (ULONG) (
            (UnpauseTime.QuadPart - m_StartTime.QuadPart) /
            m_TimePerFrame
            );

        UnpauseTime.QuadPart = m_StartTime.QuadPart +
            (m_InterruptTime + 1) * m_TimePerFrame;

        m_HardwareState = HardwareRunning;
        KeSetTimer (&m_IsrTimer, UnpauseTime, &m_IsrFakeDpc);

    }

    return STATUS_SUCCESS;

}

/*************************************************/


NTSTATUS
CHardwareSimulation::
Stop (
    )

/*++

Routine Description:

    Stop the hardware simulation....  Wait until the hardware simulation
    has successfully stopped and then return.

Arguments:

    None

Return Value:

    Success / Failure

--*/

{

    PAGED_CODE();

    //
    // If the hardware is told to stop while it's running, we need to
    // halt the interrupts first.  If we're already paused, this has
    // already been done.
    //
    if (m_HardwareState == HardwareRunning) {
    
        m_StopHardware = TRUE;
    
        KeWaitForSingleObject (
            &m_HardwareEvent,
            Suspended,
            KernelMode,
            FALSE,
            NULL
            );
    
        ASSERT (m_StopHardware == FALSE);

    }

    m_HardwareState = HardwareStopped;

    //
    // The image synthesizer may still be around.  Just for safety's
    // sake, NULL out the image synthesis buffer and toast it.
    //
    m_ImageSynth -> SetBuffer (NULL);

    if (m_SynthesisBuffer) {
        ExFreePool (m_SynthesisBuffer);
        m_SynthesisBuffer = NULL;
    }

    //
    // Delete the scatter / gather lookaside for this run.
    //
    ExDeleteNPagedLookasideList (&m_ScatterGatherLookaside);

    return STATUS_SUCCESS;

}

/**************************************************************************

    LOCKED CODE

**************************************************************************/

#ifdef ALLOC_PRAGMA
#pragma code_seg()
#endif // ALLOC_PRAGMA


ULONG
CHardwareSimulation::
ReadNumberOfMappingsCompleted (
    )

/*++

Routine Description:

    Read the number of scatter / gather mappings which have been
    completed (TOTAL NUMBER) since the last reset of the simulated
    hardware

Arguments:

    None

Return Value:

    Total number of completed mappings.

--*/

{

    //
    // Don't care if this is being updated this moment in the DPC...  I only
    // need a number to return which isn't too great (too small is ok).
    // In real hardware, this wouldn't be done this way anyway.
    //
    return m_NumMappingsCompleted;

}

/*************************************************/


ULONG
CHardwareSimulation::
ProgramScatterGatherMappings (
    IN PUCHAR *Buffer,
    IN PKSMAPPING Mappings,
    IN ULONG MappingsCount,
    IN ULONG MappingStride
    )

/*++

Routine Description:

    Program the scatter gather mapping list.  This shoves a bunch of 
    entries on a list for access during the fake interrupt.  Note that
    we have physical addresses here only for simulation.  We really
    access via the virtual address....  although we chunk it into multiple
    buffers to more realistically simulate S/G

Arguments:

    Buffer -
        The virtual address of the buffer mapped by the mapping list 

    Mappings -
        The KSMAPPINGS array corresponding to the buffer

    MappingsCount -
        The number of mappings in the mappings array

    MappingStride -
        The mapping stride used in initialization of AVStream DMA

Return Value:

    Number of mappings actually inserted.

--*/

{

    KIRQL Irql;

    ULONG MappingsInserted = 0;

    //
    // Protect our S/G list with a spinlock.
    //
    KeAcquireSpinLock (&m_ListLock, &Irql);

    //
    // Loop through the scatter / gather list and break the buffer up into
    // chunks equal to the scatter / gather mappings.  Stuff the virtual
    // addresses of these chunks on a list somewhere.  We update the buffer
    // pointer the caller passes as a more convenient way of doing this.
    //
    // If I could just remap physical in the list to virtual easily here,
    // I wouldn't need to do it.
    //
    for (ULONG MappingNum = 0; 
        MappingNum < MappingsCount &&
            m_ScatterGatherMappingsQueued < m_ScatterGatherMappingsMax; 
        MappingNum++) {

        PSCATTER_GATHER_ENTRY Entry =
            reinterpret_cast <PSCATTER_GATHER_ENTRY> (
                ExAllocateFromNPagedLookasideList (
                    &m_ScatterGatherLookaside
                    )
                );

        if (!Entry) {
            break;
        }

        Entry -> Virtual = *Buffer;
        Entry -> ByteCount = Mappings -> ByteCount;

        //
        // Move forward a specific number of bytes in chunking this into
        // mapping sized va buffers.
        //
        *Buffer += Entry -> ByteCount;
        Mappings = reinterpret_cast <PKSMAPPING> (
            (reinterpret_cast <PUCHAR> (Mappings) + MappingStride)
            );

        InsertTailList (&m_ScatterGatherMappings, &(Entry -> ListEntry));
        MappingsInserted++;
        m_ScatterGatherMappingsQueued++;
        m_ScatterGatherBytesQueued += Entry -> ByteCount;

    }

    KeReleaseSpinLock (&m_ListLock, Irql);

    return MappingsInserted;

}

/*************************************************/


NTSTATUS
CHardwareSimulation::
FillScatterGatherBuffers (
    )

/*++

Routine Description:

    The hardware has synthesized a buffer in scratch space and we're to
    fill scatter / gather buffers.

Arguments:

    None

Return Value:

    Success / Failure

--*/

{

    //
    // We're using this list lock to protect our scatter / gather lists instead
    // of some hardware mechanism / KeSynchronizeExecution / whatever.
    //
    KeAcquireSpinLockAtDpcLevel (&m_ListLock);

    PUCHAR Buffer = reinterpret_cast <PUCHAR> (m_SynthesisBuffer);
    ULONG BufferRemaining = m_ImageSize;

    //
    // For simplification, if there aren't enough scatter / gather buffers
    // queued, we don't partially fill the ones that are available.  We just
    // skip the frame and consider it starvation.
    //
    // This could be enforced by only programming scatter / gather mappings
    // for a buffer if all of them fit in the table also...
    //
    while (BufferRemaining &&
        m_ScatterGatherMappingsQueued > 0 &&
        m_ScatterGatherBytesQueued >= BufferRemaining) {

        LIST_ENTRY *listEntry = RemoveHeadList (&m_ScatterGatherMappings);
        m_ScatterGatherMappingsQueued--;

        PSCATTER_GATHER_ENTRY SGEntry =  
            reinterpret_cast <PSCATTER_GATHER_ENTRY> (
                CONTAINING_RECORD (
                    listEntry,
                    SCATTER_GATHER_ENTRY,
                    ListEntry
                    )
                );

        //
        // Since we're software, we'll be accessing this by virtual address...
        //
        ULONG BytesToCopy = 
            (BufferRemaining < SGEntry -> ByteCount) ?
            BufferRemaining :
            SGEntry -> ByteCount;

        RtlCopyMemory (
            SGEntry -> Virtual,
            Buffer,
            BytesToCopy
            );

        BufferRemaining -= BytesToCopy;
        Buffer += BytesToCopy;
        m_NumMappingsCompleted++;
        m_ScatterGatherBytesQueued -= SGEntry -> ByteCount;

        //
        // Release the scatter / gather entry back to our lookaside.
        //
        ExFreeToNPagedLookasideList (
            &m_ScatterGatherLookaside,
            reinterpret_cast <PVOID> (SGEntry)
            );

    }
    
    KeReleaseSpinLockFromDpcLevel (&m_ListLock);

    if (BufferRemaining) return STATUS_INSUFFICIENT_RESOURCES;
    else return STATUS_SUCCESS;
    
}

/*************************************************/


void
CHardwareSimulation::
FakeHardware (
    )

/*++

Routine Description:

    Simulate an interrupt and what the hardware would have done in the
    time since the previous interrupt.

Arguments:

    None

Return Value:

    None

--*/

{

    m_InterruptTime++;

    //
    // The hardware can be in a pause state in which case, it issues interrupts
    // but does not complete mappings.  In this case, don't bother synthesizing
    // a frame and doing the work of looking through the mappings table.
    //
    if (m_HardwareState == HardwareRunning) {
    
        //
        // Generate a "time stamp" just to overlay it onto the capture image.
        // It makes it more exciting than bars that do nothing.
        //
        LONGLONG PtsRel = ((m_InterruptTime + 1) * m_TimePerFrame);
    
        ULONG Min = (ULONG)(PtsRel / 600000000);
        ULONG RemMin = (ULONG)(PtsRel % 600000000);
        ULONG Sec = (ULONG)(RemMin / 10000000);
        ULONG RemSec = (ULONG)(RemMin % 10000000);
        ULONG Hund = (ULONG)(RemSec / 100000);
    
        //
        // Synthesize a buffer in scratch space.
        //
        m_ImageSynth -> SynthesizeBars ();
    
        CHAR Text [256];
        sprintf (Text, "%ld:%02ld.%02ld", Min, Sec, Hund);
    
        //
        // Overlay a clock onto the scratch space image.
        //
        m_ImageSynth -> OverlayText (
            POSITION_CENTER,
            (m_Height - 28),
            1,
            Text,
            BLACK,	
            WHITE
            );
    
        //
        // Overlay a counter of skipped frames onto the scratch image.
        //
        sprintf (Text, "Skipped: %ld", m_NumFramesSkipped);
        m_ImageSynth -> OverlayText (
            10,
            10,
            1,
            Text,
            TRANSPARENT,
            BLUE
            );

        //
        // Fill scatter gather buffers
        //
        if (!NT_SUCCESS (FillScatterGatherBuffers ())) {
            InterlockedIncrement (PLONG (&m_NumFramesSkipped));
        }

    }
        
    //
    // Issue an interrupt to our hardware sink.  This is a "fake" interrupt.
    // It will occur at DISPATCH_LEVEL.
    //
    m_HardwareSink -> Interrupt ();

    //
    // Reschedule the timer if the hardware isn't being stopped.
    //
    if (!m_StopHardware) {

        //
        // Reschedule the timer for the next interrupt time.
        //
        LARGE_INTEGER NextTime;
        NextTime.QuadPart = m_StartTime.QuadPart + 
            (m_TimePerFrame * (m_InterruptTime + 1));

        KeSetTimer (&m_IsrTimer, NextTime, &m_IsrFakeDpc);
        
    } else {
        //
        // If someone is waiting on the hardware to stop, raise the stop
        // event and clear the flag.
        //
        m_StopHardware = FALSE;
        KeSetEvent (&m_HardwareEvent, IO_NO_INCREMENT, FALSE);
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\ksfilter\tests\avshws\capture.h ===
/**************************************************************************

    AVStream Simulated Hardware Sample

    Copyright (c) 2001, Microsoft Corporation.

    File:

        capture.h

    Abstract:

        This file contains header for the video capture pin on the capture
        filter.  The capture sample performs "fake" DMA directly into
        the capture buffers.  Common buffer DMA will work slightly differently.

        For common buffer DMA, the general technique would be DPC schedules
        processing with KsPinAttemptProcessing.  The processing routine grabs
        the leading edge, copies data out of the common buffer and advances.
        Cloning would not be necessary with this technique.  It would be 
        similiar to the way "AVSSamp" works, but it would be pin-centric.

    History:

        created 3/8/2001

**************************************************************************/

//
// STREAM_POINTER_CONTEXT:
//
// This is the context structure we associate with all clone stream pointers.
// It allows the mapping code to rip apart the buffer into chunks the same
// size as the scatter/gather mappings in order to fake scatter / gather
// bus-master DMA.
//
typedef struct _STREAM_POINTER_CONTEXT {
    
    PUCHAR BufferVirtual;

} STREAM_POINTER_CONTEXT, *PSTREAM_POINTER_CONTEXT;

//
// CCapturePin:
//
// The video capture pin class.
//
class CCapturePin :
    public ICaptureSink {

private:

    //
    // The AVStream pin we're associated with.
    //
    PKSPIN m_Pin;

    //
    // Pointer to the internal device object for our capture device.
    // We access the "fake" hardware through this object.
    //
    CCaptureDevice *m_Device;

    //
    // The state we've put the hardware into.  This allows us to keep track
    // of whether to do things like unpausing or restarting.
    //
    HARDWARE_STATE m_HardwareState;

    //
    // The clock we've been assigned.  As with other capture filters, we do
    // not expose a clock.  If one has been assigned, we will use it to
    // time stamp packets (plus a reasonable delta to work the capture stream
    // in a preview graph).
    //
    PIKSREFERENCECLOCK m_Clock;

    //
    // The captured video info header.  The settings for "fake" hardware will be
    // programmed via this video info header.
    //
    PKS_VIDEOINFOHEADER m_VideoInfoHeader;

    //
    // If we are unable to insert all of the mappings in a stream pointer into
    // the "fake" hardware's scatter / gather table, we set this to the
    // stream pointer that's incomplete.  This is done both to make the 
    // relasing easier and to make it easier to fake the scatter / gather
    // hardware.
    //
    PKSSTREAM_POINTER m_PreviousStreamPointer;

    //
    // An indication of whether or not we pended I/O for some reason.  If this
    // is set, the DPC will resume I/O when any mappings are completed.
    //
    BOOLEAN m_PendIo;

    //
    // An indication of whether or not this pin has acquired the necessary
    // hardware resources to operate.  When the pin reaches KSSTATE_ACQUIRE,
    // we attempt to acquire the hardware.  This flag will be set based on
    // our success / failure.
    //
    BOOLEAN m_AcquiredResources;

    //
    // CleanupReferences():
    //
    // Clean up any references we hold on frames in the queue.  This is called
    // when we abruptly stop the fake hardware.
    //
    NTSTATUS
    CleanupReferences (
        );

    //
    // SetState():
    //
    // This is the state transition handler for the capture pin.  It attempts
    // to acquire resources for the capture pin (or releasing them if
    // necessary) and starts and stops the hardware as required.
    //
    NTSTATUS
    SetState (
        IN KSSTATE ToState,
        IN KSSTATE FromState
        );

    //
    // Process():
    //
    // This is the processing dispatch for the capture pin.  It handles
    // programming the scatter / gather tables for the hardware as buffers
    // become available.  This processing routine is designed for a direct
    // into the capture buffers kind of DMA as opposed to common-buffer
    // and copy strategies.
    //
    NTSTATUS
    Process (
        );

    //
    // CaptureVideoInfoHeader():
    //
    // This routine stashes the video info header set on the pin connection
    // in the CCapturePin object.  This is used to base hardware settings.
    //
    PKS_VIDEOINFOHEADER
    CaptureVideoInfoHeader (
        );

    //
    // Cleanup():
    //
    // This is the free callback from the bagged item (CCapturePin).  If we
    // do not provide a callback when we bag the CCapturePin, ExFreePool
    // would be called.  This is not desirable for C++ constructed objects.
    // We merely delete the object here.
    //
    static
    void
    Cleanup (
        IN CCapturePin *Pin
        )
    {
        delete Pin;
    }

public:

    //
    // CCapturePin():
    //
    // The capture pin's constructor.  Initialize any non-0, non-NULL fields
    // (since new will have zero'ed the memory anyway) and set up our
    // device level pointers for access during capture routines.
    //
    CCapturePin (
        IN PKSPIN Pin
        );

    //
    // ~CCapturePin():
    //
    // The capture pin's destructor.
    //
    ~CCapturePin (
        )
    {
    }

    //
    // ICaptureSink::CompleteMappings()
    //
    // This is the capture sink notification mechanism for mapping completion.
    // When the device DPC detects that a given number of mappings have been
    // completed by the fake hardware, it signals the capture sink of this
    // through this method.
    //
    virtual
    void
    CompleteMappings (
        IN ULONG NumMappings
        );

    /*************************************************

        Dispatch Routines

    *************************************************/

    //
    // DispatchCreate():
    //
    // This is the creation dispatch for the capture pin.  It creates
    // the CCapturePin object and associates it with the AVStream object
    // bagging it in the process.
    //
    static
    NTSTATUS
    DispatchCreate (
        IN PKSPIN Pin,
        IN PIRP Irp
        );

    //
    // DispatchSetState():
    //
    // This is the set device state dispatch for the pin.  The routine bridges
    // to SetState() in the context of the CCapturePin.
    //
    static
    NTSTATUS
    DispatchSetState (
        IN PKSPIN Pin,
        IN KSSTATE ToState,
        IN KSSTATE FromState
        )
    {
        return 
            (reinterpret_cast <CCapturePin *> (Pin -> Context)) ->
                SetState (ToState, FromState);
    }

    //
    // DispatchSetFormat():
    //
    // This is the set data format dispatch for the pin.  This will be called
    // BEFORE pin creation to validate that a data format selected is a match
    // for the range pulled out of our range list.  It will also be called
    // for format changes.
    //
    // If OldFormat is NULL, this is an indication that it's the initial
    // call and not a format change.  Even fixed format pins get this call
    // once.
    //
    static
    NTSTATUS
    DispatchSetFormat (
        IN PKSPIN Pin,
        IN PKSDATAFORMAT OldFormat OPTIONAL,
        IN PKSMULTIPLE_ITEM OldAttributeList OPTIONAL,
        IN const KSDATARANGE *DataRange,
        IN const KSATTRIBUTE_LIST *AttributeRange OPTIONAL
        );

    //
    // DispatchProcess():
    //
    // This is the processing dispatch for the capture pin.  The routine 
    // bridges to Process() in the context of the CCapturePin.
    //
    static 
    NTSTATUS
    DispatchProcess (
        IN PKSPIN Pin
        )
    {
        return 
            (reinterpret_cast <CCapturePin *> (Pin -> Context)) ->
                Process ();
    }

    //
    // IntersectHandler():
    //
    // This is the data intersection handler for the capture pin.  This 
    // determines an optimal format in the intersection of two ranges,
    // one local and one possibly foreign.  If there is no compatible format,
    // STATUS_NO_MATCH is returned.
    //
    static
    NTSTATUS
    IntersectHandler (
        IN PKSFILTER Filter,
        IN PIRP Irp,
        IN PKSP_PIN PinInstance,
        IN PKSDATARANGE CallerDataRange,
        IN PKSDATARANGE DescriptorDataRange,
        IN ULONG BufferSize,
        OUT PVOID Data OPTIONAL,
        OUT PULONG DataSize
        );

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\ksfilter\tests\avshws\image.cpp ===
/**************************************************************************

    AVStream Simulated Hardware Sample

    Copyright (c) 2001, Microsoft Corporation.

    File:

        image.cpp

    Abstract:

        The image synthesis and overlay code.  These objects provide image
        synthesis (pixel, color-bar, etc...) onto RGB24 and UYVY buffers as
        well as software string overlay into these buffers.

	This entire file, data and all, must be in locked segments.

    History:

        created 1/16/2001

**************************************************************************/

#include "avshws.h"

/**************************************************************************

    Constants

**************************************************************************/

//
// g_FontData:
//
// The following is an 8x8 bitmapped font for use in the text overlay
// code.
//
UCHAR g_FontData [256][8] = {
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
    {0x7e, 0x81, 0xa5, 0x81, 0xbd, 0x99, 0x81, 0x7e},
    {0x7e, 0xff, 0xdb, 0xff, 0xc3, 0xe7, 0xff, 0x7e},
    {0x6c, 0xfe, 0xfe, 0xfe, 0x7c, 0x38, 0x10, 0x00},
    {0x10, 0x38, 0x7c, 0xfe, 0x7c, 0x38, 0x10, 0x00},
    {0x38, 0x7c, 0x38, 0xfe, 0xfe, 0x7c, 0x38, 0x7c},
    {0x10, 0x10, 0x38, 0x7c, 0xfe, 0x7c, 0x38, 0x7c},
    {0x00, 0x00, 0x18, 0x3c, 0x3c, 0x18, 0x00, 0x00},
    {0xff, 0xff, 0xe7, 0xc3, 0xc3, 0xe7, 0xff, 0xff},
    {0x00, 0x3c, 0x66, 0x42, 0x42, 0x66, 0x3c, 0x00},
    {0xff, 0xc3, 0x99, 0xbd, 0xbd, 0x99, 0xc3, 0xff},
    {0x0f, 0x07, 0x0f, 0x7d, 0xcc, 0xcc, 0xcc, 0x78},
    {0x3c, 0x66, 0x66, 0x66, 0x3c, 0x18, 0x7e, 0x18},
    {0x3f, 0x33, 0x3f, 0x30, 0x30, 0x70, 0xf0, 0xe0},
    {0x7f, 0x63, 0x7f, 0x63, 0x63, 0x67, 0xe6, 0xc0},
    {0x99, 0x5a, 0x3c, 0xe7, 0xe7, 0x3c, 0x5a, 0x99},
    {0x80, 0xe0, 0xf8, 0xfe, 0xf8, 0xe0, 0x80, 0x00},
    {0x02, 0x0e, 0x3e, 0xfe, 0x3e, 0x0e, 0x02, 0x00},
    {0x18, 0x3c, 0x7e, 0x18, 0x18, 0x7e, 0x3c, 0x18},
    {0x66, 0x66, 0x66, 0x66, 0x66, 0x00, 0x66, 0x00},
    {0x7f, 0xdb, 0xdb, 0x7b, 0x1b, 0x1b, 0x1b, 0x00},
    {0x3e, 0x63, 0x38, 0x6c, 0x6c, 0x38, 0xcc, 0x78},
    {0x00, 0x00, 0x00, 0x00, 0x7e, 0x7e, 0x7e, 0x00},
    {0x18, 0x3c, 0x7e, 0x18, 0x7e, 0x3c, 0x18, 0xff},
    {0x18, 0x3c, 0x7e, 0x18, 0x18, 0x18, 0x18, 0x00},
    {0x18, 0x18, 0x18, 0x18, 0x7e, 0x3c, 0x18, 0x00},
    {0x00, 0x18, 0x0c, 0xfe, 0x0c, 0x18, 0x00, 0x00},
    {0x00, 0x30, 0x60, 0xfe, 0x60, 0x30, 0x00, 0x00},
    {0x00, 0x00, 0xc0, 0xc0, 0xc0, 0xfe, 0x00, 0x00},
    {0x00, 0x24, 0x66, 0xff, 0x66, 0x24, 0x00, 0x00},
    {0x00, 0x18, 0x3c, 0x7e, 0xff, 0xff, 0x00, 0x00},
    {0x00, 0xff, 0xff, 0x7e, 0x3c, 0x18, 0x00, 0x00},
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
    {0x30, 0x78, 0x78, 0x30, 0x30, 0x00, 0x30, 0x00},
    {0x6c, 0x6c, 0x6c, 0x00, 0x00, 0x00, 0x00, 0x00},
    {0x6c, 0x6c, 0xfe, 0x6c, 0xfe, 0x6c, 0x6c, 0x00},
    {0x30, 0x7c, 0xc0, 0x78, 0x0c, 0xf8, 0x30, 0x00},
    {0x00, 0xc6, 0xcc, 0x18, 0x30, 0x66, 0xc6, 0x00},
    {0x38, 0x6c, 0x38, 0x76, 0xdc, 0xcc, 0x76, 0x00},
    {0x60, 0x60, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00},
    {0x18, 0x30, 0x60, 0x60, 0x60, 0x30, 0x18, 0x00},
    {0x60, 0x30, 0x18, 0x18, 0x18, 0x30, 0x60, 0x00},
    {0x00, 0x66, 0x3c, 0xff, 0x3c, 0x66, 0x00, 0x00},
    {0x00, 0x30, 0x30, 0xfc, 0x30, 0x30, 0x00, 0x00},
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 0x30, 0x60},
    {0x00, 0x00, 0x00, 0xfc, 0x00, 0x00, 0x00, 0x00},
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 0x30, 0x00},
    {0x06, 0x0c, 0x18, 0x30, 0x60, 0xc0, 0x80, 0x00},
    {0x7c, 0xc6, 0xce, 0xde, 0xf6, 0xe6, 0x7c, 0x00},
    {0x30, 0x70, 0x30, 0x30, 0x30, 0x30, 0xfc, 0x00},
    {0x78, 0xcc, 0x0c, 0x38, 0x60, 0xcc, 0xfc, 0x00},
    {0x78, 0xcc, 0x0c, 0x38, 0x0c, 0xcc, 0x78, 0x00},
    {0x1c, 0x3c, 0x6c, 0xcc, 0xfe, 0x0c, 0x1e, 0x00},
    {0xfc, 0xc0, 0xf8, 0x0c, 0x0c, 0xcc, 0x78, 0x00},
    {0x38, 0x60, 0xc0, 0xf8, 0xcc, 0xcc, 0x78, 0x00},
    {0xfc, 0xcc, 0x0c, 0x18, 0x30, 0x30, 0x30, 0x00},
    {0x78, 0xcc, 0xcc, 0x78, 0xcc, 0xcc, 0x78, 0x00},
    {0x78, 0xcc, 0xcc, 0x7c, 0x0c, 0x18, 0x70, 0x00},
    {0x00, 0x30, 0x30, 0x00, 0x00, 0x30, 0x30, 0x00},
    {0x00, 0x30, 0x30, 0x00, 0x00, 0x30, 0x30, 0x60},
    {0x18, 0x30, 0x60, 0xc0, 0x60, 0x30, 0x18, 0x00},
    {0x00, 0x00, 0xfc, 0x00, 0x00, 0xfc, 0x00, 0x00},
    {0x60, 0x30, 0x18, 0x0c, 0x18, 0x30, 0x60, 0x00},
    {0x78, 0xcc, 0x0c, 0x18, 0x30, 0x00, 0x30, 0x00},
    {0x7c, 0xc6, 0xde, 0xde, 0xde, 0xc0, 0x78, 0x00},
    {0x30, 0x78, 0xcc, 0xcc, 0xfc, 0xcc, 0xcc, 0x00},
    {0xfc, 0x66, 0x66, 0x7c, 0x66, 0x66, 0xfc, 0x00},
    {0x3c, 0x66, 0xc0, 0xc0, 0xc0, 0x66, 0x3c, 0x00},
    {0xf8, 0x6c, 0x66, 0x66, 0x66, 0x6c, 0xf8, 0x00},
    {0xfe, 0x62, 0x68, 0x78, 0x68, 0x62, 0xfe, 0x00},
    {0xfe, 0x62, 0x68, 0x78, 0x68, 0x60, 0xf0, 0x00},
    {0x3c, 0x66, 0xc0, 0xc0, 0xce, 0x66, 0x3e, 0x00},
    {0xcc, 0xcc, 0xcc, 0xfc, 0xcc, 0xcc, 0xcc, 0x00},
    {0x78, 0x30, 0x30, 0x30, 0x30, 0x30, 0x78, 0x00},
    {0x1e, 0x0c, 0x0c, 0x0c, 0xcc, 0xcc, 0x78, 0x00},
    {0xe6, 0x66, 0x6c, 0x78, 0x6c, 0x66, 0xe6, 0x00},
    {0xf0, 0x60, 0x60, 0x60, 0x62, 0x66, 0xfe, 0x00},
    {0xc6, 0xee, 0xfe, 0xfe, 0xd6, 0xc6, 0xc6, 0x00},
    {0xc6, 0xe6, 0xf6, 0xde, 0xce, 0xc6, 0xc6, 0x00},
    {0x38, 0x6c, 0xc6, 0xc6, 0xc6, 0x6c, 0x38, 0x00},
    {0xfc, 0x66, 0x66, 0x7c, 0x60, 0x60, 0xf0, 0x00},
    {0x78, 0xcc, 0xcc, 0xcc, 0xdc, 0x78, 0x1c, 0x00},
    {0xfc, 0x66, 0x66, 0x7c, 0x6c, 0x66, 0xe6, 0x00},
    {0x78, 0xcc, 0xe0, 0x70, 0x1c, 0xcc, 0x78, 0x00},
    {0xfc, 0xb4, 0x30, 0x30, 0x30, 0x30, 0x78, 0x00},
    {0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xfc, 0x00},
    {0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0x78, 0x30, 0x00},
    {0xc6, 0xc6, 0xc6, 0xd6, 0xfe, 0xee, 0xc6, 0x00},
    {0xc6, 0xc6, 0x6c, 0x38, 0x38, 0x6c, 0xc6, 0x00},
    {0xcc, 0xcc, 0xcc, 0x78, 0x30, 0x30, 0x78, 0x00},
    {0xfe, 0xc6, 0x8c, 0x18, 0x32, 0x66, 0xfe, 0x00},
    {0x78, 0x60, 0x60, 0x60, 0x60, 0x60, 0x78, 0x00},
    {0xc0, 0x60, 0x30, 0x18, 0x0c, 0x06, 0x02, 0x00},
    {0x78, 0x18, 0x18, 0x18, 0x18, 0x18, 0x78, 0x00},
    {0x10, 0x38, 0x6c, 0xc6, 0x00, 0x00, 0x00, 0x00},
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff},
    {0x30, 0x30, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00},
    {0x00, 0x00, 0x78, 0x0c, 0x7c, 0xcc, 0x76, 0x00},
    {0xe0, 0x60, 0x60, 0x7c, 0x66, 0x66, 0xdc, 0x00},
    {0x00, 0x00, 0x78, 0xcc, 0xc0, 0xcc, 0x78, 0x00},
    {0x1c, 0x0c, 0x0c, 0x7c, 0xcc, 0xcc, 0x76, 0x00},
    {0x00, 0x00, 0x78, 0xcc, 0xfc, 0xc0, 0x78, 0x00},
    {0x38, 0x6c, 0x60, 0xf0, 0x60, 0x60, 0xf0, 0x00},
    {0x00, 0x00, 0x76, 0xcc, 0xcc, 0x7c, 0x0c, 0xf8},
    {0xe0, 0x60, 0x6c, 0x76, 0x66, 0x66, 0xe6, 0x00},
    {0x30, 0x00, 0x70, 0x30, 0x30, 0x30, 0x78, 0x00},
    {0x0c, 0x00, 0x0c, 0x0c, 0x0c, 0xcc, 0xcc, 0x78},
    {0xe0, 0x60, 0x66, 0x6c, 0x78, 0x6c, 0xe6, 0x00},
    {0x70, 0x30, 0x30, 0x30, 0x30, 0x30, 0x78, 0x00},
    {0x00, 0x00, 0xcc, 0xfe, 0xfe, 0xd6, 0xc6, 0x00},
    {0x00, 0x00, 0xf8, 0xcc, 0xcc, 0xcc, 0xcc, 0x00},
    {0x00, 0x00, 0x78, 0xcc, 0xcc, 0xcc, 0x78, 0x00},
    {0x00, 0x00, 0xdc, 0x66, 0x66, 0x7c, 0x60, 0xf0},
    {0x00, 0x00, 0x76, 0xcc, 0xcc, 0x7c, 0x0c, 0x1e},
    {0x00, 0x00, 0xdc, 0x76, 0x66, 0x60, 0xf0, 0x00},
    {0x00, 0x00, 0x7c, 0xc0, 0x78, 0x0c, 0xf8, 0x00},
    {0x10, 0x30, 0x7c, 0x30, 0x30, 0x34, 0x18, 0x00},
    {0x00, 0x00, 0xcc, 0xcc, 0xcc, 0xcc, 0x76, 0x00},
    {0x00, 0x00, 0xcc, 0xcc, 0xcc, 0x78, 0x30, 0x00},
    {0x00, 0x00, 0xc6, 0xd6, 0xfe, 0xfe, 0x6c, 0x00},
    {0x00, 0x00, 0xc6, 0x6c, 0x38, 0x6c, 0xc6, 0x00},
    {0x00, 0x00, 0xcc, 0xcc, 0xcc, 0x7c, 0x0c, 0xf8},
    {0x00, 0x00, 0xfc, 0x98, 0x30, 0x64, 0xfc, 0x00},
    {0x1c, 0x30, 0x30, 0xe0, 0x30, 0x30, 0x1c, 0x00},
    {0x18, 0x18, 0x18, 0x00, 0x18, 0x18, 0x18, 0x00},
    {0xe0, 0x30, 0x30, 0x1c, 0x30, 0x30, 0xe0, 0x00},
    {0x76, 0xdc, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
    {0x00, 0x10, 0x38, 0x6c, 0xc6, 0xc6, 0xfe, 0x00},
    {0x78, 0xcc, 0xc0, 0xcc, 0x78, 0x18, 0x0c, 0x78},
    {0x00, 0xcc, 0x00, 0xcc, 0xcc, 0xcc, 0x7e, 0x00},
    {0x1c, 0x00, 0x78, 0xcc, 0xfc, 0xc0, 0x78, 0x00},
    {0x7e, 0xc3, 0x3c, 0x06, 0x3e, 0x66, 0x3f, 0x00},
    {0xcc, 0x00, 0x78, 0x0c, 0x7c, 0xcc, 0x7e, 0x00},
    {0xe0, 0x00, 0x78, 0x0c, 0x7c, 0xcc, 0x7e, 0x00},
    {0x30, 0x30, 0x78, 0x0c, 0x7c, 0xcc, 0x7e, 0x00},
    {0x00, 0x00, 0x78, 0xc0, 0xc0, 0x78, 0x0c, 0x38},
    {0x7e, 0xc3, 0x3c, 0x66, 0x7e, 0x60, 0x3c, 0x00},
    {0xcc, 0x00, 0x78, 0xcc, 0xfc, 0xc0, 0x78, 0x00},
    {0xe0, 0x00, 0x78, 0xcc, 0xfc, 0xc0, 0x78, 0x00},
    {0xcc, 0x00, 0x70, 0x30, 0x30, 0x30, 0x78, 0x00},
    {0x7c, 0xc6, 0x38, 0x18, 0x18, 0x18, 0x3c, 0x00},
    {0xe0, 0x00, 0x70, 0x30, 0x30, 0x30, 0x78, 0x00},
    {0xc6, 0x38, 0x6c, 0xc6, 0xfe, 0xc6, 0xc6, 0x00},
    {0x30, 0x30, 0x00, 0x78, 0xcc, 0xfc, 0xcc, 0x00},
    {0x1c, 0x00, 0xfc, 0x60, 0x78, 0x60, 0xfc, 0x00},
    {0x00, 0x00, 0x7f, 0x0c, 0x7f, 0xcc, 0x7f, 0x00},
    {0x3e, 0x6c, 0xcc, 0xfe, 0xcc, 0xcc, 0xce, 0x00},
    {0x78, 0xcc, 0x00, 0x78, 0xcc, 0xcc, 0x78, 0x00},
    {0x00, 0xcc, 0x00, 0x78, 0xcc, 0xcc, 0x78, 0x00},
    {0x00, 0xe0, 0x00, 0x78, 0xcc, 0xcc, 0x78, 0x00},
    {0x78, 0xcc, 0x00, 0xcc, 0xcc, 0xcc, 0x7e, 0x00},
    {0x00, 0xe0, 0x00, 0xcc, 0xcc, 0xcc, 0x7e, 0x00},
    {0x00, 0xcc, 0x00, 0xcc, 0xcc, 0x7c, 0x0c, 0xf8},
    {0xc3, 0x18, 0x3c, 0x66, 0x66, 0x3c, 0x18, 0x00},
    {0xcc, 0x00, 0xcc, 0xcc, 0xcc, 0xcc, 0x78, 0x00},
    {0x18, 0x18, 0x7e, 0xc0, 0xc0, 0x7e, 0x18, 0x18},
    {0x38, 0x6c, 0x64, 0xf0, 0x60, 0xe6, 0xfc, 0x00},
    {0xcc, 0xcc, 0x78, 0xfc, 0x30, 0xfc, 0x30, 0x30},
    {0xf8, 0xcc, 0xcc, 0xfa, 0xc6, 0xcf, 0xc6, 0xc7},
    {0x0e, 0x1b, 0x18, 0x3c, 0x18, 0x18, 0xd8, 0x70},
    {0x1c, 0x00, 0x78, 0x0c, 0x7c, 0xcc, 0x7e, 0x00},
    {0x38, 0x00, 0x70, 0x30, 0x30, 0x30, 0x78, 0x00},
    {0x00, 0x1c, 0x00, 0x78, 0xcc, 0xcc, 0x78, 0x00},
    {0x00, 0x1c, 0x00, 0xcc, 0xcc, 0xcc, 0x7e, 0x00},
    {0x00, 0xf8, 0x00, 0xf8, 0xcc, 0xcc, 0xcc, 0x00},
    {0xfc, 0x00, 0xcc, 0xec, 0xfc, 0xdc, 0xcc, 0x00},
    {0x3c, 0x6c, 0x6c, 0x3e, 0x00, 0x7e, 0x00, 0x00},
    {0x38, 0x6c, 0x6c, 0x38, 0x00, 0x7c, 0x00, 0x00},
    {0x30, 0x00, 0x30, 0x60, 0xc0, 0xcc, 0x78, 0x00},
    {0x00, 0x00, 0x00, 0xfc, 0xc0, 0xc0, 0x00, 0x00},
    {0x00, 0x00, 0x00, 0xfc, 0x0c, 0x0c, 0x00, 0x00},
    {0xc3, 0xc6, 0xcc, 0xde, 0x33, 0x66, 0xcc, 0x0f},
    {0xc3, 0xc6, 0xcc, 0xdb, 0x37, 0x6f, 0xcf, 0x03},
    {0x18, 0x18, 0x00, 0x18, 0x18, 0x18, 0x18, 0x00},
    {0x00, 0x33, 0x66, 0xcc, 0x66, 0x33, 0x00, 0x00},
    {0x00, 0xcc, 0x66, 0x33, 0x66, 0xcc, 0x00, 0x00},
    {0x22, 0x88, 0x22, 0x88, 0x22, 0x88, 0x22, 0x88},
    {0x55, 0xaa, 0x55, 0xaa, 0x55, 0xaa, 0x55, 0xaa},
    {0xdb, 0x77, 0xdb, 0xee, 0xdb, 0x77, 0xdb, 0xee},
    {0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18},
    {0x18, 0x18, 0x18, 0x18, 0xf8, 0x18, 0x18, 0x18},
    {0x18, 0x18, 0xf8, 0x18, 0xf8, 0x18, 0x18, 0x18},
    {0x36, 0x36, 0x36, 0x36, 0xf6, 0x36, 0x36, 0x36},
    {0x00, 0x00, 0x00, 0x00, 0xfe, 0x36, 0x36, 0x36},
    {0x00, 0x00, 0xf8, 0x18, 0xf8, 0x18, 0x18, 0x18},
    {0x36, 0x36, 0xf6, 0x06, 0xf6, 0x36, 0x36, 0x36},
    {0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36},
    {0x00, 0x00, 0xfe, 0x06, 0xf6, 0x36, 0x36, 0x36},
    {0x36, 0x36, 0xf6, 0x06, 0xfe, 0x00, 0x00, 0x00},
    {0x36, 0x36, 0x36, 0x36, 0xfe, 0x00, 0x00, 0x00},
    {0x18, 0x18, 0xf8, 0x18, 0xf8, 0x00, 0x00, 0x00},
    {0x00, 0x00, 0x00, 0x00, 0xf8, 0x18, 0x18, 0x18},
    {0x18, 0x18, 0x18, 0x18, 0x1f, 0x00, 0x00, 0x00},
    {0x18, 0x18, 0x18, 0x18, 0xff, 0x00, 0x00, 0x00},
    {0x00, 0x00, 0x00, 0x00, 0xff, 0x18, 0x18, 0x18},
    {0x18, 0x18, 0x18, 0x18, 0x1f, 0x18, 0x18, 0x18},
    {0x00, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00},
    {0x18, 0x18, 0x18, 0x18, 0xff, 0x18, 0x18, 0x18},
    {0x18, 0x18, 0x1f, 0x18, 0x1f, 0x18, 0x18, 0x18},
    {0x36, 0x36, 0x36, 0x36, 0x37, 0x36, 0x36, 0x36},
    {0x36, 0x36, 0x37, 0x30, 0x3f, 0x00, 0x00, 0x00},
    {0x00, 0x00, 0x3f, 0x30, 0x37, 0x36, 0x36, 0x36},
    {0x36, 0x36, 0xf7, 0x00, 0xff, 0x00, 0x00, 0x00},
    {0x00, 0x00, 0xff, 0x00, 0xf7, 0x36, 0x36, 0x36},
    {0x36, 0x36, 0x37, 0x30, 0x37, 0x36, 0x36, 0x36},
    {0x00, 0x00, 0xff, 0x00, 0xff, 0x00, 0x00, 0x00},
    {0x36, 0x36, 0xf7, 0x00, 0xf7, 0x36, 0x36, 0x36},
    {0x18, 0x18, 0xff, 0x00, 0xff, 0x00, 0x00, 0x00},
    {0x36, 0x36, 0x36, 0x36, 0xff, 0x00, 0x00, 0x00},
    {0x00, 0x00, 0xff, 0x00, 0xff, 0x18, 0x18, 0x18},
    {0x00, 0x00, 0x00, 0x00, 0xff, 0x36, 0x36, 0x36},
    {0x36, 0x36, 0x36, 0x36, 0x3f, 0x00, 0x00, 0x00},
    {0x18, 0x18, 0x1f, 0x18, 0x1f, 0x00, 0x00, 0x00},
    {0x00, 0x00, 0x1f, 0x18, 0x1f, 0x18, 0x18, 0x18},
    {0x00, 0x00, 0x00, 0x00, 0x3f, 0x36, 0x36, 0x36},
    {0x36, 0x36, 0x36, 0x36, 0xff, 0x36, 0x36, 0x36},
    {0x18, 0x18, 0xff, 0x18, 0xff, 0x18, 0x18, 0x18},
    {0x18, 0x18, 0x18, 0x18, 0xf8, 0x00, 0x00, 0x00},
    {0x00, 0x00, 0x00, 0x00, 0x1f, 0x18, 0x18, 0x18},
    {0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff},
    {0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff},
    {0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0},
    {0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f},
    {0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00},
    {0x00, 0x00, 0x76, 0xdc, 0xc8, 0xdc, 0x76, 0x00},
    {0x00, 0x78, 0xcc, 0xf8, 0xcc, 0xf8, 0xc0, 0xc0},
    {0x00, 0xfc, 0xcc, 0xc0, 0xc0, 0xc0, 0xc0, 0x00},
    {0x00, 0xfe, 0x6c, 0x6c, 0x6c, 0x6c, 0x6c, 0x00},
    {0xfc, 0xcc, 0x60, 0x30, 0x60, 0xcc, 0xfc, 0x00},
    {0x00, 0x00, 0x7e, 0xd8, 0xd8, 0xd8, 0x70, 0x00},
    {0x00, 0x66, 0x66, 0x66, 0x66, 0x7c, 0x60, 0xc0},
    {0x00, 0x76, 0xdc, 0x18, 0x18, 0x18, 0x18, 0x00},
    {0xfc, 0x30, 0x78, 0xcc, 0xcc, 0x78, 0x30, 0xfc},
    {0x38, 0x6c, 0xc6, 0xfe, 0xc6, 0x6c, 0x38, 0x00},
    {0x38, 0x6c, 0xc6, 0xc6, 0x6c, 0x6c, 0xee, 0x00},
    {0x1c, 0x30, 0x18, 0x7c, 0xcc, 0xcc, 0x78, 0x00},
    {0x00, 0x00, 0x7e, 0xdb, 0xdb, 0x7e, 0x00, 0x00},
    {0x06, 0x0c, 0x7e, 0xdb, 0xdb, 0x7e, 0x60, 0xc0},
    {0x38, 0x60, 0xc0, 0xf8, 0xc0, 0x60, 0x38, 0x00},
    {0x78, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0x00},
    {0x00, 0xfc, 0x00, 0xfc, 0x00, 0xfc, 0x00, 0x00},
    {0x30, 0x30, 0xfc, 0x30, 0x30, 0x00, 0xfc, 0x00},
    {0x60, 0x30, 0x18, 0x30, 0x60, 0x00, 0xfc, 0x00},
    {0x18, 0x30, 0x60, 0x30, 0x18, 0x00, 0xfc, 0x00},
    {0x0e, 0x1b, 0x1b, 0x18, 0x18, 0x18, 0x18, 0x18},
    {0x18, 0x18, 0x18, 0x18, 0x18, 0xd8, 0xd8, 0x70},
    {0x30, 0x30, 0x00, 0xfc, 0x00, 0x30, 0x30, 0x00},
    {0x00, 0x76, 0xdc, 0x00, 0x76, 0xdc, 0x00, 0x00},
    {0x38, 0x6c, 0x6c, 0x38, 0x00, 0x00, 0x00, 0x00},
    {0x00, 0x00, 0x00, 0x18, 0x18, 0x00, 0x00, 0x00},
    {0x00, 0x00, 0x00, 0x00, 0x18, 0x00, 0x00, 0x00},
    {0x0f, 0x0c, 0x0c, 0x0c, 0xec, 0x6c, 0x3c, 0x1c},
    {0x78, 0x6c, 0x6c, 0x6c, 0x6c, 0x00, 0x00, 0x00},
    {0x70, 0x18, 0x30, 0x60, 0x78, 0x00, 0x00, 0x00},
    {0x00, 0x00, 0x3c, 0x3c, 0x3c, 0x3c, 0x00, 0x00},
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}
};

//
// Standard definition of EIA-189-A color bars.  The actual color definitions
// are either in CRGB24Synthesizer or CYUVSynthesizer.
//
const COLOR g_ColorBars[] = 
    {WHITE, YELLOW, CYAN, GREEN, MAGENTA, RED, BLUE, BLACK};

const UCHAR CRGB24Synthesizer::Colors [MAX_COLOR][3] = {
    {0, 0, 0},          // BLACK
    {255, 255, 255},    // WHITE
    {0, 255, 255},      // YELLOW
    {255, 255, 0},      // CYAN
    {0, 255, 0},        // GREEN
    {255, 0, 255},      // MAGENTA
    {0, 0, 255},        // RED
    {255, 0, 0},        // BLUE
    {128, 128, 128}     // GREY
};

const UCHAR CYUVSynthesizer::Colors [MAX_COLOR][3] = {
    {128, 16, 128},     // BLACK
    {128, 235, 128},    // WHITE
    {16, 211, 146},     // YELLOW
    {166, 170, 16},     // CYAN
    {54, 145, 34},      // GREEN
    {202, 106, 222},    // MAGENTA
    {90, 81, 240},      // RED
    {240, 41, 109},     // BLUE
    {128, 125, 128},    // GREY
};

/**************************************************************************

    LOCKED CODE

**************************************************************************/

#ifdef ALLOC_PRAGMA
#pragma code_seg()
#endif // ALLOC_PRAGMA


void
CImageSynthesizer::
SynthesizeBars (
    )

/*++

Routine Description:

    Synthesize EIA-189-A standard color bars onto the Image.  The image
    in question is the current synthesis buffer.

Arguments:

    None

Return Value:

    None

--*/

{
    const COLOR *CurColor = g_ColorBars;
    ULONG ColorCount = SIZEOF_ARRAY (g_ColorBars);

    //
    // Set the default cursor...
    //
    GetImageLocation (0, 0);

    //
    // Synthesize a single line.
    //
    PUCHAR ImageStart = m_Cursor;
    for (ULONG x = 0; x < m_Width; x++) 
        PutPixel (g_ColorBars [((x * ColorCount) / m_Width)]);

    PUCHAR ImageEnd = m_Cursor;
    
    //
    // Copy the synthesized line to all subsequent lines.
    //
    for (ULONG line = 1; line < m_Height; line++) {

        GetImageLocation (0, line);

        RtlCopyMemory (
            m_Cursor,
            ImageStart,
            ImageEnd - ImageStart
            );
    }
}

/*************************************************/


void 
CImageSynthesizer::
OverlayText (
    ULONG LocX,
    ULONG LocY,
    ULONG Scaling,
    CHAR *Text,
    COLOR BgColor,
    COLOR FgColor
    )

/*++

Routine Description:

    Overlay text onto the synthesized image.  Clip to fit the image
    if the overlay does not fit.  The image buffer used is the set
    synthesis buffer.

Arguments:

    LocX -
        The X location on the image to begin the overlay.  This MUST
        be inside the image.  POSITION_CENTER may be used to indicate
        horizontal centering.

    LocY -
        The Y location on the image to begin the overlay.  This MUST
        be inside the image.  POSITION_CENTER may be used to indicate
        vertical centering.

    Scaling -
        Normally, the overlay is done in 8x8 font.  A scaling of
        2 indicates 16x16, 3 indicates 24x24 and so forth.

    Text -
        A character string containing the information to overlay

    BgColor -
        The background color of the overlay window.  For transparency,
        indicate TRANSPARENT here.

    FgColor -
        The foreground color for the text overlay.

Return Value:

    None

--*/

{

    ASSERT ((LocX <= m_Width || LocX == POSITION_CENTER) &&
            (LocY <= m_Height || LocY == POSITION_CENTER));

    ULONG StrLen = 0;

    //
    // Determine the character length of the string.
    //
    for (CHAR *CurChar = Text; CurChar && *CurChar; CurChar++)
        StrLen++;

    //
    // Determine the physical size of the string plus border.  There is
    // a definable NO_CHARACTER_SEPARATION.  If this is defined, there will
    // be no added space between font characters.  Otherwise, one empty pixel
    // column is added between characters.
    //
    #ifndef NO_CHARACTER_SEPARATION
        ULONG LenX = (StrLen * (Scaling << 3)) + 1 + StrLen;
    #else // NO_CHARACTER_SEPARATION
        ULONG LenX = (StrLen * (Scaling << 3)) + 2;
    #endif // NO_CHARACTER_SEPARATION

    ULONG LenY = 2 + (Scaling << 3);

    //
    // Adjust for center overlays.
    //
    // NOTE: If the overlay doesn't fit into the synthesis buffer, this
    // merely left aligns the overlay and clips off the right side.
    //
    if (LocX == POSITION_CENTER) {
        if (LenX >= m_Width) {
            LocX = 0;
        } else {
            LocX = (m_Width >> 1) - (LenX >> 1);
        }
    }

    if (LocY == POSITION_CENTER) {
        if (LenY >= m_Height) {
            LocY = 0;
        } else {
            LocY = (m_Height >> 1) - (LenY >> 1);
        }
    }

    //
    // Determine the amount of space available on the synthesis buffer.
    // We will clip anything that finds itself outside the synthesis buffer.
    //
    ULONG SpaceX = m_Width - LocX;
    ULONG SpaceY = m_Height - LocY;

    //
    // Set the default cursor position.
    //
    GetImageLocation (LocX, LocY);

    //
    // Overlay a background color row.
    //
    if (BgColor != TRANSPARENT && SpaceY) {
        for (ULONG x = 0; x < LenX && x < SpaceX; x++) {
            PutPixel (BgColor);
        }
    }
    LocY++;
    if (SpaceY) SpaceY--;

    //
    // Loop across each row of the image.
    //
    for (ULONG row = 0; row < 8 && SpaceY; row++) {
        //
        // Generate a line.
        //
        GetImageLocation (LocX, LocY++);

        PUCHAR ImageStart = m_Cursor;

        ULONG CurSpaceX = SpaceX;
        if (CurSpaceX) {
            PutPixel (BgColor);
            CurSpaceX--;
        }

        //
        // Generate the row'th row of the overlay.
        //
        CurChar = Text;
        while (CurChar && *CurChar) {
            
            UCHAR CharBase = g_FontData [*CurChar++][row];
            for (ULONG mask = 0x80; mask && CurSpaceX; mask >>= 1) {
                for (ULONG scale = 0; scale < Scaling && CurSpaceX; scale++) {
                    if (CharBase & mask) {
                        PutPixel (FgColor);
                    } else {
                        PutPixel (BgColor);
                    }
                    CurSpaceX--;
                }
            }

            // 
            // Separate each character by one space.  Account for the border
            // space at the end by placing the separator after the last 
            // character also.
            //
            #ifndef NO_CHARACTER_SEPARATION
                if (CurSpaceX) {
                    PutPixel (BgColor);
                    CurSpaceX--;
                }
            #endif // NO_CHARACTER_SEPARATION

        }

        //
        // If there is no separation character defined, account for the
        // border.
        // 
        #ifdef NO_CHARACTER_SEPARATION
            if (CurSpaceX) {
                PutPixel (BgColor);
                CurSpaceX--;
            }
        #endif // NO_CHARACTER_SEPARATION
            

        PUCHAR ImageEnd = m_Cursor;
        //
        // Copy the line downward scale times.
        //
        for (ULONG scale = 1; scale < Scaling && SpaceY; scale++) {
            GetImageLocation (LocX, LocY++);
            RtlCopyMemory (m_Cursor, ImageStart, ImageEnd - ImageStart);
            SpaceY--;
        }

    }

    //
    // Add the bottom section of the overlay.
    //
    GetImageLocation (LocX, LocY);
    if (BgColor != TRANSPARENT && SpaceY) {
        for (ULONG x = 0; x < LenX && x < SpaceX; x++) {
            PutPixel (BgColor);
        }
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\ksfilter\tests\avshws\hwsim.h ===
/**************************************************************************

    AVStream Simulated Hardware Sample

    Copyright (c) 2001, Microsoft Corporation.

    File:

        hwsim.cpp

    Abstract:
        
        This file is the hardware simulation header.  

        The simulation fakes "DMA" transfers, scatter gather mapping handling, 
        ISR's, etc...  The ISR routine in here will be called when an ISR 
        would be generated by the fake hardware and it will directly call into 
        the device level ISR for more accurate simulation.

    History:

        created 3/9/2001

**************************************************************************/

//
// SCATTER_GATHER_MAPPINGS_MAX:
//
// The maximum number of entries in the hardware's scatter/gather list.  I
// am making this so large for a few reasons:
//
//     1) we're faking this with uncompressed surfaces -- 
//            these are large buffers which will map to a lot of s/g entries
//     2) the fake hardware implementation requires at least one frame's
//            worth of s/g entries to generate a frame
//
#define SCATTER_GATHER_MAPPINGS_MAX 128

//
// SCATTER_GATHER_ENTRY:
//
// This structure is used to keep the scatter gather table for the fake
// hardware as a doubly linked list.
//
typedef struct _SCATTER_GATHER_ENTRY {

    LIST_ENTRY ListEntry;
    PUCHAR Virtual;
    ULONG ByteCount;

} SCATTER_GATHER_ENTRY, *PSCATTER_GATHER_ENTRY;

//
// CHardwareSimulation:
//
// The hardware simulation class.
//
class CHardwareSimulation {

private:

    //
    // The image synthesizer.  This is a piece of code which actually draws
    // the requested images.
    //
    CImageSynthesizer *m_ImageSynth;

    //
    // The synthesis buffer.  This is a private buffer we use to generate the
    // capture image in.  The fake "scatter / gather" mappings are filled
    // in from this buffer during each interrupt.
    //
    PUCHAR m_SynthesisBuffer;

    //
    // Key information regarding the frames we generate.
    //
    LONGLONG m_TimePerFrame;
    ULONG m_Width;
    ULONG m_Height;
    ULONG m_ImageSize;

    //
    // Scatter gather mappings for the simulated hardware.
    //
    KSPIN_LOCK m_ListLock;
    LIST_ENTRY m_ScatterGatherMappings;

    //
    // Lookaside for memory for the scatter / gather entries on the scatter /
    // gather list.
    //
    NPAGED_LOOKASIDE_LIST m_ScatterGatherLookaside;

    //
    // The current state of the fake hardware.
    //
    HARDWARE_STATE m_HardwareState;

    //
    // The pause / stop hardware flag and event.
    //
    BOOLEAN m_StopHardware;
    KEVENT m_HardwareEvent;

    //
    // Maximum number of scatter / gather mappins in the s/g table of the
    // fake hardware.
    //
    ULONG m_ScatterGatherMappingsMax;

    //
    // Number of scatter / gather mappings that have been completed (total)
    // since the start of the hardware or any reset.
    //
    ULONG m_NumMappingsCompleted;

    //
    // Number of scatter / gather mappings that are queued for this hardware.
    //
    ULONG m_ScatterGatherMappingsQueued;
    ULONG m_ScatterGatherBytesQueued;

    //
    // Number of frames skipped due to lack of scatter / gather mappings.
    //
    ULONG m_NumFramesSkipped;

    //
    // The "Interrupt Time".  Number of "fake" interrupts that have occurred
    // since the hardware was started.
    // 
    ULONG m_InterruptTime;

    //
    // The system time at start.
    //
    LARGE_INTEGER m_StartTime;
    
    //
    // The DPC used to "fake" ISR
    //
    KDPC m_IsrFakeDpc;
    KTIMER m_IsrTimer;

    //
    // The hardware sink that will be used for interrupt notifications.
    //
    IHardwareSink *m_HardwareSink;

    //
    // FakeHardware():
    //
    // Called from the simulated interrupt.  First we fake the hardware's
    // actions (at DPC) then we call the "Interrupt service routine" on
    // the hardware sink.
    //
    void 
    FakeHardware (
        );

    //
    // SimulatedInterrupt():
    //
    // This is the hardware's simulated interrupt.  Really, it's just a DPC.
    // We'll use a spinlock instead of any KeSynchronizeExecutions.
    //
    static
    void
    SimulatedInterrupt (
        IN PKDPC Dpc,
        IN CHardwareSimulation *HardwareSim,
        IN PVOID SystemArg1,
        IN PVOID SystemArg2
        )
    {
        HardwareSim -> FakeHardware ();
    }

    //
    // FillScatterGatherBuffers():
    //
    // This is called by the hardware simulation to fill a series of scatter /
    // gather buffers with synthesized data.
    //
    NTSTATUS
    FillScatterGatherBuffers (
        );

public:

    //
    // CHardwareSimulation():
    //
    // The hardware simulation constructor.  Since the new operator will
    // have zeroed the memory, only initialize non-NULL, non-0 fields. 
    //
    CHardwareSimulation (
        IN IHardwareSink *HardwareSink
        );

    //
    // ~CHardwareSimulation():
    //
    // The hardware simulation destructor.
    //
    ~CHardwareSimulation (
        );

    //
    // Start():
    //
    // "Start" the fake hardware.  This will start issuing interrupts and 
    // DPC's. 
    //
    // The frame rate, image size, and a synthesizer must be provided.
    //
    NTSTATUS
    Start (
        CImageSynthesizer *ImageSynth,
        IN LONGLONG TimePerFrame,
        IN ULONG Width,
        IN ULONG Height,
        IN ULONG ImageSize
        );

    //
    // Pause():
    //
    // "Pause" or "unpause" the fake hardware.  This will stop issuing 
    // interrupts or DPC's on a pause and restart them on an unpause.  Note
    // that this will not reset counters as a Stop() would.
    //
    NTSTATUS
    Pause (
        IN BOOLEAN Pausing
        );

    //
    // Stop():
    //
    // "Stop" the fake hardware.  This will stop issuing interrupts and
    // DPC's.
    //
    NTSTATUS
    Stop (
        );

    //
    // ProgramScatterGatherMappings():
    //
    // Program a series of scatter gather mappings into the fake hardware.
    //
    ULONG
    ProgramScatterGatherMappings (
        IN PUCHAR *Buffer,
        IN PKSMAPPING Mappings,
        IN ULONG MappingsCount,
        IN ULONG MappingStride
        );

    //
    // Initialize():
    //
    // Initialize a piece of simulated hardware.
    //
    static 
    CHardwareSimulation *
    Initialize (
        IN KSOBJECT_BAG Bag,
        IN IHardwareSink *HardwareSink
        );

    //
    // ReadNumberOfMappingsCompleted():
    //
    // Read the number of mappings completed since the last hardware reset.
    //
    ULONG
    ReadNumberOfMappingsCompleted (
        );

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\ksfilter\tests\avshws\image.h ===
/**************************************************************************

    AVStream Simulated Hardware Sample

    Copyright (c) 2001, Microsoft Corporation.

    File:

        image.h

    Abstract:

        The image synthesis and overlay header.  These objects provide image
        synthesis (pixel, color-bar, etc...) onto RGB24 and UYVY buffers as
        well as software string overlay into these buffers.

    History:

        created 1/16/2001

**************************************************************************/

/**************************************************************************

    Constants

**************************************************************************/

//
// COLOR:
//
// Pixel color for placement onto the synthesis buffer.
//
typedef enum {

    BLACK = 0,
    WHITE,
    YELLOW,
    CYAN,
    GREEN,
    MAGENTA,
    RED,
    BLUE,
    GREY,

    MAX_COLOR,
    TRANSPARENT,

} COLOR;

//
// POSITION_CENTER:
//
// Only useful for text overlay.  This can be substituted for LocX or LocY
// in order to center the text screen on the synthesis buffer.
//
#define POSITION_CENTER ((ULONG)-1)

/*************************************************

    CImageSynthesizer

    This class synthesizes images in various formats for output from the
    capture filter.  It is capable of performing various text overlays onto
    the image surface.

*************************************************/

class CImageSynthesizer {

protected:

    //
    // The width and height the synthesizer is set to. 
    //
    ULONG m_Width;
    ULONG m_Height;

    //
    // The synthesis buffer.  All scan conversion happens in the synthesis
    // buffer.  This must be set with SetBuffer() before any scan conversion
    // routines are called.
    //
    PUCHAR m_SynthesisBuffer;

    //
    // The default cursor.  This is a pointer into the synthesis buffer where
    // a non specific PutPixel will be placed. 
    //
    PUCHAR m_Cursor;

public:

    //
    // PutPixel():
    //
    // Place a pixel at the specified image cursor and move right
    // by one pixel.  No bounds checking...  wrap around occurs.
    //
    virtual void
    PutPixel (
        PUCHAR *ImageLocation,
        COLOR Color
        ) = 0;

    //
    // PutPixel():
    //
    // Place a pixel at the default image cursor and move right
    // by one pixel.  No bounds checking...  wrap around occurs.
    //
    // If the derived class doesn't provide an implementation, provide
    // one.
    //
    virtual void
    PutPixel (
        COLOR Color
        )
    {
        PutPixel (&m_Cursor, Color);
    }
        

    //
    // GetImageLocation():
    //
    // Get the location into the image buffer for a specific X/Y location.
    // This also sets the synthesizer's default cursor to the position
    // LocX, LocY.
    //
    virtual PUCHAR
    GetImageLocation (  
        ULONG LocX,
        ULONG LocY
        ) = 0;

    //
    // SetImageSize():
    //
    // Set the image size of the synthesis buffer.
    //
    void
    SetImageSize (
        ULONG Width,
        ULONG Height
        )
    {
        m_Width = Width;
        m_Height = Height;
    }

    //
    // SetBuffer():
    //
    // Set the buffer the synthesizer generates images to.
    //
    void
    SetBuffer (
        PUCHAR SynthesisBuffer
        )
    {
        m_SynthesisBuffer = SynthesisBuffer;
    }

    //
    // SynthesizeBars():
    //
    // Synthesize EIA-189-A standard color bars.
    //
    void
    SynthesizeBars (
        );

    //
    // OverlayText():
    //
    // Overlay a text string onto the image.
    //
    void
    OverlayText (
        ULONG LocX,
        ULONG LocY,
        ULONG Scaling,
        CHAR *Text,
        COLOR BgColor,
        COLOR FgColor
        );

    //
    // DEFAULT CONSTRUCTOR
    //
    CImageSynthesizer (
        ) :
        m_Width (0),
        m_Height (0),
        m_SynthesisBuffer (NULL)
    {
    }

    //
    // CONSTRUCTOR:
    //
    CImageSynthesizer (
        ULONG Width,
        ULONG Height
        ) :
        m_Width (Width),
        m_Height (Height),
        m_SynthesisBuffer (NULL)
    {
    }

    //
    // DESTRUCTOR:
    //
    virtual
    ~CImageSynthesizer (
        )
    {
    }

};

/*************************************************

    CRGB24Synthesizer

    Image synthesizer for RGB24 format.

*************************************************/

class CRGB24Synthesizer : public CImageSynthesizer {

private:

    const static UCHAR Colors [MAX_COLOR][3];

    BOOLEAN m_FlipVertical;

public:

    //
    // PutPixel():
    //
    // Place a pixel at a specific cursor location.  *ImageLocation must
    // reside within the synthesis buffer.
    //
    virtual void
    PutPixel (
        PUCHAR *ImageLocation,
        COLOR Color
        )
    {
        if (Color != TRANSPARENT) {
            *(*ImageLocation)++ = Colors [(ULONG)Color][0];
            *(*ImageLocation)++ = Colors [(ULONG)Color][1];
            *(*ImageLocation)++ = Colors [(ULONG)Color][2];
        } else {
            *ImageLocation += 3;
        }
    }

    //
    // PutPixel():
    //
    // Place a pixel at the default cursor location.  The cursor location
    // must be set via GetImageLocation(x, y).
    // 
    virtual void
    PutPixel (
        COLOR Color
        )
    {
        if (Color != TRANSPARENT) {
            *m_Cursor++ = Colors [(ULONG)Color][0];
            *m_Cursor++ = Colors [(ULONG)Color][1];
            *m_Cursor++ = Colors [(ULONG)Color][2];
        } else {
            m_Cursor += 3;
        }
    }

    virtual PUCHAR
    GetImageLocation (
        ULONG LocX,
        ULONG LocY
        )
    {
        if (m_FlipVertical) {
            return (m_Cursor = 
                (m_SynthesisBuffer + 3 * 
                    (LocX + (m_Height - 1 - LocY) * m_Width))
                );
        } else {
            return (m_Cursor =
                (m_SynthesisBuffer + 3 * (LocX + LocY * m_Width))
                );
        }
    }

    //
    // DEFAULT CONSTRUCTOR:
    //
    CRGB24Synthesizer (
        BOOLEAN FlipVertical
        ) :
        m_FlipVertical (FlipVertical)
    {
    }

    //
    // CONSTRUCTOR:
    //
    CRGB24Synthesizer (
        BOOLEAN FlipVertical,
        ULONG Width,
        ULONG Height
        ) :
        CImageSynthesizer (Width, Height),
        m_FlipVertical (FlipVertical)
    {
    }

    //
    // DESTRUCTOR:
    //
    virtual
    ~CRGB24Synthesizer (
        )
    {
    }

};

/*************************************************

    CYUVSynthesizer

    Image synthesizer for YUV format.

*************************************************/

class CYUVSynthesizer : public CImageSynthesizer {

private:

    const static UCHAR Colors [MAX_COLOR][3];

    BOOLEAN m_Parity;

public:

    //
    // PutPixel():
    //
    // Place a pixel at a specific cursor location.  *ImageLocation must
    // reside within the synthesis buffer.
    //
    virtual void
    PutPixel (
        PUCHAR *ImageLocation,
        COLOR Color
        )
    {

        BOOLEAN Parity = (((*ImageLocation - m_SynthesisBuffer) & 0x2) != 0);

#if DBG
        //
        // Check that the current pixel points to a valid start pixel
        // in the UYVY buffer.
        //
        BOOLEAN Odd = (((*ImageLocation - m_SynthesisBuffer) & 0x1) != 0);
        ASSERT ((m_Parity && Odd) || (!m_Parity && !Odd));
#endif // DBG

        if (Color != TRANSPARENT) {
            if (Parity) {
                *(*ImageLocation)++ = Colors [(ULONG)Color][1];
            } else {
                *(*ImageLocation)++ = Colors [(ULONG)Color][0];
                *(*ImageLocation)++ = Colors [(ULONG)Color][1];
                *(*ImageLocation)++ = Colors [(ULONG)Color][2];
            }
        } else {
            *ImageLocation += (Parity ? 1 : 3);
        }

    }

    //
    // PutPixel():
    //
    // Place a pixel at the default cursor location.  The cursor location
    // must be set via GetImageLocation(x, y).
    //
    virtual void
    PutPixel (
        COLOR Color
        )

    {

        if (Color != TRANSPARENT) {
            if (m_Parity) {
                *m_Cursor++ = Colors [(ULONG)Color][1];
            } else {
                *m_Cursor++ = Colors [(ULONG)Color][0];
                *m_Cursor++ = Colors [(ULONG)Color][1];
                *m_Cursor++ = Colors [(ULONG)Color][2];
            }
        } else {
            m_Cursor += (m_Parity ? 1 : 3);
        }

        m_Parity = !m_Parity;

    }

    virtual PUCHAR
    GetImageLocation (
        ULONG LocX,
        ULONG LocY
        )
    {
    
        m_Cursor = m_SynthesisBuffer + ((LocX + LocY * m_Width) << 1);
        if (m_Parity = ((LocX & 1) != 0)) 
            m_Cursor++;

        return m_Cursor;
    }

    //
    // DEFAULT CONSTRUCTOR:
    //
    CYUVSynthesizer (
        ) 
    {
    }

    //
    // CONSTRUCTOR:
    //
    CYUVSynthesizer (
        ULONG Width,
        ULONG Height
        ) :
        CImageSynthesizer (Width, Height)
    {
    }

    //
    // DESTRUCTOR:
    //
    virtual
    ~CYUVSynthesizer (
        )
    {
    }

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\ksfilter\tests\avstest\avssamp.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       avssamp.h
//
//--------------------------------------------------------------------------

extern "C" {
#include <wdm.h>
}

#include <windef.h>
#include <stdio.h>
#include <stdlib.h>
#include <windef.h>
#define NOBITMAP
#include <mmreg.h>
#undef NOBITMAP
#include <unknown.h>
#include <ks.h>
#include <ksmedia.h>
#include <kcom.h>

#if (DBG)
#define STR_MODULENAME "avssamp: "
#endif
#include <ksdebug.h>

#define PERIOD_8KBytesS  1250
#define PERIOD_11KBytesS  909


#define FILTER_DESCRIPTORS_COUNT    1
extern const KSFILTER_DESCRIPTOR*const FilterDescriptors[ FILTER_DESCRIPTORS_COUNT ];

#ifndef mmioFOURCC    
#define mmioFOURCC( ch0, ch1, ch2, ch3 )                \
        ( (DWORD)(BYTE)(ch0) | ( (DWORD)(BYTE)(ch1) << 8 ) |    \
        ( (DWORD)(BYTE)(ch2) << 16 ) | ( (DWORD)(BYTE)(ch3) << 24 ) )
#endif

#define FOURCC_YUV422       mmioFOURCC('U', 'Y', 'V', 'Y')

// Select an image to synthesize by connecting to a particular
// input pin on the analog crossbar.  The index of the pin
// selects the image to synthesize.

typedef enum _ImageXferCommands
{
    IMAGE_XFER_NTSC_EIA_100AMP_100SAT = 0,
    IMAGE_XFER_NTSC_EIA_75AMP_100SAT,
    IMAGE_XFER_BLACK,
    IMAGE_XFER_WHITE,
    IMAGE_XFER_GRAY_INCREASING,
    IMAGE_XFER_LIST_TERMINATOR                  // Always keep this guy last
} ImageXferCommands;


typedef struct _TS_SIGN{
    LONGLONG Abs;
    LONGLONG Rel;
    LONGLONG Int;
} TS_SIGN;

class CCapFilter
{
private:
    KSSTATE                 m_state;
    PKSFILTER               m_pKsFilter;
    FILE_OBJECT             *m_pFilterObject;
    KS_FRAME_INFO           m_FrameInfo;
    KTIMER                  m_TimerObject;
    KDPC                    m_TimerDpc;
    
    ULONG                   m_ulPeriod;
    ULONG                   m_iTick;
    LONG                    m_TimerScheduled;
    LONG                    m_Active;
    LONGLONG                m_llStartTime;
    LONGLONG                m_llNextTime;
    LONGLONG                m_llLastTime;

    PKS_VIDEOINFOHEADER     m_VideoInfoHeader;
    UCHAR                   m_LineBuffer[720 * 3];// working buffer (RGB24)
    
    BYTE                    *m_pAudioBuffer;
    ULONG                   m_ulAudioBufferSize;
    ULONG                   m_ulAudioBufferOffset;
    ULONGLONG               m_ullNextAudioPos;

    ULONG                   m_iTimestamp;
    TS_SIGN                 *m_rgTimestamps;

    ULONG                   m_ulAudioDroppedFrames;
    ULONG                   m_ulVideoDroppedFrames;

public:
    static         
    VOID
    NTAPI
    TimerDeferredRoutine(
        IN PKDPC Dpc,
        IN PVOID DeferredContext,
        IN PVOID SystemArgument1,
        IN PVOID SystemArgument2
        );

    CCapFilter() :
        m_state(KSSTATE_STOP)
    {
        KeInitializeTimer(&m_TimerObject);
        KeInitializeDpc(
            &m_TimerDpc,
            CCapFilter::TimerDeferredRoutine,
            this);
    }
    
    ~CCapFilter(
        void
        )
    {
        if (m_VideoInfoHeader) {
            ExFreePool(m_VideoInfoHeader);
        }

        if ( m_pAudioBuffer != NULL ) {
            ExFreePool(m_pAudioBuffer);
        }

        if ( m_rgTimestamps != NULL ) {
            ExFreePool(m_rgTimestamps);
        }
    }
    
    
    NTSTATUS
    GetDefaultClock(
        OUT PKSDEFAULTCLOCK *ppDefaultClock
        );

    NTSTATUS 
    CopyFile(
        IN WCHAR *wsFileName
        );
    
    NTSTATUS
    CaptureVideoInfoHeader(
        IN PKS_VIDEOINFOHEADER VideoInfoHeader
        );
    
    VOID
    CopyAudioData(
        OUT VOID *pData, 
        IN ULONG cBytes
        );

    ULONG 
    ImageSynth(
        OUT PVOID Data,
        IN ULONG ByteCount,
        IN ImageXferCommands Command,
        IN BOOL FlipHorizontal
        );
        
    NTSTATUS
    CancelTimer();
    
    NTSTATUS
    Run( 
        IN PKSPIN Pin,
        IN KSSTATE FromState 
        );
        
    NTSTATUS
    Stop( 
        IN PKSPIN Pin,
        IN KSSTATE FromState 
        );
        
    NTSTATUS
    Pause( 
        IN PKSPIN Pin,
        IN KSSTATE FromState 
        );
         
    static
    NTSTATUS
    Process(
        IN PKSFILTER Filter,
        IN PKSPROCESSPIN_INDEXENTRY ProcessPinsIndex
        );
    static
    NTSTATUS
    FilterCreate(
        IN OUT PKSFILTER Filter,
        IN PIRP Irp
        );
    static
    NTSTATUS
    FilterClose(
        IN OUT PKSFILTER Filter,
        IN PIRP Irp
        );
    static
    NTSTATUS
    Property_DroppedFrames(
        IN PIRP Irp,
        IN PKSPROPERTY Property,
        OUT PKSPROPERTY_DROPPEDFRAMES_CURRENT_S DroppedFrames
        );

private:

    enum SampleType {
        Audio,
        Video
    };

    struct SAMPLE_DATA {
        SampleType  m_type;
        LONGLONG   m_llTimeStamp;
        ULONGLONG   m_ullSize;
    };

    SAMPLE_DATA *m_rgSamples ;
    ULONG       m_cSamples;
    ULONG       m_iSample;

    void 
    RegisterSample(
        SampleType type, 
        LONGLONG ullTimeStamp,
        ULONGLONG ullSize);
    
    void 
    DumpSamples();
    
    friend
    LONGLONG
    FASTCALL
    CapCorrelatedTime(
        IN KSPIN *pContext,
        OUT LONGLONG *pllSystemTime);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\ksfilter\tests\avstest\filter.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       filter.cpp
//
//--------------------------------------------------------------------------

#include "avssamp.h"

#define MAX_TIMESTAMPS 200

#ifdef ALLOC_DATA_PRAGMA
#pragma const_seg("PAGECONST")
#endif // ALLOC_DATA_PRAGMA


VOID
NTAPI
CCapFilter::TimerDeferredRoutine(
    IN PKDPC Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemArgument1,
    IN PVOID SystemArgument2
    )
/*++

Routine Description:
    Deferred routine to simulate data interrupts.

Arguments:
    IN PKDPC Dpc -
        pointer to DPC

    IN PVOID DeferredContext -
        pointer to context 

    IN PVOID SystemArgument1 -
        not used

    IN PVOID SystemArgument2 -
        not used

Return:
    No return value.

--*/
{
///    _DbgPrintF(DEBUGLVL_BLAB,("TimerDeferredRoutine"));
    
    CCapFilter *filter = reinterpret_cast<CCapFilter *>(DeferredContext);
    //
    // Force this to be completed before the compare.
    //
    InterlockedExchange(&filter->m_TimerScheduled,FALSE);
    if (filter->m_Active) 
    {
        //
        // Compute next moment when this Dpc should be scheduled.
        // Note that schedule time is computed in absolute system 
        // time and should not be affected by cumulated errors,
        // although changing the system clock will mess this up.
        //
        LARGE_INTEGER NextTime;
        NextTime.QuadPart = filter->m_llStartTime +
            (filter->m_iTick + 1) * filter->m_VideoInfoHeader->AvgTimePerFrame;
        filter->m_TimerScheduled = TRUE;
        KeSetTimer(&filter->m_TimerObject,NextTime,&filter->m_TimerDpc);
    } 
    else 
    {
        _DbgPrintF(DEBUGLVL_TERSE,("DPC noticed we are inactive now"));
    }
    KsFilterAttemptProcessing(filter->m_pKsFilter,FALSE);
    filter->m_iTick++;                
}


NTSTATUS
CCapFilter::
Process(
    IN PKSFILTER KsFilter,
    IN KSPROCESSPIN_INDEXENTRY ProcessPinsIndex[]
    )

/*++

Routine Description:

    This routine is called when there is data to be processed.

Arguments:

    Filter -
        Contains a pointer to the  filter structure.

    ProcessPinsIndex -
        Contains a pointer to an array of process pin index entries.  This
        array is indexed by pin ID.  An index entry indicates the number 
        of pin instances for the corresponding filter type and points to the
        first corresponding process pin structure in the ProcessPins array.
        This allows process pin structures to be quickly accessed by pin ID
        when the number of instances per type is not known in advance.

Return Value:

    Indication of whether more processing should be done if frames are 
    available.  A value of FALSE indicates that processing should not
    continue even if frames are available on all required queues.  Any other
    return value indicates processing should continue if frames are
    available on all required queues.

--*/

{
///    _DbgPrintF(DEBUGLVL_BLAB,("Process"));
    
    ASSERT(ProcessPinsIndex[0].Count == 1);
// uncomment when audio is required.    ASSERT(ProcessPinsIndex[1].Count == 1);

    CCapFilter *pFilter = reinterpret_cast<CCapFilter *>(KsFilter->Context);
    
    PKSPROCESSPIN processVideoPin = ProcessPinsIndex[0].Pins[0];
    PKSPROCESSPIN processAudioPin = NULL; // uncomment when audio is required.    ProcessPinsIndex[1].Pins[0];

    //
    // compute the presentation time associated to current frame    
    //
    LONGLONG llCrtTime = pFilter->m_iTick * pFilter->m_VideoInfoHeader->AvgTimePerFrame;
    
    //
    // save system clock value when processing is invoked
    //
    if ( pFilter->m_iTimestamp < MAX_TIMESTAMPS) {
        LARGE_INTEGER liTimestamp;
        KeQuerySystemTime(&liTimestamp);
        pFilter->m_rgTimestamps[pFilter->m_iTimestamp].Abs = liTimestamp.QuadPart;
        pFilter->m_rgTimestamps[pFilter->m_iTimestamp].Rel = liTimestamp.QuadPart - pFilter->m_llStartTime;
    }

    //
    // If there is frame space available for audio data, 
    // copy as much audio data as possible.
    //
    if(processAudioPin != NULL)
    {
        if ( processAudioPin->BytesAvailable > 0 ) {
            
            ULONGLONG ullCrtAudioPos;
            ULONGLONG ullAudioBytes;
            PKSSTREAM_HEADER pStreamHeader;

            //
            // Compute the current position into audio stream and the number 
            // of samples to be "captured" in order to reach that position.
            // Then as much samples as possible are output into frame and 
            // position of audio stream is updated
            //
            ullCrtAudioPos = llCrtTime / pFilter->m_ulPeriod;
            ullAudioBytes = ullCrtAudioPos - pFilter->m_ullNextAudioPos + 1;
            ullAudioBytes = min(processAudioPin->BytesAvailable, ullAudioBytes);
            pFilter->m_ullNextAudioPos = ullAudioBytes + pFilter->m_ullNextAudioPos;
            pFilter->CopyAudioData(processAudioPin->Data, (ULONG)ullAudioBytes);
            
            processAudioPin->BytesUsed += (ULONG)ullAudioBytes;
            processAudioPin->Terminate = TRUE;
            
            pStreamHeader = processAudioPin->StreamPointer->StreamHeader;
            pStreamHeader->Duration = 0;
            pStreamHeader->PresentationTime.Time = llCrtTime;
            pStreamHeader->PresentationTime.Numerator = 1;
            pStreamHeader->PresentationTime.Denominator = 1;
            pStreamHeader->OptionsFlags |= KSSTREAM_HEADER_OPTIONSF_TIMEVALID; 
            
            pFilter->RegisterSample(Audio,llCrtTime,ullAudioBytes);
        }
        else {
            pFilter->m_ulAudioDroppedFrames ++;
            if ( pFilter->m_ulAudioDroppedFrames % 100 == 0 ) {
                DbgPrint("Dropped %lu/%lu audio frames \n", 
                         pFilter->m_ulAudioDroppedFrames,
                         pFilter->m_iTick);
            }
        }
    }


    //
    // If there is space available on the video frame, 
    // generate current video frame data.
    //
    if ( processVideoPin->BytesAvailable > 0 ) {
        
        PKSSTREAM_HEADER pStreamHeader;
        
        pFilter->m_FrameInfo.PictureNumber = pFilter-> m_iTick;

        processVideoPin->BytesUsed = 
            pFilter->ImageSynth(
                processVideoPin->Data, 
                processVideoPin->BytesAvailable,
                IMAGE_XFER_NTSC_EIA_100AMP_100SAT, 
                0);
        processVideoPin->Terminate = TRUE;

        pStreamHeader = processVideoPin->StreamPointer->StreamHeader;

        pStreamHeader->PresentationTime.Time = llCrtTime;
        pStreamHeader->PresentationTime.Numerator = 1;
        pStreamHeader->PresentationTime.Denominator = 1;
        pStreamHeader->Duration = pFilter->m_VideoInfoHeader->AvgTimePerFrame;
        pStreamHeader->OptionsFlags |= KSSTREAM_HEADER_OPTIONSF_TIMEVALID | 
                                       KSSTREAM_HEADER_OPTIONSF_DURATIONVALID;

        pFilter->RegisterSample(Video,llCrtTime,processVideoPin->BytesUsed);
    }
    else {
        pFilter->m_ulVideoDroppedFrames ++;
        if ( pFilter->m_ulVideoDroppedFrames % 100 == 0 ) {
            DbgPrint("Dropped %lu/%lu video frames \n", 
                     pFilter->m_ulVideoDroppedFrames,
                     pFilter->m_iTick);
        }
    }

    //
    // Run only when the timer fires.
    //
    return STATUS_PENDING;
}

//
// EIA-189-A Standard color bar definitions
//

// 75% Amplitude, 100% Saturation
const static UCHAR NTSCColorBars75Amp100SatRGB24 [3][8] = 
{
//  Whi Yel Cya Grn Mag Red Blu Blk
    191,  0,191,  0,191,  0,191,  0,    // Blue
    191,191,191,191,  0,  0,  0,  0,    // Green
    191,191,  0,  0,191,191,  0,  0,    // Red
};

// 100% Amplitude, 100% Saturation
const static UCHAR NTSCColorBars100Amp100SatRGB24 [3][8] = 
{
//  Whi Yel Cya Grn Mag Red Blu Blk
    255,  0,255,  0,255,  0,255,  0,    // Blue
    255,255,255,255,  0,  0,  0,  0,    // Green
    255,255,  0,  0,255,255,  0,  0,    // Red
};

const static UCHAR NTSCColorBars100Amp100SatYUV [4][8] = 
{
//  Whi Yel Cya Grn Mag Red Blu Blk
    128, 16,166, 54,202, 90,240,128,    // U
    235,211,170,145,106, 81, 41, 16,    // Y
    128,146, 16, 34,222,240,109,128,    // V
    235,211,170,145,106, 81, 41, 16     // Y
};


ULONG 
CCapFilter::ImageSynth(
    OUT PVOID Data,
    IN ULONG ByteCount,
    IN ImageXferCommands Command,
    IN BOOL FlipHorizontal
    )

/*++

Routine Description:

    Synthesizes NTSC color bars, white, black, and grayscale images.

Arguments:

Return Value:

    size of transfer in bytes

--*/

{
    _DbgPrintF(DEBUGLVL_BLAB,("ImageSynth Data=%x Count=%d Cmd=%d Flip=%d", Data, ByteCount, Command, FlipHorizontal));
    
    UINT biWidth        =   m_VideoInfoHeader->bmiHeader.biWidth;
    UINT biHeight       =   m_VideoInfoHeader->bmiHeader.biHeight;
    UINT biSizeImage    =   m_VideoInfoHeader->bmiHeader.biSizeImage;
    UINT biWidthBytes   =   KS_DIBWIDTHBYTES( m_VideoInfoHeader->bmiHeader );
    UINT biBitCount     =   m_VideoInfoHeader->bmiHeader.biBitCount;
    UINT LinesToCopy    =   abs( biHeight );
    DWORD biCompression =   m_VideoInfoHeader->bmiHeader.biCompression;
    _DbgPrintF(DEBUGLVL_BLAB,("           biWidth=%d biHeight=%d biSizeImage=%d biBitCount=%d LinesToCopy=%d", 
        biWidth, biHeight, biSizeImage, biWidthBytes, biBitCount, LinesToCopy));

    UINT                    Line;
    PUCHAR                  Image = (PUCHAR)Data;
    
    
    // 
    // Synthesize a single line of image data, which will then be replicated
    //

    if (!ByteCount) {
        return 0;
    }
    
    if ((biBitCount == 24) && (biCompression == KS_BI_RGB)) {
        switch (Command) {
    
        case IMAGE_XFER_NTSC_EIA_100AMP_100SAT:
            // 100% saturation
            {
                UINT x, col;
                PUCHAR Temp = m_LineBuffer;
        
                for (x = 0; x < biWidth; x++) {
                    col = (x * 8) / biWidth;
                    col = FlipHorizontal ? (7 - col) : col;
                    
                    *Temp++ = NTSCColorBars100Amp100SatRGB24[0][col]; // Red
                    *Temp++ = NTSCColorBars100Amp100SatRGB24[1][col]; // Green
                    *Temp++ = NTSCColorBars100Amp100SatRGB24[2][col]; // Blue
                }
            }
            break;
    
        case IMAGE_XFER_NTSC_EIA_75AMP_100SAT:
            // 75% Saturation
            {
                UINT x, col;
                PUCHAR Temp = m_LineBuffer;
        
                for (x = 0; x < biWidth; x++) {
                    col = (x * 8) / biWidth;
                    col = FlipHorizontal ? (7 - col) : col;

                    *Temp++ = NTSCColorBars75Amp100SatRGB24[0][col]; // Red
                    *Temp++ = NTSCColorBars75Amp100SatRGB24[1][col]; // Green
                    *Temp++ = NTSCColorBars75Amp100SatRGB24[2][col]; // Blue
                }
            }
            break;
    
        case IMAGE_XFER_BLACK:
            // Camma corrected Grayscale ramp
            {
                UINT x, col;
                PUCHAR Temp = m_LineBuffer;
        
                for (x = 0; x < biWidth; x++) {
                    col = (255 * (x * 10) / biWidth) / 10;
                    col = FlipHorizontal ? (255 - col) : col;

                    *Temp++ = (BYTE) col; // Red
                    *Temp++ = (BYTE) col; // Green
                    *Temp++ = (BYTE) col; // Blue
                }
            }
            break;
    
        case IMAGE_XFER_WHITE:
            // All white
            RtlFillMemory(
                m_LineBuffer,
                biWidthBytes,
                (UCHAR) 255);
            break;
    
        case IMAGE_XFER_GRAY_INCREASING:
            // grayscale increasing with each image captured
            RtlFillMemory(
                m_LineBuffer,
                biWidthBytes,
                (UCHAR) (m_FrameInfo.PictureNumber * 8));
            break;
    
        default:
            break;
        }
    } // endif RGB24

    else if ((biBitCount == 16) && (biCompression == FOURCC_YUV422)) {
        switch (Command) {
    
        case IMAGE_XFER_NTSC_EIA_100AMP_100SAT:
        default:
            {
                UINT x, col;
                PUCHAR Temp = m_LineBuffer;
        
                for (x = 0; x < (biWidth / 2); x++) {
                    col = (x * 8) / (biWidth / 2);
                    col = FlipHorizontal ? (7 - col) : col;

                    *Temp++ = NTSCColorBars100Amp100SatYUV[0][col]; // U
                    *Temp++ = NTSCColorBars100Amp100SatYUV[1][col]; // Y
                    *Temp++ = NTSCColorBars100Amp100SatYUV[2][col]; // V
                    *Temp++ = NTSCColorBars100Amp100SatYUV[3][col]; // Y
                }
            }
            break;
        }
    } 

    else {
        _DbgPrintF( DEBUGLVL_ERROR, ("Unknown format!!!") );
    }


    // 
    // Copy the single line synthesized to all rows of the image
    //

    ULONG cutoff = ULONG
    (   (   (   (   ULONGLONG(m_VideoInfoHeader->AvgTimePerFrame) 
                *   ULONGLONG(m_FrameInfo.PictureNumber)
                ) 
            %   ULONGLONG(10000000)
            ) 
        *   ULONGLONG(LinesToCopy)
        ) 
    /   ULONGLONG(10000000)
    );
    for (Line = 0; (Line < LinesToCopy); Line++, Image += biWidthBytes) {
#if 1
        // Show some action on an otherwise static image
        // This will be a changing grayscale horizontal band
        // at the bottom of an RGB image and a changing color band at the 
        // top of a YUV image

        if (Line >= 3 && Line <= 6) {
            UINT j;
            for (j = 0; j < biWidthBytes; j++) {
                *(Image + j) = (UCHAR) m_FrameInfo.PictureNumber;
            }
            continue;
        }
#endif
        // Copy the synthesized line
        if (Line > cutoff) {
            RtlCopyMemory(
                    Image,
                    m_LineBuffer,
                    biWidthBytes );
        } else {
            RtlZeroMemory(
                    Image,
                    biWidthBytes );
        }
    }

    //
    // Report back the actual number of bytes copied to the destination buffer
    // (This can be smaller than the allocated buffer for compressed images)
    //

    return ByteCount;
}


void
CCapFilter::
CopyAudioData(
    OUT PVOID Data, 
    IN ULONG cBytes
    )

/*++

Routine Description:

    Copies cBytes worth of audio data from internal buffer 
    to memory pointed by Data.

Arguments:

    OUT PVOID Data - buffer where audio data should be copied

    IN ULONG cBytes - number of bytes to copy
    
Return Value:

--*/

{
    _DbgPrintF(DEBUGLVL_BLAB,("CopyAudioData"));
    
    ULONG cNextBytes;
    //
    // Copies from current offset in buffer to end. 
    // If this is not enough, restarts from begining.
    //
    do {
        cNextBytes = min(cBytes, m_ulAudioBufferSize - m_ulAudioBufferOffset);
        RtlCopyMemory(Data, &m_pAudioBuffer[m_ulAudioBufferOffset], cNextBytes);
        m_ulAudioBufferOffset = (m_ulAudioBufferOffset + cNextBytes) % m_ulAudioBufferSize;
        cBytes -= cNextBytes;
    
    } while (cBytes > 0 );
}


VOID 
CCapFilter::RegisterSample(
    IN SampleType Type, 
    IN LONGLONG TimeStamp,
    IN ULONGLONG Size
    )

/*++

Routine Description:

    Registers the output moment and size of a frame

Arguments:

    IN SampleType Type - frame type (audio or video)

    IN ULONGLONG TimeStamp - frame's timestamp
    
    IN ULONGLONG  Size - frame's size
    
Return Value:

--*/

{
    _DbgPrintF(DEBUGLVL_BLAB,("RegisterSample"));
    
    if (m_iSample < m_cSamples) {
        m_rgSamples[m_iSample].m_type = Type;
        m_rgSamples[m_iSample].m_ullSize = Size;
        m_rgSamples[m_iSample].m_llTimeStamp = TimeStamp;
    }
}


VOID 
CCapFilter::DumpSamples(
    )

/*++

Routine Description:

    Dump information about sent frames to debugger

Arguments:
    
Return Value:

--*/

{
    _DbgPrintF(DEBUGLVL_BLAB,("DumpSamples"));
    
    for (ULONG iSmp = 0; iSmp < m_iSample; iSmp++) {
        
        if ( m_rgSamples[iSmp].m_type == Audio ) {
            
            DbgPrint("ASmp[%lu] = %I64d, %I64u\n",
                     m_rgSamples[iSmp].m_llTimeStamp,
                     m_rgSamples[iSmp].m_ullSize);
        }
        else {
            
            DbgPrint("VSmp[%lu] = %I64d, %I64u\n",
                     m_rgSamples[iSmp].m_llTimeStamp,
                     m_rgSamples[iSmp].m_ullSize);
        }
    }

    m_iSample = 0;
}

#ifdef ALLOC_PRAGMA
#pragma code_seg("PAGE")
#endif // ALLOC_PRAGMA


NTSTATUS 
CCapFilter::
CopyFile(
    IN PWCHAR FileName
    )
/*++

Routine Description:
    Copies the content of a file to an internal buffer

Arguments:
    IN PWCHAR FileName -
        Name of the file to be copied

Return:
    Status of copy operation.

--*/
{
    _DbgPrintF(DEBUGLVL_BLAB,("CopyFile"));
    
    NTSTATUS status;
    IO_STATUS_BLOCK ioStatusBlock;
    UNICODE_STRING fileNameString;
    OBJECT_ATTRIBUTES objectAttributes;
    ACCESS_MASK desiredHandleAccess;
    ACCESS_MASK desiredObjectAccess;
    ULONG ulShareAccess;
    ULONG ulDisposition;
    FILE_STANDARD_INFORMATION StandardInformation;
    HANDLE hFile = NULL;
    FILE_OBJECT *pFileObject = NULL;

    //
    // Attempt to open the file based on the access rights of the caller.
    // Note that the SYNCHRONIZE flag must be set on the Create even
    // though this is contained in the translated GENERIC_READ attributes.
    // This is because the bit is tested before the Generic attributes
    // are translated. This filter only does synchronous I/O on stream
    // Read requests.
    //

    RtlInitUnicodeString(&fileNameString, FileName);

    InitializeObjectAttributes(
        &objectAttributes,
        &fileNameString,
        OBJ_CASE_INSENSITIVE,
        NULL,
        NULL);
    //
    // Set the access desired based on the type of filter which was
    // actually created.
    //

    desiredHandleAccess = GENERIC_READ | SYNCHRONIZE;
    desiredObjectAccess = FILE_READ_DATA;
    ulShareAccess = FILE_SHARE_READ;
    ulDisposition = FILE_OPEN;
    
    status = IoCreateFile(&hFile,
                          desiredHandleAccess,
                          &objectAttributes,
                          &ioStatusBlock,
                          NULL,
                          0,
                          ulShareAccess,
                          ulDisposition,
                          FILE_SYNCHRONOUS_IO_NONALERT,
                          NULL,
                          0,
                          CreateFileTypeNone,
                          NULL,
                          IO_FORCE_ACCESS_CHECK | IO_NO_PARAMETER_CHECKING);
    
    if ( !NT_SUCCESS(status) ) {
        _DbgPrintF(DEBUGLVL_BLAB, ("Failed to open file, error 0x%lx", status));
        goto error;
    }
    
    status = ObReferenceObjectByHandle(hFile,
                                       desiredObjectAccess,
                                       *IoFileObjectType,
                                       ExGetPreviousMode(),
                                       reinterpret_cast<void **>(&pFileObject),
                                       NULL);
    if ( !NT_SUCCESS(status) ) {
        goto error;
    }
    

    if (m_pAudioBuffer != NULL) {
        
        ExFreePool(m_pAudioBuffer);
        m_pAudioBuffer = NULL;
    }
    m_ulAudioBufferOffset = 0;
    m_ulAudioBufferSize = 0;

    //
    // retrieve file's size
    //
    status = KsQueryInformationFile(pFileObject,
                                    &StandardInformation,
                                    sizeof(StandardInformation),
                                    FileStandardInformation);
    if ( !NT_SUCCESS(status) || StandardInformation.EndOfFile.QuadPart > MAXLONG ) {
        goto error;
    }
    else {
        m_ulAudioBufferSize = (LONG)(StandardInformation.EndOfFile.QuadPart);
        _DbgPrintF(DEBUGLVL_TERSE, ("File size is %lu", 
                                    m_ulAudioBufferSize));
    }

    //
    // allocate a buffer to hold file's content
    //
    m_pAudioBuffer = (BYTE*)ExAllocatePoolWithTag(NonPagedPool,
                                                  m_ulAudioBufferSize,
                                                  'dfZB');
    if ( m_pAudioBuffer == NULL ) {
        _DbgPrintF(DEBUGLVL_TERSE, ("Failed to allocate file data buffer"));
        status = STATUS_INSUFFICIENT_RESOURCES;
        goto error;
    }

    //
    // read file's content to buffer
    //
    status = KsReadFile(pFileObject,
                        NULL,
                        NULL,
                        &ioStatusBlock,
                        m_pAudioBuffer,
                        m_ulAudioBufferSize,
                        0,
                        KernelMode);
    
error:
    if ( !NT_SUCCESS(status) && m_pAudioBuffer != NULL ) {
        ExFreePool(m_pAudioBuffer);
        m_pAudioBuffer = NULL;
    }

    if ( pFileObject != NULL ) {
        ObDereferenceObject(pFileObject);
    }

    if ( hFile != NULL ) {
        ZwClose(hFile);
    }

    return status;
}


NTSTATUS
CCapFilter::
FilterCreate(
    IN OUT PKSFILTER Filter,
    IN PIRP Irp
    )
/*++

Routine Description:
    Handle specific processing on filter create

Arguments:
    IN OUT PKSFILTER Filter -
        Filter instance data
        
    IN PIRP Irp - 
        Create request

Return:
    STATUS_SUCCESS if creation was handled successfully
    an error code otherwise

--*/
{
    _DbgPrintF(DEBUGLVL_BLAB,("FilterCreate"));

    PAGED_CODE();

    ASSERT(Filter);
    ASSERT(Irp);
    
    NTSTATUS status = STATUS_SUCCESS;
    CCapFilter *filter;

    do { //just to have something to break from
        
        //
        // alocate and initialize filter instance
        //
        filter = new(NonPagedPool,'pChS') CCapFilter;
        if ( filter == NULL ) {
            return STATUS_INSUFFICIENT_RESOURCES;
        }

        filter->m_pKsFilter = Filter;
        Filter->Context = PVOID(filter);
        filter->m_pFilterObject = IoGetCurrentIrpStackLocation(Irp)->FileObject;

        //
        // copy audio data
        //
        // uncomment when audio is required.
        //
        //status = filter->CopyFile(L"\\DosDevices\\C:\\avssamp.dat");
        //if ( ! NT_SUCCESS(status) ) {
        //	DbgPrint( "avssamp: Must have file c:\\avssamp.dat\n" );
        //    break;
        //}

        //
        // allocate n array for debug timestamps
        //
        filter->m_rgTimestamps = 
            reinterpret_cast<TS_SIGN *>(
                ExAllocatePoolWithTag(NonPagedPool, 
                                      sizeof(TS_SIGN)*MAX_TIMESTAMPS,
                                      'stCK'));
        if ( filter->m_rgTimestamps == NULL ) {
            status = STATUS_INSUFFICIENT_RESOURCES;
        }

    } while ( FALSE );

    if (!NT_SUCCESS(status)) {
        delete filter;
    }
                    
    return status;
}


NTSTATUS
CCapFilter::
FilterClose(
    IN OUT PKSFILTER Filter,
    IN PIRP Irp
    )
/*++

Routine Description:
    Handle specific processing on filter close

Arguments:
    IN OUT PKSFILTER Filter -
        Filter instance data
        
    IN PIRP Irp - 
        Create request

Return:
    STATUS_SUCCESS

--*/
{
    _DbgPrintF(DEBUGLVL_BLAB,("FilterClose"));

    PAGED_CODE();

    ASSERT(Filter);
    ASSERT(Irp);
    
    CCapFilter *filter = reinterpret_cast<CCapFilter *>(Filter->Context);
    ASSERT(filter);
    
    delete filter;
                    
    return STATUS_SUCCESS;
}


NTSTATUS
CCapFilter::
CaptureVideoInfoHeader(
    IN PKS_VIDEOINFOHEADER VideoInfoHeader
    )
/*++

Routine Description:
    Retrieve a copy of the Video Header Info

Arguments:
    IN PKS_VIDEOINFOHEADER VideoInfoHeader -
        Video Info Header copy

Return:
    STATUS_SUCCESS

--*/
{
    _DbgPrintF(DEBUGLVL_BLAB,("CaptureVideoInfoHeader"));
    
    //
    // There could be one of these already if a pin was created and closed.
    //
    if (m_VideoInfoHeader) {
        ExFreePool(m_VideoInfoHeader);
    }

    m_VideoInfoHeader =
        (PKS_VIDEOINFOHEADER) 
            ExAllocatePoolWithTag( 
                NonPagedPool, 
                KS_SIZE_VIDEOHEADER( VideoInfoHeader ),
                'fChS' );
    
    NTSTATUS Status;

    if (m_VideoInfoHeader) {
        RtlCopyMemory( 
            m_VideoInfoHeader, 
            VideoInfoHeader, 
            KS_SIZE_VIDEOHEADER( VideoInfoHeader ) );
        Status = STATUS_SUCCESS;            
    } else {
        Status = STATUS_INSUFFICIENT_RESOURCES;
    }

    return Status;
}

static const WCHAR ClockTypeName[] = KSSTRING_Clock;


NTSTATUS
VideoPinCreate(
    IN OUT PKSPIN Pin,
    IN PIRP Irp
    )
/*++

Routine Description:
    Handle specific processing on Video Pin creation

Arguments:
    IN OUT PKSPIN Pin -
        Pin instance data
        
    IN PIRP Irp -
        Creation request

Return:
    STATUS_SUCCESS

--*/
{
    _DbgPrintF(DEBUGLVL_BLAB,("VideoPinCreate"));
    
    NTSTATUS status = STATUS_SUCCESS;
    
    _DbgPrintF(DEBUGLVL_VERBOSE,("PinCreate filter %d as %s", Pin->Id, (Pin->Communication == KSPIN_COMMUNICATION_SOURCE) ? "SOURCE" : "SINK"));

    PAGED_CODE();

    ASSERT(Pin);
    ASSERT(Irp);

    //
    // Indicate the extended header size.
    //
    Pin->StreamHeaderSize = sizeof(KSSTREAM_HEADER) + sizeof(KS_FRAME_INFO);
    
    //
    // Use the same context as the filter (the shell copies this for us).
    //
    CCapFilter *filter = reinterpret_cast<CCapFilter *>(Pin->Context);

    status = filter->CaptureVideoInfoHeader(&(PKS_DATAFORMAT_VIDEOINFOHEADER(Pin->ConnectionFormat )->VideoInfoHeader));

    if (NT_SUCCESS(status)) 
    {
        status = KsEdit(Pin,&Pin->Descriptor,'aChS');
        if (NT_SUCCESS(status)) 
        {
            status = KsEdit(Pin,&Pin->Descriptor->AllocatorFraming,'aChS');
        }
        if (NT_SUCCESS(status)) 
        {
            PKS_VIDEOINFOHEADER VideoInfoHeader = &(PKS_DATAFORMAT_VIDEOINFOHEADER(Pin->ConnectionFormat)->VideoInfoHeader);

            PKSALLOCATOR_FRAMING_EX framing = const_cast<PKSALLOCATOR_FRAMING_EX>(Pin->Descriptor->AllocatorFraming);
            framing->FramingItem[0].Frames = 2;
            framing->FramingItem[0].PhysicalRange.MinFrameSize = VideoInfoHeader->bmiHeader.biSizeImage;
            framing->FramingItem[0].PhysicalRange.MaxFrameSize = VideoInfoHeader->bmiHeader.biSizeImage;
            framing->FramingItem[0].PhysicalRange.Stepping = 0;
            framing->FramingItem[0].FramingRange.Range.MinFrameSize =  VideoInfoHeader->bmiHeader.biSizeImage;
            framing->FramingItem[0].FramingRange.Range.MaxFrameSize = VideoInfoHeader->bmiHeader.biSizeImage;
            framing->FramingItem[0].FramingRange.Range.Stepping = 0;
        }
    }        
                    
    return status;
}


NTSTATUS
AudioPinCreate(
    IN OUT PKSPIN Pin,
    IN PIRP Irp
    )
/*++

Routine Description:
    Handle specific processing on Audio Pin creation

Arguments:
    IN OUT PKSPIN Pin -
        Pin instance data
        
    IN PIRP Irp -
        Creation request

Return:
    STATUS_SUCCESS

--*/
{
    _DbgPrintF(DEBUGLVL_BLAB,("AudioPinCreate filter %d as %s",Pin->Id,(Pin->Communication == KSPIN_COMMUNICATION_SOURCE) ? "SOURCE" : "SINK"));

    PAGED_CODE();

    ASSERT(Pin);
    ASSERT(Irp);
    
    return STATUS_SUCCESS;
}



NTSTATUS
CCapFilter::CancelTimer()
{
    //
    // let Timer's Dpc we are stopped and cancel the timer
    // (REVIEW - we should be sure no Dpc is pending when 
    // this function exits)
    //
    InterlockedExchange(&m_Active,FALSE);
    if (InterlockedExchange(&m_TimerScheduled,FALSE)) 
    {
        _DbgPrintF(DEBUGLVL_TERSE,("cancelling timer"));
        KeCancelTimer(&m_TimerObject);
        _DbgPrintF(DEBUGLVL_TERSE,("timer cancelled"));
        return(STATUS_SUCCESS);
    }
    
    return(!STATUS_SUCCESS);
}


NTSTATUS
CCapFilter::Run(
    IN PKSPIN Pin,
    IN KSSTATE FromState 
    )
/*++

Routine Description:
    Handle pin statetransition to Run state

Arguments:
    IN PKSPIN Pin -
        Pin instance data
        
    IN KSSTATE FromState -
        Current pin state

Return:
    STATUS_SUCCESS

--*/
{
    _DbgPrintF(DEBUGLVL_BLAB,("filter to KSSTATE_RUN Pin->Id:%d From:%d", Pin->Id, FromState));

#if 0
    //
    // initialize timer to drive transfer
    //
    InterlockedExchange(&m_Active, TRUE);
    //
    // comput transfer time points and start timer for first transfer
    //
    LARGE_INTEGER NextTime;
    KeQuerySystemTime(&NextTime);
    //
    // Fix the System time against the Physical time on the clock.
    //
    ////KsPinSetPinClockState(Pin,KSSTATE_RUN,NextTime.QuadPart);
    //
    // Determine how long the filter was not running in order to
    // update the start time, and therefore what the next frame
    // timestamp should be. The start and stop times are initially
    // zeroed, which means the start time initially is set to the
    // current system time.
    //
    m_llStartTime = NextTime.QuadPart - (m_iTick * m_VideoInfoHeader->AvgTimePerFrame);
    //
    // Set the offset to production of the first frame. This is produced
    // at the end of the period for which the frame is stamped, though it
    // could be produced earlier of course, even at the beginning of the
    // period.
    //
    NextTime.QuadPart = m_llStartTime + m_VideoInfoHeader->AvgTimePerFrame;
    KeSetTimer(&m_TimerObject,NextTime,&m_TimerDpc);
#endif

    return STATUS_SUCCESS;    
}    


NTSTATUS
CCapFilter::Pause(
    IN PKSPIN Pin,
    IN KSSTATE FromState                 
    )
/*++

Routine Description:
    Handle pin statetransition to Run state

Arguments:
    IN PKSPIN Pin -
        Pin instance data
        
    IN KSSTATE FromState -
        Current pin state

Return:
    STATUS_SUCCESS

--*/
{
    ASSERT(Pin);
    
    _DbgPrintF(DEBUGLVL_BLAB,("filter to KSSTATE_PAUSE Pin->Id:%d From:%d", Pin->Id, FromState));
    
    if (FromState == KSSTATE_RUN) 
    {
        CancelTimer();
        //
        // Unfix the System time from the Physical time on the clock.
        // Ignores partial frame times.
        //
//        KsPinSetPinClockState(
//            Pin,
//            KSSTATE_PAUSE,
//            m_iTick * m_VideoInfoHeader->AvgTimePerFrame);
    }
    else
    {
        //
        // initialize timer to drive transfer
        //
        InterlockedExchange(&m_Active, TRUE);
        //
        // comput transfer time points and start timer for first transfer
        //
        LARGE_INTEGER NextTime;
        KeQuerySystemTime(&NextTime);
        //
        // Fix the System time against the Physical time on the clock.
        //
        ////KsPinSetPinClockState(Pin,KSSTATE_RUN,NextTime.QuadPart);
        //
        // Determine how long the filter was not running in order to
        // update the start time, and therefore what the next frame
        // timestamp should be. The start and stop times are initially
        // zeroed, which means the start time initially is set to the
        // current system time.
        //
        m_llStartTime = NextTime.QuadPart - (m_iTick * m_VideoInfoHeader->AvgTimePerFrame);
        //
        // Set the offset to production of the first frame. This is produced
        // at the end of the period for which the frame is stamped, though it
        // could be produced earlier of course, even at the beginning of the
        // period.
        //
        NextTime.QuadPart = m_llStartTime + m_VideoInfoHeader->AvgTimePerFrame;
        KeSetTimer(&m_TimerObject,NextTime,&m_TimerDpc);
        _DbgPrintF(DEBUGLVL_BLAB,("CCapFilter::Pause KeSetTimer(%x, %d, %x)", &m_TimerObject, NextTime, &m_TimerDpc));
    }
    
    return STATUS_SUCCESS;
}


NTSTATUS
CCapFilter::Stop(
    IN PKSPIN Pin,
    IN KSSTATE FromState 
    )
/*++

Routine Description:
    Handle pin state transition to Stop

Arguments:
    IN PKSPIN Pin -
        Pin instance data
        
    IN KSSTATE FromState -
        Current pin state

Return:
    STATUS_SUCCESS

--*/
{
    _DbgPrintF(DEBUGLVL_BLAB,("filter to KSSTATE_STOP Pin->Id:%d From:%d", Pin->Id, FromState));

    CancelTimer();
    
    //
    // reinitialize transfer counters
    //
    m_iTick = 0;
    m_ullNextAudioPos = 0;
    m_ulAudioBufferOffset = 0;
    m_FrameInfo.PictureNumber = 0;
    m_FrameInfo.DropCount = 0;
    m_ulAudioDroppedFrames = 0;
    m_ulVideoDroppedFrames = 0;
    //
    // dump debug timestamps
    //
    for (ULONG iTs = 0; iTs < m_iTimestamp; iTs++) {
        DbgPrint(
            "TS[%lu] = %I64d, %I64d, %I64d\n", 
            iTs, 
            m_rgTimestamps[iTs].Abs,
            m_rgTimestamps[iTs].Rel,
            m_rgTimestamps[iTs].Int);
    }
    m_iTimestamp = 0;
    return STATUS_SUCCESS;
}


NTSTATUS
PinSetDeviceState(
    IN PKSPIN Pin,
    IN KSSTATE ToState,
    IN KSSTATE FromState
    )
/*++

Routine Description:
    Handle pin state transitions

Arguments:
    IN PKSPIN Pin -
        Pin instance data
        
    IN KSSTATE ToState -
        State to be set on pin        
        
    IN KSSTATE FromState -
        Current pin state

Return:
    STATUS_SUCCESS

--*/
{
    NTSTATUS  Status;
    
    _DbgPrintF(DEBUGLVL_BLAB,("PinSetDeviceState Pin->Id:%d From:%d To:%d",Pin->Id, FromState, ToState));

    PAGED_CODE();

    ASSERT(Pin);
    
    CCapFilter *filter = reinterpret_cast<CCapFilter *>(Pin->Context);
    
    Status = STATUS_SUCCESS;
    
    switch (ToState) 
    {
        case KSSTATE_STOP:
            Status = filter->Stop(Pin, FromState);
            break;
            
        case KSSTATE_ACQUIRE:
            //
            // This is a KS only state, that has no correspondence in DirectShow
            // 
            _DbgPrintF(DEBUGLVL_BLAB,("filter to KSSTATE_STOP Pin->Id:%d From:%d", Pin->Id, FromState));
            break;
            
        case KSSTATE_PAUSE:
            Status = filter->Pause(Pin, FromState);
            break;
            
        case KSSTATE_RUN:
            Status = filter->Run(Pin, FromState);
            break;
    }
    
    return Status;
}


NTSTATUS
VideoIntersectHandler(
    IN PVOID Filter,
    IN PIRP Irp,
    IN PKSP_PIN PinInstance,
    IN PKSDATARANGE CallerDataRange,
    IN PKSDATARANGE DescriptorDataRange,
    IN ULONG BufferSize,
    OUT PVOID Data OPTIONAL,
    OUT PULONG DataSize
    )

/*++

Routine Description:

    This routine handles video pin intersection queries by determining the
    intersection between two data ranges.

Arguments:

    Filter -
        Contains a void pointer to the  filter structure.

    Irp -
        Contains a pointer to the data intersection property request.

    PinInstance -
        Contains a pointer to a structure indicating the pin in question.

    CallerDataRange -
        Contains a pointer to one of the data ranges supplied by the client
        in the data intersection request.  The format type, subtype and
        specifier are compatible with the DescriptorDataRange.

    DescriptorDataRange -
        Contains a pointer to one of the data ranges from the pin descriptor
        for the pin in question.  The format type, subtype and specifier are
        compatible with the CallerDataRange.

    BufferSize -
        Contains the size in bytes of the buffer pointed to by the Data
        argument.  For size queries, this value will be zero.

    Data -
        Optionally contains a pointer to the buffer to contain the data format
        structure representing the best format in the intersection of the
        two data ranges.  For size queries, this pointer will be NULL.

    DataSize -
        Contains a pointer to the location at which to deposit the size of the
        data format.  This information is supplied by the function when the
        format is actually delivered and in response to size queries.

Return Value:

    STATUS_SUCCESS if there is an intersection and it fits in the supplied
    buffer, STATUS_BUFFER_OVERFLOW for successful size queries, STATUS_NO_MATCH
    if the intersection is empty, or STATUS_BUFFER_TOO_SMALL if the supplied
    buffer is too small.

--*/

{
    const GUID VideoInfoSpecifier = 
        {STATICGUIDOF(KSDATAFORMAT_SPECIFIER_VIDEOINFO)};
    
    PAGED_CODE();

    ASSERT(Filter);
    ASSERT(Irp);
    ASSERT(PinInstance);
    ASSERT(CallerDataRange);
    ASSERT(DescriptorDataRange);
    ASSERT(DataSize);
    
    PKSFILTER  FilterInstance = reinterpret_cast<PKSFILTER>( Filter );
    ULONG           DataFormatSize;
    
    _DbgPrintF(DEBUGLVL_BLAB,("VideoIntersectHandler"));
    
    //
    // Walk the formats supported by the stream searching for a match
    // of the three GUIDs which together define a DATARANGE
    //

    // Specifier FORMAT_VideoInfo for VIDEOINFOHEADER

    if (IsEqualGUID(CallerDataRange->Specifier, VideoInfoSpecifier )) {
            
        PKS_DATARANGE_VIDEO callerDataRange = PKS_DATARANGE_VIDEO(CallerDataRange);
        PKS_DATARANGE_VIDEO descriptorDataRange = PKS_DATARANGE_VIDEO(DescriptorDataRange);
        PKS_DATAFORMAT_VIDEOINFOHEADER FormatVideoInfoHeader;

        //
        // Check that the other fields match
        //
        if ((callerDataRange->bFixedSizeSamples != 
                descriptorDataRange->bFixedSizeSamples) ||
            (callerDataRange->bTemporalCompression != 
                descriptorDataRange->bTemporalCompression) ||
            (callerDataRange->StreamDescriptionFlags != 
                descriptorDataRange->StreamDescriptionFlags) ||
            (callerDataRange->MemoryAllocationFlags != 
                descriptorDataRange->MemoryAllocationFlags) ||
            (RtlCompareMemory (&callerDataRange->ConfigCaps,
                    &callerDataRange->ConfigCaps,
                    sizeof (KS_VIDEO_STREAM_CONFIG_CAPS)) != 
                    sizeof (KS_VIDEO_STREAM_CONFIG_CAPS))) 
        {
            _DbgPrintF(DEBUGLVL_VERBOSE,
                ("PinIntersectHandler: STATUS_NO_MATCH (KSDATAFORMAT_SPECIFIER_VIDEOINFO)"));
            return STATUS_NO_MATCH;
        }
        
        DataFormatSize = 
            sizeof( KSDATAFORMAT ) + 
            KS_SIZE_VIDEOHEADER( &callerDataRange->VideoInfoHeader );
            
        if (BufferSize == 0) 
        {
            //
            // Size only query...
            //
            *DataSize = DataFormatSize;
            _DbgPrintF(DEBUGLVL_VERBOSE,("PinIntersectHandler: STATUS_BUFFER_OVERFLOW DataFormatSize:%d", DataFormatSize));
            return STATUS_BUFFER_OVERFLOW;
            
        }
        
        //
        // Verify that the provided structure is large enough to
        // accept the result.
        //
        
        if (BufferSize < DataFormatSize) 
        {
            return STATUS_BUFFER_TOO_SMALL;
        }

        // Copy over the KSDATAFORMAT, followed by the actual VideoInfoHeader
            
        *DataSize = DataFormatSize;
            
        FormatVideoInfoHeader = PKS_DATAFORMAT_VIDEOINFOHEADER( Data );

        // Copy over the KSDATAFORMAT 
        
        RtlCopyMemory(&FormatVideoInfoHeader->DataFormat, DescriptorDataRange, sizeof( KSDATARANGE ));
        FormatVideoInfoHeader->DataFormat.FormatSize = DataFormatSize;

        // Copy over the callers requested VIDEOINFOHEADER

        RtlCopyMemory(&FormatVideoInfoHeader->VideoInfoHeader, &callerDataRange->VideoInfoHeader,
            KS_SIZE_VIDEOHEADER( &callerDataRange->VideoInfoHeader ) );

        // Calculate biSizeImage for this request, and put the result in both
        // the biSizeImage field of the bmiHeader AND in the SampleSize field
        // of the DataFormat.
        //
        // Note that for compressed sizes, this calculation will probably not
        // be just width * height * bitdepth

        FormatVideoInfoHeader->VideoInfoHeader.bmiHeader.biSizeImage =
            FormatVideoInfoHeader->DataFormat.SampleSize = 
            KS_DIBSIZE( FormatVideoInfoHeader->VideoInfoHeader.bmiHeader );

        //
        // REVIEW - Perform other validation such as cropping and scaling checks
        // 
        
        _DbgPrintF(DEBUGLVL_VERBOSE, ("PinIntersectHandler: STATUS_SUCCESS (KSDATAFORMAT_SPECIFIER_VIDEOINFO)"));
            
        return STATUS_SUCCESS;
        
    } // End of VIDEOINFOHEADER specifier
    
#if 0    
    // Specifier FORMAT_AnalogVideo for KS_ANALOGVIDEOINFO
    else if (IsEqualGUID (&DataRange->Specifier, 
            &KSDATAFORMAT_SPECIFIER_ANALOGVIDEO)) {
  
        //
        // For analog video, the DataRange and DataFormat
        // are identical, so just copy the whole structure
        //

        PKS_DATARANGE_ANALOGVIDEO DataRangeVideo = 
                (PKS_DATARANGE_ANALOGVIDEO) *pAvailableFormats;

        // MATCH FOUND!
        MatchFound = TRUE;            
        FormatSize = sizeof (KS_DATARANGE_ANALOGVIDEO);

        if (OnlyWantsSize) {
            break;
        }
        
        // Caller wants the full data format
        if (IntersectInfo->SizeOfDataFormatBuffer < FormatSize) {
            pSrb->Status = STATUS_BUFFER_TOO_SMALL;
            return FALSE;
        }

        RtlCopyMemory(
            IntersectInfo->DataFormatBuffer,
            DataRangeVideo,
            sizeof (KS_DATARANGE_ANALOGVIDEO));

        ((PKSDATAFORMAT)IntersectInfo->DataFormatBuffer)->FormatSize = FormatSize;

    } // End of KS_ANALOGVIDEOINFO specifier
#endif    

    _DbgPrintF(DEBUGLVL_VERBOSE,("PinIntersectHandler: STATUS_NO_MATCH"));
    return STATUS_NO_MATCH;
}


NTSTATUS
AudioIntersectHandler(
    IN PVOID Filter,
    IN PIRP Irp,
    IN PKSP_PIN PinInstance,
    IN PKSDATARANGE CallerDataRange,
    IN PKSDATARANGE DescriptorDataRange,
    IN ULONG BufferSize,
    OUT PVOID Data OPTIONAL,
    OUT PULONG DataSize
    )

/*++

Routine Description:

    This routine handles audip pin intersection queries by determining the
    intersection between two data ranges.

Arguments:

    Filter -
        Contains a void pointer to the  filter structure.

    Irp -
        Contains a pointer to the data intersection property request.

    PinInstance -
        Contains a pointer to a structure indicating the pin in question.

    CallerDataRange -
        Contains a pointer to one of the data ranges supplied by the client
        in the data intersection request.  The format type, subtype and
        specifier are compatible with the DescriptorDataRange.

    DescriptorDataRange -
        Contains a pointer to one of the data ranges from the pin descriptor
        for the pin in question.  The format type, subtype and specifier are
        compatible with the CallerDataRange.

    BufferSize -
        Contains the size in bytes of the buffer pointed to by the Data
        argument.  For size queries, this value will be zero.

    Data -
        Optionally contains a pointer to the buffer to contain the data format
        structure representing the best format in the intersection of the
        two data ranges.  For size queries, this pointer will be NULL.

    DataSize -
        Contains a pointer to the location at which to deposit the size of the
        data format.  This information is supplied by the function when the
        format is actually delivered and in response to size queries.

Return Value:

    STATUS_SUCCESS if there is an intersection and it fits in the supplied
    buffer, STATUS_BUFFER_OVERFLOW for successful size queries, STATUS_NO_MATCH
    if the intersection is empty, or STATUS_BUFFER_TOO_SMALL if the supplied
    buffer is too small.

--*/

{
    PKSDATARANGE_AUDIO descriptorDataRange;
    PKSDATARANGE_AUDIO callerDataRange;
    PKSDATAFORMAT_WAVEFORMATEX dataFormat;
    
    _DbgPrintF(DEBUGLVL_BLAB,("AudioIntersectHandler"));

    PAGED_CODE();

    ASSERT(Filter);
    ASSERT(Irp);
    ASSERT(PinInstance);
    ASSERT(CallerDataRange);
    ASSERT(DescriptorDataRange);
    ASSERT(DataSize);

    //
    // Descriptor data range must be WAVEFORMATEX.
    //
    ASSERT(IsEqualGUID(DescriptorDataRange->Specifier, KSDATAFORMAT_SPECIFIER_WAVEFORMATEX));
    descriptorDataRange = (PKSDATARANGE_AUDIO)DescriptorDataRange;

    //
    // Caller data range may be wildcard or WAVEFORMATEX.
    //
    if (IsEqualGUID(CallerDataRange->Specifier, KSDATAFORMAT_SPECIFIER_WILDCARD)) {
        //
        // Wildcard.  Do not try to look at the specifier.
        //
        callerDataRange = NULL;
    } else {
        //
        // WAVEFORMATEX.  Validate the specifier ranges.
        //
        ASSERT(IsEqualGUID(CallerDataRange->Specifier, KSDATAFORMAT_SPECIFIER_WAVEFORMATEX));

        callerDataRange = (PKSDATARANGE_AUDIO)CallerDataRange;

        if ((CallerDataRange->FormatSize != sizeof(*callerDataRange)) ||
            (callerDataRange->MaximumSampleFrequency <
             descriptorDataRange->MinimumSampleFrequency) ||
            (descriptorDataRange->MaximumSampleFrequency <
             callerDataRange->MinimumSampleFrequency) ||
            (callerDataRange->MaximumBitsPerSample <
             descriptorDataRange->MinimumBitsPerSample) ||
            (descriptorDataRange->MaximumBitsPerSample <
             callerDataRange->MinimumBitsPerSample)) {

            _DbgPrintF(DEBUGLVL_VERBOSE,("[PinIntersectHandler]  STATUS_NO_MATCH"));
            return STATUS_NO_MATCH;
        }
    }

    dataFormat = (PKSDATAFORMAT_WAVEFORMATEX)Data;

    if (BufferSize == 0) {
        //
        // Size query - return the size.
        //
        *DataSize = sizeof(*dataFormat);
        _DbgPrintF(DEBUGLVL_VERBOSE,("[PinIntersectHandler]  STATUS_BUFFER_OVERFLOW"));
        return STATUS_BUFFER_OVERFLOW;
    }

    ASSERT(dataFormat);

    if (BufferSize < sizeof(*dataFormat)) {
        //
        // Buffer is too small.
        //
        _DbgPrintF(DEBUGLVL_VERBOSE,("[PinIntersectHandler]  STATUS_BUFFER_TOO_SMALL"));
        return STATUS_BUFFER_TOO_SMALL;
    }

    //
    // Gotta build the format.
    //
    *DataSize = sizeof(*dataFormat);

    //
    // All the guids are in the descriptor's data range.
    //
    RtlCopyMemory(
        &dataFormat->DataFormat,
        DescriptorDataRange,
        sizeof(dataFormat->DataFormat));

    dataFormat->WaveFormatEx.wFormatTag = WAVE_FORMAT_PCM;

    if (callerDataRange) {
        dataFormat->WaveFormatEx.nChannels = (USHORT)
            min(callerDataRange->MaximumChannels,descriptorDataRange->MaximumChannels);
        dataFormat->WaveFormatEx.nSamplesPerSec =
            min(callerDataRange->MaximumSampleFrequency,descriptorDataRange->MaximumSampleFrequency);
        dataFormat->WaveFormatEx.wBitsPerSample = (USHORT)
            min(callerDataRange->MaximumBitsPerSample,descriptorDataRange->MaximumBitsPerSample);
    } else {
        dataFormat->WaveFormatEx.nChannels = (USHORT)
            descriptorDataRange->MaximumChannels;
        dataFormat->WaveFormatEx.nSamplesPerSec =
            descriptorDataRange->MaximumSampleFrequency;
        dataFormat->WaveFormatEx.wBitsPerSample = (USHORT)
            descriptorDataRange->MaximumBitsPerSample;
    }

    dataFormat->WaveFormatEx.nBlockAlign =
        (dataFormat->WaveFormatEx.wBitsPerSample * dataFormat->WaveFormatEx.nChannels) / 8;
    dataFormat->WaveFormatEx.nAvgBytesPerSec = 
        dataFormat->WaveFormatEx.nBlockAlign * dataFormat->WaveFormatEx.nSamplesPerSec;
    dataFormat->WaveFormatEx.cbSize = 0;
        
    dataFormat->DataFormat.FormatSize = sizeof(*dataFormat);
    dataFormat->DataFormat.SampleSize = dataFormat->WaveFormatEx.nBlockAlign;

    return STATUS_SUCCESS;
}

//
// Topology
//

const
KSPIN_INTERFACE 
PinInterfaces[] =
{
   {
      STATICGUIDOF(KSINTERFACESETID_Standard),
      KSINTERFACE_STANDARD_STREAMING,
      0
   }
};

const
KSPIN_MEDIUM 
PinMediums[] =
{
   {
      STATICGUIDOF(KSMEDIUMSETID_Standard),
      KSMEDIUM_TYPE_ANYINSTANCE,
      0
   }
};


//
// Audio Data Formats
//

const KSDATARANGE_AUDIO PinWaveIoRange = {
    {
        sizeof(KSDATARANGE_AUDIO),
        0,
        0,
        0,
        STATICGUIDOF(KSDATAFORMAT_TYPE_AUDIO),
        STATICGUIDOF(KSDATAFORMAT_SUBTYPE_PCM),
        STATICGUIDOF(KSDATAFORMAT_SPECIFIER_WAVEFORMATEX)
    },
    1,      // maximum range
    8,      // min bits per sample
    8,      // max bits per sample
    8000,   // min frequency
    8000    // max frequency
};


//
// Video Data Formats
//

#define D_X 320
#define D_Y 240

const KS_DATARANGE_VIDEO FormatRGB24Bpp_Capture = 
{
    // KSDATARANGE
    {   
        sizeof (KS_DATARANGE_VIDEO),                // FormatSize
        0,                                          // Flags
        D_X * D_Y * 3,                              // SampleSize
        0,                                          // Reserved

        STATICGUIDOF( KSDATAFORMAT_TYPE_VIDEO ),    // aka. MEDIATYPE_Video
        0xe436eb7d, 0x524f, 0x11ce, 0x9f, 0x53, 0x00, 0x20, 0xaf, 0x0b, 0xa7, 0x70, //MEDIASUBTYPE_RGB24,
        STATICGUIDOF( KSDATAFORMAT_SPECIFIER_VIDEOINFO ) // aka. FORMAT_VideoInfo
    },

    TRUE,               // BOOL,  bFixedSizeSamples (all samples same size?)
    TRUE,               // BOOL,  bTemporalCompression (all I frames?)
    0,                  // Reserved (was StreamDescriptionFlags)
    0,                  // Reserved (was MemoryAllocationFlags   (KS_VIDEO_ALLOC_*))

    // _KS_VIDEO_STREAM_CONFIG_CAPS  
    {
        STATICGUIDOF( KSDATAFORMAT_SPECIFIER_VIDEOINFO ), // GUID
        KS_AnalogVideo_NTSC_M |
        KS_AnalogVideo_PAL_B,                    // AnalogVideoStandard
        720,480,        // InputSize, (the inherent size of the incoming signal
                        //             with every digitized pixel unique)
        160,120,        // MinCroppingSize, smallest rcSrc cropping rect allowed
        720,480,        // MaxCroppingSize, largest  rcSrc cropping rect allowed
        8,              // CropGranularityX, granularity of cropping size
        1,              // CropGranularityY
        8,              // CropAlignX, alignment of cropping rect 
        1,              // CropAlignY;
        160, 120,       // MinOutputSize, smallest bitmap stream can produce
        720, 480,       // MaxOutputSize, largest  bitmap stream can produce
        8,              // OutputGranularityX, granularity of output bitmap size
        1,              // OutputGranularityY;
        0,              // StretchTapsX  (0 no stretch, 1 pix dup, 2 interp...)
        0,              // StretchTapsY
        0,              // ShrinkTapsX 
        0,              // ShrinkTapsY 
        333667,         // MinFrameInterval, 100 nS units
        640000000,      // MaxFrameInterval, 100 nS units
        8 * 3 * 30 * 160 * 120,  // MinBitsPerSecond;
        8 * 3 * 30 * 720 * 480   // MaxBitsPerSecond;
    }, 
        
    // KS_VIDEOINFOHEADER (default format)
    {
        0,0,0,0,                            // RECT  rcSource; 
        0,0,0,0,                            // RECT  rcTarget; 
        D_X * D_Y * 3 * 30,                 // DWORD dwBitRate;
        0L,                                 // DWORD dwBitErrorRate; 
        333667,                             // REFERENCE_TIME  AvgTimePerFrame;   
        sizeof (KS_BITMAPINFOHEADER),       // DWORD biSize;
        D_X,                                // LONG  biWidth;
        D_Y,                                // LONG  biHeight;
        1,                                  // WORD  biPlanes;
        24,                                 // WORD  biBitCount;
        KS_BI_RGB,                          // DWORD biCompression;
        D_X * D_Y * 3,                      // DWORD biSizeImage;
        0,                                  // LONG  biXPelsPerMeter;
        0,                                  // LONG  biYPelsPerMeter;
        0,                                  // DWORD biClrUsed;
        0                                   // DWORD biClrImportant;
    }
}; 

#undef D_X
#undef D_Y

#define D_X 320
#define D_Y 240


const  KS_DATARANGE_VIDEO FormatUYU2_Capture = 
{
    // KSDATARANGE
    {   
        sizeof (KS_DATARANGE_VIDEO),            // FormatSize
        0,                                      // Flags
        D_X * D_Y * 2,                          // SampleSize
        0,                                      // Reserved
        STATICGUIDOF( KSDATAFORMAT_TYPE_VIDEO ),         // aka. MEDIATYPE_Video
        0x59565955, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71, //MEDIASUBTYPE_UYVY,
        STATICGUIDOF( KSDATAFORMAT_SPECIFIER_VIDEOINFO ) // aka. FORMAT_VideoInfo
    },

    TRUE,               // BOOL,  bFixedSizeSamples (all samples same size?)
    TRUE,               // BOOL,  bTemporalCompression (all I frames?)
    0,                  // Reserved (was StreamDescriptionFlags)
    0,                  // Reserved (was MemoryAllocationFlags   (KS_VIDEO_ALLOC_*))

    // _KS_VIDEO_STREAM_CONFIG_CAPS  
    {
        STATICGUIDOF( KSDATAFORMAT_SPECIFIER_VIDEOINFO ), // GUID
        KS_AnalogVideo_NTSC_M |
        KS_AnalogVideo_PAL_B,                    // AnalogVideoStandard
        720,480,        // InputSize, (the inherent size of the incoming signal
                    //             with every digitized pixel unique)
        160,120,        // MinCroppingSize, smallest rcSrc cropping rect allowed
        720,480,        // MaxCroppingSize, largest  rcSrc cropping rect allowed
        8,              // CropGranularityX, granularity of cropping size
        1,              // CropGranularityY
        8,              // CropAlignX, alignment of cropping rect 
        1,              // CropAlignY;
        160, 120,       // MinOutputSize, smallest bitmap stream can produce
        720, 480,       // MaxOutputSize, largest  bitmap stream can produce
        8,              // OutputGranularityX, granularity of output bitmap size
        1,              // OutputGranularityY;
        0,              // StretchTapsX  (0 no stretch, 1 pix dup, 2 interp...)
        0,              // StretchTapsY
        0,              // ShrinkTapsX 
        0,              // ShrinkTapsY 
        333667,         // MinFrameInterval, 100 nS units
        640000000,      // MaxFrameInterval, 100 nS units
        8 * 2 * 30 * 160 * 120,  // MinBitsPerSecond;
        8 * 2 * 30 * 720 * 480   // MaxBitsPerSecond;
    }, 
        
    // KS_VIDEOINFOHEADER (default format)
    {
        0,0,0,0,                            // RECT  rcSource; 
        0,0,0,0,                            // RECT  rcTarget; 
        D_X * D_Y * 2 * 30,                 // DWORD dwBitRate;
        0L,                                 // DWORD dwBitErrorRate; 
        333667,                             // REFERENCE_TIME  AvgTimePerFrame;   
        sizeof (KS_BITMAPINFOHEADER),       // DWORD biSize;
        D_X,                                // LONG  biWidth;
        D_Y,                                // LONG  biHeight;
        1,                                  // WORD  biPlanes;
        16,                                 // WORD  biBitCount;
        FOURCC_YUV422,                      // DWORD biCompression;
        D_X * D_Y * 2,                      // DWORD biSizeImage;
        0,                                  // LONG  biXPelsPerMeter;
        0,                                  // LONG  biYPelsPerMeter;
        0,                                  // DWORD biClrUsed;
        0                                   // DWORD biClrImportant;
    }
}; 
    
#undef D_X
#undef D_Y

const PKSDATARANGE PinVideoFormatRanges[] =
{
    (PKSDATARANGE) &FormatRGB24Bpp_Capture,
    (PKSDATARANGE) &FormatUYU2_Capture    
};

const PKSDATARANGE PinAudioFormatRanges[] =
{
    (PKSDATARANGE) &PinWaveIoRange
};


DECLARE_SIMPLE_FRAMING_EX(
    AllocatorFraming,
    STATICGUIDOF(KSMEMORY_TYPE_KERNEL_PAGED),
    KSALLOCATOR_REQUIREMENTF_SYSTEM_MEMORY | 
    KSALLOCATOR_REQUIREMENTF_INPLACE_MODIFIER |
    KSALLOCATOR_REQUIREMENTF_PREFERENCES_ONLY,
    2,
    0,
    2 * PAGE_SIZE,
    2 * PAGE_SIZE);

const
KSPIN_DISPATCH
VideoPinDispatch =
{
    VideoPinCreate,
    NULL,// Close
    NULL,// Process
    NULL,// Reset
    NULL,// SetDataFormat
    PinSetDeviceState,
    NULL,// Connect
    NULL,// Disconnect
    NULL// Allocator
};

const
KSPIN_DISPATCH
AudioPinDispatch =
{
    AudioPinCreate,
    NULL,// Close
    NULL,// Process
    NULL,// Reset
    NULL,// SetDataFormat
    PinSetDeviceState,
    NULL,// Connect
    NULL,// Disconnect
    NULL// Allocator
};


DEFINE_KSAUTOMATION_TABLE(PinAutomation) {
    DEFINE_KSAUTOMATION_PROPERTIES_NULL,
    DEFINE_KSAUTOMATION_METHODS_NULL,
    DEFINE_KSAUTOMATION_EVENTS_NULL
};


GUID g_PINNAME_VIDEO_CAPTURE ={STATIC_PINNAME_VIDEO_CAPTURE};
GUID g_PINNAME_KSCATEGORY_AUDIO ={STATIC_KSCATEGORY_AUDIO};

const
KSPIN_DESCRIPTOR_EX
KsPinDescriptors[] =
{
    {   &VideoPinDispatch,
        &PinAutomation,
        {
            SIZEOF_ARRAY(PinInterfaces),
            PinInterfaces,
            SIZEOF_ARRAY(PinMediums),
            PinMediums,
            SIZEOF_ARRAY(PinVideoFormatRanges),
            PinVideoFormatRanges,
            KSPIN_DATAFLOW_OUT,
            KSPIN_COMMUNICATION_BOTH,
            &g_PINNAME_VIDEO_CAPTURE,//Name
            &KSCATEGORY_VIDEO,//Category
            0
        },
        KSPIN_FLAG_DO_NOT_INITIATE_PROCESSING |
        KSPIN_FLAG_FRAMES_NOT_REQUIRED_FOR_PROCESSING,//Flags
        1, //InstancesPossible
        1, //InstancesNecessary
        &AllocatorFraming,
        VideoIntersectHandler
    },
    {   &AudioPinDispatch,
        NULL,
        {
            SIZEOF_ARRAY(PinInterfaces),
            PinInterfaces,
            SIZEOF_ARRAY(PinMediums),
            PinMediums,
            SIZEOF_ARRAY(PinAudioFormatRanges),
            PinAudioFormatRanges,
            KSPIN_DATAFLOW_OUT,
            KSPIN_COMMUNICATION_BOTH,
            &g_PINNAME_KSCATEGORY_AUDIO,//Name
            &KSCATEGORY_AUDIO,//Category
            0
        },
        KSPIN_FLAG_DO_NOT_INITIATE_PROCESSING |
        KSPIN_FLAG_FRAMES_NOT_REQUIRED_FOR_PROCESSING,//Flags
        0, // uncomment when audio is required. 1, //InstancesPossible
        0, //InstancesNecessary
        &AllocatorFraming,
        AudioIntersectHandler
    },
    {   NULL,
        NULL,
        {
            SIZEOF_ARRAY(PinInterfaces),
            PinInterfaces,
            SIZEOF_ARRAY(PinMediums),
            PinMediums,
            0,
            NULL,
            KSPIN_DATAFLOW_IN,
            KSPIN_COMMUNICATION_NONE,
            NULL,//Name
            NULL,//Category
            0
        },
        0,//Flags
        0, //InstancesPossible
        0, //InstancesNecessary
        NULL,
        NULL
    },
    {   NULL,
        NULL,
        {
            SIZEOF_ARRAY(PinInterfaces),
            PinInterfaces,
            SIZEOF_ARRAY(PinMediums),
            PinMediums,
            0,
            NULL,
            KSPIN_DATAFLOW_IN,
            KSPIN_COMMUNICATION_NONE,
            NULL,//Name
            NULL,//Category
            0
        },
        0,//Flags
        0, //InstancesPossible
        0, //InstancesNecessary
        NULL,
        NULL
    }
};



const
GUID
KsCategories[] =
{
    STATICGUIDOF( KSCATEGORY_AUDIO ),
    STATICGUIDOF( KSCATEGORY_VIDEO ),
    STATICGUIDOF( KSCATEGORY_CAPTURE )
};

const
GUID
VolumeNodeType = {STATICGUIDOF(KSNODETYPE_VOLUME)};

const
KSNODE_DESCRIPTOR
KsNodeDescriptors[] =
{
    DEFINE_NODE_DESCRIPTOR( NULL, &VolumeNodeType, NULL )
	//DEFINE_NODE_DESCRIPTOR( NULL, NULL, NULL ),
};

//	  -------------
//  2-|           |- 0 Video
//    |			  |
//  3-|	0 Node0 1 |- 1 Audio
//    -------------
const
KSTOPOLOGY_CONNECTION
KsConnections[] =
{
    { KSFILTER_NODE, 3, 0, 0 },
    { 0, 1, KSFILTER_NODE, 1 },
    //{ KSFILTER_NODE, 2, 1, 0 },
    //{ 0, 1, KSFILTER_NODE, 0 },
};

const
KSFILTER_DISPATCH
FilterDispatch =
{
    CCapFilter::FilterCreate,
    CCapFilter::FilterClose,
    CCapFilter::Process,
    NULL // Reset
};

DEFINE_KSFILTER_DESCRIPTOR(FilterDescriptor)
{   
    &FilterDispatch,
    NULL,//AutomationTable;
    KSFILTER_DESCRIPTOR_VERSION,
    KSFILTER_FLAG_DISPATCH_LEVEL_PROCESSING,//Flags
    &KSNAME_Filter,
    DEFINE_KSFILTER_PIN_DESCRIPTORS(KsPinDescriptors),
    DEFINE_KSFILTER_CATEGORIES(KsCategories),
    DEFINE_KSFILTER_NODE_DESCRIPTORS(KsNodeDescriptors),
    DEFINE_KSFILTER_CONNECTIONS(KsConnections),
    NULL // ComponentId
};

DEFINE_KSFILTER_DESCRIPTOR_TABLE(FilterDescriptors)
{
    &FilterDescriptor
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\ksfilter\tests\irpperf\exe\irpsend.c ===
/*	-	-	-	-	-	-	-	-	*/
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) Microsoft Corporation, 1995 - 1996  All Rights Reserved.
//
/*	-	-	-	-	-	-	-	-	*/

#include <windows.h>
#include <devioctl.h>
#include <stdio.h>
#include <stdlib.h>
#include <conio.h>
#include <malloc.h>
#include <tchar.h>
#include "..\irp\irp.h"

/*	-	-	-	-	-	-	-	-	*/
#define	MAX_IRPS	200000

/*	-	-	-	-	-	-	-	-	*/
int _cdecl main(
	int	argc,
	TCHAR	*argv[],
	TCHAR	*envp[])


{
	HANDLE	hDevice;
	ULONG	cbReturned;
	ULONG	ulTries;
	ULONG	ulTime;

	hDevice = CreateFile(TEXT("\\\\.\\irp"), GENERIC_READ | GENERIC_WRITE, 0, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
	if (hDevice == (HANDLE)-1) {
		_tprintf(TEXT("failed to open device (%ld)\n"), GetLastError());
		return 0;
	}
	ulTries = MAX_IRPS;
	if (!DeviceIoControl(hDevice, IOCTL_BUILD_EACH, &ulTries, sizeof(ULONG), &ulTime, sizeof(ULONG), &cbReturned, NULL))
		_tprintf(TEXT("failed device IO (%ld)\n"), GetLastError());
	_tprintf(TEXT("Time to create and send %lu Irps = %lu MS\n"), ulTries, ulTime);
	if (!DeviceIoControl(hDevice, IOCTL_BUILD_ONE, &ulTries, sizeof(ULONG), &ulTime, sizeof(ULONG), &cbReturned, NULL))
		_tprintf(TEXT("failed device IO (%ld)\n"), GetLastError());
//	_tprintf(TEXT("Time to create 1 Irp and send it %lu times = %lu MS\n"), ulTries, ulTime);
	_tprintf(TEXT("Time to create and send %lu Irps without wait = %lu MS\n"), ulTries, ulTime);
	CloseHandle(hDevice);
	return 0;
}

/*	-	-	-	-	-	-	-	-	*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\ksfilter\tests\irpperf\sys\irp.h ===
/*	-	-	-	-	-	-	-	-	*/
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) Microsoft Corporation, 1995 - 1996  All Rights Reserved.
//
/*	-	-	-	-	-	-	-	-	*/

#define IOCTL_BUILD_EACH	CTL_CODE(FILE_DEVICE_SOUND, 0x000, METHOD_NEITHER, FILE_READ_ACCESS | FILE_WRITE_ACCESS)
#define IOCTL_BUILD_ONE		CTL_CODE(FILE_DEVICE_SOUND, 0x001, METHOD_NEITHER, FILE_READ_ACCESS | FILE_WRITE_ACCESS)

/*	-	-	-	-	-	-	-	-	*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\ksfilter\tests\avstest\device.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       device.cpp
//
//--------------------------------------------------------------------------


#include "avssamp.h"

#ifdef ALLOC_DATA_PRAGMA
#pragma const_seg("PAGECONST")
#endif // ALLOC_DATA_PRAGMA

const
KSDEVICE_DESCRIPTOR 
DeviceDescriptor =
{   
    NULL,
    SIZEOF_ARRAY(FilterDescriptors),
    FilterDescriptors
};

#ifdef ALLOC_PRAGMA
#pragma code_seg("INIT")
#endif // ALLOC_PRAGMA

extern "C"
NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPathName
    )
/*++

Routine Description:

    Sets up the driver object.

Arguments:

    DriverObject -
        Driver object for this instance.

    RegistryPathName -
        Contains the registry path which was used to load this instance.

Return Values:

    Returns STATUS_SUCCESS if the driver was initialized.

--*/
{
    _DbgPrintF(DEBUGLVL_BLAB,("DriverEntry"));

    return
        KsInitializeDriver(
            DriverObject,
            RegistryPathName,
            &DeviceDescriptor);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\ksfilter\tests\irqperf\exe\irqtest.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1997
//
//  File:       irqtest.c
//
//--------------------------------------------------------------------------

#include <windows.h>
#include <devioctl.h>

#include <stdio.h>
#include <stdlib.h>
#include <conio.h>
#include <malloc.h>

#include "stat.h"

BOOL SynchronousDeviceControl
(
   HANDLE   DeviceHandle,
   DWORD    IoControl,
   PVOID    pvIn,
   ULONG    cbIn,
   PVOID    pvOut,
   ULONG    cbOut,
   PULONG   pcbReturned
)
{
   BOOL        fResult ;
   OVERLAPPED  ov ;

   RtlZeroMemory( &ov, sizeof( OVERLAPPED ) ) ;
   if (NULL == (ov.hEvent = CreateEvent( NULL, TRUE, FALSE, NULL )))
      return FALSE ;

   fResult =
      DeviceIoControl( DeviceHandle,
                       IoControl,
                       pvIn,
                       cbIn,
                       pvOut,
                       cbOut,
                       pcbReturned,
                       &ov ) ;


   if (!fResult)
   {
      if (ERROR_IO_PENDING == GetLastError())
      {
         WaitForSingleObject( ov.hEvent, INFINITE ) ;
         fResult = TRUE ;
      }
      else
         fResult = FALSE ;
   }

   CloseHandle( ov.hEvent ) ;

   return fResult ;
}

int _cdecl main
(
   int argc,
   char *argv[],
   char *envp[]
)
{
   int                      i;
   HANDLE                   DeviceHandle ;
   ULONG                    cbReturned ;
   STAT_PARAMETERS          Parameters;
   STAT_RETRIEVE_OPERATION  RetrieveOperation = StatRetrieveDpcLatency;
   PULONG                   StatBuffer;
   ULONG                    StatBufferLength;
   
   
   StatBufferLength = 64 * 1024 * sizeof( ULONG );
   if (NULL == (StatBuffer = HeapAlloc( GetProcessHeap(), 0, StatBufferLength ))) {
        printf( "\n\nERROR: unable to allocate buffer for statistics\n\n" );
        return 1;
   }

   DeviceHandle = CreateFile( "\\\\.\\Stat",
                         GENERIC_READ | GENERIC_WRITE,
                         0,
                         NULL,
                         OPEN_EXISTING,
                         FILE_ATTRIBUTE_NORMAL | FILE_FLAG_OVERLAPPED,
                         NULL ) ;

   if (DeviceHandle == (HANDLE) -1)
   {
      printf( "\n\nERROR: unable to open STAT! device.\n\n" ) ;
      return 1 ;
   }

   
    Parameters.InterruptFrequency = 4000; // * 250ns units
    Parameters.QueueType = DelayedWorkQueue;
    
       
   if (!SynchronousDeviceControl( DeviceHandle,
                                  IOCTL_STAT_SET_PARAMETERS,
                                  &Parameters,
                                  sizeof( Parameters ),
                                  NULL,
                                  0,
                                  &cbReturned ))
   {
      printf( "\n\nERROR: failed to reset STAT! device.\n\n" ) ;
      CloseHandle( DeviceHandle ) ;
      return 2 ;
   }

   SynchronousDeviceControl( DeviceHandle,
                             IOCTL_STAT_RUN,
                             NULL,
                             0,
                             NULL,
                             0,
                             &cbReturned ) ;

   while (!_kbhit())
   {
      SynchronousDeviceControl( DeviceHandle,
                                IOCTL_STAT_RETRIEVE_STATS,
                                &RetrieveOperation,
                                sizeof( RetrieveOperation ),
                                StatBuffer,
                                StatBufferLength,
                                &cbReturned ) ;

      // These are in 250ns units, divide by 4 to convert to
      // latency in microsecond units.
      
      for (i = 0; i < cbReturned / sizeof( ULONG ); i++) {
          printf( "%d\n", StatBuffer[ i ] / 4 );
      }      
   }

   if (_kbhit ())
      _getch ();

   SynchronousDeviceControl( DeviceHandle,
                             IOCTL_STAT_STOP,
                             NULL,
                             0,
                             NULL,
                             0,
                             &cbReturned ) ;

   CloseHandle( DeviceHandle ) ;

   return 0 ;

} // end of main()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\ksfilter\tests\irpperf\sys\irp.c ===
/*	-	-	-	-	-	-	-	-	*/
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) Microsoft Corporation, 1995 - 1997  All Rights Reserved.
//
/*	-	-	-	-	-	-	-	-	*/

#include <ntddk.h>
#include <windef.h>
#include <tchar.h>
#include <stdio.h>
#include "irp.h"

#define	IOCTL_SEND	CTL_CODE(FILE_DEVICE_SOUND, 0x000, METHOD_NEITHER, FILE_WRITE_ACCESS)

#ifdef ALLOC_PRAGMA
NTSTATUS DriverEntry(
	IN PDRIVER_OBJECT       pDriverObject,
	IN PUNICODE_STRING      suRegistryPathName);
#pragma alloc_text(INIT, DriverEntry)
#endif

/*	-	-	-	-	-	-	-	-	*/
NTSTATUS DispatchCreate(
	IN PDEVICE_OBJECT	pdo,
	IN PIRP			pirp)
{
	pirp->IoStatus.Information = 0;
	pirp->IoStatus.Status = STATUS_SUCCESS;
	IoCompleteRequest(pirp, IO_NO_INCREMENT);
	return STATUS_SUCCESS;
}

#if 0
/*	-	-	-	-	-	-	-	-	*/
NTSTATUS CompletionRoutine(
	IN PDEVICE_OBJECT	pdo,
	IN PIRP			pirp,
	IN PVOID		pvContext)
{
	return STATUS_MORE_PROCESSING_REQUIRED;
}
#endif

/*	-	-	-	-	-	-	-	-	*/
NTSTATUS DispatchControl(
	IN PDEVICE_OBJECT	pdo,
	IN PIRP			pirp)
{
	PIO_STACK_LOCATION	pirpStack;
	ULONG			ulTries;
	ULONG			ulCount;
	LARGE_INTEGER		liBaseTime;
	LARGE_INTEGER		liStartTime;
	LARGE_INTEGER		liEndTime;
	LARGE_INTEGER		liPerformanceFrequency;
	KEVENT			Event;
	PIRP			pirpSend;
	IO_STATUS_BLOCK		IoStatusBlock;

	pirpStack = IoGetCurrentIrpStackLocation(pirp);
	ulTries = *(PULONG)pirpStack->Parameters.DeviceIoControl.Type3InputBuffer;
	KeQueryPerformanceCounter(&liPerformanceFrequency);
	//!!Start Base
	liStartTime = KeQueryPerformanceCounter(NULL);
	for (ulCount = ulTries; ulCount; ulCount--)
		;
	liEndTime = KeQueryPerformanceCounter(NULL);
	//!!End Base
	liBaseTime.QuadPart = liEndTime.QuadPart - liStartTime.QuadPart;
	KeInitializeEvent(&Event, NotificationEvent, FALSE);
	switch (pirpStack->Parameters.DeviceIoControl.IoControlCode) {
	case IOCTL_BUILD_EACH:
		//!!Start Timing
		liStartTime = KeQueryPerformanceCounter(NULL);
		for (ulCount = ulTries; ulCount; ulCount--) {
			KeClearEvent(&Event);
			pirpSend = IoBuildDeviceIoControlRequest(IOCTL_SEND, pdo, NULL, 0, NULL, 0, TRUE, &Event, &IoStatusBlock);
			IoCallDriver(pdo, pirpSend);
			KeWaitForSingleObject(&Event, Executive, KernelMode, FALSE, NULL);
		}
		liEndTime = KeQueryPerformanceCounter(NULL);
		//!!End Timing
		break;
	case IOCTL_BUILD_ONE:
#if 0
		pirpSend = IoBuildDeviceIoControlRequest(IOCTL_SEND, pdo, NULL, 0, NULL, 0, TRUE, &Event, &IoStatusBlock);
		//!!Start Timing
		liStartTime = KeQueryPerformanceCounter(NULL);
		for (ulCount = ulTries; ulCount; ulCount--) {
			pirpSend->CurrentLocation = (CCHAR)(pdo->StackSize + 1);
			pirpSend->Tail.Overlay.CurrentStackLocation = ((PIO_STACK_LOCATION)((UCHAR*)(pirpSend + 1) + (pdo->StackSize * sizeof(IO_STACK_LOCATION))));
			IoSetCompletionRoutine(pirpSend, CompletionRoutine, NULL, TRUE, TRUE, TRUE);
//			KeClearEvent(&Event);
			IoCallDriver(pdo, pirpSend);
//			KeWaitForSingleObject(&Event, Executive, KernelMode, FALSE, NULL);
		}
		liEndTime = KeQueryPerformanceCounter(NULL);
		//!!End Timing
		IoFreeIrp(pirpSend);
#endif
		//!!Start Timing
		liStartTime = KeQueryPerformanceCounter(NULL);
		for (ulCount = ulTries; ulCount; ulCount--) {
			KeClearEvent(&Event);
			pirpSend = IoBuildDeviceIoControlRequest(IOCTL_SEND, pdo, NULL, 0, NULL, 0, TRUE, &Event, &IoStatusBlock);
			IoCallDriver(pdo, pirpSend);
		}
		liEndTime = KeQueryPerformanceCounter(NULL);
		//!!End Timing
		break;
	}
	liEndTime.QuadPart -= liBaseTime.QuadPart;
	ulCount = (ULONG)(((liEndTime.QuadPart - liStartTime.QuadPart) * 1000) / liPerformanceFrequency.QuadPart);
	*(PULONG)(pirp->UserBuffer) = ulCount;
	pirp->IoStatus.Information = sizeof(ULONG);
	pirp->IoStatus.Status = STATUS_SUCCESS;
	IoCompleteRequest(pirp, IO_NO_INCREMENT);
	return STATUS_SUCCESS;
}

/*	-	-	-	-	-	-	-	-	*/
NTSTATUS DispatchInternalControl(
	IN PDEVICE_OBJECT	pdo,
	IN PIRP			pirp)
{
	pirp->IoStatus.Information = 0;
	pirp->IoStatus.Status = STATUS_SUCCESS;
	IoCompleteRequest(pirp, IO_NO_INCREMENT);
	return STATUS_SUCCESS;
}

/*	-	-	-	-	-	-	-	-	*/
VOID DriverUnload(
	IN PDRIVER_OBJECT	pDriverObject)
{
}

/*	-	-	-	-	-	-	-	-	*/
NTSTATUS DriverEntry(
	IN PDRIVER_OBJECT       pDriverObject,
	IN PUNICODE_STRING      suRegistryPathName)
{
	NTSTATUS	Status;
	UNICODE_STRING	usDeviceName;
	PDEVICE_OBJECT	pdo;
	
	RtlInitUnicodeString(&usDeviceName, L"\\Device\\irp");
	Status = IoCreateDevice(pDriverObject, 0, &usDeviceName, FILE_DEVICE_SOUND, 0, FALSE, &pdo);
	if (NT_SUCCESS(Status)) {
		UNICODE_STRING	usLinkName;

		RtlInitUnicodeString(&usLinkName, L"\\DosDevices\\irp");
		Status = IoCreateSymbolicLink(&usLinkName, &usDeviceName);
		if (NT_SUCCESS(Status)) {
			pDriverObject->MajorFunction[IRP_MJ_CREATE] = DispatchCreate;
			pDriverObject->MajorFunction[IRP_MJ_CLOSE] = DispatchCreate;
			pDriverObject->MajorFunction[IRP_MJ_DEVICE_CONTROL] = DispatchControl;
			pDriverObject->MajorFunction[IRP_MJ_INTERNAL_DEVICE_CONTROL] = DispatchInternalControl;
			pDriverObject->DriverUnload = DriverUnload;
			pdo->Flags |= DO_DIRECT_IO;
			pdo->Flags &= ~DO_DEVICE_INITIALIZING;

			return STATUS_SUCCESS;
		}
		IoDeleteDevice(pdo);
	}
	return Status;
}

/*	-	-	-	-	-	-	-	-	*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\ksfilter\tests\irqperf\sys\device.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1997
//
//  File:       device.c
//
//--------------------------------------------------------------------------

#include <ntddk.h>
#include <ntdef.h>

#include <memory.h>
#include <stddef.h>
#include <stdio.h>
#include <stdlib.h>
#include <tchar.h>
#include <conio.h>

#include "stat.h"
#include "private.h"

PDEVICE_OBJECT StatDeviceObject;

VOID 
DriverUnload(
    IN PDRIVER_OBJECT DriverObject
    )

/*++

Routine Description:


Arguments:
    IN DRIVER_OBJECT DriverObject -

Return:

--*/

{
    _DbgPrintF( DEBUGLVL_BLAB, ("DriverUnload") );
    if (StatDeviceObject) {
        IoDeleteDevice( StatDeviceObject );
    }
}

NTSTATUS 
GetConfiguration(
    IN PDRIVER_OBJECT DriverObject,
    OUT PCM_RESOURCE_LIST *AllocatedResources
    )

/*++

Routine Description:


Arguments:
    IN PDRIVER_OBJECT DriverObject -

    OUT PCM_RESOURCE_LIST *AllocatedResources -

Return:

--*/

{
    int                              i, Resources;
    BOOLEAN                          OverrideConflict, Conflicted;
    NTSTATUS                         Status;
    PCM_PARTIAL_RESOURCE_DESCRIPTOR  ResDes;
    ULONG                            cbResList;

    IO_RESOURCE  IoResources[] = 
    {
        { 0x250, 0x04 }
    };
    IRQ_RESOURCE IrqResources[] =
    { 
       { 7, CM_RESOURCE_INTERRUPT_LATCHED, CmResourceShareDriverExclusive }
    };
    
    if (NULL == AllocatedResources) {
      return STATUS_INVALID_PARAMETER;
    }

    *AllocatedResources = NULL;

    Resources = SIZEOF_ARRAY( IoResources ) + SIZEOF_ARRAY( IrqResources );

    cbResList = 
        sizeof( CM_RESOURCE_LIST ) +
            (Resources - 1) * 
                sizeof( CM_PARTIAL_RESOURCE_DESCRIPTOR );

    if (NULL == 
         (*AllocatedResources = 
            (PCM_RESOURCE_LIST) ExAllocatePool( NonPagedPool, cbResList ))) {
        return STATUS_NO_MEMORY;
    }      

    RtlZeroMemory( *AllocatedResources, cbResList );

    (*AllocatedResources)->Count = 1;

    (*AllocatedResources)->List[ 0 ].InterfaceType = Isa;
    (*AllocatedResources)->List[ 0 ].BusNumber = 0;
    (*AllocatedResources)->List[ 0 ].PartialResourceList.Count = Resources;

    ResDes = 
      (*AllocatedResources)->List[ 0 ].PartialResourceList.PartialDescriptors;

    for (i = 0; i < SIZEOF_ARRAY( IoResources ); i++, ResDes++) {
        ResDes->Type = CmResourceTypePort;
        ResDes->ShareDisposition = CmResourceShareDeviceExclusive;
        ResDes->Flags = CM_RESOURCE_PORT_IO;
        ResDes->u.Port.Start.QuadPart = IoResources[ i ].PortBase;
        ResDes->u.Port.Length = IoResources[ i ].PortLength;
    }

    for (i = 0; i < SIZEOF_ARRAY( IrqResources ); i++, ResDes++) {
        ResDes->Type = CmResourceTypeInterrupt;
        ResDes->ShareDisposition = IrqResources[ i ].ShareDisposition;
        ResDes->Flags = IrqResources[ i ].Flags;
        ResDes->u.Interrupt.Level = IrqResources[ i ].InterruptLevel;
        ResDes->u.Interrupt.Vector = ResDes->u.Interrupt.Level;
        ResDes->u.Interrupt.Affinity = (ULONG) -1;
    }

    OverrideConflict = FALSE;

    Status = 
        IoReportResourceUsage( 
            NULL,
            DriverObject,
            *AllocatedResources,
            cbResList,
            NULL,
            NULL,
            0,
            OverrideConflict,
            &Conflicted );

   return Status;

}

NTSTATUS 
DriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPathName
    )

/*++

Routine Description:


Arguments:
    IN PDRIVER_OBJECT DriverObject -

    IN PUNICODE_STRING RegistryPathName -

Return:

--*/

{
    NTSTATUS            Status;
    PCM_RESOURCE_LIST   AllocatedResources;

    _DbgPrintF( DEBUGLVL_BLAB, ("DriverEntry") );
    
    DriverObject->DriverUnload = DriverUnload;

    AllocatedResources = NULL;

    Status = GetConfiguration( DriverObject, &AllocatedResources );
    if (!NT_SUCCESS(Status)) {
        _DbgPrintF( DEBUGLVL_BLAB, ("failed to retrieve hardware configuration") );
        return Status;
    }

    Status = 
        RegisterDevice( 
            DriverObject, 
            RegistryPathName,
            AllocatedResources,
            &StatDeviceObject );
    if (!NT_SUCCESS(Status)) {
        _DbgPrintF( DEBUGLVL_BLAB, ("failed to register device") );
        return Status;
    }

    if (AllocatedResources) {
        ExFreePool( AllocatedResources );
    }

    return Status;
}

VOID 
HwReset(
    IN PSTAT_DEVINST DeviceInstance
    )

/*++

Routine Description:


Arguments:
    IN PSTAT_DEVINST DeviceInstance -

Return:

--*/

{
    KIRQL  irqlOld;

    // disable Stat! interrupts

    WRITE_PORT_UCHAR( 
        DeviceInstance->portBase + STAT_REG_INT , 
        0 );

    // disarm C1-C5

    WRITE_PORT_UCHAR( 
        DeviceInstance->portBase + STAT_REG_CMD,
        STAT_DISARM | STAT_C1 | STAT_C2 | STAT_C3 | STAT_C4 | STAT_C5 );

    // issue a reset

    WRITE_PORT_UCHAR( 
        DeviceInstance->portBase + STAT_REG_CMD, 
        STAT_RESET );

    // zero all counters

    WRITE_PORT_UCHAR( 
        DeviceInstance->portBase + STAT_REG_CMD,
        STAT_LD | STAT_C5 | STAT_C4 | STAT_C3 | STAT_C2 | STAT_C1 );

    // load MASTER reg (disable pointer incr)

    WRITE_PORT_UCHAR( 
        DeviceInstance->portBase + STAT_REG_CMD,
        STAT_LDPTR | STAT_CTL | STAT_MASTER );
    WRITE_PORT_USHORT( 
        (PUSHORT) (DeviceInstance->portBase + STAT_REG_DATA),
        0x4000 );

    // Set interrupt latency

    WRITE_PORT_UCHAR( 
        DeviceInstance->portBase + STAT_REG_CMD,
        STAT_LDPTR | STAT_LOAD | STAT_CTR1 );
    WRITE_PORT_USHORT( 
        (PUSHORT) (DeviceInstance->portBase + STAT_REG_DATA),
        (USHORT) DeviceInstance->InterruptFrequency );

    // configure mode for interval counter

    WRITE_PORT_UCHAR( 
        DeviceInstance->portBase + STAT_REG_CMD,
        STAT_LDPTR | STAT_MODE | STAT_CTR1 );
    WRITE_PORT_USHORT( 
        (PUSHORT) (DeviceInstance->portBase + STAT_REG_DATA),
        0x0ba2 );

    // clear latency counter (count up)

    WRITE_PORT_UCHAR( 
        DeviceInstance->portBase + STAT_REG_CMD,
        STAT_LDPTR | STAT_LOAD | STAT_CTR2 );
    WRITE_PORT_USHORT( 
        (PUSHORT) (DeviceInstance->portBase + STAT_REG_DATA),
        0 );

    // configure latency counter to ARM on CTR1 TC

    WRITE_PORT_UCHAR( DeviceInstance->portBase + STAT_REG_CMD,
                     STAT_LDPTR | STAT_MODE | STAT_CTR2 );
    WRITE_PORT_USHORT( (PUSHORT) (DeviceInstance->portBase + STAT_REG_DATA),
                      0x6ba8 );

    // clear ints gen counter (count up)

    WRITE_PORT_UCHAR( DeviceInstance->portBase + STAT_REG_CMD,
                     STAT_LDPTR | STAT_LOAD | STAT_CTR3 );
    WRITE_PORT_USHORT( (PUSHORT) (DeviceInstance->portBase + STAT_REG_DATA),
                      0 );

    // configure interrupt counter to ARM on CTR1 TC

    WRITE_PORT_UCHAR( DeviceInstance->portBase + STAT_REG_CMD,
                     STAT_LDPTR | STAT_MODE | STAT_CTR3 );
    WRITE_PORT_USHORT( (PUSHORT) (DeviceInstance->portBase + STAT_REG_DATA),
                      0x1628 );

    // set CTR1 output low

    WRITE_PORT_UCHAR( DeviceInstance->portBase + STAT_REG_CMD,
                     STAT_CLR_TC + STAT_CTR1 );

    // Dpc latency counter

    WRITE_PORT_UCHAR( 
        DeviceInstance->portBase + STAT_REG_CMD,
        STAT_LDPTR | STAT_MODE | STAT_CTR4 );
    WRITE_PORT_USHORT( 
        (PUSHORT) (DeviceInstance->portBase + STAT_REG_DATA),
        AM9513_TIMER_SOURCE_F1 |
        AM9513_TIMER_DIRECTION_UP |
        AM9513_TIMER_OUTPUT_INACTIVE );

    WRITE_PORT_UCHAR( 
        DeviceInstance->portBase + STAT_REG_CMD,
        STAT_LDPTR | STAT_LOAD | STAT_CTR4 );
    WRITE_PORT_USHORT( 
        (PUSHORT) (DeviceInstance->portBase + STAT_REG_DATA),
        0 );

    // WorkItem latency counter

    WRITE_PORT_UCHAR( 
        DeviceInstance->portBase + STAT_REG_CMD,
        STAT_LDPTR | STAT_MODE | STAT_CTR5 );
    WRITE_PORT_USHORT( 
        (PUSHORT) (DeviceInstance->portBase + STAT_REG_DATA),
        AM9513_TIMER_SOURCE_F1 |
        AM9513_TIMER_DIRECTION_UP |
        AM9513_TIMER_OUTPUT_INACTIVE );

    WRITE_PORT_UCHAR( 
        DeviceInstance->portBase + STAT_REG_CMD,
        STAT_LDPTR | STAT_LOAD | STAT_CTR5 );
    WRITE_PORT_USHORT( 
        (PUSHORT) (DeviceInstance->portBase + STAT_REG_DATA),
        0 );

        

    // Interrupts are disabled for this device, but if we were previously
    // runnning we might have a Dpc in progress on another processor so we 
    // need to synchronize this data access.

    DeviceInstance->Counters[ LATENCY_COUNTER_IRQ ].Position = 0;
    KeAcquireSpinLock( &DeviceInstance->DpcLock, &irqlOld );
    DeviceInstance->Counters[ LATENCY_COUNTER_DPC ].Position = 0;
    KeReleaseSpinLock( &DeviceInstance->DpcLock, irqlOld );
}

VOID HwRun(
    IN PSTAT_DEVINST DeviceInstance
    )

/*++

Routine Description:


Arguments:
    IN PSTAT_DEVINST DeviceInstance -

Return:

--*/

{
    // set CTR1 output low

    WRITE_PORT_UCHAR( 
        DeviceInstance->portBase + STAT_REG_CMD,
        STAT_CLR_TC + STAT_CTR1 );

    // enable IRQ source (TC of CTR1) 

    WRITE_PORT_UCHAR( 
        DeviceInstance->portBase + STAT_REG_INT,
        STAT_IE_ENABLED | STAT_IE_TC1 );

    // reset C1-C5

    WRITE_PORT_UCHAR( 
        DeviceInstance->portBase + STAT_REG_CMD,
        STAT_LD | STAT_C1 | STAT_C2 | STAT_C3 | STAT_C4 | STAT_C5 );

    // arm C1-C3

    WRITE_PORT_UCHAR( 
        DeviceInstance->portBase + STAT_REG_CMD,
        STAT_ARM | STAT_C1 | STAT_C2 | STAT_C3 );

}

VOID 
HwStop(
    IN PSTAT_DEVINST DeviceInstance
    )

/*++

Routine Description:


Arguments:
    IN PSTAT_DEVINST DeviceInstance -

Return:

--*/

{
   // disable Stat! interrupts

   WRITE_PORT_UCHAR( DeviceInstance->portBase + STAT_REG_INT , 0 );

   // disarm C1-C5

   WRITE_PORT_UCHAR( DeviceInstance->portBase + STAT_REG_CMD,
                     STAT_DISARM | STAT_C1 | STAT_C2 | STAT_C3 | STAT_C4 | STAT_C5 );
}

NTSTATUS 
HwInitialize(
    IN PSTAT_DEVINST DeviceInstance,
    IN PCM_RESOURCE_LIST AllocatedResources
    )

/*++

Routine Description:


Arguments:
    IN PSTAT_DEVINST DeviceInstance -

    IN PCM_RESOURCE_LIST AllocatedResources -

Return:

--*/

{
    NTSTATUS                         Status;
    PCM_PARTIAL_RESOURCE_DESCRIPTOR  ResDes;
    ULONG                            i, AddressSpace;

    // count resources and establish index tables

    for (i = 0,
         ResDes = 
            AllocatedResources->List[ 0 ].PartialResourceList.PartialDescriptors;
         i < AllocatedResources->List[ 0 ].PartialResourceList.Count;
         i++, ResDes++) {
         
        switch (ResDes->Type) {
        
        case CmResourceTypePort:
            AddressSpace = 1;
            HalTranslateBusAddress( 
                AllocatedResources->List[ 0 ].InterfaceType, 
                AllocatedResources->List[ 0 ].BusNumber,
                ResDes->u.Port.Start,
                &AddressSpace,
                &DeviceInstance->portPhysicalAddress );
            if (!AddressSpace) {
                DeviceInstance->portBase =
                    MmMapIoSpace( 
                        DeviceInstance->portPhysicalAddress,
                        ResDes->u.Port.Length,
                        FALSE ); // IN BOOLEAN CacheEnable
            } else {
                DeviceInstance->portBase =
                    (PUCHAR) DeviceInstance->portPhysicalAddress.LowPart;
            }    
            HwReset( DeviceInstance );
            break;

        case CmResourceTypeInterrupt:
            DeviceInstance->InterruptVector =
                HalGetInterruptVector( 
                    AllocatedResources->List[ 0 ].InterfaceType,
                    AllocatedResources->List[ 0 ].BusNumber,
                    ResDes->u.Interrupt.Level, 
                    ResDes->u.Interrupt.Vector,
                    &DeviceInstance->DIrql,
                    &DeviceInstance->InterruptAffinity );
         
            Status = 
                IoConnectInterrupt( 
                    &DeviceInstance->InterruptObject,
                    DeviceIsr,
                    DeviceInstance,
                    NULL, // IN PKSPIN_LOCK SpinLock
                    DeviceInstance->InterruptVector,
                    DeviceInstance->DIrql,
                    DeviceInstance->DIrql,
                    (ResDes->Flags & 
                        CM_RESOURCE_INTERRUPT_LATCHED) ?
                        Latched : LevelSensitive,
                    (BOOLEAN)(ResDes->ShareDisposition != 
                        CmResourceShareDriverExclusive),
                    DeviceInstance->InterruptAffinity,
                    FALSE ); // IN BOOLEAN FloatingSave
            if (!NT_SUCCESS( Status )) {
               _DbgPrintF( DEBUGLVL_ERROR, ("failed to connect interrupt") );
               return Status;
            }
            break;

        default:
            return STATUS_DEVICE_CONFIGURATION_ERROR;
            
        } 
    }

    IoInitializeDpcRequest( DeviceInstance->DeviceObject, DeviceDpc );

    return STATUS_SUCCESS;

}

BOOLEAN             
DeviceIsr(
    IN PKINTERRUPT Interrupt,
    IN PVOID Context
    )

/*++

Routine Description:


Arguments:
    IN PKINTERRUPT Interrupt -

    IN PVOID Context -

Return:

--*/

{
    PSTAT_DEVINST  DeviceInstance;

    DeviceInstance = (PSTAT_DEVINST) Context;

    //
    // save latency counters
    //

    WRITE_PORT_UCHAR( 
        DeviceInstance->portBase + STAT_REG_CMD,
        STAT_SAVE | STAT_C2 | STAT_C3 );
            
    //
    // read latency counter interrupt
    //
      
    if (DeviceInstance->Counters[ LATENCY_COUNTER_IRQ ].Position != 
            MAX_COUNTER_STORAGE) {
        WRITE_PORT_UCHAR( 
            DeviceInstance->portBase + STAT_REG_CMD,
            STAT_LDPTR | STAT_HOLD | STAT_CTR2 );
                      
        DeviceInstance->Counters[ LATENCY_COUNTER_IRQ ].Data[ DeviceInstance->Counters[ LATENCY_COUNTER_IRQ ].Position++ ] =
            (ULONG) READ_PORT_USHORT( 
                (PUSHORT) (DeviceInstance->portBase + STAT_REG_DATA) );
    }    


    if (!InterlockedExchange( &DeviceInstance->DpcPending, TRUE )) {

        // reload C4

        WRITE_PORT_UCHAR( 
            DeviceInstance->portBase + STAT_REG_CMD,
            STAT_LD | STAT_C4 );
            
        // arm C4

        WRITE_PORT_UCHAR( 
            DeviceInstance->portBase + STAT_REG_CMD,
            STAT_ARM | STAT_C4 );

        IoRequestDpc( 
            DeviceInstance->DeviceObject,   // DeviceObject
            NULL,                           // Irp
            DeviceInstance );               // Context
    } else {
        DeviceInstance->IsrWhileDpc++;
    }

    //
    // Acknowledge the interrupt
    //
    
    //
    // CTR3 is incremented for each IRQ that is missed.
    //

    // clearing TC of CTR1 will increment CTR3

    WRITE_PORT_UCHAR( 
        DeviceInstance->portBase + STAT_REG_CMD,
        STAT_CLR_TC | STAT_CTR1 );

    // reset C3

    WRITE_PORT_UCHAR( 
        DeviceInstance->portBase + STAT_REG_CMD,
        STAT_LD | STAT_C3 );

    return TRUE;

}

BOOLEAN 
SnapDpcTimeSynchronized(
    IN PSTAT_DEVINST DeviceInstance
    )

/*++

Routine Description:


Arguments:
    IN PSTAT_DEVINST DeviceInstance -

Return:

--*/

{

//    WRITE_PORT_UCHAR( DeviceInstance->portBase + STAT_REG_CMD,
//                     STAT_LDPTR | STAT_HOLD | STAT_CTR3 );
//
//    ElapsedIrqs =
//      (ULONG) READ_PORT_USHORT( (PUSHORT) (DeviceInstance->portBase + STAT_REG_DATA) );
//    ElapsedIrqs += DeviceInstance->IsrWhileDpc;

    DeviceInstance->IsrWhileDpc = 0;

//    if (ElapsedIrqs) {
//        DeviceInstance->CurrentIrqLatency +=
//            ElapsedIrqs * DeviceInstance->InterruptFrequency;
//    }


    if (DeviceInstance->Counters[ LATENCY_COUNTER_DPC ].Position != 
            MAX_COUNTER_STORAGE) {
        WRITE_PORT_UCHAR( 
            DeviceInstance->portBase + STAT_REG_CMD,
            STAT_LDPTR | STAT_HOLD | STAT_CTR4 );
                          
        DeviceInstance->Counters[ LATENCY_COUNTER_DPC ].Data[ DeviceInstance->Counters[ LATENCY_COUNTER_DPC ].Position++ ] =
            (ULONG) READ_PORT_USHORT( 
                (PUSHORT) (DeviceInstance->portBase + STAT_REG_DATA) );
    }    
        
    return TRUE;
}

VOID 
DeviceDpc(
    IN PKDPC Dpc,
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    )

/*++

Routine Description:


Arguments:
    IN PKDPC Dpc -

    IN PDEVICE_OBJECT DeviceObject -

    IN PIRP Irp -

    IN PVOID Context -

Return:

--*/

{
    PSTAT_DEVINST  DeviceInstance;

    DeviceInstance = (PSTAT_DEVINST) Context;

    // Save Dpc latency counter

    WRITE_PORT_UCHAR( 
        DeviceInstance->portBase + STAT_REG_CMD,
        STAT_SAVE | STAT_C4 );

    // Disarm Dpc latency counter

    WRITE_PORT_UCHAR( 
        DeviceInstance->portBase + STAT_REG_CMD,
        STAT_DISARM | STAT_C4 );
        
    KeAcquireSpinLockAtDpcLevel( &DeviceInstance->DpcLock );

    // Synchronize with ISR so that we can do indexed register
    // I/O without being stomped on...

    KeSynchronizeExecution( 
        DeviceInstance->InterruptObject, 
        SnapDpcTimeSynchronized, 
        Context );

    KeReleaseSpinLockFromDpcLevel( &DeviceInstance->DpcLock );
    
    if (!InterlockedExchange( &DeviceInstance->WorkItemPending, TRUE )) {

        // reload C5

        WRITE_PORT_UCHAR( 
            DeviceInstance->portBase + STAT_REG_CMD,
            STAT_LD | STAT_C5 );
            
        // arm C5

        WRITE_PORT_UCHAR( 
            DeviceInstance->portBase + STAT_REG_CMD,
            STAT_ARM | STAT_C5 );
    
        ExQueueWorkItem( 
            &DeviceInstance->WorkItem,
            DeviceInstance->QueueType );
            
    } else {
        DeviceInstance->IsrWhileDpc++;
    }

    InterlockedExchange( &DeviceInstance->DpcPending, FALSE );
}


BOOLEAN 
SnapWorkItemTimeSynchronized(
    IN PSTAT_DEVINST DeviceInstance
    )

/*++

Routine Description:


Arguments:
    IN PSTAT_DEVINST DeviceInstance -

Return:

--*/

{

    if (DeviceInstance->Counters[ LATENCY_COUNTER_WORKITEM ].Position != 
            MAX_COUNTER_STORAGE) {
        WRITE_PORT_UCHAR( 
            DeviceInstance->portBase + STAT_REG_CMD,
            STAT_LDPTR | STAT_HOLD | STAT_CTR5 );
                          
        DeviceInstance->Counters[ LATENCY_COUNTER_WORKITEM ].Data[ DeviceInstance->Counters[ LATENCY_COUNTER_WORKITEM ].Position++ ] =
            (ULONG) READ_PORT_USHORT( 
                (PUSHORT) (DeviceInstance->portBase + STAT_REG_DATA) );
    }    
        
    return TRUE;
}

VOID
DeviceWorkItem(
    PVOID Context
    )
{
    PSTAT_DEVINST  DeviceInstance;

    DeviceInstance = (PSTAT_DEVINST) Context;
    
    // Save WorkItem latency counter

    WRITE_PORT_UCHAR( 
        DeviceInstance->portBase + STAT_REG_CMD,
        STAT_SAVE | STAT_C5 );

    // Disarm WorkItem latency counter

    WRITE_PORT_UCHAR( 
        DeviceInstance->portBase + STAT_REG_CMD,
        STAT_DISARM | STAT_C5 );


    ExAcquireFastMutex( &DeviceInstance->WorkItemMutex );

    // Synchronize with ISR so that we can do indexed register
    // I/O without being stomped on...

    KeSynchronizeExecution( 
        DeviceInstance->InterruptObject, 
        SnapWorkItemTimeSynchronized, 
        Context );

    ExReleaseFastMutex( &DeviceInstance->WorkItemMutex );

    InterlockedExchange( &DeviceInstance->WorkItemPending, FALSE );
}    


NTSTATUS 
DispatchClose(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:


Arguments:
    IN PDEVICE_OBJECT DeviceObject -

    IN PIRP Irp -

Return:

--*/

{
    NTSTATUS Status;

    Status = STATUS_SUCCESS;

    Irp->IoStatus.Information = 0;
    Irp->IoStatus.Status = Status;
    IoCompleteRequest( Irp, IO_NO_INCREMENT );

    return Status;
}

NTSTATUS 
DispatchCreate(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:


Arguments:
    IN PDEVICE_OBJECT DeviceObject -

    IN PIRP Irp -

Return:

--*/

{
    NTSTATUS Status;

    Status = STATUS_SUCCESS;

    Irp->IoStatus.Information = 0;
    Irp->IoStatus.Status = Status;
    IoCompleteRequest( Irp, IO_NO_INCREMENT );

    return Status;
}

BOOLEAN 
CopyIrqLatencies(
    IN PSTAT_RETRIEVAL_SYNCPACKET SyncPacket
    )
{
    ULONG               DataToCopy;
    PIO_STACK_LOCATION  irpSp;

    DataToCopy =
        SyncPacket->DeviceInstance->Counters[ LATENCY_COUNTER_IRQ ].Position * 
            sizeof( ULONG );
            
    irpSp = IoGetCurrentIrpStackLocation( SyncPacket->Irp );            
    if (irpSp->Parameters.DeviceIoControl.OutputBufferLength <
            DataToCopy) {
        if (irpSp->Parameters.DeviceIoControl.OutputBufferLength) {
            SyncPacket->Status = STATUS_BUFFER_TOO_SMALL;
        } else {
            SyncPacket->Irp->IoStatus.Information = DataToCopy;
            SyncPacket->Status = STATUS_BUFFER_OVERFLOW;
        }
    } else {
        RtlCopyMemory( 
            SyncPacket->OutputBuffer,
            SyncPacket->DeviceInstance->Counters[ LATENCY_COUNTER_IRQ ].Data,
            DataToCopy );
        SyncPacket->DeviceInstance->Counters[ LATENCY_COUNTER_IRQ ].Position = 
            0;
        SyncPacket->Irp->IoStatus.Information = DataToCopy;
        SyncPacket->Status = STATUS_SUCCESS;
    }

    return TRUE;    
            
}    

NTSTATUS 
DispatchIoControl(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:


Arguments:
    IN PDEVICE_OBJECT DeviceObject -

    IN PIRP Irp -

Return:

--*/

{
    NTSTATUS             Status;
    KIRQL                irqlOld;
    PIO_STACK_LOCATION   irpSp;
    PSTAT_DEVINST        DeviceInstance;
    ULONG                DataToCopy;

    Irp->IoStatus.Information = 0;
    irpSp = IoGetCurrentIrpStackLocation( Irp );
    DeviceInstance = (PSTAT_DEVINST) DeviceObject->DeviceExtension;

    Status = STATUS_INVALID_DEVICE_REQUEST;

    switch (irpSp->Parameters.DeviceIoControl.IoControlCode) {
    
    case IOCTL_STAT_SET_PARAMETERS:
        if (irpSp->Parameters.DeviceIoControl.InputBufferLength !=
            sizeof( STAT_PARAMETERS )) {
            Status = STATUS_INVALID_PARAMETER_1;
        } else {
            PSTAT_PARAMETERS  Parameters;
            
            Parameters = (PSTAT_PARAMETERS) Irp->AssociatedIrp.SystemBuffer;
            DeviceInstance->InterruptFrequency = Parameters->InterruptFrequency;
            DeviceInstance->QueueType = Parameters->QueueType;
            ExInitializeWorkItem( 
                &DeviceInstance->WorkItem,
                DeviceWorkItem,
                DeviceInstance );
            HwReset( DeviceInstance );
        }
        Status = STATUS_SUCCESS;
        break;

    case IOCTL_STAT_RUN:
        HwRun( DeviceInstance );
        Status = STATUS_SUCCESS;
        break;

    case IOCTL_STAT_STOP:
        HwStop( DeviceInstance );
        Status = STATUS_SUCCESS;
        break;

    case IOCTL_STAT_RETRIEVE_STATS:
    {
        STAT_RETRIEVE_OPERATION RetrieveOperation;
        PULONG                  OutputBuffer;

        if (irpSp->Parameters.DeviceIoControl.InputBufferLength <
                sizeof( STAT_RETRIEVE_OPERATION )) {
            Status = STATUS_INVALID_PARAMETER_1;                
        } else {
            RetrieveOperation = 
                *(PSTAT_RETRIEVE_OPERATION) Irp->AssociatedIrp.SystemBuffer;
            
        }
        
        OutputBuffer =
            (PULONG) MmGetSystemAddressForMdl( Irp->MdlAddress );
            
        switch (RetrieveOperation) {
        
        case StatRetrieveIrqLatency:
        {
            STAT_RETRIEVAL_SYNCPACKET SyncPacket;
            
            SyncPacket.DeviceInstance = DeviceInstance;
            SyncPacket.Irp = Irp;
            SyncPacket.OutputBuffer = OutputBuffer;
            
            KeSynchronizeExecution( 
                DeviceInstance->InterruptObject, 
                CopyIrqLatencies,
                &SyncPacket );
        
            Status = SyncPacket.Status;        
            break;
        }            
        
        case StatRetrieveDpcLatency:
        
            KeAcquireSpinLock( &DeviceInstance->DpcLock, &irqlOld );
            
            DataToCopy =
                DeviceInstance->Counters[ LATENCY_COUNTER_DPC ].Position * 
                    sizeof( ULONG );
                    
            if (irpSp->Parameters.DeviceIoControl.OutputBufferLength <
                    DataToCopy) {
                if (irpSp->Parameters.DeviceIoControl.OutputBufferLength) {
                    Status = STATUS_BUFFER_TOO_SMALL;
                } else {
                    Irp->IoStatus.Information = DataToCopy;
                    Status = STATUS_BUFFER_OVERFLOW;
                }
            } else {
                RtlCopyMemory( 
                    OutputBuffer,
                    DeviceInstance->Counters[ LATENCY_COUNTER_DPC ].Data,
                    DataToCopy );
                DeviceInstance->Counters[ LATENCY_COUNTER_DPC ].Position = 0;
                Irp->IoStatus.Information = DataToCopy;
                Status = STATUS_SUCCESS;
            }
                    
            KeReleaseSpinLock( &DeviceInstance->DpcLock, irqlOld );
            break;
        
        case StatRetrieveWorkItemLatency:
            
            ExAcquireFastMutex( &DeviceInstance->WorkItemMutex );
            
            DataToCopy =
                DeviceInstance->Counters[ LATENCY_COUNTER_WORKITEM ].Position * 
                    sizeof( ULONG );
                    
            if (irpSp->Parameters.DeviceIoControl.OutputBufferLength <
                    DataToCopy) {
                if (irpSp->Parameters.DeviceIoControl.OutputBufferLength) {
                    Status = STATUS_BUFFER_TOO_SMALL;
                } else {
                    Irp->IoStatus.Information = DataToCopy;
                    Status = STATUS_BUFFER_OVERFLOW;
                }
            } else {
                RtlCopyMemory( 
                    OutputBuffer,
                    DeviceInstance->Counters[ LATENCY_COUNTER_WORKITEM ].Data,
                    DataToCopy );
                DeviceInstance->Counters[ LATENCY_COUNTER_WORKITEM ].Position = 0;
                Irp->IoStatus.Information = DataToCopy;
                Status = STATUS_SUCCESS;
            }
                    
            ExReleaseFastMutex( &DeviceInstance->WorkItemMutex );
            
            break;
            
        default:
            Status = STATUS_INVALID_PARAMETER;
            break;
        
        }
    }
    break;
    
    }

    Irp->IoStatus.Status = Status;
    IoCompleteRequest( Irp, IO_NO_INCREMENT );

    return Status;
}

NTSTATUS 
RegisterDevice(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPathName,
    IN PCM_RESOURCE_LIST AllocatedResources,
    OUT PDEVICE_OBJECT* DeviceObject
    )

/*++

Routine Description:


Arguments:
    IN PDRIVER_OBJECT DriverObject -

    IN PUNICODE_STRING RegistryPathName -

    IN PCM_RESOURCE_LIST AllocatedResources -

    OUT PDEVICE_OBJECT* DeviceObject -

Return:

--*/

{
    int             i;
    NTSTATUS        Status;
    PSTAT_DEVINST   DeviceInstance;
    UNICODE_STRING  DeviceName, LinkName;

    RtlInitUnicodeString( &DeviceName, STR_DEVICENAME );
    RtlInitUnicodeString( &LinkName, STR_LINKNAME );
    
    Status = 
        IoCreateDevice( 
            DriverObject, 
            sizeof( STAT_DEVINST ), 
            &DeviceName,
            FILE_DEVICE_UNKNOWN, // IN DEVICE_TYPE DeviceType
            0,                   // IN ULONG DeviceCharacteristics
            FALSE,               // IN BOOLEAN Exclusive,
            DeviceObject );

    if (!NT_SUCCESS( Status )) {
        return Status;
    }        

    DeviceInstance = (PSTAT_DEVINST) (*DeviceObject)->DeviceExtension;
    RtlZeroMemory( DeviceInstance, sizeof( STAT_DEVINST ) );
    DeviceInstance->DeviceObject = *DeviceObject;
    DeviceInstance->Counters[ LATENCY_COUNTER_IRQ ].Data =
        (PULONG) ExAllocatePool( 
            NonPagedPool, 
            sizeof( ULONG ) * MAX_COUNTER_STORAGE * MAX_COUNTERS );
    if (DeviceInstance->Counters[ LATENCY_COUNTER_IRQ ].Data) {
        for (i = 1; i < MAX_COUNTERS; i++) {
            DeviceInstance->Counters[ i ].Data = 
                DeviceInstance->Counters[ i - 1 ].Data + 
                    MAX_COUNTER_STORAGE;
        }
    } else {
        IoDeleteDevice( *DeviceObject );
        return STATUS_INSUFFICIENT_RESOURCES;
    }
    

    Status = 
        IoCreateSymbolicLink( &LinkName, &DeviceName );
    
    if (!NT_SUCCESS( Status )) {
        IoDeleteDevice( *DeviceObject );
        return Status;
    }

    KeInitializeSpinLock( &DeviceInstance->DpcLock );
    ExInitializeFastMutex( &DeviceInstance->WorkItemMutex );
    
    HwInitialize( DeviceInstance, AllocatedResources );

    DriverObject->MajorFunction[ IRP_MJ_CLOSE ] = DispatchClose;
    DriverObject->MajorFunction[ IRP_MJ_CREATE ] = DispatchCreate;
    DriverObject->MajorFunction[ IRP_MJ_DEVICE_CONTROL ] = DispatchIoControl;

    (*DeviceObject)->Flags |= DO_DIRECT_IO;
    (*DeviceObject)->Flags &= ~DO_DEVICE_INITIALIZING;

    return Status;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\ksfilter\tests\irqperf\sys\stat.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1997
//
//  File:       stat.h
//
//--------------------------------------------------------------------------

#define IOCTL_STAT_SET_PARAMETERS   CTL_CODE( FILE_DEVICE_UNKNOWN, 0x000, METHOD_BUFFERED, FILE_WRITE_ACCESS)
#define IOCTL_STAT_RUN              CTL_CODE( FILE_DEVICE_UNKNOWN, 0x001, METHOD_NEITHER, FILE_WRITE_ACCESS | FILE_READ_ACCESS)
#define IOCTL_STAT_STOP             CTL_CODE( FILE_DEVICE_UNKNOWN, 0x002, METHOD_NEITHER, FILE_WRITE_ACCESS | FILE_READ_ACCESS)
#define IOCTL_STAT_RETRIEVE_STATS   CTL_CODE( FILE_DEVICE_UNKNOWN, 0x003, METHOD_OUT_DIRECT, FILE_READ_ACCESS)

//
// Latency measurement operations
//

//
// Measures the latency from the time the interrupt is triggered on the
// hardware until it is serviced in the ISR.  Additionally, measures the time
// to schedule and service a DPC.  Each set of statistics is kept in an 
// individual buffer and returned via IOCTL_STAT_RETRIEVE_STATS.
//
// Measures the latency from the time the work item is queue until it is
// serviced (when the item is queued at DISPATCH_LEVEL).  An interrupt from 
// the STAT triggers the scheduling of the worker item to avoid synchronization 
// with the timer interrupt via a timer Dpc, which would affect the over 
// response to scheduling of the worker thread.
//

#if !defined( _NTDDK_ )
typedef enum _WORK_QUEUE_TYPE {
    CriticalWorkQueue,
    DelayedWorkQueue,
    HyperCriticalWorkQueue,
    MaximumWorkQueue
} WORK_QUEUE_TYPE;
#endif

typedef struct tagSTAT_PARAMETERS {
    ULONG           InterruptFrequency;   // in 250ns units 
    WORK_QUEUE_TYPE QueueType;
    
} STAT_PARAMETERS, *PSTAT_PARAMETERS;

//
// Statistics retrieval
//

// 
// StatRetrieveIrqLatency
//

// 
// StatRetrieveDpcLatency
//

// 
// StatRetrieveWorkItemLatency
//

#define LATENCY_COUNTER_IRQ         0
#define LATENCY_COUNTER_DPC         1
#define LATENCY_COUNTER_WORKITEM    2

typedef enum {
    StatRetrieveIrqLatency = LATENCY_COUNTER_IRQ,
    StatRetrieveDpcLatency = LATENCY_COUNTER_DPC,
    StatRetrieveWorkItemLatency = LATENCY_COUNTER_WORKITEM
    
} STAT_RETRIEVE_OPERATION, *PSTAT_RETRIEVE_OPERATION;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\ksfilter\tests\p5perf\p5cnt.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1996
//
//  File:       p5cnt.c
//
//--------------------------------------------------------------------------

#define  WANTVXDWRAPS

#include <basedef.h>
#include <vmm.h>
#include <vwin32.h>
#include <debug.h>
#include <perf.h>
#include <shell.h>
#include <vcomm.h>
#include <vmmreg.h>
#include <vxdwraps.h>

#include "p5perf.h"
#include "private.h"

#undef CURSEG
#define CURSEG() PCODE
#pragma VxD_PAGEABLE_CODE_SEG
#pragma VxD_PAGEABLE_DATA_SEG

char *aszModes[] =
{
  "Undefined",
  "Kernel",
  "User",
  "Both"
} ;

char *aszEventNames[] =
{
   "data reads",
   "data writes",
   "data TLB misses",
   "data read misses",
   "data write misses",
   "writes (hits) to M or E state lines",
   "data cache lines written back",
   "external snoops",
   "data cache snoop hits",
   "memory accesses in both pipes",
   "bank conflicts",
   "misaligned data memory references",
   "code reads",
   "code TLB misses",
   "code cache misses",
   "any segment register loaded",
   "segment descriptor cache accesses",
   "segment descriptor cache hits",
   "branches",
   "BTB hits",
   "taken branches or BTB hits",
   "pipeline flushes",
   "instructions executed in both pipes",
   "instructions executed in the v-pipe",
   "clocks while bus cycle in progress",
   "pipe stalled by full write buffers",
   "pipe stalled by waiting for data memory reads",
   "pipe stalled by writes to M or E lines",
   "locked bus cycles",
   "I/O read or write cycles",
   "non-cacheable memory references",
   "pipeline stalled by address generation interlock",
   "unknown",
   "unknown",
   "floating point operations",
   "breakpoint matches on DR0 register",
   "breakpoint matches on DR1 register",
   "breakpoint matches on DR2 register",
   "breakpoint matches on DR3 register",
   "hardware interrupts",
   "data reads or data writes",
   "data read misses or data write misses"
} ;

ULONG                 ghPerfServer ;
P5PERFEVENT           gP5Perf[ 2 ] ;

BOOL CDECL P5PERF_Device_Init
(
   HVM   hVM,
   PCHAR pszCmdTail,
   PCRS  pcrs
)
{
   static struct perf_server_0  ps0 ;
   ps0.psrv0_Level = 0 ;
   ps0.psrv0_Flags = 0 ;
   ps0.psrv0_pszServerName = "Pentium Performance" ;
   ps0.psrv0_pszServerNodeName = "P5PERF" ;
   ps0.psrv0_pControlFunc = NULL ;

   ghPerfServer = PERF_Server_Register( &ps0 ) ;

   EnableP5Counter( 0,
                    0x18,
                    P5PERF_MODEF_BOTH,
                    P5PERF_EVENTF_CYCLES |
                       P5PERF_EVENTF_PERFMON ) ;

   EnableP5Counter( 1,
                    0x27,
                    P5PERF_MODEF_BOTH,
                    P5PERF_EVENTF_COUNT |
                       P5PERF_EVENTF_PERFMON ) ;

   return TRUE ;
}

BOOL CDECL P5PERF_System_Exit
(
   HVM   hVM,
   PCRS  pcrs
)
{
   DisableP5Counter( 0 ) ;
   DisableP5Counter( 1 ) ;

   if (ghPerfServer)
   {
      PERF_Server_Deregister( ghPerfServer );
      ghPerfServer = NULL ;
   }

   return TRUE ;
}

ULONG BuildESCR( VOID )
{
   int     i ; 
   USHORT  uCtr[ 2 ] ;

   for (i = 0; i < 2; i++)
   {
      uCtr[ i ] = 0 ;

      if (gP5Perf[ i ].fInUse)
      {
         uCtr[ i ] = (USHORT) gP5Perf[ i ].ulEvent ;
         if (gP5Perf[ i ].fulMode & P5PERF_MODEF_KERNEL)
            uCtr[ i ] |= 0x0040 ;
         if (gP5Perf[ i ].fulMode & P5PERF_MODEF_USER)
            uCtr[ i ] |= 0x0080 ;
         if (gP5Perf[ i ].fulEventType & P5PERF_EVENTF_CYCLES)
            uCtr[ i ] |= 0x0100 ;
      }
   }
   return (((ULONG) uCtr[ 1 ]) << 16 | (ULONG) uCtr[ 0 ]) ;
}

ULONG ReadP5Counter
(
   ULONG hStat
)
{
   ULONG  ulMSR = MSR_COUNTER_0, ulRet ;


   if (hStat != gP5Perf[ 0 ].hStat)
      ulMSR++ ;

   //
   //    mov   ecx, MSR_COUNTER_0
   //    rdmsr
   //
   //    result in edx:eax
   //

   _asm
   {
      _asm  mov   ecx, ulMSR
      _asm  _emit 0x0F
      _asm  _emit 0x32
      _asm  mov   ulRet, eax
   }

   return ulRet ;
}

ULONG EnableP5Counter
(
   ULONG ulP5Counter,
   ULONG ulEvent,
   ULONG fulMode,
   ULONG fulEventType
)
{
   char                       szEventName[ 128 ], szNodeName[ 32 ] ;
   ULONG                      ulESCR ;
   static struct perf_stat_0  ps0 ;

   // Check to see if counter is in use...

   if (gP5Perf[ ulP5Counter ].fInUse)
      return P5PERF_ERROR_INUSE ;

   if ((fulEventType & P5PERF_EVENTF_PERFMON) && !ghPerfServer)
      return P5PERF_ERROR_PERFNOTENA ;

   gP5Perf[ ulP5Counter ].fInUse = TRUE ;
   gP5Perf[ ulP5Counter ].ulEvent = ulEvent ;
   gP5Perf[ ulP5Counter ].fulMode = fulMode ;
   gP5Perf[ ulP5Counter ].fulEventType = fulEventType ;

   ulESCR = BuildESCR() ;

   // set event counter on Pentium

   //
   //    xor   edx, edx
   //    mov   eax, ulESCR ;
   //    mov   ecx, MSR_COUNTER_EVENT
   //    wrmsr
   //

   _asm
   {
      _asm  xor   edx, edx
      _asm  mov   eax, ulESCR
      _asm  mov   ecx, MSR_COUNTER_EVENT
      _asm  _emit 0x0F
      _asm  _emit 0x30
   }

   if (fulEventType & P5PERF_EVENTF_PERFMON)
   {
      ps0.pst0_Level = 0 ;
      ps0.pst0_Flags = PSTF_RATE | PSTF_FUNCPTR ;
      _Sprintf( szEventName, "%s (%s)",
                aszEventNames[ ulEvent ], aszModes[ fulMode ] ) ;
      ps0.pst0_pszStatName = szEventName ;
      _Sprintf( szNodeName, "Event[%d]", ulEvent ) ;
      ps0.pst0_pszStatNodeName = szNodeName ;
      ps0.pst0_pszStatUnitName = NULL ;
      ps0.pst0_pszStatDescription = szEventName ;
      ps0.pst0_pStatFunc = ReadP5Counter ;
      ps0.pst0_ScaleFactor = 0 ;
      gP5Perf[ ulP5Counter ].hStat =
         PERF_Server_Add_Stat( ghPerfServer, &ps0 ) ;
   }
}

ULONG DisableP5Counter
(
   ULONG ulP5Counter
)
{
   ULONG               ulESCR ;

   // Check to see if counter is in use...

   if (!gP5Perf[ ulP5Counter ].fInUse)
      return P5PERF_ERROR_SUCCESS ;

   gP5Perf[ ulP5Counter ].fInUse = FALSE ;

   ulESCR = BuildESCR() ;

   // set event counter on Pentium

   //
   //    xor   edx, edx
   //    mov   eax, ulESCR ;
   //    mov   ecx, MSR_COUNTER_EVENT
   //    wrmsr
   //

   _asm
   {
      _asm  xor   edx, edx
      _asm  mov   eax, ulESCR
      _asm  mov   ecx, MSR_COUNTER_EVENT
      _asm  _emit 0x0F
      _asm  _emit 0x30
   }

   if (ghPerfServer && gP5Perf[ ulP5Counter ].hStat)
   {
      PERF_Server_Remove_Stat( gP5Perf[ ulP5Counter ].hStat ) ;
      gP5Perf[ ulP5Counter ].hStat = NULL ;
   }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\ksfilter\tests\irqperf\sys\private.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1997
//
//  File:       private.h
//
//--------------------------------------------------------------------------

//
// constants
//

#if (DBG)
#define STR_MODULENAME "irqperf: "
#endif

#define STR_DEVICENAME TEXT("\\Device\\Stat")
#define STR_LINKNAME TEXT("\\DosDevices\\Stat")

#define STAT_REG_DATA       0x00
#define STAT_REG_CMD        0x02
#define STAT_REG_INT        0x03

// STAT LD_PTR command:
//
// Used to load the data pointer register with the desired target
// register.  When a LD_PTR command is issued to Am9513, the next
// two bytes accessed through the data register will be to/from
// the target register.

#define STAT_LDPTR                    0x00

#define STAT_CTR1                     0x01
#define STAT_CTR2                     0x02
#define STAT_CTR3                     0x03
#define STAT_CTR4                     0x04
#define STAT_CTR5                     0x05

#define STAT_MODE                     0x00
#define STAT_LOAD                     0x08
#define STAT_HOLD                     0x10

#define STAT_CTL                      0x07

#define STAT_MASTER                   0x10
#define STAT_ALARM1                   0x00
#define STAT_ALARM2                   0x08

// massage target counter (one target only)

#define STAT_SET_TC                   0x0e8
#define STAT_CLR_TC                   0x0e0
#define STAT_STEP                     0x0f0

// interrupt enable modes

#define STAT_IE_ENABLED               0x40
#define STAT_IE_ON                    0x07
#define STAT_IE_SWITCH                0x06
#define STAT_IE_TC5                   0x05
#define STAT_IE_TC4                   0x04
#define STAT_IE_TC3                   0x03
#define STAT_IE_TC2                   0x02
#define STAT_IE_TC1                   0x01
#define STAT_IE_OFF                   0x00

//   STAT board specific commands

#define STAT_LD                       0x40
#define STAT_ARM                      0x20            // start counters
#define STAT_DISARM                   0xc0            // stop counters
#define STAT_SAVE                     0xa0            // save counters
                                      
#define STAT_C1                       0x01
#define STAT_C2                       0x02
#define STAT_C3                       0x04
#define STAT_C4                       0x08
#define STAT_C5                       0x10

#define STAT_RESET                    0xff

// Am9513 timer modes

#define AM9513_TIMER_SOURCE_F5          0x0F00
#define AM9513_TIMER_SOURCE_F4          0x0E00
#define AM9513_TIMER_SOURCE_F3          0x0D00
#define AM9513_TIMER_SOURCE_F2          0x0C00
#define AM9513_TIMER_SOURCE_F1          0x0B00
#define AM9513_TIMER_SOURCE_T5OUT       0x0A00
#define AM9513_TIMER_SOURCE_T4OUT       0x0900
#define AM9513_TIMER_SOURCE_T3OUT       0x0800
#define AM9513_TIMER_SOURCE_T2OUT       0x0700
#define AM9513_TIMER_SOURCE_T1OUT       0x0600
#define AM9513_TIMER_SOURCE_F6          0x0100
#define AM9513_TIMER_SOURCE_TMINUS1OUT  0x0000

#define AM9513_TIMER_CYCLE_REPEAT       0x0020
#define AM9513_TIMER_BASE_BCD           0x0010
#define AM9513_TIMER_DIRECTION_UP       0x0008
#define AM9513_TIMER_OUTPUT_TOGGLED     0x0002
#define AM9513_TIMER_OUTPUT_ACTIVEHIGH  0x0001
#define AM9513_TIMER_OUTPUT_INACTIVE    0x0000


//
// data structures
//

typedef struct tagIO_RESOURCE
{
   ULONG  PortBase;
   ULONG  PortLength;

} IO_RESOURCE;

typedef struct tagIRQ_RESOURCE
{
   ULONG InterruptLevel;
   UCHAR Flags;
   UCHAR ShareDisposition;

} IRQ_RESOURCE;

typedef struct tagDMA_RESOURCE
{
   ULONG DMAChannel;
   UCHAR Flags;
   
} DMA_RESOURCE;

#define MAX_COUNTERS        4
#define MAX_COUNTER_STORAGE (64 * 1024)

typedef struct tagSTAT_LATENCY_COUNTER {
    ULONG   Position;
    PULONG  Data;
} STAT_LATENCY_COUNTER;

typedef struct tagSTAT_DEVINST
{
    PDEVICE_OBJECT          DeviceObject;
    KSPIN_LOCK              DpcLock;
    FAST_MUTEX              WorkItemMutex;
    PHYSICAL_ADDRESS        portPhysicalAddress;
    PKINTERRUPT             InterruptObject;
    KAFFINITY               InterruptAffinity;
    KIRQL                   DIrql;
    ULONG                   InterruptVector;
    ULONG                   InterruptFrequency;
    PUCHAR                  portBase;
    ULONG                   IsrWhileDpc, 
                            DpcPending,
                            WorkItemPending;
    WORK_QUEUE_TYPE         QueueType;
    WORK_QUEUE_ITEM         WorkItem;                            
    STAT_LATENCY_COUNTER    Counters[ MAX_COUNTERS ];                       
                        
} STAT_DEVINST, *PSTAT_DEVINST;

typedef struct {
    PSTAT_DEVINST   DeviceInstance;
    PIRP            Irp;
    PULONG          OutputBuffer;
    NTSTATUS        Status;
} STAT_RETRIEVAL_SYNCPACKET, *PSTAT_RETRIEVAL_SYNCPACKET;

//
// macros
//

#define DEBUGLVL_BLAB    3
#define DEBUGLVL_VERBOSE 2
#define DEBUGLVL_TERSE   1
#define DEBUGLVL_ERROR   0

#if (DBG)
   #if !defined(DEBUG_LEVEL)
   #define DEBUG_LEVEL DEBUGLVL_TERSE
   #endif

   #define _DbgPrintF(lvl, strings) \
{ \
    if ((lvl) <= DEBUG_LEVEL) {\
        DbgPrint(STR_MODULENAME);\
        DbgPrint##strings;\
        DbgPrint("\n");\
        if ((lvl) == DEBUGLVL_ERROR) {\
            DbgBreakPoint();\
        } \
    } \
}
#else // !DBG
   #define _DbgPrintF(lvl, strings)
#endif // !DBG

#ifndef SIZEOF_ARRAY
    #define SIZEOF_ARRAY(ar)        (sizeof(ar)/sizeof((ar)[0]))
#endif // !defined(SIZEOF_ARRAY)

//
// prototypes
//

// device.c: 

VOID 
DeviceDpc(
    IN PKDPC Dpc,
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    );

BOOLEAN 
DeviceIsr(
    IN PKINTERRUPT Interrupt,
    IN PVOID Context
    );

NTSTATUS 
RegisterDevice(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPathName,
    IN PCM_RESOURCE_LIST AllocatedResources,
    OUT PDEVICE_OBJECT* DeviceObject
    );

//---------------------------------------------------------------------------
//  End of File: private.h
//---------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\ksfilter\tests\p5perf\p5perf.asm ===
.386p

        .xlist
        include vmm.inc
        include debug.inc
        .list

;==============================================================================
;             V I R T U A L   D E V I C E   D E C L A R A T I O N
;==============================================================================

Declare_Virtual_Device p5perf, 4, 0, P5PERF_Control, Undefined_Device_ID,\
                       Undefined_Init_Order,,,

VxD_PAGEABLE_CODE_SEG

BeginProc P5PERF_Device_Init

        cCall   _P5PERF_Device_Init, <ebx, esi, ebp>
        or      eax, eax
        jz      SHORT PDI_Error
        clc
        ret     

PDI_Error:
        stc
        ret

EndProc P5PERF_Device_Init

BeginProc P5PERF_System_Exit
        
        cCall   _P5PERF_System_Exit, <ebx, ebp>
        or      eax, eax
        jz      SHORT PSE_Error
        clc
        ret     

PSE_Error:
        stc
        ret

EndProc P5PERF_System_Exit

VxD_PAGEABLE_CODE_ENDS

VxD_LOCKED_CODE_SEG

;----------------------------------------------------------------------------
;
;   P5PERF_Control
;
;   DESCRIPTION:
;       Dispatch control messages to the correct handlers. Must be in locked
;       code segment. (All VxD segments are locked in 3.0 and 3.1)
;
;   ENTRY:
;       EAX = Message
;       EBX = VM that the message is for
;       All other registers depend on the message.
;
;   EXIT:
;       Carry clear if no error (or we don't handle the message), set
;       if something bad happened and the message can be failed.
;
;   USES:
;       All registers.
;
;----------------------------------------------------------------------------

BeginProc P5PERF_Control

        Control_Dispatch Device_Init,             P5PERF_Device_Init
        Control_Dispatch System_Exit,             P5PERF_System_Exit

        clc
        ret

EndProc P5PERF_Control

VxD_LOCKED_CODE_ENDS

end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\ksfilter\tests\p5perf\private.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1996
//
//  File:       private.h
//
//--------------------------------------------------------------------------

#define MSR_COUNTER_EVENT 0x11
#define MSR_COUNTER_0     0x12
#define MSR_COUNTER_1     0x13

extern ULONG ghPerfServer ;


ULONG EnableP5Counter
(
   ULONG ulP5Counter,
   ULONG ulEvent,
   ULONG fulMode,
   ULONG fulEventType
) ;

ULONG DisableP5Counter
(
   ULONG ulP5Counter
) ;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\ksfilter\tests\kcomtest\kcomtest.cpp ===
/*++

Copyright (C) Microsoft Corporation, 1997 - 1998

Module Name:

    kcomtest.cpp

Abstract:

    Kernel COM Test

--*/

#include <unknown.h>
#include <kcom.h>
#if (DBG)
#define STR_MODULENAME "kcomtest: "
#endif
#include <ksdebug.h>

DEFINE_GUIDSTRUCT("93E09387-5479-11D1-9AA1-00A0C9223196", TestObjectClass);

class CKCOMTest : CBaseUnknown, public IUnknown {
public:
    CKCOMTest(IUnknown* UnkOuter OPTIONAL, NTSTATUS* Status);
    ~CKCOMTest();

    // Implement IUnknown
    DEFINE_STD_UNKNOWN();
};

#ifdef ALLOC_PRAGMA
#pragma code_seg("PAGE")
#endif // ALLOC_PRAGMA


CKCOMTest::CKCOMTest(
    IUnknown* UnkOuter OPTIONAL,
    NTSTATUS* Status
    ) :
    CBaseUnknown(
        __uuidof(TestObjectClass),
        UnkOuter)
/*++

Routine Description:

    The constructor for this object class. Initializes the object.

Arguments:

    UnkOuter -
        Optionally contains the outer IUnknown to use when querying
        for interfaces.

    Status -
        The place in which to put the final status of initialization.

Return Values:

    Returns a pointer to the object.

--*/
{
    _DbgPrintF(DEBUGLVL_TERSE, ("CKOMTest"));
    *Status = STATUS_SUCCESS;
}


CKCOMTest::~CKCOMTest(
    )
/*++

Routine Description:

    The destructor for this object class.

Arguments:

    None.

Return Values:

    Nothing.

--*/
{
    _DbgPrintF(DEBUGLVL_TERSE, ("~CKOMTest"));
    //
    // Clean up resources.
    //
}


STDMETHODIMP
CKCOMTest::NonDelegatedQueryInterface(
    REFIID InterfaceId,
    PVOID* Interface
    )
/*++

Routine Description:

    Overrides CBaseUnknown::NonDelegatedQueryInterface. Queries for the specified
    interface, and increments the reference count on the object.

Arguments:

    InterfaceId -
        The identifier of the interface to return.

    Interface -
        The place in which to put the interface being returned.

Return Values:

    Returns STATUS_SUCCESS if the interface requested is supported, else
    STATUS_INVALID_PARAMETER.

--*/
{
    _DbgPrintF(DEBUGLVL_TERSE, ("NonDelegatedQueryInterface"));
    //
    // Other interfaces are supported here, and just use AddRef().
    // IUnknown is not directly supported through this method, only
    // through the CBaseUnknown::NonDelegatedQueryInterface.
    //
    return CBaseUnknown::NonDelegatedQueryInterface(InterfaceId, Interface);
}

IMPLEMENT_STD_UNKNOWN(CKCOMTest)


extern "C"
NTSTATUS
CreateObjectHandler(
    IN REFCLSID ClassId,
    IN IUnknown* UnkOuter OPTIONAL,
    IN REFIID InterfaceId,
    OUT PVOID* Interface
    )
/*++

Routine Description:

    This entry point is used to create an object of the class supported by this
    module. The entry point is registered in DriverEntry so that the built-in
    default processing can be used to acquire this entry point when the module
    is loaded by KCOM.

Arguments:

    ClassId -
        The class of object to create. This must be TestObjectClass.

    UnkOuter -
        Optionally contains the outer IUnknown interface to use.

    InterfaceId -
        Contains the interface to return on the object created. The test
        object only supports IUnknown.

    Interface -
        The place in which to return the interface on the object created.

Return Values:

    Returns STATUS_SUCCESS if the object is created and the requested
    interface is returned, else an error.

--*/
{
    CKCOMTest*  COMTest;
    NTSTATUS    Status;

    _DbgPrintF(DEBUGLVL_TERSE, ("CreateObjectHandler"));
    //
    // Ensure that the requested object class is supported.
    //
    if (!IsEqualGUIDAligned(__uuidof(TestObjectClass), ClassId)) {
        return STATUS_INVALID_DEVICE_REQUEST;
    }
    //
    // Create an object of the requested type. Since the server knows
    // what the object can do, it knows what type of pool must be
    // used to store the object created. In this case PagedPool
    //
    COMTest = new(PagedPool) CKCOMTest(UnkOuter, &Status);
    if (COMTest) {
        //
        // The object was allocated, but initialization may have
        // failed.
        //
        if (NT_SUCCESS(Status)) {
            //
            // Attempt to return the requested interface on the
            // object.
            //
            Status = COMTest->NonDelegatedQueryInterface(InterfaceId, Interface);
            if (!NT_SUCCESS(Status)) {
                //
                // The interface was not supported. Just delete the
                // object without calling Release().
                //
                delete COMTest;
            }
        } else {
            //
            // Object initialization failed. Just delete the
            // object without calling Release().
            //
            delete COMTest;
        }
    } else {
        Status = STATUS_INSUFFICIENT_RESOURCES;
    }
    return Status;
}

#ifdef ALLOC_PRAGMA
#pragma code_seg("INIT")
#endif // ALLOC_PRAGMA


extern "C"
NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPathName
    )
/*++

Routine Description:

    Sets up the driver object by calling the default KCOM initialization.

Arguments:

    DriverObject -
        Driver object for this instance.

    RegistryPathName -
        Contains the registry path which was used to load this instance.

Return Values:

    Returns STATUS_SUCCESS if the driver was initialized.

--*/
{
    _DbgPrintF(DEBUGLVL_TERSE, ("DriverEntry"));
    //
    // Initialize the driver entry points to use the default Irp processing
    // code. Pass in the create handler for objects supported by this module.
    //
    return KoDriverInitialize(DriverObject, RegistryPathName, CreateObjectHandler);
}

#ifdef ALLOC_PRAGMA
#pragma code_seg()
#endif // ALLOC_PRAGMA
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\net\irda\irsir\sources.inc ===
MAJORCOMP=setup
MINORCOMP=infs

TARGETNAME=inf
TARGETPATH=obj
TARGETTYPE=notarget
SOURCES=
NTTARGETFILES=

MISCFILES = \
    $(O)\netirsir.inf
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\net\irda\irsir\makefile.inc ===
PLATFORM_SWITCH=$(TARGET_DIRECTORY)
!IF "$(ALT_PROJECT)" == "NEC_98"
PLATFORM_SWITCH =nec98
!ENDIF

_LNG=..\..\$(LANGUAGE)
_INX=..\..
STAMP=stampinf -f

$(O)\netirsir.inf: $(_INX)\netirsir.inx $(_LNG)\netirsir.txt
    copy $(_INX)\$(@B).inx+$(_LNG)\$(@B).txt $(@B).tmp
    $(STAMP) $(@B).tmp
    prodfilt $(@B).tmp $@ +$(PLATFORM_SWITCH)
    @del $(@B).tmp
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\net\irda\irsir\daytona\brinf\makefile.inc ===
LANGUAGE=br

!include ..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\ksfilter\tests\p5perf\p5perf.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1996
//
//  File:       p5perf.h
//
//--------------------------------------------------------------------------

#define P5PERF_COUNTER_COUNTER0 0x00000000
#define P5PERF_COUNTER_COUNTER1 0x00000001

#define P5PERF_MODEF_UNDEFINED  0x00000000
#define P5PERF_MODEF_KERNEL     0x00000001
#define P5PERF_MODEF_USER       0x00000002
#define P5PERF_MODEF_BOTH       0x00000003

#define P5PERF_EVENTF_UNDEFINED 0x00000000
#define P5PERF_EVENTF_CYCLES    0x00000001
#define P5PERF_EVENTF_COUNT     0x00000002
#define P5PERF_EVENTF_PERFMON   0x00000004

#define P5PERF_ERROR_SUCCESS    0x00000000
#define P5PERF_ERROR_INUSE      0x00000001
#define P5PERF_ERROR_PERFNOTENA 0x00000002

typedef struct
{
   BOOL   fInUse ;
   ULONG  ulEvent, fulMode, fulEventType, hStat ;

} P5PERFEVENT, *PP5PERFEVENT ;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\net\irda\irsir\daytona\chsinf\makefile.inc ===
LANGUAGE=CHS

!include ..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\net\irda\irsir\daytona\chtinf\makefile.inc ===
LANGUAGE=CHT

!include ..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\net\irda\irsir\daytona\dainf\makefile.inc ===
LANGUAGE=da

!include ..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\net\irda\irsir\daytona\elinf\makefile.inc ===
LANGUAGE=el

!include ..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\net\irda\irsir\daytona\esinf\makefile.inc ===
LANGUAGE=es

!include ..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\net\irda\irsir\daytona\csinf\makefile.inc ===
LANGUAGE=cs

!include ..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\net\irda\irsir\daytona\fiinf\makefile.inc ===
LANGUAGE=fi

!include ..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\net\irda\irsir\daytona\frinf\makefile.inc ===
LANGUAGE=fr

!include ..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\net\irda\irsir\daytona\gerinf\makefile.inc ===
LANGUAGE=GER

!include ..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\net\irda\irsir\daytona\huinf\makefile.inc ===
LANGUAGE=hu

!include ..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\net\irda\irsir\daytona\itinf\makefile.inc ===
LANGUAGE=it

!include ..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\net\irda\irsir\daytona\jpninf\makefile.inc ===
LANGUAGE=JPN

!include ..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\net\irda\irsir\daytona\necinf\makefile.inc ===
LANGUAGE=JPN

!include ..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\net\irda\irsir\daytona\noinf\makefile.inc ===
LANGUAGE=no

!include ..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\net\irda\irsir\daytona\plinf\makefile.inc ===
LANGUAGE=pl

!include ..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\net\irda\irsir\daytona\psuinf\makefile.inc ===
LANGUAGE=psu

!include ..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\net\irda\irsir\daytona\nlinf\makefile.inc ===
LANGUAGE=nl

!include ..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\net\irda\irsir\daytona\ptinf\makefile.inc ===
LANGUAGE=pt

!include ..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\net\irda\irsir\daytona\ruinf\makefile.inc ===
LANGUAGE=ru

!include ..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\net\irda\irsir\daytona\trinf\makefile.inc ===
LANGUAGE=tr

!include ..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\net\irda\irsir\daytona\usainf\makefile.inc ===
!include ..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\net\irda\irsir\daytona\svinf\makefile.inc ===
LANGUAGE=sv

!include ..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\net\irda\mknet\inf\makefile.inc ===
!IFNDEF LANGUAGE
LANGUAGE=usa
!ENDIF

_LNG=$(LANGUAGE)
_INX=.
STAMP=stampinf -f $@

$(O)\IRMK7W2K.INF: $(_INX)\IRMK7W2K.inx $(_LNG)\IRMK7W2K.txt
    copy $(_INX)\$(@B).inx+$(_LNG)\$(@B).txt $@
    $(STAMP)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\net\irda\irsir\daytona\tstinf\makefile.inc ===
LANGUAGE=TST

!include ..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\net\irda\mknet\sys\dbg.c ===
/*****************************************************************************
 **																			**
 **	COPYRIGHT (C) 2000, 2001 MKNET CORPORATION								**
 **	DEVELOPED FOR THE MK7100-BASED VFIR PCI CONTROLLER.						**
 **																			**
 *****************************************************************************/

/**********************************************************************

Module Name:
	DBG.C

Routines:
	MyLogEvent
	MyLogPhysEvent
	DbgInterPktTimeGap
	DbgTestInit
	MK7DbgTestIntTmo

**********************************************************************/

#include	"precomp.h"
#pragma		hdrstop
#include	"protot.h"


#define LOG_LENGTH 1000


#if DBG


UINT	DbgLogIndex = 0;
char	*DbgLogMsg[LOG_LENGTH] = {0};
ULONG	DbgLogVal[LOG_LENGTH] = {0};

// This to keep track of the phy buffs
ULONG	DbgLogTxPhysBuffs[DEF_TCB_CNT];
ULONG	DbgLogRxPhysBuffs[CalRpdSize(DEF_RCB_CNT)];
UINT	DbgLogTxPhysBuffsIndex = 0;
UINT	DbgLogRxPhysBuffsIndex = 0;


// Globals to ease debugging
UINT		GDbgDataSize=0;
MK7DBG_STAT	GDbgStat;
ULONG		GDbgSleep=0;

LONGLONG	GDbgTACmdTime[1000];
LONGLONG	GDbgTARspTime[1000];
LONGLONG	GDbgTATime[1000];
UINT		GDbgTATimeIdx;



//----------------------------------------------------------------------
// Procedure:		[MyLogEvent]
//
// Description:	Log to our arrary.
//
//----------------------------------------------------------------------
VOID MyLogEvent(char *msg, ULONG val)
{

//	NdisGetCurrentSystemTime((PLARGE_INTEGER)&DbgLog[DbgLogIndex].usec);

	DbgLogMsg[DbgLogIndex] = msg;
	DbgLogVal[DbgLogIndex] = val;
	DbgLogIndex++;
	DbgLogIndex %= LOG_LENGTH;
}



//----------------------------------------------------------------------
// Procedure:		[MyLogPhysEvent]
//
// Description:	Log to our arrary.

//----------------------------------------------------------------------
VOID MyLogPhysEvent(ULONG *logarray, UINT *index, ULONG val)
{
	logarray[*index] = val;
	(*index)++;
}


//----------------------------------------------------------------------
//	Procedure:		Time gap between successive sends.
//----------------------------------------------------------------------
VOID	DbgInterPktTimeGap()
{
	NdisMSleep(GDbgSleep);
}



//----------------------------------------------------------------------
// Procedure:	[DbgTestInit]
//
// Description:	Initialized the test context.
//
//-----------------------------------------------------------------------
VOID DbgTestInit(PMK7_ADAPTER Adapter)
{
	UINT	i;

	//************************************************************
	// The start of this routine is to facilitate debugging. We create
	// canned debug/test settings so we don't have to manually change
	// variables in debugger. However, tests not covered by the hardcoded
	// settings still need to be manually set.
	//
	// 2 main functions happen here to help w/ test/debug:
	//	1. Desired fields in the Adapter struct are extracted here and
	//		displayed so we don't have to manually look at these fields.
	//  2. Setup debug/test fields in Adapter.
	//************************************************************


	//************************************************************
	//
	// Set DbgTest here to run canned tests.
	//
	//************************************************************

	//++++++++++++++++++++++++++++++
	// Hardcode something to ease debug.
	Adapter->DbgTest = 0;
	//++++++++++++++++++++++++++++++


	if (Adapter->DbgTest == 0)
		return;

	switch(Adapter->DbgTest) {
	//
	// Tests 1-5 all need Loopback turned on at startup.
	//

	case 1:
		Adapter->LBPktLevel = 1;
		Adapter->DbgTestDataCnt = GDbgDataSize;
		break;

	case 2:
		Adapter->LBPktLevel = 4;
		break;

	case 3:
		Adapter->LBPktLevel = 15;
		break;

	case 4:
		Adapter->LBPktLevel = 32;
		break;

	case 5:
		Adapter->LBPktLevel = 4;
		break;

	case 6:
		Adapter->LBPktLevel = 1;
		Adapter->DbgTestDataCnt = GDbgDataSize;
		break;

	case 7:
		Adapter->LBPktLevel = 0;
		Adapter->DbgTestDataCnt = GDbgDataSize;
		break;

	default:
		// anything else we're not running any tests
		break;
	}

	NdisZeroMemory(&GDbgStat, sizeof(MK7DBG_STAT));


	// Use our timer to simulate TX/RX (this to basically tests
	// my interrupt handling logic while hw interrupt is not yet
	// working. (May be used for other tests.)
	// Always set it up but we may not use it.
//	NdisMInitializeTimer(&Adapter->MK7DbgTestIntTimer,
//						Adapter->MK7AdapterHandle,
//						(PNDIS_TIMER_FUNCTION) MK7DbgTestIntTmo,
//						(PVOID) Adapter);


	for (i=0; i<1000; i++) {
		GDbgTACmdTime[i] = 0;
		GDbgTARspTime[i] = 0;
		GDbgTATime[i] = 0;
	}

	GDbgTATimeIdx = 0;

}


//----------------------------------------------------------------------
// Procedure:	[MK7DbgTestIntTmo]
//
// Description:	Process a test interrupt time out.
//
// (NOTE: This was used to test the TEST_Int bit when hw interrupt was
// not fully working. This function is no longer needed. It's here as
// as example on how to process an NDIS timer.)
//-----------------------------------------------------------------------
VOID MK7DbgTestIntTmo(PVOID sysspiff1,
				NDIS_HANDLE MiniportAdapterContext,
				PVOID sysspiff2,
				PVOID sysspiff3)
{
	PMK7_ADAPTER	Adapter;
	UINT	tcbidx;
	PTCB	tcb;
	PRCB	rcb;
	UINT	testsize;
	PUCHAR	dst, src;

	Adapter = PMK7_ADAPTER_FROM_CONTEXT_HANDLE(MiniportAdapterContext);

	MK7DisableInterrupt(Adapter);

    NdisAcquireSpinLock(&Adapter->Lock);

	// Find the tcb-trd being sent. We just go back one becuase after
	// the send this gets incremented.
	if (Adapter->nextAvailTcbIdx == 0) {
		tcbidx = Adapter->NumTcb - 1;
	}
	else {
		tcbidx = Adapter->nextAvailTcbIdx - 1;
	}

	tcb = Adapter->pTcbArray[tcbidx];
	rcb = Adapter->pRcbArray[Adapter->nextRxRcbIdx];


	// Copy from TX buff to RX buff
	src = tcb->buff;
	dst = rcb->rpd->databuff;
	testsize = tcb->PacketLength;
	NdisMoveMemory(dst, src, testsize);
	
	// now the RX ring buffer fields -- count
	rcb->rrd->count = tcb->trd->count;
	// now make sure the ownerships go to the drv
	GrantTrdToDrv(tcb->trd);
	GrantRrdToDrv(rcb->rrd);

    NdisReleaseSpinLock(&Adapter->Lock);

	MK7Reg_Write(Adapter, R_INTS, 0x0004);
}

#endif // DBG end bracket
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\net\irda\mknet\sys\dbg.h ===
/*****************************************************************************
 **																			**
 **	COPYRIGHT (C) 2000, 2001 MKNET CORPORATION								**
 **	DEVELOPED FOR THE MK7100-BASED VFIR PCI CONTROLLER.						**
 **																			**
 *****************************************************************************/

/**********************************************************************

Module Name:
	DBG.H

**********************************************************************/

#ifndef _DBG_H
#define _DBG_H


// Statistics should eventually go in the adapter struct.
typedef struct MK7DBG_STAT {
	UINT	isrCnt;
	// TX
	UINT	txIsrCnt;
	UINT	txSndCnt;		// call to our send
	UINT	txComp;			// TX processed w/ int bit set
	UINT	txCompNoInt;	// TX processed w/o int bit set
	UINT	txNoTcb;
	UINT	txProcQ;		// processed Q'd entry
	UINT	txSkipPoll;		// master side skipped a poll because no tcb's
	UINT	txLargestPkt;
	UINT	txSlaveStuck;
	UINT	txErrCnt;
	UINT	txErr;
	// RX
	UINT	rxIsrCnt;
	UINT	rxComp;
	UINT	rxCompNoInt;
	UINT	rxNoRpd;
	UINT	rxPktsInd;
	UINT	rxPktsRtn;
	UINT	rxLargestPkt;
	UINT	rxErrCnt;
	UINT	rxErr;
	UINT	rxErrSirCrc;
} MK7DBG_STAT;



#if DBG

extern	MK7DBG_STAT		GDbgStat;
extern	VOID			MyLogEvent(char *, ULONG);
extern	LONGLONG		GDbgTACmdTime[];	// command sent
extern	LONGLONG		GDbgTARspTime[];	// response received
extern	LONGLONG		GDbgTATime[];		// turnaround time
extern	UINT			GDbgTATimeIdx;
extern	VOID			MyLogPhysEvent(ULONG *, UINT *, ULONG);
extern	ULONG			DbgLogTxPhysBuffs[];
extern	ULONG			DbgLogRxPhysBuffs[];
extern	UINT			DbgLogTxPhysBuffsIndex;
extern	UINT			DbgLogRxPhysBuffsIndex;
#define	LOGTXPHY(V)		{MyLogPhysEvent(DbgLogTxPhysBuffs, &DbgLogTxPhysBuffsIndex, V);}
#define	LOGRXPHY(V)		{MyLogPhysEvent(DbgLogRxPhysBuffs, &DbgLogRxPhysBuffsIndex, V);}


//
// __FUNC__[] is the the built-in variable to hold a string, usually
// the name of the function we're currently in. Here the macro sets
// the variable so calls to DbgPrint later will print out the function
// name.
//
// The variables __FILE__ and __LINE__ are used similarly. But these
// 2 are set automatically.

#define DBGFUNC(__F)         static const char __FUNC__[] = __F;; \
						{DbgPrint("%s: \n", __FUNC__);}
#define DBGLINE(S)		{DbgPrint("%s:%d - ", __FILE__, __LINE__);DbgPrint S;}
#define	DBGSTR(S)		DbgPrint S;
#define	DBGSTATUS1(S,I)	DbgPrint (S, I)		// B3.1.0-pre
#define DBGLOG(S, V)	{MyLogEvent(S, V);}

#endif	// DBG



#if !DBG
#define	DBGLOG(S,V)
#define DBGFUNC(__F);
#define DBGLINE(S);
#define	DBGSTR(S);
#define	DBGSTR1(S, I);
#define	LOGTXPHY(V)
#define	LOGRXPHY(V)

#undef	ASSERT
#define	ASSERT(x)
#endif	// !DBG


#define	LOOPBACK_NONE	0
#define	LOOPBACK_SW		1
#define	LOOPBACK_HW		2


#endif      // DBG_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\net\irda\mknet\sys\mk7.h ===
/*****************************************************************************
 **																			**
 **	COPYRIGHT (C) 2000, 2001 MKNET CORPORATION								**
 **	DEVELOPED FOR THE MK7100-BASED VFIR PCI CONTROLLER.						**
 **																			**
 *****************************************************************************/

/**********************************************************************

Module Name:
	MK7.H

Comments:
	Include file for the MK7100 controller. Also includes Phoenix stuff.
	

**********************************************************************/

#ifndef	_MK7_H
#define	_MK7_H

#include	<ndis.h>


#define	MK7REG	USHORT


#define	PHOENIX_REG_CNT		0x34	// 52
#define	PHOENIX_REG_SIZE	2		// 2 bytes
#define	MK7_IO_SIZE			(PHOENIX_REG_CNT * PHOENIX_REG_SIZE)
//#define MISC_REG_CNT		4
//#define MISC_REG_SIZE		2
//#define MK7_IO_SIZE		( (PHOENIX_REG_CNT * PHOENIX_REG_SIZE) + \
//							  (MISC_REG_CNT * MISC_REG_SIZE) )




//******************************
// Phoenix Definitions
//******************************

//
// Registers
//

#define	REG_BASE				0x00000000

#define	REG_RPRB_OFFSET			0x00	// Ring Pointer Readback
#define	REG_RBAU_OFFSET			0x02	// Ring Base Addr - Upper
#define	REG_RBAL_OFFSET			0x04	// Ring Base Addr - Lower
#define	REG_RSIZ_OFFSET			0x06	// Ring Size
#define	REG_PRMT_OFFSET			0x08	// PROMPT
#define	REG_ACMP_OFFSET			0x0A	// Addr Compare
#define	REG_TXCL_OFFSET			0x0C	// Clear TX Interrupt
#define	REG_RXCL_OFFSET			0x0D	// Clear RX Interrupt
#define	REG_CFG0_OFFSET			0x10	// Config Reg 0 (IR Config Reg 0)
#define	REG_SFLG_OFFSET			0x12	// SIR Flag
#define	REG_ENAB_OFFSET			0x14	// Enable
#define	REG_CPHY_OFFSET			0x16	// Config to Physical
#define	REG_CFG2_OFFSET			0x18	// Phy Config Reg 2 (IRCONFIG2)
#define	REG_MPLN_OFFSET			0x1A	// Max Packet Length
#define	REG_RCNT_OFFSET			0x1C	// Recv Byte Count
#define	REG_CFG3_OFFSET			0x1E	// Phy Config Reg 3 (IRCONFIG3)
#define REG_INTS_OFFSET			0x30	// Interrupt Status
#define	REG_GANA_OFFSET			0x31	// General & Analog Transceiver Control // B3.1.0-pre


#define	R_RPRB			(REG_BASE + REG_RPRB_OFFSET)
#define	R_RBAU			(REG_BASE + REG_RBAU_OFFSET)
#define	R_RBAL			(REG_BASE + REG_RBAL_OFFSET)
#define	R_RSIZ			(REG_BASE + REG_RSIZ_OFFSET)
#define	R_PRMT			(REG_BASE + REG_PRMT_OFFSET)
#define	R_ACMP			(REG_BASE + REG_ACMP_OFFSET)
#define R_TXCL			(REG_BASE + REG_TXCL_OFFSET)
#define R_RXCL			(REG_BASE + REG_RXCL_OFFSET)
#define	R_CFG0			(REG_BASE + REG_CFG0_OFFSET)
#define	R_SFLG			(REG_BASE + REG_SFLG_OFFSET)
#define	R_ENAB			(REG_BASE + REG_ENAB_OFFSET)
#define	R_CPHY			(REG_BASE + REG_CPHY_OFFSET)
#define	R_CFG2			(REG_BASE + REG_CFG2_OFFSET)
#define	R_MPLN			(REG_BASE + REG_MPLN_OFFSET)
#define	R_RCNT			(REG_BASE + REG_RCNT_OFFSET)
#define	R_CFG3			(REG_BASE + REG_CFG3_OFFSET)
#define	R_INTS			(REG_BASE + REG_INTS_OFFSET)
#define R_GANA			(REG_BASE + REG_GANA_OFFSET)


// Use the above definitions for register access or the
// following structure.
//
// (NOTE: This is useful if we used memory mapped access to the registers.)
//
//typedef struct _MK7REG {
//	USHORT	MK7REG_RPRB;
//	USHORT	MK7REG_RBAU;
//	USHORT	MK7REG_RBAL;
//	USHORT	MK7REG_RSIZ;
//	USHORT	MK7REG_RPMP;
//	USHORT	MK7REG_ACMP;
//	USHORT	MK7REG_CFG0;
//	USHORT	MK7REG_SFLG;
//	USHORT	MK7REG_ENAB;
//	USHORT	MK7REG_CPHY;
//	USHORT	MK7REG_CFG2;
//	USHORT	MK7REG_MPLN;
//	USHORT	MK7REG_RCNT;
//	USHORT	MK7REG_CFG3;
//	USHORT	MK7REG_INTM;
//	USHORT	MK7REG_INTE;
//} MK7REG, PMK7REG;



//
// Ring Entry Formats
//
// (A Ring entry is referred to as TRD (Transmit Ring Descriptor) &
// RRD (Receive Ring Descriptor)).
//

typedef	struct TRD {
	unsigned	count:16;
	unsigned	unused:8;
	unsigned	status:8;
	unsigned	addr:32;
} TRD, *PTRD;


typedef struct RRD {
	unsigned	count:16;
	unsigned	unused:8;
	unsigned	status:8;
	unsigned	addr:32;
} RRD, *PRRD;


// Bit mask definitions for the TX and RX Ring Buffer Descriptor Status field.
#define B_TRDSTAT_UNDER			0x01	// underrun
#define B_TRDSTAT_CLRENTX		0x04	// R/W REQ_TO_CLEAR_ENTX
#define B_TRDSTAT_FORCEUNDER	0x08	// R/W FORCE_UNDERRUN
#define B_TRDSTAT_NEEDPULSE		0x10	// R/W NEED_PULSE
#define B_TRDSTAT_BADCRC		0x20	// R/W BAD_CRC
#define B_TRDSTAT_DISTXCRC		0x40	// R/W DISTX-CRC
#define B_TRDSTAT_HWOWNS		0x80	// R/W HW OWNS

#define B_RRDSTAT_SIRBAD		0x04	// R SIR BAD (if SIR Filter is on)
#define B_RRDSTAT_OVERRUN		0x08	// R RCV FIFO overflow
#define B_RRDSTAT_LEN			0x10	// R Max length packet encountered
#define B_RRDSTAT_CRCERR		0x20	// R CRC_ERROR (16- or 32-bit)
#define B_RRDSTAT_PHYERR		0x40	// R PHY_ERROR (encoding error)
#define B_RRDSTAT_HWOWNS		0x80	// R/W HW OWNS

#define	B_CFG0_ENRX				0x0800	// ENTX - enable TX	[R_CFG0]
#define	B_CFG0_ENTX				0x1000	// ENRX - enable RX [R_CFG0]
#define	B_CFG0_INVTTX			0x0002	// INVERTTX


// Bits for TX & RX interrupt enable mask and Interrupt Status registers
// [R_INTS] (@ 0x30)
#define	B_TX_INTS				0x0001	// TX_int (bit 0) [R_INTS]
#define B_RX_INTS				0x0002	// RX_int (bit 1) [R_INTS]
#define B_TEST_INTS				0x0004	// TEST_int for testing (R/W)

// Enable RX & TX interrupts
#define	B_ENAB_INT				0x0100	// Enable/Dislabe both RX/TX interrupt (bit 8)
										// [R_CFG3]


// Bits in IR Enable Reg [R_ENAB] (@ 0x14)
#define	B_ENAB_IRENABLE		0x8000		// IR_ENABLE (bit 15) [R_ENAB]


// B3.1.0-pre This bit mask (0x0020) was set wrong.
// Bit for >SIR TX  (fast = >SIR)
#define	B_FAST_TX			0x0200		// IRCONFIG (bit 9) -- bit set to 0 - SIR
										//                  --     set to 1 - >SIR

// B3.1.0-pre New SEL0/1 power level control
#define B_GANA_SEL01		0x0003		// Bits 0 (SEL0) & 1 (SEL1)


// Ring Size settings
#define	RINGSIZE_4				0x00
#define	RINGSIZE_8				0x01
#define	RINGSIZE_16				0x03
#define	RINGSIZE_32				0x07
#define	RINGSIZE_64				0x0F

#define	RINGSIZE_RX4			(RINGSIZE_4  << 8)
#define	RINGSIZE_RX8			(RINGSIZE_8  << 8)
#define	RINGSIZE_RX16			(RINGSIZE_16 << 8)
#define	RINGSIZE_RX32			(RINGSIZE_32 << 8)
#define	RINGSIZE_RX64			(RINGSIZE_64 << 8)
#define	RINGSIZE_TX4			(RINGSIZE_4  << 12)
#define	RINGSIZE_TX8			(RINGSIZE_8  << 12)
#define	RINGSIZE_TX16			(RINGSIZE_16 << 12)
#define	RINGSIZE_TX32			(RINGSIZE_32 << 12)
#define	RINGSIZE_TX64			(RINGSIZE_64 << 12)


// Set IrDA speeds to IRCONFIG2
#define HW_SIR_SPEED_2400		((47<<10) |  (12<<5))
#define HW_SIR_SPEED_9600		((11<<10) |  (12<<5))
#define HW_SIR_SPEED_19200		((5<<10)  |  (12<<5))
#define HW_SIR_SPEED_38400		((2<<10)  |  (12<<5))
#define HW_SIR_SPEED_57600		((1<<10)  |  (12<<5))
#define HW_SIR_SPEED_115200		((12<<5))
// Additional defs
#define	HW_MIR_SPEED_576000		((1<<10)  |  (16<<5))
#define	HW_MIR_SPEED_1152000	((8<<5))


// RRD Macros
#define GrantRrdToHw(x)		(x->status = B_RRDSTAT_HWOWNS)
#define GrantTrdToHw(x)		(x->status = B_TRDSTAT_HWOWNS)
#define GrantRrdToDrv(x)	(x->status &= ~B_RRDSTAT_HWOWNS)
#define GrantTrdToDrv(x)	(x->status &= ~B_TRDSTAT_HWOWNS)
#define	HwOwnsRrd(x)		((x->status & B_RRDSTAT_HWOWNS))
#define HwOwnsTrd(x)		((x->status & B_TRDSTAT_HWOWNS))

#define	RrdError(x)			(x->status & 0x6C)		// PHY_ERROR, CRC_ERROR, Rx Overrun, Rx SIRBAD

#define	RrdAnyError(x)		(x->status & 0x7C)		// Any error at all (for debug)
#define	TrdError(x)			(x->status & 0x01)		// Underrun
#define	TrdAnyError(x)		(x->status & 0x01)		// Underrun

// Macros to access MK7 hw registers
// 16-bit registers
#if	!DBG
#define	MK7Reg_Write(adapter, _port, _val) \
	NdisRawWritePortUshort( (PUCHAR)(adapter->MappedIoBase+_port), (USHORT)(_val) )
#define	MK7Reg_Read(adapter, _port, _pval) \
	NdisRawReadPortUshort( (PUCHAR)(adapter->MappedIoBase+_port), (PUSHORT)(_pval) )
//#define	MK7Reg_Write(_port, _val) DEBUGSTR(("MK7Write\n"))
//#define	MK7Reg_Read(_port, _pval) DEBUGSTR(("MK7Read\n"))
#endif


#define MK7DisableIr(adapter)	(MK7Reg_Write(adapter, R_ENAB, ~B_ENAB_IRENABLE))
#define MK7EnableIr(adapter)	(MK7Reg_Write(adapter, R_ENAB, B_ENAB_IRENABLE))



#define	MK7OurInterrupt(x)	(x != 0)
#if DBG
#define	MK7RXInterrupt(x)	( (x & B_RX_INTS) || (x & B_TEST_INTS) )
#define	MK7TXInterrupt(x)	( (x & B_TX_INTS) || (x & B_TEST_INTS) )
#else
#define	MK7RXInterrupt(x)	(x & B_RX_INTS)
#define	MK7TXInterrupt(x)	(x & B_TX_INTS)
#endif

//******************************
// Phoenix End
//******************************



#include	"winpci.h"
#include	"mk7comm.h"
#include	"wincomm.h"
#include	"dbg.h"
#include	"queue.h"


#endif // _MK7_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\net\irda\mknet\sys\mkinit.c ===
/*****************************************************************************
 **																			**
 **	COPYRIGHT (C) 2000, 2001 MKNET CORPORATION								**
 **	DEVELOPED FOR THE MK7100-BASED VFIR PCI CONTROLLER.						**
 **																			**
 *****************************************************************************/

/**********************************************************************

Module Name:
	MKINIT.C

Routines:
	ClaimAdapter
	SetupIrIoMapping
	SetupAdapterInfo
	AllocAdapterMemory
	ReleaseAdapterMemory
	FreeAdapterObject
	SetupTransmitQueues
	SetupReceiveQueues
	InitializeMK7
	InitializeAdapter
	StartAdapter
	MK7ResetComplete
	ResetTransmitQueues
	ResetReceiveQueues

Comments:
	Various one-time inits. This involves a combo of inits to the
	NDIS env and the MK7100 hw.

**********************************************************************/

#include	"precomp.h"
#include	"protot.h"
#pragma		hdrstop




//-----------------------------------------------------------------------------
// Procedure:	[ClaimAdapter]
//
// Description: Locate a MK7-based adapter and assign (claim) the adapter
//		hardware. This routine also stores the slot, base IO Address, and IRQ.
//
// Arguments:
//	  Adapter - ptr to Adapter object instance.
//
// Returns:
//	  NDIS_STATUS_SUCCESS - If an adapter is successfully found and claimed
//	  NDIS_STATUS_FAILURE- If an adapter is not found/claimed
//
//-----------------------------------------------------------------------------
NDIS_STATUS
ClaimAdapter(PMK7_ADAPTER Adapter, NDIS_HANDLE WrapperConfigurationContext)
{
	USHORT				NumPciBoardsFound;
	ULONG				Bus;
	UINT				i,j;
	NDIS_STATUS			Status = NDIS_STATUS_SUCCESS;
	USHORT				VendorID = MKNET_PCI_VENDOR_ID;
	USHORT				DeviceID = MK7_PCI_DEVICE_ID;
	PCI_CARDS_FOUND_STRUC PciCardsFound;
	PNDIS_RESOURCE_LIST AssignedResources;


	DBGLOG("=> ClaimAdapter", 0);

	// "Bus" is not used??
	Bus = (ULONG) Adapter->BusNumber;

	if (Adapter->MKBusType != PCIBUS) {
		//Not supported -  ISA, EISA or MicroChannel
		DBGLOG("<= ClaimAdapter (ERR - 1", 0);
		return (NDIS_STATUS_FAILURE);
	}


	NumPciBoardsFound = FindAndSetupPciDevice(Adapter,
								WrapperConfigurationContext,
								VendorID,
								DeviceID,
								&PciCardsFound);

	if(NumPciBoardsFound) {

#if DBG
		DBGSTR(("\n\n					  Found the following adapters\n"));

		for(i=0; i < NumPciBoardsFound; i++) {
			DBGSTR(("slot=%x, io=%x, irq=%x \n",
			PciCardsFound.PciSlotInfo[i].SlotNumber,
			PciCardsFound.PciSlotInfo[i].BaseIo,
			PciCardsFound.PciSlotInfo[i].Irq));
		}
#endif

	}
	else {
		DBGSTR(("our PCI board was not found!!!!!!\n"));
		MKLogError(Adapter,
					EVENT_16,
					NDIS_ERROR_CODE_ADAPTER_NOT_FOUND,
					0);

		DBGLOG("<= ClaimAdapter (ERR - 2", 0);
		return (NDIS_STATUS_FAILURE);
	}

	i = 0;	 // only one adapter in the system
	//		NOTE: i == the index into PciCardsFound that we want to use.


	//****************************************
	// Store our allocated resources in Adapter struct
	//****************************************
	Adapter->MKSlot = PciCardsFound.PciSlotInfo[i].SlotNumber;
	Adapter->MKInterrupt = PciCardsFound.PciSlotInfo[i].Irq;
	Adapter->MKBaseIo = PciCardsFound.PciSlotInfo[i].BaseIo;

	DBGLOG("<= ClaimAdapter", 0);

	return (NDIS_STATUS_SUCCESS);
}



//-----------------------------------------------------------------------------
// Procedure:	[SetupIrIoMapping]
//
// Description: This sets up our assigned PCI I/O space w/ NDIS.
//
// Arguments:
//	  Adapter - ptr to Adapter object instance
//
// Returns:
//	  NDIS_STATUS_SUCCESS
//	  not NDIS_STATUS_SUCCESS
//-----------------------------------------------------------------------------
NDIS_STATUS
SetupIrIoMapping(PMK7_ADAPTER Adapter)
{
	NDIS_STATUS Status = NDIS_STATUS_SUCCESS;


	DBGFUNC("SetupIrIoMapping");
	DBGLOG("=> SetupIrIoMapping", 0);

	Adapter->MappedIoRange = Adapter->MKBaseSize;

	Status = NdisMRegisterIoPortRange(
					(PVOID *) &Adapter->MappedIoBase,
					Adapter->MK7AdapterHandle,
					(UINT) Adapter->MKBaseIo,
					Adapter->MappedIoRange);

	DBGSTR(("SetupPciRegs: io=%x, size=%x, stat=%x\n",
		Adapter->MKBaseIo, Adapter->MappedIoRange, Status));

	if (Status != NDIS_STATUS_SUCCESS) {
		DBGSTR(("ERROR: NdisMRegisterIoPortRange failed (Status = 0x%x)\n", Status));
		DBGLOG("<= SetupIrIoMapping (ERR)", 0);
		return (Status);
	}
	DBGLOG("<= SetupIrIoMapping", 0);
	return (Status);
}

//-----------------------------------------------------------------------------
// Procedure:	[SetupAdapterInfo]
//
// Description: Sets up the various adapter fields in the specified Adapter
//				object.
// Arguments:
//	  Adapter - ptr to Adapter object instance
//
// Returns:
//	  NDIS_STATUS_SUCCESS - If an adapter's IO mapping was setup correctly
//	  not NDIS_STATUS_SUCCESS- If an adapter's IO space could not be registered
//-----------------------------------------------------------------------------
NDIS_STATUS
SetupAdapterInfo(PMK7_ADAPTER Adapter)
{
	NDIS_STATUS Status;


	DBGFUNC("SetupAdapterInfo");
	DBGLOG("=> SetupAdapterInfo", 0);

	// Setup the IR Registers I/O mapping
	Status = SetupIrIoMapping(Adapter);

	Adapter->InterruptMode = NdisInterruptLevelSensitive;
//	Adapter->InterruptMode = NdisInterruptLatched;

	DBGLOG("<= SetupAdapterInfo", 0);
	return (Status);
}



//-----------------------------------------------------------------------------
// Procedure:	[AllocAdapterMemory]
//
// Description:	Allocte and setup memory (control structures, shared memory
//		data buffers, ring buffers, etc.) for the MK7. Additional setups
//		may also be done later on, e.g., TX/RX CB lists, buffer lists, etc. 
//
// Arguments:
//	  Adapter - the adapter structure to allocate for.
//
// Returns:
//	  NDIS_STATUS_SUCCESS - If the shared memory structures were setup
//	  not NDIS_STATUS_SUCCESS- If not enough memory or map registers could be
//							   allocated
//-----------------------------------------------------------------------------
NDIS_STATUS
AllocAdapterMemory(PMK7_ADAPTER Adapter)
{
	NDIS_STATUS				Status;
	ULONG					alignedphys;


	DBGFUNC("AllocAdapterMemory");
	DBGLOG("=> SetupAdapterMemory", 0);

	Adapter->MaxPhysicalMappings = MK7_MAXIMUM_PACKET_SIZE_ESC;


	//****************************************
	// We allocate several chunks of memory. They fall into 2 categories:
	// cached and non-cached. Memory that is shared w/ the hw is non-cached
	// for reason of simplicity. Cached memory is used for our internal
	// sw runtime operations.
	//
	// The following is done:
	// 1. Allocate RRDs and TRDs from non-cached memory. This is the
	//	  Ring descriptors for the hw. (The base address of this is
	//	  set in the Phoenix's Base Address Reg.)
	// 2. RX memory --
	//		I.	Alloc cached memory for RCBs and RPDs.
	//		II. Alloc non-cached for RX DMA data buffers (these are
	//			mapped to RX packet->buffers).
	// 3. TX memory --
	//		I.	Alloc cached for TCBs.
	//		II. Alloc non-cached for TX DMA data buffers.
	//****************************************


	//****************************************
	// Since we use shared memory (NdisMAllocateSharedMemory), we have to
	// call NdisMAllocateMapRegisters even though we don't use such
	// mapping. So just ask for 1 map reg.
	//****************************************
	Adapter->NumMapRegisters = 1;
	Status = NdisMAllocateMapRegisters(
				Adapter->MK7AdapterHandle,
				0,
				FALSE,
				Adapter->NumMapRegisters,
				Adapter->MaxPhysicalMappings );

	if (Status != NDIS_STATUS_SUCCESS) {
		Adapter->NumMapRegisters = 0;

		MKLogError(Adapter, EVENT_11, NDIS_ERROR_CODE_OUT_OF_RESOURCES, 0);
		DBGSTR(("NdisMAllocateMapRegister Failed - %x\n", Status));
		DBGLOG("<= SetupAdapterMemory: (ERR - NdisMAllocateMapRegister)", 0);
		return(Status);
	}


	//****************************************
	// RRDs & TRDs (RX/TX Ring Descriptors)
	//
	// Allocate shared memory for the Phoenix Ring buffers.  Each TRD and
	// RRD has a max count (we may not use all). This contiguous space
	// holds both the RRDs and TRDs. The 1st 64 entries are RRDs followed
	// immediately by 64 TRDs. Hence, the 1st TRD is always a max ring count
	// (64x8=512 bytes) from the 1st RRD. We always allocate the max for
	// simplicity. Allocate enough extras to align on 1k boundary.
	//****************************************
	Adapter->RxTxUnCachedSize = 1024 + ( (sizeof(RRD) + sizeof(TRD)) * MAX_RING_SIZE );
	NdisMAllocateSharedMemory(Adapter->MK7AdapterHandle,
							Adapter->RxTxUnCachedSize,
							FALSE,		// non-cached
							(PVOID) &Adapter->RxTxUnCached,
							&Adapter->RxTxUnCachedPhys);
	if (Adapter->RxTxUnCached == NULL) {
		Adapter->pRrd = Adapter->pTrd = NULL;

		MKLogError(Adapter, EVENT_12, NDIS_ERROR_CODE_OUT_OF_RESOURCES, 0);
		DBGSTR(("ERROR: Failed alloc for RRDs & TRDs\n"));
		DBGLOG("<= SetupAdapterMemory: (ERR - RRD/TRD mem)", Adapter->RxTxUnCachedSize);
		return (NDIS_STATUS_FAILURE);
	}
	// Align to 1K boundary.
	// NOTE: We don't modify RxTxUnCached. We need it for release later.
	alignedphys = NdisGetPhysicalAddressLow(Adapter->RxTxUnCachedPhys);
	alignedphys += 0x000003FF;
	alignedphys &= (~0x000003FF);
	Adapter->pRrdTrdPhysAligned = alignedphys;
	Adapter->pRrdTrd = Adapter->RxTxUnCached +
		(alignedphys - NdisGetPhysicalAddressLow(Adapter->RxTxUnCachedPhys));


	Adapter->pRrd		= Adapter->pRrdTrd;
	Adapter->pRrdPhys	= Adapter->pRrdTrdPhysAligned;
	// TRDs are right after RRDs (see Phoenix doc)
	Adapter->pTrd = Adapter->pRrd + (sizeof(RRD) * MAX_RING_SIZE);
	Adapter->pTrdPhys = Adapter->pRrdPhys + (sizeof(RRD) * MAX_RING_SIZE);



	//****************************************
	// Allocate RX memory
	//
	// 1. Cacheable control structures (RCBs, RPDs),
	// 2. Non-cacheable DMA buffers.
	//****************************************

	// RCBs and RPDs (cached)
	Adapter->RecvCachedSize = (	Adapter->NumRcb * sizeof(RCB) +
								Adapter->NumRpd * sizeof(RPD) );
	Status = ALLOC_SYS_MEM(&Adapter->RecvCached, Adapter->RecvCachedSize);
	if (Status != NDIS_STATUS_SUCCESS) {
		Adapter->RecvCached = (PUCHAR) 0;

		MKLogError(Adapter, EVENT_13, NDIS_ERROR_CODE_OUT_OF_RESOURCES, 0);
		DBGSTR(("ERROR: Failed allocate %d bytes for RecvCached mem\n",
				Adapter->RecvCachedSize));
		DBGLOG("<= SetupAdapterMemory: (ERR - RCB/RPD mem)", Adapter->RecvCachedSize);
		return (Status);
	}
	DBGSTR(("Allocated %08x %8d bytes for RecvCached mem\n", 
			Adapter->RecvCached, Adapter->RecvCachedSize));
	NdisZeroMemory((PVOID) Adapter->RecvCached, Adapter->RecvCachedSize);


	// RX data buffers (non-cached)
	// Alignment!?
	Adapter->RecvUnCachedSize = (Adapter->NumRpd * RPD_BUFFER_SIZE);
	NdisMAllocateSharedMemory(
			Adapter->MK7AdapterHandle,
			Adapter->RecvUnCachedSize,
			FALSE,		// non-cached
			(PVOID) &Adapter->RecvUnCached,
			&Adapter->RecvUnCachedPhys );
	if (Adapter->RecvUnCached == NULL) {
		MKLogError(Adapter, EVENT_14, NDIS_ERROR_CODE_OUT_OF_RESOURCES, 0);
		DBGSTR(("ERROR: Failed allocate %d bytes for RecvUnCached mem\n",
				Adapter->RecvUnCachedSize));
		DBGLOG("<= SetupAdapterMemory: (ERR - RPD buff mem)", Adapter->RecvUnCachedSize);
		return (NDIS_STATUS_FAILURE);
	}
	DBGSTR(("Allocated %08x %8d bytes for RecvUnCached mem\n",
			Adapter->RecvUnCached, Adapter->RecvUnCachedSize));
	NdisZeroMemory((PVOID) Adapter->RecvUnCached, Adapter->RecvUnCachedSize);



	//****************************************
	// Allocate TX memory
	//
	// 1. Cacheable control structure (TCBs),
	// 2. Non-cacheable DMA buffers (coalesce).
	//****************************************

	// TCBs (cached)
	Adapter->XmitCachedSize = (Adapter->NumTcb * sizeof(TCB));
	Status = ALLOC_SYS_MEM(&Adapter->XmitCached, Adapter->XmitCachedSize);
	if (Status != NDIS_STATUS_SUCCESS) {
		Adapter->XmitCached = (PUCHAR) 0;

		MKLogError(Adapter, EVENT_13, NDIS_ERROR_CODE_OUT_OF_RESOURCES, 0);
		DBGSTR(("ERROR: Failed allocate %d bytes for XmitCached mem\n",
				Adapter->XmitCachedSize));
		DBGLOG("<= SetupAdapterMemory: (ERR - TCB mem)", Adapter->XmitCachedSize);
		return (Status);
	}
	DBGSTR(("Allocated %08x %8d bytes for XmitCached mem\n",
			Adapter->XmitCached, Adapter->XmitCachedSize));
	NdisZeroMemory((PVOID) Adapter->XmitCached, Adapter->XmitCachedSize);


	// TX coalesce data buffers (non-cached)
	Adapter->XmitUnCachedSize =
		((Adapter->NumTcb + 1) * COALESCE_BUFFER_SIZE);

	//****************************************
	// Do we need to paragraph align this memory?
	//****************************************
	NdisMAllocateSharedMemory(
			Adapter->MK7AdapterHandle,
			Adapter->XmitUnCachedSize,
			FALSE,
			(PVOID) &Adapter->XmitUnCached,
			&Adapter->XmitUnCachedPhys);

	if (Adapter->XmitUnCached == NULL) {
		MKLogError(Adapter, EVENT_15, NDIS_ERROR_CODE_OUT_OF_RESOURCES, 0);
		DBGSTR(("ERROR: Failed allocate %d bytes for XmitUnCached mem\n", 
				Adapter->XmitUnCachedSize));
		DBGLOG("<= SetupAdapterMemory: (ERR - TX buff mem)", (ULONG)0);
		return (NDIS_STATUS_FAILURE);
	}
	DBGSTR(("Allocated %08x %8d bytes for XmitUnCached mem\n", 
				Adapter->XmitUnCached, Adapter->XmitUnCachedSize));
	// initialize this recently allocated area to zeros
	NdisZeroMemory((PVOID) Adapter->XmitUnCached, Adapter->XmitUnCachedSize);


	DBGLOG("<= SetupAdapterMemory", 0);
	return (NDIS_STATUS_SUCCESS);
}



//-----------------------------------------------------------------------------
// Procedure:	[ReleaseAdapterMemory]
//
// Description: This is the reverse of AllocAdapterMemory().  We deallocate the
//		shared memory data structures for the Adapter structure.  This includes
//		the both the cached and uncached memory allocations. We also free any
//		allocated map registers in this routine.
//
// Arguments:
//		Adapter - Ptr to the Adapter structure
//
// Returns:		(none)
//-----------------------------------------------------------------------------
VOID
ReleaseAdapterMemory(PMK7_ADAPTER Adapter)
{
	UINT	i;
	PRCB	rcb;
	PRPD	rpd;


	DBGFUNC("ReleaseAdapterMemory");
	DBGLOG("=> ReleaseAdapterMemory", 0);

	//********************
	// Release RX memory
	//********************

	// Packet and buffer descriptors and pools	
	if (Adapter->ReceivePacketPool) {
		DBGLOG("Freeing Packet Pool resources\n", 0);

		rcb = Adapter->pRcb;
		for (i=0; i<Adapter->NumRcb; i++) {
			NdisFreeBuffer(rcb->rpd->ReceiveBuffer);
			NdisFreePacket(rcb->rpd->ReceivePacket);
			rcb++;
		}

		rpd = (PRPD) QueuePopHead(&Adapter->FreeRpdList);
		while (rpd != (PRPD)NULL) {
			NdisFreeBuffer(rpd->ReceiveBuffer);
			NdisFreePacket(rpd->ReceivePacket);
			rpd = (PRPD) QueuePopHead(&Adapter->FreeRpdList);
		}

		NdisFreeBufferPool(Adapter->ReceiveBufferPool);
		NdisFreePacketPool(Adapter->ReceivePacketPool);
	}



	// RCBs (cacheable)
	if (Adapter->RecvCached) {
		DBGLOG("Freeing %d bytes RecvCached\n", Adapter->RecvCachedSize);
		NdisFreeMemory((PVOID) Adapter->RecvCached, Adapter->RecvCachedSize, 0);
		Adapter->RecvCached = (PUCHAR) 0;
	}

	// RX shared data buffer memory (non-cacheable)
	if (Adapter->RecvUnCached) {
		DBGLOG("Freeing %d bytes RecvUnCached\n", Adapter->RecvUnCachedSize);

		NdisMFreeSharedMemory(
			Adapter->MK7AdapterHandle,
			Adapter->RecvUnCachedSize,
			FALSE,
			(PVOID) Adapter->RecvUnCached,
			Adapter->RecvUnCachedPhys);
		Adapter->RecvUnCached = (PUCHAR) 0;
	}



	//********************
	// Release TX memory
	//********************

	// TCBs (cacheable)
	if (Adapter->XmitCached) {
		DBGLOG("Freeing %d bytes XmitCached\n", Adapter->XmitCachedSize);
		NdisFreeMemory((PVOID) Adapter->XmitCached, Adapter->XmitCachedSize, 0);
		Adapter->XmitCached = (PUCHAR) 0;
	}

	// TX shared data buffer memory (non-cacheable)
	if (Adapter->XmitUnCached) {
		DBGLOG("Freeing %d bytes XmitUnCached\n", Adapter->XmitUnCachedSize);

		// Now free the shared memory that was used for the command blocks and
		// transmit buffers.

		NdisMFreeSharedMemory(
			Adapter->MK7AdapterHandle,
			Adapter->XmitUnCachedSize,
			FALSE,
			(PVOID) Adapter->XmitUnCached,
			Adapter->XmitUnCachedPhys
			);
		Adapter->XmitUnCached = (PUCHAR) 0;
	}


	//********************
	// RRDs/TRDs (Ring) & Reg Map (non-cacheable)
	//********************

	// If this is a miniport driver we must free our allocated map registers
	if (Adapter->NumMapRegisters) {
		NdisMFreeMapRegisters(Adapter->MK7AdapterHandle);
	}

	// Now the TRDs & RRDs
	if (Adapter->RxTxUnCached) {
		NdisMFreeSharedMemory(
			Adapter->MK7AdapterHandle,
			Adapter->RxTxUnCachedSize,
			FALSE,
			(PVOID) Adapter->RxTxUnCached,
			Adapter->RxTxUnCachedPhys );
	}

	DBGLOG("<= ReleaseAdapterMemory", 0);
}



//-----------------------------------------------------------------------------
// Procedure:	[FreeAdapterObject]
//
// Description: Free all allocated resources for the adapter.
//
// Arguments:
//		Adapter - ptr to Adapter object instance
//
// Returns:		(none)
//-----------------------------------------------------------------------------
VOID
FreeAdapterObject(PMK7_ADAPTER Adapter)
{
	DBGFUNC("FreeAdapterObject");

	// The reverse of AllocAdapterMemory().
	ReleaseAdapterMemory(Adapter);

	// Delete any IO mappings that we have registered
	if (Adapter->MappedIoBase) {
		NdisMDeregisterIoPortRange(
					Adapter->MK7AdapterHandle,
					(UINT) Adapter->MKBaseIo,
					Adapter->MappedIoRange,
					(PVOID) Adapter->MappedIoBase);
	}

	// free the adapter object itself
	FREE_SYS_MEM(Adapter, sizeof(MK7_ADAPTER));
}



//-----------------------------------------------------------------------------
// Procedure:	[SetupTransmitQueues]
//
// Description: Setup TRBs, TRDs and TX data buffs at INIT time. This routine
//		may also be called at RESET time.
//
// Arguments:
//	  Adapter - ptr to Adapter object instance
//	  DebugPrint - A boolean value that will be TRUE if this routine is to
//				   write all of transmit queue debug info to the debug terminal.
//
// Returns:	   (none)
//-----------------------------------------------------------------------------
VOID
SetupTransmitQueues(PMK7_ADAPTER Adapter,
					BOOLEAN DebugPrint)
{
	UINT	i;
	PTCB	tcb;
	PTRD	trd;
	PUCHAR	databuff;
	ULONG	databuffphys;


	DBGLOG("=> SetupTransmitQueues", 0);

	Adapter->nextAvailTcbIdx = 0;
	Adapter->nextReturnTcbIdx = 0;

	Adapter->pTcb	= (PTCB)Adapter->XmitCached;

	tcb				= Adapter->pTcb;			// TCB
	trd				= (PTRD)Adapter->pTrd;		// TRD
	databuff		= Adapter->XmitUnCached;
	databuffphys	= NdisGetPhysicalAddressLow(Adapter->XmitUnCachedPhys);// shared data buffer

	//****************************************
	// Pair up a TCB w/ a TRD, and init ownership of TRDs to the driver.
	// Setup the physical buffer to the Ring descriptor (TRD).
	//****************************************
	for (i=0; i<Adapter->NumTcb; i++) {	
		tcb->trd		= trd;
		tcb->buff		= databuff;
		tcb->buffphy	= databuffphys;

		LOGTXPHY(databuffphys);	// for debug

		trd->count		= 0;
		trd->status		= 0;
		trd->addr		= (UINT)databuffphys;
		GrantTrdToDrv(trd);

		Adapter->pTcbArray[i] = tcb;

		tcb++;
		trd++;
		databuff		+= COALESCE_BUFFER_SIZE;
		databuffphys	+= COALESCE_BUFFER_SIZE;
	}


	// Initialize the Transmit queueing pointers to NULL
	Adapter->FirstTxQueue = (PNDIS_PACKET) NULL;
	Adapter->LastTxQueue = (PNDIS_PACKET) NULL;
	Adapter->NumPacketsQueued = 0;

	DBGLOG("<= SetupTransmitQueues", 0);
}


//-----------------------------------------------------------------------------
// Procedure:	[SetupReceiveQueues]
//
// Description:	Setup all rx-related descriptors, buffers, etc. using memory
//		allocated during init. Also setup our buffers for NDIS 5 and multiple
//		receive indications	through a packet array.
//
// Arguments:
//	  Adapter - ptr to Adapter object instance
//
// Returns:	   (none)
//-----------------------------------------------------------------------------
VOID
SetupReceiveQueues(PMK7_ADAPTER Adapter)
{
	UINT		i;
	PRCB		rcb;
	PRRD		rrd;
	PRPD		rpd;
	PUCHAR		databuff;
	ULONG		databuffphys;
	PRPD		*TempPtr;
	NDIS_STATUS	status;


	DBGLOG("=> SetupReceiveQueues", 0);

	QueueInitList(&Adapter->FreeRpdList);

	Adapter->nextRxRcbIdx = 0;

// 4.0.1 BOC
	Adapter->UsedRpdCount = 0;
	Adapter->rcbPendRpdCnt = 0;	// April 8, 2001.
// 4.0.1 EOC

	Adapter->pRcb	= (PRCB)Adapter->RecvCached;


	//****************************************
	// Our driver does not currently use async allocs. However, it's
	// still true that we have only one buffer per rx packet.
	//****************************************
	NdisAllocatePacketPool(&status,
						&Adapter->ReceivePacketPool,
						Adapter->NumRpd,
						NUM_BYTES_PROTOCOL_RESERVED_SECTION);
	ASSERT(status == NDIS_STATUS_SUCCESS);

	NdisAllocateBufferPool(&status,
						&Adapter->ReceiveBufferPool,
						Adapter->NumRpd);
	ASSERT(status == NDIS_STATUS_SUCCESS);


	//****************************************
	// Pair up a RCB w/ a RRD
	//****************************************
	rcb	= Adapter->pRcb;
	rrd	= (PRRD)Adapter->pRrd;
	for (i=0; i<Adapter->NumRcb; i++) {
		rcb->rrd	= rrd;

		rrd->count	= 0;
		GrantRrdToHw(rrd);

		Adapter->pRcbArray[i] = rcb;

		rcb++;
		rrd++;
	}


	//****************************************
	// Now set up the RPDs and the data buffers. The RPDs come right
	// after the RCBs in RecvCached memory. Put the RPDs on FreeRpdList.
	// Map the databuff to NDIS Packet/Buffer.
	// "Adapter->pRcb + Adapter->NumRcb" will skip over (NumRcb * sizeof(RCB))
	// bytes to get to RPDs because pRcb is ptr to RCB. 
	//****************************************
	rpd				= (PRPD) (Adapter->pRcb + Adapter->NumRcb);
	databuff		= Adapter->RecvUnCached;
	databuffphys	= NdisGetPhysicalAddressLow(Adapter->RecvUnCachedPhys);
	for (i=0; i<Adapter->NumRpd; i++) {

		rpd->databuff		= databuff;
		rpd->databuffphys	= databuffphys;

		LOGRXPHY(databuffphys);

		NdisAllocatePacket(&status,
						&rpd->ReceivePacket,
						Adapter->ReceivePacketPool);
		ASSERT(status== NDIS_STATUS_SUCCESS);

		//****************************************
		// Set the medium-specific header size in OOB data block.
		//****************************************
		NDIS_SET_PACKET_HEADER_SIZE(rpd->ReceivePacket,	ADDR_SIZE+CONTROL_SIZE);

		NdisAllocateBuffer(&status,
						&rpd->ReceiveBuffer,
						Adapter->ReceiveBufferPool,
						(PVOID)databuff,
						MK7_MAXIMUM_PACKET_SIZE);
		ASSERT(status == NDIS_STATUS_SUCCESS);

		NdisChainBufferAtFront(rpd->ReceivePacket,	rpd->ReceiveBuffer);

		QueuePutTail(&Adapter->FreeRpdList, &rpd->link);

		TempPtr = (PRPD *)&rpd->ReceivePacket->MiniportReserved;
		*TempPtr = rpd;

		rpd++;
		databuff		+= RPD_BUFFER_SIZE;
		databuffphys	+= RPD_BUFFER_SIZE;
	}



	//****************************************
	// Assign a RPB to each RCB, and setup the related RRD's data ptr.
	//****************************************
	rcb	= Adapter->pRcb;
	rrd	= rcb->rrd;
	for (i=0; i<Adapter->NumRcb; i++) {
		rpd = (PRPD) QueuePopHead(&Adapter->FreeRpdList);
		rcb->rpd	= rpd;
		rrd->addr	= rpd->databuffphys;
		rcb++;
		rrd = rcb->rrd;
	}
}



//-----------------------------------------------------------------------------
// Procedure:	[InitializeMK7] (RYM-IRDA)
//
// Description:	Init the Phoenix core to SIR mode.
//
// Arguments:
//	  Adapter - ptr to Adapter object instance
//
// Returns:
//		TRUE
//		FALSE
//-----------------------------------------------------------------------------
BOOLEAN
InitializeMK7(PMK7_ADAPTER Adapter)
{
	ULONG	phyaddr;
	MK7REG	mk7reg;


	DBGFUNC("InitializeMK7");

	//****************************************
	// Setup Ring Base Address & Ring Size. Need to shift down/right
	// 10 bits first.
	//****************************************
	phyaddr = (Adapter->pRrdTrdPhysAligned >> 10);
	MK7Reg_Write(Adapter, R_RBAL, (USHORT)phyaddr);
	MK7Reg_Write(Adapter, R_RBAU, (USHORT)(phyaddr >> 16));


	//****************************************
	// RX & TX ring sizes
	//
	// Now need to do this for RX & TX separately.
	//****************************************
	mk7reg = 0;

	switch(Adapter->NumRcb) {
	case 4:		mk7reg = RINGSIZE_RX4;		break;
	case 8:		mk7reg = RINGSIZE_RX8;		break;
	case 16:	mk7reg = RINGSIZE_RX16;		break;
	case 32:	mk7reg = RINGSIZE_RX32;		break;
	case 64:	mk7reg = RINGSIZE_RX64;		break;
	}

	switch(Adapter->NumTcb) {
	case 4:		mk7reg |= RINGSIZE_TX4;		break;
	case 8:		mk7reg |= RINGSIZE_TX8;		break;
	case 16:	mk7reg |= RINGSIZE_TX16;	break;
	case 32:	mk7reg |= RINGSIZE_TX32;	break;
	case 64:	mk7reg |= RINGSIZE_TX64;	break;
	}

	MK7Reg_Write(Adapter, R_RSIZ, mk7reg);


	//****************************************
	// The following is based on Phoenix's Programming Model
	// for SIR mode.
	//****************************************

	//****************************************
	// Step 1:	clear IRENALBE
	// This is the only writeable bit in this reg so just write it.
	//****************************************
	MK7Reg_Write(Adapter, R_ENAB, ~B_ENAB_IRENABLE);

	//****************************************
	// Step 2:	MAXRXALLOW
	//****************************************
	MK7Reg_Write(Adapter, R_MPLN, MK7_MAXIMUM_PACKET_SIZE_ESC);

	//****************************************
	// Step 3:
	// IRCONFIG0 - We init in SIR w/ filter, RX, etc.
	//****************************************
#if DBG
	if (Adapter->LB == LOOPBACK_HW) {
		DBGLOG("   Loopback HW", 0);

//		MK7Reg_Write(Adapter, R_CFG0, 0x5C40);		// HW loopback: ENTX, ENRX, + below
		MK7Reg_Write(Adapter, R_CFG0, 0xDC40);		// HW loopback: ENTX, ENRX, + below
	}
	else {
#endif

		// We need to clear EN_MEMSCHD in IRCONFIG0 to reset the TX/RX
		// indexes to 0. Eveytime we init we need to do this. Actually we
		// just set eveything to zero since we're in ~B_ENAB_IRENABLE mode
		// anyway & we do the real setup right away below.
		MK7Reg_Write(Adapter, R_CFG0, 0x0000);
				
		if (Adapter->Wireless) {
			// WIRELESS: ..., no invert TX
			MK7Reg_Write(Adapter, R_CFG0, 0x0E18);
		}
		else {
			// WIRED: ENRX, DMA, small pkts, SIR, SIR RX filter, invert TX
			MK7Reg_Write(Adapter, R_CFG0, 0x0E1A);
		}
#if DBG
	}
#endif

	
	//****************************************
	// Step 4:
	// Infrared Phy Reg - Baude Rate & Pulse width
	//****************************************
	mk7reg = HW_SIR_SPEED_9600;
	MK7Reg_Write(Adapter, R_CFG2, mk7reg);


	//****************************************
	// Setup CFG3 - 48Mhz, etc.
	//****************************************
	//MK7Reg_Write(Adapter, R_CFG3, 0xF606);
	// We want to set the following:
	//		Bit 1	- 1 for 1 RCV pin (for all speeds)
	//		    2/3	- 48MHz
	//			8	- 0 to disable interrupt
	//			9	- 0 for SIR
	//			11	- 0 for burst mode
	MK7Reg_Write(Adapter, R_CFG3, 0xF406);


	// Set SEL0/1 for power level control for the 8102. This
	// should not affect the 8100.
	// IMPORTANT: The FIRSL bit in this register is the same
	//				as the FIRSL bit in CFG3!
	MK7Reg_Write(Adapter, R_GANA, 0x0000);


	//
	// More one-time inits are done later when we startup the controller
	// (see StartMK7()).
	//

	return (TRUE);
}



//-----------------------------------------------------------------------------
// Procedure:	[InitializeAdapter]
//
// Description:
//
// Arguments:
//		Adapter - ptr to Adapter object instance
//
// Returns:
//		TRUE - If the adapter was initialized
//		FALSE - If the adapter failed initialization
//-----------------------------------------------------------------------------
BOOLEAN
InitializeAdapter(PMK7_ADAPTER Adapter)
{
	UINT	i;


	DBGFUNC("InitializeAdapter");


   	for (i=0; i<NUM_BAUDRATES; i++) {
		if (supportedBaudRateTable[i].bitsPerSec <= Adapter->MaxConnSpeed) {
			Adapter->AllowedSpeedMask |= supportedBaudRateTable[i].ndisCode;
		}
	}

	Adapter->supportedSpeedsMask	= ALL_IRDA_SPEEDS;
	Adapter->linkSpeedInfo 			= &supportedBaudRateTable[BAUDRATE_9600];
	Adapter->CurrentSpeed			= DEFAULT_BAUD_RATE;	// 9600
	//Adapter->extraBOFsRequired	= MAX_EXTRA_SIR_BOFS; Now configurable
	Adapter->writePending			= FALSE;

	// Set both TRUE to allow Windows to let us know when it wants an update.
	Adapter->mediaBusy				= TRUE;
//	Adapter->haveIndicatedMediaBusy = TRUE;		// 1.0.0

	NdisMInitializeTimer(&Adapter->MinTurnaroundTxTimer,
						Adapter->MK7AdapterHandle,
						(PNDIS_TIMER_FUNCTION)MinTurnaroundTxTimeout,
						(PVOID)Adapter);

	// 1.0.0
	NdisMInitializeTimer(&Adapter->MK7AsyncResetTimer,
		Adapter->MK7AdapterHandle,
		(PNDIS_TIMER_FUNCTION) MK7ResetComplete,
		(PVOID) Adapter);

	return (InitializeMK7(Adapter));
}



//----------------------------------------------------------------------
// Procedure:	[StartMK7]
//
// Description: All inits are done. Now we can enable the MK7 to
//				be able to do RXs and TXs.
//
//----------------------------------------------------------------------
VOID	StartMK7(PMK7_ADAPTER Adapter)
{
	MK7REG	mk7reg;


	//****************************************
	// The following is based on Phoenix's Programming Model
	// for SIR mode.
	//****************************************

	//****************************************
	// Step 5:	IR_ENABLE
	// Now finish where InitializeMK7() left off. This completes
	// the one-time init of the MK7 core.
	//****************************************
	MK7Reg_Write(Adapter, R_ENAB, B_ENAB_IRENABLE);

	MK7Reg_Read(Adapter, R_ENAB, &mk7reg);

//	ASSERT(mk7reg == 0x8FFF);

	// Still need to do the 1st Prompt. This will be done later
	// when we call MK7EnableInterrupt().
}



//----------------------------------------------------------------------
// Procedure:	[StartAdapter]
//
// Description: All inits are done. Now we can enable the adapter to
//				be able to do RXs and TXs.
//
//----------------------------------------------------------------------
VOID	StartAdapter(PMK7_ADAPTER Adapter)
{
	StartMK7(Adapter);
}

//-----------------------------------------------------------------------------
// Procedure;	[MKResetComplete]
//
// Description: This function is called by a timer indicating our
//              reset is done (by way of .5 seconds expiring)
//
// Arguements:  NDIS_HANDLE MiniportAdapterContext
//
// Return:		nothing, but sets NdisMResetComplete and enables ints.
//-----------------------------------------------------------------------------

VOID
MK7ResetComplete(PVOID sysspiff1,
                  NDIS_HANDLE MiniportAdapterContext,
                  PVOID sysspiff2, PVOID sysspiff3)
{
    PMK7_ADAPTER Adapter;
	MK7REG mk7reg;

//    DEBUGFUNC("MKResetComplete");

//    INITSTR(("\n"));
    Adapter = PMK7_ADAPTER_FROM_CONTEXT_HANDLE(MiniportAdapterContext);

	// NdisAcquireSpinLock(&Adapter->Lock); 4.0.1
	MK7Reg_Read(Adapter, R_INTS, &Adapter->recentInt);
	Adapter->recentInt = 0;
	MK7SwitchToRXMode(Adapter);

    NdisMResetComplete(Adapter->MK7AdapterHandle,
        (NDIS_STATUS) NDIS_STATUS_SUCCESS,
        TRUE);

	Adapter->hardwareStatus = NdisHardwareStatusReady;

	Adapter->ResetInProgress = FALSE;

	StartMK7(Adapter);

	MK7EnableInterrupt(Adapter);

//	PSTR("=> NDIS RESET COMPLETE\n\r");

	// NdisReleaseSpinLock(&Adapter->Lock);	// 4.0.1
}


//-----------------------------------------------------------------------------
// Procedure:	[ResetTransmitQueues]
//
// Description: Setup TRBs, TRDs and TX data buffs at INIT time. And Reset
//				TCB/RCB	Index to zero in both hardware and software
//
// Arguments:
//	  Adapter - ptr to Adapter object instance
//	  DebugPrint - A boolean value that will be TRUE if this routine is to
//				   write all of transmit queue debug info to the debug terminal.
//
// Returns:	   (none)
//-----------------------------------------------------------------------------
VOID
ResetTransmitQueues(PMK7_ADAPTER Adapter,
					BOOLEAN DebugPrint)
{
	UINT	i;
	PTCB	tcb;
	PTRD	trd;
	PUCHAR	databuff;
	ULONG	databuffphys;
	MK7REG	mk7reg;


	DBGLOG("=> SetupTransmitQueues", 0);

	Adapter->nextAvailTcbIdx = 0;
	Adapter->nextReturnTcbIdx = 0;

	MK7Reg_Read(Adapter, R_CFG0, &mk7reg);
	mk7reg &= 0xfbff;
	MK7Reg_Write(Adapter, R_CFG0, mk7reg);
	mk7reg |= 0x0400;
	MK7Reg_Write(Adapter, R_CFG0, mk7reg);

	Adapter->pTcb	= (PTCB)Adapter->XmitCached;

	tcb				= Adapter->pTcb;			// TCB
	trd				= (PTRD)Adapter->pTrd;		// TRD
	databuff		= Adapter->XmitUnCached;
	databuffphys	= NdisGetPhysicalAddressLow(Adapter->XmitUnCachedPhys);// shared data buffer

	//****************************************
	// Pair up a TCB w/ a TRD, and init ownership of TRDs to the driver.
	// Setup the physical buffer to the Ring descriptor (TRD).
	//****************************************
	for (i=0; i<Adapter->NumTcb; i++) {
		tcb->trd		= trd;
		tcb->buff		= databuff;
		tcb->buffphy	= databuffphys;

		trd->count		= 0;
		trd->status		= 0;
		trd->addr		= (UINT)databuffphys;
		GrantTrdToDrv(trd);

		Adapter->pTcbArray[i] = tcb;

		tcb++;
		trd++;
		databuff		+= COALESCE_BUFFER_SIZE;
		databuffphys	+= COALESCE_BUFFER_SIZE;
	}


	// Initialize the Transmit queueing pointers to NULL
	Adapter->FirstTxQueue = (PNDIS_PACKET) NULL;
	Adapter->LastTxQueue = (PNDIS_PACKET) NULL;
	Adapter->NumPacketsQueued = 0;

	DBGLOG("<= SetupTransmitQueues", 0);
}
//-----------------------------------------------------------------------------
// Procedure:	[ResetReceiveQueues]
//
// Description:	Reset all the rrd's Ownership to HW
//				and byte_counts to zero. All other
//				setting (such as rpd) will remain				
//				same.  We do not reset all, because
//				some data buffers may still hold by
//				by the upper protocol layers.
//
// Arguments:
//	  Adapter - ptr to Adapter object instance
//
// Returns:	   (none)
//-----------------------------------------------------------------------------
VOID
ResetReceiveQueues(PMK7_ADAPTER Adapter)
{
	UINT		i;
	PRCB		rcb;
	PRRD		rrd;

	DBGLOG("=> SetupReceiveQueues", 0);

	Adapter->nextRxRcbIdx = 0;

	Adapter->pRcb	= (PRCB)Adapter->RecvCached;

	//****************************************
	// Pair up a RCB w/ a RRD
	//****************************************
	rcb	= Adapter->pRcb;
	rrd	= (PRRD)Adapter->pRrd;
	for (i=0; i<Adapter->NumRcb; i++) {
		rcb->rrd	= rrd;

		rrd->count	= 0;
		GrantRrdToHw(rrd);

		Adapter->pRcbArray[i] = rcb;

		rcb++;
		rrd++;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\net\irda\mknet\sys\mk7comm.h ===
/*****************************************************************************
 **																			**
 **	COPYRIGHT (C) 2000, 2001 MKNET CORPORATION								**
 **	DEVELOPED FOR THE MK7100-BASED VFIR PCI CONTROLLER.						**
 **																			**
 *****************************************************************************/

/**********************************************************************

Module Name:
	MK7COMM.H

Comments:
	Include file for the MK7 driver.

**********************************************************************/

#ifndef	_MK7COMM_H
#define	_MK7COMM_H


//
// IrDA definitions
//

#define MAX_EXTRA_SIR_BOFS				48
#define	SIR_BOF_SIZE					1
#define	SIR_EOF_SIZE					1
#define ADDR_SIZE						1
#define CONTROL_SIZE					1
#define	MAX_I_DATA_SIZE					2048
#define	MAX_I_DATA_SIZE_ESC				(MAX_I_DATA_SIZE + 40)
#define SIR_FCS_SIZE					2
#define FASTIR_FCS_SIZE					4		// FIR/VFIR

// History:
//	B2.1.0 - Was 2; set to 10 to align to 4DW.
//  B3.1.0-pre - back to 2
//#define ALIGN_PAD						10		// buffer alignment
#define ALIGN_PAD						2		// buffer alignment


#define DEFAULT_TURNAROUND_usec 1000			// 1000 usec (1 msec)

typedef struct {
	enum baudRates tableIndex;
	UINT bitsPerSec;					// actual bits/sec
	UINT ndisCode;						// bitmask
} baudRateInfo;

enum baudRates {

	// SIR
	BAUDRATE_2400 = 0,
	BAUDRATE_9600,
	BAUDRATE_19200,
	BAUDRATE_38400,
	BAUDRATE_57600,
	BAUDRATE_115200,

	// MIR
	BAUDRATE_576000,
	BAUDRATE_1152000,

	// FIR
	BAUDRATE_4M,

	// VFIR
	BAUDRATE_16M,

	NUM_BAUDRATES	/* must be last */
};

#define DEFAULT_BAUD_RATE 9600

#define MAX_SIR_SPEED				115200
#define MIN_FIR_SPEED				4000000
#define	VFIR_SPEED					16000000

//
// End IrDA definitions
//



// TX/RX Ring settings
#define DEF_RING_SIZE		64
#define	MIN_RING_SIZE		4
#define	MAX_RING_SIZE		64
#define DEF_TXRING_SIZE		4
#define DEF_RXRING_SIZE		(DEF_TXRING_SIZE * 2)
#define	DEF_EBOFS			24
#define MIN_EBOFS			0
#define MAX_EBOFS			48
#define	HW_VER_1_EBOFS		5	// 4.1.0

#define	DEF_RCB_CNT			DEF_RING_SIZE	// !!RCB and TCB cnt must be the same!!
#define	DEF_TCB_CNT			DEF_RING_SIZE	// ALSO SEE MAX_ARRAY_xxx_PACKETS


// Alloc twice as many receive buffers as receive ring size because these buffs
// are pended to upper layer. Don't know when they may be returned.
#define	CalRpdSize(x)		(x * 2)			// Get RPD size given ring size
#define	NO_RCB_PENDING		0xFF

#define	RX_MODE				0
#define TX_MODE				1


// Set to hw for RX
#define	MK7_MAXIMUM_PACKET_SIZE			(MAX_EXTRA_SIR_BOFS + \
										 SIR_BOF_SIZE + \
										 ADDR_SIZE + \
										 CONTROL_SIZE + \
										 MAX_I_DATA_SIZE + \
										 SIR_FCS_SIZE + \
										 SIR_EOF_SIZE)

#define	MK7_MAXIMUM_PACKET_SIZE_ESC		(MAX_EXTRA_SIR_BOFS + \
										 SIR_BOF_SIZE + \
										 ADDR_SIZE + \
										 CONTROL_SIZE + \
										 MAX_I_DATA_SIZE_ESC + \
										 SIR_FCS_SIZE + \
										 SIR_EOF_SIZE)

// For RX memory allocation
//#define	RPD_BUFFER_SIZE					(MK7_MAXIMUM_PACKET_SIZE + ALIGN_PAD)
#define	RPD_BUFFER_SIZE					(MK7_MAXIMUM_PACKET_SIZE_ESC + ALIGN_PAD)

// For TX memory allocation
#define COALESCE_BUFFER_SIZE			(MK7_MAXIMUM_PACKET_SIZE_ESC + ALIGN_PAD)


// Not used?
#define MAX_TX_PACKETS 4
#define MAX_RX_PACKETS 4

#define SIR_BOF_TYPE		UCHAR
#define SIR_EXTRA_BOF_TYPE	UCHAR
#define SIR_EXTRA_BOF_SIZE	sizeof(SIR_EXTRA_BOF_TYPE)
#define SIR_EOF_TYPE		UCHAR
#define SIR_FCS_TYPE		USHORT
#define	SIR_BOF				0xC0
#define SIR_EXTRA_BOF		0xC0
#define SIR_EOF				0xC1
#define SIR_ESC				0x7D
#define SIR_ESC_COMP		0x20

// When FCS is computed on an IR packet with FCS appended, the result
// should be this constant.
#define GOOD_FCS ((USHORT) ~0xf0b8)


//
// Link list
//
typedef struct _MK7_LIST_ENTRY {
	LIST_ENTRY	Link;
} MK7_LIST_ENTRY, *PMK7_LIST_ENTRY;



//
// COALESCE -- Consolidate data for TX
//
typedef struct _COALESCE {
	MK7_LIST_ENTRY		Link;
	PVOID				OwningTcb;
	PUCHAR				CoalesceBufferPtr;
	ULONG				CoalesceBufferPhys;
} COALESCE, *PCOALESCE;




//
// Receive Packet Descriptor (RPD)
//
//   Each receive buffer has this control struct.
//
//   (We use this mainly because there doesn't seem to be a simple way
//    to obtain a buff's phy addr from its virtual addr.)
//
typedef struct _RPD {
	MK7_LIST_ENTRY	link;
	PNDIS_BUFFER	ReceiveBuffer;	// mapped buffer
	PNDIS_PACKET	ReceivePacket;	// mapped packet
	PUCHAR			databuff;		// virtual data buffer
	ULONG			databuffphys;	// physical data buffer
	USHORT			status;
	UINT			FrameLength;
} RPD, *PRPD;




//
// Receive Control Block (RCB)
//
//   Points to the corresponding RX Ring entry (RRD).
//
typedef struct _RCB {
	MK7_LIST_ENTRY	link;
	PRRD			rrd;		// RX ring descriptor - RBD
	ULONG			rrdphys;	// Phy addr of RX ring descriptor
	PRPD			rpd;		// Receive Packet Descriptor
} RCB, *PRCB;


//
// Transmit Control Block (TCB)
//
//   Points to the corresponding TX Ring entry (TRD).
//
//   NOTE: We have a link field. Chances are we don't need it
//   because the TCB (which is the software context for a TRD)
//   is indexed. For now we'll have a link field in case it's
//   needed.
//
typedef struct _TCB {
	MK7_LIST_ENTRY	link;
	PTRD			trd;		// TX Ring entry - Transmit Ring Descriptor
	ULONG			trdPhy;
	PUCHAR			buff;		// virtual data buffer
	ULONG			buffphy;	// physical data buffer
	// Stuff you get back from NdisQueryPacket()
	PNDIS_PACKET	Packet;
	UINT			PacketLength;
	UINT			NumPhysDesc;
	UINT			BufferCount;
	PNDIS_BUFFER	FirstBuffer;
	BOOLEAN			changeSpeedAfterThisTcb;
} TCB, *PTCB;




//
// MK7_ADAPTER
//
typedef struct _MK7_ADAPTER
{
#if DBG
	UINT					Debug;
	UINT					DbgTest;			// different debug/tests to run; 0=none
	UINT					DbgTestDataCnt;
#define DBG_QUEUE_LEN	4095   //0xfff
	UINT					DbgIndex;
	UCHAR					DbgQueue[DBG_QUEUE_LEN];

	UINT					DbgSendCallCnt;
	UINT					DbgSentCnt;
	UINT					DbgSentPktsCnt;

	UINT					LB;					// Loopback debug/test
	UINT					LBPktLevel;			// pass thru 1 out of this many
	UINT					LBPktCnt;

	NDIS_MINIPORT_TIMER		MK7DbgTestIntTimer;	// for interrupt testing
#endif

	// Handle given by NDIS when the Adapter registered itself.
	NDIS_HANDLE				MK7AdapterHandle;

	// 1st pkt queued for TX in deserialized miniport
	PNDIS_PACKET			FirstTxQueue;
	PNDIS_PACKET			LastTxQueue;
	UINT					NumPacketsQueued;

	// Save the most recent interrupt events because the reg
	// is cleared once it's read.
	MK7REG					recentInt;
	UINT					CurrentSpeed;		// bits/sec
	UINT					MaxConnSpeed;		// in 100bps increments
	UINT					AllowedSpeedMask;
	baudRateInfo			*linkSpeedInfo;
//	BOOLEAN					haveIndicatedMediaBusy;	// 1.0.0


	// Keep track of when to change speed.
	PNDIS_PACKET			changeSpeedAfterThisPkt;
	UINT					changeSpeedPending;
//#define	CHANGESPEED_ON_T	1		// change speed marked on TCB
#define	CHANGESPEED_ON_DONE	1		// change speed marked on Q
#define	CHANGESPEED_ON_Q	2		// change speed marked on Q


	// This info may come from the Registry
	UINT					RegNumRcb;			// # of RCB from the Registry
	UINT					RegNumTcb;			// # of TCB from the Registry
	UINT					RegNumRpd;			// RPD (RX Packet Descriptor) from Registry
	UINT					RegSpeed;			// IrDA speeds
	UINT					RegExtraBOFs;		// Extra BOFs based on 115.2kbps

	//******************************
	// RXs & TXs
	//******************************
//	UINT					RrdTrdSize;			// total RRD & TRD memory size
	PUCHAR					pRrdTrd;			// virtual address - aligned
	ULONG					pRrdTrdPhysAligned;	// physical address - aligned

	PUCHAR					RxTxUnCached;
	NDIS_PHYSICAL_ADDRESS	RxTxUnCachedPhys;
	UINT					RxTxUnCachedSize;

	UINT					RingSize;			// same for both RRD & TRD

	//******************************
	// RXs
	//******************************
	UINT					NumRcb;				// what we actually use
	PRCB					pRcb;				// start of RCB
	PUCHAR					pRrd;				// start of RRD ( = pRrdTrd)
	ULONG					pRrdPhys;			// start of phy RRD ( = pRrdTrdPhysAligned)
	PRCB					pRcbArray[MAX_RING_SIZE];
	UINT					nextRxRcbIdx;		// index of next RCB to process
	UINT					rcbPendRpdIdx;		// 1st RCB waiting for RPD
	UINT					rcbPendRpdCnt;		// keep cnt to help simplify code logic
	UINT					rcbUsed;			// RYM10-5 needed??

	UINT					NumRpd;				// actually allocated/used
	MK7_LIST_ENTRY			FreeRpdList;		// start of free list
// 4.0.1 BOC
	UINT					UsedRpdCount;		// num of Rpds that not yet return to driver
// 4.0.1 EOC.
	NDIS_HANDLE				ReceivePacketPool;
	NDIS_HANDLE				ReceiveBufferPool;

	PUCHAR					RecvCached;			// control structs
	UINT					RecvCachedSize;
	PUCHAR					RecvUnCached;		// data buffs
	UINT					RecvUnCachedSize;
	NDIS_PHYSICAL_ADDRESS	RecvUnCachedPhys;

	// 4.1.0 HwVersion
#define	HW_VER_1	1
#define HW_VER_2	2
	BOOLEAN					HwVersion;

	//******************************
	// TXs
	//******************************
	UINT					NumTcb;				// what we actually use
	PTCB					pTcb;				// start of TCB
	PUCHAR					pTrd;				// start of TRD (512 bytes from pRrd)
	ULONG					pTrdPhys;
	PTCB					pTcbArray[MAX_RING_SIZE];
	UINT					nextAvailTcbIdx;	// index of next avail in the ring to use for TX
	UINT					nextReturnTcbIdx;	// index of next that'll be returned on completion
	UINT					tcbUsed;
	BOOLEAN					writePending;		// RYM-2K-1TX

	PUCHAR					XmitCached;			// control structs
	UINT					XmitCachedSize;
	PUCHAR					XmitUnCached;		// data buffs - coalesce buffs
	UINT					XmitUnCachedSize;
	NDIS_PHYSICAL_ADDRESS	XmitUnCachedPhys;


	ULONG					MaxPhysicalMappings;

	// I/O port space (NOT memory mapped I/O)
	PUCHAR					MappedIoBase;
	UINT					MappedIoRange;


	// Adapter Information Variable (set via Registry entries)
	UINT					BusNumber;			//' BusNumber'
	USHORT					BusDevice;			// PCI Bus/Device #

	// timer structure for Async Resets
	NDIS_MINIPORT_TIMER		MK7AsyncResetTimer;	// 1.0.0

	NDIS_MINIPORT_TIMER		MinTurnaroundTxTimer;

	NDIS_MINIPORT_INTERRUPT	Interrupt;			// interrupt object

	NDIS_INTERRUPT_MODE 	InterruptMode;

	NDIS_SPIN_LOCK			Lock;

	UINT				 	NumMapRegisters;

	UINT					IOMode;

	UINT					Wireless;

	UINT					HangCheck;			// 1.0.0


	//******************************
	// Hardware capabilities
	//******************************
	// This is a mask of NDIS_IRDA_SPEED_xxx bit values.
	UINT supportedSpeedsMask;
	// Time (in microseconds) that must transpire between a transmit
	//and the next receive.
	UINT turnAroundTime_usec;
	// Extra BOF (Beginning Of Frame) characters required at the
	// start of each received frame.
	UINT extraBOFsRequired;


	//******************************
	// OIDs
	//******************************
	UINT	hardwareStatus;		// OID_GEN_HARDWARE_STATUS
	BOOLEAN	nowReceiving;		// OID_IRDA_RECEIVING
	BOOLEAN	mediaBusy;			// OID_IRDA_MEDIA_BUSY


	UINT					MKBaseSize;		// Total port size in bytes
	UINT    				MKBaseIo;		// Base I/O address
	UINT					MKBusType;		// 'BusType' (EISA or PCI)
	UINT					MKInterrupt;	// 'InterruptNumber'
	USHORT					MKSlot;			// 'Slot', PCI Slot Number
	

	// This variable should be initialized to false, and set to true
	// to prevent re-entrancy in our driver during reset spinlock and unlock
	// stuff related to checking our link status
	BOOLEAN					ResetInProgress;	

	NDIS_MEDIA_STATE		LinkIsActive;	// not used right now

	// save the status of the Memory Write Invalidate bit in the PCI command word
	BOOLEAN				MWIEnable;


	//
	// Put statistics here
	//


} MK7_ADAPTER, *PMK7_ADAPTER;


//Given a MiniportContextHandle return the PMK7_ADAPTER it represents.
#define PMK7_ADAPTER_FROM_CONTEXT_HANDLE(Handle) ((PMK7_ADAPTER)(Handle))


//================================================
// Global Variables shared by all driver instances
//================================================


// This constant is used for places where NdisAllocateMemory needs to be
// called and the HighestAcceptableAddress does not matter.
static const NDIS_PHYSICAL_ADDRESS HighestAcceptableMax =
	NDIS_PHYSICAL_ADDRESS_CONST(-1,-1);


#endif		// _MK7COMM.H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\net\irda\mknet\sys\interrup.c ===
/*****************************************************************************
 **																			**
 **	COPYRIGHT (C) 2000, 2001 MKNET CORPORATION								**
 **	DEVELOPED FOR THE MK7100-BASED VFIR PCI CONTROLLER.						**
 **																			**
 *****************************************************************************/

/**********************************************************************

Module Name:
	INTERRUP.C

Procedures:
	MKMiniportIsr
	MKMiniportHandleInterrupt
	ProcessRXComp
	ProcessTXComp
	ProcessRXCompIsr
	ProcessTXCompIsr

Comments:



**********************************************************************/

#include	"precomp.h"
#pragma		hdrstop
#include	"protot.h"



//-----------------------------------------------------------------------------
// Procedure:	[MKMiniportIsr] (miniport)
//
// Description: This is the interrupt service routine running at interrupt level.
//				It checks to see if there is an interrupt pending. If yes, it
//				disables board interrupts and schedules HandleInterrupt callback.
//
// Arguments:
//		MiniportAdapterContext - The context value returned by the Miniport
//				when the adapter was initialized (see the call
//				NdisMSetAttributes). In reality, it is a pointer to MK7_ADAPTER.
//
// Returns:
//		InterruptRecognized - Returns True if the interrupt belonges to this
//				adapter, and false otherwise.
//		QueueMiniportHandleInterrupt - Returns True if we want a callback to
//				HandleInterrupt.
//
//-----------------------------------------------------------------------------
VOID
MKMiniportIsr(	OUT PBOOLEAN InterruptRecognized,
				OUT PBOOLEAN QueueMiniportHandleInterrupt,
				IN NDIS_HANDLE MiniportAdapterContext )
{	
	MK7REG	mk7reg, ReadInt;


	PMK7_ADAPTER Adapter = PMK7_ADAPTER_FROM_CONTEXT_HANDLE(MiniportAdapterContext);


	DBGLOG("=> INT", 0);

	//****************************************
	// Read the Interrupt Event Reg and save to context area for
	// DPC processing.
	//
	// IMPORTANT NOTE: The ISR runs at DIRQL level and is, thus, higher
	// proiority than other miniport routines. We need to be careful
	// about shared resources. Example: If our multi-pkt send is running
	// when an int occurs, the send routine can be preempted. If the ISR
	// and the send routine access shared resource then we have problems.
	//
	// We save the interrupt in recentInt because the interrupt event
	// register may be cleared upon a Read. (This has been verified.)
	//****************************************
	//MK7Reg_Read(Adapter, R_INTS, &Adapter->recentInt);
	MK7Reg_Read(Adapter, R_INTS, &ReadInt);
	if (MK7OurInterrupt(ReadInt)) {

		// Int enable should happen only after DPC is done.
		// Also disabling interrupt clears Interrupt Status.
		MK7DisableInterrupt(Adapter);

		Adapter->recentInt = ReadInt;

		MK7Reg_Read(Adapter, R_CFG3, &mk7reg);
			if ((mk7reg & 0x1000) != 0){
				mk7reg &= 0xEFFF;
				MK7Reg_Write(Adapter, R_CFG3, mk7reg);
				mk7reg |= 0x1000;
				MK7Reg_Write(Adapter, R_CFG3, mk7reg);
//				mk7reg = mk7reg; //For Debugging
			}

#if	DBG
		GDbgStat.isrCnt++;
		DBGLOG("   INT status", Adapter->recentInt);
#endif

		// Don't do TX processing in ISR. I saw a condition where SetSpeed()
		// was called while tcbused = 1. I set the change-speed flags correctly.
		// But the TX processing in ISR cleared tcbused resulting in the code
		// not chaning speed in DPC.
		// ProcessTXCompIsr(Adapter);

		ProcessRXCompIsr(Adapter);

		*InterruptRecognized = TRUE;
		*QueueMiniportHandleInterrupt = TRUE;
	}
	else {
		*InterruptRecognized = FALSE;
		*QueueMiniportHandleInterrupt = FALSE;
	}
}



//-----------------------------------------------------------------------------
// Procedure:	[MKMiniportHandleInterrupt]
//
// Description: This is the DPC for the ISR. It goes on to do RX & TX
//				completion processing.
//
// Arguments:
//		MiniportAdapterContext (miniport) - The context value returned by the
//				 Miniport when the adapter was initialized (see the call
//				NdisMSetAttributes). In reality, it is a pointer to MK7_ADAPTER.
//
// Returns: (none)
//-----------------------------------------------------------------------------
VOID
MKMiniportHandleInterrupt(NDIS_HANDLE MiniportAdapterContext)
{
	MK7REG	mk7reg;
	PMK7_ADAPTER Adapter = PMK7_ADAPTER_FROM_CONTEXT_HANDLE(MiniportAdapterContext);


	NdisAcquireSpinLock(&Adapter->Lock);

	DBGLOG("=> MKMiniportHandleInterrupt", Adapter->recentInt);

	//****************************************
	// DPC runs at Dispatch Level IRQL (just below ISR's DIRQL in proiority).
	// Note that recentInt can be modified in the ISR routine, which is
	// higher IRQL. But since this is DPC w/ int disabled, recentInt can
	// be safely queried.
	//****************************************
	ProcessTXComp(Adapter);
	ProcessRXComp(Adapter);

	Adapter->recentInt = 0;		// clear the saved int

	NdisReleaseSpinLock(&Adapter->Lock);
	MK7EnableInterrupt(Adapter);
}



//-----------------------------------------------------------------------------
// Procedure:	[ProcessRXComp]
//
// Description: This is the DPC for RX completions.
//
// Arguments:
//		Adapter - ptr to Adapter object instance
//
// Returns: (none)
//-----------------------------------------------------------------------------

VOID	ProcessRXComp(PMK7_ADAPTER Adapter)
{
	UINT			PacketArrayCount, i;
// 4.0.1 BOC
	UINT			PacketFreeCount;
// 4.0.1 EOC
	PNDIS_PACKET	PacketArray[MAX_ARRAY_RECEIVE_PACKETS];
	PRCB			rcb;
	PRRD			rrd;
	PRPD			rpd;
	UINT			rrdstatus;
	BOOLEAN			done=FALSE;
	BOOLEAN			gotdata=FALSE;
	MK7REG			intereg;
	UINT			rcvcnt;
// 4.0.1 BOC
	BOOLEAN			LowResource;
// 4.0.1 EOC


	// Process only if we get the corresponding int.
	if (!(Adapter->recentInt & B_RX_INTS)) {
		return;
	}

	DBGLOG("=> RX comp", 0);

#if DBG
	GDbgStat.rxIsrCnt++;
#endif


	// 1.0.0
	// If we have just started receiving a packet, indicate media-busy
	// to the protocol.
//    if (Adapter->mediaBusy && !Adapter->haveIndicatedMediaBusy) {
//   	    if (Adapter->CurrentSpeed > MAX_SIR_SPEED) {
//#if DBG
//			DBGLOG("Error: MKMiniportHandleInterrupt is in wrong state",
//	           	    Adapter->CurrentSpeed);
//#endif
//       	    ASSERT(0);
//        }
//   	    NdisMIndicateStatus(Adapter->MK7AdapterHandle,
//       	                    NDIS_STATUS_MEDIA_BUSY, NULL, 0);
//       NdisMIndicateStatusComplete(Adapter->MK7AdapterHandle);
		// RYM-5+
		// May need to protect this because ISR also writes to this?
//		Adapter->haveIndicatedMediaBusy = TRUE;
//    }



	rcb 		= Adapter->pRcbArray[Adapter->nextRxRcbIdx];
	rrd			= rcb->rrd;
	rrdstatus	= rrd->status;	// for debug

	do {
		PacketArrayCount = 0;
// 4.0.1 BOC
		LowResource = FALSE;
// 4.0.1 EOC.


// 4.0.1 BOC
		PacketFreeCount = 0;
// 4.0.1 EOC.
		// inner loop
		while ( !HwOwnsRrd(rrd) && 
				(PacketArrayCount < MAX_ARRAY_RECEIVE_PACKETS) ) {
// 4.0.1 BOC
			if (QueueEmpty(&Adapter->FreeRpdList))
				{
					break;
		        }
// 4.0.1 EOC.

#if	DBG
			// DBG_STAT
			if (RrdAnyError(rrd)) {
				GDbgStat.rxErrCnt++;
				GDbgStat.rxErr |= rrd->status;
				DBGSTATUS1("   RX err: %x \n\r", rrd->status);
			}
			if (Adapter->recentInt & B_RX_INTS)
				GDbgStat.rxComp++;
			else
				GDbgStat.rxCompNoInt++;
#endif

			if (RrdError(rrd)) {
				// If error just give RRD back to hw and continue.
				// (NOTE: This may indicate errors for MIR & FIR only.
				//		The sw does the FCS for SIR.)
				// (Note that hw may not detect all SIR errors.)
				rrd->count = 0;
				GrantRrdToHw(rrd);
				// Next receive to read from
				Adapter->nextRxRcbIdx++;
				Adapter->nextRxRcbIdx %= Adapter->NumRcb;
				rcb = Adapter->pRcbArray[Adapter->nextRxRcbIdx];
				rrd = rcb->rrd;
				rrdstatus = rrd->status;	// for debug
//				break;		// this to do 1 rx per int

				DBGLOG("   RX err", 0);

				continue;	// this to do > 1 rx per int
			}
				

			// Additional software processing for SIR frames
			if (Adapter->CurrentSpeed <= MAX_SIR_SPEED) {
				if (!ProcRXSir(rcb->rpd->databuff, (UINT)rrd->count)) {
					// If error just give RRD back to hw and continue.
					rrd->count = 0;
					GrantRrdToHw(rrd);
					// Next receive to read from
					Adapter->nextRxRcbIdx++;
					Adapter->nextRxRcbIdx %= Adapter->NumRcb;
					rcb = Adapter->pRcbArray[Adapter->nextRxRcbIdx];
					rrd = rcb->rrd;
					rrdstatus = rrd->status;	// for debug
#if	DBG
					GDbgStat.rxErrCnt++;
					GDbgStat.rxErrSirCrc++;
#endif
					//	break;		// this to do 1 rx per int

					DBGLOG("   RX err", 0);

					continue;	// this to do > 1 rx per int
				}
			}


			// Remove count of FCS bytes:
			//	SIR/MIR = 2 (16 bits)
			//	FIR/VFIR = 4 (32 bits)
			if (Adapter->CurrentSpeed < MIN_FIR_SPEED) {
				rcvcnt = (UINT) rrd->count - SIR_FCS_SIZE;
				DBGLOG("   RX comp (slow)", 0);
			}
			else {
				rcvcnt = (UINT) rrd->count - FASTIR_FCS_SIZE;
				DBGLOG("   RX comp (fast)", 0);
			}


			NdisAdjustBufferLength(rcb->rpd->ReceiveBuffer, rcvcnt);



#if	DBG
			if (rcvcnt > GDbgStat.rxLargestPkt) {
				GDbgStat.rxLargestPkt = rcvcnt;
			}

//			NdisGetCurrentSystemTime((PLARGE_INTEGER)&GDbgTARspTime[GDbgTATimeIdx]);
//			GDbgTATime[GDbgTATimeIdx] = GDbgTARspTime[GDbgTATimeIdx] -
//				GDbgTACmdTime[GDbgTATimeIdx];
//			GDbgTATimeIdx++;
//			GDbgTATimeIdx %= 1000;	// wrap around
#endif


			PacketArray[PacketArrayCount] = rcb->rpd->ReceivePacket;
// 4.0.1 BOC
			if (((Adapter->NumRpd - Adapter->UsedRpdCount-Adapter->NumRcb) <= 4)|| LowResource==TRUE) {
				NDIS_SET_PACKET_STATUS(PacketArray[PacketArrayCount], NDIS_STATUS_RESOURCES);
				LowResource = TRUE;
				PacketFreeCount++;
			}
			else {
				// NDIS_SET_PACKET_STATUS(PacketArray[PacketArrayCount], NDIS_STATUS_SUCCESS);
				NDIS_SET_PACKET_STATUS(PacketArray[PacketArrayCount], NDIS_STATUS_SUCCESS);
			}
// 4.0.1 EOC

			PacketArrayCount++;

// 4.0.1 BOC
			Adapter->UsedRpdCount++;
// 4.0.1 EOC

			// unbind the one we just indicated to upper layer
			rcb->rpd = (PRPD)NULL;
			rcb->rrd->addr = 0;


			// get a new one for the next rx
			rpd = (PRPD) QueuePopHead(&Adapter->FreeRpdList);

// 4.0.1 BOC
			ASSERT(!(rpd == (PRPD)NULL));
//			if (rpd == (PRPD)NULL) {

				//****************************************
				// If there's no existing RCB that's waiting for a
				// RPD, set the start of waiting RCBs to this one.
				//****************************************
//				if (Adapter->rcbPendRpdCnt == 0) {
//					Adapter->rcbPendRpdIdx = Adapter->nextRxRcbIdx;
//				}
//				Adapter->rcbPendRpdCnt++;
//
//#if DBG
//				GDbgStat.rxNoRpd++;
//#endif
//			}
//			else {
// 4.0.1 EOC
				// bind new RDP-Packet to RCB-RRD
				rcb->rpd = rpd;
				rcb->rrd->addr = rpd->databuffphys;
				rcb->rrd->count = 0;
				GrantRrdToHw(rcb->rrd);
// 4.0.1 BOC
//				}
// 4.0.1 EOC.

			// Next receive to read from
			Adapter->nextRxRcbIdx++;
			Adapter->nextRxRcbIdx %= Adapter->NumRcb;


			rcb = Adapter->pRcbArray[Adapter->nextRxRcbIdx];
			rrd = rcb->rrd;
			rrdstatus = rrd->status;	// for debug

		}	// while


		if (PacketArrayCount >= MAX_ARRAY_RECEIVE_PACKETS) {
			DBGLOG("   RX max indicate", 0);
		}


		//****************************************
		// RYM-5+
		// NOTE: This controls whether we poll the next ring buffers
		//		 for data after serviceing the current ring buffer that
		//		 caused the original RX int. The current int scheme
		//		 is to get 1 rx buffer per int. So the following lines
		// 		 are replaced with a 1 rx per int logic.
		// **We're done when we run into the 1st Ring entry that
		// **we have no ownership.
		//****************************************
		if (HwOwnsRrd(rrd))
			done = TRUE;
//		done = TRUE;

		// Indicate away
		if(PacketArrayCount) {
			NdisReleaseSpinLock(&Adapter->Lock);
			NdisMIndicateReceivePacket(Adapter->MK7AdapterHandle,
							PacketArray,
							PacketArrayCount);
#if	DBG
			GDbgStat.rxPktsInd += PacketArrayCount;
#endif
			gotdata = TRUE;

			NdisAcquireSpinLock(&Adapter->Lock);
			//DBGLOG("   ProcessRXInterrupt: indicated Packet(s)", PacketArrayCount);
		}


		//****************************************
		// Check Packet status on return from Indicate. Pending means
		// NDIS-upper layer still holds it, else it's ours.
		//****************************************
		// Don't do this for deserialized driver.
//		for (i=0; i<PacketArrayCount; i++ ) {
//			NDIS_STATUS ReturnStatus;
//
//			ReturnStatus = NDIS_GET_PACKET_STATUS(PacketArray[i]);
//			
			// recover the RPD
//			rpd = *(PRPD *)(PacketArray[i]->MiniportReserved);
//			
//			if (ReturnStatus != NDIS_STATUS_PENDING) {
//				ProcReturnedRpd(Adapter, rpd);
//			}
//		}
// 4.0.1 BOC
		for (i=PacketArrayCount-PacketFreeCount; i<PacketArrayCount; i++){
			rpd = *(PRPD *)(PacketArray[i]->MiniportReserved);
			ProcReturnedRpd(Adapter, rpd);
			Adapter->UsedRpdCount--;
		}
// 4.0.1 EOC.

	} while (!done);

	Adapter->nowReceiving = FALSE;

}


//-----------------------------------------------------------------------------
// Procedure:   [ProcessTXComp]
//
// Description: TX complete processing in DPC. This is very similar to
//		ProcessTXCompIsr(), the main difference being we also process the TX
//		queue here and perform TXs as necessary.
//
// Arguements:	Adapter.
//
// Result:		(none)
//-----------------------------------------------------------------------------
VOID	ProcessTXComp(PMK7_ADAPTER Adapter)
{
    PTCB			tcb;
	MK7REG			mk7reg;
	NDIS_STATUS		SendStatus;
	PNDIS_PACKET	QueuePacket;


	// Process only if we get the corresponding int.
	if (!(Adapter->recentInt & B_TX_INTS)) {
		return;
	}


	DBGLOG("=> TX comp", 0);


#if DBG
		GDbgStat.txIsrCnt++;
#endif

	// Debug
	if (Adapter->CurrentSpeed > MAX_SIR_SPEED) {
		DBGLOG("   TX comp (fast)", 0);
	}
	else {
		DBGLOG("   TX comp (slow)", 0);
	}


	// Simplified change speed
	if (Adapter->changeSpeedPending == CHANGESPEED_ON_DONE) {
		// Note: We're changing speed in TX mode.
		MK7ChangeSpeedNow(Adapter);
		Adapter->changeSpeedPending = 0;
	}


	while (Adapter->tcbUsed > 0) {
		tcb = Adapter->pTcbArray[Adapter->nextReturnTcbIdx];

		if ( !HwOwnsTrd(tcb->trd) ) {
#if	DBG
			if (TrdAnyError(tcb->trd)) {
				GDbgStat.txErrCnt++;
				GDbgStat.txErr |= tcb->trd->status;
				DBGSTATUS1("   TX err: %x \n\r", tcb->trd->status);
			}
			if (Adapter->recentInt & B_TX_INTS)
				GDbgStat.txComp++;
			else
				GDbgStat.txCompNoInt++;
#endif
			tcb->trd->count = 0; 


			// For each completing TX there's a corresponding q'd pkt.
			// We release it here.
			QueuePacket = Adapter->FirstTxQueue;
			DequeuePacket(Adapter->FirstTxQueue, Adapter->LastTxQueue);
			Adapter->NumPacketsQueued--;
			NDIS_SET_PACKET_STATUS(QueuePacket, NDIS_STATUS_SUCCESS);
			NdisMSendComplete(	Adapter->MK7AdapterHandle,
								QueuePacket,
								NDIS_STATUS_SUCCESS);
			Adapter->HangCheck = 0;			// 1.0.0
			Adapter->nextReturnTcbIdx++;
			Adapter->nextReturnTcbIdx %= Adapter->NumTcb;
			Adapter->tcbUsed--;
		}
		else {
			DBGLOG("   Not our TCB; but tcbUsed>0", 0);
			break;
		}
	}


	// No resource even if we have more to send. Return now & let subsequent
	// TX completes keep the ball rolling.
	if (Adapter->tcbUsed >= Adapter->NumTcb) {
		// NdisReleaseSpinLock(&Adapter->Lock);
		return;
	}


	// If no TXs queued and all TXs are done, then switch to RX mode.
    if ( (!Adapter->FirstTxQueue) && (Adapter->tcbUsed == 0) ) {
		MK7SwitchToRXMode(Adapter);
		return;
    }


	// Send the q'd pkts until all done or until all TX ring buffers are used up.
	//while(Adapter->FirstTxQueue) {
	if (Adapter->FirstTxQueue) {

#if	DBG
		GDbgStat.txProcQ++;
#endif

		DBGLOG("   Proc Q", 0);

		QueuePacket = Adapter->FirstTxQueue;
		SendStatus = SendPkt(Adapter, QueuePacket);
	}
}


//-----------------------------------------------------------------------------
// Procedure:   [ProcessRXCompIsr]
//
// Description: Some RX complete processing in ISR.
//
// Arguements:	Adapter.
//
// Result:		(none)
//-----------------------------------------------------------------------------
VOID	ProcessRXCompIsr(PMK7_ADAPTER Adapter)
{

	// 4.1.0 Back for HW_VER_1 support
	if (Adapter->recentInt & B_RX_INTS) {
		Adapter->nowReceiving=TRUE;
//		if (!Adapter->mediaBusy) {
			// mediaBusy: IrLAP clears mediaBusy (via OID) to indicate
			// it wants to be notified when media becomes busy. Here
			// we detect it is cleared. We then set it and clear
			// haveIndicatedMediaBusy so we do notify later in DPC.
//			Adapter->mediaBusy = TRUE;
//			Adapter->haveIndicatedMediaBusy = FALSE;
//			Adapter->nowReceiving = TRUE;
//		}
	}
}



//-----------------------------------------------------------------------------
// Procedure:   [ProcessTXCompIsr]
//
// Description: TX complete processing in ISR. This is very similar to
//		ProcessTXComp() except we don't start any TX's here.
//
// Arguements:	Adapter.
//
// Result:		(none)
//-----------------------------------------------------------------------------
VOID	ProcessTXCompIsr(PMK7_ADAPTER Adapter)
{
    PTCB	tcb;
	MK7REG	mk7reg;

	//******************************
	// Whether or not there was a TX-completion interrupt, we do some
	// processing here in case ever the driver or hw missed an
	// interrupt previously.
	//
	// We loop until all tcb's are returned (tcbUsed == 0) or we run into
	// a TX ring buff that the hw still owns (HwOwnsTrd()). When we leave
	// here, we should have processed all current TX completions based on
	// the TX ownership bit. We switch to RX mode ONLY after all TX are
	// completed (either here in the ISR or in DPC).
	//******************************


	while (Adapter->tcbUsed > 0) {
		tcb = Adapter->pTcbArray[Adapter->nextReturnTcbIdx];

		if ( !HwOwnsTrd(tcb->trd) ) {
#if	DBG
			if (TrdAnyError(tcb->trd)) {
				GDbgStat.txErrCnt++;
				GDbgStat.txErr |= tcb->trd->status;
				DBGSTATUS1("   TX err: %x \n\r", tcb->trd->status);
			}
			if (Adapter->recentInt & B_TX_INTS)
				GDbgStat.txComp++;
			else
				GDbgStat.txCompNoInt++;
#endif
			tcb->trd->count = 0; 
			Adapter->nextReturnTcbIdx++;
			Adapter->nextReturnTcbIdx %= Adapter->NumTcb;
			Adapter->tcbUsed--;
		}
		else {
			return;
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\net\irda\mknet\sys\mk7comm.c ===
/*****************************************************************************
 **																			**
 **	COPYRIGHT (C) 2000, 2001 MKNET CORPORATION								**
 **	DEVELOPED FOR THE MK7100-BASED VFIR PCI CONTROLLER.						**
 **																			**
 *****************************************************************************/

/**********************************************************************

Module Name:
	MK7COMM.C

Routines:
	MK7Reg_Write
	MK7Reg_Read
	MK7DisableInterrupt
	MK7EnableInterrupt
	MK7SwitchToRXMode
	MK7SwitchToTXMode
	SetSpeed
	MK7ChangeSpeedNow

Comments:


**********************************************************************/

#include	"precomp.h"
#include	"protot.h"
#pragma		hdrstop


baudRateInfo supportedBaudRateTable[NUM_BAUDRATES] = {
	{
		BAUDRATE_2400,					// Table index
		2400,							// bps
		NDIS_IRDA_SPEED_2400,			// NDIS bit mask code (NOTE: We don't support 
										// 2400. We set this bit to 0.)
	},
	{
		BAUDRATE_9600,
		9600,
		NDIS_IRDA_SPEED_9600,
	},
	{
		BAUDRATE_19200,
		19200,
		NDIS_IRDA_SPEED_19200,
	},
	{
		BAUDRATE_38400,
		38400,
		NDIS_IRDA_SPEED_38400,
	},
	{
		BAUDRATE_57600,
		57600,
		NDIS_IRDA_SPEED_57600,
	},
	{
		BAUDRATE_115200,
		115200,
		NDIS_IRDA_SPEED_115200,
	},
	{
		BAUDRATE_576000,
		576000,
		NDIS_IRDA_SPEED_576K,
	},
	{
		BAUDRATE_1152000,
		1152000,
		NDIS_IRDA_SPEED_1152K,
	},
	{
		BAUDRATE_4M,
		4000000,
		NDIS_IRDA_SPEED_4M,
	},
	{
		BAUDRATE_16M,
		16000000,
		NDIS_IRDA_SPEED_16M,
	}
};



// Write to IRCONFIG2 w/ these to set SIR/MIR speeds
MK7REG	HwSirMirSpeedTable[] = {
	HW_SIR_SPEED_2400,
	HW_SIR_SPEED_9600,
	HW_SIR_SPEED_19200,
	HW_SIR_SPEED_38400,
	HW_SIR_SPEED_57600,
	HW_SIR_SPEED_115200,
	HW_MIR_SPEED_576000,
	HW_MIR_SPEED_1152000
};



#if	DBG

//----------------------------------------------------------------------
//
//	NOTE: The following Write and Read routines are bracketed w/ DBG
//		switch. In the non-debug version, these 2 calls are inline
//		macros for faster execution.
//
//----------------------------------------------------------------------


//----------------------------------------------------------------------
// Procedure:	[MK7Reg_Write]
//
// Description:	Write to the MK7100 register.
//				(Note: In the free build, this is an inline macro. It's
//				here in the checked build for debugging.)
//----------------------------------------------------------------------
VOID MK7Reg_Write(PMK7_ADAPTER Adapter, ULONG port, USHORT val)
{
	PUCHAR	ioport;

	// Break this out for debugging
	ioport = Adapter->MappedIoBase + port;
	NdisRawWritePortUshort(ioport, val);
}



//----------------------------------------------------------------------
// Procedure:	[MK7Reg_Read]
//
// Description:	Read from MK7100 register.
//				(Note: In the free build, this is an inline macro. It's
//				here in the checked build for debugging.)
//----------------------------------------------------------------------
VOID MK7Reg_Read(PMK7_ADAPTER Adapter, ULONG port, USHORT *pval)
{
	PUCHAR 	ioport;

	// Break this out for debugging
	ioport = Adapter->MappedIoBase + port;
	NdisRawReadPortUshort(ioport, pval);
}

#endif


//----------------------------------------------------------------------
// Procedure:	[MK7DisableInterrupt]
//
// Description:	Disable all interrupts on the MK7
//
// Arguments:
//		Adapter - ptr to Adapter object instance
//
// Returns:
//	  	NDIS_STATUS_SUCCESS - If an adapter is successfully found and claimed
//	  	NDIS_STATUS_FAILURE - If an adapter is not found/claimed
//
//----------------------------------------------------------------------
NDIS_STATUS MK7DisableInterrupt(PMK7_ADAPTER Adapter)
{
	MK7REG	mk7reg;
	UINT	i;


	// NOTE: Workaround for potential hw problem where 0xFFFF is returned
	for (i=0; i<50; i++) {
		MK7Reg_Read(Adapter, R_CFG3, &mk7reg);
		if (mk7reg != 0xFFFF) {
			break;
		}
	}
	ASSERT(i < 50);

	mk7reg &= (~B_ENAB_INT);

	MK7Reg_Write(Adapter, R_CFG3, mk7reg);
	return(NDIS_STATUS_SUCCESS);
}



//----------------------------------------------------------------------
// Procedure:	[MK7EnableInterrupt]
//
// Description:	Enable all interrupts on the MK7
//
// Arguments:
//		Adapter - ptr to Adapter object instance
//
// Returns:
//	  	NDIS_STATUS_SUCCESS - If an adapter is successfully found and claimed
//	  	NDIS_STATUS_FAILURE - If an adapter is not found/claimed
//
//----------------------------------------------------------------------
NDIS_STATUS MK7EnableInterrupt(PMK7_ADAPTER Adapter)
{
	MK7REG	mk7reg;
	UINT	i;


	// NOTE: Workaround for potential hw problem where 0xFFFF is returned
	for (i=0; i<50; i++) {
		MK7Reg_Read(Adapter, R_CFG3, &mk7reg);
		if (mk7reg != 0xFFFF) {
			break;
		}
	}
	ASSERT(i < 50);

	mk7reg |= B_ENAB_INT;


	MK7Reg_Write(Adapter, R_CFG3, mk7reg);

	// PROMPT - Always after an Enable
	MK7Reg_Write(Adapter, R_PRMT, 0);

	return(NDIS_STATUS_SUCCESS);
}



//----------------------------------------------------------------------
// Procedure:	[MK7SwitchToRXMode]
//
// Description:	Put hw in receive mode.
//
// Actions:
//	- Hw registers are programmed accordingly.
//	- IOMode set to RX_MODE.
//	- SlaveTXStuckCnt reset.
//----------------------------------------------------------------------
VOID	MK7SwitchToRXMode(PMK7_ADAPTER Adapter)
{
	MK7REG mk7reg;

	MK7Reg_Read(Adapter, R_CFG0, &mk7reg);
	mk7reg &= (~B_CFG0_ENTX);
	MK7Reg_Write(Adapter, R_CFG0, mk7reg);		
	Adapter->IOMode = RX_MODE;

	DBGLOG("-  Switch to RX mode", 0);
}



//----------------------------------------------------------------------
// Procedure:	[MK7SwitchToTXMode]
//
// Description:	Put hw in receive mode.
//
// Actions:
//	- Hw registers are programmed accordingly.
//	- IOMode set to TX_MODE.
//----------------------------------------------------------------------
VOID	MK7SwitchToTXMode(PMK7_ADAPTER Adapter)
{
	MK7REG mk7reg;

	MK7Reg_Read(Adapter, R_CFG0, &mk7reg);
	mk7reg |= B_CFG0_ENTX;
	MK7Reg_Write(Adapter, R_CFG0, mk7reg);
	Adapter->IOMode = TX_MODE;

	DBGLOG("-  Switch to TX mode", 0);
}



//----------------------------------------------------------------------
// Procedure:	[SetSpeed]
//
// Description:
//		Set the hw to a new speed.
//		[IMPORTANT: This should be called only from xxxSetInformation().]
//
// Actions:
//----------------------------------------------------------------------
BOOLEAN	SetSpeed(PMK7_ADAPTER Adapter)
{
	UINT	i, bps;
	MK7REG	mk7reg;
    PTCB	tcb;

	//******************************
	// The idea is any sends that came before the change-speed command are
	// sent at the old speed. There are 3 scenarios here:
	//	1.	There's no TXs outstanding -- We can change speed right away.
	//	2.	There's TXs oustanding in the TX ring but none in the TX q -- We
	//		do not change speed right away.
	//	3.	There's TXs oustanding in the TX q (may be also in the TX ring) --
	//		We do not change speed right away.
	//******************************


	DBGLOG("=> SetSpeed", 0);

	// If we're already waiting to change speed, fail all such requests
	// until the original is done. (Is this good?)
	//if (Adapter->changeSpeedPending) {
	//	LOG("SetSpeed: already pending", 0);
	//	return (FALSE);
	//}

	// This means 1 TX is already active. Change speed on completion.
	if (Adapter->NumPacketsQueued == 1) {
		Adapter->changeSpeedPending = CHANGESPEED_ON_DONE; // After the latest tx
		DBGLOG("<= SetSpeed: Q", 0);
		return (TRUE);
	}
	else
	if (Adapter->NumPacketsQueued > 1) {
		Adapter->changeSpeedAfterThisPkt = Adapter->LastTxQueue;
		Adapter->changeSpeedPending = CHANGESPEED_ON_Q;
		DBGLOG("<= SetSpeed: Qs", 0);
		return (TRUE);
	}


	// There's nothing pending TX or TX completion we must be
	// changing speed in RX mode.
	MK7ChangeSpeedNow(Adapter);

	return(TRUE);
}



//----------------------------------------------------------------------
// Procedure:	[MK7ChangeSpeedNow]
//
// Description:
//		Set the hw to a new speed.
//
// Actions:
//----------------------------------------------------------------------
VOID	MK7ChangeSpeedNow(PMK7_ADAPTER Adapter)
{
	UINT	i, bps;
	MK7REG	mk7reg,	mk7reg_cfg3, mk7reg_w;


	DBGLOG("=> MK7ChangeSpeedNow", 0);

	bps = Adapter->linkSpeedInfo->bitsPerSec;


	//****************************************
	// Clear IRENABLE Bit
	// This is the only writeable bit in this reg so just write it.
	//****************************************
	MK7Reg_Write(Adapter, R_ENAB, ~B_ENAB_IRENABLE);


	// NOTE: Workaround for potential hw problem where 0xFFFF is returned.
	// (See aLSO MK7EnableInterrupt & MK7DisableInterrupt)
	for (i=0; i<50; i++) {
		MK7Reg_Read(Adapter, R_CFG3, &mk7reg_cfg3);
		if (mk7reg_cfg3 != 0xFFFF) {
			break;
		}
	}
	ASSERT(i < 50);


	// Need distinguish between changing speed in RX or TX mode.
	// Prep the bit that says TX or RX
	if (Adapter->IOMode == TX_MODE) {
		mk7reg_w = 0x1000;
	}
	else {
		mk7reg_w = 0;
	}


	if (bps <= MAX_SIR_SPEED) {	// SIR
		if (Adapter->Wireless) {
	 		// WIRELESS: ... no INVERTTX
			mk7reg_w |= 0x0E18;
		}
		else {
			// WIRED: ENRX, DMA, small pkts, SIR, SIR RX filter, INVERTTX
			mk7reg_w |= 0x0E1A;
		}
		MK7Reg_Write(Adapter, R_CFG0, mk7reg_w);

		// Baud rate & pulse width
		i = Adapter->linkSpeedInfo->tableIndex;
		mk7reg = HwSirMirSpeedTable[i];
		MK7Reg_Write(Adapter, R_CFG2, mk7reg);

		mk7reg_cfg3 &= ~B_FAST_TX;
		MK7Reg_Write(Adapter, R_CFG3, mk7reg_cfg3);

		DBGLOG("   SIR", 0);
	}
	else
	if (bps < MIN_FIR_SPEED) {	// MIR
		if (Adapter->Wireless) {
	 		// WIRELESS: ... no INVERTTX
			mk7reg_w |= 0x0CA0;
		}
		else {
			// WIRED: ENRX, DMA, 16-bit CRC, MIR, INVERTTX
			mk7reg_w |= 0x0CA2;
		}
		MK7Reg_Write(Adapter, R_CFG0, mk7reg_w);
	
		// Baud rate & pulse width, & preamble
		i = Adapter->linkSpeedInfo->tableIndex;
		mk7reg = HwSirMirSpeedTable[i];
		mk7reg |= 0x0001;		// Preamble
		MK7Reg_Write(Adapter, R_CFG2, mk7reg);

		mk7reg_cfg3 |= B_FAST_TX;
		MK7Reg_Write(Adapter, R_CFG3, mk7reg_cfg3);

		DBGLOG("   MIR", 0);
	}
	else
	if (bps < VFIR_SPEED) {		// FIR
		if (Adapter->Wireless) {
	 		// WIRELESS: ... no INVERTTX
			mk7reg_w |= 0x0C40;
		}
		else {
			// WIRED: ENRX, DMA, 32-bit CRC, FIR, INVERTTX
			mk7reg_w |= 0x0C42;
		}
		MK7Reg_Write(Adapter, R_CFG0, mk7reg_w);

		MK7Reg_Write(Adapter, R_CFG2, 0x000A);		// 10 Preambles

		mk7reg_cfg3 |= B_FAST_TX;
		MK7Reg_Write(Adapter, R_CFG3, mk7reg_cfg3);

		DBGLOG("   FIR", 0);
	}
	else {						// VFIR
		// For testing 4Mbps in VFIR mode.
		//if (Adapter->Wireless) {
	 		// WIRELESS: ... no INVERTTX
		//	mk7reg_w |= 0x0C40;
		//}
		//else {
			// WIRED: ENRX, DMA, 32-bit CRC, FIR, INVERTTX
		//	mk7reg_w |= 0x0C42;
		//}
		//MK7Reg_Write(Adapter, R_CFG0, mk7reg_w);

		if (Adapter->Wireless) {
	 		// WIRELESS: ... no INVERTTX
			mk7reg_w |= 0x2C00;
		}
		else {
			// WIRED: VFIR, ENRX, DMA, 32-bit CRC, FIR, INVERTTX
			mk7reg_w |= 0x2C02;
		}
		MK7Reg_Write(Adapter, R_CFG0, mk7reg_w);


		MK7Reg_Write(Adapter, R_CFG2, 0x000A);	// 10 Preambles

		mk7reg_cfg3 |= B_FAST_TX;
		MK7Reg_Write(Adapter, R_CFG3, mk7reg_cfg3);

		DBGLOG("   VFIR", 0);
	}


	Adapter->CurrentSpeed = bps;


	//****************************************
	// Set IRENABLE Bit
	//****************************************
	MK7Reg_Write(Adapter, R_ENAB, B_ENAB_IRENABLE);


	//****************************************
	// PROMPT
	//****************************************
	MK7Reg_Write(Adapter, R_PRMT, 0);

	return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\net\irda\mknet\sys\precomp.h ===
/*****************************************************************************
 **																			**
 **	COPYRIGHT (C) 2000, 2001 MKNET CORPORATION								**
 **	DEVELOPED FOR THE MK7100-BASED VFIR PCI CONTROLLER.						**
 **																			**
 *****************************************************************************/

#include	"mk7.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\net\irda\mknet\sys\mkmini.c ===
/*****************************************************************************
 **																			**
 **	COPYRIGHT (C) 2000, 2001 MKNET CORPORATION								**
 **	DEVELOPED FOR THE MK7100-BASED VFIR PCI CONTROLLER.						**
 **																			**
 *****************************************************************************/

/*****************************************************************************

Module Name:
	MKMINI.C

Routines:
	MKMiniportReturnPackets
	MKMiniportCheckForHang
	MKMiniportHalt
	MKMiniportShutdownHandler
	MKMiniportInitialize
	MKMiniportReset
	(MK7EnableInterrupt & Disable in MK7COMM.C.)
	DriverEntry

Comments:
	Contains most NDIS API routines supplied to Windows by the miniport.

*****************************************************************************/

#include	"precomp.h"
#pragma		hdrstop
#include	"protot.h"


// Globals to help debug/test
PMK7_ADAPTER	GAdapter;




//-----------------------------------------------------------------------------
// Procedure:	[MKMiniportReturnPackets]
//
// Description: NDIS returns a previously indicated pkt by calling this routine.
//
// Arguments:
//		IN NDIS_HANDLE MiniportAdapterContext
//			- a context version of our Adapter pointer
//		IN NDIS_PACKET Packet
//			- the packet that is being freed
//
// Returns:		(none)
//
//-----------------------------------------------------------------------------
VOID MKMiniportReturnPackets(	NDIS_HANDLE  MiniportAdapterContext,
								PNDIS_PACKET Packet)
{
	PMK7_ADAPTER	Adapter;
	PRPD			rpd;
	PRCB			rcb;

	//****************************************
	// - SpinLock brackets the FreeList resource.
	// - Recover the RPD from the returned pkt, then return
	//   the RPD to the FreeList.
	//****************************************

	Adapter = PMK7_ADAPTER_FROM_CONTEXT_HANDLE(MiniportAdapterContext);

	NdisAcquireSpinLock(&Adapter->Lock);

	ASSERT(Packet);

#if	DBG
	GDbgStat.rxPktsRtn++;
#endif

	rpd = *(PRPD *)(Packet->MiniportReserved);

	ASSERT(rpd);

	ProcReturnedRpd(Adapter, rpd);

// 4.0.1 BOC
	Adapter->UsedRpdCount--;
// 4.0.1 EOC

	NdisReleaseSpinLock(&Adapter->Lock);
}


//-----------------------------------------------------------------------------
// Procedure:	[MKMiniportCheckForHang]
//
// Description: This procedure does not do much for now.
//
// Arguments:
//		MiniportAdapterContext (both) - pointer to the adapter object data area
//
// Returns:
//		FALSE or TRUE
//-----------------------------------------------------------------------------
BOOLEAN MKMiniportCheckForHang(NDIS_HANDLE MiniportAdapterContext)
{
	PMK7_ADAPTER Adapter;

	Adapter = PMK7_ADAPTER_FROM_CONTEXT_HANDLE(MiniportAdapterContext);

	NdisAcquireSpinLock(&Adapter->Lock);
	// DbgPrint(" ==> Hang Check\n\r");
	if (Adapter->IOMode == TX_MODE) {
		Adapter->HangCheck++;
		if (Adapter->HangCheck >= 3) {
			NdisReleaseSpinLock(&Adapter->Lock);
			return(TRUE);
		}
	}
	NdisReleaseSpinLock(&Adapter->Lock);

	return(FALSE);
}


//-----------------------------------------------------------------------------
// Procedure:	[MKMiniportHalt]
//
// Description: Halts our hardware. We disable interrupts as well as the hw
//				itself. We release other Windows resources such as allocated
//				memory and timers.
//
// Arguments:
//		MiniportAdapterContext - pointer to the adapter object data area.
//
// Returns:		(none)
//-----------------------------------------------------------------------------
VOID MKMiniportHalt(NDIS_HANDLE MiniportAdapterContext)
{
	PMK7_ADAPTER Adapter;
	BOOLEAN		Cancelled;


	DBGFUNC("  MKMiniportHalt");

	Adapter = PMK7_ADAPTER_FROM_CONTEXT_HANDLE(MiniportAdapterContext);

	MK7DisableInterrupt(Adapter);
	MK7DisableIr(Adapter);

    Adapter->hardwareStatus = NdisHardwareStatusClosing;


	// check to make sure there are no outstanding transmits
	while(Adapter->FirstTxQueue) {
		PNDIS_PACKET QueuePacket = Adapter->FirstTxQueue;

		Adapter->NumPacketsQueued--;
		DequeuePacket(Adapter->FirstTxQueue, Adapter->LastTxQueue);

		NDIS_SET_PACKET_STATUS(QueuePacket, NDIS_STATUS_FAILURE);
		NdisMSendComplete(
			Adapter->MK7AdapterHandle,
			QueuePacket,
			NDIS_STATUS_FAILURE);
	}


	// deregister shutdown handler
	NdisMDeregisterAdapterShutdownHandler(Adapter->MK7AdapterHandle);

	// Free the interrupt object
	NdisMDeregisterInterrupt(&Adapter->Interrupt);

	NdisMCancelTimer(&Adapter->MinTurnaroundTxTimer, &Cancelled);

	NdisFreeSpinLock(&Adapter->Lock);

	// Free the entire adapter object, including the shared memory structures.
	FreeAdapterObject(Adapter);
}

//-----------------------------------------------------------------------------
// Procedure:	[MKMiniportShutdownHandler]
//
// Description: Removes an adapter instance that was previously initialized.
//		To Shutdown simply Disable interrupts.	Since the system is shutting
//		down there is no need to release resources (memory, i/o space, etc.)
//		that the adapter instance was using.
//
// Arguments:
//		MiniportAdapterContext - pointer to the adapter object data area.
//
// Returns:		(none)
//-----------------------------------------------------------------------------
VOID MKMiniportShutdownHandler(NDIS_HANDLE MiniportAdapterContext)

{
	PMK7_ADAPTER Adapter;

	Adapter = PMK7_ADAPTER_FROM_CONTEXT_HANDLE(MiniportAdapterContext);

	MK7DisableInterrupt(Adapter);
}

//-----------------------------------------------------------------------------
// Procedure:	[MKMiniportInitialize] (only single adapter support for now)
//
// Description: This routine is called once per supported adapter card in the
//		system. This routine is responsible for initializing each adapter.
//		This includes parsing all of the necessary parameters from the registry,
//		allocating and initializing shared memory structures, configuring the
//		MK7100 chip, registering the interrupt, etc.
//
// Arguments:
//		OpenErrorStatus (mini) - Returns more info about any failure
//		SelectedMediumIndex (mini) - Returns the index in MediumArray of the
//									 medium that the miniport is using
//		MediumArraySize (mini) - An array of medium types that the driver
//								 supports
//		MiniportAdapterHandle (mini) - pointer to the adapter object data area.
//
//		WrapperConfigurationContext (both) - A value that we will pass to
//											 NdisOpenConfiguration.
//
//
// Returns:
//		NDIS_STATUS_SUCCESS - If the adapter was initialized successfully.
//		<not NDIS_STATUS_SUCCESS> - If for some reason the adapter didn't
//									initialize
//-----------------------------------------------------------------------------
NDIS_STATUS
MKMiniportInitialize(PNDIS_STATUS OpenErrorStatus,
			   PUINT SelectedMediumIndex,
			   PNDIS_MEDIUM MediumArray,
			   UINT MediumArraySize,
			   NDIS_HANDLE MiniportAdapterHandle,
			   NDIS_HANDLE WrapperConfigurationContext)
{
	ULONG				i;
	NDIS_STATUS			Status;
	PMK7_ADAPTER		Adapter;
	NDIS_HANDLE			ConfigHandle;
	NDIS_INTERFACE_TYPE IfType;
	PVOID				OverrideNetAddress;
	MK7REG				mk7reg;


	DBGFUNC("  MKMiniportInitialize");

	//****************************************
	// We're an IrDA device. Exit w/ error if type not passed in.
	//****************************************
	for (i = 0; i < MediumArraySize; i++) {
		if (MediumArray[i] == NdisMediumIrda)
			break;
	}

	if (i == MediumArraySize) {
		DBGSTR(("ERROR: IrDA Media type not found.\n"));
		DBGLOG("=> MKMiniportInitialize (ERR): IrDA not found", 0);
		return (NDIS_STATUS_UNSUPPORTED_MEDIA);
	}

	*SelectedMediumIndex = i;

	//****************************************
	// Allocate the Adapter Object, exit if error.
	// (Cacheable, non-paged system memory)
	//****************************************
	Status = ALLOC_SYS_MEM(&Adapter, sizeof(MK7_ADAPTER));
	if (Status != NDIS_STATUS_SUCCESS) {
		DBGSTR(("ERROR: ADAPTER Allocate Memory failed (Status = 0x%x)\n", Status));
		DBGLOG("<= MKMiniportInitialize: (ERR - 1)", 0);
		return (Status);
	}
	NdisZeroMemory(Adapter, sizeof(MK7_ADAPTER));
	Adapter->MK7AdapterHandle = MiniportAdapterHandle;

	GAdapter = Adapter;

    Adapter->hardwareStatus = NdisHardwareStatusInitializing;

	//****************************************
	// Process the Registry -- Get config settings, etc.
	//****************************************
	Status = ProcessRegistry(Adapter, WrapperConfigurationContext);	
	if (Status != NDIS_STATUS_SUCCESS) {
		FreeAdapterObject(Adapter);
		DBGSTR(("ERROR: ProcessRegistry() \n"));
		DBGLOG("<= MKMiniportInitialize: (ERR - 2)", 0);
		return (NDIS_STATUS_FAILURE);
	}


	//****************************************
	// Let NDIS know kind of driver and features we support
	//****************************************
	IfType = NdisInterfacePci;

	NdisMSetAttributesEx(
		Adapter->MK7AdapterHandle,
		(NDIS_HANDLE) Adapter,
		0,
		(ULONG) NDIS_ATTRIBUTE_DESERIALIZE | NDIS_ATTRIBUTE_BUS_MASTER,
		IfType );


	//****************************************
	// Claim the physical Adapter for this Adapter object. We call on
	// NdisMPciAssignResources to find our assigned resources.
	//****************************************
	if (ClaimAdapter(Adapter, WrapperConfigurationContext) != NDIS_STATUS_SUCCESS) {
		FreeAdapterObject(Adapter);
		DBGSTR(("ERROR: No adapter detected\n"));
		DBGLOG("<= MKMiniportInitialize: (ERR - 3)", 0);
		return (NDIS_STATUS_FAILURE);
	}


	//****************************************
	// Set up the MK7 register I/O mapping w/ NDIS, interrupt mode, etc.
	//****************************************
	Status = SetupAdapterInfo(Adapter);
	if (Status != NDIS_STATUS_SUCCESS) {
		FreeAdapterObject(Adapter);
		DBGSTR(("ERROR: I/O Space allocation failed (Status = 0x%X)\n",Status));
		DBGLOG("<= MKMiniportInitialize: (ERR - 4)", 0);
		return(NDIS_STATUS_FAILURE);
	}


	//****************************************
	// Allocate & initialize memory/buffer needs.
	//****************************************
	Status = AllocAdapterMemory(Adapter);
	if (Status != NDIS_STATUS_SUCCESS) {
		FreeAdapterObject(Adapter);

        MKLogError(Adapter, EVENT_10, NDIS_ERROR_CODE_OUT_OF_RESOURCES, 0);
		DBGSTR(("ERROR: Shared Memory Allocation failed (Status = 0x%x)\n", Status));
		DBGLOG("<= MKMiniportInitialize: (ERR - 5)", 0);
		return (NDIS_STATUS_FAILURE);
	}

	
	// 4.1.0 Check hw version.
	MK7Reg_Read(Adapter, R_CFG3, &mk7reg);
	if ((mk7reg & 0x1000) != 0){
		mk7reg &= 0xEFFF;
		MK7Reg_Write(Adapter, R_CFG3, mk7reg);
		mk7reg |= 0x1000;
		MK7Reg_Write(Adapter, R_CFG3, mk7reg);
		MK7Reg_Read(Adapter, R_CFG3, &mk7reg);
		if ((mk7reg & 0x1000) != 0)
			Adapter->HwVersion = HW_VER_1;
		else
			Adapter->HwVersion = HW_VER_2;
	}
	else{
		Adapter->HwVersion = HW_VER_2;
	}


	//****************************************
	// Disable interrupts while we finish with the initialization
	// Must AllocAdapterMemory() before you can do this.
	//****************************************
	MK7DisableInterrupt(Adapter);


	//****************************************
	// Register our interrupt with the NDIS wrapper, hook our interrupt
	// vector, & use shared interrupts for our PCI adapters
	//****************************************
	Status = NdisMRegisterInterrupt(&Adapter->Interrupt,
		Adapter->MK7AdapterHandle,
		Adapter->MKInterrupt,
		Adapter->MKInterrupt,
		TRUE,						// call ISR each time NIC interrupts
		TRUE, 						// shared irq 
		Adapter->InterruptMode);	// NdisInterruptLatched, NdisInterruptLevelSensitive

	if (Status != NDIS_STATUS_SUCCESS) {
		FreeAdapterObject(Adapter);
        MKLogError(Adapter,
            EVENT_0,
            NDIS_ERROR_CODE_INTERRUPT_CONNECT,
            (ULONG) Adapter->MKInterrupt);
		DBGLOG("<= MKMiniportInitialize: (ERR - 6)", 0);
		return (NDIS_STATUS_FAILURE);
	}



#if	DBG
	DbgTestInit(Adapter);
#endif


	//****************************************
	// allocate a spin lock
	//****************************************
	NdisAllocateSpinLock(&Adapter->Lock);


	Adapter->HangCheck = 0;
	Adapter->nowReceiving=FALSE;	// 4.1.0


	//****************************************
	// Setup and initialize the transmit and receive structures then
	// init the adapter
	//****************************************
	SetupTransmitQueues(Adapter, TRUE);

	SetupReceiveQueues(Adapter);

	if (!InitializeAdapter(Adapter)) {
		FreeAdapterObject(Adapter);
		NdisMDeregisterInterrupt(&Adapter->Interrupt);

		DBGSTR(("ERROR: InitializeAdapter Failed.\n"));
		DBGLOG("<= MKMiniportInitialize: (ERR - 7)", 0);
		return (NDIS_STATUS_FAILURE);
	}


	//****************************************
	// Register a shutdown handler
	//****************************************
	NdisMRegisterAdapterShutdownHandler(Adapter->MK7AdapterHandle,
		(PVOID) Adapter,
		(ADAPTER_SHUTDOWN_HANDLER) MKMiniportShutdownHandler);

	StartAdapter(Adapter);
	MK7EnableInterrupt(Adapter);

	Adapter->hardwareStatus = NdisHardwareStatusReady;

	DBGSTR(("MKMiniportInitialize: Completed Init Successfully\n"));
	DBGLOG("<= MKMiniportInitialize", 0);
	return (NDIS_STATUS_SUCCESS);
}


//-----------------------------------------------------------------------------
// RYM-5++
// Procedure:	[MKMiniportReset]
//
// Description: Instructs the Miniport to issue a hardware reset to the
//		network adapter.  The driver also resets its software state. this
//		function also resets the transmit queues.
//
// Arguments:
//		AddressingReset - TRUE if the wrapper needs to call
//						  MiniportSetInformation to restore the addressing
//						  information to the current values
//		MiniportAdapterContext - pointer to the adapter object data area.
//
// Returns:
//		NDIS_STATUS_PENDING - This function sets a timer to complete, so
//							  pending is always returned
//
// (NOTE: The timer-based completion scheme has been disable by now starting
// the timer. We may now want to return Success instead of Pending.)
//-----------------------------------------------------------------------------
NDIS_STATUS
MKMiniportReset(PBOOLEAN AddressingReset,
		  NDIS_HANDLE MiniportAdapterContext)
{
	PMK7_ADAPTER Adapter;
	MK7REG	mk7reg;


	DBGFUNC("MKMiniportReset");

	Adapter = PMK7_ADAPTER_FROM_CONTEXT_HANDLE(MiniportAdapterContext);

	NdisAcquireSpinLock(&Adapter->Lock);

    Adapter->hardwareStatus = NdisHardwareStatusReset;

	*AddressingReset = TRUE;

	// *** possible temporary code
	// *** NDIS may actually handle this
	Adapter->ResetInProgress = TRUE;

	// Disable interrupts while we re-init the transmit structures
	MK7DisableInterrupt(Adapter);
	MK7DisableIr(Adapter);


	// The NDIS 5 support for deserialized miniports requires that
	// when reset is called, the driver de-queue and fail all uncompleted
	// sends, and complete any uncompleted sends. Essentially we must have
	// no pending send requests left when we leave this routine.


	// we will fail all sends that we have left right now.
	while(Adapter->FirstTxQueue) {
		PNDIS_PACKET QueuePacket = Adapter->FirstTxQueue;

		Adapter->NumPacketsQueued--;
		DequeuePacket(Adapter->FirstTxQueue, Adapter->LastTxQueue);

		// we must release the lock here before returning control to ndis
		// (even temporarily like this)
		NdisReleaseSpinLock(&Adapter->Lock);

		NDIS_SET_PACKET_STATUS(QueuePacket, NDIS_STATUS_FAILURE);
		NdisMSendComplete(
			Adapter->MK7AdapterHandle,
			QueuePacket,
			NDIS_STATUS_FAILURE);

		NdisAcquireSpinLock(&Adapter->Lock);
	}

	// clean up all the packets we have successfully TX'd
//	ProcessTXInterrupt(Adapter);


	// Clear out our software transmit structures
	NdisZeroMemory((PVOID) Adapter->XmitCached, Adapter->XmitCachedSize);

	// Re-initialize the transmit structures
	ResetTransmitQueues(Adapter, FALSE);
	ResetReceiveQueues(Adapter);
	Adapter->tcbUsed = 0;
	NdisMSetTimer(&Adapter->MK7AsyncResetTimer, 500);

//	Adapter->hardwareStatus = NdisHardwareStatusReady;
//	Adapter->ResetInProgress = FALSE;
//	MK7EnableInterrupt(Adapter);
//	MK7EnableIr(Adapter);

	NdisReleaseSpinLock(&Adapter->Lock);
	return(NDIS_STATUS_PENDING);
}



//-----------------------------------------------------------------------------
// Procedure:	[DriverEntry]
//
// Description: This is the primary initialization routine for the MK7 driver.
//		It is simply responsible for the intializing the wrapper and registering
//		the adapter driver. The routine gets called once per driver, but
//		MKMiniportInitialize(miniport)  will get called multiple times if there are
//		multiple adapters.
//
// Arguments:
//		DriverObject - Pointer to driver object created by the system.
//		RegistryPath - The registry path of this driver
//
// Returns:
//	The status of the operation, normally this will be NDIS_STATUS_SUCCESS
//-----------------------------------------------------------------------------
NTSTATUS
DriverEntry(PDRIVER_OBJECT DriverObject,
			PUNICODE_STRING RegistryPath)
{
	NDIS_STATUS		Status;
	NDIS_HANDLE		NdisWrapperHandle;


	NDIS_MINIPORT_CHARACTERISTICS MKMiniportChar;

	DBGFUNC("MK7-DriverEntry");
	DBGLOG("=> DriverEntry", 0);

	//****************************************
	// Now we must initialize the wrapper, and then register the Miniport
	//****************************************
	NdisMInitializeWrapper( &NdisWrapperHandle,
		DriverObject,
		RegistryPath,
		NULL );

	NdisZeroMemory(&MKMiniportChar, sizeof(MKMiniportChar));

	// Initialize the Miniport characteristics for the call to
	// NdisMRegisterMiniport.
	MKMiniportChar.MajorNdisVersion			= MK7_NDIS_MAJOR_VERSION;
	MKMiniportChar.MinorNdisVersion			= MK7_NDIS_MINOR_VERSION;
	MKMiniportChar.CheckForHangHandler		= MKMiniportCheckForHang;
	MKMiniportChar.DisableInterruptHandler	= MK7DisableInterrupt;
	MKMiniportChar.EnableInterruptHandler	= MK7EnableInterrupt;
	MKMiniportChar.HaltHandler				= MKMiniportHalt;
	MKMiniportChar.HandleInterruptHandler	= MKMiniportHandleInterrupt;
	MKMiniportChar.InitializeHandler		= MKMiniportInitialize;
	MKMiniportChar.ISRHandler				= MKMiniportIsr;
	MKMiniportChar.QueryInformationHandler	= MKMiniportQueryInformation;
	MKMiniportChar.ReconfigureHandler		= NULL;
	MKMiniportChar.ResetHandler				= MKMiniportReset;
	MKMiniportChar.SetInformationHandler	= MKMiniportSetInformation;
	MKMiniportChar.SendHandler				= NULL;
	MKMiniportChar.SendPacketsHandler		= MKMiniportMultiSend;
	MKMiniportChar.ReturnPacketHandler		= MKMiniportReturnPackets;
	MKMiniportChar.TransferDataHandler		= NULL;
//	MKMiniportChar.AllocateCompleteHandler	= D100AllocateComplete;


	//****************************************
	// Register this driver with the NDIS wrapper
	// This will cause MKMiniportInitialize to be called before returning
	// (is this really true? -- SoftIce shows this returning before
	// MKMiniportInitialize() is called(?))
	//****************************************
	Status = NdisMRegisterMiniport(	NdisWrapperHandle,
									&MKMiniportChar,
									sizeof(NDIS_MINIPORT_CHARACTERISTICS));

	if (Status == NDIS_STATUS_SUCCESS) {
		DBGLOG("<= DriverEntry", 0);
		return (STATUS_SUCCESS);
	}

	DBGLOG("<= DriverEntry: Failed!", 0);
	return (Status);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\net\irda\mknet\sys\protot.h ===
/*****************************************************************************
 **																			**
 **	COPYRIGHT (C) 2000, 2001 MKNET CORPORATION								**
 **	DEVELOPED FOR THE MK7100-BASED VFIR PCI CONTROLLER.						**
 **																			**
 *****************************************************************************/

/**********************************************************************

Module Name:
	PROTOT.H

Comments:	
	Prototype all extern function references and globle variables.

**********************************************************************/

// DBG.C
#if	DBG
// MyLogEvent
// MyLogPhysEvent
extern	VOID 		DbgTestInit(PMK7_ADAPTER);
extern	VOID 		MK7DbgTestIntTmo(PVOID, NDIS_HANDLE, PVOID, PVOID);
extern	VOID		DbgInterPktTimeGap();

extern	MK7DBG_STAT	GDbgStat;
#endif


// INTERRUPT.C
extern	VOID		MKMiniportIsr(PBOOLEAN, PBOOLEAN, NDIS_HANDLE);
extern	VOID		MKMiniportHandleInterrupt(IN NDIS_HANDLE);
extern	VOID		ProcessTXCompIsr(PMK7_ADAPTER);
extern	VOID		ProcessRXCompIsr(PMK7_ADAPTER);
extern	VOID		ProcessTXComp(PMK7_ADAPTER);
extern	VOID		ProcessRXComp(PMK7_ADAPTER);


// MK7COMM.C
#if DBG
extern	VOID		MK7Reg_Read(PVOID, ULONG, USHORT *);
extern	VOID		MK7Reg_Write(PVOID, ULONG, USHORT);
#endif
extern	NDIS_STATUS	MK7DisableInterrupt(PMK7_ADAPTER);
extern	NDIS_STATUS	MK7EnableInterrupt(PMK7_ADAPTER);
extern	VOID		MK7SwitchToRXMode(PMK7_ADAPTER);
extern	VOID		MK7SwitchToTXMode(PMK7_ADAPTER);
extern	BOOLEAN		SetSpeed(PMK7_ADAPTER);
extern	VOID		MK7ChangeSpeedNow(PMK7_ADAPTER);

extern	baudRateInfo	supportedBaudRateTable[];



// MKINIT.C
extern	NDIS_STATUS ClaimAdapter(PMK7_ADAPTER, NDIS_HANDLE);
extern	NDIS_STATUS SetupIrIoMapping(PMK7_ADAPTER);
extern	NDIS_STATUS SetupAdapterInfo(PMK7_ADAPTER);
extern	NDIS_STATUS AllocAdapterMemory(PMK7_ADAPTER);
//(ReleaseAdapterMemory)
extern	VOID 		FreeAdapterObject(PMK7_ADAPTER);
extern	VOID		SetupTransmitQueues(PMK7_ADAPTER, BOOLEAN);
extern	VOID		SetupReceiveQueues(PMK7_ADAPTER);

// (InitializeMK7)
// 1.0.0
extern	VOID		ResetTransmitQueues(PMK7_ADAPTER, BOOLEAN);
extern  VOID		ResetReceiveQueues(PMK7_ADAPTER);
extern  VOID		MK7ResetComplete(PVOID,NDIS_HANDLE,PVOID,PVOID);

extern	BOOLEAN		InitializeAdapter(PMK7_ADAPTER);
extern	VOID 		StartAdapter(PMK7_ADAPTER);	




// MKMINI.C
//	MKMiniportReturnPackets
//	MKMiniportReturnPackets
//	MKMiniportCheckForHang
//	MKMiniportHalt
//	MKMiniportShutdownHandler
//	MKMiniportInitialize
//	MKMiniportReset
//	(MK7EnableInterrupt & Disable in MK7COMM.C.)
//	DriverEntry


// SEND.C
extern	VOID		MKMiniportMultiSend(NDIS_HANDLE, PPNDIS_PACKET, UINT);
extern	NDIS_STATUS SendPkt(PMK7_ADAPTER, PNDIS_PACKET);
extern	UINT		PrepareForTransmit(PMK7_ADAPTER, PNDIS_PACKET, PTCB);
extern	VOID		CopyFromPacketToBuffer(	PMK7_ADAPTER,
						PNDIS_PACKET,
   		            	UINT,
       		   			PCHAR,
       					PNDIS_BUFFER,
       					PUINT);
extern	VOID		MinTurnaroundTxTimeout(PVOID, NDIS_HANDLE, PVOID, PVOID);


// SIR.C
extern	BOOLEAN		NdisToSirPacket(PMK7_ADAPTER, PNDIS_PACKET, UCHAR *, UINT, UINT *);
extern	USHORT		ComputeSirFCS(PUCHAR, UINT);
extern	BOOLEAN		ProcRXSir(PUCHAR, UINT);


// UTIL.C
extern	PNDIS_IRDA_PACKET_INFO GetPacketInfo(PNDIS_PACKET);
extern	VOID		ProcReturnedRpd(PMK7_ADAPTER, PRPD);



// WINOIDS.C
extern	NDIS_STATUS MKMiniportQueryInformation(NDIS_HANDLE,
						NDIS_OID,
						PVOID,
						ULONG,
						PULONG,
						PULONG);
extern	NDIS_STATUS MKMiniportSetInformation(NDIS_HANDLE,
						NDIS_OID,
						PVOID,
						ULONG,
						PULONG,
						PULONG);

// WINPCI.C
extern	USHORT		FindAndSetupPciDevice(PMK7_ADAPTER,
						NDIS_HANDLE,
						USHORT,
						USHORT,
						PPCI_CARDS_FOUND_STRUC);

// WINREG.C
extern	NDIS_STATUS ParseRegistryParameters(PMK7_ADAPTER, NDIS_HANDLE);
extern	NDIS_STATUS ProcessRegistry(PMK7_ADAPTER, NDIS_HANDLE);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\net\irda\mknet\sys\queue.h ===
/*****************************************************************************
 **																			**
 **	COPYRIGHT (C) 2000, 2001 MKNET CORPORATION								**
 **	DEVELOPED FOR THE MK7100-BASED VFIR PCI CONTROLLER.						**
 **																			**
 *****************************************************************************/

/**********************************************************************

Module Name:
	QUEUE.H
		

**********************************************************************/


//-------------------------------------------------------------------------
// QueueInitList -- Macro which will initialize a queue to NULL.
//-------------------------------------------------------------------------
#define QueueInitList(_L) (_L)->Link.Flink = (_L)->Link.Blink = (PLIST_ENTRY)0;


//-------------------------------------------------------------------------
// QueueEmpty -- Macro which checks to see if a queue is empty.
//-------------------------------------------------------------------------
#define QueueEmpty(_L) (QueueGetHead((_L)) == (PMK7_LIST_ENTRY)0)


//-------------------------------------------------------------------------
// QueueGetHead -- Macro which returns the head of the queue, but does not
// remove the head from the queue.
//-------------------------------------------------------------------------
#define QueueGetHead(_L) ((PMK7_LIST_ENTRY)((_L)->Link.Flink))


//-------------------------------------------------------------------------
// QueuePushHead -- Macro which puts an element at the head of the queue.
//-------------------------------------------------------------------------
#define QueuePushHead(_L,_E) \
    ASSERT(_L); \
    ASSERT(_E); \
    if (!((_E)->Link.Flink = (_L)->Link.Flink)) \
    { \
        (_L)->Link.Blink = (PLIST_ENTRY)(_E); \
    } \
(_L)->Link.Flink = (PLIST_ENTRY)(_E);


//-------------------------------------------------------------------------
// QueueRemoveHead -- Macro which removes the head of the head of queue.
//-------------------------------------------------------------------------
#define QueueRemoveHead(_L) \
    {                                                     \
    PMK7_LIST_ENTRY ListElem;                        \
    ASSERT((_L));                                     \
    if (ListElem = (PMK7_LIST_ENTRY)(_L)->Link.Flink) /* then fix up our our list to point to next elem */ \
        {   \
            if(!((_L)->Link.Flink = ListElem->Link.Flink)) /* rechain list pointer to next link */ \
                /* if the list pointer is null, null out the reverse link */ \
                (_L)->Link.Blink = (PLIST_ENTRY) 0; \
        } }

//-------------------------------------------------------------------------
// QueuePutTail -- Macro which puts an element at the tail (end) of the queue.
//-------------------------------------------------------------------------
#define QueuePutTail(_L,_E) \
    ASSERT(_L); \
    ASSERT(_E); \
    if ((_L)->Link.Blink) \
    { \
        ((PMK7_LIST_ENTRY)(_L)->Link.Blink)->Link.Flink = (PLIST_ENTRY)(_E); \
        (_L)->Link.Blink = (PLIST_ENTRY)(_E); \
    } \
    else \
    { \
        (_L)->Link.Flink = \
        (_L)->Link.Blink = (PLIST_ENTRY)(_E); \
    } \
(_E)->Link.Flink = (PLIST_ENTRY)0;

//-------------------------------------------------------------------------
// QueueGetTail -- Macro which returns the tail of the queue, but does not
// remove the tail from the queue.
//-------------------------------------------------------------------------
#define QueueGetTail(_L) ((PMK7_LIST_ENTRY)((_L)->Link.Blink))

//-------------------------------------------------------------------------
// QueuePopHead -- Macro which  will pop the head off of a queue (list), and
//                 return it (this differs only from queueremovehead only in the 1st line)
//-------------------------------------------------------------------------
#define QueuePopHead(_L) \
(PMK7_LIST_ENTRY) (_L)->Link.Flink; QueueRemoveHead(_L);


typedef struct _MK7_RESERVED {

	// next packet in the chain of queued packets being allocated,
	// or waiting for the finish of transmission.
	//
	// We always keep the packet on a list so that in case the
	// the adapter is closing down or resetting, all the packets
	// can easily be located and "canceled".
	//
	PNDIS_PACKET Next;
} MK7_RESERVED,*PMK7_RESERVED;

#define PMK7_RESERVED_FROM_PACKET(_Packet) \
	((PMK7_RESERVED)((_Packet)->MiniportReserved))

#define EnqueuePacket(_Head, _Tail, _Packet)		   		\
{													   		\
	if (!_Head) {									   		\
		_Head = _Packet;							   		\
	} else {										   		\
		PMK7_RESERVED_FROM_PACKET(_Tail)->Next = _Packet;	\
	}												   		\
	PMK7_RESERVED_FROM_PACKET(_Packet)->Next = NULL;   		\
	_Tail = _Packet;								   		\
}

#define DequeuePacket(Head, Tail)						\
{													 	\
	PMK7_RESERVED Reserved =						  	\
		PMK7_RESERVED_FROM_PACKET(Head);				\
	if (!Reserved->Next) {							   	\
		Tail = NULL;									\
	}												   	\
	Head = Reserved->Next;							   	\
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\net\irda\mknet\sys\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by IRMK7.RC
//

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NO_MFC                     1
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\net\irda\mknet\sys\util.c ===
/*****************************************************************************
 **																			**
 **	COPYRIGHT (C) 2000, 2001 MKNET CORPORATION								**
 **	DEVELOPED FOR THE MK7100-BASED VFIR PCI CONTROLLER.						**
 **																			**
 *****************************************************************************/

/**********************************************************************

Module Name:
	UTIL.C

Routines:
	GetPacketInfo
 	ProcReturnedRpd

Comments:
	Various utilities to assist in operating in the NDIS env.

**********************************************************************/


#include	"precomp.h"
//#include	"protot.h"
#pragma		hdrstop




//-----------------------------------------------------------------------------
// Procedure:	[GetPacketInfo]
//
//-----------------------------------------------------------------------------
PNDIS_IRDA_PACKET_INFO GetPacketInfo(PNDIS_PACKET packet)
{
    MEDIA_SPECIFIC_INFORMATION *mediaInfo;
    UINT size;
    NDIS_GET_PACKET_MEDIA_SPECIFIC_INFO(packet, &mediaInfo, &size);
    return (PNDIS_IRDA_PACKET_INFO)mediaInfo->ClassInformation;
}



//----------------------------------------------------------------------
// Procedure:	[ProcReturnedRpd]
//
// Description:	Process a RPD (previously indicated pkt) being returned
//		to us from NDIS.
//
//----------------------------------------------------------------------
VOID ProcReturnedRpd(PMK7_ADAPTER Adapter, PRPD rpd)
{
	NdisAdjustBufferLength(rpd->ReceiveBuffer, MK7_MAXIMUM_PACKET_SIZE);

	//******************************
	// If a RCB is waiting for a RPD, bind the RPD to the RCB-RRD
	// and give the RCB-RRD to hw.	Else, put the RPD on FreeRpdList.
	//******************************

	if (Adapter->rcbPendRpdCnt > 0) {
		PRCB	rcb;

		rcb = Adapter->pRcbArray[Adapter->rcbPendRpdIdx];
		rcb->rpd = rpd;
		rcb->rrd->addr = rpd->databuffphys;
		rcb->rrd->count = 0;
		GrantRrdToHw(rcb->rrd);

		Adapter->rcbPendRpdCnt--;

		//****************************************
		// If more RCBs waiting for RPDs then need to
		// bump the index up, taking care of wrapping.
		//****************************************
		if (Adapter->rcbPendRpdCnt > 0) {
			Adapter->rcbPendRpdIdx++;
			Adapter->rcbPendRpdIdx %= Adapter->NumRcb;
		}
	}
	else {
		QueuePutTail(&Adapter->FreeRpdList, &rpd->link);
	}

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\net\irda\mknet\sys\wincomm.h ===
/*****************************************************************************
 **																			**
 **	COPYRIGHT (C) 2000, 2001 MKNET CORPORATION								**
 **	DEVELOPED FOR THE MK7100-BASED VFIR PCI CONTROLLER.						**
 **																			**
 *****************************************************************************/

/**********************************************************************

Module Name:
	WINCOMM.H

Comments:

**********************************************************************/

#ifndef	_WINCOMM_H
#define	_WINCOMM_H


#define MK7_NDIS_MAJOR_VERSION		5
#define MK7_NDIS_MINOR_VERSION		0
#define MK7_DRIVER_VERSION ((MK7_NDIS_MAJOR_VERSION*0x100) + MK7_NDIS_MINOR_VERSION)
#define MK7_MAJOR_VERSION			0
#define MK7_MINOR_VERSION			1
#define MK7_LETTER_VERSION			'a'

// SIR
#define NDIS_IRDA_SPEED_2400       (UINT)(0 << 0)	// Not supported
#define NDIS_IRDA_SPEED_9600       (UINT)(1 << 1)
#define NDIS_IRDA_SPEED_19200      (UINT)(1 << 2)
#define NDIS_IRDA_SPEED_38400      (UINT)(1 << 3)
#define NDIS_IRDA_SPEED_57600      (UINT)(1 << 4)
#define NDIS_IRDA_SPEED_115200     (UINT)(1 << 5)
// MIR
#define NDIS_IRDA_SPEED_576K       (UINT)(1 << 6)
#define NDIS_IRDA_SPEED_1152K      (UINT)(1 << 7)
// FIR
#define NDIS_IRDA_SPEED_4M         (UINT)(1 << 8)
// VFIR
#define	NDIS_IRDA_SPEED_16M			(UINT)(1 << 9)


//
// Speed bit masks
//
#define ALL_SLOW_IRDA_SPEEDS (							\
	NDIS_IRDA_SPEED_9600  |								\
	NDIS_IRDA_SPEED_19200 | NDIS_IRDA_SPEED_38400 |		\
	NDIS_IRDA_SPEED_57600 | NDIS_IRDA_SPEED_115200)

#define ALL_IRDA_SPEEDS (													\
	ALL_SLOW_IRDA_SPEEDS | NDIS_IRDA_SPEED_576K | NDIS_IRDA_SPEED_1152K |		\
	NDIS_IRDA_SPEED_4M   | NDIS_IRDA_SPEED_16M)


// For processing Registry entries
#define MK7_OFFSET(field)		( (UINT) FIELD_OFFSET(MK7_ADAPTER,field) )
#define MK7_SIZE(field)	  		sizeof( ((MK7_ADAPTER *)0)->field )


// NDIS multisend capability may send >1 pkt for TX at a time.
// This comes down in an array. Since we queue them up and process
// TX at a time, this number does not necessarily have to match
// the count of TX ring size.
#define	 MAX_ARRAY_SEND_PACKETS		8
// limit our receive routine to indicating this many at a time
// IMPORTANT: Keep this less than TCB or ringsize count for now or
// the algorithm may break
#define	 MAX_ARRAY_RECEIVE_PACKETS	16
//#define	 MAX_ARRAY_RECEIVE_PACKETS	1


#define NUM_BYTES_PROTOCOL_RESERVED_SECTION	   16


// NDIS BusType values
#define		ISABUS			 1
#define		EISABUS			 2
#define		PCIBUS			 5


// IRDA-5 ?
//- Driver defaults
#define		LOOKAHEAD_SIZE		222


//- Macros peculiar to NT
//- The highest physical address that can be allocated to buffers.
//  Non-page system mem.

// 1.0.0 NDIS requirements
#define		MEMORY_TAG			'tNKM'
//#define ALLOC_SYS_MEM(_pbuffer, _length) NdisAllocateMemory( \
//	(PVOID*)(_pbuffer), \
//	(_length), \
//	0, \
//	HighestAcceptableMax)
#define ALLOC_SYS_MEM(_pbuffer, _length) NdisAllocateMemoryWithTag( \
	(PVOID*)(_pbuffer), \
	(_length), \
	(ULONG)MEMORY_TAG)
#define FREE_SYS_MEM(_buffer,_length) NdisFreeMemory((_buffer), (_length), 0)



#define MAX_PCI_CARDS 12



//-------------------------------------------------------------------------
// PCI Cards found - returns hardware info after scanning for devices
//-------------------------------------------------------------------------
typedef struct _PCI_CARDS_FOUND_STRUC
{
	USHORT NumFound;
	struct
	{
		ULONG			BaseIo;
		UCHAR			ChipRevision;
//		ULONG			SubVendor_DeviceID;
		USHORT			SlotNumber;		// Ndis Slot number
//		ULONG			MemPhysAddress; // CSR Physical address
		UCHAR			Irq;
	} PciSlotInfo[MAX_PCI_CARDS];

} PCI_CARDS_FOUND_STRUC, *PPCI_CARDS_FOUND_STRUC;




// Uniquely defines the location of the error
#define MKLogError(_Adapt, _EvId, _ErrCode, _Spec1) \
	NdisWriteErrorLogEntry((NDIS_HANDLE)(_Adapt)->MK7AdapterHandle, \
		(NDIS_ERROR_CODE)(_ErrCode), (ULONG) 3, (ULONG)(_EvId), \
		(ULONG)(_Spec1), (ULONG_PTR)(_Adapt))


// Each entry in the error log will be tagged with a unique event code so that
// we'll be able to grep the driver source code for that specific event, and
// get an idea of why that particular event was logged.	 Each time a new
// "MKLogError" statement is added to the code, a new Event tag should be
// added below.
//
// RYM10-2
// "-" indicates being used in new code,
// "x" not used in new code.
// "X" not even used in the original code.
typedef enum _MK_EVENT_VIEWER_CODES
{
		EVENT_0,					// - couldn't register the specified interrupt
		EVENT_1,					// - One of our PCI cards didn't get required resources
		EVENT_2,					// x bad node address (it was a multicast address)
		EVENT_3,					// x failed self-test
		EVENT_4,					// X Wait for SCB failed
		EVENT_5,					// X NdisRegisterAdapter failed for the MAC driver
		EVENT_6,					// x WaitSCB failed
		EVENT_7,					// X Command complete status was never posted to the SCB
		EVENT_8,					// X Couldn't find a phy at over-ride address 0
		EVENT_9,					// x Invalid duplex or speed setting with the detected phy
		EVENT_10,					// - Couldn't setup adapter memory
		EVENT_11,					// - couldn't allocate enough map registers
		EVENT_12,					// - couldn't allocate enough RRD/TRD non-cached memory
		EVENT_13,					// - couldn't allocate enough RCB/RPD or TCB cached memory
		EVENT_14,					// - couldn't allocate enough RX non-cached shared memory
		EVENT_15,					// - couldn't allocate enough TX non-cached shared memory
		EVENT_16,					// - Didn't find any PCI boards
		EVENT_17,		   // 11	// X Multiple PCI were found, but none matched our id.
		EVENT_18,		   // 12	// - NdisMPciAssignResources Error
		EVENT_19,		   // 13	// X Didn't Find Any PCI Boards that matched our subven/subdev
		EVENT_20,		   // 14	// x ran out of cached memory to allocate in async allocation
		EVENT_30		   // 1e	// X WAIT_TRUE timed out
} MK_EVENT_VIEWER_CODES;




#endif		// _WINCOMM.H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\net\irda\mknet\sys\winoids.c ===
/*****************************************************************************
 **																			**
 **	COPYRIGHT (C) 2000, 2001 MKNET CORPORATION								**
 **	DEVELOPED FOR THE MK7100-BASED VFIR PCI CONTROLLER.						**
 **																			**
 *****************************************************************************/

 /**********************************************************************

Module Name:
	WINOIDS.C

Routines:
	MKMiniportQueryInformation 
	MKMiniportSetInformation 

Comments:
	Windows-NDIS Sets & Gets of OIDs.

**********************************************************************/


#include	"precomp.h"
#include	"protot.h"
#pragma		hdrstop



//----------------------------------------------------------------------
//  Function:	    MKMiniportQueryInformation
//
//  Description:
//  Query the capabilities and status of the miniport driver.
//
//----------------------------------------------------------------------
NDIS_STATUS MKMiniportQueryInformation (
    IN NDIS_HANDLE MiniportAdapterContext,
    IN NDIS_OID Oid,
    IN PVOID InformationBuffer,
    IN ULONG InformationBufferLength,
    OUT PULONG BytesWritten,
    OUT PULONG BytesNeeded)
{
    NDIS_STATUS result = NDIS_STATUS_SUCCESS;
    PMK7_ADAPTER Adapter = PMK7_ADAPTER_FROM_CONTEXT_HANDLE(MiniportAdapterContext);
    INT i, speeds, speedSupported;
    UINT *infoPtr;
    CHAR *pnpid;
	MK7REG	mk7reg;
//    CMCONFIG_A *hwInfo = (CMCONFIG_A *)InformationBuffer;

    static  NDIS_OID MK7GlobalSupportedOids[] = {
		OID_GEN_SUPPORTED_LIST,
	    OID_GEN_HARDWARE_STATUS,
		OID_GEN_MEDIA_SUPPORTED,
		OID_GEN_MEDIA_IN_USE,
		OID_GEN_MEDIA_CONNECT_STATUS,	// 1.0.0
		OID_GEN_MAXIMUM_LOOKAHEAD,
		OID_GEN_MAXIMUM_FRAME_SIZE,
	 	OID_GEN_MAXIMUM_SEND_PACKETS,
		OID_GEN_MAXIMUM_TOTAL_SIZE,
		OID_GEN_MAC_OPTIONS,
		OID_GEN_PROTOCOL_OPTIONS,
		OID_GEN_LINK_SPEED,
		OID_GEN_TRANSMIT_BUFFER_SPACE,
		OID_GEN_RECEIVE_BUFFER_SPACE,
		OID_GEN_TRANSMIT_BLOCK_SIZE,
		OID_GEN_RECEIVE_BLOCK_SIZE,
		OID_GEN_VENDOR_DESCRIPTION,
   	 	OID_GEN_VENDOR_DRIVER_VERSION,
		OID_GEN_DRIVER_VERSION,
		OID_GEN_CURRENT_PACKET_FILTER,
		OID_GEN_CURRENT_LOOKAHEAD,
		OID_IRDA_RECEIVING,
		OID_IRDA_SUPPORTED_SPEEDS,
		OID_IRDA_LINK_SPEED,
		OID_IRDA_MEDIA_BUSY,
		OID_IRDA_TURNAROUND_TIME,
		OID_IRDA_MAX_RECEIVE_WINDOW_SIZE,
		OID_IRDA_EXTRA_RCV_BOFS };

    static ULONG BaudRateTable[NUM_BAUDRATES] = {
		// Add 16Mbps support; 2400 not supported
		0, 9600, 19200,38400, 57600, 115200, 576000, 1152000, 4000000, 16000000};
    NDIS_MEDIUM Medium = NdisMediumIrda;
    ULONG GenericUlong;
    PVOID SourceBuffer = (PVOID) (&GenericUlong);
    ULONG SourceLength = sizeof(ULONG);


    switch (Oid){

	case OID_GEN_SUPPORTED_LIST:
	    SourceBuffer = (PVOID) (MK7GlobalSupportedOids);
	    SourceLength = sizeof(MK7GlobalSupportedOids);
	    break;

    case OID_GEN_HARDWARE_STATUS:
        GenericUlong = Adapter->hardwareStatus;
        break;

	case OID_GEN_MEDIA_SUPPORTED:
	case OID_GEN_MEDIA_IN_USE:
	    SourceBuffer = (PVOID) (&Medium);
	    SourceLength = sizeof(NDIS_MEDIUM);
	    break;
	case OID_GEN_MEDIA_CONNECT_STATUS:
		GenericUlong = (ULONG) NdisMediaStateConnected;
		break;
	case OID_IRDA_RECEIVING:
	    GenericUlong = (ULONG)Adapter->nowReceiving;
	    break;
			
	case OID_IRDA_SUPPORTED_SPEEDS:
	    speeds = Adapter->supportedSpeedsMask &
					Adapter->AllowedSpeedMask &
					ALL_IRDA_SPEEDS;

        for (i = 0, infoPtr = (PUINT)BaudRateTable, SourceLength=0;
             (i < NUM_BAUDRATES) && speeds;
             i++){

            if (supportedBaudRateTable[i].ndisCode & speeds){
                *infoPtr++ = supportedBaudRateTable[i].bitsPerSec;
                SourceLength += sizeof(UINT);
                speeds &= ~supportedBaudRateTable[i].ndisCode;
            }
        }

	    SourceBuffer = (PVOID) BaudRateTable;
	    break;

	case OID_GEN_LINK_SPEED:
	    GenericUlong = Adapter->MaxConnSpeed;  // 100bps increments
	    break;

	case OID_IRDA_LINK_SPEED:
	    if (Adapter->linkSpeedInfo){
    		GenericUlong = (ULONG)Adapter->linkSpeedInfo->bitsPerSec;
	    }
	    else {
	    	GenericUlong = DEFAULT_BAUD_RATE;
	    }
	    break;


	case OID_IRDA_MEDIA_BUSY:	// 4.1.0
		if (Adapter->HwVersion == HW_VER_1){
			if (Adapter->nowReceiving==TRUE){
				NdisAcquireSpinLock(&Adapter->Lock);
				Adapter->mediaBusy=TRUE;
				NdisReleaseSpinLock(&Adapter->Lock);
			}
			else {
				NdisAcquireSpinLock(&Adapter->Lock);
				Adapter->mediaBusy=FALSE;
				NdisReleaseSpinLock(&Adapter->Lock);
			}
		}
		else{
				MK7Reg_Read(Adapter, R_CFG3, &mk7reg);
				if(((mk7reg & 0x1000) != 0)|| (Adapter->nowReceiving==TRUE)) {
					NdisAcquireSpinLock(&Adapter->Lock);
					Adapter->mediaBusy = TRUE;
					NdisReleaseSpinLock(&Adapter->Lock);
				}
				else {
					NdisAcquireSpinLock(&Adapter->Lock);
					Adapter->mediaBusy=FALSE;
					NdisReleaseSpinLock(&Adapter->Lock);
				}
		}
		GenericUlong = (UINT)Adapter->mediaBusy;
	    break;


	case OID_GEN_CURRENT_LOOKAHEAD:
	case OID_GEN_MAXIMUM_LOOKAHEAD:
	    GenericUlong = MAX_I_DATA_SIZE;
	    break;

    case OID_GEN_MAXIMUM_TOTAL_SIZE:		// Largest pkt protocol sends to miniport
    case OID_GEN_TRANSMIT_BLOCK_SIZE:
    case OID_GEN_RECEIVE_BLOCK_SIZE:
	case OID_GEN_MAXIMUM_FRAME_SIZE:
        // Normally there's some difference in these values, based on the
        // MAC header, but IrDA doesn't have one.
	    GenericUlong = MAX_I_DATA_SIZE;
	    break;

	case OID_GEN_RECEIVE_BUFFER_SPACE:
	case OID_GEN_TRANSMIT_BUFFER_SPACE:
	    GenericUlong = (ULONG) (MK7_MAXIMUM_PACKET_SIZE * MAX_TX_PACKETS);
	    break;

	case OID_GEN_MAC_OPTIONS:
	    GenericUlong = NDIS_MAC_OPTION_COPY_LOOKAHEAD_DATA |
			   NDIS_MAC_OPTION_TRANSFERS_NOT_PEND;
	    break;

	case OID_GEN_MAXIMUM_SEND_PACKETS:
	    GenericUlong = MAX_ARRAY_SEND_PACKETS;
	    break;

	case OID_IRDA_TURNAROUND_TIME:
	    // Indicate the amount of time that the transceiver needs
	    // to recuperate after a send.
	    GenericUlong =
		      (ULONG)Adapter->turnAroundTime_usec;
	    break;

	case OID_IRDA_EXTRA_RCV_BOFS:
	    // Pass back the number of _extra_ BOFs to be prepended
	    // to packets sent to this unit at 115.2 baud, the
	    // maximum Slow IR speed.  This will be scaled for other
	    // speed according to the table in the
	    // Infrared Extensions to NDIS' spec.
	    GenericUlong = (ULONG)Adapter->extraBOFsRequired;
	    break;

	case OID_GEN_CURRENT_PACKET_FILTER:
	    GenericUlong = NDIS_PACKET_TYPE_PROMISCUOUS;
	    break;

	case OID_IRDA_MAX_RECEIVE_WINDOW_SIZE:
	    GenericUlong = MAX_RX_PACKETS;
	    //GenericUlong = 1;
	    break;

	case OID_GEN_VENDOR_DESCRIPTION:
	    SourceBuffer = (PVOID)"MKNet Very Highspeed IR";
	    SourceLength = 24;
	    break;

    case OID_GEN_VENDOR_DRIVER_VERSION:
        // This value is used to know whether to update driver.
        GenericUlong = (MK7_MAJOR_VERSION << 16) +
                       (MK7_MINOR_VERSION << 8) +
                       MK7_LETTER_VERSION;
        break;

	case OID_GEN_DRIVER_VERSION:
        GenericUlong = (MK7_NDIS_MAJOR_VERSION << 8) + MK7_NDIS_MINOR_VERSION;
        SourceLength = 2;
	    break;

    case OID_IRDA_MAX_SEND_WINDOW_SIZE:	// 4.0.1
        GenericUlong = MAX_ARRAY_SEND_PACKETS;
        break;

	default:
	    result = NDIS_STATUS_NOT_SUPPORTED;
	    break;
    }

    if (result == NDIS_STATUS_SUCCESS) {
	if (SourceLength > InformationBufferLength) {
	    *BytesNeeded = SourceLength;
	    result = NDIS_STATUS_INVALID_LENGTH;
	}
	else {
	    *BytesNeeded = 0;
	    *BytesWritten = SourceLength;
	    NdisMoveMemory(InformationBuffer, SourceBuffer, SourceLength);
	}
    }

    return result;

}



//----------------------------------------------------------------------
//  Function:	    MKMiniportSetInformation
//
//  Description:
//  Allow other layers of the network software (e.g., a transport
//  driver) to control the miniport driver by changing information that
//  the miniport driver maintains in its OIDs, such as the packet
//  or multicast addresses.
//----------------------------------------------------------------------
NDIS_STATUS MKMiniportSetInformation (
    IN NDIS_HANDLE MiniportAdapterContext,
    IN NDIS_OID Oid,
    IN PVOID InformationBuffer,
    IN ULONG InformationBufferLength,
    OUT PULONG BytesRead,
    OUT PULONG BytesNeeded)
{
    NDIS_STATUS result = NDIS_STATUS_SUCCESS;
    PMK7_ADAPTER Adapter = PMK7_ADAPTER_FROM_CONTEXT_HANDLE(MiniportAdapterContext);
    UINT i,speedSupported;
    NDIS_DMA_DESCRIPTION DMAChannelDcr;
    CHAR *pnpid;
    UCHAR IOResult;
//     CMCONFIG_A *hwInfo = (CMCONFIG_A *)InformationBuffer;

    if (InformationBufferLength >= sizeof(UINT)){

	UINT info = *(UINT *)InformationBuffer;
	*BytesRead = sizeof(UINT);
	*BytesNeeded = 0;

	switch (Oid) {
	    case OID_IRDA_LINK_SPEED:
		result = NDIS_STATUS_INVALID_DATA;

		// Find the appropriate speed and set it
		speedSupported = NUM_BAUDRATES;
		for (i = 0; i < speedSupported; i++) {
		    if (supportedBaudRateTable[i].bitsPerSec == info) {
				Adapter->linkSpeedInfo = &supportedBaudRateTable[i];
				result = NDIS_STATUS_SUCCESS;
				break;
		    }
		}
		if (result == NDIS_STATUS_SUCCESS) {
		    if (!SetSpeed(Adapter)){
				result = NDIS_STATUS_FAILURE;
		    }
		}
		else {
		    *BytesRead = 0;
		    *BytesNeeded = 0;
		}
		break;


	    case OID_IRDA_MEDIA_BUSY:

		//  The protocol can use this OID to reset the busy field
		//  in order to check it later for intervening activity.
		//
		Adapter->mediaBusy = (BOOLEAN)info;
		result = NDIS_STATUS_SUCCESS;
		break;

	    case OID_GEN_CURRENT_PACKET_FILTER:
		result = NDIS_STATUS_SUCCESS;
		break;


        case OID_GEN_CURRENT_LOOKAHEAD:
        result = (info<=MAX_I_DATA_SIZE) ? NDIS_STATUS_SUCCESS : NDIS_STATUS_INVALID_LENGTH;
        break;

	    //	 We don't support these
	    //
	    case OID_IRDA_RATE_SNIFF:
	    case OID_IRDA_UNICAST_LIST:

	     // These are query-only parameters.
	     //
	    case OID_IRDA_SUPPORTED_SPEEDS:
	    case OID_IRDA_MAX_UNICAST_LIST_SIZE:
	    case OID_IRDA_TURNAROUND_TIME:

	    default:
		*BytesRead = 0;
		*BytesNeeded = 0;
		result = NDIS_STATUS_NOT_SUPPORTED;
		break;
	}
    }
    else {
	*BytesRead = 0;
	*BytesNeeded = sizeof(UINT);
	result = NDIS_STATUS_INVALID_LENGTH;
    }

    return result;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\net\irda\mknet\sys\send.c ===
/*****************************************************************************
 **																			**
 **	COPYRIGHT (C) 2000, 2001 MKNET CORPORATION								**
 **	DEVELOPED FOR THE MK7100-BASED VFIR PCI CONTROLLER.						**
 **																			**
 *****************************************************************************/

/**********************************************************************

Module Name:
	SEND.C

Routines:
	MKMiniportMultiSend
	SendPkt
	PrepareForTransmit
	CopyFromPacketToBuffer
	MinTurnaroundTxTimeout
	[TestDataToTXBuff]

Comments:
	Transmits in the NDIS env.

**********************************************************************/

#include	"precomp.h"
#include	"protot.h"
#pragma		hdrstop



#if	DBG
// for debug/test
extern VOID TestDataToTXBuff(PCHAR, UINT, PUINT);
#define	TEST_PATTERN_SIZE 16
CHAR	TestPattern[] = {0,1,2,3,4,5,6,7,8,9,0x0A,0x0B,0x0C,0x0D,0x0E,0x0F};
#endif


//-----------------------------------------------------------------------------
// Procedure:	[MKMiniportMultiSend]
//
// Description:	This routine simply takes the pkt(s) passed down and queues
//		it to the trasmit queue (FirstTxQueue) for later processing. Each
//		pkt is marked NDIS_STATUS_PENDING) before returning.
//
// Arguments:
//		MiniportAdapterContext (Adapter Structure pointer)
//      PacketArray - an array of pointers to NDIS_PACKET structs
//      PacketCount - number of packets in PacketArray
//
// Returns:		(none)	
//
//-----------------------------------------------------------------------------
VOID
MKMiniportMultiSend(NDIS_HANDLE MiniportAdapterContext,
					PPNDIS_PACKET PacketArray,
					UINT NumberOfPackets)
{
    PMK7_ADAPTER	Adapter;
    NDIS_STATUS		Status;
    UINT			PacketCount;
	UINT			i;
	PNDIS_PACKET	QueuePacket;


    DBGFUNC("=> MKMiniportMultiSend");
	DBGLOG("=> MKMiniportMultiSend", 0);

    Adapter = PMK7_ADAPTER_FROM_CONTEXT_HANDLE(MiniportAdapterContext);

    NdisAcquireSpinLock(&Adapter->Lock);

#if	DBG
	Adapter->DbgSendCallCnt++;
	GDbgStat.txSndCnt++;
	Adapter->DbgSentCnt++;
	Adapter->DbgSentPktsCnt += NumberOfPackets; 
#endif


	// Q 'em up 1st
    for(PacketCount=0; PacketCount < NumberOfPackets; PacketCount++) {
    	Adapter->NumPacketsQueued++;
		EnqueuePacket(	Adapter->FirstTxQueue,
						Adapter->LastTxQueue,
						PacketArray[PacketCount] );
		NDIS_SET_PACKET_STATUS(PacketArray[PacketCount], NDIS_STATUS_PENDING);
	}

	if (Adapter->writePending || (Adapter->IOMode == TX_MODE)) {
		// In TX mode: Meaning TX outstanding. We wait for the TX comp to kick
		// off the next TX.
		// Or we have writePending, which means a pkt is on q waiting for
		// MinTurnaroundTimeout.
		DBGLOG("<= MKMiniportMultiSend: TX_MODE", 0);
	    NdisReleaseSpinLock(&Adapter->Lock);
		return;
	}

	ASSERT(Adapter->tcbUsed == 0);

	QueuePacket = Adapter->FirstTxQueue;

	Status = SendPkt(Adapter, QueuePacket);

	DBGLOG("<= MKMiniportMultiSend", 0);

    NdisReleaseSpinLock(&Adapter->Lock);

	MK7EnableInterrupt(Adapter);
}



//-----------------------------------------------------------------------------
// Procedure:   [SendPkt]
//
// Description:	This sets up (copies) the pkt to the TX ring data buffer in
//		preparation for TX. The caller then needs to Enable Int & Prompt to
//		initiate the actual tx at hw level.
//
// Arguments:
//      Adapter - ptr to Adapter object instance
//      Packet - A pointer to a descriptor for the packet that is to be
//               transmitted.
// Returns:
//      NDIS_STATUS_SUCCESS - We copied the entire packet into a TRD data buff,
//                            so we can immediately return the packet/buffer
//							  back to the upper layers.
//		NDIS_STATUS_RESOURCE - No resource. NDIS should re-send this to us
//							  at a later time. (Caller should re-Q the pkt.)
//----------------------------------------------------------------------
NDIS_STATUS
SendPkt(	PMK7_ADAPTER Adapter,
			PNDIS_PACKET Packet)
{
	PTCB	tcb;
	UINT	bytestosend, sndcnt, nextavail;
	MK7REG	mk7reg;
	BOOLEAN	timeout;
    PNDIS_IRDA_PACKET_INFO packetInfo;
	PNDIS_PACKET	QueuePacket;


	//****************************************
	// To send a pkt we do the following:
	// 1.	Check Min Turnaround Time.
	// 2.	Check if there's avail TX resource. It not we return "resource".
	//		(We assume that there's outstanding TXs to trigger subseuqent TX
	//		completion interrupts, which will keep the ball rolling.)
	//		(RYM-IRDA-5+ Need to talk to Wayne about missed interrupts.)
	// 3.	Copy the NDIS pkt into the contiguous TX buffer.
	// 4.	The copied pkt could have been marked as the last pkt to go out
	//		at the old speed after which we change speed. We check for this.
	//****************************************
    DBGFUNC("=> SendPkt");	
	DBGLOG("=> SendPkt", 0);


    packetInfo = GetPacketInfo(Packet);
    if (packetInfo->MinTurnAroundTime) {

	    UINT usecToWait = packetInfo->MinTurnAroundTime;
		UINT msecToWait;
        packetInfo->MinTurnAroundTime = 0;

		DBGLOG("<= SendPkt: Delay TX", 0);


		// Need to set IOMode = TX  so if a multisend comes down before
		// the delayed TX timer goes off we just q.
		
		
		// Ndis timer has a 1ms granularity (in theory).  Let's round off.
        msecToWait = (usecToWait<1000) ? 1 : (usecToWait+500)/1000;
        NdisMSetTimer(&Adapter->MinTurnaroundTxTimer, msecToWait);
// 4.0.1 BOC
		MK7SwitchToTXMode(Adapter);
// 4.0.1 EOC
		Adapter->writePending = TRUE;

        return (NDIS_STATUS_PENDING); // Say we're successful.  We'll come back here.
	}


	// Avail TX resource
	if (Adapter->tcbUsed >= Adapter->NumTcb) {
#if	DBG
		GDbgStat.txNoTcb++;
#endif
		DBGSTR(("STATUS (SendPkt): No avail TCB\n"));
		return (NDIS_STATUS_RESOURCES);
	}

	tcb = Adapter->pTcbArray[Adapter->nextAvailTcbIdx];

	bytestosend = PrepareForTransmit(Adapter, Packet, tcb);

	if (Adapter->changeSpeedAfterThisPkt == Packet) {
		Adapter->changeSpeedAfterThisPkt = NULL;
		Adapter->changeSpeedPending = CHANGESPEED_ON_DONE;
	}

#if	DBG
	if (bytestosend > GDbgStat.txLargestPkt) {
		GDbgStat.txLargestPkt = bytestosend;
	}
#endif

	// 1.0.0
	if (bytestosend == 0) {
#if DBG
		DbgPrint ("==> OB \n\r");
#endif
			// Simplified change speed
		if (Adapter->changeSpeedPending == CHANGESPEED_ON_DONE) {
			// Note: We're changing speed in TX mode.
			MK7ChangeSpeedNow(Adapter);
			Adapter->changeSpeedPending = 0;
		}
			// For each completing TX there's a corresponding q'd pkt.
			// We release it here.
			QueuePacket = Adapter->FirstTxQueue;
			DequeuePacket(Adapter->FirstTxQueue, Adapter->LastTxQueue);
			Adapter->NumPacketsQueued--;
			NDIS_SET_PACKET_STATUS(QueuePacket, NDIS_STATUS_RESOURCES);
			NdisMSendComplete(	Adapter->MK7AdapterHandle,
								QueuePacket,
								NDIS_STATUS_RESOURCES);
			return(NDIS_STATUS_RESOURCES);
	}

	// Take care of ring wrap when incrementing.
	Adapter->nextAvailTcbIdx++;
	Adapter->nextAvailTcbIdx %= Adapter->NumTcb;
	Adapter->tcbUsed++;


	tcb->trd->count = bytestosend;

	GrantTrdToHw(tcb->trd);
	MK7SwitchToTXMode(Adapter);


#if	DBG
	NdisGetCurrentSystemTime((PLARGE_INTEGER)&GDbgTACmdTime[GDbgTATimeIdx]);
#endif

	DBGLOG("<= SendPkt", 0);

	return (NDIS_STATUS_SUCCESS);
}



//-----------------------------------------------------------------------------
// Procedure:   [PrepareForTransmit]
//
// Description:	When we come here we know there's an available TCB for the next
//		TX. We move the Packet data into the tx buff associated w/ the TCB.
//
// Arguments:
//      Adapter - ptr to Adapter object instance
//      Packet - A pointer to a descriptor for the packet that is to be
//               transmitted.
//      SwTcb - Pointer to a software structure that represents a hardware TCB.
//
// Returns:
//      TRUE If we were able to acquire the necessary TRD's or Coalesce buffer
//           for the packet in we are attempting to prepare for transmission.
//      FALSE If we needed a coalesce buffer, and we didn't have any available.
//-----------------------------------------------------------------------------
UINT PrepareForTransmit(PMK7_ADAPTER Adapter,
                   PNDIS_PACKET Packet,
                   PTCB tcb)
{
	UINT	BytesCopied;


	if (Adapter->CurrentSpeed <= MAX_SIR_SPEED) {
		// SIR needs additional software process
		if ( NdisToSirPacket(Adapter,
							Packet,
							(UCHAR *)tcb->buff,
							MK7_MAXIMUM_PACKET_SIZE,
							&BytesCopied) ) {

			return(BytesCopied);
		}
		return(0);
	}


#if	DBG
	if (Adapter->DbgTestDataCnt > 0) {
		TestDataToTXBuff(tcb->buff, Adapter->DbgTestDataCnt, &BytesCopied);
		return(BytesCopied);
	}
#endif


	tcb->Packet = Packet;
    NdisQueryPacket(tcb->Packet,
			        &tcb->NumPhysDesc,
	    	    	&tcb->BufferCount,
		    	    &tcb->FirstBuffer,
        			&tcb->PacketLength);

	// Alignment??
	//
	// Copy from packet to TCB data buffer
	CopyFromPacketToBuffer(	Adapter,
								tcb->Packet,
								tcb->PacketLength,
								tcb->buff,
								tcb->FirstBuffer,
								&BytesCopied );

//	ASSERT(BytesCopied == tcb->PacketLength);
	if (BytesCopied != tcb->PacketLength) {
#if DBG
		DbgPrint (" ==> BytesCopied Unmatched\n\r");
#endif
		return(0);
	}
	else 
		return(BytesCopied);
}



//-----------------------------------------------------------------------------
// Procedure:   [CopyFromPacketToBuffer]
//
// Description: This routine will copy a packet to a the passed buffer (which
//		in this case will be a coalesce buffer).
//
// Arguments:
//      Adapter - ptr to Adapter object instance
//      Packet - The packet to copy from.
//      BytesToCopy - The number of bytes to copy from the packet.
//      DestBuffer - The destination of the copy.
//      FirstBuffer - The first buffer of the packet that we are copying from.
//
// Result:
//      BytesCopied - The number of bytes actually copied
//
// Returns:		(none)
//-----------------------------------------------------------------------------
VOID
CopyFromPacketToBuffer( PMK7_ADAPTER Adapter,
                           PNDIS_PACKET Packet,
                           UINT BytesToCopy,
                           PCHAR DestBuffer,
                           PNDIS_BUFFER FirstBuffer,
                           PUINT BytesCopied)
{
	PNDIS_BUFFER    CurrentBuffer, NextBuffer;
    PVOID           VirtualAddress;
    UINT            CurrentLength;
    UINT            AmountToMove;

    *BytesCopied = 0;
    if (!BytesToCopy)
        return;

	if (FirstBuffer == NULL)
		return;
    
	CurrentBuffer = FirstBuffer;

	while (CurrentBuffer != NULL) {
			NdisQueryBufferSafe(CurrentBuffer, &VirtualAddress, &CurrentLength, 16);
			if (!VirtualAddress) {
#if DBG
				DbgPrint("==> Throw Away Failed Packet\n\r");
#endif
				return;
			}
			NdisGetNextBuffer(CurrentBuffer, &NextBuffer);
			CurrentBuffer = NextBuffer;
	}
    CurrentBuffer = FirstBuffer;
	// NDIS requirement
//  NdisQueryBuffer(CurrentBuffer,&VirtualAddress,&CurrentLength);
	NdisQueryBufferSafe(CurrentBuffer, &VirtualAddress, &CurrentLength, 16);

    while (BytesToCopy) {
        while (!CurrentLength) {
            NdisGetNextBuffer(CurrentBuffer, &CurrentBuffer);

            // If we've reached the end of the packet.  We return with what
            // we've done so far (which must be shorter than requested).
            if (!CurrentBuffer)
                return;

			// NDIS requirement
//			 NdisQueryBuffer(CurrentBuffer,&VirtualAddress,&CurrentLength);
			 NdisQueryBufferSafe(CurrentBuffer, &VirtualAddress, &CurrentLength, 16);


        }

        // Compute how much data to move from this fragment
        if (CurrentLength > BytesToCopy)
            AmountToMove = BytesToCopy;
        else
            AmountToMove = CurrentLength;

        // Copy the data.
        NdisMoveMemory(DestBuffer, VirtualAddress, AmountToMove);

        // Update destination pointer
        DestBuffer = (PCHAR) DestBuffer + AmountToMove;

        // Update counters
        *BytesCopied +=AmountToMove;
        BytesToCopy -=AmountToMove;
        CurrentLength = 0;
    }

	DBGLOG("  CopyFromPacketToBuffer: Bytes to Copy = ", BytesToCopy);
	DBGLOG("  CopyFromPacketToBuffer: Bytes Copied  = ", *BytesCopied);
}


//-----------------------------------------------------------------------------
// Procedure:	[MinTurnaroundTxTimeout] RYM-2K-1TX
//
// Description:	Delayed write because of Min Turnaround requirement. Just
//				do send.
//-----------------------------------------------------------------------------
VOID MinTurnaroundTxTimeout(PVOID sysspiff1,
							NDIS_HANDLE MiniportAdapterContext,
 							PVOID sysspiff2,
 							PVOID sysspiff3)
{
	PMK7_ADAPTER	Adapter;
	PNDIS_PACKET	QueuePacket;
    NDIS_STATUS		Status;


	Adapter = PMK7_ADAPTER_FROM_CONTEXT_HANDLE(MiniportAdapterContext);

	DBGLOG("=> MinTurnaroundTxTimeout", 0);

    NdisAcquireSpinLock(&Adapter->Lock);

	QueuePacket = Adapter->FirstTxQueue;

	if (!QueuePacket) {
	    NdisReleaseSpinLock(&Adapter->Lock);
		return;
	}

	Status = SendPkt(Adapter, QueuePacket);

	// Note: We set false here because we just processed a q'd TX pkt
	// that was waiting for MinTurnaround. However, we may still stay
	// in TX mode based on other pkts on the q. This is determined in
	// TX comp. Either writePending or IOMode will prevent new pkts
	// from above to get thru out of sequence.
	Adapter->writePending = FALSE;

    NdisReleaseSpinLock(&Adapter->Lock);

	MK7EnableInterrupt(Adapter);
}



#if	DBG
//--------------------------------------------------------------------------------
// Procedure:	[TestDataToTXBuff]
//
// Description:	Put test data in tx buff instead of data that came down.
//--------------------------------------------------------------------------------
VOID TestDataToTXBuff(	PCHAR	DestBuffer,
						UINT	BytesToCopy,
						PUINT	BytesCopied)
{
	UINT	i, j;

	for(i=0,j=0; j<BytesToCopy; j++) {
		DestBuffer[j] = TestPattern[i];
		i++;
		i %= TEST_PATTERN_SIZE;
	}
	*BytesCopied = BytesToCopy;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\net\irda\mknet\sys\sir.c ===
/*****************************************************************************
 **																			**
 **	COPYRIGHT (C) 2000, 2001 MKNET CORPORATION								**
 **	DEVELOPED FOR THE MK7100-BASED VFIR PCI CONTROLLER.						**
 **																			**
 *****************************************************************************/

 /**********************************************************************

Module Name:
	SIR.C

Routines:
	NdisToSirPacket
	ComputeSirFCS
	ProcRXSir

Comments:

**********************************************************************/


#include	"precomp.h"
#include	"protot.h"
#pragma		hdrstop



// SIR only
const USHORT fcsTable[256] =
{
        0x0000, 0x1189, 0x2312, 0x329b, 0x4624, 0x57ad, 0x6536, 0x74bf,
        0x8c48, 0x9dc1, 0xaf5a, 0xbed3, 0xca6c, 0xdbe5, 0xe97e, 0xf8f7,
        0x1081, 0x0108, 0x3393, 0x221a, 0x56a5, 0x472c, 0x75b7, 0x643e,
        0x9cc9, 0x8d40, 0xbfdb, 0xae52, 0xdaed, 0xcb64, 0xf9ff, 0xe876,
        0x2102, 0x308b, 0x0210, 0x1399, 0x6726, 0x76af, 0x4434, 0x55bd,
        0xad4a, 0xbcc3, 0x8e58, 0x9fd1, 0xeb6e, 0xfae7, 0xc87c, 0xd9f5,
        0x3183, 0x200a, 0x1291, 0x0318, 0x77a7, 0x662e, 0x54b5, 0x453c,
        0xbdcb, 0xac42, 0x9ed9, 0x8f50, 0xfbef, 0xea66, 0xd8fd, 0xc974,
        0x4204, 0x538d, 0x6116, 0x709f, 0x0420, 0x15a9, 0x2732, 0x36bb,
        0xce4c, 0xdfc5, 0xed5e, 0xfcd7, 0x8868, 0x99e1, 0xab7a, 0xbaf3,
        0x5285, 0x430c, 0x7197, 0x601e, 0x14a1, 0x0528, 0x37b3, 0x263a,
        0xdecd, 0xcf44, 0xfddf, 0xec56, 0x98e9, 0x8960, 0xbbfb, 0xaa72,
        0x6306, 0x728f, 0x4014, 0x519d, 0x2522, 0x34ab, 0x0630, 0x17b9,
        0xef4e, 0xfec7, 0xcc5c, 0xddd5, 0xa96a, 0xb8e3, 0x8a78, 0x9bf1,
        0x7387, 0x620e, 0x5095, 0x411c, 0x35a3, 0x242a, 0x16b1, 0x0738,
        0xffcf, 0xee46, 0xdcdd, 0xcd54, 0xb9eb, 0xa862, 0x9af9, 0x8b70,
        0x8408, 0x9581, 0xa71a, 0xb693, 0xc22c, 0xd3a5, 0xe13e, 0xf0b7,
        0x0840, 0x19c9, 0x2b52, 0x3adb, 0x4e64, 0x5fed, 0x6d76, 0x7cff,
        0x9489, 0x8500, 0xb79b, 0xa612, 0xd2ad, 0xc324, 0xf1bf, 0xe036,
        0x18c1, 0x0948, 0x3bd3, 0x2a5a, 0x5ee5, 0x4f6c, 0x7df7, 0x6c7e,
        0xa50a, 0xb483, 0x8618, 0x9791, 0xe32e, 0xf2a7, 0xc03c, 0xd1b5,
        0x2942, 0x38cb, 0x0a50, 0x1bd9, 0x6f66, 0x7eef, 0x4c74, 0x5dfd,
        0xb58b, 0xa402, 0x9699, 0x8710, 0xf3af, 0xe226, 0xd0bd, 0xc134,
        0x39c3, 0x284a, 0x1ad1, 0x0b58, 0x7fe7, 0x6e6e, 0x5cf5, 0x4d7c,
        0xc60c, 0xd785, 0xe51e, 0xf497, 0x8028, 0x91a1, 0xa33a, 0xb2b3,
        0x4a44, 0x5bcd, 0x6956, 0x78df, 0x0c60, 0x1de9, 0x2f72, 0x3efb,
        0xd68d, 0xc704, 0xf59f, 0xe416, 0x90a9, 0x8120, 0xb3bb, 0xa232,
        0x5ac5, 0x4b4c, 0x79d7, 0x685e, 0x1ce1, 0x0d68, 0x3ff3, 0x2e7a,
        0xe70e, 0xf687, 0xc41c, 0xd595, 0xa12a, 0xb0a3, 0x8238, 0x93b1,
        0x6b46, 0x7acf, 0x4854, 0x59dd, 0x2d62, 0x3ceb, 0x0e70, 0x1ff9,
        0xf78f, 0xe606, 0xd49d, 0xc514, 0xb1ab, 0xa022, 0x92b9, 0x8330,
        0x7bc7, 0x6a4e, 0x58d5, 0x495c, 0x3de3, 0x2c6a, 0x1ef1, 0x0f78
};





ULONG __inline EscapeSlowIrData(PUCHAR Dest, UCHAR SourceByte)
{
    switch (SourceByte){
        case SIR_BOF:
        case SIR_EOF:
        case SIR_ESC:
            Dest[0] = SIR_ESC;
            Dest[1] = SourceByte ^ SIR_ESC_COMP;
            return 2;

        default:
            Dest[0] = SourceByte;
            return 1;
    }
}




//-----------------------------------------------------------------------------
// Procedure:	[NdisToSirPacket]
//-----------------------------------------------------------------------------
BOOLEAN NdisToSirPacket	(PMK7_ADAPTER Adapter,
						PNDIS_PACKET Packet,
						UCHAR *irPacketBuf,
						UINT irPacketBufLen,
						UINT *irPacketLen
					)
{
	PNDIS_BUFFER    CurrentBuffer, NextBuffer;
	UINT			CurrentLength;
	PVOID           VirtualAddress;
	PNDIS_BUFFER ndisBuf;
	UINT i, ndisPacketBytes = 0, I_fieldBytes, totalBytes = 0;
	UINT ndisPacketLen, numExtraBOFs;
	SIR_FCS_TYPE fcs;
	UCHAR nextChar;
    UCHAR *bufData;
    UINT bufLen;
	PNDIS_IRDA_PACKET_INFO packetInfo = GetPacketInfo(Packet);


	// Get the packet's entire length and its first NDIS buffer
	NdisQueryPacket(Packet, NULL, NULL, &ndisBuf, &ndisPacketLen);

	// Make sure that the packet is big enough to be legal.
	// It consists of an A, C, and variable-length I field.
	if (ndisPacketLen < ADDR_SIZE + CONTROL_SIZE){
//		DBGERR(("packet too short in NdisToIrPacket (%d bytes)", ndisPacketLen));
		return (FALSE);
	}
	else {
		I_fieldBytes = ndisPacketLen - ADDR_SIZE - CONTROL_SIZE;
	}


	// Make sure that we won't overwrite our contiguous buffer.
	// Make sure that the passed-in buffer can accomodate this packet's
	// data no matter how much it grows through adding ESC-sequences, etc.
	if (ndisPacketLen > MK7_MAXIMUM_PACKET_SIZE) {
		// The packet is too large
		// Tell the caller to retry with a packet size large
		// enough to get past this stage next time.
		//DBGERR(("Packet too large in NdisToIrPacket (%d=%xh bytes), MAX_IRDA_DATA_SIZE=%d, irPacketBufLen=%d.",  ndisPacketLen, ndisPacketLen, MAX_IRDA_DATA_SIZE, irPacketBufLen));
		*irPacketLen = ndisPacketLen;
		return (FALSE);
	}
	
    if (!ndisBuf) {
        // DBGERR(("No NDIS_BUFFER in NdisToIrPacket"));
        return (FALSE);
    }
	
	
	CurrentBuffer = ndisBuf;
	while (CurrentBuffer != NULL) {
			NdisQueryBufferSafe(CurrentBuffer, &VirtualAddress, &CurrentLength, 16);
			if (!VirtualAddress) {
#if DBG
				DbgPrint("==> Throw Away Failed Packet\n\r");
#endif
				return (FALSE);
			}
			NdisGetNextBuffer(CurrentBuffer, &NextBuffer);
			CurrentBuffer = NextBuffer;
	}

	// NDIS requirement
//  NdisQueryBuffer(ndisBuf, (PVOID *)&bufData, &bufLen);
    NdisQueryBufferSafe(ndisBuf, (PVOID *)&bufData, &bufLen,16);

	/*
	 *  Now begin building the IR frame.
	 *
	 *  This is the final format:
	 *
	 *      extra BOFs ...
	 *		BOF	(1)
	 *		NdisMediumIrda packet (what we get from NDIS):
	 *			Address (1)
	 *			Control (1)
	 *		FCS	(2)
	 *      EOF (1)
	 */

    // Prepend BOFs (extra BOFs + 1 actual BOF)
	// 4.1.0
	if ((Adapter->HwVersion==HW_VER_1) && (Adapter->CurrentSpeed <= MAX_SIR_SPEED))
		numExtraBOFs = HW_VER_1_EBOFS;	
	else
		numExtraBOFs = packetInfo->ExtraBOFs;

	
	if (numExtraBOFs > MAX_EXTRA_SIR_BOFS) {
		numExtraBOFs = MAX_EXTRA_SIR_BOFS;
	}
	for (i = totalBytes = 0; i < numExtraBOFs; i++) {
		*(SIR_BOF_TYPE *)(irPacketBuf+totalBytes) = SIR_EXTRA_BOF;
		totalBytes += SIR_EXTRA_BOF_SIZE;
	}
	*(SIR_BOF_TYPE *)(irPacketBuf+totalBytes) = SIR_BOF;
	totalBytes += SIR_BOF_SIZE;

    fcs = 0xffff;

	// Fill TX buff w/ I data & calculate FCS as we go
    for (i=0; i<ndisPacketLen; i++) {

        ASSERT(bufData);
        nextChar = *bufData++;
        fcs = (fcs >> 8) ^ fcsTable[(fcs ^ nextChar) & 0xff];

		totalBytes += EscapeSlowIrData(&irPacketBuf[totalBytes], nextChar);
		
        if (--bufLen==0) {
            NdisGetNextBuffer(ndisBuf, &ndisBuf);
            if (ndisBuf) {
				// NDIS requriement
//				NdisQueryBuffer(ndisBuf, (PVOID *)&bufData, &bufLen);
				NdisQueryBufferSafe(ndisBuf, (PVOID *)&bufData, &bufLen,16);
            }
            else {
                bufData = NULL;
            }
        }
    }


    if (bufData != NULL) {
		// Packet was corrupt -- it misreported its size.
		// DBGERR(("Packet corrupt in NdisToIrPacket (buffer lengths don't add up to packet length)."));
		*irPacketLen = 0;
		return (FALSE);
    }

    fcs = ~fcs;

	// Put in the 16-bit FCS
    totalBytes += EscapeSlowIrData(&irPacketBuf[totalBytes], (UCHAR)(fcs&0xff));
    totalBytes += EscapeSlowIrData(&irPacketBuf[totalBytes], (UCHAR)(fcs>>8));

    // EOF
	*(SIR_EOF_TYPE *)&irPacketBuf[totalBytes] = SIR_EOF;
	totalBytes += SIR_EOF_SIZE;

	*irPacketLen = totalBytes;

//	DBGOUT(("... NdisToIrPacket converted %d-byte ndis pkt to %d-byte irda pkt:", ndisPacketLen, *irPacketLen));

	return (TRUE);
}



//----------------------------------------------------------------------
// Procedure:	[ComputeSirFCS]
//
//----------------------------------------------------------------------
USHORT ComputeSirFCS(UCHAR *data, UINT dataLen)
{
  USHORT fcs = 0xffff;
  UINT i;
 	
//  DBGOUT(("ComputeSirFCS() on %d-byte buffer.", dataLen));

  for (i = 0; i < dataLen; i++){
    fcs = (fcs >> 8) ^ fcsTable[(fcs ^ *data++) & 0xff];
  }

  fcs = ~fcs;

//  DBGOUT(("ComputeFCS returning %d=0x%x.", (UINT)fcs, (UINT)fcs));

  return (fcs);
}


//-----------------------------------------------------------------------------
// Procedure:   [ProcRXSir]
//
//-----------------------------------------------------------------------------
BOOLEAN	ProcRXSir(UCHAR *dBuff, UINT dCnt)
{
	USHORT fcs;


	// FCS is not computed over the FCS field. Need to look into this.
	// (It seems when the original FCS is included in the calculation,
	// we should get GOOD_FCS for result.)

	fcs = ComputeSirFCS(dBuff, dCnt);

	if (fcs != GOOD_FCS)
		return (FALSE);

	return (TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\net\irda\mknet\sys\winpci.h ===
/*****************************************************************************
 **																			**
 **	COPYRIGHT (C) 2000, 2001 MKNET CORPORATION								**
 **	DEVELOPED FOR THE MK7100-BASED VFIR PCI CONTROLLER.						**
 **																			**
 *****************************************************************************/

/**********************************************************************

Module Name:
	WINPCI.H

Comments:
	PCI & Windows PCI defs.

**********************************************************************/

#ifndef _WINPCI_H
#define _WINPCI_H


//-------------------------------------------------------------------------
// PCI configuration hardware ports
//-------------------------------------------------------------------------
#define CF1_CONFIG_ADDR_REGISTER    0x0CF8
#define CF1_CONFIG_DATA_REGISTER    0x0CFC
#define CF2_SPACE_ENABLE_REGISTER   0x0CF8
#define CF2_FORWARD_REGISTER        0x0CFA
#define CF2_BASE_ADDRESS            0xC000



//-------------------------------------------------------------------------
// Configuration Space Header
//-------------------------------------------------------------------------
typedef struct _PCI_CONFIG_STRUC {
    USHORT  PciVendorId;        // PCI Vendor ID
    USHORT  PciDeviceId;        // PCI Device ID
    USHORT  PciCommand;
    USHORT  PciStatus;
    UCHAR   PciRevisionId;
    UCHAR   PciClassCode[3];
    UCHAR   PciCacheLineSize;
    UCHAR   PciLatencyTimer;
    UCHAR   PciHeaderType;
    UCHAR   PciBIST;
    ULONG   PciBaseReg0;
    ULONG   PciBaseReg1;
    ULONG   PciBaseReg2;
    ULONG   PciBaseReg3;
    ULONG   PciBaseReg4;
    ULONG   PciBaseReg5;
    ULONG   PciReserved0;
    ULONG   PciReserved1;
    ULONG   PciExpROMAddress;
    ULONG   PciReserved2;
    ULONG   PciReserved3;
    UCHAR   PciInterruptLine;
    UCHAR   PciInterruptPin;
    UCHAR   PciMinGnt;
    UCHAR   PciMaxLat;
} PCI_CONFIG_STRUC, *PPCI_CONFIG_STRUC;


//----------------------------------------------------------------------
// PCI Config Space
//----------------------------------------------------------------------
#define PCI_VENDOR_ID_REGISTER      0x00    // PCI Vendor ID Register
#define PCI_DEVICE_ID_REGISTER      0x02    // PCI Device ID Register
#define PCI_CONFIG_ID_REGISTER      0x00    // PCI Configuration ID Register
#define PCI_COMMAND_REGISTER        0x04    // PCI Command Register
#define PCI_STATUS_REGISTER         0x06    // PCI Status Register
#define PCI_REV_ID_REGISTER         0x08    // PCI Revision ID Register
#define PCI_CLASS_CODE_REGISTER     0x09    // PCI Class Code Register
#define PCI_CACHE_LINE_REGISTER     0x0C    // PCI Cache Line Register
#define PCI_LATENCY_TIMER           0x0D    // PCI Latency Timer Register
#define PCI_HEADER_TYPE             0x0E    // PCI Header Type Register
#define PCI_BIST_REGISTER           0x0F    // PCI Built-In SelfTest Register
#define PCI_BAR_0_REGISTER          0x10    // PCI Base Address Register 0
#define PCI_BAR_1_REGISTER          0x14    // PCI Base Address Register 1
#define PCI_BAR_2_REGISTER          0x18    // PCI Base Address Register 2
#define PCI_BAR_3_REGISTER          0x1C    // PCI Base Address Register 3
#define PCI_BAR_4_REGISTER          0x20    // PCI Base Address Register 4
#define PCI_BAR_5_REGISTER          0x24    // PCI Base Address Register 5
#define PCI_SUBVENDOR_ID_REGISTER   0x2C    // PCI SubVendor ID Register
#define PCI_SUBDEVICE_ID_REGISTER   0x2E    // PCI SubDevice ID Register
#define PCI_EXPANSION_ROM           0x30    // PCI Expansion ROM Base Register
#define PCI_INTERRUPT_LINE          0x3C    // PCI Interrupt Line Register
#define PCI_INTERRUPT_PIN           0x3D    // PCI Interrupt Pin Register
#define PCI_MIN_GNT_REGISTER        0x3E    // PCI Min-Gnt Register
#define PCI_MAX_LAT_REGISTER        0x3F    // PCI Max_Lat Register
#define PCI_NODE_ADDR_REGISTER      0x40    // PCI Node Address Register



//-------------------------------------------------------------------------
// PCI Class Code Definitions
// Configuration Space Header
//-------------------------------------------------------------------------
#define PCI_BASE_CLASS      0x02    // Base Class - Network Controller
#define PCI_SUB_CLASS       0x00    // Sub Class - Ethernet Controller
#define PCI_PROG_INTERFACE  0x00    // Prog I/F - Ethernet COntroller

//-------------------------------------------------------------------------
// The following is copied from EQUATES.H
// Bit Mask definitions
//-------------------------------------------------------------------------
#define BIT_0		0x0001
#define BIT_1		0x0002
#define BIT_2		0x0004
#define BIT_3		0x0008
#define BIT_4		0x0010
#define BIT_5		0x0020
#define BIT_6		0x0040
#define BIT_7		0x0080
#define BIT_8		0x0100
#define BIT_9		0x0200
#define BIT_10		0x0400
#define BIT_11		0x0800
#define BIT_12		0x1000
#define BIT_13		0x2000
#define BIT_14		0x4000
#define BIT_15		0x8000
#define BIT_24		0x01000000
#define BIT_28		0x10000000

//-------------------------------------------------------------------------
// PCI Command Register Bit Definitions
// Configuration Space Header
//-------------------------------------------------------------------------
#define CMD_IO_SPACE            BIT_0
#define CMD_MEMORY_SPACE        BIT_1
#define CMD_BUS_MASTER          BIT_2
#define CMD_SPECIAL_CYCLES      BIT_3
#define CMD_MEM_WRT_INVALIDATE  BIT_4
#define CMD_VGA_PALLETTE_SNOOP  BIT_5
#define CMD_PARITY_RESPONSE     BIT_6
#define CMD_WAIT_CYCLE_CONTROL  BIT_7
#define CMD_SERR_ENABLE         BIT_8
#define CMD_BACK_TO_BACK        BIT_9

//-------------------------------------------------------------------------
// PCI Status Register Bit Definitions
// Configuration Space Header
//-------------------------------------------------------------------------
#define STAT_BACK_TO_BACK           BIT_7
#define STAT_DATA_PARITY            BIT_8
#define STAT_DEVSEL_TIMING          BIT_9 OR BIT_10
#define STAT_SIGNAL_TARGET_ABORT    BIT_11
#define STAT_RCV_TARGET_ABORT       BIT_12
#define STAT_RCV_MASTER_ABORT       BIT_13
#define STAT_SIGNAL_MASTER_ABORT    BIT_14
#define STAT_DETECT_PARITY_ERROR    BIT_15

//-------------------------------------------------------------------------
// PCI Base Address Register For Memory (BARM) Bit Definitions
// Configuration Space Header
//-------------------------------------------------------------------------
#define BARM_LOCATE_BELOW_1_MEG     BIT_1
#define BARM_LOCATE_IN_64_SPACE     BIT_2
#define BARM_PREFETCHABLE           BIT_3

//-------------------------------------------------------------------------
// PCI Base Address Register For I/O (BARIO) Bit Definitions
// Configuration Space Header
//-------------------------------------------------------------------------
#define BARIO_SPACE_INDICATOR       BIT_0

//-------------------------------------------------------------------------
// PCI BIOS Definitions
// Refer To The PCI BIOS Specification
//-------------------------------------------------------------------------
//- Function Code List
#define PCI_FUNCTION_ID         0xB1    // AH Register
#define PCI_BIOS_PRESENT        0x01    // AL Register
#define FIND_PCI_DEVICE         0x02    // AL Register
#define FIND_PCI_CLASS_CODE     0x03    // AL Register
#define GENERATE_SPECIAL_CYCLE  0x06    // AL Register
#define READ_CONFIG_BYTE        0x08    // AL Register
#define READ_CONFIG_WORD        0x09    // AL Register
#define READ_CONFIG_DWORD       0x0A    // AL Register
#define WRITE_CONFIG_BYTE       0x0B    // AL Register
#define WRITE_CONFIG_WORD       0x0C    // AL Register
#define WRITE_CONFIG_DWORD      0x0D    // AL Register

//- Function Return Code List
#define SUCCESSFUL              0x00
#define FUNC_NOT_SUPPORTED      0x81
#define BAD_VENDOR_ID           0x83
#define DEVICE_NOT_FOUND        0x86
#define BAD_REGISTER_NUMBER     0x87

//- PCI BIOS Calls
#define PCI_BIOS_INTERRUPT      0x1A        // PCI BIOS Int 1Ah Function Call
#define PCI_PRESENT_CODE        0x20494350  // Hex Equivalent Of 'PCI '

#define PCI_SERVICE_IDENTIFIER  0x49435024  // ASCII Codes for 'ICP$'

//- Device and Vendor IDs
#define MK7_PCI_DEVICE_ID       0x7100
#define MKNET_PCI_VENDOR_ID     0x1641
// For debugging
#define DBG_DEVICE_ID           0x7100
#define DBG_VENDOR_ID           0x2828

#endif      // _WINPCI_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\net\irda\mknet\sys\winreg.c ===
/*****************************************************************************
 **																			**
 **	COPYRIGHT (C) 2000, 2001 MKNET CORPORATION								**
 **	DEVELOPED FOR THE MK7100-BASED VFIR PCI CONTROLLER.						**
 **																			**
 *****************************************************************************/

/**********************************************************************

Module Name:
	WINREG.C

Routines:
	ParseRegistryParameters
	ProcessRegistry

Comments:
	Parse Windows Registry.

*****************************************************************************/

#include	"precomp.h"
#pragma		hdrstop



//************************************************************
// MK7RegTabType
//
//      One instance of this structure will be used for every configuration
//      parameter that this driver supports.  The table contains all of the
//      relavent information about each parameter:  Name, whether or not it is
//      required, where it is located in the "Adapter" structure, the size of
//      the parameter in bytes, the default value for the parameter, and what
//      the minimum and maximum values are for the parameter.  In the debug
//      version of the driver, this table also contains a field for the ascii
//      name of the parameter.
//************************************************************
typedef struct _MK7RegTabType {
    NDIS_STRING RegVarName;             // variable name text
    char       *RegAscName;             // variable name text
    UINT        Mandantory;             // 1 -> manditory, 0 -> optional
#define			MK7OPTIONAL		0
#define			MK7MANDATORY	1
    UINT        FieldOffset;            // offset to MK7_ADAPTER field loaded
    UINT        FieldSize;              // size (in bytes) of the field
    UINT        Default;                // default value to use
    UINT        Min;                    // minimum value allowed
    UINT        Max;                    // maximum value allowed
} MK7RegTabType;



//************************************************************
// Registry Parameters Table
//
//      This table contains a list of all of the configuration parameters
//      that the driver supports.  The driver will attempt to find these
//      parameters in the registry and use the registry value for these
//      parameters.  If the parameter is not found in the registry, then the
//      default value is used. This is a way for us to set defaults for
//		certain parameters.
//
//************************************************************


MK7RegTabType MK7RegTab[ ] = {
//
//	REGISTRY NAME						TEXT NAME		MAN/OPT			OFFSET
//	SIZE								DEF VAL			MIN				MAX
//

//#if DBG
//	{NDIS_STRING_CONST("Debug"),		"Debug",		MK7OPTIONAL,	MK7_OFFSET(Debug),
//	 MK7_SIZE(Debug),					DBG_NORMAL,		0,          	0xffffffff},
//#endif

	{NDIS_STRING_CONST("MaxConnectRate"),	"MaxConnectRate",	MK7OPTIONAL,	MK7_OFFSET(MaxConnSpeed),
	 MK7_SIZE(MaxConnSpeed),			16000000,			9600,			16000000},

	{NDIS_STRING_CONST("MinTurnAroundTime"), "MinTurnAroundTime",	MK7OPTIONAL, MK7_OFFSET(turnAroundTime_usec),
	 MK7_SIZE(turnAroundTime_usec),		DEFAULT_TURNAROUND_usec,	0,		 DEFAULT_TURNAROUND_usec},

	//
	// All the ones from here down are not really necessary except for testing.
	//

	{NDIS_STRING_CONST("BusNumber"),	"BusNumber",	MK7OPTIONAL,	MK7_OFFSET(BusNumber),
	 MK7_SIZE(BusNumber),				0,				0,				16},

    {NDIS_STRING_CONST("SlotNumber"),	"SlotNumber",	MK7OPTIONAL,	MK7_OFFSET(MKSlot),
	 MK7_SIZE(MKSlot),					0,				0,				32},

#if DBG
	{NDIS_STRING_CONST("Loopback"),		"Loopback",		MK7OPTIONAL,	MK7_OFFSET(LB),
	 MK7_SIZE(LB),						0,				0,				2},
#endif

	{NDIS_STRING_CONST("RingSize"),		"RingSize",		MK7OPTIONAL,	MK7_OFFSET(RingSize),
	 MK7_SIZE(RingSize),				DEF_RING_SIZE,	MIN_RING_SIZE,	MAX_RING_SIZE},

	{NDIS_STRING_CONST("RXRingSize"),	"RXRingSize",	MK7OPTIONAL,	MK7_OFFSET(RegNumRcb),
	 MK7_SIZE(RegNumRcb),				DEF_RXRING_SIZE,MIN_RING_SIZE,	DEF_RXRING_SIZE},

	{NDIS_STRING_CONST("TXRingSize"),	"TXRingSize",	MK7OPTIONAL,	MK7_OFFSET(RegNumTcb),
	 MK7_SIZE(RegNumTcb),				DEF_TXRING_SIZE,MIN_RING_SIZE,	DEF_TXRING_SIZE},

	{NDIS_STRING_CONST("ExtraBOFs"),	"ExtraBOFs",	MK7OPTIONAL,	MK7_OFFSET(RegExtraBOFs),
	 MK7_SIZE(RegExtraBOFs),			DEF_EBOFS,		MIN_EBOFS,		MAX_EBOFS},

	{NDIS_STRING_CONST("Speed"),		"Speed",		MK7OPTIONAL,	MK7_OFFSET(RegSpeed),
	 MK7_SIZE(RegSpeed),				16000000,		4000000,		16000000},

    {NDIS_STRING_CONST("BusType"),		"BusType",		MK7OPTIONAL,	MK7_OFFSET(MKBusType),
	MK7_SIZE(MKBusType),				PCIBUS,			PCIBUS,			PCIBUS},

    {NDIS_STRING_CONST("IoSize"),		"IoSize",		MK7OPTIONAL,	MK7_OFFSET(MKBaseSize),
	MK7_SIZE(MKBaseSize),				MK7_IO_SIZE,	MK7_IO_SIZE,	MK7_IO_SIZE},

	{NDIS_STRING_CONST("Wireless"),		"Wireless",		MK7OPTIONAL,	MK7_OFFSET(Wireless),
	 MK7_SIZE(Wireless),				1,				0,				1},
};



#define NUM_REG_PARAM ( sizeof (MK7RegTab) / sizeof (MK7RegTabType) )


//-----------------------------------------------------------------------------
// Procedure:   ParseRegistryParameters
//
// Description: This routine will parse all of the parameters out of the
//		registry/PROTOCOL.INI, and store the values in the "Adapter"
//		Structure.  If the parameter is not present in the registry, then the
//		default value for the parameter will be placed into the "Adapter"
//		structure.  This routine also checks the validity of the parameter
//		value, and if the value is out of range, the driver will the min/max
//		value allowed.
//
// Arguments:
//      Adapter - ptr to Adapter object instance
//      ConfigHandle - NDIS Configuration Registery handle
//
// Returns:
//      NDIS_STATUS_SUCCESS - All mandatory parameters were parsed
//      NDIS_STATUS_FAILED - A mandatory parameter was not present
//-----------------------------------------------------------------------------

NDIS_STATUS
ParseRegistryParameters(IN PMK7_ADAPTER Adapter,
                        IN NDIS_HANDLE ConfigHandle)
{
    UINT                i;
    NDIS_STATUS         Status;
    MK7RegTabType      *RegTab;
    UINT                value;
    PUCHAR              fieldPtr;
    PNDIS_CONFIGURATION_PARAMETER ReturnedValue;
#if DBG
    char                ansiRegName[32];
	ULONG				paramval;
#endif


	//****************************************
    // Grovel through the registry parameters and aquire all of the values
    // stored therein.
	//****************************************
    for (i=0, RegTab=MK7RegTab;	i<NUM_REG_PARAM; i++, RegTab++) {

        fieldPtr = ((PUCHAR) Adapter) + RegTab->FieldOffset;

#if DBG
        strcpy(ansiRegName, RegTab->RegAscName);
#endif

		//****************************************
        // Get the configuration value for a specific parameter.  Under NT the
        // parameters are all read in as DWORDs.
		//****************************************
        NdisReadConfiguration(&Status,
            &ReturnedValue,
            ConfigHandle,
            &RegTab->RegVarName,
            NdisParameterInteger);


		//****************************************
		// Param in Reg:
        // Check that it's w/i the min-max range. If not set it to
		// default, else just set to that in the Reg.
		//
		// Param not in Reg:
		// If it's a mandatory param, error out.
		// If it's optional (non-mandatory), again use default.
		//****************************************
        if (Status == NDIS_STATUS_SUCCESS) {

#if DBG
			paramval = ReturnedValue->ParameterData.IntegerData;
#endif

            if (ReturnedValue->ParameterData.IntegerData < RegTab->Min ||
                ReturnedValue->ParameterData.IntegerData > RegTab->Max) {
                value = RegTab->Default;
            }
            else {
                value = ReturnedValue->ParameterData.IntegerData;
            }
        }
        else if (RegTab->Mandantory) {
            DBGSTR(("Could not find mandantory in registry\n"));
			DBGLOG("<= ParseRegistryParameters (ERROR out)", 0);
			return (NDIS_STATUS_FAILURE);
        }
        else {	// non-mandatory
            value = RegTab->Default;
        }

		//****************************************
        // Store the value in the adapter structure.
		//****************************************
        switch (RegTab->FieldSize) {
        case 1:
                *((PUCHAR) fieldPtr) = (UCHAR) value;
                break;

        case 2:
                *((PUSHORT) fieldPtr) = (USHORT) value;
                break;

        case 4:
                *((PULONG) fieldPtr) = (ULONG) value;
                break;

        default:
            DBGSTR(("Bogus field size %d\n", RegTab->FieldSize));
            break;
        }
    }

    return (NDIS_STATUS_SUCCESS);
}



//----------------------------------------------------------------------
// Procedure:	[ProcessRegistry]
//
// Description:	Do all the one time Registry stuff.
//
// Return:		NDIS_STATUS_SUCCESS
//				(!NDIS_STATUS_SUCCESS)

//----------------------------------------------------------------------
NDIS_STATUS	ProcessRegistry(PMK7_ADAPTER Adapter,
							NDIS_HANDLE WrapperConfigurationContext)
{
	NDIS_STATUS		Status;
	NDIS_HANDLE		ConfigHandle;
    PVOID			OverrideNetAddress;
    ULONG			i;


	NdisOpenConfiguration(&Status,
						&ConfigHandle,
						WrapperConfigurationContext);

	if (Status != NDIS_STATUS_SUCCESS) {
		return (NDIS_STATUS_FAILURE);
	}

	//****************************************
	// Parse all our configuration parameters. Error out if bad
	// status returned -- Required param not in Registry.
	//****************************************
	Status = ParseRegistryParameters(Adapter, ConfigHandle);
	if (Status != NDIS_STATUS_SUCCESS) {
		NdisCloseConfiguration(ConfigHandle);
		return (Status);
	  }

	NdisCloseConfiguration(ConfigHandle);

//	Adapter->NumRcb = Adapter->RegNumRcb;
//	Adapter->NumTcb = Adapter->RegNumTcb;
	Adapter->NumRcb = DEF_RXRING_SIZE;
	Adapter->NumTcb = DEF_TXRING_SIZE;
	Adapter->NumRpd = CalRpdSize(Adapter->NumRcb);
	Adapter->extraBOFsRequired = Adapter->RegExtraBOFs;

	return(Status);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\net\irda\nscirda\makefile.inc ===
_LNG=$(LANGUAGE)
_INX=.

$(O)\irnsc.inf: $(_INX)\irnsc.inx $(_LNG)\irnsc.txt
    copy $(_INX)\$(@B).inx+$(_LNG)\$(@B).txt $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\net\irda\mknet\sys\winpci.c ===
/*****************************************************************************
 **																			**
 **	COPYRIGHT (C) 2000, 2001 MKNET CORPORATION								**
 **	DEVELOPED FOR THE MK7100-BASED VFIR PCI CONTROLLER.						**
 **																			**
 *****************************************************************************/

/**********************************************************************

Module Name:
	WINPCI.C

Routines:
	FindAndSetupPciDevice

Comments:
	Windows-NDIS PCI.

**********************************************************************/

#include	"precomp.h"
#pragma		hdrstop



//-----------------------------------------------------------------------------
// Procedure:   [FindAndSetupPciDevice]
//
// Description: This routine finds an adapter for the driver to load on
//              The critical piece to understanding this routine is that
//              the System will not let us read any information from PCI
//              space from any slot but the one that the System thinks
//              we should be using. The configuration manager rules this
//              land... The Slot number used by this routine is just a
//              placeholder, it could be zero even.
//
//				This code has enough flexibility to support multiple
//				PCI adapters. For now we only do one.
//
// Arguments:
//      Adapter - ptr to Adapter object instance
//      VendorID - Vendor ID of the adapter.
//      DeviceID - Device ID of the adapter.
//      PciCardsFound - A structure that contains an array of the IO addresses,
//                   IRQ, and node addresses of each PCI card that we find.
//
//    NOTE: due to NT 5's Plug and Play configuration manager
//          this routine will never return more than one device.
//
// Returns:
//      USHORT - Number of MK7 based PCI adapters found in the scanned bus
//-----------------------------------------------------------------------------
USHORT FindAndSetupPciDevice(IN PMK7_ADAPTER	Adapter, 
						NDIS_HANDLE WrapperConfigurationContext,
						IN USHORT		VendorID,
                    	IN USHORT		DeviceID,
                    	OUT PPCI_CARDS_FOUND_STRUC pPciCardsFound )
{
	NDIS_STATUS stat;
    ULONG		Device_Vendor_Id = 0;
    USHORT      Slot			= 0;

    /*
     *  We should only need 2 adapter resources (2 IO and 1 interrupt),
     *  but I've seen devices get extra resources.
     *  So give the NdisMQueryAdapterResources call room for 10 resources.
     */
    #define RESOURCE_LIST_BUF_SIZE (sizeof(NDIS_RESOURCE_LIST) + (10*sizeof(CM_PARTIAL_RESOURCE_DESCRIPTOR)))
    UCHAR buf[RESOURCE_LIST_BUF_SIZE];
    PNDIS_RESOURCE_LIST resList = (PNDIS_RESOURCE_LIST)buf;
    UINT bufSize = RESOURCE_LIST_BUF_SIZE;


	//****************************************
    // Verify the device is ours.
	//****************************************
    NdisReadPciSlotInformation(
        Adapter->MK7AdapterHandle,
        Slot,
        PCI_VENDOR_ID_REGISTER,
        (PVOID) &Device_Vendor_Id,
        sizeof (ULONG));

    if ( (((USHORT) Device_Vendor_Id) != VendorID) ||
         (((USHORT) (Device_Vendor_Id >> 16)) != DeviceID) ) {
	    pPciCardsFound->NumFound = 0;
		return (0);
	}


	//****************************************
    // Controller revision id
	//****************************************
	NdisReadPciSlotInformation(
		Adapter->MK7AdapterHandle,
		Slot,
		PCI_REV_ID_REGISTER,
		&pPciCardsFound->PciSlotInfo[0].ChipRevision,
		sizeof(pPciCardsFound->PciSlotInfo[0].ChipRevision));

	
	//****************************************
    // SubDevice and SubVendor ID
	// (We may want this in the future.)
	//****************************************
//        NdisReadPciSlotInformation(
//            Adapter->MK7AdapterHandle,
//            Slot,
//            PCI_SUBVENDOR_ID_REGISTER,
//            &pPciCardsFound->PciSlotInfo[found].SubVendor_DeviceID,
//            0x4);
//

    pPciCardsFound->PciSlotInfo[0].SlotNumber = (USHORT) 0;
	

	NdisMQueryAdapterResources(&stat, WrapperConfigurationContext, resList, &bufSize);
    if (stat == NDIS_STATUS_SUCCESS) {
        PCM_PARTIAL_RESOURCE_DESCRIPTOR resDesc;
        BOOLEAN     haveIRQ = FALSE,
                    haveIOAddr = FALSE;
        UINT i;

        for (resDesc = resList->PartialDescriptors, i = 0;
             i < resList->Count;
             resDesc++, i++) {

            switch (resDesc->Type) {
                case CmResourceTypePort:
					if (!haveIOAddr) {
		                if (resDesc->Flags & CM_RESOURCE_PORT_IO) {
			                pPciCardsFound->PciSlotInfo[0].BaseIo =
				                resDesc->u.Port.Start.LowPart;
							haveIOAddr = TRUE;
						}
					}
					break;

                case CmResourceTypeInterrupt:
					if (!haveIRQ) {
		                pPciCardsFound->PciSlotInfo[0].Irq =
			                (UCHAR) (resDesc->u.Port.Start.LowPart);
						haveIRQ = TRUE;
					}
					break;

	            case CmResourceTypeMemory:
					break;
            }
        }
    }

    return(1);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\net\irda\sigmatel\inf\makefile.inc ===
!IFNDEF LANGUAGE
LANGUAGE=usa
!ENDIF

_LNG=$(LANGUAGE)
_INX=.
STAMP=stampinf -f $@ -d 01/23/2001 -v 1.14.0.0

$(O)\irstusb.INF: $(_INX)\irstusb.inx $(_LNG)\irstusb.txt
    copy $(_INX)\$(@B).inx+$(_LNG)\$(@B).txt $@
    $(STAMP)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\net\irda\sigmatel\sys\convert.c ===
/**************************************************************************************************************************
 *  CONVERT.C SigmaTel STIR4200 format conversion (NDIS->IR, IR->NDIS) module
 **************************************************************************************************************************
 *  (C) Unpublished Copyright of Sigmatel, Inc. All Rights Reserved.
 *
 *
 *		Created: 04/06/2000 
 *			Version 0.9
 *		Edited: 05/12/2000 
 *			Version 0.94
 *	
 *
 **************************************************************************************************************************/

#define DOBREAKS    // enable debug breaks

#include <ndis.h>
#include <ntddndis.h>  // defines OID's

#include <usbdi.h>
#include <usbdlib.h>

#include "debug.h"
#include "ircommon.h"
#include "irndis.h"
#include "stir4200.h"

//
// Tables for CRC calculations
//
static const USHORT fcsTable16[256] =
{
    0x0000, 0x1189, 0x2312, 0x329b, 0x4624, 0x57ad, 0x6536, 0x74bf,
    0x8c48, 0x9dc1, 0xaf5a, 0xbed3, 0xca6c, 0xdbe5, 0xe97e, 0xf8f7,
    0x1081, 0x0108, 0x3393, 0x221a, 0x56a5, 0x472c, 0x75b7, 0x643e,
    0x9cc9, 0x8d40, 0xbfdb, 0xae52, 0xdaed, 0xcb64, 0xf9ff, 0xe876,
    0x2102, 0x308b, 0x0210, 0x1399, 0x6726, 0x76af, 0x4434, 0x55bd,
    0xad4a, 0xbcc3, 0x8e58, 0x9fd1, 0xeb6e, 0xfae7, 0xc87c, 0xd9f5,
    0x3183, 0x200a, 0x1291, 0x0318, 0x77a7, 0x662e, 0x54b5, 0x453c,
    0xbdcb, 0xac42, 0x9ed9, 0x8f50, 0xfbef, 0xea66, 0xd8fd, 0xc974,
    0x4204, 0x538d, 0x6116, 0x709f, 0x0420, 0x15a9, 0x2732, 0x36bb,
    0xce4c, 0xdfc5, 0xed5e, 0xfcd7, 0x8868, 0x99e1, 0xab7a, 0xbaf3,
    0x5285, 0x430c, 0x7197, 0x601e, 0x14a1, 0x0528, 0x37b3, 0x263a,
    0xdecd, 0xcf44, 0xfddf, 0xec56, 0x98e9, 0x8960, 0xbbfb, 0xaa72,
    0x6306, 0x728f, 0x4014, 0x519d, 0x2522, 0x34ab, 0x0630, 0x17b9,
    0xef4e, 0xfec7, 0xcc5c, 0xddd5, 0xa96a, 0xb8e3, 0x8a78, 0x9bf1,
    0x7387, 0x620e, 0x5095, 0x411c, 0x35a3, 0x242a, 0x16b1, 0x0738,
    0xffcf, 0xee46, 0xdcdd, 0xcd54, 0xb9eb, 0xa862, 0x9af9, 0x8b70,
    0x8408, 0x9581, 0xa71a, 0xb693, 0xc22c, 0xd3a5, 0xe13e, 0xf0b7,
    0x0840, 0x19c9, 0x2b52, 0x3adb, 0x4e64, 0x5fed, 0x6d76, 0x7cff,
    0x9489, 0x8500, 0xb79b, 0xa612, 0xd2ad, 0xc324, 0xf1bf, 0xe036,
    0x18c1, 0x0948, 0x3bd3, 0x2a5a, 0x5ee5, 0x4f6c, 0x7df7, 0x6c7e,
    0xa50a, 0xb483, 0x8618, 0x9791, 0xe32e, 0xf2a7, 0xc03c, 0xd1b5,
    0x2942, 0x38cb, 0x0a50, 0x1bd9, 0x6f66, 0x7eef, 0x4c74, 0x5dfd,
    0xb58b, 0xa402, 0x9699, 0x8710, 0xf3af, 0xe226, 0xd0bd, 0xc134,
    0x39c3, 0x284a, 0x1ad1, 0x0b58, 0x7fe7, 0x6e6e, 0x5cf5, 0x4d7c,
    0xc60c, 0xd785, 0xe51e, 0xf497, 0x8028, 0x91a1, 0xa33a, 0xb2b3,
    0x4a44, 0x5bcd, 0x6956, 0x78df, 0x0c60, 0x1de9, 0x2f72, 0x3efb,
    0xd68d, 0xc704, 0xf59f, 0xe416, 0x90a9, 0x8120, 0xb3bb, 0xa232,
    0x5ac5, 0x4b4c, 0x79d7, 0x685e, 0x1ce1, 0x0d68, 0x3ff3, 0x2e7a,
    0xe70e, 0xf687, 0xc41c, 0xd595, 0xa12a, 0xb0a3, 0x8238, 0x93b1,
    0x6b46, 0x7acf, 0x4854, 0x59dd, 0x2d62, 0x3ceb, 0x0e70, 0x1ff9,
    0xf78f, 0xe606, 0xd49d, 0xc514, 0xb1ab, 0xa022, 0x92b9, 0x8330,
    0x7bc7, 0x6a4e, 0x58d5, 0x495c, 0x3de3, 0x2c6a, 0x1ef1, 0x0f78
};

static const ULONG fcsTable32[256] =
{
    0x00000000, 0x77073096, 0xEE0E612C, 0x990951BA, 0x076DC419, 0x706AF48F, 0xE963A535, 0x9E6495A3,
    0x0EDB8832, 0x79DCB8A4, 0xE0D5E91E, 0x97D2D988, 0x09B64C2B, 0x7EB17CBD, 0xE7B82D07, 0x90BF1D91,
    0x1DB71064, 0x6AB020F2, 0xF3B97148, 0x84BE41DE, 0x1ADAD47D, 0x6DDDE4EB, 0xF4D4B551, 0x83D385C7,
    0x136C9856, 0x646BA8C0, 0xFD62F97A, 0x8A65C9EC, 0x14015C4F, 0x63066CD9, 0xFA0F3D63, 0x8D080DF5,
    0x3B6E20C8, 0x4C69105E, 0xD56041E4, 0xA2677172, 0x3C03E4D1, 0x4B04D447, 0xD20D85FD, 0xA50AB56B,
    0x35B5A8FA, 0x42B2986C, 0xDBBBC9D6, 0xACBCF940, 0x32D86CE3, 0x45DF5C75, 0xDCD60DCF, 0xABD13D59,
    0x26D930AC, 0x51DE003A, 0xC8D75180, 0xBFD06116, 0x21B4F4B5, 0x56B3C423, 0xCFBA9599, 0xB8BDA50F,
    0x2802B89E, 0x5F058808, 0xC60CD9B2, 0xB10BE924, 0x2F6F7C87, 0x58684C11, 0xC1611DAB, 0xB6662D3D,
    0x76DC4190, 0x01DB7106, 0x98D220BC, 0xEFD5102A, 0x71B18589, 0x06B6B51F, 0x9FBFE4A5, 0xE8B8D433,
    0x7807C9A2, 0x0F00F934, 0x9609A88E, 0xE10E9818, 0x7F6A0DBB, 0x086D3D2D, 0x91646C97, 0xE6635C01,
    0x6B6B51F4, 0x1C6C6162, 0x856530D8, 0xF262004E, 0x6C0695ED, 0x1B01A57B, 0x8208F4C1, 0xF50FC457,
    0x65B0D9C6, 0x12B7E950, 0x8BBEB8EA, 0xFCB9887C, 0x62DD1DDF, 0x15DA2D49, 0x8CD37CF3, 0xFBD44C65,
    0x4DB26158, 0x3AB551CE, 0xA3BC0074, 0xD4BB30E2, 0x4ADFA541, 0x3DD895D7, 0xA4D1C46D, 0xD3D6F4FB,
    0x4369E96A, 0x346ED9FC, 0xAD678846, 0xDA60B8D0, 0x44042D73, 0x33031DE5, 0xAA0A4C5F, 0xDD0D7CC9,
    0x5005713C, 0x270241AA, 0xBE0B1010, 0xC90C2086, 0x5768B525, 0x206F85B3, 0xB966D409, 0xCE61E49F,
    0x5EDEF90E, 0x29D9C998, 0xB0D09822, 0xC7D7A8B4, 0x59B33D17, 0x2EB40D81, 0xB7BD5C3B, 0xC0BA6CAD,
    0xEDB88320, 0x9ABFB3B6, 0x03B6E20C, 0x74B1D29A, 0xEAD54739, 0x9DD277AF, 0x04DB2615, 0x73DC1683,
    0xE3630B12, 0x94643B84, 0x0D6D6A3E, 0x7A6A5AA8, 0xE40ECF0B, 0x9309FF9D, 0x0A00AE27, 0x7D079EB1,
    0xF00F9344, 0x8708A3D2, 0x1E01F268, 0x6906C2FE, 0xF762575D, 0x806567CB, 0x196C3671, 0x6E6B06E7,
    0xFED41B76, 0x89D32BE0, 0x10DA7A5A, 0x67DD4ACC, 0xF9B9DF6F, 0x8EBEEFF9, 0x17B7BE43, 0x60B08ED5,
    0xD6D6A3E8, 0xA1D1937E, 0x38D8C2C4, 0x4FDFF252, 0xD1BB67F1, 0xA6BC5767, 0x3FB506DD, 0x48B2364B,
    0xD80D2BDA, 0xAF0A1B4C, 0x36034AF6, 0x41047A60, 0xDF60EFC3, 0xA867DF55, 0x316E8EEF, 0x4669BE79,
    0xCB61B38C, 0xBC66831A, 0x256FD2A0, 0x5268E236, 0xCC0C7795, 0xBB0B4703, 0x220216B9, 0x5505262F,
    0xC5BA3BBE, 0xB2BD0B28, 0x2BB45A92, 0x5CB36A04, 0xC2D7FFA7, 0xB5D0CF31, 0x2CD99E8B, 0x5BDEAE1D,
    0x9B64C2B0, 0xEC63F226, 0x756AA39C, 0x026D930A, 0x9C0906A9, 0xEB0E363F, 0x72076785, 0x05005713,
    0x95BF4A82, 0xE2B87A14, 0x7BB12BAE, 0x0CB61B38, 0x92D28E9B, 0xE5D5BE0D, 0x7CDCEFB7, 0x0BDBDF21,
    0x86D3D2D4, 0xF1D4E242, 0x68DDB3F8, 0x1FDA836E, 0x81BE16CD, 0xF6B9265B, 0x6FB077E1, 0x18B74777,
    0x88085AE6, 0xFF0F6A70, 0x66063BCA, 0x11010B5C, 0x8F659EFF, 0xF862AE69, 0x616BFFD3, 0x166CCF45,
    0xA00AE278, 0xD70DD2EE, 0x4E048354, 0x3903B3C2, 0xA7672661, 0xD06016F7, 0x4969474D, 0x3E6E77DB,
    0xAED16A4A, 0xD9D65ADC, 0x40DF0B66, 0x37D83BF0, 0xA9BCAE53, 0xDEBB9EC5, 0x47B2CF7F, 0x30B5FFE9,
    0xBDBDF21C, 0xCABAC28A, 0x53B39330, 0x24B4A3A6, 0xBAD03605, 0xCDD70693, 0x54DE5729, 0x23D967BF,
    0xB3667A2E, 0xC4614AB8, 0x5D681B02, 0x2A6F2B94, 0xB40BBE37, 0xC30C8EA1, 0x5A05DF1B, 0x2D02EF8D
};


/*****************************************************************************
*
*  Function:	NdisToFirPacket
*
*  Synopsis:	convert an NDIS packet to a Fir IR packet
*
*				Write the IR packet into the provided buffer and report
*				its actual size.
*
*  Arguments:	pIrDev - pointer to device instance
*				pPacket - NDIS packet to convert
*				pIrPacketBuf - output buffer
*				IrPacketBufLen - output buffer size
*				pContigPacketBuf - temporary staging buffer
*				pIrPacketLen - lenght of the converted data
*
*  Returns:		TRUE  - on success
*				FALSE - on failure
*
*
*****************************************************************************/
BOOLEAN         
NdisToFirPacket(
		IN PIR_DEVICE pIrDev,
		IN PNDIS_PACKET pPacket,
		OUT PUCHAR pIrPacketBuf,
		ULONG IrPacketBufLen,
		IN PUCHAR pContigPacketBuf,
		OUT PULONG pIrPacketLen
	)
{
    PNDIS_BUFFER        pNdisBuf;
    ULONG               ndisPacketBytes = 0;
    ULONG               I_fieldBytes, ndisPacketLen;
    FAST_IR_FCS_TYPE    fcs;
    FAST_IR_FCS_TYPE    UNALIGNED *pfcs;
    ULONG               i, TotalBytes, EscSize;
	PSTIR4200_FRAME_HEADER  pFrameHeader = (PSTIR4200_FRAME_HEADER)pIrPacketBuf;
	PUCHAR					pIrPacketBufFrame = pIrPacketBuf + sizeof(STIR4200_FRAME_HEADER);

    /***********************************************/
    /*   Get  the  packet's entire length and its  */
    /*   first NDIS buffer                         */
    /***********************************************/
    NdisQueryPacket( pPacket, NULL, NULL, &pNdisBuf, (UINT*)&ndisPacketLen );

    /***********************************************/
    /*   Make  sure that the packet is big enough  */
    /*   to be legal. It consists of an A, C, and  */
    /*   variable-length I field.                  */
    /***********************************************/
    if( ndisPacketLen < IRDA_A_C_TOTAL_SIZE )
    {
		DEBUGMSG(DBG_ERR, (" NdisToFirPacket(): Packet is too small\n"));
        return FALSE;
    }
    else
    {
        I_fieldBytes = ndisPacketLen - IRDA_A_C_TOTAL_SIZE;
    }

    /***********************************************/
    /*   Make  sure  that  we won't overwrite our  */
    /*   contiguous buffer                         */
    /***********************************************/
    if( (ndisPacketLen > MAX_TOTAL_SIZE_WITH_ALL_HEADERS) ||
        (MAX_POSSIBLE_IR_PACKET_SIZE_FOR_DATA(I_fieldBytes) > IrPacketBufLen) )
    {
        /***********************************************/
        /*   The packet is too large. Tell the caller  */
        /*   to retry with a packet size large enough  */
        /*   to get past this stage next time.         */
        /***********************************************/
		DEBUGMSG(DBG_ERR, (" NdisToFirPacket(): Packet is too big\n"));
        return FALSE;
    }

    /***********************************************/
    /*   Read  the  NDIS packet into a contiguous  */
    /*   buffer.  We have to do this in two steps  */
    /*   so  that  we  can compute the FCS BEFORE  */
    /*   applying escape-byte transparency.        */
    /***********************************************/
    while( pNdisBuf )
    {
        UCHAR *bufData;
        ULONG bufLen;

#if defined(LEGACY_NDIS5)
        NdisQueryBuffer( pNdisBuf, (PVOID*)&bufData, (UINT*)&bufLen );
#else
        NdisQueryBufferSafe( pNdisBuf, (PVOID*)&bufData, (UINT*)&bufLen, NormalPagePriority );
        if (bufData == NULL) 
		{
            DEBUGMSG(DBG_ERR, (" NdisToFirPacket(): Could not query buffer\n"));
            return FALSE;
        }
#endif
        if( (ndisPacketBytes + bufLen) > ndisPacketLen )
        {
			//
            // Packet was corrupt -- it misreported its size.
            //
			DEBUGMSG(DBG_ERR, (" NdisToFirPacket(): Packet is corrupt\n"));
            return FALSE;
        }
        NdisMoveMemory( (PVOID)(pContigPacketBuf + ndisPacketBytes), (PVOID)bufData, bufLen );
        ndisPacketBytes += bufLen;
        NdisGetNextBuffer( pNdisBuf, &pNdisBuf );
    }

    /***********************************************/
    /*   Do sanity check on length of packet...    */
    /***********************************************/
    if( ndisPacketBytes != ndisPacketLen )
    {
		//
		// Packet was corrupt -- it misreported its size.
        //
		DEBUGMSG(DBG_ERR, (" NdisToFirPacket(): Packet is corrupt\n"));
		return FALSE;
    }

    /***********************************************/
    /*   Compute  the  FCS  on  the packet BEFORE  */
    /*   applying  transparency  fixups.  The FCS  */
    /*   also   must   be   sent  using  ESC-char  */
    /*   transparency.                             */
    /***********************************************/
    fcs = ComputeFCS32( pContigPacketBuf, ndisPacketBytes );

    /***********************************************/
    /*   Add FCS to packet...                      */
    /***********************************************/
    pfcs = (FAST_IR_FCS_TYPE *)&pContigPacketBuf[ndisPacketBytes];
    *pfcs = fcs;

    /***********************************************/
    /*   Build the STIr4200 FIR frame.             */
    /***********************************************/

    /***********************************************/
    /*   Add preamble...                           */
    /***********************************************/
    memset( pIrPacketBufFrame, STIR4200_FIR_PREAMBLE, STIR4200_FIR_PREAMBLE_SIZ );

    /***********************************************/
    /*   Add BOF's...                              */
    /***********************************************/
    memset( &pIrPacketBufFrame[STIR4200_FIR_PREAMBLE_SIZ], STIR4200_FIR_BOF, STIR4200_FIR_BOF_SIZ );
    
    /***********************************************/
    /*   Escape A, C, I & CRC fields of packet...  */
    /***********************************************/
    EscSize = ndisPacketBytes + FAST_IR_FCS_SIZE;
    for( i = 0, TotalBytes = STIR4200_FIR_PREAMBLE_SIZ + STIR4200_FIR_BOF_SIZ; i < EscSize; i++ )
    {
        UCHAR   c;

        switch( c = pContigPacketBuf[i] )
        {
			case STIR4200_FIR_ESC_CHAR:
				pIrPacketBufFrame[TotalBytes++] = STIR4200_FIR_ESC_CHAR;
				pIrPacketBufFrame[TotalBytes++] = STIR4200_FIR_ESC_DATA_7D;
				break;
			case STIR4200_FIR_BOF:                  // BOF = EOF too
				pIrPacketBufFrame[TotalBytes++] = STIR4200_FIR_ESC_CHAR;
				pIrPacketBufFrame[TotalBytes++] = STIR4200_FIR_ESC_DATA_7E;
				break;
			case STIR4200_FIR_PREAMBLE:
				pIrPacketBufFrame[TotalBytes++] = STIR4200_FIR_ESC_CHAR;
				pIrPacketBufFrame[TotalBytes++] = STIR4200_FIR_ESC_DATA_7F;
				break;
			default: 
				pIrPacketBufFrame[TotalBytes++] = c;
        }
    }

    /***********************************************/
    /*   Add EOF's...                              */
    /***********************************************/
    memset( &pIrPacketBufFrame[TotalBytes], STIR4200_FIR_EOF, STIR4200_FIR_EOF_SIZ );

  	/***********************************************/
    /*   Add in STIr4200 header...                 */
    /***********************************************/
    TotalBytes += STIR4200_FIR_EOF_SIZ;
    pFrameHeader->id1     = STIR4200_HEADERID_BYTE1;
    pFrameHeader->id2     = STIR4200_HEADERID_BYTE2;
    pFrameHeader->sizlsb  = LOBYTE(TotalBytes);
    pFrameHeader->sizmsb  = HIBYTE(TotalBytes);

	/***********************************************/
    /*   Calc size packet w/escaped data...        */
    /***********************************************/
    *pIrPacketLen = TotalBytes + sizeof(STIR4200_FRAME_HEADER);

    return TRUE;
}


/*****************************************************************************
*
*  Function:	NdisToMirPacket
*
*  Synopsis:	convert an NDIS packet to a Mir IR packet
*
*				Write the IR packet into the provided buffer and report
*				its actual size.
*
*  Arguments:	pIrDev - pointer to device instance
*				pPacket - NDIS packet to convert
*				pIrPacketBuf - output buffer
*				IrPacketBufLen - output buffer size
*				pContigPacketBuf - temporary staging buffer
*				pIrPacketLen - lenght of the converted data
*
*  Returns:		TRUE  - on success
*				FALSE - on failure
*
*
*****************************************************************************/
BOOLEAN         
NdisToMirPacket(
		IN PIR_DEVICE pIrDev,
		IN PNDIS_PACKET pPacket,
		OUT PUCHAR pIrPacketBuf,
		ULONG IrPacketBufLen,
		IN PUCHAR pContigPacketBuf,
		OUT PULONG pIrPacketLen
	)
{
    PNDIS_BUFFER        pNdisBuf;
    ULONG               ndisPacketBytes = 0;
    ULONG               I_fieldBytes, ndisPacketLen;
    MEDIUM_IR_FCS_TYPE  fcs;
    MEDIUM_IR_FCS_TYPE  UNALIGNED *pfcs;
    ULONG               i, TotalBytes, EscSize;
	PSTIR4200_FRAME_HEADER  pFrameHeader = (PSTIR4200_FRAME_HEADER)pIrPacketBuf;
	PUCHAR					pIrPacketBufFrame = pIrPacketBuf + sizeof(STIR4200_FRAME_HEADER);

    /***********************************************/
    /*   Get  the  packet's entire length and its  */
    /*   first NDIS buffer                         */
    /***********************************************/
    NdisQueryPacket( pPacket, NULL, NULL, &pNdisBuf, (UINT*)&ndisPacketLen );

    /***********************************************/
    /*   Make  sure that the packet is big enough  */
    /*   to be legal. It consists of an A, C, and  */
    /*   variable-length I field.                  */
    /***********************************************/
    if( ndisPacketLen < IRDA_A_C_TOTAL_SIZE )
    {
		DEBUGMSG(DBG_ERR, (" NdisToMirPacket(): Packet too small\n"));
        return FALSE;
    }
    else
    {
        I_fieldBytes = ndisPacketLen - IRDA_A_C_TOTAL_SIZE;
    }

    /***********************************************/
    /*   Make  sure  that  we won't overwrite our  */
    /*   contiguous buffer                         */
    /***********************************************/
    if( (ndisPacketLen > MAX_TOTAL_SIZE_WITH_ALL_HEADERS) ||
        (MAX_POSSIBLE_IR_PACKET_SIZE_FOR_DATA(I_fieldBytes) > IrPacketBufLen) )
    {
        /***********************************************/
        /*   The packet is too large. Tell the caller  */
        /*   to retry with a packet size large enough  */
        /*   to get past this stage next time.         */
        /***********************************************/
		DEBUGMSG(DBG_ERR, (" NdisToMirPacket(): Packet too big\n"));
        return FALSE;
    }

    /***********************************************/
    /*   Read  the  NDIS packet into a contiguous  */
    /*   buffer.  We have to do this in two steps  */
    /*   so  that  we  can compute the FCS BEFORE  */
    /*   applying escape-byte transparency.        */
    /***********************************************/
    while( pNdisBuf )
    {
        UCHAR *bufData;
        ULONG bufLen;

#if defined(LEGACY_NDIS5)
        NdisQueryBuffer( pNdisBuf, (PVOID*)&bufData, (UINT*)&bufLen );
#else
        NdisQueryBufferSafe( pNdisBuf, (PVOID*)&bufData, (UINT*)&bufLen, NormalPagePriority );
        if (bufData == NULL) 
		{
            DEBUGMSG(DBG_ERR, (" NdisToMirPacket(): Could not query buffer\n"));
            return FALSE;
        }
#endif
        if( ndisPacketBytes + bufLen > ndisPacketLen )
        {
			//
            // Packet was corrupt -- it misreported its size.
            //
			DEBUGMSG(DBG_ERR, (" NdisToMirPacket(): Packet is corrupt\n"));
			*pIrPacketLen = 0;
            return FALSE;
        }
        NdisMoveMemory( (PVOID)(pContigPacketBuf + ndisPacketBytes), (PVOID)bufData, bufLen );
        ndisPacketBytes += bufLen;
        NdisGetNextBuffer( pNdisBuf, &pNdisBuf );
    }

    /***********************************************/
    /*   Do sanity check on length of packet...    */
    /***********************************************/
    if( ndisPacketBytes != ndisPacketLen )
    {
		//
		// Packet was corrupt -- it misreported its size.
        //
		DEBUGMSG(DBG_ERR, (" NdisToMirPacket(): Packet is corrupt\n"));
		return FALSE;
    }

    /***********************************************/
    /*   Compute  the  FCS  on  the packet BEFORE  */
    /*   applying  transparency  fixups.  The FCS  */
    /*   also   must   be   sent  using  ESC-char  */
    /*   transparency.                             */
    /***********************************************/
    fcs = ComputeFCS16( pContigPacketBuf, ndisPacketBytes );

    /***********************************************/
    /*   Add FCS to packet...                      */
    /***********************************************/
    pfcs    = (MEDIUM_IR_FCS_TYPE *)&pContigPacketBuf[ndisPacketBytes];
    *pfcs   = fcs;

    /***********************************************/
    /*   Build the STIr4200 MIR frame.             */
    /***********************************************/

    /***********************************************/
    /*   Add BOF's...                              */
    /***********************************************/
    memset( pIrPacketBufFrame, STIR4200_MIR_BOF, STIR4200_MIR_BOF_SIZ );
    
    /***********************************************/
    /*   Escape A, C, I & CRC fields of packet...  */
    /***********************************************/
    EscSize = ndisPacketBytes + MEDIUM_IR_FCS_SIZE;
    for( i = 0, TotalBytes = STIR4200_MIR_BOF_SIZ; i < EscSize; i++ )
    {
        UCHAR   c;

        switch( c = pContigPacketBuf[i] )
        {
			case STIR4200_MIR_ESC_CHAR:
				pIrPacketBufFrame[TotalBytes++] = STIR4200_MIR_ESC_CHAR;
				pIrPacketBufFrame[TotalBytes++] = STIR4200_MIR_ESC_DATA_7D;
				break;
			case STIR4200_MIR_BOF:                  // BOF = EOF too
				pIrPacketBufFrame[TotalBytes++] = STIR4200_MIR_ESC_CHAR;
				pIrPacketBufFrame[TotalBytes++] = STIR4200_MIR_ESC_DATA_7E;
				break;
			default: 
				pIrPacketBufFrame[TotalBytes++] = c;
        }
    }

    /***********************************************/
    /*   Add EOF's...                              */
    /***********************************************/
    memset( &pIrPacketBufFrame[TotalBytes], STIR4200_MIR_EOF, STIR4200_MIR_EOF_SIZ );

  	/***********************************************/
    /*   Add in STIr4200 header...                 */
    /***********************************************/
    TotalBytes += STIR4200_MIR_EOF_SIZ;
    pFrameHeader->id1     = STIR4200_HEADERID_BYTE1;
    pFrameHeader->id2     = STIR4200_HEADERID_BYTE2;
    pFrameHeader->sizlsb  = LOBYTE(TotalBytes);
    pFrameHeader->sizmsb  = HIBYTE(TotalBytes);

	/***********************************************/
    /*   Calc size packet w/escaped data...        */
    /***********************************************/
    *pIrPacketLen = TotalBytes + sizeof(STIR4200_FRAME_HEADER);

    return TRUE;
}


/*****************************************************************************
*
*  Function:    NdisToSirPacket
*
*  Synopsis:    convert an NDIS packet to a Sir IR packet
*
*               Write the IR packet into the provided buffer and report
*               its actual size.
*
*  Arguments:	pIrDev - pointer to device instance
*				pPacket - NDIS packet to convert
*				pIrPacketBuf - output buffer
*				IrPacketBufLen - output buffer size
*				pContigPacketBuf - temporary staging buffer
*				pIrPacketLen - lenght of the converted data
*
*  Returns:     TRUE  - on success
*               FALSE - on failure
*
*
*****************************************************************************/
BOOLEAN
NdisToSirPacket( 
		IN PIR_DEVICE pIrDev,
		IN PNDIS_PACKET pPacket,
		OUT PUCHAR pIrPacketBuf,
		ULONG IrPacketBufLen,
		IN PUCHAR pContigPacketBuf,
		OUT PULONG pIrPacketLen
	)
{
    PNDIS_BUFFER            pNdisBuf;
    ULONG                   i, ndisPacketBytes = 0;
    ULONG                   I_fieldBytes, totalBytes = 0;
    ULONG                   ndisPacketLen, numExtraBOFs;
    SLOW_IR_FCS_TYPE        fcs, tmpfcs;
    UCHAR                   fcsBuf[SLOW_IR_FCS_SIZE * 2];
    ULONG                   fcsLen = 0;
    PNDIS_IRDA_PACKET_INFO  pPacketInfo = GetPacketInfo(pPacket);
    UCHAR                   nextChar;
	PSTIR4200_FRAME_HEADER  pFrameHeader = (PSTIR4200_FRAME_HEADER)pIrPacketBuf;
	PUCHAR					pIrPacketBufFrame = pIrPacketBuf + sizeof(STIR4200_FRAME_HEADER);

    /***********************************************/
    /*   Get  the  packet's entire length and its  */
    /*   first NDIS buffer                         */
    /***********************************************/
    NdisQueryPacket( pPacket, NULL, NULL, &pNdisBuf, (UINT*)&ndisPacketLen );

    /***********************************************/
    /*   Make  sure that the packet is big enough  */
    /*   to be legal. It consists of an A, C, and  */
    /*   variable-length I field.                  */
    /***********************************************/
    if( ndisPacketLen < IRDA_A_C_TOTAL_SIZE )
    {
		DEBUGMSG(DBG_ERR, (" NdisToSirPacket(): Packet is too small\n"));
        return FALSE;
    }
    else
    {
        I_fieldBytes = ndisPacketLen - IRDA_A_C_TOTAL_SIZE;
    }

    /***********************************************/
    /*   Make  sure  that  we won't overwrite our  */
    /*   contiguous  buffer.  Make  sure that the  */
    /*   passed-in  buffer  can  accomodate  this  */
    /*   packet's  data  no  matter  how  much it  */
    /*   grows through adding ESC-sequences, etc.  */
    /***********************************************/
    if( (ndisPacketLen > MAX_TOTAL_SIZE_WITH_ALL_HEADERS) ||
        (MAX_POSSIBLE_IR_PACKET_SIZE_FOR_DATA(I_fieldBytes) > IrPacketBufLen) )
    {
		//
        // Packet is too big
		//
		DEBUGMSG(DBG_ERR, (" NdisToSirPacket(): Packet is too big\n"));
		return FALSE;
    }

    /***********************************************/
    /*   First,  read  the  NDIS  packet  into  a  */
    /*   contiguous buffer. We have to do this in  */
    /*   two steps so that we can compute the FCS  */
    /*   BEFORE        applying       escape-byte  */
    /*   transparency.                             */
    /***********************************************/
    while( pNdisBuf )
    {
        UCHAR *bufData;
        ULONG bufLen;

#if defined(LEGACY_NDIS5)
        NdisQueryBuffer( pNdisBuf, (PVOID*)&bufData, (UINT*)&bufLen );
#else
        NdisQueryBufferSafe( pNdisBuf, (PVOID*)&bufData, (UINT*)&bufLen, NormalPagePriority );
        if (bufData == NULL) 
		{
            DEBUGMSG(DBG_ERR, (" NdisToSirPacket(): Could not query buffer\n"));
            return FALSE;
        }
#endif
        if( (ndisPacketBytes + bufLen) > ndisPacketLen )
        {
            //
			// Packet was corrupt -- it misreported its size.
            //
			DEBUGMSG(DBG_ERR, (" NdisToSirPacket(): Packet is corrupt\n"));
			return FALSE;
        }
        NdisMoveMemory( (PVOID)(pContigPacketBuf + ndisPacketBytes), (PVOID)bufData, bufLen );
        ndisPacketBytes += bufLen;
        NdisGetNextBuffer( pNdisBuf, &pNdisBuf );
    }

    /***********************************************/
    /*   Do sanity check on length of packet...    */
    /***********************************************/
    if( ndisPacketBytes != ndisPacketLen )
    {
		//
        // Packet was corrupt -- it misreported its size.
        //
		DEBUGMSG(DBG_ERR, (" NdisToSirPacket(): Packet is corrupt\n"));
		return FALSE;
    }

    /***********************************************/
    /*   Compute  the  FCS  on  the packet BEFORE  */
    /*   applying  transparency  fixups.  The FCS  */
    /*   also   must   be   sent  using  ESC-char  */
    /*   transparency,  so  figure  out how large  */
    /*   the fcs will really be.                   */
    /***********************************************/
    fcs = ComputeFCS16( pContigPacketBuf, ndisPacketBytes );

    for( i = 0, tmpfcs = fcs, fcsLen = 0; i < SLOW_IR_FCS_SIZE; tmpfcs >>= 8, i++ )
    {
        UCHAR fcsbyte = tmpfcs & 0x00ff;

        switch( fcsbyte )
        {
			case SLOW_IR_BOF:
			case SLOW_IR_EOF:
			case SLOW_IR_ESC:
				fcsBuf[fcsLen++] = SLOW_IR_ESC;
				fcsBuf[fcsLen++] = fcsbyte ^ SLOW_IR_ESC_COMP;
				break;
			default:
				fcsBuf[fcsLen++] = fcsbyte;
				break;
        }
    }

    /***********************************************/
    /*   Now begin building the IR frame.          */
    /*                                             */
    /*   This is the final format:                 */
    /*                                             */
    /*  BOF  (1)                                   */
    /*  extra BOFs ...                             */
    /*          NdisMediumIrda packet (from NDIS): */
    /*                  Address (1)                */
    /*                  Control (1)                */
    /*          FCS     (2)                        */
    /*  EOF  (1)                                   */
    /*                                             */
    /*  Prepend BOFs (extra BOFs + 1 actual BOF)   */
    /***********************************************/
	numExtraBOFs = pPacketInfo->ExtraBOFs;
    if( numExtraBOFs > MAX_NUM_EXTRA_BOFS )
    {
        numExtraBOFs = MAX_NUM_EXTRA_BOFS;
    }

    for( i = totalBytes = 0; i < numExtraBOFs; i++ )
    {
        *(SLOW_IR_BOF_TYPE*)(pIrPacketBufFrame + totalBytes) = SLOW_IR_EXTRA_BOF;
        totalBytes += SLOW_IR_EXTRA_BOF_SIZE;
    }

    *(SLOW_IR_BOF_TYPE*)(pIrPacketBufFrame + totalBytes) = SLOW_IR_BOF;
    totalBytes += SLOW_IR_BOF_SIZE;

    /***********************************************/
    /*   Copy the NDIS packet from our contiguous  */
    /*   buffer,       applying       escape-char  */
    /*   transparency.                             */
    /***********************************************/
    for( i = 0; i < ndisPacketBytes; i++ )
    {
        nextChar = pContigPacketBuf[i];
        switch( nextChar )
        {
			case SLOW_IR_BOF:
			case SLOW_IR_EOF:
			case SLOW_IR_ESC:
				pIrPacketBufFrame[totalBytes++] = SLOW_IR_ESC;
				pIrPacketBufFrame[totalBytes++] = nextChar ^ SLOW_IR_ESC_COMP;
				break;
			default:
				pIrPacketBufFrame[totalBytes++] = nextChar;
				break;
        }
    }

    /***********************************************/
    /*   Add FCS, EOF.                             */
    /***********************************************/
    NdisMoveMemory( (PVOID)(pIrPacketBufFrame + totalBytes), (PVOID)fcsBuf, fcsLen );
    totalBytes += fcsLen;
    *(SLOW_IR_EOF_TYPE*)(pIrPacketBufFrame + totalBytes) = (UCHAR)SLOW_IR_EOF;
    totalBytes += SLOW_IR_EOF_SIZE;

 	/***********************************************/
    /*   Add in STIr4200 header...                 */
    /***********************************************/
    pFrameHeader->id1     = STIR4200_HEADERID_BYTE1;
    pFrameHeader->id2     = STIR4200_HEADERID_BYTE2;
    pFrameHeader->sizlsb  = LOBYTE(totalBytes);
    pFrameHeader->sizmsb  = HIBYTE(totalBytes);

   *pIrPacketLen = totalBytes + sizeof(STIR4200_FRAME_HEADER);
   return TRUE;
}


/*****************************************************************************
*
*  Function:	ComputeFCS16
*
*  Synopsis:	Calculates the 16 bit CRC.
*
*  Arguments:	pData - pointer to data buffer
*				DataLen - length of data buffer
*	
*  Returns:		Calculated CRC 
*
*  Notes:
*
*****************************************************************************/
USHORT
ComputeFCS16(
		IN PUCHAR pData, 
		UINT DataLen
	)
{
    USHORT	fcs = 0xffff;
    UINT    i;

    for( i = 0; i < DataLen; i++ )
    {
        fcs = (fcs >> 8) ^ fcsTable16[(fcs ^ *pData++)& 0xff];
    }
    fcs = ~fcs;
    return fcs;
}


/*****************************************************************************
*
*  Function:	ComputeFCS32
*
*  Synopsis:	Calculates the 32 bit CRC.
*
*  Arguments:	pData - pointer to data buffer
*				DataLen - length of data buffer
*	
*  Returns:		Calculated CRC 
*
*  Notes:
*
*****************************************************************************/
#define USE_FASTER_CRC32 1
ULONG 
ComputeFCS32(
		IN PUCHAR pData, 
		ULONG DataLen
	)
{
#ifdef USE_FASTER_CRC32

#define UPDC32(octet, crc) (crc_32_tab[((crc) ^ ((UCHAR)octet)) & 0xff] ^ ((crc) >> 8))

    ULONG   crc;

    crc = 0xFFFFFFFF;
    for( ; DataLen; --DataLen, ++pData )
    {
        crc = (fcsTable32[((crc) ^ (*pData)) & 0xff] ^ ((crc) >> 8));
    }
    return ~crc;
#else
    ULONG	crc, temp1, temp2;

    crc = 0xFFFFFFFF;
    while( DataLen-- != 0 )
    {
        temp1 = (crc >> 8) & 0x00FFFFFFL;
        temp2 = fcsTable32[((int)crc ^ *pData++) & 0xff];
        crc = temp1 ^ temp2;
    }
    return crc;
#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\net\irda\sigmatel\sys\debug.c ===
/**************************************************************************************************************************
 *  DEBUG.C SigmaTel STIR4200 debug module
 **************************************************************************************************************************
 *  (C) Unpublished Copyright of Sigmatel, Inc. All Rights Reserved.
 *
 *
 *		Created: 04/06/2000 
 *			Version 0.9
 *	
 *
 **************************************************************************************************************************/

#if DBG

#include "ndis.h"
#include "stdarg.h"
#include "stdio.h"

#include "usbdi.h"
#include "usbdlib.h"
#include "debug.h"


//
// begin, data/code  used only in DBG build
//
IRUSB_DBGDATA gDbgBuf = { 0, 0, 0 }; 

//
// ptr to global debug data struct; txt buffer is only allocated in DBG builds
//
PIRUSB_DBGDATA gpDbg = &gDbgBuf; 

#ifdef DEBUG
int DbgSettings =
                  //DBG_PNP |
                  //DBG_TIME     |
                  //DBG_DBG      |
                  //DBG_STAT     |
                  //DBG_FUNCTION |
                  DBG_ERROR    |
                  //DBG_WARN |
                  //DBG_BUFS |
                  //DBG_OUT |
                  0;
#endif


/*****************************************************************************
*
*  Function:	DBG_PrintBuf
*
*  Synopsis:	Prints a message to the debugger.
*
*  Arguments:	bufptr - pointer to the data to print
*				buflen - length of data 
*	
*  Returns:		None 
*
*  Notes:
*
*****************************************************************************/
VOID 
DBG_PrintBuf( 
		IN PUCHAR bufptr, 
		int buflen 
	)
{
	int i, linei;

	#define ISPRINT(ch) (((ch) >= ' ') && ((ch) <= '~'))
	#define PRINTCHAR(ch) (UCHAR)(ISPRINT(ch) ? (ch) : '.')

	DbgPrint("\r\n         %d bytes @%x:", buflen, bufptr);

	//
	//  Print whole lines of 8 characters with HEX and ASCII
	//
	for (i = 0; i+8 <= buflen; i += 8) 
	{
		UCHAR ch0 = bufptr[i+0],
			ch1 = bufptr[i+1], ch2 = bufptr[i+2],
			ch3 = bufptr[i+3], ch4 = bufptr[i+4],
			ch5 = bufptr[i+5], ch6 = bufptr[i+6],
			ch7 = bufptr[i+7];

		DbgPrint("\r\n         %02x %02x %02x %02x %02x %02x %02x %02x"
			"   %c %c %c %c %c %c %c %c",
			ch0, ch1, ch2, ch3, ch4, ch5, ch6, ch7,
			PRINTCHAR(ch0), PRINTCHAR(ch1),
			PRINTCHAR(ch2), PRINTCHAR(ch3),
			PRINTCHAR(ch4), PRINTCHAR(ch5),
			PRINTCHAR(ch6), PRINTCHAR(ch7));
	}

	//
	//  Print final incomplete line
	//
	DbgPrint("\r\n        ");
	for (linei = 0; (linei < 8) && (i < buflen); i++, linei++)
	{
		DbgPrint(" %02x", (int)(bufptr[i]));
	}

	DbgPrint("  ");
	i -= linei;
	while (linei++ < 8) DbgPrint("   ");

	for (linei = 0; (linei < 8) && (i < buflen); i++, linei++){
		UCHAR ch = bufptr[i];
		DbgPrint(" %c", PRINTCHAR(ch));
	}

	DbgPrint("\t\t<>\r\n");
}



#endif // end , if DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\net\irda\sigmatel\sys\diags.c ===
/**************************************************************************************************************************
 *  DIAGS.C SigmaTel STIR4200 diagnostic module
 **************************************************************************************************************************
 *  (C) Unpublished Copyright of Sigmatel, Inc. All Rights Reserved.
 *
 *
 *		Created: 04/27/2000 
 *			Version 0.92
 *		Edited: 05/12/2000 
 *			Version 0.94
 *		Edited: 05/19/2000 
 *			Version 0.95
 *		Edited: 05/24/2000 
 *			Version 0.96
 *		Edited: 10/09/2000 
 *			Version 1.10
 *	
 *
 **************************************************************************************************************************/

#if defined(DIAGS)

#define DOBREAKS    // enable debug breaks

#include <ndis.h>
#include <ntddndis.h>  // defines OID's

#include <usbdi.h>
#include <usbdlib.h>

#include "debug.h"
#include "ircommon.h"
#include "irndis.h"
#include "irusb.h"
#include "stir4200.h"
#include "diags.h"


/*****************************************************************************
*
*  Function:	Diags_BufferToFirPacket
*
*  Synopsis:	convert a buffer to a Fir IR packet
*
*				Write the IR packet into the provided buffer and report
*				its actual size.
*
*  Arguments:	pIrDev - pointer to device instance
*				pIrPacketBuf - output buffer
*				IrPacketBufLen - output buffer size
*				pContigPacketBuf - temporary staging buffer (input buffer)
*				ContigPacketLen - input buffer size
*				pIrPacketLen - lenght of the converted data
*
*  Returns:		TRUE  - on success
*				FALSE - on failure
*
*
*****************************************************************************/
BOOLEAN         
Diags_BufferToFirPacket(
		IN PIR_DEVICE pIrDev,
		OUT PUCHAR pIrPacketBuf,
		ULONG IrPacketBufLen,
		IN PUCHAR pContigPacketBuf,
		ULONG ContigPacketLen,
		OUT PULONG pIrPacketLen
	)
{
    ULONG               I_fieldBytes;
    FAST_IR_FCS_TYPE    fcs, *pfcs;
    ULONG               i, TotalBytes, EscSize;
	PSTIR4200_FRAME_HEADER  pFrameHeader = (PSTIR4200_FRAME_HEADER)pIrPacketBuf;
	PUCHAR					pIrPacketBufFrame = pIrPacketBuf + sizeof(STIR4200_FRAME_HEADER);

    /***********************************************/
    /*   Make  sure that the packet is big enough  */
    /*   to be legal. It consists of an A, C, and  */
    /*   variable-length I field.                  */
    /***********************************************/
    if( ContigPacketLen < IRDA_A_C_TOTAL_SIZE )
    {
		DEBUGMSG(DBG_ERR, (" Diags_BufferToFirPacket(): Packet is too small\n"));
        return FALSE;
    }
    else
    {
        I_fieldBytes = ContigPacketLen - IRDA_A_C_TOTAL_SIZE;
    }

    /***********************************************/
    /*   Make  sure  that  we won't overwrite our  */
    /*   contiguous buffer                         */
    /***********************************************/
    if( (ContigPacketLen > MAX_TOTAL_SIZE_WITH_ALL_HEADERS) ||
        (MAX_POSSIBLE_IR_PACKET_SIZE_FOR_DATA(I_fieldBytes) > IrPacketBufLen) )
    {
        /***********************************************/
        /*   The packet is too large. Tell the caller  */
        /*   to retry with a packet size large enough  */
        /*   to get past this stage next time.         */
        /***********************************************/
		DEBUGMSG(DBG_ERR, (" Diags_BufferToFirPacket(): Packet is too big\n"));
        return FALSE;
    }

    /***********************************************/
    /*   Compute  the  FCS  on  the packet BEFORE  */
    /*   applying  transparency  fixups.  The FCS  */
    /*   also   must   be   sent  using  ESC-char  */
    /*   transparency.                             */
    /***********************************************/
    fcs = ComputeFCS32( pContigPacketBuf, ContigPacketLen );

    /***********************************************/
    /*   Add FCS to packet...                      */
    /***********************************************/
    pfcs = (FAST_IR_FCS_TYPE *)&pContigPacketBuf[ContigPacketLen];
    *pfcs = fcs;

    /***********************************************/
    /*   Build the STIr4200 FIR frame.             */
    /***********************************************/

    /***********************************************/
    /*   Add preamble...                           */
    /***********************************************/
    memset( pIrPacketBufFrame, STIR4200_FIR_PREAMBLE, STIR4200_FIR_PREAMBLE_SIZ );

    /***********************************************/
    /*   Add BOF's...                              */
    /***********************************************/
    memset( &pIrPacketBufFrame[STIR4200_FIR_PREAMBLE_SIZ], STIR4200_FIR_BOF, STIR4200_FIR_BOF_SIZ );
    
    /***********************************************/
    /*   Escape A, C, I & CRC fields of packet...  */
    /***********************************************/
    EscSize = ContigPacketLen + FAST_IR_FCS_SIZE;
    for( i = 0, TotalBytes = STIR4200_FIR_PREAMBLE_SIZ + STIR4200_FIR_BOF_SIZ; i < EscSize; i++ )
    {
        UCHAR   c;

        switch( c = pContigPacketBuf[i] )
        {
			case STIR4200_FIR_ESC_CHAR:
				pIrPacketBufFrame[TotalBytes++] = STIR4200_FIR_ESC_CHAR;
				pIrPacketBufFrame[TotalBytes++] = STIR4200_FIR_ESC_DATA_7D;
				break;
			case STIR4200_FIR_BOF:                  // BOF = EOF too
				pIrPacketBufFrame[TotalBytes++] = STIR4200_FIR_ESC_CHAR;
				pIrPacketBufFrame[TotalBytes++] = STIR4200_FIR_ESC_DATA_7E;
				break;
			case STIR4200_FIR_PREAMBLE:
				pIrPacketBufFrame[TotalBytes++] = STIR4200_FIR_ESC_CHAR;
				pIrPacketBufFrame[TotalBytes++] = STIR4200_FIR_ESC_DATA_7F;
				break;
			default: 
				pIrPacketBufFrame[TotalBytes++] = c;
        }
    }

    /***********************************************/
    /*   Add EOF's...                              */
    /***********************************************/
    memset( &pIrPacketBufFrame[TotalBytes], STIR4200_FIR_EOF, STIR4200_FIR_EOF_SIZ );

  	/***********************************************/
    /*   Add in STIr4200 header...                 */
    /***********************************************/
    TotalBytes += STIR4200_FIR_EOF_SIZ;
    pFrameHeader->id1     = STIR4200_HEADERID_BYTE1;
    pFrameHeader->id2     = STIR4200_HEADERID_BYTE2;
    pFrameHeader->sizlsb  = LOBYTE(TotalBytes);
    pFrameHeader->sizmsb  = HIBYTE(TotalBytes);

	/***********************************************/
    /*   Calc size packet w/escaped data...        */
    /***********************************************/
    *pIrPacketLen = TotalBytes + sizeof(STIR4200_FRAME_HEADER);

    return TRUE;
}


/*****************************************************************************
*
*  Function:	Diags_BufferToSirPacket
*
*  Synopsis:	convert a buffer to a Sir IR packet
*
*               Write the IR packet into the provided buffer and report
*               its actual size.
*
*  Arguments:	pIrDev - pointer to device instance
*				pPacket - NDIS packet to convert
*				pIrPacketBuf - output buffer
*				IrPacketBufLen - output buffer size
*				pContigPacketBuf - temporary staging buffer (input buffer)
*				ContigPacketLen - input buffer size
*				pIrPacketLen - lenght of the converted data
*
*  Returns:     TRUE  - on success
*               FALSE - on failure
*
*
*****************************************************************************/
BOOLEAN
Diags_BufferToSirPacket(
		IN PIR_DEVICE pIrDev,
		OUT PUCHAR pIrPacketBuf,
		ULONG IrPacketBufLen,
		IN PUCHAR pContigPacketBuf,
		ULONG ContigPacketLen,
		USHORT ExtraBOFs,
		OUT PULONG pIrPacketLen
	)
{
    ULONG                   i;
    ULONG                   I_fieldBytes, totalBytes = 0;
    ULONG                   numExtraBOFs;
    SLOW_IR_FCS_TYPE        fcs, tmpfcs;
    UCHAR                   fcsBuf[SLOW_IR_FCS_SIZE * 2];
    ULONG                   fcsLen = 0;
    UCHAR                   nextChar;
	PSTIR4200_FRAME_HEADER  pFrameHeader = (PSTIR4200_FRAME_HEADER)pIrPacketBuf;
	PUCHAR					pIrPacketBufFrame = pIrPacketBuf + sizeof(STIR4200_FRAME_HEADER);

    /***********************************************/
    /*   Make  sure that the packet is big enough  */
    /*   to be legal. It consists of an A, C, and  */
    /*   variable-length I field.                  */
    /***********************************************/
    if( ContigPacketLen < IRDA_A_C_TOTAL_SIZE )
    {
		DEBUGMSG(DBG_ERR, (" NdisToSirPacket(): Packet is too small\n"));
        return FALSE;
    }
    else
    {
        I_fieldBytes = ContigPacketLen - IRDA_A_C_TOTAL_SIZE;
    }

    /***********************************************/
    /*   Make  sure  that  we won't overwrite our  */
    /*   contiguous  buffer.  Make  sure that the  */
    /*   passed-in  buffer  can  accomodate  this  */
    /*   packet's  data  no  matter  how  much it  */
    /*   grows through adding ESC-sequences, etc.  */
    /***********************************************/
    if( (ContigPacketLen > MAX_TOTAL_SIZE_WITH_ALL_HEADERS) ||
        (MAX_POSSIBLE_IR_PACKET_SIZE_FOR_DATA(I_fieldBytes) > IrPacketBufLen) )
    {
		//
        // Packet is too big
		//
		DEBUGMSG(DBG_ERR, (" NdisToSirPacket(): Packet is too big\n"));
		return FALSE;
    }

    /***********************************************/
    /*   Compute  the  FCS  on  the packet BEFORE  */
    /*   applying  transparency  fixups.  The FCS  */
    /*   also   must   be   sent  using  ESC-char  */
    /*   transparency,  so  figure  out how large  */
    /*   the fcs will really be.                   */
    /***********************************************/
    fcs = ComputeFCS16( pContigPacketBuf, ContigPacketLen );

    for( i = 0, tmpfcs = fcs, fcsLen = 0; i < SLOW_IR_FCS_SIZE; tmpfcs >>= 8, i++ )
    {
        UCHAR fcsbyte = tmpfcs & 0x00ff;

        switch( fcsbyte )
        {
			case SLOW_IR_BOF:
			case SLOW_IR_EOF:
			case SLOW_IR_ESC:
				fcsBuf[fcsLen++] = SLOW_IR_ESC;
				fcsBuf[fcsLen++] = fcsbyte ^ SLOW_IR_ESC_COMP;
				break;
			default:
				fcsBuf[fcsLen++] = fcsbyte;
				break;
        }
    }

    /***********************************************/
    /*   Now begin building the IR frame.          */
    /*                                             */
    /*   This is the final format:                 */
    /*                                             */
    /*  BOF  (1)                                   */
    /*  extra BOFs ...                             */
    /*          NdisMediumIrda packet (from NDIS): */
    /*                  Address (1)                */
    /*                  Control (1)                */
    /*          FCS     (2)                        */
    /*  EOF  (1)                                   */
    /*                                             */
    /*  Prepend BOFs (extra BOFs + 1 actual BOF)   */
    /***********************************************/
	numExtraBOFs = ExtraBOFs;
    if( numExtraBOFs > MAX_NUM_EXTRA_BOFS )
    {
        numExtraBOFs = MAX_NUM_EXTRA_BOFS;
    }

    for( i = totalBytes = 0; i < numExtraBOFs; i++ )
    {
        *(SLOW_IR_BOF_TYPE*)(pIrPacketBufFrame + totalBytes) = SLOW_IR_EXTRA_BOF;
        totalBytes += SLOW_IR_EXTRA_BOF_SIZE;
    }

    *(SLOW_IR_BOF_TYPE*)(pIrPacketBufFrame + totalBytes) = SLOW_IR_BOF;
    totalBytes += SLOW_IR_BOF_SIZE;

    /***********************************************/
    /*   Copy the NDIS packet from our contiguous  */
    /*   buffer,       applying       escape-char  */
    /*   transparency.                             */
    /***********************************************/
    for( i = 0; i < ContigPacketLen; i++ )
    {
        nextChar = pContigPacketBuf[i];
        switch( nextChar )
        {
			case SLOW_IR_BOF:
			case SLOW_IR_EOF:
			case SLOW_IR_ESC:
				pIrPacketBufFrame[totalBytes++] = SLOW_IR_ESC;
				pIrPacketBufFrame[totalBytes++] = nextChar ^ SLOW_IR_ESC_COMP;
				break;
			default:
				pIrPacketBufFrame[totalBytes++] = nextChar;
				break;
        }
    }

    /***********************************************/
    /*   Add FCS, EOF.                             */
    /***********************************************/
    NdisMoveMemory( (PVOID)(pIrPacketBufFrame + totalBytes), (PVOID)fcsBuf, fcsLen );
    totalBytes += fcsLen;
    *(SLOW_IR_EOF_TYPE*)(pIrPacketBufFrame + totalBytes) = (UCHAR)SLOW_IR_EOF;
    totalBytes += SLOW_IR_EOF_SIZE;

 	/***********************************************/
    /*   Add in STIr4200 header...                 */
    /***********************************************/
    pFrameHeader->id1     = STIR4200_HEADERID_BYTE1;
    pFrameHeader->id2     = STIR4200_HEADERID_BYTE2;
    pFrameHeader->sizlsb  = LOBYTE(totalBytes);
    pFrameHeader->sizmsb  = HIBYTE(totalBytes);

   *pIrPacketLen = totalBytes + sizeof(STIR4200_FRAME_HEADER);
   return TRUE;
}


/*****************************************************************************
*
*  Function:	Diags_Enable
*
*  Synopsis:	Switches the STIr4200 to diagnostic mode
*
*  Arguments:	pThisDev - pointer to IR device
*	
*  Returns:     NT status code
*
*  Notes:
*
*****************************************************************************/
NTSTATUS
Diags_Enable(
		IN OUT PIR_DEVICE pThisDev
	)
{
	PIRUSB_CONTEXT		pThisContext;
	PLIST_ENTRY			pListEntry;

	//
	// Make sure diags aren't already active
	//
	if( pThisDev->DiagsActive )
	{
        DEBUGMSG(DBG_ERR, (" Diags_Enable diags already active\n"));
		return STATUS_UNSUCCESSFUL;
	}

	//
	// Get a context to switch to the new mode
	//
	pListEntry = ExInterlockedRemoveHeadList( &pThisDev->SendAvailableQueue, &pThisDev->SendLock );

	if( NULL == pListEntry )
    {
        //
		// This must not happen
		//
        DEBUGMSG(DBG_ERR, (" Diags_Enable failed to find a free context struct\n"));
		IRUSB_ASSERT( 0 );
        
		return STATUS_UNSUCCESSFUL;
    }
	
	InterlockedDecrement( &pThisDev->SendAvailableCount );

	pThisContext = CONTAINING_RECORD( pListEntry, IRUSB_CONTEXT, ListEntry );
	pThisContext->ContextType = CONTEXT_DIAGS_ENABLE;
	
	//
	// Disable further interaction with the stack
	//
	InterlockedExchange( &pThisDev->DiagsPendingActivation, TRUE );

	//
	// Queue the context and then wait 
	//
	KeClearEvent( &pThisDev->EventDiags );
	ExInterlockedInsertTailList(
			&pThisDev->SendBuiltQueue,
			&pThisContext->ListEntry,
			&pThisDev->SendLock
		);
	InterlockedIncrement( &pThisDev->SendBuiltCount );

	MyKeWaitForSingleObject( pThisDev, &pThisDev->EventDiags, NULL, 0 );

	return pThisDev->IOCTLStatus;
}


/*****************************************************************************
*
*  Function:	Diags_Disable
*
*  Synopsis:	Switches the STIr4200 back to normal mode
*
*  Arguments:	pThisDev - pointer to IR device
*	
*  Returns:     NT status code
*
*  Notes:
*
*****************************************************************************/
NTSTATUS
Diags_Disable(
		IN OUT PIR_DEVICE pThisDev
	)
{
	PRCV_BUFFER pRecBuf;
	PLIST_ENTRY pEntry;
    
	//
	// Make sure diags are active
	//
	if( !pThisDev->DiagsActive )
	{
        DEBUGMSG(DBG_ERR, (" Diags_Disable diags not active\n"));
		return STATUS_UNSUCCESSFUL;
	}

	//
	// Enable interaction with the stack and no queuing of contexts is required
	//
	InterlockedExchange( &pThisDev->DiagsActive, FALSE );
	InterlockedExchange( &pThisDev->DiagsPendingActivation, FALSE );

	//
	// Get rid of all the diagnostic buffers
	//
	while( pEntry=ExInterlockedRemoveHeadList(
			&pThisDev->DiagsReceiveQueue,
			&pThisDev->DiagsReceiveLock )
		)
    {
		pRecBuf = CONTAINING_RECORD( pEntry, RCV_BUFFER, ListEntry );

		InterlockedExchange( &pRecBuf->DataLen, 0 );
		InterlockedExchange( (PULONG)&pRecBuf->BufferState, RCV_STATE_FREE );
    }

	return STATUS_SUCCESS;
}


/*****************************************************************************
*
*  Function:	Diags_ReadRegisters
*
*  Synopsis:	Prepares a context to read the registers
*
*  Arguments:	pThisDev - pointer to IR device
*				pIOCTL - pointer to IOCTL descriptor
*				IOCTLSize - size of the IOCTL buffer
*	
*  Returns:     NT status code
*
*  Notes:
*
*****************************************************************************/
NTSTATUS
Diags_ReadRegisters(
		IN OUT PIR_DEVICE pThisDev,
		OUT PDIAGS_READ_REGISTERS_IOCTL pIOCTL,
		ULONG IOCTLSize
	)
{
	PIRUSB_CONTEXT		pThisContext;
	PLIST_ENTRY			pListEntry;

	//
	// First basic validation
	//
	if( IOCTLSize < sizeof(DIAGS_READ_REGISTERS_IOCTL) )
	{
        DEBUGMSG(DBG_ERR, (" Diags_ReadRegisters invalid output buffer\n"));
		return STATUS_UNSUCCESSFUL;
	}
	
	//
	// Now we get a little more sofisticated
	//
	if( ((pIOCTL->FirstRegister+pIOCTL->NumberRegisters)>(STIR4200_MAX_REG+1)) || 
		((IOCTLSize+1)<(sizeof(DIAGS_READ_REGISTERS_IOCTL)+pIOCTL->NumberRegisters)) )
	{
        DEBUGMSG(DBG_ERR, (" Diags_ReadRegisters invalid output buffer\n"));
		return STATUS_UNSUCCESSFUL;
	}

	pThisDev->pIOCTL = pIOCTL;
	pThisDev->IOCTLStatus = STATUS_UNSUCCESSFUL;
	
	//
	// Get a context to queue
	//
	pListEntry = ExInterlockedRemoveHeadList( &pThisDev->SendAvailableQueue, &pThisDev->SendLock );

	if( NULL == pListEntry )
    {
        //
		// This must not happen
		//
        DEBUGMSG(DBG_ERR, (" Diags_ReadRegisters failed to find a free context struct\n"));
		IRUSB_ASSERT( 0 );
        
		return STATUS_UNSUCCESSFUL;
    }
	
	InterlockedDecrement( &pThisDev->SendAvailableCount );

	pThisContext = CONTAINING_RECORD( pListEntry, IRUSB_CONTEXT, ListEntry );
	pThisContext->ContextType = CONTEXT_DIAGS_READ_REGISTERS;
	
	//
	// Queue the context and then wait 
	//
	KeClearEvent( &pThisDev->EventDiags );
	ExInterlockedInsertTailList(
			&pThisDev->SendBuiltQueue,
			&pThisContext->ListEntry,
			&pThisDev->SendLock
		);
	InterlockedIncrement( &pThisDev->SendBuiltCount );

	MyKeWaitForSingleObject( pThisDev, &pThisDev->EventDiags, NULL, 0 );

	return pThisDev->IOCTLStatus;
}


/*****************************************************************************
*
*  Function:	Diags_WriteRegister
*
*  Synopsis:	Prepares a context to write the registers
*
*  Arguments:	pThisDev - pointer to IR device
*				pIOCTL - pointer to IOCTL descriptor
*				IOCTLSize - size of the IOCTL buffer
*	
*  Returns:     NT status code
*
*  Notes:
*
*****************************************************************************/
NTSTATUS
Diags_WriteRegister(
		IN OUT PIR_DEVICE pThisDev,
		OUT PDIAGS_READ_REGISTERS_IOCTL pIOCTL,
		ULONG IOCTLSize
	)
{
	PIRUSB_CONTEXT		pThisContext;
	PLIST_ENTRY			pListEntry;

	//
	// Validation
	//
	if( (IOCTLSize < sizeof(DIAGS_READ_REGISTERS_IOCTL)) ||
		(pIOCTL->FirstRegister>STIR4200_MAX_REG) )
	{
        DEBUGMSG(DBG_ERR, (" Diags_WriteRegister invalid output buffer\n"));
		return STATUS_UNSUCCESSFUL;
	}
	
	pThisDev->pIOCTL = pIOCTL;
	pThisDev->IOCTLStatus = STATUS_UNSUCCESSFUL;
	
	//
	// Get a context to queue
	//
	pListEntry = ExInterlockedRemoveHeadList( &pThisDev->SendAvailableQueue, &pThisDev->SendLock );

	if( NULL == pListEntry )
    {
        //
		// This must not happen
		//
        DEBUGMSG(DBG_ERR, (" Diags_ReadRegisters failed to find a free context struct\n"));
		IRUSB_ASSERT( 0 );
        
		return STATUS_UNSUCCESSFUL;
    }
	
	InterlockedDecrement( &pThisDev->SendAvailableCount );

	pThisContext = CONTAINING_RECORD( pListEntry, IRUSB_CONTEXT, ListEntry );
	pThisContext->ContextType = CONTEXT_DIAGS_WRITE_REGISTER;
	
	//
	// Queue the context and the wait 
	//
	KeClearEvent( &pThisDev->EventDiags );
	ExInterlockedInsertTailList(
			&pThisDev->SendBuiltQueue,
			&pThisContext->ListEntry,
			&pThisDev->SendLock
		);
	InterlockedIncrement( &pThisDev->SendBuiltCount );

	MyKeWaitForSingleObject( pThisDev, &pThisDev->EventDiags, NULL, 0 );

	return pThisDev->IOCTLStatus;
}


/*****************************************************************************
*
*  Function:	Diags_PrepareBulk
*
*  Synopsis:	Prepares a context to do a bulk transfer
*
*  Arguments:	pThisDev - pointer to IR device
*				pIOCTL - pointer to IOCTL descriptor
*				IOCTLSize - size of the IOCTL buffer
*				DirectionOut - TRUE if bulk-out, FALSE if bulk-in
*	
*  Returns:     NT status code
*
*  Notes:
*
*****************************************************************************/
NTSTATUS
Diags_PrepareBulk(
		IN OUT PIR_DEVICE pThisDev,
		OUT PDIAGS_BULK_IOCTL pIOCTL,
		ULONG IOCTLSize,
		BOOLEAN DirectionOut
	)
{
	PIRUSB_CONTEXT		pThisContext;
	PLIST_ENTRY			pListEntry;

	//
	// First basic validation
	//
	if( IOCTLSize < sizeof(DIAGS_BULK_IOCTL) )
	{
        DEBUGMSG(DBG_ERR, (" Diags_PrepareBulk invalid input buffer\n"));
		return STATUS_UNSUCCESSFUL;
	}
	
	//
	// Now we get a little more sofisticated
	//
	if( IOCTLSize < (sizeof(DIAGS_BULK_IOCTL)+pIOCTL->DataSize-1) )
	{
        DEBUGMSG(DBG_ERR, (" Diags_PrepareBulk invalid output buffer\n"));
		return STATUS_UNSUCCESSFUL;
	}

	pThisDev->pIOCTL = pIOCTL;
	pThisDev->IOCTLStatus = STATUS_UNSUCCESSFUL;
	
	//
	// Get a context to queue
	//
	pListEntry = ExInterlockedRemoveHeadList( &pThisDev->SendAvailableQueue, &pThisDev->SendLock );

	if( NULL == pListEntry )
    {
        //
		// This must not happen
		//
        DEBUGMSG(DBG_ERR, (" Diags_PrepareBulk failed to find a free context struct\n"));
		IRUSB_ASSERT( 0 );
        
		return STATUS_UNSUCCESSFUL;
    }
	
	InterlockedDecrement( &pThisDev->SendAvailableCount );

	pThisContext = CONTAINING_RECORD( pListEntry, IRUSB_CONTEXT, ListEntry );
	if( DirectionOut )
		pThisContext->ContextType = CONTEXT_DIAGS_BULK_OUT;
	else
		pThisContext->ContextType = CONTEXT_DIAGS_BULK_IN;

	//
	// Queue the context and then wait 
	//
	KeClearEvent( &pThisDev->EventDiags );
	ExInterlockedInsertTailList(
			&pThisDev->SendBuiltQueue,
			&pThisContext->ListEntry,
			&pThisDev->SendLock
		);
	InterlockedIncrement( &pThisDev->SendBuiltCount );

	MyKeWaitForSingleObject( pThisDev, &pThisDev->EventDiags, NULL, 0 );

	return pThisDev->IOCTLStatus;
}


/*****************************************************************************
*
*  Function:	Diags_PrepareSend
*
*  Synopsis:	Prepares a diagnostic send
*
*  Arguments:	pThisDev - pointer to IR device
*				pIOCTL - pointer to IOCTL descriptor
*				IOCTLSize - size of the IOCTL buffer
*	
*  Returns:		None
*
*  Notes:
*
*****************************************************************************/
NTSTATUS
Diags_PrepareSend(
		IN OUT PIR_DEVICE pThisDev,
		OUT PDIAGS_SEND_IOCTL pIOCTL,
		ULONG IOCTLSize
	)
{
	PIRUSB_CONTEXT		pThisContext;
	PLIST_ENTRY			pListEntry;
	ULONG				Size = sizeof(DIAGS_SEND_IOCTL)+pIOCTL->DataSize-1;

	//
	// First basic validation
	//
	if( IOCTLSize < sizeof(DIAGS_SEND_IOCTL) )
	{
        DEBUGMSG(DBG_ERR, (" Diags_PrepareBulk invalid input buffer\n"));
		return STATUS_UNSUCCESSFUL;
	}
	
	//
	// Now we get a little more sofisticated
	//
	if( IOCTLSize < (sizeof(DIAGS_SEND_IOCTL)+pIOCTL->DataSize-1) )
	{
        DEBUGMSG(DBG_ERR, (" Diags_PrepareSend invalid output buffer\n"));
		return STATUS_UNSUCCESSFUL;
	}

	pThisDev->pIOCTL = pIOCTL;
	pThisDev->IOCTLStatus = STATUS_UNSUCCESSFUL;
	
	//
	// Get a context to queue
	//
	pListEntry = ExInterlockedRemoveHeadList( &pThisDev->SendAvailableQueue, &pThisDev->SendLock );

	if( NULL == pListEntry )
    {
        //
		// This must not happen
		//
        DEBUGMSG(DBG_ERR, (" Diags_PrepareSend failed to find a free context struct\n"));
		IRUSB_ASSERT( 0 );
        
		return STATUS_UNSUCCESSFUL;
    }
	
	InterlockedDecrement( &pThisDev->SendAvailableCount );

	pThisContext = CONTAINING_RECORD( pListEntry, IRUSB_CONTEXT, ListEntry );
	pThisContext->ContextType = CONTEXT_DIAGS_SEND;

	//
	// Queue the context and then wait 
	//
	KeClearEvent( &pThisDev->EventDiags );
	ExInterlockedInsertTailList(
			&pThisDev->SendBuiltQueue,
			&pThisContext->ListEntry,
			&pThisDev->SendLock
		);
	InterlockedIncrement( &pThisDev->SendBuiltCount );

	MyKeWaitForSingleObject( pThisDev, &pThisDev->EventDiags, NULL, 0 );

	return pThisDev->IOCTLStatus;
}


/*****************************************************************************
*
*  Function:	Diags_Receive
*
*  Synopsis:	Diagnostic receive
*
*  Arguments:	pThisDev - pointer to IR device
*				pIOCTL - pointer to IOCTL descriptor
*				IOCTLSize - size of the IOCTL buffer
*	
*  Returns:		None
*
*  Notes:
*
*****************************************************************************/
NTSTATUS
Diags_Receive(
		IN OUT PIR_DEVICE pThisDev,
		OUT PDIAGS_RECEIVE_IOCTL pIOCTL,
		ULONG IOCTLSize
	)
{
	PLIST_ENTRY			pListEntry;
	PRCV_BUFFER			pRecBuf;

	//
	// First basic validation
	//
	if( IOCTLSize < sizeof(DIAGS_RECEIVE_IOCTL) )
	{
        DEBUGMSG(DBG_ERR, (" Diags_Receive invalid input buffer\n"));
		return STATUS_UNSUCCESSFUL;
	}
	
	//
	// Get a received packet
	//
	pListEntry = ExInterlockedRemoveHeadList( &pThisDev->DiagsReceiveQueue, &pThisDev->DiagsReceiveLock );

	if( NULL == pListEntry )
    {
        //
		// No packet available
		//
		return STATUS_UNSUCCESSFUL;
    }
	
	pRecBuf = CONTAINING_RECORD( pListEntry, RCV_BUFFER, ListEntry );

	//
	// Now we get a little more sofisticated
	//
	if( IOCTLSize < (sizeof(DIAGS_RECEIVE_IOCTL)+pIOCTL->DataSize-1) )
	{
        DEBUGMSG(DBG_ERR, (" Diags_Receive invalid output buffer\n"));
		return STATUS_UNSUCCESSFUL;
	}

	//
	// Copy the data
	//
	NdisMoveMemory( pIOCTL->pData, pRecBuf->pDataBuf, pRecBuf->DataLen );
	pIOCTL->DataSize = (USHORT)pRecBuf->DataLen;
	pThisDev->pIOCTL = pIOCTL;
	InterlockedExchange( &pRecBuf->DataLen, 0 );
	InterlockedExchange( (PULONG)&pRecBuf->BufferState, RCV_STATE_FREE );

	return STATUS_SUCCESS;
}


/*****************************************************************************
*
*  Function:	Diags_GetSpeed
*
*  Synopsis:	Retrieves the current speed
*
*  Arguments:	pThisDev - pointer to IR device
*				pIOCTL - pointer to IOCTL descriptor
*				IOCTLSize - size of the IOCTL buffer
*	
*  Returns:		None
*
*  Notes:
*
*****************************************************************************/
NTSTATUS
Diags_GetSpeed(
		IN OUT PIR_DEVICE pThisDev,
		OUT PDIAGS_SPEED_IOCTL pIOCTL,
		ULONG IOCTLSize
	)
{
	//
	// First basic validation
	//
	if( IOCTLSize < sizeof(DIAGS_SPEED_IOCTL) )
	{
        DEBUGMSG(DBG_ERR, (" Diags_GetSpeed invalid input buffer\n"));
		return STATUS_UNSUCCESSFUL;
	}

	pIOCTL->Speed = pThisDev->currentSpeed;

	return STATUS_SUCCESS;
}


/*****************************************************************************
*
*  Function:	Diags_SetSpeed
*
*  Synopsis:	Sets a new speed in diagnostic mode
*
*  Arguments:	pThisDev - pointer to IR device
*				pIOCTL - pointer to IOCTL descriptor
*				IOCTLSize - size of the IOCTL buffer
*	
*  Returns:		None
*
*  Notes:
*
*****************************************************************************/
NTSTATUS
Diags_SetSpeed(
		IN OUT PIR_DEVICE pThisDev,
		OUT PDIAGS_SPEED_IOCTL pIOCTL,
		ULONG IOCTLSize
	)
{
	NDIS_STATUS status;
	USHORT i;
	
	//
	// First basic validation
	//
	if( IOCTLSize < sizeof(DIAGS_SPEED_IOCTL) )
	{
        DEBUGMSG(DBG_ERR, (" Diags_SetSpeed invalid input buffer\n"));
		return STATUS_UNSUCCESSFUL;
	}

    if( pThisDev->currentSpeed == pIOCTL->Speed )
    {
        //
        // We are already set to the requested speed.
        //
		return STATUS_SUCCESS;
    }

    DEBUGMSG(DBG_ERR, (" Diags_SetSpeed(OID_IRDA_LINK_SPEED, 0x%x, decimal %d)\n",pIOCTL->Speed, pIOCTL->Speed));

    for( i = 0; i < NUM_BAUDRATES; i++ )
    {
        if( supportedBaudRateTable[i].BitsPerSec == pIOCTL->Speed )
        {
            //
            // Keep a pointer to the link speed which has
            // been requested. 
            //
            pThisDev->linkSpeedInfo = &supportedBaudRateTable[i]; 

            status = NDIS_STATUS_PENDING; 
            break; //for
        }
    }

    //
	// Don't set if there is an error
	//
	if( NDIS_STATUS_PENDING != status  )
    {
        DEBUGMSG(DBG_ERR, (" Invalid link speed\n"));
 		return STATUS_UNSUCCESSFUL;
	} 

	//
	// Set the new speed
	//
	IrUsb_PrepareSetSpeed( pThisDev );
	
	while( pThisDev->linkSpeedInfo->BitsPerSec != pThisDev->currentSpeed )
	{
		NdisMSleep( 50000 );
	}

	return STATUS_SUCCESS;
}


/*****************************************************************************
*
*  Function:	Diags_CompleteEnable
*
*  Synopsis:	Completes the enabling of the diagnostic state
*
*  Arguments:	pThisDev - pointer to IR device
*				pContext - pinter to the operation context
*	
*  Returns:		None
*
*  Notes:
*
*****************************************************************************/
VOID
Diags_CompleteEnable(
		IN OUT PIR_DEVICE pThisDev,
		IN PVOID pContext
	)
{
	PIRUSB_CONTEXT pThisContext = pContext;

	//
	// Really enable diags
	//
	InterlockedExchange( &pThisDev->DiagsActive, TRUE );

	//
	// Return the context
	//
	ExInterlockedInsertTailList(
		&pThisDev->SendAvailableQueue,
		&pThisContext->ListEntry,
		&pThisDev->SendLock
	);
	InterlockedIncrement( &pThisDev->SendAvailableCount );

	//
	// Signal
	//
	KeSetEvent( &pThisDev->EventDiags, 0, FALSE );  //signal we're done
}


/*****************************************************************************
*
*  Function:	Diags_CompleteReadRegisters
*
*  Synopsis:	Reads the registers and returns the value
*
*  Arguments:	pThisDev - pointer to IR device
*				pContext - pinter to the operation context
*	
*  Returns:		None
*
*  Notes:
*
*****************************************************************************/
VOID
Diags_CompleteReadRegisters(
		IN OUT PIR_DEVICE pThisDev,
		IN PVOID pContext
	)
{
	PDIAGS_READ_REGISTERS_IOCTL pIOCTL = pThisDev->pIOCTL;
	PIRUSB_CONTEXT pThisContext = pContext;

	//
	// Read the data
	//
	pThisDev->IOCTLStatus = St4200ReadRegisters( pThisDev, pIOCTL->FirstRegister, pIOCTL->NumberRegisters );
	if( pThisDev->IOCTLStatus == STATUS_SUCCESS )
	{
		NdisMoveMemory( 
				&pIOCTL->pRegisterBuffer, 
				&pThisDev->StIrTranceiver.FifoDataReg+pIOCTL->FirstRegister,
				pIOCTL->NumberRegisters
			);
	}

	//
	// Return the context
	//
	ExInterlockedInsertTailList(
		&pThisDev->SendAvailableQueue,
		&pThisContext->ListEntry,
		&pThisDev->SendLock
	);
	InterlockedIncrement( &pThisDev->SendAvailableCount );

	//
	// Signal
	//
	KeSetEvent( &pThisDev->EventDiags, 0, FALSE );  //signal we're done
}


/*****************************************************************************
*
*  Function:	Diags_CompleteWriteRegister
*
*  Synopsis:	Reads the registers and returns the value
*
*  Arguments:	pThisDev - pointer to IR device
*				pContext - pinter to the operation context
*	
*  Returns:		None
*
*  Notes:
*
*****************************************************************************/
VOID
Diags_CompleteWriteRegister(
		IN OUT PIR_DEVICE pThisDev,
		IN PVOID pContext
	)
{
	PDIAGS_READ_REGISTERS_IOCTL pIOCTL = pThisDev->pIOCTL;
	PIRUSB_CONTEXT pThisContext = pContext;

	//
	// Copy the new register value
	//
	NdisMoveMemory( 
			&pThisDev->StIrTranceiver.FifoDataReg+pIOCTL->FirstRegister,
			&pIOCTL->pRegisterBuffer, 
			1
		);

	//
	// Write to the device
	//
	pThisDev->IOCTLStatus = St4200WriteRegister( pThisDev, pIOCTL->FirstRegister );

	//
	// Return the context
	//
	ExInterlockedInsertTailList(
		&pThisDev->SendAvailableQueue,
		&pThisContext->ListEntry,
		&pThisDev->SendLock
	);
	InterlockedIncrement( &pThisDev->SendAvailableCount );

	//
	// Signal
	//
	KeSetEvent( &pThisDev->EventDiags, 0, FALSE );  //signal we're done
}

/*****************************************************************************
*
*  Function:	Diags_Bulk
*
*  Synopsis:	Executes a diagnostic bulk transfer
*
*  Arguments:	pThisDev - pointer to IR device
*				pContext - pinter to the operation context
*				DirectionOut - TRUE if bulk-out, FALSE if bulk-in
*	
*  Returns:		None
*
*  Notes:
*
*****************************************************************************/
VOID
Diags_Bulk(
		IN OUT PIR_DEVICE pThisDev,
		IN PVOID pContext,
		BOOLEAN DirectionOut
	)
{
	PDIAGS_BULK_IOCTL	pIOCTL = pThisDev->pIOCTL;
	PIRUSB_CONTEXT		pThisContext = pContext;
	NTSTATUS			status;
    PIRP                pIrp;
    PURB				pUrb = NULL;
    PDEVICE_OBJECT		pUrbTargetDev;
    PIO_STACK_LOCATION	pNextStack;
	KIRQL				OldIrql;

    IRUSB_ASSERT( KeGetCurrentIrql() == PASSIVE_LEVEL );

	IRUSB_ASSERT( NULL != pThisContext );

	//
	// Stop if a halt/reset is going on
	//
	if( pThisDev->fPendingWriteClearStall || pThisDev->fPendingHalt || 
		pThisDev->fPendingReset || pThisDev->fPendingClearTotalStall ) 
	{
        DEBUGMSG(DBG_ERR, (" Diags_Bulk abort due to pending reset or halt\n"));
		goto done;
	}
		
	pUrb = pThisDev->pUrb;

	NdisZeroMemory( pUrb, pThisDev->UrbLen );

	//
	// Save the effective length
	//
	pThisDev->BufLen = pIOCTL->DataSize;

	//
    // Now that we have created the urb, we will send a
    // request to the USB device object.
    //
    pUrbTargetDev = pThisDev->pUsbDevObj;

	//
	// make an irp sending to usbhub
	//
	pIrp = IoAllocateIrp( (CCHAR)(pThisDev->pUsbDevObj->StackSize + 1), FALSE );

    if( NULL == pIrp )
    {
        DEBUGMSG(DBG_ERR, (" Diags_Bulk failed to alloc IRP\n"));
        goto done;
    }

    pIrp->IoStatus.Status = STATUS_PENDING;
    pIrp->IoStatus.Information = 0;

	pThisContext->pIrp = pIrp;

	//
	// Build our URB for USBD
	//
    pUrb->UrbBulkOrInterruptTransfer.Hdr.Length = (USHORT)sizeof( struct _URB_BULK_OR_INTERRUPT_TRANSFER );
    pUrb->UrbBulkOrInterruptTransfer.Hdr.Function = URB_FUNCTION_BULK_OR_INTERRUPT_TRANSFER;
	if( DirectionOut )
	{
		pUrb->UrbBulkOrInterruptTransfer.TransferFlags = USBD_TRANSFER_DIRECTION_OUT ;
		pUrb->UrbBulkOrInterruptTransfer.PipeHandle = pThisDev->BulkOutPipeHandle;
	}
	else
	{
		pUrb->UrbBulkOrInterruptTransfer.TransferFlags = USBD_TRANSFER_DIRECTION_IN ;
 		pUrb->UrbBulkOrInterruptTransfer.PipeHandle = pThisDev->BulkInPipeHandle;
   }
	// short packet is not treated as an error.
    pUrb->UrbBulkOrInterruptTransfer.TransferFlags |= USBD_SHORT_TRANSFER_OK;
    pUrb->UrbBulkOrInterruptTransfer.UrbLink = NULL;
    pUrb->UrbBulkOrInterruptTransfer.TransferBufferMDL = NULL;
    pUrb->UrbBulkOrInterruptTransfer.TransferBuffer = pIOCTL->pData;
    pUrb->UrbBulkOrInterruptTransfer.TransferBufferLength = (int)pIOCTL->DataSize;

    //
    // Call the class driver to perform the operation.
	//
    pNextStack = IoGetNextIrpStackLocation( pIrp );

    IRUSB_ASSERT( pNextStack != NULL );

    //
    // pass the URB to the USB driver stack
    //
	pNextStack->MajorFunction = IRP_MJ_INTERNAL_DEVICE_CONTROL;
	pNextStack->Parameters.Others.Argument1 = pUrb;
	pNextStack->Parameters.DeviceIoControl.IoControlCode = IOCTL_INTERNAL_USB_SUBMIT_URB;
	
    IoSetCompletionRoutine(
			pIrp,							// irp to use
			Diags_CompleteIrp,				// routine to call when irp is done
			DEV_TO_CONTEXT(pThisContext),	// context to pass routine
			TRUE,							// call on success
			TRUE,							// call on error
			TRUE							// call on cancel
		);

#ifdef SERIALIZE
	KeClearEvent( &pThisDev->EventSyncUrb );
#endif
	
	//
    // Call IoCallDriver to send the irp to the usb port.
    //
	ExInterlockedInsertTailList(
			&pThisDev->SendPendingQueue,
			&pThisContext->ListEntry,
			&pThisDev->SendLock
		);
	InterlockedIncrement( &pThisDev->SendPendingCount );
	status = MyIoCallDriver( pThisDev, pUrbTargetDev, pIrp );

    //
    // The USB driver should always return STATUS_PENDING when
    // it receives a write irp
    //
    IRUSB_ASSERT( status == STATUS_PENDING );

	status = MyKeWaitForSingleObject( pThisDev, &pThisDev->EventSyncUrb, NULL, 0 );

	if( status == STATUS_TIMEOUT ) 
	{
		DEBUGMSG( DBG_ERR,(" Diags_Bulk() TIMED OUT! return from IoCallDriver USBD %x\n", status));
		IrUsb_CancelIo( pThisDev, pIrp, &pThisDev->EventSyncUrb );
	}


done:
	//
	// Return the context
	//
	KeAcquireSpinLock( &pThisDev->SendLock, &OldIrql );
	RemoveEntryList( &pThisContext->ListEntry );
	KeReleaseSpinLock( &pThisDev->SendLock, OldIrql );
	InterlockedDecrement( &pThisDev->SendPendingCount );
	ExInterlockedInsertTailList(
			&pThisDev->SendAvailableQueue,
			&pThisContext->ListEntry,
			&pThisDev->SendLock
		);
	InterlockedIncrement( &pThisDev->SendAvailableCount );

	//
	// Signal
	//
	KeSetEvent( &pThisDev->EventDiags, 0, FALSE );  //signal we're done
}


/*****************************************************************************
*
*  Function:	Diags_Send
*
*  Synopsis:	Sends a packet through the diagnostic path
*
*  Arguments:	pThisDev - pointer to IR device
*				pContext - pinter to the operation context
*	
*  Returns:		None
*
*  Notes:
*
*****************************************************************************/
VOID
Diags_Send(
		IN OUT PIR_DEVICE pThisDev,
		IN PVOID pContext
	)
{
	PDIAGS_SEND_IOCTL	pIOCTL = pThisDev->pIOCTL;
	PIRUSB_CONTEXT		pThisContext = pContext;
	NTSTATUS			status;
    PIRP                pIrp;
    PURB				pUrb = NULL;
    PDEVICE_OBJECT		pUrbTargetDev;
    PIO_STACK_LOCATION	pNextStack;
	BOOLEAN				fConvertedPacket;
	KIRQL				OldIrql;
	ULONG				BytesToWrite;

    IRUSB_ASSERT( KeGetCurrentIrql() == PASSIVE_LEVEL );

	IRUSB_ASSERT( NULL != pThisContext );

	//
	// Stop if a halt/reset is going on
	//
	if( pThisDev->fPendingWriteClearStall || pThisDev->fPendingHalt || 
		pThisDev->fPendingReset || pThisDev->fPendingClearTotalStall ) 
	{
        DEBUGMSG(DBG_ERR, (" Diags_Send abort due to pending reset or halt\n"));
		goto done;
	}
		
	pUrb = pThisDev->pUrb;

	NdisZeroMemory( pUrb, pThisDev->UrbLen );

	DEBUGMSG(DBG_ERR, (" Diags_Send() packet size: %d\n", pIOCTL->DataSize));

	//
	// Convert the packet to an ir frame and copy into our buffer
	// and send the irp.
	//
	if( pThisDev->currentSpeed<=MAX_SIR_SPEED )
	{
		fConvertedPacket = Diags_BufferToSirPacket(
				pThisDev,
				(PUCHAR)pThisDev->pBuffer,
				MAX_IRDA_DATA_SIZE,
				pIOCTL->pData,
				pIOCTL->DataSize,
				pIOCTL->ExtraBOFs,
				&BytesToWrite
			);
	}
	else if( pThisDev->currentSpeed<=MAX_MIR_SPEED )
	{
		fConvertedPacket = Diags_BufferToFirPacket(
				pThisDev,
				(PUCHAR)pThisDev->pBuffer,
				MAX_IRDA_DATA_SIZE,
				pIOCTL->pData,
				pIOCTL->DataSize,
				&BytesToWrite
			);
	}
	else
	{
		fConvertedPacket = Diags_BufferToFirPacket(
				pThisDev,
				(PUCHAR)pThisDev->pBuffer,
				MAX_IRDA_DATA_SIZE,
				pIOCTL->pData,
				pIOCTL->DataSize,
				&BytesToWrite
			);
	}
	
	if( fConvertedPacket == FALSE )
	{
		DEBUGMSG(DBG_ERR, (" Diags_Send() NdisToIrPacket failed. Couldn't convert packet!\n"));
		goto done;
	}

	//
	// Always force turnaround
	//
	NdisMSleep( pThisDev->dongleCaps.turnAroundTime_usec );
	
	//
    // Now that we have created the urb, we will send a
    // request to the USB device object.
    //
    pUrbTargetDev = pThisDev->pUsbDevObj;

	//
	// make an irp sending to usbhub
	//
	pIrp = IoAllocateIrp( (CCHAR)(pThisDev->pUsbDevObj->StackSize + 1), FALSE );

    if( NULL == pIrp )
    {
        DEBUGMSG(DBG_ERR, (" Diags_Send failed to alloc IRP\n"));
        goto done;
    }

    pIrp->IoStatus.Status = STATUS_PENDING;
    pIrp->IoStatus.Information = 0;

	pThisContext->pIrp = pIrp;

	//
	// Build our URB for USBD
	//
    pUrb->UrbBulkOrInterruptTransfer.Hdr.Length = (USHORT)sizeof( struct _URB_BULK_OR_INTERRUPT_TRANSFER );
    pUrb->UrbBulkOrInterruptTransfer.Hdr.Function = URB_FUNCTION_BULK_OR_INTERRUPT_TRANSFER;
    pUrb->UrbBulkOrInterruptTransfer.PipeHandle = pThisDev->BulkOutPipeHandle;
    pUrb->UrbBulkOrInterruptTransfer.TransferFlags = USBD_TRANSFER_DIRECTION_OUT ;
    // short packet is not treated as an error.
    pUrb->UrbBulkOrInterruptTransfer.TransferFlags |= USBD_SHORT_TRANSFER_OK;
    pUrb->UrbBulkOrInterruptTransfer.UrbLink = NULL;
    pUrb->UrbBulkOrInterruptTransfer.TransferBufferMDL = NULL;
    pUrb->UrbBulkOrInterruptTransfer.TransferBuffer = pThisDev->pBuffer;
    pUrb->UrbBulkOrInterruptTransfer.TransferBufferLength = (int)BytesToWrite;

    //
    // Call the class driver to perform the operation.
	//
    pNextStack = IoGetNextIrpStackLocation( pIrp );

    IRUSB_ASSERT( pNextStack != NULL );

    //
    // pass the URB to the USB driver stack
    //
	pNextStack->MajorFunction = IRP_MJ_INTERNAL_DEVICE_CONTROL;
	pNextStack->Parameters.Others.Argument1 = pUrb;
	pNextStack->Parameters.DeviceIoControl.IoControlCode = IOCTL_INTERNAL_USB_SUBMIT_URB;
	
    IoSetCompletionRoutine(
			pIrp,							// irp to use
			Diags_CompleteIrp,				// routine to call when irp is done
			DEV_TO_CONTEXT(pThisContext),	// context to pass routine
			TRUE,							// call on success
			TRUE,							// call on error
			TRUE							// call on cancel
		);

#ifdef SERIALIZE
	KeClearEvent( &pThisDev->EventSyncUrb );
#endif
	
	//
    // Call IoCallDriver to send the irp to the usb port.
    //
	ExInterlockedInsertTailList(
			&pThisDev->SendPendingQueue,
			&pThisContext->ListEntry,
			&pThisDev->SendLock
		);
	InterlockedIncrement( &pThisDev->SendPendingCount );
	status = MyIoCallDriver( pThisDev, pUrbTargetDev, pIrp );

    //
    // The USB driver should always return STATUS_PENDING when
    // it receives a write irp
    //
    IRUSB_ASSERT( status == STATUS_PENDING );

	status = MyKeWaitForSingleObject( pThisDev, &pThisDev->EventSyncUrb, NULL, 0 );

	if( status == STATUS_TIMEOUT ) 
	{
		DEBUGMSG( DBG_ERR,(" Diags_Send() TIMED OUT! return from IoCallDriver USBD %x\n", status));
		IrUsb_CancelIo( pThisDev, pIrp, &pThisDev->EventSyncUrb );
	}

done:
	KeAcquireSpinLock( &pThisDev->SendLock, &OldIrql );
	RemoveEntryList( &pThisContext->ListEntry );
	KeReleaseSpinLock( &pThisDev->SendLock, OldIrql );
	InterlockedDecrement( &pThisDev->SendPendingCount );
	ExInterlockedInsertTailList(
			&pThisDev->SendAvailableQueue,
			&pThisContext->ListEntry,
			&pThisDev->SendLock
		);
	InterlockedIncrement( &pThisDev->SendAvailableCount );

	//
	// Signal
	//
	KeSetEvent( &pThisDev->EventDiags, 0, FALSE );  //signal we're done
}

/*****************************************************************************
*
*  Function:   Diags_CompleteIrp
*
*  Synopsis:   Completes a USB operation
*
*  Arguments:  pUsbDevObj - pointer to the USB device object which
*                           completed the irp
*              pIrp       - the irp which was completed by the
*                           device object
*              Context    - the context given to IoSetCompletionRoutine
*                           before calling IoCallDriver on the irp
*                           The Context is a pointer to the ir device object.
*
*  Returns:    STATUS_MORE_PROCESSING_REQUIRED - allows the completion routine
*              (IofCompleteRequest) to stop working on the irp.
*
*****************************************************************************/
NTSTATUS
Diags_CompleteIrp(
		IN PDEVICE_OBJECT pUsbDevObj,
		IN PIRP           pIrp,
		IN PVOID          Context
	)
{
    PIR_DEVICE          pThisDev;
    NTSTATUS            status;
	PIRUSB_CONTEXT		pThisContext = (PIRUSB_CONTEXT)Context;
	PIRP				pContextIrp;
	PURB                pContextUrb;
	PDIAGS_BULK_IOCTL	pIOCTL;

    //
    // The context given to IoSetCompletionRoutine is an IRUSB_CONTEXT struct
    //
	IRUSB_ASSERT( NULL != pThisContext );				// we better have a non NULL buffer

    pThisDev = pThisContext->pThisDev;

	IRUSB_ASSERT( NULL != pThisDev );	

	pContextIrp = pThisContext->pIrp;
	pContextUrb = pThisDev->pUrb;
	pIOCTL = pThisDev->pIOCTL;

	//
	// Perform various IRP, URB, and buffer 'sanity checks'
	//
    IRUSB_ASSERT( pContextIrp == pIrp );				// check we're not a bogus IRP

    status = pIrp->IoStatus.Status;
	pThisDev->IOCTLStatus = status;

	//
	// we should have failed, succeeded, or cancelled, but NOT be pending
	//
	IRUSB_ASSERT( STATUS_PENDING != status );

    //
    // IoCallDriver has been called on this Irp;
    // Set the length based on the TransferBufferLength
    // value in the URB
    //
    pIrp->IoStatus.Information = pContextUrb->UrbBulkOrInterruptTransfer.TransferBufferLength;
	pIOCTL->DataSize = (USHORT)pIrp->IoStatus.Information;

    //
    // Free the IRP  because we alloced it ourselves,
    //
    IoFreeIrp( pIrp );
	InterlockedIncrement( (PLONG)&pThisDev->NumWrites );

	IrUsb_DecIoCount( pThisDev ); // we will track count of pending irps

#ifdef SERIALIZE
	KeSetEvent( &pThisDev->EventSyncUrb, 0, FALSE );  //signal we're done
#endif
    return STATUS_MORE_PROCESSING_REQUIRED;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\net\irda\sigmatel\sys\diags.h ===
/**************************************************************************************************************************
 *  DIAGS.H SigmaTel STIR4200 diagnostic definitions
 **************************************************************************************************************************
 *  (C) Unpublished Copyright of Sigmatel, Inc. All Rights Reserved.
 *
 *
 *		Created: 04/27/2000 
 *			Version 0.92
 *		Edited: 05/12/2000 
 *			Version 0.94
 *	
 *
 **************************************************************************************************************************/

#ifndef DIAGS_H
#define DIAGS_H

#include "diagsioctl.h"

//
// Prototypes
//
BOOLEAN         
Diags_BufferToFirPacket(
		IN PIR_DEVICE pIrDev,
		OUT PUCHAR pIrPacketBuf,
		ULONG IrPacketBufLen,
		IN PUCHAR pContigPacketBuf,
		ULONG ContigPacketLen,
		OUT PULONG pIrPacketLen
	);

BOOLEAN
Diags_BufferToSirPacket(
		IN PIR_DEVICE pIrDev,
		OUT PUCHAR pIrPacketBuf,
		ULONG IrPacketBufLen,
		IN PUCHAR pContigPacketBuf,
		ULONG ContigPacketLen,
		USHORT ExtraBOFs,
		OUT PULONG pIrPacketLen
	);

NTSTATUS
Diags_Enable(
		IN OUT PIR_DEVICE pThisDev
	);

NTSTATUS
Diags_Disable(
		IN OUT PIR_DEVICE pThisDev
	);

NTSTATUS
Diags_ReadRegisters(
		IN PIR_DEVICE pThisDev,
		OUT PDIAGS_READ_REGISTERS_IOCTL pIOCTL,
		ULONG IOCTLSize
	);

NTSTATUS
Diags_WriteRegister(
		IN OUT PIR_DEVICE pThisDev,
		OUT PDIAGS_READ_REGISTERS_IOCTL pIOCTL,
		ULONG IOCTLSize
	);

NTSTATUS
Diags_PrepareBulk(
		IN OUT PIR_DEVICE pThisDev,
		OUT PDIAGS_BULK_IOCTL pIOCTL,
		ULONG IOCTLSize,
		BOOLEAN DirectionOut
	);

NTSTATUS
Diags_PrepareSend(
		IN OUT PIR_DEVICE pThisDev,
		OUT PDIAGS_SEND_IOCTL pIOCTL,
		ULONG IOCTLSize
	);

NTSTATUS
Diags_Receive(
		IN OUT PIR_DEVICE pThisDev,
		OUT PDIAGS_RECEIVE_IOCTL pIOCTL,
		ULONG IOCTLSize
	);

NTSTATUS
Diags_GetSpeed(
		IN OUT PIR_DEVICE pThisDev,
		OUT PDIAGS_SPEED_IOCTL pIOCTL,
		ULONG IOCTLSize
	);

NTSTATUS
Diags_SetSpeed(
		IN OUT PIR_DEVICE pThisDev,
		OUT PDIAGS_SPEED_IOCTL pIOCTL,
		ULONG IOCTLSize
	);

VOID
Diags_CompleteEnable(
		IN OUT PIR_DEVICE pThisDev,
		IN PVOID pContext
	);

VOID
Diags_CompleteReadRegisters(
		IN OUT PIR_DEVICE pThisDev,
		IN PVOID pContext
	);

VOID
Diags_CompleteWriteRegister(
		IN OUT PIR_DEVICE pThisDev,
		IN PVOID pContext
	);

VOID
Diags_Bulk(
		IN OUT PIR_DEVICE pThisDev,
		IN PVOID pContext,
		BOOLEAN DirectionOut
	);

VOID
Diags_Send(
		IN OUT PIR_DEVICE pThisDev,
		IN PVOID pContext
	);

NTSTATUS
Diags_CompleteIrp(
		IN PDEVICE_OBJECT pUsbDevObj,
		IN PIRP           pIrp,
		IN PVOID          Context
	);

#endif DIAGS_H

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\net\irda\sigmatel\sys\debug.h ===
/**************************************************************************************************************************
 *  DEBUG.H SigmaTel STIR4200 debug header file
 **************************************************************************************************************************
 *  (C) Unpublished Copyright of Sigmatel, Inc. All Rights Reserved.
 *
 *
 *		Created: 04/06/2000 
 *			Version 0.9
 *		Edited: 04/27/2000 
 *			Version 0.92
 *	
 *
 **************************************************************************************************************************/

#ifndef _DEBUG_H_
#define _DEBUG_H_

#if DBG

#define DEBUG
#define DEBUG_IRUSB

//Begin, Debug code from BulkUsb

#ifndef DBGSTR_PREFIX
#define DBGSTR_PREFIX "StIrUsb: " 
#endif

#define DPRINT DbgPrint

#define TRAP() DbgBreakPoint();

#define IRUSB_DBGOUTSIZE 512

typedef struct _IRUSB_DBGDATA 
{
	// mirrors device extension pending io count
	ULONG PendingIoCount;

	// count of pipe errors detected during the life of this device instance
	ULONG PipeErrorCount;

	// count of pipe resets performed during the life of this device instance
	ULONG ResetPipeCount;

} IRUSB_DBGDATA, *PIRUSB_DBGDATA;

//these declared in debug 'c' file
extern PIRUSB_DBGDATA gpDbg; 

static const PCHAR szIrpMajFuncDesc[] =
{  // note this depends on corresponding values to the indexes in wdm.h
   "IRP_MJ_CREATE",
   "IRP_MJ_CREATE_NAMED_PIPE",
   "IRP_MJ_CLOSE",
   "IRP_MJ_READ",
   "IRP_MJ_WRITE",
   "IRP_MJ_QUERY_INFORMATION",
   "IRP_MJ_SET_INFORMATION",
   "IRP_MJ_QUERY_EA",
   "IRP_MJ_SET_EA",
   "IRP_MJ_FLUSH_BUFFERS",
   "IRP_MJ_QUERY_VOLUME_INFORMATION",
   "IRP_MJ_SET_VOLUME_INFORMATION",
   "IRP_MJ_DIRECTORY_CONTROL",
   "IRP_MJ_FILE_SYSTEM_CONTROL",
   "IRP_MJ_DEVICE_CONTROL",
   "IRP_MJ_INTERNAL_DEVICE_CONTROL",
   "IRP_MJ_SHUTDOWN",
   "IRP_MJ_LOCK_CONTROL",
   "IRP_MJ_CLEANUP",
   "IRP_MJ_CREATE_MAILSLOT",
   "IRP_MJ_QUERY_SECURITY",
   "IRP_MJ_SET_SECURITY",
   "IRP_MJ_POWER",          
   "IRP_MJ_SYSTEM_CONTROL", 
   "IRP_MJ_DEVICE_CHANGE",  
   "IRP_MJ_QUERY_QUOTA",    
   "IRP_MJ_SET_QUOTA",      
   "IRP_MJ_PNP"            
};
//IRP_MJ_MAXIMUM_FUNCTION defined in wdm.h

static const PCHAR szPnpMnFuncDesc[] =
{	// note this depends on corresponding values to the indexes in wdm.h 

    "IRP_MN_START_DEVICE",
    "IRP_MN_QUERY_REMOVE_DEVICE",
    "IRP_MN_REMOVE_DEVICE",
    "IRP_MN_CANCEL_REMOVE_DEVICE",
    "IRP_MN_STOP_DEVICE",
    "IRP_MN_QUERY_STOP_DEVICE",
    "IRP_MN_CANCEL_STOP_DEVICE",
    "IRP_MN_QUERY_DEVICE_RELATIONS",
    "IRP_MN_QUERY_INTERFACE",
    "IRP_MN_QUERY_CAPABILITIES",
    "IRP_MN_QUERY_RESOURCES",
    "IRP_MN_QUERY_RESOURCE_REQUIREMENTS",
    "IRP_MN_QUERY_DEVICE_TEXT",
    "IRP_MN_FILTER_RESOURCE_REQUIREMENTS",
    "IRP_MN_READ_CONFIG",
    "IRP_MN_WRITE_CONFIG",
    "IRP_MN_EJECT",
    "IRP_MN_SET_LOCK",
    "IRP_MN_QUERY_ID",
    "IRP_MN_QUERY_PNP_DEVICE_STATE",
    "IRP_MN_QUERY_BUS_INFORMATION",
    "IRP_MN_DEVICE_USAGE_NOTIFICATION",
	"IRP_MN_SURPRISE_REMOVAL"
};

#define IRP_PNP_MN_FUNCMAX	IRP_MN_SURPRISE_REMOVAL

static const PCHAR szSystemPowerState[] = 
{
    "PowerSystemUnspecified",
    "PowerSystemWorking",
    "PowerSystemSleeping1",
    "PowerSystemSleeping2",
    "PowerSystemSleeping3",
    "PowerSystemHibernate",
    "PowerSystemShutdown",
    "PowerSystemMaximum"
};

static const PCHAR szDevicePowerState[] = 
{
    "PowerDeviceUnspecified",
    "PowerDeviceD0",
    "PowerDeviceD1",
    "PowerDeviceD2",
    "PowerDeviceD3",
    "PowerDeviceMaximum"
};

VOID 
DBG_PrintBuf(
		IN PUCHAR bufptr, 
		int buflen
	);

#define IRUSB_ASSERT( cond ) ASSERT( cond )

#define IRUSB_StringForDevState( devState )	szDevicePowerState[ devState ] 

#define IRUSB_StringForSysState( sysState )	szSystemPowerState[ sysState ] 

#define IRUSB_StringForPnpMnFunc( mnfunc ) szPnpMnFuncDesc[ mnfunc ]

#define IRUSB_StringForIrpMjFunc( mjfunc ) szIrpMajFuncDesc[ mjfunc ]


#else // if not DBG

//
// dummy definitions that go away in the retail build
//
#define IRUSB_ASSERT( cond )
#define IRUSB_StringForDevState( devState )
#define IRUSB_StringForSysState( sysState ) 
#define IRUSB_StringForPnpMnFunc( mnfunc )
#define IRUSB_StringForIrpMjFunc( mjfunc ) 

#endif
// End, debug code from Bul kUsb

#ifdef DEBUG

#define DEBUGCOND( ilev, cond, _x_) \
	if( (ilev & DbgSettings) && ( cond )) { \
			DbgPrint( DBGSTR_PREFIX ); \
			DbgPrint _x_ ; \
	}

#define DEBUGONCE( ilev, _x_ ) \
{ \
	static BOOLEAN didOnce = FALSE; \
	if ( !didOnce ) { \
		didOnce = TRUE; \
	    DEBUGMSG( ilev, _x_ ); \
	} \
}

#define DEBUGONCECOND( ilev, cond, _x_ ) \
{ \
	static BOOLEAN didOnce = FALSE; \
	if (( !didOnce ) && (cond)) { \
		didOnce = TRUE; \
	    DEBUGMSG( ilev, _x_ ); \
	} \
}

extern int DbgSettings;

#define DEBUGMSG( dbgs, format )		( ((dbgs) & DbgSettings)? DbgPrint format:0 )

#define IRUSB_DUMP( flag, parms )		( (( flag) & DbgSettings )? DBG_PrintBuf parms: 0 )

    #define DBG_STAT     (1 << 23)
    #define DBG_PNP      (1 << 24)
    #define DBG_TIME     (1 << 25)
    #define DBG_DBG      (1 << 26)
    #define DBG_OUT      (1 << 27)
    #define DBG_BUF      (1 << 28)
    #define DBG_BUFS     (1 << 28)
    #define DBG_FUNCTION (1 << 29)
    #define DBG_FUNC     (1 << 29)
    #define DBG_WARN     (1 << 30)
    #define DBG_WARNING  (1 << 30)
    #define DBG_ERROR    (1 << 31)
    #define DBG_ERR      (1 << 31)
#if defined(ERROR_MESSAGES)
    #define DBG_INT_ERR  (1 << 31)
#else
    #define DBG_INT_ERR  (1 << 29)
#endif

    #define DBGDBG(_dbgPrint)                       \
            DbgPrint(_dbgPrint)

    #ifdef DEBUG_IRUSB

        #define DBG_D(dbgs, i) (((dbgs) & DbgSettings)? DbgPrint("irusb:"#i"==%d\n", (i)):0)
        #define DBG_X(dbgs, x) (((dbgs) & DbgSettings)? DbgPrint("irusb:"#x"==0x%0*X\n", sizeof(x)*2, ((ULONG_PTR)(x))&((1<<(sizeof(x)*8))-1) ):0)
        #define DBG_UNISTR(dbgs, s) (((dbgs) & DbgSettings)? DbgPrint("irusb:"#s"==%wZ\n", (s) ):0))

        #define DBGTIME(_str)                               \
            {                                               \
                LARGE_INTEGER Time;                         \
                                                            \
                KeQuerySystemTime(&Time);                   \
                DEBUGMSG(DBG_TIME, (_str " %d:%d\n",        \
                                    Time.HighPart,          \
                                    Time.LowPart/10000));   \
            }
    #else // DEBUG_IRUSB

        #define DBGTIME(_str)
        #define DBGFUNC(_dbgPrint)
        #define DBGOUT(_dbgPrint)
        #define DBGERR(_dbgPrint)
        #define DBGWARN(_dbgPrint)
        #define DBGSTAT(_dbgPrint)
        #define DBGTIME(_dbgPrint)
        #define DEBUGMSG(dbgs,format)
		#define DEBUGONCE( ilev, _x_ )
		#define DEBUGCOND( a, b, c )
		#define DEBUGONCECOND( a, b, c )
        #define IRUSB_DUMP(dbgs,format)

    #endif // DEBUG_IRUSB

#else // DEBUG

    #define DBGTIME(_str)
    #define DBGFUNC(_dbgPrint)
    #define DBGDBG(_dbgPrint)
    #define DBGOUT(_dbgPrint)
    #define DBGERR(_dbgPrint)
    #define DBGWARN(_dbgPrint)
    #define DBGSTAT(_dbgPrint)
    #define DEBUGMSG(dbgs,format)
    #define DBG_D(dbgs, ivar)
    #define DBG_X(dbgs, xvar)
    #define DBG_UNISTR(dbgs, svar)
	#define DEBUGONCE( ilev, _x_ )
	#define DEBUGONCECOND( a, b, c )
    #define DEBUGCOND( a, b, c )
    #define IRUSB_DUMP(dbgs,format)

#endif // DEBUG

#endif // _DEBUG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\net\irda\sigmatel\sys\ircommon.h ===
/**************************************************************************************************************************
 *  IRCOMMON.H SigmaTel STIR4200 common USB/IR definitions
 **************************************************************************************************************************
 *  (C) Unpublished Copyright of Sigmatel, Inc. All Rights Reserved.
 *
 *
 *		Created: 04/06/2000 
 *			Version 0.9
 *		Edited: 04/24/2000 
 *			Version 0.91
 *		Edited: 04/27/2000 
 *			Version 0.92
 *		Edited: 05/03/2000 
 *			Version 0.93
 *		Edited: 05/12/2000 
 *			Version 0.94
 *		Edited: 05/19/2000 
 *			Version 0.95
 *		Edited: 07/27/2000 
 *			Version 1.01
 *		Edited: 09/16/2000 
 *			Version 1.03
 *		Edited: 09/25/2000 
 *			Version 1.10
 *		Edited: 11/09/2000 
 *			Version 1.12
 *		Edited: 02/20/2001
 *			Version 1.15
 *
 **************************************************************************************************************************/

#ifndef _IRCOM_H
#define _IRCOM_H
 
#include "stir4200.h"

// 
// This is for use by check-for-hang handler and is just a reasonable guess;
// Total # of USBD control errors, read aerrors and write errors;
// Used by check-for-hang handler to decide if we need a reset
//
#define IRUSB_100ns_PER_ms                    10000
#define IRUSB_100ns_PER_us                    10
#define IRUSB_ms_PER_SEC                      1000
#define IRUSB_100ns_PER_SEC                   ( IRUSB_100ns_PER_ms * IRUSB_ms_PER_SEC )

#define MAX_QUERY_TIME_100ns             ( 8 * IRUSB_100ns_PER_SEC )        //8 sec
#define MAX_SET_TIME_100ns               MAX_QUERY_TIME_100ns
#define MAX_SEND_TIME_100ns             ( 20 * IRUSB_100ns_PER_SEC )        //20 sec

#define MAX_TURNAROUND_usec     10000

#define DEFAULT_TURNAROUND_usec 1000


#define MIN(a,b) (((a) <= (b)) ? (a) : (b))
#define MAX(a,b) (((a) >= (b)) ? (a) : (b))

//
//  A receive buffer is either FREE (not holding anything) FULL
// (holding undelivered data) or PENDING (holding data delivered
// asynchronously)
//
typedef enum  
{
    RCV_STATE_FREE,
    RCV_STATE_FULL,
    RCV_STATE_PENDING
} RCV_BUFFER_STATE, FIFO_BUFFER_STATE;

//
// Structure to keep track of receive packets and buffers to indicate
// receive data to the protocol.
//
typedef struct
{
    PVOID				pPacket;
    UINT				DataLen;
    PUCHAR				pDataBuf;
	PVOID    			pThisDev;
    ULONG				fInRcvDpc;
    RCV_BUFFER_STATE	BufferState;
#if defined(DIAGS)
	LIST_ENTRY			ListEntry;			// This will be used to do the diags queueing
#endif
#if defined(WORKAROUND_MISSING_C1)
	BOOLEAN				MissingC1Detected;
#endif
} RCV_BUFFER, *PRCV_BUFFER;

//
// Structure to read data from the FIFO
//
typedef struct
{
    UINT				DataLen;
    PUCHAR				pDataBuf;
	PVOID    			pThisDev;
	PVOID				pIrp;
    FIFO_BUFFER_STATE	BufferState;
} FIFO_BUFFER, *PFIFO_BUFFER;

//
// All different sizes for data
//
#define IRDA_ADDRESS_FIELD_SIZE				1
#define IRDA_CONTROL_FIELD_SIZE				1
#define IRDA_A_C_TOTAL_SIZE					( IRDA_ADDRESS_FIELD_SIZE + IRDA_CONTROL_FIELD_SIZE )

#define USB_IRDA_TOTAL_NON_DATA_SIZE		( IRDA_ADDRESS_FIELD_SIZE +  IRDA_CONTROL_FIELD_SIZE )
#define IRDA_MAX_DATAONLY_SIZE				2048
#define MAX_TOTAL_SIZE_WITH_ALL_HEADERS		( IRDA_MAX_DATAONLY_SIZE + USB_IRDA_TOTAL_NON_DATA_SIZE )

#define MAX_NUM_EXTRA_BOFS					48

#define MAX_POSSIBLE_IR_PACKET_SIZE_FOR_DATA(dataLen) (							\
        (dataLen) * 2 + (MAX_NUM_EXTRA_BOFS + 1) *								\
        SLOW_IR_BOF_SIZE + IRDA_ADDRESS_FIELD_SIZE + IRDA_CONTROL_FIELD_SIZE +	\
        SLOW_IR_FCS_SIZE + SLOW_IR_EOF_SIZE) + sizeof(STIR4200_FRAME_HEADER)

//
// Note that the receive size needs to be incremented to account for
// the way the decoding can use one more byte
//
#define MAX_RCV_DATA_SIZE					(MAX_TOTAL_SIZE_WITH_ALL_HEADERS + FAST_IR_FCS_SIZE + 1)

#define MAX_IRDA_DATA_SIZE					MAX_POSSIBLE_IR_PACKET_SIZE_FOR_DATA(IRDA_MAX_DATAONLY_SIZE)

//
// Possible speeds
//
typedef enum _BAUD_RATE 
{
        //
        // Slow IR
        //
        BAUDRATE_2400 = 0,
        BAUDRATE_9600,
        BAUDRATE_19200,
        BAUDRATE_38400,
        BAUDRATE_57600,
        BAUDRATE_115200,

        //
        // Medium IR
        //
#if !defined(DWORKAROUND_BROKEN_MIR)
        BAUDRATE_576000,
        BAUDRATE_1152000,
#endif
        //
        // Fast IR
        //
        BAUDRATE_4000000,

        //
        // must be last
        //
        NUM_BAUDRATES

} BAUD_RATE;

typedef enum _IR_MODE 
{
	IR_MODE_SIR = 0,
	IR_MODE_MIR,
	IR_MODE_FIR,
	NUM_IR_MODES
} IR_MODE;

//
// Speeds
//
#define SPEED_2400				2400
#define SPEED_9600				9600
#define SPEED_19200				19200
#define SPEED_38400				38400
#define SPEED_57600				57600
#define SPEED_115200			115200
#define SPEED_576000			576000
#define SPEED_1152000			1152000
#define SPEED_4000000			4000000

#define DEFAULT_BAUD_RATE		SPEED_9600

#define MAX_SIR_SPEED           SPEED_115200
#define MAX_MIR_SPEED           SPEED_1152000


//
// Sizes of IrLAP frame fields:
//       Beginning Of Frame (BOF)
//       End Of Frame (EOF)
//       Address
//       Control
//
#define SLOW_IR_BOF_TYPE			UCHAR
#define SLOW_IR_BOF_SIZE			sizeof(SLOW_IR_BOF_TYPE)
#define SLOW_IR_EOF_TYPE			UCHAR
#define SLOW_IR_EOF_SIZE			sizeof(SLOW_IR_EOF_TYPE)
#define SLOW_IR_FCS_TYPE			USHORT
#define SLOW_IR_FCS_SIZE			sizeof(SLOW_IR_FCS_TYPE)
#define SLOW_IR_BOF					0xC0
#define SLOW_IR_EOF					0xC1
#define SLOW_IR_ESC					0x7D
#define SLOW_IR_ESC_COMP			0x20
#define SLOW_IR_EXTRA_BOF_TYPE      UCHAR
#define SLOW_IR_EXTRA_BOF_SIZE      sizeof(SLOW_IR_EXTRA_BOF_TYPE)
#define SLOW_IR_EXTRA_BOF           0xC0

#define MEDIUM_IR_BOF				0x7E
#define MEDIUM_IR_EOF				0x7E
#define MEDIUM_IR_FCS_TYPE			USHORT
#define MEDIUM_IR_FCS_SIZE			sizeof(MEDIUM_IR_FCS_TYPE)

#define FAST_IR_FCS_TYPE            ULONG
#define FAST_IR_FCS_SIZE            sizeof(FAST_IR_FCS_TYPE)
#define FAST_IR_EOF_TYPE			ULONG
#define FAST_IR_EOF_SIZE			sizeof(FAST_IR_EOF_TYPE)

//
// Definition for speed masks
//
#define NDIS_IRDA_SPEED_MASK_2400		0x001    // SLOW IR ...
#define NDIS_IRDA_SPEED_MASK_9600		0x003
#define NDIS_IRDA_SPEED_MASK_19200		0x007
#define NDIS_IRDA_SPEED_MASK_38400		0x00f
#define NDIS_IRDA_SPEED_MASK_57600		0x01f
#define NDIS_IRDA_SPEED_MASK_115200		0x03f
#define NDIS_IRDA_SPEED_MASK_576K		0x07f   // MEDIUM IR ...
#define NDIS_IRDA_SPEED_MASK_1152K		0x0ff
#define NDIS_IRDA_SPEED_MASK_4M			0x1ff   // FAST IR

#define GOOD_FCS                        ((USHORT) ~0xf0b8)
#define FIR_GOOD_FCS                    ((ULONG) ~0xdebb20e3)

typedef struct
{
    BAUD_RATE	TableIndex;
    UINT		BitsPerSec;
	IR_MODE		IrMode;
    UINT		NdisCode;			// bitmask element as used by ndis and in class-specific descriptor
	UCHAR		Stir4200Divisor;
} BAUDRATE_INFO;


//
// Struct to hold the IR USB dongle's USB Class-Specific Descriptor as per
// "Universal Serial Bus IrDA Bridge Device Definition" doc, section 7.2
// This is the struct returned by USBD as the result of a request with an urb 
// of type _URB_CONTROL_VENDOR_OR_CLASS_REQUEST, function URB_FUNCTION_CLASS_DEVICE
// 

// Enable 1-byte alignment in the below struct
#pragma pack (push,1)

typedef struct _IRUSB_CLASS_SPECIFIC_DESCRIPTOR
{
    BOOLEAN  ClassConfigured;            

    UCHAR  bmDataSize;         // max bytes allowed in any frame as per IrLAP spec, where:
                            
#define BM_DATA_SIZE_2048   (1 << 5)
#define BM_DATA_SIZE_1024   (1 << 4)
#define BM_DATA_SIZE_512    (1 << 3)
#define BM_DATA_SIZE_256    (1 << 2)
#define BM_DATA_SIZE_128    (1 << 1)
#define BM_DATA_SIZE_64     (1 << 0)

    UCHAR bmWindowSize;         // max un-acked frames that can be received
                                // before an ack is sent, where:
#define BM_WINDOW_SIZE_7     (1 << 6)
#define BM_WINDOW_SIZE_6     (1 << 5)
#define BM_WINDOW_SIZE_5     (1 << 4)
#define BM_WINDOW_SIZE_4     (1 << 3)
#define BM_WINDOW_SIZE_3     (1 << 2)
#define BM_WINDOW_SIZE_2     (1 << 1)
#define BM_WINDOW_SIZE_1     (1 << 0)

    UCHAR bmMinTurnaroundTime;         // min millisecs required for recovery between
                                       // end of last xmission and can receive again, where:
#define BM_TURNAROUND_TIME_0ms      (1 << 7)  // 0 ms
#define BM_TURNAROUND_TIME_0p01ms   (1 << 6)  // 0.01 ms
#define BM_TURNAROUND_TIME_0p05ms   (1 << 5)  // 0.05 ms
#define BM_TURNAROUND_TIME_0p1ms    (1 << 4)  // 0.1 ms
#define BM_TURNAROUND_TIME_0p5ms    (1 << 3)  // 0.5 ms
#define BM_TURNAROUND_TIME_1ms      (1 << 2)  // 1 ms
#define BM_TURNAROUND_TIME_5ms      (1 << 1)  // 5 ms
#define BM_TURNAROUND_TIME_10ms     (1 << 0)  // 10 ms

    USHORT wBaudRate;

//
// ir speed masks as used both by NDIS and as formatted in USB class-specfic descriptor
//
#define NDIS_IRDA_SPEED_2400		(1 << 0)    // SLOW IR ...
#define NDIS_IRDA_SPEED_9600		(1 << 1)
#define NDIS_IRDA_SPEED_19200		(1 << 2)
#define NDIS_IRDA_SPEED_38400		(1 << 3)
#define NDIS_IRDA_SPEED_57600		(1 << 4)
#define NDIS_IRDA_SPEED_115200		(1 << 5)
#define NDIS_IRDA_SPEED_576K		(1 << 6)   // MEDIUM IR ...
#define NDIS_IRDA_SPEED_1152K		(1 << 7)
#define NDIS_IRDA_SPEED_4M			(1 << 8)   // FAST IR

    
    UCHAR  bmExtraBofs; // #BOFS required at 115200; 0 if slow speeds <=115200 not supported

#define BM_EXTRA_BOFS_0        (1 << 7)  
#define BM_EXTRA_BOFS_1        (1 << 6)  
#define BM_EXTRA_BOFS_2        (1 << 5)  
#define BM_EXTRA_BOFS_3        (1 << 4)  
#define BM_EXTRA_BOFS_6        (1 << 3)  
#define BM_EXTRA_BOFS_12       (1 << 2)  
#define BM_EXTRA_BOFS_24       (1 << 1)  
#define BM_EXTRA_BOFS_48       (1 << 0)  
    
} IRUSB_CLASS_SPECIFIC_DESCRIPTOR, *PIRUSB_CLASS_SPECIFIC_DESCRIPTOR;

#pragma pack (pop) //disable 1-byte alignment


typedef struct _DONGLE_CAPABILITIES
{
    //
    // Time (in microseconds) that must transpire between
    // a transmit and the next receive.
    //
    LONG turnAroundTime_usec;   // gotten from class-specific descriptor

    //
    // Max un-acked frames that can be received
    // before an ack is sent
    //
    UINT windowSize;            // gotten from class-specific descriptor

    //
    // #BOFS required at 115200; 0 if slow speeds <=115200 are not supported
    //
    UINT extraBOFS;             // gotten from class-specific descriptor

    //
    // max bytes allowed in any frame as per IrLAP spec
    //
    UINT dataSize;              // gotten from class-specific descriptor

} DONGLE_CAPABILITIES, *PDONGLE_CAPABILITIES;


//
// Enum of context types for SendPacket
//
typedef enum _CONTEXT_TYPE 
{
    CONTEXT_NDIS_PACKET,
    CONTEXT_SET_SPEED,
	CONTEXT_READ_WRITE_REGISTER,
	CONTEXT_DIAGS_ENABLE,
	CONTEXT_DIAGS_DISABLE,
	CONTEXT_DIAGS_READ_REGISTERS,
	CONTEXT_DIAGS_WRITE_REGISTER,
	CONTEXT_DIAGS_BULK_OUT,
	CONTEXT_DIAGS_BULK_IN,
	CONTEXT_DIAGS_SEND
} CONTEXT_TYPE;

typedef	VOID (*WORK_PROC)(struct _IR_WORK_ITEM *);

typedef struct _IR_WORK_ITEM
{
    PVOID               pIrDevice;
    WORK_PROC           Callback;
    PUCHAR              pInfoBuf;
    ULONG               InfoBufLen;
	ULONG				fInUse;  // declared as ulong for use with interlockedexchange
} IR_WORK_ITEM, *PIR_WORK_ITEM;

//
// Transceiver type definition
//
typedef enum _TRANSCEIVER_TYPE 
{
	TRANSCEIVER_4012 = 0,
	TRANSCEIVER_4000,
	TRANSCEIVER_VISHAY,
	TRANSCEIVER_INFINEON
} TRANSCEIVER_TYPE;

//
// Chip revision definition
//
typedef enum _CHIP_REVISION 
{
	CHIP_REVISION_6 = 5,
	CHIP_REVISION_7,
	CHIP_REVISION_8
} CHIP_REVISION;

typedef struct _IR_DEVICE
{
    //
    // Keep track of various device objects.
    //
    PDEVICE_OBJECT  pUsbDevObj;     //'Next Device Object'
    PDEVICE_OBJECT  pPhysDevObj;    // Physical Device Object 

    //
    // This is the handle that the NDIS wrapper associates with a connection.
    // (The handle that the miniport driver associates with the connection
    // is just an index into the devStates array).
    //
    HANDLE hNdisAdapter;

    //
    // The dongle interface allows us to check the tranceiver type once
    // and then set up the interface to allow us to init, set speed,
    // and deinit the dongle.
    //
    // We also want the dongle capabilities.
    //
    DONGLE_CAPABILITIES dongleCaps;

	//
	// Type of transceiver installed
	//
	TRANSCEIVER_TYPE TransceiverType;

	//
	// Revision of the installed 4200
	//
	CHIP_REVISION ChipRevision;

    //
    // Current speed setting, in bits/sec.
    // Note: This is updated when we ACTUALLY change the speed,
    //       not when we get the request to change speed via
    //       irusbSetInformation.
    //
    //
    //  When speed is changed, we have to clear the send queue before
    //  setting the new speed on the hardware.
    //  These vars let us remember to do it.
    //
    UINT			currentSpeed;

    //
    // Current link speed information. This also will maintain the
    // chosen speed if the protocol requests a speed change.
    //
    BAUDRATE_INFO	*linkSpeedInfo;

    //
    // Maintain statistical debug info.
    //
    ULONG packetsReceived;
    ULONG packetsReceivedDropped;
    ULONG packetsReceivedOverflow;
    ULONG packetsReceivedChecksum;
    ULONG packetsReceivedRunt;
	ULONG packetsReceivedNoBuffer;
    ULONG packetsSent;
	ULONG packetsSentDropped;
 	ULONG packetsSentRejected;
 	ULONG packetsSentInvalid;

#if DBG
    ULONG packetsHeldByProtocol;
    ULONG MaxPacketsHeldByProtocol;
	ULONG TotalBytesReceived;
	ULONG TotalBytesSent;
	ULONG NumYesQueryMediaBusyOids;
	ULONG NumNoQueryMediaBusyOids;
	ULONG NumSetMediaBusyOids;
	ULONG NumMediaBusyIndications;
	ULONG NumPacketsSentRequiringTurnaroundTime;
	ULONG NumPacketsSentNotRequiringTurnaroundTime;
#endif

	//
    // used by check hang handler to track Query, Set, and Send times
    //
	LARGE_INTEGER	LastQueryTime;
    LARGE_INTEGER	LastSetTime;
	BOOLEAN			fSetpending;
	BOOLEAN			fQuerypending;

    //
    // Set when device has been started; use for safe cleanup after failed initialization
    //
    BOOLEAN			fDeviceStarted;

    //
    // Indicates that we have received an OID_GEN_CURRENT_PACKET_FILTER
    // indication from the protocol. We can deliver received packets to the
    // protocol.
    //
    BOOLEAN			fGotFilterIndication;

    //
    // NDIS calls most of the MiniportXxx function with IRQL DISPATCH_LEVEL.
    // There are a number of instances where the ir device must send
    // requests to the device which may be synchronous and
    // we can't block in DISPATCH_LEVEL. Therefore, we set up a thread to deal
    // with request which require PASSIVE_LEVEL. An event is used to signal
    // the thread that work is required.
    //
    HANDLE          hPassiveThread;
    BOOLEAN         fKillPassiveLevelThread;

    KEVENT			EventPassiveThread;

/*  
    According to  W2000 ddk doc:
    The IrDA protocol driver sets this OID to zero to request the miniport to
    start monitoring for a media busy condition. The IrDA protocol 
    can then query this OID to determine whether the media is busy.
    If the media is not busy, the miniport returns a zero for this
    OID when queried. If the media is busy,that is, if the miniport
    has detected some traffic since the IrDA protocol driver last
    set OID_IRDA_MEDIA_BUSY to zero the miniport returns a non-zero
    value for this OID when queried. On detecting the media busy
    condition. the miniport must also call NdisMIndicateStatus to
    indicate NDIS_STATUS_MEDIA_BUSY. When the media is busy, 
    the IrDA protocol driver will not send packets to the miniport
    for transmission. After the miniport has detected a busy state, 
    it does not have to monitor for a media busy condition until
    the IrDA protocol driver again sets OID_IRDA_MEDIA_BUSY to zero.

    According to USB IrDA Bridge Device Definition Doc sec 5.4.1.2:

    The bmStatus field indicators shall be set by the Device as follows:
    Media_Busy
     Media_Busy shall indicate zero (0) if the Device:
    . has not received a Check Media Busy class-specific request
    . has detected no traffic on the infrared media since receiving a Check Media Busy
    . class-specific request
   . Has returned a header with Media_Busy set to one (1) since receiving a Check
      Media Busy class-specific request.
     
    Media_Busy shall indicate one (1) if the Device has detected traffic on the infrared
     media since receiving a Check Media Busy class-specific request. Note that
     Media_Busy shall indicate one (1) in exactly one header following receipt of each
     Check Media Busy class-specific request.

    According to USB IrDA Bridge Device Definition Doc sec 6.2.2:

      Check Media Busy
    This class-specific request instructs the Device to look for a media busy condition. If infrared
    traffic of any kind is detected by this Device, the Device shall set the Media_Busy field in the
    bmStatus field in the next Data-In packet header sent to the host. In the case where a Check
    Media Busy command has been received, a media busy condition detected, and no IrLAP frame
    traffic is ready to transmit to the host, the Device shall set the Media_Busy field and send it in a
    Data-In packet with no IrLAP frame following the header.

    bmRequestType   bRequest   wValue   wIndex   wLength   Data
    00100001B          3        Zero   Interface   Zero   [None]
     
*/
    ULONG         fMediaBusy;  // declare as ULONGS for use with InterlockedExchange
    ULONG         fIndicatedMediaBusy;

    //
    // The variable fProcessing is used to indicate that the ir device
    // object has an active polling thread,
    //
    // Under normal circumstances fReceiving should always be TRUE.
    // However sometimes the processing has to be stopped
    // and this variable is used to synchronize
    //
    ULONG fProcessing;

	//
	// To be set to true when really receiving packets
	//
    ULONG fCurrentlyReceiving;

    //
    // The variables fPendingHalt and fPendingReset allow the send and receive
    // completion routines to complete the current pending irp and
    // then cleanup and stop sending irps to the USB driver.
    //
    BOOLEAN fPendingHalt;
    BOOLEAN fPendingReset;


    ULONG fPendingReadClearStall;
    ULONG fPendingWriteClearStall;

	// 
	// This is required when the part gets into a complete USB hang and a reset is required
	//
    ULONG fPendingClearTotalStall;

    //
    // We keep an array of receive buffers so that we don't continually
    // need to allocate buffers to indicate packets to the protocol.
    // Since the protocol can retain ownership of up to eight packets
    // and we can be receiving up to WindowSize  ( 7 ) packets while the protocol has
    // ownership of eight packets, we will allocate 16 packets for
    // receiving.
    //
    #define NUM_RCV_BUFS 16

    RCV_BUFFER		rcvBufs[NUM_RCV_BUFS];
	PRCV_BUFFER		pCurrentRecBuf;

	FIFO_BUFFER		PreReadBuffer;

	//
	// Can have max of NUM_RCV_BUFS packets pending + one set and one query
	//
	#define  NUM_WORK_ITEMS	 (NUM_RCV_BUFS+3)

	IR_WORK_ITEM	WorkItems[NUM_WORK_ITEMS];

	//
    // Since we can have multiple write irps pending with the USB driver,
    // we track the irp contexts for each one so we have all the info we need at each
	// invokation of the USB write completion routine. See the IRUSB_CONTEXT definition below
    // There are 128 contexts for sending, one for read/write operations, one for setting the speed
	// and one for diagnostic operations
	//
	#define	NUM_SEND_CONTEXTS 131

	PVOID			pSendContexts;

    //
    // Handles to the NDIS packet pool and NDIS buffer pool
    // for allocating the receive buffers.
    //
    HANDLE			hPacketPool;
    HANDLE			hBufferPool;
	BOOLEAN			BufferPoolAllocated;

	KEVENT			EventSyncUrb;
	KEVENT			EventAsyncUrb;

	NTSTATUS        StatusControl;  
	NTSTATUS        StatusReadWrite;  
	NTSTATUS        StatusSendReceive;  
	
	//
	// track pending IRPS; this should be zero at halt time
	//
	UINT			PendingIrpCount;
    ULONG			NumReads;
    ULONG			NumWrites;
    ULONG			NumReadWrites;

	//
    // various USB errors
    //
    ULONG			NumDataErrors;
    ULONG			NumReadWriteErrors;

    HANDLE			BulkInPipeHandle;
    HANDLE			BulkOutPipeHandle;

    HANDLE          hPollingThread;
    BOOLEAN         fKillPollingThread;

//
// The IR USB dongle's USB Class-Specific Descriptor as per
// "Universal Serial Bus IrDA Bridge Device Definition" doc, section 7.2
// This is the struct returned by USBD as the result of a request with an urb 
// of type _URB_CONTROL_VENDOR_OR_CLASS_REQUEST, function URB_FUNCTION_CLASS_DEVICE.
// Note this  struct is  in-line, not a pointer
// 
    IRUSB_CLASS_SPECIFIC_DESCRIPTOR  ClassDesc;

	UINT			IdVendor;			// USB vendor Id read from dongle
	
	//
	// We don't define it here because we need to isolate USB stuff so we
	// can build  things referencing NDIS with the BINARY_COMPATIBLE flag for win9x
	//
	PUCHAR			pUsbInfo;

	//
	// Optional registry entry for debugging; limit baud rate. 
	// The mask is set up as per the USB Class-Specific descriptor 'wBaudRate'
	// This is 'and'ed with value from Class descriptor to possibly limit baud rate;
	// It defaults to 0xffff
	//
	UINT			BaudRateMask;

	//
	// Necessary to read the registry fields
	//
	NDIS_HANDLE		WrapperConfigurationContext;

	//
	// IR Tranceiver Model
	//
	STIR4200_TRANCEIVER StIrTranceiver;

	//
	// Send buffers (works only if sending is serialied)
	//
	PUCHAR			pBuffer;
	UINT			BufLen;
	PUCHAR			pStagingBuffer;
    
	//
	// Send FIFO count
	//
	ULONG			SendFifoCount;

	//
	// Receive adaptive delay
	//
	ULONG			ReceiveAdaptiveDelay;
	ULONG			ReceiveAdaptiveDelayBoost;

	//
	// Send URB (works only if sending is serialied)
	//
	PURB			pUrb;
	UINT			UrbLen;

	//
	// Receive buffer and positions
	//
	UCHAR			pRawBuf[STIR4200_FIFO_SIZE];
	ULONG			rawCleanupBytesRead;
	PORT_RCV_STATE  rcvState;
    ULONG           readBufPos;
	BOOLEAN			fReadHoldingReg;
	ULONG			PreFifoCount;

	//
	// Send lists and lock
    //
	LIST_ENTRY		SendAvailableQueue;
    LIST_ENTRY		SendBuiltQueue;
	LIST_ENTRY		SendPendingQueue;
	ULONG			SendAvailableCount;
	ULONG			SendBuiltCount;
	ULONG			SendPendingCount;
	KSPIN_LOCK		SendLock;

	//
	// Read and write register list, shares the other send queues
    //
	LIST_ENTRY		ReadWritePendingQueue;
	ULONG			ReadWritePendingCount;

	//
	// Diagnostics
	//
#if defined(DIAGS)
	ULONG			DiagsActive;
	ULONG			DiagsPendingActivation;
	PVOID			pIOCTL;
	NTSTATUS		IOCTLStatus;
	NDIS_HANDLE		NdisDeviceHandle;
	KEVENT			EventDiags;
	LIST_ENTRY		DiagsReceiveQueue;
	KSPIN_LOCK		DiagsReceiveLock;
#endif

	//
	// Logging
	//
#if defined(RECEIVE_LOGGING)
	HANDLE ReceiveFileHandle;
	__int64 ReceiveFilePosition;
#endif

#if defined(RECEIVE_ERROR_LOGGING)
	HANDLE ReceiveErrorFileHandle;
	__int64 ReceiveErrorFilePosition;
#endif

#if defined(SEND_LOGGING)
	HANDLE SendFileHandle;
	__int64 SendFilePosition;
#endif
	
#if !defined(WORKAROUND_BROKEN_MIR)
	//
	// Mir in software
	//
	UCHAR pRawUnstuffedBuf[STIR4200_FIFO_SIZE];
	UCHAR MirIncompleteByte;
	ULONG MirIncompleteBitCount;
	ULONG MirOneBitCount;
	ULONG MirFlagCount;
#endif

	//
	// Dummy send fix
	//
	BOOLEAN GearedDown;

	//
	// temporary Fix!
	//
	//ULONG SirDpll;
	//ULONG FirDpll;
	//ULONG SirSensitivity;
	//ULONG FirSensitivity;
} IR_DEVICE, *PIR_DEVICE;


//
// We use a pointer to the IR_DEVICE structure as the miniport's device context.
//

#define CONTEXT_TO_DEV(__deviceContext) ((PIR_DEVICE)(__deviceContext))
#define DEV_TO_CONTEXT(__irdev) ((HANDLE)(__irdev))

#define IRUSB_TAG 'RITS'


VOID   
MyNdisMSetInformationComplete( 
        IN PIR_DEVICE pThisDev,
        IN NDIS_STATUS Status
	);

VOID  
MyNdisMQueryInformationComplete( 
        IN PIR_DEVICE pThisDev,
        IN NDIS_STATUS Status
	);

USHORT
ComputeFCS16(
		IN PUCHAR pData, 
		UINT DataLen
	);

ULONG 
ComputeFCS32(
		IN PUCHAR pData, 
		ULONG DataLen
	);

BOOLEAN         
NdisToFirPacket(
		IN PIR_DEVICE pIrDev,
		IN PNDIS_PACKET pPacket,
		OUT PUCHAR pIrPacketBuf,
		ULONG IrPacketBufLen,
		IN PUCHAR pContigPacketBuf,
		OUT PULONG pIrPacketLen
	);

BOOLEAN
NdisToMirPacket( 
		IN PIR_DEVICE pIrDev,
		IN PNDIS_PACKET pPacket,
		OUT PUCHAR pIrPacketBuf,
		ULONG IrPacketBufLen,
		IN PUCHAR pContigPacketBuf,
		OUT PULONG pIrPacketLen
	);

BOOLEAN
NdisToSirPacket( 
		IN PIR_DEVICE pIrDev,
		IN PNDIS_PACKET pPacket,
		OUT PUCHAR pIrPacketBuf,
		ULONG IrPacketBufLen,
		IN PUCHAR pContigPacketBuf,
		OUT PULONG pIrPacketLen
	);

BOOLEAN     
ReceiveFirStepFSM(
		IN OUT PIR_DEVICE pIrDev, 
		OUT PULONG pBytesProcessed
	);

BOOLEAN     
ReceiveMirStepFSM(
		IN OUT PIR_DEVICE pIrDev, 
		OUT PULONG pBytesProcessed
	);

#if !defined(WORKAROUND_BROKEN_MIR)
BOOLEAN
ReceiveMirUnstuff(
		IN OUT PIR_DEVICE pIrDev,
		IN PUCHAR pInputBuffer,
		ULONG InputBufferSize,
		OUT PUCHAR pOutputBuffer,
		OUT PULONG pOutputBufferSize
	);
#endif

BOOLEAN     
ReceiveSirStepFSM(
		IN OUT PIR_DEVICE pIrDev, 
		OUT PULONG pBytesProcessed
	);

VOID
ReceiveProcessFifoData(
		IN OUT PIR_DEVICE pThisDev
	);

VOID
ReceiveResetPointers(
		IN OUT PIR_DEVICE pThisDev
	);

NTSTATUS
ReceivePreprocessFifo(
		IN OUT PIR_DEVICE pThisDev,
		OUT PULONG pFifoCount
	);

NTSTATUS
ReceiveGetFifoData(
		IN OUT PIR_DEVICE pThisDev,
		OUT PUCHAR pData,
		OUT PULONG pBytesRead,
		ULONG BytesToRead
	);

VOID 
ReceiveProcessReturnPacket(
		OUT PIR_DEVICE pThisDev,
		OUT PRCV_BUFFER pReceiveBuffer
	);

NTSTATUS 
ReceivePacketRead( 
		IN PIR_DEVICE pThisDev,
		OUT PFIFO_BUFFER pRecBuf
	);

NTSTATUS
ReceiveCompletePacketRead(
		IN PDEVICE_OBJECT pUsbDevObj,
		IN PIRP           pIrp,
		IN PVOID          Context
	);

VOID  
IndicateMediaBusy(
       IN PIR_DEVICE pThisDev
   );

VOID  
IrUsb_IncIoCount( 
		IN OUT PIR_DEVICE pThisDev 
	); 

VOID  
IrUsb_DecIoCount( 
		IN OUT PIR_DEVICE pThisDev 
	);

NTSTATUS
IrUsb_GetDongleCaps( 
		IN OUT PIR_DEVICE pThisDev 
	);

VOID 
IrUsb_SetDongleCaps( 
        IN OUT PIR_DEVICE pThisDev 
	);

VOID 
MyMemFree(
		IN PVOID pMem,
		IN UINT size
	);

PVOID 
MyMemAlloc(
		UINT size
	);

BOOLEAN 
AllocUsbInfo(
		IN OUT PIR_DEVICE pThisDev 
	);

VOID 
FreeUsbInfo(
		IN OUT PIR_DEVICE pThisDev 
	);

VOID 
PollingThread(
		IN OUT PVOID Context
	);

extern BAUDRATE_INFO supportedBaudRateTable[NUM_BAUDRATES];

VOID 
ReceiveDeliverBuffer(
		IN OUT PIR_DEVICE pThisDev,
		IN PRCV_BUFFER pRecBuf
	);

NTSTATUS 
InitializeProcessing(
        IN OUT PIR_DEVICE pThisDev,
		IN BOOLEAN InitPassiveThread
    );

NTSTATUS
IrUsb_ResetPipe (
		IN PIR_DEVICE pThisDev,
		IN HANDLE Pipe
    );

BOOLEAN
IrUsb_InitSendStructures( 
        IN OUT PIR_DEVICE pThisDev
	);

VOID
IrUsb_FreeSendStructures( 
        IN OUT PIR_DEVICE pThisDev
	);

NDIS_STATUS
SendPacketPreprocess(
		IN OUT PIR_DEVICE pThisDev,
		IN PVOID pPacketToSend
	);

NDIS_STATUS
SendPreprocessedPacketSend(
		IN OUT PIR_DEVICE pThisDev,
		IN PVOID pContext
	);

NTSTATUS
SendWaitCompletion(
		IN OUT PIR_DEVICE pThisDev
	);

NTSTATUS
SendCheckForOverflow(
		IN OUT PIR_DEVICE pThisDev
	);

NTSTATUS 
SendCompletePacketSend(
		IN PDEVICE_OBJECT pUsbDevObj,
		IN PIRP           pIrp,
		IN PVOID          Context
	);

PRCV_BUFFER
ReceiveGetBuf( 
		PIR_DEVICE pThisDev,
		OUT PUINT pIndex,
		IN RCV_BUFFER_STATE BufferState
	);

VOID 
PassiveLevelThread(
        IN PVOID Context
    );

BOOLEAN
ScheduleWorkItem(
		IN OUT PIR_DEVICE pThisDev,
		WORK_PROC Callback,
		IN PVOID pInfoBuf,
		ULONG InfoBufLen
	);

VOID 
FreeWorkItem(
		IN OUT PIR_WORK_ITEM pItem
	);

VOID 
IrUsb_PrepareSetSpeed(
		IN OUT PIR_DEVICE pThisDev
	);

VOID
ResetPipeCallback (
		IN PIR_WORK_ITEM pWorkItem
    );

PVOID 
AllocXferUrb ( 
		VOID 
	);

VOID
FreeXferUrb( 
		IN OUT PVOID pUrb 
	);

BOOLEAN
IrUsb_CancelPendingReadIo(
		IN OUT PIR_DEVICE pThisDev,
		BOOLEAN fWaitCancelComplete
    );

BOOLEAN
IrUsb_CancelPendingWriteIo(
		IN OUT PIR_DEVICE pThisDev
    );

BOOLEAN
IrUsb_CancelPendingReadWriteIo(
		IN OUT PIR_DEVICE pThisDev
    );

#endif // _IRCOM_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\net\irda\sigmatel\sys\hwio.c ===
/**************************************************************************************************************************
 *  HWIO.C SigmaTel STIR4200 hardware specific module (to access the registers)
 **************************************************************************************************************************
 *  (C) Unpublished Copyright of Sigmatel, Inc. All Rights Reserved.
 *
 *
 *		Created: 04/06/2000 
 *			Version 0.9
 *		Edited: 04/27/2000 
 *			Version 0.92
 *		Edited: 05/12/2000 
 *			Version 0.94
 *		Edited: 07/27/2000 
 *			Version 1.01
 *		Edited: 08/22/2000 
 *			Version 1.02
 *		Edited: 09/16/2000 
 *			Version 1.03
 *		Edited: 09/25/2000 
 *			Version 1.10
 *		Edited: 11/10/2000 
 *			Version 1.12
 *		Edited: 01/16/2001
 *			Version 1.14
 *		Edited: 02/20/2001
 *			Version 1.15
 *
 **************************************************************************************************************************/

#define DOBREAKS    // enable debug breaks

#include <ndis.h>
#include <ntdef.h>
#include <windef.h>

#include "stdarg.h"
#include "stdio.h"

#include "debug.h"
#include "usbdi.h"
#include "usbdlib.h"

#include "ircommon.h"
#include "irusb.h"
#include "irndis.h"
#include "stir4200.h"


/*****************************************************************************
*
*  Function:   St4200ResetFifo
*
*  Synopsis:   Reset the STIr4200 FIFO to clear several hangs
*
*  Arguments:  pDevice - pointer to current ir device object
*
*  Returns:    NT_STATUS
*
*
*****************************************************************************/
NTSTATUS        
St4200ResetFifo( 
		IN PVOID pDevice
	)
{
	NTSTATUS		Status;
	PIR_DEVICE		pThisDev = (PIR_DEVICE)pDevice;
	
	DEBUGMSG(DBG_INT_ERR, (" St4200ResetFifo: Issuing a FIFO reset()\n"));
	
#if !defined(FAST_WRITE_REGISTERS)
	if( (Status = St4200ReadRegisters(pThisDev, STIR4200_MODE_REG, 1)) != STATUS_SUCCESS )
	{
		DEBUGMSG(DBG_ERR, (" St4200ResetFifo(): USB failure\n"));
		goto done;
	}
#endif

	//
	// Force a FIFO reset by clearing and setting again the RESET_OFF bit
	//
	pThisDev->StIrTranceiver.ModeReg &= (~STIR4200_MODE_RESET_OFF);
	if( (Status = St4200WriteRegister(pThisDev, STIR4200_MODE_REG)) != STATUS_SUCCESS )
	{
		DEBUGMSG(DBG_ERR, (" St4200ResetFifo(): USB failure\n"));
		goto done;
	}

	pThisDev->StIrTranceiver.ModeReg |= STIR4200_MODE_RESET_OFF;
	if( (Status = St4200WriteRegister(pThisDev, STIR4200_MODE_REG)) != STATUS_SUCCESS )
	{
		DEBUGMSG(DBG_ERR, (" St4200ResetFifo(): USB failure\n"));
		goto done;
	}

done:
	return Status;
}


/*****************************************************************************
*
*  Function:   St4200DoubleResetFifo
*
*  Synopsis:   Reset the STIr4200 FIFO to clear several 4012 related hangs
*
*  Arguments:  pDevice - pointer to current ir device object
*
*  Returns:    NT_STATUS
*
*
*****************************************************************************/
NTSTATUS        
St4200DoubleResetFifo( 
		IN PVOID pDevice
	)
{
	NTSTATUS		Status;
	PIR_DEVICE		pThisDev = (PIR_DEVICE)pDevice;
	
	DEBUGMSG(DBG_INT_ERR, (" St4200DoubleResetFifo: Issuing a FIFO reset()\n"));

	//
	// Turn off the receiver to clear the pointers
	//
	if( (Status = St4200TurnOffReceiver( pThisDev ) ) != STATUS_SUCCESS )
	{
		DEBUGMSG(DBG_ERR, (" St4200DoubleResetFifo(): USB failure\n"));
		goto done;
	}

	//
	// Now clear the fifo logic
	//
#if !defined(FAST_WRITE_REGISTERS)
	if( (Status = St4200ReadRegisters(pThisDev, STIR4200_STATUS_REG, 1)) != STATUS_SUCCESS )
	{
		DEBUGMSG(DBG_ERR, (" St4200DoubleResetFifo(): USB failure\n"));
		goto done;
	}

	if( (Status = St4200ReadRegisters(pThisDev, STIR4200_STATUS_REG, 1)) != STATUS_SUCCESS )
	{
		DEBUGMSG(DBG_ERR, (" St4200DoubleResetFifo(): USB failure\n"));
		goto done;
	}
#endif

	pThisDev->StIrTranceiver.StatusReg |= STIR4200_STAT_FFCLR;
	if( (Status = St4200WriteRegister(pThisDev, STIR4200_STATUS_REG)) != STATUS_SUCCESS )
	{
		DEBUGMSG(DBG_ERR, (" St4200DoubleResetFifo(): USB failure\n"));
		goto done;
	}

	//
	// All back on
	//
	pThisDev->StIrTranceiver.StatusReg &= (~STIR4200_STAT_FFCLR);
	if( (Status = St4200WriteRegister(pThisDev, STIR4200_STATUS_REG)) != STATUS_SUCCESS )
	{
		DEBUGMSG(DBG_ERR, (" St4200DoubleResetFifo(): USB failure\n"));
		goto done;
	}

	if( (Status = St4200TurnOnReceiver( pThisDev ) ) != STATUS_SUCCESS )
	{
		DEBUGMSG(DBG_ERR, (" St4200DoubleResetFifo(): USB failure\n"));
		goto done;
	}


done:
	return Status;
}


/*****************************************************************************
*
*  Function:   St4200SoftReset
*
*  Synopsis:   Soft reset of the STIr4200 modulator
*
*  Arguments:  pDevice - pointer to current ir device object
*
*  Returns:    NT_STATUS
*
*
*****************************************************************************/
NTSTATUS        
St4200SoftReset( 
		IN PVOID pDevice
	)
{
	NTSTATUS		Status;
	PIR_DEVICE		pThisDev = (PIR_DEVICE)pDevice;
	
	DEBUGMSG(DBG_INT_ERR, (" St4200SoftReset: Issuing a soft reset()\n"));
	
#if !defined(FAST_WRITE_REGISTERS)
	if( (Status = St4200ReadRegisters(pThisDev, STIR4200_CONTROL_REG, 1)) != STATUS_SUCCESS )
	{
		DEBUGMSG(DBG_ERR, (" St4200SoftReset(): USB failure\n"));
		goto done;
	}
#endif

	//
	// Force a FIFO reset by clearing and setting again the RESET_OFF bit
	//
	pThisDev->StIrTranceiver.ControlReg |= STIR4200_CTRL_SRESET;
	if( (Status = St4200WriteRegister(pThisDev, STIR4200_CONTROL_REG)) != STATUS_SUCCESS )
	{
		DEBUGMSG(DBG_ERR, (" St4200SoftReset(): USB failure\n"));
		goto done;
	}

	pThisDev->StIrTranceiver.ControlReg &= (~STIR4200_CTRL_SRESET);
	if( (Status = St4200WriteRegister(pThisDev, STIR4200_CONTROL_REG)) != STATUS_SUCCESS )
	{
		DEBUGMSG(DBG_ERR, (" St4200SoftReset(): USB failure\n"));
		goto done;
	}

done:
	return Status;
}


/*****************************************************************************
*
*  Function:   St4200SetIrMode
*
*  Synopsis:   Sets the STIr4200 to the proper operational mode
*
*  Arguments:  pDevice - pointer to current ir device object
*			   mode - mode to set the tranceiver to
*
*  Returns:    NT_STATUS
*
*
*****************************************************************************/
NTSTATUS        
St4200SetIrMode( 
		IN OUT PVOID pDevice,
		ULONG mode 
	)
{
    NTSTATUS		Status;
	PIR_DEVICE		pThisDev = (PIR_DEVICE)pDevice;

#if !defined(FAST_WRITE_REGISTERS)
    if( (Status = St4200ReadRegisters(pThisDev, STIR4200_MODE_REG, 1)) != STATUS_SUCCESS )
    {
		DEBUGMSG(DBG_ERR, (" St4200SetIrMode(): USB failure\n"));
		goto done;
    }
#endif

	//
	// Remove all mode bits and set the proper mode
	//
	pThisDev->StIrTranceiver.ModeReg &= ~STIR4200_MODE_MASK;
	pThisDev->StIrTranceiver.ModeReg |= STIR4200_MODE_RESET_OFF;

	//
	// Enable the bug fixing feature for LA8
	//
#if defined(SUPPORT_LA8)
	if( pThisDev->ChipRevision >= CHIP_REVISION_8 )
	{
		pThisDev->StIrTranceiver.ModeReg &= ~STIR4200_MODE_AUTO_RESET;
		pThisDev->StIrTranceiver.ModeReg &= ~STIR4200_MODE_BULKIN_FIX;
	}
#endif

    switch( (IR_MODE)mode )
    {
		case IR_MODE_SIR:
			pThisDev->StIrTranceiver.ModeReg |= STIR4200_MODE_SIR;
			//if( pThisDev->linkSpeedInfo->BitsPerSec != SPEED_9600 )
				pThisDev->StIrTranceiver.ModeReg |= STIR4200_MODE_BULKIN_FIX;

			//pThisDev->StIrTranceiver.ModeReg |= STIR4200_MODE_ASK;
			break;
#if !defined(WORKAROUND_BROKEN_MIR)
		case IR_MODE_MIR:
			pThisDev->MirIncompleteBitCount = 0;
			pThisDev->MirOneBitCount = 0;
			pThisDev->MirIncompleteByte = 0;
			pThisDev->MirFlagCount = 0;
			pThisDev->StIrTranceiver.ModeReg |= STIR4200_MODE_MIR;
			break;
#endif
		case IR_MODE_FIR:
			pThisDev->StIrTranceiver.ModeReg |= STIR4200_MODE_FIR;
#if defined(SUPPORT_LA8)
			if( pThisDev->ChipRevision >= CHIP_REVISION_8 )
			{
				pThisDev->StIrTranceiver.ModeReg |= STIR4200_MODE_BULKIN_FIX;
				pThisDev->StIrTranceiver.ModeReg |= STIR4200_MODE_AUTO_RESET;
			}
#endif
			break;
		default:
			IRUSB_ASSERT( 0 );
    }

    if( (Status = St4200WriteRegister(pThisDev, STIR4200_MODE_REG) ) != STATUS_SUCCESS )
    {
		DEBUGMSG(DBG_ERR, (" St4200SetIrMode(): USB failure\n"));
		goto done;
    }

    /***********************************************/
    /*   Set TEMIC transceiver...                  */
    /***********************************************/
#if !defined(FAST_WRITE_REGISTERS)
    if( (Status = St4200ReadRegisters(pThisDev, STIR4200_CONTROL_REG, 1)) != STATUS_SUCCESS )
    {
		DEBUGMSG(DBG_ERR, (" St4200SetIrMode(): USB failure\n"));
		goto done;
    }
#endif

	pThisDev->StIrTranceiver.ControlReg |= STIR4200_CTRL_SDMODE;
    
	if( (Status = St4200WriteRegister(pThisDev, STIR4200_CONTROL_REG)) != STATUS_SUCCESS )
    {
		DEBUGMSG(DBG_ERR, (" St4200SetIrMode(): USB failure\n"));
		goto done;
    }
 
#if !defined(FAST_WRITE_REGISTERS)
    if( (Status = St4200ReadRegisters(pThisDev, STIR4200_CONTROL_REG, 1)) != STATUS_SUCCESS )
    {
		DEBUGMSG(DBG_ERR, (" St4200SetIrMode(): USB failure\n"));
		goto done;
    }
#endif
	
	pThisDev->StIrTranceiver.ControlReg &= (~STIR4200_CTRL_SDMODE);

	if( (Status = St4200WriteRegister(pThisDev, STIR4200_CONTROL_REG)) != STATUS_SUCCESS )
    {
		DEBUGMSG(DBG_ERR, (" St4200SetIrMode(): USB failure\n"));
		goto done;
    }

done:
    return Status;
}

/*****************************************************************************
*
*  Function:   St4200SetSpeed
*
*  Synopsis:   Sets the STIr4200 speed
*
*  Arguments:  pDevice - pointer to current ir device object
*
*  Returns:    NT_STATUS
*
*
*****************************************************************************/
NTSTATUS        
St4200SetSpeed( 
		IN OUT PVOID pDevice
	)
{
    NTSTATUS        Status;
	PIR_DEVICE		pThisDev = (PIR_DEVICE)pDevice;

#if defined(RECEIVE_LOGGING)
	if( pThisDev->linkSpeedInfo->BitsPerSec==SPEED_4000000 )
	{
		IO_STATUS_BLOCK IoStatusBlock;
		OBJECT_ATTRIBUTES ObjectAttributes;
		UNICODE_STRING FileName;
		NTSTATUS Status;

		RtlInitUnicodeString(&FileName, L"\\DosDevices\\c:\\receive.log");
		
		InitializeObjectAttributes(
			&ObjectAttributes,
			&FileName,
			OBJ_CASE_INSENSITIVE,
			NULL,
			NULL
			);

		Status=ZwCreateFile(
			   &pThisDev->ReceiveFileHandle,
			   GENERIC_WRITE | SYNCHRONIZE,
			   &ObjectAttributes,
			   &IoStatusBlock,
			   0,
			   FILE_ATTRIBUTE_NORMAL,
			   FILE_SHARE_READ,
			   FILE_OVERWRITE_IF,
			   FILE_SYNCHRONOUS_IO_NONALERT,
			   NULL,
			   0
			   );
		
		pThisDev->ReceiveFilePosition = 0;
	}
	else
	{
		if( pThisDev->ReceiveFileHandle )
		{
			ZwClose( pThisDev->ReceiveFileHandle );
			pThisDev->ReceiveFileHandle = 0;
			pThisDev->ReceiveFilePosition = 0;
		}
	}
#endif
#if defined(RECEIVE_ERROR_LOGGING)
	if( pThisDev->linkSpeedInfo->BitsPerSec==SPEED_4000000 )
	{
		IO_STATUS_BLOCK IoStatusBlock;
		OBJECT_ATTRIBUTES ObjectAttributes;
		UNICODE_STRING FileName;
		NTSTATUS Status;

		RtlInitUnicodeString(&FileName, L"\\DosDevices\\c:\\receive_error.log");
		
		InitializeObjectAttributes(
			&ObjectAttributes,
			&FileName,
			OBJ_CASE_INSENSITIVE,
			NULL,
			NULL
			);

		Status=ZwCreateFile(
			   &pThisDev->ReceiveErrorFileHandle,
			   GENERIC_WRITE | SYNCHRONIZE,
			   &ObjectAttributes,
			   &IoStatusBlock,
			   0,
			   FILE_ATTRIBUTE_NORMAL,
			   FILE_SHARE_READ,
			   FILE_OVERWRITE_IF,
			   FILE_SYNCHRONOUS_IO_NONALERT,
			   NULL,
			   0
			   );
		
		pThisDev->ReceiveErrorFilePosition = 0;
	}
	else
	{
		if( pThisDev->ReceiveErrorFileHandle )
		{
			ZwClose( pThisDev->ReceiveErrorFileHandle );
			pThisDev->ReceiveErrorFileHandle = 0;
			pThisDev->ReceiveErrorFilePosition = 0;
		}
	}
#endif
#if defined(SEND_LOGGING)
	if( pThisDev->linkSpeedInfo->BitsPerSec==SPEED_4000000 )
	{
		IO_STATUS_BLOCK IoStatusBlock;
		OBJECT_ATTRIBUTES ObjectAttributes;
		UNICODE_STRING FileName;
		NTSTATUS Status;

		RtlInitUnicodeString(&FileName, L"\\DosDevices\\c:\\send.log");
		
		InitializeObjectAttributes(
			&ObjectAttributes,
			&FileName,
			OBJ_CASE_INSENSITIVE,
			NULL,
			NULL
			);

		Status=ZwCreateFile(
			   &pThisDev->SendFileHandle,
			   GENERIC_WRITE | SYNCHRONIZE,
			   &ObjectAttributes,
			   &IoStatusBlock,
			   0,
			   FILE_ATTRIBUTE_NORMAL,
			   FILE_SHARE_READ,
			   FILE_OVERWRITE_IF,
			   FILE_SYNCHRONOUS_IO_NONALERT,
			   NULL,
			   0
			   );
		
		pThisDev->SendFilePosition = 0;
	}
	else
	{
		if( pThisDev->SendFileHandle )
		{
			ZwClose( pThisDev->SendFileHandle );
			pThisDev->SendFileHandle = 0;
			pThisDev->SendFilePosition = 0;
		}
	}
#endif

	//
	// Always force a new tuning
	//
	if( (Status = St4200TuneDpllAndSensitivity(pThisDev, pThisDev->linkSpeedInfo->BitsPerSec)) != STATUS_SUCCESS )
	{
		DEBUGMSG(DBG_ERR, (" St4200TuneDpllAndSensitivity(): USB failure\n"));
		goto done;
	}

	//
	// First power down the modulator
    //
#if !defined(FAST_WRITE_REGISTERS)
    if( (Status = St4200ReadRegisters(pThisDev, STIR4200_CONTROL_REG, 1)) != STATUS_SUCCESS )
    {
		DEBUGMSG(DBG_ERR, (" St4200SetSpeed(): USB failure\n"));
		goto done;
    }
#endif
    pThisDev->StIrTranceiver.ControlReg |= (STIR4200_CTRL_TXPWD | STIR4200_CTRL_RXPWD);
    pThisDev->StIrTranceiver.ControlReg |= STIR4200_CTRL_RXSLOW;
    if( (Status = St4200WriteRegister(pThisDev, STIR4200_CONTROL_REG)) != STATUS_SUCCESS )
    {
		DEBUGMSG(DBG_ERR, (" St4200SetSpeed(): USB failure\n"));
		goto done;
    }

    //
	// Then set baudrate
	//
	pThisDev->StIrTranceiver.BaudrateReg = pThisDev->linkSpeedInfo->Stir4200Divisor;

    if( (Status = St4200WriteRegister(pThisDev, STIR4200_BAUDRATE_REG)) != STATUS_SUCCESS )
    {
		DEBUGMSG(DBG_ERR, (" St4200SetSpeed(): USB failure\n"));
		goto done;
    }

	//
	// We'll have to write the MSB of baud-rate too (only for 2400)
	//
	if( pThisDev->linkSpeedInfo->BitsPerSec == SPEED_2400 )
	{
		pThisDev->StIrTranceiver.ModeReg |= STIR4200_MODE_PDLCK8;
		
		if( (Status = St4200WriteRegister(pThisDev, STIR4200_MODE_REG)) != STATUS_SUCCESS )
		{
			DEBUGMSG(DBG_ERR, (" St4200SetSpeed(): USB failure\n"));
			goto done;
		}
	}
	else
	{
		if( pThisDev->StIrTranceiver.ModeReg & STIR4200_MODE_PDLCK8 )
		{
			pThisDev->StIrTranceiver.ModeReg &= ~STIR4200_MODE_PDLCK8;
			
			if( (Status = St4200WriteRegister(pThisDev, STIR4200_MODE_REG)) != STATUS_SUCCESS )
			{
				DEBUGMSG(DBG_ERR, (" St4200SetSpeed(): USB failure\n"));
				goto done;
			}
		}
	}

	//
	// Modulator back up
    //
	pThisDev->StIrTranceiver.ControlReg &= (~(STIR4200_CTRL_TXPWD | STIR4200_CTRL_RXPWD));

	if( (Status = St4200WriteRegister(pThisDev, STIR4200_CONTROL_REG)) != STATUS_SUCCESS )
	{
		DEBUGMSG(DBG_ERR, (" St4200SetSpeed(): USB failure\n"));
		goto done;
	}

	//
	// then IR mode
	//
	Status = St4200SetIrMode( pThisDev, pThisDev->linkSpeedInfo->IrMode );

	if( Status != STATUS_SUCCESS )
    {
		DEBUGMSG(DBG_ERR, (" St4200SetSpeed(): USB failure\n"));
		goto done;
    }

	//
	// Unmute it
	//
    pThisDev->StIrTranceiver.ControlReg &= ~STIR4200_CTRL_RXSLOW;
    if( (Status = St4200WriteRegister(pThisDev, STIR4200_CONTROL_REG)) != STATUS_SUCCESS )
    {
		DEBUGMSG(DBG_ERR, (" St4200SetSpeed(): USB failure\n"));
		goto done;
    }

	//
	// Program the receive delay for FIR
	//
	if( pThisDev->linkSpeedInfo->BitsPerSec == SPEED_4000000 )
	{
		if( pThisDev->dongleCaps.windowSize == 2 )
			pThisDev->ReceiveAdaptiveDelay = STIR4200_MULTIPLE_READ_DELAY;
		else
			pThisDev->ReceiveAdaptiveDelay = 0;
		pThisDev->ReceiveAdaptiveDelayBoost = 0;
	}

#if defined(WORKAROUND_GEAR_DOWN)
	//
	// Force a reset if going to 9600 from 4M
	//
	pThisDev->GearedDown = FALSE;
	if( pThisDev->linkSpeedInfo->BitsPerSec==SPEED_9600 && pThisDev->currentSpeed==SPEED_4000000 )
	{		
		St4200ResetFifo( pThisDev );
		pThisDev->GearedDown = TRUE;		
	}
#endif

done:
    return STATUS_SUCCESS;
}


/*****************************************************************************
*
*  Function:   St4200GetFifoCount
*
*  Synopsis:   Verifies if there is data to be received
*
*  Arguments:  pDevice - pointer to current ir device object
*			   pCountFifo - pointer to variable to return FIFO count
*
*  Returns:    NT_STATUS
*
*
*****************************************************************************/
NTSTATUS        
St4200GetFifoCount( 
		IN PVOID pDevice,
		OUT PULONG pCountFifo
	)
{
    NTSTATUS		Status = STATUS_SUCCESS;
	PIR_DEVICE		pThisDev = (PIR_DEVICE)pDevice;

    *pCountFifo = 0;
	if( pThisDev->PreFifoCount )
	{
		*pCountFifo = pThisDev->PreFifoCount;
	}
	else
	{
		Status = St4200ReadRegisters( pThisDev, STIR4200_FIFOCNT_LSB_REG, 2 );

		if( Status == STATUS_SUCCESS )
		{
			*pCountFifo = 
				((ULONG)MAKEUSHORT(pThisDev->StIrTranceiver.FifoCntLsbReg, pThisDev->StIrTranceiver.FifoCntMsbReg));
		}
	}

	pThisDev->PreFifoCount = 0;
    return Status;
}


/*****************************************************************************
*
*  Function:   St4200TuneDpllAndSensitivity
*
*  Synopsis:   tunes the DPLL and sensitivity registers
*
*  Arguments:  pDevice - pointer to current ir device object
*			   Speed - speed to tune for
*
*  Returns:    NT_STATUS
*
*
*****************************************************************************/
NTSTATUS        
St4200TuneDpllAndSensitivity(
		IN OUT PVOID pDevice,
		ULONG Speed
	)
{
    NTSTATUS		Status;
	PIR_DEVICE		pThisDev = (PIR_DEVICE)pDevice;

#if !defined(FAST_WRITE_REGISTERS)
    //
	// Read the current value of the DPLL
	//
	if( (Status = St4200ReadRegisters(pThisDev, STIR4200_DPLLTUNE_REG, 1)) != STATUS_SUCCESS )
    {
		DEBUGMSG(DBG_ERR, (" St4200TuneDpllAndSensitivity(): USB failure\n"));
		goto done;
    }
#endif

	//
	// Tune the DPLL according to the installed transceiver
	//
    switch( pThisDev->TransceiverType )
	{
		case TRANSCEIVER_INFINEON:
			pThisDev->StIrTranceiver.DpllTuneReg = STIR4200_DPLL_DESIRED_INFI;
			break;
		case TRANSCEIVER_VISHAY:
			pThisDev->StIrTranceiver.DpllTuneReg = STIR4200_DPLL_DESIRED_VISHAY;
			break;
		case TRANSCEIVER_4000:
			pThisDev->StIrTranceiver.DpllTuneReg = STIR4200_DPLL_DESIRED_4000;
			break;
		case TRANSCEIVER_4012:
		default:
			switch( Speed )
			{
				case SPEED_9600:
				case SPEED_19200:
				case SPEED_38400:
				case SPEED_57600:
				case SPEED_115200:
					pThisDev->StIrTranceiver.DpllTuneReg = STIR4200_DPLL_DESIRED_4012_SIR; //(UCHAR)pThisDev->SirDpll;
					break;
				case SPEED_4000000:
					pThisDev->StIrTranceiver.DpllTuneReg = STIR4200_DPLL_DESIRED_4012_FIR; //(UCHAR)pThisDev->FirDpll;
					break;
				default:
					pThisDev->StIrTranceiver.DpllTuneReg = STIR4200_DPLL_DESIRED_4012;
					break;
			}
			break;
	}
    if( (Status = St4200WriteRegister(pThisDev, STIR4200_DPLLTUNE_REG)) != STATUS_SUCCESS )
    {
		DEBUGMSG(DBG_ERR, (" St4200TuneDpllAndSensitivity(): USB failure\n"));
		goto done;
    }

#if !defined(FAST_WRITE_REGISTERS)
    //
	// Read the current value of the sensitivity
	//
	if( (Status = St4200ReadRegisters(pThisDev, STIR4200_SENSITIVITY_REG, 1)) != STATUS_SUCCESS )
    {
		DEBUGMSG(DBG_ERR, (" St4200TuneDpllAndSensitivity(): USB failure\n"));
		goto done;
    }
#endif

	//
	// Tune the sensitivity
	//
    switch( pThisDev->TransceiverType )
	{
		case TRANSCEIVER_INFINEON:
			switch( Speed )
			{
				default:
				case SPEED_9600:
				case SPEED_19200:
				case SPEED_38400:
				case SPEED_57600:
				case SPEED_115200:
					pThisDev->StIrTranceiver.SensitivityReg = STIR4200_SENS_RXDSNS_INFI_SIR;//(UCHAR)pThisDev->SirSensitivity;
					break;
				case SPEED_4000000:
					pThisDev->StIrTranceiver.SensitivityReg = STIR4200_SENS_RXDSNS_INFI_FIR;//(UCHAR)pThisDev->FirSensitivity;
					break;
			}
			break;
		case TRANSCEIVER_VISHAY:
			pThisDev->StIrTranceiver.SensitivityReg = STIR4200_SENS_RXDSNS_DEFAULT;
			break;
		case TRANSCEIVER_4000:
			pThisDev->StIrTranceiver.SensitivityReg = STIR4200_SENS_RXDSNS_DEFAULT;
			break;
		case TRANSCEIVER_4012:
		default:
			switch( Speed )
			{
				default:
				case SPEED_9600:
					pThisDev->StIrTranceiver.SensitivityReg = STIR4200_SENS_RXDSNS_4012_SIR_9600;
					break;
				case SPEED_19200:
				case SPEED_38400:
				case SPEED_57600:
				case SPEED_115200:
					pThisDev->StIrTranceiver.SensitivityReg = STIR4200_SENS_RXDSNS_4012_SIR;//(UCHAR)pThisDev->SirSensitivity;
					break;
				case SPEED_4000000:
					pThisDev->StIrTranceiver.SensitivityReg = STIR4200_SENS_RXDSNS_4012_FIR;//(UCHAR)pThisDev->FirSensitivity;
					break;
			}
			break;
	}
    if( (Status = St4200WriteRegister(pThisDev, STIR4200_SENSITIVITY_REG)) != STATUS_SUCCESS )
    {
		DEBUGMSG(DBG_ERR, (" St4200TuneDpllAndSensitivity(): USB failure\n"));
		goto done;
    }


done:
    return Status;
}


/*****************************************************************************
*
*  Function:   St4200EnableOscillatorPowerDown
*
*  Synopsis:   enable the oscillator to power down when we go into suspend mode
*
*  Arguments:  pDevice - pointer to current ir device object
*
*  Returns:    NT_STATUS
*
*
*****************************************************************************/
NTSTATUS        
St4200EnableOscillatorPowerDown(
		IN OUT PVOID pDevice
	)
{
    NTSTATUS		Status;
	PIR_DEVICE		pThisDev = (PIR_DEVICE)pDevice;

#if !defined(FAST_WRITE_REGISTERS)
    //
	// Read the current value
	//
	if( (Status = St4200ReadRegisters(pThisDev, STIR4200_TEST_REG, 1)) != STATUS_SUCCESS )
    {
		DEBUGMSG(DBG_ERR, (" St4200EnableOscillatorPowerDown(): USB failure\n"));
		goto done;
    }
#endif

	//
	// Enable
	//
    pThisDev->StIrTranceiver.TestReg |= STIR4200_TEST_EN_OSC_SUSPEND;
    if( (Status = St4200WriteRegister(pThisDev, STIR4200_TEST_REG)) != STATUS_SUCCESS )
    {
		DEBUGMSG(DBG_ERR, (" St4200EnableOscillatorPowerDown(): USB failure\n"));
		goto done;
    }

done:
    return Status;
}


/*****************************************************************************
*
*  Function:   St4200TurnOnSuspend
*
*  Synopsis:   prepares the part to go into suspend mode
*
*  Arguments:  pDevice - pointer to current ir device object
*
*  Returns:    NT_STATUS
*
*
*****************************************************************************/
NTSTATUS        
St4200TurnOnSuspend(
		IN OUT PVOID pDevice
	)
{
    NTSTATUS		Status;
	PIR_DEVICE		pThisDev = (PIR_DEVICE)pDevice;

#if !defined(FAST_WRITE_REGISTERS)
    //
	// Read the current value
	//
	if( (Status = St4200ReadRegisters(pThisDev, STIR4200_CONTROL_REG, 1)) != STATUS_SUCCESS )
    {
		DEBUGMSG(DBG_ERR, (" St4200TurnOnSuspend(): USB failure\n"));
		goto done;
    }
#endif

	//
	// Control UOUT
	//
    pThisDev->StIrTranceiver.ControlReg |= STIR4200_CTRL_SDMODE;
    if( (Status = St4200WriteRegister(pThisDev, STIR4200_CONTROL_REG)) != STATUS_SUCCESS )
    {
		DEBUGMSG(DBG_ERR, (" St4200TurnOnSuspend(): USB failure\n"));
		goto done;
    }

done:
    return Status;
}


/*****************************************************************************
*
*  Function:   St4200TurnOffSuspend
*
*  Synopsis:   prepares the part to go back into operational mode
*
*  Arguments:  pDevice - pointer to current ir device object
*
*  Returns:    NT_STATUS
*
*
*****************************************************************************/
NTSTATUS        
St4200TurnOffSuspend(
		IN OUT PVOID pDevice
	)
{
    NTSTATUS		Status;
	PIR_DEVICE		pThisDev = (PIR_DEVICE)pDevice;

#if !defined(FAST_WRITE_REGISTERS)
    //
	// Read the current value
	//
	if( (Status = St4200ReadRegisters(pThisDev, STIR4200_CONTROL_REG, 1)) != STATUS_SUCCESS )
    {
		DEBUGMSG(DBG_ERR, (" St4200TurnOffSuspend(): USB failure\n"));
		goto done;
    }
#endif

	//
	// Control UOUT
	//
    pThisDev->StIrTranceiver.ControlReg &= ~STIR4200_CTRL_SDMODE;
    if( (Status = St4200WriteRegister(pThisDev, STIR4200_CONTROL_REG)) != STATUS_SUCCESS )
    {
		DEBUGMSG(DBG_ERR, (" St4200TurnOffSuspend(): USB failure\n"));
		goto done;
    }

done:
    return Status;
}


/*****************************************************************************
*
*  Function:   St4200TurnOffReceiver
*
*  Synopsis:   turns of the STIr4200 receiver
*
*  Arguments:  pDevice - pointer to current ir device object
*
*  Returns:    NT_STATUS
*
*
*****************************************************************************/
NTSTATUS        
St4200TurnOffReceiver(
		IN OUT PVOID pDevice
	)
{
    NTSTATUS		Status;
	PIR_DEVICE		pThisDev = (PIR_DEVICE)pDevice;

#if !defined(FAST_WRITE_REGISTERS)
    //
	// Read the current value
	//
	if( (Status = St4200ReadRegisters(pThisDev, STIR4200_CONTROL_REG, 1)) != STATUS_SUCCESS )
    {
		DEBUGMSG(DBG_ERR, (" St4200TurnOffReceiver(): USB failure\n"));
		goto done;
    }
#endif

	//
	// Turn off receiver
	//
    pThisDev->StIrTranceiver.ControlReg |= STIR4200_CTRL_RXPWD;
    if( (Status = St4200WriteRegister(pThisDev, STIR4200_CONTROL_REG)) != STATUS_SUCCESS )
    {
		DEBUGMSG(DBG_ERR, (" St4200TurnOffReceiver(): USB failure\n"));
		goto done;
    }

done:
    return Status;
}


/*****************************************************************************
*
*  Function:   St4200TurnOnReceiver
*
*  Synopsis:   turns on the STIr4200 receiver
*
*  Arguments:  pDevice - pointer to current ir device object
*
*  Returns:    NT_STATUS
*
*
*****************************************************************************/
NTSTATUS        
St4200TurnOnReceiver(
		IN OUT PVOID pDevice
	)
{
    NTSTATUS		Status;
	PIR_DEVICE		pThisDev = (PIR_DEVICE)pDevice;

#if !defined(FAST_WRITE_REGISTERS)
    //
	// Read the current value
	//
	if( (Status = St4200ReadRegisters(pThisDev, STIR4200_CONTROL_REG, 1)) != STATUS_SUCCESS )
    {
		DEBUGMSG(DBG_ERR, (" St4200TurnOnReceiver(): USB failure\n"));
		goto done;
    }
#endif

	//
	// Turn on receiver
	//
    pThisDev->StIrTranceiver.ControlReg &= ~STIR4200_CTRL_RXPWD;
    if( (Status = St4200WriteRegister(pThisDev, STIR4200_CONTROL_REG)) != STATUS_SUCCESS )
    {
		DEBUGMSG(DBG_ERR, (" St4200TurnOnReceiver(): USB failure\n"));
		goto done;
    }

done:
    return Status;
}


/*****************************************************************************
*
*  Function:	St4200WriteMultipleRegisters
*
*  Synopsis:	reads multiple registers from the tranceiver
*
*  Arguments:	pDevice - pointer to current ir device object
*				FirstRegister - first register to write
*				RegistersToWrite - number of registers
*				
*  Returns:		NT_STATUS
*
*
*****************************************************************************/
NTSTATUS        
St4200WriteMultipleRegisters(
		IN PVOID pDevice,
		UCHAR FirstRegister, 
		UCHAR RegistersToWrite
	)
{
    NTSTATUS            status;
	PIRUSB_CONTEXT		pThisContext;
    PURB				pUrb = NULL;
    PDEVICE_OBJECT		pUrbTargetDev;
    PIO_STACK_LOCATION	pNextStack;
    PIRP                pIrp;
	PIR_DEVICE			pThisDev = (PIR_DEVICE)pDevice;
	PLIST_ENTRY			pListEntry;

	DEBUGMSG(DBG_FUNC, ("+St4200WriteMultipleRegisters\n"));

    IRUSB_ASSERT( KeGetCurrentIrql() == PASSIVE_LEVEL );

	//
	// Make sure there isn't a halt/reset going on
	//
	if( pThisDev->fPendingHalt || pThisDev->fPendingReset || pThisDev->fPendingClearTotalStall ) 
	{
        DEBUGMSG(DBG_ERR, (" St4200WriteMultipleRegisters abort due to pending reset\n"));

		status = STATUS_UNSUCCESSFUL;
		goto done;
	}
		
	//
	// Validate the parameters
	//
	if( (FirstRegister+RegistersToWrite)>(STIR4200_MAX_REG+1) )
	{
        DEBUGMSG(DBG_ERR, (" St4200WriteMultipleRegisters invalid input parameters\n"));

        status = STATUS_UNSUCCESSFUL;
        goto done;
	}

	pListEntry = ExInterlockedRemoveHeadList( &pThisDev->SendAvailableQueue, &pThisDev->SendLock );

	if( NULL == pListEntry )
    {
        //
		// This must not happen
		//
        DEBUGMSG(DBG_ERR, (" St4200WriteMultipleRegisters failed to find a free context struct\n"));
		IRUSB_ASSERT( 0 );

        status = STATUS_UNSUCCESSFUL;
        goto done;
    }
	
	InterlockedDecrement( &pThisDev->SendAvailableCount );

	pThisContext = CONTAINING_RECORD( pListEntry, IRUSB_CONTEXT, ListEntry );
	pThisContext->ContextType = CONTEXT_READ_WRITE_REGISTER;

	pUrb = pThisDev->pUrb;
	NdisZeroMemory( pUrb, pThisDev->UrbLen );

	//
    // Now that we have created the urb, we will send a
    // request to the USB device object.
    //
    pUrbTargetDev = pThisDev->pUsbDevObj;

	//
	// make an irp sending to usbhub
	//
	pIrp = IoAllocateIrp( (CCHAR)(pThisDev->pUsbDevObj->StackSize + 1), FALSE );

    if( NULL == pIrp )
    {
        DEBUGMSG(DBG_ERR, (" St4200WriteMultipleRegisters failed to alloc IRP\n"));

		ExInterlockedInsertTailList(
				&pThisDev->SendAvailableQueue,
				&pThisContext->ListEntry,
				&pThisDev->SendLock
			);
		InterlockedIncrement( &pThisDev->SendAvailableCount );
        status = STATUS_UNSUCCESSFUL;
        goto done;
    }

    pIrp->IoStatus.Status = STATUS_PENDING;
    pIrp->IoStatus.Information = 0;

	pThisContext->pIrp = pIrp;

	//
	// Build our URB for USBD
	//
    pUrb->UrbControlVendorClassRequest.Hdr.Length = (USHORT)sizeof( struct _URB_CONTROL_VENDOR_OR_CLASS_REQUEST );
    pUrb->UrbControlVendorClassRequest.Hdr.Function = URB_FUNCTION_VENDOR_DEVICE;
    pUrb->UrbControlVendorClassRequest.TransferFlags = USBD_TRANSFER_DIRECTION_OUT;
    // short packet is not treated as an error.
    pUrb->UrbControlVendorClassRequest.TransferFlags |= USBD_SHORT_TRANSFER_OK;
    pUrb->UrbControlVendorClassRequest.UrbLink = NULL;
    pUrb->UrbControlVendorClassRequest.TransferBufferMDL = NULL;
    pUrb->UrbControlVendorClassRequest.TransferBuffer = &(pThisDev->StIrTranceiver.FifoDataReg)+FirstRegister;
    pUrb->UrbControlVendorClassRequest.TransferBufferLength = RegistersToWrite;
	pUrb->UrbControlVendorClassRequest.Request = STIR4200_WRITE_REGS_REQ;
	pUrb->UrbControlVendorClassRequest.RequestTypeReservedBits = 0;
	pUrb->UrbControlVendorClassRequest.Index = FirstRegister;

	//
	// Call the class driver to perform the operation.
	//
    pNextStack = IoGetNextIrpStackLocation( pIrp );

    IRUSB_ASSERT( pNextStack != NULL );

    //
    // pass the URB to the USB driver stack
    //
	pNextStack->MajorFunction = IRP_MJ_INTERNAL_DEVICE_CONTROL;
	pNextStack->Parameters.Others.Argument1 = pUrb;
	pNextStack->Parameters.DeviceIoControl.IoControlCode = IOCTL_INTERNAL_USB_SUBMIT_URB;

	IoSetCompletionRoutine(
			pIrp,							// irp to use
			St4200CompleteReadWriteRequest,	// routine to call when irp is done
			DEV_TO_CONTEXT(pThisContext),	// context to pass routine
			TRUE,							// call on success
			TRUE,							// call on error
			TRUE							// call on cancel
		);

	KeClearEvent( &pThisDev->EventSyncUrb );

	//
    // Call IoCallDriver to send the irp to the usb port.
    //
	ExInterlockedInsertTailList(
			&pThisDev->ReadWritePendingQueue,
			&pThisContext->ListEntry,
			&pThisDev->SendLock
		);
	InterlockedIncrement( &pThisDev->ReadWritePendingCount );
    status = MyIoCallDriver( pThisDev, pUrbTargetDev, pIrp );

    //
    // The USB driver should always return STATUS_PENDING when
    // it receives a write irp
    //
    if( (status == STATUS_PENDING) || (status == STATUS_SUCCESS) )
	{
        // wait, but dump out on timeout
        if( status == STATUS_PENDING )
		{
            status = MyKeWaitForSingleObject( pThisDev, &pThisDev->EventSyncUrb, NULL, 0 );

            if( status == STATUS_TIMEOUT ) 
			{
				KIRQL OldIrql;

				DEBUGMSG( DBG_ERR,(" St4200WriteMultipleRegisters() TIMED OUT! return from IoCallDriver USBD %x\n", status));
				KeAcquireSpinLock( &pThisDev->SendLock, &OldIrql );
				RemoveEntryList( &pThisContext->ListEntry );
				KeReleaseSpinLock( &pThisDev->SendLock, OldIrql );
				InterlockedDecrement( &pThisDev->ReadWritePendingCount );
				IrUsb_CancelIo( pThisDev, pIrp, &pThisDev->EventSyncUrb );
            }
        }
    } 
	else 
	{
        DEBUGMSG( DBG_ERR, (" St4200WriteMultipleRegisters IoCallDriver FAILED(%x)\n",status));
		IRUSB_ASSERT( status == STATUS_PENDING );
	}

done:
    DEBUGMSG(DBG_FUNC, ("-St4200WriteMultipleRegisters\n"));
    return status;
}


/*****************************************************************************
*
*  Function:	St4200WriteRegister
*
*  Synopsis:	writes a STIr4200 register
*
*  Arguments:	pDevice - pointer to current ir device object
*				FirstRegister - first register to write
*
*  Returns:		NT_STATUS
*
*
*****************************************************************************/
NTSTATUS        
St4200WriteRegister(
		IN PVOID pDevice,
		UCHAR RegisterToWrite
	)
{
    NTSTATUS            status;
	PIRUSB_CONTEXT		pThisContext;
    PURB				pUrb = NULL;
    PDEVICE_OBJECT		pUrbTargetDev;
    PIO_STACK_LOCATION	pNextStack;
    PIRP                pIrp;
	PIR_DEVICE			pThisDev = (PIR_DEVICE)pDevice;
	PLIST_ENTRY			pListEntry;

	DEBUGMSG(DBG_FUNC, ("+St4200WriteRegister\n"));

    IRUSB_ASSERT( KeGetCurrentIrql() == PASSIVE_LEVEL );

	//
	// Make sure there isn't a halt/reset going on
	//
	if( pThisDev->fPendingHalt || pThisDev->fPendingReset || pThisDev->fPendingClearTotalStall ) 
	{
        DEBUGMSG(DBG_ERR, (" St4200WriteRegister abort due to pending reset\n"));

		status = STATUS_UNSUCCESSFUL;
		goto done;
	}
		
	//
	// Validate the parameters
	//
	if( RegisterToWrite>STIR4200_MAX_REG )
	{
        DEBUGMSG(DBG_ERR, (" St4200WriteRegister invalid input parameters\n"));

        status = STATUS_UNSUCCESSFUL;
        goto done;
	}

	pListEntry = ExInterlockedRemoveHeadList( &pThisDev->SendAvailableQueue, &pThisDev->SendLock );

	if( NULL == pListEntry )
    {
        //
		// This must not happen
		//
        DEBUGMSG(DBG_ERR, (" St4200WriteRegister failed to find a free context struct\n"));
		IRUSB_ASSERT( 0 );

        status = STATUS_UNSUCCESSFUL;
        goto done;
    }
	
	InterlockedDecrement( &pThisDev->SendAvailableCount );

	pThisContext = CONTAINING_RECORD( pListEntry, IRUSB_CONTEXT, ListEntry );
	pThisContext->ContextType = CONTEXT_READ_WRITE_REGISTER;

	pUrb = pThisDev->pUrb;
	NdisZeroMemory( pUrb, pThisDev->UrbLen );

	//
    // Now that we have created the urb, we will send a
    // request to the USB device object.
    //
    pUrbTargetDev = pThisDev->pUsbDevObj;

	//
	// make an irp sending to usbhub
	//
	pIrp = IoAllocateIrp( (CCHAR)(pThisDev->pUsbDevObj->StackSize + 1), FALSE );

    if( NULL == pIrp )
    {
        DEBUGMSG(DBG_ERR, (" St4200WriteRegister failed to alloc IRP\n"));

		ExInterlockedInsertTailList(
				&pThisDev->SendAvailableQueue,
				&pThisContext->ListEntry,
				&pThisDev->SendLock
			);
		InterlockedIncrement( &pThisDev->SendAvailableCount );
        status = STATUS_UNSUCCESSFUL;
        goto done;
    }

    pIrp->IoStatus.Status = STATUS_PENDING;
    pIrp->IoStatus.Information = 0;

	pThisContext->pIrp = pIrp;

	//
	// Build our URB for USBD
	//
    pUrb->UrbControlVendorClassRequest.Hdr.Length = (USHORT) sizeof( struct _URB_CONTROL_VENDOR_OR_CLASS_REQUEST );
    pUrb->UrbControlVendorClassRequest.Hdr.Function = URB_FUNCTION_VENDOR_DEVICE;
    pUrb->UrbControlVendorClassRequest.TransferFlags = USBD_TRANSFER_DIRECTION_OUT;
    // short packet is not treated as an error.
    pUrb->UrbControlVendorClassRequest.TransferFlags |= USBD_SHORT_TRANSFER_OK;
    pUrb->UrbControlVendorClassRequest.UrbLink = NULL;
    pUrb->UrbControlVendorClassRequest.TransferBufferMDL = NULL;
    pUrb->UrbControlVendorClassRequest.Value = *(&pThisDev->StIrTranceiver.FifoDataReg+RegisterToWrite);
	pUrb->UrbControlVendorClassRequest.Request = STIR4200_WRITE_REG_REQ;
	pUrb->UrbControlVendorClassRequest.RequestTypeReservedBits = 0;
	pUrb->UrbControlVendorClassRequest.Index = RegisterToWrite;

	//
	// Call the class driver to perform the operation.
	//
    pNextStack = IoGetNextIrpStackLocation( pIrp );

    IRUSB_ASSERT( pNextStack != NULL );

    //
    // pass the URB to the USB driver stack
    //
	pNextStack->MajorFunction = IRP_MJ_INTERNAL_DEVICE_CONTROL;
	pNextStack->Parameters.Others.Argument1 = pUrb;
	pNextStack->Parameters.DeviceIoControl.IoControlCode = IOCTL_INTERNAL_USB_SUBMIT_URB;

	IoSetCompletionRoutine(
			pIrp,							// irp to use
			St4200CompleteReadWriteRequest,	// routine to call when irp is done
			DEV_TO_CONTEXT(pThisContext),	// context to pass routine
			TRUE,							// call on success
			TRUE,							// call on error
			TRUE							// call on cancel
		);

	KeClearEvent( &pThisDev->EventSyncUrb );

	//
    // Call IoCallDriver to send the irp to the usb port.
    //
	ExInterlockedInsertTailList(
			&pThisDev->ReadWritePendingQueue,
			&pThisContext->ListEntry,
			&pThisDev->SendLock
		);
	InterlockedIncrement( &pThisDev->ReadWritePendingCount );
    status = MyIoCallDriver( pThisDev, pUrbTargetDev, pIrp );

    //
    // The USB driver should always return STATUS_PENDING when
    // it receives a write irp
    //
    if( (status == STATUS_PENDING) || (status == STATUS_SUCCESS) )
	{
        // wait, but dump out on timeout
        if( status == STATUS_PENDING )
		{
            status = MyKeWaitForSingleObject( pThisDev, &pThisDev->EventSyncUrb, NULL, 0 );

            if( status == STATUS_TIMEOUT ) 
			{
				KIRQL OldIrql;

				DEBUGMSG( DBG_ERR,(" St4200WriteRegister() TIMED OUT! return from IoCallDriver USBD %x\n", status));
				KeAcquireSpinLock( &pThisDev->SendLock, &OldIrql );
				RemoveEntryList( &pThisContext->ListEntry );
				KeReleaseSpinLock( &pThisDev->SendLock, OldIrql );
				InterlockedDecrement( &pThisDev->ReadWritePendingCount );
				IrUsb_CancelIo( pThisDev, pIrp, &pThisDev->EventSyncUrb );
            }
        }
    } 
	else 
	{
        DEBUGMSG( DBG_ERR, (" St4200WriteRegister IoCallDriver FAILED(%x)\n",status));
		IRUSB_ASSERT( status == STATUS_PENDING );
	}

done:
    DEBUGMSG(DBG_FUNC, ("-St4200WriteRegister\n"));
    return status;
}


/*****************************************************************************
*
*  Function:	St4200ReadRegisters
*
*  Synopsis:	reads multiple STIr4200 register
*
*  Arguments:	pDevice - pointer to current ir device object
*				FirstRegister - first register to read
*				RegistersToWrite - number of registers to read
*
*  Returns:		NT_STATUS
*
*
*****************************************************************************/
NTSTATUS
St4200ReadRegisters(
		IN OUT PVOID pDevice,
		UCHAR FirstRegister, 
		UCHAR RegistersToRead
	)
{
    NTSTATUS            status;
	PIRUSB_CONTEXT		pThisContext;
    PURB				pUrb = NULL;
    PDEVICE_OBJECT		pUrbTargetDev;
    PIO_STACK_LOCATION	pNextStack;
    PIRP                pIrp;
	PIR_DEVICE			pThisDev = (PIR_DEVICE)pDevice;
	PLIST_ENTRY			pListEntry;

	DEBUGMSG(DBG_FUNC, ("+St4200ReadRegisters\n"));

    IRUSB_ASSERT( KeGetCurrentIrql() == PASSIVE_LEVEL );

	//
	// Make sure there isn't a halt/reset going on
	//
	if( pThisDev->fPendingHalt || pThisDev->fPendingReset || pThisDev->fPendingClearTotalStall ) 
	{
        DEBUGMSG(DBG_ERR, (" St4200ReadRegisters abort due to pending reset\n"));

		status = STATUS_UNSUCCESSFUL;
		goto done;
	}

	//
	// Validate the parameters
	//
	if( (FirstRegister+RegistersToRead)>(STIR4200_MAX_REG+1) )
	{
        DEBUGMSG(DBG_ERR, (" St4200ReadRegisters invalid input parameters\n"));

        status = STATUS_UNSUCCESSFUL;
        goto done;
	}

	pListEntry = ExInterlockedRemoveHeadList( &pThisDev->SendAvailableQueue, &pThisDev->SendLock );

	if( NULL == pListEntry )
    {
        //
		// This must not happen
		//
		DEBUGMSG(DBG_ERR, (" St4200ReadRegisters failed to find a free context struct\n"));
		IRUSB_ASSERT( 0 );

        status = STATUS_UNSUCCESSFUL;
        goto done;
    }

	InterlockedDecrement( &pThisDev->SendAvailableCount );
	
	pThisContext = CONTAINING_RECORD( pListEntry, IRUSB_CONTEXT, ListEntry );
	pThisContext->ContextType = CONTEXT_READ_WRITE_REGISTER;

	pUrb = pThisDev->pUrb;
	NdisZeroMemory( pUrb, pThisDev->UrbLen );

	//
    // Now that we have created the urb, we will send a
    // request to the USB device object.
    //
    pUrbTargetDev = pThisDev->pUsbDevObj;

	//
	// make an irp sending to usbhub
	//
	pIrp = IoAllocateIrp( (CCHAR)(pThisDev->pUsbDevObj->StackSize + 1), FALSE );

    if( NULL == pIrp )
    {
        DEBUGMSG(DBG_ERR, (" St4200ReadRegisters failed to alloc IRP\n"));

		ExInterlockedInsertTailList(
				&pThisDev->SendAvailableQueue,
				&pThisContext->ListEntry,
				&pThisDev->SendLock
			);
		InterlockedIncrement( &pThisDev->SendAvailableCount );
        status = STATUS_UNSUCCESSFUL;
        goto done;
    }

    pIrp->IoStatus.Status = STATUS_PENDING;
    pIrp->IoStatus.Information = 0;

	pThisContext->pIrp = pIrp;

	//
	// Build our URB for USBD
	//
    pUrb->UrbControlVendorClassRequest.Hdr.Length = (USHORT) sizeof( struct _URB_CONTROL_VENDOR_OR_CLASS_REQUEST );
    pUrb->UrbControlVendorClassRequest.Hdr.Function = URB_FUNCTION_VENDOR_DEVICE ;
    pUrb->UrbControlVendorClassRequest.TransferFlags = USBD_TRANSFER_DIRECTION_IN ;
    // short packet is not treated as an error.
    pUrb->UrbControlVendorClassRequest.TransferFlags |= USBD_SHORT_TRANSFER_OK;
    pUrb->UrbControlVendorClassRequest.UrbLink = NULL;
    pUrb->UrbControlVendorClassRequest.TransferBufferMDL = NULL;
    pUrb->UrbControlVendorClassRequest.TransferBuffer = &(pThisDev->StIrTranceiver.FifoDataReg)+FirstRegister;
    pUrb->UrbControlVendorClassRequest.TransferBufferLength = RegistersToRead;
	pUrb->UrbControlVendorClassRequest.Request = STIR4200_READ_REGS_REQ;
	pUrb->UrbControlVendorClassRequest.RequestTypeReservedBits = 0;
	pUrb->UrbControlVendorClassRequest.Index = FirstRegister;
    
	//
    // Call the class driver to perform the operation.
	//
    pNextStack = IoGetNextIrpStackLocation( pIrp );

    IRUSB_ASSERT( pNextStack != NULL );

    //
    // pass the URB to the USB driver stack
    //
	pNextStack->MajorFunction = IRP_MJ_INTERNAL_DEVICE_CONTROL;
	pNextStack->Parameters.Others.Argument1 = pUrb;
	pNextStack->Parameters.DeviceIoControl.IoControlCode = IOCTL_INTERNAL_USB_SUBMIT_URB;

	IoSetCompletionRoutine(
			pIrp,							// irp to use
			St4200CompleteReadWriteRequest,	// routine to call when irp is done
			DEV_TO_CONTEXT(pThisContext),	// context to pass routine
			TRUE,							// call on success
			TRUE,							// call on error
			TRUE							// call on cancel
		);

	KeClearEvent( &pThisDev->EventSyncUrb );

	//
    // Call IoCallDriver to send the irp to the usb port.
    //
	ExInterlockedInsertTailList(
			&pThisDev->ReadWritePendingQueue,
			&pThisContext->ListEntry,
			&pThisDev->SendLock
		);
	InterlockedIncrement( &pThisDev->ReadWritePendingCount );
	status = MyIoCallDriver( pThisDev, pUrbTargetDev, pIrp );

    //
    // The USB driver should always return STATUS_PENDING when
    // it receives a write irp
    //
	if( (status == STATUS_PENDING) || (status == STATUS_SUCCESS) )
	{
		// wait, but dump out on timeout
		if( status == STATUS_PENDING )
		{
			status = MyKeWaitForSingleObject( pThisDev, &pThisDev->EventSyncUrb, NULL, 0 );

			if( status == STATUS_TIMEOUT ) 
			{
				KIRQL OldIrql;

				DEBUGMSG( DBG_ERR,(" St4200ReadRegisters() TIMED OUT! return from IoCallDriver USBD %x\n", status));
				KeAcquireSpinLock( &pThisDev->SendLock, &OldIrql );
				RemoveEntryList( &pThisContext->ListEntry );
				KeReleaseSpinLock( &pThisDev->SendLock, OldIrql );
				InterlockedDecrement( &pThisDev->ReadWritePendingCount );
				IrUsb_CancelIo( pThisDev, pIrp, &pThisDev->EventSyncUrb );
			}
			else
			{
				//
				// Update the status to reflect the real return code
				//
				status = pThisDev->StatusReadWrite;
			}
		}
	} 
	else 
	{
		DEBUGMSG( DBG_ERR, (" St4200ReadRegisters IoCallDriver FAILED(%x)\n",status));
		
		//
		// Don't assert, as such a failure can happen at shutdown
		//
		//IRUSB_ASSERT( status == STATUS_PENDING );
	}

done:
    DEBUGMSG(DBG_FUNC, ("-St4200ReadRegisters\n"));
    return status;
}


/*****************************************************************************
*
*  Function:   St4200CompleteReadWriteRequest
*
*  Synopsis:   completes a read/write ST4200 register request
*
*  Arguments:  pUsbDevObj - pointer to the  device object which
*                           completed the irp
*              pIrp       - the irp which was completed by the device
*                           object
*              Context    - send context
*
*  Returns:    NT_STATUS
*
*
*****************************************************************************/
NTSTATUS
St4200CompleteReadWriteRequest(
		IN PDEVICE_OBJECT pUsbDevObj,
		IN PIRP           pIrp,
		IN PVOID          Context
	)
{
    PIR_DEVICE          pThisDev;
    NTSTATUS            status;
	PIRUSB_CONTEXT		pThisContext = (PIRUSB_CONTEXT)Context;
	PIRP				pContextIrp;
	PURB                pContextUrb;
	PLIST_ENTRY			pListEntry;

    DEBUGMSG(DBG_FUNC, ("+St4200CompleteReadWriteRequest\n"));

    //
    // The context given to IoSetCompletionRoutine is an IRUSB_CONTEXT struct
    //
	IRUSB_ASSERT( NULL != pThisContext );				// we better have a non NULL buffer

    pThisDev = pThisContext->pThisDev;

	IRUSB_ASSERT( NULL != pThisDev );	

	pContextIrp = pThisContext->pIrp;
	pContextUrb = pThisDev->pUrb;
	
	//
	// Perform various IRP, URB, and buffer 'sanity checks'
	//
    IRUSB_ASSERT( pContextIrp == pIrp );				// check we're not a bogus IRP

    status = pIrp->IoStatus.Status;

	//
	// we should have failed, succeeded, or cancelled, but NOT be pending
	//
	IRUSB_ASSERT( STATUS_PENDING != status );

	//
	// Remove from the pending queue (only if NOT cancelled)
	//
	if( status != STATUS_CANCELLED )
	{
		KIRQL OldIrql;
		
		KeAcquireSpinLock( &pThisDev->SendLock, &OldIrql );
		RemoveEntryList( &pThisContext->ListEntry );
		KeReleaseSpinLock( &pThisDev->SendLock, OldIrql );
		InterlockedDecrement( &pThisDev->ReadWritePendingCount );
	}

    //pIrp->IoStatus.Information = pContextUrb->UrbControlVendorClassRequest.TransferBufferLength;

    DEBUGMSG(DBG_OUT, 
		(" St4200CompleteReadWriteRequest  pIrp->IoStatus.Status = 0x%x\n", status));
    //DEBUGMSG(DBG_OUT, 
	//	(" St4200CompleteReadWriteRequest  pIrp->IoStatus.Information = 0x%x, dec %d\n", pIrp->IoStatus.Information,pIrp->IoStatus.Information));

    //
    // Free the IRP  because we alloced it ourselves,
    //
    IoFreeIrp( pIrp );
	InterlockedIncrement( &pThisDev->NumReadWrites );

	IrUsb_DecIoCount( pThisDev ); // we will track count of pending irps

	//
	// Put back on the available queue
	//
	ExInterlockedInsertTailList(
			&pThisDev->SendAvailableQueue,
			&pThisContext->ListEntry,
			&pThisDev->SendLock
		);
	InterlockedIncrement( &pThisDev->SendAvailableCount );

	if( ( STATUS_SUCCESS != status )  && ( STATUS_CANCELLED != status ) ) 
	{
		InterlockedIncrement( (PLONG)&pThisDev->NumReadWriteErrors );
		
		//
		// We have a serious USB failure, we'll have to issue a total reset
		//
		if( !pThisDev->fPendingClearTotalStall && !pThisDev->fPendingHalt 
			&& !pThisDev->fPendingReset && pThisDev->fProcessing )
		{
			DEBUGMSG(DBG_ERR, (" St4200CompleteReadWriteRequest error, will schedule an entire reset\n"));
			//DbgPrint(" St4200CompleteReadWriteRequest error, will schedule an entire reset\n");
    
			InterlockedExchange( (PLONG)&pThisDev->fPendingClearTotalStall, TRUE );
			ScheduleWorkItem( pThisDev,	RestoreIrDevice, NULL, 0 );
		}
	}

	//
	// This will only work as long as we serialize the access to the hardware
	//
	pThisDev->StatusReadWrite = status;
	
	//
	// Signal we're done
	//
	KeSetEvent( &pThisDev->EventSyncUrb, 0, FALSE );  
    DEBUGMSG(DBG_FUNC, ("-St4200CompleteReadWriteRequest\n"));
    return STATUS_MORE_PROCESSING_REQUIRED;
}


#if defined( WORKAROUND_STUCK_AFTER_GEAR_DOWN )
/*****************************************************************************
*
*  Function:	St4200FakeSend
*
*  Synopsis:	forces a bulk transfer
*
*  Arguments:	pDevice - pointer to current ir device object
*				pData - pointer to bulk data
*				DataSize - size of bulk data
*
*  Returns:		NT_STATUS
*
*
*****************************************************************************/
NTSTATUS        
St4200FakeSend(
		IN PVOID pDevice,
		PUCHAR pData,
		ULONG DataSize
	)
{
    NTSTATUS            status;
	PIRUSB_CONTEXT		pThisContext;
    PURB				pUrb = NULL;
    PDEVICE_OBJECT		pUrbTargetDev;
    PIO_STACK_LOCATION	pNextStack;
    PIRP                pIrp;
	PIR_DEVICE			pThisDev = (PIR_DEVICE)pDevice;
	PLIST_ENTRY			pListEntry;

	DEBUGMSG(DBG_FUNC, ("+St4200FakeSend\n"));

    IRUSB_ASSERT( KeGetCurrentIrql() == PASSIVE_LEVEL );

	//
	// Stop if a halt/reset/suspend is going on
	//
	if( pThisDev->fPendingWriteClearStall || pThisDev->fPendingHalt || 
		pThisDev->fPendingReset || pThisDev->fPendingClearTotalStall || !pThisDev->fProcessing ) 
	{
        DEBUGMSG(DBG_ERR, (" St4200FakeSend abort due to pending reset\n"));

		status = STATUS_UNSUCCESSFUL;
		goto done;
	}
		
	pListEntry = ExInterlockedRemoveHeadList( &pThisDev->SendAvailableQueue, &pThisDev->SendLock );

	if( NULL == pListEntry )
    {
        //
		// This must not happen
		//
        DEBUGMSG(DBG_ERR, (" St4200FakeSend failed to find a free context struct\n"));
		IRUSB_ASSERT( 0 );

        status = STATUS_UNSUCCESSFUL;
        goto done;
    }
	
	InterlockedDecrement( &pThisDev->SendAvailableCount );

	pThisContext = CONTAINING_RECORD( pListEntry, IRUSB_CONTEXT, ListEntry );
	pThisContext->ContextType = CONTEXT_READ_WRITE_REGISTER;

	pUrb = pThisDev->pUrb;
	NdisZeroMemory( pUrb, pThisDev->UrbLen );

	//
    // Now that we have created the urb, we will send a
    // request to the USB device object.
    //
    pUrbTargetDev = pThisDev->pUsbDevObj;

	//
	// make an irp sending to usbhub
	//
	pIrp = IoAllocateIrp( (CCHAR)(pThisDev->pUsbDevObj->StackSize + 1), FALSE );

    if( NULL == pIrp )
    {
        DEBUGMSG(DBG_ERR, (" St4200FakeSend failed to alloc IRP\n"));

		ExInterlockedInsertTailList(
				&pThisDev->SendAvailableQueue,
				&pThisContext->ListEntry,
				&pThisDev->SendLock
			);
		InterlockedIncrement( &pThisDev->SendAvailableCount );
        status = STATUS_UNSUCCESSFUL;
        goto done;
    }

    pIrp->IoStatus.Status = STATUS_PENDING;
    pIrp->IoStatus.Information = 0;

	pThisContext->pIrp = pIrp;

	//
	// Build our URB for USBD
	//
    pUrb->UrbBulkOrInterruptTransfer.Hdr.Length = (USHORT)sizeof( struct _URB_BULK_OR_INTERRUPT_TRANSFER );
    pUrb->UrbBulkOrInterruptTransfer.Hdr.Function = URB_FUNCTION_BULK_OR_INTERRUPT_TRANSFER;
    pUrb->UrbBulkOrInterruptTransfer.PipeHandle = pThisDev->BulkOutPipeHandle;
    pUrb->UrbBulkOrInterruptTransfer.TransferFlags = USBD_TRANSFER_DIRECTION_OUT ;
    // short packet is not treated as an error.
    pUrb->UrbBulkOrInterruptTransfer.TransferFlags |= USBD_SHORT_TRANSFER_OK;
    pUrb->UrbBulkOrInterruptTransfer.UrbLink = NULL;
    pUrb->UrbBulkOrInterruptTransfer.TransferBufferMDL = NULL;
    pUrb->UrbBulkOrInterruptTransfer.TransferBuffer = pData;
    pUrb->UrbBulkOrInterruptTransfer.TransferBufferLength = (int)DataSize;

	//
	// Call the class driver to perform the operation.
	//
    pNextStack = IoGetNextIrpStackLocation( pIrp );

    IRUSB_ASSERT( pNextStack != NULL );

    //
    // pass the URB to the USB driver stack
    //
	pNextStack->MajorFunction = IRP_MJ_INTERNAL_DEVICE_CONTROL;
	pNextStack->Parameters.Others.Argument1 = pUrb;
	pNextStack->Parameters.DeviceIoControl.IoControlCode = IOCTL_INTERNAL_USB_SUBMIT_URB;

	IoSetCompletionRoutine(
			pIrp,							// irp to use
			St4200CompleteReadWriteRequest,	// routine to call when irp is done
			DEV_TO_CONTEXT(pThisContext),	// context to pass routine
			TRUE,							// call on success
			TRUE,							// call on error
			TRUE							// call on cancel
		);

	KeClearEvent( &pThisDev->EventSyncUrb );

	//
    // Call IoCallDriver to send the irp to the usb port.
    //
	ExInterlockedInsertTailList(
			&pThisDev->ReadWritePendingQueue,
			&pThisContext->ListEntry,
			&pThisDev->SendLock
		);
	InterlockedIncrement( &pThisDev->ReadWritePendingCount );
    status = MyIoCallDriver( pThisDev, pUrbTargetDev, pIrp );

    //
    // The USB driver should always return STATUS_PENDING when
    // it receives a write irp
    //
    if( (status == STATUS_PENDING) || (status == STATUS_SUCCESS) )
	{
        // wait, but dump out on timeout
        if( status == STATUS_PENDING )
		{
            status = MyKeWaitForSingleObject( pThisDev, &pThisDev->EventSyncUrb, NULL, 0 );

            if( status == STATUS_TIMEOUT ) 
			{
				KIRQL OldIrql;

				DEBUGMSG( DBG_ERR,(" St4200FakeSend() TIMED OUT! return from IoCallDriver USBD %x\n", status));
				KeAcquireSpinLock( &pThisDev->SendLock, &OldIrql );
				RemoveEntryList( &pThisContext->ListEntry );
				KeReleaseSpinLock( &pThisDev->SendLock, OldIrql );
				InterlockedDecrement( &pThisDev->ReadWritePendingCount );
				IrUsb_CancelIo( pThisDev, pIrp, &pThisDev->EventSyncUrb );
            }
        }
    } 
	else 
	{
        DEBUGMSG( DBG_ERR, (" St4200FakeSend IoCallDriver FAILED(%x)\n",status));
		IRUSB_ASSERT( status == STATUS_PENDING );
	}

done:
    DEBUGMSG(DBG_FUNC, ("-St4200FakeSend\n"));
    return status;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\net\irda\sigmatel\sys\irmisc.c ===
/**************************************************************************************************************************
 *  IRMISC.C SigmaTel STIR4200 misc module
 **************************************************************************************************************************
 *  (C) Unpublished Copyright of Sigmatel, Inc. All Rights Reserved.
 *
 *
 *		Created: 04/06/2000 
 *			Version 0.9
 *		Edited: 09/16/2000 
 *			Version 1.03
 *		Edited: 09/25/2000 
 *			Version 1.10
 *		Edited: 12/07/2000 
 *			Version 1.12
 *		Edited: 01/09/2001 
 *			Version 1.13
 *		Edited: 01/16/2001
 *			Version 1.14
 *	
 *
 **************************************************************************************************************************/

#define DOBREAKS    // enable debug breaks

#include <ndis.h>
#include <ntddndis.h>  // defines OID's

#include <usbdi.h>
#include <usbdlib.h>

#include "debug.h"
#include "ircommon.h"
#include "irndis.h"


/*****************************************************************************
*
*  Function:	IrUsb_CreateDeviceExt
*
*  Synopsis:	Creates a IR device extension
*
*  Arguments:	DeviceExt - pointer to DeviceExt pointer to return created device extension.
*	
*  Returns:		STATUS_SUCCESS if successful
*			    STATUS_UNSUCCESSFUL otherwise
*
*  Notes:
*
*****************************************************************************/
NTSTATUS
IrUsb_CreateDeviceExt(
		IN OUT PIR_DEVICE *DeviceExt
	)
{
    NTSTATUS	ntStatus = STATUS_SUCCESS;
    PIR_DEVICE	pThisDev = NULL;

    DEBUGMSG(DBG_FUNC,("+IrUsb_CreateDeviceExt() \n"));

    pThisDev = NewDevice();

    if( !pThisDev )  
	{
         ntStatus = STATUS_INSUFFICIENT_RESOURCES;
         goto done;
    }

    *DeviceExt = pThisDev;

done:
    DEBUGMSG(DBG_FUNC,("-IrUsb_CreateDeviceExt() \n"));
    return ntStatus;
}


/*****************************************************************************
*
*  Function:	IrUsb_AddDevice
*
*  Synopsis:    This routine is called to create and initialize our Functional Device Object (FDO).
*				For monolithic drivers, this is done in DriverEntry(), but Plug and Play devices
*				wait for a PnP event
*
*  Arguments:	DeviceExt - receives ptr to new dev obj
*	
*  Returns:		STATUS_SUCCESS if successful,
*				STATUS_UNSUCCESSFUL otherwise
*
*  Notes:
*
*****************************************************************************/
NTSTATUS
IrUsb_AddDevice(
		IN OUT PIR_DEVICE *DeviceExt
	)
{
    NTSTATUS ntStatus;
    
    DEBUGMSG( DBG_FUNC,("+IrUsb_AddDevice()\n"));

    *DeviceExt = NULL;
	ntStatus = IrUsb_CreateDeviceExt( DeviceExt );

    DEBUGMSG( DBG_FUNC,("-IrUsb_AddDevice() (%x)\n", ntStatus));
    return ntStatus;
}


/*****************************************************************************
*
*  Function:	IrUsb_GetDongleCaps
*
*  Synopsis:	We need to manually set the data in the class specific descriptor, since
*				our device does not support the automatic-read feature
*
*  Arguments:	pThisDev - pointer to IR device
*	
*  Returns:		STATUS_SUCCESS if successful
*				STATUS_UNSUCCESSFUL otherwise
*
*  Notes:
*
*****************************************************************************/
NTSTATUS
IrUsb_GetDongleCaps( 
		IN OUT PIR_DEVICE pThisDev 
	)
{
    IRUSB_CLASS_SPECIFIC_DESCRIPTOR *pDesc = &(pThisDev->ClassDesc);
    NTSTATUS						ntStatus = STATUS_SUCCESS;
	NDIS_HANDLE						ConfigurationHandle;

	//
	// Make sure the cose is only executed at init time
	//
	if( pDesc->ClassConfigured )
	{
		return STATUS_SUCCESS;
	}
	
	pDesc->ClassConfigured = TRUE;

	//
	// Some is hardwired, some are read from the registry
	//
	NdisOpenConfiguration(
			&ntStatus,
			&ConfigurationHandle,
			pThisDev->WrapperConfigurationContext
		);

	//
	// Turnaroud time (read from the registry)
	//
	if( NT_SUCCESS(ntStatus) ) 
	{
		NDIS_STRING Keyword = NDIS_STRING_CONST("MinTurnTime");
		PNDIS_CONFIGURATION_PARAMETER pParameterValue;
		
		NdisReadConfiguration(
				&ntStatus,
				&pParameterValue,
				ConfigurationHandle,
				&Keyword,
				NdisParameterInteger 
			);

		if( NT_SUCCESS(ntStatus) ) 
		{
			switch( pParameterValue->ParameterData.IntegerData )
			{
				case 500:
					pDesc->bmMinTurnaroundTime = BM_TURNAROUND_TIME_0p5ms;
					break;
				case 1000:
					pDesc->bmMinTurnaroundTime = BM_TURNAROUND_TIME_1ms;
					break;
				case 5000:
					pDesc->bmMinTurnaroundTime = BM_TURNAROUND_TIME_5ms;
					break;
				case 10000:
					pDesc->bmMinTurnaroundTime = BM_TURNAROUND_TIME_10ms;
					break;
				default:
					pDesc->bmMinTurnaroundTime = BM_TURNAROUND_TIME_0ms;
					break;
			}
		}

		//
		// Speed mask (read from the registry)
		//
		if( NT_SUCCESS(ntStatus) ) 
		{
			NDIS_STRING Keyword = NDIS_STRING_CONST("SpeedEnable");
			PNDIS_CONFIGURATION_PARAMETER pParameterValue;
		
			NdisReadConfiguration(
					&ntStatus,
					&pParameterValue,
					ConfigurationHandle,
					&Keyword,
					NdisParameterInteger 
				);

			if( NT_SUCCESS(ntStatus) ) 
			{
				switch( pParameterValue->ParameterData.IntegerData )
				{
					case SPEED_2400:
						pThisDev->BaudRateMask = NDIS_IRDA_SPEED_MASK_2400;
						break;
					case SPEED_9600:
						pThisDev->BaudRateMask = NDIS_IRDA_SPEED_MASK_9600;
						break;
					case SPEED_19200:
						pThisDev->BaudRateMask = NDIS_IRDA_SPEED_MASK_19200;
						break;
					case SPEED_38400:
						pThisDev->BaudRateMask = NDIS_IRDA_SPEED_MASK_38400;
						break;
					case SPEED_57600:
						pThisDev->BaudRateMask = NDIS_IRDA_SPEED_MASK_57600;
						break;
					case SPEED_115200:
						pThisDev->BaudRateMask = NDIS_IRDA_SPEED_MASK_115200;
						break;
					case SPEED_576000:
						pThisDev->BaudRateMask = NDIS_IRDA_SPEED_MASK_576K;
						break;
					case SPEED_1152000:
						pThisDev->BaudRateMask = NDIS_IRDA_SPEED_MASK_1152K;
						break;
					case SPEED_4000000:
						pThisDev->BaudRateMask = NDIS_IRDA_SPEED_MASK_4M;
						break;
					default:
						pThisDev->BaudRateMask = NDIS_IRDA_SPEED_MASK_4M;
						break;
				}
			}
		}

		//
		// Read the tranceiver type
		//
		if( NT_SUCCESS(ntStatus) ) 
		{
			NDIS_STRING Keyword = NDIS_STRING_CONST("TransceiverType");
			PNDIS_CONFIGURATION_PARAMETER pParameterValue;
		
			NdisReadConfiguration(
					&ntStatus,
					&pParameterValue,
					ConfigurationHandle,
					&Keyword,
					NdisParameterInteger 
				);

			if( NT_SUCCESS(ntStatus) ) 
			{
				switch( pParameterValue->ParameterData.IntegerData )
				{
					case TRANSCEIVER_INFINEON:
						pThisDev->TransceiverType = TRANSCEIVER_INFINEON;
						break;
					case TRANSCEIVER_VISHAY:
						pThisDev->TransceiverType = TRANSCEIVER_VISHAY;
						break;
					case TRANSCEIVER_4000:
						pThisDev->TransceiverType = TRANSCEIVER_4000;
						break;
					case TRANSCEIVER_4012:
					default:
						pThisDev->TransceiverType = TRANSCEIVER_4012;
						break;
				}
			}
			else
			{
				//
				// Force a default anyway
				//
				pThisDev->TransceiverType = TRANSCEIVER_4012;
				ntStatus = STATUS_SUCCESS;

			}
		}

		//
		// And the receive window
		//
		if( NT_SUCCESS(ntStatus) )
		{
			if( pThisDev->ChipRevision == CHIP_REVISION_7 ) 
			{
				NDIS_STRING Keyword = NDIS_STRING_CONST("ReceiveWindow");
				PNDIS_CONFIGURATION_PARAMETER pParameterValue;
			
				NdisReadConfiguration(
						&ntStatus,
						&pParameterValue,
						ConfigurationHandle,
						&Keyword,
						NdisParameterInteger 
					);

				if( NT_SUCCESS(ntStatus) ) 
				{
					switch( pParameterValue->ParameterData.IntegerData )
					{
						case 2:
							pDesc->bmWindowSize = BM_WINDOW_SIZE_2;
							break;
						case 1:
						default:
							pDesc->bmWindowSize = BM_WINDOW_SIZE_1;
							break;
					}
				}
				else
				{
					//
					// Force a default anyway
					//
					pDesc->bmWindowSize = BM_WINDOW_SIZE_1;
					ntStatus = STATUS_SUCCESS;

				}
			}
#if defined(SUPPORT_LA8) && !defined(LEGACY_NDIS5)
			else if( pThisDev->ChipRevision == CHIP_REVISION_8 ) 
			{
				pDesc->bmWindowSize = BM_WINDOW_SIZE_2;
			}
#endif
			else
			{
				pDesc->bmWindowSize = BM_WINDOW_SIZE_1;
			}
		}

		//
		// temporary stuff Fix!
		//
		/*if( NT_SUCCESS(ntStatus) )
		{
			NDIS_STRING Keyword = NDIS_STRING_CONST("SirDpll");
			PNDIS_CONFIGURATION_PARAMETER pParameterValue;
			NTSTATUS DumStatus;
		
			NdisReadConfiguration(
					&DumStatus,
					&pParameterValue,
					ConfigurationHandle,
					&Keyword,
					NdisParameterInteger 
				);
			pThisDev->SirDpll = pParameterValue->ParameterData.IntegerData;
		}

		if( NT_SUCCESS(ntStatus) )
		{
			NDIS_STRING Keyword = NDIS_STRING_CONST("FirDpll");
			PNDIS_CONFIGURATION_PARAMETER pParameterValue;
			NTSTATUS DumStatus;
		
			NdisReadConfiguration(
					&DumStatus,
					&pParameterValue,
					ConfigurationHandle,
					&Keyword,
					NdisParameterInteger 
				);
			pThisDev->FirDpll = pParameterValue->ParameterData.IntegerData;
		}

		if( NT_SUCCESS(ntStatus) )
		{
			NDIS_STRING Keyword = NDIS_STRING_CONST("SirSensitivity");
			PNDIS_CONFIGURATION_PARAMETER pParameterValue;
			NTSTATUS DumStatus;
		
			NdisReadConfiguration(
					&DumStatus,
					&pParameterValue,
					ConfigurationHandle,
					&Keyword,
					NdisParameterInteger 
				);
			pThisDev->SirSensitivity = pParameterValue->ParameterData.IntegerData;
		}

		if( NT_SUCCESS(ntStatus) )
		{
			NDIS_STRING Keyword = NDIS_STRING_CONST("FirSensitivity");
			PNDIS_CONFIGURATION_PARAMETER pParameterValue;
			NTSTATUS DumStatus;
		
			NdisReadConfiguration(
					&DumStatus,
					&pParameterValue,
					ConfigurationHandle,
					&Keyword,
					NdisParameterInteger 
				);
			pThisDev->FirSensitivity = pParameterValue->ParameterData.IntegerData;
		}*/

		NdisCloseConfiguration( ConfigurationHandle );

	}

	if( NT_SUCCESS(ntStatus) ) 
	{
		// Maximum data size
		pDesc->bmDataSize = BM_DATA_SIZE_2048;

		// Speed
		pDesc->wBaudRate = NDIS_IRDA_SPEED_MASK_4M;
#if defined(WORKAROUND_BROKEN_MIR)
		pDesc->wBaudRate &= (~NDIS_IRDA_SPEED_1152K & ~NDIS_IRDA_SPEED_576K);
#endif

		// Extra BOFs
		pDesc->bmExtraBofs = BM_EXTRA_BOFS_24;
	}

	return ntStatus;
}


/*****************************************************************************
*
*  Function:	IrUsb_SetDongleCaps
*
*  Synopsis:    Set the DONGLE_CAPABILITIES struct in our device from the information
*				we have already gotten from the USB Class-Specific descriptor.
*				Some data items are usable directly as formatted in the Class-Specific descriptor,
*				but some need to be translated  to a different format for OID_xxx use;
*				The donglecaps struct is thus used to hold the info in a form
*				usable directly by OID_xxx 's.
*
*  Arguments:	pThisDev - pointer to IR device
*	
*  Returns:		None
*
*  Notes:		
*
*****************************************************************************/
VOID 
IrUsb_SetDongleCaps( 
		IN OUT PIR_DEVICE pThisDev 
	)
{
    DONGLE_CAPABILITIES					*pCaps = &(pThisDev->dongleCaps);
    IRUSB_CLASS_SPECIFIC_DESCRIPTOR		*pDesc = &(pThisDev->ClassDesc);

    DEBUGMSG( DBG_FUNC,("+IrUsb_SetDongleCaps\n"));  

    DEBUGMSG( DBG_FUNC, (" IrUsb_SetDongleCaps() RAW ClassDesc BUFFER:\n"));
    IRUSB_DUMP( DBG_FUNC,( (PUCHAR) pDesc, 12 ) );

    //
	// Deal with the turnaround time
	//
	switch( pDesc->bmMinTurnaroundTime ) 
    {

        case BM_TURNAROUND_TIME_0ms:
            pCaps->turnAroundTime_usec = 0;
            break;

        case BM_TURNAROUND_TIME_0p01ms:  
            pCaps->turnAroundTime_usec = 10; //device tells us millisec; we store as microsec
            break;

        case BM_TURNAROUND_TIME_0p05ms:
            pCaps->turnAroundTime_usec = 50; 
            break;

        case BM_TURNAROUND_TIME_0p1ms:
            pCaps->turnAroundTime_usec = 100; 
            break;

        case BM_TURNAROUND_TIME_0p5ms:
            pCaps->turnAroundTime_usec = 500; 
            break;

        case BM_TURNAROUND_TIME_1ms:
            pCaps->turnAroundTime_usec = 1000; 
            break;

        case BM_TURNAROUND_TIME_5ms:
            pCaps->turnAroundTime_usec = 5000;
            break;

        case BM_TURNAROUND_TIME_10ms:
            pCaps->turnAroundTime_usec = 10000;
            break;

        default:
            IRUSB_ASSERT( 0 ); // we should have covered all the cases here
            pCaps->turnAroundTime_usec = 1000;
    }

	//
    // We probably support many window sizes and will have multiple of these bits set;
    // Just save the biggest we support for now to tell ndis
	//
    if( pDesc->bmWindowSize & BM_WINDOW_SIZE_7 )  
            pCaps->windowSize = 7;
    else if(  pDesc->bmWindowSize & BM_WINDOW_SIZE_6 )
            pCaps->windowSize = 6;
    else if(  pDesc->bmWindowSize & BM_WINDOW_SIZE_5 )
            pCaps->windowSize = 5;
    else if(  pDesc->bmWindowSize & BM_WINDOW_SIZE_4 )
            pCaps->windowSize = 4;
    else if(  pDesc->bmWindowSize & BM_WINDOW_SIZE_3 )
            pCaps->windowSize = 3;
    else if(  pDesc->bmWindowSize & BM_WINDOW_SIZE_2 )
            pCaps->windowSize = 2;
    else if(  pDesc->bmWindowSize & BM_WINDOW_SIZE_1 )
            pCaps->windowSize = 1;
    else 
	{
		IRUSB_ASSERT( 0 ); // we should have covered all the cases here
		pCaps->windowSize = 1;
    }

    //
	// Extra BOFS
	//
	switch( (USHORT)pDesc->bmExtraBofs )
    {

        case BM_EXTRA_BOFS_0:
            pCaps->extraBOFS = 0;
            break;

        case BM_EXTRA_BOFS_1:          
            pCaps->extraBOFS = 1;
            break;

        case BM_EXTRA_BOFS_2:          
            pCaps->extraBOFS = 2;
            break;

        case BM_EXTRA_BOFS_3:          
            pCaps->extraBOFS = 3;
            break;

        case BM_EXTRA_BOFS_6:          
            pCaps->extraBOFS = 6;
            break;

        case BM_EXTRA_BOFS_12:         
            pCaps->extraBOFS = 12;
            break;

        case BM_EXTRA_BOFS_24:         
            pCaps->extraBOFS = 24;
            break;

        case BM_EXTRA_BOFS_48:         
            pCaps->extraBOFS = 48;
            break;

        default:
            IRUSB_ASSERT( 0 ); // we should have covered all the cases here
            pCaps->extraBOFS = 0;
    }

	//
    // We probably support many data sizes and will have multiple of these bits set;
    // Just save biggest we support for now to tell ndis
	//
    if( pDesc->bmDataSize & BM_DATA_SIZE_2048 )  
            pCaps->dataSize = 2048;
    else if(  pDesc->bmDataSize & BM_DATA_SIZE_1024 )
            pCaps->dataSize = 1024;
    else if(  pDesc->bmDataSize & BM_DATA_SIZE_512 )
            pCaps->dataSize = 512;
    else if(  pDesc->bmDataSize & BM_DATA_SIZE_256 )
            pCaps->dataSize = 256;
    else if(  pDesc->bmDataSize & BM_DATA_SIZE_128 )
            pCaps->dataSize = 128;
    else if(  pDesc->bmDataSize & BM_DATA_SIZE_64 )
            pCaps->dataSize = 64;
    else
	{
		IRUSB_ASSERT( 0 ); // we should have covered all the cases here
		pCaps->dataSize = 2048;
    }

	pDesc->wBaudRate &= pThisDev->BaudRateMask;  // mask defaults to 0xffff; may be set in registry

	//
    // max frame size is 2051; max irda dataSize should be 2048
	//
    IRUSB_ASSERT( MAX_TOTAL_SIZE_WITH_ALL_HEADERS > pCaps->dataSize);

    DEBUGMSG( DBG_FUNC,(" IrUsb_SetDongleCaps pCaps->turnAroundTime_usec = dec %d\n",pCaps->turnAroundTime_usec));
    DEBUGMSG( DBG_FUNC,("   extraBOFS = dec %d\n",pCaps->extraBOFS));
    DEBUGMSG( DBG_FUNC,("   dataSize = dec %d\n",pCaps->dataSize));
    DEBUGMSG( DBG_FUNC,("   windowSize = dec %d\n",pCaps->windowSize)); 
    DEBUGMSG( DBG_FUNC,("   MAX_TOTAL_SIZE_WITH_ALL_HEADERS == dec %d\n",MAX_TOTAL_SIZE_WITH_ALL_HEADERS)); 

    DEBUGMSG( DBG_FUNC,("   pDesc->bmDataSize = 0x%02x\n",pDesc->bmDataSize));
    DEBUGMSG( DBG_FUNC,("   pDesc->bmWindowSize = 0x%02x\n",pDesc->bmWindowSize));
    DEBUGMSG( DBG_FUNC,("   pDesc->bmMinTurnaroundTime = 0x%02x\n",pDesc->bmMinTurnaroundTime));
    DEBUGMSG( DBG_FUNC,("   pDesc->wBaudRate = 0x%04x\n",pDesc->wBaudRate));
    DEBUGMSG( DBG_FUNC,("   pDesc->bmExtraBofs = 0x%02x\n",pDesc->bmExtraBofs));

    DEBUGMSG( DBG_FUNC,("-IrUsb_SetDongleCaps\n")); 
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\net\irda\sigmatel\sys\diagsioctl.h ===
/**************************************************************************************************************************
 *  DIAGSIOCTL.H SigmaTel STIR4200 diagnostic IOCTL definitions
 **************************************************************************************************************************
 *  (C) Unpublished Copyright of Sigmatel, Inc. All Rights Reserved.
 *
 *
 *		Created: 05/12/2000 
 *			Version 0.94
 *		Edited: 05/24/2000 
 *			Version 0.96
 *	
 *
 **************************************************************************************************************************/

#ifndef DIAGSIOCTL_H
#define DIAGSIOCTL_H

//
// Diagnostic operation codes
//
#define DIAGS_ENABLE			0
#define DIAGS_DISABLE			1
#define DIAGS_READ_REGISTERS	2
#define DIAGS_WRITE_REGISTER	3
#define DIAGS_BULK_OUT			4
#define DIAGS_BULK_IN			5
#define DIAGS_SEND				6
#define DIAGS_RECEIVE			7
#define DIAGS_GET_SPEED			8
#define DIAGS_SET_SPEED			9

//
// Read Register structure
//
typedef struct _DIAGS_READ_REGISTERS_IOCTL
{
	USHORT DiagsCode;
	UCHAR FirstRegister;
	UCHAR NumberRegisters;
	UCHAR pRegisterBuffer[1];
} DIAGS_READ_REGISTERS_IOCTL, *PDIAGS_READ_REGISTERS_IOCTL;

typedef struct _IR_REG
{
	UCHAR RegNum;
	UCHAR RegVal;
} IR_REG, *PIR_REG;

//
// Bulk structure 
//
typedef struct _DIAGS_BULK_IOCTL
{
	USHORT DiagsCode;
	USHORT DataSize;
	UCHAR pData[1];
} DIAGS_BULK_IOCTL, *PDIAGS_BULK_IOCTL;

//
// Send structure
//
typedef struct _DIAGS_SEND_IOCTL
{
	USHORT DiagsCode;
	USHORT ExtraBOFs;
	USHORT DataSize;
	UCHAR pData[1];
} DIAGS_SEND_IOCTL, *PDIAGS_SEND_IOCTL;

//
// Receive structure
//
typedef struct _DIAGS_RECEIVE_IOCTL
{
	USHORT DiagsCode;
	USHORT DataSize;
	UCHAR pData[1];
} DIAGS_RECEIVE_IOCTL, *PDIAGS_RECEIVE_IOCTL;

//
// Speed get/set structure
//
typedef struct _DIAGS_SPEED_IOCTL
{
	USHORT DiagsCode;
	ULONG Speed;
} DIAGS_SPEED_IOCTL, *PDIAGS_SPEED_IOCTL;

#define FILE_DEVICE_STIRUSB			0x8000

#define IOCTL_PROTOCOL_DIAGS		CTL_CODE(FILE_DEVICE_STIRUSB, 0 , METHOD_BUFFERED, FILE_ANY_ACCESS)

#endif DIAGSIOCTL_H

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\net\irda\sigmatel\sys\irusb.h ===
/**************************************************************************************************************************
 *  IRUSB.H SigmaTel STIR4200 USB specific definitions
 **************************************************************************************************************************
 *  (C) Unpublished Copyright of Sigmatel, Inc. All Rights Reserved.
 *
 *
 *		Created: 04/06/2000 
 *			Version 0.9
 *		Edited: 04/27/2000 
 *			Version 0.92
 *		Edited: 08/09/2000 
 *			Version 1.02
 *	
 *
 **************************************************************************************************************************/


#ifndef USB_H
#define USB_H

//
// Send and Read/Write register structure 
// Most of the buffers have been moved to IRCOMMON.H and made global to save memory
// This will only work if the main thread is serialized 
//
typedef struct _IRUSB_CONTEXT {
    PIR_DEVICE		pThisDev;
	PVOID			pPacket;
    PIRP			pIrp;
	LIST_ENTRY		ListEntry;			// This will be used to do the queueing
	LARGE_INTEGER	TimeReceived;		// For enforcing turnaround time
	CONTEXT_TYPE	ContextType;		// To gear up/down
} IRUSB_CONTEXT, *PIRUSB_CONTEXT, **PPIRUSB_CONTEXT;


typedef struct _IRUSB_USB_INFO
{
    // USB configuration handle and ptr for the configuration the
    // device is currently in
    USBD_CONFIGURATION_HANDLE UsbConfigurationHandle;
	PUSB_CONFIGURATION_DESCRIPTOR UsbConfigurationDescriptor;

	PIRP IrpSubmitUrb;
	PIRP IrpSubmitIoCtl;

    // ptr to the USB device descriptor
    // for this device
    PUSB_DEVICE_DESCRIPTOR UsbDeviceDescriptor;

    // we support one interface
    // this is a copy of the info structure
    // returned from select_configuration or
    // select_interface
    PUSBD_INTERFACE_INFORMATION UsbInterface;

	// urb for control descriptor request
	struct _URB_CONTROL_DESCRIPTOR_REQUEST DescriptorUrb;

	// urb to use for control/status requests to USBD
	struct _URB_CONTROL_VENDOR_OR_CLASS_REQUEST ClassUrb;
} IRUSB_USB_INFO, *PIRUSB_USB_INFO;


//
// Prototypes
//
NTSTATUS
UsbIoCompleteControl(
		IN PDEVICE_OBJECT pUsbDevObj,
		IN PIRP           pIrp,
		IN PVOID          Context
    );

NTSTATUS 
MyIoCallDriver(
		IN PIR_DEVICE pThisDev,
		IN PDEVICE_OBJECT pDeviceObject,
		IN OUT PIRP pIrp
	);

NTSTATUS
IrUsb_CallUSBD(
		IN PIR_DEVICE pThisDev,
		IN PURB pUrb
	);

NTSTATUS
IrUsb_ResetUSBD(
		IN PIR_DEVICE pThisDev,
		BOOLEAN ForceUnload
    );

BOOLEAN
IrUsb_CancelIo(
		IN PIR_DEVICE pThisDev,
		IN PIRP pIrpToCancel,
		IN PKEVENT pEventToClear
    );

NTSTATUS
IrUsb_SelectInterface(
		IN OUT PIR_DEVICE pThisDev,
		IN PUSB_CONFIGURATION_DESCRIPTOR pConfigurationDescriptor
    );

NTSTATUS 
MyKeWaitForSingleObject( 
		IN PIR_DEVICE pThisDev,
		IN PVOID pEventWaitingFor,
		IN OUT PIRP pIrpWaitingFor,
		LONGLONG timeout100ns
	);


#endif // USB_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\net\irda\sigmatel\sys\irndis.h ===
/**************************************************************************************************************************
 *  IRNDIS.H SigmaTel STIR4200 ndis standard entry point definitions
 **************************************************************************************************************************
 *  (C) Unpublished Copyright of Sigmatel, Inc. All Rights Reserved.
 *
 *
 *		Created: 04/06/2000 
 *			Version 0.9
 *		Edited: 04/27/2000 
 *			Version 0.92
 *		Edited: 05/03/2000 
 *			Version 0.93
 *		Edited: 05/24/2000 
 *			Version 0.96
 *		Edited: 08/09/2000 
 *			Version 1.02
 *		Edited: 09/16/2000 
 *			Version 1.03
 *		Edited: 09/25/2000 
 *			Version 1.10
 *		Edited: 11/09/2000 
 *			Version 1.12
 *	
 *
 **************************************************************************************************************************/

#ifndef IRNDIS_H
#define IRNDIS_H


//
// NDIS version compatibility.
//
#define NDIS_MAJOR_VERSION 5  
#define NDIS_MINOR_VERSION 0

#define DRIVER_MAJOR_VERSION 1  
#define DRIVER_MINOR_VERSION 20


//
// Externs for required NDIS-dependent miniport export functions
//
VOID 
StIrUsbHalt(
		IN NDIS_HANDLE MiniportAdapterContext
	);

NDIS_STATUS 
StIrUsbInitialize(
		OUT PNDIS_STATUS    OpenErrorStatus,
		OUT PUINT           SelectedMediumIndex,
		IN  PNDIS_MEDIUM    MediumArray,
		IN  UINT            MediumArraySize,
		IN  NDIS_HANDLE     MiniportAdapterHandle,
		IN  NDIS_HANDLE     WrapperConfigurationContext
	);

NDIS_STATUS 
StIrUsbQueryInformation(
		IN  NDIS_HANDLE MiniportAdapterContext,
		IN  NDIS_OID    Oid,
		IN  PVOID       InformationBuffer,
		IN  ULONG       InformationBufferLength,
		OUT PULONG      BytesWritten,
		OUT PULONG      BytesNeeded
    );

VOID
StIrUsbSendPackets(
		IN NDIS_HANDLE  MiniportAdapterContext,
		IN PPNDIS_PACKET  PacketArray,
		IN UINT  NumberOfPackets
	);

NDIS_STATUS 
StIrUsbSend(
		IN NDIS_HANDLE  MiniportAdapterContext,
		IN PNDIS_PACKET Packet,
		IN UINT         Flags
	);

NDIS_STATUS 
StIrUsbSetInformation(
		IN  NDIS_HANDLE MiniportAdapterContext,
		IN  NDIS_OID    Oid,
		IN  PVOID       InformationBuffer,
		IN  ULONG       InformationBufferLength,
		OUT PULONG      BytesRead,
		OUT PULONG      BytesNeeded
	);

VOID StIrUsbReturnPacket(
		IN OUT NDIS_HANDLE MiniportAdapterContext,
		IN OUT PNDIS_PACKET Packet
	);

VOID
IrUsb_CommonShutdown(
		IN OUT PIR_DEVICE pThisDev,
		BOOLEAN KillPassiveThread
	);

NDIS_STATUS 
StIrUsbReset(
		OUT PBOOLEAN    AddressingReset,
		IN  NDIS_HANDLE MiniportAdapterContext
	);

BOOLEAN
StIrUsbCheckForHang(
		IN NDIS_HANDLE MiniportAdapterContext
    );

NTSTATUS
StIrUsbDispatch(
		IN PDEVICE_OBJECT DeviceObject,
		IN PIRP Irp
	);

NTSTATUS
StIrUsbCreate(
		IN PDEVICE_OBJECT DeviceObject,
		IN PIRP Irp
	);

NTSTATUS
StIrUsbClose(
		IN PDEVICE_OBJECT DeviceObject,
		IN PIRP Irp
	);

VOID
ResetIrDevice(
		IN PIR_WORK_ITEM pWorkItem
	);

VOID
RestoreIrDevice(
		IN PIR_WORK_ITEM pWorkItem
	);

VOID
SuspendIrDevice(
		IN PIR_WORK_ITEM pWorkItem
	);

VOID
ResumeIrDevice(
		IN PIR_WORK_ITEM pWorkItem
	);

PIR_DEVICE
NewDevice();

NTSTATUS
IrUsb_StartDevice(
		IN PIR_DEVICE pThisDev
    );

NTSTATUS
IrUsb_StopDevice(
		IN PIR_DEVICE pThisDev
    );

NTSTATUS
IrUsb_AddDevice(
		IN OUT PIR_DEVICE *DeviceExt
    );

NTSTATUS
IrUsb_CreateDeviceExt(
		IN OUT PIR_DEVICE *DeviceExt
    );

NTSTATUS
IrUsb_ConfigureDevice(
		IN OUT PIR_DEVICE pThisDev
    );

VOID
IrUsb_CancelPendingIo(
		IN OUT PIR_DEVICE pThisDev
    );

NDIS_STATUS 
InitializeDevice(
		IN OUT PIR_DEVICE pThisDev
	);

VOID 
DeinitializeDevice(
		IN OUT PIR_DEVICE pThisDev
	);

NDIS_STATUS 
UsbOpen(
		IN PIR_DEVICE pThisDev
	);

NDIS_STATUS 
UsbClose(
		IN PIR_DEVICE pThisDev
	);

VOID 
FreeDevice(
		IN OUT PIR_DEVICE pThisDev
	);

PNDIS_IRDA_PACKET_INFO  
GetPacketInfo(
		IN PNDIS_PACKET pPacket
	);

#endif IRNDIS_H

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\net\irda\sigmatel\sys\irusb.c ===
/**************************************************************************************************************************
 *  IRUSB.C SigmaTel STIR4200 main module (contains main NDIS entry points)
 **************************************************************************************************************************
 *  (C) Unpublished Copyright of Sigmatel, Inc. All Rights Reserved.
 *
 *
 *		Created: 04/06/2000 
 *			Version 0.9
 *		Edited: 04/24/2000 
 *			Version 0.91
 *		Edited: 04/27/2000 
 *			Version 0.92
 *		Edited: 05/03/2000 
 *			Version 0.93
 *		Edited: 05/12/2000 
 *			Version 0.94
 *		Edited: 05/19/2000 
 *			Version 0.95
 *		Edited: 05/24/2000 
 *			Version 0.96
 *		Edited: 08/22/2000 
 *			Version 1.02
 *		Edited: 09/25/2000 
 *			Version 1.10
 *		Edited: 10/13/2000 
 *			Version 1.11
 *		Edited: 11/13/2000 
 *			Version 1.12
 *		Edited: 12/29/2000 
 *			Version 1.13
 *	
 *
 **************************************************************************************************************************/

#define DOBREAKS    // enable debug breaks

#include <ndis.h>
#include <ntddndis.h>  // defines OID's

#include <usbdi.h>
#include <usbdlib.h>

#include "debug.h"
#include "ircommon.h"
#include "irusb.h"
#include "irndis.h"
#include "diags.h"

//
// Diagnostic global variables
//
#if defined(DIAGS)
NDIS_HANDLE hSavedWrapper;
PIR_DEVICE pGlobalDev;
#endif

//
// Mark the DriverEntry function to run once during initialization.
//
NDIS_STATUS DriverEntry( PDRIVER_OBJECT DriverObject, PUNICODE_STRING RegistryPath );
#pragma NDIS_INIT_FUNCTION( DriverEntry )

/*****************************************************************************
*
*  Function:   DriverEntry
*
*  Synopsis:   register driver entry functions with NDIS
*
*  Arguments:  DriverObject - the driver object being initialized
*              RegistryPath - registry path of the driver
*
*  Returns:    value returned by NdisMRegisterMiniport
*
*  Algorithm:
*
*
*  Notes:
*
*  This routine runs at IRQL PASSIVE_LEVEL.
*
*****************************************************************************/
NDIS_STATUS
DriverEntry(
		IN PDRIVER_OBJECT pDriverObject,
		IN PUNICODE_STRING pRegistryPath
	)
{
    NDIS_STATUS status = NDIS_STATUS_SUCCESS;
    NDIS50_MINIPORT_CHARACTERISTICS characteristics;
    NDIS_HANDLE hWrapper;

    DEBUGMSG(DBG_FUNC, ("+DriverEntry(IrUsb)\n"));
    DEBUGMSG( DBG_FUNC ,(" Entering IRUSB DriverEntry(), pRegistryPath=\n    %ws\n", pRegistryPath->Buffer ));

    NdisMInitializeWrapper(
			&hWrapper,
			pDriverObject,
			pRegistryPath,
			NULL
		);

#if defined(DIAGS)
	hSavedWrapper = hWrapper;
#endif

    DEBUGMSG(DBG_FUNC, (" DriverEntry(IrUsb) called NdisMInitializeWrapper()\n"));

    NdisZeroMemory(
			&characteristics,
			sizeof(NDIS50_MINIPORT_CHARACTERISTICS)
		);

    characteristics.MajorNdisVersion        =    (UCHAR)NDIS_MAJOR_VERSION;
    characteristics.MinorNdisVersion        =    (UCHAR)NDIS_MINOR_VERSION;
    characteristics.Reserved                =    0;

    characteristics.HaltHandler             =    StIrUsbHalt;
    characteristics.InitializeHandler       =    StIrUsbInitialize;
    characteristics.QueryInformationHandler =    StIrUsbQueryInformation;
    characteristics.SetInformationHandler   =    StIrUsbSetInformation;
    characteristics.ResetHandler            =    StIrUsbReset;

    //
    // For now we will allow NDIS to send only one packet at a time.
    //
	characteristics.SendHandler				=    StIrUsbSend;
    characteristics.SendPacketsHandler      =    StIrUsbSendPackets;

    //
    // We don't use NdisMIndicateXxxReceive function, so we will
    // need a ReturnPacketHandler to retrieve our packet resources.
    //
    characteristics.ReturnPacketHandler     =    StIrUsbReturnPacket;
    characteristics.TransferDataHandler     =    NULL;

    //
    // NDIS never calls the ReconfigureHandler.
    //
    characteristics.ReconfigureHandler      =    NULL;
    characteristics.CheckForHangHandler     =	 StIrUsbCheckForHang;

    //
    // This miniport driver does not handle interrupts.
    //
    characteristics.HandleInterruptHandler  =    NULL;
    characteristics.ISRHandler              =    NULL;
    characteristics.DisableInterruptHandler =    NULL;
    characteristics.EnableInterruptHandler  =    NULL;

    //
    // This miniport does not control a busmaster DMA with
    // NdisMAllocateShareMemoryAsysnc, AllocateCompleteHandler won't be
    // called from NDIS.
    //
    characteristics.AllocateCompleteHandler =    NULL;

    DEBUGMSG(DBG_FUNC, (" DriverEntry(IrUsb) initted locks and events\n"));
    DEBUGMSG(DBG_FUNC, (" DriverEntry(IrUsb) about to NdisMRegisterMiniport()\n"));

    status = NdisMRegisterMiniport(
			hWrapper,
			&characteristics,
			sizeof(NDIS50_MINIPORT_CHARACTERISTICS)
        );

    DEBUGMSG(DBG_FUNC, (" DriverEntry(IrUsb) after NdisMRegisterMiniport() status 0x%x\n", status));
    DEBUGMSG(DBG_WARN, ("-DriverEntry(IrUsb) status = 0x%x\n", status));

    return status;
}


/*****************************************************************************
*
*  Function:   StIrUsbInitialize
*
*  Synopsis:   Initializes the device (usbd.sys) and allocates all resources
*              required to carry out 'network' io operations.
*
*  Arguments:  OpenErrorStatus - allows StIrUsbInitialize to return additional
*                                status code NDIS_STATUS_xxx if returning
*                                NDIS_STATUS_OPEN_FAILED
*              SelectedMediumIndex - specifies to NDIS the medium type the
*                                    driver uses
*              MediumArray - array of NdisMediumXXX the driver can choose
*              MediumArraySize
*              MiniportAdapterHandle - handle identifying miniport's NIC
*              WrapperConfigurationContext - used with Ndis config and init
*                                            routines
*
*  Returns:    NDIS_STATUS_SUCCESS if properly configure and resources allocated
*              NDIS_STATUS_FAILURE, otherwise
*							 
*							 more specific failures:
*              NDIS_STATUS_UNSUPPORTED_MEDIA - driver can't support any medium
*              NDIS_STATUS_ADAPTER_NOT_FOUND - NdisOpenConfiguration or
*                                              NdisReadConfiguration failed
*              NDIS_STATUS_OPEN_FAILED       - failed to open serial.sys
*              NDIS_STATUS_NOT_ACCEPTED      - serial.sys does not accept the
*                                              configuration
*              NDIS_STATUS_RESOURCES         - could not claim sufficient
*                                              resources
*
*
*  Notes:      NDIS will not submit requests until this is complete.
*
*  This routine runs at IRQL PASSIVE_LEVEL.
*
*****************************************************************************/
NDIS_STATUS
StIrUsbInitialize(
		OUT PNDIS_STATUS OpenErrorStatus,
		OUT PUINT        SelectedMediumIndex,
		IN  PNDIS_MEDIUM MediumArray,
		IN  UINT         MediumArraySize,
		IN  NDIS_HANDLE  NdisAdapterHandle,
		IN  NDIS_HANDLE  WrapperConfigurationContext
	)
{
    UINT i;
    PIR_DEVICE pThisDev = NULL;
    NDIS_STATUS status = NDIS_STATUS_SUCCESS;
    NTSTATUS ntStatus = STATUS_SUCCESS;
    PDEVICE_OBJECT pPhysicalDeviceObject = NULL;
    PDEVICE_OBJECT pNextDeviceObject = NULL;
#if defined(DIAGS)
	UNICODE_STRING SymbolicLinkName;
	UNICODE_STRING DeviceName;
    PDEVICE_OBJECT pDeviceObject;
    PDRIVER_DISPATCH MajorFunction[IRP_MJ_MAXIMUM_FUNCTION+1];
#endif

    DEBUGMSG(DBG_WARN, ("+StIrUsbInitialize\n"));

    //
    // Search for the irda medium in the medium array.
    //
    for( i = 0; i < MediumArraySize; i++ )
    {
        if( MediumArray[i] == NdisMediumIrda )
        {
            break;
        }
    }
    if( i < MediumArraySize )
    {
        *SelectedMediumIndex = i;
    }
    else
    {
        //
        // Irda medium not found.
        //
        DEBUGMSG(DBG_ERROR, (" Failure: NdisMediumIrda not found!\n"));
        status = NDIS_STATUS_UNSUPPORTED_MEDIA;

		//
		// Log the error
		//
        NdisWriteErrorLogEntry(
				NdisAdapterHandle,
				NDIS_STATUS_UNSUPPORTED_MEDIA,
				1,
				status
			);

        goto done;
    }

	//
	// This will connect to a specific bus
	//
	NdisMGetDeviceProperty(
			NdisAdapterHandle,
			&pPhysicalDeviceObject,
			NULL,
			&pNextDeviceObject,
			NULL,
			NULL
		);

	IRUSB_ASSERT( pPhysicalDeviceObject );
	IRUSB_ASSERT( pNextDeviceObject );

    DEBUGMSG( 
			DBG_OUT,
			("NdisMGetDeviceProperty PDO 0x%x,Next DO 0x%x\n",
			pPhysicalDeviceObject, pNextDeviceObject)
		);

    //
    // Allocate a functional device object.
    //
    ntStatus = IrUsb_AddDevice( &pThisDev );

    IRUSB_ASSERT( pThisDev );

    if( (ntStatus != STATUS_SUCCESS) || (pThisDev == NULL) )
    {
		//
		// Log the error
		//
        NdisWriteErrorLogEntry(
				NdisAdapterHandle,
				NDIS_STATUS_RESOURCES,
				1,
				ntStatus
			);

        DEBUGMSG(DBG_ERROR, (" IrUsb_AddDevice() FAILED.\n"));
        status = NDIS_STATUS_RESOURCES;
        goto done;
    }

    pThisDev->pUsbDevObj = pNextDeviceObject;
    pThisDev->pPhysDevObj = pPhysicalDeviceObject;

    //
    // Initialize device object and resources.
    // All the queues and buffer/packets etc. are allocated here.
    //
    status = InitializeDevice( pThisDev );
    if( status != NDIS_STATUS_SUCCESS )
    {
		//
		// Log the error
		//
        NdisWriteErrorLogEntry(
				NdisAdapterHandle,
				NDIS_STATUS_RESOURCES,
				1,
				status
			);

        DEBUGMSG(DBG_ERROR, (" InitializeDevice failed. Returned 0x%.8x\n", status));
        status = NDIS_STATUS_RESOURCES;
        goto done;
    }

    //
    // Record the NdisAdapterHandle.
    //
    pThisDev->hNdisAdapter = NdisAdapterHandle;
	
    //
    // NdisMSetAttributes will associate our adapter handle with the wrapper's
    // adapter handle.  The wrapper will then always use our handle
    // when calling us.  We use a pointer to the device object as the context.
    //
    NdisMSetAttributesEx(
			NdisAdapterHandle,
			(NDIS_HANDLE)pThisDev,
			0,
			NDIS_ATTRIBUTE_DESERIALIZE,
			NdisInterfaceInternal
		);

	//
    // Now we're ready to do our own startup processing.
    // USB client drivers such as us set up URBs (USB Request Packets) to send requests
    // to the host controller driver (HCD). The URB structure defines a format for all
    // possible commands that can be sent to a USB device.
    // Here, we request the device descriptor and store it,
    // and configure the device.
    // In USB, no special  HW processing is required to 'open'  or 'close' the pipes
	//
	pThisDev->WrapperConfigurationContext = WrapperConfigurationContext;
	ntStatus = IrUsb_StartDevice( pThisDev );

    if( ntStatus != STATUS_SUCCESS )
    {
		//
		// Log the error
		//
        NdisWriteErrorLogEntry(
				pThisDev->hNdisAdapter,
				NDIS_STATUS_ADAPTER_NOT_FOUND,
				1,
				ntStatus
			);

        DEBUGMSG(DBG_ERROR, (" IrUsb_StartDevice FAILED. Returned 0x%.8x\n", ntStatus));
        status = NDIS_STATUS_ADAPTER_NOT_FOUND;
        goto done;
    }

    //
    // Create an irp and begin our receives.
    // NOTE: All other receive processing will be done in the read completion
    //       routine  and PollingThread  started therein.
    //
    status = InitializeProcessing( pThisDev, TRUE );

    if( status != NDIS_STATUS_SUCCESS )
    {
		//
		// Log the error
		//
        NdisWriteErrorLogEntry(
				pThisDev->hNdisAdapter,
				NDIS_STATUS_RESOURCES,
				1,
				status
			);

        DEBUGMSG(DBG_ERROR, (" InitializeProcessing failed. Returned 0x%.8x\n", status));
        status = NDIS_STATUS_RESOURCES;
        goto done;
    }

	//
	// Initialize the diagnostic portion
	//
#if defined(DIAGS)
	NdisZeroMemory( MajorFunction, sizeof(PDRIVER_DISPATCH)*(IRP_MJ_MAXIMUM_FUNCTION+1) );
	
	RtlInitUnicodeString( &SymbolicLinkName, L"\\DosDevices\\Stirusb" );
    RtlInitUnicodeString( &DeviceName, L"\\Device\\Stirusb" );

	MajorFunction[IRP_MJ_CREATE] = StIrUsbCreate;
    MajorFunction[IRP_MJ_CLOSE] = StIrUsbClose;
	MajorFunction[IRP_MJ_DEVICE_CONTROL] = StIrUsbDispatch;

	NdisMRegisterDevice(
			hSavedWrapper,
			&DeviceName,
			&SymbolicLinkName,
			MajorFunction,
			&pDeviceObject,
			&pThisDev->NdisDeviceHandle
		);
	pGlobalDev = pThisDev;
#endif

done:
    if( status != NDIS_STATUS_SUCCESS )
    {
        if( pThisDev != NULL )
        {
            DeinitializeDevice( pThisDev );
            FreeDevice( pThisDev );
        }
    }

    if( status!=NDIS_STATUS_SUCCESS )
    {
        DEBUGMSG(DBG_ERR, (" IrUsb: StIrUsbInitialize failed %x\n", status));
    }
    else
    {
        DEBUGMSG(DBG_ERR, (" IrUsb: StIrUsbInitialize SUCCESS %x\n", status));

    }

    DEBUGMSG(DBG_FUNC, ("-StIrUsbInitialize\n"));
    return status;
}

/*****************************************************************************
*
*  Function:   StIrUsbHalt
*
*  Synopsis:   Deallocates resources when the NIC is removed and halts the
*              device.
*
*  Arguments:  Context - pointer to the ir device object
*
*  Returns:	   None
*
*  Algorithm:  Mirror image of StIrUsbInitialize...undoes everything initialize
*              did.
*  Notes:
*
*  This routine runs at IRQL PASSIVE_LEVEL.
*
*  BUGBUG: Could StIrUsbReset fail and then StIrUsbHalt be called. If so, we need
*          to chech validity of all the pointers, etc. before trying to
*          deallocate.
*
*****************************************************************************/
VOID
StIrUsbHalt(
		IN NDIS_HANDLE Context
	)
{
    PIR_DEVICE pThisDev;
    NTSTATUS ntstatus;

    DEBUGMSG(DBG_WARN, ("+StIrUsbHalt\n")); // change to FUNC later?

    pThisDev = CONTEXT_TO_DEV( Context );

	if( TRUE == pThisDev->fPendingHalt ) 
	{
		DEBUGMSG(DBG_ERR, (" StIrUsbHalt called with halt already pending\n"));
		IRUSB_ASSERT( 0 );
		goto done;
	}

    //
    // Let the send completion and receive completion routine know that there
    // is a pending reset.
    //
    pThisDev->fPendingHalt = TRUE;

    IrUsb_CommonShutdown( pThisDev, TRUE );  //shutdown logic common to halt and reset; see below

	//
	// We had better not have left any pending read, write, or control IRPS hanging out there!
	//
	IRUSB_ASSERT( 0 == pThisDev->PendingIrpCount );

	if ( 0 != pThisDev->PendingIrpCount ) 
	{
		DEBUGMSG(DBG_ERR, (" StIrUsbHalt WE LEFT %d PENDING IRPS!!!!!\n", pThisDev->PendingIrpCount));
	}

	IRUSB_ASSERT( FALSE == pThisDev->fSetpending );
	IRUSB_ASSERT( FALSE == pThisDev->fQuerypending );

	//
	// Destroy diags
	//
#if defined(DIAGS)
	NdisMDeregisterDevice( pThisDev->NdisDeviceHandle );
#endif

    //
    // Free our own IR device object.
    //
    FreeDevice( pThisDev );

done:
	DEBUGMSG(DBG_ERR, (" StIrUsbHalt HALT complete\n"));
    DEBUGMSG(DBG_WARN, ("-StIrUsbHalt\n")); // change to FUNC later?
}


/*****************************************************************************
*
*  Function:	IrUsb_CommonShutdown
*	
*  Synopsis:	Deallocates resources when the NIC is removed and halts the
*				device. This is stuff common to IrUsbHalt and IrUsbReset and is called by both
*
*  Arguments:	pThisDev - pointer to IR device
*				KillPassiveThread - determines whether we need to kill the passive thread
*
*  Returns:		None
*
*  Algorithm:	Mirror image of IrUsbInitialize...undoes everything initialize
*				did.
*
*  Notes:
*
*  This routine runs at IRQL PASSIVE_LEVEL.
*
*
*****************************************************************************/
VOID
IrUsb_CommonShutdown(
		IN OUT PIR_DEVICE pThisDev,
		BOOLEAN KillPassiveThread
	)
{
	DEBUGMSG(DBG_WARN, ("+IrUsb_CommonShutdown\n")); //chg to FUNC later?

	//
	// Stop processing and sleep 50 milliseconds.
	//
	InterlockedExchange( (PLONG)&pThisDev->fProcessing, FALSE );
	NdisMSleep( 50000 );

	//
	// Kill the passive thread
	//
	if( KillPassiveThread )
	{
		DEBUGMSG(DBG_WARN, (" IrUsb_CommonShutdown About to Kill PassiveLevelThread\n"));
		pThisDev->fKillPassiveLevelThread = TRUE;
		KeSetEvent(&pThisDev->EventPassiveThread, 0, FALSE);

		while( pThisDev->hPassiveThread != NULL )
		{
			//
			// Sleep 50 milliseconds.
			//
			NdisMSleep( 50000 );
		}

		DEBUGMSG(DBG_WARN, (" passive thread killed\n"));
	}

	//
	// Kill the polling thread
	//
	DEBUGMSG(DBG_WARN, (" IrUsb_CommonShutdown About to kill Polling thread\n"));
	pThisDev->fKillPollingThread = TRUE;

	while( pThisDev->hPollingThread != NULL )
	{
		//
		// Sleep 50 milliseconds.
		//
		NdisMSleep( 50000 );
	}

	IRUSB_ASSERT( pThisDev->packetsHeldByProtocol == 0 );
	DEBUGMSG( DBG_WARN, (" Polling thread killed\n") );

	//
	// Sleep 50 milliseconds so pending io might finish normally
	//
	NdisMSleep( 50000 );    

	DEBUGMSG(DBG_WARN, (" IrUsb_CommonShutdown About to IrUsb_CancelPendingIo()\n"));

	//
	// Cancel any outstandig IO we may have
	//
	IrUsb_CancelPendingIo( pThisDev );

	//
	// Deinitialize our own ir device object.
	//
	DeinitializeDevice( pThisDev );

	pThisDev->fDeviceStarted = FALSE;

	DEBUGMSG(DBG_WARN, ("-IrUsb_CommonShutdown\n")); //chg to FUNC later?
}


/*****************************************************************************
*
*  Function:   StIrUsbReset
*
*  Synopsis:   Resets the drivers software state.
*
*  Arguments:  AddressingReset - return arg. If set to TRUE, NDIS will call
*                                MiniportSetInformation to restore addressing
*                                information to the current values.
*              Context         - pointer to ir device object
*
*  Returns:    NDIS_STATUS_PENDING
*
*
*  Notes:
*
*
*****************************************************************************/
NDIS_STATUS
StIrUsbReset(
		OUT PBOOLEAN AddressingReset,
		IN NDIS_HANDLE MiniportAdapterContext
	)
{
    PIR_DEVICE pThisDev;
    NDIS_STATUS status = NDIS_STATUS_PENDING;

    DEBUGMSG(DBG_WARN, ("+StIrUsbReset\n"));  // CHANGE TO FUNC?

    pThisDev = CONTEXT_TO_DEV( MiniportAdapterContext );

	if( TRUE == pThisDev->fPendingReset ) 
	{
		DEBUGMSG(DBG_ERROR, (" StIrUsbReset called with reset already pending\n"));

		status = NDIS_STATUS_RESET_IN_PROGRESS ;
		goto done;
	}

    //
    // Let the send completion and receive completion routine know that there
    // is a pending reset.
    //
    pThisDev->fPendingReset = TRUE;
	InterlockedExchange( (PLONG)&pThisDev->fProcessing, FALSE );
    *AddressingReset = TRUE;

	if( FALSE == ScheduleWorkItem( pThisDev, ResetIrDevice, NULL, 0) )
	{
		status = NDIS_STATUS_FAILURE;
	}

 done:
    DEBUGMSG(DBG_WARN, ("-StIrUsbReset\n"));  // change to FUNC later?
    return status;
}


/*****************************************************************************
*
*  Function:    StIrUsbCheckForHang
*
*  Synopsis:    Makes sure the device/driver operating state is correct
*
*  Arguments:   Context - pointer to ir device object
*
*  Returns:     TRUE - driver is hung
*				FALSE - otherwise
*
*  Notes:
*
*
*****************************************************************************/
BOOLEAN
StIrUsbCheckForHang(
		IN NDIS_HANDLE MiniportAdapterContext
    )
{
    PIR_DEVICE pThisDev;

    pThisDev = CONTEXT_TO_DEV( MiniportAdapterContext );

	/*if( pThisDev->fPendingClearTotalStall )
	{
		DEBUGMSG(DBG_ERROR, (" StIrUsbCheckForHang USB hang, will ask for a reset\n"));
		return TRUE;
	}
	else*/
		return FALSE;
}


/*****************************************************************************
*
*  Function:	SuspendIrDevice
*
*  Synopsis:	Callback for a going into suspend mode
*
*  Arguments:	pWorkItem - pointer to the reset work item
*
*  Returns:		None
*
*  Notes:
*
*****************************************************************************/
VOID
SuspendIrDevice(
		IN PIR_WORK_ITEM pWorkItem
	)
{
	PIR_DEVICE		pThisDev = (PIR_DEVICE)pWorkItem->pIrDevice;
	NTSTATUS		Status = STATUS_SUCCESS;

	//
	// We no longer need the work item
	//
	FreeWorkItem( pWorkItem );

	//
	// Now cancel everything that's pending, after a little time to complete
	//
	NdisMSleep( 100*1000 );
	DEBUGMSG(DBG_ERROR, (" SuspendIrDevice(), cancelling pending IRPs\n"));
	IrUsb_CancelPendingIo( pThisDev );

	//
	// Prepare the part
	//
#if defined(SUPPORT_LA8)
	if( pThisDev->ChipRevision >= CHIP_REVISION_8 )
	{
		Status = St4200EnableOscillatorPowerDown( pThisDev );
		if( Status == STATUS_SUCCESS )
		{
			Status = St4200TurnOnSuspend( pThisDev );
		}
	}
#endif

	//
	// Tell the OS
	//
	if( pThisDev->fQuerypending )
		MyNdisMQueryInformationComplete( pThisDev, Status );
}


/*****************************************************************************
*
*  Function:	ResumeIrDevice
*
*  Synopsis:	Callback for a going out of suspend mode
*
*  Arguments:	pWorkItem - pointer to the reset work item
*
*  Returns:		None
*
*  Notes:
*
*****************************************************************************/
VOID
ResumeIrDevice(
		IN PIR_WORK_ITEM pWorkItem
	)
{
	PIR_DEVICE		pThisDev = (PIR_DEVICE)pWorkItem->pIrDevice;

	//
	// We no longer need the work item
	//
	FreeWorkItem( pWorkItem );
	
	//
	// Get the device back up and running
	//
#if defined(SUPPORT_LA8)
	if( pThisDev->ChipRevision >= CHIP_REVISION_8 )
	{
		St4200TurnOffSuspend( pThisDev );
	}
#endif
	St4200SetSpeed( pThisDev );
	InterlockedExchange( (PLONG)&pThisDev->currentSpeed, pThisDev->linkSpeedInfo->BitsPerSec );
	InterlockedExchange( (PLONG)&pThisDev->fProcessing, TRUE );
}


/*****************************************************************************
*
*  Function:	RestoreIrDevice
*
*  Synopsis:	Callback for a on-the-fly reset
*
*  Arguments:	pWorkItem - pointer to the reset work item
*
*  Returns:		None
*
*  Notes:
*
*****************************************************************************/
VOID
RestoreIrDevice(
		IN PIR_WORK_ITEM pWorkItem
	)
{
	NDIS_STATUS		status = STATUS_SUCCESS;
	PIR_DEVICE		pThisDev = (PIR_DEVICE)pWorkItem->pIrDevice;
	UINT			CurrentSpeed, i;

    DEBUGMSG(DBG_WARN, ("+RestoreIrDevice\n")); 

	DEBUGMSG(DBG_ERROR, (" RestoreIrDevice USB hang, resetting\n"));

	//
	// We no longer need the work item
	//
	FreeWorkItem( pWorkItem );

	//
	// Give a little time to complete
	//
	NdisMSleep( 100*1000 );

	//
	// Force a reset on the USB bus
	//
	status = IrUsb_ResetUSBD( pThisDev, FALSE );
    if( status != NDIS_STATUS_SUCCESS )
    {
        //IrUsb_ResetUSBD( pThisDev, TRUE );
		pThisDev->fDeviceStarted =  FALSE;
		InterlockedExchange( (PLONG)&pThisDev->fProcessing, FALSE );
		DEBUGMSG(DBG_ERROR, (" RestoreIrDevice() IrUsb_ResetUSBD failed. Returned 0x%.8x\n", status));
        goto done;
    }

	//
	// Save the current speed
	//
	CurrentSpeed = pThisDev->currentSpeed;

	//
	// Shutdown the device
	//
    DEBUGMSG(DBG_WARN, (" RestoreIrDevice() about to call IrUsb_CommonShutdown()\n")); // change to FUNC later?
	IrUsb_CommonShutdown( pThisDev, FALSE );  //shutdown logic common to halt and reset; see above
    DEBUGMSG(DBG_WARN, (" RestoreIrDevice() after IrUsb_CommonShutdown()\n")); // change to FUNC later?
	
	//
	// Destroy and create again the USB portion of the device
	//
    DEBUGMSG(DBG_WARN, (" RestoreIrDevice() about to refresh USB info\n")); // change to FUNC later?
	FreeUsbInfo( pThisDev );

	if( !AllocUsbInfo( pThisDev ) )
	{
        DEBUGMSG(DBG_ERROR, (" RestoreIrDevice() AllocUsbInfo failed\n"));
        goto done;
	}

    DEBUGMSG(DBG_WARN, (" RestoreIrDevice() after refreshing USB info\n")); // change to FUNC later?

	//
	// Reinitialize the device
	//
    DEBUGMSG(DBG_WARN, (" RestoreIrDevice() about to call InitializeDevice()\n")); // change to FUNC later?
	status = InitializeDevice( pThisDev );  

    if( status != NDIS_STATUS_SUCCESS )
    {
        DEBUGMSG(DBG_ERROR, (" RestoreIrDevice() InitializeDevice failed. Returned 0x%.8x\n", status));
        goto done;
    }

    DEBUGMSG(DBG_WARN, (" RestoreIrDevice() InitializeProcessing() SUCCESS, about to call InitializeReceive()\n")); // change to FUNC later?

	//
	// Restart it
	//
	status = IrUsb_StartDevice( pThisDev );

    if( status != STATUS_SUCCESS )
    {
        DEBUGMSG(DBG_ERROR, (" RestoreIrDevice() IrUsb_StartDevice failed. Returned 0x%.8x\n", status));
        goto done;
    }

    //
    // Keep a pointer to the link speed which was previously set
    //
    for( i = 0; i < NUM_BAUDRATES; i++ )
    {
        if( supportedBaudRateTable[i].BitsPerSec == CurrentSpeed )
        {
            pThisDev->linkSpeedInfo = &supportedBaudRateTable[i]; 

            break; //for
        }
    }

	//
	// restore the old speed
	//
	DEBUGMSG( DBG_ERR, (" Restoring speed to: %d\n", pThisDev->linkSpeedInfo->BitsPerSec));
	status = St4200SetSpeed( pThisDev );
    if( status != STATUS_SUCCESS )
    {
        DEBUGMSG(DBG_ERROR, (" RestoreIrDevice() St4200SetSpeed failed. Returned 0x%.8x\n", status));
        goto done;
    }
	InterlockedExchange( (PLONG)&pThisDev->currentSpeed, CurrentSpeed );

    //
    // Initialize receive loop.
    //
    status = InitializeProcessing( pThisDev, FALSE );

    if( status != NDIS_STATUS_SUCCESS )
    {
        DEBUGMSG(DBG_ERROR, (" RestoreIrDevice() InitializeProcessing failed. Returned 0x%.8x\n", status));
        goto done;
    }

done:
    DEBUGCOND(DBG_ERROR, (status != NDIS_STATUS_SUCCESS), (" RestoreIrDevice failed = 0x%.8x\n", status));
}


/*****************************************************************************
*
*  Function:	ResetIrDevice
*
*  Synopsis:	Callback for StIrUsbReset
*
*  Arguments:	pWorkItem - pointer to the reset work item
*
*  Returns:		None
*
*  Notes:
*
*  The following elements of the ir device object outlast the reset:
*
*      pUsbDevObj
*      hNdisAdapter
*
*****************************************************************************/
VOID
ResetIrDevice(
		IN PIR_WORK_ITEM pWorkItem
	)
{
	NDIS_STATUS		status = STATUS_SUCCESS;
	PIR_DEVICE		pThisDev = (PIR_DEVICE)pWorkItem->pIrDevice;

    DEBUGMSG(DBG_WARN, ("+ResetIrDevice\n")); // change to FUNC later?

	//
	// We no longer need the work item
	//
	FreeWorkItem( pWorkItem );

	//
	// Now cancel everything that's pending, after a little time to complete
	//
	NdisMSleep( 100*1000 );
	DEBUGMSG(DBG_ERROR, (" ResetIrDevice(), cancelling pending IRPs\n"));
	IrUsb_CancelPendingIo( pThisDev );
	
	//
	// reset the part
	//
	status = IrUsb_ResetUSBD( pThisDev, FALSE );
    if( status != STATUS_SUCCESS )
    {
		pThisDev->fDeviceStarted =  FALSE;
		//
		// Log the error
		//
        NdisWriteErrorLogEntry(
				pThisDev->hNdisAdapter,
				NDIS_STATUS_ADAPTER_NOT_FOUND,
				1,
				status
			);

        DEBUGMSG(DBG_ERROR, (" ResetIrDevice() IrUsb_ResetUSBD failed. Returned 0x%.8x\n", status));
        status = NDIS_STATUS_ADAPTER_NOT_FOUND;
        goto done;
    }
 
	//
	// Shutdown the device
	//
    DEBUGMSG(DBG_WARN, (" ResetIrDevice() about to call IrUsb_CommonShutdown()\n")); // change to FUNC later?
	IrUsb_CommonShutdown( pThisDev, FALSE );  //shutdown logic common to halt and reset; see above
    DEBUGMSG(DBG_WARN, (" ResetIrDevice() after IrUsb_CommonShutdown()\n")); // change to FUNC later?
	
	//
	// Destroy and create again the USB portion of the device
	//
    DEBUGMSG(DBG_WARN, (" ResetIrDevice() about to refresh USB info\n")); // change to FUNC later?
	FreeUsbInfo( pThisDev );

	if( !AllocUsbInfo( pThisDev ) )
	{
		//
		// Log the error
		//
        NdisWriteErrorLogEntry(
				pThisDev->hNdisAdapter,
				NDIS_STATUS_RESOURCES,
				1,
				status
			);

        DEBUGMSG(DBG_ERROR, (" ResetIrDevice() AllocUsbInfo failed\n"));
        status = NDIS_STATUS_FAILURE;
        goto done;
	}

    DEBUGMSG(DBG_WARN, (" ResetIrDevice() after refreshing USB info\n")); // change to FUNC later?

	//
	// Reinitialize the device
	//
    DEBUGMSG(DBG_WARN, (" ResetIrDevice() about to call InitializeDevice()\n")); // change to FUNC later?
	status = InitializeDevice( pThisDev );  

    if( status != NDIS_STATUS_SUCCESS )
    {
		//
		// Log the error
		//
        NdisWriteErrorLogEntry(
				pThisDev->hNdisAdapter,
				NDIS_STATUS_RESOURCES,
				1,
				status
			);

        DEBUGMSG(DBG_ERROR, (" ResetIrDevice() InitializeDevice failed. Returned 0x%.8x\n", status));
        status = NDIS_STATUS_FAILURE;
        goto done;
    }

    DEBUGMSG(DBG_WARN, (" ResetIrDevice() InitializeProcessing() SUCCESS, about to call InitializeReceive()\n")); // change to FUNC later?

	//
	// Restart it
	//
	status = IrUsb_StartDevice( pThisDev );

    if( status != STATUS_SUCCESS )
    {
		//
		// Log the error
		//
        NdisWriteErrorLogEntry(
				pThisDev->hNdisAdapter,
				NDIS_STATUS_ADAPTER_NOT_FOUND,
				1,
				status
			);

        DEBUGMSG(DBG_ERROR, (" ResetIrDevice() IrUsb_StartDevice failed. Returned 0x%.8x\n", status));
        status = NDIS_STATUS_ADAPTER_NOT_FOUND;
        goto done;
    }

    //
    // Initialize receive loop.
    //
    status = InitializeProcessing( pThisDev, FALSE );

    if( status != NDIS_STATUS_SUCCESS )
    {
		//
		// Log the error
		//
        NdisWriteErrorLogEntry(
				pThisDev->hNdisAdapter,
				NDIS_STATUS_RESOURCES,
				1,
				status
			);

        DEBUGMSG(DBG_ERROR, (" ResetIrDevice() InitializeProcessing failed. Returned 0x%.8x\n", status));
        status = NDIS_STATUS_FAILURE;
        goto done;
    }

done:
    DEBUGCOND(DBG_ERROR, (status != NDIS_STATUS_SUCCESS), (" ResetIrDevice failed = 0x%.8x\n", status));

	//
	// Deal with possible errors
	//
    if( status != STATUS_SUCCESS )
    {
        status = NDIS_STATUS_HARD_ERRORS;
    }

	NdisMResetComplete(
			pThisDev->hNdisAdapter,
			status,
			TRUE
		);

    DEBUGMSG(DBG_WARN, ("-ResetIrDevice\n")); // change to FUNC later?
}


/*****************************************************************************
*
*  Function:	GetPacketInfo
*
*  Synopsis:	Gets the IR specific information for an input packet
*
*  Arguments:	pPacket - pointer to packet
*	
*  Returns:		PNDIS_IRDA_PACKET_INFO structure for the packet
*
*  Notes:
*
*****************************************************************************/
PNDIS_IRDA_PACKET_INFO 
GetPacketInfo( 
		IN PNDIS_PACKET pPacket
	)
{
    PMEDIA_SPECIFIC_INFORMATION pMediaInfo;
    UINT                        Size;

    NDIS_GET_PACKET_MEDIA_SPECIFIC_INFO( pPacket, &pMediaInfo, &Size );

	if( Size )
		return (PNDIS_IRDA_PACKET_INFO)pMediaInfo->ClassInformation;
	else
		return NULL;
}


/*****************************************************************************
*
*  Function:	MyNdisMSetInformationComplete
*
*  Synopsis:	Call NdisMSetInformationComplete()
*
*  Arguments:	pThisDev - pointer to IR device
*				Status - status to signal
*	
*  Returns:		None
*
*  Notes:		
*
*****************************************************************************/
VOID 
MyNdisMSetInformationComplete(
		IN PIR_DEVICE pThisDev,
		IN NDIS_STATUS Status
	)
{
    DEBUGMSG( DBG_FUNC,("+MyNdisMSetInformationComplete\n"));

    NdisMSetInformationComplete( (NDIS_HANDLE)pThisDev->hNdisAdapter, Status );
    pThisDev->LastSetTime.QuadPart = 0;
	pThisDev->fSetpending = FALSE;

    DEBUGMSG( DBG_FUNC,("-MyNdisMSetInformationComplete\n"));
}


/*****************************************************************************
*
*  Function:	MyNdisMQueryInformationComplete
*
*  Synopsis:	Call NdisMQueryInformationComplete()
*
*  Arguments:	pThisDev - pointer to IR device
*				Status - status to signal
*	
*  Returns:		None
*
*  Notes:		
*
*****************************************************************************/
VOID 
MyNdisMQueryInformationComplete(
		IN PIR_DEVICE pThisDev,
		IN NDIS_STATUS Status
	)
{
    DEBUGMSG( DBG_FUNC,("+MyNdisMQueryInformationComplete\n"));

    NdisMQueryInformationComplete( (NDIS_HANDLE)pThisDev->hNdisAdapter, Status );
    pThisDev->LastQueryTime.QuadPart = 0;
	pThisDev->fQuerypending = FALSE;

    DEBUGMSG( DBG_FUNC,("-MyNdisMQueryInformationComplete\n"));
}


/*****************************************************************************
*
*  Function:	IndicateMediaBusy
*
*  Synopsis:	Call NdisMIndicateStatus()
*
*  Arguments:	pThisDev - pointer to IR device
*	
*  Returns:		None
*
*  Notes:
*
*****************************************************************************/
VOID 
IndicateMediaBusy(
		IN PIR_DEVICE pThisDev
	)

{
    DEBUGMSG( DBG_FUNC,("+IndicateMediaBusy\n"));

    NdisMIndicateStatus(
		   pThisDev->hNdisAdapter,
		   NDIS_STATUS_MEDIA_BUSY,
		   NULL,
		   0
       );

    NdisMIndicateStatusComplete(
		   pThisDev->hNdisAdapter,
       );

#if DBG
	pThisDev->NumMediaBusyIndications ++;
#endif
#if !defined(ONLY_ERROR_MESSAGES)
    DEBUGMSG(DBG_ERR, (" IndicateMediaBusy()\n"));
#endif

    DEBUGMSG( DBG_FUNC,("-IndicateMediaBusy\n"));
}


/*****************************************************************************
*
*  Function:   StIrUsbSendPackets
*
*  Synopsis:   Send a packet to the USB driver and add the sent irp and io context to
*              To the pending send queue; this que is really just needed for possible later error cancellation
*
*
*  Arguments:  MiniportAdapterContext	- pointer to current ir device object
*              PacketArray				- pointer to array of packets to send
*              NumberOfPackets          - number of packets in the array
*
*  Returns:    VOID
*
*	Notes: This routine does nothing but calling StIrUsbSend
*
*
*****************************************************************************/
VOID
StIrUsbSendPackets(
		IN NDIS_HANDLE  MiniportAdapterContext,
		IN PPNDIS_PACKET  PacketArray,
		IN UINT  NumberOfPackets
	)
{
	ULONG i;

	//
    // This is a great opportunity to be lazy.  
    // Just call StIrUsbSend with each packet  
    // in sequence and set the result in the 
    // packet array object.                      
	//
    for( i=0; i<NumberOfPackets; i++ )
    {
        StIrUsbSend( MiniportAdapterContext, PacketArray[i], 0 );
    }
}


/*****************************************************************************
*
*  Function:   StIrUsbSend
*
*  Synopsis:   Send a packet to the USB driver and add the sent irp and io context to
*              To the pending send queue; this que is really just needed for possible later error cancellation
*
*
*  Arguments:  MiniportAdapterContext - pointer to current ir device object
*              pPacketToSend          - pointer to packet to send
*              Flags                  - any flags set by protocol
*
*  Returns:    NDIS_STATUS_PENDING - This is generally what we should
*                                    return. We will call NdisMSendComplete
*                                    when the USB driver completes the
*                                    send.
*
*  Unsupported returns:
*              NDIS_STATUS_SUCCESS  - We should never return this since
*                                     results will always be pending from
*                                     the USB driver.
*              NDIS_STATUS_RESOURCES - This indicates to the protocol that the
*                                      device currently has no resources to complete
*                                      the request. The protocol will resend
*                                      the request when it receives either
*                                      NdisMSendResourcesAvailable or
*                                      NdisMSendComplete from the device.
*
*	Notes: This routine delegates all the real work to SendPacketPreprocess in send.c
*
*
*****************************************************************************/
NDIS_STATUS
StIrUsbSend(
		IN NDIS_HANDLE  MiniportAdapterContext,
		IN PNDIS_PACKET pPacketToSend,
		IN UINT         Flags
	)
{
	PIR_DEVICE		pThisDev = (PIR_DEVICE)MiniportAdapterContext;
	NDIS_STATUS		Status;

	DEBUGMSG( DBG_FUNC,("+StIrUsbSend()\n"));

    //
	// Make sure we are in the proper status, i.e. we are processing
	// and no diagnostics are active
	//
#if defined(DIAGS)
	if( !pThisDev->fProcessing || pThisDev->DiagsPendingActivation )
#else
	if( !pThisDev->fProcessing )
#endif
	{
		Status = NDIS_STATUS_FAILURE;
		goto done;
	}

	//
	// Send the packet to the hardware
	//
    NDIS_SET_PACKET_STATUS( pPacketToSend, NDIS_STATUS_PENDING );
	Status = SendPacketPreprocess( 
			pThisDev,
			pPacketToSend
		);

done:
	//
	// If the operation didn't pend we have to complete
	// We are really bouncing the packets...
	//
	if( Status != NDIS_STATUS_PENDING )
	{
		NdisMSendComplete(
				pThisDev->hNdisAdapter,
				pPacketToSend,
				NDIS_STATUS_SUCCESS 
			);
	}

	DEBUGMSG( DBG_FUNC,("-StIrUsbSend()\n"));
	return Status;
}


// Diagnostic entry points

#if defined(DIAGS)

/*****************************************************************************
*
*  Function:	StIrUsbDispatch
*
*  Synopsis:	Processes the diagnostic Irps
*	
*  Arguments:	DeviceObject - pointer to the device object
*				Irp - pointer to the Irp
*	
*  Returns:		NT status code
*
*  Notes:
*
*****************************************************************************/
NTSTATUS
StIrUsbDispatch(
		IN PDEVICE_OBJECT DeviceObject,
		IN PIRP Irp
	)
{
	PIR_DEVICE			pThisDev = pGlobalDev;
    PIO_STACK_LOCATION  irpSp;
    ULONG               FunctionCode;
    NTSTATUS			status;
	PVOID				pBuffer;
	ULONG				BufferLength;
	USHORT				DiagsCode;

	DEBUGMSG( DBG_FUNC,("+StIrUsbDispatch()\n"));
    
    //
	// Get the Irp
	//
	irpSp = IoGetCurrentIrpStackLocation( Irp );

	//
	// Get the data
	//
    FunctionCode = irpSp->Parameters.DeviceIoControl.IoControlCode;
	pBuffer = Irp->AssociatedIrp.SystemBuffer;
	BufferLength = irpSp->Parameters.DeviceIoControl.InputBufferLength;
	DiagsCode = *(PUSHORT)pBuffer;

	//
	// Process the diagnostic operation
	//
	switch( FunctionCode )
	{
		case IOCTL_PROTOCOL_DIAGS:
			switch( DiagsCode )
			{
				case DIAGS_ENABLE:
					status = Diags_Enable( pThisDev );
					break;
				case DIAGS_DISABLE:
					status = Diags_Disable( pThisDev );
					break;
				case DIAGS_READ_REGISTERS:
					status = Diags_ReadRegisters( pThisDev, pBuffer, BufferLength );
					if( status == STATUS_SUCCESS )
					{
						Irp->IoStatus.Information = sizeof(DIAGS_READ_REGISTERS_IOCTL);
					}
					break;
				case DIAGS_WRITE_REGISTER:
					status = Diags_WriteRegister( pThisDev, pBuffer, BufferLength );
					break;
				case DIAGS_BULK_OUT:
					status = Diags_PrepareBulk( pThisDev, pBuffer, BufferLength, TRUE );
					break;
				case DIAGS_BULK_IN:
					status = Diags_PrepareBulk( pThisDev, pBuffer, BufferLength, FALSE );
					if( status == STATUS_SUCCESS )
					{
						PDIAGS_BULK_IOCTL pIOCTL = pThisDev->pIOCTL;
						
						Irp->IoStatus.Information = sizeof(DIAGS_BULK_IOCTL)+pIOCTL->DataSize-1;
					}
					break;
				case DIAGS_SEND:
					status = Diags_PrepareSend( pThisDev, pBuffer, BufferLength );
					break;
				case DIAGS_RECEIVE:
					status = Diags_Receive( pThisDev, pBuffer, BufferLength );
					if( status == STATUS_SUCCESS )
					{
						PDIAGS_RECEIVE_IOCTL pIOCTL = pThisDev->pIOCTL;
						
						Irp->IoStatus.Information = sizeof(DIAGS_RECEIVE_IOCTL)+pIOCTL->DataSize-1;
					}
					break;
				case DIAGS_GET_SPEED:
					status = Diags_GetSpeed( pThisDev, pBuffer, BufferLength );
					if( status == STATUS_SUCCESS )
					{
						Irp->IoStatus.Information = sizeof(DIAGS_SPEED_IOCTL);
					}
					break;
				case DIAGS_SET_SPEED:
					status = Diags_SetSpeed( pThisDev, pBuffer, BufferLength );
					break;
				default:
					status = STATUS_NOT_SUPPORTED;
					break;
			}
			break;
		default:
			status = STATUS_NOT_SUPPORTED;
			break;
	}

    //
	// Complete and return
	//
	Irp->IoStatus.Status = status;
	IoCompleteRequest( Irp, IO_NO_INCREMENT );
	DEBUGMSG( DBG_FUNC,("-StIrUsbDispatch()\n"));
    return status;
}


/*****************************************************************************
*
*  Function:	StIrUsbCreate
*
*  Synopsis:	Creates a new diagnostic object (it does nothing)
*	
*  Arguments:	DeviceObject - pointer to the device object
*				Irp - pointer to the Irp
*	
*  Returns:		NT status code
*
*  Notes:
*
*****************************************************************************/
NTSTATUS
StIrUsbCreate(
		IN PDEVICE_OBJECT DeviceObject,
		IN PIRP Irp
	)
{
 	PIR_DEVICE pThisDev = pGlobalDev;

	//
    //  Initialize list for holding pending read requests
    //
    KeInitializeSpinLock( &pThisDev->DiagsReceiveLock );
    InitializeListHead( &pThisDev->DiagsReceiveQueue );

    Irp->IoStatus.Status = STATUS_SUCCESS;
	IoCompleteRequest( Irp, IO_NO_INCREMENT );
	return STATUS_SUCCESS;
}


/*****************************************************************************
*
*  Function:	StIrUsbClose
*
*  Synopsis:	Destroys a new diagnostic object (it does nothing)
*	
*  Arguments:	DeviceObject - pointer to the device object
*				Irp - pointer to the Irp
*	
*  Returns:		NT status code
*
*  Notes:
*
*****************************************************************************/
NTSTATUS
StIrUsbClose(
		IN PDEVICE_OBJECT DeviceObject,
		IN PIRP Irp
	)
{
    Irp->IoStatus.Status = STATUS_SUCCESS;
	IoCompleteRequest( Irp, IO_NO_INCREMENT );
	return STATUS_SUCCESS;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\net\irda\sigmatel\sys\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by IrUsb.rc
//
#define IDC_CURSOR1                     104

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NO_MFC                     1
#define _APS_NEXT_RESOURCE_VALUE        105
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\net\irda\sigmatel\sys\request.c ===
/**************************************************************************************************************************
 *  REQUEST.C SigmaTel STIR4200 OID query/set module
 **************************************************************************************************************************
 *  (C) Unpublished Copyright of Sigmatel, Inc. All Rights Reserved.
 *
 *
 *		Created: 04/06/2000 
 *			Version 0.9
 *		Edited: 04/24/2000 
 *			Version 0.91
 *		Edited: 04/27/2000 
 *			Version 0.92
 *		Edited: 05/03/2000 
 *			Version 0.93
 *		Edited: 05/12/2000 
 *			Version 0.94
 *		Edited: 05/19/2000 
 *			Version 0.95
 *		Edited: 06/13/2000 
 *			Version 0.96
 *		Edited: 08/22/2000 
 *			Version 1.02
 *		Edited: 09/25/2000 
 *			Version 1.10
 *		Edited: 12/29/2000 
 *			Version 1.13
 *	
 *
 **************************************************************************************************************************/

#define DOBREAKS    // enable debug breaks

#include <ndis.h>
#include <ntddndis.h>  // defines OID's

#include <usbdi.h>
#include <usbdlib.h>

#include "debug.h"
#include "ircommon.h"
#include "irndis.h"
#include "diags.h"

//
//  These are the OIDs we support 
//
UINT supportedOIDs[] =
{
    //
    // General required OIDs.
    //
    OID_GEN_SUPPORTED_LIST,
    OID_GEN_HARDWARE_STATUS,
    OID_GEN_MEDIA_SUPPORTED,
    OID_GEN_MEDIA_IN_USE,
    OID_GEN_MAXIMUM_LOOKAHEAD,
    OID_GEN_MAXIMUM_FRAME_SIZE,
    OID_GEN_LINK_SPEED,
    OID_GEN_TRANSMIT_BUFFER_SPACE,
    OID_GEN_RECEIVE_BUFFER_SPACE,
    OID_GEN_TRANSMIT_BLOCK_SIZE,
    OID_GEN_RECEIVE_BLOCK_SIZE,
    OID_GEN_VENDOR_ID,
    OID_GEN_VENDOR_DESCRIPTION,
    OID_GEN_CURRENT_PACKET_FILTER,
    OID_GEN_CURRENT_LOOKAHEAD,
    OID_GEN_DRIVER_VERSION,
    OID_GEN_MAXIMUM_TOTAL_SIZE,
    OID_GEN_PROTOCOL_OPTIONS,
    OID_GEN_MAC_OPTIONS,
    OID_GEN_MEDIA_CONNECT_STATUS,
    OID_GEN_MAXIMUM_SEND_PACKETS,
    OID_GEN_VENDOR_DRIVER_VERSION,

    //
    // Required statistical OIDs.
    //
    OID_GEN_XMIT_OK,
    OID_GEN_RCV_OK,
    OID_GEN_XMIT_ERROR,
    OID_GEN_RCV_ERROR,
    OID_GEN_RCV_NO_BUFFER,

    //
    // Infrared-specific OIDs.
    //
    OID_IRDA_RECEIVING,
    OID_IRDA_TURNAROUND_TIME,
    OID_IRDA_SUPPORTED_SPEEDS,
    OID_IRDA_LINK_SPEED,
    OID_IRDA_MEDIA_BUSY,
    OID_IRDA_EXTRA_RCV_BOFS,
	OID_IRDA_MAX_RECEIVE_WINDOW_SIZE,		
	OID_IRDA_MAX_SEND_WINDOW_SIZE,		

    OID_PNP_CAPABILITIES,

    OID_PNP_SET_POWER,  
    OID_PNP_QUERY_POWER
    //OID_PNP_ENABLE_WAKE_UP
    //OID_PNP_ADD_WAKE_UP_PATTERN		
    //OID_PNP_REMOVE_WAKE_UP_PATTERN	
    //OID_PNP_WAKE_UP_PATTERN_LIST	
    //OID_PNP_WAKE_UP_OK		
    //OID_PNP_WAKE_UP_ERROR	
}; 


/*****************************************************************************
*
*  Function:   StIrUsbQueryInformation
*
*  Synopsis:   Queries the capabilities and status of the miniport driver.
*
*  Arguments:  MiniportAdapterContext  - miniport context area (PIR_DEVICE)
*              Oid                     - system defined OID_Xxx
*              InformationBuffer       - where to return Oid specific info
*              InformationBufferLength - specifies size of InformationBuffer
*              BytesWritten            - bytes written to InformationBuffer
*              BytesNeeded             - addition bytes required if
*                                        InformationBufferLength is less than
*                                        what the Oid requires to write
*
*  Returns:    NDIS_STATUS_SUCCESS       - success
*              NDIS_STATUS_PENDING       - will complete asynchronously and
*                                          call NdisMQueryInformationComplete
*              NDIS_STATUS_INVALID_OID   - don't recognize the Oid
*              NDIS_STATUS_INVALID_LENGTH- InformationBufferLength does not
*                                          match length for the Oid
*              NDIS_STATUS_NOT_ACCEPTED  - failure
*              NDIS_STATUS_NOT_SUPPORTED - do not support an optional Oid
*              NDIS_STATUS_RESOURCES     - failed allocation of resources
*
*  Notes:
*       See list of Supported OIDs at the top of this module in the supportedOIDs[] array
*
*
*****************************************************************************/
NDIS_STATUS
StIrUsbQueryInformation(
		IN  NDIS_HANDLE MiniportAdapterContext,
		IN  NDIS_OID    Oid,
		IN  PVOID       InformationBuffer,
		IN  ULONG       InformationBufferLength,
		OUT PULONG      BytesWritten,
		OUT PULONG      BytesNeeded
	)
{
    PIR_DEVICE      pThisDev;
    NDIS_STATUS     status;
    UINT            speeds;
    UINT            i;
    UINT            infoSizeNeeded;
    PUINT           pInfoPtr;
	PNDIS_PNP_CAPABILITIES pNdisPnpCapabilities;

    static char vendorDesc[] = "SigmaTel Usb-IrDA Dongle";

    DEBUGMSG(DBG_FUNC, ("+StIrUsbQueryInformation\n"));

    pThisDev = CONTEXT_TO_DEV( MiniportAdapterContext );

	IRUSB_ASSERT( NULL != pThisDev ); 
	IRUSB_ASSERT( NULL != BytesWritten );
	IRUSB_ASSERT( NULL != BytesNeeded );

    status = NDIS_STATUS_SUCCESS;

    KeQuerySystemTime( &pThisDev->LastQueryTime ); //used by check for hang handler
	pThisDev->fQuerypending = TRUE;

	if( (NULL == InformationBuffer) && InformationBufferLength )
	{ 
		//
		// Should be impossible but it happened on an MP system!
		//
		DEBUGMSG(DBG_ERR, (" StIrUsbQueryInformation() NULL info buffer passed!, InformationBufferLength = dec %d\n",InformationBufferLength));
		status = NDIS_STATUS_NOT_ACCEPTED;
		*BytesNeeded =0;
		*BytesWritten = 0;
		goto done;
	}

	//
    // Figure out buffer size needed.
    // Most OIDs just return a single UINT, but there are exceptions.
    //
    switch( Oid )
    {
        case OID_GEN_SUPPORTED_LIST:
            infoSizeNeeded = sizeof(supportedOIDs);
            break;

        case OID_PNP_CAPABILITIES:
            infoSizeNeeded = sizeof(NDIS_PNP_CAPABILITIES);
            break;

        case OID_GEN_DRIVER_VERSION:
            infoSizeNeeded = sizeof(USHORT);
            break;

        case OID_GEN_VENDOR_DESCRIPTION:
            infoSizeNeeded = sizeof(vendorDesc);
            break;

        case OID_IRDA_SUPPORTED_SPEEDS:
            speeds = pThisDev->ClassDesc.wBaudRate;
            for (infoSizeNeeded = 0; speeds; infoSizeNeeded += sizeof(UINT))
            {
                //
                // This instruction clears the lowest set bit in speeds.
                // Trust me.
                //
                speeds &= (speeds - 1);
            }
            break;

        default:
            infoSizeNeeded = sizeof(UINT);
            break;
    }

    //
    // If the protocol provided a large enough buffer, we can go ahead
    // and complete the query.
    //
    if( InformationBufferLength >= infoSizeNeeded )
    {
        //
        // Set default results.
        //
        *BytesWritten = infoSizeNeeded;
        *BytesNeeded = 0;

        switch( Oid )
        {
            //
            // Generic OIDs.
            //

            case OID_GEN_SUPPORTED_LIST:
                DEBUGMSG(DBG_ERR, (" StIrUsbQueryInformation(OID_GEN_SUPPORTED_LIST)\n"));
/*
                Specifies an array of OIDs for objects that the underlying
                driver or its device supports. Objects include general, media-specific,
                and implementation-specific objects.

                The underlying driver should order the OID list it returns 
                in increasing numeric order. NDIS forwards a subset of the returned 
                list to protocols that make this query. That is, NDIS filters
                any supported statistics OIDs out of the list since protocols
                never make statistics queries subsequentlly. 
*/
                NdisMoveMemory(
						InformationBuffer,
						(PVOID)supportedOIDs,
						sizeof(supportedOIDs)
					);
                break;

            case OID_GEN_HARDWARE_STATUS:
                DEBUGMSG(DBG_ERR, (" StIrUsbQueryInformation(OID_GEN_HARDWARE_STATUS)\n"));
                //
                // If we can be called with a context, then we are
                // initialized and ready.
                //
                *(UINT *)InformationBuffer = NdisHardwareStatusReady;
                break;

            case OID_GEN_MEDIA_SUPPORTED:
                DEBUGMSG(DBG_ERR, (" StIrUsbQueryInformation(OID_GEN_MEDIA_SUPPORTED)\n"));
                *(UINT *)InformationBuffer = NdisMediumIrda;
                break;

            case OID_GEN_MEDIA_IN_USE:
                DEBUGMSG(DBG_ERR, (" StIrUsbQueryInformation(OID_GEN_MEDIA_IN_USE)\n"));
                *(UINT *)InformationBuffer = NdisMediumIrda;
                break;

            case OID_GEN_TRANSMIT_BUFFER_SPACE: 
                DEBUGMSG(DBG_ERR, (" StIrUsbQueryInformation(OID_GEN_TRANSMIT_BUFFER_SPACE)\n"));
/*
                The amount of memory, in bytes, on the device available 
                for buffering transmit data.  
*/
                *(UINT *)InformationBuffer = MAX_TOTAL_SIZE_WITH_ALL_HEADERS;
                break;

            case OID_GEN_RECEIVE_BUFFER_SPACE: 
                DEBUGMSG(DBG_ERR, (" StIrUsbQueryInformation(OID_GEN_RECEIVE_BUFFER_SPACE)\n"));
/*
                The amount of memory on the device available 
                for buffering receive data.
*/
                *(UINT *)InformationBuffer = MAX_TOTAL_SIZE_WITH_ALL_HEADERS;
                break;

            case OID_GEN_TRANSMIT_BLOCK_SIZE: 
                DEBUGMSG(DBG_ERR, (" StIrUsbQueryInformation(OID_GEN_TRANSMIT_BLOCK_SIZE)\n"));
/*
                The minimum number of bytes that a single net packet 
                occupies in the transmit buffer space of the device.
                For example, on some devices the transmit space is 
                divided into 256-byte pieces so such a device's 
                transmit block size would be 256. To calculate 
                the total transmit buffer space on such a device, 
                its driver multiplies the number of transmit 
                buffers on the device by its transmit block size.

                For other devices, the transmit block size is
                identical to its maximum packet size. 
*/
                *(UINT *)InformationBuffer = pThisDev->dongleCaps.dataSize + USB_IRDA_TOTAL_NON_DATA_SIZE;
                break;

            case OID_GEN_RECEIVE_BLOCK_SIZE: 
                DEBUGMSG(DBG_ERR, (" StIrUsbQueryInformation(OID_GEN_RECEIVE_BLOCK_SIZE)\n"));
/*
                The amount of storage, in bytes, that a single packet
                occupies in the receive buffer space of the device
*/
                *(UINT *)InformationBuffer = pThisDev->dongleCaps.dataSize + USB_IRDA_TOTAL_NON_DATA_SIZE;
                break;

            case OID_GEN_MAXIMUM_LOOKAHEAD: 
                DEBUGMSG(DBG_ERR, (" StIrUsbQueryInformation(OID_GEN_MAXIMUM_LOOKAHEAD)\n"));
/*
                The maximum number of bytes the device can always provide as lookahead data.
                If the underlying driver supports multipacket receive indications,
                bound protocols are given full net packets on every indication. 
                Consequently, this value is identical to that 
                returned for OID_GEN_RECEIVE_BLOCK_SIZE. 
*/
                *(UINT *)InformationBuffer =  pThisDev->dongleCaps.dataSize + USB_IRDA_TOTAL_NON_DATA_SIZE;
                break;

            case OID_GEN_CURRENT_LOOKAHEAD: 
                DEBUGMSG(DBG_ERR, (" StIrUsbQueryInformation(OID_GEN_CURRENT_LOOKAHEAD)\n"));
/*
                The number of bytes of received packet data, 
                excluding the header, that will be indicated 
                to the protocol driver. For a query, 
                NDIS returns the largest lookahead size from 
                among all the bindings. A protocol driver can 
                set a suggested value for the number of bytes 
                to be used in its binding; however, 
                the underlying device driver is never required 
                to limit its indications to the value set. 

                If the underlying driver supports multipacket
                receive indications, bound protocols are given
                full net packets on every indication. Consequently,
                this value is identical to that returned for OID_GEN_RECEIVE_BLOCK_SIZE. 
*/
                *(UINT *)InformationBuffer = pThisDev->dongleCaps.dataSize + USB_IRDA_TOTAL_NON_DATA_SIZE;
                break;

            case OID_GEN_MAXIMUM_FRAME_SIZE:
                DEBUGMSG(DBG_ERR, (" StIrUsbQueryInformation(OID_GEN_MAXIMUM_FRAME_SIZE)\n"));
/*
                The maximum network packet size in bytes 
                the device supports, not including a header. 
                For a binding emulating another medium type, 
                the device driver must define the maximum frame 
                size in such a way that it will not transform 
                a protocol-supplied net packet of this size 
                to a net packet too large for the true network medium.
*/
                *(UINT *)InformationBuffer = pThisDev->dongleCaps.dataSize;
                break;

            case OID_GEN_MAXIMUM_TOTAL_SIZE:
                DEBUGMSG(DBG_ERR, (" StIrUsbQueryInformation(OID_GEN_MAXIMUM_TOTAL_SIZE)\n"));
/*
                The maximum total packet length, in bytes, 
                the device supports, including the header. 
                This value is medium-dependent. The returned 
                length specifies the largest packet a protocol 
                driver can pass to NdisSend or NdisSendPackets.

                For a binding emulating another media type,
                the device driver must define the maximum total 
                packet length in such a way that it will not 
                transform a protocol-supplied net packet of 
                this size to a net packet too large for the true network medium.
*/
                *(UINT *)InformationBuffer = pThisDev->dongleCaps.dataSize;  //+ USB_IRDA_TOTAL_NON_DATA_SIZE;
                break;

            case OID_IRDA_MAX_RECEIVE_WINDOW_SIZE:
                DEBUGMSG(DBG_ERR, (" StIrUsbQueryInformation(OID_IRDA_MAX_RECEIVE_WINDOW_SIZE) \n"));
                // Gotten from the device's USB Class-Specific Descriptor
                *(PUINT)InformationBuffer = pThisDev->dongleCaps.windowSize;
                break;

            case OID_IRDA_MAX_SEND_WINDOW_SIZE:
                DEBUGMSG(DBG_ERR, (" StIrUsbQueryInformation(OID_IRDA_MAX_SEND_WINDOW_SIZE) \n"));
                // Gotten from the device's USB Class-Specific Descriptor
                *(PUINT)InformationBuffer = pThisDev->dongleCaps.windowSize;
                break;

            case OID_GEN_VENDOR_ID:
                DEBUGMSG(DBG_ERR, (" StIrUsbQueryInformation(OID_GEN_VENDOR_ID)\n"));
                // we get this from our config descriptor
                *(UINT *)InformationBuffer = pThisDev->IdVendor;
                break;

            case OID_GEN_VENDOR_DESCRIPTION:
                DEBUGMSG(DBG_ERR, (" StIrUsbQueryInformation(OID_GEN_VENDOR_DESCRIPTION)\n"));
                NdisMoveMemory(
						InformationBuffer,
						(PVOID)vendorDesc,
						sizeof(vendorDesc)
					);
                break;

            case OID_GEN_LINK_SPEED:
                DEBUGMSG(DBG_ERR, (" StIrUsbQueryInformation(OID_GEN_LINK_SPEED)\n"));
                //
                // Return MAXIMUM POSSIBLE speed for this device in units
                // of 100 bits/sec.
                //
                *(UINT *)InformationBuffer = 0;
                speeds = pThisDev->ClassDesc.wBaudRate;
                *BytesWritten = 0;

                for ( i = 0; i<NUM_BAUDRATES; i++ )
                {
                    if ((supportedBaudRateTable[i].NdisCode & speeds) &&
                        ((supportedBaudRateTable[i].BitsPerSec)/100 > *(UINT *)InformationBuffer))
                    {
                        *(UINT *)InformationBuffer = supportedBaudRateTable[i].BitsPerSec/100;
                        *BytesWritten = sizeof(UINT);
                    }
                }

                DEBUGMSG(DBG_ERR, (" StIrUsbQueryInformation(OID_GEN_LINK_SPEED)  %d\n",*(UINT *)InformationBuffer));
                break;

            case OID_GEN_CURRENT_PACKET_FILTER:
                DEBUGMSG(DBG_ERR, (" StIrUsbQueryInformation(OID_GEN_CURRENT_PACKET_FILTER)\n"));
                *(UINT *)InformationBuffer = NDIS_PACKET_TYPE_PROMISCUOUS;
                break;

            case OID_GEN_DRIVER_VERSION:
                DEBUGMSG(DBG_ERR, (" StIrUsbQueryInformation(OID_GEN_DRIVER_VERSION)\n"));
                *(USHORT *)InformationBuffer = ((NDIS_MAJOR_VERSION << 8) | NDIS_MINOR_VERSION);
                break;

            case OID_GEN_PROTOCOL_OPTIONS:
                DEBUGMSG(DBG_ERR, (" StIrUsbQueryInformation(OID_GEN_PROTOCOL_OPTIONS)\n"));
                DEBUGMSG(DBG_ERR, ("This is a set-only OID\n"));
                *BytesWritten = 0;
                status = NDIS_STATUS_NOT_SUPPORTED;
                break;

            case OID_GEN_MAC_OPTIONS:
                DEBUGMSG(DBG_ERR, (" StIrUsbQueryInformation(OID_GEN_MAC_OPTIONS)\n"));
                *(UINT *)InformationBuffer = NDIS_MAC_OPTION_COPY_LOOKAHEAD_DATA | NDIS_MAC_OPTION_TRANSFERS_NOT_PEND;  
                break;

            case OID_GEN_MEDIA_CONNECT_STATUS:
                DEBUGMSG(DBG_ERR, (" StIrUsbQueryInformation(OID_GEN_MEDIA_CONNECT_STATUS)\n"));
                //
                // Since we are not physically connected to a LAN, we
                // cannot determine whether or not we are connected;
                // so always indicate that we are.
                //
                *(UINT *)InformationBuffer = NdisMediaStateConnected;
                break;

            case OID_GEN_MAXIMUM_SEND_PACKETS:
                DEBUGMSG(DBG_ERR, (" StIrUsbQueryInformation(OID_GEN_MAXIMUM_SEND_PACKETS)\n"));
								//
                //
				// The maximum number of send packets the
                // MiniportSendPackets function can accept. 
				//
                *(UINT *)InformationBuffer = NUM_SEND_CONTEXTS-3;
                break;

            case OID_GEN_VENDOR_DRIVER_VERSION:
                DEBUGMSG(DBG_ERR, (" StIrUsbQueryInformation(OID_GEN_VENDOR_DRIVER_VERSION)\n"));
                *(UINT *)InformationBuffer = ((DRIVER_MAJOR_VERSION << 16) | DRIVER_MINOR_VERSION);
                break;

            //
            // Required statistical OIDs.
            //
            case OID_GEN_XMIT_OK:
                DEBUGMSG(DBG_ERR, (" StIrUsbQueryInformation(OID_GEN_XMIT_OK)\n"));
                *(UINT *)InformationBuffer = (UINT)pThisDev->packetsSent;
                break;

            case OID_GEN_RCV_OK:
                DEBUGMSG(DBG_ERR, (" StIrUsbQueryInformation(OID_GEN_RCV_OK)\n"));
                *(UINT *)InformationBuffer = (UINT)pThisDev->packetsReceived;
                break;

            case OID_GEN_XMIT_ERROR:
                DEBUGMSG(DBG_ERR, (" StIrUsbQueryInformation(OID_GEN_XMIT_ERROR)\n"));
                *(UINT *)InformationBuffer = (UINT)(pThisDev->packetsSentDropped +
					pThisDev->packetsSentRejected + pThisDev->packetsSentInvalid );
                break;

            case OID_GEN_RCV_ERROR:
                DEBUGMSG(DBG_ERR, (" StIrUsbQueryInformation(OID_GEN_RCV_ERROR)\n"));
                *(UINT *)InformationBuffer = (UINT)(pThisDev->packetsReceivedDropped +
					pThisDev->packetsReceivedChecksum + pThisDev->packetsReceivedRunt +
					pThisDev->packetsReceivedOverflow);
                break;

            case OID_GEN_RCV_NO_BUFFER:
                DEBUGMSG(DBG_ERR, (" StIrUsbQueryInformation(OID_GEN_RCV_NO_BUFFER)\n"));
                *(UINT *)InformationBuffer = (UINT)pThisDev->packetsReceivedNoBuffer;
                break;

            //
            // Infrared OIDs.
            //
            case OID_IRDA_LINK_SPEED: 
                DEBUGMSG(DBG_ERR, (" StIrUsbQueryInformation(OID_IRDA_LINK_SPEED)\n"));
                *(UINT *)InformationBuffer = (UINT)pThisDev->currentSpeed;
				break;

            case OID_IRDA_RECEIVING:
#if !defined(ONLY_ERROR_MESSAGES)
                DEBUGMSG(DBG_ERR, (" StIrUsbQueryInformation(OID_IRDA_RECEIVING, %xh)\n",pThisDev->fCurrentlyReceiving));
#endif
                *(UINT *)InformationBuffer = (UINT)pThisDev->fCurrentlyReceiving; 
                break;

            case OID_IRDA_TURNAROUND_TIME:
                DEBUGMSG(DBG_ERR, (" StIrUsbQueryInformation(OID_IRDA_TURNAROUND_TIME)\n"));
                //
                // Time remote station must wait after receiving data from us
                // before we can receive
				//
                *(UINT *)InformationBuffer = pThisDev->dongleCaps.turnAroundTime_usec;
                break;

            case OID_IRDA_SUPPORTED_SPEEDS:
                DEBUGMSG(DBG_ERR, (" StIrUsbQueryInformation(OID_IRDA_SUPPORTED_SPEEDS)\n"));
                speeds = pThisDev->ClassDesc.wBaudRate;
                *BytesWritten = 0;

                for( i = 0, pInfoPtr = (PUINT)InformationBuffer;
                     (i < NUM_BAUDRATES) && speeds && (InformationBufferLength >= sizeof(UINT));
                     i++ )
                {
                    if( supportedBaudRateTable[i].NdisCode & speeds )
                    {
                        *pInfoPtr++ = supportedBaudRateTable[i].BitsPerSec;
                        InformationBufferLength -= sizeof(UINT);
                        *BytesWritten += sizeof(UINT);
                        speeds &= ~supportedBaudRateTable[i].NdisCode;
                        DEBUGMSG(DBG_FUNC, (" - supporting speed %d bps\n", supportedBaudRateTable[i].BitsPerSec));
                    }
                }

                if( speeds )
                {
                    //
                    // This shouldn't happen, since we checked the
                    // InformationBuffer size earlier.
                    //
                    DEBUGMSG(DBG_ERR, (" Something's wrong; previous check for buf size failed somehow\n"));

                    for( *BytesNeeded = 0; speeds; *BytesNeeded += sizeof(UINT) )
                    {
                        //
                        // This instruction clears the lowest set bit in speeds.
                        // Trust me.
                        //
                        speeds &= (speeds - 1);
                    }

                    status = NDIS_STATUS_INVALID_LENGTH;
                }
                else
                {
                    status = NDIS_STATUS_SUCCESS;
                }
                break;


            case OID_IRDA_MEDIA_BUSY:
#if !defined(ONLY_ERROR_MESSAGES)
                DEBUGMSG(DBG_ERR, (" StIrUsbQueryInformation(OID_IRDA_MEDIA_BUSY, %xh)\n", pThisDev->fMediaBusy));
#endif
/*  
    According to  W2000 ddk doc:
    The IrDA protocol driver sets this OID to zero to request the miniport to
    start monitoring for a media busy condition. The IrDA protocol 
    can then query this OID to determine whether the media is busy.
    If the media is not busy, the miniport returns a zero for this
    OID when queried. If the media is busy,that is, if the miniport
    has detected some traffic since the IrDA protocol driver last
    set OID_IRDA_MEDIA_BUSY to zero the miniport returns a non-zero
    value for this OID when queried. On detecting the media busy
    condition. the miniport must also call NdisMIndicateStatus to
    indicate NDIS_STATUS_MEDIA_BUSY. When the media is busy, 
    the IrDA protocol driver will not send packets to the miniport
    for transmission. After the miniport has detected a busy state, 
    it does not have to monitor for a media busy condition until
    the IrDA protocol driver again sets OID_IRDA_MEDIA_BUSY to zero.

    According to USB IrDA Bridge Device Definition Doc sec 5.4.1.2:

    The bmStatus field indicators shall be set by the Device as follows:
    Media_Busy
     Media_Busy shall indicate zero (0) if the Device:
    . has not received a Check Media Busy class-specific request
    . has detected no traffic on the infrared media since receiving a Check Media Busy
    . class-specific request
   . Has returned a header with Media_Busy set to one (1) since receiving a Check
      Media Busy class-specific request.
     
    Media_Busy shall indicate one (1) if the Device has detected traffic on the infrared
     media since receiving a Check Media Busy class-specific request. Note that
     Media_Busy shall indicate one (1) in exactly one header following receipt of each
     Check Media Busy class-specific request.

    According to USB IrDA Bridge Device Definition Doc sec 6.2.2:

      Check Media Busy
    This class-specific request instructs the Device to look for a media busy condition. If infrared
    traffic of any kind is detected by this Device, the Device shall set the Media_Busy field in the
    bmStatus field in the next Data-In packet header sent to the host. In the case where a Check
    Media Busy command has been received, a media busy condition detected, and no IrLAP frame
    traffic is ready to transmit to the host, the Device shall set the Media_Busy field and send it in a
    Data-In packet with no IrLAP frame following the header.

    bmRequestType   bRequest   wValue   wIndex   wLength   Data
    00100001B          3        Zero   Interface   Zero   [None]
     
*/
#if DBG
				if ( pThisDev->fMediaBusy ) 
					pThisDev->NumYesQueryMediaBusyOids++;
				else
					pThisDev->NumNoQueryMediaBusyOids++;
#endif
                *(UINT *)InformationBuffer = pThisDev->fMediaBusy; 
                status = NDIS_STATUS_SUCCESS;
                break;

            case OID_IRDA_EXTRA_RCV_BOFS:
                DEBUGMSG(DBG_ERR, (" StIrUsbQueryInformation(OID_IRDA_EXTRA_RCV_BOFS)\n"));
                //
                // Pass back the number of _extra_ BOFs to be prepended
                // to packets sent to this unit at 115.2 baud, the
                // maximum Slow IR speed. 
                // Gotten from the device's USB Class-Specific Descriptor
				//			
                *(UINT *)InformationBuffer = pThisDev->dongleCaps.extraBOFS;
                break;

            // PNP OIDs
            case OID_PNP_CAPABILITIES:
                DEBUGMSG(DBG_ERR, (" StIrUsbQueryInformation(OID_PNP_CAPABILITIES) OID %x BufLen:%d\n", Oid, InformationBufferLength));
                NdisZeroMemory( 
						InformationBuffer,
						sizeof(NDIS_PNP_CAPABILITIES)
					);
				//
				// Prepare formatting with the info
				//
				pNdisPnpCapabilities = (PNDIS_PNP_CAPABILITIES)InformationBuffer;
				pNdisPnpCapabilities->WakeUpCapabilities.MinMagicPacketWakeUp = NdisDeviceStateUnspecified;
				pNdisPnpCapabilities->WakeUpCapabilities.MinPatternWakeUp = NdisDeviceStateUnspecified;
				pNdisPnpCapabilities->WakeUpCapabilities.MinLinkChangeWakeUp = NdisDeviceStateUnspecified;
                break;

			case OID_PNP_QUERY_POWER:
				//
				// If we are asked to power down prepare to do it
				//
				switch( (NDIS_DEVICE_POWER_STATE)*(UINT *)InformationBuffer )
				{
					case NdisDeviceStateD0:
						DEBUGMSG(DBG_ERR, (" StIrUsbQueryInformation(OID_PNP_QUERY_POWER) NdisDeviceStateD0\n"));
						break;
					case NdisDeviceStateD1:
		                DEBUGMSG(DBG_ERR, (" StIrUsbQueryInformation(OID_PNP_QUERY_POWER) NdisDeviceStateD1\n"));
						//break;
					case NdisDeviceStateD2:
		                DEBUGMSG(DBG_ERR, (" StIrUsbQueryInformation(OID_PNP_QUERY_POWER) NdisDeviceStateD2\n"));
						//break;
					case NdisDeviceStateD3:
						DEBUGMSG(DBG_ERR, (" StIrUsbQueryInformation(OID_PNP_QUERY_POWER) NdisDeviceStateD3\n"));
						//
						// The processing must be essentially shut down
						//
						InterlockedExchange( (PLONG)&pThisDev->fProcessing, FALSE );
						ScheduleWorkItem( pThisDev,	SuspendIrDevice, NULL, 0 );
						//
						// This will be the new value of the DPLL register (when we come back up)
						//
						pThisDev->StIrTranceiver.DpllTuneReg = STIR4200_DPLL_DEFAULT;
						status = NDIS_STATUS_PENDING;
						break;
				}
				break;
			
            default:
                DEBUGMSG(DBG_ERR, (" StIrUsbQueryInformation(%d=0x%x), invalid OID\n", Oid, Oid));
                status = NDIS_STATUS_NOT_SUPPORTED; 
                break;
        }
    }
    else
    {
        *BytesNeeded = infoSizeNeeded - InformationBufferLength;
        *BytesWritten = 0;
        status = NDIS_STATUS_INVALID_LENGTH;
    }

done:
    if( NDIS_STATUS_PENDING != status ) 
	{
        // zero-out the time so check for hang handler knows nothing pending
        pThisDev->LastQueryTime.QuadPart = 0;
		pThisDev->fQuerypending          = FALSE;
    }

    DEBUGMSG(DBG_FUNC, ("-StIrUsbQueryInformation\n"));
    return status;
}

/*****************************************************************************
*
*  Function:   StIrUsbSetInformation
*
*  Synopsis:   StIrUsbSetInformation allows other layers of the network software
*              (e.g., a transport driver) to control the miniport driver
*              by changing information that the miniport driver maintains
*              in its OIDs, such as the packet filters or multicast addresses.
*
*  Arguments:  MiniportAdapterContext  - miniport context area (PIR_DEVICE)
*              Oid                     - system defined OID_Xxx
*              InformationBuffer       - buffer containing data for the set Oid
*              InformationBufferLength - specifies size of InformationBuffer
*              BytesRead               - bytes read from InformationBuffer
*              BytesNeeded             - addition bytes required if
*                                        InformationBufferLength is less than
*                                        what the Oid requires to read
*
*  Returns:    NDIS_STATUS_SUCCESS       - success
*              NDIS_STATUS_PENDING       - will complete asynchronously and
*                                          call NdisMSetInformationComplete
*              NDIS_STATUS_INVALID_OID   - don't recognize the Oid
*              NDIS_STATUS_INVALID_LENGTH- InformationBufferLength does not
*                                          match length for the Oid
*              NDIS_STATUS_INVALID_DATA  - supplied data was invalid for the
*                                          given Oid
*              NDIS_STATUS_NOT_ACCEPTED  - failure
*              NDIS_STATUS_NOT_SUPPORTED - do not support an optional Oid
*              NDIS_STATUS_RESOURCES     - failed allocation of resources
*
*  Notes:
*
*
*****************************************************************************/
NDIS_STATUS
StIrUsbSetInformation(
		IN  NDIS_HANDLE MiniportAdapterContext,
		IN  NDIS_OID    Oid,
		IN  PVOID       InformationBuffer,
		IN  ULONG       InformationBufferLength,
		OUT PULONG      BytesRead,
		OUT PULONG      BytesNeeded
	)
{
    NDIS_STATUS status;
    PIR_DEVICE pThisDev;
    int i;

    DEBUGMSG(DBG_FUNC, ("+StIrUsbSetInformation\n"));

    status   = NDIS_STATUS_SUCCESS;
    pThisDev = CONTEXT_TO_DEV( MiniportAdapterContext );

	IRUSB_ASSERT( NULL != pThisDev ); 
	IRUSB_ASSERT( NULL != BytesRead );
	IRUSB_ASSERT( NULL != BytesNeeded );

    KeQuerySystemTime( &pThisDev->LastSetTime ); //used by check for hang handler
	pThisDev->fSetpending = TRUE;

	if( (NULL == InformationBuffer) && InformationBufferLength ) 
	{ 
        DEBUGMSG(DBG_ERR, ("    StIrUsbSetInformation() NULL info buffer passed!,InformationBufferLength = dec %d\n",InformationBufferLength));
		status = NDIS_STATUS_NOT_ACCEPTED;
        *BytesNeeded =0;
        *BytesRead = 0;
        goto done;
 
	}

    if( InformationBufferLength >= sizeof(UINT) )
    {
        //
        //  Set default results.
        //
        UINT info = 0;
		
		if( NULL != InformationBuffer ) 
		{
			info = *(UINT *)InformationBuffer;
		}

        *BytesRead = sizeof(UINT);
        *BytesNeeded = 0;

        switch( Oid )
        {
            //
            //  Generic OIDs.
            //

            case OID_GEN_CURRENT_PACKET_FILTER:
                DEBUGMSG(DBG_ERR, (" StIrUsbSetInformation(OID_GEN_CURRENT_PACKET_FILTER, %xh)\n", info));
                //
                // We ignore the packet filter itself.
                //
                // Note:  The protocol may use a NULL filter, in which case
                //        we will not get this OID; so don't wait on
                //        OID_GEN_CURRENT_PACKET_FILTER to start receiving
                //        frames.
                //
                pThisDev->fGotFilterIndication = TRUE;
                break;

            case OID_GEN_CURRENT_LOOKAHEAD:
                DEBUGMSG(DBG_ERR, (" StIrUsbSetInformation(OID_GEN_CURRENT_LOOKAHEAD, %xh)\n", info));
                //
                // We always indicate entire receive frames all at once,
                // so just ignore this.
                //
                break;

            case OID_GEN_PROTOCOL_OPTIONS:
                DEBUGMSG(DBG_ERR, (" StIrUsbSetInformation(OID_GEN_PROTOCOL_OPTIONS, %xh)\n", info));
                //
                // Ignore.
                //
                break;

            //
            // Infrared OIDs.
            //
            case OID_IRDA_LINK_SPEED:
				//
				// Don't do it if we are in diagnostic mode
				//
#if defined(DIAGS)
				if( pThisDev->DiagsActive )
				{
                    DEBUGMSG(DBG_ERR, (" Rejecting due to diagnostic mode\n"));
					status = NDIS_STATUS_SUCCESS;
					break;
				}
#endif

                if( pThisDev->currentSpeed == info )
                {
                    //
                    // We are already set to the requested speed.
                    //
                    DEBUGONCE(DBG_FUNC, (" Link speed already set.\n"));
                    status = NDIS_STATUS_SUCCESS;

                    break;
                }

                DEBUGMSG(DBG_ERR, (" StIrUsbSetInformation(OID_IRDA_LINK_SPEED, 0x%x, decimal %d)\n",info, info));
                status = NDIS_STATUS_INVALID_DATA;

                for( i = 0; i < NUM_BAUDRATES; i++ )
                {
                    if( supportedBaudRateTable[i].BitsPerSec == info )
                    {
                        //
                        // Keep a pointer to the link speed which has
                        // been requested. 
                        //
                        pThisDev->linkSpeedInfo = &supportedBaudRateTable[i]; 

                        status = NDIS_STATUS_PENDING; 
                        break; //for
                    }
                }

                //
				// Don't set if there is an error
				//
				if( NDIS_STATUS_PENDING != status  )
                {
                    status = NDIS_STATUS_INVALID_DATA;
                    DEBUGMSG(DBG_ERR, (" Invalid link speed\n"));

                    *BytesRead = 0;
                    *BytesNeeded = 0;
					break;
                } 

				//
				// Set the new speed
				//
				IrUsb_PrepareSetSpeed( pThisDev ); 
				break;

            case OID_IRDA_MEDIA_BUSY:
#if !defined(ONLY_ERROR_MESSAGES)
                DEBUGMSG(DBG_ERR, (" StIrUsbSetInformation(OID_IRDA_MEDIA_BUSY, %xh)\n", info));
#endif
				//
				// See comments in the 'query' code above;
				//
#if DBG
				pThisDev->NumSetMediaBusyOids++;
#endif
				// should always be setting 0
				DEBUGCOND( DBG_ERR, TRUE == info, (" StIrUsbSetInformation(OID_IRDA_MEDIA_BUSY, %xh)\n", info));

				InterlockedExchange( &pThisDev->fMediaBusy, FALSE ); 
				InterlockedExchange( &pThisDev->fIndicatedMediaBusy, FALSE ); 

 				status = NDIS_STATUS_SUCCESS; 
                break;

			case OID_PNP_SET_POWER:
				//
				// Perform the operations required to stop/resume
				//
				switch( (NDIS_DEVICE_POWER_STATE)info )
				{
					case NdisDeviceStateD0:
		                DEBUGMSG(DBG_ERR, (" StIrUsbSetInformation(OID_PNP_SET_POWER) NdisDeviceStateD0\n"));
						//
						// Processing back up (and a new speed setting)
						//
						ScheduleWorkItem( pThisDev,	ResumeIrDevice, NULL, 0 );
						break;
					case NdisDeviceStateD1:
		                DEBUGMSG(DBG_ERR, (" StIrUsbSetInformation(OID_PNP_SET_POWER) NdisDeviceStateD1\n"));
						//break;
					case NdisDeviceStateD2:
		                DEBUGMSG(DBG_ERR, (" StIrUsbSetInformation(OID_PNP_SET_POWER) NdisDeviceStateD2\n"));
						//break;
					case NdisDeviceStateD3:
		                DEBUGMSG(DBG_ERR, (" StIrUsbSetInformation(OID_PNP_SET_POWER) NdisDeviceStateD3\n"));					
						//
						// Handle the case where query wasn't sent
						//
						if( pThisDev->fProcessing )
						{
							InterlockedExchange( (PLONG)&pThisDev->fProcessing, FALSE );
							ScheduleWorkItem( pThisDev,	SuspendIrDevice, NULL, 0 );
							//
							// This will be the new value of the DPLL register (when we come back up)
							//
							pThisDev->StIrTranceiver.DpllTuneReg = STIR4200_DPLL_DEFAULT;
						}
						break;
				}
				break;

            default:
                DEBUGMSG(DBG_ERR, (" StIrUsbSetInformation(OID=%d=0x%x, value=%xh) - invalid OID\n", Oid, Oid, info));

                *BytesRead = 0;
                *BytesNeeded = 0;
                status = NDIS_STATUS_INVALID_OID;

                break;
        }
    }
    else
    {
        //
        // The given data buffer is not large enough for the information
        // to set.
        //
        *BytesRead = 0;
        *BytesNeeded = sizeof(UINT);
        status = NDIS_STATUS_INVALID_LENGTH;
    }

done:

    if( NDIS_STATUS_PENDING != status ) 
	{
		//
        // zero-out the time so check for hang handler knows nothing pending
		//
        pThisDev->LastSetTime.QuadPart = 0;
		pThisDev->fSetpending = FALSE;
    }

    DEBUGMSG(DBG_FUNC, ("-StIrUsbSetInformation\n"));

    return status;
}


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\net\irda\sigmatel\sys\openclos.c ===
/**************************************************************************************************************************
 *  OPENCLOS.C SigmaTel STIR4200 init/shutdown module
 **************************************************************************************************************************
 *  (C) Unpublished Copyright of Sigmatel, Inc. All Rights Reserved.
 *
 *
 *		Created: 04/06/2000 
 *			Version 0.9
 *		Edited: 04/24/2000 
 *			Version 0.91
 *		Edited: 04/27/2000 
 *			Version 0.92
 *		Edited: 05/12/2000 
 *			Version 0.94
 *		Edited: 05/19/2000 
 *			Version 0.95
 *	
 *
 **************************************************************************************************************************/

#define DOBREAKS    // enable debug breaks

#include <ndis.h>
#include <ntddndis.h>  // defines OID's

#include <usbdi.h>
#include <usbdlib.h>

#include "debug.h"
#include "ircommon.h"
#include "irndis.h"

/*****************************************************************************
*
*  Function:	InitializeDevice
*
*  Synopsis:	initialize resources for a single IR device object
*
*  Arguments:	pThisDev - IR device object to initialize
*
*  Returns:		NDIS_STATUS_SUCCESS      - if device is successfully opened
*				NDIS_STATUS_RESOURCES    - could not claim sufficient
*                                         resources
*
*
*  Notes:
*              we do a lot of stuff in this open device function
*              - allocate packet pool
*              - allocate buffer pool
*              - allocate packets/buffers/memory and chain together
*                (only one buffer per packet)
*              - initialize send queue
*
*  This function should be called with device lock held.
*
*  We don't initialize the following ir device object entries, since
*  these values will outlast an reset.
*       pUsbDevObj
*       hNdisAdapter
*       dongleCaps
*       fGotFilterIndication
*
*****************************************************************************/
NDIS_STATUS
InitializeDevice(
		IN OUT PIR_DEVICE pThisDev
	)
{
    int				i;
    NDIS_STATUS		status = NDIS_STATUS_SUCCESS;

    DEBUGMSG(DBG_FUNC|DBG_PNP, ("+InitializeDevice\n"));

    IRUSB_ASSERT( pThisDev != NULL );

    //
    // Current speed is the default (9600).
    //
    pThisDev->linkSpeedInfo = &supportedBaudRateTable[BAUDRATE_9600];
    pThisDev->currentSpeed  = DEFAULT_BAUD_RATE;

    //
    // Init statistical info. 
    // We need to do this cause reset won't free and realloc pThisDev!
    //
    pThisDev->packetsReceived         = 0;
    pThisDev->packetsReceivedDropped  = 0;
    pThisDev->packetsReceivedOverflow = 0;
	pThisDev->packetsReceivedChecksum = 0;
	pThisDev->packetsReceivedRunt	  = 0;
	pThisDev->packetsReceivedNoBuffer = 0;
    
	pThisDev->packetsSent             = 0;
    pThisDev->packetsSentDropped      = 0;
	pThisDev->packetsSentRejected	  = 0;
	pThisDev->packetsSentInvalid	  = 0;

	pThisDev->NumDataErrors			  = 0;
	pThisDev->NumReadWriteErrors	  = 0;

	pThisDev->NumReads				  = 0;
	pThisDev->NumWrites				  = 0;
	pThisDev->NumReadWrites			  = 0;

#if DBG
	pThisDev->TotalBytesReceived      = 0;
	pThisDev->TotalBytesSent          = 0;
	pThisDev->NumYesQueryMediaBusyOids		= 0;
	pThisDev->NumNoQueryMediaBusyOids		= 0;
	pThisDev->NumSetMediaBusyOids			= 0;
	pThisDev->NumMediaBusyIndications		= 0;
	pThisDev->packetsHeldByProtocol			= 0;
	pThisDev->MaxPacketsHeldByProtocol		= 0;
	pThisDev->NumPacketsSentRequiringTurnaroundTime		= 0;
	pThisDev->NumPacketsSentNotRequiringTurnaroundTime	= 0;
#endif

    //
	// Variables about the state of the device
	//
	pThisDev->fDeviceStarted          = FALSE;
    pThisDev->fGotFilterIndication    = FALSE;
    pThisDev->fPendingHalt            = FALSE;
    pThisDev->fPendingReadClearStall  = FALSE;
    pThisDev->fPendingWriteClearStall = FALSE;
	pThisDev->fPendingReset			  = FALSE;

	pThisDev->fPendingClearTotalStall = FALSE;

    pThisDev->fKillPollingThread      = FALSE;

    pThisDev->fKillPassiveLevelThread  = FALSE;

    pThisDev->LastQueryTime.QuadPart   = 0;
    pThisDev->LastSetTime.QuadPart     = 0;
	pThisDev->PendingIrpCount          = 0;

	//
	// OID Set/Query pending
	// 
	pThisDev->fQuerypending            = FALSE;
	pThisDev->fSetpending              = FALSE;

	//
	// Diags are off
	//
#if defined(DIAGS)
	pThisDev->DiagsActive			   = FALSE;
	pThisDev->DiagsPendingActivation   = FALSE;
#endif

    //
	// Some more state variables
	// 
	InterlockedExchange( &pThisDev->fMediaBusy, FALSE ); 
    InterlockedExchange( &pThisDev->fIndicatedMediaBusy, FALSE ); 

	pThisDev->pCurrentRecBuf			= NULL;

    pThisDev->fProcessing				= FALSE;
    pThisDev->fCurrentlyReceiving		= FALSE;

    pThisDev->fReadHoldingReg			= FALSE;

	pThisDev->BaudRateMask				= 0xffff;  // as per Class Descriptor; may be reset in registry

	//
	// Initialize the queues.
	//
	if( TRUE != IrUsb_InitSendStructures( pThisDev ) )
	{
		DEBUGMSG(DBG_ERR, (" Failed to init WDM objects\n"));
		goto done;
	}

    //
    // Allocate the NDIS packet and NDIS buffer pools
    // for this device's RECEIVE buffer queue.
    // Our receive packets must only contain one buffer a piece,
    // so #buffers == #packets.
    //
    NdisAllocatePacketPool(
			&status,                    // return status
			&pThisDev->hPacketPool,     // handle to the packet pool
			NUM_RCV_BUFS,               // number of packet descriptors
			16                          // number of bytes reserved for ProtocolReserved field
		);

    if( status != NDIS_STATUS_SUCCESS )
    {
        DEBUGMSG(DBG_ERR, (" NdisAllocatePacketPool failed. Returned 0x%.8x\n", status));
        goto done;
    }

    NdisAllocateBufferPool(
			&status,               // return status
			&pThisDev->hBufferPool,// handle to the buffer pool
			NUM_RCV_BUFS           // number of buffer descriptors
		);

    if( status != NDIS_STATUS_SUCCESS )
    {
        DEBUGMSG(DBG_ERR, (" NdisAllocateBufferPool failed. Returned 0x%.8x\n", status));
        pThisDev->BufferPoolAllocated = FALSE;
		goto done;
    }
        
	pThisDev->BufferPoolAllocated = TRUE;

    //
	// Prepare the work items
	// 
	for( i = 0; i < NUM_WORK_ITEMS; i++ )
    {
		PIR_WORK_ITEM pWorkItem;

		pWorkItem = &(pThisDev->WorkItems[i]);

		pWorkItem->pIrDevice    = pThisDev;
		pWorkItem->pInfoBuf     = NULL;
		pWorkItem->InfoBufLen   = 0;
		pWorkItem->fInUse       = FALSE;
		pWorkItem->Callback     = NULL;
	}

    //
    //  Initialize each of the RECEIVE objects for this device.
    //
    for( i = 0; i < NUM_RCV_BUFS; i++ )
    {
        PNDIS_BUFFER pBuffer = NULL;
        PRCV_BUFFER pReceivBuffer = &pThisDev->rcvBufs[i];

        //
        // Allocate a data buffer
        //
        pReceivBuffer->pDataBuf = MyMemAlloc( MAX_RCV_DATA_SIZE ); 

        if( pReceivBuffer->pDataBuf == NULL )
        {
            status = NDIS_STATUS_RESOURCES;
            goto done;
        }

        NdisZeroMemory( 
				pReceivBuffer->pDataBuf,
				MAX_RCV_DATA_SIZE
			);

		pReceivBuffer->pThisDev = pThisDev;
        pReceivBuffer->DataLen = 0;
        pReceivBuffer->BufferState = RCV_STATE_FREE;

#if defined(WORKAROUND_MISSING_C1)
		pReceivBuffer->MissingC1Detected = FALSE;
#endif

        //
        //  Allocate the NDIS_PACKET.
        //
        NdisAllocatePacket(
				&status,									// return status
				&((PNDIS_PACKET)pReceivBuffer->pPacket),	// return pointer to allocated descriptor
				pThisDev->hPacketPool						// handle to packet pool
			);

        if( status != NDIS_STATUS_SUCCESS )
        {
            DEBUGMSG(DBG_ERR, (" NdisAllocatePacket failed. Returned 0x%.8x\n", status));
            goto done;
        }
    }

	//
	// These are the receive objects for the USB
	//
    pThisDev->PreReadBuffer.pDataBuf = MyMemAlloc( STIR4200_FIFO_SIZE ); 

    if( pThisDev->PreReadBuffer.pDataBuf == NULL )
    {
        status = NDIS_STATUS_RESOURCES;
        goto done;
    }

    NdisZeroMemory( 
			pThisDev->PreReadBuffer.pDataBuf,
			STIR4200_FIFO_SIZE
		);

	pThisDev->PreReadBuffer.pThisDev = pThisDev;
    pThisDev->PreReadBuffer.DataLen = 0;
    pThisDev->PreReadBuffer.BufferState = RCV_STATE_FREE;

	//
	// Synchronization events
	//
	KeInitializeEvent(
        &pThisDev->EventSyncUrb,
        NotificationEvent,    // non-auto-clearing event
        FALSE                 // event initially non-signalled
    );

    KeInitializeEvent(
            &pThisDev->EventAsyncUrb,
            NotificationEvent,    // non-auto-clearing event
            FALSE                 // event initially non-signalled
        );

done:
    //
    // If we didn't complete the init successfully, then we should clean
    // up what we did allocate.
    //
    if( status != NDIS_STATUS_SUCCESS )
    {
        DEBUGMSG(DBG_ERR, (" InitializeDevice() FAILED\n"));
        DeinitializeDevice(pThisDev);
    }
    else
    {
        DEBUGMSG(DBG_OUT, (" InitializeDevice() SUCCEEDED\n"));
    }

    DEBUGMSG(DBG_FUNC|DBG_PNP, ("-InitializeDevice()\n"));
    return status;
}


/*****************************************************************************
*
*  Function:   DeinitializeDevice
*
*  Synopsis:   deallocate the resources of the IR device object
*
*  Arguments:  pThisDev - the IR device object to close
*
*  Returns:    none
*
*
*  Notes:
*
*  Called for shutdown and reset.
*  Don't clear hNdisAdapter, since we might just be resetting.
*  This function should be called with device lock held.
*
*****************************************************************************/
VOID
DeinitializeDevice(
		IN OUT PIR_DEVICE pThisDev
	)
{
    UINT			i;

    DEBUGMSG( DBG_FUNC|DBG_PNP, ("+DeinitializeDevice\n"));

    pThisDev->linkSpeedInfo = NULL;

    //
    // Free all resources for the RECEIVE buffer queue.
    //
    for( i = 0; i < NUM_RCV_BUFS; i++ )
    {
        PNDIS_BUFFER pBuffer = NULL;
        PRCV_BUFFER  pRcvBuf = &pThisDev->rcvBufs[i];

        if( pRcvBuf->pPacket != NULL )
        {
            NdisFreePacket( (PNDIS_PACKET)pRcvBuf->pPacket );
            pRcvBuf->pPacket = NULL;
        }

        if( pRcvBuf->pDataBuf != NULL )
        {
            MyMemFree( pRcvBuf->pDataBuf, MAX_RCV_DATA_SIZE ); 
            pRcvBuf->pDataBuf = NULL;
        }

        pRcvBuf->DataLen = 0;
    }

	//
	// Deallocate the USB receive buffers
	//
    if( pThisDev->PreReadBuffer.pDataBuf != NULL )
        MyMemFree( pThisDev->PreReadBuffer.pDataBuf, STIR4200_FIFO_SIZE ); 

    //
    // Free the packet and buffer pool handles for this device.
    //
    if( pThisDev->hPacketPool )
    {
        NdisFreePacketPool( pThisDev->hPacketPool );
        pThisDev->hPacketPool = NULL;
    }

    if( pThisDev->BufferPoolAllocated )
    {
        NdisFreeBufferPool( pThisDev->hBufferPool );
        pThisDev->BufferPoolAllocated = FALSE;
    }

    if( pThisDev->fDeviceStarted )
    {
		NTSTATUS ntstatus;

		ntstatus = IrUsb_StopDevice( pThisDev ); 
        DEBUGMSG(DBG_FUNC, (" DeinitializeDevice IrUsb_StopDevice() status = 0x%x\n",ntstatus));
    }

    InterlockedExchange( &pThisDev->fMediaBusy, FALSE ); 
    InterlockedExchange( &pThisDev->fIndicatedMediaBusy, FALSE ); 

	IrUsb_FreeSendStructures( pThisDev );

	DEBUGMSG(DBG_FUNC|DBG_PNP, ("-DeinitializeDevice\n"));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\net\irda\sigmatel\sys\rwir.c ===
/**************************************************************************************************************************
 *  RWIR.C SigmaTel STIR4200 USB, but not NDIS, module
 **************************************************************************************************************************
 *  (C) Unpublished Copyright of Sigmatel, Inc. All Rights Reserved.
 *
 *
 *		Created: 04/06/2000 
 *			Version 0.9
 *		Edited: 04/24/2000 
 *			Version 0.91
 *		Edited: 04/27/2000 
 *			Version 0.92
 *		Edited: 05/01/2000 
 *			Version 0.93
 *		Edited: 05/12/2000 
 *			Version 0.94
 *		Edited: 05/19/2000 
 *			Version 0.95
 *		Edited: 05/24/2000 
 *			Version 0.96
 *		Edited: 08/22/2000 
 *			Version 1.02
 *		Edited: 09/25/2000 
 *			Version 1.10
 *		Edited: 11/09/2000 
 *			Version 1.12
 *	
 *
 **************************************************************************************************************************/

#include <ndis.h>
#include <ntdef.h>
#include <windef.h>

#include "usbdi.h"
#include "usbdlib.h"

#include "debug.h"

#include "ircommon.h"
#include "irusb.h"
#include "diags.h"


/*****************************************************************************
*
*  Function:	InitializeProcessing
*
*  Synopsis:	Initialize the driver processing (sending and receiving packets) functionality.
*
*  Arguments:	pThisDevice - pointer to current ir device object
*				InitPassiveThread - whether we must initialize the passive thread
*	
*  Returns:		NDIS_STATUS_SUCCESS   - if irp is successfully sent to USB
*                                       device object
*				NDIS_STATUS_RESOURCES - if mem can't be alloc'd
*				NDIS_STATUS_FAILURE   - otherwise
*
*  Notes:
*
*  This routine must be called in IRQL PASSIVE_LEVEL.
*
*****************************************************************************/
NTSTATUS
InitializeProcessing(
        IN OUT PIR_DEVICE pThisDev,
		IN BOOLEAN InitPassiveThread
	)
{
    NTSTATUS status = STATUS_SUCCESS;

    DEBUGMSG(DBG_FUNC, ("+InitializeProcessing\n"));

	if( InitPassiveThread )
	{
		//
		// Create a thread to run at IRQL PASSIVE_LEVEL.
		//
		status = PsCreateSystemThread(
				&pThisDev->hPassiveThread,
				(ACCESS_MASK)0L,
				NULL,
				NULL,
				NULL,
				PassiveLevelThread,
				pThisDev
			);

		if( status != STATUS_SUCCESS )
		{
			DEBUGMSG(DBG_ERROR, (" PsCreateSystemThread PassiveLevelThread failed. Returned 0x%.8x\n", status));
			status = STATUS_INSUFFICIENT_RESOURCES;
			goto done;
		}
	}

    //
    // Create a thread to run at IRQL PASSIVE_LEVEL to be always receiving.
    //
    status = PsCreateSystemThread(
			&pThisDev->hPollingThread,
			(ACCESS_MASK)0L,
			NULL,
			NULL,
			NULL,
			PollingThread,
			pThisDev
		);

	if( status != STATUS_SUCCESS )
    {
        DEBUGMSG(DBG_ERROR, (" PsCreateSystemThread PollingThread failed. Returned 0x%.8x\n", status));
		status = STATUS_INSUFFICIENT_RESOURCES;
		goto done;
    }

    pThisDev->fProcessing = TRUE;

done:
    DEBUGMSG(DBG_FUNC, ("-InitializeProcessing\n"));
    return status;
}


/*****************************************************************************
*
*  Function:	ScheduleWorkItem
*
*  Synopsis:	Preapares a work item in such a way that the passive thread can process it
*
*  Arguments:	pThisDev - pointer to IR device
*				Callback - function to call
*				pInfoBuf - context for the call
*				InfoBufLen - length of the context
*
*  Returns:		TRUE if successful
*				FALSE otherwise
*
*  Notes:
*
*****************************************************************************/
BOOLEAN
ScheduleWorkItem(
		IN OUT PIR_DEVICE pThisDev,
		WORK_PROC Callback,
		IN PVOID pInfoBuf,
		ULONG InfoBufLen
	)
{
	int				i;
	PIR_WORK_ITEM	pWorkItem = NULL;
	BOOLEAN			ItemScheduled = FALSE;

    DEBUGMSG(DBG_FUNC, ("+ScheduleWorkItem\n"));

    //
	// Find an item that is available
	//
	for( i = 0; i < NUM_WORK_ITEMS; i++ )
	{
		pWorkItem = &(pThisDev->WorkItems[i]);

		if( pWorkItem->fInUse == FALSE ) 
		{
			InterlockedExchange( (PLONG)&pWorkItem->fInUse, TRUE );
			ItemScheduled = TRUE;
			break;
		}
	}

	//
	// Can't fail because can only have one set and one query pending,
	// and no more than 8 packets to process
	//
	IRUSB_ASSERT( NULL != pWorkItem );
	IRUSB_ASSERT( i < NUM_WORK_ITEMS );

    InterlockedExchangePointer( &pWorkItem->pInfoBuf, pInfoBuf );
    InterlockedExchange( (PLONG)&pWorkItem->InfoBufLen, InfoBufLen );

    /*
    ** This interface was designed to use NdisScheduleWorkItem(), which
    ** would be good except that we're really only supposed to use that
    ** interface during startup and shutdown, due to the limited pool of
    ** threads available to service NdisScheduleWorkItem().  Therefore,
    ** instead of scheduling real work items, we simulate them, and use
    ** our own thread to process the calls.  This also makes it easy to
    ** expand the size of our own thread pool, if we wish.
    **
    ** Our version is slightly different from actual NDIS_WORK_ITEMs,
    ** because that is an NDIS 5.0 structure, and we want people to
    ** (at least temporarily) build this with NDIS 4.0 headers.
    */
    InterlockedExchangePointer( (PVOID *)&pWorkItem->Callback, (PVOID)Callback );

    /*
    ** Our worker thread checks this list for new jobs, whenever its event
    ** is signalled.
    */

    // wake up worker thread
    KeSetEvent( &pThisDev->EventPassiveThread, 0, FALSE );

    DEBUGMSG(DBG_FUNC, ("-ScheduleWorkItem\n"));
	return ItemScheduled;
}


/*****************************************************************************
*
*  Function:	FreeWorkItem
*
*  Synopsis:	Sets the work item to the reusable state.
*
*  Arguments:	pItem - pointer to work item
*	
*  Returns:		None
*
*  Notes:
*
*****************************************************************************/
VOID
FreeWorkItem(
        IN OUT PIR_WORK_ITEM pItem
    )
{
    InterlockedExchange( (PLONG)&pItem->fInUse, FALSE );
}


/*****************************************************************************
*
*  Function:	IrUsb_CancelPendingIo
*
*  Synopsis:	Cancels all the pending IO for the device
*
*  Arguments:	pThisDev - pointer to the IR device
*	
*  Returns:		None
*
*  Notes:
*
*****************************************************************************/
VOID
IrUsb_CancelPendingIo(
		IN OUT PIR_DEVICE pThisDev
    )
{
    DEBUGMSG( DBG_FUNC, ("+IrUsb_CancelPendingIo(), fDeviceStarted =%d\n", pThisDev->fDeviceStarted)); // chag to FUNC later?

    IRUSB_ASSERT( KeGetCurrentIrql() <= DISPATCH_LEVEL );

    if( pThisDev->fDeviceStarted )
	{
        IrUsb_CancelPendingReadIo( pThisDev, TRUE );
        IrUsb_CancelPendingWriteIo( pThisDev );
        IrUsb_CancelPendingReadWriteIo( pThisDev );
    }

    DEBUGMSG( DBG_FUNC, ("-IrUsb_CancelPendingIo()\n")); // chag to FUNC later?
}


/*****************************************************************************
*
*  Function:	IrUsb_CancelPendingReadIo
*
*  Synopsis:	Cancels the pending read IRPs
*
*  Arguments:	pThisDev - pointer to the IR device
*				fWaitCancelComplete - pointer to the IRP to cancel
*	
*  Returns:		TRUE if cancelled any
*				FALSE otherwise
*
*  Notes:
*
*****************************************************************************/
BOOLEAN
IrUsb_CancelPendingReadIo(
		IN OUT PIR_DEVICE pThisDev,
		BOOLEAN fWaitCancelComplete
    )
{
	BOOLEAN		CancelResult = FALSE;
	int			i;

    DEBUGMSG( DBG_FUNC, ("+IrUsb_CancelPendingReadIo()\n"));

    IRUSB_ASSERT( KeGetCurrentIrql() <= DISPATCH_LEVEL );
	
    if( ( RCV_STATE_PENDING == pThisDev->PreReadBuffer.BufferState ) &&
		 ( NULL != pThisDev->PreReadBuffer.pIrp ) )
    {
		PIRP pIrp = (PIRP)pThisDev->PreReadBuffer.pIrp;
		
		//
		// Since IoCallDriver has been called on this request, we call IoCancelIrp
		//  and let our completion routine handle it
		//
		DEBUGMSG( DBG_FUNC, (" IrUsb_CancelPendingReadIo() about to CANCEL a read IRP!\n"));

		KeClearEvent( &pThisDev->EventAsyncUrb );

		CancelResult = IoCancelIrp( (PIRP)pThisDev->PreReadBuffer.pIrp );  

		DEBUGCOND( DBG_ERR, !CancelResult, (" IrUsb_CancelPendingReadIo() COULDN'T CANCEL IRP!\n"));
		DEBUGCOND( DBG_FUNC, CancelResult, (" IrUsb_CancelPendingReadIo() CANCELLED IRP SUCCESS!\n"));

		if( CancelResult && fWaitCancelComplete ) 
		{
			MyKeWaitForSingleObject(
					pThisDev,
					&pThisDev->EventAsyncUrb,
					NULL,  // irp to cancel; we did it above already, so pass NULL
					0 
				);

			IRUSB_ASSERT( pThisDev->PreReadBuffer.pIrp == NULL );
		}
	}

    DEBUGMSG( DBG_FUNC, ("-IrUsb_CancelPendingReadIo()\n"));
    return CancelResult;
}


/*****************************************************************************
*
*  Function:	IrUsb_CancelPendingWriteIo
*
*  Synopsis:	Cancels the pending write IRPs
*
*  Arguments:	pThisDev - pointer to the IR device
*	
*  Returns:		TRUE if cancelled any
*				FALSE otherwise
*
*  Notes:
*
*****************************************************************************/
BOOLEAN
IrUsb_CancelPendingWriteIo(
		IN OUT PIR_DEVICE pThisDev
    )
{
	BOOLEAN			CancelResult = FALSE;
	PIRUSB_CONTEXT	pThisContext;
	PLIST_ENTRY		pListEntry;

    DEBUGMSG( DBG_FUNC, ("+IrUsb_CancelPendingWriteIo()\n"));

    IRUSB_ASSERT( KeGetCurrentIrql() < DISPATCH_LEVEL );

    //
    // Free all resources for the SEND buffer queue.
    //
	while( pListEntry = ExInterlockedRemoveHeadList( &pThisDev->SendPendingQueue, &pThisDev->SendLock ) )
	{
		InterlockedDecrement( &pThisDev->SendPendingCount );

		pThisContext = CONTAINING_RECORD( pListEntry, IRUSB_CONTEXT, ListEntry );
		
		//
		// Get the IRUSB_CONTEXT and cancel its IRP; the completion routine will itself
		// remove it from the HeadPendingSendList and NULL out HeadPendingSendList
		// when the last IRP on the list has been  cancelled; that's how we exit this loop
		//
		IRUSB_ASSERT( NULL != pThisContext->pIrp );

		DEBUGMSG( DBG_WARN, (" IrUsb_CancelPendingWriteIo() about to CANCEL a write IRP!\n"));

		//
		// Completion routine ( IrUsbCompleteWrite() )will free irps, mdls, buffers, etc as well
		//
		CancelResult = IoCancelIrp( pThisContext->pIrp );

		DEBUGCOND( DBG_ERR, !CancelResult, 
			(" IrUsb_CancelPendingWriteIo() COULDN'T CANCEL IRP! 0x%x\n", pThisContext->pIrp ) );
		DEBUGCOND( DBG_FUNC, CancelResult, 
			(" IrUsb_CancelPendingWriteIo() CANCELLED IRP SUCCESS! 0x%x\n\n", pThisContext->pIrp) );

		//
		// Sleep 200 microsecs to give cancellation time to work
		//
		NdisMSleep( 200 );
	} 
	
    DEBUGMSG( DBG_FUNC, ("-IrUsb_CancelPendingWriteIo()\n"));
    return CancelResult;
}


/*****************************************************************************
*
*  Function:	IrUsb_CancelPendingReadWriteIo
*
*  Synopsis:	Cancels the pending register access IRPs
*
*  Arguments:	pThisDev - pointer to the IR device
*	
*  Returns:		TRUE if cancelled any
*				FALSE otherwise
*
*  Notes:
*
*****************************************************************************/
BOOLEAN
IrUsb_CancelPendingReadWriteIo(
		IN OUT PIR_DEVICE pThisDev
    )
{
	BOOLEAN			CancelResult = FALSE;
	PIRUSB_CONTEXT	pThisContext;
	PLIST_ENTRY		pListEntry;

    DEBUGMSG( DBG_FUNC, ("+IrUsb_CancelPendingReadWriteIo()\n"));

    IRUSB_ASSERT( KeGetCurrentIrql() < DISPATCH_LEVEL );

    //
    // Free all resources for the SEND buffer queue.
    //
	while( pListEntry = ExInterlockedRemoveHeadList( &pThisDev->ReadWritePendingQueue, &pThisDev->SendLock ) )
	{
		InterlockedDecrement( &pThisDev->ReadWritePendingCount );

		pThisContext = CONTAINING_RECORD( pListEntry, IRUSB_CONTEXT, ListEntry );
		
		//
		// Get the IRUSB_CONTEXT and cancel its IRP; the completion routine will itself
		// remove it from the HeadPendingSendList and NULL out HeadPendingSendList
		// when the last IRP on the list has been  cancelled; that's how we exit this loop
		//
		IRUSB_ASSERT( NULL != pThisContext->pIrp );

		DEBUGMSG( DBG_WARN, (" IrUsb_CancelPendingReadWriteIo() about to CANCEL a write IRP!\n"));

		//
		// Completion routine ( IrUsbCompleteWrite() )will free irps, mdls, buffers, etc as well
		//
		CancelResult = IoCancelIrp( pThisContext->pIrp );

		DEBUGCOND( DBG_ERR, !CancelResult, 
			(" IrUsb_CancelPendingReadWriteIo() COULDN'T CANCEL IRP! 0x%x\n", pThisContext->pIrp ) );
		DEBUGCOND( DBG_WARN, CancelResult, 
			(" IrUsb_CancelPendingReadWriteIo() CANCELLED IRP SUCCESS! 0x%x\n\n", pThisContext->pIrp) );

		//
		// Sleep 200 microsecs to give cancellation time to work
		//
		NdisMSleep( 200 );
	} 
	
    DEBUGMSG( DBG_FUNC, ("-IrUsb_CancelPendingReadWriteIo()\n"));
    return CancelResult;
}


/*****************************************************************************
*
*  Function:	IrUsb_CancelIo
*
*  Synopsis:	Cancels a pending IRP
*
*  Arguments:	pThisDev - pointer to the IR device
*				pIrpToCancel - pointer to the IRP to cancel
*				pEventToClear - pointer to the event to wait on
*	
*  Returns:		TRUE if cancelled,
*				FALSE otherwise
*
*  Notes:
*
*****************************************************************************/
BOOLEAN
IrUsb_CancelIo(
		IN PIR_DEVICE pThisDev,
		IN PIRP pIrpToCancel,
		IN PKEVENT pEventToClear
    )
{
	BOOLEAN CancelResult = FALSE;

    DEBUGMSG( DBG_FUNC, ("+IrUsb_CancelIo()\n"));

    IRUSB_ASSERT( KeGetCurrentIrql() <= DISPATCH_LEVEL );

	KeClearEvent( pEventToClear );

	CancelResult = IoCancelIrp( pIrpToCancel );  

    DEBUGCOND( DBG_ERR, !CancelResult, (" IrUsb_CancelIo() COULDN'T CANCEL IRP!\n"));
    DEBUGCOND( DBG_FUNC, CancelResult, (" IrUsb_CancelIo() CANCELLED IRP SUCCESS!\n"));

	if( CancelResult ) 
	{
		MyKeWaitForSingleObject(
				pThisDev,
				pEventToClear,
				NULL,  // irp to cancel; we did it above already, so pass NULL
				0 
			);
	}

    DEBUGMSG( DBG_FUNC, ("-IrUsb_CancelIo()\n"));
    return CancelResult;
}


/*****************************************************************************
*
*  Function:	MyIoCallDriver
*
*  Synopsis:	Calls a device driver and keeps track of the count
*
*  Arguments:	pThisDev - pointer to IR device
*				pDeviceObject - pointer to device driver to call
*				pIrp - pointer to Irp to submit
*	
*  Returns:		NT status code
*
*  Notes:		
*
*****************************************************************************/
NTSTATUS
MyIoCallDriver(
	   IN PIR_DEVICE pThisDev,
       IN PDEVICE_OBJECT pDeviceObject,
       IN OUT PIRP pIrp
   )
{
    NTSTATUS	ntStatus;

	DEBUGMSG( DBG_FUNC,("+MyIoCallDriver\n "));

	//
	// We will track count of pending irps;
	// We May later add logic to actually save array of pending irps
	//
	IrUsb_IncIoCount( pThisDev );
	ntStatus = IoCallDriver( pDeviceObject, pIrp );

	DEBUGMSG( DBG_FUNC,("+MyIoCallDriver\n "));
	return ntStatus;
}


/*****************************************************************************
*
*  Function:	IrUsb_CallUSBD
*
*  Synopsis:	Passes a URB to the USBD class driver
*				The client device driver passes USB request block (URB) structures
*				to the class driver as a parameter in an IRP with Irp->MajorFunction
*				set to IRP_MJ_INTERNAL_DEVICE_CONTROL and the next IRP stack location
*				Parameters.DeviceIoControl.IoControlCode field set to
*				IOCTL_INTERNAL_USB_SUBMIT_URB.
*
*  Arguments:	pThisDev - pointer to the IR device
*				pUrb - pointer to an already-formatted Urb request block
*	
*  Returns:		STATUS_SUCCESS if successful,
*				STATUS_UNSUCCESSFUL otherwise
*
*  Notes:
*
*****************************************************************************/
NTSTATUS
IrUsb_CallUSBD(
		IN PIR_DEVICE pThisDev,
		IN PURB pUrb
    )
{
    NTSTATUS			ntStatus;
    PDEVICE_OBJECT		pUrbTargetDev;
    PIO_STACK_LOCATION	pNextStack;

    DEBUGMSG( DBG_FUNC,("+IrUsb_CallUSBD\n"));

    IRUSB_ASSERT( KeGetCurrentIrql() == PASSIVE_LEVEL );
    IRUSB_ASSERT( pThisDev );
    IRUSB_ASSERT( NULL == ((PIRUSB_USB_INFO)pThisDev->pUsbInfo)->IrpSubmitUrb );  //shouldn't be multiple control calls pending

    //
    // issue a synchronous request (we'll wait )
    //
    pUrbTargetDev = pThisDev->pUsbDevObj;

    IRUSB_ASSERT( pUrbTargetDev );

	// make an irp sending to usbhub
	((PIRUSB_USB_INFO)pThisDev->pUsbInfo)->IrpSubmitUrb = 
		IoAllocateIrp( (CCHAR)(pThisDev->pUsbDevObj->StackSize + 1), FALSE );

    if( NULL == ((PIRUSB_USB_INFO)