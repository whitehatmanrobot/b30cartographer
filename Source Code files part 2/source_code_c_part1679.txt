CurNode].dwNext ;
        }

        if(dwPrevsNode == INVALID_INDEX)
            *pdwRoot = dwFea ;  //  first on the list.
        else
            pnPri[dwPrevsNode].dwNext = dwFea ;

        pnPri[dwFea].dwNext = dwCurNode ;
    }

    //  pdwPriority  array holds index of all features
    //  including synthesized - which are assigned indicies
    //  dwFea >= dwNumFea.  The feature indicies are ordered
    //  with the highest priority feature index occupying
    //  pdwPriority[0].

    dwNumSyn = gMasterTable[MTI_SYNTHESIZED_FEATURES].dwArraySize ;

    pdwPriority = (PDWORD)gMasterTable[MTI_PRIORITYARRAY].pubStruct ;

    for(dwIndex = 0 ; dwIndex < dwNumSyn  ; dwIndex++)
    {
        pdwPriority[dwIndex] = dwIndex + dwNumFea ;
        //  take all synthesized features and assign them
        //  the highest pri.
    }

    for(dwCurNode = dwPrnStickyroot ; dwCurNode != INVALID_INDEX ;
            dwIndex++ )
    {
        pdwPriority[dwIndex] = dwCurNode ;
        dwCurNode = pnPri[dwCurNode].dwNext ;
    }

    for(dwCurNode = dwDocStickyroot  ; dwCurNode != INVALID_INDEX ;
            dwIndex++ )
    {
        pdwPriority[dwIndex] = dwCurNode ;
        dwCurNode = pnPri[dwCurNode].dwNext ;
    }

    ASSERT(dwIndex == gMasterTable[MTI_PRIORITYARRAY].dwArraySize) ;

    MemFree(pnPri) ;
    return(TRUE);

} //BInitPriorityArray ()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\parsers\gpd\parspec.c ===
Definitions:

statement delimiter:
    a new statement will always follow a linebreak
    character:
    a) unless the following character is the continuation character
    b) if the following character is another linebreak character,
        it is a null statement.
    c) statements consisting entirely of whitespace characters,
        comments or combinations are considered null statements.
    d) the parser ignores null statements.
    e) parser eats everything up to linebreak character and each
        subsequent line that begins with the continuation char
        in the event of a parsing error.
    The Construct delimiters are a statement in and of themselves
    and they also serve to terminate the previous statement
    and delimit the start of the following statement.
    you may think of a <construct_delimiter>  as equivalent to
    <linebreak><construct_delimiter><linebreak>


Whitespace characters:   space, TAB
Linebreak  characters:   <CR>, <LF> if both occur consecutively
    the pair is treated as one linebreak.
White characters:  either Whitespace or Linebreak characters.
continuation character: +
    NEW DEF:  when used as a continuation char
    the '+' must appear as the first char in a line.
    The parser will interpret the preceeding linebreak
    as whitespace.
Logical linebreak: a linebreak character that is NOT followed by a
    continuation character.
Continuation linebreak:  a linebreak character followed by a
    continuation character.
Arbitrary whitespace:  Whitespace chars or comments or
    Continuation Linebreak
Construct delimiters:  curly braces { }
    A linebreak character is not required to preceed or proceed
    a construct delimiter.
    You may think of a <construct_delimiter>  as logically equivalent
    to      <linebreak><construct_delimiter><linebreak>
    Construct delimiters also delimit the scope of macro
    definitions.  If a macro was defined within a nesting level
    created by a pair of construct delimiters, it remains defined
    only within that nesting level.
Nesting level:  the logical set of statements enclosed by
    a matching pair of construct delimiters.
Statement delimiter: Logical linebreak or Construct delimiter.
Keyword - value separator:  colon :
string delimiter:  double quotes ""
macro invocation:  equals =
comment indicator: *%
    Comments may be inserted immediately preceeding any logical
    or continuation linebreak.  They may contain
    any characters except linebreak characters.
    The linebreak character terminates the comment.
    The comment indicator must be preceeded by a White Character.
    (unless the comment indicator is the first byte in the source file.)
Grouping operator: ()  used in certain value constructs.
Hex substring delimiter: <>
Escape character :  %  used in string and parameter constructs.



The above characters have reserved meanings
and may not be used in any keyword, symbol name
or any user defined name.

Name spaces:

If attributes keyword are used within other constructs
say feature or global keyword inside an option,
that keyword must be declared using the EXTERN_FEATURE:
or EXTERN_GLOBAL:  modifier.  Otherwise the attribute type
expected (dictionary used) will be defined by the state.

the namespaces of the attribute keywords for various constructs
may overlap each other, since we rely on the above rules to
assign the namespace, but they cannot overlap non-attribute
keywords.


Keywords:  predefined keywords must begin with '*'
the remainder of the keyword may be comprised of
'A' to 'Z', 'a' to 'z', '0' - '9', '_'  and  may
be terminated by an optional '?'.

Symbol Keywords  do not begin with '*' and may be any
name defined by the user, they must be comprised of the same
characters as normal keywords.  Symbol Keywords are used
as the name of Value macros and Font names in certain constructs.


Parsing rules:

Values:  on some Keywords the Value is
ignored by the parser.  In these cases
the Value (and the : delimiter) may be omitted
for example:
*Macros
*Macros: PaperNames
are both valid.


Block Macro definitions:
if the definition (body of a BlockMacro)
contains braces, the braces must appear in pairs
and the correct order.  ie {  must appear before }.
braces may be nested within the body.


Parsing Level 0:  this is the outermost level of parsing.
At this level  the characters {, } are interpreted
as construct delimiters,  *% begins a comment etc.
This is contrasted to the parsing rules applied to
higher level objects like strings  where these charcters
have no special meaning.

Linebreak characters may only appear in parsing level 0.
Their appearance at any time terminates parsing of the current statement.

parser eats everything up to linebreak character
in the event of a parsing error.

Statements begin with either a *<keyword> or a <symbol keyword>
where the keyword is a parser recognized keyword token and
where <symbol keyword> is a parser unrecognized token
which may represent a ValueMacroName or a TTFontName.
such tokens must not begin with '*'.  and will be marked
as SYMBOL in the TokenMap.

In general arbitary Whitespaces may appear between
any entities recognized at Parsing level 0.
If Whitespaces are permitted within such entities
it will noted.

For added robustness, macro strings will not be
expanded to their binary equivalents.  This prevents the
insertion of random Linebreak characters in the stream.

Rule for GPD authors:  for maximum robustness and error
recovery, place level 0 braces (Construct delimiters) on a
separate line.  Do not place Construct delimiters on the same
line where questionable keywords and constructs are used.


Heap useage:

the heap will be divided into several sections, each large enough
to hold whatever may come.  Growth of the heap sections
is not allowed.

Strings, composite objects like RECTS:   holds all strings, offsets referenced
from beginning of string section.

Arrays of various types:   each type of array is assigned its own dedicated
memory buffer.  A master table contains pointers to each array,
its size and current entry.  Once data is entered into the array,
the keeper of the data need only remember the index of the array
the data was written into.

After all parsing operations are complete, we will consolidate the
arrays into one memory space and update the master table accordingly.


Some composite values require an indefinite amount of storage
or reside in dedicated structures.
(for example strings, lists and UIconstraints).
Such values are stored in 2 parts, a fixed sized link, and
and the part the link refers to.  This part may be variable
sized and may occupy heap space or one or more dedicated
structures or some combination thereof.
Since the link is always of a known size, it may be stored
in a field in a structure etc.

The following table lists the values supported by the parser
and how they are structured:

value type: Strings
link:       ARRAYREF
                dwOffset field specifies heap offset of start of string
                dwCount  field specifies string length excluding
                    terminating NULL.
body:       Null terminated array of bytes stored in heap.

value type: LIST
value type: QualifiedName




Shortcuts that cause headaches:

*Command:   2 forms exist.


Macros:

    a macroDefinition cannot be self-referencing
    macroDefintions cannot be forward referenced.
    ie only a previously defined and fully resolved macro can be
    referenced.

    scope:  an Macro is defined (referenceable) only after parsing the
    closing brace of its definition and until encoutering a closing
    brace that signifies the termination of the level the macro
    was defined in.

    namespaces:  since macro definitions are stored in a stack,
    defining a second macro with the same name does not necessarily
    destroy the first definition.  If The first macro was defined
    outside of the scope of the 2nd, it will be visible once
    the parser leaves the scope of the 2nd Macro.

    ValueMacros:
    Only string ValueMacros may be nested.
    That if any valueMacro definition references
        another valueMacro, the parser will assume
        the definition is a stringMacro, and the
        macro being referenced is also a stringvalue.

    BlockMacros:
        a blockMacro may contain other Macrodefinitions
        but those definitions can only be referenced inside
        the block macro.  They will not appear
        when the blockmacro is actually referenced.
        A BlockMacroName may NOT be substituted
        by a ValueMacro either in a *BlockMacro or
        *InsertBlock  statement.



----- more parsing rules ------

the first non-null line of the root GPD sourcefile
must be:
*GPDSpecVersion:


arbitary whitespace is allowed between tokens
comprising a command parameter.
arbitary whitespace is allowed anywhere within
a hex substring.
--------------------------------------------------------------


Currently, these are the known types of keywords:

CONSTRUCTS:  introduces a construct (causes a parser context change)
    usually followed by open brace in next statement.
    construct is terminated by matching close brace.

    *UIGroup, *Switch, *Case, *Default, *Command
    *FontCartridge, *TTFontSubs, *Feature, *Option
    *OEM, *BlockMacro, *Macros
    a construct may be thought of as a type of structure
    initialization.   ONly certain keywords are may be used
    inside of a construct.  Some of these keywords may only be
    using within their associated construct and no where else.

LOCAL ATTRIBUTES:  initializes a value in a construct.
GLOBAL ATTRIBUTES:  initializes a value in the global structure.

local and global attributes may be subdivided into
freefloating and fixed.  A fixed attribute must be used
in the same nesting level as the construct it is associated
with.  A freefloating attribute may be used within another
construct as long as that construct is contained within the
construct associated attribute.


SPECIAL ATTRIBUTE:  initializes and adds another item to a dedicated
    or global list or a list in construct.  or has side effects
    requiring special processing.
    examples:

    *Installable?, - Causes an installable feature
    to be synthesized.  but parser may deal with this after all
    Feature/Options have been parsed.  So not really.

    Adds link to special  tree structure:
    *Constraints, *InvalidCombination, *InvalidInstallableCombination,
    *InstalledConstraints, *NotInstalledConstraints

    The values introduced by these keywords are additive
    (like using a LIST):
    *Font


    *Command:<commandName>:<invocation>    a shorthand

    *MemConfigKB    a shorthand way of creating an entire
        memory option.

    LIST(<QualifiedName>,<QualifiedName>,<QualifiedName>)
    may be written as:
    <FeatureName>.LIST(<OptionName>,<OptionName>,<OptionName>)


if there are other types of keywords let me know.

Special Parsing contexts:
in which User defines new keywords simply by
referencing them.

*TTFontSubs:
{
    <TTFontFaceName>: <DeviceFontID>
    ....  not actually a symbol, but adds a string, number pair
    to a list.  May be implemented during construction as a symbol.
}
*Macros:
{
    <ValueMacroName>:<macrovalue>
}

*FontCart:  note the FontCart construct is ROOT_ONLY and
is not multivalued.  Each construct with a unique SymbolName
corresponds to a dedicated FONTCART structure.

If  we want to make FontCarts multivalued,
we introduce a new keyword *AvailFontCarts: LIST(symbol1, symbol2, symbol3)
which is a FreeFloating Global.


MacroProcessing:
=<ValueMacroName>    where a value  or component of a string is expected
=<BlockMacroName>  following a symbolname following a construct Keyword.
*InsertBlock: <BlockMacroName>

recognized value types:
    ORDER :== <section>.<number>


SYMBOLS: Any user defined (not recognized by the parser) token used
to identify a statement or construct or value.
<CommandNames> are not symbols because the parser has a list
of recognized Valid Unidrv commands.   Non Macro Symbols may be
forward referenced:  ie  *DefaultOption or *Constraints may reference
a symbol that is defined later.

where defined:

Associated Keyword: <symbol type>
*Macros: <ValueMacroNames>     not the Group Name!
*BlockMacro: <BlockMacroNames>
*Feature: <featureSymbol>
*Option: <optionSymbol>
*OEM: <OEM group name>   saved in symbol tree for possible future use.
*TTFontSubs:   TTFontnames may be stored as symbols, but
    are not symbols in the strictest sense.

constructs not using symbols:
*TTFontSubs: <ON | OFF>             predefined.
*UIGroup: <Group name>   optional - not used by parser.
*Default: <optional tag>   optional - not used by parser.
*Command:  <Unidrv Command Name>   predefined.  CmdSelect
    is a special name which triggers special processing.
*FontCartridge: <optional tag>  optional - not used by parser.
    Implementation hint: use macros to keep all definitions in one place.
    or introduce *AvailFontCart: LIST(<FontCartSymbol>, <FontCartSymbol>)
    inside constructs.

where referenced:
*InsertMacro: <BlockMacroNames>
*<ConstructKeyword>: <symboldef> =<BlockMacroName>

*<anykeyword>: =<ValueMacroName>
    except *BlockMacro, *InsertMacro, *Include
*Switch: <FeatureName>
*Case: <OptionName>


Currently the parser saves symbols defined in *Feature and *Option
keywords and remembers symbol references made in *Switch and *Case
keywords.

The include keyword:

    must not appear within a macrodefinition
    must not reference a macrovalue
    must be terminated by a linebreak  not {  or } construct.

--- state machine ----

The parser treates construct keywords as operators
which change the state of the parser. (create state
transitions.)

the set of allowed transitions is
defined in the table AllowedTransitions
this table enforces several rules:

the construct _TTFONTSUBS can only
appear at the root level.

no constructs may appear within
OEM, FONTCART, TTFONTSUBS, COMMAND  constructs.


The following code fragment is a comprehensive list
of the allowed state transitions:


    pst = astAllowedTransitions[STATE_ROOT] ;

    pst[CONSTRUCT_UIGROUP] = STATE_UIGROUP;
    pst[CONSTRUCT_FEATURE] = STATE_FEATURE;
    pst[CONSTRUCT_SWITCH] = STATE_SWITCH_ROOT;
    pst[CONSTRUCT_COMMAND] = STATE_COMMAND;
    pst[CONSTRUCT_FONTCART] = STATE_FONTCART;
    pst[CONSTRUCT_TTFONTSUBS] = STATE_TTFONTSUBS;
    pst[CONSTRUCT_OEM] = STATE_OEM;

    pst = astAllowedTransitions[STATE_UIGROUP] ;

    pst[CONSTRUCT_UIGROUP] = STATE_UIGROUP;
    pst[CONSTRUCT_FEATURE] = STATE_FEATURE;

    pst = astAllowedTransitions[STATE_FEATURE] ;

    pst[CONSTRUCT_OPTION] = STATE_OPTIONS;
    pst[CONSTRUCT_SWITCH] = STATE_SWITCH_FEATURE;

    pst = astAllowedTransitions[STATE_OPTIONS] ;

    pst[CONSTRUCT_SWITCH] = STATE_SWITCH_OPTION;
    pst[CONSTRUCT_COMMAND] = STATE_COMMAND;
    pst[CONSTRUCT_OEM] = STATE_OEM;

    pst = astAllowedTransitions[STATE_SWITCH_ROOT] ;

    pst[CONSTRUCT_CASE] = STATE_CASE_ROOT;
    pst[CONSTRUCT_DEFAULT] = STATE_DEFAULT_ROOT;

    pst = astAllowedTransitions[STATE_SWITCH_FEATURE] ;

    pst[CONSTRUCT_CASE] = STATE_CASE_FEATURE;
    pst[CONSTRUCT_DEFAULT] = STATE_DEFAULT_FEATURE;

    pst = astAllowedTransitions[STATE_SWITCH_OPTION] ;

    pst[CONSTRUCT_CASE] = STATE_CASE_OPTION;
    pst[CONSTRUCT_DEFAULT] = STATE_DEFAULT_OPTION;

    pst = astAllowedTransitions[STATE_CASE_ROOT] ;

    pst[CONSTRUCT_SWITCH] = STATE_SWITCH_ROOT;
    pst[CONSTRUCT_COMMAND] = STATE_COMMAND;
    pst[CONSTRUCT_OEM] = STATE_OEM;

    pst = astAllowedTransitions[STATE_DEFAULT_ROOT] ;

    pst[CONSTRUCT_SWITCH] = STATE_SWITCH_ROOT;
    pst[CONSTRUCT_COMMAND] = STATE_COMMAND;
    pst[CONSTRUCT_OEM] = STATE_OEM;

    pst = astAllowedTransitions[STATE_CASE_FEATURE] ;

    pst[CONSTRUCT_SWITCH] = STATE_SWITCH_FEATURE;
    pst[CONSTRUCT_COMMAND] = STATE_COMMAND;
    pst[CONSTRUCT_OEM] = STATE_OEM;

    pst = astAllowedTransitions[STATE_DEFAULT_FEATURE] ;

    pst[CONSTRUCT_SWITCH] = STATE_SWITCH_FEATURE;
    pst[CONSTRUCT_COMMAND] = STATE_COMMAND;
    pst[CONSTRUCT_OEM] = STATE_OEM;

    pst = astAllowedTransitions[STATE_CASE_OPTION] ;

    pst[CONSTRUCT_SWITCH] = STATE_SWITCH_OPTION;
    pst[CONSTRUCT_COMMAND] = STATE_COMMAND;
    pst[CONSTRUCT_OEM] = STATE_OEM;

    pst = astAllowedTransitions[STATE_DEFAULT_OPTION] ;

    pst[CONSTRUCT_SWITCH] = STATE_SWITCH_OPTION;
    pst[CONSTRUCT_COMMAND] = STATE_COMMAND;
    pst[CONSTRUCT_OEM] = STATE_OEM;




--- multiple statements and redefinitions: ------

for standard attributes,  if two statements containing
that attribute  with different values appears in the
same construct, the attribute takes the latter occuring value.

If the attribute is defined to be FreeFloating, it may appear
multiple times in different *Option or *Case constructs.
In this case if the effect of the multiple occurances is to
add new branches which are compatible with the existing tree,
or to reinitialize the value of a node in the existing tree
that is an accepted use of multiple occuring attributes.
However if the effect is to define a new branch which is
incompatible with the existing tree, that is an error, and
the latter initialization of the attribute is ignored.

There is one exception to the rule of adding conflicting branches
to the attribute tree.  That exception allows default initializers
to be created.  If an attribute is assigned a value which is
subsequently made multivalued, the initial value becomes the
default initializer  unless the GPD author explicitly specified
a 'default' case when making the attribute multivalued.

Note the order cannot be reversed.
An attribute which is already defined to be multivalued
cannot subsequently be defined to be fewer valued.

--- state machine ----

the set of allowed transitions is
defined in the table AllowedTransitions
this table enforces several rules:

the construct _TTFONTSUBS can only
appear at the root level.

no constructs may appear within
OEM, FONTCART, TTFONTSUBS, COMMAND  constructs.


---- use of switch/case constructs -----

The same feature must not be referenced in nested constructs.
This will produce an attribute tree that contains the same
feature at two different levels.   similarly...
an attribute tree  should not be constructed
piecemeal.  It is an error if the tree is subsequently
redefined/elaborated using a different feature nesting
order.
-----
Severity of errors:

!!!!!:  parser is non-compilable/non-functional unless
    this is resolved.
!!!!:  unfinished functionality.  Some legal GPD files
    will cause corruption.
!!!:   integrity check omitted - a corrupt file may be inadvertantly
    generated if resource limitations are encountered.
!!:  syntax error in GPD may cause widespread corruption
!:  emit useful message for user.
BUG_BUG:  wish item - user friendlier error message etc.
    parser self-consistency check, self diagnostics.
    more general, elegant, faster, more complex code etc.


Note:  PARANOID BUG_BUGs indicate error conditions that are
the result of coding errors (mistaken assumptions, incomplete
code paths etc)  and are not the result of improper GPD syntax,
or resource constraints (overflow of fixed length buffers etc).

All originating error messages should report the name of
the function, name of variable or system call that is
out of range or invalid.

Later, if a caller function sees a failure return value,
it may want to tack on an extra message say
keyword or line number where error occured.

A if a function returns with a failure condition, the caller
may at its discretion increase the severity of the error.
For example if the caller passed a string to be parsed
and it failed, the string parsing function may raise a tiny
error condition.  But if the caller was going to use the
string to open a GPD or resource file, then this suddenly
becomes a major problem.

A function may
never reduce the severity of an error unless code was just
executed which will migitate the source of the problem.
Don't select  ERRSEV_RESTART  unless there is a handler
on the next go round to solve the initial problem.
An endless loop may result otherwise.
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\parsers\gpd\snaptbl.c ===
//   Copyright (c) 1996-1999  Microsoft Corporation
/*  snaptbl.c - function to initialize the snapshot table  */


#include    "gpdparse.h"


// ----  functions defined in snaptbl.c ---- //

DWORD   DwInitSnapShotTable1(
PBYTE   pubnRaw) ;

DWORD   DwInitSnapShotTable2(
PBYTE   pubnRaw,
DWORD   dwI) ;




// ------- end function declarations ------- //

//  assume a pointer to this table is stored in the RAWbinary data.


DWORD   DwInitSnapShotTable1(
PBYTE   pubnRaw)
/* this function is to be called once
immediately after the raw binary data is read from
the file, this memory is to be freed immediately prior
to freeing pubRaw.
The entries belonging to different structures are
separated by an entry with    dwNbytes = 0.
*/
{
    PSTATICFIELDS   pStatic ;
//    PMINIRAWBINARYDATA pmrbd  ;
    DWORD   dwI = 0;

    pStatic = (PSTATICFIELDS)pubnRaw ;
//    pmrbd = (PMINIRAWBINARYDATA)pubRaw ;
    pStatic->snapShotTable = (PSNAPSHOTTABLE)
        MemAlloc(sizeof(SNAPSHOTTABLE) * MAX_SNAPSHOT_ELEMENTS) ;

    if(!pStatic->snapShotTable)
        return(FALSE) ;

    //   SSTI_GLOBALS  section

    //
    // General
    //



    pStatic->snapShotTable[dwI].pstrKeyword  = "*GPDSpecVersion" ;
    pStatic->snapShotTable[dwI].dwSrcOffset  = offsetof(GLOBALATTRIB,
                                        atrGPDSpecVersion) ;
    pStatic->snapShotTable[dwI].dwDestOffset = offsetof(GLOBALS,
                                        pwstrGPDSpecVersion) ;
    pStatic->snapShotTable[dwI].dwNbytes = sizeof(PWSTR) ;
    pStatic->snapShotTable[dwI].dwDefaultValue = 0 ;
    pStatic->snapShotTable[dwI].dwFlags = SSF_REQUIRED  | SSF_MAKE_STRINGPTR ;
    pStatic->snapShotTable[dwI].dwGIDflags = 0 ;
    dwI++ ;



    pStatic->snapShotTable[dwI].pstrKeyword  = "*GPDFileVersion" ;
    pStatic->snapShotTable[dwI].dwSrcOffset  = offsetof(GLOBALATTRIB,
                                        atrGPDFileVersion) ;
    pStatic->snapShotTable[dwI].dwDestOffset = offsetof(GLOBALS,
                                        pwstrGPDFileVersion) ;
    pStatic->snapShotTable[dwI].dwNbytes = sizeof(PWSTR) ;
    pStatic->snapShotTable[dwI].dwDefaultValue = 0 ;
#if defined(DEVSTUDIO) || defined(GPDCHECKER)
    pStatic->snapShotTable[dwI].dwFlags = SSF_REQUIRED  | SSF_MAKE_STRINGPTR ;
#else
    pStatic->snapShotTable[dwI].dwFlags =  SSF_MAKE_STRINGPTR ;
#endif
    pStatic->snapShotTable[dwI].dwGIDflags = 0 ;
    dwI++ ;


    pStatic->snapShotTable[dwI].pstrKeyword  = "*GPDFileName" ;
    pStatic->snapShotTable[dwI].dwSrcOffset  = offsetof(GLOBALATTRIB,
                                        atrGPDFileName) ;
    pStatic->snapShotTable[dwI].dwDestOffset = offsetof(GLOBALS,
                                        pwstrGPDFileName) ;
    pStatic->snapShotTable[dwI].dwNbytes = sizeof(PWSTR) ;
    pStatic->snapShotTable[dwI].dwDefaultValue = 0 ;
#if defined(DEVSTUDIO) || defined(GPDCHECKER)
    pStatic->snapShotTable[dwI].dwFlags = SSF_REQUIRED  | SSF_MAKE_STRINGPTR ;
#else
    pStatic->snapShotTable[dwI].dwFlags = SSF_MAKE_STRINGPTR ;
#endif
    pStatic->snapShotTable[dwI].dwGIDflags = 0 ;
    dwI++ ;



    pStatic->snapShotTable[dwI].pstrKeyword  = "*MasterUnits" ;
    pStatic->snapShotTable[dwI].dwSrcOffset  = offsetof(GLOBALATTRIB,
                                        atrMasterUnits) ;
    pStatic->snapShotTable[dwI].dwDestOffset = offsetof(GLOBALS,
                                        ptMasterUnits) ;
    pStatic->snapShotTable[dwI].dwNbytes = sizeof(POINT) ;
    pStatic->snapShotTable[dwI].dwDefaultValue = 0 ;
    pStatic->snapShotTable[dwI].dwFlags = SSF_REQUIRED ;
    pStatic->snapShotTable[dwI].dwGIDflags = 0 ;
    dwI++ ;

    //  Amanda cannot have RC IDs here.
    //  so no atrModelNameID ;


    pStatic->snapShotTable[dwI].pstrKeyword  = "*ModelName" ;
    pStatic->snapShotTable[dwI].dwSrcOffset  = offsetof(GLOBALATTRIB,
                                        atrModelName) ;
    pStatic->snapShotTable[dwI].dwDestOffset = offsetof(GLOBALS,
                                        pwstrModelName) ;
    pStatic->snapShotTable[dwI].dwNbytes = sizeof(PWSTR) ;
    pStatic->snapShotTable[dwI].dwDefaultValue = 0 ;
    pStatic->snapShotTable[dwI].dwFlags = SSF_REQUIRED  | SSF_MAKE_STRINGPTR ;
    pStatic->snapShotTable[dwI].dwGIDflags = 0 ;
    dwI++ ;


    pStatic->snapShotTable[dwI].pstrKeyword  = "*PrinterType" ;
    pStatic->snapShotTable[dwI].dwSrcOffset  = offsetof(GLOBALATTRIB,
                                        atrPrinterType) ;
    pStatic->snapShotTable[dwI].dwDestOffset = offsetof(GLOBALS,
                                        printertype) ;
    pStatic->snapShotTable[dwI].dwNbytes = sizeof(PRINTERTYPE) ;
    pStatic->snapShotTable[dwI].dwDefaultValue = 0 ;
    pStatic->snapShotTable[dwI].dwFlags = SSF_REQUIRED ;
    pStatic->snapShotTable[dwI].dwGIDflags = 0 ;
    dwI++ ;

    // "Include"  would be here if it weren't processed
    // at GetToken time.


    pStatic->snapShotTable[dwI].pstrKeyword  = "*ResourceDLL" ;
    pStatic->snapShotTable[dwI].dwSrcOffset  = offsetof(GLOBALATTRIB,
                                        atrResourceDLL) ;
    pStatic->snapShotTable[dwI].dwDestOffset = offsetof(GLOBALS,
                                        pwstrResourceDLL) ;
    pStatic->snapShotTable[dwI].dwNbytes = sizeof(PWSTR) ;
    pStatic->snapShotTable[dwI].dwDefaultValue = 0 ;
    pStatic->snapShotTable[dwI].dwFlags = SSF_MAKE_STRINGPTR  ;
    pStatic->snapShotTable[dwI].dwGIDflags = 0 ;
    dwI++ ;

    pStatic->snapShotTable[dwI].pstrKeyword  = "*MaxCopies" ;
    pStatic->snapShotTable[dwI].dwSrcOffset  = offsetof(GLOBALATTRIB,
                                        atrMaxCopies) ;
    pStatic->snapShotTable[dwI].dwDestOffset = offsetof(GLOBALS,
                                        dwMaxCopies) ;
    pStatic->snapShotTable[dwI].dwNbytes = sizeof(DWORD) ;
    pStatic->snapShotTable[dwI].dwDefaultValue = 1 ;
    pStatic->snapShotTable[dwI].dwFlags = 0 ;
    pStatic->snapShotTable[dwI].dwGIDflags = 0 ;
    dwI++ ;

    pStatic->snapShotTable[dwI].pstrKeyword  = "*FontCartSlots" ;
    pStatic->snapShotTable[dwI].dwSrcOffset  = offsetof(GLOBALATTRIB,
                                        atrFontCartSlots) ;
    pStatic->snapShotTable[dwI].dwDestOffset = offsetof(GLOBALS,
                                        dwFontCartSlots) ;
    pStatic->snapShotTable[dwI].dwNbytes = sizeof(DWORD) ;
    pStatic->snapShotTable[dwI].dwDefaultValue = 0 ;
    pStatic->snapShotTable[dwI].dwFlags = 0 ;
    pStatic->snapShotTable[dwI].dwGIDflags = 0 ;
    dwI++ ;

    pStatic->snapShotTable[dwI].pstrKeyword  = "*OEMCustomData" ;
    pStatic->snapShotTable[dwI].dwSrcOffset  = offsetof(GLOBALATTRIB,
                                        atrOEMCustomData) ;
    pStatic->snapShotTable[dwI].dwDestOffset = offsetof(GLOBALS,
                                        pOEMCustomData) ;
    pStatic->snapShotTable[dwI].dwNbytes = sizeof(PBYTE) ;
    pStatic->snapShotTable[dwI].dwDefaultValue = 0 ;
    pStatic->snapShotTable[dwI].dwFlags = SSF_MAKE_STRINGPTR ;
    pStatic->snapShotTable[dwI].dwGIDflags = 0 ;
    dwI++ ;


    pStatic->snapShotTable[dwI].pstrKeyword  = "*OEMCustomData" ;
    pStatic->snapShotTable[dwI].dwSrcOffset  = offsetof(GLOBALATTRIB,
                                        atrOEMCustomData) ;
    pStatic->snapShotTable[dwI].dwDestOffset = offsetof(GLOBALS,
                                        dwOEMCustomData) ;
    pStatic->snapShotTable[dwI].dwNbytes = sizeof(DWORD) ;
    pStatic->snapShotTable[dwI].dwDefaultValue = 0 ;
    pStatic->snapShotTable[dwI].dwFlags = SSF_STRINGLEN ;
    pStatic->snapShotTable[dwI].dwGIDflags = 0 ;
    dwI++ ;



    pStatic->snapShotTable[dwI].pstrKeyword  = "*RotateCoordinate?" ;
    pStatic->snapShotTable[dwI].dwSrcOffset  = offsetof(GLOBALATTRIB,
                                        atrRotateCoordinate) ;
    pStatic->snapShotTable[dwI].dwDestOffset = offsetof(GLOBALS,
                                        bRotateCoordinate) ;
    pStatic->snapShotTable[dwI].dwNbytes = sizeof(BOOL) ;
    pStatic->snapShotTable[dwI].dwDefaultValue = FALSE ;
    pStatic->snapShotTable[dwI].dwFlags = 0 ;
    pStatic->snapShotTable[dwI].dwGIDflags = 0 ;
    dwI++ ;

    pStatic->snapShotTable[dwI].pstrKeyword  = "*RotateRaster?" ;
    pStatic->snapShotTable[dwI].dwSrcOffset  = offsetof(GLOBALATTRIB,
                                        atrRotateRasterData) ;
    pStatic->snapShotTable[dwI].dwDestOffset = offsetof(GLOBALS,
                                        bRotateRasterData) ;
    pStatic->snapShotTable[dwI].dwNbytes = sizeof(BOOL) ;
    pStatic->snapShotTable[dwI].dwDefaultValue = FALSE ;
    pStatic->snapShotTable[dwI].dwFlags = 0 ;
    pStatic->snapShotTable[dwI].dwGIDflags = 0 ;
    dwI++ ;

    pStatic->snapShotTable[dwI].pstrKeyword  = "*TextCaps" ;
    pStatic->snapShotTable[dwI].dwSrcOffset  = offsetof(GLOBALATTRIB,
                                        atrTextCaps) ;
    pStatic->snapShotTable[dwI].dwDestOffset = offsetof(GLOBALS,
                                        liTextCaps) ;
    pStatic->snapShotTable[dwI].dwNbytes = sizeof(LISTINDEX) ;
    pStatic->snapShotTable[dwI].dwDefaultValue = END_OF_LIST  ;
    pStatic->snapShotTable[dwI].dwFlags = 0 ;
    pStatic->snapShotTable[dwI].dwGIDflags = 0 ;
    dwI++ ;

    pStatic->snapShotTable[dwI].pstrKeyword  = "*RotateFont?" ;
    pStatic->snapShotTable[dwI].dwSrcOffset  = offsetof(GLOBALATTRIB,
                                        atrRotateFont) ;
    pStatic->snapShotTable[dwI].dwDestOffset = offsetof(GLOBALS,
                                        bRotateFont) ;
    pStatic->snapShotTable[dwI].dwNbytes = sizeof(BOOL) ;
    pStatic->snapShotTable[dwI].dwDefaultValue = FALSE ;
    pStatic->snapShotTable[dwI].dwFlags = 0 ;
    pStatic->snapShotTable[dwI].dwGIDflags = 0 ;
    dwI++ ;

    pStatic->snapShotTable[dwI].pstrKeyword  = "*MemoryUsage" ;
    pStatic->snapShotTable[dwI].dwSrcOffset  = offsetof(GLOBALATTRIB,
                                        atrMemoryUsage) ;
    pStatic->snapShotTable[dwI].dwDestOffset = offsetof(GLOBALS,
                                        liMemoryUsage) ;
    pStatic->snapShotTable[dwI].dwNbytes = sizeof(LISTINDEX) ;
    pStatic->snapShotTable[dwI].dwDefaultValue = END_OF_LIST  ;
    pStatic->snapShotTable[dwI].dwFlags = 0 ;
    pStatic->snapShotTable[dwI].dwGIDflags = 0 ;
    dwI++ ;

    pStatic->snapShotTable[dwI].pstrKeyword  = "*ReselectFont" ;
    pStatic->snapShotTable[dwI].dwSrcOffset  = offsetof(GLOBALATTRIB,
                                        atrReselectFont) ;
    pStatic->snapShotTable[dwI].dwDestOffset = offsetof(GLOBALS,
                                        liReselectFont) ;
    pStatic->snapShotTable[dwI].dwNbytes = sizeof(LISTINDEX) ;
    pStatic->snapShotTable[dwI].dwDefaultValue = END_OF_LIST  ;
    pStatic->snapShotTable[dwI].dwFlags = 0 ;
    pStatic->snapShotTable[dwI].dwGIDflags = 0 ;
    dwI++ ;

    pStatic->snapShotTable[dwI].pstrKeyword  = "*OEMPrintingCallbacks" ;
    pStatic->snapShotTable[dwI].dwSrcOffset  = offsetof(GLOBALATTRIB,
                                        atrOEMPrintingCallbacks) ;
    pStatic->snapShotTable[dwI].dwDestOffset = offsetof(GLOBALS,
                                        liOEMPrintingCallbacks) ;
    pStatic->snapShotTable[dwI].dwNbytes = sizeof(LISTINDEX) ;
    pStatic->snapShotTable[dwI].dwDefaultValue = END_OF_LIST  ;
    pStatic->snapShotTable[dwI].dwFlags = 0 ;
    pStatic->snapShotTable[dwI].dwGIDflags = 0 ;
    dwI++ ;


#if 0
    dead keyword
    pStatic->snapShotTable[dwI].dwSrcOffset  = offsetof(DFEATURE_OPTIONS,
                                        atrMinSize) ;
    pStatic->snapShotTable[dwI].dwDestOffset = offsetof(GLOBALS,
                                        ptMinSize) ;
    pStatic->snapShotTable[dwI].dwNbytes = sizeof(POINT) ;
    pStatic->snapShotTable[dwI].dwDefaultValue = 0 ;
    pStatic->snapShotTable[dwI].dwFlags = 0 ;
    //  only SSF_REQUIRED for custompage;
    pStatic->snapShotTable[dwI].dwGIDflags = GIDF_PAGESIZE ;
//    pmrbd->dwSSPaperSizeMinSizeIndex = dwI ;
    dwI++ ;

    pStatic->snapShotTable[dwI].dwSrcOffset  = offsetof(DFEATURE_OPTIONS,
                                        atrMaxSize) ;
    pStatic->snapShotTable[dwI].dwDestOffset = offsetof(GLOBALS,
                                        ptMaxSize) ;
    pStatic->snapShotTable[dwI].dwNbytes = sizeof(POINT) ;
    pStatic->snapShotTable[dwI].dwDefaultValue = 0 ;
    pStatic->snapShotTable[dwI].dwFlags = 0 ;
    pStatic->snapShotTable[dwI].dwGIDflags = GIDF_PAGESIZE ;
//    pmrbd->dwSSPaperSizeMaxSizeIndex = dwI ;
    dwI++ ;


    pStatic->snapShotTable[dwI].dwSrcOffset  = offsetof(GLOBALATTRIB,
                                        atrMaxPrintableArea) ;
    pStatic->snapShotTable[dwI].dwDestOffset = offsetof(GLOBALS,
                                        ptMaxPrintableArea) ;
    pStatic->snapShotTable[dwI].dwNbytes = sizeof(POINT) ;
    pStatic->snapShotTable[dwI].dwDefaultValue = 0 ;
    pStatic->snapShotTable[dwI].dwFlags = 0 ;
    pStatic->snapShotTable[dwI].dwGIDflags = 0 ;
    dwI++ ;


    dead keyword
    pStatic->snapShotTable[dwI].dwSrcOffset  = offsetof(GLOBALATTRIB,
                                        atrRasterCaps) ;
    pStatic->snapShotTable[dwI].dwDestOffset = offsetof(GLOBALS,
                                        ) ;
    pStatic->snapShotTable[dwI].dwNbytes = sizeof(POINT) ;
    pStatic->snapShotTable[dwI].dwDefaultValue = 0 ;
    pStatic->snapShotTable[dwI].dwFlags = 0 ;
    pStatic->snapShotTable[dwI].dwGIDflags = 0 ;
    dwI++ ;



    pStatic->snapShotTable[dwI].dwSrcOffset  = offsetof(GLOBALATTRIB,
                                        atrMinOverlayID) ;
    pStatic->snapShotTable[dwI].dwDestOffset = offsetof(GLOBALS,
                                        iMinOverlayID) ;
    pStatic->snapShotTable[dwI].dwNbytes = sizeof(INT) ;
    pStatic->snapShotTable[dwI].dwDefaultValue = 1 ;
    pStatic->snapShotTable[dwI].dwFlags = 0 ;
    pStatic->snapShotTable[dwI].dwGIDflags = 0 ;
    dwI++ ;

    pStatic->snapShotTable[dwI].dwSrcOffset  = offsetof(GLOBALATTRIB,
                                        atrMaxOverlayID) ;
    pStatic->snapShotTable[dwI].dwDestOffset = offsetof(GLOBALS,
                                        iMaxOverlayID) ;
    pStatic->snapShotTable[dwI].dwNbytes = sizeof(INT) ;
    pStatic->snapShotTable[dwI].dwDefaultValue = NO_LIMIT_NUM ;
    pStatic->snapShotTable[dwI].dwFlags = 0 ;
    pStatic->snapShotTable[dwI].dwGIDflags = 0 ;
    dwI++ ;


    dead keyword
    pStatic->snapShotTable[dwI].dwSrcOffset  = offsetof(GLOBALATTRIB,
                                        atrLandscapeGrxRotation) ;
    pStatic->snapShotTable[dwI].dwDestOffset = offsetof(GLOBALS,
                                        dwLandscapeGrxRotation) ;
    pStatic->snapShotTable[dwI].dwNbytes = sizeof(DWORD) ;
    pStatic->snapShotTable[dwI].dwDefaultValue = LGR_NONE ;
    pStatic->snapShotTable[dwI].dwFlags = 0 ;
    pStatic->snapShotTable[dwI].dwGIDflags = 0 ;
    dwI++ ;


    pStatic->snapShotTable[dwI].dwSrcOffset  = offsetof(GLOBALATTRIB,
                                        atrIncrementalDownload) ;
    pStatic->snapShotTable[dwI].dwDestOffset = offsetof(GLOBALS,
                                        bIncrementalDownload) ;
    pStatic->snapShotTable[dwI].dwNbytes = sizeof(BOOL) ;
    pStatic->snapShotTable[dwI].dwDefaultValue = TRUE ;
    pStatic->snapShotTable[dwI].dwFlags = 0 ;
    pStatic->snapShotTable[dwI].dwGIDflags = 0 ;
    dwI++ ;

    pStatic->snapShotTable[dwI].dwSrcOffset  = offsetof(GLOBALATTRIB,
                                        atrMemoryForFontsOnly) ;
    pStatic->snapShotTable[dwI].dwDestOffset = offsetof(GLOBALS,
                                        bMemoryForFontsOnly) ;
    pStatic->snapShotTable[dwI].dwNbytes = sizeof(BOOL) ;
    pStatic->snapShotTable[dwI].dwDefaultValue = FALSE ;
    pStatic->snapShotTable[dwI].dwFlags = 0 ;
    pStatic->snapShotTable[dwI].dwGIDflags = 0 ;
    dwI++ ;

    pStatic->snapShotTable[dwI].dwSrcOffset  = offsetof(GLOBALATTRIB,
                                        atrRotateFont) ;
    pStatic->snapShotTable[dwI].dwDestOffset = offsetof(GLOBALS,
                                        bRotateFont) ;
    pStatic->snapShotTable[dwI].dwNbytes = sizeof(BOOL) ;
    pStatic->snapShotTable[dwI].dwDefaultValue = TRUE ;
    pStatic->snapShotTable[dwI].dwFlags = 0 ;
    pStatic->snapShotTable[dwI].dwGIDflags = 0 ;
    dwI++ ;


//-----


    pStatic->snapShotTable[dwI].dwSrcOffset  = offsetof(GLOBALATTRIB,
                                        atrRasterZeroFill) ;
    pStatic->snapShotTable[dwI].dwDestOffset = offsetof(GLOBALS,
                                        bRasterZeroFill) ;
    pStatic->snapShotTable[dwI].dwNbytes = sizeof(BOOL) ;
    pStatic->snapShotTable[dwI].dwDefaultValue = TRUE ;
    pStatic->snapShotTable[dwI].dwFlags = 0 ;
    pStatic->snapShotTable[dwI].dwGIDflags = 0 ;
    dwI++ ;



    dead keyword
    pStatic->snapShotTable[dwI].dwSrcOffset  = offsetof(GLOBALATTRIB,
                                        atrRestoreDefaultFont) ;
    pStatic->snapShotTable[dwI].dwDestOffset = offsetof(GLOBALS,
                                        bRestoreDefaultFont) ;
    pStatic->snapShotTable[dwI].dwNbytes = sizeof(BOOL) ;
    pStatic->snapShotTable[dwI].dwDefaultValue = FALSE ;
    pStatic->snapShotTable[dwI].dwFlags = 0 ;
    pStatic->snapShotTable[dwI].dwGIDflags = 0 ;
    dwI++ ;



#endif

    //
    // Cursor Control related information
    //



    pStatic->snapShotTable[dwI].pstrKeyword  = "*CursorXAfterCR" ;
    pStatic->snapShotTable[dwI].dwSrcOffset  = offsetof(GLOBALATTRIB,
                                        atrCursorXAfterCR) ;
    pStatic->snapShotTable[dwI].dwDestOffset = offsetof(GLOBALS,
                                        cxaftercr) ;
    pStatic->snapShotTable[dwI].dwNbytes = sizeof(CURSORXAFTERCR) ;
    pStatic->snapShotTable[dwI].dwDefaultValue = CXCR_AT_CURSOR_X_ORIGIN ;
    pStatic->snapShotTable[dwI].dwFlags = 0 ;
    pStatic->snapShotTable[dwI].dwGIDflags = 0 ;
    dwI++ ;

    pStatic->snapShotTable[dwI].pstrKeyword  = "*BadCursorMoveInGrxMode" ;
    pStatic->snapShotTable[dwI].dwSrcOffset  = offsetof(GLOBALATTRIB,
                                        atrBadCursorMoveInGrxMode) ;
    pStatic->snapShotTable[dwI].dwDestOffset = offsetof(GLOBALS,
                                        liBadCursorMoveInGrxMode) ;
    pStatic->snapShotTable[dwI].dwNbytes = sizeof(LISTINDEX) ;
    pStatic->snapShotTable[dwI].dwDefaultValue = END_OF_LIST ;
    pStatic->snapShotTable[dwI].dwFlags = 0 ;
    pStatic->snapShotTable[dwI].dwGIDflags = 0 ;
    dwI++ ;


    pStatic->snapShotTable[dwI].pstrKeyword  = "*YMoveAttributes" ;
    pStatic->snapShotTable[dwI].dwSrcOffset  = offsetof(GLOBALATTRIB,
                                        atrYMoveAttributes) ;
    pStatic->snapShotTable[dwI].dwDestOffset = offsetof(GLOBALS,
                                        liYMoveAttributes) ;
    pStatic->snapShotTable[dwI].dwNbytes = sizeof(LISTINDEX) ;
    pStatic->snapShotTable[dwI].dwDefaultValue = END_OF_LIST ;
    pStatic->snapShotTable[dwI].dwFlags = 0 ;
    pStatic->snapShotTable[dwI].dwGIDflags = 0 ;
    dwI++ ;

    pStatic->snapShotTable[dwI].pstrKeyword  = "*MaxLineSpacing" ;
    pStatic->snapShotTable[dwI].dwSrcOffset  = offsetof(GLOBALATTRIB,
                                        atrMaxLineSpacing) ;
    pStatic->snapShotTable[dwI].dwDestOffset = offsetof(GLOBALS,
                                        dwMaxLineSpacing) ;
    pStatic->snapShotTable[dwI].dwNbytes = sizeof(DWORD) ;
    pStatic->snapShotTable[dwI].dwDefaultValue = NO_LIMIT_NUM ;
    pStatic->snapShotTable[dwI].dwFlags = 0 ;
    pStatic->snapShotTable[dwI].dwGIDflags = 0 ;
    dwI++ ;

    pStatic->snapShotTable[dwI].pstrKeyword  = "*UseSpaceForXMove?" ;
    pStatic->snapShotTable[dwI].dwSrcOffset  = offsetof(GLOBALATTRIB,
                                        atrbUseSpaceForXMove) ;
    pStatic->snapShotTable[dwI].dwDestOffset = offsetof(GLOBALS,
                                        bUseSpaceForXMove) ;
    pStatic->snapShotTable[dwI].dwNbytes = sizeof(BOOL) ;
    pStatic->snapShotTable[dwI].dwDefaultValue = TRUE ;
    pStatic->snapShotTable[dwI].dwFlags = 0 ;
    pStatic->snapShotTable[dwI].dwGIDflags = 0 ;
    dwI++ ;

    pStatic->snapShotTable[dwI].pstrKeyword  = "*AbsXMovesRightOnly?" ;
    pStatic->snapShotTable[dwI].dwSrcOffset  = offsetof(GLOBALATTRIB,
                                        atrbAbsXMovesRightOnly) ;
    pStatic->snapShotTable[dwI].dwDestOffset = offsetof(GLOBALS,
                                        bAbsXMovesRightOnly) ;
    pStatic->snapShotTable[dwI].dwNbytes = sizeof(BOOL) ;
    pStatic->snapShotTable[dwI].dwDefaultValue =  FALSE;
    pStatic->snapShotTable[dwI].dwFlags = 0 ;
    pStatic->snapShotTable[dwI].dwGIDflags = 0 ;
    dwI++ ;



    pStatic->snapShotTable[dwI].pstrKeyword  = "*EjectPageWithFF?" ;
    pStatic->snapShotTable[dwI].dwSrcOffset  = offsetof(GLOBALATTRIB,
                                        atrEjectPageWithFF) ;
    pStatic->snapShotTable[dwI].dwDestOffset = offsetof(GLOBALS,
                                        bEjectPageWithFF) ;
    pStatic->snapShotTable[dwI].dwNbytes = sizeof(BOOL) ;
    pStatic->snapShotTable[dwI].dwDefaultValue = FALSE ;
    pStatic->snapShotTable[dwI].dwFlags = 0 ;
    pStatic->snapShotTable[dwI].dwGIDflags = 0 ;
    dwI++ ;


    pStatic->snapShotTable[dwI].pstrKeyword  = "*XMoveThreshold" ;
    pStatic->snapShotTable[dwI].dwSrcOffset  = offsetof(GLOBALATTRIB,
                                        atrXMoveThreshold) ;
    pStatic->snapShotTable[dwI].dwDestOffset = offsetof(GLOBALS,
                                        dwXMoveThreshold) ;
    pStatic->snapShotTable[dwI].dwNbytes = sizeof(DWORD) ;
    pStatic->snapShotTable[dwI].dwDefaultValue = 0 ;
    pStatic->snapShotTable[dwI].dwFlags = 0 ;
    pStatic->snapShotTable[dwI].dwGIDflags = 0 ;
    dwI++ ;

    pStatic->snapShotTable[dwI].pstrKeyword  = "*YMoveThreshold" ;
    pStatic->snapShotTable[dwI].dwSrcOffset  = offsetof(GLOBALATTRIB,
                                        atrYMoveThreshold) ;
    pStatic->snapShotTable[dwI].dwDestOffset = offsetof(GLOBALS,
                                        dwYMoveThreshold) ;
    pStatic->snapShotTable[dwI].dwNbytes = sizeof(DWORD) ;
    pStatic->snapShotTable[dwI].dwDefaultValue = 0 ;
    pStatic->snapShotTable[dwI].dwFlags = 0 ;
    pStatic->snapShotTable[dwI].dwGIDflags = 0 ;
    dwI++ ;

    pStatic->snapShotTable[dwI].pstrKeyword  = "*XMoveUnit" ;
    pStatic->snapShotTable[dwI].dwSrcOffset  = offsetof(GLOBALATTRIB,
                                        atrXMoveUnits) ;
    pStatic->snapShotTable[dwI].dwDestOffset = offsetof(GLOBALS,
                                        ptDeviceUnits.x) ;
    pStatic->snapShotTable[dwI].dwNbytes = sizeof(DWORD) ;
    pStatic->snapShotTable[dwI].dwDefaultValue = 1 ;
    pStatic->snapShotTable[dwI].dwFlags = 0 ; // Required if
    pStatic->snapShotTable[dwI].dwGIDflags = 0 ;
    dwI++ ;

    pStatic->snapShotTable[dwI].pstrKeyword  = "*YMoveUnit" ;
    pStatic->snapShotTable[dwI].dwSrcOffset  = offsetof(GLOBALATTRIB,
                                        atrYMoveUnits) ;
    pStatic->snapShotTable[dwI].dwDestOffset = offsetof(GLOBALS,
                                        ptDeviceUnits.y) ;
    pStatic->snapShotTable[dwI].dwNbytes = sizeof(DWORD) ;
    pStatic->snapShotTable[dwI].dwDefaultValue = 1 ;
    pStatic->snapShotTable[dwI].dwFlags = 0 ; // Required if
    pStatic->snapShotTable[dwI].dwGIDflags = 0 ;
    dwI++ ;

    pStatic->snapShotTable[dwI].pstrKeyword  = "*LineSpacingMoveUnit" ;
    pStatic->snapShotTable[dwI].dwSrcOffset  = offsetof(GLOBALATTRIB,
                                        atrLineSpacingMoveUnit) ;
    pStatic->snapShotTable[dwI].dwDestOffset = offsetof(GLOBALS,
                                        dwLineSpacingMoveUnit) ;
    pStatic->snapShotTable[dwI].dwNbytes = sizeof(DWORD) ;
    pStatic->snapShotTable[dwI].dwDefaultValue = 0 ;
    pStatic->snapShotTable[dwI].dwFlags = 0 ; // unidrv will assume a default value.
    pStatic->snapShotTable[dwI].dwGIDflags = 0 ;
    dwI++ ;


    //
    // Color related information
    //



    pStatic->snapShotTable[dwI].pstrKeyword  = "*ChangeColorModeOnPage?" ;
    pStatic->snapShotTable[dwI].dwSrcOffset  = offsetof(GLOBALATTRIB,
                                        atrChangeColorMode) ;
    pStatic->snapShotTable[dwI].dwDestOffset = offsetof(GLOBALS,
                                        bChangeColorMode) ;
    pStatic->snapShotTable[dwI].dwNbytes = sizeof(BOOL) ;
    pStatic->snapShotTable[dwI].dwDefaultValue = FALSE ;
    pStatic->snapShotTable[dwI].dwFlags = 0 ;
    pStatic->snapShotTable[dwI].dwGIDflags = 0 ;
    dwI++ ;

    pStatic->snapShotTable[dwI].pstrKeyword  = "*MagentaInCyanDye" ;
    pStatic->snapShotTable[dwI].dwSrcOffset  = offsetof(GLOBALATTRIB,
                                        atrMagentaInCyanDye) ;
    pStatic->snapShotTable[dwI].dwDestOffset = offsetof(GLOBALS,
                                        dwMagentaInCyanDye) ;
    pStatic->snapShotTable[dwI].dwNbytes = sizeof(DWORD) ;
    pStatic->snapShotTable[dwI].dwDefaultValue = UNUSED_ITEM ;
    pStatic->snapShotTable[dwI].dwFlags = 0 ;
    pStatic->snapShotTable[dwI].dwGIDflags = 0 ;
    dwI++ ;

    pStatic->snapShotTable[dwI].pstrKeyword  = "*YellowInCyanDye" ;
    pStatic->snapShotTable[dwI].dwSrcOffset  = offsetof(GLOBALATTRIB,
                                        atrYellowInCyanDye) ;
    pStatic->snapShotTable[dwI].dwDestOffset = offsetof(GLOBALS,
                                        dwYellowInCyanDye) ;
    pStatic->snapShotTable[dwI].dwNbytes = sizeof(DWORD) ;
    pStatic->snapShotTable[dwI].dwDefaultValue = UNUSED_ITEM ;
    pStatic->snapShotTable[dwI].dwFlags = 0 ;
    pStatic->snapShotTable[dwI].dwGIDflags = 0 ;
    dwI++ ;

    pStatic->snapShotTable[dwI].pstrKeyword  = "*CyanInMagentaDye" ;
    pStatic->snapShotTable[dwI].dwSrcOffset  = offsetof(GLOBALATTRIB,
                                        atrCyanInMagentaDye) ;
    pStatic->snapShotTable[dwI].dwDestOffset = offsetof(GLOBALS,
                                        dwCyanInMagentaDye) ;
    pStatic->snapShotTable[dwI].dwNbytes = sizeof(DWORD) ;
    pStatic->snapShotTable[dwI].dwDefaultValue = UNUSED_ITEM ;
    pStatic->snapShotTable[dwI].dwFlags = 0 ;
    pStatic->snapShotTable[dwI].dwGIDflags = 0 ;
    dwI++ ;

    pStatic->snapShotTable[dwI].pstrKeyword  = "*YellowInMagentaDye" ;
    pStatic->snapShotTable[dwI].dwSrcOffset  = offsetof(GLOBALATTRIB,
                                        atrYellowInMagentaDye) ;
    pStatic->snapShotTable[dwI].dwDestOffset = offsetof(GLOBALS,
                                        dwYellowInMagentaDye) ;
    pStatic->snapShotTable[dwI].dwNbytes = sizeof(DWORD) ;
    pStatic->snapShotTable[dwI].dwDefaultValue = UNUSED_ITEM ;
    pStatic->snapShotTable[dwI].dwFlags = 0 ;
    pStatic->snapShotTable[dwI].dwGIDflags = 0 ;
    dwI++ ;

    pStatic->snapShotTable[dwI].pstrKeyword  = "*CyanInYellowDye" ;
    pStatic->snapShotTable[dwI].dwSrcOffset  = offsetof(GLOBALATTRIB,
                                        atrCyanInYellowDye) ;
    pStatic->snapShotTable[dwI].dwDestOffset = offsetof(GLOBALS,
                                        dwCyanInYellowDye) ;
    pStatic->snapShotTable[dwI].dwNbytes = sizeof(DWORD) ;
    pStatic->snapShotTable[dwI].dwDefaultValue = UNUSED_ITEM ;
    pStatic->snapShotTable[dwI].dwFlags = 0 ;
    pStatic->snapShotTable[dwI].dwGIDflags = 0 ;
    dwI++ ;

    pStatic->snapShotTable[dwI].pstrKeyword  = "*MagentaInYellowDye" ;
    pStatic->snapShotTable[dwI].dwSrcOffset  = offsetof(GLOBALATTRIB,
                                        atrMagentaInYellowDye) ;
    pStatic->snapShotTable[dwI].dwDestOffset = offsetof(GLOBALS,
                                        dwMagentaInYellowDye) ;
    pStatic->snapShotTable[dwI].dwNbytes = sizeof(DWORD) ;
    pStatic->snapShotTable[dwI].dwDefaultValue = UNUSED_ITEM ;
    pStatic->snapShotTable[dwI].dwFlags = 0 ;
    pStatic->snapShotTable[dwI].dwGIDflags = 0 ;
    dwI++ ;


// BUG_BUG!   to be deleted: following 3 pallete entries.
//  but Alvin uses this entry as a secret testing mechanism
//  see ifdef TESTBAND  for example.
    pStatic->snapShotTable[dwI].pstrKeyword  = "*MaxNumPalettes" ;
    pStatic->snapShotTable[dwI].dwSrcOffset  = offsetof(GLOBALATTRIB,
                                        atrMaxNumPalettes) ;
    pStatic->snapShotTable[dwI].dwDestOffset = offsetof(GLOBALS,
                                        dwMaxNumPalettes) ;
    pStatic->snapShotTable[dwI].dwNbytes = sizeof(DWORD) ;
    pStatic->snapShotTable[dwI].dwDefaultValue = 0 ;
    pStatic->snapShotTable[dwI].dwFlags = 0;
    pStatic->snapShotTable[dwI].dwGIDflags = 0 ;
    dwI++ ;

#if 0
    pStatic->snapShotTable[dwI].pstrKeyword  = "*PaletteSizes" ;
    pStatic->snapShotTable[dwI].dwSrcOffset  = offsetof(GLOBALATTRIB,
                                        atrPaletteSizes) ;
    pStatic->snapShotTable[dwI].dwDestOffset = offsetof(GLOBALS,
                                        liPaletteSizes) ;
    pStatic->snapShotTable[dwI].dwNbytes = sizeof(LISTINDEX) ;
    pStatic->snapShotTable[dwI].dwDefaultValue = END_OF_LIST ;
    pStatic->snapShotTable[dwI].dwFlags = 0 ;  //  conditionally req.
    pStatic->snapShotTable[dwI].dwGIDflags = 0 ;
    dwI++ ;

    pStatic->snapShotTable[dwI].pstrKeyword  = "*PaletteScope" ;
    pStatic->snapShotTable[dwI].dwSrcOffset  = offsetof(GLOBALATTRIB,
                                        atrPaletteScope) ;
    pStatic->snapShotTable[dwI].dwDestOffset = offsetof(GLOBALS,
                                        liPaletteScope) ;
    pStatic->snapShotTable[dwI].dwNbytes = sizeof(LISTINDEX) ;
    pStatic->snapShotTable[dwI].dwDefaultValue = END_OF_LIST ;
    pStatic->snapShotTable[dwI].dwFlags = 0 ;
    pStatic->snapShotTable[dwI].dwGIDflags = 0 ;
    dwI++ ;

#endif


    //
    // Raster related information
    //




    pStatic->snapShotTable[dwI].pstrKeyword  = "*OutputDataFormat" ;
    pStatic->snapShotTable[dwI].dwSrcOffset  = offsetof(GLOBALATTRIB,
                                        atrOutputDataFormat) ;
    pStatic->snapShotTable[dwI].dwDestOffset = offsetof(GLOBALS,
                                        outputdataformat) ;
    pStatic->snapShotTable[dwI].dwNbytes = sizeof(OUTPUTDATAFORMAT) ;
    pStatic->snapShotTable[dwI].dwDefaultValue = ODF_H_BYTE ;
    pStatic->snapShotTable[dwI].dwFlags = 0 ;
    pStatic->snapShotTable[dwI].dwGIDflags = 0 ;
    dwI++ ;


    pStatic->snapShotTable[dwI].pstrKeyword  = "*OptimizeLeftBound?" ;
    pStatic->snapShotTable[dwI].dwSrcOffset  = offsetof(GLOBALATTRIB,
                                        atrOptimizeLeftBound) ;
    pStatic->snapShotTable[dwI].dwDestOffset = offsetof(GLOBALS,
                                        bOptimizeLeftBound) ;
    pStatic->snapShotTable[dwI].dwNbytes = sizeof(BOOL) ;
    pStatic->snapShotTable[dwI].dwDefaultValue = FALSE ;
    pStatic->snapShotTable[dwI].dwFlags = 0 ;
    pStatic->snapShotTable[dwI].dwGIDflags = 0 ;
    dwI++ ;

    pStatic->snapShotTable[dwI].pstrKeyword  = "*StripBlanks" ;
    pStatic->snapShotTable[dwI].dwSrcOffset  = offsetof(GLOBALATTRIB,
                                        atrStripBlanks) ;
    pStatic->snapShotTable[dwI].dwDestOffset = offsetof(GLOBALS,
                                        liStripBlanks) ;
    pStatic->snapShotTable[dwI].dwNbytes = sizeof(LISTINDEX) ;
    pStatic->snapShotTable[dwI].dwDefaultValue = END_OF_LIST  ;
    pStatic->snapShotTable[dwI].dwFlags = 0 ;
    pStatic->snapShotTable[dwI].dwGIDflags = 0 ;
    dwI++ ;

    pStatic->snapShotTable[dwI].pstrKeyword  = "*RasterSendAllData?" ;
    pStatic->snapShotTable[dwI].dwSrcOffset  = offsetof(GLOBALATTRIB,
                                        atrRasterSendAllData) ;
    pStatic->snapShotTable[dwI].dwDestOffset = offsetof(GLOBALS,
                                        bRasterSendAllData) ;
    pStatic->snapShotTable[dwI].dwNbytes = sizeof(BOOL) ;
    pStatic->snapShotTable[dwI].dwDefaultValue = FALSE ;
    pStatic->snapShotTable[dwI].dwFlags = 0 ;
    pStatic->snapShotTable[dwI].dwGIDflags = 0 ;
    dwI++ ;

    pStatic->snapShotTable[dwI].pstrKeyword  = "*CursorXAfterSendBlockData" ;
    pStatic->snapShotTable[dwI].dwSrcOffset  = offsetof(GLOBALATTRIB,
                                        atrCursorXAfterSendBlockData) ;
    pStatic->snapShotTable[dwI].dwDestOffset = offsetof(GLOBALS,
                                        cxafterblock) ;
    pStatic->snapShotTable[dwI].dwNbytes = sizeof(CURSORXAFTERSENDBLOCKDATA) ;
    pStatic->snapShotTable[dwI].dwDefaultValue = CXSBD_AT_GRXDATA_END ;
    pStatic->snapShotTable[dwI].dwFlags = 0 ;
    pStatic->snapShotTable[dwI].dwGIDflags = 0 ;
    dwI++ ;

    pStatic->snapShotTable[dwI].pstrKeyword  = "*CursorYAfterSendBlockData" ;
    pStatic->snapShotTable[dwI].dwSrcOffset  = offsetof(GLOBALATTRIB,
                                        atrCursorYAfterSendBlockData) ;
    pStatic->snapShotTable[dwI].dwDestOffset = offsetof(GLOBALS,
                                        cyafterblock) ;
    pStatic->snapShotTable[dwI].dwNbytes = sizeof(CURSORYAFTERSENDBLOCKDATA) ;
    pStatic->snapShotTable[dwI].dwDefaultValue = CYSBD_NO_MOVE ;
    pStatic->snapShotTable[dwI].dwFlags = 0 ;
    pStatic->snapShotTable[dwI].dwGIDflags = 0 ;
    dwI++ ;

    pStatic->snapShotTable[dwI].pstrKeyword  = "*MirrorRasterByte?" ;
    pStatic->snapShotTable[dwI].dwSrcOffset  = offsetof(GLOBALATTRIB,
                                        atrMirrorRasterByte) ;
    pStatic->snapShotTable[dwI].dwDestOffset = offsetof(GLOBALS,
                                        bMirrorRasterByte) ;
    pStatic->snapShotTable[dwI].dwNbytes = sizeof(BOOL) ;
    pStatic->snapShotTable[dwI].dwDefaultValue = FALSE ;
    pStatic->snapShotTable[dwI].dwFlags = 0 ;
    pStatic->snapShotTable[dwI].dwGIDflags = 0 ;
    dwI++ ;

    pStatic->snapShotTable[dwI].pstrKeyword  = "*MirrorRasterPage?" ;
    pStatic->snapShotTable[dwI].dwSrcOffset  = offsetof(GLOBALATTRIB,
                                        atrMirrorRasterPage) ;
    pStatic->snapShotTable[dwI].dwDestOffset = offsetof(GLOBALS,
                                        bMirrorRasterPage) ;
    pStatic->snapShotTable[dwI].dwNbytes = sizeof(BOOL) ;
    pStatic->snapShotTable[dwI].dwDefaultValue = FALSE ;
    pStatic->snapShotTable[dwI].dwFlags = 0 ;
    pStatic->snapShotTable[dwI].dwGIDflags = 0 ;
    dwI++ ;


    pStatic->snapShotTable[dwI].pstrKeyword  = "*UseExpColorSelectCmd?" ;
    pStatic->snapShotTable[dwI].dwSrcOffset  = offsetof(GLOBALATTRIB,
                                        atrUseColorSelectCmd) ;
    pStatic->snapShotTable[dwI].dwDestOffset = offsetof(GLOBALS,
                                        bUseCmdSendBlockDataForColor) ;
    pStatic->snapShotTable[dwI].dwNbytes = sizeof(BOOL) ;
    pStatic->snapShotTable[dwI].dwDefaultValue = FALSE  ;
    pStatic->snapShotTable[dwI].dwFlags = 0 ;
    pStatic->snapShotTable[dwI].dwGIDflags = 0 ;
    dwI++ ;

    pStatic->snapShotTable[dwI].pstrKeyword  = "*MoveToX0BeforeSetColor?" ;
    pStatic->snapShotTable[dwI].dwSrcOffset  = offsetof(GLOBALATTRIB,
                                        atrMoveToX0BeforeColor) ;
    pStatic->snapShotTable[dwI].dwDestOffset = offsetof(GLOBALS,
                                        bMoveToX0BeforeColor) ;
    pStatic->snapShotTable[dwI].dwNbytes = sizeof(BOOL) ;
    pStatic->snapShotTable[dwI].dwDefaultValue = FALSE   ;
    pStatic->snapShotTable[dwI].dwFlags = 0 ;
    pStatic->snapShotTable[dwI].dwGIDflags = 0 ;
    dwI++ ;


    pStatic->snapShotTable[dwI].pstrKeyword  = "*EnableGDIColorMapping?" ;
    pStatic->snapShotTable[dwI].dwSrcOffset  = offsetof(GLOBALATTRIB,
                                        atrEnableGDIColorMapping) ;
    pStatic->snapShotTable[dwI].dwDestOffset = offsetof(GLOBALS,
                                        bEnableGDIColorMapping) ;
    pStatic->snapShotTable[dwI].dwNbytes = sizeof(BOOL) ;
    pStatic->snapShotTable[dwI].dwDefaultValue = FALSE   ;
    pStatic->snapShotTable[dwI].dwFlags = 0 ;
    pStatic->snapShotTable[dwI].dwGIDflags = 0 ;
    dwI++ ;


    pStatic->snapShotTable[dwI].pstrKeyword  = "*SendMultipleRows?" ;
    pStatic->snapShotTable[dwI].dwSrcOffset  = offsetof(GLOBALATTRIB,
                                        atrSendMultipleRows) ;
    pStatic->snapShotTable[dwI].dwDestOffset = offsetof(GLOBALS,
                                        bSendMultipleRows) ;
    pStatic->snapShotTable[dwI].dwNbytes = sizeof(BOOL) ;
    pStatic->snapShotTable[dwI].dwDefaultValue = FALSE ;
    pStatic->snapShotTable[dwI].dwFlags = 0 ;
    pStatic->snapShotTable[dwI].dwGIDflags = 0 ;
    dwI++ ;



    //
    //Font Information
    //Device Font Specific.
    //



    pStatic->snapShotTable[dwI].pstrKeyword  = "*DeviceFonts" ;
    pStatic->snapShotTable[dwI].dwSrcOffset  = offsetof(GLOBALATTRIB,
                                        atrDeviceFontsList ) ;
    pStatic->snapShotTable[dwI].dwDestOffset = offsetof(GLOBALS,
                                        liDeviceFontList) ;
    pStatic->snapShotTable[dwI].dwNbytes = sizeof(LISTINDEX) ;
    pStatic->snapShotTable[dwI].dwDefaultValue = END_OF_LIST  ;
    pStatic->snapShotTable[dwI].dwFlags = SSF_LIST | SSF_FONTID ;
    pStatic->snapShotTable[dwI].dwGIDflags = 0 ;
    dwI++ ;

    pStatic->snapShotTable[dwI].pstrKeyword  = "*DefaultFont" ;
    pStatic->snapShotTable[dwI].dwSrcOffset  = offsetof(GLOBALATTRIB,
                                        atrDefaultFont) ;
    pStatic->snapShotTable[dwI].dwDestOffset = offsetof(GLOBALS,
                                        dwDefaultFont) ;
    pStatic->snapShotTable[dwI].dwNbytes = sizeof(DWORD) ;
    pStatic->snapShotTable[dwI].dwDefaultValue = 0 ;
    pStatic->snapShotTable[dwI].dwFlags = SSF_FONTID ;  // required if device fonts
                                            //  are supported.
    pStatic->snapShotTable[dwI].dwGIDflags = 0 ;
    dwI++ ;


    pStatic->snapShotTable[dwI].pstrKeyword  = "*MaxFontUsePerPage" ;
    pStatic->snapShotTable[dwI].dwSrcOffset  = offsetof(GLOBALATTRIB,
                                        atrMaxFontUsePerPage) ;
    pStatic->snapShotTable[dwI].dwDestOffset = offsetof(GLOBALS,
                                        dwMaxFontUsePerPage) ;
    pStatic->snapShotTable[dwI].dwNbytes = sizeof(DWORD) ;
    pStatic->snapShotTable[dwI].dwDefaultValue = NO_LIMIT_NUM ;
    pStatic->snapShotTable[dwI].dwFlags = 0 ;
    pStatic->snapShotTable[dwI].dwGIDflags = 0 ;
    dwI++ ;

    pStatic->snapShotTable[dwI].pstrKeyword  = "*DefaultCTT" ;
    pStatic->snapShotTable[dwI].dwSrcOffset  = offsetof(GLOBALATTRIB,
                                        atrDefaultCTT) ;
    pStatic->snapShotTable[dwI].dwDestOffset = offsetof(GLOBALS,
                                        dwDefaultCTT) ;
    pStatic->snapShotTable[dwI].dwNbytes = sizeof(DWORD) ;
    pStatic->snapShotTable[dwI].dwDefaultValue = 0 ;
    pStatic->snapShotTable[dwI].dwFlags = SSF_OTHER_RESID ;
    pStatic->snapShotTable[dwI].dwGIDflags = 0 ;
    dwI++ ;

    pStatic->snapShotTable[dwI].pstrKeyword  = "*LookaheadRegion" ;
    pStatic->snapShotTable[dwI].dwSrcOffset  = offsetof(GLOBALATTRIB,
                                        atrLookaheadRegion) ;
    pStatic->snapShotTable[dwI].dwDestOffset = offsetof(GLOBALS,
                                        dwLookaheadRegion) ;
    pStatic->snapShotTable[dwI].dwNbytes = sizeof(DWORD) ;
    pStatic->snapShotTable[dwI].dwDefaultValue = 0 ;
    pStatic->snapShotTable[dwI].dwFlags = 0 ;
    pStatic->snapShotTable[dwI].dwGIDflags = 0 ;
    dwI++ ;

    pStatic->snapShotTable[dwI].pstrKeyword  = "*TextYOffset" ;
    pStatic->snapShotTable[dwI].dwSrcOffset  = offsetof(GLOBALATTRIB,
                                        atrTextYOffset) ;
    pStatic->snapShotTable[dwI].dwDestOffset = offsetof(GLOBALS,
                                        iTextYOffset) ;
    pStatic->snapShotTable[dwI].dwNbytes = sizeof(INT) ;
    pStatic->snapShotTable[dwI].dwDefaultValue = 0 ;
    pStatic->snapShotTable[dwI].dwFlags = 0 ;
    pStatic->snapShotTable[dwI].dwGIDflags = 0 ;
    dwI++ ;

    pStatic->snapShotTable[dwI].pstrKeyword  = "*CharPosition" ;
    pStatic->snapShotTable[dwI].dwSrcOffset  = offsetof(GLOBALATTRIB,
                                        atrCharPosition) ;
    pStatic->snapShotTable[dwI].dwDestOffset = offsetof(GLOBALS,
                                        charpos) ;
    pStatic->snapShotTable[dwI].dwNbytes = sizeof(CHARPOSITION) ;
    pStatic->snapShotTable[dwI].dwDefaultValue = CP_UPPERLEFT ;
    pStatic->snapShotTable[dwI].dwFlags = 0 ;
    pStatic->snapShotTable[dwI].dwGIDflags = 0 ;
    dwI++ ;


    //
    //Font Substitution.
    //



    pStatic->snapShotTable[dwI].pstrKeyword  = "*TTFSEnabled?" ;
    pStatic->snapShotTable[dwI].dwSrcOffset  = offsetof(GLOBALATTRIB,
                                        atrTTFSEnabled ) ;
    pStatic->snapShotTable[dwI].dwDestOffset = offsetof(GLOBALS,
                                        bTTFSEnabled) ;
    pStatic->snapShotTable[dwI].dwNbytes = sizeof(BOOL) ;
    pStatic->snapShotTable[dwI].dwDefaultValue = FALSE ;
    pStatic->snapShotTable[dwI].dwFlags = 0 ;
    pStatic->snapShotTable[dwI].dwGIDflags = 0 ;
    dwI++ ;

    //
    //Font Download
    //




    pStatic->snapShotTable[dwI].pstrKeyword  = "*MinFontID" ;
    pStatic->snapShotTable[dwI].dwSrcOffset  = offsetof(GLOBALATTRIB,
                                        atrMinFontID) ;
    pStatic->snapShotTable[dwI].dwDestOffset = offsetof(GLOBALS,
                                        dwMinFontID) ;
    pStatic->snapShotTable[dwI].dwNbytes = sizeof(DWORD) ;
    pStatic->snapShotTable[dwI].dwDefaultValue = 1 ;
    pStatic->snapShotTable[dwI].dwFlags = 0 ;
    pStatic->snapShotTable[dwI].dwGIDflags = 0 ;
    dwI++ ;

    pStatic->snapShotTable[dwI].pstrKeyword  = "*MaxFontID" ;
    pStatic->snapShotTable[dwI].dwSrcOffset  = offsetof(GLOBALATTRIB,
                                        atrMaxFontID) ;
    pStatic->snapShotTable[dwI].dwDestOffset = offsetof(GLOBALS,
                                        dwMaxFontID) ;
    pStatic->snapShotTable[dwI].dwNbytes = sizeof(DWORD) ;
    pStatic->snapShotTable[dwI].dwDefaultValue = 65535 ;
    pStatic->snapShotTable[dwI].dwFlags = 0 ;
    pStatic->snapShotTable[dwI].dwGIDflags = 0 ;
    dwI++ ;

    pStatic->snapShotTable[dwI].pstrKeyword  = "*MaxNumDownFonts" ;
    pStatic->snapShotTable[dwI].dwSrcOffset  = offsetof(GLOBALATTRIB,
                                        atrMaxNumDownFonts) ;
    pStatic->snapShotTable[dwI].dwDestOffset = offsetof(GLOBALS,
                                        dwMaxNumDownFonts) ;
    pStatic->snapShotTable[dwI].dwNbytes = sizeof(DWORD) ;
    pStatic->snapShotTable[dwI].dwDefaultValue = NO_LIMIT_NUM ;
    pStatic->snapShotTable[dwI].dwFlags = 0 ;
    pStatic->snapShotTable[dwI].dwGIDflags = 0 ;
    dwI++ ;

    pStatic->snapShotTable[dwI].pstrKeyword  = "*DLSymbolSet" ;
    pStatic->snapShotTable[dwI].dwSrcOffset  = offsetof(GLOBALATTRIB,
                                        atrDLSymbolSet) ;
    pStatic->snapShotTable[dwI].dwDestOffset = offsetof(GLOBALS,
                                        dlsymbolset) ;
    pStatic->snapShotTable[dwI].dwNbytes = sizeof(DLSYMBOLSET) ;
    pStatic->snapShotTable[dwI].dwDefaultValue = UNUSED_ITEM ;
    pStatic->snapShotTable[dwI].dwFlags = 0 ;
    pStatic->snapShotTable[dwI].dwGIDflags = 0 ;
    dwI++ ;



    pStatic->snapShotTable[dwI].pstrKeyword  = "*MinGlyphID" ;
    pStatic->snapShotTable[dwI].dwSrcOffset  = offsetof(GLOBALATTRIB,
                                        atrMinGlyphID) ;
    pStatic->snapShotTable[dwI].dwDestOffset = offsetof(GLOBALS,
                                        dwMinGlyphID) ;
    pStatic->snapShotTable[dwI].dwNbytes = sizeof(DWORD) ;
    pStatic->snapShotTable[dwI].dwDefaultValue = 32 ;
    pStatic->snapShotTable[dwI].dwFlags = 0 ;
    pStatic->snapShotTable[dwI].dwGIDflags = 0 ;
    dwI++ ;

    pStatic->snapShotTable[dwI].pstrKeyword  = "*MaxGlyphID" ;
    pStatic->snapShotTable[dwI].dwSrcOffset  = offsetof(GLOBALATTRIB,
                                        atrMaxGlyphID) ;
    pStatic->snapShotTable[dwI].dwDestOffset = offsetof(GLOBALS,
                                        dwMaxGlyphID) ;
    pStatic->snapShotTable[dwI].dwNbytes = sizeof(DWORD) ;
    pStatic->snapShotTable[dwI].dwDefaultValue = 255 ;
    pStatic->snapShotTable[dwI].dwFlags = 0 ;
    pStatic->snapShotTable[dwI].dwGIDflags = 0 ;
    dwI++ ;

    /****
      *  Moved to SSTI_UPDATE_GLOBALS section
      *
    pStatic->snapShotTable[dwI].pstrKeyword  = "*FontFormat" ;
    pStatic->snapShotTable[dwI].dwSrcOffset  = offsetof(GLOBALATTRIB,
                                        atrFontFormat) ;
    pStatic->snapShotTable[dwI].dwDestOffset = offsetof(GLOBALS,
                                        fontformat) ;
    pStatic->snapShotTable[dwI].dwNbytes = sizeof(FONTFORMAT) ;
    pStatic->snapShotTable[dwI].dwDefaultValue = UNUSED_ITEM ;
        //  UNUSED_ITEM  must be used as default - used by other code.
    pStatic->snapShotTable[dwI].dwFlags = 0 ;  // required if the printer
    // supports font downloading.
    pStatic->snapShotTable[dwI].dwGIDflags = 0 ;
    dwI++ ;
     *
    ***/


    //
    // font simulation
    //


    pStatic->snapShotTable[dwI].pstrKeyword  = "*DiffFontsPerByteMode?" ;
    pStatic->snapShotTable[dwI].dwSrcOffset  = offsetof(GLOBALATTRIB,
                                        atrDiffFontsPerByteMode) ;
    pStatic->snapShotTable[dwI].dwDestOffset = offsetof(GLOBALS,
                                        bDiffFontsPerByteMode) ;
    pStatic->snapShotTable[dwI].dwNbytes = sizeof(BOOL) ;
    pStatic->snapShotTable[dwI].dwDefaultValue = FALSE ;
    pStatic->snapShotTable[dwI].dwFlags = 0 ;
    pStatic->snapShotTable[dwI].dwGIDflags = 0 ;
    dwI++ ;

    //
    // rectangle area fill
    //




    pStatic->snapShotTable[dwI].pstrKeyword  = "*CursorXAfterRectFill" ;
    pStatic->snapShotTable[dwI].dwSrcOffset  = offsetof(GLOBALATTRIB,
                                        atrCursorXAfterRectFill) ;
    pStatic->snapShotTable[dwI].dwDestOffset = offsetof(GLOBALS,
                                        cxafterfill) ;
    pStatic->snapShotTable[dwI].dwNbytes = sizeof(CURSORXAFTERRECTFILL) ;
    pStatic->snapShotTable[dwI].dwDefaultValue = CXARF_AT_RECT_X_ORIGIN ;
    pStatic->snapShotTable[dwI].dwFlags = 0 ;
    pStatic->snapShotTable[dwI].dwGIDflags = 0 ;
    dwI++ ;

    pStatic->snapShotTable[dwI].pstrKeyword  = "*CursorYAfterRectFill" ;
    pStatic->snapShotTable[dwI].dwSrcOffset  = offsetof(GLOBALATTRIB,
                                        atrCursorYAfterRectFill) ;
    pStatic->snapShotTable[dwI].dwDestOffset = offsetof(GLOBALS,
                                        cyafterfill) ;
    pStatic->snapShotTable[dwI].dwNbytes = sizeof(CURSORYAFTERRECTFILL) ;
    pStatic->snapShotTable[dwI].dwDefaultValue = CYARF_AT_RECT_Y_ORIGIN ;
    pStatic->snapShotTable[dwI].dwFlags = 0 ;
    pStatic->snapShotTable[dwI].dwGIDflags = 0 ;
    dwI++ ;

    pStatic->snapShotTable[dwI].pstrKeyword  = "*MinGrayFill" ;
    pStatic->snapShotTable[dwI].dwSrcOffset  = offsetof(GLOBALATTRIB,
                                        atrMinGrayFill) ;
    pStatic->snapShotTable[dwI].dwDestOffset = offsetof(GLOBALS,
                                        dwMinGrayFill) ;
    pStatic->snapShotTable[dwI].dwNbytes = sizeof(DWORD) ;
    pStatic->snapShotTable[dwI].dwDefaultValue = 1 ;
    pStatic->snapShotTable[dwI].dwFlags = 0 ;
    pStatic->snapShotTable[dwI].dwGIDflags = 0 ;
    dwI++ ;

    pStatic->snapShotTable[dwI].pstrKeyword  = "*MaxGrayFill" ;
    pStatic->snapShotTable[dwI].dwSrcOffset  = offsetof(GLOBALATTRIB,
                                        atrMaxGrayFill) ;
    pStatic->snapShotTable[dwI].dwDestOffset = offsetof(GLOBALS,
                                        dwMaxGrayFill) ;
    pStatic->snapShotTable[dwI].dwNbytes = sizeof(DWORD) ;
    pStatic->snapShotTable[dwI].dwDefaultValue = 100 ;
    pStatic->snapShotTable[dwI].dwFlags = 0 ;
    pStatic->snapShotTable[dwI].dwGIDflags = 0 ;
    dwI++ ;



    //  end of SSTI_GLOBALS  section

    pStatic->snapShotTable[dwI].dwNbytes = 0 ;
    dwI++ ;


    // beginning of SSTI_UPDATE_GLOBALS section

    pStatic->snapShotTable[dwI].pstrKeyword  = "*MaxMultipleRowBytes" ;
    pStatic->snapShotTable[dwI].dwSrcOffset  = offsetof(GLOBALATTRIB,
                                        atrMaxMultipleRowBytes) ;
    pStatic->snapShotTable[dwI].dwDestOffset = offsetof(GLOBALS,
                                        dwMaxMultipleRowBytes) ;
    pStatic->snapShotTable[dwI].dwNbytes = sizeof(DWORD) ;
    pStatic->snapShotTable[dwI].dwDefaultValue = 0 ;
    pStatic->snapShotTable[dwI].dwFlags = 0 ;
    pStatic->snapShotTable[dwI].dwGIDflags = 0 ;
    dwI++ ;

    pStatic->snapShotTable[dwI].pstrKeyword  = "*TextHalftoneThreshold" ;
    pStatic->snapShotTable[dwI].dwSrcOffset  = offsetof(GLOBALATTRIB,
                                        atrTextHalftoneThreshold) ;
    pStatic->snapShotTable[dwI].dwDestOffset = offsetof(GLOBALS,
                                        dwTextHalftoneThreshold) ;
    pStatic->snapShotTable[dwI].dwNbytes = sizeof(DWORD) ;
    pStatic->snapShotTable[dwI].dwDefaultValue = 0 ;
    pStatic->snapShotTable[dwI].dwFlags = 0 ;
    pStatic->snapShotTable[dwI].dwGIDflags = 0 ;
    dwI++ ;


    pStatic->snapShotTable[dwI].pstrKeyword  = "*FontFormat" ;
    pStatic->snapShotTable[dwI].dwSrcOffset  = offsetof(GLOBALATTRIB,
                                        atrFontFormat) ;
    pStatic->snapShotTable[dwI].dwDestOffset = offsetof(GLOBALS,
                                        fontformat) ;
    pStatic->snapShotTable[dwI].dwNbytes = sizeof(FONTFORMAT) ;
    pStatic->snapShotTable[dwI].dwDefaultValue = UNUSED_ITEM ;
        //  UNUSED_ITEM  must be used as default - used by other code.
    pStatic->snapShotTable[dwI].dwFlags = 0 ;  // required if the printer
                                               // supports font downloading.
    pStatic->snapShotTable[dwI].dwGIDflags = 0 ;
    dwI++ ;


    //  end of SSTI_UPDATE_GLOBALS  section

    pStatic->snapShotTable[dwI].dwNbytes = 0 ;
    dwI++ ;

    //  beginning of SSTI_UIINFO  section


    pStatic->snapShotTable[dwI].pstrKeyword  = "*ResourceDLL" ;
    pStatic->snapShotTable[dwI].dwSrcOffset  = offsetof(GLOBALATTRIB,
                                        atrResourceDLL) ;
    pStatic->snapShotTable[dwI].dwDestOffset = offsetof(UIINFO,
                                        loResourceName) ;
    pStatic->snapShotTable[dwI].dwNbytes = sizeof(PTRREF) ;
    pStatic->snapShotTable[dwI].dwDefaultValue = 0 ;
    pStatic->snapShotTable[dwI].dwFlags = SSF_OFFSETONLY  ;
    pStatic->snapShotTable[dwI].dwGIDflags = 0 ;
    dwI++ ;

    pStatic->snapShotTable[dwI].pstrKeyword  = "*rcPersonalityID" ;
    pStatic->snapShotTable[dwI].dwSrcOffset  = offsetof(GLOBALATTRIB,
                                        atrRcPersonalityID) ;
    pStatic->snapShotTable[dwI].dwDestOffset = offsetof(UIINFO,
                                        loPersonality) ;
    pStatic->snapShotTable[dwI].dwNbytes = sizeof(RESREF) ;
    pStatic->snapShotTable[dwI].dwDefaultValue = 0 ;
    pStatic->snapShotTable[dwI].dwFlags = SSF_SETRCID | SSF_STRINGID;
    pStatic->snapShotTable[dwI].dwGIDflags = 0 ;
    dwI++ ;

    pStatic->snapShotTable[dwI].pstrKeyword  = "*Personality" ;
    pStatic->snapShotTable[dwI].dwSrcOffset  = offsetof(GLOBALATTRIB,
                                        atrPersonality) ;
    pStatic->snapShotTable[dwI].dwDestOffset = offsetof(UIINFO,
                                        loPersonality) ;
    pStatic->snapShotTable[dwI].dwNbytes = sizeof(PTRREF) ;
    pStatic->snapShotTable[dwI].dwDefaultValue = 0 ;
    pStatic->snapShotTable[dwI].dwFlags = SSF_DONT_USEDEFAULT |
                   SSF_OFFSETONLY | SSF_NON_LOCALIZABLE;
    pStatic->snapShotTable[dwI].dwGIDflags = 0 ;
    dwI++ ;



    //  special processing dwSpecVersion - done.


    pStatic->snapShotTable[dwI].pstrKeyword  = "*MaxCopies" ;
    pStatic->snapShotTable[dwI].dwSrcOffset  = offsetof(GLOBALATTRIB,
                                        atrMaxCopies) ;
    pStatic->snapShotTable[dwI].dwDestOffset = offsetof(UIINFO,
                                        dwMaxCopies) ;
    pStatic->snapShotTable[dwI].dwNbytes = sizeof(DWORD) ;
    pStatic->snapShotTable[dwI].dwDefaultValue = 1 ;
    pStatic->snapShotTable[dwI].dwFlags = 0 ;
    pStatic->snapShotTable[dwI].dwGIDflags = 0 ;
    dwI++ ;

    pStatic->snapShotTable[dwI].pstrKeyword  = "*rcPrinterIconID" ;
    pStatic->snapShotTable[dwI].dwSrcOffset  = offsetof(GLOBALATTRIB,
                    atrPrinterIcon) ;  //  new keyword.
    pStatic->snapShotTable[dwI].dwDestOffset = offsetof(UIINFO,
                                        loPrinterIcon) ;
    pStatic->snapShotTable[dwI].dwNbytes = sizeof(RESREF) ;
    pStatic->snapShotTable[dwI].dwDefaultValue = 0 ;
    pStatic->snapShotTable[dwI].dwFlags = SSF_ICONID ;
    pStatic->snapShotTable[dwI].dwGIDflags = 0 ;
    dwI++ ;

    pStatic->snapShotTable[dwI].pstrKeyword  = "*FontCartSlots" ;

    pStatic->snapShotTable[dwI].dwSrcOffset  = offsetof(GLOBALATTRIB,
                                        atrFontCartSlots) ;
    pStatic->snapShotTable[dwI].dwDestOffset = offsetof(UIINFO,
                                        dwCartridgeSlotCount) ;
    pStatic->snapShotTable[dwI].dwNbytes = sizeof(DWORD) ;
    pStatic->snapShotTable[dwI].dwDefaultValue = 0 ;
    pStatic->snapShotTable[dwI].dwFlags = 0 ;
    pStatic->snapShotTable[dwI].dwGIDflags = 0 ;
    dwI++ ;

    pStatic->snapShotTable[dwI].pstrKeyword  = "*HelpFile" ;
    pStatic->snapShotTable[dwI].dwSrcOffset  = offsetof(GLOBALATTRIB,
                                        atrHelpFile) ;
    pStatic->snapShotTable[dwI].dwDestOffset = offsetof(UIINFO,
                                        loHelpFileName) ;
    pStatic->snapShotTable[dwI].dwNbytes = sizeof(PTRREF) ;
    pStatic->snapShotTable[dwI].dwDefaultValue = 0 ;
    pStatic->snapShotTable[dwI].dwFlags = SSF_OFFSETONLY ;
    pStatic->snapShotTable[dwI].dwGIDflags = 0 ;
    dwI++ ;

    pStatic->snapShotTable[dwI].pstrKeyword  = "*MasterUnits" ;
    pStatic->snapShotTable[dwI].dwSrcOffset  = offsetof(GLOBALATTRIB,
                                        atrMasterUnits) ;
    pStatic->snapShotTable[dwI].dwDestOffset = offsetof(UIINFO,
                                        ptMasterUnits) ;
    pStatic->snapShotTable[dwI].dwNbytes = sizeof(POINT) ;
    pStatic->snapShotTable[dwI].dwDefaultValue = 0 ;
    pStatic->snapShotTable[dwI].dwFlags = SSF_REQUIRED ;
    pStatic->snapShotTable[dwI].dwGIDflags = 0 ;
    dwI++ ;

    pStatic->snapShotTable[dwI].pstrKeyword  = "*PrintRate" ;
    pStatic->snapShotTable[dwI].dwSrcOffset  = offsetof(GLOBALATTRIB,
                                        atrPrintRate) ;
    pStatic->snapShotTable[dwI].dwDestOffset = offsetof(UIINFO,
                                        dwPrintRate) ;
    pStatic->snapShotTable[dwI].dwNbytes = sizeof(DWORD) ;
    pStatic->snapShotTable[dwI].dwDefaultValue = 0 ;
    pStatic->snapShotTable[dwI].dwFlags = 0 ;
    pStatic->snapShotTable[dwI].dwGIDflags = 0 ;
    dwI++ ;

    pStatic->snapShotTable[dwI].pstrKeyword  = "*PrintRateUnit" ;
    pStatic->snapShotTable[dwI].dwSrcOffset  = offsetof(GLOBALATTRIB,
                                        atrPrintRateUnit) ;
    pStatic->snapShotTable[dwI].dwDestOffset = offsetof(UIINFO,
                                        dwPrintRateUnit) ;
    pStatic->snapShotTable[dwI].dwNbytes = sizeof(DWORD) ;
    pStatic->snapShotTable[dwI].dwDefaultValue = INVALID_INDEX ;
    pStatic->snapShotTable[dwI].dwFlags = 0 ;
    pStatic->snapShotTable[dwI].dwGIDflags = 0 ;
    dwI++ ;

    pStatic->snapShotTable[dwI].pstrKeyword  = "*PrintRatePPM" ;
    pStatic->snapShotTable[dwI].dwSrcOffset  = offsetof(GLOBALATTRIB,
                                        atrPrintRatePPM) ;
    pStatic->snapShotTable[dwI].dwDestOffset = offsetof(UIINFO,
                                        dwPrintRatePPM) ;
    pStatic->snapShotTable[dwI].dwNbytes = sizeof(DWORD) ;
    pStatic->snapShotTable[dwI].dwDefaultValue = 0 ;
    pStatic->snapShotTable[dwI].dwFlags = 0 ;
    pStatic->snapShotTable[dwI].dwGIDflags = 0 ;
    dwI++ ;

    pStatic->snapShotTable[dwI].pstrKeyword  = "*LETTER_SIZE_EXISTS?  synthesized" ;
    pStatic->snapShotTable[dwI].dwSrcOffset  = offsetof(GLOBALATTRIB,
                                        atrLetterSizeExists) ;
    pStatic->snapShotTable[dwI].dwDestOffset = offsetof(UIINFO,
                                        dwFlags) ;
    pStatic->snapShotTable[dwI].dwNbytes = sizeof(DWORD) ;
    pStatic->snapShotTable[dwI].dwDefaultValue = FLAG_LETTER_SIZE_EXISTS ;
    pStatic->snapShotTable[dwI].dwFlags = SSF_BITFIELD_DEF_FALSE ;
    pStatic->snapShotTable[dwI].dwGIDflags = 0 ;
    dwI++ ;

    pStatic->snapShotTable[dwI].pstrKeyword  = "*A4_SIZE_EXISTS?  synthesized" ;
    pStatic->snapShotTable[dwI].dwSrcOffset  = offsetof(GLOBALATTRIB,
                                        atrA4SizeExists) ;
    pStatic->snapShotTable[dwI].dwDestOffset = offsetof(UIINFO,
                                        dwFlags) ;
    pStatic->snapShotTable[dwI].dwNbytes = sizeof(DWORD) ;
    pStatic->snapShotTable[dwI].dwDefaultValue = FLAG_A4_SIZE_EXISTS ;
    pStatic->snapShotTable[dwI].dwFlags = SSF_BITFIELD_DEF_FALSE ;
    pStatic->snapShotTable[dwI].dwGIDflags = 0 ;
    dwI++ ;




    //  end of SSTI_UIINFO  section

    pStatic->snapShotTable[dwI].dwNbytes = 0 ;
    dwI++ ;


    //  beginning of SSTI_UPDATE_UIINFO  section

    pStatic->snapShotTable[dwI].pstrKeyword  = "*OutputOrderReversed? (global)" ;
    pStatic->snapShotTable[dwI].dwSrcOffset  = offsetof(GLOBALATTRIB,
                                        atrOutputOrderReversed) ;
    pStatic->snapShotTable[dwI].dwDestOffset = offsetof(UIINFO,
                                        dwFlags) ;
    pStatic->snapShotTable[dwI].dwNbytes = sizeof(DWORD) ;
    pStatic->snapShotTable[dwI].dwDefaultValue = FLAG_REVERSE_PRINT ;
    pStatic->snapShotTable[dwI].dwFlags = SSF_BITFIELD_DEF_FALSE ;
    pStatic->snapShotTable[dwI].dwGIDflags = 0 ;
    dwI++ ;

    pStatic->snapShotTable[dwI].pstrKeyword  = "*ReverseBandOrderForEvenPages?" ;
    pStatic->snapShotTable[dwI].dwSrcOffset  = offsetof(GLOBALATTRIB,
                                        atrReverseBandOrderForEvenPages) ;
    pStatic->snapShotTable[dwI].dwDestOffset = offsetof(UIINFO,
                                        dwFlags) ;
    pStatic->snapShotTable[dwI].dwNbytes = sizeof(DWORD) ;
    pStatic->snapShotTable[dwI].dwDefaultValue = FLAG_REVERSE_BAND_ORDER ;
    pStatic->snapShotTable[dwI].dwFlags = SSF_BITFIELD_DEF_FALSE ;
    pStatic->snapShotTable[dwI].dwGIDflags = 0 ;
    dwI++ ;

    pStatic->snapShotTable[dwI].pstrKeyword  = "*DraftQualitySettings" ;
    pStatic->snapShotTable[dwI].dwSrcOffset  = offsetof(GLOBALATTRIB,
                                        atrDraftQualitySettings) ;
    pStatic->snapShotTable[dwI].dwDestOffset = offsetof(UIINFO,
                                        liDraftQualitySettings) ;
    pStatic->snapShotTable[dwI].dwNbytes = sizeof(LISTINDEX) ;
    pStatic->snapShotTable[dwI].dwDefaultValue = END_OF_LIST ;
    pStatic->snapShotTable[dwI].dwFlags = 0 ;
    pStatic->snapShotTable[dwI].dwGIDflags = 0 ;
    dwI++ ;

    pStatic->snapShotTable[dwI].pstrKeyword  = "*BetterQualitySettings" ;
    pStatic->snapShotTable[dwI].dwSrcOffset  = offsetof(GLOBALATTRIB,
                                        atrBetterQualitySettings) ;
    pStatic->snapShotTable[dwI].dwDestOffset = offsetof(UIINFO,
                                        liBetterQualitySettings) ;
    pStatic->snapShotTable[dwI].dwNbytes = sizeof(LISTINDEX) ;
    pStatic->snapShotTable[dwI].dwDefaultValue = END_OF_LIST ;
    pStatic->snapShotTable[dwI].dwFlags = 0 ;
    pStatic->snapShotTable[dwI].dwGIDflags = 0 ;
    dwI++ ;

    pStatic->snapShotTable[dwI].pstrKeyword  = "*BestQualitySettings" ;
    pStatic->snapShotTable[dwI].dwSrcOffset  = offsetof(GLOBALATTRIB,
                                        atrBestQualitySettings) ;
    pStatic->snapShotTable[dwI].dwDestOffset = offsetof(UIINFO,
                                        liBestQualitySettings) ;
    pStatic->snapShotTable[dwI].dwNbytes = sizeof(LISTINDEX) ;
    pStatic->snapShotTable[dwI].dwDefaultValue = END_OF_LIST ;
    pStatic->snapShotTable[dwI].dwFlags = 0 ;
    pStatic->snapShotTable[dwI].dwGIDflags = 0 ;
    dwI++ ;

    pStatic->snapShotTable[dwI].pstrKeyword  = "*DefaultQuality" ;
    pStatic->snapShotTable[dwI].dwSrcOffset  = offsetof(GLOBALATTRIB,
                                        atrDefaultQuality) ;
    pStatic->snapShotTable[dwI].dwDestOffset = offsetof(UIINFO,
                                        defaultQuality) ;
    pStatic->snapShotTable[dwI].dwNbytes = sizeof(QUALITYSETTING) ;
    pStatic->snapShotTable[dwI].dwDefaultValue = QS_BEST ;
    pStatic->snapShotTable[dwI].dwFlags = 0 ;
    pStatic->snapShotTable[dwI].dwGIDflags = 0 ;
    dwI++ ;

    pStatic->snapShotTable[dwI].pstrKeyword  = "*ChangeColorModeOnDoc?" ;
    pStatic->snapShotTable[dwI].dwSrcOffset  = offsetof(GLOBALATTRIB,
                                        atrChangeColorModeDoc) ;
    pStatic->snapShotTable[dwI].dwDestOffset = offsetof(UIINFO,
                                        bChangeColorModeOnDoc) ;
    pStatic->snapShotTable[dwI].dwNbytes = sizeof(BOOL) ;
    pStatic->snapShotTable[dwI].dwDefaultValue = TRUE ;
    pStatic->snapShotTable[dwI].dwFlags = 0 ;
    pStatic->snapShotTable[dwI].dwGIDflags = 0 ;
    dwI++ ;




    //  end of SSTI_UPDATE_UIINFO  section



    return(dwI) ;
}



DWORD   DwInitSnapShotTable2(
PBYTE   pubnRaw,
DWORD   dwI)
{
    PSTATICFIELDS   pStatic ;
//    PMINIRAWBINARYDATA pmrbd  ;

    pStatic = (PSTATICFIELDS)pubnRaw ;
    if(!pStatic->snapShotTable)
        return(0) ;  //  should already be initialized!



    //  end of SSTI_UPDATE_UIINFO  section

    pStatic->snapShotTable[dwI].dwNbytes = 0 ;
    dwI++ ;

    //  beginning of SSTI_FEATURES  section

    //  note:  dwGID and dwOptionSize are handled directly.


    pStatic->snapShotTable[dwI].pstrKeyword  = "*Priority - synthesized" ;
    pStatic->snapShotTable[dwI].dwSrcOffset  = offsetof(DFEATURE_OPTIONS,
                                        atrPriority) ;
    pStatic->snapShotTable[dwI].dwDestOffset = offsetof(FEATURE,
                                        dwPriority) ;
    pStatic->snapShotTable[dwI].dwNbytes = sizeof(DWORD) ;
    pStatic->snapShotTable[dwI].dwDefaultValue = 0 ;
    pStatic->snapShotTable[dwI].dwFlags = 0 ;
    pStatic->snapShotTable[dwI].dwGIDflags = 0 ;
    dwI++ ;



    pStatic->snapShotTable[dwI].pstrKeyword  = "*FeatureType" ;
    pStatic->snapShotTable[dwI].dwSrcOffset  = offsetof(DFEATURE_OPTIONS,
                                        atrFeatureType) ;
    pStatic->snapShotTable[dwI].dwDestOffset = offsetof(FEATURE,
                                        dwFeatureType) ;
    pStatic->snapShotTable[dwI].dwNbytes = sizeof(DWORD) ;
    pStatic->snapShotTable[dwI].dwDefaultValue = FT_DOCPROPERTY ;
        // actually is required, but is optional for predefined GIDs.
    pStatic->snapShotTable[dwI].dwFlags = 0 ;
    pStatic->snapShotTable[dwI].dwGIDflags = 0 ;
    pStatic->dwSSFeatureTypeIndex  = dwI ;         //  DO NOT CUT AND PASTE !!!!
    dwI++ ;


    pStatic->snapShotTable[dwI].pstrKeyword  = "*ConcealFromUI?" ;
    pStatic->snapShotTable[dwI].dwSrcOffset  = offsetof(DFEATURE_OPTIONS,
                                        atrConcealFromUI) ;
    pStatic->snapShotTable[dwI].dwDestOffset = offsetof(FEATURE,
                                        dwFlags) ;
    pStatic->snapShotTable[dwI].dwNbytes = sizeof(DWORD) ;
    pStatic->snapShotTable[dwI].dwDefaultValue = FEATURE_FLAG_NOUI ;
    pStatic->snapShotTable[dwI].dwFlags = SSF_BITFIELD_DEF_FALSE ;
    pStatic->snapShotTable[dwI].dwGIDflags = 0 ;
    dwI++ ;


    pStatic->snapShotTable[dwI].pstrKeyword  = "*UpdateQualityMacro?" ;
    pStatic->snapShotTable[dwI].dwSrcOffset  = offsetof(DFEATURE_OPTIONS,
                                        atrUpdateQualityMacro) ;
    pStatic->snapShotTable[dwI].dwDestOffset = offsetof(FEATURE,
                                        dwFlags) ;
    pStatic->snapShotTable[dwI].dwNbytes = sizeof(DWORD) ;
    pStatic->snapShotTable[dwI].dwDefaultValue = FEATURE_FLAG_UPDATESNAPSHOT ;
    pStatic->snapShotTable[dwI].dwFlags = SSF_BITFIELD_DEF_FALSE ;
    pStatic->snapShotTable[dwI].dwGIDflags = 0 ;
    dwI++ ;




    pStatic->snapShotTable[dwI].pstrKeyword  = "*rcNameID (Fea)" ;
    pStatic->snapShotTable[dwI].dwSrcOffset  = offsetof(DFEATURE_OPTIONS,
                                        atrFeaRcNameID) ;
    pStatic->snapShotTable[dwI].dwDestOffset = offsetof(FEATURE,
                                        loDisplayName) ;
    pStatic->snapShotTable[dwI].dwNbytes = sizeof(RESREF) ;
    pStatic->snapShotTable[dwI].dwDefaultValue = 0 ;  // Use this if not found
    pStatic->snapShotTable[dwI].dwFlags =  SSF_SETRCID | SSF_STRINGID;
    pStatic->snapShotTable[dwI].dwGIDflags = 0 ;
    dwI++ ;

    pStatic->snapShotTable[dwI].pstrKeyword  = "*Name (Fea)" ;
    pStatic->snapShotTable[dwI].dwSrcOffset  = offsetof(DFEATURE_OPTIONS,
                                        atrFeaDisplayName) ;
    pStatic->snapShotTable[dwI].dwDestOffset = offsetof(FEATURE,
                                        loDisplayName) ;
    pStatic->snapShotTable[dwI].dwNbytes = sizeof(RESREF) ;
    pStatic->snapShotTable[dwI].dwDefaultValue = 0 ;
    pStatic->snapShotTable[dwI].dwFlags = SSF_DONT_USEDEFAULT |
                  SSF_FAILIFZERO | SSF_OFFSETONLY | SSF_NON_LOCALIZABLE ;
    pStatic->snapShotTable[dwI].dwGIDflags = 0 ;
    dwI++ ;

    pStatic->snapShotTable[dwI].pstrKeyword  = "*HelpIndex (Fea)" ;
    pStatic->snapShotTable[dwI].dwSrcOffset  = offsetof(DFEATURE_OPTIONS,
                                        atrFeaHelpIndex) ;
    pStatic->snapShotTable[dwI].dwDestOffset = offsetof(FEATURE,
                                        iHelpIndex) ;
    pStatic->snapShotTable[dwI].dwNbytes = sizeof(INT) ;
    pStatic->snapShotTable[dwI].dwDefaultValue = UNUSED_ITEM ;
    pStatic->snapShotTable[dwI].dwFlags = SSF_OTHER_RESID ;
    pStatic->snapShotTable[dwI].dwGIDflags = 0 ;
    dwI++ ;

    pStatic->snapShotTable[dwI].pstrKeyword  = "*FeaKeyWord - Synthesized" ;
    pStatic->snapShotTable[dwI].dwSrcOffset  = offsetof(DFEATURE_OPTIONS,
                                        atrFeaKeyWord) ;
    pStatic->snapShotTable[dwI].dwDestOffset = offsetof(FEATURE,
                                        loKeywordName) ;
    pStatic->snapShotTable[dwI].dwNbytes = sizeof(PTRREF) ;
    pStatic->snapShotTable[dwI].dwDefaultValue = 0 ;
    pStatic->snapShotTable[dwI].dwFlags = SSF_REQUIRED | SSF_OFFSETONLY ;
    pStatic->snapShotTable[dwI].dwGIDflags = 0 ;
    dwI++ ;

    pStatic->snapShotTable[dwI].pstrKeyword  = "*UIType" ;
    pStatic->snapShotTable[dwI].dwSrcOffset  = offsetof(DFEATURE_OPTIONS,
                                        atrUIType) ;
    pStatic->snapShotTable[dwI].dwDestOffset = offsetof(FEATURE,
                                        dwUIType) ;
    pStatic->snapShotTable[dwI].dwNbytes = sizeof(DWORD) ;
    pStatic->snapShotTable[dwI].dwDefaultValue = UIT_PICKONE ;
    pStatic->snapShotTable[dwI].dwFlags = 0 ;
    pStatic->snapShotTable[dwI].dwGIDflags = 0 ;
    dwI++ ;





    //  end of SSTI_FEATURES  section

    pStatic->snapShotTable[dwI].dwNbytes = 0 ;
    dwI++ ;

    //  beginning of SSTI_UPDATE_FEATURES  section



    pStatic->snapShotTable[dwI].pstrKeyword  = "*DefaultOption" ;
    pStatic->snapShotTable[dwI].dwSrcOffset  = offsetof(DFEATURE_OPTIONS,
                                        atrDefaultOption) ;
    pStatic->snapShotTable[dwI].dwDestOffset = offsetof(FEATURE,
                                        dwDefaultOptIndex) ;
    pStatic->snapShotTable[dwI].dwNbytes = sizeof(DWORD) ;
    pStatic->snapShotTable[dwI].dwDefaultValue = 0 ;
    pStatic->snapShotTable[dwI].dwFlags = 0 ;
    pStatic->snapShotTable[dwI].dwGIDflags = 0 ;
    pStatic->dwSSdefaultOptionIndex = dwI ;
    dwI++ ;


    pStatic->snapShotTable[dwI].pstrKeyword  = "*rcIconID (Fea)" ;
    pStatic->snapShotTable[dwI].dwSrcOffset  = offsetof(DFEATURE_OPTIONS,
                                        atrFeaRcIconID) ;
    pStatic->snapShotTable[dwI].dwDestOffset = offsetof(FEATURE,
                                        loResourceIcon) ;
    pStatic->snapShotTable[dwI].dwNbytes = sizeof(RESREF) ;
    pStatic->snapShotTable[dwI].dwDefaultValue = 0 ;
    pStatic->snapShotTable[dwI].dwFlags = SSF_ICONID ;
    pStatic->snapShotTable[dwI].dwGIDflags = 0 ;
    dwI++ ;


    pStatic->snapShotTable[dwI].pstrKeyword  = "*rcPromptMsgID" ;
    pStatic->snapShotTable[dwI].dwSrcOffset  = offsetof(DFEATURE_OPTIONS,
                                        atrFeaRcPromptMsgID) ;
    pStatic->snapShotTable[dwI].dwDestOffset = offsetof(FEATURE,
                                        loPromptMessage) ;
    pStatic->snapShotTable[dwI].dwNbytes = sizeof(RESREF) ;
    pStatic->snapShotTable[dwI].dwDefaultValue = 0 ;
    pStatic->snapShotTable[dwI].dwFlags = SSF_OTHER_RESID ;
    pStatic->snapShotTable[dwI].dwGIDflags = 0 ;
    dwI++ ;


    //  end of SSTI_UPDATE_FEATURES  section

    pStatic->snapShotTable[dwI].dwNbytes = 0 ;
    dwI++ ;




    //  beginning of SSTI_OPTIONS  section




    pStatic->snapShotTable[dwI].pstrKeyword  = "*OptKeyWord - synth" ;
    pStatic->snapShotTable[dwI].dwSrcOffset  = offsetof(DFEATURE_OPTIONS,
                                        atrOptKeyWord ) ;
    pStatic->snapShotTable[dwI].dwDestOffset = offsetof(OPTION,
                                        loKeywordName) ;
    pStatic->snapShotTable[dwI].dwNbytes = sizeof(PTRREF) ;
    pStatic->snapShotTable[dwI].dwDefaultValue = 0 ;
    pStatic->snapShotTable[dwI].dwFlags =  SSF_OFFSETONLY;
    pStatic->snapShotTable[dwI].dwGIDflags = 0xffffffff ;
    dwI++ ;

    pStatic->snapShotTable[dwI].pstrKeyword  = "*rcNameID (Opt)" ;
    pStatic->snapShotTable[dwI].dwSrcOffset  = offsetof(DFEATURE_OPTIONS,
                                        atrOptRcNameID) ;
    pStatic->snapShotTable[dwI].dwDestOffset = offsetof(OPTION,
                                        loDisplayName) ;
    pStatic->snapShotTable[dwI].dwNbytes = sizeof(RESREF) ;
    pStatic->snapShotTable[dwI].dwDefaultValue = 0 ;  // Use this if not found
    pStatic->snapShotTable[dwI].dwFlags =  SSF_SETRCID | SSF_STRINGID;
    pStatic->snapShotTable[dwI].dwGIDflags = 0xffffffff ;
    dwI++ ;

    pStatic->snapShotTable[dwI].pstrKeyword  = "*Name (Opt)" ;
    pStatic->snapShotTable[dwI].dwSrcOffset  = offsetof(DFEATURE_OPTIONS,
                                        atrOptDisplayName) ;
    pStatic->snapShotTable[dwI].dwDestOffset = offsetof(OPTION,
                                        loDisplayName) ;
    pStatic->snapShotTable[dwI].dwNbytes = sizeof(RESREF) ;
    pStatic->snapShotTable[dwI].dwDefaultValue = 0 ;
    pStatic->snapShotTable[dwI].dwFlags = SSF_DONT_USEDEFAULT |
                  SSF_FAILIFZERO | SSF_OFFSETONLY | SSF_NON_LOCALIZABLE ;
    pStatic->snapShotTable[dwI].dwGIDflags = 0xffffffff ;
    dwI++ ;


    pStatic->snapShotTable[dwI].pstrKeyword  = "*HelpIndex (Opt)" ;
    pStatic->snapShotTable[dwI].dwSrcOffset  = offsetof(DFEATURE_OPTIONS,
                                        atrOptHelpIndex) ;
    pStatic->snapShotTable[dwI].dwDestOffset = offsetof(OPTION,
                                        iHelpIndex) ;
    pStatic->snapShotTable[dwI].dwNbytes = sizeof(INT) ;
    pStatic->snapShotTable[dwI].dwDefaultValue = UNUSED_ITEM ;
    pStatic->snapShotTable[dwI].dwFlags = SSF_OTHER_RESID ;
    pStatic->snapShotTable[dwI].dwGIDflags = 0xffffffff ;
    dwI++ ;

    pStatic->snapShotTable[dwI].pstrKeyword  = "*rcPromptTime (Opt)" ;
    pStatic->snapShotTable[dwI].dwSrcOffset  = offsetof(DFEATURE_OPTIONS,
                                        atrOptRcPromptTime) ;
    pStatic->snapShotTable[dwI].dwDestOffset = offsetof(OPTION,
                                        dwPromptTime) ;
    pStatic->snapShotTable[dwI].dwNbytes = sizeof(DWORD) ;
    pStatic->snapShotTable[dwI].dwDefaultValue = PROMPT_UISETUP ;
        // Required if rcPromptMsgID exists.
    pStatic->snapShotTable[dwI].dwFlags = 0 ;
    pStatic->snapShotTable[dwI].dwGIDflags = 0xffffffff ;
    dwI++ ;

    pStatic->snapShotTable[dwI].pstrKeyword  = "*DisabledFeatures" ;
    pStatic->snapShotTable[dwI].dwSrcOffset  = offsetof(DFEATURE_OPTIONS,
                                        atrDisabledFeatures) ;
    pStatic->snapShotTable[dwI].dwDestOffset = offsetof(OPTION,
                                        liDisabledFeatures) ;
    pStatic->snapShotTable[dwI].dwNbytes = sizeof(LISTINDEX) ;
    pStatic->snapShotTable[dwI].dwDefaultValue = END_OF_LIST  ;
    pStatic->snapShotTable[dwI].dwFlags = 0 ;
    pStatic->snapShotTable[dwI].dwGIDflags = 0xffffffff ;
    dwI++ ;




    // write the CommandIndex into pOption->dwCmdIndex
    //  the Invocation field is not used.
    pStatic->snapShotTable[dwI].pstrKeyword  = "*Command (CmdSelect)" ;
    pStatic->snapShotTable[dwI].dwSrcOffset  = offsetof(DFEATURE_OPTIONS,
                                        atrCommandIndex) ;
    pStatic->snapShotTable[dwI].dwDestOffset = offsetof(OPTION,
                    dwCmdIndex) ;
                     //  Invocation) + offsetof(INVOCATION, dwCount) ;
    pStatic->snapShotTable[dwI].dwNbytes = sizeof(DWORD) ;
    pStatic->snapShotTable[dwI].dwDefaultValue = UNUSED_ITEM ;
    pStatic->snapShotTable[dwI].dwFlags = SSF_HEAPOFFSET ;
    pStatic->snapShotTable[dwI].dwGIDflags = 0xffffffff ;
    dwI++ ;


    //  --- option specific entries ----



    pStatic->snapShotTable[dwI].pstrKeyword  = "*DPI" ;
    pStatic->snapShotTable[dwI].dwSrcOffset  = offsetof(DFEATURE_OPTIONS,
                                        atrDPI) ;
    pStatic->snapShotTable[dwI].dwDestOffset = offsetof(RESOLUTION,
                                        iXdpi) ;
    pStatic->snapShotTable[dwI].dwNbytes = sizeof(DWORD) ;
    pStatic->snapShotTable[dwI].dwDefaultValue = 0 ;
    pStatic->snapShotTable[dwI].dwFlags = SSF_REQUIRED ;
    pStatic->snapShotTable[dwI].dwGIDflags = GIDF_RESOLUTION ;
    dwI++ ;


    pStatic->snapShotTable[dwI].pstrKeyword  = "*DPI" ;
    pStatic->snapShotTable[dwI].dwSrcOffset  = offsetof(DFEATURE_OPTIONS,
                                        atrDPI);
    pStatic->snapShotTable[dwI].dwDestOffset = offsetof(RESOLUTION,
                                        iYdpi) ;
    pStatic->snapShotTable[dwI].dwNbytes = sizeof(DWORD) ;
    pStatic->snapShotTable[dwI].dwDefaultValue = 0 ;
    pStatic->snapShotTable[dwI].dwFlags = SSF_REQUIRED | SSF_SECOND_DWORD ;
    pStatic->snapShotTable[dwI].dwGIDflags = GIDF_RESOLUTION ;
    dwI++ ;

    pStatic->snapShotTable[dwI].pstrKeyword  = "*OptionID" ;
    pStatic->snapShotTable[dwI].dwSrcOffset  = offsetof(DFEATURE_OPTIONS,
                                        atrOptIDvalue) ;
    pStatic->snapShotTable[dwI].dwDestOffset = offsetof(RESOLUTION,
                                        dwResolutionID) ;
    pStatic->snapShotTable[dwI].dwNbytes = sizeof(DWORD) ;
    pStatic->snapShotTable[dwI].dwDefaultValue = RES_ID_IGNORE ;
    pStatic->snapShotTable[dwI].dwFlags = 0 ;
    pStatic->snapShotTable[dwI].dwGIDflags = GIDF_RESOLUTION ;
    dwI++ ;



    //  -----

    pStatic->snapShotTable[dwI].pstrKeyword  = "*rcHTPatternID" ;
    pStatic->snapShotTable[dwI].dwSrcOffset  = offsetof(DFEATURE_OPTIONS,
                                        atrRcHTPatternID) ;
    pStatic->snapShotTable[dwI].dwDestOffset = offsetof(HALFTONING,
                                        dwRCpatternID) ;
    pStatic->snapShotTable[dwI].dwNbytes = sizeof(INT) ;
    pStatic->snapShotTable[dwI].dwDefaultValue = 0 ;
    pStatic->snapShotTable[dwI].dwFlags = SSF_OTHER_RESID ;
    //  SSF_REQUIRED for OEM defined patterns.
    pStatic->snapShotTable[dwI].dwGIDflags = GIDF_HALFTONING;
    dwI++ ;

    pStatic->snapShotTable[dwI].pstrKeyword  = "*HTPatternSize" ;
    pStatic->snapShotTable[dwI].dwSrcOffset  = offsetof(DFEATURE_OPTIONS,
                                        atrHTPatternSize) ;
    pStatic->snapShotTable[dwI].dwDestOffset = offsetof(HALFTONING,
                                        HalftonePatternSize) ;
    pStatic->snapShotTable[dwI].dwNbytes = sizeof(POINT) ;
    pStatic->snapShotTable[dwI].dwDefaultValue = 0 ;
    pStatic->snapShotTable[dwI].dwFlags = 0 ;
    //  SSF_REQUIRED for OEM defined patterns.
    pStatic->snapShotTable[dwI].dwGIDflags = GIDF_HALFTONING ;
    dwI++ ;

    pStatic->snapShotTable[dwI].pstrKeyword  = "*HTNumPatterns" ;
    pStatic->snapShotTable[dwI].dwSrcOffset  = offsetof(DFEATURE_OPTIONS,
                                        atrHTNumPatterns) ;
    pStatic->snapShotTable[dwI].dwDestOffset = offsetof(HALFTONING,
                                        dwHTNumPatterns) ;
    pStatic->snapShotTable[dwI].dwNbytes = sizeof(DWORD) ;
    pStatic->snapShotTable[dwI].dwDefaultValue = 1 ;
    pStatic->snapShotTable[dwI].dwFlags = 0 ;
    pStatic->snapShotTable[dwI].dwGIDflags = GIDF_HALFTONING ;
    dwI++ ;

    pStatic->snapShotTable[dwI].pstrKeyword  = "*HTCallbackID" ;
    pStatic->snapShotTable[dwI].dwSrcOffset  = offsetof(DFEATURE_OPTIONS,
                                        atrHTCallbackID) ;
    pStatic->snapShotTable[dwI].dwDestOffset = offsetof(HALFTONING,
                                        dwHTCallbackID) ;
    pStatic->snapShotTable[dwI].dwNbytes = sizeof(DWORD) ;
    pStatic->snapShotTable[dwI].dwDefaultValue = 0 ;
    pStatic->snapShotTable[dwI].dwFlags = 0 ;
    pStatic->snapShotTable[dwI].dwGIDflags = GIDF_HALFTONING ;
    dwI++ ;

    pStatic->snapShotTable[dwI].pstrKeyword  = "*Luminance" ;
    pStatic->snapShotTable[dwI].dwSrcOffset  = offsetof(DFEATURE_OPTIONS,
                                        atrLuminance) ;
    pStatic->snapShotTable[dwI].dwDestOffset = offsetof(HALFTONING,
                                        iLuminance) ;
    pStatic->snapShotTable[dwI].dwNbytes = sizeof(INT) ;
    pStatic->snapShotTable[dwI].dwDefaultValue = 100 ;
    pStatic->snapShotTable[dwI].dwFlags = 0 ;
    pStatic->snapShotTable[dwI].dwGIDflags = GIDF_HALFTONING ;
    dwI++ ;

    pStatic->snapShotTable[dwI].pstrKeyword  = "*dwHalftoneID - synth" ;
    pStatic->snapShotTable[dwI].dwSrcOffset  = offsetof(DFEATURE_OPTIONS,
                                        atrOptIDvalue) ;
    pStatic->snapShotTable[dwI].dwDestOffset = offsetof(HALFTONING,
                                        dwHTID) ;
    pStatic->snapShotTable[dwI].dwNbytes = sizeof(DWORD) ;
    pStatic->snapShotTable[dwI].dwDefaultValue = 0 ;
    pStatic->snapShotTable[dwI].dwFlags = SSF_REQUIRED ;
    pStatic->snapShotTable[dwI].dwGIDflags = GIDF_HALFTONING ;
    dwI++ ;

    //  ------

    pStatic->snapShotTable[dwI].pstrKeyword  = "*dwDuplexID - synth" ;
    pStatic->snapShotTable[dwI].dwSrcOffset  = offsetof(DFEATURE_OPTIONS,
                                        atrOptIDvalue) ;
    pStatic->snapShotTable[dwI].dwDestOffset = offsetof(DUPLEX,
                                        dwDuplexID) ;
    pStatic->snapShotTable[dwI].dwNbytes = sizeof(DWORD) ;
    pStatic->snapShotTable[dwI].dwDefaultValue = 0 ;
    pStatic->snapShotTable[dwI].dwFlags = SSF_REQUIRED ;
    pStatic->snapShotTable[dwI].dwGIDflags = GIDF_DUPLEX ;
    dwI++ ;

    //  ------

    pStatic->snapShotTable[dwI].pstrKeyword  = "*dwRotationAngle - synth" ;
    pStatic->snapShotTable[dwI].dwSrcOffset  = offsetof(DFEATURE_OPTIONS,
                                        atrOptIDvalue) ;
    pStatic->snapShotTable[dwI].dwDestOffset = offsetof(ORIENTATION,
                                        dwRotationAngle) ;
    pStatic->snapShotTable[dwI].dwNbytes = sizeof(DWORD) ;
    pStatic->snapShotTable[dwI].dwDefaultValue = ROTATE_NONE ;
    pStatic->snapShotTable[dwI].dwFlags = SSF_REQUIRED ;
    pStatic->snapShotTable[dwI].dwGIDflags = GIDF_ORIENTATION ;
    dwI++ ;

    //  ------

    pStatic->snapShotTable[dwI].pstrKeyword  = "*dwPageProtectID - synth" ;
    pStatic->snapShotTable[dwI].dwSrcOffset  = offsetof(DFEATURE_OPTIONS,
                                        atrOptIDvalue) ;
    pStatic->snapShotTable[dwI].dwDestOffset = offsetof(PAGEPROTECT,
                                        dwPageProtectID) ;
    pStatic->snapShotTable[dwI].dwNbytes = sizeof(DWORD) ;
    pStatic->snapShotTable[dwI].dwDefaultValue = PAGEPRO_OFF ;
    pStatic->snapShotTable[dwI].dwFlags = SSF_REQUIRED ;
    pStatic->snapShotTable[dwI].dwGIDflags = GIDF_PAGEPROTECTION ;
    dwI++ ;

    //  -----


    pStatic->snapShotTable[dwI].pstrKeyword  = "*PageDimensions" ;
    pStatic->snapShotTable[dwI].dwSrcOffset  = offsetof(DFEATURE_OPTIONS,
                                        atrPageDimensions) ;
    pStatic->snapShotTable[dwI].dwDestOffset = offsetof(PAGESIZE,
                                        szPaperSize) ;
    pStatic->snapShotTable[dwI].dwNbytes = sizeof(SIZE) ;
    pStatic->snapShotTable[dwI].dwDefaultValue = 0 ;
    pStatic->snapShotTable[dwI].dwFlags = 0 ;
    //  not required for userdefined pagesize.
    pStatic->snapShotTable[dwI].dwGIDflags = GIDF_PAGESIZE ;
    dwI++ ;


    pStatic->snapShotTable[dwI].pstrKeyword  = "*dwPaperSizeID - synth" ;
    pStatic->snapShotTable[dwI].dwSrcOffset  = offsetof(DFEATURE_OPTIONS,
                                        atrOptIDvalue) ;
    pStatic->snapShotTable[dwI].dwDestOffset = offsetof(PAGESIZE,
                                        dwPaperSizeID) ;
    pStatic->snapShotTable[dwI].dwNbytes = sizeof(DWORD) ;
    pStatic->snapShotTable[dwI].dwDefaultValue = 0 ;
    pStatic->snapShotTable[dwI].dwFlags = SSF_REQUIRED ;
    pStatic->snapShotTable[dwI].dwGIDflags = GIDF_PAGESIZE ;
    dwI++ ;

    //  ------- special case INPUTSLOT



    pStatic->snapShotTable[dwI].pstrKeyword  = "*dwPaperSourceID - synth" ;
    pStatic->snapShotTable[dwI].dwSrcOffset  = offsetof(DFEATURE_OPTIONS,
                                        atrOptIDvalue) ;
    pStatic->snapShotTable[dwI].dwDestOffset = offsetof(INPUTSLOT,
                                        dwPaperSourceID) ;
    pStatic->snapShotTable[dwI].dwNbytes = sizeof(DWORD) ;
    pStatic->snapShotTable[dwI].dwDefaultValue = 0 ;
    pStatic->snapShotTable[dwI].dwFlags = SSF_REQUIRED ;
    pStatic->snapShotTable[dwI].dwGIDflags = GIDF_INPUTSLOT ;
    dwI++ ;

#if 0
    dead keyword

    pStatic->snapShotTable[dwI].dwSrcOffset  = offsetof(DFEATURE_OPTIONS,
                                        atrPaperFeed) ;
    pStatic->snapShotTable[dwI].dwDestOffset = offsetof(INPUTSLOT,
                                        dwBinAdjust) ;
    pStatic->snapShotTable[dwI].dwNbytes = sizeof(DWORD) ;
    pStatic->snapShotTable[dwI].dwDefaultValue = DCBA_FACEUPNONE ;
    pStatic->snapShotTable[dwI].dwFlags = 0 ;
    pStatic->snapShotTable[dwI].dwGIDflags = GIDF_INPUTSLOT ;
    dwI++ ;
#endif

    //  ------

    pStatic->snapShotTable[dwI].pstrKeyword  = "*dwMediaTypeID - synth" ;
    pStatic->snapShotTable[dwI].dwSrcOffset  = offsetof(DFEATURE_OPTIONS,
                                        atrOptIDvalue) ;
    pStatic->snapShotTable[dwI].dwDestOffset = offsetof(MEDIATYPE,
                                        dwMediaTypeID) ;
    pStatic->snapShotTable[dwI].dwNbytes = sizeof(DWORD) ;
    pStatic->snapShotTable[dwI].dwDefaultValue = 0 ;
    pStatic->snapShotTable[dwI].dwFlags = SSF_REQUIRED ;
    pStatic->snapShotTable[dwI].dwGIDflags = GIDF_MEDIATYPE ;
    dwI++ ;


    // -----

    pStatic->snapShotTable[dwI].pstrKeyword  = "*dwCollateID - synth" ;
    pStatic->snapShotTable[dwI].dwSrcOffset  = offsetof(DFEATURE_OPTIONS,
                                        atrOptIDvalue) ;
    pStatic->snapShotTable[dwI].dwDestOffset = offsetof(COLLATE,
                                        dwCollateID) ;
    pStatic->snapShotTable[dwI].dwNbytes = sizeof(DWORD) ;
    pStatic->snapShotTable[dwI].dwDefaultValue = 0 ;
    pStatic->snapShotTable[dwI].dwFlags = SSF_REQUIRED ;
    pStatic->snapShotTable[dwI].dwGIDflags = GIDF_COLLATE ;
    dwI++ ;



    //  -----



    //  -----

    pStatic->snapShotTable[dwI].pstrKeyword  = "*MemoryConfigMB" ;
    pStatic->snapShotTable[dwI].dwSrcOffset  = offsetof(DFEATURE_OPTIONS,
                                        atrMemoryConfigMB) ;
    pStatic->snapShotTable[dwI].dwDestOffset = offsetof(MEMOPTION,
                                        dwInstalledMem) ;
    pStatic->snapShotTable[dwI].dwNbytes = sizeof(DWORD) ;
    pStatic->snapShotTable[dwI].dwDefaultValue = 0 ;
    pStatic->snapShotTable[dwI].dwFlags = SSF_MB_TO_BYTES ;
    pStatic->snapShotTable[dwI].dwGIDflags = GIDF_MEMOPTION ;
    dwI++ ;

    pStatic->snapShotTable[dwI].pstrKeyword  = "*MemoryConfigMB" ;
    pStatic->snapShotTable[dwI].dwSrcOffset  = offsetof(DFEATURE_OPTIONS,
                                        atrMemoryConfigMB) ;
    pStatic->snapShotTable[dwI].dwDestOffset = offsetof(MEMOPTION,
                                        dwFreeMem) ;
    pStatic->snapShotTable[dwI].dwNbytes = sizeof(DWORD) ;
    pStatic->snapShotTable[dwI].dwDefaultValue = 0 ;
    pStatic->snapShotTable[dwI].dwFlags = SSF_SECOND_DWORD | SSF_MB_TO_BYTES ;
    pStatic->snapShotTable[dwI].dwGIDflags = GIDF_MEMOPTION ;
    dwI++ ;



    pStatic->snapShotTable[dwI].pstrKeyword  = "*MemoryConfigKB" ;
    pStatic->snapShotTable[dwI].dwSrcOffset  = offsetof(DFEATURE_OPTIONS,
                                        atrMemoryConfigKB) ;
    pStatic->snapShotTable[dwI].dwDestOffset = offsetof(MEMOPTION,
                                        dwInstalledMem) ;
    pStatic->snapShotTable[dwI].dwNbytes = sizeof(DWORD) ;
    pStatic->snapShotTable[dwI].dwDefaultValue = 0 ;
    pStatic->snapShotTable[dwI].dwFlags = SSF_KB_TO_BYTES |
    SSF_DONT_USEDEFAULT | SSF_FAILIFZERO ;
    pStatic->snapShotTable[dwI].dwGIDflags = GIDF_MEMOPTION ;
    dwI++ ;

    pStatic->snapShotTable[dwI].pstrKeyword  = "*MemoryConfigKB" ;
    pStatic->snapShotTable[dwI].dwSrcOffset  = offsetof(DFEATURE_OPTIONS,
                                        atrMemoryConfigKB) ;
    pStatic->snapShotTable[dwI].dwDestOffset = offsetof(MEMOPTION,
                                        dwFreeMem) ;
    pStatic->snapShotTable[dwI].dwNbytes = sizeof(DWORD) ;
    pStatic->snapShotTable[dwI].dwDefaultValue = 0 ;
    pStatic->snapShotTable[dwI].dwFlags = SSF_SECOND_DWORD |
        SSF_KB_TO_BYTES | SSF_DONT_USEDEFAULT | SSF_FAILIFZERO ;
    pStatic->snapShotTable[dwI].dwGIDflags = GIDF_MEMOPTION ;
    dwI++ ;

// ------

    pStatic->snapShotTable[dwI].pstrKeyword  = "*OutputOrderReversed? (option level)"  ;
    pStatic->snapShotTable[dwI].dwSrcOffset  = offsetof(DFEATURE_OPTIONS,
                                        atrOutputOrderReversed) ;
    pStatic->snapShotTable[dwI].dwDestOffset = offsetof(OUTPUTBIN,
                                        bOutputOrderReversed) ;
    pStatic->snapShotTable[dwI].dwNbytes = sizeof(BOOL) ;
    pStatic->snapShotTable[dwI].dwDefaultValue = UNUSED_ITEM ;
    pStatic->snapShotTable[dwI].dwFlags = 0 ;
    pStatic->snapShotTable[dwI].dwGIDflags = GIDF_OUTPUTBIN ;
    dwI++ ;



    //  end of SSTI_OPTIONS  section

    pStatic->snapShotTable[dwI].dwNbytes = 0 ;
    dwI++ ;

    //  beginning of SSTI_UPDATE_OPTIONS  section


    pStatic->snapShotTable[dwI].pstrKeyword  = "*rcIconID (Opt)" ;
    pStatic->snapShotTable[dwI].dwSrcOffset  = offsetof(DFEATURE_OPTIONS,
                                        atrOptRcIconID) ;
    pStatic->snapShotTable[dwI].dwDestOffset = offsetof(OPTION,
                                        loResourceIcon) ;
    pStatic->snapShotTable[dwI].dwNbytes = sizeof(INT) ;
    pStatic->snapShotTable[dwI].dwDefaultValue = 0 ;
    pStatic->snapShotTable[dwI].dwFlags = SSF_ICONID ;
    pStatic->snapShotTable[dwI].dwGIDflags = 0xffffffff ;
    dwI++ ;

    pStatic->snapShotTable[dwI].pstrKeyword  = "*rcPromptMsgID (Opt)" ;
    pStatic->snapShotTable[dwI].dwSrcOffset  = offsetof(DFEATURE_OPTIONS,
                                        atrOptRcPromptMsgID) ;
    pStatic->snapShotTable[dwI].dwDestOffset = offsetof(OPTION,
                                        loPromptMessage) ;
    pStatic->snapShotTable[dwI].dwNbytes = sizeof(INT) ;
    pStatic->snapShotTable[dwI].dwDefaultValue = 0 ;
    pStatic->snapShotTable[dwI].dwFlags = SSF_OTHER_RESID ;
    pStatic->snapShotTable[dwI].dwGIDflags = 0xffffffff ;
    dwI++ ;


    pStatic->snapShotTable[dwI].pstrKeyword  = "*PageProtectMem (Opt)" ;
    pStatic->snapShotTable[dwI].dwSrcOffset  = offsetof(DFEATURE_OPTIONS,
                                        atrPageProtectMem) ;
    pStatic->snapShotTable[dwI].dwDestOffset = offsetof(PAGESIZE,
                                        dwPageProtectionMemory) ;
    pStatic->snapShotTable[dwI].dwNbytes = sizeof(DWORD) ;
    pStatic->snapShotTable[dwI].dwDefaultValue = 0 ;
    pStatic->snapShotTable[dwI].dwFlags = 0 ;
        // required if there is a page protect feature
    pStatic->snapShotTable[dwI].dwGIDflags = GIDF_PAGESIZE ;
    dwI++ ;





    //  end of SSTI_UPDATE_OPTIONS  section


    pStatic->snapShotTable[dwI].dwNbytes = 0 ;
    dwI++ ;




    //  beginning of SSTI_OPTIONEX  section




    pStatic->snapShotTable[dwI].pstrKeyword  = "*DPI" ;
    pStatic->snapShotTable[dwI].dwSrcOffset  = offsetof(DFEATURE_OPTIONS,
                                        atrDPI) ;
    pStatic->snapShotTable[dwI].dwDestOffset = offsetof(RESOLUTIONEX,
                                        ptGrxDPI) ;
    pStatic->snapShotTable[dwI].dwNbytes = sizeof(POINT) ;
    pStatic->snapShotTable[dwI].dwDefaultValue = 0 ;
    pStatic->snapShotTable[dwI].dwFlags = SSF_REQUIRED ;
    pStatic->snapShotTable[dwI].dwGIDflags = GIDF_RESOLUTION ;
    dwI++ ;

    pStatic->snapShotTable[dwI].pstrKeyword  = "*TextDPI" ;
    pStatic->snapShotTable[dwI].dwSrcOffset  = offsetof(DFEATURE_OPTIONS,
                                        atrTextDPI) ;
    pStatic->snapShotTable[dwI].dwDestOffset = offsetof(RESOLUTIONEX,
                                        ptTextDPI) ;
    pStatic->snapShotTable[dwI].dwNbytes = sizeof(POINT) ;
    pStatic->snapShotTable[dwI].dwDefaultValue = 0 ;
    pStatic->snapShotTable[dwI].dwFlags = SSF_REQUIRED ;
    pStatic->snapShotTable[dwI].dwGIDflags = GIDF_RESOLUTION ;
    dwI++ ;

    pStatic->snapShotTable[dwI].pstrKeyword  = "*MinStripBlankPixels" ;
    pStatic->snapShotTable[dwI].dwSrcOffset  = offsetof(DFEATURE_OPTIONS,
                                        atrMinStripBlankPixels) ;
    pStatic->snapShotTable[dwI].dwDestOffset = offsetof(RESOLUTIONEX,
                                        dwMinStripBlankPixels) ;
    pStatic->snapShotTable[dwI].dwNbytes = sizeof(DWORD) ;
    pStatic->snapShotTable[dwI].dwDefaultValue = 0 ;
    pStatic->snapShotTable[dwI].dwFlags = 0 ;
    // required if *StripBlanks is not NONE.
    pStatic->snapShotTable[dwI].dwGIDflags = GIDF_RESOLUTION ;
    dwI++ ;

    pStatic->snapShotTable[dwI].pstrKeyword  = "*RedDeviceGamma" ;
    pStatic->snapShotTable[dwI].dwSrcOffset  = offsetof(DFEATURE_OPTIONS,
                                        atrRedDeviceGamma) ;
    pStatic->snapShotTable[dwI].dwDestOffset = offsetof(RESOLUTIONEX,
                                        dwRedDeviceGamma) ;
    pStatic->snapShotTable[dwI].dwNbytes = sizeof(DWORD) ;
    pStatic->snapShotTable[dwI].dwDefaultValue = UNUSED_ITEM ;
    pStatic->snapShotTable[dwI].dwFlags = 0 ;
    // required if *StripBlanks is not NONE.
    pStatic->snapShotTable[dwI].dwGIDflags = GIDF_RESOLUTION ;
    dwI++ ;

    pStatic->snapShotTable[dwI].pstrKeyword  = "*GreenDeviceGamma" ;
    pStatic->snapShotTable[dwI].dwSrcOffset  = offsetof(DFEATURE_OPTIONS,
                                        atrGreenDeviceGamma) ;
    pStatic->snapShotTable[dwI].dwDestOffset = offsetof(RESOLUTIONEX,
                                        dwGreenDeviceGamma) ;
    pStatic->snapShotTable[dwI].dwNbytes = sizeof(DWORD) ;
    pStatic->snapShotTable[dwI].dwDefaultValue = UNUSED_ITEM ;
    pStatic->snapShotTable[dwI].dwFlags = 0 ;
    // required if *StripBlanks is not NONE.
    pStatic->snapShotTable[dwI].dwGIDflags = GIDF_RESOLUTION ;
    dwI++ ;

    pStatic->snapShotTable[dwI].pstrKeyword  = "*BlueDeviceGamma" ;
    pStatic->snapShotTable[dwI].dwSrcOffset  = offsetof(DFEATURE_OPTIONS,
                                        atrBlueDeviceGamma) ;
    pStatic->snapShotTable[dwI].dwDestOffset = offsetof(RESOLUTIONEX,
                                        dwBlueDeviceGamma) ;
    pStatic->snapShotTable[dwI].dwNbytes = sizeof(DWORD) ;
    pStatic->snapShotTable[dwI].dwDefaultValue = UNUSED_ITEM ;
    pStatic->snapShotTable[dwI].dwFlags = 0 ;
    // required if *StripBlanks is not NONE.
    pStatic->snapShotTable[dwI].dwGIDflags = GIDF_RESOLUTION ;
    dwI++ ;

    pStatic->snapShotTable[dwI].pstrKeyword  = "*PinsPerPhysPass" ;
    pStatic->snapShotTable[dwI].dwSrcOffset  = offsetof(DFEATURE_OPTIONS,
                                        atrPinsPerPhysPass) ;
    pStatic->snapShotTable[dwI].dwDestOffset = offsetof(RESOLUTIONEX,
                                        dwPinsPerPhysPass) ;
    pStatic->snapShotTable[dwI].dwNbytes = sizeof(DWORD) ;
    pStatic->snapShotTable[dwI].dwDefaultValue = 1 ;
    pStatic->snapShotTable[dwI].dwFlags = 0 ;
    pStatic->snapShotTable[dwI].dwGIDflags = GIDF_RESOLUTION ;
    dwI++ ;

    pStatic->snapShotTable[dwI].pstrKeyword  = "*PinsPerLogPass" ;
    pStatic->snapShotTable[dwI].dwSrcOffset  = offsetof(DFEATURE_OPTIONS,
                                        atrPinsPerLogPass) ;
    pStatic->snapShotTable[dwI].dwDestOffset = offsetof(RESOLUTIONEX,
                                        dwPinsPerLogPass) ;
    pStatic->snapShotTable[dwI].dwNbytes = sizeof(DWORD) ;
    pStatic->snapShotTable[dwI].dwDefaultValue = 1 ;
    pStatic->snapShotTable[dwI].dwFlags = 0 ;
    pStatic->snapShotTable[dwI].dwGIDflags = GIDF_RESOLUTION ;
    dwI++ ;


    pStatic->snapShotTable[dwI].pstrKeyword  = "*SpotDiameter" ;
    pStatic->snapShotTable[dwI].dwSrcOffset  = offsetof(DFEATURE_OPTIONS,
                                        atrSpotDiameter) ;
    pStatic->snapShotTable[dwI].dwDestOffset = offsetof(RESOLUTIONEX,
                                        dwSpotDiameter) ;
    pStatic->snapShotTable[dwI].dwNbytes = sizeof(DWORD) ;
    pStatic->snapShotTable[dwI].dwDefaultValue = 0 ;
    pStatic->snapShotTable[dwI].dwFlags = SSF_REQUIRED ;
    pStatic->snapShotTable[dwI].dwGIDflags = GIDF_RESOLUTION ;
    dwI++ ;

    pStatic->snapShotTable[dwI].pstrKeyword  = "*RequireUniDir?" ;
    pStatic->snapShotTable[dwI].dwSrcOffset  = offsetof(DFEATURE_OPTIONS,
                                        atrRequireUniDir) ;
    pStatic->snapShotTable[dwI].dwDestOffset = offsetof(RESOLUTIONEX,
                                        bRequireUniDir) ;
    pStatic->snapShotTable[dwI].dwNbytes = sizeof(BOOL) ;
    pStatic->snapShotTable[dwI].dwDefaultValue = FALSE ;
    pStatic->snapShotTable[dwI].dwFlags = 0 ;
    pStatic->snapShotTable[dwI].dwGIDflags = GIDF_RESOLUTION ;
    dwI++ ;



    //  ---- _COLORMODEEX


    pStatic->snapShotTable[dwI].pstrKeyword  = "*Color?" ;
    pStatic->snapShotTable[dwI].dwSrcOffset  = offsetof(DFEATURE_OPTIONS,
                                        atrColor) ;
    pStatic->snapShotTable[dwI].dwDestOffset = offsetof(COLORMODEEX,
                                        bColor) ;
    pStatic->snapShotTable[dwI].dwNbytes = sizeof(DWORD) ;
    pStatic->snapShotTable[dwI].dwDefaultValue = TRUE ;
    pStatic->snapShotTable[dwI].dwFlags = 0 ;
    pStatic->snapShotTable[dwI].dwGIDflags = GIDF_COLORMODE ;
    dwI++ ;



    pStatic->snapShotTable[dwI].pstrKeyword  = "*DevNumOfPlanes" ;
    pStatic->snapShotTable[dwI].dwSrcOffset  = offsetof(DFEATURE_OPTIONS,
                                        atrDevNumOfPlanes) ;
    pStatic->snapShotTable[dwI].dwDestOffset = offsetof(COLORMODEEX,
                                        dwPrinterNumOfPlanes) ;
    pStatic->snapShotTable[dwI].dwNbytes = sizeof(DWORD) ;
    pStatic->snapShotTable[dwI].dwDefaultValue = 1 ;
    pStatic->snapShotTable[dwI].dwFlags = 0 ;
    pStatic->snapShotTable[dwI].dwGIDflags = GIDF_COLORMODE ;
    dwI++ ;


    pStatic->snapShotTable[dwI].pstrKeyword  = "*DevBPP" ;
    pStatic->snapShotTable[dwI].dwSrcOffset  = offsetof(DFEATURE_OPTIONS,
                                        atrDevBPP) ;
    pStatic->snapShotTable[dwI].dwDestOffset = offsetof(COLORMODEEX,
                                        dwPrinterBPP) ;
    pStatic->snapShotTable[dwI].dwNbytes = sizeof(DWORD) ;
    pStatic->snapShotTable[dwI].dwDefaultValue = 1 ;
    pStatic->snapShotTable[dwI].dwFlags = 0 ;
    pStatic->snapShotTable[dwI].dwGIDflags = GIDF_COLORMODE ;
    dwI++ ;

    pStatic->snapShotTable[dwI].pstrKeyword  = "*ColorPlaneOrder" ;
    pStatic->snapShotTable[dwI].dwSrcOffset  = offsetof(DFEATURE_OPTIONS,
                                        atrColorPlaneOrder) ;
    pStatic->snapShotTable[dwI].dwDestOffset = offsetof(COLORMODEEX,
                                        liColorPlaneOrder) ;
    pStatic->snapShotTable[dwI].dwNbytes = sizeof(LISTINDEX) ;
    pStatic->snapShotTable[dwI].dwDefaultValue = END_OF_LIST ;
    pStatic->snapShotTable[dwI].dwFlags = 0 ;
    //  SSF_REQUIRED only if NumPlanes > 1.
    pStatic->snapShotTable[dwI].dwGIDflags = GIDF_COLORMODE ;
    dwI++ ;

    pStatic->snapShotTable[dwI].pstrKeyword  = "*DrvBPP" ;
    pStatic->snapShotTable[dwI].dwSrcOffset  = offsetof(DFEATURE_OPTIONS,
                                        atrDrvBPP) ;
    pStatic->snapShotTable[dwI].dwDestOffset = offsetof(COLORMODEEX,
                                        dwDrvBPP) ;
    pStatic->snapShotTable[dwI].dwNbytes = sizeof(DWORD) ;
    pStatic->snapShotTable[dwI].dwDefaultValue = 1 ;
    pStatic->snapShotTable[dwI].dwFlags = 0 ;
    pStatic->snapShotTable[dwI].dwGIDflags = GIDF_COLORMODE ;
    dwI++ ;




    pStatic->snapShotTable[dwI].pstrKeyword  = "*IPCallbackID" ;
    pStatic->snapShotTable[dwI].dwSrcOffset  = offsetof(DFEATURE_OPTIONS,
                                        atrIPCallbackID) ;
    pStatic->snapShotTable[dwI].dwDestOffset = offsetof(COLORMODEEX,
                                        dwIPCallbackID) ;
    pStatic->snapShotTable[dwI].dwNbytes = sizeof(DWORD) ;
    pStatic->snapShotTable[dwI].dwDefaultValue = 0 ;
    pStatic->snapShotTable[dwI].dwFlags = 0 ;
    pStatic->snapShotTable[dwI].dwGIDflags = GIDF_COLORMODE ;
    dwI++ ;

    pStatic->snapShotTable[dwI].pstrKeyword  = "*RasterMode" ;
    pStatic->snapShotTable[dwI].dwSrcOffset  = offsetof(DFEATURE_OPTIONS,
                                        atrRasterMode) ;
    pStatic->snapShotTable[dwI].dwDestOffset = offsetof(COLORMODEEX,
                                        dwRasterMode) ;
    pStatic->snapShotTable[dwI].dwNbytes = sizeof(DWORD) ;
    pStatic->snapShotTable[dwI].dwDefaultValue = RASTMODE_INDEXED ;
    pStatic->snapShotTable[dwI].dwFlags = 0 ;
    pStatic->snapShotTable[dwI].dwGIDflags = GIDF_COLORMODE ;
    dwI++ ;

    pStatic->snapShotTable[dwI].pstrKeyword  = "*PaletteSize" ;
    pStatic->snapShotTable[dwI].dwSrcOffset  = offsetof(DFEATURE_OPTIONS,
                                        atrPaletteSize) ;
    pStatic->snapShotTable[dwI].dwDestOffset = offsetof(COLORMODEEX,
                                        dwPaletteSize ) ;
    pStatic->snapShotTable[dwI].dwNbytes = sizeof(DWORD) ;
    pStatic->snapShotTable[dwI].dwDefaultValue = 2 ;
    pStatic->snapShotTable[dwI].dwFlags = 0 ;
    pStatic->snapShotTable[dwI].dwGIDflags = GIDF_COLORMODE ;
    dwI++ ;

    pStatic->snapShotTable[dwI].pstrKeyword  = "*PaletteProgrammable?" ;
    pStatic->snapShotTable[dwI].dwSrcOffset  = offsetof(DFEATURE_OPTIONS,
                                        atrPaletteProgrammable) ;
    pStatic->snapShotTable[dwI].dwDestOffset = offsetof(COLORMODEEX,
                                        bPaletteProgrammable) ;
    pStatic->snapShotTable[dwI].dwNbytes = sizeof(DWORD) ;
    pStatic->snapShotTable[dwI].dwDefaultValue = BT_FALSE ;
    pStatic->snapShotTable[dwI].dwFlags = 0 ;
    pStatic->snapShotTable[dwI].dwGIDflags = GIDF_COLORMODE ;
    dwI++ ;


    //  -----  _PAGESIZEEX


    // note if set to 0,0 assume is same as papersize subject
    // to margin restrictions.

    pStatic->snapShotTable[dwI].pstrKeyword  = "*PrintableArea" ;
    pStatic->snapShotTable[dwI].dwSrcOffset  = offsetof(DFEATURE_OPTIONS,
                                        atrPrintableSize) ;
    pStatic->snapShotTable[dwI].dwDestOffset = offsetof(PAGESIZEEX,
                                        szImageArea) ;
    pStatic->snapShotTable[dwI].dwNbytes = sizeof(SIZEL) ;
    pStatic->snapShotTable[dwI].dwDefaultValue = 0 ;
    pStatic->snapShotTable[dwI].dwFlags = 0 ;
    pStatic->snapShotTable[dwI].dwGIDflags = GIDF_PAGESIZE ;
    dwI++ ;

    pStatic->snapShotTable[dwI].pstrKeyword  = "*PrintableOrigin" ;
    pStatic->snapShotTable[dwI].dwSrcOffset  = offsetof(DFEATURE_OPTIONS,
                                        atrPrintableOrigin) ;
    pStatic->snapShotTable[dwI].dwDestOffset = offsetof(PAGESIZEEX,
                                        ptImageOrigin) ;
    pStatic->snapShotTable[dwI].dwNbytes = sizeof(POINT) ;
    pStatic->snapShotTable[dwI].dwDefaultValue = UNUSED_ITEM ;
    pStatic->snapShotTable[dwI].dwFlags = 0 ;
    pStatic->snapShotTable[dwI].dwGIDflags = GIDF_PAGESIZE ;
    dwI++ ;

    // *CursorOrigin        see  BspecialProcessOption

    pStatic->snapShotTable[dwI].pstrKeyword  = "*MinSize" ;
    pStatic->snapShotTable[dwI].dwSrcOffset  = offsetof(DFEATURE_OPTIONS,
                                        atrMinSize) ;
    pStatic->snapShotTable[dwI].dwDestOffset = offsetof(PAGESIZEEX,
                                        ptMinSize) ;
    pStatic->snapShotTable[dwI].dwNbytes = sizeof(POINT) ;
    pStatic->snapShotTable[dwI].dwDefaultValue = 0 ;
    pStatic->snapShotTable[dwI].dwFlags = 0 ;
    //  only SSF_REQUIRED for custompage;
    pStatic->snapShotTable[dwI].dwGIDflags = GIDF_PAGESIZE ;
    pStatic->dwSSPaperSizeMinSizeIndex = dwI ;
    dwI++ ;

    pStatic->snapShotTable[dwI].pstrKeyword  = "*MaxSize" ;
    pStatic->snapShotTable[dwI].dwSrcOffset  = offsetof(DFEATURE_OPTIONS,
                                        atrMaxSize) ;
    pStatic->snapShotTable[dwI].dwDestOffset = offsetof(PAGESIZEEX,
                                        ptMaxSize) ;
    pStatic->snapShotTable[dwI].dwNbytes = sizeof(POINT) ;
    pStatic->snapShotTable[dwI].dwDefaultValue = 0 ;
    pStatic->snapShotTable[dwI].dwFlags = 0 ;
    pStatic->snapShotTable[dwI].dwGIDflags = GIDF_PAGESIZE ;
    pStatic->dwSSPaperSizeMaxSizeIndex = dwI ;
    dwI++ ;



    pStatic->snapShotTable[dwI].pstrKeyword  = "*TopMargin" ;
    pStatic->snapShotTable[dwI].dwSrcOffset  = offsetof(DFEATURE_OPTIONS,
                                        atrTopMargin) ;
    pStatic->snapShotTable[dwI].dwDestOffset = offsetof(PAGESIZEEX,
                                        dwTopMargin) ;
    pStatic->snapShotTable[dwI].dwNbytes = sizeof(DWORD) ;
    pStatic->snapShotTable[dwI].dwDefaultValue = 0 ;
    pStatic->snapShotTable[dwI].dwFlags = 0 ;
    pStatic->snapShotTable[dwI].dwGIDflags = GIDF_PAGESIZE ;
    dwI++ ;

    pStatic->snapShotTable[dwI].pstrKeyword  = "*BottomMargin" ;
    pStatic->snapShotTable[dwI].dwSrcOffset  = offsetof(DFEATURE_OPTIONS,
                                        atrBottomMargin) ;
    pStatic->snapShotTable[dwI].dwDestOffset = offsetof(PAGESIZEEX,
                                        dwBottomMargin) ;
    pStatic->snapShotTable[dwI].dwNbytes = sizeof(DWORD) ;
    pStatic->snapShotTable[dwI].dwDefaultValue = 0 ;
    pStatic->snapShotTable[dwI].dwFlags = 0 ;
    pStatic->snapShotTable[dwI].dwGIDflags = GIDF_PAGESIZE ;
    dwI++ ;

    pStatic->snapShotTable[dwI].pstrKeyword  = "*MaxPrintableWidth" ;
    pStatic->snapShotTable[dwI].dwSrcOffset  = offsetof(DFEATURE_OPTIONS,
                                        atrMaxPrintableWidth) ;
    pStatic->snapShotTable[dwI].dwDestOffset = offsetof(PAGESIZEEX,
                                        dwMaxPrintableWidth) ;
    pStatic->snapShotTable[dwI].dwNbytes = sizeof(DWORD) ;
    pStatic->snapShotTable[dwI].dwDefaultValue = 0 ;
    pStatic->snapShotTable[dwI].dwFlags = 0 ;
    pStatic->snapShotTable[dwI].dwGIDflags = GIDF_PAGESIZE ;
    dwI++ ;

    pStatic->snapShotTable[dwI].pstrKeyword  = "*MinLeftMargin" ;
    pStatic->snapShotTable[dwI].dwSrcOffset  = offsetof(DFEATURE_OPTIONS,
                                        atrMinLeftMargin) ;
    pStatic->snapShotTable[dwI].dwDestOffset = offsetof(PAGESIZEEX,
                                        dwMinLeftMargin) ;
    pStatic->snapShotTable[dwI].dwNbytes = sizeof(DWORD) ;
    pStatic->snapShotTable[dwI].dwDefaultValue = 0 ;
    pStatic->snapShotTable[dwI].dwFlags = 0 ;
    pStatic->snapShotTable[dwI].dwGIDflags = GIDF_PAGESIZE ;
    dwI++ ;

    pStatic->snapShotTable[dwI].pstrKeyword  = "*CenterPrintable?" ;
    pStatic->snapShotTable[dwI].dwSrcOffset  = offsetof(DFEATURE_OPTIONS,
                                        atrCenterPrintable) ;
    pStatic->snapShotTable[dwI].dwDestOffset = offsetof(PAGESIZEEX,
                                        bCenterPrintArea) ;
    pStatic->snapShotTable[dwI].dwNbytes = sizeof(BOOL) ;
    pStatic->snapShotTable[dwI].dwDefaultValue = FALSE ;
    pStatic->snapShotTable[dwI].dwFlags = 0 ;
    pStatic->snapShotTable[dwI].dwGIDflags = GIDF_PAGESIZE ;
    dwI++ ;



    pStatic->snapShotTable[dwI].pstrKeyword  = "*RotateSize?" ;
    pStatic->snapShotTable[dwI].dwSrcOffset  = offsetof(DFEATURE_OPTIONS,
                                        atrRotateSize) ;
    pStatic->snapShotTable[dwI].dwDestOffset = offsetof(PAGESIZEEX,
                                        bRotateSize) ;
    pStatic->snapShotTable[dwI].dwNbytes = sizeof(BOOL) ;
    pStatic->snapShotTable[dwI].dwDefaultValue = FALSE ;
    pStatic->snapShotTable[dwI].dwFlags = 0 ;
    pStatic->snapShotTable[dwI].dwGIDflags = GIDF_PAGESIZE ;
    dwI++ ;


    pStatic->snapShotTable[dwI].pstrKeyword  = "*PortRotationAngle" ;
    pStatic->snapShotTable[dwI].dwSrcOffset  = offsetof(DFEATURE_OPTIONS,
                                        atrPortRotationAngle) ;
    pStatic->snapShotTable[dwI].dwDestOffset = offsetof(PAGESIZEEX,
                                        dwPortRotationAngle) ;
    pStatic->snapShotTable[dwI].dwNbytes = sizeof(DWORD) ;
    pStatic->snapShotTable[dwI].dwDefaultValue = 0 ;
    pStatic->snapShotTable[dwI].dwFlags = 0 ;
    pStatic->snapShotTable[dwI].dwGIDflags = GIDF_PAGESIZE ;
    dwI++ ;


    pStatic->snapShotTable[dwI].pstrKeyword  = "*CustCursorOriginX" ;
    pStatic->snapShotTable[dwI].dwSrcOffset  = offsetof(DFEATURE_OPTIONS,
                                        atrCustCursorOriginX) ;
    pStatic->snapShotTable[dwI].dwDestOffset = offsetof(PAGESIZEEX,
                                        strCustCursorOriginX) ;
    pStatic->snapShotTable[dwI].dwNbytes = sizeof(INVOCATION) ;
    pStatic->snapShotTable[dwI].dwDefaultValue = 0 ;
    pStatic->snapShotTable[dwI].dwFlags = 0 ;
    pStatic->snapShotTable[dwI].dwGIDflags = GIDF_PAGESIZE ;
    dwI++ ;


    pStatic->snapShotTable[dwI].pstrKeyword  = "*CustCursorOriginY" ;
    pStatic->snapShotTable[dwI].dwSrcOffset  = offsetof(DFEATURE_OPTIONS,
                                        atrCustCursorOriginY) ;
    pStatic->snapShotTable[dwI].dwDestOffset = offsetof(PAGESIZEEX,
                                        strCustCursorOriginY) ;
    pStatic->snapShotTable[dwI].dwNbytes = sizeof(INVOCATION) ;
    pStatic->snapShotTable[dwI].dwDefaultValue = 0 ;
    pStatic->snapShotTable[dwI].dwFlags = 0 ;
    pStatic->snapShotTable[dwI].dwGIDflags = GIDF_PAGESIZE ;
    dwI++ ;


    pStatic->snapShotTable[dwI].pstrKeyword  = "*CustPrintableOriginX" ;
    pStatic->snapShotTable[dwI].dwSrcOffset  = offsetof(DFEATURE_OPTIONS,
                                        atrCustPrintableOriginX) ;
    pStatic->snapShotTable[dwI].dwDestOffset = offsetof(PAGESIZEEX,
                                        strCustPrintableOriginX) ;
    pStatic->snapShotTable[dwI].dwNbytes = sizeof(INVOCATION) ;
    pStatic->snapShotTable[dwI].dwDefaultValue = 0 ;
    pStatic->snapShotTable[dwI].dwFlags = 0 ;
    pStatic->snapShotTable[dwI].dwGIDflags = GIDF_PAGESIZE ;
    dwI++ ;


    pStatic->snapShotTable[dwI].pstrKeyword  = "*CustPrintableOriginY" ;
    pStatic->snapShotTable[dwI].dwSrcOffset  = offsetof(DFEATURE_OPTIONS,
                                        atrCustPrintableOriginY) ;
    pStatic->snapShotTable[dwI].dwDestOffset = offsetof(PAGESIZEEX,
                                        strCustPrintableOriginY) ;
    pStatic->snapShotTable[dwI].dwNbytes = sizeof(INVOCATION) ;
    pStatic->snapShotTable[dwI].dwDefaultValue = 0 ;
    pStatic->snapShotTable[dwI].dwFlags = 0 ;
    pStatic->snapShotTable[dwI].dwGIDflags = GIDF_PAGESIZE ;
    dwI++ ;


    pStatic->snapShotTable[dwI].pstrKeyword  = "*CustPrintableSizeX" ;
    pStatic->snapShotTable[dwI].dwSrcOffset  = offsetof(DFEATURE_OPTIONS,
                                        atrCustPrintableSizeX) ;
    pStatic->snapShotTable[dwI].dwDestOffset = offsetof(PAGESIZEEX,
                                        strCustPrintableSizeX) ;
    pStatic->snapShotTable[dwI].dwNbytes = sizeof(INVOCATION) ;
    pStatic->snapShotTable[dwI].dwDefaultValue = 0 ;
    pStatic->snapShotTable[dwI].dwFlags = 0 ;
    pStatic->snapShotTable[dwI].dwGIDflags = GIDF_PAGESIZE ;
    dwI++ ;


    pStatic->snapShotTable[dwI].pstrKeyword  = "*CustPrintableSizeY" ;
    pStatic->snapShotTable[dwI].dwSrcOffset  = offsetof(DFEATURE_OPTIONS,
                                        atrCustPrintableSizeY) ;
    pStatic->snapShotTable[dwI].dwDestOffset = offsetof(PAGESIZEEX,
                                        strCustPrintableSizeY) ;
    pStatic->snapShotTable[dwI].dwNbytes = sizeof(INVOCATION) ;
    pStatic->snapShotTable[dwI].dwDefaultValue = 0 ;
    pStatic->snapShotTable[dwI].dwFlags = 0 ;
    pStatic->snapShotTable[dwI].dwGIDflags = GIDF_PAGESIZE ;
    dwI++ ;




    //  -----

#if 0
    pStatic->snapShotTable[dwI].dwSrcOffset  = offsetof(DFEATURE_OPTIONS,
                                        atrFeedMargins) ;
    pStatic->snapShotTable[dwI].dwDestOffset = offsetof(INPUTSLOTEX,
                                        sTopMargin) ;
    pStatic->snapShotTable[dwI].dwNbytes = sizeof(DWORD) ;
    pStatic->snapShotTable[dwI].dwDefaultValue = 0 ;
    pStatic->snapShotTable[dwI].dwFlags = 0 ;
    pStatic->snapShotTable[dwI].dwGIDflags = GIDF_INPUTSLOT ;
    dwI++ ;

    pStatic->snapShotTable[dwI].dwSrcOffset  = offsetof(DFEATURE_OPTIONS,
                                        atrFeedMargins) ;
    pStatic->snapShotTable[dwI].dwDestOffset = offsetof(INPUTSLOTEX,
                                        sBottomMargin) ;
    pStatic->snapShotTable[dwI].dwNbytes = sizeof(DWORD) ;
    pStatic->snapShotTable[dwI].dwDefaultValue = 0 ;
    pStatic->snapShotTable[dwI].dwFlags = SSF_SECOND_DWORD ;
    pStatic->snapShotTable[dwI].dwGIDflags = GIDF_INPUTSLOT ;
    dwI++ ;

#endif


    //  end of SSTI_OPTIONEX  section

    pStatic->snapShotTable[dwI].dwNbytes = 0 ;
    dwI++ ;


    //  beginning of SSTI_UPDATE_OPTIONEX  section


    //  end of SSTI_UPDATE_OPTIONEX  section

    pStatic->snapShotTable[dwI].dwNbytes = 0 ;
    dwI++ ;



    //  beginning of SSTI_SPECIAL  section
    //  contains entries requiring special processing.


    pStatic->snapShotTable[dwI].pstrKeyword  = "*dwSSTableCmdIndex - synth" ;
    pStatic->snapShotTable[dwI].dwSrcOffset  = 0 ;
        // not needed.
    pStatic->snapShotTable[dwI].dwDestOffset = 0 ;
        // not needed.
    pStatic->snapShotTable[dwI].dwNbytes = sizeof(DWORD) ;
    pStatic->snapShotTable[dwI].dwDefaultValue = UNUSED_ITEM ;
    pStatic->snapShotTable[dwI].dwFlags = SSF_HEAPOFFSET ;
    pStatic->snapShotTable[dwI].dwGIDflags = 0 ;
    pStatic->dwSSTableCmdIndex = dwI ;
    dwI++ ;

    //  this entry is actually used to guide the copy into the
    //  sequenced command list.

    pStatic->snapShotTable[dwI].pstrKeyword  = "*dwSSCmdSelectIndex - synth" ;
    pStatic->snapShotTable[dwI].dwSrcOffset  = offsetof(DFEATURE_OPTIONS,
                                        atrCommandIndex ) ;
    pStatic->snapShotTable[dwI].dwDestOffset = 0 ;
    pStatic->snapShotTable[dwI].dwNbytes = sizeof(DWORD) ;
    pStatic->snapShotTable[dwI].dwDefaultValue = UNUSED_ITEM ;
    pStatic->snapShotTable[dwI].dwFlags = SSF_HEAPOFFSET ;
    pStatic->snapShotTable[dwI].dwGIDflags = 0 ;
    pStatic->dwSSCmdSelectIndex = dwI ;
    dwI++ ;

#if 0
    don't initialize this field, leave for amanda's personal use.

    //  Extract atrMargins convert to ImageableArea, place in rcImgArea.
    pStatic->snapShotTable[dwI].dwSrcOffset  = offsetof(DFEATURE_OPTIONS,
                                        atrMargins ) ;
    pStatic->snapShotTable[dwI].dwDestOffset = offsetof(PAGESIZE,
                                        rcImgArea ) ;
    pStatic->snapShotTable[dwI].dwNbytes = sizeof(RECT) ;
    pStatic->snapShotTable[dwI].dwDefaultValue = 0 ;
    pStatic->snapShotTable[dwI].dwFlags = 0 ;
    pStatic->snapShotTable[dwI].dwGIDflags = GIDF_PAGESIZE ;
//    pmrbd->dwSSPaperSizeMarginsIndex = dwI ;
    dwI++ ;
#endif



// special check needed: if missing set to same as
//  printable origin.   see  BspecialProcessOption

    pStatic->snapShotTable[dwI].pstrKeyword  = "*CursorOrigin" ;
    pStatic->snapShotTable[dwI].dwSrcOffset  = offsetof(DFEATURE_OPTIONS,
                                        atrCursorOrigin) ;
    pStatic->snapShotTable[dwI].dwDestOffset = offsetof(PAGESIZEEX,
                                        ptPrinterCursorOrig) ;
    pStatic->snapShotTable[dwI].dwNbytes = sizeof(POINT) ;
    pStatic->snapShotTable[dwI].dwDefaultValue = 0 ;
    pStatic->snapShotTable[dwI].dwFlags = SSF_RETURN_UNINITIALIZED ;
    pStatic->snapShotTable[dwI].dwGIDflags = GIDF_PAGESIZE ;
    pStatic->dwSSPaperSizeCursorOriginIndex = dwI ;
    dwI++ ;


    //  constraints info is not copied into the snapshot.

    pStatic->snapShotTable[dwI].pstrKeyword  = "*Constraints" ;
    pStatic->snapShotTable[dwI].dwSrcOffset  = offsetof(DFEATURE_OPTIONS,
                                        atrConstraints) ;
    pStatic->snapShotTable[dwI].dwDestOffset = 0 ;
    pStatic->snapShotTable[dwI].dwNbytes = sizeof(DWORD) ;
    pStatic->snapShotTable[dwI].dwDefaultValue = END_OF_LIST ;
    pStatic->snapShotTable[dwI].dwFlags = 0 ;
    pStatic->snapShotTable[dwI].dwGIDflags = 0 ;
    pStatic->dwSSConstraintsIndex = dwI ;
    dwI++ ;


    pStatic->snapShotTable[dwI].pstrKeyword  = "*InvalidCombination" ;
    pStatic->snapShotTable[dwI].dwSrcOffset  = offsetof(DFEATURE_OPTIONS,
                                        atrInvalidCombos) ;
    pStatic->snapShotTable[dwI].dwDestOffset = 0 ;
    pStatic->snapShotTable[dwI].dwNbytes = sizeof(DWORD) ;
    pStatic->snapShotTable[dwI].dwDefaultValue = END_OF_LIST ;
    pStatic->snapShotTable[dwI].dwFlags = 0 ;
    pStatic->snapShotTable[dwI].dwGIDflags = 0 ;
    pStatic->dwSSInvalidCombosIndex = dwI ;
    dwI++ ;

#ifdef  GMACROS

    pStatic->snapShotTable[dwI].pstrKeyword  = "*DependentSettings" ;
    pStatic->snapShotTable[dwI].dwSrcOffset  = offsetof(DFEATURE_OPTIONS,
                                        atrDependentSettings) ;
    pStatic->snapShotTable[dwI].dwDestOffset = 0 ;
    pStatic->snapShotTable[dwI].dwNbytes = sizeof(DWORD) ;
    pStatic->snapShotTable[dwI].dwDefaultValue = END_OF_LIST ;
    pStatic->snapShotTable[dwI].dwFlags = 0 ;
    pStatic->snapShotTable[dwI].dwGIDflags = 0 ;
    pStatic->dwSSDepSettingsIndex = dwI ;
    dwI++ ;

    pStatic->snapShotTable[dwI].pstrKeyword  = "*UIChangeTriggersMacro" ;
    pStatic->snapShotTable[dwI].dwSrcOffset  = offsetof(DFEATURE_OPTIONS,
                                        atrUIChangeTriggersMacro) ;
    pStatic->snapShotTable[dwI].dwDestOffset = 0 ;
    pStatic->snapShotTable[dwI].dwNbytes = sizeof(DWORD) ;
    pStatic->snapShotTable[dwI].dwDefaultValue = END_OF_LIST ;
    pStatic->snapShotTable[dwI].dwFlags = 0 ;
    pStatic->snapShotTable[dwI].dwGIDflags =  0 ;
    pStatic->dwSSUIChangeTriggersMacroIndex = dwI ;
    dwI++ ;

#endif


    //  end of SSTI_SPECIAL  section

    pStatic->snapShotTable[dwI].dwNbytes = 0 ;
    dwI++ ;


    return(dwI) ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\parsers\gpd\snapshot.c ===
//   Copyright (c) 1996-1999  Microsoft Corporation
/*  snapshot.c - functions to produce a snapshot from
the multivalued GPD binary data.

History of Changes
 10/28/98 --hsingh--
         Added functions BgetLocFeaIndex() and BgetLocFeaOptIndex()
         to support special processing for Feauture Locale if present
         in the gpd.
         Bug Report 231798
*/




#include    "gpdparse.h"


#ifndef  PARSERDLL



// ----  functions defined in snapshot.c ---- //

PINFOHEADER   PINFOHDRcreateSnapshot(
PBYTE   pubnRaw,  //  raw binary data.    PSTATIC.   BETA2
POPTSELECT   poptsel   // assume fully initialized
) ;

BOOL  BinitOptionFields(
PBYTE   pubDestOption,  // ptr to some type of option structure.
PBYTE   pubDestOptionEx,  // option extra structure if any.
PBYTE   pubnRaw,  //  raw binary data.
DWORD   dwFea,
DWORD   dwOpt,
POPTSELECT   poptsel ,  // assume fully initialized
PINFOHEADER  pInfoHdr,   // used to access global structure.
BOOL    bUpdate  //  if true only update selected fields.
) ;

BOOL    BinitUIinfo(
PUIINFO     pUIinfo ,
PBYTE   pubnRaw,  //  PSTATIC.   BETA2
POPTSELECT   poptsel,   // assume fully initialized
BOOL    bUpdate  //  if true only update selected fields.
) ;

BOOL    BinitFeatures(
PFEATURE    pFeaturesDest,
PDFEATURE_OPTIONS  pfoSrc,
PBYTE   pubnRaw,  //  raw binary data.
POPTSELECT   poptsel,   // assume fully initialized
BOOL    bUpdate  //  if true only update selected fields.
) ;

BOOL    BinitGlobals(
PGLOBALS pGlobals,
PBYTE   pubnRaw,  //  raw binary data.
POPTSELECT   poptsel,   // assume fully initialized
BOOL    bUpdate  //  if true only update selected fields.
) ;

BOOL    BinitCommandTable(
PDWORD  pdwCmdTable,  //  dest array
PBYTE   pubnRaw,  //  raw binary data.
POPTSELECT   poptsel   // assume fully initialized
) ;

BOOL    BinitRawData(
PRAWBINARYDATA   pRawData, // contained in INFOHEADER.
PBYTE   pubnRaw  //  Parser's raw binary data.
) ;

BOOL    BinitGPDdriverInfo(
PGPDDRIVERINFO  pGPDdriverInfo,
PBYTE   pubnRaw,  //  raw binary data.
POPTSELECT   poptsel   // assume fully initialized
) ;

BOOL    BinitSequencedCmds(
PGPDDRIVERINFO  pGPDdriverInfo,
PBYTE   pubnRaw,  //  raw binary data.
POPTSELECT   poptsel   // assume fully initialized
) ;

BOOL    BaddSequencedCmdToList(
DWORD   dwCmdIn,  // index of a command in CommandArray
PGPDDRIVERINFO  pGPDdriverInfo,
DWORD   dwNewListNode,  //  an unused listnode to add to the list.
PBYTE   pubnRaw  //  raw binary data.
) ;

BinitDefaultOptionArray(
POPTSELECT   poptsel,   // assume is large enough
PBYTE   pubnRaw) ;

TRISTATUS     EdetermineDefaultOption(
PBYTE   pubnRaw,  // start of Rawbinary data
DWORD   dwFeature,   // determine the default for this feature
PDFEATURE_OPTIONS  pfo,
POPTSELECT   poptsel,   // assume is large enough
PDWORD      pdwPriority) ;

VOID    VtileDefault(
PBYTE   pubDest,
DWORD   dwDefault,
DWORD   dwBytes) ;

VOID    VtransferValue(
OUT PBYTE   pubDest,
IN  PBYTE   pubSrc ,
IN  DWORD   dwBytes,
IN  DWORD   dwFlags,
IN  DWORD   dwDefaultValue,  // holds bit flag value.
IN  PBYTE   pubHeap ) ;  //  used to form ptr if SSF_MAKE_STRINGPTR

BOOL    BspecialProcessOption(
PBYTE   pubnRaw,  // start of Rawbinary data
PBYTE   pubDestOption,  // ptr to some type of option structure.
PBYTE   pubDestOptionEx,
PDFEATURE_OPTIONS  pfo ,  // source data
IN  POPTSELECT       poptsel,     // option array which determines path
                //  through atr.
PINFOHEADER  pInfoHdr,   // used to access global structure.
DWORD   dwFea,   //  feature index
DWORD   dwOpt,
BOOL   bDefaultOpt
) ;

TRISTATUS     EextractValueFromTree(
PBYTE   pubnRaw,  // start of Rawbinary data
DWORD   dwSSTableIndex,  // some info about this value.
OUT PBYTE    pubDest,  // write value or link here
OUT PDWORD  pdwUnresolvedFeature,  // if the attribute tree has
            //  a dependency on this feature and the current option
            //  for that feature is not defined  in poptsel, this
            //  function will write the index of the required
            //  feature in pdwUnresolvedFeature.
IN  ATREEREF    atrRoot,    //  root of attribute tree to navigate.
IN  POPTSELECT       poptsel,     // option array which determines path
                //  through atr.  may be filled with OPTION_INDEX_ANY
                //  if we are jumpstarting
IN  DWORD   dwFeature,
IN OUT  PDWORD   pdwNextOpt  //  if multiple options are selected
    //  for dwFeature, pdwNextOpt points to the Nth option to consider
    //  in the  poptsel list,  at return time, this value
    //  is incremented if there are remaining options selected,
    //  else is reset to zero.
    //  For the first call, or PICKONE features,
    //  this value must be set to zero.
) ;

BOOL   RaisePriority(
DWORD   dwFeature1,
DWORD   dwFeature2,
PBYTE   pubnRaw,
PDWORD  pdwPriority) ;

DWORD  dwNumOptionSelected(
IN  DWORD  dwNumFeatures,
IN  POPTSELECT       poptsel
) ;

BOOL  BinitSnapShotIndexTable(PBYTE  pubnRaw) ;

BOOL    BinitSizeOptionTables(PBYTE  pubnRaw) ;

PRAWBINARYDATA
LoadRawBinaryData (
    IN PTSTR    ptstrDataFilename
    ) ;

PRAWBINARYDATA
GpdLoadCachedBinaryData(
    PTSTR   ptstrGpdFilename
    ) ;

VOID
UnloadRawBinaryData (
    IN PRAWBINARYDATA   pnRawData
) ;

PINFOHEADER
InitBinaryData(
    IN PRAWBINARYDATA   pnRawData,        // actually pStatic
    IN PINFOHEADER      pInfoHdr,
    IN POPTSELECT       pOptions
    ) ;

VOID
FreeBinaryData(
    IN PINFOHEADER pInfoHdr
    ) ;

BOOL    BIsRawBinaryDataInDate(
IN  PBYTE   pubRaw) ;  // this is pointer to memory mapped file! BETA2

BOOL BgetLocFeaIndex(
  IN  PRAWBINARYDATA pnRawData,     // raw binary data.
  OUT PDWORD         pdwFea     // Index of the Locale Feature (if present)
  ) ;

BOOL BgetLocFeaOptIndex(
    IN     PRAWBINARYDATA   pnRawData,
       OUT PDWORD           pdwFea,
       OUT PDWORD           pdwOptIndex
    );


#endif  PARSERDLL



BOOL   BfindMatchingOrDefaultNode(
IN  PATTRIB_TREE    patt ,  // start of ATTRIBUTE tree array.
IN  OUT  PDWORD  pdwNodeIndex,  // Points to first node in chain
IN  DWORD   dwOptionID     //  may even take on the value DEFAULT_INIT
) ;


// ------- end function declarations ------- //


#ifndef  PARSERDLL


/*  ---- Memory Map ---- /*


INFOHEADER {RAWBINARYDATA}  <= reference pt for local offsets.
UIINFO
GPDDRIVERINFO  (aka DRIVERINFO)
CMD_TABLE    of DWORDS
LOCALLIST (to support sequenced commands)
FEATURES
OPTIONS and OPTIONEXTRAS


/*  ---- end Memory Map ---- */



PINFOHEADER   PINFOHDRcreateSnapshot(
PBYTE   pubnRaw,  //  raw binary data.    PSTATIC.   BETA2
POPTSELECT   poptsel   // assume fully initialized
)
/*  this function allocates the single memoryblock
that contains the entire snapshot.  */
{
    DWORD   dwCurOffset = 0, loGPDdriverInfo, loInfoHeader,
        loUIinfo, loCmdTable, loListArray, loFeatures, dwSize,
        dwNumFeatures, dwNumListNodes, dwTotSize, loOptions,
        dwSizeOption, dwSizeOptionEx, dwFea, dwGID , dwNumOptions,
        dwI , dwCmd;
    PDWORD   pdwSymbolRoots  ;
    PENHARRAYREF   pearTableContents ;
    PDFEATURE_OPTIONS  pfo ;
    PINFOHEADER  pInfoHdr ;
    PUIINFO     pUIinfo ;
    PSTATICFIELDS   pStatic ;
    //  PMINIRAWBINARYDATA pmrbd  = NULL ;
    PGPDDRIVERINFO  pGPDdriverInfo ;
    PBYTE   pubRaw,  //  ptr to BUD data.
            pubOptionsDest ,  // ptr to any of the several varieties
           pubDestOptionEx ;  // of option structures.
    BOOL    bStatus ;
    PFEATURE    pFeaturesDest ;

    pStatic = (PSTATICFIELDS)pubnRaw ;    // transform pubRaw from PSTATIC
    pubRaw  = pStatic->pubBUDData ;         //  to PMINIRAWBINARYDATA


    loInfoHeader = dwCurOffset ;
    dwCurOffset += sizeof(INFOHEADER) ;
    loUIinfo = dwCurOffset ;
    dwCurOffset += sizeof(UIINFO) ;
    loGPDdriverInfo = dwCurOffset ;
    dwCurOffset += sizeof(GPDDRIVERINFO) ;
    loCmdTable = dwCurOffset ;
    dwCurOffset += sizeof(DWORD) * CMD_MAX ;

    pearTableContents = (PENHARRAYREF)(pubRaw + sizeof(MINIRAWBINARYDATA)) ;

    dwNumFeatures = pearTableContents[MTI_DFEATURE_OPTIONS].dwCount  ;
    dwNumFeatures += pearTableContents[MTI_SYNTHESIZED_FEATURES].dwCount  ;

    dwNumListNodes = dwNumOptionSelected(dwNumFeatures, poptsel) ;
    // if there are pickmany, we could have more than dwNumFeatures.

    dwNumListNodes += NUM_CONFIGURATION_CMDS ;

    loListArray = dwCurOffset ;
    dwCurOffset += dwNumListNodes * sizeof(LISTNODE) ;

    loFeatures = dwCurOffset ;
    dwCurOffset += dwNumFeatures * sizeof(FEATURE) ;

    loOptions =  dwCurOffset ;
    //  There are too many options and optionextra structures
    //  for me to track all the offsets, so just track the
    //  amount of memory consumed.

    pfo = (PDFEATURE_OPTIONS)(pubRaw + pearTableContents[MTI_DFEATURE_OPTIONS].
                                loOffset) ;

//    pmrbd = (PMINIRAWBINARYDATA)pubRaw ;

    for(dwTotSize = dwFea = 0 ; dwFea < dwNumFeatures ; dwFea++)
    {
        dwGID = pfo[dwFea].dwGID ;
        dwNumOptions = pfo[dwFea].dwNumOptions ;

        if(dwGID != GID_UNKNOWN)
        {
            dwSize = pStatic->pdwSizeOption[dwGID] +
                    pStatic->pdwSizeOptionEx[dwGID] ;
        }
        else
        {
            dwSize = sizeof(OPTION);
        }

        dwTotSize += dwSize * dwNumOptions ;  // of all options
    }
    dwCurOffset += dwTotSize ;  // total size of local snapshot.

    //  now allocate memory and partition this block into structures.

    if(!(pInfoHdr = (PINFOHEADER)MemAllocZ(dwCurOffset) ))
    {
        ERR(("Fatal: PINFOHDRcreateSnapshot - unable to alloc %d bytes.\n",
            dwCurOffset));
        //  cannot use globals outside of parser.
        //  use error num to relay failure.
        return(NULL) ;   // This is unrecoverable
    }
    pUIinfo = (PUIINFO)((PBYTE)(pInfoHdr) + loUIinfo) ;
    pGPDdriverInfo = (PGPDDRIVERINFO)((PBYTE)(pInfoHdr) + loGPDdriverInfo) ;


    if(!BinitCommandTable((PDWORD)((PBYTE)(pInfoHdr) + loCmdTable),
        pubnRaw, poptsel) )
    {
        MemFree(pInfoHdr) ;
        return(NULL) ;
    }

    // init GPDDRIVERINFO
    // note all offsets in DataTable are relative to pubResourceData
    //  the StringHeap.  Except these :

    pGPDdriverInfo->pInfoHeader =  pInfoHdr ;
    pGPDdriverInfo->DataType[DT_COMMANDTABLE].loOffset = loCmdTable ;
    pGPDdriverInfo->DataType[DT_COMMANDTABLE].dwCount =  CMD_MAX ;
    pGPDdriverInfo->DataType[DT_LOCALLISTNODE].loOffset =  loListArray ;
    pGPDdriverInfo->DataType[DT_LOCALLISTNODE].dwCount =  dwNumListNodes ;


    if(!BinitGPDdriverInfo(pGPDdriverInfo, pubnRaw, poptsel) )
    {
        MemFree(pInfoHdr) ;
        return(NULL) ;
    }

    //  init  InfoHeader

    pInfoHdr->loUIInfoOffset = loUIinfo ;
    pInfoHdr->loDriverOffset = loGPDdriverInfo ;

    if(!BinitRawData(&pInfoHdr->RawData, pubnRaw) )
    {
        MemFree(pInfoHdr) ;
        return(NULL) ;
    }

    //  init  UIInfo

    pUIinfo->pInfoHeader = pInfoHdr ;
    pUIinfo->loFeatureList = loFeatures ;  // from  pInfoHdr
    pUIinfo->loFontSubstTable =
        pGPDdriverInfo->DataType[DT_FONTSUBST].loOffset ;  // in pubRaw
    pUIinfo->dwFontSubCount =
        pGPDdriverInfo->DataType[DT_FONTSUBST].dwCount ;
    pUIinfo->UIGroups.dwCount = 0 ;  // in pubRaw
    pUIinfo->CartridgeSlot.loOffset =  // in pubRaw
        pGPDdriverInfo->DataType[DT_FONTSCART].loOffset ;
    pUIinfo->CartridgeSlot.dwCount =
        pGPDdriverInfo->DataType[DT_FONTSCART].dwCount ;
//    pUIinfo->dwFlags =  FLAG_RULESABLE ;
        // start with just this
        // and turn on/off more flags as needed.  ROTATE_90
        // and  ORIENT_SUPPORT are never  set.  This is now obsolete.
    if(pGPDdriverInfo->Globals.fontformat != UNUSED_ITEM)
        pUIinfo->dwFlags |= FLAG_FONT_DOWNLOADABLE ;
    if(pGPDdriverInfo->Globals.liDeviceFontList != END_OF_LIST)
        pUIinfo->dwFlags |= FLAG_FONT_DEVICE ;

#if 0
    Alvins code never looks at this flag anyway.
    for(dwCmd = CMD_FIRST_RULES ; dwCmd < CMD_LAST_RULES + 1 ; dwCmd++ )
    {
        if( ((PDWORD)((PBYTE)(pInfoHdr) + loCmdTable))[dwCmd] ==
                UNUSED_ITEM)
            pUIinfo->dwFlags &= ~FLAG_RULESABLE ; // clear flag
    }                       //  if requisite command is missing.
#endif


    if(!BinitUIinfo(pUIinfo, pubnRaw, poptsel, FALSE) )
    {
        MemFree(pInfoHdr) ;
        return(NULL) ;
    }

    //  init  features and options

    pFeaturesDest =  (PFEATURE)((PBYTE)(pInfoHdr) + loFeatures) ;

    for( dwFea = 0 ; dwFea < dwNumFeatures ; dwFea++)
    {
        dwGID = pfo[dwFea].dwGID ;
        dwNumOptions = pfo[dwFea].dwNumOptions ;


        pFeaturesDest[dwFea].Options.loOffset = loOptions ;
        pFeaturesDest[dwFea].Options.dwCount = dwNumOptions ;

        if(!BinitFeatures(pFeaturesDest + dwFea, pfo + dwFea,
                            pubnRaw, poptsel, FALSE))
        {
            MemFree(pInfoHdr) ;
            return(NULL) ;
        }

        if(dwGID != GID_UNKNOWN)
        {
            dwSizeOption = pStatic->pdwSizeOption[dwGID] ;
            dwSizeOptionEx = pStatic->pdwSizeOptionEx[dwGID] ;

            pUIinfo->aloPredefinedFeatures[dwGID] =
                loFeatures + dwFea * sizeof(FEATURE) ;
                // all fields initially set to zeros.
        }
        else
        {
            dwSizeOption = sizeof(OPTION);
            dwSizeOptionEx = 0 ;
        }

        //  special non-atreeref fields
        (pFeaturesDest + dwFea)->dwFeatureID = dwGID ;
        (pFeaturesDest + dwFea)->dwOptionSize = dwSizeOption ;

        loOptions += dwSizeOption * dwNumOptions ;
        pubOptionsDest =  (PBYTE)(pInfoHdr) + pFeaturesDest[dwFea].Options.loOffset ;
        for(dwI = 0 ; dwI < dwNumOptions ; dwI++)
        {
            if(dwSizeOptionEx)
            {
                ((POPTION)pubOptionsDest)->loRenderOffset = loOptions ;
                pubDestOptionEx =  (PBYTE)(pInfoHdr) + loOptions ;
                loOptions += dwSizeOptionEx ;
            }
            else
            {
                ((POPTION)pubOptionsDest)->loRenderOffset = 0 ;
                pubDestOptionEx = NULL ;
            }

            if(!BinitOptionFields(pubOptionsDest, pubDestOptionEx,
                        pubnRaw, dwFea, dwI, poptsel, pInfoHdr, FALSE) )
            {
                MemFree(pInfoHdr) ;
                return(NULL) ;
            }
            pubOptionsDest += dwSizeOption ;
        }
    }

#ifndef KERNEL_MODE
    if(!BCheckGPDSemantics(pInfoHdr, poptsel) )
    {
        MemFree(pInfoHdr) ;
        pInfoHdr = NULL ;
    }
#endif

    return(pInfoHdr) ;
}

BOOL  BinitOptionFields(
PBYTE   pubDestOption,  // ptr to some type of option structure.
PBYTE   pubDestOptionEx,  // option extra structure if any.
PBYTE   pubnRaw,  //  raw binary data.
DWORD   dwFea,
DWORD   dwOpt,
POPTSELECT   poptsel ,  // assume fully initialized
PINFOHEADER  pInfoHdr,   // used to access global structure.
BOOL    bUpdate  //  if true only update selected fields.
)
{
    PENHARRAYREF   pearTableContents ;
    PDFEATURE_OPTIONS  pfo ;
    //  PMINIRAWBINARYDATA pmrbd  ;
    PATREEREF    patrRoot ;    //  root of attribute tree to navigate.
    DWORD  dwUnresolvedFeature,     // dummy storage
                dwI, dwStart , dwEnd, dwNextOpt, dwGID   ;
    OPTSELECT  optsPrevs ;
    PBYTE   pubDest ;
    BOOL    bStatus = TRUE ;
    PBYTE   pubRaw ;
    PSTATICFIELDS   pStatic ;

    pStatic = (PSTATICFIELDS)pubnRaw ;    // transform pubRaw from PSTATIC
    pubRaw  = pStatic->pubBUDData ;         //  to PMINIRAWBINARYDATA

    //  pmrbd = (PMINIRAWBINARYDATA)pubRaw ;
    pearTableContents = (PENHARRAYREF)(pubRaw + sizeof(MINIRAWBINARYDATA)) ;
    pfo = (PDFEATURE_OPTIONS)(pubRaw + pearTableContents[MTI_DFEATURE_OPTIONS].
                                loOffset) ;

    pfo += dwFea  ;  //  index pfo to the proper feature.
    dwGID = pfo->dwGID ;

    //  save previous option selection for this feature.

    optsPrevs = poptsel[dwFea] ;  // save setting since we will sweep it.

    poptsel[dwFea].ubNext = NULL_OPTSELECT ;
    poptsel[dwFea].ubCurOptIndex = (BYTE)dwOpt ;

    if(bUpdate)  //  assume update comes after main group.
        dwStart = pStatic->ssTableIndex[SSTI_UPDATE_OPTIONS].dwStart ;  // starting Index
    else
        dwStart = pStatic->ssTableIndex[SSTI_OPTIONS].dwStart ;  // starting Index

    dwEnd = pStatic->ssTableIndex[SSTI_UPDATE_OPTIONS].dwEnd ;  // Ending Index

    for(dwI = dwStart ; bStatus  &&  (dwI < dwEnd) ; dwI++)
    {
        if(!(pStatic->snapShotTable[dwI].dwNbytes))
            continue ;  // skip over section delimiter.
        if(dwGID >= MAX_GID)
        {
            if(pStatic->snapShotTable[dwI].dwGIDflags != 0xffffffff)
                continue ;  // this field not used for generic GID.
        }
        else if(!(pStatic->snapShotTable[dwI].dwGIDflags & ( 1 << dwGID)))
            continue ;  // this field not used for this GID.


        patrRoot = (PATREEREF)((PBYTE)pfo +
                    pStatic->snapShotTable[dwI].dwSrcOffset) ;
        pubDest = pubDestOption + pStatic->snapShotTable[dwI].dwDestOffset ;

        dwNextOpt = 0 ;  // extract info for first option selected for
                            //  this feature.

        if(EextractValueFromTree(pubnRaw, dwI, pubDest,
            &dwUnresolvedFeature,  *patrRoot, poptsel, 0, // set to
            // any value.  Doesn't matter.
            &dwNextOpt) != TRI_SUCCESS)
        {
            ERR(("BinitOptionFields: Failed to extract value for attribute in Fea: %d, Opt: %d\n", dwFea, dwOpt));
            bStatus = FALSE ;
        }
    }

    if(bUpdate)  //  assume update comes after main group.
        dwStart = pStatic->ssTableIndex[SSTI_UPDATE_OPTIONEX].dwStart ;  // starting Index
    else
        dwStart = pStatic->ssTableIndex[SSTI_OPTIONEX].dwStart ;  // starting Index

    dwEnd = pStatic->ssTableIndex[SSTI_UPDATE_OPTIONEX].dwEnd ;  // Ending Index


    for(dwI = dwStart ; bStatus  &&  pubDestOptionEx  &&  (dwI < dwEnd)
            ; dwI++)
    {
        if(!(pStatic->snapShotTable[dwI].dwNbytes))
            continue ;  // skip over section delimiter.
        if(!(pStatic->snapShotTable[dwI].dwGIDflags & ( 1 << dwGID)))
            continue ;  // this field not used for this GID.


        patrRoot = (PATREEREF)((PBYTE)pfo +
                    pStatic->snapShotTable[dwI].dwSrcOffset) ;
        pubDest = pubDestOptionEx + pStatic->snapShotTable[dwI].dwDestOffset ;

        dwNextOpt = 0 ;  // extract info for first option selected for
                            //  this feature.

        if(EextractValueFromTree(pubnRaw, dwI, pubDest,
            &dwUnresolvedFeature,  *patrRoot, poptsel, 0,
            &dwNextOpt) != TRI_SUCCESS)
        {
            ERR(("BinitOptionFields: Failed to extract value for attribute in Fea: %d, Opt: %d\n", dwFea, dwOpt));
            bStatus = FALSE ;
        }
    }

    if(!bUpdate  &&  !BspecialProcessOption(pubnRaw, pubDestOption,
        pubDestOptionEx,
        pfo , poptsel, pInfoHdr, dwFea, dwOpt,
        optsPrevs.ubCurOptIndex == dwOpt) )
            //  dwOpt is the default option for dwFea!
    {
        bStatus = FALSE ;
    }

    poptsel[dwFea] = optsPrevs ;  // restore previous setting.
    return(bStatus) ;
}

BOOL    BinitUIinfo(
PUIINFO     pUIinfo ,
PBYTE   pubnRaw,  //  PSTATIC.   BETA2
POPTSELECT   poptsel,   // assume fully initialized
BOOL    bUpdate  //  if true only update selected fields.
)
{
    PENHARRAYREF   pearTableContents ;
    PMINIRAWBINARYDATA pmrbd  ;
    PATREEREF    patrRoot ;    //  root of attribute tree to navigate.
    DWORD  dwUnresolvedFeature,     // dummy storage
                dwI, dwStart , dwEnd, dwNextOpt ;
    BOOL    bStatus = TRUE ;
    PGLOBALATTRIB  pga ;
    PBYTE   pubDest, pubRaw ;
    PSTATICFIELDS   pStatic ;

    pStatic = (PSTATICFIELDS)pubnRaw ;    // transform pubRaw from PSTATIC
    pubRaw  = pStatic->pubBUDData ;         //  to PMINIRAWBINARYDATA

    pmrbd = (PMINIRAWBINARYDATA)pubRaw ;
    pearTableContents = (PENHARRAYREF)(pubRaw + sizeof(MINIRAWBINARYDATA)) ;
    pga = (PGLOBALATTRIB)(pubRaw + pearTableContents[MTI_GLOBALATTRIB].
                            loOffset) ;

    if(bUpdate)  //  assume update comes after main group.
        dwStart = pStatic->ssTableIndex[SSTI_UPDATE_UIINFO].dwStart ;  // starting Index
    else
        dwStart = pStatic->ssTableIndex[SSTI_UIINFO].dwStart ;  // starting Index
    dwEnd = pStatic->ssTableIndex[SSTI_UPDATE_UIINFO].dwEnd ;  // Ending Index

    for(dwI = dwStart ; bStatus  &&  (dwI < dwEnd) ; dwI++)
    {
        if(!(pStatic->snapShotTable[dwI].dwNbytes))
            continue ;  // skip over section delimiter.

        patrRoot = (PATREEREF)((PBYTE)pga +
                    pStatic->snapShotTable[dwI].dwSrcOffset) ;
        pubDest = (PBYTE)pUIinfo + pStatic->snapShotTable[dwI].dwDestOffset ;

        dwNextOpt = 0 ;  // extract info for first option selected for
                            //  this feature.
        if(EextractValueFromTree(pubnRaw, dwI, pubDest,
            &dwUnresolvedFeature,  *patrRoot, poptsel, 0,
                &dwNextOpt) != TRI_SUCCESS)
        {
            bStatus = FALSE ;
        }
    }

    pUIinfo->pubResourceData =
        pubRaw + pearTableContents[MTI_STRINGHEAP].loOffset  ;
    pUIinfo->dwSpecVersion = pmrbd->dwSpecVersion ;    //  don't change!
    pUIinfo->dwSize = sizeof(UIINFO);
    pUIinfo->dwTechnology = DT_RASPRINTER ;
    pUIinfo->dwDocumentFeatures = pmrbd->rbd.dwDocumentFeatures;
    pUIinfo->dwPrinterFeatures = pmrbd->rbd.dwPrinterFeatures;
    pUIinfo->dwCustomSizeOptIndex = UNUSED_ITEM;  // until found later
    pUIinfo->dwFreeMem = 400000 ;  //  default just in case
                    //  there are no GID_MEMOPTION features.
     pUIinfo->dwMaxDocKeywordSize = pmrbd->dwMaxDocKeywordSize + KEYWORD_SIZE_EXTRA;
     pUIinfo->dwMaxPrnKeywordSize = pmrbd->dwMaxPrnKeywordSize + KEYWORD_SIZE_EXTRA;

    //  dead:  replace with macros

//    pUIinfo->dwWhichBasePtr[UIDT_FEATURE] = 0 ;
//    pUIinfo->dwWhichBasePtr[UIDT_OPTION] = 0 ;
//    pUIinfo->dwWhichBasePtr[UIDT_OPTIONEX] = 0 ;
//    pUIinfo->dwWhichBasePtr[UIDT_CONSTRAINT] = BASE_USE_RESOURCE_DATA ;
//    pUIinfo->dwWhichBasePtr[UIDT_GROUPS] = BASE_USE_RESOURCE_DATA ;
//    pUIinfo->dwWhichBasePtr[UIDT_LISTNODE] = BASE_USE_RESOURCE_DATA ;
//    pUIinfo->dwWhichBasePtr[UIDT_FONTSCART] = BASE_USE_RESOURCE_DATA ;
//    pUIinfo->dwWhichBasePtr[UIDT_FONTSUBST] = BASE_USE_RESOURCE_DATA ;


    return(bStatus) ;
}



BOOL    BinitFeatures(
PFEATURE    pFeaturesDest,
PDFEATURE_OPTIONS  pfoSrc,
PBYTE   pubnRaw,  //  raw binary data.
POPTSELECT   poptsel,   // assume fully initialized
BOOL    bUpdate  //  if true only update selected fields.
)
{
    PENHARRAYREF   pearTableContents ;
    //  PMINIRAWBINARYDATA pmrbd  ;
    PATREEREF    patrRoot ;    //  root of attribute tree to navigate.
    DWORD  dwUnresolvedFeature,     // dummy storage
                dwI, dwStart , dwEnd , dwNextOpt ;
    BOOL    bStatus = TRUE ;
    PBYTE   pubDest ;
    PBYTE   pubRaw ;
    PSTATICFIELDS   pStatic ;

    pStatic = (PSTATICFIELDS)pubnRaw ;    // transform pubRaw from PSTATIC
    pubRaw  = pStatic->pubBUDData ;         //  to PMINIRAWBINARYDATA


    //  pmrbd = (PMINIRAWBINARYDATA)pubRaw ;
    pearTableContents = (PENHARRAYREF)(pubRaw + sizeof(MINIRAWBINARYDATA)) ;


    if(bUpdate)  //  assume update comes after main group.
        dwStart = pStatic->ssTableIndex[SSTI_UPDATE_FEATURES].dwStart ;  // starting Index
    else
        dwStart = pStatic->ssTableIndex[SSTI_FEATURES].dwStart ;  // starting Index


    dwEnd = pStatic->ssTableIndex[SSTI_UPDATE_FEATURES].dwEnd ;  // Ending Index

    for(dwI = dwStart ; bStatus  &&  (dwI < dwEnd) ; dwI++)
    {
        if(!pStatic->snapShotTable[dwI].dwNbytes)
            continue ;  // ignore section delimiter.

        patrRoot = (PATREEREF)((PBYTE)pfoSrc +
                    pStatic->snapShotTable[dwI].dwSrcOffset) ;
        pubDest = (PBYTE)pFeaturesDest + pStatic->snapShotTable[dwI].dwDestOffset ;

        dwNextOpt = 0 ;  // extract info for first option selected for
                            //  this feature.

        if(EextractValueFromTree(pubnRaw, dwI, pubDest,
            &dwUnresolvedFeature,  *patrRoot, poptsel, 0,
                &dwNextOpt) != TRI_SUCCESS)
        {
            bStatus = FALSE ;
        }
    }

    return(bStatus) ;
}


BOOL    BinitGlobals(
PGLOBALS pGlobals,
PBYTE   pubnRaw,  //  raw binary data.
POPTSELECT   poptsel,   // assume fully initialized
BOOL    bUpdate  //  if true only update selected fields.
)
{
    PENHARRAYREF   pearTableContents ;
    //  PMINIRAWBINARYDATA pmrbd  ;
    PATREEREF    patrRoot ;    //  root of attribute tree to navigate.
    DWORD  dwUnresolvedFeature,     // dummy storage
                dwI, dwStart , dwEnd, dwNextOpt  ;
    BOOL    bStatus = TRUE ;
    PGLOBALATTRIB  pga ;
    PBYTE   pubDest ;
    PBYTE   pubRaw ;
    PSTATICFIELDS   pStatic ;

    pStatic = (PSTATICFIELDS)pubnRaw ;    // transform pubRaw from PSTATIC
    pubRaw  = pStatic->pubBUDData ;         //  to PMINIRAWBINARYDATA


    //  pmrbd = (PMINIRAWBINARYDATA)pubRaw ;
    pearTableContents = (PENHARRAYREF)(pubRaw + sizeof(MINIRAWBINARYDATA)) ;
    pga = (PGLOBALATTRIB)(pubRaw + pearTableContents[MTI_GLOBALATTRIB].
                            loOffset) ;

    if (bUpdate)
        dwStart = pStatic->ssTableIndex[SSTI_UPDATE_GLOBALS].dwStart ;
    else
        dwStart = pStatic->ssTableIndex[SSTI_GLOBALS].dwStart ;  // starting Index

    dwEnd = pStatic->ssTableIndex[SSTI_UPDATE_GLOBALS].dwEnd ;  // Ending Index

    for(dwI = dwStart ; bStatus  &&  (dwI < dwEnd) ; dwI++)
    {
        if(!(pStatic->snapShotTable[dwI].dwNbytes))
            continue ;  // skip over section delimiter.

        patrRoot = (PATREEREF)((PBYTE)pga +
                    pStatic->snapShotTable[dwI].dwSrcOffset) ;
        pubDest = (PBYTE)pGlobals + pStatic->snapShotTable[dwI].dwDestOffset ;

        dwNextOpt = 0 ;  // extract info for first option selected for
                            //  this feature.

        if(EextractValueFromTree(pubnRaw, dwI, pubDest,
            &dwUnresolvedFeature,  *patrRoot, poptsel, 0,
                &dwNextOpt) != TRI_SUCCESS)
        {
            bStatus = FALSE ;
        }
    }

    return(bStatus) ;
}


BOOL    BinitCommandTable(
PDWORD  pdwCmdTable,  //  dest array
PBYTE   pubnRaw,  //  raw binary data.
POPTSELECT   poptsel   // assume fully initialized
)
{
    PENHARRAYREF   pearTableContents ;
    //  PMINIRAWBINARYDATA pmrbd  ;
    PATREEREF    patrRoot ;    //  root of attribute tree to navigate.
    DWORD  dwUnresolvedFeature,     // dummy storage
                dwNextOpt , dwI;  //  index to the commandTable
                // describing how to transfer the Command data type.
    BOOL    bStatus = TRUE ;
    PBYTE   pubRaw ;
    PSTATICFIELDS   pStatic ;

    pStatic = (PSTATICFIELDS)pubnRaw ;    // transform pubRaw from PSTATIC
    pubRaw  = pStatic->pubBUDData ;         //  to PMINIRAWBINARYDATA

    //  pmrbd = (PMINIRAWBINARYDATA)pubRaw ;
    pearTableContents = (PENHARRAYREF)(pubRaw + sizeof(MINIRAWBINARYDATA)) ;
    patrRoot = (PATREEREF)(pubRaw + pearTableContents[MTI_COMMANDTABLE].
                            loOffset) ;


    //  loop for every PATREEREF in the MTI_COMMANDTABLE !
    //  not looping through each entry in the section.

    for(dwI = 0 ; bStatus  &&  (dwI < CMD_MAX) ; dwI++)
    {
        dwNextOpt = 0 ;  // extract info for first option selected for
                            //  this feature.

        if(EextractValueFromTree(pubnRaw, pStatic->dwSSTableCmdIndex,
            (PBYTE)(pdwCmdTable + dwI),
            &dwUnresolvedFeature,  patrRoot[dwI], poptsel, 0,
                &dwNextOpt) != TRI_SUCCESS)
        {
            bStatus = FALSE ;
        }
    }
    return(bStatus) ;
}


BOOL    BinitRawData(
PRAWBINARYDATA   pRawData, // contained in INFOHEADER.
PBYTE   pubnRaw  //  Parser's raw binary data.
)
{
    PMINIRAWBINARYDATA  pmrbd ;
    PBYTE   pubRaw ;
    PSTATICFIELDS   pStatic ;

    pStatic = (PSTATICFIELDS)pubnRaw ;    // transform pubRaw from PSTATIC
    pubRaw  = pStatic->pubBUDData ;         //  to PMINIRAWBINARYDATA

    pmrbd = (PMINIRAWBINARYDATA)pubRaw ;

    pRawData->dwFileSize = pmrbd->rbd.dwFileSize;
    pRawData->dwParserSignature = pmrbd->rbd.dwParserSignature;
    pRawData->dwParserVersion = pmrbd->rbd.dwParserVersion;
    pRawData->dwChecksum32 = pmrbd->rbd.dwChecksum32;
    pRawData->dwSrcFileChecksum32 = pmrbd->rbd.dwSrcFileChecksum32;


    //  this not the count of synthesized vs.
    //  explicitly defined features

    pRawData->dwDocumentFeatures = pmrbd->rbd.dwDocumentFeatures;
    pRawData->dwPrinterFeatures = pmrbd->rbd.dwPrinterFeatures;
    pRawData->pvPrivateData = pubnRaw ;   //  BETA2

    pRawData->pvReserved = NULL;


    return(TRUE) ;
}


BOOL    BinitGPDdriverInfo(
PGPDDRIVERINFO  pGPDdriverInfo,
PBYTE   pubnRaw,  //  raw binary data.
POPTSELECT   poptsel   // assume fully initialized
)
{
    PENHARRAYREF   pearTableContents ;
    BOOL   bStatus ;
    PBYTE   pubRaw ;
    PSTATICFIELDS   pStatic ;

    pStatic = (PSTATICFIELDS)pubnRaw ;    // transform pubRaw from PSTATIC
    pubRaw  = pStatic->pubBUDData ;         //  to PMINIRAWBINARYDATA

    pearTableContents = (PENHARRAYREF)(pubRaw + sizeof(MINIRAWBINARYDATA)) ;

    pGPDdriverInfo->dwSize =  sizeof(GPDDRIVERINFO) ;
    pGPDdriverInfo->pubResourceData =
        pubRaw + pearTableContents[MTI_STRINGHEAP].loOffset  ;

    pGPDdriverInfo->DataType[DT_COMMANDARRAY].loOffset =
        pearTableContents[MTI_COMMANDARRAY].loOffset -
        pearTableContents[MTI_STRINGHEAP].loOffset  ;
    pGPDdriverInfo->DataType[DT_COMMANDARRAY].dwCount =
        pearTableContents[MTI_COMMANDARRAY].dwCount  ;

    pGPDdriverInfo->DataType[DT_PARAMETERS].loOffset =
        pearTableContents[MTI_PARAMETER].loOffset -
        pearTableContents[MTI_STRINGHEAP].loOffset  ;
    pGPDdriverInfo->DataType[DT_PARAMETERS].dwCount =
        pearTableContents[MTI_PARAMETER].dwCount  ;

    pGPDdriverInfo->DataType[DT_TOKENSTREAM].loOffset =
        pearTableContents[MTI_TOKENSTREAM].loOffset -
        pearTableContents[MTI_STRINGHEAP].loOffset  ;
    pGPDdriverInfo->DataType[DT_TOKENSTREAM].dwCount =
        pearTableContents[MTI_TOKENSTREAM].dwCount  ;

    pGPDdriverInfo->DataType[DT_LISTNODE].loOffset =
        pearTableContents[MTI_LISTNODES].loOffset -
        pearTableContents[MTI_STRINGHEAP].loOffset  ;
    pGPDdriverInfo->DataType[DT_LISTNODE].dwCount =
        pearTableContents[MTI_LISTNODES].dwCount  ;

    pGPDdriverInfo->DataType[DT_FONTSCART].loOffset =
        pearTableContents[MTI_FONTCART].loOffset -
        pearTableContents[MTI_STRINGHEAP].loOffset  ;
    pGPDdriverInfo->DataType[DT_FONTSCART].dwCount =
        pearTableContents[MTI_FONTCART].dwCount  ;

    pGPDdriverInfo->DataType[DT_FONTSUBST].loOffset =
        pearTableContents[MTI_TTFONTSUBTABLE].loOffset -
        pearTableContents[MTI_STRINGHEAP].loOffset  ;
    pGPDdriverInfo->DataType[DT_FONTSUBST].dwCount =
        pearTableContents[MTI_TTFONTSUBTABLE].dwCount  ;

    bStatus = BinitSequencedCmds(pGPDdriverInfo, pubnRaw, poptsel) ;
    if(bStatus)
        bStatus = BinitGlobals(&pGPDdriverInfo->Globals, pubnRaw,  poptsel, FALSE ) ;

    return(bStatus) ;
}


BOOL    BinitSequencedCmds(
PGPDDRIVERINFO  pGPDdriverInfo,
PBYTE   pubnRaw,  //  raw binary data.
POPTSELECT   poptsel   // assume fully initialized
)
{
    PINFOHEADER  pInfoHdr ;
    PDWORD      pdwCmdTable ;   // start of local CommandTable
    PENHARRAYREF   pearTableContents ;
    DWORD       dwCmdIn ,  //  command table index.
                            //  or commandArray index.
                dwNextOpt, dwFea, dwNumFeatures ,
                dwUnresolvedFeature,
                dwNewListNode = 0 ;  //  an unused listnode to
                        //  add to the list.  initially none are used.
    PDFEATURE_OPTIONS  pfo ;
    ATREEREF    atrRoot ;    //  root of attribute tree
    //  PMINIRAWBINARYDATA  pmrbd ;
    OPTSELECT  optsPrevs ;
    BOOL    bStatus = TRUE ;
    PBYTE   pubRaw ;
    PSTATICFIELDS   pStatic ;

    pStatic = (PSTATICFIELDS)pubnRaw ;    // transform pubRaw from PSTATIC
    pubRaw  = pStatic->pubBUDData ;         //  to PMINIRAWBINARYDATA

    //  pmrbd = (PMINIRAWBINARYDATA)pubRaw ;

    pInfoHdr  = pGPDdriverInfo->pInfoHeader ;
    pdwCmdTable = (PDWORD)((PBYTE)(pInfoHdr) +
            pGPDdriverInfo->DataType[DT_COMMANDTABLE].loOffset) ;

    pearTableContents = (PENHARRAYREF)(pubRaw + sizeof(MINIRAWBINARYDATA)) ;

    pGPDdriverInfo->dwJobSetupIndex = END_OF_LIST ;
    pGPDdriverInfo->dwDocSetupIndex = END_OF_LIST ;
    pGPDdriverInfo->dwPageSetupIndex = END_OF_LIST ;
    pGPDdriverInfo->dwPageFinishIndex = END_OF_LIST ;
    pGPDdriverInfo->dwDocFinishIndex = END_OF_LIST ;
    pGPDdriverInfo->dwJobFinishIndex = END_OF_LIST ;

    //  first add the configuration commands to the list.
    //  get them from the commandtable.   Assume they are all
    //  contiguous

    for(dwCmdIn = FIRST_CONFIG_CMD ; dwCmdIn < LAST_CONFIG_CMD  ; dwCmdIn++)
    {
        if((pdwCmdTable[dwCmdIn] != UNUSED_ITEM)  &&
            BaddSequencedCmdToList(pdwCmdTable[dwCmdIn],  pGPDdriverInfo,
                dwNewListNode, pubnRaw  ) )
            dwNewListNode++ ;
    }

    //  now wander through all the features, seeing what
    //  command is needed.

    pfo = (PDFEATURE_OPTIONS)(pubRaw + pearTableContents[MTI_DFEATURE_OPTIONS].
                                loOffset) ;
    dwNumFeatures = pearTableContents[MTI_DFEATURE_OPTIONS].dwCount  ;
    dwNumFeatures += pearTableContents[MTI_SYNTHESIZED_FEATURES].dwCount  ;


    for(dwFea = 0 ; dwFea < dwNumFeatures ; dwFea++)
    {
        dwNextOpt = 0 ;  // extract info for first option selected for
                            //  this feature.

        atrRoot = pfo[dwFea].atrCommandIndex ;
        if(EextractValueFromTree(pubnRaw, pStatic->dwSSCmdSelectIndex,
            (PBYTE)&dwCmdIn, // CmdArray index  - dest
            &dwUnresolvedFeature,  atrRoot, poptsel, dwFea,
            &dwNextOpt) != TRI_SUCCESS)
        {
            bStatus = FALSE ;
            continue ;
        }
        if( (dwCmdIn != UNUSED_ITEM)  &&
            BaddSequencedCmdToList(dwCmdIn,  pGPDdriverInfo,
                dwNewListNode, pubnRaw  ) )
            dwNewListNode++ ;

        while(dwNextOpt)   // multiple options selected.
        {
            if(EextractValueFromTree(pubnRaw, pStatic->dwSSCmdSelectIndex,
                (PBYTE)&dwCmdIn, // CmdArray index  - dest
                &dwUnresolvedFeature,  atrRoot, poptsel, dwFea,
                &dwNextOpt) != TRI_SUCCESS)
            {
                bStatus = FALSE ;
                continue ;
            }
            if((dwCmdIn != UNUSED_ITEM)  &&
                BaddSequencedCmdToList(dwCmdIn,  pGPDdriverInfo,
                    dwNewListNode, pubnRaw  ) )
                dwNewListNode++ ;
        }
    }
    return(bStatus);
}


BOOL    BaddSequencedCmdToList(
DWORD   dwCmdIn,  // index of a command in CommandArray
PGPDDRIVERINFO  pGPDdriverInfo,
DWORD   dwNewListNode,  //  an unused listnode to add to the list.
PBYTE   pubnRaw  //  raw binary data.
)
/*  remember:
    the pdwSeqCmdRoot points to the first node in a list.
    There is a list for each SEQSECTION.
    Each node contains the index to a command in the command array
    and an index to the next node in the list.
*/
{
    PCOMMAND    pcmdArray ;  // the Command Array
    SEQSECTION     eSection;
    PDWORD      pdwSeqCmdRoot ; // points to a list root.
    DWORD       dwOrder,  // order value of a command.
                dwCurListNode,  // node index as we traverse the list.
                dwPrevsListNode ;  // the prevs node in the list.
    PINFOHEADER  pInfoHdr ;
    PLISTNODE   plstNodes ;  //  start of local listnodes array
    PENHARRAYREF   pearTableContents ;
    PBYTE   pubRaw ;
    PSTATICFIELDS   pStatic ;

    pStatic = (PSTATICFIELDS)pubnRaw ;    // transform pubRaw from PSTATIC
    pubRaw  = pStatic->pubBUDData ;         //  to PMINIRAWBINARYDATA

    pInfoHdr  = pGPDdriverInfo->pInfoHeader ;
    plstNodes = (PLISTNODE)((PBYTE)pInfoHdr +
            pGPDdriverInfo->DataType[DT_LOCALLISTNODE].loOffset) ;

    pearTableContents = (PENHARRAYREF)(pubRaw + sizeof(MINIRAWBINARYDATA)) ;

    pcmdArray = (PCOMMAND)(pubRaw +
                pearTableContents[MTI_COMMANDARRAY].loOffset) ;

    eSection = pcmdArray[dwCmdIn].ordOrder.eSection ;
    switch(eSection)
    {
        case (SS_JOBSETUP):
        {
            pdwSeqCmdRoot = &pGPDdriverInfo->dwJobSetupIndex;
            break ;
        }
        case (SS_DOCSETUP):
        {
            pdwSeqCmdRoot = &pGPDdriverInfo->dwDocSetupIndex;
            break ;
        }
        case (SS_PAGESETUP):
        {
            pdwSeqCmdRoot = &pGPDdriverInfo->dwPageSetupIndex;
            break ;
        }
        case (SS_PAGEFINISH):
        {
            pdwSeqCmdRoot = &pGPDdriverInfo->dwPageFinishIndex;
            break ;
        }
        case (SS_DOCFINISH):
        {
            pdwSeqCmdRoot = &pGPDdriverInfo->dwDocFinishIndex;
            break ;
        }
        case (SS_JOBFINISH):
        {
            pdwSeqCmdRoot = &pGPDdriverInfo->dwJobFinishIndex;
            break ;
        }
        default:
        {
            ERR(("BaddSequencedCmdToList: Invalid or non-existent *Order value specified.\n"));
            return(FALSE);  // command not added to linked list.
        }
    }
    //  Insert a new node in the list pointed to by pdwSeqCmdRoot

    dwOrder = pcmdArray[dwCmdIn].ordOrder.dwOrder ;

    // walk the list until you find an order larger than yours.

    dwPrevsListNode = END_OF_LIST ;
    dwCurListNode = *pdwSeqCmdRoot ;

    while((dwCurListNode != END_OF_LIST)  &&
        (pcmdArray[plstNodes[dwCurListNode].dwData].ordOrder.dwOrder
        < dwOrder)  )
    {
        dwPrevsListNode = dwCurListNode ;
        dwCurListNode = plstNodes[dwCurListNode].dwNextItem ;
    }

    plstNodes[dwNewListNode].dwData = dwCmdIn ;
    plstNodes[dwNewListNode].dwNextItem = dwCurListNode ;
    if(dwPrevsListNode == END_OF_LIST)
        *pdwSeqCmdRoot = dwNewListNode ;
    else
        plstNodes[dwPrevsListNode].dwNextItem = dwNewListNode ;

    return(TRUE) ;
}

/*++
    The default Option array (as determined from the gpd) is initialized.
    Since the options or attributues of features may be dependent on the
    some other features, the order of initialization of feature assumes
    importance. The priority array therefore tries to order the
    initialization so that when a feature has to be initialised, all the
    features on which it is dependent on have already been initialised.
    If, inspite of the priority array, a feature's option cannot be
    determined until some other feature's option has been determined,
    the RaisePriority Function is used (This is called by
    EdetermineDefaultOption() ).
    A quirky code here is the pdwPriorityCopy which is initialised
    to pdwPriority. The latter is in read only space and therefore
    prevents change of priority in the RaisePriority Function.
    Therefore pdwPriorityCopy is passed to that function.

    Some special case processing is required for the *Feature:Locale
    keyword if it occurs in the .gpd. The default option for this
    feature is to be set to the SystemDefaultLocale.

--*/

BinitDefaultOptionArray(
POPTSELECT   poptsel,   // assume is large enough
PBYTE   pubnRaw)
{
    PENHARRAYREF        pearTableContents ;
//  PMINIRAWBINARYDATA  pmrbd  ;
    PDFEATURE_OPTIONS   pfo ;
    PDWORD              pdwPriority,     // Array of feature indices arranged
                                         // according to priority.
                        pdwPriorityCopy; // pdwPriority is in read only space.
                                         // We might have to change the
                                         // priorities temporarily to allow
                                         // Default option array to be
                                         // constructed. This change is done in
                                         // pdwPriorityCopy

    DWORD               dwNumFeatures,   // Total number of features
                        dwI ,
                        dwFea,           // Index of Feature Locale
                        dwOptIndex;      // Index of Option of Locale that
                                         // matches System Locale
    PBYTE               pubRaw ;
    PSTATICFIELDS       pStatic ;

    pStatic = (PSTATICFIELDS)pubnRaw ;    // transform pubRaw from PSTATIC
    pubRaw  = pStatic->pubBUDData ;         //  to PMINIRAWBINARYDATA



    //  obtain pointers to structures:
    //  pmrbd = (PMINIRAWBINARYDATA)pubRaw ;
    pearTableContents = (PENHARRAYREF)(pubRaw + sizeof(MINIRAWBINARYDATA)) ;

    dwNumFeatures = pearTableContents[MTI_DFEATURE_OPTIONS].dwCount  ;
    dwNumFeatures += pearTableContents[MTI_SYNTHESIZED_FEATURES].dwCount  ;
    //  both explicit and synthesized features are contiguous.
    if(dwNumFeatures > MAX_COMBINED_OPTIONS)
        return(FALSE);  // too many to save



    dwFea = dwOptIndex = (DWORD)-1; // For safety sake only. Should be initialized
                             // in the function BgetLocFeaOptIndex().

    // returns TRUE if everything OK. if return is TRUE and dwFea is -1
    // Locale is not present and no special processing is required.
    // If dwFea != -1 and dwOptIndex == -1 means none of the options in
    // the .gpd match the system default. Again no special processing
    // for locale is required.

    // Assuming that only a single matching option is possible for
    // Locale.
    if ( !BgetLocFeaOptIndex(
                (PRAWBINARYDATA)pubnRaw, &dwFea, &dwOptIndex) )
    {
        return FALSE;
    }



    pdwPriority = (PDWORD)(pubRaw + pearTableContents[MTI_PRIORITYARRAY].
                                loOffset) ;

    pfo = (PDFEATURE_OPTIONS)(pubRaw + pearTableContents[MTI_DFEATURE_OPTIONS].
                                loOffset) ;

    if ( ! (pdwPriorityCopy = (PDWORD) MemAlloc (
                        pearTableContents[MTI_PRIORITYARRAY].dwCount *
                        pearTableContents[MTI_PRIORITYARRAY].dwElementSiz ) ) )
    {
        // Set error codes and
        ERR(("Fatal: BinitDefaultOptionArray - unable to allocate memory\n" ));
        return FALSE;
    }

    memcpy(pdwPriorityCopy, pdwPriority,
                pearTableContents[MTI_PRIORITYARRAY].dwCount *
                pearTableContents[MTI_PRIORITYARRAY].dwElementSiz );




    for(dwI = 0 ; dwI < dwNumFeatures ; dwI++)
    {
        poptsel[dwI].ubCurOptIndex = OPTION_INDEX_ANY ;
        poptsel[dwI].ubNext = NULL_OPTSELECT ;
    }

    // Initialize the option array for Feature Locale.
    // Or should we call ReconstructOptionArray.????
    if ( dwFea != -1 && dwOptIndex != -1)
    {
        poptsel[dwFea].ubCurOptIndex  = (BYTE)dwOptIndex;
        poptsel[dwFea].ubNext         = NULL_OPTSELECT ;
    }

    for(dwI = 0 ; dwI < dwNumFeatures ; dwI++)
    {
        //  The order of evaluation is determined
        //  by the priority array.

        if(poptsel[pdwPriorityCopy[dwI]].ubCurOptIndex == OPTION_INDEX_ANY)
        {
            if(EdetermineDefaultOption(pubnRaw , pdwPriorityCopy[dwI],
                    pfo, poptsel, pdwPriorityCopy) != TRI_SUCCESS)
            {
                ERR(("BinitDefaultOptionArray: failed to determine consistent \
                      default options.\n"));

                if ( pdwPriorityCopy )
                    MemFree(pdwPriorityCopy);

                return(FALSE);
            }
        }
    }
    //  BUG_BUG!!!! now verify the set options thus determined is
    //  fully self consistent.  is not precluded by UIConstraints.
    //  warn user and fail otherwise .
    //  successful execution of EdetermineDefaultOption basically
    //  assures this.

    if ( pdwPriorityCopy )
        MemFree(pdwPriorityCopy);

    return(TRUE);
}


TRISTATUS     EdetermineDefaultOption(
PBYTE   pubnRaw,         // start of Rawbinary data
DWORD   dwFeature,       // determine the default for this feature
PDFEATURE_OPTIONS  pfo,
POPTSELECT   poptsel,    // assume is large enough
PDWORD      pdwPriority) // Priority array indicating the priority of various
                         // features.
{
    //  PMINIRAWBINARYDATA pmrbd  ;
    TRISTATUS  eStatus   ;
    DWORD   dwUnresolvedFeature , // no option has been determined
            dwNextOpt ,           // for this feature
            dwOption ;  //  for   BextractValueFromTree
                        //  to write into.
    PBYTE   pubRaw ;
    PSTATICFIELDS   pStatic ;

    pStatic = (PSTATICFIELDS)pubnRaw ;    // transform pubRaw from PSTATIC
    pubRaw  = pStatic->pubBUDData ;         //  to PMINIRAWBINARYDATA


    //  This function will modify the priority array
    //  each time the tree walk fails so that each feature
    //  evaluated depends only on default options that have
    //  previously evaluated .

    //  pmrbd = (PMINIRAWBINARYDATA)pubRaw ;

    dwNextOpt = 0 ;  // extract info for first option selected for
                        //  this feature.

    while((eStatus = EextractValueFromTree(
                    pubnRaw, pStatic->dwSSdefaultOptionIndex,
                    (PBYTE )&dwOption,
                    &dwUnresolvedFeature,
                    pfo[dwFeature].atrDefaultOption,
                    poptsel, 0,
                    &dwNextOpt)) == TRI_AGAIN)
    {
        //  recursion handles depth, while loop handles breadth

        if(poptsel[dwUnresolvedFeature].ubCurOptIndex == OPTION_PENDING)
        {
            ERR(("Fatal syntax error: EdetermineDefaultOption - circular dependency in default options.\n"));
            return(TRI_UTTER_FAILURE) ;
        }
        poptsel[dwFeature].ubCurOptIndex = OPTION_PENDING ;
        // marks entry in option array so we can detect infinite loops.

        if(!RaisePriority(dwFeature, dwUnresolvedFeature, pubnRaw, pdwPriority))
            return(FALSE) ;  // modify Priority array to reflect
                            //  reality.

        eStatus = EdetermineDefaultOption(pubnRaw, dwUnresolvedFeature,
                  pfo, poptsel, pdwPriority) ;
        if(eStatus == TRI_UTTER_FAILURE)
            return(TRI_UTTER_FAILURE) ;
    }
    if(eStatus == TRI_SUCCESS)
        poptsel[dwFeature].ubCurOptIndex = (BYTE)dwOption ;

    return(eStatus);
}


VOID    VtileDefault(
PBYTE   pubDest,
DWORD   dwDefault,
DWORD   dwBytes)
{
    DWORD  dwRemain ;

    // This function will copy the same DWORD
    //  repeatedly into the dest until dwBytes have
    //  been written.

    for (dwRemain = dwBytes ; dwRemain > sizeof(DWORD)  ;
            dwRemain -= sizeof(DWORD) )
    {
        memcpy(pubDest , &dwDefault, sizeof(DWORD)) ;
        pubDest += sizeof(DWORD) ;
    }
    memcpy(pubDest, &dwDefault, dwRemain) ;
}




VOID    VtransferValue(
OUT PBYTE   pubDest,
IN  PBYTE   pubSrc ,
IN  DWORD   dwBytes,
IN  DWORD   dwFlags,
IN  DWORD   dwDefaultValue,  // holds bit flag value.
IN  PBYTE   pubHeap )   //  used to form ptr if SSF_MAKE_STRINGPTR
/*  this  wrapper implements:
    SSF_OFFSETONLY, SSF_MAKE_STRINGPTR,
    SSF_SECOND_DWORD, SSF_SETRCID, SSF_STRINGLEN,
    SSF_BITFIELD_ xxx
    notice all of these flags are basically
    mutually exclusive. But this function only
    enforces this for the first three flags.
*/
{
    if(dwFlags & SSF_SECOND_DWORD)
    {
        memcpy(pubDest, pubSrc + sizeof(DWORD) , dwBytes) ;
    }
    else if(dwFlags & SSF_MAKE_STRINGPTR)
    {
        PBYTE   pubStr ;

        pubStr = pubHeap + ((PARRAYREF)pubSrc)->loOffset  ;

        memcpy(pubDest, (PBYTE)&pubStr , sizeof(PBYTE)) ;
    }
    else if(dwFlags & SSF_OFFSETONLY)
    {
        memcpy(pubDest, (PBYTE)&(((PARRAYREF)pubSrc)->loOffset) , dwBytes) ;
    }
    else if(dwFlags & SSF_STRINGLEN)
    {
        memcpy(pubDest, (PBYTE)&(((PARRAYREF)pubSrc)->dwCount) , dwBytes) ;
    }
    else if(dwFlags & SSF_BITFIELD_DEF_FALSE  ||
                dwFlags & SSF_BITFIELD_DEF_TRUE)
    {
        if(*(PDWORD)pubSrc)   // assume fields are zero initialized
            *(PDWORD)pubDest |= dwDefaultValue ;
        else
            *(PDWORD)pubDest &= ~dwDefaultValue ;
    }
    else
    {
        memcpy(pubDest, pubSrc , dwBytes) ;
    }

    if(dwBytes == sizeof(DWORD) )
    {
        if(dwFlags & SSF_KB_TO_BYTES)
            *(PDWORD)pubDest <<=  10 ;  // convert Kbytes to bytes
        else if(dwFlags & SSF_MB_TO_BYTES)
            *(PDWORD)pubDest <<=  20 ;  // convert Mbytes to bytes

        if(dwFlags & SSF_SETRCID)
            *(PDWORD)pubDest |=  GET_RESOURCE_FROM_DLL ;
    }
}


BOOL    BspecialProcessOption(
PBYTE   pubnRaw,  // start of Rawbinary data
PBYTE   pubDestOption,  // ptr to some type of option structure.
PBYTE   pubDestOptionEx,
PDFEATURE_OPTIONS  pfo ,  // source data
IN  POPTSELECT       poptsel,     // option array which determines path
                //  through atr.
PINFOHEADER  pInfoHdr,   // used to access global structure.
DWORD   dwFea,   //  feature index
DWORD   dwOpt,
BOOL   bDefaultOpt
)
{
    PGPDDRIVERINFO  pGPDdriverInfo ;
    //  PMINIRAWBINARYDATA pmrbd  ;
    DWORD  dwGID, dwNextOpt, dwUnresolvedFeature, dwI ;
    PBYTE  pubDest ;
    PATREEREF   patrRoot ;
    PUIINFO     pUIinfo ;
    BOOL    bStatus = TRUE ;
    PBYTE   pubRaw ;
    PSTATICFIELDS   pStatic ;

    pStatic = (PSTATICFIELDS)pubnRaw ;    // transform pubRaw from PSTATIC
    pubRaw  = pStatic->pubBUDData ;         //  to PMINIRAWBINARYDATA

    pGPDdriverInfo = (PGPDDRIVERINFO)((PBYTE)(pInfoHdr) +
                    pInfoHdr->loDriverOffset) ;

    pUIinfo = (PUIINFO)((PBYTE)(pInfoHdr) +
                    pInfoHdr->loUIInfoOffset)  ;

    //  pmrbd = (PMINIRAWBINARYDATA)pubRaw ;
    dwGID = pfo->dwGID ;

#if  0
    //  dead code for now.
    //  Extract atrMargins convert to ImageableArea, place in rcImgArea.

    dwI = pStatic->dwSSPaperSizeMarginsIndex;

    if(pStatic->snapShotTable[dwI].dwGIDflags & ( 1 << dwGID))
    {
        RECT    rcMargins ;
        PRECT   prcImageArea ;
        SIZE    szPaperSize ;

        patrRoot = (PATREEREF)((PBYTE)pfo +
                    pStatic->snapShotTable[dwI].dwSrcOffset) ;
        pubDest = (PBYTE)&rcMargins ;

        dwNextOpt = 0 ;  // extract info for first option selected for
                            //  this feature.

        if(EextractValueFromTree(pubnRaw, dwI, pubDest,
            &dwUnresolvedFeature,  *patrRoot, poptsel, 0, // set to
            // any value.  Doesn't matter.
            &dwNextOpt) != TRI_SUCCESS)
        {
            bStatus = FALSE ;
        }
        szPaperSize = ((PPAGESIZE)pubDestOption)->szPaperSize ;
        prcImageArea = &((PPAGESIZE)pubDestOption)->rcImgAreaP ;

        prcImageArea->left = rcMargins.left ;
        prcImageArea->top = rcMargins.top ;
        prcImageArea->right = szPaperSize.x - rcMargins.right ;
        prcImageArea->bottom = szPaperSize.y - rcMargins.bottom ;
    }


    //  Extract atrMin/MaxSize place in ptMin/MaxSize in GLOBALS.

    dwI = pStatic->dwSSPaperSizeMinSizeIndex;

    if(pStatic->snapShotTable[dwI].dwGIDflags & ( 1 << dwGID)  &&
        ((PPAGESIZE)pubDestOption)->dwPaperSizeID == DMPAPER_USER )
    {
        pUIinfo->dwCustomSizeOptIndex = dwOpt ;
        pUIinfo->dwFlags |= FLAG_CUSTOMSIZE_SUPPORT ;

        patrRoot = (PATREEREF)((PBYTE)pfo +
                    pStatic->snapShotTable[dwI].dwSrcOffset) ;
        pubDest = (PBYTE)(&pGPDdriverInfo->Globals) +
                    pStatic->snapShotTable[dwI].dwDestOffset;

        dwNextOpt = 0 ;  // extract info for first option selected for
                            //  this feature.

        if(EextractValueFromTree(pubnRaw, dwI, pubDest,
            &dwUnresolvedFeature,  *patrRoot, poptsel, 0, // set to
            // any value.  Doesn't matter.
            &dwNextOpt) != TRI_SUCCESS)
        {
            bStatus = FALSE ;
        }
    }

    dwI = pStatic->dwSSPaperSizeMaxSizeIndex;

    if(pStatic->snapShotTable[dwI].dwGIDflags & ( 1 << dwGID)  &&
        ((PPAGESIZE)pubDestOption)->dwPaperSizeID == DMPAPER_USER )
    {

        patrRoot = (PATREEREF)((PBYTE)pfo +
                    pStatic->snapShotTable[dwI].dwSrcOffset) ;
        pubDest = (PBYTE)(&pGPDdriverInfo->Globals) +
                    pStatic->snapShotTable[dwI].dwDestOffset;

        dwNextOpt = 0 ;  // extract info for first option selected for
                            //  this feature.

        if(EextractValueFromTree(pubnRaw, dwI, pubDest,
            &dwUnresolvedFeature,  *patrRoot, poptsel, 0, // set to
            // any value.  Doesn't matter.
            &dwNextOpt) != TRI_SUCCESS)
        {
            bStatus = FALSE ;
        }
    }

#endif


    dwI = pStatic->dwSSPaperSizeCursorOriginIndex ;

    if(pStatic->snapShotTable[dwI].dwGIDflags & ( 1 << dwGID) )
    {
        TRISTATUS  triStatus ;

        patrRoot = (PATREEREF)((PBYTE)pfo +
                    pStatic->snapShotTable[dwI].dwSrcOffset) ;

        pubDest = pubDestOptionEx +
                    pStatic->snapShotTable[dwI].dwDestOffset;

        dwNextOpt = 0 ;  // extract info for first option selected for
                            //  this feature.

        if((triStatus  = EextractValueFromTree(pubnRaw, dwI, pubDest,
            &dwUnresolvedFeature,  *patrRoot, poptsel, 0, // set to
            // any value.  Doesn't matter.
            &dwNextOpt)) != TRI_SUCCESS)
        {
            if(triStatus == TRI_UNINITIALIZED)
            {
                ((PPAGESIZEEX)pubDestOptionEx)->ptPrinterCursorOrig =
                    ((PPAGESIZEEX)pubDestOptionEx)->ptImageOrigin ;
            }
            else
                bStatus = FALSE ;
        }
    }


    if(dwGID == GID_MEMOPTION  &&
        bDefaultOpt)
    {
        pUIinfo->dwFreeMem = ((PMEMOPTION)pubDestOption)->dwFreeMem ;
    }

    if(dwGID == GID_COLORMODE   &&
        ((PCOLORMODEEX)pubDestOptionEx)->bColor )
    {
        pUIinfo->dwFlags |= FLAG_COLOR_DEVICE ;
    }


    return(bStatus);
}




TRISTATUS     EextractValueFromTree(
PBYTE   pubnRaw,  // start of Rawbinary data
DWORD   dwSSTableIndex,  // some info about this value.
OUT PBYTE    pubDest,  // write value or link here
OUT PDWORD  pdwUnresolvedFeature,  // if the attribute tree has
            //  a dependency on this feature and the current option
            //  for that feature is not defined  in poptsel, this
            //  function will write the index of the required
            //  feature in pdwUnresolvedFeature.
IN  ATREEREF    atrRoot,    //  root of attribute tree to navigate.
IN  POPTSELECT       poptsel,     // option array which determines path
                //  through atr.  may be filled with OPTION_INDEX_ANY
                //  if we are jumpstarting
IN  DWORD   dwFeature,
IN OUT  PDWORD   pdwNextOpt  //  if multiple options are selected
    //  for dwFeature, pdwNextOpt points to the Nth option to consider
    //  in the  poptsel list,  at return time, this value
    //  is incremented if there are remaining options selected,
    //  else is reset to zero.
    //  For the first call, or PICKONE features,
    //  this value must be set to zero.
)
{
    BOOL    bMissingDependency = FALSE;
    PATTRIB_TREE    patt ;  // start of ATTRIBUTE tree array.
    PENHARRAYREF   pearTableContents ;
    //  PMINIRAWBINARYDATA pmrbd  ;
    DWORD   dwBytes ,  // size of value in bytes
        dwValueNodeIndex , dwNodeIndex, dwFea, dwI ,
        dwDefault ,  // value to copy or tile to dest.
        dwOption, dwFlags ;
    PBYTE   pubHeap ,  // ptr to start of heap.
        pubSrc ;  //  ptr to value bytes
    PBYTE   pubRaw ;
    PSTATICFIELDS   pStatic ;

    pStatic = (PSTATICFIELDS)pubnRaw ;    // transform pubRaw from PSTATIC
    pubRaw  = pStatic->pubBUDData ;         //  to PMINIRAWBINARYDATA


    //  obtain pointers to structures:

    pearTableContents = (PENHARRAYREF)(pubRaw + sizeof(MINIRAWBINARYDATA)) ;

    patt = (PATTRIB_TREE)(pubRaw + pearTableContents[MTI_ATTRIBTREE].
                            loOffset) ;

    pubHeap = (PBYTE)(pubRaw + pearTableContents[MTI_STRINGHEAP].
                            loOffset) ;

    //  pmrbd = (PMINIRAWBINARYDATA)pubRaw ;

    dwBytes = pStatic->snapShotTable[dwSSTableIndex].dwNbytes ;
    dwFlags = pStatic->snapShotTable[dwSSTableIndex].dwFlags ;

    dwDefault = pStatic->snapShotTable[dwSSTableIndex].dwDefaultValue ;
    //  now attempt to navigate the attributeTree.

    if(atrRoot == ATTRIB_UNINITIALIZED)
    {
        DWORD   dwRemain ;  // bytes remaining to copy.

UNINITIALIZED_BRANCH:

        if(dwFlags & SSF_BITFIELD_DEF_FALSE)
        {
            *(PDWORD)pubDest &= ~dwDefault ;  //  clear bitflag
        }
        else if(dwFlags & SSF_BITFIELD_DEF_TRUE)
        {
            *(PDWORD)pubDest |= dwDefault ;  // set bitflag
        }
        else if(!(dwFlags & SSF_DONT_USEDEFAULT))
        {
            if (dwBytes == sizeof(DWORD))
                memcpy (pubDest, &dwDefault, sizeof(DWORD));
            else if (dwBytes == (sizeof(DWORD)*2))
            {
                memcpy (pubDest, &dwDefault, sizeof(DWORD));
                memcpy (pubDest+sizeof(DWORD), &dwDefault, sizeof(DWORD));
            }
            else
                VtileDefault(pubDest, dwDefault, dwBytes) ;
        }

        if(dwFlags & SSF_REQUIRED)
        {
            ERR(("EextractValueFromTree: a required keyword is missing from the GPD file. %s\n",
                pStatic->snapShotTable[dwSSTableIndex].pstrKeyword ));
            return(TRI_UNINITIALIZED) ;
        }
        if(dwFlags & SSF_FAILIFZERO)
        {   //  see if dest is completely zeroed. Fail if it is.
            for(dwI = 0 ; (dwI < dwBytes) && !pubDest[dwI] ; dwI++)
                ;
            if(dwI == dwBytes)
            {
                ERR(("EextractValueFromTree: None of several initializers found.  %s\n",
                    pStatic->snapShotTable[dwSSTableIndex].pstrKeyword ));
                return(TRI_UNINITIALIZED) ;  //  of the two or more
                //  keywords that could have initialized this field,
                //  none were found.
            }

        }
        if(dwFlags & SSF_RETURN_UNINITIALIZED)
            return(TRI_UNINITIALIZED) ;

        return(TRI_SUCCESS) ;   // no value defined.
    }
    else if(atrRoot & ATTRIB_HEAP_VALUE)
    {
        DWORD   dwTmp ;

        if(dwFlags & SSF_HEAPOFFSET)
        {
            dwTmp = atrRoot & ~ATTRIB_HEAP_VALUE ;
            pubSrc = (PBYTE)&dwTmp ;
        }
        else
            pubSrc = pubHeap + (atrRoot & ~ATTRIB_HEAP_VALUE) ;

        if (dwBytes == sizeof(DWORD) && !(dwFlags &
                (SSF_SECOND_DWORD |
                SSF_MAKE_STRINGPTR |
                SSF_OFFSETONLY |
                SSF_STRINGLEN |
                SSF_BITFIELD_DEF_FALSE |
                SSF_BITFIELD_DEF_TRUE |
                SSF_KB_TO_BYTES |
                SSF_MB_TO_BYTES |
                SSF_SETRCID)))
        {
            memcpy (pubDest,pubSrc,sizeof(DWORD));
        }
        else
        {
            VtransferValue(pubDest, pubSrc , dwBytes, dwFlags, dwDefault, pubHeap ) ;
        }

        if(dwFlags & SSF_NON_LOCALIZABLE)
//            pmrbd->bContainsNames = TRUE ;
            ; //  set a flag here.
        return(TRI_SUCCESS) ;
    }
    //  atrRoot specifies a node index
    dwNodeIndex = atrRoot ;
    dwValueNodeIndex = END_OF_LIST ;

    if(patt[dwNodeIndex].dwFeature == DEFAULT_INIT )
    {
        dwValueNodeIndex = dwNodeIndex  ;
        dwNodeIndex = patt[dwNodeIndex].dwNext ;
    }

    while (dwNodeIndex != END_OF_LIST)
    {

        if((dwFea = patt[dwNodeIndex].dwFeature) == dwFeature)
        //  for this feature, I may want to examine not the first
        //  selected option, but other selections. (PICKMANY)
        //  walk the PICKMANY list.
        {
            for(dwI = 0 ; dwI < *pdwNextOpt ; dwI++)
            {
                if(poptsel[dwFea].ubNext != NULL_OPTSELECT)
                    dwFea = poptsel[dwFea].ubNext ;
                else
                    break ;
            }
            if(poptsel[dwFea].ubNext != NULL_OPTSELECT)
                (*pdwNextOpt)++ ;
            else
                *pdwNextOpt = 0 ;  // reset to indicate end of list.
        }

        dwOption =
            (DWORD)poptsel[dwFea].ubCurOptIndex  ;

        if(dwOption == OPTION_PENDING)
        {
            ERR(("EextractValueFromTree: Fatal syntax error, circular dependency in default options.\n"));
            return(TRI_UTTER_FAILURE) ;
        }
        if(dwOption == OPTION_INDEX_ANY)
        {
            *pdwUnresolvedFeature = patt[dwNodeIndex].dwFeature ;
            return(TRI_AGAIN) ;  // option array not fully defined.
        }
        //  valid option for this feature, see if a matching
        //  node exists.
#ifndef OLDWAY
        while (patt[dwNodeIndex].dwOption != dwOption &&
               patt[dwNodeIndex].dwNext != END_OF_LIST)
        {
            dwNodeIndex = patt[dwNodeIndex].dwNext;
        }
        if(patt[dwNodeIndex].dwOption != dwOption &&
           patt[dwNodeIndex].dwOption != DEFAULT_INIT)
        {
            break;
        }
#else
        if(!BfindMatchingOrDefaultNode(patt , &dwNodeIndex, dwOption))
        {
            //  attribute tree does not contain the specified
            //  branch.  Use the Global Default Initializer if exists.
            break ;
        }
#endif
        if(patt[dwNodeIndex].eOffsetMeans == VALUE_AT_HEAP)
        {
            dwValueNodeIndex = dwNodeIndex ;  // Eureka !
            break ;
        }
        //  does this node contain a sublevel?
        if(patt[dwNodeIndex].eOffsetMeans == NEXT_FEATURE)
        {
            // Down to the next level we go.
            dwNodeIndex = patt[dwNodeIndex ].dwOffset ;
        }
        else
             break;   //  tree corruption has occurred.  exit.
    }
    if(dwValueNodeIndex != END_OF_LIST  &&
        patt[dwValueNodeIndex].eOffsetMeans == VALUE_AT_HEAP )
    {
        if(dwFlags & SSF_HEAPOFFSET)
            pubSrc = (PBYTE)&(patt[dwValueNodeIndex].dwOffset) ;
        else
            pubSrc = pubHeap + patt[dwValueNodeIndex].dwOffset ;

        if (dwBytes == sizeof(DWORD) && !(dwFlags &
                (SSF_SECOND_DWORD |
                SSF_MAKE_STRINGPTR |
                SSF_OFFSETONLY |
                SSF_STRINGLEN |
                SSF_BITFIELD_DEF_FALSE |
                SSF_BITFIELD_DEF_TRUE |
                SSF_KB_TO_BYTES |
                SSF_MB_TO_BYTES |
                SSF_SETRCID)))
        {
            memcpy (pubDest,pubSrc,sizeof(DWORD));
        }
        else
        {
            VtransferValue(pubDest, pubSrc , dwBytes, dwFlags, dwDefault, pubHeap ) ;
        }

        if(dwFlags & SSF_NON_LOCALIZABLE)
//            pmrbd->bContainsNames = TRUE ;
            ;  // set a flag here
        return(TRI_SUCCESS) ;
    }
    //  attribute tree does not contain the specified
    //  branch.  This is not necessarily an error since
    //  the attribute tree is allowed to be sparsely populated.
    goto  UNINITIALIZED_BRANCH ;
}



BOOL   RaisePriority(
DWORD   dwFeature1,
DWORD   dwFeature2,
PBYTE   pubnRaw,
PDWORD  pdwPriority)
{
    // takes to lower priority feature and assigns
    // it the priority of the other feature.
    //  The priority of all features between feature1
    //  and feature2 including the higher priority feature
    //  are demoted one level.
    PENHARRAYREF   pearTableContents ;
//    PDWORD   pdwPriority ;
    DWORD   dwHigherP, dwLowerP, dwFeature, dwI, dwEntries  ;
    PBYTE   pubRaw ;
    PSTATICFIELDS   pStatic ;

    pStatic = (PSTATICFIELDS)pubnRaw ;    // transform pubRaw from PSTATIC
    pubRaw  = pStatic->pubBUDData ;         //  to PMINIRAWBINARYDATA

    pearTableContents = (PENHARRAYREF)(pubRaw + sizeof(MINIRAWBINARYDATA)) ;

/**
    pdwPriority = (PDWORD)(pubRaw + pearTableContents[MTI_PRIORITYARRAY].
                                loOffset) ;
**/

    dwEntries = pearTableContents[MTI_PRIORITYARRAY].dwCount ;

    dwHigherP = dwLowerP = dwEntries ;  // init to invalid value.

    //  a Priority 1 is considered
    //  a 'higher' priority than a priority 2, but arithmetically its
    //  the other way around.

    for(dwI = 0 ; dwI < dwEntries ; dwI++)
    {
        if(pdwPriority[dwI] == dwFeature1)
        {
            if(dwHigherP == dwEntries)
                dwHigherP = dwI ;
            else
            {
                dwLowerP = dwI ;
                break ;
            }
        }
        else if(pdwPriority[dwI] == dwFeature2)
        {
            if(dwHigherP == dwEntries)
                dwHigherP = dwI ;
            else
            {
                dwLowerP = dwI ;
                break ;
            }
        }
    }
    //  BUG_BUG paranoid:  could verify
    //  if( dwHigherP ==  dwEntries  ||  dwLowerP == dwEntries )
    //        return(FALSE);  priority array or arg values
    //      are corrupted .
    ASSERT(dwHigherP != dwEntries  &&  dwLowerP != dwEntries);

    dwFeature = pdwPriority[dwLowerP] ;  // this feature will be promoted.

    for(dwI = dwLowerP  ; dwI > dwHigherP ; dwI--)
    {
        pdwPriority[dwI] = pdwPriority[dwI - 1] ;
    }
    pdwPriority[dwHigherP] = dwFeature ;
    return(TRUE) ;
}


DWORD  dwNumOptionSelected(
IN  DWORD  dwNumFeatures,
IN  POPTSELECT       poptsel
)
/*  reports number of options actually selected in
option select array.  The caller supplies dwNumFeatures -
the number of Doc and Printer sticky features, and this
function does the rest.  The actual number of options
selected may be larger than dwNumFeatures if there are
PICKMANY features.  */
{
    DWORD       dwCount, dwI, // feature Index
        dwNext ;  // if pick many, next option selection for this feature.

    dwCount = dwNumFeatures ;

    for(dwI = 0 ; dwI < dwNumFeatures ; dwI++)
    {
        for(dwNext = dwI ;
            poptsel[dwNext].ubNext != NULL_OPTSELECT ;
            dwNext = poptsel[dwNext].ubNext )
        {
            dwCount++ ;
        }
    }
    return(dwCount) ;
}


//  assume a pointer to this table is stored in the RAWbinary data.




BOOL  BinitSnapShotIndexTable(PBYTE  pubnRaw)
/*
    snapShotTable[]  is assumed to be divided into sections
    with an entry with dwNbytes = 0 dividing the sections.
    The end of the table is also terminated by an entry
    with dwNbytes = 0.
    This function initializes pmrbd->ssTableIndex
    which serves as an index into pmrbd->snapShotTable.

*/
{
    PSTATICFIELDS   pStatic ;
//    PMINIRAWBINARYDATA pmrbd  ;
    DWORD dwI,  // snapShotTable Index
        dwSect ;  //  SSTABLEINDEX  Index
    PRANGE   prng ;

    pStatic = (PSTATICFIELDS)pubnRaw ;
//    pmrbd = (PMINIRAWBINARYDATA)pubRaw ;
    pStatic->ssTableIndex = (PRANGE)
        MemAlloc(sizeof(RANGE) * MAX_STRUCTURETYPES) ;
    if(!pStatic->ssTableIndex)
        return(FALSE) ;


    prng  = pStatic->ssTableIndex ;

    for(dwI = dwSect = 0 ; dwSect < MAX_STRUCTURETYPES ; dwSect++, dwI++)
    {
        prng[dwSect].dwStart = dwI ;

        for(  ; pStatic->snapShotTable[dwI].dwNbytes ; dwI++ )
            ;

        prng[dwSect].dwEnd = dwI ;  // one past the last entry
    }
    return(TRUE);
}




BOOL    BinitSizeOptionTables(PBYTE  pubnRaw)
{
//    PMINIRAWBINARYDATA pmrbd  ;
    PSTATICFIELDS   pStatic ;

    pStatic = (PSTATICFIELDS)pubnRaw ;
//    pmrbd = (PMINIRAWBINARYDATA)pubRaw ;
    pStatic->pdwSizeOption = (PDWORD)
        MemAlloc(sizeof(DWORD) * MAX_GID * 2) ;
    if(!pStatic->pdwSizeOption)
        return(FALSE) ;

    pStatic->pdwSizeOptionEx = pStatic->pdwSizeOption + MAX_GID ;


    pStatic->pdwSizeOption[GID_RESOLUTION] = sizeof(RESOLUTION);
    pStatic->pdwSizeOptionEx[GID_RESOLUTION] = sizeof(RESOLUTIONEX);

    pStatic->pdwSizeOption[GID_PAGESIZE] = sizeof(PAGESIZE);
    pStatic->pdwSizeOptionEx[GID_PAGESIZE] = sizeof(PAGESIZEEX);

    pStatic->pdwSizeOption[GID_PAGEREGION] = sizeof(OPTION);
    pStatic->pdwSizeOptionEx[GID_PAGEREGION] = 0 ;

    pStatic->pdwSizeOption[GID_DUPLEX] = sizeof(DUPLEX);
    pStatic->pdwSizeOptionEx[GID_DUPLEX] = 0 ;

    pStatic->pdwSizeOption[GID_INPUTSLOT] = sizeof(INPUTSLOT);
    pStatic->pdwSizeOptionEx[GID_INPUTSLOT] = 0 ;  //  sizeof(INPUTSLOTEX);

    pStatic->pdwSizeOption[GID_MEDIATYPE] = sizeof(MEDIATYPE);
    pStatic->pdwSizeOptionEx[GID_MEDIATYPE] = 0 ;

    pStatic->pdwSizeOption[GID_MEMOPTION] = sizeof(MEMOPTION);
    pStatic->pdwSizeOptionEx[GID_MEMOPTION] = 0 ;

    pStatic->pdwSizeOption[GID_COLORMODE] = sizeof(COLORMODE);
    pStatic->pdwSizeOptionEx[GID_COLORMODE] = sizeof(COLORMODEEX);

    pStatic->pdwSizeOption[GID_ORIENTATION] = sizeof(ORIENTATION);
    pStatic->pdwSizeOptionEx[GID_ORIENTATION] = 0 ;

    pStatic->pdwSizeOption[GID_PAGEPROTECTION] = sizeof(PAGEPROTECT);
    pStatic->pdwSizeOptionEx[GID_PAGEPROTECTION] = 0 ;

    pStatic->pdwSizeOption[GID_COLLATE] = sizeof(COLLATE);
    pStatic->pdwSizeOptionEx[GID_COLLATE] = 0 ;

    pStatic->pdwSizeOption[GID_OUTPUTBIN] = sizeof(OUTPUTBIN);
    pStatic->pdwSizeOptionEx[GID_OUTPUTBIN] = 0 ;

    pStatic->pdwSizeOption[GID_HALFTONING] = sizeof(HALFTONING);
    pStatic->pdwSizeOptionEx[GID_HALFTONING] = 0 ;



    // outside array bounds.
//    pmrbd->pdwSizeOption[GID_UNKNOWN] = sizeof(OPTION);
//    pmrbd->pdwSizeOptionEx[GID_UNKNOWN] = 0 ;

    return(TRUE) ;
}


PRAWBINARYDATA
LoadRawBinaryData (
    IN PTSTR    ptstrDataFilename
    )

/*++

Routine Description:

    Load raw binary printer description data.

Arguments:

    ptstrDataFilename - Specifies the name of the original printer description file

Return Value:

    Pointer to raw binary printer description data
    NULL if there is an error

--*/

{
    //  PMINIRAWBINARYDATA pmrbd  ;
    PSTATICFIELDS   pStatic ;

    PRAWBINARYDATA  pnRawData;   //  actually points to pStatic structure
    DWORD   dwI ;
//    extern  int  giDebugLevel  ;

//    giDebugLevel = 5 ;

    //
    // Sanity check
    //


    if (ptstrDataFilename == NULL) {

        ERR(("GPD filename is NULL.\n"));
        return NULL;
    }

    //
    // Attempt to load cached binary printer description data first
    //

    if (!(pnRawData = GpdLoadCachedBinaryData(ptstrDataFilename)))
    {
        #ifndef KERNEL_MODE

        #ifdef  PARSERLIB

        (VOID) BcreateGPDbinary(ptstrDataFilename, 0) ;
                // 0 = min Verbosity Level

        pnRawData = GpdLoadCachedBinaryData(ptstrDataFilename) ;

        #else  PARSERLIB

        //
        // If there is no cached binary data or it's out-of-date, we'll parse
        // the ASCII text file and cache the resulting binary data.
        //

        DWORD  pathlen = 0 ;
        DWORD  namelen =  0 ;
        WCHAR * pwDLLQualifiedName = NULL ;

        //  WCHAR           awchDLLpath[MAX_PATH];
        PWSTR   pwstrDLLname = TEXT("gpdparse.dll") ;

        typedef BOOL    (*PFBCREATEGPDBINARY)(PWSTR, DWORD) ;
        PFBCREATEGPDBINARY  pfBcreateGPDbinary = NULL ;
        PWSTR   pwstrLastBackSlash ;
        HINSTANCE   hParser = NULL ;

        //  how large should pwDLLQualifiedName be???

        pathlen = wcslen(ptstrDataFilename) ;
        namelen =  pathlen + wcslen(pwstrDLLname)  + 1;

        if(!(pwDLLQualifiedName = (PWSTR)MemAllocZ(namelen * sizeof(WCHAR)) ))
        {
            ERR(("Fatal: unable to alloc memory for pwDLLQualifiedName: %d WCHARs.\n",
                namelen));
            return(NULL) ;   // This is unrecoverable
        }



        wcsncpy(pwDLLQualifiedName, ptstrDataFilename , namelen);

        if (pwstrLastBackSlash = wcsrchr(pwDLLQualifiedName, TEXT('\\')))
        {
            *(pwstrLastBackSlash + 1) = NUL;


            wcscat(pwDLLQualifiedName, pwstrDLLname) ;

            hParser = LoadLibrary(pwDLLQualifiedName) ;
            if(hParser)
                pfBcreateGPDbinary = (PFBCREATEGPDBINARY)GetProcAddress(hParser, "BcreateGPDbinary") ;
            else
                ERR(("Couldn't load gpdparse.dll: %S\n", pwDLLQualifiedName)) ;

            if(pfBcreateGPDbinary)
                (VOID) pfBcreateGPDbinary(ptstrDataFilename, 0) ;
                        // 0 = min Verbosity Level

            if(hParser)
                FreeLibrary(hParser) ;

            pnRawData = GpdLoadCachedBinaryData(ptstrDataFilename) ;
        }

        if(pwDLLQualifiedName)
            MemFree(pwDLLQualifiedName) ;

        #endif  PARSERLIB
        #endif  KERNEL_MODE
    }
    if(!pnRawData)
    {
        //  there is nothing I can do about this now.
        ERR(("Unable to locate or create Binary data.\n"));
        SetLastError(ERROR_FILE_CORRUPT);
        return NULL;
    }

    pStatic = (PSTATICFIELDS)pnRawData ;

    /*  BETA2  */
//    pmrbd->rbd.pvReserved = NULL;  Do when creating BUD file.
    pStatic->pdwSizeOption = NULL ;
    pStatic->ssTableIndex  = NULL ;
    pStatic->snapShotTable = NULL ;

    //  Call initialization functions to setup a few tables
    //  needed to create snapshots.

    if(BinitSizeOptionTables((PBYTE)pnRawData)  &&
        (dwI = DwInitSnapShotTable1((PBYTE)pnRawData) )  &&
        (dwI = DwInitSnapShotTable2((PBYTE)pnRawData, dwI) )  &&
        (dwI < MAX_SNAPSHOT_ELEMENTS)  &&
        BinitSnapShotIndexTable((PBYTE)pnRawData)  )
    {
        return (pnRawData);
    }
    if(dwI >= MAX_SNAPSHOT_ELEMENTS)
        RIP(("Too many entries to fit inside SnapShotTable\n"));

    UnloadRawBinaryData (pnRawData) ;
    return (NULL);  // failure
}

PRAWBINARYDATA
GpdLoadCachedBinaryData(
    PTSTR   ptstrGpdFilename
    )

/*++

Routine Description:

    Load cached binary GPD data file into memory

Arguments:

    ptstrGpdFilename - Specifies the GPD filename

Return Value:

    Pointer to Binary GPD data if successful, NULL if there is an error
    BETA2  returns pointer to pStatic.

--*/

{
    HFILEMAP        hFileMap;
    DWORD           dwSize;
    PVOID           pvData;
    PTSTR           ptstrBpdFilename;
    PRAWBINARYDATA  pRawData ;
    PSTATICFIELDS   pstaticData = NULL;
//    PMINIRAWBINARYDATA pmrbd  ;


    //
    // Generate BPD filename from the specified PPD filename
    //

    if (! (ptstrBpdFilename = pwstrGenerateGPDfilename(ptstrGpdFilename)))
        return NULL;

    //
    // First map the data file into memory
    //

    if (! (hFileMap = MapFileIntoMemory(ptstrBpdFilename, &pvData, &dwSize)))
    {
        //  ERR(("Couldn't map file '%ws' into memory: %d\n", ptstrBpdFilename, GetLastError()));
        MemFree(ptstrBpdFilename);
        return NULL;
    }

    //
    // Verify size, parser version number, and signature.
    // Allocate a memory buffer and copy data into it.
    //

    pRawData = pvData;
//    pmrbd = (PMINIRAWBINARYDATA)pRawData ;
    pstaticData = NULL;

    if ((dwSize > sizeof(PMINIRAWBINARYDATA) +
        sizeof(ENHARRAYREF) * MTI_NUM_SAVED_OBJECTS) &&
        (dwSize >= pRawData->dwFileSize) &&
        (pRawData->dwParserVersion == GPD_PARSER_VERSION) &&
        (pRawData->dwParserSignature == GPD_PARSER_SIGNATURE) &&
        (BIsRawBinaryDataInDate((PBYTE)pRawData)) &&
        (pstaticData = MemAlloc(sizeof(STATICFIELDS))))
    {
        CopyMemory(&(pstaticData->rbd), pRawData, sizeof(RAWBINARYDATA));
            // copy only the first structure of the BUD file.
        pstaticData->hFileMap = hFileMap ;
        pstaticData->pubBUDData = (PBYTE)pRawData ;            //  BETA2
            //  this points to the entire BUD file.
    }
    else
    {
        ERR(("Invalid binary GPD data\n"));   // warning
        SetLastError(ERROR_INVALID_DATA);
        UnmapFileFromMemory(hFileMap);          //  BETA2
        MemFree(ptstrBpdFilename);
        return(NULL) ;  //  fatal error.
    }

    MemFree(ptstrBpdFilename);

    return &(pstaticData->rbd);   //  BETA2
}



VOID
UnloadRawBinaryData (
    IN PRAWBINARYDATA   pnRawData
)
{
    PSTATICFIELDS   pStatic ;
//    PMINIRAWBINARYDATA pmrbd  ;

//    pmrbd = (PMINIRAWBINARYDATA)pRawData ;
    pStatic = (PSTATICFIELDS)pnRawData ;

    if(!pnRawData)
    {
        ERR(("GpdUnloadRawBinaryData given Null ptr.\n"));
        return ;
    }

    if(pStatic->pdwSizeOption)
        MemFree(pStatic->pdwSizeOption);
    if(pStatic->ssTableIndex)
        MemFree(pStatic->ssTableIndex);
    if(pStatic->snapShotTable)
        MemFree(pStatic->snapShotTable);
    UnmapFileFromMemory(pStatic->hFileMap);          //  BETA2

    MemFree(pnRawData);
}


PINFOHEADER
InitBinaryData(
    IN PRAWBINARYDATA   pnRawData,        // actually pStatic
    IN PINFOHEADER      pInfoHdr,
    IN POPTSELECT       pOptions
    )
{
    BOOL   bDeleteOptArray = FALSE ;

    if(pInfoHdr)
    {
        FreeBinaryData(pInfoHdr) ;
        //  there's no advantage to keeping the block
        //  if we are going to reinitialize everything.
        //  eventually we can optimize.
    }
    if(!pOptions) // if not passed from UI
    {
        bDeleteOptArray = TRUE ;

        pOptions = (POPTSELECT)MemAlloc(sizeof(OPTSELECT) * MAX_COMBINED_OPTIONS) ;
        if(!pOptions  ||
            !BinitDefaultOptionArray(pOptions, (PBYTE)pnRawData))
        {
            if(pOptions)
                MemFree(pOptions);
            return(NULL);  // Bummer, you lose any pInfoHdr you passed in.
        }
    }

    pInfoHdr = PINFOHDRcreateSnapshot((PBYTE)pnRawData, pOptions) ;

    if(bDeleteOptArray  &&  pOptions)
        MemFree(pOptions);

    return( pInfoHdr );
}


VOID
FreeBinaryData(
    IN PINFOHEADER pInfoHdr
    )
{
    if(pInfoHdr)
        MemFree(pInfoHdr);
}


BOOL    BIsRawBinaryDataInDate(
IN  PBYTE   pubRaw)   // this is pointer to memory mapped file! BETA2
{
#ifdef  KERNEL_MODE

    return(TRUE);

#else   // !KERNEL_MODE

    PENHARRAYREF   pearTableContents ;
    PGPDFILEDATEINFO    pfdi ;
    DWORD   dwNumFiles, dwI ;
    BOOL    bInDate ;
    PBYTE   pubHeap ;
    PWSTR   pwstrFileName ;
    FILETIME        FileTime;
    HANDLE          hFile;

    pearTableContents = (PENHARRAYREF)(pubRaw + sizeof(MINIRAWBINARYDATA)) ;
    pubHeap  = pubRaw + pearTableContents[MTI_STRINGHEAP].loOffset  ;

    dwNumFiles = pearTableContents[MTI_GPDFILEDATEINFO].dwCount  ;

    pfdi = (PGPDFILEDATEINFO)(pubRaw + pearTableContents[MTI_GPDFILEDATEINFO].
                                loOffset) ;

    for(dwI = 0 ; dwI < dwNumFiles ; dwI++)
    {
        pwstrFileName = OFFSET_TO_POINTER(pubHeap, pfdi[dwI].arFileName.loOffset);
        bInDate = FALSE ;

        hFile  = CreateFile(pwstrFileName,
                    GENERIC_READ,
                    FILE_SHARE_READ,
                    NULL,
                    OPEN_EXISTING,
                    FILE_ATTRIBUTE_NORMAL,
                    NULL);

        if (hFile != INVALID_HANDLE_VALUE)
        {
            if (GetFileTime(hFile, NULL, NULL, &FileTime))
                bInDate = (CompareFileTime(&FileTime, &pfdi[dwI].FileTime) == 0 ) ;
            else
                ERR(("GetFileTime '%S' failed.\n", pwstrFileName));

            CloseHandle(hFile);
        }
        else {
            ERR(("CreateFile '%S' failed.\n", pwstrFileName));
        }

        if(!bInDate)
        {
            ERR(("Raw binary data file is out-of-date.\n"));
            return(FALSE) ;
        }
    }
    return(TRUE);

#endif  // !KERNEL_MODE
}



// Puts the Index of Feature Locale(if present) in *pdwFea and returns TRUE.
// If Locale not present returns TRUE and puts -1 in *pdwFea.
// Any other processing error, returns FALSE.

BOOL BgetLocFeaIndex (
    IN PRAWBINARYDATA   pnRawData,
    OUT PDWORD          pdwFea  // The index of the Locale feature
 )
{

    DWORD               dwNumFeatures,        // Total Number of features
                        dwHeapOffset;
    BOOL                bStatus = TRUE; // Warning!!!!!!.
                                        // Dont remove initialization.
    PBYTE               pubSrc,
                        pubRaw,
                        pubResourceData;

    ATREEREF            atrLocKW;
    PDFEATURE_OPTIONS   pfoSrc;
    PENHARRAYREF        pearTableContents;


    // At this point we only have the raw data which is a big structure
    // with arrays, trees etc. Function PINFOHDRcreateSnapshota()
    // goes through all the Raw Data and extracts info into well defined
    // structures from where it is easy to get the required information.
    // Unfortunately when this function is called, PINFOHDRcreateSnapshot()
    // has not been called earlier, so we are left with getting our hands
    // dirty with the raw data.
    // Since it does make sense to go through the entire raw data just to
    // get the small info that we want, we will attempt to navigate only
    // certain areas.

    pubRaw  = ((PSTATICFIELDS)pnRawData)->pubBUDData;

    pearTableContents = (PENHARRAYREF)(pubRaw + sizeof(MINIRAWBINARYDATA)) ;
    pubResourceData   = pubRaw + pearTableContents[MTI_STRINGHEAP].loOffset;

    pfoSrc            = (PDFEATURE_OPTIONS)(pubRaw +
                            pearTableContents[MTI_DFEATURE_OPTIONS].loOffset);

    dwNumFeatures     = pearTableContents[MTI_DFEATURE_OPTIONS].dwCount  ;
//    dwNumFeatures    += pearTableContents[MTI_SYNTHESIZED_FEATURES].dwCount  ;

    if(dwNumFeatures > MAX_COMBINED_OPTIONS)
        return FALSE;  // too many


    for ( *pdwFea = 0; bStatus && (*pdwFea < dwNumFeatures); (*pdwFea)++)
    {
        atrLocKW  = pfoSrc[*pdwFea].atrFeaKeyWord;

        if ( atrLocKW & ATTRIB_HEAP_VALUE)
        {
            // Get a pointer to the ARRAYREF structure that holds the
            // heap offset of the real string.
            pubSrc = (pubResourceData + (atrLocKW & ~ATTRIB_HEAP_VALUE));
            dwHeapOffset = *((PDWORD)&(((PARRAYREF)pubSrc)->loOffset));

        }
        else
        {

            // It can come here either
            // if (atrRoot == ATTRIB_UNINITIALIZED
            //      For a *Feature: <symbolname> to appear
            //      without <symbolname> is a syntactic error.
            //      Has to be caught earlier.
            // or if
            //     patt[dwNodeIndex].dwFeature == DEFAULT_INIT)
            // or if it points to another node.
            // These should never happen.


            // Feature keyword not initialized. Serious Problem.
            // Should have been caught in the parsing stage. Cannot continue.

            ERR(("Feature Symbol Name cannot be determined\n"));
            bStatus = FALSE;
        }
        if ( bStatus && !strncmp(LOCALE_KEYWORD,
              (LPSTR)OFFSET_TO_POINTER(pubResourceData, dwHeapOffset),
              strlen(LOCALE_KEYWORD) ) )
        {
            // FOUND.... Locale.
            break;
        }

    }  //for *pdwFea

    if (bStatus && *pdwFea == dwNumFeatures)
    {
        //Feature Locale does not appear in the GPD. Nothing to do.
       *pdwFea = (DWORD)-1;
    }

    return bStatus;

} //BgetLocFeaIndex(...)


/*++

    Returns FALSE if some processing error occurs.
    If TRUE is returned then
        i)   if dwFea = -1  --> *Feature:Locale not found.
        ii)  if dwFea != -1 but dwOptIndex = -1,  --> None of the options
             match system locale. OR for some reason we have not been
             able to determine default option. The calling function may
             handle whatever way it wants.
        iii) if neither dwFea nor dwOptIndex is -1 --> Locale feature and
             matching option index found.

    1) Check if Locale keyword appears in the .gpd. If no, return. No action is
        required. This process also gets the Index of the Locale feature
        if present,
    2) query the SystemDefaultLCID. Reason: We want to see which Locale
        option in .gpd matches the SystemLCID.
    3) Go through the option array of the Locale feature and get the Index of
        the option that has OptionId = SystemDefaultCodePage.
        IMPORTANT assumption here is that only one Option will match
        the system LCID. Multiple matching option will result in
        great ambiguity.
    4) If option not present in GPD, do nothing. return quietly.
--*/
BOOL BgetLocFeaOptIndex(
    IN     PRAWBINARYDATA   pnRawData,
       OUT PDWORD           pdwFea,      // Assuming space already allocated.
       OUT PDWORD           pdwOptIndex  // Assuming space already allocated.
    )

{
    DWORD           dwNumFeatures,  // Total features
                    dwNumOptions,   // Total number of options for a feature.
                                    // dwOptionID
                    dwValue;        //

    ATREEREF        atrOptIDRoot,   // Root of OptionID attrib tree.
                                    // The OptionID (which is = the LCID)
                                    // is determined by following tree rooted
                                    // at atrOptIDRoot
                    atrOptIDNode;   // The heap pointer ( leaf of the tree).
    LCID            lcidSystemLocale; // The System locale


    PENHARRAYREF        pearTableContents;
    PBYTE               pubnRaw,
                        pubRaw;
    PDFEATURE_OPTIONS   pfo;
    PBYTE               pubHeap;
    PATTRIB_TREE        patt;

    pubRaw  = ((PSTATICFIELDS)pnRawData)->pubBUDData;

    pearTableContents = (PENHARRAYREF)(pubRaw + sizeof(MINIRAWBINARYDATA)) ;


    pfo = (PDFEATURE_OPTIONS) (pubRaw +
                        pearTableContents[MTI_DFEATURE_OPTIONS].loOffset);

    // 1. Extract index of feature locale from raw data
    if ( !BgetLocFeaIndex(pnRawData, pdwFea))
        return FALSE; //Big Time Error.

    if (*pdwFea == -1) {
        return TRUE; //indicates nothing to do. For reasons go into the
                     // function dwGetLocFeaIndex
    }

    lcidSystemLocale = LOCALE_SYSTEM_DEFAULT;

    #ifndef WINNT_40
    // 2) Determine the locale(LCID) and put it in lcidSystemLocale
    if ( ! (lcidSystemLocale = GetSystemDefaultLCID() ) )
    {
        ERR(("Cannot determine System locale\n") );

        *pdwOptIndex = (DWORD)-1; //No matching option found.
        return TRUE;
    }
    #endif //ifndef WINNT_40

    // 3. Get Index (dwOptIndex) of Option whose OptionID = lcidSystemLocale


    patt = (PATTRIB_TREE)(pubRaw + pearTableContents[MTI_ATTRIBTREE].
                        loOffset) ;

    pubHeap = (PBYTE)(pubRaw + pearTableContents[MTI_STRINGHEAP].
                        loOffset) ;

    // Pointer to root of atrOptIdvalue tree (or list)
    atrOptIDRoot = pfo[*pdwFea].atrOptIDvalue;
    if(atrOptIDRoot == ATTRIB_UNINITIALIZED)
    {
        // GPD is coded incorrectly though it may be correct syntactically.
        // The reason for the error is :
        // Every option for the Locale Feature
        // has to have an OptionID that matches the LCID values as
        // specified in Win32. If *OptionID field does not appear in
        // the Option construct, it is an inexcusable error.
        // Instead of failing, let us just indicate that we have not been
        // able to determine the default option i.e. *pdwOptIndex = -1.

        *pdwOptIndex = (DWORD)-1;
        return TRUE; // or should it be FALSE

    }

    else if (atrOptIDRoot & ATTRIB_HEAP_VALUE)
    {
        // It cannot appear here.
        // Because *OptionID is ATT_LOCAL_OPTION_ONLY
        // Instead of failing, let us prefer to continue
        ERR(("OptionID for Feature Locale cannot be determined\n"));
        *pdwOptIndex = (DWORD)-1;
        return TRUE;
    }

    else if (patt[atrOptIDRoot].dwFeature == DEFAULT_INIT)
    {
        if ( patt[atrOptIDRoot].dwNext == END_OF_LIST)
        {
            *pdwOptIndex = (DWORD)-1;
            return TRUE;
        }

        atrOptIDRoot = patt[atrOptIDRoot].dwNext ;  // to the next node.
    }

    for(; atrOptIDRoot != END_OF_LIST;
                     atrOptIDRoot = patt[atrOptIDRoot].dwNext)
    {
        // Should not be anything else.
        if( patt[atrOptIDRoot].eOffsetMeans == VALUE_AT_HEAP)
        {
            atrOptIDNode = patt[atrOptIDRoot].dwOffset;
            dwValue = *(PDWORD)(pubHeap + atrOptIDNode );
            if (dwValue == (DWORD)lcidSystemLocale)
               // Found the option with matching LCID
            {
                *pdwOptIndex = patt[atrOptIDRoot].dwOption;
                break;
            }

        } //if
        else
        {
            ERR(("OptionID for Feature Locale cannot be determined\n"));
            *pdwOptIndex = (DWORD)-1;
            return TRUE;
        }
    } // for

    // 4. Option not present in GPD i.e. Matching locale not found
    //    Let the default as specified in GPD continue as default.

    if ( atrOptIDRoot == END_OF_LIST)
    {
        *pdwOptIndex = (DWORD)-1;

    }

    return TRUE;

} //BgetLocFeaOptIndex


#endif  PARSERDLL

BOOL   BfindMatchingOrDefaultNode(
IN  PATTRIB_TREE    patt ,  // start of ATTRIBUTE tree array.
IN  OUT  PDWORD  pdwNodeIndex,  // Points to first node in chain
IN  DWORD   dwOptionID     //  may even take on the value DEFAULT_INIT
)
/*  caller passes a NodeIndex that points to the first node in
    a horizontal (option) chain.  Caller finds via optionarray
    the corresponding dwOption that is associated with this
    feature.
    search horizontally along the tree searching for a matching
    option.  If found, return the index of that node, else see
    if there is a default initializer node at the end of the chain.
*/
{
    for(   ; FOREVER ; )
    {
        if(patt[*pdwNodeIndex].dwOption == dwOptionID )
        {
            //  we found it!
            return(TRUE) ;
        }
        if(patt[*pdwNodeIndex].dwNext == END_OF_LIST)
        {
            if(patt[*pdwNodeIndex].dwOption == DEFAULT_INIT )
                return(TRUE) ;
            return(FALSE) ;
        }
        *pdwNodeIndex = patt[*pdwNodeIndex].dwNext ;
    }
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\parsers\gpd\parser.c ===
notes:

identify functions that can be used in both
user mode and km  to perform
   memory mapped file read, write
   memory allocation
      what is memory scheme used by NT?
      how do you realloc memory and still retain
      the same starting address if all memory segments share
      the linear address space?

      use HeapAlloc?  Cannot use virtualalloc()

      just so I can start writing code assume:

      base_pointer = VirtualAlloc(NULL, max_size_in_bytes, MEM_RESERVE,
         PAGE_NOACCESS) ;
      pointer = VirtualAlloc(base_pointer, size_needed_in_bytes, MEM_COMMIT,
         PAGE_READWRITE) ;
      as you need more memory, just commit more and more until
         max_size is reached.
      VirtualFree(pointer)

Set up build env to create dll, make file, dependencies
etc.

----
typedef  struct
{
}  GPD, *PGPD;  // structure containing raw GPD data

/* ----
 *  new prefixes:
 *      gpd: a GPD structure
 *      pgpd:  ptr to GPD structure
 */


allocate memory for all scaffold structures.
Allocate more memory than the structure will need since
reallocation may be impossible.  All structures may be
carved from one gigantic block of memory.

Initialize a master table to keep track of all structures.
The master table is an array of entries of the form:

struct  _MASTER_TABLE_ENTRY
{
    PBYTE  pubStruct ;  // address of element zero of array
    DWORD  dwArraySize ;  // number of elements that can fit into memory
                //  set to MAX_SYMBOLNODES for [SYMBOLTREE]
    DWORD   dwCurIndex ;  //  points to first uninitialized element
    DWORD   dwElementSiz ;  // size of each element in array.
}  MASTERTABENTRY ;

all offsets are to each individual array.  There is no
master offset.

MASTERTAB_ENTRY   gMasterTable[MTI_MAX_ENTRIES] ;

Bufffers needed for:

typedef enum
{
    MTI_SOURCEBUFFER:  Source file (GPD  input stream)
        not sure how memory mapped files and recursive includes
        will alter this.
    MTI_STRINGHEAP:  String heap
    MTI_TOKENMAP:  tokenMap   large enough to hold an old and New copy!
    MTI_NEWTOKENMAP:  newtokenMap   (not a separate buffer from TOKENMAP -
        just points immediately after oldTokenMap).
    MTI_SYMBOLTREE:  symbolTree Array
    MTI_BLOCKMACROARRAY (one for Block and another for Value macros)
    MTI_DFEATURE_OPTIONS:  references a whole bunch of treeroots.
        should be initialized to ATTRIB_UNINITIALIZED values.
        SymbolID pointed to by dwFeatureSymbols contains largest
        array index appropriated.  We won't need to allocate
        more elements in the final array than this.
    MTI_TTFONTSUBTABLE:  array of arrayrefs and integers.
    MTI_GLOBALATTRIB:   structure holding value of global attributes.
    MTI_ATTRIBTREE:  array of ATTRIB_TREE structures.
    MTI_COMMANDTABLE:  array of PATREEREF (or DWORD indicies to COMMAND_ARRAY)
            // the size of this table is set by the number of
            // predefined Unidrv commands.
    MTI_COMMANDARRAY:  array of COMMAND structures.
            // size varies depending on number of commands and variants
            // defined in the GPD file.
    MTI_FONTCART:   array of FontCartridge structures - one per construct.
    MTI_LISTNODES:   array of LISTNODEs.
    MTI_MAX_ENTRIES:  Last entry.
}  MT_INDICIES ;


Note:  the prefix  MTI_ stands for MasterTableIndex, the
base portion of the name is the structure typedef.

BLOCKMACROARRAY  is an array of structs temporarily carved into
a buffer:
typedef  struct
{
    DWORD  tIndexID;  tokenindex where a macro ID value is stored
    DWORD  tIndexOpen;  index of open brace
    DWORD  tIndexClose;  index of closing brace
} BLOCKMACROARRAY ;



each dword contains the tokenIndex where a macro ID value is stored.
curBlockMacroArray points to the smallest index of the macroArray currently
uninitialized.   (initially  curBlockMacroArray = 0)

VALUEMACROARRAY  is an array of DWORDS holding a
    tokenindex where a valuemacro ID value is stored

MACROLEVELSTACK:   is operated as a two dword stack that saves the
values of curBlockMacroArray and curValueMacroArray , each time
a brace is encountered.

-------

increaseMacroLevel():   called in response to parsing open brace.
    Copy this entry to the newtokenarray .
    save the value of curBlockMacroArray and curValueMacroArray in the
    macrolevelstack.  we will use this later.
    check if this brace begins the definition of a blockmacro,
    this is easy to do.
    if( curBlockMacroArray  &&
        (BlockMacroArray[curBlockMacroArray - 1].tIndexOpen == -1))
    {
        yes, we are beginning a BlockMacro definition.
        record newtokenArray index of open brace entry in tIndexOpen.
        check to see tIndexOpen is one higher than tIndexID, else
        a syntax error needs to be flagged for this blockMacro.
    }

decreaseMacroLevel:  called in response to parsing close brace.
    temporarily save curBlockMacroArray and curValueMacroArray
    into temp vars largerBlockIndex and largerValueIndex.

    now pop the value of curBlockMacroArray and curValueMacroArray from the
    stack.
    locate all macros referenced in the macroarray (less than largerIndex,
    and greater than or equal to curMacroArray retrieved from stack)
    that are expired due to the change in level.  Delete their entries
    in the tokenmap by replacing their  tkKeyID by NULLKEY.  This
    will break the endless chain resulting when a macro defines another
    macro.

    Does this closing brace end a macro definition?
    if(MacroArray[curMacroArray - 1].tIndexClose == -1)   //yes
    {
        MacroArray[curMacroArray - 1].tIndexClose =
            location of } in newtokenArray;
    }
    Copy this entry to the newtokenarray .

----





The symbol tree is comprised of these nodes.  The symbol tree
organizes the symbol space into a hierarchy.  For each feature
symbol, there is a set of option symbols particular to that feature.
All symbol nodes are stored in one array.  Multiple trees may
exist in one array.   When the symboltree is frozen, it can be
optimized by restoring the tree as an array of (STRREFs+subSpaceIndex.
Where the symbolID serves as the index to the arrayref.
(+ symboltype offset)  The end of each symbol list may be signified by
a NULL arrayref.


typedef  struct
{
    ARRAYREF   arSymbolName;
    DWORD   dwSymbolID;    // has nothing to do with array of symbol structs.
            //  value begins at zero and is incremented to obtain
            //  next value.
    DWORD   dwNextSymbol;   // index to next element in this space.
    DWORD   dwSubSpaceIndex ;  // index to first element in new symbol space
            which exists within the catagory represented by this symbol.
            for example in the catagory represented by the
            symbol  PAPERSIZES:  we may have the subspace
            comprised of Letter, A4, Legal, etc.
}   SYMBOLNODE , * PSYMBOLNODE ;
//  assign this struct the type  'psn'


// ---- Global and state Variables ---- //
{
    // ---- Index in SYMBOLNODE array to each type of tree ---- //

    DWORD   gdwFeatureSymbols ;    // initially set to INVALID_INDEX
    DWORD   gdwFontCartSymbols ;
    DWORD   gdwTTFontSymbols ;
    DWORD   gdwBlockMacroSymbols ;
    DWORD   gdwValueMacroSymbols ;

    // ---- track value of curBlockMacroArray and curValueMacroArray ---- //

    DWORD   gdwCurBlockMacroArray ;   // initially set to zero.  First
    DWORD   gdwCurValueMacroArray ;   // writable slot in MacroArray.
    DWORD   gdwMacroLevelStackPtr ;   // Push: write values into
            // MacroLevelStack[MacroLevelStackPtr++]
            //  Pop: read values from
            // MacroLevelStack[--MacroLevelStackPtr]

}



typedef  struct _TOKENMAP
{
    DWORD  dwKeywordID ;  // index of entry in KeywordTable
    ABSARRAYREF  aarKeyword ; // points to keyword in the source file
    ABSARRAYREF  aarValue ;  // value associated with this keyword.
                        // an arrayref is needed if we store
                        // the value in the heap.
                        //  It also makes copying the string
                        // to another place easier.  No need to
                        // search for a linebreak char.  Just
                        // Copyn()  will do.
    DWORD   dwValue  ;  // interpretation of Value string - see flags.
         // maybe commandID, numerical value of constant, MacroID assigned
         // to MacroSymbol  ,  SymbolID  etc.

    DWFLAGS    dwFlags ;  // bitfield with the following flags
        //  TKMF_VALUE_SAVED     independently of the tokenmap.
        //  TKMF_COMMAND_SHORTCUT  only used when parsing commands.
        //  TKMF_INLINE_BLOCKMACROREF   need to know when resolving macros.
        //  TKMF_MACROREF    indicates a value macro reference that must be resolved
        //  TKMF_SYMBOLID  dwValue contains a symbolID.
        //  TKMF_SYMBOL_REGISTERED  set when the symbolID is registered.
        //  TKMF_EXTERN:  The extern Qualifier was prepended to the keyword
        //  and has now been truncated.

} TKMAP, *PTKMAP

special keywordIDs:

ID_NULLENTRY:  ignore this, either expired code, parsing error etc.
ID_UNRECOGNIZED:  conforms to correct syntax, but not in my keyword table.
    could be a keyword defined in a newer spec or name of valuemacro.
    other other OEM defined stuff.
ID_SYMBOL:  does not begin with * , but conforms to syntax
    for a symbol.
ID_EOF:  end of file - no more tokenMap entries

    -----------------------------------

During the parsing to create the token map we
a) replace all comments with spaces
b) replace consecutive linebreaks with spaces.
c) parse all mainkeywords and replace with keywordIDs
d) init pointers to keywords and arrayref to values
e) set appropriate flags.
f) register symbols.


// ---- note ---- //
    all functions parsing the input stream may indicate
    reaching EOB by returning NULL.   caller should check for
    NULL return value after calling these functions and
    react accordingly.
// -------------- //

BUG_BUG:  CreateTokenMap should note if
*Command is the short version.   If so
then 2nd pass (macroresolution) should
expand it so special case code is not needed.

PTKMAP  CreateTokenMap(
IN OUT  PBYTE  pubCur  // location within source to start parsing
)
{
    PBYTE  pubNewPos ;  // transient data.

    //  assume we are at parsing level 0  - outside of any
    //  contexts requiring a change of parsing rules.

    pubCur = PubEatWhite(pubCur) ;

    this function will move forward until the first non-whitespace
    or non-linebreak character is encountered.   Convert first
    occurances of consecutive linebreak chars to whitespace.
    (should this be done here?: convert linebreak+continuation
    to whitespace.)

    /*  PubEatComments(pubCur)  */

    if pubCur points to start of a valid comment, this function
    will advance until linebreak character is encountered.
    it will also completely consume the comment by replacing
    all the characters  with spaces.

    while((pubNewPos = PubEatComments(pubCur)) != pubCur)
    {
        pubCur = pubNewPos ;
        pubCur = PubEatWhite(pubCur) ;
    }

    at this point pubCur points to first non-WHITE char that
    is also not a comment.

    we expect to see {, } (braces)  or a valid keyword at this
    point.

    while(pubCur)
    {
        pubCur = dwIdentifyKeyword(pubCur, tkmap+i) ;


            this function does several things:
            'brackets' keyword to see if it is properly terminated with :
            and begins with * (if it is not a brace).
            performs table lookup to obtain the keywordID which is written
            to tkmap[i].dwKeywordID .
            Determines based on the keyword ID if next token represents
            another keyword (as is the case if keyword is a brace)
            or if it represents a value.  If its a keyword, assigns NULL
            to  arValue, else arValue points to first nonwhite char
            in value after the : delimiter.    This function treats
            the value as a black box.
            If the keyword happens to be a brace,  dwValue
            will hold the nesting level of the brace.
            This will allow very fast identification of scope.

            If the state machine is used at this point we can
            resolve attribute names.  Otherwise we scan only
            for non-attribute keywords and mark all other legally
            constructed keywords as UNRECOGNIZED.  However attributes
            prefaced with EXTERN_FEATURE or EXTERN_GLOBAL may be
            identified at this time.

            A second pass using the state machine then applies the
            proper attribute namespace and resolves all UNRECOGNIZED
            keywords.   All remaining unrecognized keywords produce
            a warning message.

            Returns pubCur, which points to first char in the value or
            first char of next keyword if no value exists.

            Error handling:  calls a function WriteErrorMsg() to
            record any errors that it encounters.  may set dwKeywordID
            to ERROR, and set pubValue pointing to offending keyword,
            and return this value in pubCur.

        pubCur = scanOverValue(pubCur) ;
            init arValue, set dwFlags.
            Note:  lets parse the value only to reach the next
            keyword, not with the intent of saving the value
            somewhere.  This is because at this point we have
            no clue as to where the value should be
            saved to.  Wait for a subsequent pass to avoid
            cluttering the heap with data that will eventually
            be cubbyholed elsewhere.  There are a few execptions
            that will cause things to happen.  One is if the shortcut
            version of another construct is encountered, then
            we must expand this in the tokenMap so it looks like
            the full fledged version. On the other hand we may
            choose to defer the expansion till later, but we
            may flag this now.
            See *command  for an example.

            Also replace any occurances of linebreak + continuation
            char with spaces.

            Eat comments and white spaces until we reach beginning of
            a non-Null statement.
    }

    things that need to be done at some point
    in this function:

    lazy way to guard against useage of command shortcuts:
    when ever encountering a command keyword, leave
    the following entry unused. (mark it as NULL keyword)

    the Command name (the value portion)
    needs to be parsed and converted to a unidrv ID
    this may be placed in tokenmap.dwValue.
    set the flag TKMF_SYMBOL_REGISTERED.  This will
    prevent the value string from getting registered in a
    symbol table.
}


defineAndResolveMacros()
    this function scans through the tokenMap
    making a copy of the tokenMap without
    the macrodefinitions or references.  All references
    are replaced by the definitions inserted in-line!


{
    Can't store ValueMacro Definitions in scratch memory, they
    will actually be referenced directly if the value is not
    a string!

    initialize NEWTOKENMAP to refer to unused entries
    in TOKENMAP buffer.  We will create a new copy of
    the tokenmap here!

    1st pass:
    defineBlockMacroSymbols()
        search for all *BlockMacro keywords
        add macro symbol definitions
        to the symbol tree.  assign them
        an ordinal ID value 1, 2, 3, ...
        in this case, we may use the tree
        as a pure array of StringRefs.  with
        in index to the first uninitialized entry.
        write the macroID value into the tokenMap.dwValue.

    ScanForMacroReferences();

    walk through the old tokenMap one entry at a time.

    for (every entry in the tokenMap)
    {
        switch()
        {
            case (entry begins a block macrodef)
                copy token entry into new tokenMap
                record the new tokenIndex into
                BlockMacroArray[curBlockMacroArray]
                set  tIndexOpen and close to -1 to indicate
                not yet initialized.
                increment curBlockMacroArray.
                (all lines of macrodef are automatically copied over!)
            case (entry contains a block macroref)
                convert the symbolname to a macroID via
                the symboltree.  Search the BlockMacroArray entries
                from index curBlockMacroArray - 1 to zero
                using the first macroID that matches.

                copy all the valid tokenMap entries
                between BlockMacroArray[index].tIndexOpen
                and tIndexClose defined for the block macro
                referenced.   Avoid circular reference by ensuring
                tIndexClose != -1 for the selected macro.

            case (entry begins a value macrodef: *Macros)
                defineValueMacros()

            case (entry references a valuemacro)
                know by checking tokenMap.dwFlags = MACROREF.
                    dereferenceValueMacro()
            // sorry, cannot defer this since value macros
            // have a limited scope.  We must access the
            //  valueMacroArray at the time we see the reference
            // since valueMacroArray dynamically changes as we
            // encounter braces.

            case ({)  increment macro nesting level
                any macro defined within a macro  is undefined
                outside of that macro!

            case (})  decrease macro nesting level.

            default;  // all other entries
                copy to new tokenMap
        }
    }
    old tokenMap is now useless, its memory now lies fallow.
}

ScanForMacroReferences()
{
    may want to factor out common stuff.

    for (each entry in oldTokenMap)
    {
        if(entry does not define an macro nor is a brace char)
        {
            must scan all values for macroReference.
            if a non string value is expected, the = macroname
            must be the first and only entity comprising the value.
            If its a string, we must parse each construct!
            set flag in oldTokenMap.
            can share code used in defineValueMacros().
        }
    }
}

//  note:  all continuation chars have been replaced by spaces
//  previously at    scanOverValue()  time.

defineValueMacros(old, newtokenindex)
{
    this function is called upon encountering
    a *Macros: groupname   construct

    check to see there is an opening brace

    while(tokenArray[tokenindex].keywordID != closingBrace)
    {
        each entry up to the closing brace defines a
        value macro.

        register macroname in ValueMacroSymbols tree
        Store index to tokenArray in
        valueMacroArray

        maybe also valueMacroArray should
        have an arrayref


        1) we have no idea what value is being defined or how
            to properly parse for it.
            the value may reference another macro(s)

        so the only time we attempt parsing the value is
        if the value appears to be a string macro.   If at any time
        the parsing fails, the entire value is treated as a black box.

        Copy the entire value string (everything up to but NOT including the
        first linebreak char ) into the heap.  initialize an arrayref
        to access this string.

        the following portion is also common to   dereferenceValueMacro().
        and partly common to ScanForMacroReferences()

        Attempt to determine if the value in the heap is a string.
        If so
        {
            parse along the string until macro reference is found
            then lookup macroname in the valueMacroArray,
            see how many bytes the macro contains and shift
            the remainder of the referencing macrostring to make
            room to insert the referenced macrostring.
            Copy the referenced macrostring in the space provided.
            Update the length of the referencing macrostring.
            repeat until no other macro references are found.
        }
        else
            do nothing special.

        store ref to string in heap inside tokenArray.arValue
    }
}


dereferenceValueMacro(index)
{
    may want to factor out common stuff.

    there is a macro reference in this statement since
    it is flagged in the tokenMap.


    if(valuetype for keywordID in the master keyword table != VALUE_COMMAND_INVOC
        or VALUE_STRING)
    {
        expect macroref to be the first and only thing you
        encounter.

        convert macroref to macroID.
        lookup macroID in valueMacroArray.
        for(i = curValueMacroIndex  ; i ; i--)
        {
            if(tokenMap[valueMacroArray[i - 1]].dwValue == macroID)
                break;  // p
        }
        If found, copy arrayref to value field which references Macro.

        tokenMap[index].arValue = tokenMap[valueMacroArray[i - 1]].arValue
    }
    else //  valueMacro occurs in a string.
    {
        Copy the entire value string (everything up to but NOT including the
        first linebreak char ) into the heap.
        parse along the string until macro reference is found
        then lookup macroname in the valueMacroArray,
        see how many bytes the macro contains and shift
        the remainder of the referencing macrostring to make
        room to insert the referenced macrostring.
        Copy the referenced macrostring in the space provided.
        Update the length of the referencing macrostring.
        repeat until no other macro references are found.
        Copy updated arrayref to value field in tokenMap.
    }
}


defineSymbols(tokenMap)       ???
{
    Note:  All Macro symbols have been processed
    by the time this function is called.

    Scans down tokenMap looking for
    Feature:,   Font:   keywordIDs
    and adding their symbol definitions to
    the symbol tree.    This portion may be common to
     register macroname in ValueMacroSymbols tree
     part of   defineValueMacros()  and defineBlockMacroSymbols()



    then rescans (or in the same pass)
    the tokenMap keeping track of
    which Feature we are in, so when an Option
    keyword is encountered, we know which Feature symbol
    to associate the option symbol with.   If an option
    construct occurs outside of a Feature construct, we
    will know and can flag this as an error.

}


at this point only symbols defined by    Feature:,  BlockMacros:, Font:
are stored in the symbol tree.

processSymbolRefs(tokenMap)
{
    exactly which circustances may symbols appear outside of
    a value?   if they occur:  keywordID should indicate
    exactly what catagory of symbol and the symbolID.
    in the high and low word.

    replaces ptr to symbol values in source file
    with SymbolID value  or index to QualifiedName construct
    or index to List construct which contains SymbolID value
    or index to QualifiedName construct.   tokenMap will
    clearly identify which of the 4 cases applies.

    At this point identify long or short version of command.
    for short version,  dwKeyWordID = SHORTCMD | <COMMANDID> ;
    for long version :  dwKeywordID = LONGCMD ;
        and  Cmd  keyword  dwKeywordID = CMD
                            dwValue = <COMMANDID> ;
    Find and register dwKeywordID = SYMBOL in the appropriate
    symbol Tree.  Change dwKeywordID to (for example)
    TTFONTNAME | FONTNAMEID.

    At this point NO keywords should remain unrecognized.
}


main()
{
    PTKMAP  CreateTokenMap(
        at what point do we distinguish between
        shortcuts and non shortcut keywords?  do this
        soon, before BInterpretTokens()  is called.

    defineAndResolveMacros()
    defineSymbols(tokenMap) ;
        registers symbols for TTFontSubs?
    processSymbolRefs(tokenMap) ;??? not needed at this time?

    initStructures()  with default or failsafe values ;
        //  this is done after first pass and we know
        //  how many DFEATURE_OPTION structures to allocate.
        //  we will initialize all dword values to ATTRIB_UNINITIALIZED.
        //  this is essential!
        //  the GlobalAttribute structure.
    BInterpretTokens() ;
    checkStructures() to ensure failsafe values have
        been replaced - otherwise GPD file failed to
        initialize some mandatory field.

        verify that features that are referenced in switch
        statements are indeed PICKONE.  May force it to be
        and warn or fail.

        go through all allocated data structures ensuring
        that they all contain at least the minimum required
        fields.  Supply defaults for any omitted but required
        values.  raise warnings.  If a structure is fatally flawed,
        you may have to fatally error out.
    ConstructSeqCommandsArray() !
}


OpenIssues:

How to deal with TTFontSubs

*TTFontSubs: <On/Off>
{
    symbolKeyname1: <integer>
    symbolKeyname2: <integer>
    symbolKeyname3: <integer>
    ...
}

the On/Off part is handled by
                VsetbTTFontSubs(ptkmap->aarValue) ;

who handles the symbolKeywords?  what if some are repeated?
                ProcessSymbolKeyword(ptkmap + wEntry) ;

    Both are called from within   BInterpretTokens


// ---- tables of static data ---- //

// ---- The mainKeyword table ---- //

The mainKeyword Table is an array of
structures of the form:

typedef  struct
{
    PSTR        pstrKeyword ;  // keywordID is the index of this entry.
    DWORD       dwHashValue ;  // optional - implement as time permits.
    VALUE       eAllowedValue ;
    DWORD       flAgs ;
    TYPE        eType;   // may replace Type/Subtype with a function
    DWORD       dwSubType ;  // if there is minimal code duplication.
    DWORD       dwOffset ;  //  into appropriate struct for attributes only.
    //  the size   (num bytes to copy) of an attribute is easily determined
    //   from the AllowedValue field.
} KEYWORDTABLE_ENTRY;


global  KEYWORDTABLE_ENTRY  gMainKeywordTable[] =
{
    static initializers
}

typedef  enum
{
    TY_CONSTRUCT, TY_ATTRIBUTE, TY_SPECIAL
}   TYPE ;

typedef  enum
{
    SPCL_MEMCONFIGKB, SPCL_MEMCONFIGMB,
} SPECIAL ;  // special subtypes

typedef  enum
{
    ATT_GLOBAL_ONLY, ATT_GLOBAL_FREEFLOAT,
    ATT_LOCAL_FEATURE_ONLY,  ATT_LOCAL_FEATURE_FF ,
    ATT_LOCAL_OPTION_ONLY,  ATT_LOCAL_OPTION_FF ,
    ATT_LOCAL_COMMAND_ONLY,  ATT_LOCAL_FONTCART_ONLY,
    ATT_LOCAL_TTFONTSUBS_ONLY,  ATT_LOCAL_OEM_ONLY,
    ATT_LAST   // Must be last in list.
}   ATTRIBUTE ;  // subtype

typedef  enum
{
    CONSTRUCT_UIGROUP ,
    CONSTRUCT_FEATURE ,
    CONSTRUCT_OPTION ,
    CONSTRUCT_SWITCH,
    CONSTRUCT_CASE ,
    CONSTRUCT_DEFAULT ,
    CONSTRUCT_COMMAND ,
    CONSTRUCT_FONTCART ,
    CONSTRUCT_TTFONTSUBS ,
    CONSTRUCT_OEM ,
    CONSTRUCT_LAST,  // must end list of transition inducing constructs.
    // constructs below do not cause state transitions
    CONSTRUCT_BLOCKMACRO ,
    CONSTRUCT_MACROS,
    CONSTRUCT_OPENBRACE,
    CONSTRUCT_CLOSEBRACE,
}  CONSTRUCT ;      //  SubType if Type = CONSTRUCT

typedef  enum
{
    SPEC_CONSTR, SPEC_INS_CONSTR,
    SPEC_NOT_INS_CONSTR, SPEC_INVALID_COMBO, SPEC_INVALID_INS_COMBO,
    SPEC_MEM_CONFIG_KB, SPEC_MEM_CONFIG_MB, SPEC_FONT,
    SPEC_, SPEC_, SPEC_,
}   SPECIAL ;


typedef  enum
{
    NO_VALUE, VALUE_STRING, VALUE_COMMAND_INVOC,
    VALUE_SYMBOL_DEF,
    VALUE_SYMBOL_REF, VALUE_CONSTANT_catagory,
    VALUE_INTEGER, VALUE_POINT, VALUE_RECT,
    VALUE_BOOLEAN, VALUE_QUALIFIED_NAME,
    VALUE_MAX
}  VALUE ;

what does the parser expect after a keyword?

NO_VALUE : a linebreak OR  an effective linebreak:   ({)  or comment
VALUE_STRING: Quoted String, hexstring, string MACROREF,
    parameterless invocation.
VALUE_COMMAND_INVOC:  like VALUE_STRING but allowed to contain
    one or more parameter references.
VALUE_SYMBOL_DEF:  Symbol  definition - any value allowed

VALUE_SYMBOL_FIRST:    base of user-defined symbol catagory
VALUE_SYMBOL_FEATURES = VALUE_SYMBOL_FIRST + SCL_FEATURES :
VALUE_SYMBOL_FONTCART = VALUE_SYMBOL_FIRST + SCL_FONTCART :
VALUE_SYMBOL_BLOCKMACRO = VALUE_SYMBOL_FIRST + SCL_BLOCKMACRO :
VALUE_SYMBOL_VALUEMACRO = VALUE_SYMBOL_FIRST + SCL_VALUEMACRO :
VALUE_SYMBOL_OPTIONS = VALUE_SYMBOL_FIRST + SCL_OPTIONS :
VALUE_SYMBOL_LAST = VALUE_SYMBOL_FIRST + SCL_NUMSYMCLASSES - 1 :

VALUE_CONSTANT_FIRST:   base of enumeration catagory.
VALUE_CONSTANT_PRINTERTYPE = VALUE_CONSTANT_FIRST + CL_PRINTERTYPE ;
VALUE_CONSTANT_FEATURETYPE = VALUE_CONSTANT_FIRST + CL_FEATURETYPE ;
    lots of class types listed here
    ..........
VALUE_CONSTANT_LAST = VALUE_CONSTANT_FIRST + CL_NUMCLASSES - 1 ;
VALUE_INTEGER:  integer
VALUE_POINT:  point
VALUE_RECT:  rectangle
VALUE_BOOLEAN:  boolean.
VALUE_QUALIFIED_NAME:  Qualified name (one or more symbols separated by .)
VALUE_LIST:   no attribute actually is assigned this descriptor,
    // but used in the gValueToSize table.
VALUE_LARGEST:  not a real descriptor, but this position in the
    gValueToSize table  holds the largest of the above values.
VALUE_MAX:  number of elements in gValueToSize table.

-----
allowed values for KEYWORDTABLE_ENTRY.flAgs:

KWF_LIST:  the value may be a LIST containing one or more
    items of type AllowedValue.  The storage format
    must be of type LIST.  Only certain values may qualify
    for list format.
KWF_MACROREF_ALLOWED: since only a handful of keywords cannot accept
    macro references, it may be a waste of a flag, but reserve this
    to alert us that this special case must accounted for.
KWF_COMMAND:  This attribute is stored in a dedicated structure

KWF_FONTCART:  This attribute is stored in a dedicated structure
KWF_TTFONTSUBS:  This attribute is stored in a dedicated structure
KWF_OEM:  This attribute is stored in a dedicated structure


--------- special flag constructs ----

KWF_DEDICATED_FIELD = KWF_COMMAND | KWF_FONTCART |
    KWF_TTFONTSUBS | KWF_OEM

:  this indicates this attribute is stored
    in a dedicated structure, not in the heap.  As a result,
    the dwOffset field is  interpreted differently from attributes
    without this flag set.

-----

Notes:

the KeywordTable is partitioned into sections:
non-attribute Keywords
GlobalAttributes
FeatureAttributes
OptionAttributes
CommandAttributes
etc.
A range of indicies (min-max)
may be provided or a special flag
may denote the last entry in each section.
The separation exists because the same keyword may
exist in two different sections.
-----

command array:

just a list of command names and #defines giving the unidrv
value.  Use this table to assign each commandname a value.
CmdSelect is a special value -1!


typedef struct
{
    ARRAYREF  CommandName ;
    DWORD     UnidrvIndex ;  // #define  value assigned to command.
} CMD_TABLE ;

global  CommandTable[NUM_UNIDRV_CMDS] ;


------

Table to convert allowed values to sizes:

DWORD  gValueToSize[VALUE_MAX] ;   // size of various values in bytes

VinitValueToSize()
{
    // BUG_BUG!  assume array is zero initialized

    gValueToSize[VALUE_LARGEST] = 0 ;
    gValueToSize[NO_VALUE] = 0 ;
    gValueToSize[VALUE_BOOLEAN] = sizeof(BOOL) ; // etc
    gValueToSize[VALUE_RECT] = sizeof(RECT) ; // etc
    gValueToSize[VALUE_LIST] = sizeof(DWORD) ; // etc
        // only the index of first listnode is stored.


    for(i = 0 ; i < CL_NUMCLASSES ; i++)
        gValueToSize[VALUE_CONSTANT_FIRST + i] = sizeof(DWORD) ;

    for(i = 0 ; i < VALUE_MAX ; i++)
    {
        if (!gValueToSize[i])
            assert! ;  //  ensure table is fully initialized .
        if(gValueToSize[i] > gValueToSize[VALUE_LARGEST])
            gValueToSize[VALUE_LARGEST] = gValueToSize[i] ;
    }
}


-----

ensure all whitespaces are stripped before allowing token
to be registered, compared with etc.
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\parsers\gpd\sources.inc ===
!IF 0

Copyright (c) 1996 - 1999  Microsoft Corporation

Common sources shared by both um and km directory


!ENDIF

SOURCES=..\gpd.c
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\parsers\gpd\state2.c ===
//   Copyright (c) 1996-1999  Microsoft Corporation
/*  state2.c - create, manage the attribute tree   */


#include    "gpdparse.h"


// ----  functions defined in state2.c ---- //

BOOL  BprocessAttribute(
PTKMAP  ptkmap,   // pointer to tokenmap
PGLOBL  pglobl
) ;

BOOL   BstoreFontCartAttrib(
PTKMAP  ptkmap,   // pointer to tokenmap
PGLOBL  pglobl
) ;

BOOL   BstoreTTFontSubAttrib(
PTKMAP  ptkmap,   // pointer to tokenmap
PGLOBL  pglobl
) ;


BOOL   BstoreCommandAttrib(
PTKMAP  ptkmap,   // pointer to tokenmap
PGLOBL  pglobl
) ;

BOOL   BstoreFeatureOptionAttrib(
PTKMAP  ptkmap,   // pointer to tokenmap
PGLOBL  pglobl
) ;

BOOL  BstoreGlobalAttrib(
PTKMAP  ptkmap,   // pointer to tokenmap
PGLOBL  pglobl
) ;

BOOL    BaddBranchToTree(
PTKMAP      ptkmap,         // pointer to tokenmap
PATREEREF   patrAttribRoot,  //   pointer to dword with index
PGLOBL      pglobl
) ;

BOOL   BcreateGlobalInitializerNode(
PDWORD  pdwNodeIndex,
DWORD   dwOffset,
PGLOBL  pglobl) ;

BOOL   BcreateEndNode(
PDWORD  pdwNodeIndex,
DWORD   dwFeature,
DWORD   dwOption,
PGLOBL  pglobl
) ;

BOOL   BfindOrCreateMatchingNode(
IN  DWORD   dwRootNodeIndex , //  first node in chain matching feature
OUT PDWORD  pdwNodeIndex,     // points to node in chain also matching option
    DWORD   dwFeatureID,      //
    DWORD   dwOptionID,       //  may even take on the value DEFAULT_INIT
    PGLOBL  pglobl
) ;

BOOL   BfindMatchingNode(
IN  DWORD   dwRootNodeIndex ,  //  first node in chain matching feature
OUT PDWORD  pdwNodeIndex,  // points to node in chain also matching option
    DWORD   dwFeatureID,
    DWORD   dwOptionID,     //  may even take on the value DEFAULT_INIT
    PGLOBL  pglobl
) ;

BOOL BallocElementFromMasterTable(
MT_INDICIES  eMTIndex,   // select type of structure desired.
PDWORD       pdwNodeIndex,
PGLOBL       pglobl) ;

BOOL  BreturnElementFromMasterTable(
MT_INDICIES  eMTIndex,   // select type of structure desired.
DWORD        dwNodeIndex,
PGLOBL       pglobl) ;

BOOL    BconvertSymCmdIDtoUnidrvID(
IN  DWORD   dwCommandID , //  from RegisterSymbol
OUT PDWORD  pdwUnidrvID,
    PGLOBL  pglobl
) ;


// ---------------------------------------------------- //


BOOL  BprocessAttribute(
PTKMAP  ptkmap,   // pointer to tokenmap
PGLOBL  pglobl
)
{
    DWORD       dwKeywordID ;
    CONSTRUCT   eSubType ;
    BOOL        bStatus = FALSE ;
    STATE       stState;

    dwKeywordID = ptkmap->dwKeywordID ;

    eSubType = (ATTRIBUTE)(mMainKeywordTable[dwKeywordID].dwSubType) ;

    if(mdwCurStsPtr)
        stState = mpstsStateStack[mdwCurStsPtr - 1].stState ;
    else
        stState = STATE_ROOT ;

    if(!(gabAllowedAttributes[stState][eSubType]))
    {
        vIdentifySource(ptkmap, pglobl) ;
        ERR(("the Keyword %0.*s is not allowed within the state: %s\n",
            ptkmap->aarKeyword.dw, ptkmap->aarKeyword.pub,
            gpubStateNames[stState]));
        return(FALSE) ;
    }

    switch(eSubType)
    {
        case  ATT_GLOBAL_ONLY:
        case  ATT_GLOBAL_FREEFLOAT:
        {
            bStatus = BstoreGlobalAttrib(ptkmap, pglobl) ;
            break ;
        }
        case  ATT_LOCAL_FEATURE_ONLY:
        case  ATT_LOCAL_FEATURE_FF:
        case  ATT_LOCAL_OPTION_ONLY:
        case  ATT_LOCAL_OPTION_FF:
        {
            bStatus = BstoreFeatureOptionAttrib(ptkmap, pglobl) ;
            break ;
        }
        case  ATT_LOCAL_COMMAND_ONLY:
        {
            bStatus = BstoreCommandAttrib(ptkmap, pglobl) ;
            break ;
        }
        case  ATT_LOCAL_FONTCART_ONLY:
        {
            bStatus = BstoreFontCartAttrib(ptkmap, pglobl) ;
            break ;
        }
        case  ATT_LOCAL_TTFONTSUBS_ONLY:
        {
            bStatus = BstoreTTFontSubAttrib(ptkmap, pglobl) ;
            break ;
        }
        case  ATT_LOCAL_OEM_ONLY:
        default:
        {
            //  currently there are no dedicated keywords
            //  for these states.
            //  see  ProcessSymbolKeyword()  which is called elsewhere.
            break ;
        }
    }
    return(bStatus) ;
}





BOOL   BstoreFontCartAttrib(
PTKMAP  ptkmap,   // pointer to tokenmap
PGLOBL  pglobl
)
/*    assume the FontCartID is stored in the state stack
    whenever a FontCart construct is encountered.
    FontCart info is not multivalued.  Thus all binary
    info is stored directly into an array of fontcart
    structures indexed by FontCartID.
*/
{
    DWORD   dwFontCartID = INVALID_SYMBOLID ;
    DWORD    dwTstsInd, dwTstsInd2 ;
    STATE   stState ;

    for(dwTstsInd = 0 ; dwTstsInd < mdwCurStsPtr ; dwTstsInd++)
    {
        dwTstsInd2 = mdwCurStsPtr - (1 + dwTstsInd) ;
            //  this is the safe way of decrementing an unsigned index

        stState = mpstsStateStack[dwTstsInd2].stState ;

        if(stState == STATE_FONTCART)
        {
            dwFontCartID = mpstsStateStack[dwTstsInd2].dwSymbolID  ;
            break ;
            //  parser can't even recognize a fontcart attribute
            //  outside of STATE_FONTCART so this path is 100% certain
        }
    }
    if(dwFontCartID == INVALID_SYMBOLID)
    {
        //  BUG_BUG!  - what does this imply?  how could
        //  this situation occur?
        return(FALSE) ;
    }

    if (!BaddValueToHeap(&dwFontCartID,
        ptkmap, TRUE, pglobl))
    {
        return(FALSE) ;
    }
    return(TRUE) ;
}


BOOL   BstoreTTFontSubAttrib(
PTKMAP  ptkmap,  // pointer to tokenmap
PGLOBL  pglobl
)
/*    assume the TTFontSubID is stored in the state stack
    whenever a TTFontSub construct is encountered.
    TTFontSub info is not multivalued.  Thus all binary
    info is stored directly into an array of TTFontSub
    structures indexed by TTFontSubID.
*/
{
    DWORD   dwTTFSID = INVALID_SYMBOLID ;
    DWORD    dwTstsInd, dwTstsInd2 ;
    STATE   stState ;

    for(dwTstsInd = 0 ; dwTstsInd < mdwCurStsPtr ; dwTstsInd++)
    {
        dwTstsInd2 = mdwCurStsPtr - (1 + dwTstsInd) ;
            //  this is the safe way of decrementing an unsigned index

        stState = mpstsStateStack[dwTstsInd2].stState ;

        if(stState == STATE_TTFONTSUBS)
        {
            dwTTFSID = mpstsStateStack[dwTstsInd2].dwSymbolID  ;
            break ;
            //  parser can't even recognize a TTfontsub attribute
            //  outside of STATE_TTFONTSUBS so this path is 100% certain
        }
    }
    if(dwTTFSID == INVALID_SYMBOLID)
    {
        //  BUG_BUG!  - what does this imply?  how could
        //  this situation occur?
        return(FALSE) ;
    }

    if (!BaddValueToHeap(&dwTTFSID,
        ptkmap, TRUE, pglobl))
    {
        return(FALSE) ;
    }
    return(TRUE) ;
}





BOOL   BstoreCommandAttrib(
PTKMAP  ptkmap,   // pointer to tokenmap
PGLOBL  pglobl
)
/*   assume CreateTokenMap has parsed the CommandName
    (the value after the *Command keyword.) and converted
    it to a CommandID storing it in dwValue.

    further assume the CommandID is stored in the state stack
    whenever a COMMAND construct is encountered.
*/
{
    BOOL    bStatus = FALSE ;
    DWORD   dwCommandID = INVALID_SYMBOLID, dwUnidrvID  ;
            //  remember the CommandID is issued by the parser
            //  on a first come first served basis, the dwUnidrvID
            //  is predefined.
    DWORD    dwTstsInd, dwTstsInd2 ;  // temp state stack index
    STATE   stState ;
    PATREEREF  patr ;


    for(dwTstsInd = 0 ; dwTstsInd < mdwCurStsPtr ; dwTstsInd++)
    {
        dwTstsInd2 = mdwCurStsPtr - (1 + dwTstsInd) ;
            //  this is the safe way of decrementing an unsigned index

        stState = mpstsStateStack[dwTstsInd2].stState ;

        if(stState == STATE_COMMAND )
        {
            dwCommandID = mpstsStateStack[dwTstsInd2].dwSymbolID  ;
            break ;
            //  parser can't even recognize a command attribute
            //  outside of STATE_COMMAND so this path is 100% certain
        }
    }
    if(dwCommandID == INVALID_SYMBOLID)
    {
        vIdentifySource(ptkmap, pglobl) ;
        ERR(("Internal error: BstoreCommandAttrib - invalid CommandID.\n"));
        return(FALSE) ;
    }

    if(!BconvertSymCmdIDtoUnidrvID( dwCommandID , &dwUnidrvID, pglobl) )
    {
        vIdentifySource(ptkmap, pglobl) ;
        ERR(("unrecognized Unidrv command name: *%0.*s.\n",
            ptkmap->aarValue.dw,
            ptkmap->aarValue.pub));
        return(FALSE) ;
    }

    if(dwUnidrvID == CMD_SELECT)
    {
        PDFEATURE_OPTIONS   pfo ;
        DWORD   dwFeatureID ;

        for(dwTstsInd = 0 ; dwTstsInd < dwTstsInd2 ; dwTstsInd++)
        {
            stState = mpstsStateStack[dwTstsInd].stState ;
            if(stState == STATE_FEATURE )
            {
                BOOL    bInsideOpt ;

                dwFeatureID = mpstsStateStack[dwTstsInd].dwSymbolID  ;

                for(bInsideOpt = FALSE , dwTstsInd++ ; dwTstsInd < dwTstsInd2 ;
                    dwTstsInd++)
                {
                    stState = mpstsStateStack[dwTstsInd].stState ;
                    if(stState == STATE_OPTIONS )
                        bInsideOpt = TRUE ;
                }

                if(!bInsideOpt)
                    break ;  //  CmdSelect must reside within an option.

                pfo = (PDFEATURE_OPTIONS)
                    gMasterTable[MTI_DFEATURE_OPTIONS].pubStruct +
                    dwFeatureID ;

                bStatus = BaddBranchToTree(ptkmap, &(pfo->atrCommandIndex), pglobl) ;
                return(bStatus) ;
            }
        }
        vIdentifySource(ptkmap, pglobl) ;
        ERR(("syntax err: the CmdSelect specifier can only be used inside an Option construct.\n"));

        return(FALSE) ;
    }

    //  else  CommandID refers to a predefined Unidrv command.
    //  figure out address of command table.
    patr = (PATREEREF) gMasterTable[MTI_COMMANDTABLE].pubStruct ;
    bStatus = BaddBranchToTree(ptkmap,  patr + dwUnidrvID, pglobl) ;
    //  note: assumes commandtable is large enough.
    return(bStatus) ;
}



BOOL   BstoreFeatureOptionAttrib(
PTKMAP  ptkmap,   // pointer to tokenmap
PGLOBL  pglobl
)
/*  strange but true, since feature and option attributes
    share the same structure, they can use the same code!
    In fact LOCAL_FEATURES will end up single valued, and
    all OPTIONs will end up multivalued as planned!
*/
{
    BOOL    bStatus = FALSE ;
    PDFEATURE_OPTIONS   pfo ;
    DWORD   dwFeatureID ;
    DWORD    dwTstsInd ;  // temp state stack index
    STATE   stState ;
    DWORD   dwOffset;
    DWORD   dwKeywordID ;


    for(dwTstsInd = 0 ; dwTstsInd < mdwCurStsPtr ; dwTstsInd++)
    {
        stState = mpstsStateStack[dwTstsInd].stState ;
        if(stState == STATE_FEATURE )
        {
            dwFeatureID = mpstsStateStack[dwTstsInd].dwSymbolID  ;
            break ;
        }
    }
    ASSERT(dwTstsInd < mdwCurStsPtr);
    // paranoid  BUG_BUG:  what happens if we go through the entire
    // stack and never find a feature state?  this could only
    // happen via a coding error.  The process of creating the
    // token map uses the state to select the proper attribute
    // dictionary to be used to identify each unrecognized keyword.

    ASSERT(dwFeatureID < gMasterTable[MTI_DFEATURE_OPTIONS].dwArraySize);

    // paranoid  BUG_BUG:  may check to see if we allocated enough
    //  FeatureOptions
    //  if( dwFeatureID >= gMasterTable[MTI_DFEATURE_OPTIONS].dwArraySize )
    //      failure. - code error.

    //  just get address of structure holding attribute values.
    pfo = (PDFEATURE_OPTIONS) gMasterTable[MTI_DFEATURE_OPTIONS].pubStruct +
            dwFeatureID ;

    dwKeywordID = ptkmap->dwKeywordID ;
    dwOffset = mMainKeywordTable[dwKeywordID].dwOffset ;

    bStatus = BaddBranchToTree(ptkmap,  (PATREEREF)((PBYTE)pfo + dwOffset), pglobl) ;

    return(bStatus) ;
}


BOOL  BstoreGlobalAttrib(
PTKMAP  ptkmap,   // pointer to tokenmap
PGLOBL  pglobl
)
{
    BOOL    bStatus = FALSE ;
    PBYTE   pub ;
    DWORD   dwOffset;
    DWORD   dwKeywordID ;


    // BUG_BUG:  may check to see if this value is equal to 1:
    //  if( gMasterTable[MTI_GLOBALATTRIB].dwArraySize != 1)
    //      failure. - code error.
    //  a zero indicates no memory has yet been allocated.
    ASSERT( gMasterTable[MTI_GLOBALATTRIB].dwArraySize == 1) ;

    //  just get address of structure holding attribute values.
    pub =  gMasterTable[MTI_GLOBALATTRIB].pubStruct ;

    dwKeywordID = ptkmap->dwKeywordID ;
    dwOffset = mMainKeywordTable[dwKeywordID].dwOffset ;

    //  the location PATREEREF contains either the values offset
    //  in the heap or the index to the root of the attribute tree

    bStatus = BaddBranchToTree(ptkmap, (PATREEREF)(pub + dwOffset), pglobl) ;

    return(bStatus) ;
}






BOOL    BaddBranchToTree(
PTKMAP      ptkmap,   // pointer to tokenmap
PATREEREF   patrAttribRoot,  //   pointer to dword with index
                             //  of root to selected attribute value tree.
PGLOBL      pglobl
)

// create/expand attribute tree or overwrite node on existing tree
// If new branch is not compatible
// with existing tree, it is an error.  You may overwrite a node
// in the tree, but you may not alter the branches in the tree.
// in case of failure there will be 2 outcomes:
// a) the attribute tree is left unchanged.
// b) a new node is added, but is left uninitialized.
//    (atrAttribRoot == ATTRIB_UNINITIALIZED)     -or-
//    (patt[*pdwNodeIndex].eOffsetMeans == UNINITIALIZED)


//  algorithm: starting from index 0 walk up the state stack
//  recording symbolIDs until both a FeatureID and OptionID
//  has been collected.  This defines one segment of the
//  new branch that will be added to the tree.  Now walk
//  the tree to see if an identical branch exists.  If so
//  go there and go collect another FeatureID/OptionID pair
//  so we can repeat the process.  If such a segment does not
//  exist on the tree, create it.  When the stack is empty,
//  parse the value and store it on the new leaf node on the
//  tree.

//  In the simplest case, there are no feature/option pairs
//  on the stack.  This means we have a root level attribute,
//  which  just overwrite/creates the global initializer node.

//  If there is a feature/option pair on the stack we
//  enter a loop to process each feature/option pair.
//  the first pass of the loop handles the boundary conditions.
//  Here is where we need to deal with the special
//  cases of  patrAttribRoot referencing the heap
//  or the global initializer node.
//
//  I) patrAttribRoot contains node index
//      A) node is global default initializer
//          1) there is no sublevel.
//              create a new sublevel.
//              link global default initializer to sublevel
//          2) next points to a node (new sublevel)
//              go into new sublevel, now handle just like
//              case I.B).
//      B) node is normal
//          1) if node's Feature doesn't match FeatureID
//              the new branch is incompatible with the tree
//              abort.
//          2) Feature's match, search for matching option
//              a)  option found, drop to end of loop
//              b)  option not found, create new node at end
//                  i) previous node is a default initializer
//                      copy its contents to new node.
//                      initialize node just vacated to
//                      FeatureID, OptionID
//                  ii) initialize new node to
//                      FeatureID, OptionID
//  II) patrAttribRoot is uninitialized
//      create new sublevel
//      link patrAttribRoot to sublevel
//  III) patrAttribRoot pts to heap
//      create global initializer node
//      link heap to initializer node
//      create new sublevel
//      link initializer node to new sublevel
//
//
//
//   on each subsequent pass through the attribute tree/stack,
//      we attempt to enter the next sublevel, since
//      this is what corresponds to the new FeatureID/OptionID
//      pair retrieved from the stack.
//
//  I) there is a sublevel from this node
//      enter sublevel
//      1) if node's Feature doesn't match FeatureID
//          the new branch is incompatible with the tree
//          abort.
//      2) Feature's match, search for matching option
//          a)  option found, drop to end of loop
//          b)  option not found, create new node at end
//              i) previous node is a default initializer
//                  copy its contents to new node.
//                  initialize node just vacated to
//                  FeatureID, OptionID
//              ii) initialize new node to
//                  FeatureID, OptionID
//  II) there is no sublevel
//      1)  if the current node references a VALUE
//          create a new sublevel node (to be the default)
//          initialize it with the value from the
//          current node.
//          a)  if optionID is not DEFAULT_INIT
//              insert another node prior to
//              the default node just created.
//      2)  else current node is UNINITIALIZED.
//          create a new sublevel node.
//
//
//
{
    PATTRIB_TREE    patt ;  // start of ATTRIBUTE tree array.
    DWORD        dwTstsInd ;  // temp state stack index
    STATE   stState ;
    DWORD   dwFeatureID, dwOptionID ;
    DWORD  dwNodeIndex ;
    DWORD  dwPrevsNodeIndex ;  // will keep track
    //  of where we are as we navigate the tree.


    patt = (PATTRIB_TREE) gMasterTable[MTI_ATTRIBTREE].pubStruct ;
            //  determine this even though we may not use it.

    dwPrevsNodeIndex = END_OF_LIST ;  // first pass will go
    // through special initialization code.

    for(dwTstsInd = 0 ; dwTstsInd < mdwCurStsPtr ; dwTstsInd++)
    {
        //  BUG_BUG  paranoid:  code assumes state stack is
        //  well behaved as it should be if code is written
        //  correctly.  No safety checks here.
        //  any errors will cause failure further along.

        stState = mpstsStateStack[dwTstsInd].stState ;

        if(stState == STATE_FEATURE  ||
            stState == STATE_SWITCH_ROOT  ||
            stState == STATE_SWITCH_FEATURE  ||
            stState == STATE_SWITCH_OPTION)
        {
            dwFeatureID = mpstsStateStack[dwTstsInd].dwSymbolID  ;
            continue ;
        }
        if(stState == STATE_OPTIONS  ||
            stState == STATE_CASE_ROOT  ||
            stState == STATE_CASE_FEATURE  ||
            stState == STATE_CASE_OPTION)
        {
            dwOptionID = mpstsStateStack[dwTstsInd].dwSymbolID  ;
        }
        else if(stState == STATE_DEFAULT_ROOT  ||
            stState == STATE_DEFAULT_FEATURE  ||
            stState == STATE_DEFAULT_OPTION)
        {
            dwOptionID = DEFAULT_INIT ;
        }
        else
        {
            continue ;  // these states have no effect on the attrib tree
        }

        if(dwPrevsNodeIndex == END_OF_LIST)
        {
            //  first pass through the for loop
            //  process all special cases first time
            //  around.

            if(*patrAttribRoot == ATTRIB_UNINITIALIZED)  //  case II)
            {
                //  create a new tree consisting of one node .

                if(! BcreateEndNode(&dwNodeIndex, dwFeatureID,
                    dwOptionID, pglobl)  )
                {
                    return(FALSE) ;
                }

                *patrAttribRoot = dwNodeIndex ;  // Make this one node
                    //  the root of the tree.
                dwPrevsNodeIndex = dwNodeIndex ;
                continue ;  // ready for next level.
            }
            else if(*patrAttribRoot & ATTRIB_HEAP_VALUE)  // case III)
            {
                //  turn off heap flag to leave pure heap offset,
                //  then store heap offset into new Node.

                if(! BcreateGlobalInitializerNode(&dwNodeIndex,
                    *patrAttribRoot & ~ATTRIB_HEAP_VALUE, pglobl) )
                {
                    return(FALSE) ;
                }
                *patrAttribRoot = dwNodeIndex ;  // Make the global
                    //  initializer node the root of the new tree.

                dwPrevsNodeIndex = dwNodeIndex ;

                if(! BcreateEndNode(&dwNodeIndex, dwFeatureID,
                    dwOptionID, pglobl)  )    //  new sublevel node.
                {
                    return(FALSE) ;
                }
                patt[dwPrevsNodeIndex].dwNext = dwNodeIndex ;
                    //  global initializer node references sublevel node.

                dwPrevsNodeIndex = dwNodeIndex ;
                continue ;  // ready for next level.
            }
            else  //  case I)
            {

                dwNodeIndex = *patrAttribRoot ;

                if(patt[dwNodeIndex].dwFeature == DEFAULT_INIT ) // I.A)
                {
                    if(patt[dwNodeIndex].dwNext == END_OF_LIST) // I.A.1)
                    {
                        //  create a new sublevel
                        dwPrevsNodeIndex = dwNodeIndex ;
                            // hold global initializer in PrevsNode.

                        if(! BcreateEndNode(&dwNodeIndex, dwFeatureID,
                            dwOptionID, pglobl)  )
                        {
                            return(FALSE) ;
                        }

                        patt[dwPrevsNodeIndex].dwNext = dwNodeIndex ;
                            //  global initializer node references sublevel
                            //  node.
                        dwPrevsNodeIndex = dwNodeIndex ;
                        continue ;  // ready for next level.
                    }
                    else  //  I.A.2)
                    {
                        dwNodeIndex = patt[dwNodeIndex].dwNext ;
                        //  enter new sublevel and drop into
                        //  code path for case   I.B)
                    }
                }
                //  case I.B)
                if(!BfindOrCreateMatchingNode(dwNodeIndex, &dwNodeIndex,
                    dwFeatureID, dwOptionID, pglobl) )
                {
                    vIdentifySource(ptkmap, pglobl) ;
                    return(FALSE) ;
                }
                dwPrevsNodeIndex = dwNodeIndex ;   // goto end of loop.
                continue ;
            }
        }

        //  this is the generic case: dwPrevsNodeIndex points
        //  to a normal node and this node matched the
        //  feature/option from the previous pass.
        //  objective:  boldly attempt to enter the sublevel
        //  and see if there is something there that matches
        //  what we are seeking.

        if(patt[dwPrevsNodeIndex].eOffsetMeans == NEXT_FEATURE)
        {
            // Down to the next level we go.
            dwNodeIndex = patt[dwPrevsNodeIndex].dwOffset ;

            if(!BfindOrCreateMatchingNode(dwNodeIndex, &dwNodeIndex, dwFeatureID,
                dwOptionID, pglobl) )
            {
                vIdentifySource(ptkmap, pglobl) ;
                return(FALSE) ;
            }
            dwPrevsNodeIndex = dwNodeIndex ;   // goto end of loop.
        }
        else  //  must create a new sublevel now.
        {
            DWORD  dwDefaultNode = END_OF_LIST;

            //  OffsetMeans can be either VALUE or  UNINITIALIZED.
            if(patt[dwPrevsNodeIndex].eOffsetMeans == VALUE_AT_HEAP)
            {
                // create a default initializer node for the
                //  new sublevel.  Transfer heap offset from Prevs
                //  node into it.

                if(! BcreateEndNode(&dwNodeIndex, dwFeatureID,
                    DEFAULT_INIT, pglobl)  )
                {
                    return(FALSE) ;
                }
                patt[dwNodeIndex].eOffsetMeans = VALUE_AT_HEAP ;
                patt[dwNodeIndex].dwOffset =
                    patt[dwPrevsNodeIndex].dwOffset ;
                dwDefaultNode = dwNodeIndex ;  // remember this node
            }

            //  create first sublevel node with desired feature/option.

            if(dwDefaultNode == END_OF_LIST  ||
                dwOptionID != DEFAULT_INIT)
            {
                //  this means if a default initializer node
                //  was already created to propagate the value
                //  from the previous level AND  the new branch
                //  also specifies a default initializer node, there's
                //  no need to create a second initializer node.

                //  if this path is being executed, it means above
                //  statement is FALSE.

                if(! BcreateEndNode(&dwNodeIndex, dwFeatureID,
                    dwOptionID, pglobl) )
                {
                    return(FALSE) ;
                }
                patt[dwNodeIndex].dwNext = dwDefaultNode ;
            }

            patt[dwPrevsNodeIndex].eOffsetMeans = NEXT_FEATURE ;
            patt[dwPrevsNodeIndex].dwOffset = dwNodeIndex ;

            dwPrevsNodeIndex = dwNodeIndex ;  // goto end of loop.
        }
    }  //  end of for loop

    //  we have navigated to the end of the new branch.
    //  now parse the value, and store in binary form in the heap.
    //  if a previous VALUE existed, overwrite it on the heap,
    //  otherwise allocate fresh storage on the heap.

    if(dwPrevsNodeIndex != END_OF_LIST)  // there was branch in the stack.
    {
        if (patt[dwPrevsNodeIndex].eOffsetMeans == NEXT_FEATURE)
        {
            vIdentifySource(ptkmap, pglobl) ;
            ERR(("syntax error: attempt to truncate existing attribute tree.\n"));
            return(FALSE) ;
        }
        if (!BaddValueToHeap(&patt[dwPrevsNodeIndex].dwOffset,
            ptkmap, (patt[dwPrevsNodeIndex].eOffsetMeans == VALUE_AT_HEAP ), pglobl))
        {
            return(FALSE) ;
        }
        patt[dwPrevsNodeIndex].eOffsetMeans = VALUE_AT_HEAP ;
        //  if dwOffset was originally UNINITIALIZED, its not anymore.
    }
    else                //  attribute found at root level.
    {                   //  this means we update/create
                        //  the global default initializer.
        if(*patrAttribRoot == ATTRIB_UNINITIALIZED)
        {
            //  parse value token, add value (in binary form) into heap.
            if(! BaddValueToHeap((PDWORD)patrAttribRoot, ptkmap, FALSE, pglobl) )
            {
                //  BUG_BUG  what do we do if parsing or something happens?
                //      for now just return failure as is.  Lose one attribute.
                //      Sanity check later will determine if this
                //      omission is fatal.
                *patrAttribRoot = ATTRIB_UNINITIALIZED ;
                return(FALSE);
            }
            // returns offset in heap of parsed Value in patrAttribRoot
            *patrAttribRoot |= ATTRIB_HEAP_VALUE ;
        }
        else if(*patrAttribRoot & ATTRIB_HEAP_VALUE)
        {
            *patrAttribRoot &= ~ATTRIB_HEAP_VALUE ;
            //  turn off flag to leave pure heap offset.

            if(! BaddValueToHeap((PDWORD)patrAttribRoot, ptkmap, TRUE, pglobl) )
            {
                *patrAttribRoot |= ATTRIB_HEAP_VALUE ;
                return(FALSE);
            }
            *patrAttribRoot |= ATTRIB_HEAP_VALUE ;
        }
        else    // patrAttribRoot contains index of root of attribute tree.
        {

            //  does a global default initializer node exist?
            if(patt[*patrAttribRoot].dwFeature == DEFAULT_INIT)
            {
                if(! BaddValueToHeap(&patt[*patrAttribRoot].dwOffset,
                    ptkmap, TRUE, pglobl) )
                {
                    return(FALSE);
                }
            }
            else    //  if not, we need to create one.
            {
                if(! BcreateGlobalInitializerNode(&dwNodeIndex, 0, pglobl) )
                {
                    return(FALSE) ;
                }
                if (! BaddValueToHeap(&patt[dwNodeIndex].dwOffset,
                                                        ptkmap, FALSE, pglobl) )
                {
                    (VOID)BreturnElementFromMasterTable(MTI_ATTRIBTREE,
                        dwNodeIndex, pglobl);
                    return(FALSE) ;
                }

                patt[dwNodeIndex].dwNext = *patrAttribRoot ;

                *patrAttribRoot = dwNodeIndex ;  // Make the default
                    //  initializer the root of the tree.
            }
        }
    }
    return(TRUE) ;  // mission accomplished.
}

BOOL   BcreateGlobalInitializerNode(
PDWORD  pdwNodeIndex,
DWORD   dwOffset,  // caller can initialize this now.
PGLOBL  pglobl)
{
    PATTRIB_TREE    patt ;  // start of ATTRIBUTE tree array.
    patt = (PATTRIB_TREE) gMasterTable[MTI_ATTRIBTREE].pubStruct ;

    if(! BallocElementFromMasterTable(MTI_ATTRIBTREE ,
        pdwNodeIndex, pglobl ) )
    {
        return(FALSE) ;
    }
    patt[*pdwNodeIndex].dwFeature = DEFAULT_INIT ;
    //  don't care what dwOption says.
    patt[*pdwNodeIndex].eOffsetMeans = VALUE_AT_HEAP ;
    patt[*pdwNodeIndex].dwNext = END_OF_LIST ;
    patt[*pdwNodeIndex].dwOffset = dwOffset ;
    return(TRUE) ;
}

BOOL   BcreateEndNode(
PDWORD  pdwNodeIndex,
DWORD   dwFeature,
DWORD   dwOption,
PGLOBL  pglobl
)
{
    PATTRIB_TREE    patt ;  // start of ATTRIBUTE tree array.
    patt = (PATTRIB_TREE) gMasterTable[MTI_ATTRIBTREE].pubStruct ;

    if(! BallocElementFromMasterTable(MTI_ATTRIBTREE ,
        pdwNodeIndex, pglobl) )
    {
        return(FALSE) ;
    }
    patt[*pdwNodeIndex].dwFeature = dwFeature ;
    patt[*pdwNodeIndex].dwOption = dwOption ;
    patt[*pdwNodeIndex].eOffsetMeans = UNINITIALIZED ;
    patt[*pdwNodeIndex].dwNext = END_OF_LIST ;
    //  patt[*dwNodeIndex].dwOffset = not yet defined.
    return(TRUE) ;
}



BOOL   BfindOrCreateMatchingNode(
IN  DWORD   dwRootNodeIndex ,  //  first node in chain matching feature
OUT PDWORD  pdwNodeIndex,  // points to node in chain also matching option
    DWORD   dwFeatureID,   //
    DWORD   dwOptionID,     //  may even take on the value DEFAULT_INIT
    PGLOBL  pglobl
)
/*  caller passes a NodeIndex that points to the first node in
    a horizontal (option) chain.
    If the feature of the Node doesn't match dwFeature, this indicates
    the new branch caller is attempting to add is incompatible
    with the existing tree and an error results.   Otherwise,
    search horizontally along the tree searching for a matching
    option.  If found, return the index of that node, else
    must create one.  Make sure the default initializer node is
    always the last node in the chain.
*/
{
    PATTRIB_TREE    patt ;  // start of ATTRIBUTE tree array.
    DWORD           dwPrevsNodeIndex ;

    patt = (PATTRIB_TREE) gMasterTable[MTI_ATTRIBTREE].pubStruct ;

    if(patt[dwRootNodeIndex].dwFeature != dwFeatureID )
    {
        ERR(("BfindOrCreateMatchingNode: this branch conflicts with the existing tree \n"));
        //  and cannot be added.
        return(FALSE) ;
    }

    // Yes feature matches, search for matching option.

    *pdwNodeIndex = dwRootNodeIndex ;  // protects rootatr from
        // being overwritten.


    for(   ; FOREVER ; )
    {
        if(patt[*pdwNodeIndex].dwOption == dwOptionID )
        {
            //  we found it!
            return(TRUE) ;
        }
        if(patt[*pdwNodeIndex].dwNext == END_OF_LIST)
            break ;
        *pdwNodeIndex = patt[*pdwNodeIndex].dwNext ;
    }

    //  matching option not found
    //  create node, attach it to the end

    dwPrevsNodeIndex = *pdwNodeIndex ;  // last node in list.

    if(! BallocElementFromMasterTable(MTI_ATTRIBTREE ,
        pdwNodeIndex, pglobl) )
    {
        return(FALSE) ;
    }
    patt[*pdwNodeIndex].dwNext = END_OF_LIST ;
    patt[dwPrevsNodeIndex].dwNext = *pdwNodeIndex ;

    if(patt[dwPrevsNodeIndex].dwOption == DEFAULT_INIT)
    {
        // must copy default data to new node
        // the default initializer must remain at
        // the end of the list.
        patt[*pdwNodeIndex].dwOption =
            patt[dwPrevsNodeIndex].dwOption;
        patt[*pdwNodeIndex].dwOffset =
            patt[dwPrevsNodeIndex].dwOffset;
        patt[*pdwNodeIndex].dwFeature =
            patt[dwPrevsNodeIndex].dwFeature;
        patt[*pdwNodeIndex].eOffsetMeans =
            patt[dwPrevsNodeIndex].eOffsetMeans;
        *pdwNodeIndex = dwPrevsNodeIndex ;
        //  want new initialization to occur in
        //  second to last node.  How do you
        //  know dwOptionID isn't DEFAULT_INIT?
        //  simple because since a DEFAULT_INIT
        //  node does exist in the chain, the
        //  search would have found it and
        //  exited the function long before
        //  reaching this code.
    }

    //  initialize vacated or last node.

    patt[*pdwNodeIndex].dwOption = dwOptionID;
    patt[*pdwNodeIndex].dwFeature = dwFeatureID;
    patt[*pdwNodeIndex].eOffsetMeans = UNINITIALIZED ;
    //   patt[*pdwNodeIndex].dwOffset = don't know yet

    return(TRUE) ;
}


BOOL   BfindMatchingNode(
IN  DWORD   dwRootNodeIndex ,  //  first node in chain matching feature
OUT PDWORD  pdwNodeIndex,  // points to node in chain also matching option
    DWORD   dwFeatureID,
    DWORD   dwOptionID,     //  may even take on the value DEFAULT_INIT
    PGLOBL  pglobl
)
/*  caller passes a NodeIndex that points to the first node in
    a horizontal (option) chain.
    If the feature of the Node doesn't match dwFeature, this indicates
    the new branch caller is attempting to add is incompatible
    with the existing tree and an error results.   Otherwise,
    search horizontally along the tree searching for a matching
    option.  If found, return the index of that node, else
    returns FALSE.
*/
{
    PATTRIB_TREE    patt ;  // start of ATTRIBUTE tree array.
    DWORD           dwPrevsNodeIndex ;

    patt = (PATTRIB_TREE) gMasterTable[MTI_ATTRIBTREE].pubStruct ;

    *pdwNodeIndex = dwRootNodeIndex ;  // protects rootatr from
        // being overwritten.

    if(patt[*pdwNodeIndex].dwFeature != dwFeatureID )
    {
        ERR(("BfindMatchingNode: this branch conflicts with the existing tree \n"));
        //  and cannot be added.
        return(FALSE) ;
    }

    // Yes feature matches, search for matching option.

    for(   ; FOREVER ; )
    {
        if(patt[*pdwNodeIndex].dwOption == dwOptionID )
        {
            //  we found it!
            return(TRUE) ;
        }
        if(patt[*pdwNodeIndex].dwNext == END_OF_LIST)
            break ;
        *pdwNodeIndex = patt[*pdwNodeIndex].dwNext ;
    }

    return(FALSE);  //  matching option not found
}




BOOL BallocElementFromMasterTable(
MT_INDICIES  eMTIndex,   // select type of structure desired.
PDWORD       pdwNodeIndex,
PGLOBL       pglobl)
{
    if(gMasterTable[eMTIndex].dwCurIndex >=
        gMasterTable[eMTIndex].dwArraySize)
    {
        ERR(("BallocElementFromMasterTable: Out of array elements - restart.\n"));

        if(ERRSEV_RESTART > geErrorSev)
        {
            geErrorSev = ERRSEV_RESTART ;
            geErrorType = ERRTY_MEMORY_ALLOCATION ;
            gdwMasterTabIndex = eMTIndex ;
        }
        return(FALSE) ;
    }
    *pdwNodeIndex = gMasterTable[eMTIndex].dwCurIndex ;
    gMasterTable[eMTIndex].dwCurIndex++ ;  //  Node now taken.
    return(TRUE) ;
}

BOOL  BreturnElementFromMasterTable(
MT_INDICIES  eMTIndex,   // select type of structure desired.
DWORD        dwNodeIndex,
PGLOBL       pglobl)
{
    if(gMasterTable[eMTIndex].dwCurIndex == dwNodeIndex + 1)
    {
        gMasterTable[eMTIndex].dwCurIndex = dwNodeIndex ;
        return(TRUE) ;
    }
    //   BUG_BUG:  Can return only the most recently allocated node
    //  not a concern , memory waste is at most 1% and only temporary.
    if(ERRSEV_CONTINUE > geErrorSev)
    {
        geErrorSev = ERRSEV_CONTINUE ;
        geErrorType = ERRTY_CODEBUG ;
        gdwMasterTabIndex = eMTIndex ;
    }
    return(FALSE) ;
}


BOOL    BconvertSymCmdIDtoUnidrvID(
IN  DWORD   dwCommandID , //  from RegisterSymbol
OUT PDWORD  pdwUnidrvID,
    PGLOBL  pglobl
)
{   //  convert dwCommandID to UnidrvID
    PSYMBOLNODE     psn ;
    ABSARRAYREF     aarKey ;
    DWORD           dwNodeIndex ;
    BOOL            bStatus ;

    psn = (PSYMBOLNODE) gMasterTable[MTI_SYMBOLTREE].pubStruct ;

    dwNodeIndex = DWsearchSymbolListForID(dwCommandID,
                mdwCmdNameSymbols, pglobl) ;
    aarKey.dw = psn[dwNodeIndex].arSymbolName.dwCount ;
    aarKey.pub = mpubOffRef + psn[dwNodeIndex].arSymbolName.loOffset ;

    bStatus = BparseConstant(&aarKey, pdwUnidrvID,
        VALUE_CONSTANT_COMMAND_NAMES, pglobl) ;
    return(bStatus);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\parsers\gpd\states.c ===
//   Copyright (c) 1996-1999  Microsoft Corporation
------ state of the system ---------

Each parsing of an open brace should change
the state of the system.

As a feature, option, switch(feature), case(option)
or other construct is parsed  this is noted.

this construct stack allows us to select the appropriate
context for parsing:

is this a local keyword to this option (construct) or is it
EXTERN:?

What tree structure should be built for this construct?

then the parsing code should continue parsing
tokens as normal.


There will be tables that state what the
local keywords are for each situation.

constructs:
UIGroup, Feature, Option, Switch, Case,
Commands, Font, OEM



state stack:
each state is of the form:  state / symbol

The stack is empty at the root level.

state   allowed transitions         may contain

root     UIGroup                    any global attributes
         Feature
         Switch
         Commands
         Font
         OEM

UIGroup  Feature                    none
         UIGroup

Feature  Switch                     feature attributes
         Options

Switch   Case                       none

Options  Switch                     option attributes
                                    relocatable Global Attributes

Case     Switch
                                    relocatable local Attributes
                                       of immediately enclosing
                                       construct outside of Switch.
                                    relocatable Global Attributes

Commands none                       command attributes

ShortCommands none                  cmdName:invocation

Font     none                       font attributes

OEM      none                       oem  attributes


Note:  Commands and Fonts are considered
relocatable Global Attributes

Tables:  root attributes (divide into relocatable and non)
         feature attributes  ()
         option attributes    ()
         command attributes
         font attributes
         oem  attributes

Tables of allowed transitions:

Rules: how to construct a tree and where to plant the tree
   for a local or global attribute


----  implementation of this state machine -------

typedef  enum  {CONSTRUCT, LOCAL, GLOBAL,
         INVALID_CONSTRUCT, INVALID_LOCAL,  INVALID_GLOBAL,
         INVALID_UNRECOGNIZED, COMMENT, EOF }  keywordClass ;

GroundState()
{
   STATE  StateStack[] ;

   for(1)
   {
      extract Keyword(keyword)
      class = ClassifyKeyword(keyword)
      switch (class)
      {
         case  (CONSTRUCT):
            parseSymbol(symbol) ;
            parseOpenBrace() ; //  somewhere we need to register symbol
                           //  and allocate memory for structure
                           //  and return ptr or index to new
                           //  or existing structure
            changeState(keyword) ;
         case  (COMMENT):
            absorbCommentLine() ;
         case  (LOCAL) :
            ProcessLocalAttribute(keyword) ;
         case  (GLOBAL) :
            ProcessGlobalAttribute(keyword) ;
         case  (SPECIAL) :
            ProcessSpecialAttribute(keyword) ;
         case  (EOF)
            return(1);
         default:
            ErrorHandling() ;
      }
      if(rc == FATAL)
         return(1);
   }
}

class = ClassifyKeyword(keyword)
{

   if(commentline)
      return(COMMENT) ;
   if(EOF)
      return(EOF) ;

   The current state determines which sets of
   keywords are allowed.

   state = DetermineCurrentState()

   implement this table:

   for each state there is a list of all the keywords
   arranged in a fixed order (by keyword ID) each keyword
   is assigned a classification:
      Valid Constructs
      InValid Constructs
      Valid Local Attribute
      InValid Local Attribute
      Valid Global Attribute
      InValid Global Attribute
      Valid Special Attribute
      InValid Special Attribute

   if(keyword not found it table)
      return(INVALID_UNRECOGNIZED) ;

   return(classTable[keyword][state]) ;
}

typedef  enum {ROOT, UIGROUP, FEATURE, SWITCH, OPTIONS, CASE_ROOT,
         CASE_FEATURE, CASE_OPTION, COMMAND, SHORT_COMMAND,
         FONT, OEM, any other passive construct} STATES ;

Sample Table

KEYWORD                STATES ---->
                                                         *Command
                      *UIGroup  *Switch   *CaseRoot *CaseOption    *Font
                 *Root     *Feature  *Options  *CaseFeature   *ShortCmd *OEM
UIGroup        : VC   VC   IC   IC   IC   IC   IC   IC   IC   IC   IC   IC
Feature        : VC   VC   IC   IC   IC   IC   IC   IC   IC   IC   IC   IC
Switch         : VC   IC   VC   IC   VC   VC   VC   VC   IC   IC   IC   IC
Options        : IC   IC   VC   IC   IC   IC   IC   IC   IC   IC   IC   IC
Case           : IC   IC   IC   VC   IC   IC   IC   IC   IC   IC   IC   IC
Command        : VC   IC   IC   IC   VC   VC   VC   VC   IC   IC   IC   IC
Font           : VC   IC   IC   IC   VC   VC   VC   VC   IC   IC   IC   IC
OEM            : VC   IC   IC   IC   IC   IC   IC   IC   IC   IC   IC   IC
UIConstraints  : IS   IS   VS   IS   VS   IS   IS   IS   IS   IS   IS   IS

note:  UIConstraints appearing in a Feature is treated differently
   than appearing under Options.  The processing of UIConstraints
   causes one, two or many elements to be added to the Constraints
   Array.  This is in stark contrast to normal keywords hence
   the classification of Special.




state stack:
each state is of the form:  state / symbol

DetermineCurrentState()
{
   //  this state is only used to determine
   //  which catagories of keywords are
   //  assigned which TYPES in ClassifyKeyword().

   if(CurState == 0)
      return(ROOT) ;  // No further processing needed.
   return(stateStack[CurState - 1].state) ;
}

changeState(keyword, symbol, mode)
{

    // Change needed:  shortcut  *Command
    // does not initiate a state change.  This should
    // be treated as a special keyword.


   // mode determines if the *Command keyword
   // introduces a normal command construct or
   // the short version.

   switch(keyword)
   {
      case (*UIGroup):
         addState(UIGROUP, symbol);
      case (*Feature):
         addState(FEATURE, symbol);
      case (*Switch):
         addState(SWITCH, symbol);
      case (*Option):
         addState(OPTIONS, symbol);
      case (*Font):
         addState(FONT, symbol);
      case (*OEM):
         addState(OEM, symbol);
      case (*Command):
      {
         if(mode == short)
            addState(SHORT_CMD, symbol);
         else
            addState(COMMAND, symbol);
      }
      case (*Case):
      {
         if(stateStack[CurState - 2].state == ROOT  ||
            stateStack[CurState - 2].state == CASE_ROOT)
            addState(CASE_ROOT, symbol);
         if(stateStack[CurState - 2].state == FEATURE  ||
            stateStack[CurState - 2].state == CASE_FEATURE)
            addState(CASE_FEATURE, symbol);
         if(stateStack[CurState - 2].state == OPTIONS  ||
            stateStack[CurState - 2].state == CASE_OPTIONS)
            addState(CASE_OPTIONS, symbol);
      }
   }
}



//  these two functions will grow an appropriate
//  tree for each keyword based on the StateStack
//  and plant the tree in the appropriate attribute
//  field in the appropriate structure, (index) etc.
//  or add a branch to an existing tree,
//  and set the value at the node of the tree.

ProcessLocalAttribute(keyword) ;
ProcessGlobalAttribute(keyword, lpvalue)
{
   locate entry in Dglobals corresponding
   to keyword.

   OR the current branch (constructed using the state stack)
   with any existing tree pointed to by entry in Dglobals.

   if this branch exists in the existing tree, locate the offset
   in heap and overwrite that by
   (lptype)(lpRef + attributeTree[i].offset) = (lptype)lpvalue ;

   otherwise
   offset = lpCurHeapPos - lpRef ;
   lpCurHeapPos += sizeof(datatype) ;

   Note:  an attribute tree  should not be constructed
   piecemeal.  It is an error if the tree is subsequently
   redefined/elaborated using a different feature nesting
   order.

}


may need to keep a table for each keyword
with the following info per keyword.

keyword, datastructure, offset within datastructure, sizeof(data)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\parsers\gpd\state1.c ===
//   Copyright (c) 1996-1999  Microsoft Corporation
/*
 *  state1.c - implements the state machine to track constructs
 */



#include    "gpdparse.h"


// ----  functions defined in state1.c ---- //

BOOL   BInterpretTokens(
PTKMAP  ptkmap,   // pointer to tokenmap
BOOL    bFirstPass,  //  is this the first or 2nd time around?
PGLOBL  pglobl
) ;

BOOL  BprocessSpecialKeyword(
PTKMAP  ptkmap,   // pointer to tokenmap
BOOL    bFirstPass,  //  is this the first or 2nd time around?
PGLOBL  pglobl
) ;

BOOL  BprocessSymbolKeyword(
PTKMAP  ptkmap,   // pointer to current entry in tokenmap
PGLOBL  pglobl
) ;

VOID    VinitAllowedTransitions(
PGLOBL  pglobl
);

BOOL    BpushState(
PTKMAP  ptkmap,   // pointer to current entry in tokenmap
BOOL    bFirstPass,
PGLOBL  pglobl
) ;

BOOL   BchangeState(
PTKMAP  ptkmap,  // pointer to construct in tokenmap
CONSTRUCT   eConstruct,   //  this will induce a transition to NewState
STATE       stOldState,
BOOL        bSymbol,      //  should dwValue be saved as a SymbolID ?
BOOL        bFirstPass,
PGLOBL      pglobl
) ;

DWORD   DWregisterSymbol(
PABSARRAYREF  paarSymbol,  // the symbol string to register
CONSTRUCT eConstruct ,  // type of construct determines class of symbol.
BOOL    bCopy,   //  shall we copy paarSymbol to heap?  May set
DWORD   dwFeatureID,   //  if you are registering an option symbol
PGLOBL  pglobl
) ;

BOOL  BaddAARtoHeap(
PABSARRAYREF    paarSrc,
PARRAYREF       parDest,
DWORD           dwAlign,
PGLOBL          pglobl) ;

BOOL     BwriteToHeap(
OUT  PDWORD  pdwDestOff,  //  heap offset of dest string
     PBYTE   pubSrc,       //  points to src string
     DWORD   dwCnt,        //  num bytes to copy from src to dest.
     DWORD   dwAlign,
     PGLOBL  pglobl) ;

DWORD   DWsearchSymbolListForAAR(
PABSARRAYREF    paarSymbol,
DWORD           dwNodeIndex,
PGLOBL          pglobl) ;

DWORD   DWsearchSymbolListForID(
DWORD       dwSymbolID,   // find node containing this ID.
DWORD       dwNodeIndex,
PGLOBL      pglobl
) ;

BOOL  BCmpAARtoAR(
PABSARRAYREF    paarStr1,
PARRAYREF       parStr2,
PGLOBL          pglobl
) ;

BOOL  BpopState(
PGLOBL      pglobl
) ;

VOID   VinitDictionaryIndex(
PGLOBL      pglobl
) ;

VOID    VcharSubstitution(
PABSARRAYREF   paarStr,
BYTE           ubTgt,
BYTE           ubReplcmnt,
PGLOBL         pglobl
) ;


VOID   VIgnoreBlock(
    PTKMAP  ptkmap,
    BOOL    bIgnoreBlock,
    PGLOBL  pglobl
) ;



// ---------------------------------------------------- //




BOOL   BInterpretTokens(
PTKMAP  ptkmap,     // pointer to tokenmap
BOOL    bFirstPass,  //  is this the first or 2nd time around?
PGLOBL  pglobl
)
{
    DWORD       dwKeywordID ;
    KEYWORD_TYPE    eType;
    WORD        wEntry ;
    BOOL        bStatus = FALSE ;



    if(bFirstPass)
    {
        //  This bit of code creates a synthesized inputslot
        //  which the UI code will interpret as the UseFormToTrayTable

        //  BUG_BUG!!!:  should be replaced by preprocessing
        //  shortcuts etc.  Or by an option in stdnames.gpd

        ABSARRAYREF    aarSymbol ;
        DWORD       dwFeaID ;

        aarSymbol.pub = "InputBin" ; // no way to keep this in ssync
                //  with the global table.
        aarSymbol.dw = strlen(aarSymbol.pub) ;


        dwFeaID = DWregisterSymbol(&aarSymbol, CONSTRUCT_FEATURE,
                    TRUE, INVALID_SYMBOLID, pglobl) ;

        if(dwFeaID != INVALID_SYMBOLID)
        {
            aarSymbol.pub = "FORMSOURCE" ; // no way to keep this in ssync
                    //  with the global table.
            aarSymbol.dw = strlen(aarSymbol.pub) ;

            dwFeaID = DWregisterSymbol(&aarSymbol, CONSTRUCT_OPTION,
                        TRUE, dwFeaID, pglobl) ;
            ASSERT(dwFeaID == 0);  //  this option must be first.
        }
    }
    else
    {
        ARRAYREF       arStrValue ;
        BOOL        bPrevsExists ;


        if(!BwriteToHeap(&arStrValue.loOffset, "\0\0", 2, 4, pglobl) )
        {
            bStatus = FALSE ;  // heap overflow start over.
        }
        arStrValue.dwCount = 0 ;  // create a NULL unicode string.

        BexchangeArbDataInFOATNode(
                0 ,  //  dwFea
                0,  //  dwOption,
                offsetof(DFEATURE_OPTIONS, atrOptDisplayName ),
                sizeof(ARRAYREF),
                NULL,     // previous contents of attribute node
                (PBYTE)&arStrValue,  // new contents of attribute node.
                &bPrevsExists,   // previous contents existed.
                FALSE,     //  access synthetic features
                pglobl
            )   ;
    }


    for(wEntry = 0 ; geErrorSev < ERRSEV_RESTART ; wEntry++)
    {
        //  These ID's must be processed separately
        //  because they do not index into the mainKeyword table.
        //  The code for generic ID's will fail.

        dwKeywordID = ptkmap[wEntry].dwKeywordID ;

        if (dwKeywordID == gdwID_IgnoreBlock)
        {
            VIgnoreBlock(ptkmap + wEntry, TRUE, pglobl) ;
            continue ;
        }

        switch(dwKeywordID)
        {
            case (ID_EOF):
            {
                //  BUG_BUG!!!  Cleanup code here
                //  integrity checking code:
                //  check to see mdwCurStsPtr == 0
                //  and any other loose ends are tied.

                bStatus = (mdwCurStsPtr) ? (FALSE) : (TRUE);
                return(bStatus) ;
            }
            case (ID_NULLENTRY):
            {
                continue ;  // does this work?
                    // should drop to bottom of FOREVER for loop.
            }
            case (ID_SYMBOL):
            {
                bStatus = BprocessSymbolKeyword(ptkmap + wEntry, pglobl) ;
                continue ;  //  uses TKMF_SYMBOL_REGISTERED to track passes
            }
            case (ID_UNRECOGNIZED):
            {    //  if identified on first pass, won't pass this way again!
                if(bStatus = BidentifyAttributeKeyword(ptkmap + wEntry, pglobl) )
                {
                    dwKeywordID = ptkmap[wEntry].dwKeywordID ;
                    break ;  // fall out of switch statement
                    //  and into next switch.
                }

                if(bFirstPass)
                {
                    vIdentifySource(ptkmap + wEntry, pglobl) ;
                    ERR(("Warning, unrecognized keyword: %0.*s\n", \
                            ptkmap[wEntry].aarKeyword.dw, \
                            ptkmap[wEntry].aarKeyword.pub));

                    VIgnoreBlock(ptkmap + wEntry, FALSE, pglobl) ;

                    //  if this keyword is immediately
                    //  followed by open brace, ignore all
                    //  statements from there until the matching closing
                    //  brace.
                }

                continue ;
            }
            default :
                break ;
        }

        eType = mMainKeywordTable[dwKeywordID].eType ;

        switch (eType)
        {
            case  (TY_CONSTRUCT):
            {
                if( CONSTRUCT_CLOSEBRACE ==
                    (CONSTRUCT)(mMainKeywordTable[dwKeywordID].dwSubType))
                {
                    bStatus = BpopState(pglobl) ;
                    if(!bStatus)
                    {
                        vIdentifySource(ptkmap + wEntry, pglobl) ;
                        ERR(("Unmatched closing brace!\n"));
                    }
                }
                else
                {
                    bStatus = BpushState(ptkmap + wEntry, bFirstPass, pglobl) ;
                    if(!bStatus)
                    {
                        vIdentifySource(ptkmap + wEntry, pglobl) ;
                        //  ERR(("Fatal error parsing construct.\n"));
                        //  stack is now invalid.
                        //  in the future make parser smarter -
                        //  eject contents between braces.
                        //  geErrorType = ERRTY_SYNTAX ;
                        //  geErrorSev = ERRSEV_FATAL ;
                    }
                }
                break ;
            }
            case  (TY_ATTRIBUTE) :
            {
                if(!bFirstPass)  // must wait till all attribute
                {              //  buffers are allocated.
                    bStatus = BprocessAttribute(ptkmap + wEntry, pglobl) ;
                    if(!bStatus)
                    {
                        vIdentifySource(ptkmap + wEntry, pglobl) ;
                    }
                }
                break ;
            }
            case  (TY_SPECIAL) :
            {
                bStatus = BprocessSpecialKeyword(ptkmap + wEntry,
                    bFirstPass, pglobl) ;  // don't really know if 2 passes
                {                //  are needed.
                    if(!bStatus)
                    {
                        vIdentifySource(ptkmap + wEntry, pglobl) ;
                    }
                }
                break ;
            }
            default:
            {
                vIdentifySource(ptkmap + wEntry, pglobl) ;
                ERR(("Internal Error: unrecognized keyword type! %0.*s.\n",
                    ptkmap[wEntry].aarKeyword.dw,
                    ptkmap[wEntry].aarKeyword.pub));
                geErrorSev = ERRSEV_FATAL ;
                geErrorType = ERRTY_CODEBUG ;
                break ;
            }
        }
    }
    if(geErrorSev >= ERRSEV_RESTART)
        bStatus = FALSE ;
    return(bStatus) ;
}


BOOL  BprocessSpecialKeyword(
PTKMAP  ptkmap,     // pointer to tokenmap
BOOL    bFirstPass,   //  is this the first or 2nd time around?
PGLOBL  pglobl
)
{
    DWORD       dwKeywordID, dwOffset ;
    CONSTRUCT   eSubType ;
    BOOL        bStatus = FALSE ;
    STATE       stState ;

    dwKeywordID = ptkmap->dwKeywordID ;

    eSubType = (SPECIAL)(mMainKeywordTable[dwKeywordID].dwSubType) ;
    dwOffset = mMainKeywordTable[dwKeywordID].dwOffset ;

    if(mdwCurStsPtr)
        stState = mpstsStateStack[mdwCurStsPtr - 1].stState ;
    else
        stState = STATE_ROOT ;

    switch(eSubType)
    {
        //  note: for the record I despise special casing these
        //  shortcuts.  Ideally I could preprocess them
        //  to convert
        //  *TTFS: "font name" : <fontID>
        //  into
        //  *TTFontSub: <unique value symbol>
        //  {
        //      *TTFontName: "font name"
        //      *DevFontID:  <fontID>
        //  }
        //  the only glitch with this is if the same font is listed
        //  multiple times in the GPD file, it will appear
        //  in the TTFontSubTable multiple times.

#if 0
        case  SPEC_FONTSUB :
        {
            ARRAYREF   arFontname ;
            ABSARRAYREF    aarFontname ;

            if(stState != STATE_ROOT)
            {
                vIdentifySource(ptkmap, pglobl) ;
                ERR(("The *TTFS  keyword must reside at the root level.\n"));
                return(FALSE) ;
            }

            if(bFirstPass)
            {
                //  parse string value and register as a symbol.
                if((ptkmap->dwFlags & TKMF_NOVALUE )  ||
                    !BparseString(&ptkmap->aarValue, &arFontname) )
                {
                    vIdentifySource(ptkmap, pglobl) ;
                    ERR(("*TTFS fontname is not a valid string value.\n"));
                    return(FALSE) ;
                }

                if(ptkmap->aarValue.pub[0] != ':')
                {
                    ERR(("Colon delimiter expected after  parsing fontname string  for *TTFontSub.\n")) ;
                    return(FALSE) ;
                }
                //  a keyword with a composite value
                (VOID)BeatDelimiter(&ptkmap->aarValue, ":") ;
                //  I know this will succeed!
                // paarValue should now contain the integer
                // fontID.  Leave this for the 2nd pass.

                // convert arFontname to aar suitable for
                // Font registration.

                aarFontname.dw = arFontname.dwCount ;
                aarFontname.pub = arFontname.loOffset + mpubOffRef;

                //  New version of DWregisterSymbol registers the entire
                //  string - whitespaces and all.
                //
                //  Note suppress copying symbol into Heap since
                //  ParseString has already done that.

                ptkmap->dwValue = DWregisterSymbol(&aarFontname,
                    CONSTRUCT_TTFONTSUBS, FALSE, pglobl ) ;
                if(ptkmap->dwValue != INVALID_SYMBOLID)
                {
                    ptkmap->dwFlags |= TKMF_SYMBOL_REGISTERED ;
                }
                else
                {
                    return(FALSE) ;
                }
            }
            else if(ptkmap->dwFlags & TKMF_SYMBOL_REGISTERED)
            // second pass, TTFONTSUBTABLE arrays allocated
            // for all successfully registered entrants.
            {
                PSYMBOLNODE     psn ;
                DWORD           dwDevFontID ;
                PTTFONTSUBTABLE  pttft ;
                DWORD       dwTTFontNameIndex  ;

                psn = (PSYMBOLNODE) gMasterTable[MTI_SYMBOLTREE].pubStruct ;

                pttft = (PTTFONTSUBTABLE)
                    gMasterTable[MTI_TTFONTSUBTABLE].pubStruct;
                pttft += ptkmap->dwValue ;  // index correct element.

                dwTTFontNameIndex = DWsearchSymbolListForID(ptkmap->dwValue,
                    mdwTTFontSymbols, pglobl) ;

                ASSERT(dwTTFontNameIndex  != INVALID_INDEX) ;

                pttft->arTTFontName = psn[dwTTFontNameIndex].arSymbolName ;
                //  if structure assignment is supported.

                bStatus = BparseInteger(&ptkmap->aarValue, &dwDevFontID,
                                    VALUE_INTEGER) ;
                if(bStatus)
                    pttft->dwDevFontID = dwDevFontID ;
                else
                {
                    //  BUG_BUG!  : Error parsing TTFontSub table entry
                    //  syntax error in devID.  Dead codepath who cares?
                    pttft->dwDevFontID = 0 ;  //  is this a good fallback?
                }
            }
            break;
        }
#endif
        case SPEC_INVALID_COMBO:
        {
            if(bFirstPass)
            {
                bStatus = TRUE ;
                break;    //  do nothing on the FirstPass
            }

            bStatus = BparseInvalidCombination(&ptkmap->aarValue, dwOffset, pglobl) ;
            break;
        }
        case SPEC_INVALID_INS_COMBO:
        {
            if(bFirstPass)
            {
                bStatus = TRUE ;
                break;    //  do nothing on the FirstPass
            }

            bStatus = BparseInvalidInstallableCombination1(&ptkmap->aarValue,
                            dwOffset, pglobl) ;
            break;
        }
        case SPEC_MEM_CONFIG_KB:  // should already be replaced
        case SPEC_MEM_CONFIG_MB:  //  at parseKeyword
        default:
        {
            break ;
        }
    }
    return(bStatus) ;
}



BOOL  BprocessSymbolKeyword(
PTKMAP  ptkmap,   // pointer to current entry in tokenmap
PGLOBL  pglobl
)
{
    //  registering the TTFontNames as symbols allows
    //  me to count the number of unique names and reserve
    //  the proper amount of TTFONTSUBTABLE elements and
    //  eliminates multiple instances of the same name.

    BOOL        bStatus = FALSE ;
    STATE       stState ;

    if(mdwCurStsPtr)
        stState = mpstsStateStack[mdwCurStsPtr - 1].stState ;
    else
        stState = STATE_ROOT ;

    switch (stState)
    {
        //  note TTFontSubs now has its own keyword.
        //  and is handled as a Special Keyword.
        default:
        {
            // assume its just VALUEMACRO state
            // or user-defined symbols from an undefined
            // keyword.
            // ignore these.
            bStatus = TRUE ;
            break ;
        }
    }
    return(bStatus);
}





VOID    VinitAllowedTransitions(
PGLOBL pglobl)
{
    PSTATE      pst ;
    PBOOL       pb ;
    WORD        wS, wC, wA ;

    //  default initializer  is  STATE_INVALID
    for(wS = 0 ; wS < STATE_LAST ; wS++)
    {
        for(wC = 0 ; wC < CONSTRUCT_LAST ; wC++)
            gastAllowedTransitions[wS][wC] = STATE_INVALID ;
    }

    pst = gastAllowedTransitions[STATE_ROOT] ;

    pst[CONSTRUCT_UIGROUP] = STATE_UIGROUP;
    pst[CONSTRUCT_FEATURE] = STATE_FEATURE;
    pst[CONSTRUCT_SWITCH] = STATE_SWITCH_ROOT;
    pst[CONSTRUCT_COMMAND] = STATE_COMMAND;
    pst[CONSTRUCT_FONTCART] = STATE_FONTCART;
    pst[CONSTRUCT_TTFONTSUBS] = STATE_TTFONTSUBS;
    pst[CONSTRUCT_OEM] = STATE_OEM;

    pst = gastAllowedTransitions[STATE_UIGROUP] ;

    pst[CONSTRUCT_UIGROUP] = STATE_UIGROUP;
    pst[CONSTRUCT_FEATURE] = STATE_FEATURE;

    pst = gastAllowedTransitions[STATE_FEATURE] ;

    pst[CONSTRUCT_OPTION] = STATE_OPTIONS;
    pst[CONSTRUCT_SWITCH] = STATE_SWITCH_FEATURE;

    pst = gastAllowedTransitions[STATE_OPTIONS] ;

    pst[CONSTRUCT_SWITCH] = STATE_SWITCH_OPTION;
    pst[CONSTRUCT_COMMAND] = STATE_COMMAND;
    pst[CONSTRUCT_OEM] = STATE_OEM;

    pst = gastAllowedTransitions[STATE_SWITCH_ROOT] ;

    pst[CONSTRUCT_CASE] = STATE_CASE_ROOT;
    pst[CONSTRUCT_DEFAULT] = STATE_DEFAULT_ROOT;

    pst = gastAllowedTransitions[STATE_SWITCH_FEATURE] ;

    pst[CONSTRUCT_CASE] = STATE_CASE_FEATURE;
    pst[CONSTRUCT_DEFAULT] = STATE_DEFAULT_FEATURE;

    pst = gastAllowedTransitions[STATE_SWITCH_OPTION] ;

    pst[CONSTRUCT_CASE] = STATE_CASE_OPTION;
    pst[CONSTRUCT_DEFAULT] = STATE_DEFAULT_OPTION;

    pst = gastAllowedTransitions[STATE_CASE_ROOT] ;

    pst[CONSTRUCT_SWITCH] = STATE_SWITCH_ROOT;
    pst[CONSTRUCT_COMMAND] = STATE_COMMAND;
    pst[CONSTRUCT_OEM] = STATE_OEM;

    pst = gastAllowedTransitions[STATE_DEFAULT_ROOT] ;

    pst[CONSTRUCT_SWITCH] = STATE_SWITCH_ROOT;
    pst[CONSTRUCT_COMMAND] = STATE_COMMAND;
    pst[CONSTRUCT_OEM] = STATE_OEM;

    pst = gastAllowedTransitions[STATE_CASE_FEATURE] ;

    pst[CONSTRUCT_SWITCH] = STATE_SWITCH_FEATURE;
    pst[CONSTRUCT_COMMAND] = STATE_COMMAND;
    pst[CONSTRUCT_OEM] = STATE_OEM;

    pst = gastAllowedTransitions[STATE_DEFAULT_FEATURE] ;

    pst[CONSTRUCT_SWITCH] = STATE_SWITCH_FEATURE;
    pst[CONSTRUCT_COMMAND] = STATE_COMMAND;
    pst[CONSTRUCT_OEM] = STATE_OEM;

    pst = gastAllowedTransitions[STATE_CASE_OPTION] ;

    pst[CONSTRUCT_SWITCH] = STATE_SWITCH_OPTION;
    pst[CONSTRUCT_COMMAND] = STATE_COMMAND;
    pst[CONSTRUCT_OEM] = STATE_OEM;

    pst = gastAllowedTransitions[STATE_DEFAULT_OPTION] ;

    pst[CONSTRUCT_SWITCH] = STATE_SWITCH_OPTION;
    pst[CONSTRUCT_COMMAND] = STATE_COMMAND;
    pst[CONSTRUCT_OEM] = STATE_OEM;


    //  ------------------------------------------------------  //
    //  now initialize allowed attributes table:
    //  which attributes are allowed in each state.

    //  default initializer  is  FALSE -- No attributes are allowed
    //  in any state.

    for(wS = 0 ; wS < STATE_LAST ; wS++)
    {
        for(wA = 0 ; wA < ATT_LAST ; wA++)
        {
            gabAllowedAttributes[wS][wA] = FALSE ;
        }
    }


    pb = gabAllowedAttributes[STATE_ROOT] ;
    pb[ATT_GLOBAL_ONLY] = TRUE ;
    pb[ATT_GLOBAL_FREEFLOAT] = TRUE ;

    pb = gabAllowedAttributes[STATE_CASE_ROOT] ;
    pb[ATT_GLOBAL_FREEFLOAT] = TRUE ;

    pb = gabAllowedAttributes[STATE_DEFAULT_ROOT] ;
    pb[ATT_GLOBAL_FREEFLOAT] = TRUE ;

    pb = gabAllowedAttributes[STATE_OPTIONS] ;
    pb[ATT_GLOBAL_FREEFLOAT] = TRUE ;
    pb[ATT_LOCAL_FEATURE_FF] = TRUE ;
    pb[ATT_LOCAL_OPTION_ONLY] = TRUE ;
    pb[ATT_LOCAL_OPTION_FF] = TRUE ;

    pb = gabAllowedAttributes[STATE_CASE_OPTION] ;
    pb[ATT_GLOBAL_FREEFLOAT] = TRUE ;
    pb[ATT_LOCAL_FEATURE_FF] = TRUE ;
    pb[ATT_LOCAL_OPTION_FF] = TRUE ;

    pb = gabAllowedAttributes[STATE_DEFAULT_OPTION] ;
    pb[ATT_GLOBAL_FREEFLOAT] = TRUE ;
    pb[ATT_LOCAL_FEATURE_FF] = TRUE ;
    pb[ATT_LOCAL_OPTION_FF] = TRUE ;

    pb = gabAllowedAttributes[STATE_FEATURE] ;

    pb[ATT_LOCAL_FEATURE_ONLY] = TRUE ;
    pb[ATT_LOCAL_FEATURE_FF]  = TRUE ;

    pb = gabAllowedAttributes[STATE_CASE_FEATURE] ;
    pb[ATT_LOCAL_FEATURE_FF]  = TRUE ;

    pb = gabAllowedAttributes[STATE_DEFAULT_FEATURE] ;
    pb[ATT_LOCAL_FEATURE_FF]  = TRUE ;

    pb = gabAllowedAttributes[STATE_COMMAND] ;
    pb[ATT_LOCAL_COMMAND_ONLY] = TRUE ;

    pb = gabAllowedAttributes[STATE_FONTCART] ;
    pb[ATT_LOCAL_FONTCART_ONLY] = TRUE ;

    pb = gabAllowedAttributes[STATE_TTFONTSUBS] ;
    pb[ATT_LOCAL_TTFONTSUBS_ONLY] = TRUE ;

    pb = gabAllowedAttributes[STATE_OEM] ;
    pb[ATT_LOCAL_OEM_ONLY] = TRUE ;
}



BOOL    BpushState(
PTKMAP  ptkmap,   // pointer to current entry in tokenmap
BOOL    bFirstPass,
PGLOBL  pglobl
)
{
    // this function assumes (eType == TY_CONSTRUCT)

    DWORD       dwKeywordID ;
    CONSTRUCT   eSubType ;
    BOOL        bStatus = FALSE ;
    STATE       stOldState, stNewState ;

    if(mdwCurStsPtr >= mdwMaxStackDepth)
    {
        if(ERRSEV_RESTART > geErrorSev)
        {
            ERR(("Exceeded max state stack depth.  Restarting\n"));
            geErrorSev = ERRSEV_RESTART ;
            geErrorType = ERRTY_MEMORY_ALLOCATION ;
            gdwMasterTabIndex = MTI_STSENTRY ;
        }
        return(FALSE);
    }
    dwKeywordID = ptkmap->dwKeywordID ;

    eSubType = (CONSTRUCT)(mMainKeywordTable[dwKeywordID].dwSubType) ;

    if(mdwCurStsPtr)
        stOldState = mpstsStateStack[mdwCurStsPtr - 1].stState ;
    else
        stOldState = STATE_ROOT ;

    switch (eSubType)
    {
        //  note  CONSTRUCT_CLOSEBRACE already processed
        //  by PopState().
        case (CONSTRUCT_OPENBRACE):
        {
            vIdentifySource(ptkmap, pglobl) ;
            ERR(("OpenBrace encountered without accompanying construct keyword.\n"));
            geErrorType = ERRTY_SYNTAX ;
            geErrorSev = ERRSEV_FATAL ;
            break ;
        }
        case (CONSTRUCT_FEATURE):
        case (CONSTRUCT_OPTION):
        case (CONSTRUCT_SWITCH):
        case (CONSTRUCT_COMMAND):   //  commandID's already registered.
        case (CONSTRUCT_CASE):
        case (CONSTRUCT_FONTCART):
        case (CONSTRUCT_TTFONTSUBS):
        {
            bStatus = BchangeState(ptkmap, eSubType, stOldState, TRUE,
                bFirstPass, pglobl) ;

            break ;
        }
        case (CONSTRUCT_UIGROUP):
        {
            //  BUG_BUG!!!!!  incomplete.  no reqest for this.
        }
        case (CONSTRUCT_DEFAULT):
        case (CONSTRUCT_OEM):
        {
            bStatus = BchangeState(ptkmap, eSubType, stOldState, FALSE,
                bFirstPass, pglobl) ;

            break ;
        }
        default:
        {
            bStatus = TRUE ;  // its ok to ignore some keywords.
            break ;
        }
    }
    return(bStatus) ;
}


/*

dead code.
VOID  VsetbTTFontSubs(
IN   PABSARRAYREF   paarValue)
{
    // BUG_BUG!!!!!:
    // exactly what is supposed to happen ?  register
    //  synthesized symbol ?
    gbTTFontSubs = FALSE ;

    if( BeatSurroundingWhiteSpaces(paarValue) )
    {
        if(paarValue->dw == 2  &&  ! strncmp(paarValue->pub,  "ON",  2))
            gbTTFontSubs = TRUE ;
        else if(paarValue->dw != 3 ||  strncmp(paarValue->pub,  "OFF",  3))
        {
            BUG_BUG!: value must be either "ON" or "OFF".
        }
    }
}
*/

BOOL   BchangeState(
PTKMAP      ptkmap,      // pointer to construct in tokenmap
CONSTRUCT   eConstruct,  //  this will induce a transition to NewState
STATE       stOldState,
BOOL        bSymbol,     //  should dwValue be saved as a SymbolID ?
BOOL        bFirstPass,
PGLOBL      pglobl
)
{
    BOOL        bStatus = FALSE ;
    STATE       stNewState ;

    //  was checked in PushState, but never hurts to check
    //  in the same function that consumes the resource.
    if(mdwCurStsPtr >= mdwMaxStackDepth)
    {
        if(ERRSEV_RESTART > geErrorSev)
        {
            geErrorSev = ERRSEV_RESTART ;
            geErrorType = ERRTY_MEMORY_ALLOCATION ;
            gdwMasterTabIndex = MTI_STSENTRY ;
        }
        return(FALSE);
    }

    stNewState = gastAllowedTransitions[stOldState][eConstruct] ;
    if(stNewState == STATE_INVALID)
    {
        vIdentifySource(ptkmap, pglobl) ;
        ERR(("the Construct %0.*s is not allowed within the state: %s\n",
            ptkmap->aarKeyword.dw, ptkmap->aarKeyword.pub,
            gpubStateNames[stOldState]));
        //  (convert stOldState
        //  and  eConstruct  to meaningful string)
        //  This is a fatal error since parser cannot second
        //  guess the problem.  The parser's job is to report
        //  as many legitemate problems as possible not to
        //  create as useable binary in spite of all the syntax
        //  errors.

        if(ERRSEV_FATAL > geErrorSev)
        {
            geErrorSev = ERRSEV_FATAL ;
            geErrorType = ERRTY_SYNTAX ;
        }
        return(FALSE);
    }
    else
    {
        if(bFirstPass)
        {   //  verify open brace follows construct and discard it.
            DWORD       dwKeywordID ;
            PTKMAP  ptkmapTmp = ptkmap + 1 ;

            dwKeywordID = ptkmapTmp->dwKeywordID ;
            while(dwKeywordID == ID_NULLENTRY)  // skip nulls, comments etc.
            {
                dwKeywordID = (++ptkmapTmp)->dwKeywordID ;
            }
            if(dwKeywordID < ID_SPECIAL  &&
                mMainKeywordTable[dwKeywordID].eType == TY_CONSTRUCT  &&
                mMainKeywordTable[dwKeywordID].dwSubType ==
                CONSTRUCT_OPENBRACE )
            {
                ptkmapTmp->dwKeywordID = ID_NULLENTRY ;
            }
            else
            {
                vIdentifySource(ptkmap, pglobl) ;
                ERR(("open brace expected after construct: %0.*s but was not found\n",
                    ptkmap->aarKeyword.dw , ptkmap->aarKeyword.pub )) ;
                geErrorType = ERRTY_SYNTAX ;
                geErrorSev = ERRSEV_FATAL ;
                return(FALSE);
            }
        }
        if(bSymbol)
        {
            //  BUG_BUG:  verify tokenmap.dwFlags set to SYMBOLID before
            //  assuming dwValue is a symbol.  An error here
            //  is a parser bug.
            //  dwValue is initialized when dwFlag is set.
            //  further assert is pointless.

            //  perform multiple passes.  The first pass
            //  registers symbols and counts number of arrays
            //  to allocate, 2nd pass fills arrays.  SymbolID
            //  now serves as array index.

            if(!(ptkmap->dwFlags & TKMF_SYMBOL_REGISTERED))
            {
                if(!bFirstPass)
                {
                    vIdentifySource(ptkmap, pglobl) ;
                    ERR(("symbol registration failed twice for: *%0.*s.\n",
                        ptkmap->aarValue.dw,
                        ptkmap->aarValue.pub));
                    return(FALSE) ;  // retry
                }

                if((ptkmap->dwFlags & TKMF_NOVALUE )  ||
                ! BeatSurroundingWhiteSpaces(&ptkmap->aarValue) )
                {
                    vIdentifySource(ptkmap, pglobl) ;
                    ERR(("syntax error in symbol name.\n"));
                    ptkmap->dwValue = INVALID_SYMBOLID ;
                    return(FALSE) ;
                }

                ptkmap->dwValue = DWregisterSymbol(&ptkmap->aarValue,
                                    eConstruct, TRUE,  INVALID_SYMBOLID, pglobl) ;
                if(ptkmap->dwValue != INVALID_SYMBOLID)
                {
                    ptkmap->dwFlags |= TKMF_SYMBOL_REGISTERED ;
                }
                else
                {
                    vIdentifySource(ptkmap, pglobl) ;
                    ERR(("symbol registration failed: *%0.*s.\n",
                        ptkmap->aarValue.dw,
                        ptkmap->aarValue.pub));
                    return(FALSE) ;  // retry
                }
            }
            else   // second pass, DFEATURE_OPTION arrays allocated.
            {
                if(eConstruct == CONSTRUCT_SWITCH)
                {
                    PDFEATURE_OPTIONS   pfo ;

                    pfo = (PDFEATURE_OPTIONS)
                        gMasterTable[MTI_DFEATURE_OPTIONS].pubStruct ;
                    pfo[ptkmap->dwValue].bReferenced = TRUE ;
                    //  this tells me this Feature is being referenced
                    //  by switch statement, hence the feature had better
                    //  be PICKONE.  Sanity checks will later verify
                    //  this assumption.
                }
                if(eConstruct == CONSTRUCT_FEATURE  ||
                    eConstruct == CONSTRUCT_SWITCH)
                {
                    //  BUG_BUG!!!!!:  (DCR 454049)
                    //  Note, the same Feature symbol cannot appear
                    //  twice in the stack for any reason.
                    //  A sanity check is needed.
                    //  if duplicate symbol found in stack,
                    //  "a Nested Switch Construct refers to the
                    //  same feature as an enclosing switch or Feature
                    //  construct.  This makes no sense."
                }
            }

            bStatus = TRUE ;
            mpstsStateStack[mdwCurStsPtr].dwSymbolID = ptkmap->dwValue ;
        }
        else
            bStatus = TRUE ;

        if(bStatus)
        {
            mpstsStateStack[mdwCurStsPtr].stState = stNewState ;
            mdwCurStsPtr++ ;
        }
    }
    return(bStatus) ;
}

DWORD   DWregisterSymbol(
PABSARRAYREF  paarSymbol,   // the symbol string to register
CONSTRUCT     eConstruct ,  // type of construct determines class of symbol.
BOOL          bCopy,        //  shall we copy paarSymbol to heap?  May set
                            // to FALSE only if paarSymbol already points
                            // to a heap object!
DWORD         dwFeatureID,   //  if you are registering an option symbol
                            //   and you already know the feature , pass it in
                            //  here.  Otherwise set to INVALID_SYMBOLID
PGLOBL        pglobl
)
/*  this function registers the entire string specified
    in paarSymbol.  The caller must isolate the string.
*/
{
    //  returns SymbolID, a zero indexed ordinal
    //    for extra speed we may hash string

    PSYMBOLNODE     psn ;
    DWORD   dwCurNode, dwSymbolID = INVALID_SYMBOLID;

//    bCopy = TRUE;   //check. Force BUDs to be the same.

    if(!paarSymbol->dw)
    {
        ERR(("DWregisterSymbol: No symbol value supplied.\n"));
        return(INVALID_SYMBOLID);  // report failure.
    }

    psn = (PSYMBOLNODE) gMasterTable[MTI_SYMBOLTREE].pubStruct ;


    switch(eConstruct)
    {
        case CONSTRUCT_FEATURE :    // since forward references are allowed
        case CONSTRUCT_SWITCH :     // it cannot be assumed that references
        case CONSTRUCT_FONTCART:    // will be to registered symbols .
        case CONSTRUCT_COMMAND:
        case CONSTRUCT_TTFONTSUBS:
        case CONSTRUCT_BLOCKMACRO:
        case CONSTRUCT_MACROS:
        case CONSTRUCT_PREPROCESSOR:
        {
            PDWORD  pdwSymbolClass ;

            pdwSymbolClass = (PDWORD)gMasterTable[MTI_SYMBOLROOT].pubStruct ;

            if(eConstruct == CONSTRUCT_FONTCART)
                pdwSymbolClass += SCL_FONTCART ;
            else if(eConstruct == CONSTRUCT_TTFONTSUBS)
                pdwSymbolClass += SCL_TTFONTNAMES ;
            else if(eConstruct == CONSTRUCT_COMMAND)
                pdwSymbolClass += SCL_COMMANDNAMES ;
            else if(eConstruct == CONSTRUCT_BLOCKMACRO)
                pdwSymbolClass +=  SCL_BLOCKMACRO;
            else if(eConstruct == CONSTRUCT_MACROS)
                pdwSymbolClass +=  SCL_VALUEMACRO;
            else if(eConstruct == CONSTRUCT_PREPROCESSOR)
                pdwSymbolClass +=  SCL_PPDEFINES;
            else
                pdwSymbolClass += SCL_FEATURES ;
            if(*pdwSymbolClass == INVALID_INDEX)
            {
                //  register this symbol now.
                if(!BallocElementFromMasterTable(MTI_SYMBOLTREE, &dwCurNode, pglobl))
                {
                    //  we have run out of symbol nodes!
                    return(INVALID_SYMBOLID);  // report failure.
                }
                if(bCopy)
                {
                    if(!BaddAARtoHeap(paarSymbol,
                                    &(psn[dwCurNode].arSymbolName), 1, pglobl))
                        return(INVALID_SYMBOLID);  // report failure.
                }
                else
                {
                    //  derive one from the other.
                    psn[dwCurNode].arSymbolName.dwCount = paarSymbol->dw ;
                    psn[dwCurNode].arSymbolName.loOffset  =
                                            (DWORD)(paarSymbol->pub - mpubOffRef);
                }
                dwSymbolID = psn[dwCurNode].dwSymbolID = 0 ;  // first symbol
                                                            // in list.
                psn[dwCurNode].dwNextSymbol = INVALID_INDEX ;   // no previous
                                                        // symbols exist.
                psn[dwCurNode].dwSubSpaceIndex = INVALID_INDEX ;  // no
                        // option symbols exist.
                *pdwSymbolClass = dwCurNode ;  // now we have a registered
                                                //  symbol
            }
            else
            {
                //  search list for matching symbol.
                dwSymbolID = DWsearchSymbolListForAAR(paarSymbol, *pdwSymbolClass, pglobl) ;
                if(dwSymbolID != INVALID_SYMBOLID)  // found
                    ;  // nothing else is needed, just return.
                else   // not found, must register.
                {
                    if(!BallocElementFromMasterTable(MTI_SYMBOLTREE,
                        &dwCurNode, pglobl))
                    {
                        return(INVALID_SYMBOLID);  // report failure.
                    }
                    // tack new symbol onto head of list.
                    if(bCopy)
                    {
                        if(!BaddAARtoHeap(paarSymbol,
                                     &(psn[dwCurNode].arSymbolName), 1, pglobl) )
                            return(INVALID_SYMBOLID);  // report failure.
                    }
                    else
                    {
                        //  derive one from the other.
                        psn[dwCurNode].arSymbolName.dwCount = paarSymbol->dw ;
                        psn[dwCurNode].arSymbolName.loOffset  =
                                                (DWORD)(paarSymbol->pub - mpubOffRef);
                    }
                    dwSymbolID = psn[dwCurNode].dwSymbolID =
                    psn[*pdwSymbolClass].dwSymbolID + 1;
                            // increment last ID
                    psn[dwCurNode].dwNextSymbol = *pdwSymbolClass ;
                        // link to previous symbols.
                    psn[dwCurNode].dwSubSpaceIndex = INVALID_INDEX ;  // no
                            // option symbols exist.
                    *pdwSymbolClass = dwCurNode ;  // points to most recent
                                                    //  symbol
                }
            }
            break;
        }
        case CONSTRUCT_OPTION :
        case CONSTRUCT_CASE :
        {
            DWORD
                dwFeatureIndex, // node containing this symbolID.
                dwRootOptions ; //  root of option symbols.


#if PARANOID
            if(mdwCurStsPtr)
            {

                //  this safety check almost superfluous.

                stPrevsState = mpstsStateStack[mdwCurStsPtr - 1].State ;

                if(eConstruct == CONSTRUCT_OPTION  &&
                    stPrevsState != STATE_FEATURE)
                {
                    ERR(("DWregisterSymbol: option or case construct is not enclosed within feature or switch !\n"));
                    return(INVALID_SYMBOLID);  // report failure.
                }
                if(eConstruct == CONSTRUCT_CASE  &&
                    (stPrevsState != STATE_SWITCH_ROOT  ||
                    (stPrevsState != STATE_SWITCH_FEATURE  ||
                    (stPrevsState != STATE_SWITCH_OPTION )  )
                {
                    ERR(("DWregisterSymbol: case construct is not enclosed within  switch !\n"));
                    return(INVALID_SYMBOLID);  // report failure.
                }
#endif
            //  Boldly assume top of stack contains a featureID.
            //  see paranoid code for all assumptions made.

            if(dwFeatureID == INVALID_SYMBOLID)
                dwFeatureID = mpstsStateStack[mdwCurStsPtr - 1].dwSymbolID  ;

            dwFeatureIndex = DWsearchSymbolListForID(dwFeatureID,
                mdwFeatureSymbols, pglobl) ;
            //  PARANOID  BUG_BUG: coding error if symbolID isn't found!
            ASSERT(dwFeatureIndex  != INVALID_INDEX) ;

            dwRootOptions = psn[dwFeatureIndex].dwSubSpaceIndex ;

            //  found root of option symbols!

            if(dwRootOptions == INVALID_INDEX)
            {
                if(!BallocElementFromMasterTable(MTI_SYMBOLTREE, &dwCurNode, pglobl))
                {
                    return(INVALID_SYMBOLID);  // report failure.
                }
                //  register this symbol now.
                if(bCopy)
                {
                    if(!BaddAARtoHeap(paarSymbol, &(psn[dwCurNode].arSymbolName), 1, pglobl) )
                        return(INVALID_SYMBOLID);  // report failure.
                }
                else
                {
                    //  derive one from the other.
                    psn[dwCurNode].arSymbolName.dwCount = paarSymbol->dw ;
                    psn[dwCurNode].arSymbolName.loOffset  =
                                            (DWORD)(paarSymbol->pub - mpubOffRef);
                }
                dwSymbolID = psn[dwCurNode].dwSymbolID = 0 ;
                    // first symbol in list.
                psn[dwCurNode].dwNextSymbol = INVALID_INDEX ;
                    // no previous symbols exist.
                psn[dwCurNode].dwSubSpaceIndex = INVALID_INDEX ;

                    // option symbols have no subspace.

                psn[dwFeatureIndex].dwSubSpaceIndex = dwRootOptions =
                    dwCurNode ;  // now we have a registered symbol
            }
            else
            {
                //  search list for matching symbol.
                dwSymbolID = DWsearchSymbolListForAAR(paarSymbol,
                                                    dwRootOptions, pglobl) ;
                if(dwSymbolID != INVALID_SYMBOLID)  // found
                    ;  // nothing else is needed, just return.
                else   // not found, must register.
                {
                    if(!BallocElementFromMasterTable(MTI_SYMBOLTREE,
                        &dwCurNode, pglobl))
                    {
                        return(INVALID_SYMBOLID);  // report failure.
                    }
                    // tack new symbol onto head of list.
                    if(bCopy)
                    {
                        if(!BaddAARtoHeap(paarSymbol,
                                   &(psn[dwCurNode].arSymbolName), 1, pglobl) )
                            return(INVALID_SYMBOLID);  // report failure.
                    }
                    else
                    {
                        //  derive one from the other.
                        psn[dwCurNode].arSymbolName.dwCount =
                                                paarSymbol->dw ;
                        psn[dwCurNode].arSymbolName.loOffset  =
                                                (DWORD)(paarSymbol->pub - mpubOffRef);
                    }
                    dwSymbolID = psn[dwCurNode].dwSymbolID =
                    psn[dwRootOptions].dwSymbolID + 1;  // increment last ID
                    psn[dwCurNode].dwNextSymbol = dwRootOptions ;
                        // link to previous symbols.
                    psn[dwCurNode].dwSubSpaceIndex = INVALID_INDEX ;
                        // option symbols have no subspace.
                    psn[dwFeatureIndex].dwSubSpaceIndex = dwRootOptions =
                        dwCurNode ;  // points to most recent symbol
                }
            }
#if PARANOID
            }
            else
            {
                //  BUG_BUG:
                ERR(("DWregisterSymbol: option or case construct is not enclosed within feature or switch !\n"));
                return(INVALID_SYMBOLID);  // report failure.
            }
#endif
            break;
        }
        default:
        {
            //  PARANOID  BUG_BUG:
            ERR(("DWregisterSymbol: construct has no symbol class.\n"));
            return(INVALID_SYMBOLID);  // report failure.
        }
    }
    return(dwSymbolID) ;
}





BOOL  BaddAARtoHeap(
PABSARRAYREF    paarSrc,
PARRAYREF       parDest,
DWORD           dwAlign,   //  write data to address that is a multiple of dwAlign
PGLOBL          pglobl)
//  this function copies a non NULL terminated string fragment
//  referenced by an 'aar'
//  into the communal STRINGHEAP  and returns an 'ar'
//  which describes the location of the copy.
{
    PBYTE  pubSrc, pubDest ;
    DWORD  dwCnt ;  // num bytes to copy.

    // legal values for dwAlign are 1 and 4.

    mloCurHeap = (mloCurHeap + dwAlign - 1) / dwAlign ;
    mloCurHeap *= dwAlign ;

    pubSrc = paarSrc->pub ;
    dwCnt = paarSrc->dw ;
    pubDest = mpubOffRef + mloCurHeap ;


    //  is there enough room in the heap ?
    //  don't forget the NULL.
    if(mloCurHeap + dwCnt + 1 >  mdwMaxHeap)
    {
        //   log error to debug output.
        //  register error so appropriate action is taken.
        if(ERRSEV_RESTART > geErrorSev)
        {
            geErrorSev = ERRSEV_RESTART ;
            geErrorType = ERRTY_MEMORY_ALLOCATION ;
            gdwMasterTabIndex = MTI_STRINGHEAP ;
        }
        return(FALSE);
    }

    parDest->dwCount = dwCnt ;
    parDest->loOffset =  mloCurHeap;  // offset only!
    memcpy(pubDest, pubSrc, dwCnt);
    //   the copy may also fail for random reasons!
    pubDest[dwCnt] = '\0' ;  //  Add Null termination.
    mloCurHeap += (dwCnt + 1);   // update heap ptr.

    return(TRUE) ;
}



BOOL     BwriteToHeap(
OUT  PDWORD  pdwDestOff,  //  heap offset of dest string
     PBYTE   pubSrc,       //  points to src string
     DWORD   dwCnt,        //  num bytes to copy from src to dest.
     DWORD   dwAlign,   //  write data to address that is a multiple of dwAlign
     PGLOBL  pglobl)
//  this function copies dwCnt bytes from pubSrc to
//  top of heap and writes the offset of the destination string
//  to pdwDestOff.   Nothing is changed if FAILS.
//  Warning!  No Null termination is added to string.
{
    PBYTE  pubDest ;

    // legal values for dwAlign are 1 and 4.

    mloCurHeap = (mloCurHeap + dwAlign - 1) / dwAlign ;
    mloCurHeap *= dwAlign ;

    pubDest = mpubOffRef + mloCurHeap ;

    //  is there enough room in the heap ?
    if(mloCurHeap + dwCnt  >  mdwMaxHeap)
    {
        //  log error to debug output.
        //  register error so appropriate action is taken.
        ERR(("BwriteToHeap: out of heap - restarting.\n"));
        if(ERRSEV_RESTART > geErrorSev)
        {
            geErrorSev = ERRSEV_RESTART ;
            geErrorType = ERRTY_MEMORY_ALLOCATION ;
            gdwMasterTabIndex = MTI_STRINGHEAP ;
        }
        return(FALSE);
    }

    memcpy(pubDest, pubSrc, dwCnt);
    //  the copy may also fail for random reasons!
    *pdwDestOff = mloCurHeap ;
    mloCurHeap += (dwCnt);   // update heap ptr.

    return(TRUE) ;
}


DWORD   DWsearchSymbolListForAAR(
PABSARRAYREF    paarSymbol,
DWORD           dwNodeIndex,
PGLOBL          pglobl)
//  given a 'aar' to a string representing a symbol, search
//  the SymbolList beginning at dwNodeIndex for this symbol.
//  Return its symbolID  if found, else return the INVALID_SYMBOLID.
{
    PSYMBOLNODE     psn ;

    psn = (PSYMBOLNODE) gMasterTable[MTI_SYMBOLTREE].pubStruct ;

    for( ; dwNodeIndex != INVALID_INDEX ;
        dwNodeIndex = psn[dwNodeIndex].dwNextSymbol)
    {
        if(BCmpAARtoAR(paarSymbol,  &(psn[dwNodeIndex].arSymbolName), pglobl) )
            return(psn[dwNodeIndex].dwSymbolID);  // string matches !
    }
    return(INVALID_SYMBOLID);
}


DWORD   DWsearchSymbolListForID(
DWORD       dwSymbolID,   // find node containing this ID.
DWORD       dwNodeIndex, // start search here.
PGLOBL      pglobl)
//  given a  symbolID, search the SymbolList beginning at dwNodeIndex
//  for this symbol.
//  If found return the node index which contains the requested symbolID,
//  else return INVALID_INDEX.
{
    PSYMBOLNODE     psn ;

    psn = (PSYMBOLNODE) gMasterTable[MTI_SYMBOLTREE].pubStruct ;

    for( ; dwNodeIndex != INVALID_INDEX ;
        dwNodeIndex = psn[dwNodeIndex].dwNextSymbol)
    {
        if(psn[dwNodeIndex].dwSymbolID == dwSymbolID)
            return(dwNodeIndex);  // ID matches !
    }
    return(INVALID_INDEX);
}


BOOL  BCmpAARtoAR(
PABSARRAYREF    paarStr1,
PARRAYREF       parStr2,
PGLOBL          pglobl)
//  Compares two strings, one referenced by 'aar' the other
//  referenced by 'ar'.  Returns TRUE if they match, FALSE
//  otherwise.
{
    if(paarStr1->dw != parStr2->dwCount)
        return(FALSE) ;  // Lengths don't even match!
    if(strncmp(paarStr1->pub, mpubOffRef + parStr2->loOffset ,  paarStr1->dw))
        return(FALSE) ;
    return(TRUE) ;
}


BOOL  BpopState(
PGLOBL          pglobl)
{
    if(mdwCurStsPtr)
    {
        mdwCurStsPtr-- ;
        return(TRUE);
    }
    else
    {
        //  ERR(("Unmatched closing brace!\n"));
        //  message moved to caller.
        //  in the future make parser smarter.
        geErrorType = ERRTY_SYNTAX ;
        geErrorSev = ERRSEV_FATAL ;
        return(FALSE);
    }
}





VOID   VinitDictionaryIndex(
PGLOBL          pglobl)
/*
    MainKeywordTable[]  is assumed to be divided into
    a NonAttributes section and several Attributes sections
    with pstrKeyword = NULL dividing the sections.
    The end of the table is also terminated by a NULL entry.
    This function initializes the grngDictionary[]
    which serves as an index into the main keyword Table.

*/
{
    DWORD dwI,  // keywordTable Index
        dwSect ;  //  RNGDICTIONARY Index
    PRANGE   prng ;

    prng  = (PRANGE)(gMasterTable[MTI_RNGDICTIONARY].pubStruct) ;


    for(dwI = dwSect = 0 ; dwSect < END_ATTR ; dwSect++, dwI++)
    {
        prng[dwSect].dwStart = dwI ;

        for(  ; mMainKeywordTable[dwI].pstrKeyword ; dwI++ )
            ;

        prng[dwSect].dwEnd = dwI ;  // one past the last entry
    }
}

VOID    VcharSubstitution(
PABSARRAYREF   paarStr,
BYTE           ubTgt,
BYTE           ubReplcmnt,
PGLOBL         pglobl)
{
    DWORD   dwI ;

    for(dwI = 0 ; dwI < paarStr->dw ; dwI++)
    {
        if(paarStr->pub[dwI] == ubTgt)
            paarStr->pub[dwI] = ubReplcmnt ;
    }
}


VOID   VIgnoreBlock(
PTKMAP  ptkmap,
BOOL    bIgnoreBlock,
PGLOBL  pglobl)
//  This boolean determines the message that will be issued.
{
    /*  Should we ignore?  check that first non-NULL entry
        after wCurEntry  is open brace if so
        ignore all entries up to EOF or matching closing
        brace.  */

    DWORD       dwKeywordID, dwDepth ; // depth relative to *IgnoreBlock


    ptkmap->dwKeywordID = ID_NULLENTRY ;  // neutralize keyword regardless.
    ptkmap++ ;
    dwKeywordID = ptkmap->dwKeywordID ;
    while(dwKeywordID == ID_NULLENTRY)  // skip nulls, comments etc.
    {
        dwKeywordID = (++ptkmap)->dwKeywordID ;
    }
    if(dwKeywordID < ID_SPECIAL  &&
        mMainKeywordTable[dwKeywordID].eType == TY_CONSTRUCT  &&
        mMainKeywordTable[dwKeywordID].dwSubType ==
        CONSTRUCT_OPENBRACE )
    {
        ptkmap->dwKeywordID = ID_NULLENTRY ;
        dwDepth = 1 ;
        ptkmap++ ;
        if(bIgnoreBlock)
        {
            if(gdwVerbosity >= 4)
                ERR(("Note: Ignoring block following *IgnoreBlock.\n"));
        }
        else
            ERR(("Ignoring block following unrecognized keyword.\n"));
    }
    else
    {
        if(bIgnoreBlock  &&  gdwVerbosity >= 2)
            ERR(("Note:  Brace delimited block not found after *IgnoreBlock.\n"));
        return ;  // do nothing.
    }
    while(dwDepth)
    {
        dwKeywordID = ptkmap->dwKeywordID ;
        if(dwKeywordID == ID_EOF)
        {
            ERR(("Ignoring Block: EOF encountered before closing brace.\n"));
            return ;    //  stop regardless!
        }
        if(dwKeywordID < ID_SPECIAL)
        {
            KEYWORD_TYPE    eType;
            CONSTRUCT       eSubType ;

            eType = mMainKeywordTable[dwKeywordID].eType ;
            if(eType  ==  TY_CONSTRUCT)
            {
                eSubType = (CONSTRUCT)(mMainKeywordTable[dwKeywordID].dwSubType) ;
                if(eSubType == CONSTRUCT_OPENBRACE)
                    dwDepth++ ;
                else if( eSubType == CONSTRUCT_CLOSEBRACE)
                    dwDepth-- ;
            }
        }
        ptkmap->dwKeywordID = ID_NULLENTRY ;
        ptkmap++ ;
    }

    return ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\parsers\gpd\treewalk.c ===
//   Copyright (c) 1996-1999  Microsoft Corporation
/*  treewalk.c - functions to enumerate string and font IDs found
in the GPD file.  */

/*  this source file used only by mdt  so is built only
as part of the gpd library  */

#include    "gpdparse.h"


#ifndef  PARSERDLL



// ----  functions defined in treewalk.c ---- //
BOOL    GetGPDResourceIDs(
PDWORD pdwResArray,
DWORD   dwArraySize,    //  number of elements in array.
PDWORD   pdwNeeded,
BOOL bFontIDs,
PRAWBINARYDATA prbd) ;

BOOL   BWalkTheAttribTree(
PBYTE   pubnRaw,  // start of Rawbinary data
IN  ATREEREF    atrRoot,    //  root of attribute tree to navigate.
IN  BOOL    bList,  // is the value stored as a list?
OUT PDWORD      arIDarray,   //  caller supplied array to be
                                    //  filled in with all resource IDs found.
IN  DWORD   dwArraySize,    //  number of elements in array.
IN  OUT     PDWORD   pdwNeeded   // number of resource IDs
);

BOOL    BRecurseDownTheTree(
PBYTE   pubnRaw,  // start of Rawbinary data
IN  DWORD    dwNodeIndex,    //   first node in chain of attribute tree to navigate.
IN  BOOL    bList,  // is the value stored as a list?
OUT PDWORD      arIDarray,   //  caller supplied array to be
                                    //  filled in with all resource IDs found.
IN  DWORD   dwArraySize,    //  number of elements in array.
IN  OUT     PDWORD   pdwNeeded   // number of resource IDs
) ;

BOOL    bWalkTheList(
PBYTE   pubnRaw,  // start of Rawbinary data
IN  DWORD    dwListIndex,    //   first node in LIST to navigate.
OUT PDWORD      arIDarray,   //  caller supplied array to be
                                    //  filled in with all resource IDs found.
IN  DWORD   dwArraySize,    //  number of elements in array.
IN  OUT     PDWORD   pdwNeeded   // number of resource IDs
);

BOOL    bAddIDtoArray(
IN  DWORD    dwID,    //   ID value to add to array.
OUT PDWORD      arIDarray,   //  caller supplied array to be
                                    //  filled in with all resource IDs found.
IN  DWORD   dwArraySize,    //  number of elements in array.
IN  OUT     PDWORD   pdwNeeded   // number of resource IDs
);




BOOL    GetGPDResourceIDs(
PDWORD pdwResArray,
DWORD   dwArraySize,    //  number of elements in array.
PDWORD   pdwNeeded,
BOOL bFontIDs,
PRAWBINARYDATA prbd)
/*
Parameters:
    pdwResArray     Resource IDs are loaded into this array
    dwArraySize     Number of elements in the array
    pdwNeeded       Number of IDs of the specified resource in the GPD
    bFontIDs        True if UFM IDs should be loaded into array or false if string IDs should be loaded
    prbd        GPD raw data pointer from GPDPARSE.DLL.
Returns:
   Return FALSE only if BUD corruption has occured.

  if  pdwResArray is NULL, the number of elements required for the array  is stored in pdwNeeded.
  if pdwResArray is not NULL, the number of Resource IDs copied into the array  is stored in pdwNeeded.

*/
{
    PENHARRAYREF   pearTableContents ;
    PBYTE   pubRaw ;
    PSTATICFIELDS   pStatic ;
    PBYTE   pubHeap ;  // ptr to start of heap.
    PGLOBALATTRIB  pga ;
    PATREEREF    patrRoot ;    //  root of attribute tree to navigate.
    BOOL    bStatus = TRUE ;
    DWORD   dwNumFeatures, dwFea, dwNumStructs, dwIndex,
                    dwStart, dwEnd, dwI;
    PDFEATURE_OPTIONS  pfo ;
    PTTFONTSUBTABLE     pttfs ;
    PFONTCART                 pfontcart ;



    *pdwNeeded = 0 ;  // initally set to zero.

    pStatic = (PSTATICFIELDS)prbd ;    // transform pubRaw from PSTATIC
    pubRaw  = pStatic->pubBUDData ;         //  to PMINIRAWBINARYDATA


    //  pmrbd = (PMINIRAWBINARYDATA)pubRaw ;
    pearTableContents = (PENHARRAYREF)(pubRaw + sizeof(MINIRAWBINARYDATA)) ;


//  need to do this for each section in ssTableIndex

    pga = (PGLOBALATTRIB)(pubRaw + pearTableContents[MTI_GLOBALATTRIB].
                            loOffset) ;


    dwStart = pStatic->ssTableIndex[SSTI_GLOBALS].dwStart ;  // starting Index
    dwEnd = pStatic->ssTableIndex[SSTI_UPDATE_UIINFO].dwEnd ;  // Ending Index

    for(dwI = dwStart ; bStatus  &&  (dwI < dwEnd) ; dwI++)
    {
        if(!(pStatic->snapShotTable[dwI].dwNbytes))
            continue ;  // skip over section delimiter.

        if(bFontIDs  &&  !(pStatic->snapShotTable[dwI].dwFlags  & SSF_FONTID))
            continue;
        if(!bFontIDs  &&  !(pStatic->snapShotTable[dwI].dwFlags  & SSF_STRINGID))
            continue;

        patrRoot = (PATREEREF)((PBYTE)pga +
                    pStatic->snapShotTable[dwI].dwSrcOffset) ;

        bStatus = BWalkTheAttribTree(
            (PBYTE)prbd,  // start of Rawbinary data
            *patrRoot,    //
            pStatic->snapShotTable[dwI].dwFlags  & SSF_LIST,  // is the value stored as a list?
            pdwResArray,
            dwArraySize,    //  number of elements in array.
            pdwNeeded   ) ;
    }
    if(!bStatus)
        return(bStatus);

    //  find IDs in Feature/Option structure.

    pfo = (PDFEATURE_OPTIONS)(pubRaw + pearTableContents[MTI_DFEATURE_OPTIONS].
                                loOffset) ;
    dwNumFeatures = pearTableContents[MTI_DFEATURE_OPTIONS].dwCount  ;
    dwNumFeatures += pearTableContents[MTI_SYNTHESIZED_FEATURES].dwCount  ;

    for( dwFea = 0 ; dwFea < dwNumFeatures ; dwFea++)
    {
        dwStart = pStatic->ssTableIndex[SSTI_FEATURES].dwStart ;  // starting Index
        dwEnd = pStatic->ssTableIndex[SSTI_UPDATE_OPTIONEX].dwEnd ;  // Ending Index

        for(dwI = dwStart ; bStatus  &&  (dwI < dwEnd) ; dwI++)
        {
            if(!(pStatic->snapShotTable[dwI].dwNbytes))
                continue ;  // skip over section delimiter.

            if(bFontIDs  &&  !(pStatic->snapShotTable[dwI].dwFlags  & SSF_FONTID))
                continue;
            if(!bFontIDs  &&  !(pStatic->snapShotTable[dwI].dwFlags  & SSF_STRINGID))
                continue;

            patrRoot = (PATREEREF)((PBYTE)(pfo + dwFea) +
                        pStatic->snapShotTable[dwI].dwSrcOffset) ;

            bStatus = BWalkTheAttribTree(
                (PBYTE)prbd,  // start of Rawbinary data
                *patrRoot,    //
                pStatic->snapShotTable[dwI].dwFlags  & SSF_LIST,  // is the value stored as a list?
                pdwResArray,
                dwArraySize,    //  number of elements in array.
                pdwNeeded   ) ;
        }
        if(!bStatus)
            return(bStatus);
    }


    pfontcart = (PFONTCART)(pubRaw + pearTableContents[MTI_FONTCART].
                            loOffset) ;

    dwNumStructs = pearTableContents[MTI_FONTCART].dwCount  ;

    for( dwIndex = 0 ; bStatus  &&  (dwIndex < dwNumStructs) ; dwIndex++)
    {
        if(bFontIDs)
        {
            bStatus = bWalkTheList(
                            (PBYTE)prbd,  pfontcart[dwIndex].dwPortFontLst,
                            pdwResArray,  dwArraySize, pdwNeeded ) ;
            if(!bStatus)
                break;
            bStatus = bWalkTheList(
                            (PBYTE)prbd,  pfontcart[dwIndex].dwLandFontLst,
                            pdwResArray,  dwArraySize, pdwNeeded ) ;
            if(!bStatus)
                break;
        }
        else
        {
            bStatus = bAddIDtoArray(
                 pfontcart[dwIndex].dwRCCartNameID,    //   ID value to add to array.
                pdwResArray, dwArraySize,  pdwNeeded) ;
        }

        //  DWORD   dwFontLst ;  // Index to list of FontIDs
        //  is already incorporated into landscape and portrait lists
    }


    pttfs = (PTTFONTSUBTABLE)(pubRaw + pearTableContents[MTI_TTFONTSUBTABLE].
                            loOffset) ;

    dwNumStructs = pearTableContents[MTI_TTFONTSUBTABLE].dwCount  ;

    for( dwIndex = 0 ; !bFontIDs  &&  bStatus  &&
                    (dwIndex < dwNumStructs) ; dwIndex++)
    {
        bStatus = bAddIDtoArray(
             pttfs[dwIndex].dwRcTTFontNameID,    //   ID value to add to array.
            pdwResArray, dwArraySize,  pdwNeeded) ;

        if(!bStatus)
            break;

        bStatus = bAddIDtoArray(
             pttfs[dwIndex].dwRcDevFontNameID,    //   ID value to add to array.
            pdwResArray, dwArraySize,  pdwNeeded) ;
    }

    return(bStatus);
}



//   Return FALSE only if BUD corruption has occured.

BOOL   BWalkTheAttribTree(
PBYTE   pubnRaw,  // start of Rawbinary data
IN  ATREEREF    atrRoot,    //  root of attribute tree to navigate.
IN  BOOL    bList,  // is the value stored as a list?
OUT PDWORD      arIDarray,   //  caller supplied array to be
                                    //  filled in with all resource IDs found.
IN  DWORD   dwArraySize,    //  number of elements in array.
IN  OUT     PDWORD   pdwNeeded   // number of resource IDs
                                            //  or values found.  Initial value
                                            //  may be non-zero since this
                                            //  accumulates starting from the
                                            //  first call.  Also serves to track where
                                            //  in arIDarray the function should
                                            //  be storing the ID values.
)
{
    PATTRIB_TREE    patt ;  // start of ATTRIBUTE tree array.
    DWORD  dwNodeIndex;  // Points to first node in chain

    PENHARRAYREF   pearTableContents ;
    PBYTE   pubRaw ;
    PSTATICFIELDS   pStatic ;
    PBYTE   pubHeap ;  // ptr to start of heap.
    BOOL    bStatus = TRUE ;
    DWORD   dwValue, dwListIndex ;   // index to listnode.
    PDWORD   pdwID ;   // points to value on the heap.


    pStatic = (PSTATICFIELDS)pubnRaw ;    // transform pubRaw from PSTATIC
    pubRaw  = pStatic->pubBUDData ;         //  to PMINIRAWBINARYDATA


    //  obtain pointers to structures:

    pearTableContents = (PENHARRAYREF)(pubRaw + sizeof(MINIRAWBINARYDATA)) ;

    patt = (PATTRIB_TREE)(pubRaw + pearTableContents[MTI_ATTRIBTREE].
                            loOffset) ;

    pubHeap = (PBYTE)(pubRaw + pearTableContents[MTI_STRINGHEAP].
                            loOffset) ;

    //  *pdwNeeded  = 0 ;  //  this is done only once by the caller.

    //  after processing initial special cases, call another
    //  function to perform the recursion at each Feature level.

    if(atrRoot == ATTRIB_UNINITIALIZED)
        return TRUE ;  // go to next keyword.
    if(atrRoot & ATTRIB_HEAP_VALUE)
    {
        dwValue = *(PDWORD)(pubHeap + (atrRoot & ~ATTRIB_HEAP_VALUE) );

        if(bList)
        {
            dwListIndex = dwValue ;
            //  now need to traverse the listnodes.
            bStatus = bWalkTheList(
                            pubnRaw,  dwListIndex,
                            arIDarray,  dwArraySize, pdwNeeded ) ;
        }
        else    // ID Value is in the heap.
        {
            bStatus = bAddIDtoArray(dwValue,  //   ID value to add to array.
                arIDarray, dwArraySize,  pdwNeeded) ;
        }
        return(bStatus);  //  no more tree traveral to be done.
    }
    //  else    atrRoot specifies a node index
    dwNodeIndex = atrRoot ;

    //  first node only might be the global default initializer:
    if(patt[dwNodeIndex].dwFeature == DEFAULT_INIT )
    {
        // we have a global default initializer!
        //  it may be assumed dwOffset contains heap offset.
        if(patt[dwNodeIndex].eOffsetMeans != VALUE_AT_HEAP )
            return(FALSE);  // assumption violated.  BUD is corrupted.

        dwValue = *(PDWORD)(pubHeap + patt[dwNodeIndex].dwOffset) ;

        if(bList)
        {
            dwListIndex = dwValue ;
            //  now need to traverse the listnodes.
            bStatus = bWalkTheList(
                            pubnRaw,  dwListIndex,
                            arIDarray,  dwArraySize, pdwNeeded ) ;
        }
        else    // ID Value is in the heap.
        {
            bStatus = bAddIDtoArray(dwValue,  //   ID value to add to array.
                arIDarray, dwArraySize,  pdwNeeded) ;
        }

        dwNodeIndex = patt[dwNodeIndex].dwNext ;  // to the next node.
    }

    if(bStatus)
        bStatus = BRecurseDownTheTree(
                        pubnRaw,  dwNodeIndex, bList,
                        arIDarray,  dwArraySize, pdwNeeded ) ;

    //  have we overflowed the caller supplied array?
    //  who cares, just return.  It is the callers responsibility
    //  to see how many IDs were found and how much was
    //  allocated.
    return(bStatus);
}


BOOL    BRecurseDownTheTree(
PBYTE   pubnRaw,  // start of Rawbinary data
IN  DWORD    dwNodeIndex,    //   first node in chain of attribute tree to navigate.
IN  BOOL    bList,  // is the value stored as a list?
OUT PDWORD      arIDarray,   //  caller supplied array to be
                                    //  filled in with all resource IDs found.
IN  DWORD   dwArraySize,    //  number of elements in array.
IN  OUT     PDWORD   pdwNeeded   // number of resource IDs
                                            //  or values found.  Initial value
                                            //  may be non-zero since this
                                            //  accumulates starting from the
                                            //  first call.  Also serves to track where
                                            //  in arIDarray the function should
                                            //  be storing the ID values.
)
{
    PATTRIB_TREE    patt ;  // start of ATTRIBUTE tree array.

    PENHARRAYREF   pearTableContents ;
    PBYTE   pubRaw ;
    PSTATICFIELDS   pStatic ;
    PBYTE   pubHeap ;  // ptr to start of heap.
    BOOL    bStatus = TRUE ;
    DWORD   dwValue;

    pStatic = (PSTATICFIELDS)pubnRaw ;    // transform pubRaw from PSTATIC
    pubRaw  = pStatic->pubBUDData ;         //  to PMINIRAWBINARYDATA


    //  obtain pointers to structures:

    pearTableContents = (PENHARRAYREF)(pubRaw + sizeof(MINIRAWBINARYDATA)) ;

    patt = (PATTRIB_TREE)(pubRaw + pearTableContents[MTI_ATTRIBTREE].
                            loOffset) ;

    pubHeap = (PBYTE)(pubRaw + pearTableContents[MTI_STRINGHEAP].
                            loOffset) ;



    //  traverse the tree with wild abandon!  No more
    //  special cases to worry about!


    for(  ;  bStatus  &&   dwNodeIndex != END_OF_LIST ;
            dwNodeIndex = patt[dwNodeIndex].dwNext  )
    {
        //  does this node contain a sublevel?
        if(patt[dwNodeIndex].eOffsetMeans == NEXT_FEATURE)
        {
            DWORD   dwNewNodeIndex;

            // Down to the next level we go.
            dwNewNodeIndex = patt[dwNodeIndex ].dwOffset ;

            bStatus = BRecurseDownTheTree(
                                pubnRaw,  dwNewNodeIndex, bList,
                                arIDarray,  dwArraySize, pdwNeeded ) ;
        }
        else if(patt[dwNodeIndex].eOffsetMeans == VALUE_AT_HEAP)
        {
            dwValue = *(PDWORD)(pubHeap + patt[dwNodeIndex].dwOffset) ;

            if(bList)
            {
                DWORD   dwListIndex = dwValue;

                //  now need to traverse the listnodes.
                bStatus = bWalkTheList(
                                pubnRaw,  dwListIndex,
                                arIDarray,  dwArraySize, pdwNeeded ) ;
            }
            else    // ID Value is in the heap.
            {
                bStatus = bAddIDtoArray(dwValue,  //   ID value to add to array.
                    arIDarray, dwArraySize,  pdwNeeded) ;
            }
        }
        else
            bStatus = FALSE ;  //  Tree corruption.
    }

    return(bStatus);
}



BOOL    bWalkTheList(
PBYTE   pubnRaw,  // start of Rawbinary data
IN  DWORD    dwListIndex,    //   first node in LIST to navigate.
OUT PDWORD      arIDarray,   //  caller supplied array to be
                                    //  filled in with all resource IDs found.
IN  DWORD   dwArraySize,    //  number of elements in array.
IN  OUT     PDWORD   pdwNeeded   // number of resource IDs
                                            //  or values found.  Initial value
                                            //  may be non-zero since this
                                            //  accumulates starting from the
                                            //  first call.  Also serves to track where
                                            //  in arIDarray the function should
                                            //  be storing the ID values.
)
{
    PLISTNODE    plstRoot ;  // start of LIST array

    PENHARRAYREF   pearTableContents ;
    PBYTE   pubRaw ;
    PSTATICFIELDS   pStatic ;
    BOOL    bStatus = TRUE ;

    pStatic = (PSTATICFIELDS)pubnRaw ;    // transform pubRaw from PSTATIC
    pubRaw  = pStatic->pubBUDData ;         //  to PMINIRAWBINARYDATA


    //  obtain pointers to structures:

    pearTableContents = (PENHARRAYREF)(pubRaw + sizeof(MINIRAWBINARYDATA)) ;

    plstRoot = (PLISTNODE)(pubRaw + pearTableContents[MTI_LISTNODES].
                            loOffset) ;


    for(  ;  bStatus  &&   dwListIndex != END_OF_LIST ;
            dwListIndex = plstRoot[dwListIndex].dwNextItem  )
    {
        bStatus = bAddIDtoArray(
             plstRoot[dwListIndex].dwData,    //   ID value to add to array.
            arIDarray, dwArraySize,  pdwNeeded) ;
    }
    return(bStatus);
}



BOOL    bAddIDtoArray(
IN  DWORD    dwID,    //   ID value to add to array.
OUT PDWORD      arIDarray,   //  caller supplied array to be
                                    //  filled in with all resource IDs found.
IN  DWORD   dwArraySize,    //  number of elements in array.
IN  OUT     PDWORD   pdwNeeded   // number of resource IDs
                                            //  or values found.  Initial value
                                            //  may be non-zero since this
                                            //  accumulates starting from the
                                            //  first call.  Also serves to track where
                                            //  in arIDarray the function should
                                            //  be storing the ID values.
)
{
        if(arIDarray  &&  *pdwNeeded < dwArraySize)
        {
            arIDarray[*pdwNeeded] =  dwID ;
        }

        (*pdwNeeded)++ ;
        return(TRUE);
}


/*  simplified rules for traversing attribute tree:
    features:  only time you need to check features is
    when you are looking at the first node.  Because this may be
    the Global default Initializer.

    Otherwise dwNext will always take you along to the next option
    until you hit END_OF_LIST.

    Now OffsetMeans = heapoffset  means you extract the value
        at the heap or interpret the heapoffset as the array index
        of a listnode.
    if Offsetmeans = Next_Fea, interpret heapoffset as treenode
        index and begin searching in this new branch.
        You must perform recursion.

    so this function must pass in a writable counter
    that track which entry in the user supplied array is
    'current'  (ready to be written into).   This serves both
    to keep track of where to write the ID values and how large
    an array the user should supply.  This same counter
    must be passed into the function that walks the listnodes.      */

#endif  PARSERDLL
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\parsers\gpd\value1.c ===
//   Copyright (c) 1996-1999  Microsoft Corporation
/*  value1.c - functions to parse value field
and to convert the information into the proper
binary format.  */


#include    "gpdparse.h"


// ----  functions defined in value1.c ---- //

BOOL   BaddValueToHeap(
IN  OUT  PDWORD  ploHeap,  // dest offset to value in binary form
IN   PTKMAP  ptkmap,   // pointer to tokenmap
IN   BOOL    bOverWrite,  // assume ploHeap contains a valid offset
        //  to a reserved region of the heap of the proper size
        //  and write binary value into this location instead of
        //  growing heap.  Note:  defer overwriting lpHeap
        //  until we are certain of success.
IN OUT PGLOBL pglobl
) ;

BOOL   BparseAndWrite(
IN     PBYTE   pubDest,       // write binary data or link to this address.
IN     PTKMAP  ptkmap,        // pointer to tokenmap
IN     BOOL    bAddToHeap,    // if true, write to curHeap not pubDest
OUT    PDWORD  pdwHeapOffset, // if (bAddToHeap)  heap offset where
IN OUT PGLOBL  pglobl
) ;

BOOL    BparseInteger(
IN  PABSARRAYREF  paarValue,
IN  PDWORD        pdwDest,       //  write dword value here.
IN  VALUE         eAllowedValue,  // dummy
IN  PGLOBL        pglobl
)  ;

BOOL    BparseList(
IN      PABSARRAYREF  paarValue,
IN      PDWORD        pdwDest,   //  location where index to start of list
                                 //  is saved
IN      BOOL          (*fnBparseValue)(PABSARRAYREF, PDWORD, VALUE, PGLOBL),   // callback
IN      VALUE         eAllowedValue, // dummy
IN  OUT PGLOBL        pglobl
) ;

BOOL    BeatLeadingWhiteSpaces(
IN  OUT  PABSARRAYREF   paarSrc
) ;

BOOL    BeatDelimiter(
IN  OUT  PABSARRAYREF   paarSrc,
IN  PBYTE  pubDelStr        //  points to a string which paarSrc must match
) ;

BOOL    BdelimitToken(
IN  OUT  PABSARRAYREF   paarSrc,    //  source string
IN  PBYTE   pubDelimiters,          //  array of valid delimiters
OUT     PABSARRAYREF   paarToken,   //  token defined by delimiter
OUT     PDWORD      pdwDel      //  which delimiter was first encountered?
) ;

BOOL    BeatSurroundingWhiteSpaces(
IN  PABSARRAYREF   paarSrc
) ;

BOOL    BparseSymbol(
IN  PABSARRAYREF  paarValue,
IN  PDWORD        pdwDest,        //  write dword value here.
IN  VALUE         eAllowedValue,  // which class of symbol is this?
IN  PGLOBL        pglobl
)  ;

BOOL    BparseQualifiedName
(
IN  PABSARRAYREF   paarValue,
IN  PDWORD         pdwDest,       //  write dword value here.
IN  VALUE          eAllowedValue, // which class of symbol is this?
IN  PGLOBL         pglobl
)  ;

BOOL    BparseQualifiedNameEx
(
IN  PABSARRAYREF  paarValue,
IN  PDWORD        pdwDest,       //  write dword value here.
IN  VALUE         eAllowedValue, // which class of symbol is this?
IN  PGLOBL        pglobl
)  ;


BOOL    BparsePartiallyQualifiedName
(
IN  PABSARRAYREF   paarValue,
IN  PDWORD         pdwDest,        //  write dword value here.
IN  VALUE          eAllowedValue,  // which class of symbol is this?
IN  PGLOBL         pglobl
) ;

BOOL    BparseOptionSymbol(
IN  PABSARRAYREF  paarValue,
IN  PDWORD        pdwDest,       //  write dword value here.
IN  VALUE         eAllowedValue, // which class of symbol is this?
IN  PGLOBL        pglobl
) ;

BOOL    BparseConstant(
IN  OUT  PABSARRAYREF  paarValue,
OUT      PDWORD        pdwDest,       //  write dword value here.
IN       VALUE         eAllowedValue,  // which class of constant is this?
IN       PGLOBL        pglobl
) ;

BOOL  BinitClassIndexTable(
IN  OUT PGLOBL      pglobl) ;

BOOL    BparseRect(
IN  PABSARRAYREF   paarValue,
IN  PRECT   prcDest,
    PGLOBL  pglobl
) ;

BOOL    BparsePoint(
IN  PABSARRAYREF   paarValue,
IN  PPOINT   pptDest,
    PGLOBL   pglobl
) ;

BOOL    BparseString(
IN  PABSARRAYREF   paarValue,
IN  PARRAYREF      parStrValue,
IN  OUT PGLOBL     pglobl
) ;

BOOL    BparseAndTerminateString(
IN  PABSARRAYREF   paarValue,
IN  PARRAYREF      parStrValue,
IN  VALUE          eAllowedValue,
IN  OUT PGLOBL     pglobl
) ;

BOOL     BwriteUnicodeToHeap(
IN   PARRAYREF      parSrcString,
OUT  PARRAYREF      parUnicodeString,
IN  INT             iCodepage,
IN  OUT PGLOBL      pglobl
) ;

BOOL    BparseStrSegment(
IN  PABSARRAYREF   paarStrSeg,       // source str segment
IN  PARRAYREF      parStrLiteral,    // dest for result
IN  OUT PGLOBL     pglobl
) ;

BOOL    BparseStrLiteral(
IN  PABSARRAYREF   paarStrSeg,       // points to literal substring segment.
IN  PARRAYREF      parStrLiteral,    // dest for result
IN  OUT PGLOBL     pglobl
) ;

BOOL    BparseHexStr(
IN  PABSARRAYREF   paarStrSeg,       // points to hex substring segment.
IN  PARRAYREF      parStrLiteral,    // dest for result
IN OUT PGLOBL      pglobl
) ;

BOOL    BparseOrderDep(
IN  PABSARRAYREF   paarValue,
IN  PORDERDEPENDENCY   pordDest,
    PGLOBL          pglobl
) ;

PDWORD   pdwEndOfList(
PDWORD   pdwNodeIndex,
PGLOBL   pglobl) ;

#ifdef  GMACROS

PBYTE    ExtendChain(
         PBYTE   pubDest,
 IN      BOOL    bOverWrite,
 IN  OUT PGLOBL  pglobl) ;
#endif

// ---------------------------------------------------- //



BOOL   BaddValueToHeap(
IN  OUT  PDWORD  ploHeap,  // dest offset to value in binary form
IN   PTKMAP  ptkmap,   // pointer to tokenmap
IN   BOOL    bOverWrite,  // assume ploHeap contains a valid offset
        //  to a reserved region of the heap of the proper size
        //  and write binary value into this location instead of
        //  growing heap.  Note:  defer overwriting lpHeap
        //  until we are certain of success.
IN OUT PGLOBL pglobl
)
{
    DWORD       dwKeywordID ;
    PBYTE  pubDest ;


    dwKeywordID = ptkmap->dwKeywordID ;
    // BUG_BUG !!!!! what if dwKeywordID  is a special value?
    if(dwKeywordID >= ID_SPECIAL)
        return  FALSE ;

    //  note:  different attributes are stored in different places
    //  using different branching techniques.  See the
    //  Bstore_XXX_Attrib()  functions for the different
    //  setups.  This function works in concert with those
    //  functions.

    switch(mMainKeywordTable[dwKeywordID].flAgs & KWF_DEDICATED_FIELD)
    {   //  extract just the flags describing the attribute storage type.
        case KWF_TTFONTSUBS:
        {
            //  since ploHeap always points to the index
            //  of the appropriate FontSub structure,
            //  we ignore bOverWrite

            DWORD   dwOffset ;
            PTTFONTSUBTABLE   pttft ;

            dwOffset = mMainKeywordTable[dwKeywordID].dwOffset ;

            pttft = (PTTFONTSUBTABLE)
                    gMasterTable[MTI_TTFONTSUBTABLE].pubStruct +  *ploHeap;

            //  write binary data into (PBYTE)pttft + dwOffset ;
            pubDest = (PBYTE)pttft + dwOffset ;

            if(bOverWrite  &&
                mMainKeywordTable[dwKeywordID].flAgs & KWF_ADDITIVE  &&
                mMainKeywordTable[dwKeywordID].flAgs & KWF_LIST)
            {
                pubDest = (PBYTE)pdwEndOfList((PDWORD)pubDest, pglobl);  // walks the list and returns pointer
                                //  to the actual END_OF_LIST  value so it can be overwritten to
                                //   extend the list.
            }

#ifdef  GMACROS
            //   call this from every place that supports KWF_ADDITIVE.

            else if( mMainKeywordTable[dwKeywordID].flAgs & KWF_CHAIN)
            {
                if(!(pubDest = ExtendChain(pubDest, bOverWrite, pglobl)))
                    return(FALSE) ;
            }
#endif


            if(!BparseAndWrite(pubDest,  ptkmap, FALSE, NULL, pglobl ) )
            {
                return(FALSE) ;
            }
            break;
        }
        case KWF_FONTCART:
        {
            //  since ploHeap always points to the index
            //  of the appropriate FontCart structure,
            //  we ignore bOverWrite

            DWORD   dwOffset ;
            PFONTCART   pfc ;

            dwOffset = mMainKeywordTable[dwKeywordID].dwOffset ;

            pfc = (PFONTCART)
                    gMasterTable[MTI_FONTCART].pubStruct +  *ploHeap;

            //  write binary data into (PBYTE)pfc + dwOffset ;
            pubDest = (PBYTE)pfc + dwOffset ;

            if(bOverWrite  &&
                mMainKeywordTable[dwKeywordID].flAgs & KWF_ADDITIVE  &&
                mMainKeywordTable[dwKeywordID].flAgs & KWF_LIST)
            {
                pubDest = (PBYTE)pdwEndOfList((PDWORD)pubDest, pglobl);  // walks the list and returns pointer
                                //  to the actual END_OF_LIST  value so it can be overwritten to
                                //   extend the list.
            }
#ifdef  GMACROS
            else if( mMainKeywordTable[dwKeywordID].flAgs & KWF_CHAIN)
            {
                if(!(pubDest = ExtendChain(pubDest, bOverWrite, pglobl )))
                    return(FALSE) ;
            }
#endif

            if(!BparseAndWrite(pubDest,  ptkmap, FALSE, NULL , pglobl) )
            {
                return(FALSE) ;
            }
            break;
        }
        case KWF_COMMAND:
        {
            //  ploHeap actually points to the variable
            //  that will receive (or already contains) the CommandArray
            //  index .  This is most likely stored in the leaf node
            //  of the attribute tree or maybe the CommandTable
            //  itself if the command is single-valued.

            PCOMMAND    pcmd ;
            DWORD   dwOffset ;

            if(!bOverWrite)  //  ploHeap  is uninitialized.
            {
                //  obtain first free command element
                //  and initialize ploHeap.
                if(! BallocElementFromMasterTable(MTI_COMMANDARRAY ,
                    ploHeap, pglobl) )
                {
                    return(FALSE) ;
                }
            }
            //  this path now shared by both cases of (bOverWrite)

            pcmd = (PCOMMAND)
                gMasterTable[MTI_COMMANDARRAY].pubStruct +  *ploHeap;

            dwOffset = mMainKeywordTable[dwKeywordID].dwOffset ;

            //  write binary data into CmdArray[*ploHeap] +  dwOffset;
            //  since we write into reserved memory

            pubDest = (PBYTE)pcmd + dwOffset ;

            if(bOverWrite  &&
                mMainKeywordTable[dwKeywordID].flAgs & KWF_ADDITIVE  &&
                mMainKeywordTable[dwKeywordID].flAgs & KWF_LIST)
            {
                pubDest = (PBYTE)pdwEndOfList((PDWORD)pubDest, pglobl);  // walks the list and returns pointer
                                //  to the actual END_OF_LIST  value so it can be overwritten to
                                //   extend the list.
            }
#ifdef  GMACROS
            else if( mMainKeywordTable[dwKeywordID].flAgs & KWF_CHAIN)
            {
                if(!(pubDest = ExtendChain(pubDest, bOverWrite, pglobl )))
                    return(FALSE) ;
            }
#endif

            if(!BparseAndWrite(pubDest,  ptkmap, FALSE, NULL, pglobl ) )
            {
                return(FALSE) ;
            }
            break ;
        }
        default:   //  no dedicated structures, save data on heap.
        {
            if(bOverWrite)  //  ploHeap really does contain
            {               //  an offset to the heap.
                pubDest = mpubOffRef + *ploHeap ;

                if(mMainKeywordTable[dwKeywordID].flAgs & KWF_ADDITIVE  &&
                    mMainKeywordTable[dwKeywordID].flAgs & KWF_LIST)
                {
                    pubDest = (PBYTE)pdwEndOfList((PDWORD)pubDest, pglobl);  // walks the list and returns pointer
                                    //  to the actual END_OF_LIST  value so it can be overwritten to
                                    //   extend the list.
                }
#ifdef  GMACROS
                else if( mMainKeywordTable[dwKeywordID].flAgs & KWF_CHAIN)
                {
                    if(!(pubDest = ExtendChain(pubDest, bOverWrite, pglobl )))
                        return(FALSE) ;
                }
#endif

                if(!BparseAndWrite(pubDest,  ptkmap, FALSE, NULL, pglobl ) )
                {
                    return(FALSE) ;
                }
            }
            else
            {
                //  write at cur heap ptr, tell me where
                //  this is,  and advance CurHeap.
                if(!BparseAndWrite(NULL,  ptkmap,
                                TRUE,  ploHeap, pglobl) )
                {
                    return(FALSE) ;
                }
            }
            break ;
        }
    }
    return(TRUE) ;
}


BOOL   BparseAndWrite(
IN   PBYTE    pubDest,        // write binary data or link to this address.
IN   PTKMAP   ptkmap,         // pointer to tokenmap
IN   BOOL     bAddToHeap,     // if true, write to curHeap not pubDest
OUT  PDWORD   pdwHeapOffset,  // if (bAddToHeap)  heap offset where
                              // binary data or link to data was written to.
IN OUT PGLOBL pglobl
)
/*  parses value according to its expected type and writes
    the appropriate data into the appropriate structures
    (if the value is a composite object)  and places an
    appropriate link in pubDest or simply writes the binary
    data directly to pubDest (if simple object).
    If (bAddToHeap == TRUE) ignore pubDest and write
    data or link to curHeap location and return that offset
    in pdwHeapOffset.

    Warning!  this function allocates a tmp buffer (pubBuf)
    which is freed at the very end.
    So do not add extra returns() in this function
    without freeing this buffer.
*/
{
    DWORD       dwKeywordID ;
    VALUE       eAllowedValue ;  //  how should token be parsed?
    ABSARRAYREF   aarValue ;     //  location of value token
    BOOL        bList ;
    BOOL        bStatus = FALSE ;
    PBYTE        pubBuf = NULL ;
                //  temp Dest if needed.
    PBYTE       pubTmp ;  // points to dest for parsing function.



    dwKeywordID = ptkmap->dwKeywordID ;
    eAllowedValue = mMainKeywordTable[dwKeywordID].eAllowedValue ;
    aarValue = ptkmap->aarValue ;
    bList = (mMainKeywordTable[dwKeywordID].flAgs & KWF_LIST) ?
            (TRUE) : (FALSE);

    if(bAddToHeap)     //  PARANOID checks.
    {
        if(!pdwHeapOffset)
        {
            vIdentifySource(ptkmap, pglobl);
            ERR(("internal consistency error.  heap ptr not supplied.\n"));
            return(FALSE) ;
        }
    }
    else
    {
        if(!pubDest)
            return(FALSE) ;
    }

    if(bAddToHeap)
    {
        DWORD  dwSize ;  // for debugging purposes.

        dwSize = gValueToSize[VALUE_LARGEST] ;

        if(!(pubBuf = MemAlloc(dwSize) ))
        {
            geErrorSev = ERRSEV_FATAL ;
            geErrorType = ERRTY_MEMORY_ALLOCATION ;
            return(FALSE) ;
        }
    }
#ifdef  GMACROS
     if(bAddToHeap  && (mMainKeywordTable[dwKeywordID].flAgs & KWF_CHAIN))
     {
         if(!(pubTmp = ExtendChain(pubBuf, /* bOverWrite = */ FALSE, pglobl )))
             return(FALSE) ;
     }
     else
#endif
          pubTmp = (bAddToHeap) ? (pubBuf) : (pubDest) ;

    //  all parsing functions write links to a specified
    //  memory location.  If the link is to be saved to
    //  the heap, the link is first created in a temp
    //  buffer pubBuf[] which is subseqently copied to
    //  the heap outside of the function.


    switch(eAllowedValue)
    {
        case  VALUE_STRING_NO_CONVERT:
        case  VALUE_STRING_DEF_CONVERT:
        case  VALUE_STRING_CP_CONVERT:
        {
            bStatus = BparseAndTerminateString(&aarValue, (PARRAYREF)pubTmp,
                                eAllowedValue, pglobl) ;
            break ;
        }
        case  VALUE_COMMAND_INVOC:
        {
            bStatus = BparseCommandString(&aarValue, (PARRAYREF)pubTmp, pglobl) ;
            break ;
        }
        case  VALUE_PARAMETER:
        {
            ((PARRAYREF)pubTmp)->dwCount = 0 ;

            bStatus = BprocessParam(&aarValue, (PARRAYREF)pubTmp, pglobl) ;
            break ;
        }
        case  VALUE_POINT:
        {
            bStatus = BparsePoint(&aarValue, (PPOINT)pubTmp, pglobl) ;
            break ;
        }
        case  VALUE_RECT:
        {
            bStatus = BparseRect(&aarValue, (PRECT)pubTmp, pglobl) ;
            break ;
        }
        case  VALUE_ORDERDEPENDENCY:
        {
            bStatus = BparseOrderDep(&aarValue, (PORDERDEPENDENCY)pubTmp, pglobl) ;
            break ;
        }
//        case  VALUE_BOOLEAN:  this is one class of CONSTANT.
        case  VALUE_SYMBOL_DEF:   //  what is this??
        {
            break ;
        }
        case  VALUE_INTEGER:
        {
            if(bList)
                bStatus = BparseList(&aarValue, (PDWORD)pubTmp,
                    BparseInteger, eAllowedValue, pglobl) ;
            else
                bStatus = BparseInteger(&aarValue, (PDWORD)pubTmp,
                    eAllowedValue, pglobl) ;

            break ;
        }

        case  VALUE_CONSTRAINT:
        {
            bStatus = BparseConstraint(&aarValue, (PDWORD)pubTmp,
                    bAddToHeap, pglobl) ;  //  create list vs append to existing
            break ;
        }
        case  VALUE_QUALIFIED_NAME:
        {
            if(bList)
                bStatus = BparseList(&aarValue, (PDWORD)pubTmp, BparseQualifiedName, eAllowedValue, pglobl) ;
            else
                bStatus = BparseQualifiedName(&aarValue, (PDWORD)pubTmp, eAllowedValue, pglobl) ;
            break ;
        }
        case  VALUE_QUALIFIED_NAME_EX:
        {
            if(bList)
                bStatus = BparseList(&aarValue, (PDWORD)pubTmp, BparseQualifiedNameEx, eAllowedValue, pglobl) ;
            else
                bStatus = BparseQualifiedNameEx(&aarValue, (PDWORD)pubTmp, eAllowedValue, pglobl) ;
            break ;
        }
        case  VALUE_PARTIALLY_QUALIFIED_NAME:
        {
            if(bList)
                bStatus = BparseList(&aarValue, (PDWORD)pubTmp, BparsePartiallyQualifiedName, eAllowedValue, pglobl) ;
            else
                bStatus = BparsePartiallyQualifiedName(&aarValue, (PDWORD)pubTmp, eAllowedValue, pglobl) ;
            break ;
        }
        case  NO_VALUE :  // how can an attribute not have a value?
        {
            bStatus = TRUE ;
            break ;
        }
        default:
        {
            if(  eAllowedValue >= VALUE_CONSTANT_FIRST  &&
                eAllowedValue <= VALUE_CONSTANT_LAST )
            {
                if(bList)
                    bStatus = BparseList(&aarValue, (PDWORD)pubTmp, BparseConstant, eAllowedValue, pglobl) ;
                else
                    bStatus = BparseConstant(&aarValue, (PDWORD)pubTmp, eAllowedValue, pglobl) ;
            }
            else  if(  eAllowedValue == VALUE_SYMBOL_OPTIONS )  //  check
                    //  this case before the other symbols.
            {
                if(bList)
                    bStatus = BparseList(&aarValue, (PDWORD)pubTmp, BparseOptionSymbol, eAllowedValue, pglobl) ;
                else
                    bStatus = BparseOptionSymbol(&aarValue, (PDWORD)pubTmp, eAllowedValue, pglobl) ;
            }
            else  if(  eAllowedValue >= VALUE_SYMBOL_FIRST  &&
                eAllowedValue <= VALUE_SYMBOL_LAST )
            {
                if(bList)
                    bStatus = BparseList(&aarValue, (PDWORD)pubTmp, BparseSymbol, eAllowedValue, pglobl) ;
                else
                    bStatus = BparseSymbol(&aarValue, (PDWORD)pubTmp, eAllowedValue, pglobl) ;
            }
            else
            {
                ERR(("internal consistency error - unrecognized VALUE type!\n"));
                //  don't know how to parse unrecognized value type!
            }
            break ;
        }
    }
    if(!bStatus)
        vIdentifySource(ptkmap, pglobl);

    if(bStatus  && (eAllowedValue != NO_VALUE) )
    {
        if(bAddToHeap)
        {
#ifdef  GMACROS
            if(mMainKeywordTable[dwKeywordID].flAgs & KWF_CHAIN)
            {
                if(!BwriteToHeap(pdwHeapOffset, pubBuf,
                    gValueToSize[VALUE_LIST], 4, pglobl) )   //  chains are LISTS of VALUES.
                {
                    bStatus = FALSE ;  // heap overflow start over.
                }
            }
            else
#endif

                if(!BwriteToHeap(pdwHeapOffset, pubTmp,
                gValueToSize[(bList) ? (VALUE_LIST) : (eAllowedValue)], 4, pglobl) )
            {
                bStatus = FALSE ;  // heap overflow start over.
            }
        }
    }
    if(pubBuf)
        MemFree(pubBuf) ;
    return(bStatus) ;
}




BOOL    BparseInteger(
IN  PABSARRAYREF  paarValue,
IN  PDWORD        pdwDest,       //  write dword value here.
IN  VALUE         eAllowedValue, // dummy
IN  PGLOBL        pglobl
)
/*  the GPD spec defines an integer as a sequence
    of numbers preceeded by an optional + or -  OR
    simply the symbol '*' which means 'don't care'.
    NEW:  also permit a leading 0x to indicate a number in
    hexadecimal format.  ie  0x01fE .  No + or - allowed
    in hex format.
*/
{
#define    pubM  (paarValue->pub)
#define    dwM   (paarValue->dw)

    BOOL  bNeg = FALSE ;
    DWORD   dwNumber   ;
    BOOL        bStatus = FALSE ;
    ABSARRAYREF   aarValue ;

    if(eAllowedValue != VALUE_INTEGER)
        return(FALSE); // paranoid check just to use variable
                        //  and thereby avoid compiler warning.

    (VOID) BeatLeadingWhiteSpaces(paarValue) ;

    aarValue.pub = pubM ;  // used only to emit error message.
    aarValue.dw  = dwM ;

    if(!dwM)
    {
        ERR(("BparseInteger: no integer found - empty list?\n"));
        //  ERR(("\t%0.40s\n", aarValue.pub )) ;
        //  danger of over shooting EOF
        return(FALSE);
    }
    if(*pubM == '*')
    {
        dwNumber = WILDCARD_VALUE ;
        pubM++ ;
        dwM-- ;
        bStatus = TRUE ;
    }
    else if(*pubM == '0')  //  leading zero indicates hexadecimal format
    {
        pubM++ ;
        dwM-- ;

        if(dwM  &&  (*pubM == 'x'  ||  *pubM == 'X'))
        {
            pubM++ ;
            dwM-- ;
        }
        else
        {
            dwNumber = 0 ;
            bStatus = TRUE ;
            goto  EndNumber ;
        }
        if(!dwM)
        {
            ERR(("BparseInteger: no digits found in Hex value.\n"));
            return(FALSE);
        }
        for(dwNumber = 0 ; dwM  ;  pubM++, dwM-- )
        {
            if(*pubM >= '0'  &&  *pubM <= '9')
            {
                dwNumber *= 0x10 ;
                dwNumber += (*pubM - '0') ;
            }
            else if(*pubM >= 'a'  &&  *pubM <= 'f')
            {
                dwNumber *= 0x10 ;
                dwNumber += (*pubM - 'a' + 0x0a) ;
            }
            else if(*pubM >= 'A'  &&  *pubM <= 'F')
            {
                dwNumber *= 0x10 ;
                dwNumber += (*pubM - 'A' + 0x0a) ;
            }
            else
                break;

            bStatus = TRUE ;
        }
    }
    else
    {
        if(*pubM == '-')
        {
            bNeg = TRUE ;
            pubM++ ;
            dwM-- ;
        }
        else if(*pubM == '+')
        {
            pubM++ ;
            dwM-- ;
        }
        //  is there anything else after the sign?
        (VOID) BeatLeadingWhiteSpaces(paarValue) ;

        if(!dwM)
        {
            ERR(("BparseInteger: no digits found.\n"));
            return(FALSE);
        }
        for(dwNumber = 0 ; dwM  &&  *pubM >= '0'  &&  *pubM <= '9' ;  )
        {
            dwNumber *= 10 ;
            dwNumber += (*pubM - '0') ;
            pubM++ ;
            dwM-- ;
            bStatus = TRUE ;
        }
    }

EndNumber:

    if(! bStatus)
    {
        ERR(("error parsing integer value: %0.*s\n", aarValue.dw, aarValue.pub));
        return(FALSE);
    }

    //  is there anything else after the digit string?
    (VOID) BeatLeadingWhiteSpaces(paarValue) ;

    if(dwM)
    {
        ERR(("unexpected characters after digits in integer value: %0.*s\n", aarValue.dw, aarValue.pub));
        return(FALSE);
    }
    *pdwDest = (bNeg) ? ((unsigned)(-(signed)dwNumber)) : (dwNumber) ;
    return(TRUE);

#undef    pubM
#undef    dwM
}




BOOL    BparseList(
IN  PABSARRAYREF   paarValue,
IN  PDWORD         pdwDest,       //  location where index to start of list
                                  //  is saved
IN  BOOL           (*fnBparseValue)(PABSARRAYREF, PDWORD, VALUE, PGLOBL),   // callback
IN  VALUE          eAllowedValue,  // dummy
IN OUT PGLOBL      pglobl
)
/*  non-destructively parse this list using
    callback function to parse the actual values
    in between the LIST structure.
    LIST ( <value> , <value> , ... )

    Notes:
    1) all continuation line delimiters have been replaced by
        spaces at TokenMap creation time.  No need to worry
        about this here
    2) The List construct must begin with the reserved token
        'LIST' which must be followed by the token '('.
    3) The list of values is enclosed by parenthesis,
        adjacent values are delimited by comma.
    4) This function assumes <value> does not contain any
        reserved characters ',' comma or ')' close parenthesis
    5) whitespaces may appear between syntactic elements (tokens).
    6) Even if a LIST is not detected, we will still save
        the single value in a LIST construct.
    7) Must check string count to see if we have reached the
        end of value statement.

*/
{
    ABSARRAYREF     aarToken ;  // points to individual value.
    PLISTNODE    plstRoot ;  // start of LIST array
    DWORD       dwNodeIndex , dwPrevsNode, dwFirstNode;
                        // index of list node.
    DWORD       dwDelIndex ;    //  if BdelimitToken
        //  found a delimiter, this contains the index to pubDelimiters
        //  of the delimiter that was found.
    BOOL    bSyntaxErr = FALSE ;

    plstRoot = (PLISTNODE) gMasterTable[MTI_LISTNODES].pubStruct ;

    if(! BeatDelimiter(paarValue, "LIST"))
    {
        //  this keyword LIST  was not found, assume just
        //  one value exists.

        if(! BallocElementFromMasterTable(MTI_LISTNODES ,
            &dwNodeIndex, pglobl) )
        {
            return(FALSE) ;
        }
        // shove parsed integer into data field of new listnode.

        if(!fnBparseValue(paarValue, &(plstRoot[dwNodeIndex].dwData),
                    eAllowedValue, pglobl))
        {
            (VOID)BreturnElementFromMasterTable(MTI_LISTNODES, dwNodeIndex, pglobl) ;
            return(FALSE) ;
        }
        plstRoot[dwNodeIndex].dwNextItem = END_OF_LIST ;

        *pdwDest = dwNodeIndex ;

        return(TRUE) ;
    }
    if(! BeatDelimiter(paarValue, "("))
    {
        ERR(("syntax error: missing '(' after LIST.\n"));
        return(FALSE) ;
    }

    dwPrevsNode = END_OF_LIST ;
    //  prepare to process an entire list of items.

    for(dwDelIndex = 0 ; dwDelIndex != 1 ;   )
    {
        if(!BdelimitToken(paarValue, ",)", &aarToken, &dwDelIndex) )
        {
            bSyntaxErr = TRUE ;

            ERR(("missing terminating )  in LIST construct.\n"));
            //  emit message for user.

            break ;   //  attempt to return the list we have so far.
        }
        if(dwDelIndex == 1  &&  !aarToken.dw)
            break ;  // empty item.

        if(! BallocElementFromMasterTable(MTI_LISTNODES ,
            &dwNodeIndex, pglobl) )
        {
            return(FALSE) ;
        }
        // shove parsed integer into data field of new listnode.

        if(!fnBparseValue(&aarToken, &(plstRoot[dwNodeIndex].dwData),
                eAllowedValue, pglobl))
        {
            (VOID)BreturnElementFromMasterTable(MTI_LISTNODES, dwNodeIndex, pglobl) ;
            continue ;   //  just skip to the next value in list.
        }
        plstRoot[dwNodeIndex].dwNextItem = END_OF_LIST ;

        if(dwPrevsNode == END_OF_LIST)
        {
            // Therefore, this is the first node in the list.
            dwFirstNode = dwNodeIndex ;
        }
        else    //  cause prevs node to point to this node.
        {
            plstRoot[dwPrevsNode].dwNextItem = dwNodeIndex ;
        }
        dwPrevsNode = dwNodeIndex ;  // place here instead
        // of part of for( ; ; ) statement so 'continue' will
        //  bypass this statement.
    }

    if(dwPrevsNode == END_OF_LIST)
        dwFirstNode = END_OF_LIST ;
        //  empty list is now acceptable.

    if(!bSyntaxErr)
    {
        //  verify there is nothing else in statement.
        (VOID) BeatLeadingWhiteSpaces(paarValue) ;
        if(paarValue->dw)
        {
            ERR(("extraneous characters found after the end of the LIST construct.\n"));
            //  may want to print them out.
            //  not a fatal condition, continue.
        }
    }
    *pdwDest  = dwFirstNode ;
    return(TRUE) ;
}


BOOL    BeatLeadingWhiteSpaces(
IN  OUT  PABSARRAYREF   paarSrc
)
/*  as name suggests, advance paarSrc to
    first nonwhite or set dw = 0  if src string
    is exhausted.
*/
{
    PBYTE  pub ;
    DWORD  dw  ;

    pub = paarSrc->pub ;
    dw = paarSrc->dw ;

    while(dw  &&  (*pub == ' '  ||  *pub == '\t') )
    {
        pub++ ;
        dw-- ;
    }
    paarSrc->pub = pub ;
    paarSrc->dw = dw ;
    return(TRUE);  // always return true now,
    // but can add more robust error checking in the future.
}


BOOL    BeatDelimiter(
IN  OUT  PABSARRAYREF   paarSrc,
IN       PBYTE          pubDelStr //  points to a string which paarSrc must match
)
    //  expects to encounter only
    //  whitespaces before reaching the specified delimiter string.
    //  if delimiter doesn't match or src string is exhausted, returns
    //  FALSE.  parrSrc  not updated.  Otherwise parrSrc
    //  is updated to point to char which follows delimiter.
{
    PBYTE  pub ;
    DWORD  dw, dwLen   ;

    (VOID) BeatLeadingWhiteSpaces(paarSrc) ;

    pub = paarSrc->pub ;
    dw = paarSrc->dw ;
    dwLen = strlen(pubDelStr) ;

    if(dw < dwLen)
        return(FALSE);

    if(strncmp(pub,  pubDelStr,  dwLen))
        return(FALSE);

    pub += dwLen;
    dw -= dwLen;  // 'Eat' delimiter string

    paarSrc->pub = pub ;
    paarSrc->dw = dw ;

    return(TRUE);
}

BOOL    BdelimitToken(
IN  OUT  PABSARRAYREF   paarSrc,       //  source string
IN       PBYTE          pubDelimiters, //  array of valid delimiters
OUT      PABSARRAYREF   paarToken,     //  token defined by delimiter
OUT      PDWORD         pdwDel         //  which delimiter was first encountered?
)
//  searchs paarSrc for the first occurence of one of the
//  characters in the string pubDelimiters.  Once found
//  all characters up to that delimiter are considered a
//  token and an abs string ref to this token is returned
//  in paarToken.   paarSrc is updated to point to first char
//  after the delimiter.  If delimiter is not found within paarSrc,
//  returns FALSE and neither paarSrc or paarToken is updated.
//  pdwDel  will contain the zero based index of the delimiter
//  that was first encountered:  pubDelimiters[pdwDel] .
//  Note this function ignores the " and < delimiters if they
//  are preceeded by the % character.  See ParseString for
//  more info.
{
    PBYTE  pub ;
    DWORD  dw, dwLen, dwI  ;


    pub = paarSrc->pub ;
    dw = paarSrc->dw ;

    dwLen = strlen(pubDelimiters) ;

    while( dw )
    {
        for(dwI = 0 ; dwI < dwLen ; dwI++)
        {
            if(*pub == pubDelimiters[dwI])
            {
                if((*pub == '"'  ||  *pub == '<')  &&
                    (dw < paarSrc->dw)  &&  *(pub - 1) == '%')
                {
                    continue ;
                }
                paarToken->pub = paarSrc->pub ;
                paarToken->dw = paarSrc->dw - dw ;

                *pdwDel = dwI ;  // this was the delimiter

                paarSrc->pub = ++pub ;  // position after delimiter.
                paarSrc->dw = --dw ;    //  may go to zero.

                return(TRUE);
            }
        }
        pub++ ;
        dw-- ;
    }
    return(FALSE);  // string exhausted, no delimiters found.
}


BOOL    BeatSurroundingWhiteSpaces(
IN  PABSARRAYREF   paarSrc
)
/*  as name suggests, advance paarSrc to
    first nonwhite and adjust count to exclude
    trailing whitespaces or set dw = 0  if src string
    is exhausted.   Note:  this routine expects
    only leading and trailing whitespaces.
    The presence of whitespaces within the token
    is a user error. (or maybe an internal error).
*/
{
    PBYTE  pub ;
    DWORD  dw , dwLen ;

    pub = paarSrc->pub ;
    dw = paarSrc->dw ;

    while(dw  &&  (*pub == ' '  ||  *pub == '\t') )
    {
        pub++ ;
        dw-- ;
    }
    paarSrc->pub = pub ;

    for(dwLen = 0 ; dw  &&  (*pub != ' ')  &&  (*pub != '\t') ; dwLen++ )
    {
        pub++ ;
        dw-- ;
    }
    paarSrc->dw = dwLen ;

    //  make sure the rest is white

    while(dw  &&  (*pub == ' '  ||  *pub == '\t') )
    {
        pub++ ;
        dw-- ;
    }
    if(dw)
    {
        ERR(("more than one token found where only one was expected: %0.*s\n",
            paarSrc->dw, paarSrc->pub));

        return(FALSE);
    }
    return(TRUE);
}


BOOL    BparseSymbol(
IN  PABSARRAYREF   paarValue,
IN  PDWORD         pdwDest,       //  write dword value here.
IN  VALUE          eAllowedValue, // which class of symbol is this?
IN  PGLOBL         pglobl
)
{
    DWORD  dwSymbolTree ;

    dwSymbolTree = ((PDWORD)gMasterTable[MTI_SYMBOLROOT].pubStruct)
                        [eAllowedValue - VALUE_SYMBOL_FIRST] ;

    if(! BeatSurroundingWhiteSpaces(paarValue) )
        return(FALSE);

    *pdwDest = DWsearchSymbolListForAAR(paarValue, dwSymbolTree, pglobl) ;
    if(*pdwDest == INVALID_SYMBOLID)
    {
        ERR(("user supplied a non-existent symbol: %0.*s in class: %d\n",
        paarValue->dw, paarValue->pub, (eAllowedValue - VALUE_SYMBOL_FIRST) ));

        return(FALSE);
    }
    return(TRUE);
}


BOOL    BparseQualifiedName
(
IN  PABSARRAYREF   paarValue,
IN  PDWORD         pdwDest,        //  write dword value here.
IN  VALUE          eAllowedValue,  // which class of symbol is this?
IN  PGLOBL         pglobl
)
/*   A QualifiedName shall be stored in one DWord, if more
    storage is required, things get more complex.
    A QualifiedName shall consist of 2 parts, Attributes
    requiring more qualifiers may specify a LIST of
    qualified names.
    note: cramming DWORD into WORD, assumes all ID values
    are WORD sized.
*/
{
    ABSARRAYREF     aarFeature ;  // points to FeatureName.
    DWORD       dwDelIndex ;  // serves no purpose here.
    DWORD   dwFeatureID, dwFeatureIndex , dwRootOptions, dwOptionID;
    PSYMBOLNODE     psn ;

    if(!BdelimitToken(paarValue, ".", &aarFeature, &dwDelIndex) )
    {
        ERR(("required delimiter '.' missing in qualified value: %0.*s\n",
        paarValue->dw, paarValue->pub));
        return(FALSE);
    }
    if(! BeatSurroundingWhiteSpaces(&aarFeature) )  // holds feature
    {
        ERR(("no feature found in qualified value: %0.*s\n",
        paarValue->dw, paarValue->pub));
        return(FALSE);
    }
    if(! BeatSurroundingWhiteSpaces(paarValue) )  // holds option
    {
        ERR(("no option found in qualified value: %0.*s\n",
        aarFeature.dw, aarFeature.pub));
        return(FALSE);
    }

    dwFeatureID = DWsearchSymbolListForAAR(&aarFeature, mdwFeatureSymbols, pglobl) ;
    if(dwFeatureID == INVALID_SYMBOLID)
    {
        ERR(("qualified name references a non-existent Feature symbol: %0.*s\n",
        aarFeature.dw, aarFeature.pub));
        //  for qualified value.
        return(FALSE);
    }
    dwFeatureIndex = DWsearchSymbolListForID(dwFeatureID,
        mdwFeatureSymbols, pglobl);

    psn = (PSYMBOLNODE) gMasterTable[MTI_SYMBOLTREE].pubStruct ;

    dwRootOptions = psn[dwFeatureIndex].dwSubSpaceIndex ;
    dwOptionID = DWsearchSymbolListForAAR(paarValue, dwRootOptions, pglobl) ;
    if(dwOptionID == INVALID_SYMBOLID)
    {
        ERR(("qualified name references a non-existent Option symbol: %0.*s\n",
            paarValue->dw, paarValue->pub));
        return(FALSE);
    }
    ((PQUALNAME)pdwDest)->wFeatureID = (WORD)dwFeatureID ;
    ((PQUALNAME)pdwDest)->wOptionID = (WORD)dwOptionID ;

    return(TRUE);
}




BOOL    BparseQualifiedNameEx
(
IN  PABSARRAYREF  paarValue,
IN  PDWORD        pdwDest,       //  write dword value here.
IN  VALUE         eAllowedValue,  // which class of symbol is this?
IN  PGLOBL        pglobl
)
/*   A QualifiedNameEx is a QualifiedName followed
    by   an unsigned integer  with a  .  delimiter.
    Optionally it may just be an integer!
    This type shall be used to store resource references.

    This shall be stored in one DWord  in the following format:

    {   //  arranged in order of increasing memory addresses
        WORD    intValue ;
        BYTE    OptionIndex ;
        BYTE    FeatureIndex ;    //   note  high byte may be cleared
    }                                       //  since this is intended for use only
                                            //   as a resource reference.


*/
{
    ABSARRAYREF     aarFeature,   // points to FeatureName.
                                aarOption ;    // points to OptionName.
    DWORD       dwDelIndex ;  // serves no purpose here.
    DWORD   dwFeatureID, dwFeatureIndex , dwRootOptions, dwOptionID;
    PSYMBOLNODE     psn ;

    if(!BdelimitToken(paarValue, ".", &aarFeature, &dwDelIndex) )
    {
        //  assume this is an integer form.

        return(BparseInteger( paarValue,   pdwDest,   VALUE_INTEGER, pglobl) );
    }

    if(! BeatSurroundingWhiteSpaces(&aarFeature) )  // holds feature
    {
        ERR(("no feature found in qualified valueEx: %0.*s\n",
        paarValue->dw, paarValue->pub));
        return(FALSE);
    }
    if(!BdelimitToken(paarValue, ".", &aarOption, &dwDelIndex) )
    {
        ERR(("required 2nd delimiter '.' missing in qualified valueEx: %0.*s\n",
        paarValue->dw, paarValue->pub));
        return(FALSE);
    }

    if(! BeatSurroundingWhiteSpaces(&aarOption) )  // holds option
    {
        ERR(("no option found in qualified valueEx: %0.*s\n",
        aarFeature.dw, aarFeature.pub));
        return(FALSE);
    }
    if(!BparseInteger( paarValue,   pdwDest,   VALUE_INTEGER, pglobl) )
    {
        ERR(("Err parsing integer portion of qualified valueEx: %0.*s\n",
        paarValue->dw, paarValue->pub));
        return(FALSE);
    }

    dwFeatureID = DWsearchSymbolListForAAR(&aarFeature, mdwFeatureSymbols, pglobl) ;
    if(dwFeatureID == INVALID_SYMBOLID)
    {
        ERR(("qualified name references a non-existent Feature symbol: %0.*s\n",
        aarFeature.dw, aarFeature.pub));
        //  for qualified value.
        return(FALSE);
    }
    dwFeatureIndex = DWsearchSymbolListForID(dwFeatureID,
        mdwFeatureSymbols, pglobl) ;

    psn = (PSYMBOLNODE) gMasterTable[MTI_SYMBOLTREE].pubStruct ;

    dwRootOptions = psn[dwFeatureIndex].dwSubSpaceIndex ;
    dwOptionID = DWsearchSymbolListForAAR(&aarOption, dwRootOptions, pglobl) ;
    if(dwOptionID == INVALID_SYMBOLID)
    {
        ERR(("qualified name references a non-existent Option symbol: %0.*s\n",
            aarOption.dw, aarOption.pub));
        return(FALSE);
    }
    if(gdwResDLL_ID)   //  has already been initialized
    {
        if(gdwResDLL_ID  !=  dwFeatureID)
        {
            ERR(("References to ResourceDLLs must be placed in the feature with symbolname: RESDLL.\n"));
            return(FALSE);
        }
    }
    else
        gdwResDLL_ID  =  dwFeatureID ;

    if(dwOptionID >= 0x80 )
    {
        ERR(("GPD may not reference more than 127 resource files.\n"));
        return(FALSE);
    }
    //  integer portion already set.
    ((PQUALNAMEEX)pdwDest)->bFeatureID = (BYTE)dwFeatureID ;
    ((PQUALNAMEEX)pdwDest)->bOptionID = (BYTE)dwOptionID ;

    //  if needed, clear high bit here!
    ((PQUALNAMEEX)pdwDest)->bOptionID &= ~0x80  ;

    return(TRUE);
}





BOOL    BparsePartiallyQualifiedName
(
IN  PABSARRAYREF   paarValue,
IN  PDWORD         pdwDest,   //  write dword value here.
IN  VALUE          eAllowedValue,  // which class of symbol is this?
IN  PGLOBL         pglobl
)
/*   Similar to  parseQualifiedName but will tolerate
    a Featurename by itself.
    in this case the optionID will be set to INVALID_SYMBOLID.
*/
{
    ABSARRAYREF     aarFeature ;  // points to FeatureName.
    DWORD       dwDelIndex ;  // serves no purpose here.
    DWORD   dwFeatureID, dwFeatureIndex , dwRootOptions,
        dwOptionID = 0;
    PSYMBOLNODE     psn ;

    if(!BdelimitToken(paarValue, ".", &aarFeature, &dwDelIndex) )
    {
        aarFeature = *paarValue ;  //  initialize since BdelimitToken doesn't
        dwOptionID = INVALID_SYMBOLID ;
    }
    if(! BeatSurroundingWhiteSpaces(&aarFeature) )  // holds feature
    {
        ERR(("no feature found in partially qualified value: %0.*s\n", paarValue->dw, paarValue->pub));
        return(FALSE);
    }

    if(!dwOptionID  &&
        ! BeatSurroundingWhiteSpaces(paarValue) )  // holds option
    {
        ERR(("no option found after . in partially qualified value: %0.*s\n", paarValue->dw, paarValue->pub));
        return(FALSE);
    }

    dwFeatureID = DWsearchSymbolListForAAR(&aarFeature, mdwFeatureSymbols, pglobl) ;
    if(dwFeatureID == INVALID_SYMBOLID)
    {
        ERR(("qualified name references a non-existent Feature symbol: %0.*s\n", paarValue->dw, paarValue->pub));
        return(FALSE);
    }
    dwFeatureIndex = DWsearchSymbolListForID(dwFeatureID,
        mdwFeatureSymbols, pglobl);

    psn = (PSYMBOLNODE) gMasterTable[MTI_SYMBOLTREE].pubStruct ;


    if(!dwOptionID)
    {
        dwRootOptions = psn[dwFeatureIndex].dwSubSpaceIndex ;
        dwOptionID = DWsearchSymbolListForAAR(paarValue, dwRootOptions, pglobl) ;
        if(dwOptionID == INVALID_SYMBOLID)
        {
            ERR(("qualified name references a non-existent Option symbol: %0.*s\n", paarValue->dw, paarValue->pub));
            return(FALSE);
        }
    }
    ((PQUALNAME)pdwDest)->wFeatureID = (WORD)dwFeatureID ;
    ((PQUALNAME)pdwDest)->wOptionID = (WORD)dwOptionID ;

    return(TRUE);
}




BOOL    BparseOptionSymbol(
IN  PABSARRAYREF   paarValue,
IN  PDWORD         pdwDest,       //  write dword value here.
IN  VALUE          eAllowedValue,  // which class of symbol is this?
IN  PGLOBL         pglobl
)
/*  Note we assume any attribute expecting an OptionSymbol
    must reside within a Feature Construct.
*/
{
    WORD    wTstsInd ;  // temp state stack index
    STATE   stState ;
    DWORD   dwFeatureID, dwFeatureIndex , dwRootOptions;
    PSYMBOLNODE     psn ;

    if(  eAllowedValue != VALUE_SYMBOL_OPTIONS )
        return(FALSE);

    if(! BeatSurroundingWhiteSpaces(paarValue) )
        return(FALSE);

    for(wTstsInd = 0 ; wTstsInd < mdwCurStsPtr ; wTstsInd++)
    {
        stState = mpstsStateStack[wTstsInd].stState ;
        if(stState == STATE_FEATURE )
        {
            dwFeatureID = mpstsStateStack[wTstsInd].dwSymbolID  ;
            break ;
        }
    }
    dwFeatureIndex = DWsearchSymbolListForID(dwFeatureID,
        mdwFeatureSymbols, pglobl) ;

    psn = (PSYMBOLNODE) gMasterTable[MTI_SYMBOLTREE].pubStruct ;

    dwRootOptions = psn[dwFeatureIndex].dwSubSpaceIndex ;
    *pdwDest = DWsearchSymbolListForAAR(paarValue, dwRootOptions, pglobl) ;
    if(*pdwDest == INVALID_SYMBOLID)
    {
        ERR(("qualified name references a non-existent Option symbol: %0.*s\n", paarValue->dw, paarValue->pub));
        return(FALSE);
    }
    return(TRUE);
}



BOOL    BparseConstant(
IN  OUT  PABSARRAYREF  paarValue,
OUT      PDWORD        pdwDest,       //  write dword value here.
IN       VALUE         eAllowedValue,  // which class of constant is this?
IN       PGLOBL        pglobl
)
/*  note:  this function will destroy/modify paarValue, it will
    only reference the constant name when done.  */
{
    DWORD   dwClassIndex = eAllowedValue - VALUE_CONSTANT_FIRST ;
    DWORD   dwI, dwCount, dwStart , dwLen;

    dwStart = gcieTable[dwClassIndex].dwStart ;
    dwCount = gcieTable[dwClassIndex].dwCount ;

    if(! BeatSurroundingWhiteSpaces(paarValue) )
        return(FALSE);

    for(dwI = 0 ; dwI < dwCount ; dwI++)
    {
        dwLen = strlen(gConstantsTable[dwStart + dwI].pubName);

        if((dwLen == paarValue->dw)  &&
            !strncmp(paarValue->pub, gConstantsTable[dwStart + dwI].pubName,
                        paarValue->dw) )
        {
            *pdwDest = gConstantsTable[dwStart + dwI].dwValue ;
            return(TRUE);
        }
    }
#if defined(DEVSTUDIO)  //  Keep messages to one line, where possible
    ERR(("Error: constant value '%0.*s' is not a member of enumeration class: %s\n",
        paarValue->dw , paarValue->pub, gConstantsTable[dwStart - 1].pubName));
#else
    ERR(("Error: constant value not a member of enumeration class: %s\n", gConstantsTable[dwStart - 1].pubName));
    ERR(("\t%0.*s\n", paarValue->dw , paarValue->pub )) ;
#endif
    return(FALSE);
}


BOOL  BinitClassIndexTable(
IN  OUT     PGLOBL  pglobl)
{
    DWORD   dwOldClass, dwCTIndex ;

    for(dwCTIndex = 0 ; dwCTIndex < CL_NUMCLASSES ; dwCTIndex++ )
    {
        gcieTable[dwCTIndex].dwStart = 0 ;
        gcieTable[dwCTIndex].dwCount = 0 ;  // set to known state.
    }

    dwOldClass = gConstantsTable[0].dwValue  ;
    gcieTable[dwOldClass].dwStart = 2 ;  // index of first entry

    for(dwCTIndex = 2 ; 1 ; dwCTIndex++ )
    {
        if(!gConstantsTable[dwCTIndex].pubName)
        {
            gcieTable[dwOldClass].dwCount =
                dwCTIndex - gcieTable[dwOldClass].dwStart ;

            dwOldClass = gConstantsTable[dwCTIndex].dwValue ;

            if(dwOldClass == CL_NUMCLASSES)
                break ;  // reached end of table.

            gcieTable[dwOldClass].dwStart = dwCTIndex + 2 ;
        }
    }
    for(dwCTIndex = 0 ; dwCTIndex < CL_NUMCLASSES ; dwCTIndex++ )
    {
        if(!gcieTable[dwCTIndex].dwCount)
        {
            geErrorSev = ERRSEV_FATAL ;
            geErrorType = ERRTY_CODEBUG ;
            return(FALSE) ; //   paranoid - some classes not
        }
    }           //  listed in    gConstantsTable[] .
    return(TRUE) ;
}

BOOL    BparseRect(
IN  PABSARRAYREF   paarValue,
IN  PRECT   prcDest,
    PGLOBL  pglobl
)
/*  note:  integers initialize the rect structure in memory
    in the order in which they appear.  First int initializes
    the lowest memory location and so on.
*/
{
    ABSARRAYREF     aarToken ;  // points to individual value.
    DWORD       dwDelIndex ;    //  if BdelimitToken
        //  found a delimiter, this contains the index to pubDelimiters
        //  of the delimiter that was found.
    DWORD   dwI ;  // number integers in RECT


    if(! BeatDelimiter(paarValue, "RECT"))
    {
        ERR(("expected token 'RECT'.\n"));
        return(FALSE) ;
    }
    if(! BeatDelimiter(paarValue, "("))
    {
        ERR(("syntax error: missing '(' after RECT.\n"));
        return(FALSE) ;
    }

    for(dwI = dwDelIndex = 0 ; dwI < 4  &&  dwDelIndex != 1 ;   dwI++)
    {
        if(!BdelimitToken(paarValue, ",)", &aarToken, &dwDelIndex) )
        {
            ERR(("missing terminating )  in RECT construct.\n"));
            //  emit message for user.

            return(FALSE) ;
        }
        if(!BparseInteger(&aarToken, (PDWORD)prcDest + dwI, VALUE_INTEGER, pglobl))
        {
            ERR(("syntax error in %d th integer of RECT.\n", dwI));
            ERR(("\t%0.*s\n", aarToken.dw, aarToken.pub));
            return(FALSE) ;
        }
    }

    if(dwI != 4  ||  dwDelIndex != 1)
    {
        ERR(("incorrect number of integers for RECT.\n"));
        return(FALSE) ;
    }
    //  verify there is nothing else in statement.

    (VOID) BeatLeadingWhiteSpaces(paarValue) ;
    if(paarValue->dw)
    {
        ERR(("extraneous characters found after the end of the RECT construct: %0.*s\n", paarValue->dw, paarValue->pub));
        //  may want to print them out.
        //  not a fatal condition, continue.
    }
    return(TRUE) ;
}


BOOL    BparsePoint(
IN  PABSARRAYREF   paarValue,
IN  PPOINT   pptDest,
    PGLOBL   pglobl
)
{
    ABSARRAYREF     aarToken ;  // points to individual value.
    DWORD       dwDelIndex ;    //  if BdelimitToken
        //  found a delimiter, this contains the index to pubDelimiters
        //  of the delimiter that was found.
    DWORD   dwI ;  // number integers in POINT


    if(! BeatDelimiter(paarValue, "PAIR"))
    {
        ERR(("expected token 'PAIR'.\n"));
        return(FALSE) ;
    }
    if(! BeatDelimiter(paarValue, "("))
    {
        ERR(("syntax error: missing '(' after PAIR.\n"));
        return(FALSE) ;
    }

    for(dwI = dwDelIndex = 0 ; dwI < 2  &&  dwDelIndex != 1 ;   dwI++)
    {
        if(!BdelimitToken(paarValue, ",)", &aarToken, &dwDelIndex) )
        {
            ERR(("missing terminating )  in PAIR construct.\n"));
            //  emit message for user.

            return(FALSE) ;
        }
        if(!BparseInteger(&aarToken, (PDWORD)pptDest + dwI, VALUE_INTEGER, pglobl))
        {
            ERR(("syntax error in %d th integer of PAIR.\n", dwI));
            ERR(("\t%0.*s\n", aarToken.dw, aarToken.pub));
            return(FALSE) ;
        }
    }

    if(dwI != 2  ||  dwDelIndex != 1)
    {
        ERR(("incorrect number of integers for PAIR.\n"));
        return(FALSE) ;
    }
    //  verify there is nothing else in statement.

    (VOID) BeatLeadingWhiteSpaces(paarValue) ;
    if(paarValue->dw)
    {
        ERR(("extraneous characters found after the end of the PAIR construct: %0.*s\n", paarValue->dw, paarValue->pub));
    }
    return(TRUE) ;
}


BOOL    BparseString(
IN  PABSARRAYREF   paarValue,
IN  PARRAYREF      parStrValue,
IN  OUT PGLOBL     pglobl
)
/*  strings are comprised of one or more string segments separated
    by optional arbitrary whitespace,
    each string segment is surrounded by double quotes.
    string segments may contain a mixture of literal sections
    and hexsubstrings.   Hexsubstrings are delimited by angle brackets.
    WhiteSpaces (but not linebreak chars) are permitted in the
    literal portion of the string, they part of the string.
    Otherwise only printable  chars are allowed.
    Valid hexchars and Arbitrary whitespace is permitted
    within the hexsubstrings.  Parsing of a string value ends
    when a statement terminator is encountered.

    The escape char %
    Within the literal portion of a string segment
    the following combinations are reinterpreted:

    %< maps to literal <
    %" maps to literal "

    > only has a special meaning within a hexsubstring.

    Assumption:  assumes the only heap usage that occurs
    within this function (and any called functions) is
    to assemble all string segments contiguously on the heap.
    Any hidden use of the heap will corrupt the continuity.

    the string may be terminated by : if a second value field is expected.
*/
{
    ABSARRAYREF     aarToken ;  // points to individual string segment.
    DWORD       dwDelIndex ;    //  dummy
    DWORD   dwI ;  // number of string segments parsed.


    if(! BeatDelimiter(paarValue, "\""))
    {
        ERR(("syntax error: string  must begin with '\"' .\n"));
        return(FALSE) ;
    }

    parStrValue->dwCount = 0 ;  // initialize so BparseStrSegment
                            //  will overwrite instead of append

    for(dwI = dwDelIndex = 0 ;  1 ;   dwI++)
    {
        if(!BdelimitToken(paarValue, "\"", &aarToken, &dwDelIndex) )
        {
            ERR(("missing terminating '\"'  in string.\n"));
            //  emit message for user.

            return(FALSE) ;
        }
        if(!BparseStrSegment(&aarToken, parStrValue, pglobl))
        {
            return(FALSE) ;
        }
        if(! BeatDelimiter(paarValue, "\""))  // find start of next
                //  string segment, if one exists.
            break ;
    }

    //  verify there is either a specially recognized character
    //  or nothing else in Value string.


    if(paarValue->dw)
    {
        if(*paarValue->pub == ':')
        {
            //  a keyword with a composite value
            (VOID)BeatDelimiter(paarValue, ":") ;
                //  I know this will succeed!
            (VOID) BeatLeadingWhiteSpaces(paarValue) ;
            return(TRUE) ;
        }
        else
        {
            ERR(("extraneous characters found after end quote, in string construct: %0.*s\n", paarValue->dw, paarValue->pub));
            //    may want to print them out.
            return(FALSE) ;
        }
    }
    return(TRUE) ;
}


BOOL    BparseAndTerminateString(
IN  PABSARRAYREF   paarValue,
IN  PARRAYREF      parStrValue,
IN  VALUE          eAllowedValue,
IN  OUT  PGLOBL    pglobl
)
{

    ARRAYREF    arSrcString ;
    INT     iCodepage ;  // unused for now.


    if(!BparseString(paarValue, parStrValue, pglobl) )
        return(FALSE) ;


    //  We don't want null terminations to occur between parameter
    //  portion of a string.  We just want to blindly add the NULL
    //  when parsing is really finished.

    {
        DWORD      dwDummy ;  // holds offset in heap, but we don't care.

        if(!BwriteToHeap(&dwDummy, "\0", 1, 1, pglobl) )  //  add Null termination
            return(FALSE) ;
    }

    if(eAllowedValue == VALUE_STRING_NO_CONVERT)
        return(TRUE) ;
    if(eAllowedValue == VALUE_STRING_CP_CONVERT)
    {
        //  we need to determine the value set by *CodePage
        PGLOBALATTRIB   pga ;
        DWORD   dwHeapOffset;

        pga =  (PGLOBALATTRIB)gMasterTable[
                    MTI_GLOBALATTRIB].pubStruct ;

        if(!BReadDataInGlobalNode(&pga->atrCodePage,
                &dwHeapOffset, pglobl) )
            return(TRUE);

        //  if no codepage is defined, we will not perform
        //  any xlation since we assume all strings are already
        //  expressed in unicode.

        iCodepage = *(PDWORD)(mpubOffRef + dwHeapOffset) ;
    }
    else   //  eAllowedValue == VALUE_STRING_DEF_CONVERT
        iCodepage = CP_ACP ; // use system default codepage.

    arSrcString = *parStrValue ;
    if(!BwriteUnicodeToHeap(&arSrcString, parStrValue,
            iCodepage, pglobl))
        return(FALSE) ;
    return(TRUE) ;
}

BOOL     BwriteUnicodeToHeap(
IN   PARRAYREF      parSrcString,
OUT  PARRAYREF      parUnicodeString,
IN   INT            iCodepage,
IN  OUT PGLOBL      pglobl
)
//  this function copies dwCnt bytes from pubSrc to
//  top of heap and writes the offset of the destination string
//  to pdwDestOff.   Nothing is changed if FAILS.
//  Warning!  Double Null termination is added to string.
{
    PBYTE  pubDest ;      //  destination location
    PBYTE  pubSrc ;       //  points to src string
    DWORD  dwAlign = sizeof(WCHAR) ;    //  align Unicode string at WORD boundaries.
    DWORD  dwMaxDestSize , dwActDestSize, dwDummy ;

    mloCurHeap = (mloCurHeap + dwAlign - 1) / dwAlign ;
    mloCurHeap *= dwAlign ;

    pubDest = mpubOffRef + mloCurHeap ;
    pubSrc  = mpubOffRef + parSrcString->loOffset ;

    parUnicodeString->loOffset = mloCurHeap ;

    dwMaxDestSize = sizeof(WCHAR) * (parSrcString->dwCount + 1) ;

    //  is there enough room in the heap ?
    if(mloCurHeap + dwMaxDestSize  >  mdwMaxHeap)
    {
        ERR(("Heap exhausted - restart.\n"));

        if(ERRSEV_RESTART > geErrorSev)
        {
            geErrorSev = ERRSEV_RESTART ;
            geErrorType = ERRTY_MEMORY_ALLOCATION ;
            gdwMasterTabIndex = MTI_STRINGHEAP ;
        }
        return(FALSE);
    }
    dwActDestSize = sizeof(WCHAR) * MultiByteToWideChar(iCodepage,
            MB_PRECOMPOSED, pubSrc, parSrcString->dwCount, (PWORD)pubDest,
            dwMaxDestSize);

    mloCurHeap += dwActDestSize ;   // update heap ptr.
    parUnicodeString->dwCount = dwActDestSize ;

    (VOID)BwriteToHeap(&dwDummy, "\0\0", 2, 1, pglobl)   ;
        //  add DoubleNull termination
        //  this cannot fail since we already took the NULs into account

    return(TRUE) ;
}






BOOL    BparseStrSegment(
IN  PABSARRAYREF   paarStrSeg,      // source str segment
IN  PARRAYREF      parStrLiteral,    // dest for result
IN  OUT PGLOBL         pglobl
)
{
    ABSARRAYREF     aarToken ;  // points to literal or hex substring segment.
    DWORD       dwDelIndex ;    //  dummy
    DWORD   dwI ;  // number of string segments parsed.

    for(dwI = dwDelIndex = 0 ;  1 ;   dwI++)
    {
        if(!BdelimitToken(paarStrSeg, "<", &aarToken, &dwDelIndex) )
        {
            // no more hex substrings.
            return(BparseStrLiteral(paarStrSeg, parStrLiteral, pglobl) ) ;
        }
        if(!BparseStrLiteral(&aarToken, parStrLiteral, pglobl))
        {
            return(FALSE) ;
        }
        if(!BdelimitToken(paarStrSeg, ">", &aarToken, &dwDelIndex) )
        {
            ERR(("Missing '>' terminator in hexsubstring.\n"));
            return(FALSE) ;
        }
        if(!(BparseHexStr(&aarToken, parStrLiteral, pglobl) ) )
            return(FALSE) ;
    }
    return TRUE;
}


BOOL    BparseStrLiteral(
IN  PABSARRAYREF   paarStrSeg,      // points to literal substring segment.
IN  PARRAYREF      parStrLiteral,    // dest for result
IN  OUT PGLOBL         pglobl
)
/* in this function all delimiters have been parsed out.
    only special character sequence is %" and %<
    Does not Null terminate heap string
*/
{
    ARRAYREF      arTmpDest ;  // write result here first.
    DWORD       dwI ;  //  byte index along literal substring
    PBYTE       pubStartRun ;

    while(paarStrSeg->dw)
    {
        pubStartRun = paarStrSeg->pub ;

        for(dwI = 0 ; paarStrSeg->dw ;  dwI++)
        {
            if(*paarStrSeg->pub == '%'  &&  paarStrSeg->dw > 1  &&
                (paarStrSeg->pub[1] == '"'  ||  paarStrSeg->pub[1] == '<'))
            {
                paarStrSeg->dw-- ;    // skip the escape char.
                paarStrSeg->pub++ ;
                break ;
            }
            paarStrSeg->dw-- ;
            paarStrSeg->pub++ ;
        }
        if(!BwriteToHeap(&arTmpDest.loOffset, pubStartRun, dwI, 1, pglobl))
            return(FALSE) ;
        //  append this run to existing string
        if(!parStrLiteral->dwCount)  // no prevs string exists
        {
            parStrLiteral->loOffset = arTmpDest.loOffset ;
        }
        else
        {
            // BUG_BUG paranoid:  may check that string is contiguous
            // parStrLiteral->loOffset + parStrLiteral->dwCount
            // should equal arTmpDest.loOffset
            ASSERT(parStrLiteral->loOffset + parStrLiteral->dwCount == arTmpDest.loOffset );
        }
        parStrLiteral->dwCount += dwI ;
    }
    return(TRUE) ;
}


BOOL    BparseHexStr(
IN  PABSARRAYREF   paarStrSeg,      // points to hex substring segment.
IN  PARRAYREF      parStrLiteral,    // dest for result
IN  OUT PGLOBL     pglobl
)
/* in this function all delimiters have been parsed out.
    only Whitespace and hex chars should exist.
    Does not Null terminate heap string
*/
{
    ARRAYREF      arTmpDest ;  // write result here first.
    DWORD       dwI ;  //  num dest bytes
    BYTE        ubHex, ubSrc, aub[40] ;  // accumulate hexbytes here
    BOOL        bHigh = TRUE ;

    while(paarStrSeg->dw)
    {
        for(dwI = 0 ; paarStrSeg->dw ;  )
        {
            ubSrc = *paarStrSeg->pub ;
            paarStrSeg->dw-- ;
            paarStrSeg->pub++ ;
            if(ubSrc >= '0'  &&  ubSrc <= '9')
            {
                ubHex =  ubSrc - '0' ;
            }
            else if(ubSrc >= 'a'  &&  ubSrc <= 'f')
            {
                ubHex =  ubSrc - 'a' + 10 ;
            }
            else if(ubSrc >= 'A'  &&  ubSrc <= 'F')
            {
                ubHex =  ubSrc - 'A' + 10 ;
            }
            else if(ubSrc == ' '  ||  ubSrc == '\t')
                continue;  // safe to ignore whitespace  chars
            else
            {
                ERR(("syntax error:  illegal char found within hexsubstring: %c\n", ubSrc));
                return(FALSE) ;
            }
            if(bHigh)
            {
                aub[dwI] = ubHex << 4 ;   // store in high nibble.
                bHigh = FALSE ;
            }
            else
            {
                aub[dwI] |= ubHex ;   // store in low nibble.
                bHigh = TRUE ;
                dwI++ ;  // advance to next dest byte
            }
            if(dwI >= 40)
                break ;   // buffer full -- must flush aub
        }
        if(!BwriteToHeap(&arTmpDest.loOffset, aub, dwI, 1, pglobl))
            return(FALSE) ;
        //  append this run to existing string
        if(!parStrLiteral->dwCount)  // no prevs string exists
        {
            parStrLiteral->loOffset = arTmpDest.loOffset ;
        }
        else
        {
            // BUG_BUG paranoid:  may check that string is contiguous
            // parStrLiteral->loOffset + parStrLiteral->dwCount
            // should equal arTmpDest.loOffset
            ASSERT(parStrLiteral->loOffset + parStrLiteral->dwCount == arTmpDest.loOffset );
        }
        parStrLiteral->dwCount += dwI ;
    }
    if(!bHigh)
    {
        ERR(("hex string contains odd number of hex digits.\n"));
    }
    return(bHigh) ;
}


BOOL    BparseOrderDep(
IN  PABSARRAYREF      paarValue,
IN  PORDERDEPENDENCY  pordDest,
    PGLOBL            pglobl
)
//  an order dependency value has the syntax:
//  SECTION.integer
{
    ABSARRAYREF     aarSection ;  // points to SECTION token
    DWORD       dwDelIndex ;    //  if BdelimitToken
        //  found a delimiter, this contains the index to pubDelimiters
        //  of the delimiter that was found.
    DWORD   dwI ;  // number integers in RECT


    if(!BdelimitToken(paarValue, ".", &aarSection, &dwDelIndex) )
    {
        ERR(("required delimiter '.' missing in order dependency value.\n"));
        return(FALSE);
    }
    if(!BparseConstant(&aarSection, (PDWORD)&(pordDest->eSection),
        VALUE_CONSTANT_SEQSECTION , pglobl))
    {
        ERR(("A valid orderdep SECTION name was not supplied: %0.*s\n", aarSection.dw, aarSection.pub));
        return(FALSE);
    }

    //  now interpret remainder of paarValue as an integer.

    if(!BparseInteger(paarValue, &(pordDest->dwOrder), VALUE_INTEGER, pglobl))
    {
        ERR(("syntax error in integer portion of order dependency.\n"));
        return(FALSE) ;
    }

    //  verify there is nothing else in statement.

    (VOID) BeatLeadingWhiteSpaces(paarValue) ;
    if(paarValue->dw)
    {
        ERR(("extraneous characters found after the end of the orderDependency value: %0.*s\n",
            paarValue->dw, paarValue->pub));
        //    may want to print them out.
        //  not a fatal condition, continue.
    }
    return(TRUE) ;
}


PDWORD   pdwEndOfList(
  PDWORD   pdwNodeIndex,   //  index of first node in the list
  PGLOBL   pglobl)
// walks the list and returns pointer  to field containing the
//  actual END_OF_LIST  value so it can be overwritten to
//   extend the list.
{
    PLISTNODE    plstRoot ;  // start of LIST array
    DWORD       dwNodeIndex , dwPrevsNode, dwFirstNode;

    plstRoot = (PLISTNODE) gMasterTable[MTI_LISTNODES].pubStruct ;
    dwNodeIndex = *pdwNodeIndex ;

    if(dwNodeIndex == END_OF_LIST )
        return(pdwNodeIndex);   //  no actual node referenced.

    while(plstRoot[dwNodeIndex].dwNextItem != END_OF_LIST )
        dwNodeIndex = plstRoot[dwNodeIndex].dwNextItem ;
    return(&plstRoot[dwNodeIndex].dwNextItem);
}

#ifdef  GMACROS

 PBYTE    ExtendChain(PBYTE    pubDest,
 IN   BOOL    bOverWrite,
 IN OUT PGLOBL pglobl)
    //  Links together values from separate entries into one LIST
    //  the values may be of any type.  If the values are LISTS, this
    //  modifier creates LISTS of LISTS.
    //  returns new value of pubDest
{
    DWORD    dwNodeIndex;
    PLISTNODE    plstRoot ;  // start of LIST array

    plstRoot = (PLISTNODE) gMasterTable[MTI_LISTNODES].pubStruct ;

    if(bOverWrite)
        pubDest = (PBYTE)pdwEndOfList((PDWORD)pubDest, pglobl);  // walks the list and returns pointer
                    //  to the actual END_OF_LIST  value so it can be overwritten to
                    //   extend the list.


    //  Add one list node and write its index to pubDest.
    //  set nextnode field of node just added to END_OF_LIST.

    if(! BallocElementFromMasterTable(MTI_LISTNODES ,
        &dwNodeIndex, pglobl) )
    {
        return(NULL) ;
    }
    plstRoot[dwNodeIndex].dwNextItem = END_OF_LIST ;

    *(PDWORD)pubDest = dwNodeIndex ;

    // update pubDest to point to value field of of the node just added.
    // now the LIST() we will now proceed to parse will grow from this
    // value field.

    pubDest = (PBYTE)&(plstRoot[dwNodeIndex].dwData) ;
    return(pubDest) ;
}


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\parsers\gpd\token1.c ===
//   Copyright (c) 1996-1999  Microsoft Corporation
/*  token1.c - functions to create the tokenmap  */


#include    "gpdparse.h"


// ----  functions defined in token1.c ---- //

BOOL    BcreateTokenMap(
PWSTR   pwstrFileName,
PGLOBL  pglobl )  ;

PARSTATE  PARSTscanForKeyword(
PDWORD   pdwTKMindex,
PGLOBL  pglobl) ;

PARSTATE  PARSTparseColon(
PDWORD   pdwTKMindex,
PGLOBL  pglobl) ;

PARSTATE  PARSTparseValue(
PDWORD   pdwTKMindex,
PGLOBL  pglobl) ;

BOOL  BparseKeyword(
DWORD   dwTKMindex,
PGLOBL  pglobl) ;

BOOL    BisExternKeyword(
DWORD   dwTKMindex,
PGLOBL  pglobl) ;

BOOL  BisColonNext(
PGLOBL  pglobl) ;

BOOL    BeatArbitraryWhite(
PGLOBL  pglobl) ;

BOOL    BeatComment(
PGLOBL  pglobl) ;

BOOL    BscanStringSegment(
PGLOBL  pglobl) ;

BOOL    BscanDelimitedString(
BYTE  ubDelimiter,
PBOOL    pbMacroDetected,
PGLOBL  pglobl) ;

PARSTATE    PARSTrestorePrevsFile(
PDWORD   pdwTKMindex,
PGLOBL  pglobl) ;

PWSTR
PwstrAnsiToUnicode(
IN  PSTR pstrAnsiString,
    PGLOBL  pglobl
) ;

PARSTATE    PARSTloadIncludeFile(
PDWORD   pdwTKMindex,
PWSTR   pwstrFileName,    // root GPD file
PGLOBL  pglobl);

BOOL    BloadFile(
PWSTR   pwstrFileName,
PGLOBL  pglobl ) ;

BOOL        BarchiveStrings(
DWORD   dwTKMindex,
PGLOBL  pglobl) ;

DWORD  DWidentifyKeyword(
DWORD   dwTKMindex,
PGLOBL  pglobl) ;

BOOL    BidentifyAttributeKeyword(
PTKMAP  ptkmap,   // pointer to tokenmap
PGLOBL  pglobl
) ;

BOOL    BcopyToTmpHeap(
PABSARRAYREF    paarDest,
PABSARRAYREF    paarSrc,
PGLOBL          pglobl) ;

DWORD    dwStoreFileName(PWSTR    pwstrFileName,
PARRAYREF   parDest,
PGLOBL      pglobl) ;

VOID    vFreeFileNames(
PGLOBL  pglobl ) ;

VOID    vIdentifySource(
    PTKMAP   ptkmap,
    PGLOBL  pglobl) ;



//  functions defined in preproc1.c  //

BOOL  BPreProcess(
    PGLOBL  pglobl
) ;  //  from current file position, use file macros to access.

BOOL  DefineSymbol(
    PBYTE   symbol,
    PGLOBL  pglobl
) ;

// ---------------------------------------------------- //



//    define  Local Macro to access info for current file:


#define    mprngDictionary  ((PRANGE)(gMasterTable \
                            [MTI_RNGDICTIONARY].pubStruct))


//  static  DWORD  gdwLastIndex ;  // leave this in this file only!
//  Now is part of the GLOBL structure.


BOOL    BcreateTokenMap(
PWSTR   pwstrFileName,   // root GPD file
PGLOBL  pglobl)
/*  some things that occur within this function:

    Open and memory map initial file and any files specified
    by *Include.

    parse keyword, init aarKeyword field, set dwFlags,
    set dwKeywordID, parse Value , init aarValue,
    ArchiveStrings to tempHeap.  During parsing of Values,
    comments and continuation lines are replaced by whitespaces.

    Assume  each function in switch statement increments dwTKMindex
    by at most by 1.  Otherwise undetected TokenMap overflow may occur.
*/
{
    PTKMAP   ptkmap ;   // start of tokenmap
    DWORD   dwTKMindex = 0,   //  current tokenKeyMap index
            dwCnt ;   //  counts length of keyword or value string
    PBYTE   pubStart ;  // start address of keyword or value string
    PARSTATE  parst = PARST_KEYWORD ;


    // note in the case of the SOURCEBUFFERS, dwCurIndex is initialized
    // to zero by loadIncludeFile().  Since we never append onto
    // the existing source, dwCurIndex is used to track the current
    // position within the file (streamptr).

    //  mCurFile initialized to 0 at buffer allocation time.

    gdwLastIndex = 0 ;  // ok, allow BarchiveStrings() of all entries.

    gmrbd.rbd.dwSrcFileChecksum32 = 0 ;

{
    PBYTE  symbol ;


    symbol = "WINNT_40" ;    //  newer OSs support older OS features unless otherwise specified.
    if(! DefineSymbol(symbol, pglobl))
        return(FALSE) ;

#ifndef WINNT_40
    symbol = "WINNT_50" ;
    if(! DefineSymbol(symbol, pglobl))
        return(FALSE) ;
    symbol = "WINNT_51" ;
    if(! DefineSymbol(symbol, pglobl))
        return(FALSE) ;
#endif

    if(! DefineSymbol("PARSER_VER_1.0", pglobl))   //  support multiple versions at once.
        return(FALSE) ;
}

    if(! BloadFile(pwstrFileName, pglobl) )
    {
        return(FALSE) ;
    }

    if(!BPreProcess(pglobl) )
        return(FALSE) ;

    ptkmap = (PTKMAP) gMasterTable[MTI_TOKENMAP].pubStruct ;


    while(parst != PARST_EXIT)
    {
        if(dwTKMindex >= gMasterTable[MTI_TOKENMAP].dwArraySize)
        {
            ERR(("Internal: no more tokenmap elements - restart.\n"));

            if(ERRSEV_RESTART > geErrorSev)
            {
                geErrorSev = ERRSEV_RESTART ;
                geErrorType = ERRTY_MEMORY_ALLOCATION ;
                gdwMasterTabIndex = MTI_TOKENMAP ;
            }
            return(FALSE) ;
        }
        switch(parst)
        {
            case (PARST_KEYWORD):
            {
                parst = PARSTscanForKeyword(&dwTKMindex, pglobl) ;
                break ;
            }
            case (PARST_COLON):
            {
                parst = PARSTparseColon(&dwTKMindex, pglobl) ;
                break ;
            }
            case (PARST_VALUE):
            {
                parst = PARSTparseValue(&dwTKMindex, pglobl) ;
                break ;
            }
            case (PARST_INCLUDEFILE):
            {
                parst = PARSTloadIncludeFile(&dwTKMindex, pwstrFileName, pglobl) ;
                if(!BPreProcess(pglobl) )
                    return(FALSE) ;
                break ;
            }
            case (PARST_EOF) :
            {
                parst = PARSTrestorePrevsFile(&dwTKMindex, pglobl) ;
                if((parst != PARST_EXIT)  &&  !BPreProcess(pglobl) )
                    return(FALSE) ;
                if(parst == PARST_EXIT  &&  mdwNestingLevel  &&  geErrorSev != ERRSEV_FATAL)
                {
                    ERR(("EOF reached before #Endif: was parsed!\n"));
                    geErrorType = ERRTY_SYNTAX ;
                    geErrorSev = ERRSEV_FATAL ;
                    return(FALSE) ;
                }
                break ;
            }
            case (PARST_ABORT) :
            {
                return(FALSE) ;  // abnormal termination.
                break ;
            }
            default:
            {
                ERR(("Internal error: no other PARST_ states exist!\n"));
                if(ERRSEV_FATAL > geErrorSev)
                {
                    geErrorSev = ERRSEV_FATAL ;
                    geErrorType = ERRTY_CODEBUG ;
                }
                return(FALSE) ;
            }
        }
    }
    return(TRUE) ;
}


PARSTATE  PARSTscanForKeyword(
PDWORD   pdwTKMindex,
PGLOBL   pglobl)
/*  this function exits with 2 possible codes:
    PARST_EOF:  end of source file encountered - return to parent file
    PARST_COLON:  a keyword or symbol keyword was parsed, now expecting
                a colon delimiter.
*/
{
    PTKMAP   ptkmap ;   // start of tokenmap

    // these two vars are just for inspiration, they may
    //  never be used.
    DWORD   dwCnt ;   //  counts length of keyword or value string
    PBYTE   pubStart ;  // start address of keyword or value string
    BYTE    ubSrc ;   //  a src byte


    /*  assume:
        no field in ptkmap[*pdwTKMindex] is initialized.
        pass all info by saving into ptkmap.

        always clear flags field and  consume remainder of
        line up to first linebreak char  in the event of
        a parsing error.

        we are looking for whichever occurs first:

        a) arbitrary white space
        c) { or }
        d) line break chars
        e) *keyword
        f) symbol keyword (not beginning with *)
        g) any other chars is a fatal error.
    */

    ptkmap = (PTKMAP) gMasterTable[MTI_TOKENMAP].pubStruct ;

    // was the previous entry an *include ?
    if(*pdwTKMindex)
    {
        DWORD   dwKeywordID,  dwSubType;

        dwKeywordID = ptkmap[*pdwTKMindex - 1].dwKeywordID ;

        if( (dwKeywordID  < ID_SPECIAL)  &&
            (mMainKeywordTable[dwKeywordID].eType == TY_SPECIAL))
        {
            dwSubType = mMainKeywordTable[dwKeywordID].dwSubType ;

            if( dwSubType == SPEC_INCLUDE )
            {
                (*pdwTKMindex)-- ;  // make this the current entry again
                return(PARST_INCLUDEFILE) ;
            }
            else if( (dwSubType == SPEC_MEM_CONFIG_KB)  ||
                ( dwSubType == SPEC_MEM_CONFIG_MB) )
            {
                BexpandMemConfigShortcut(dwSubType) ;
                //  checks to make sure there are
                //  enough slots in the tokenmap before proceeding.
            }
        }

        if(*pdwTKMindex >  gdwLastIndex  &&
                ! BarchiveStrings(*pdwTKMindex - 1, pglobl) )
            return(PARST_ABORT) ;
        gdwLastIndex = *pdwTKMindex ;
        //  strings from each entry will get saved only once.
    }

    ptkmap[*pdwTKMindex].dwFileNameIndex =
        mpSourcebuffer[mCurFile - 1].dwFileNameIndex ;

    while(  mdwSrcInd < mdwSrcMax  )
    {
        if(!BeatArbitraryWhite(pglobl) )
            break ;

        ptkmap[*pdwTKMindex].dwLineNumber =
            mpSourcebuffer[mCurFile - 1].dwLineNumber  ;

        switch(ubSrc = mpubSrcRef[mdwSrcInd])
        {
            case '*':
            {
                if(mdwSrcInd + 1 >= mdwSrcMax)
                {
                    vIdentifySource(ptkmap + *pdwTKMindex, pglobl) ;
                    ERR(("Unexpected EOF encountered parsing Keyword.\n"));
                    mdwSrcInd++ ;  // move past *  this
                    // will trigger EOF detector.
                    break ;
                }
                //  assume it must be a keyword since it wasn't
                //  consumed by eatArbitraryWhite().
                mdwSrcInd++ ;  // move past *
                if(BparseKeyword(*pdwTKMindex, pglobl) )
                {
                    ptkmap[*pdwTKMindex].dwKeywordID =
                        DWidentifyKeyword(*pdwTKMindex, pglobl) ;
                    return(PARST_COLON) ;
                }
                else
                {
                    vIdentifySource(ptkmap + *pdwTKMindex, pglobl) ;
                    ERR(("syntax error in Keyword: %0.*s.\n", ptkmap[*pdwTKMindex].aarKeyword.dw + 1,
                                    ptkmap[*pdwTKMindex].aarKeyword.pub - 1));

                    ptkmap[*pdwTKMindex].dwFlags = 0 ;
                            // must clear the flags
                    mdwSrcInd-- ;  // go back to *
                    BeatComment(pglobl) ;  // may place cursor at EOF
                }
                break ;
            }
            case '{':
            case '}':
            {
                ptkmap[*pdwTKMindex].aarKeyword.pub = mpubSrcRef +
                                                        mdwSrcInd ;
                ptkmap[*pdwTKMindex].aarKeyword.dw = 1 ;
                ptkmap[*pdwTKMindex].aarValue.pub = 0 ;
                ptkmap[*pdwTKMindex].aarValue.dw = 0 ;
                ptkmap[*pdwTKMindex].dwFlags |= TKMF_NOVALUE ;
                ptkmap[*pdwTKMindex].dwKeywordID =
                        DWidentifyKeyword(*pdwTKMindex, pglobl) ;
                (*pdwTKMindex)++ ;  // this is the complete entry!
                mdwSrcInd++ ;
                return(PARST_KEYWORD);  // re-enter this function
                break ;                 //  from the top.
            }
            case '\x1A':  // ignore control Z
                mdwSrcInd++ ;
                break;

            case '\n':
            {
                BYTE   ubTmp ;

                mdwSrcInd++ ;
                if(mdwSrcInd  < mdwSrcMax)
                {
                    ubTmp = mpubSrcRef[mdwSrcInd] ;
                    if(ubTmp  == '\r')
                    {
                        mdwSrcInd++ ;
                    }
                }
                mpSourcebuffer[mCurFile-1].dwLineNumber++ ;
                break ;  // eat 'em up yum!
            }
            case '\r':
            {
                BYTE   ubTmp ;

                mdwSrcInd++ ;
                if(mdwSrcInd  < mdwSrcMax)
                {
                    ubTmp = mpubSrcRef[mdwSrcInd] ;
                    if(ubTmp  == '\n')
                    {
                        mdwSrcInd++ ;
                    }
                }
                mpSourcebuffer[mCurFile-1].dwLineNumber++ ;
                break ;  // eat 'em up yum!
            }
            default:
            {
                if(BisExternKeyword(*pdwTKMindex, pglobl) )
                /*  if this token matches either EXTERN_GLOBAL
                or EXTERN_FEATURE  */
                {
                    if(!BisColonNext(pglobl) )
                    {
                        vIdentifySource(ptkmap + *pdwTKMindex, pglobl) ;
                        ERR(("syntax error:  Colon expected but missing.\n"));
                        ptkmap[*pdwTKMindex].dwFlags = 0 ;
                                    // must clear the flags
                                    //  if there is a syntax error.
                        BeatComment(pglobl) ;  // may place cursor at EOF
                    }
                    //  regardless of success or failure, we
                    //  remain in this function waiting for a *keyword.
                    break ;
                }
                //   parse token as a symbolkey.
                if(BparseKeyword(*pdwTKMindex, pglobl) )
                {
                    ptkmap[*pdwTKMindex].dwKeywordID = ID_SYMBOL ;
                    ptkmap[*pdwTKMindex].dwFlags |= TKMF_SYMBOL_KEYWORD ;
                    return (PARST_COLON) ;
                }
                else
                {
                    vIdentifySource(ptkmap + *pdwTKMindex, pglobl) ;
                    ERR(("syntax error: valid keyword token expected: %0.*s.\n", ptkmap[*pdwTKMindex].aarKeyword.dw,
                                    ptkmap[*pdwTKMindex].aarKeyword.pub));

                    ptkmap[*pdwTKMindex].dwFlags = 0 ;
                    BeatComment(pglobl) ;  // may place cursor at EOF
                }
                break ;
            }  //  end  default case
        }   //  end switch
    }  // end while
    return(PARST_EOF) ;  // falls out of for loop.
}



PARSTATE  PARSTparseColon(
PDWORD   pdwTKMindex,
PGLOBL   pglobl)
/*  this function exits with 3 possible codes:
    PARST_VALUE:  a colon parsed, now expecting a value.
    PARST_KEYWORD:  a line termination, EOF or illegal char was parsed.
        ready to parse a new entry.


    what looks to be a keyword has been parsed.
    attempt to look for a colon or line terminator.

    always clear flags field and  consume remainder of
    line up to first linebreak char  in the event of
    a parsing error.

*/
{
    PTKMAP   ptkmap ;   // start of tokenmap
    BYTE    ubSrc ;   //  a src byte

    ptkmap = (PTKMAP) gMasterTable[MTI_TOKENMAP].pubStruct ;


    if(!BeatArbitraryWhite(pglobl) )
    {
        //  encountered EOF and no value found.
        ptkmap[*pdwTKMindex].dwFlags |= TKMF_NOVALUE ;
        (*pdwTKMindex)++ ;  // entry complete
        return(PARST_KEYWORD) ;
    }
    if((ubSrc = mpubSrcRef[mdwSrcInd]) == ':')
    {
        mdwSrcInd++ ;  //  now expect a value
        return(PARST_VALUE) ;
    }
    else if(ubSrc == '\n'  ||  ubSrc == '\r')
    {
        //  encountered linebreak and no value found.
        ptkmap[*pdwTKMindex].dwFlags |= TKMF_NOVALUE ;
        (*pdwTKMindex)++ ;  // entry complete
        return(PARST_KEYWORD) ;
    }
    vIdentifySource(ptkmap + *pdwTKMindex, pglobl) ;
    ERR(("Colon expected after keyword: *%0.*s.\n", ptkmap[*pdwTKMindex].aarKeyword.dw,
                    ptkmap[*pdwTKMindex].aarKeyword.pub));
    BeatComment(pglobl) ;  // may place cursor at EOF
    ptkmap[*pdwTKMindex].dwFlags = 0 ;
    return(PARST_KEYWORD) ;
}



PARSTATE  PARSTparseValue(
PDWORD   pdwTKMindex,
PGLOBL   pglobl)
/*  this function exits with 1 possible codes:
    PARST_KEYWORD:  correctly parsed value, a line termination, EOF
        or illegal char was parsed.   ready to parse a new entry.


    Cursor is initially just past the colon delimiter, the purpose of
    this function is to locate the end of the value construct.  That
    is parse up to the level 0 { or } or linebreak.
    Replace any comments and continuation constructs that occur
    within this value with spaces.

    This function makes no assumptions about the type
    of value, it only assumes the value may be comprised of none, one
    of more tokens (separated by optional whitespace) of the form:

        LIST(aaa, bbb, ccc)
        POINT(), RECT()
        integer: *, + - nnnn
        Symbols, CONSTANTS
        "strings%""  %{command params}
        qualified.names
        =macroname

    We cannot simply stop scanning when { or } or non-continuation
    linebreak is encountered because the chars { and } may occur
    within comments, strings or command parameters.  Each of these
    constructs are governed by different parsing rules and hence
    are parsed by their own specialized functions.

    This function assumes all comments are preceeded by a
    white character.
*/
{
    PTKMAP   ptkmap ;   // start of tokenmap
    BYTE    ubSrc ;   //  a src byte
    DWORD   dwOrgInd; // holds index of start of value.

    ptkmap = (PTKMAP) (gMasterTable[MTI_TOKENMAP].pubStruct) ;

    if(!BeatArbitraryWhite(pglobl) )
    {
        ptkmap[*pdwTKMindex].dwFlags |= TKMF_NOVALUE ;
        (*pdwTKMindex)++ ;  // entry complete
        return(PARST_KEYWORD) ;
    }

    ptkmap[*pdwTKMindex].aarValue.pub = mpubSrcRef +
                                            mdwSrcInd ;
    dwOrgInd = mdwSrcInd ;

    while((ubSrc = mpubSrcRef[mdwSrcInd]) !=  '{'  &&   ubSrc !=  '}'  &&
            ubSrc !=  '\n'  &&  ubSrc !=  '\r')
    {
        switch(ubSrc)
        {
            case  '*':  // integer wildcard
            case  '-':  // integer neg sign
            case  '+':  // integer plus sign
            case  '.':  // separator for qualified name
            case  '?':  // valid char for symbolname
            case  '_':  // valid char for symbolname
            {
                mdwSrcInd++ ;   // go past this
                break ;
            }
            case  ':':  // additional token in value - shortcut?
            {
                ptkmap[*pdwTKMindex].dwFlags |= TKMF_COLON ;
                mdwSrcInd++ ;   // go past this
                break ;
            }
            case  '=':  // macroname indicator
            {
                ptkmap[*pdwTKMindex].dwFlags |= TKMF_MACROREF ;
                mdwSrcInd++ ;   // go past this
                break ;
            }

            case  '%':  // command parameter
            {
                if(!BscanDelimitedString('}', NULL, pglobl) )
                {
                    vIdentifySource(ptkmap + *pdwTKMindex, pglobl) ;
                    ERR(("Expected closing '}'.\n"));
                    ptkmap[*pdwTKMindex].dwFlags = 0 ;

                    return(PARST_KEYWORD) ;
                }
                break ;
            }

            case  '"' :   // this is a string construct
            {
                mdwSrcInd++ ;   // go past this
                if(!BscanStringSegment(pglobl) )
                {
                    vIdentifySource(ptkmap + *pdwTKMindex, pglobl) ;
                    ERR(("Error parsing string segment: %0.*s.\n",
                        mdwSrcInd - dwOrgInd,
                        ptkmap[*pdwTKMindex].aarValue.pub));

                    ptkmap[*pdwTKMindex].dwFlags = 0 ;

                    return(PARST_KEYWORD) ;
                }
                break ;
            }
            case '(':   //  arg list for LIST, POINT or RECT
            {
                BOOL  bMacroDetected ;

                if(!BscanDelimitedString(')', &bMacroDetected, pglobl) )
                {
                    vIdentifySource(ptkmap + *pdwTKMindex, pglobl) ;
                    ERR(("Expected closing ')'.\n"));

                    ptkmap[*pdwTKMindex].dwFlags = 0 ;

                    return(PARST_KEYWORD) ;
                }
                if(bMacroDetected)
                    ptkmap[*pdwTKMindex].dwFlags |= TKMF_MACROREF ;
                break ;
            }
            default:
            {
                if( (ubSrc  >= 'a' &&  ubSrc <= 'z')  ||
                    (ubSrc  >= 'A' &&  ubSrc <= 'Z')  ||
                    (ubSrc  >= '0' &&  ubSrc <= '9')  )
                {
                    mdwSrcInd++ ;   // looks legal, next char
                    break ;
                }
                else
                {
                    vIdentifySource(ptkmap + *pdwTKMindex, pglobl) ;
                    ERR(("illegal char encountered parsing value: %0.*s.\n",
                        mdwSrcInd - dwOrgInd,
                        ptkmap[*pdwTKMindex].aarValue.pub));
                    ERR(("    Line ignored.\n")) ;
                    ptkmap[*pdwTKMindex].dwFlags = 0 ;
                    BeatComment(pglobl) ;
                    ptkmap[*pdwTKMindex].dwKeywordID = gdwID_IgnoreBlock;
                    (*pdwTKMindex)++ ;  // entry complete

                    return(PARST_KEYWORD) ;
                }
            }
        }
        if(!BeatArbitraryWhite(pglobl) )
        {
            ptkmap[*pdwTKMindex].aarValue.dw =
                                mdwSrcInd - dwOrgInd ;
            if(!(mdwSrcInd - dwOrgInd))
                ptkmap[*pdwTKMindex].dwFlags |= TKMF_NOVALUE ;
            (*pdwTKMindex)++ ;  // entry complete
            return(PARST_KEYWORD) ; // end of file encountered.
        }
    }

    ptkmap[*pdwTKMindex].aarValue.dw = mdwSrcInd - dwOrgInd ;
    if(!(mdwSrcInd - dwOrgInd))
        ptkmap[*pdwTKMindex].dwFlags |= TKMF_NOVALUE ;

    (*pdwTKMindex)++ ;  // entry complete
    return(PARST_KEYWORD) ;
}








/*  all of the following helper functions
  leaves the cursor after the object being parsed
  if successful, otherwise cursor is unchanged
  except for consuming leading whitespace.
  Return value means sucess in parsing or
  simply that EOF was not encountered, see
  specific function.  */




BOOL  BparseKeyword(
DWORD   dwTKMindex,
PGLOBL  pglobl)
/*  assumes  mdwSrcInd points to start of keyword (char
    just after *).   Determine end of keyword.  mdwSrcInd advanced
    past end of keyword.  Initializes tokenmap entry aarKeyword.
*/
{
    PTKMAP   ptkmap ;   // start of tokenmap
    DWORD   dwCnt ;   //  counts length of keyword or value string
    BYTE    ubSrc ;   //  a src byte

    ptkmap = (PTKMAP) gMasterTable[MTI_TOKENMAP].pubStruct ;

    ptkmap[dwTKMindex].aarKeyword.pub = mpubSrcRef +
                                            mdwSrcInd ;

    for(dwCnt = 0 ; mdwSrcInd < mdwSrcMax ; mdwSrcInd++, dwCnt++)
    {
        ubSrc = mpubSrcRef[mdwSrcInd] ;
        if(ubSrc  == '?')
        {
            mdwSrcInd++ ;
            dwCnt++ ;
            break;  // the ? char is permitted as a terminator only.
        }
        if( (ubSrc  < 'a' ||  ubSrc > 'z')  &&
            (ubSrc  < 'A' ||  ubSrc > 'Z')  &&
            (ubSrc  < '0' ||  ubSrc > '9')  &&
            (ubSrc  != '_')  )
        {
            break ;  // end of keyword token.
        }
    }
    ptkmap[dwTKMindex].aarKeyword.dw = dwCnt ;
    return(dwCnt != 0);
}


BOOL    BisExternKeyword(
DWORD   dwTKMindex,
PGLOBL  pglobl)
/*  if this token matches either EXTERN_GLOBAL
    or EXTERN_FEATURE, this function sets the approp
    flag in the tokenentry, advances  mdwSrcInd past
    qualifier and returns true.   Else it leaves everything
    undisturbed and returns false.
*/
{
    PTKMAP   ptkmap ;   // start of tokenmap
    DWORD   dwCnt ;   //  counts length of keyword or value string
    BYTE    ubSrc ;   //  a src byte

    ptkmap = (PTKMAP) gMasterTable[MTI_TOKENMAP].pubStruct ;


    if((dwCnt = strlen("EXTERN_GLOBAL"))
        &&  (mdwSrcInd + dwCnt <= mdwSrcMax)
        &&  !strncmp(mpubSrcRef + mdwSrcInd ,  "EXTERN_GLOBAL", dwCnt ))
    {
        ptkmap[dwTKMindex].dwFlags |= TKMF_EXTERN_GLOBAL ;
    }
    else  if(dwCnt = strlen("EXTERN_FEATURE")  &&
        mdwSrcInd + dwCnt <= mdwSrcMax  &&
        !strncmp(mpubSrcRef + mdwSrcInd ,  "EXTERN_FEATURE", dwCnt ))
    {
        ptkmap[dwTKMindex].dwFlags |= TKMF_EXTERN_FEATURE ;
    }
    else
        return(FALSE);

    mdwSrcInd += dwCnt ;  // skip past qualifier
    return(TRUE);
}

BOOL  BisColonNext(
PGLOBL   pglobl)
{
    if(BeatArbitraryWhite(pglobl)  &&  mpubSrcRef[mdwSrcInd] == ':')
    {
        mdwSrcInd++ ;  // advance past colon.
        return(TRUE) ;
    }
    return(FALSE);  // leave pointing to non-colon object.
}

BOOL    BeatArbitraryWhite(
PGLOBL   pglobl)
/*  does nothing if not positioned
    at arbitrary whitespace, returns FALSE
    only if EOF  is encountered.
    Will replace comments and continuation constructs
    with spaces.
*/
{
    BYTE    ubSrc ;   //  a src byte

    while( mdwSrcInd < mdwSrcMax )
    {
        switch(ubSrc = mpubSrcRef[mdwSrcInd])
        {
            case '*':     //  a comment?
            {
                if(mdwSrcInd + 1 < mdwSrcMax  &&
                    mpubSrcRef[mdwSrcInd + 1]  == '%')
                {
                    if(!BeatComment(pglobl) )  // leave pointing at linebreak.
                        return(FALSE) ;  //  reached EOF.
                }
                else
                    return(TRUE) ;  // reached non-white.
                break ;
            }
            case ' ':
            case '\t':
            {
                mdwSrcInd++ ;  // go to next char
                break ;
            }
            case '\r':    // eat continuation constructs
            case '\n':    //  do not process normal EOL chars.
            {
                BYTE   ubTmp ;

                if(mdwSrcInd + 1 < mdwSrcMax)
                {
                    ubTmp = mpubSrcRef[mdwSrcInd + 1] ;
                    if(ubTmp  == '+')
                    {
                        mpubSrcRef[mdwSrcInd] = ' ' ;
                        mpubSrcRef[mdwSrcInd + 1] = ' ' ;
                        mdwSrcInd += 2 ;  // skip past '+'
                        mpSourcebuffer[mCurFile-1].dwLineNumber++ ;
                        break ;
                    }
                    else  if( ((ubTmp  == '\n') || (ubTmp  == '\r'))
                          &&  (ubTmp  != ubSrc)
                          &&  (mdwSrcInd + 2 < mdwSrcMax)
                          &&  (mpubSrcRef[mdwSrcInd + 2]  == '+') )
                    {
                        mpubSrcRef[mdwSrcInd] = ' ' ;
                        mpubSrcRef[mdwSrcInd + 1] = ' ' ;
                        mpubSrcRef[mdwSrcInd + 2] = ' ' ;
                        mdwSrcInd += 3 ;  // skip past '+'
                        mpSourcebuffer[mCurFile-1].dwLineNumber++ ;
                        break ;
                    }
                }
                return(TRUE) ;  // reached logical linebreak.
            }
            default:
                return(TRUE) ;  // reached non-white.
        }
    }
    return(FALSE) ;  //  reached EOF.
}

BOOL    BeatComment(
PGLOBL   pglobl)
//  replaces entire comment  with spaces until
//  linebreak char or EOF  is encountered.
{
    BYTE    ubSrc ;   //  a src byte

    for(  ;  mdwSrcInd < mdwSrcMax  ;  mdwSrcInd++)
    {
        ubSrc = mpubSrcRef[mdwSrcInd] ;
        if(ubSrc == '\n'  ||  ubSrc == '\r' )
            return(TRUE) ;  // reached linebreak char.
        mpubSrcRef[mdwSrcInd] = ' ' ;  // replace with space.
    }
    return(FALSE) ;  //  reached EOF.
}


BOOL    BscanStringSegment(
PGLOBL   pglobl)
//  cursor set just after first "
{
    BYTE    ubSrc  = '\0',   //  a src byte
            ubPrevs ;


    while(  mdwSrcInd < mdwSrcMax  )
    {
        ubPrevs = ubSrc ;
        ubSrc = mpubSrcRef[mdwSrcInd] ;

        if(ubSrc == '<'  &&  ubPrevs  != '%')
        {
            mdwSrcInd++ ;  // skip <
            if(!BscanDelimitedString('>', NULL, pglobl) )
            {
                ERR(("\nMissing closing > in string segment.\n"));
                return(FALSE) ;
            }
            continue ;  // leaves cursor pointing after '>'
        }
        else if(ubSrc == '"'  &&  ubPrevs  != '%')
        {
            mdwSrcInd++ ;  // end of literal string
            return(TRUE) ;
        }
        else if(ubSrc == '\n'  ||  ubSrc == '\r')
            break ;
        else
            mdwSrcInd++ ;  // scan through string
    }
    ERR(("\nLinebreak or EOF was encountered while parsing string segment.\n"));
    return(FALSE) ;
}


BOOL    BscanDelimitedString(
BYTE     ubDelimiter,      //  the byte that signifies the end.
PBOOL    pbMacroDetected,  //  set true if '=' was encountered.
PGLOBL   pglobl)
//  cursor set just after first <
{
    BYTE    ubSrc ;   //  a src byte

    if(pbMacroDetected)
        *pbMacroDetected = FALSE;

    while(  mdwSrcInd < mdwSrcMax  )
    {
        ubSrc = mpubSrcRef[mdwSrcInd] ;

        if(ubSrc == ubDelimiter)
        {       // end of hex substring construct
            mdwSrcInd++ ;
            return(TRUE) ;
        }
        else  if(ubSrc ==  ' '  ||   ubSrc ==  '\t'  ||
            ubSrc ==  '\n'  ||  ubSrc ==  '\r')
        {
            if(!BeatArbitraryWhite(pglobl) )
                break ;
            ubSrc = mpubSrcRef[mdwSrcInd] ;

            if(ubSrc ==  '\n'  ||  ubSrc ==  '\r')
                break ;
        }
        else
        {
            mdwSrcInd++ ;  // keep parsing

            if(ubSrc ==  '='  &&  pbMacroDetected)
                *pbMacroDetected = TRUE ;
        }
    }
    ERR(("unexpected linebreak or EOF.\n"));
    return(FALSE) ;   // BUG_BUG!  unexpected linebreak or EOF
                    //  in hex substring if delimiter was >
                    //  LIST, POINT, etc if delimiter was ).
                    //  command parameter if delimiter was }
}


PARSTATE    PARSTrestorePrevsFile(
PDWORD   pdwTKMindex,
PGLOBL   pglobl)
/*  this function exits with 2 possible codes:
    PARST_EXIT:  no more files left in stack !
    PARST_KEYWORD:  returned to prevs file.  Ready to
        resume parsing of new tokenmap entry.

    The only function that issues PARST_EOF  is  parseKeyword().
    It handles all processing for the previous keyword.
*/
{
    PTKMAP   ptkmap ;   // start of tokenmap

    ptkmap = (PTKMAP) gMasterTable[MTI_TOKENMAP].pubStruct ;

    mCurFile-- ;  // pop stack

    MemFree(mpSourcebuffer[mCurFile].pubSrcBuf) ;
    if(mCurFile)
        return(PARST_KEYWORD) ;

    ptkmap[*pdwTKMindex].dwKeywordID = ID_EOF ;
    (*pdwTKMindex)++ ;
    //  this is the last entry in the tokenmap.
    return(PARST_EXIT) ;  //  reached end of rootfile.
}



PWSTR
PwstrAnsiToUnicode(
    IN  PSTR pstrAnsiString,
        PGLOBL   pglobl
)

/*++

Routine Description:

    Make a Unicode copy of the input ANSI string
    Warning: caller must delete Unicode copy when finished

Arguments:

    pstrAnsiString - Pointer to the input ANSI string

Return Value:

    Pointer to the resulting Unicode string
    NULL if there is an error

--*/

{
    PWSTR   pwstr;  // holds Unicode string
    DWORD dwLen ;

    ASSERT(pstrAnsiString != NULL);

    dwLen = strlen(pstrAnsiString) + 1;

    if (pwstr = (PWSTR)MemAlloc(dwLen * sizeof(WCHAR)))
    {
        MultiByteToWideChar(CP_ACP, MB_PRECOMPOSED, pstrAnsiString, dwLen,
                    pwstr, dwLen * sizeof(WCHAR));
        //
        // Make sure the Unicode string is null-terminated
        //
        pwstr[dwLen - 1] = NUL;
    }
    else
    {
        ERR(("Fatal: unable to alloc requested memory: %d bytes.\n",
            dwLen * sizeof(WCHAR)));
        geErrorType = ERRTY_MEMORY_ALLOCATION ;
        geErrorSev = ERRSEV_FATAL ;
    }
    return pwstr;
}


PARSTATE    PARSTloadIncludeFile(
PDWORD   pdwTKMindex,
PWSTR    pwstrRootFileName,    // root GPD file
PGLOBL   pglobl)
/*  this function exits with 2 possible codes:
    PARST_ABORT:  unable to read included file, force termination.
    PARST_KEYWORD:  opened file, updated  SOURCEBUFFER stack,
        ready to parse a new tokenmap entry which will overwrite the
        *Include entry.

    pdwTKMindex points to tokenmap entry containing the
    *include keyword.

    Each Memory Mapped file is referenced by a SOURCEBUFFER
    structure.

    typedef  struct
    {
        PBYTE  pubSrcBuf ;      //  start of file bytes.
        DWORD  dwCurIndex ;     //  stream ptr
        DWORD  dwArraySize ;    //  filesize
        PWSTR   pwstrFileName ;
        HFILEMAP   hFile ;         //  used to access/close file.
    } SOURCEBUFFER, * PSOURCEBUFFER ;
    //  the tagname is 'sb'

*/
{
    PTKMAP   ptkmap ;   // start of tokenmap
    ARRAYREF      arStrValue ;  // dest for BparseString.
    PWSTR   pwstrFileName ;  //  , pwstrFullyQualifiedName = NULL;
    WCHAR * pwDLLQualifiedName = NULL ;
    PBYTE   pubFileName ;
    PARSTATE    parst = PARST_KEYWORD;
    PWSTR   pwstrLastBackSlash ;
    DWORD  pathlen = 0 ;
    DWORD  namelen =  0 ;

    ptkmap = (PTKMAP) gMasterTable[MTI_TOKENMAP].pubStruct ;

    //  does a value exist?

    if(ptkmap[*pdwTKMindex].dwFlags & TKMF_NOVALUE  ||
        !BparseString(&(ptkmap[*pdwTKMindex].aarValue), &arStrValue, pglobl) )
    {
        ERR(("syntax error in filename for *Include keyword.\n"));
        //  fatal error.    override initial error code.
        return(PARST_ABORT) ;
    }
#if !defined(DEVSTUDIO)
    //  nothing here !
#endif
    pubFileName = mpubOffRef + arStrValue.loOffset ;

    pwstrFileName = PwstrAnsiToUnicode(pubFileName, pglobl) ;

    if(!pwstrFileName)
    {
        parst = PARST_ABORT ;
        goto FREE_MEM ;
    }
#if !defined(DEVSTUDIO)

    //  how large should pwDLLQualifiedName be???

    pathlen = wcslen(pwstrRootFileName) ;
    namelen =  pathlen + wcslen(pwstrFileName)  + 1;

    if (!(pwDLLQualifiedName =
        (PWSTR)MemAlloc(namelen * sizeof(WCHAR)) ))
    {
        ERR(("Fatal: unable to alloc requested memory: %d WCHARs.\n",
            namelen));
        geErrorType = ERRTY_MEMORY_ALLOCATION ;
        geErrorSev = ERRSEV_FATAL ;
        return(PARST_ABORT) ;
    }

    wcsncpy(pwDLLQualifiedName, pwstrRootFileName , namelen);

    if (pwstrLastBackSlash = wcsrchr(pwDLLQualifiedName,TEXT('\\')))
    {
        *(pwstrLastBackSlash + 1) = NUL;

        wcscat(pwDLLQualifiedName, pwstrFileName) ;
    }
    else
    {
        ERR(("Internal Error: Must specify fully qualified path to Root GPD file.\n"));
        //  fatal error.    override initial error code.
        parst = PARST_ABORT ;
        goto FREE_MEM ;
    }

    if(! BloadFile(pwDLLQualifiedName, pglobl) )
#else
    if(! BloadFile(pwstrFileName, pglobl) )
#endif
        parst = PARST_ABORT ;
    else
        parst = PARST_KEYWORD ;

FREE_MEM:

    if(pwstrFileName)
        MemFree(pwstrFileName) ;
    if(pwDLLQualifiedName)
        MemFree(pwDLLQualifiedName) ;
    return(parst) ;
}


BOOL    BloadFile(
PWSTR   pwstrFileName,
PGLOBL  pglobl)
{
    PBYTE  pub ;
    PGPDFILEDATEINFO    pfdi ;
    DWORD       dwNodeIndex ;
    HANDLE          hFile;


    //  mCurFile points to first uninitialized SOURCEBUFFER element
    if(mCurFile  >= mMaxFiles)
    {
        //  nesting level too deep.

        if(ERRSEV_RESTART > geErrorSev)
        {
            geErrorSev = ERRSEV_RESTART ;
            geErrorType = ERRTY_MEMORY_ALLOCATION ;
            gdwMasterTabIndex = MTI_SOURCEBUFFER ;
        }
        return(FALSE) ;
    }


    pfdi = (PGPDFILEDATEINFO) gMasterTable[MTI_GPDFILEDATEINFO].pubStruct ;
    //  address of first GPDFILEDATEINFO struct

    if(! BallocElementFromMasterTable(MTI_GPDFILEDATEINFO , &dwNodeIndex, pglobl) )
    {
        return(FALSE) ;
    }



    mpSourcebuffer[mCurFile].dwFileNameIndex =
        dwStoreFileName(pwstrFileName, &pfdi[dwNodeIndex].arFileName, pglobl) ;
        // store Unicode representation of filename for diagnostic purposes.

    if(mpSourcebuffer[mCurFile].dwFileNameIndex == INVALID_INDEX)
    {
        return(FALSE) ;  // something failed
    }

    mpSourcebuffer[mCurFile].dwLineNumber = 1 ;  // new rule:  line 0 does not exist.


    mpSourcebuffer[mCurFile].hFile = MapFileIntoMemory(
        pwstrFileName, (PVOID  *)&(pub),
        &(mpSourcebuffer[mCurFile].dwArraySize)) ;

    if(!mpSourcebuffer[mCurFile].hFile  || !pub)
    {
        ERR(("unable to open GPD file: %S\n", pwstrFileName));
        //  set fatal error
        geErrorSev = ERRSEV_FATAL ;
        geErrorType = ERRTY_FILE_OPEN ;
        return(FALSE) ;
    }
    //  mapping successful.   allocate writable buffer.
    mpSourcebuffer[mCurFile].pubSrcBuf =
            MemAlloc(mpSourcebuffer[mCurFile].dwArraySize) ;
    if(!(mpSourcebuffer[mCurFile].pubSrcBuf))
    {
        ERR(("Fatal: unable to alloc requested memory: %d bytes.\n",
            mpSourcebuffer[mCurFile].dwArraySize));
        geErrorType = ERRTY_MEMORY_ALLOCATION ;
        geErrorSev = ERRSEV_FATAL ;
        gdwMasterTabIndex = MTI_SOURCEBUFFER ;
        UnmapFileFromMemory(mpSourcebuffer[mCurFile].hFile) ;
        return(FALSE) ;   // This is unrecoverable
    }
    memcpy(mpSourcebuffer[mCurFile].pubSrcBuf,
        pub, mpSourcebuffer[mCurFile].dwArraySize) ;

    UnmapFileFromMemory(mpSourcebuffer[mCurFile].hFile) ;

    //  reopen to determine timestamp.

    hFile  = CreateFile(pwstrFileName,
                GENERIC_READ,
                FILE_SHARE_READ,
                NULL,
                OPEN_EXISTING,
                FILE_ATTRIBUTE_NORMAL,
                NULL);

    if (hFile != INVALID_HANDLE_VALUE)
    {
        if(!GetFileTime(hFile, NULL, NULL,
                        &pfdi[dwNodeIndex].FileTime) )
        {
            ERR(("GetFileTime '%S' failed.\n", pwstrFileName));
        }
        CloseHandle(hFile);
    }
    else
    {
        geErrorSev  = ERRSEV_FATAL;
        geErrorType = ERRTY_FILE_OPEN;
        ERR(("CreateFile '%S' failed.\n", pwstrFileName));
    }

    gmrbd.rbd.dwSrcFileChecksum32 =
        ComputeCrc32Checksum(
            mpSourcebuffer[mCurFile].pubSrcBuf,
            mpSourcebuffer[mCurFile].dwArraySize,
            gmrbd.rbd.dwSrcFileChecksum32      ) ;

    mCurFile++ ;  // we now have an open file on the stack
    mdwSrcInd  = 0 ;  // initialize stream ptr to start of file.
    return(TRUE) ;
}


BOOL        BarchiveStrings(
DWORD   dwTKMindex,
PGLOBL  pglobl)
/*
    you see the Memory Mapped file only exists until
    parsing reaches EOF.  At that time its closed.
    And all the aars stored in the tokenmap become useless.
    So to extend their lifetime, we copy the strings to
    a temporary heap.  A heap that isn't going to be
    saved as part of the GPD binary file.
*/
{
    PTKMAP   ptkmap ;   // start of tokenmap
    DWORD   dwKeywordID ;
    ABSARRAYREF    aarDest ;

    ptkmap = (PTKMAP) gMasterTable[MTI_TOKENMAP].pubStruct ;
    dwKeywordID = ptkmap[dwTKMindex].dwKeywordID ;

    if((dwKeywordID != ID_NULLENTRY)  &&  (dwKeywordID != ID_EOF) )
    {
        //  copy keyword string over
        if(!BcopyToTmpHeap(&aarDest, &(ptkmap[dwTKMindex].aarKeyword), pglobl))
            return(FALSE) ;
        ptkmap[dwTKMindex].aarKeyword.pub = aarDest.pub ;
        ptkmap[dwTKMindex].aarKeyword.dw  = aarDest.dw  ;

        if(!(ptkmap[dwTKMindex].dwFlags & TKMF_NOVALUE))
        {
            //  copy value string over.
            if(!BcopyToTmpHeap(&aarDest, &(ptkmap[dwTKMindex].aarValue), pglobl))
                return(FALSE) ;
            ptkmap[dwTKMindex].aarValue.pub = aarDest.pub ;
            ptkmap[dwTKMindex].aarValue.dw  = aarDest.dw  ;
        }
    }
    return(TRUE) ;
}






DWORD  DWidentifyKeyword(
DWORD   dwTKMindex,
PGLOBL  pglobl)
/*  assumes  keywords are not symbol keywords.
    if they are attribute keywords they will be labeled
    as ID_UNRECOGNIZED.
    returns (KeywordID)  */
{
    PTKMAP   ptkmap ;   // start of tokenmap
    DWORD   dwCnt ;   //  counts length of keyword or value string
    DWORD   dwKeyID ;  //  array index of MainKeywordTable
                    //  also serves as the keywordID
    PBYTE   pubKey ;
    DWORD   dwStart, dwEnd ;

    ptkmap = (PTKMAP) gMasterTable[MTI_TOKENMAP].pubStruct ;

    if(ptkmap[dwTKMindex].dwFlags & TKMF_SYMBOL_KEYWORD)
    {
        return(ID_SYMBOL) ;  //  safety net.
    }

    dwStart = mprngDictionary[NON_ATTR].dwStart ;
    dwEnd = mprngDictionary[NON_ATTR].dwEnd ;

    for(dwKeyID = dwStart ;  dwKeyID  < dwEnd  ;  dwKeyID++ )
    {
        pubKey = mMainKeywordTable[dwKeyID].pstrKeyword ;
        dwCnt = strlen(pubKey) ;
        if(dwCnt != ptkmap[dwTKMindex].aarKeyword.dw)
            continue ;
        if(strncmp(ptkmap[dwTKMindex].aarKeyword.pub, pubKey, dwCnt))
            continue ;
        return(dwKeyID);
    }
    return(ID_UNRECOGNIZED) ;    //  does not attempt to identify
            //  attributes, this is done in BInterpretTokens().
}


BOOL    BidentifyAttributeKeyword(
PTKMAP  ptkmap,   // pointer to tokenmap
PGLOBL  pglobl
)
/*
    //  Assume this is an attribute keyword.
    //  If the flags TKMF_EXTERN_GLOBAL or _FEATURE
    //  the GPD author is explicitly identifying
    //  this as an attribute.   Else look at the current
    //  state as an indication of which attribute dictionary
    //  to look at.
*/
{
    DWORD       dwKeywordID ;
    STATE       stOldState;
    KEYWORD_SECTS   eSection ;
    DWORD   dwStart, dwEnd , dwKeyID,
        dwCnt ;   //  counts length of keyword or value string
    PBYTE   pubKey ;

    if(ptkmap->dwFlags & TKMF_EXTERN_GLOBAL )
        eSection = GLOBAL_ATTR ;
    else if(ptkmap->dwFlags & TKMF_EXTERN_FEATURE )
        eSection = FEATURE_ATTR ;
    else
    {
        if(mdwCurStsPtr)
            stOldState = mpstsStateStack[mdwCurStsPtr - 1].stState ;
        else
            stOldState = STATE_ROOT ;
        switch(stOldState)
        {
            case (STATE_ROOT):
            case (STATE_CASE_ROOT):
            case (STATE_DEFAULT_ROOT):
            {
                eSection =  GLOBAL_ATTR;
                break ;
            }
            case (STATE_FEATURE):
            case (STATE_CASE_FEATURE):
            case (STATE_DEFAULT_FEATURE):
            {
                eSection =  FEATURE_ATTR;
                break ;
            }
            case (STATE_OPTIONS):
            case (STATE_CASE_OPTION):
            case (STATE_DEFAULT_OPTION):
            {
                eSection =  OPTION_ATTR;
                break ;
            }
            case (STATE_COMMAND):
            {
                eSection =  COMMAND_ATTR;
                break ;
            }
            case (STATE_FONTCART):
            {
                eSection = FONTCART_ATTR ;
                break ;
            }
            case (STATE_TTFONTSUBS):
            {
                eSection = TTFONTSUBS_ATTR ;
                break ;
            }
            case (STATE_OEM):
            {
                eSection = OEM_ATTR ;
                break ;
            }
            default:   //  STATE_UIGROUP, STATE_SWITCH_anything  etc.
            {
                return(FALSE);  // no attributes allowed in this state.
            }
        }
    }
    dwStart = mprngDictionary[eSection].dwStart ;
    dwEnd = mprngDictionary[eSection].dwEnd ;

    for(dwKeyID = dwStart ;  dwKeyID  < dwEnd  ;  dwKeyID++ )
    {
        pubKey = mMainKeywordTable[dwKeyID].pstrKeyword ;
        dwCnt = strlen(pubKey) ;
        if(dwCnt != ptkmap->aarKeyword.dw)
            continue ;
        if(strncmp(ptkmap->aarKeyword.pub, pubKey, dwCnt))
            continue ;
        ptkmap->dwKeywordID = dwKeyID;
        return(TRUE);
    }
    return(FALSE);  // keyword not found in dictionary.
}


BOOL    BcopyToTmpHeap(
PABSARRAYREF    paarDest,
PABSARRAYREF    paarSrc,
PGLOBL          pglobl)
/*  copy aarstring to the temp heap
    does not create null terminated strings!  */
{

#define  mpubOffReft     (gMasterTable[MTI_TMPHEAP].pubStruct)
#define  mloCurHeapt     (gMasterTable[MTI_TMPHEAP].dwCurIndex)
#define  mdwMaxHeapt     (gMasterTable[MTI_TMPHEAP].dwArraySize)

    if(mloCurHeapt + paarSrc->dw >= mdwMaxHeapt)
    {
        ERR(("Out of heap space, restart.\n"));

        if(ERRSEV_RESTART > geErrorSev)
        {
            geErrorSev = ERRSEV_RESTART ;
            geErrorType = ERRTY_MEMORY_ALLOCATION ;
            gdwMasterTabIndex = MTI_TMPHEAP ;
        }
        return(FALSE) ;
    }
    paarDest->dw = paarSrc->dw ;
    paarDest->pub = mpubOffReft + mloCurHeapt ;

    memcpy(paarDest->pub, paarSrc->pub, paarSrc->dw ) ;
    mloCurHeapt += paarSrc->dw ;
    return(TRUE) ;

#undef  mpubOffReft
#undef  mloCurHeapt
#undef  mdwMaxHeapt
}


#define     mCurFileName   (gMasterTable[MTI_FILENAMES].dwCurIndex)
#define     mpFileNamesArray  ((PWSTR *)(gMasterTable \
                            [MTI_FILENAMES].pubStruct))



DWORD    dwStoreFileName(PWSTR    pwstrFileName,
PARRAYREF   parDest,
PGLOBL      pglobl)
    // goes into a permanent
    //  stack of filenames - to be deleted at return buffers
    //  time.   Returns index in array where name has been
    //  stored.
    //  also saves filename into heap.  So we can access the GPD file
    //  and check its timestamp whenever we load the BUD file.
{
    DWORD  dwNodeIndex, dwLen ;

    if(!BallocElementFromMasterTable(MTI_FILENAMES, &dwNodeIndex, pglobl))
        return(INVALID_INDEX) ;

    dwLen = wcslen(pwstrFileName) + 1 ;  // need room for terminating null.
    mpFileNamesArray[dwNodeIndex] = MemAlloc(dwLen * 2) ;
    if(!mpFileNamesArray[dwNodeIndex])
    {
        ERR(("Fatal: unable to alloc requested memory: %d bytes.\n",
            dwLen * 2));
        geErrorType = ERRTY_MEMORY_ALLOCATION ;
        geErrorSev = ERRSEV_FATAL ;
        return(INVALID_INDEX) ;
    }
    wcscpy(mpFileNamesArray[dwNodeIndex], pwstrFileName) ;

    parDest->dwCount = (dwLen - 1) * 2 ;  // doesn't include the NUL term.

    if(!BwriteToHeap(&parDest->loOffset, (PBYTE)pwstrFileName, dwLen * 2, 2, pglobl) )  //  includes Null termination
        return(INVALID_INDEX) ;

    return(dwNodeIndex) ;
}



VOID    vFreeFileNames(
PGLOBL   pglobl )
{

    //  free all buffers holding the filenames.

    while(mCurFileName)
    {
        mCurFileName-- ;  // pop stack
        MemFree(mpFileNamesArray[mCurFileName]) ;
    }
}


VOID    vIdentifySource(
    PTKMAP   ptkmap,
    PGLOBL   pglobl )
{
    PWSTR    pwstrFileName ;

    if(ptkmap->dwKeywordID  ==  ID_EOF)
    {
        ERR(("\nEnd of File reached.\n")) ;
        return;
    }

    pwstrFileName = mpFileNamesArray[ptkmap->dwFileNameIndex] ;

    if(pwstrFileName)
#if defined(DEVSTUDIO)  //  Emit compiler-style line messages
        ERR(("\n%S(%d): ", pwstrFileName, ptkmap->dwLineNumber)) ;
#else
        ERR(("\n%S: line: %d ...\n", pwstrFileName, ptkmap->dwLineNumber)) ;
#endif
}


#undef  mCurFileName
#undef  mpFileNamesArray
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\parsers\ppd\ppdchar.c ===
/*++

Copyright (c) 1996-1997  Microsoft Corporation

Module Name:

    ppdchar.c

Abstract:

    Functions for parsing the lexical elements of a PPD file

Environment:

    PostScript driver, PPD parser

Revision History:

    08/20/96 -davidx-
        Common coding style for NT 5.0 drivers.

    03/26/96 -davidx-
    	Created it.

--*/

#include "lib.h"
#include "ppd.h"
#include "ppdparse.h"



PFILEOBJ
PCreateFileObj(
    PTSTR   ptstrFilename
    )

/*++

Routine Description:

    Create an input file object

Arguments:

    ptstrFilename - Specifies the input file name

Return Value:

    Pointer to the newly-created file object
    NULL if there is an error

--*/

{
    PFILEOBJ    pFile;

    if (! (pFile = MemAllocZ(sizeof(FILEOBJ))) ||
        ! (pFile->ptstrFileName = DuplicateString(ptstrFilename)))
    {
        ERR(("Memory allocation failed\n"));
        MemFree(pFile);
        return NULL;
    }

    pFile->hFileMap = MapFileIntoMemory(ptstrFilename,
                                        (PVOID *) &pFile->pubStart,
                                        &pFile->dwFileSize);

    if (pFile->hFileMap == NULL)
    {
        ERR(("Couldn't open file: %ws\n", ptstrFilename));
        MemFree(pFile);
        pFile = NULL;
    }
    else
    {
        pFile->pubNext = pFile->pubStart;
        pFile->pubEnd = pFile->pubStart + pFile->dwFileSize;
        pFile->iLineNumber = 1;
        pFile->bNewLine = TRUE;
    }

    return pFile;
}



VOID
VDeleteFileObj(
    PFILEOBJ    pFile
    )

/*++

Routine Description:

    Delete an input file object

Arguments:

    pFile - Specifies the file object to be deleted

Return Value:

    NONE

--*/

{
    ASSERT(pFile && pFile->hFileMap);

    UnmapFileFromMemory(pFile->hFileMap);
    MemFree(pFile->ptstrFileName);
    MemFree(pFile);
}



INT
IGetNextChar(
    PFILEOBJ    pFile
    )

/*++

Routine Description:

    Read the next character from the input file

Arguments:

    pFile - Specifies the input file

Return Value:

    Next character from the input file
    EOF_CHAR if end-of-file is encountered

--*/

{
    INT iBadChars = 0;

    //
    // Skip non-printable control characters
    //

    while (!END_OF_FILE(pFile) && !IS_VALID_CHAR(*pFile->pubNext))
        iBadChars++, pFile->pubNext++;

    if (iBadChars)
    {
        TERSE(("%ws: Non-printable characters on line %d\n",
               pFile->ptstrFileName,
               pFile->iLineNumber));
    }

    if (END_OF_FILE(pFile))
        return EOF_CHAR;

    //
    // A newline is a carriage-return, a line-feed, or CR-LF combination
    //

    if (*pFile->pubNext == LF ||
        *pFile->pubNext == CR && (END_OF_FILE(pFile) || pFile->pubNext[1] != LF))
    {
        pFile->bNewLine = TRUE;
        pFile->iLineNumber++;

    }
    else
    {
        pFile->bNewLine = FALSE;
    }

    return *(pFile->pubNext++); // return current character and advance pointer to next char
}



VOID
VUngetChar(
    PFILEOBJ    pFile
    )

/*++

Routine Description:

    Return the last character read to the input file

Arguments:

    pFile - Specifies the input file

Return Value:

    NONE

--*/

{
    ASSERT(pFile->pubNext > pFile->pubStart);
    pFile->pubNext--;
    
    if (pFile->bNewLine)
    {
        ASSERT(pFile->iLineNumber > 1);
        pFile->iLineNumber--;
        pFile->bNewLine = FALSE;
    }
}



VOID
VSkipSpace(
    PFILEOBJ    pFile
    )

/*++

Routine Description:

    Skip all characters until the next non-space character

Arguments:

    pFile - Specifies the input file

Return Value:

    NONE

--*/

{
    while (!END_OF_FILE(pFile) && IS_SPACE(*pFile->pubNext))
        pFile->pubNext++;
}



VOID
VSkipLine(
    PFILEOBJ    pFile
    )

/*++

Routine Description:

    Skip the remaining characters on the current input line

Arguments:

    pFile - Specifies the input file

Return Value:

    NONE

--*/

{
    while (!END_OF_LINE(pFile) && IGetNextChar(pFile) != EOF_CHAR)
        NULL;
}



BOOL
BIs7BitAscii(
    PSTR        pstr
    )

/*++

Routine Description:

    Check if a character string consists only of printable 7-bit ASCII characters

Arguments:

    pstr - Specifies the character string to be checked

Return Value:

    TRUE if the specified string consists only of printable 7-bit ASCII characters
    FALSE otherwise

--*/

{
    PBYTE   pub = (PBYTE) pstr;

    while (*pub && gubCharMasks[*pub] && *pub < 127)
        pub++;

    return (*pub == 0);
}



//
// Table to indicate which characters are allowed in what fields
//

#define DEFAULT_MASK (KEYWORD_MASK|XLATION_MASK|QUOTED_MASK|STRING_MASK)
#define BINARY_MASK  (QUOTED_MASK|XLATION_MASK)

const BYTE gubCharMasks[256] = {

    /* 00 :   */ 0,
    /* 01 :   */ 0,
    /* 02 :   */ 0,
    /* 03 :   */ 0,
    /* 04 :   */ 0,
    /* 05 :   */ 0,
    /* 06 :   */ 0,
    /* 07 :   */ 0,
    /* 08 :   */ 0,
    /* 09 :   */ DEFAULT_MASK ^ KEYWORD_MASK,
    /* 0A :   */ QUOTED_MASK,
    /* 0B :   */ 0,
    /* 0C :   */ 0,
    /* 0D :   */ QUOTED_MASK,
    /* 0E :   */ 0,
    /* 0F :   */ 0,
    /* 10 :   */ 0,
    /* 11 :   */ 0,
    /* 12 :   */ 0,
    /* 13 :   */ 0,
    /* 14 :   */ 0,
    /* 15 :   */ 0,
    /* 16 :   */ 0,
    /* 17 :   */ 0,
    /* 18 :   */ 0,
    /* 19 :   */ 0,
    /* 1A :   */ 0,
    /* 1B :   */ 0,
    /* 1C :   */ 0,
    /* 1D :   */ 0,
    /* 1E :   */ 0,
    /* 1F :   */ 0,
    /* 20 :   */ DEFAULT_MASK ^ KEYWORD_MASK,
    /* 21 : ! */ DEFAULT_MASK,
    /* 22 : " */ DEFAULT_MASK ^ QUOTED_MASK,
    /* 23 : # */ DEFAULT_MASK,
    /* 24 : $ */ DEFAULT_MASK,
    /* 25 : % */ DEFAULT_MASK,
    /* 26 : & */ DEFAULT_MASK,
    /* 27 : ' */ DEFAULT_MASK,
    /* 28 : ( */ DEFAULT_MASK,
    /* 29 : ) */ DEFAULT_MASK,
    /* 2A : * */ DEFAULT_MASK,
    /* 2B : + */ DEFAULT_MASK,
    /* 2C : , */ DEFAULT_MASK,
    /* 2D : - */ DEFAULT_MASK,
    /* 2E : . */ DEFAULT_MASK,
    /* 2F : / */ DEFAULT_MASK ^ (KEYWORD_MASK|STRING_MASK),
    /* 30 : 0 */ DEFAULT_MASK | DIGIT_MASK,
    /* 31 : 1 */ DEFAULT_MASK | DIGIT_MASK,
    /* 32 : 2 */ DEFAULT_MASK | DIGIT_MASK,
    /* 33 : 3 */ DEFAULT_MASK | DIGIT_MASK,
    /* 34 : 4 */ DEFAULT_MASK | DIGIT_MASK,
    /* 35 : 5 */ DEFAULT_MASK | DIGIT_MASK,
    /* 36 : 6 */ DEFAULT_MASK | DIGIT_MASK,
    /* 37 : 7 */ DEFAULT_MASK | DIGIT_MASK,
    /* 38 : 8 */ DEFAULT_MASK | DIGIT_MASK,
    /* 39 : 9 */ DEFAULT_MASK | DIGIT_MASK,
    /* 3A : : */ DEFAULT_MASK ^ (KEYWORD_MASK|XLATION_MASK),
    /* 3B : ; */ DEFAULT_MASK,
    /* 3C : < */ DEFAULT_MASK,
    /* 3D : = */ DEFAULT_MASK,
    /* 3E : > */ DEFAULT_MASK,
    /* 3F : ? */ DEFAULT_MASK,
    /* 40 : @ */ DEFAULT_MASK,
    /* 41 : A */ DEFAULT_MASK | HEX_DIGIT_MASK,
    /* 42 : B */ DEFAULT_MASK | HEX_DIGIT_MASK,
    /* 43 : C */ DEFAULT_MASK | HEX_DIGIT_MASK,
    /* 44 : D */ DEFAULT_MASK | HEX_DIGIT_MASK,
    /* 45 : E */ DEFAULT_MASK | HEX_DIGIT_MASK,
    /* 46 : F */ DEFAULT_MASK | HEX_DIGIT_MASK,
    /* 47 : G */ DEFAULT_MASK,
    /* 48 : H */ DEFAULT_MASK,
    /* 49 : I */ DEFAULT_MASK,
    /* 4A : J */ DEFAULT_MASK,
    /* 4B : K */ DEFAULT_MASK,
    /* 4C : L */ DEFAULT_MASK,
    /* 4D : M */ DEFAULT_MASK,
    /* 4E : N */ DEFAULT_MASK,
    /* 4F : O */ DEFAULT_MASK,
    /* 50 : P */ DEFAULT_MASK,
    /* 51 : Q */ DEFAULT_MASK,
    /* 52 : R */ DEFAULT_MASK,
    /* 53 : S */ DEFAULT_MASK,
    /* 54 : T */ DEFAULT_MASK,
    /* 55 : U */ DEFAULT_MASK,
    /* 56 : V */ DEFAULT_MASK,
    /* 57 : W */ DEFAULT_MASK,
    /* 58 : X */ DEFAULT_MASK,
    /* 59 : Y */ DEFAULT_MASK,
    /* 5A : Z */ DEFAULT_MASK,
    /* 5B : [ */ DEFAULT_MASK,
    /* 5C : \ */ DEFAULT_MASK,
    /* 5D : ] */ DEFAULT_MASK,
    /* 5E : ^ */ DEFAULT_MASK,
    /* 5F : _ */ DEFAULT_MASK,
    /* 60 : ` */ DEFAULT_MASK,
    /* 61 : a */ DEFAULT_MASK | HEX_DIGIT_MASK,
    /* 62 : b */ DEFAULT_MASK | HEX_DIGIT_MASK,
    /* 63 : c */ DEFAULT_MASK | HEX_DIGIT_MASK,
    /* 64 : d */ DEFAULT_MASK | HEX_DIGIT_MASK,
    /* 65 : e */ DEFAULT_MASK | HEX_DIGIT_MASK,
    /* 66 : f */ DEFAULT_MASK | HEX_DIGIT_MASK,
    /* 67 : g */ DEFAULT_MASK,
    /* 68 : h */ DEFAULT_MASK,
    /* 69 : i */ DEFAULT_MASK,
    /* 6A : j */ DEFAULT_MASK,
    /* 6B : k */ DEFAULT_MASK,
    /* 6C : l */ DEFAULT_MASK,
    /* 6D : m */ DEFAULT_MASK,
    /* 6E : n */ DEFAULT_MASK,
    /* 6F : o */ DEFAULT_MASK,
    /* 70 : p */ DEFAULT_MASK,
    /* 71 : q */ DEFAULT_MASK,
    /* 72 : r */ DEFAULT_MASK,
    /* 73 : s */ DEFAULT_MASK,
    /* 74 : t */ DEFAULT_MASK,
    /* 75 : u */ DEFAULT_MASK,
    /* 76 : v */ DEFAULT_MASK,
    /* 77 : w */ DEFAULT_MASK,
    /* 78 : x */ DEFAULT_MASK,
    /* 79 : y */ DEFAULT_MASK,
    /* 7A : z */ DEFAULT_MASK,
    /* 7B : { */ DEFAULT_MASK,
    /* 7C : | */ DEFAULT_MASK,
    /* 7D : } */ DEFAULT_MASK,
    /* 7E : ~ */ DEFAULT_MASK,
    /* 7F :   */ BINARY_MASK,
    /* 80 :   */ BINARY_MASK,
    /* 81 :   */ BINARY_MASK,
    /* 82 :   */ BINARY_MASK,
    /* 83 :   */ BINARY_MASK,
    /* 84 :   */ BINARY_MASK,
    /* 85 :   */ BINARY_MASK,
    /* 86 :   */ BINARY_MASK,
    /* 87 :   */ BINARY_MASK,
    /* 88 :   */ BINARY_MASK,
    /* 89 :   */ BINARY_MASK,
    /* 8A :   */ BINARY_MASK,
    /* 8B :   */ BINARY_MASK,
    /* 8C :   */ BINARY_MASK,
    /* 8D :   */ BINARY_MASK,
    /* 8E :   */ BINARY_MASK,
    /* 8F :   */ BINARY_MASK,
    /* 90 :   */ BINARY_MASK,
    /* 91 :   */ BINARY_MASK,
    /* 92 :   */ BINARY_MASK,
    /* 93 :   */ BINARY_MASK,
    /* 94 :   */ BINARY_MASK,
    /* 95 :   */ BINARY_MASK,
    /* 96 :   */ BINARY_MASK,
    /* 97 :   */ BINARY_MASK,
    /* 98 :   */ BINARY_MASK,
    /* 99 :   */ BINARY_MASK,
    /* 9A :   */ BINARY_MASK,
    /* 9B :   */ BINARY_MASK,
    /* 9C :   */ BINARY_MASK,
    /* 9D :   */ BINARY_MASK,
    /* 9E :   */ BINARY_MASK,
    /* 9F :   */ BINARY_MASK,
    /* A0 :   */ BINARY_MASK,
    /* A1 :   */ BINARY_MASK,
    /* A2 :   */ BINARY_MASK,
    /* A3 :   */ BINARY_MASK,
    /* A4 :   */ BINARY_MASK,
    /* A5 :   */ BINARY_MASK,
    /* A6 :   */ BINARY_MASK,
    /* A7 :   */ BINARY_MASK,
    /* A8 :   */ BINARY_MASK,
    /* A9 :   */ BINARY_MASK,
    /* AA :   */ BINARY_MASK,
    /* AB :   */ BINARY_MASK,
    /* AC :   */ BINARY_MASK,
    /* AD :   */ BINARY_MASK,
    /* AE :   */ BINARY_MASK,
    /* AF :   */ BINARY_MASK,
    /* B0 :   */ BINARY_MASK,
    /* B1 :   */ BINARY_MASK,
    /* B2 :   */ BINARY_MASK,
    /* B3 :   */ BINARY_MASK,
    /* B4 :   */ BINARY_MASK,
    /* B5 :   */ BINARY_MASK,
    /* B6 :   */ BINARY_MASK,
    /* B7 :   */ BINARY_MASK,
    /* B8 :   */ BINARY_MASK,
    /* B9 :   */ BINARY_MASK,
    /* BA :   */ BINARY_MASK,
    /* BB :   */ BINARY_MASK,
    /* BC :   */ BINARY_MASK,
    /* BD :   */ BINARY_MASK,
    /* BE :   */ BINARY_MASK,
    /* BF :   */ BINARY_MASK,
    /* C0 :   */ BINARY_MASK,
    /* C1 :   */ BINARY_MASK,
    /* C2 :   */ BINARY_MASK,
    /* C3 :   */ BINARY_MASK,
    /* C4 :   */ BINARY_MASK,
    /* C5 :   */ BINARY_MASK,
    /* C6 :   */ BINARY_MASK,
    /* C7 :   */ BINARY_MASK,
    /* C8 :   */ BINARY_MASK,
    /* C9 :   */ BINARY_MASK,
    /* CA :   */ BINARY_MASK,
    /* CB :   */ BINARY_MASK,
    /* CC :   */ BINARY_MASK,
    /* CD :   */ BINARY_MASK,
    /* CE :   */ BINARY_MASK,
    /* CF :   */ BINARY_MASK,
    /* D0 :   */ BINARY_MASK,
    /* D1 :   */ BINARY_MASK,
    /* D2 :   */ BINARY_MASK,
    /* D3 :   */ BINARY_MASK,
    /* D4 :   */ BINARY_MASK,
    /* D5 :   */ BINARY_MASK,
    /* D6 :   */ BINARY_MASK,
    /* D7 :   */ BINARY_MASK,
    /* D8 :   */ BINARY_MASK,
    /* D9 :   */ BINARY_MASK,
    /* DA :   */ BINARY_MASK,
    /* DB :   */ BINARY_MASK,
    /* DC :   */ BINARY_MASK,
    /* DD :   */ BINARY_MASK,
    /* DE :   */ BINARY_MASK,
    /* DF :   */ BINARY_MASK,
    /* E0 :   */ BINARY_MASK,
    /* E1 :   */ BINARY_MASK,
    /* E2 :   */ BINARY_MASK,
    /* E3 :   */ BINARY_MASK,
    /* E4 :   */ BINARY_MASK,
    /* E5 :   */ BINARY_MASK,
    /* E6 :   */ BINARY_MASK,
    /* E7 :   */ BINARY_MASK,
    /* E8 :   */ BINARY_MASK,
    /* E9 :   */ BINARY_MASK,
    /* EA :   */ BINARY_MASK,
    /* EB :   */ BINARY_MASK,
    /* EC :   */ BINARY_MASK,
    /* ED :   */ BINARY_MASK,
    /* EE :   */ BINARY_MASK,
    /* EF :   */ BINARY_MASK,
    /* F0 :   */ BINARY_MASK,
    /* F1 :   */ BINARY_MASK,
    /* F2 :   */ BINARY_MASK,
    /* F3 :   */ BINARY_MASK,
    /* F4 :   */ BINARY_MASK,
    /* F5 :   */ BINARY_MASK,
    /* F6 :   */ BINARY_MASK,
    /* F7 :   */ BINARY_MASK,
    /* F8 :   */ BINARY_MASK,
    /* F9 :   */ BINARY_MASK,
    /* FA :   */ BINARY_MASK,
    /* FB :   */ BINARY_MASK,
    /* FC :   */ BINARY_MASK,
    /* FD :   */ BINARY_MASK,
    /* FE :   */ BINARY_MASK,
    /* FF :   */ BINARY_MASK,
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\parsers\ppd\custsize.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    custsize.c

Abstract:

    Parser functions for handling custom page size feature

Environment:

    Windows NT PostScript driver

Revision History:

    03/20/97 -davidx-
        Created it.

--*/

#include "lib.h"
#include "ppd.h"


BOOL
BFixupCustomSizeDataFeedDirection(
    PUIINFO          pUIInfo,
    PPPDDATA         pPpdData,
    PCUSTOMSIZEDATA  pCSData
    )

/*++

Routine Description:

    Validate the requested paper feed direction parameter
    Fix up any inconsistency if necessary

Arguments:

    pPpdData - Points to PPDDATA structure
    pCSData - Specifies custom page size parameters

Return Value:

    TRUE if we can find a feeding direction to fit the custom page size.
    FALSE otherwise.

Note:

    See Figure 3 on page 109 of PPD 4.3 spec for more details.

--*/

#define ORIENTATION_AVAILABLE(iOrient) (dwFlags & (1 << (iOrient)))
#define FIXUP_FEEDDIRECTION(iMainOrient, iAltOrient, wAltFeedDirection) \
        { \
            if (! ORIENTATION_AVAILABLE(iMainOrient)) \
            { \
                pCSData->wFeedDirection = \
                    ORIENTATION_AVAILABLE(iAltOrient) ? \
                        (wAltFeedDirection) : \
                        MAX_FEEDDIRECTION; \
            } \
        }

{
    static const DWORD  adwMasks[4] = { 0x1, 0x3, 0x7, 0xf };
    DWORD   dwFlags;
    BOOL    bXGreaterThanY;
    BOOL    bShortEdgeFirst;
    LONG    lVal;
    WORD    wFeedDirectionSave;

    //
    // Figure out which custom page size orientations are supported
    // dwFlags is DWORD value whose lower-order 4 bits are interpreted as flags:
    //     If orientation N is supported, then bit 1 << N will be set
    //

    dwFlags = 0xf;

    if ((lVal = MINCUSTOMPARAM_ORIENTATION(pPpdData)) > 3)
        dwFlags = 0;
    else if (lVal > 0)
        dwFlags &= ~adwMasks[lVal - 1];

    if ((lVal = MAXCUSTOMPARAM_ORIENTATION(pPpdData)) < 3)
        dwFlags &= adwMasks[lVal];

    wFeedDirectionSave = pCSData->wFeedDirection;
    bXGreaterThanY = (pCSData->dwX > pCSData->dwY);

    //
    // First try to fit within the current feeding direction.
    //

    switch (pCSData->wFeedDirection)
    {
    case SHORTEDGEFIRST:

        if (bXGreaterThanY)
        {
            // orientation 0 (or 2)
            FIXUP_FEEDDIRECTION(0, 2, SHORTEDGEFIRST_FLIPPED);
        }
        else
        {
            // orientation 1 (or 3)
            FIXUP_FEEDDIRECTION(1, 3, SHORTEDGEFIRST_FLIPPED);
        }
        break;

    case SHORTEDGEFIRST_FLIPPED:

        if (bXGreaterThanY)
        {
            // orientation 2 (or 0)
            FIXUP_FEEDDIRECTION(2, 0, SHORTEDGEFIRST);
        }
        else
        {
            // orientation 3 (or 1)
            FIXUP_FEEDDIRECTION(3, 1, SHORTEDGEFIRST);
        }
        break;

    case LONGEDGEFIRST:

        if (bXGreaterThanY)
        {
            // orientation 1 (or 3)
            FIXUP_FEEDDIRECTION(1, 3, LONGEDGEFIRST_FLIPPED);
        }
        else
        {
            // orientation 0 (or 2)
            FIXUP_FEEDDIRECTION(0, 2, LONGEDGEFIRST_FLIPPED);
        }
        break;

    case LONGEDGEFIRST_FLIPPED:

        if (bXGreaterThanY)
        {
            // orientation 3 (or 1)
            FIXUP_FEEDDIRECTION(3, 1, LONGEDGEFIRST);
        }
        else
        {
            // orientation 2 (or 0)
            FIXUP_FEEDDIRECTION(2, 0, LONGEDGEFIRST);
        }
        break;
    }

    //
    // If the paper feed direction is not valid, we'll automatically
    // pick one here (default to long-edge-first if possible). This
    // should always change Long to Short, or Short to Long.
    //

    if (pCSData->wFeedDirection >= MAX_FEEDDIRECTION)
    {
        if (bXGreaterThanY)
        {
            if (ORIENTATION_AVAILABLE(1))
                pCSData->wFeedDirection = LONGEDGEFIRST;
            else if (ORIENTATION_AVAILABLE(3))
                pCSData->wFeedDirection = LONGEDGEFIRST_FLIPPED;
            else if (ORIENTATION_AVAILABLE(0))
                pCSData->wFeedDirection = SHORTEDGEFIRST;
            else // (ORIENTATION_AVAILABLE(2))
                pCSData->wFeedDirection = SHORTEDGEFIRST_FLIPPED;
        }
        else
        {
            if (ORIENTATION_AVAILABLE(0))
                pCSData->wFeedDirection = LONGEDGEFIRST;
            else if (ORIENTATION_AVAILABLE(2))
                pCSData->wFeedDirection = LONGEDGEFIRST_FLIPPED;
            else if (ORIENTATION_AVAILABLE(1))
                pCSData->wFeedDirection = SHORTEDGEFIRST;
            else // (ORIENTATION_AVAILABLE(3))
                pCSData->wFeedDirection = SHORTEDGEFIRST_FLIPPED;
        }
    }

    bShortEdgeFirst =
        (pCSData->wFeedDirection == SHORTEDGEFIRST ||
         pCSData->wFeedDirection == SHORTEDGEFIRST_FLIPPED);

    if ( (!bShortEdgeFirst && !LONGEDGEFIRST_SUPPORTED(pUIInfo, pPpdData)) ||
         (bShortEdgeFirst && !SHORTEDGEFIRST_SUPPORTED(pUIInfo, pPpdData)))
    {
        //
        // The other feeding direction we picked doesn't fit either, so we
        // have to stick with the original feeding direction.
        //

        pCSData->wFeedDirection = wFeedDirectionSave;

        //
        // Check the availability of orientations and flip the feed direction if necessary
        //

        if ((pCSData->wFeedDirection == LONGEDGEFIRST || pCSData->wFeedDirection == SHORTEDGEFIRST) &&
            !(ORIENTATION_AVAILABLE(0) || ORIENTATION_AVAILABLE(1)))
        {
            pCSData->wFeedDirection = (pCSData->wFeedDirection == LONGEDGEFIRST) ?
                LONGEDGEFIRST_FLIPPED : SHORTEDGEFIRST_FLIPPED;
        }
        else if ((pCSData->wFeedDirection == LONGEDGEFIRST_FLIPPED || pCSData->wFeedDirection == SHORTEDGEFIRST_FLIPPED) &&
            !(ORIENTATION_AVAILABLE(2) || ORIENTATION_AVAILABLE(3)))
        {
            pCSData->wFeedDirection = (pCSData->wFeedDirection == LONGEDGEFIRST_FLIPPED) ?
                LONGEDGEFIRST : SHORTEDGEFIRST;
        }

        return FALSE;
    }
    else
        return TRUE;
}



BOOL
BValidateCustomPageSizeData(
    IN PRAWBINARYDATA       pRawData,
    IN OUT PCUSTOMSIZEDATA  pCSData
    )

/*++

Routine Description:

    Validate the specified custom page size parameters, and
    Fix up any inconsistencies found.

Arguments:

    pRawData - Points to raw binary printer description data
    pCSData - Specifies the custom page size parameters to be validate

Return Value:

    TRUE if the custom page size parameters are valid, FALSE otherwise.
    If FALSE is returned, custom page size parameters have been
    fixed up to a consistent state.

--*/

{
    PUIINFO             pUIInfo;
    PPPDDATA            pPpdData;
    PPAGESIZE           pPageSize;
    CUSTOMSIZEDATA      csdata;
    PDWORD              pdwWidth, pdwHeight;
    DWORD               dwTemp;
    BOOL                bShortEdgeFirst, bXGreaterThanY;
    BOOL                bFit;

    pUIInfo = GET_UIINFO_FROM_INFOHEADER((PINFOHEADER) pRawData);
    pPpdData = GET_DRIVER_INFO_FROM_INFOHEADER((PINFOHEADER) pRawData);

    ASSERT(pUIInfo != NULL && pPpdData != NULL);

    if ((pPageSize = PGetCustomPageSizeOption(pUIInfo)) == NULL)
    {
        RIP(("Custom page size not supported\n"));
        return TRUE;
    }

    csdata = *pCSData;

    //
    // Width and height offset parameters are straightforward to verify
    //

    if ((LONG) csdata.dwWidthOffset < MINCUSTOMPARAM_WIDTHOFFSET(pPpdData))
        csdata.dwWidthOffset = MINCUSTOMPARAM_WIDTHOFFSET(pPpdData);
    else if ((LONG) csdata.dwWidthOffset > MAXCUSTOMPARAM_WIDTHOFFSET(pPpdData))
        csdata.dwWidthOffset = MAXCUSTOMPARAM_WIDTHOFFSET(pPpdData);

    if ((LONG) csdata.dwHeightOffset < MINCUSTOMPARAM_HEIGHTOFFSET(pPpdData))
        csdata.dwHeightOffset = MINCUSTOMPARAM_HEIGHTOFFSET(pPpdData);
    else if ((LONG) csdata.dwHeightOffset > MAXCUSTOMPARAM_HEIGHTOFFSET(pPpdData))
        csdata.dwHeightOffset = MAXCUSTOMPARAM_HEIGHTOFFSET(pPpdData);

    //
    // Validate cut-sheet vs. roll-fed selection
    //

    if (csdata.wCutSheet && !(pPpdData->dwCustomSizeFlags & CUSTOMSIZE_CUTSHEET))
        csdata.wCutSheet = FALSE;
    else if (!csdata.wCutSheet && !(pPpdData->dwCustomSizeFlags & CUSTOMSIZE_ROLLFED))
        csdata.wCutSheet = TRUE;

    //
    // Check if the specified paper feed direction can be satisfied
    //

    bFit = BFixupCustomSizeDataFeedDirection(pUIInfo, pPpdData, &csdata);

    //
    // If we haven't been able to fit the custom paper size in
    // correct feeding direction and orientation, then we have
    // to swap width and height here, because they will be opposite
    // of what PPD spec 4.3 page 109 Figure 3 specifies.
    //

    if (!bFit)
    {
        dwTemp = csdata.dwX;
        csdata.dwX = csdata.dwY;
        csdata.dwY = dwTemp;
    }

    //
    // Verify width and height parameters
    //

    bShortEdgeFirst =
        (csdata.wFeedDirection == SHORTEDGEFIRST ||
         csdata.wFeedDirection == SHORTEDGEFIRST_FLIPPED);

    bXGreaterThanY = (csdata.dwX > csdata.dwY);

    if ((bShortEdgeFirst && bXGreaterThanY) ||
        (!bShortEdgeFirst && !bXGreaterThanY))
    {
        // In this case: x <=> height, y <=> width

        pdwHeight = &csdata.dwX;
        pdwWidth = &csdata.dwY;
    }
    else
    {
        // In this case: x <=> width, y <=> height

        pdwWidth = &csdata.dwX;
        pdwHeight = &csdata.dwY;
    }

    if ((LONG) (*pdwWidth + csdata.dwWidthOffset) > pPageSize->szPaperSize.cx)
    {
        *pdwWidth = pPageSize->szPaperSize.cx - csdata.dwWidthOffset;

        if ((LONG) *pdwWidth < MINCUSTOMPARAM_WIDTH(pPpdData))
        {
            *pdwWidth = MINCUSTOMPARAM_WIDTH(pPpdData);
            csdata.dwWidthOffset = pPageSize->szPaperSize.cx - *pdwWidth;
        }
    }
    else if ((LONG) *pdwWidth < MINCUSTOMPARAM_WIDTH(pPpdData))
    {
        *pdwWidth = MINCUSTOMPARAM_WIDTH(pPpdData);
    }

    if ((LONG) (*pdwHeight + csdata.dwHeightOffset) > pPageSize->szPaperSize.cy)
    {
        *pdwHeight = pPageSize->szPaperSize.cy - csdata.dwHeightOffset;

        if ((LONG) *pdwHeight < MINCUSTOMPARAM_HEIGHT(pPpdData))
        {
            *pdwHeight = MINCUSTOMPARAM_HEIGHT(pPpdData);
            csdata.dwHeightOffset = pPageSize->szPaperSize.cy - *pdwHeight;
        }
    }
    else if ((LONG) *pdwHeight < MINCUSTOMPARAM_HEIGHT(pPpdData))
    {
        *pdwHeight = MINCUSTOMPARAM_HEIGHT(pPpdData);
    }

    //
    // Check if anything has changed and
    // return appropriate result value
    //

    if (memcmp(pCSData, &csdata, sizeof(csdata)) == 0)
        return TRUE;

    *pCSData = csdata;
    return FALSE;
}



VOID
VFillDefaultCustomPageSizeData(
    IN PRAWBINARYDATA   pRawData,
    OUT PCUSTOMSIZEDATA pCSData,
    IN BOOL             bMetric
    )

/*++

Routine Description:

    Initialize the custom page size parameters to their default values

Arguments:

    pRawData - Points to raw printer description data
    pCSData - Buffer for storing default custom page size parameters
    bMetric - Whether we're on a metric system

Return Value:

    NONE

--*/

{
    PPPDDATA    pPpdData;

    pPpdData = GET_DRIVER_INFO_FROM_INFOHEADER((PINFOHEADER) pRawData);

    ASSERT(pPpdData != NULL);

    //
    // Default to Letter or A4 depending on whether
    // we're on metric system or not
    //

    if (bMetric)
    {
        pCSData->dwX = 210000;  // 210mm
        pCSData->dwY = 297000; // 297mm
    }
    else
    {
        pCSData->dwX = 215900;  // 8.5"
        pCSData->dwY = 279400; // 11"
    }

    //
    // Get default offsets and feed direction
    //

    pCSData->dwWidthOffset = MINCUSTOMPARAM_WIDTHOFFSET(pPpdData);
    pCSData->dwHeightOffset = MINCUSTOMPARAM_HEIGHTOFFSET(pPpdData);

    pCSData->wFeedDirection =
        (pPpdData->dwCustomSizeFlags & CUSTOMSIZE_SHORTEDGEFEED) ?
            SHORTEDGEFIRST : LONGEDGEFIRST;

    //
    // Make sure the default custom page size parameters are consistent
    //

    (VOID) BValidateCustomPageSizeData(pRawData, pCSData);
}



VOID
VGetCustomSizeParamRange(
    IN PRAWBINARYDATA    pRawData,
    IN PCUSTOMSIZEDATA   pCSData,
    OUT PCUSTOMSIZERANGE pCSRange
    )

/*++

Routine Description:

    Return the valid ranges for custom page size width, height,
    and offset parameters based on their current values

Arguments:

    pRawData - Points to raw printer description data
    pCSData - Specifies the current custom page size parameter values
    pCSRange - Output buffer for returning custom page size parameter ranges
        It should point to an array of 4 CUSTOMSIZERANGE structures:
            0 (CUSTOMPARAM_WIDTH)
            1 (CUSTOMPARAM_HEIGHT)
            2 (CUSTOMPARAM_WIDTHOFFSET)
            3 (CUSTOMPARAM_HEIGHTOFFSET)

Return Value:

    NONE

--*/

{
    PUIINFO             pUIInfo;
    PPPDDATA            pPpdData;
    BOOL                bShortEdgeFirst, bXGreaterThanY;
    PPAGESIZE           pPageSize;
    CUSTOMSIZEDATA      csdata;
    PCUSTOMSIZERANGE    pWidthRange, pHeightRange, pTempRange;
    BOOL                bFit;

    pUIInfo = GET_UIINFO_FROM_INFOHEADER((PINFOHEADER) pRawData);
    pPpdData = GET_DRIVER_INFO_FROM_INFOHEADER((PINFOHEADER) pRawData);

    ASSERT(pUIInfo != NULL && pPpdData != NULL);

    pPageSize = PGetCustomPageSizeOption(pUIInfo);

    ASSERT(pPageSize != NULL);

    //
    // The range for width and height offsets are predictable
    //

    pCSRange[CUSTOMPARAM_WIDTHOFFSET].dwMin = MINCUSTOMPARAM_WIDTHOFFSET(pPpdData);
    pCSRange[CUSTOMPARAM_WIDTHOFFSET].dwMax = MAXCUSTOMPARAM_WIDTHOFFSET(pPpdData);
    pCSRange[CUSTOMPARAM_HEIGHTOFFSET].dwMin = MINCUSTOMPARAM_HEIGHTOFFSET(pPpdData);
    pCSRange[CUSTOMPARAM_HEIGHTOFFSET].dwMax = MAXCUSTOMPARAM_HEIGHTOFFSET(pPpdData);

    //
    // The range for width and height are affected by the selected paper feed direction
    //

    csdata = *pCSData;
    bFit = BFixupCustomSizeDataFeedDirection(pUIInfo, pPpdData, &csdata);

    bShortEdgeFirst =
        (csdata.wFeedDirection == SHORTEDGEFIRST ||
         csdata.wFeedDirection == SHORTEDGEFIRST_FLIPPED);

    bXGreaterThanY = (csdata.dwX > csdata.dwY);

    if ((bShortEdgeFirst && bXGreaterThanY) ||
        (!bShortEdgeFirst && !bXGreaterThanY))
    {
        //
        // Here user's logical x/y and custom page
        // size width/height are swapped
        //

        pWidthRange = pCSRange + CUSTOMPARAM_HEIGHT;
        pHeightRange = pCSRange + CUSTOMPARAM_WIDTH;
    }
    else
    {
        //
        // Here user's logical x/y correspond to
        // custom page size width/height
        //

        pWidthRange = pCSRange + CUSTOMPARAM_WIDTH;
        pHeightRange = pCSRange + CUSTOMPARAM_HEIGHT;
    }

    //
    // If we haven't been able to fit the custom paper size in
    // correct feeding direction and orientation, then we have
    // to swap width and height here, because they will be opposite
    // of what PPD spec 4.3 page 109 Figure 3 specifies.
    //

    if (!bFit)
    {
        pTempRange = pWidthRange;
        pWidthRange = pHeightRange;
        pHeightRange = pTempRange;
    }

    pWidthRange->dwMin = MINCUSTOMPARAM_WIDTH(pPpdData);
    pWidthRange->dwMax = MAXCUSTOMPARAM_WIDTH(pPpdData);
    pHeightRange->dwMin = MINCUSTOMPARAM_HEIGHT(pPpdData);
    pHeightRange->dwMax = MAXCUSTOMPARAM_HEIGHT(pPpdData);

    if (pWidthRange->dwMax > pPageSize->szPaperSize.cx - csdata.dwWidthOffset)
        pWidthRange->dwMax = pPageSize->szPaperSize.cx - csdata.dwWidthOffset;

    if (pHeightRange->dwMax > pPageSize->szPaperSize.cy - csdata.dwHeightOffset)
        pHeightRange->dwMax = pPageSize->szPaperSize.cy - csdata.dwHeightOffset;
}



BOOL
BFormSupportedThruCustomSize(
    PRAWBINARYDATA  pRawData,
    DWORD           dwX,
    DWORD           dwY,
    PWORD           pwFeedDirection
    )

/*++

Routine Description:

    Determine whether a form can be supported through custom page size

Arguments:

    pRawData - Points to raw printer description data
    dwX, dwY - Form width and height (in microns)
    pwFeedDirection - if not NULL, will be set to the selected feed direction

Return Value:

    TRUE if the form can be supported through custom page size
    FALSE if not. In that case, pwFeedDirection will be LONGEDGEFIRST.

--*/
{
    PPPDDATA        pPpdData = GET_DRIVER_INFO_FROM_INFOHEADER((PINFOHEADER) pRawData);
    static WORD     awPrefFeedDir[] = {
                                        LONGEDGEFIRST,
                                        SHORTEDGEFIRST
                                      };
    CUSTOMSIZEDATA  csdata;
    DWORD           i;

    for (i = 0; i < (sizeof(awPrefFeedDir)/sizeof(WORD)); i++)
    {
        csdata.dwX = dwX;
        csdata.dwY = dwY;
        csdata.dwWidthOffset =
        csdata.dwHeightOffset = 0;
        csdata.wCutSheet = TRUE;
        csdata.wFeedDirection = awPrefFeedDir[i];

        (VOID) BValidateCustomPageSizeData(pRawData, &csdata);

        if (dwX == csdata.dwX && dwY == csdata.dwY && csdata.wFeedDirection != MAX_FEEDDIRECTION)
        {
            if (pwFeedDirection != NULL)
                *pwFeedDirection = csdata.wFeedDirection; // might be flipped

            return TRUE;
        }
    }

    if (pwFeedDirection != NULL)
        *pwFeedDirection = LONGEDGEFIRST; // just set a safe default, the return value should be checked !

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\parsers\ppd\ppdentry.c ===
/*++

Copyright (c) 1996-1997  Microsoft Corporation

Module Name:

    ppdentry.c

Abstract:

    Functions for parsing syntactical elements of a PPD file

Environment:

    PostScript driver, PPD parser

Revision History:

    08/20/96 -davidx-
        Common coding style for NT 5.0 drivers.

    03/26/96 -davidx-
        Created it.

--*/

#include "lib.h"
#include "ppd.h"
#include "ppdparse.h"

//
// Forward declaration of local functions
//

PPDERROR IParseKeyword(PPARSERDATA);
PPDERROR IParseValue(PPARSERDATA);
PPDERROR IParseField(PFILEOBJ, PBUFOBJ, BYTE);



PPDERROR
IParseEntry(
    PPARSERDATA pParserData
    )

/*++

Routine Description:

    Parse one entry from a PPD file

Arguments:

    pParserData - Points to parser data structure

Return Value:

    Status code

--*/

{
    PPDERROR    iStatus;
    INT         iChar;
    PFILEOBJ    pFile = pParserData->pFile;

    //
    // Clear values from previous entry
    //

    CLEAR_BUFFER(&pParserData->Keyword);
    CLEAR_BUFFER(&pParserData->Option);
    CLEAR_BUFFER(&pParserData->Xlation);
    CLEAR_BUFFER(&pParserData->Value);

    pParserData->dwValueType = VALUETYPE_NONE;

    //
    // Parse the keyword field and skip over trailing white spaces
    //

    if ((iStatus = IParseKeyword(pParserData)) != PPDERR_NONE)
        return iStatus;

    //
    // Look at the first non-space character after the keyword field
    //

    VSkipSpace(pFile);

    if ((iChar = IGetNextChar(pFile)) == EOF_CHAR)
        return PPDERR_EOF;

    if (IS_NEWLINE(iChar))
        return PPDERR_NONE;

    if (iChar != SEPARATOR_CHAR)
    {
        //
        // Parse the option field and skip over trailing white spaces
        //

        ASSERT(iChar != EOF_CHAR);
        VUngetChar(pFile);

        if ((iStatus = IParseField(pFile, &pParserData->Option, KEYWORD_MASK)) != PPDERR_NONE)
            return iStatus;

        VSkipSpace(pFile);

        //
        // Look at the first non-space character after the option field
        //

        if ((iChar = IGetNextChar(pFile)) == XLATION_CHAR)
        {
            //
            // Parse the translation string field
            //

            if ((iStatus = IParseField(pFile, &pParserData->Xlation, XLATION_MASK)) != PPDERR_NONE)
                return iStatus;

            iChar = IGetNextChar(pFile);
        }
        
        if (iChar != SEPARATOR_CHAR)
            return ISyntaxError(pFile, "Missing ':'");
    }

    //
    // Parse the value field and interpret the entry if it's valid
    //
    
    if ((iStatus = IParseValue(pParserData)) == PPDERR_NONE)
    {
        //
        // Take care of any embedded hexdecimals in the translation string
        //
    
        if (! IS_BUFFER_EMPTY(&pParserData->Xlation) &&
            ! BConvertHexString(&pParserData->Xlation))
        {
            return ISyntaxError(pFile, "Invalid hexdecimals in the translation string");
        }

        //
        // Interpret the current entry
        //

        iStatus = IInterpretEntry(pParserData);
    }

    return iStatus;
}



PPDERROR
IParseKeyword(
    PPARSERDATA pParserData
    )

/*++

Routine Description:

    Parse the keyword field of a PPD file entry

Arguments:

    pParserData - Points to parser data structure

Return Value:

    Status code

--*/

{
    PFILEOBJ    pFile = pParserData->pFile;
    INT         iChar;

    while (TRUE)
    {
        //
        // Get the first character of a line
        //

        if ((iChar = IGetNextChar(pFile)) == EOF_CHAR)
            return PPDERR_EOF;

        //
        // Ignore empty lines
        //

        if (IS_NEWLINE(iChar))
            continue;

        if (IS_SPACE(iChar))
        {
            VSkipSpace(pFile);
            
            if ((iChar = IGetNextChar(pFile)) == EOF_CHAR)
                return PPDERR_EOF;

            if (IS_NEWLINE(iChar))
                continue;

            return ISyntaxError(pFile, "Missing '*'");
        }

        //
        // If the line is not empty, the first character must be the keyword character
        //

        if (! IS_KEYWORD_CHAR(iChar))
            return ISyntaxError(pFile, "Missing '*'");
        
        //
        // If the second character is not %, then the line is a normal entry.
        // Otherwise, the line is a comment.
        //

        if ((iChar = IGetNextChar(pFile)) == EOF_CHAR)
            return PPDERR_EOF;

        if (!IS_NEWLINE(iChar) && iChar != COMMENT_CHAR)
        {
            VUngetChar(pFile);
            break;
        }

        VSkipLine(pFile);
    }

    return IParseField(pFile, &pParserData->Keyword, KEYWORD_MASK);
}



PPDERROR
IParseValue(
    PPARSERDATA pParserData
    )

/*++

Routine Description:

    Parse the value field of a PPD file entry

Arguments:

    pParserData - Points to parser data structure
    
Return Value:

    Status code

--*/

{
    PPDERROR    iStatus;
    INT         iChar;
    PBUFOBJ     pBufObj = &pParserData->Value;
    PFILEOBJ    pFile = pParserData->pFile;

    //
    // The value is either a StringValue, a SymbolValue, or a QuotedValue
    // depending on the first non-space character
    //

    VSkipSpace(pFile);

    if ((iChar = IGetNextChar(pFile)) == EOF_CHAR)
        return PPDERR_EOF;

    if (iChar == QUOTE_CHAR)
    {
        //
        // The value is a quoted string
        //

        pParserData->dwValueType = VALUETYPE_QUOTED;
        
        if ((iStatus = IParseField(pFile, pBufObj, QUOTED_MASK)) != PPDERR_NONE)
            return iStatus;

        //
        // Read the closing quote character
        //

        if ((iChar = IGetNextChar(pFile)) != QUOTE_CHAR)
            return ISyntaxError(pFile, "Unbalanced '\"'");
    }
    else if (iChar == SYMBOL_CHAR)
    {
        //
        // The value is a symbol reference
        //

        pParserData->dwValueType = VALUETYPE_SYMBOL;
        ADD_CHAR_TO_BUFFER(pBufObj, iChar);

        if ((iStatus = IParseField(pFile, pBufObj, KEYWORD_MASK)) != PPDERR_NONE)
            return iStatus;
    }
    else
    {
        PBYTE   pubEnd;

        //
        // The value is a string
        //

        pParserData->dwValueType = VALUETYPE_STRING;
        VUngetChar(pFile);

        if ((iStatus = IParseField(pFile, pBufObj, STRING_MASK)) != PPDERR_NONE)
            return iStatus;

        //
        // Ignore any trailing spaces
        //

        ASSERT(pBufObj->dwSize > 0);
        pubEnd = pBufObj->pbuf + (pBufObj->dwSize - 1);

        while (IS_SPACE(*pubEnd))
            *pubEnd-- = NUL;

        pBufObj->dwSize= (DWORD)(pubEnd - pBufObj->pbuf) + 1;
        ASSERT(pBufObj->dwSize > 0);
    }

    //
    // Ignore extra characters after the entry value
    //

    VSkipSpace(pFile);
    iChar = IGetNextChar(pFile);

    if (! IS_NEWLINE(iChar))
    {
        if (iChar != XLATION_CHAR)
        {
            TERSE(("%ws: Extra chars at the end of line %d\n",
                   pFile->ptstrFileName,
                   pFile->iLineNumber));
        }

        VSkipLine(pFile);
    }

    return PPDERR_NONE;
}



PPDERROR
IParseField(
    PFILEOBJ    pFile,
    PBUFOBJ     pBufObj,
    BYTE        ubMask
    )

/*++

Routine Description:

    Parse one field of a PPD file entry

Arguments:

    pFile - Specifies the input file object
    pBufObj - Specifies the buffer for storing the field value
    ubMask - Mask to limit the set of allowable characters

Return Value:

    Status code

--*/

{
    PPDERROR    iStatus;
    INT         iChar;

    while ((iChar = IGetNextChar(pFile)) != EOF_CHAR)
    {
        if (! IS_MASKED_CHAR(iChar, ubMask))
        {
            //
            // Encountered a not-allowed character
            //

            if (IS_BUFFER_EMPTY(pBufObj) && !(ubMask & QUOTED_MASK))
                return ISyntaxError(pFile, "Empty field");

            //
            // Always put a null byte at the end
            //

            pBufObj->pbuf[pBufObj->dwSize] = 0;

            VUngetChar(pFile);
            return PPDERR_NONE;
        }
        else
        {
            //
            // If we're parsing a quoted string and we encountered a line
            // starting with the keyword character, then we'll assume 
            // the closing quote is missing. Just give a warning and continue.
            //

            if ((ubMask & QUOTED_MASK) &&
                IS_KEYWORD_CHAR(iChar) &&
                !IS_BUFFER_EMPTY(pBufObj) &&
                IS_NEWLINE(pBufObj->pbuf[pBufObj->dwSize - 1]))
            {
                (VOID) ISyntaxError(pFile, "Expecting '\"'");
            }

            //
            // Grow the buffer if it's full. If we're not allowed to
            // grow it, then return a syntax error.
            //

            if (IS_BUFFER_FULL(pBufObj))
            {
                if (ubMask & (STRING_MASK|QUOTED_MASK))
                {
                    if ((iStatus = IGrowValueBuffer(pBufObj)) != PPDERR_NONE)
                        return iStatus;
                }
                else
                {
                    return ISyntaxError(pFile, "Field too long");
                }
            }

            ADD_CHAR_TO_BUFFER(pBufObj, iChar);
        }
    }

    return PPDERR_EOF;
}



BOOL
BConvertHexString(
    PBUFOBJ pBufObj
    )

/*++

Routine Description:

    Convert embedded hexdecimal strings into binary data

Arguments:

    pBufObj - Specifies the buffer object to be converted

Return Value:

    TRUE if everything is ok
    FALSE if the embedded hexdecimal string is ill-formed

--*/

#define HexDigitValue(c) \
        (((c) >= '0' && (c) <= '9') ? ((c) - '0') : \
         ((c) >= 'A' && (c) <= 'F') ? ((c) - 'A' + 10) : ((c) - 'a' + 10))

{
    PBYTE   pubSrc, pubDest;
    DWORD   dwSize;
    DWORD   dwHexMode = 0;

    pubSrc = pubDest = pBufObj->pbuf;
    dwSize = pBufObj->dwSize;

    while (dwSize--)
    {
        if (dwHexMode)
        {
            //
            // We're currently inside a hex string:
            //  switch to normal mode if '>' is encountered
            //  otherwise, only valid hex digits, newline, and spaces are allowed
            //

            if (IS_HEX_DIGIT(*pubSrc))
            {
                //
                // If we're currently on odd hex digit, save the hex digit value
                // in the upper nibble of the destination byte.
                // If we're on even hex digit, save the hex digit value in the
                // lower nibble of the destination byte. If the destination byte
                // is zero and NUL is not allowed, then return with error.
                //

                if (dwHexMode & 1)
                    *pubDest = HexDigitValue(*pubSrc) << 4;
                else
                    *pubDest++ |= HexDigitValue(*pubSrc);

                dwHexMode++;
            }
            else if (*pubSrc == '>')
            {
                if ((dwHexMode & 1) == 0)
                {
                    TERSE(("Odd number of hexdecimal digits\n"));
                    return FALSE;
                }

                dwHexMode = 0;
            }
            else if (!IS_SPACE(*pubSrc) && !IS_NEWLINE(*pubSrc))
            {
                TERSE(("Invalid hexdecimal digit\n"));
                return FALSE;
            }
        }
        else
        {
            //
            // We're not currently inside a hex string:
            //  switch to hex mode if '<' is encountered
            //  otherwise, simply copy the source byte to the destination
            //

            if (*pubSrc == '<')
                dwHexMode = 1;
            else
                *pubDest++ = *pubSrc;
        }

        pubSrc++;
    }

    if (dwHexMode)
    {
        TERSE(("Missing '>' in hexdecimal string\n"));
        return FALSE;
    }

    //
    // Modified the buffer size if it's changed
    //

    *pubDest = 0;
    pBufObj->dwSize = (DWORD)(pubDest - pBufObj->pbuf);
    return TRUE;
}



PPDERROR
ISyntaxErrorMessage(
    PFILEOBJ    pFile,
    PSTR        pstrMsg
    )

/*++

Routine Description:

    Display syntax error message

Arguments:

    pFile - Specifies the input file object
    pstrMsg - Indicate the reason for the syntax error

Return Value:

    PPDERR_SYNTAX

--*/

{
    //
    // Display an error message
    //

    TERSE(("%ws: %s on line %d\n", pFile->ptstrFileName, pstrMsg, pFile->iLineNumber));

    //
    // Skip any remaining characters on the current line
    //

    VSkipLine(pFile);

    return PPDERR_SYNTAX;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\parsers\ppd\ppd.c ===
/*++

Copyright (c) 1996-1997  Microsoft Corporation

Module Name:

    ppd.c

Abstract:

    Public interface to the PPD parser

Environment:

    Windows NT PostScript driver

Revision History:

    10/14/96 -davidx-
        Add new interface function MapToDeviceOptIndex.

    09/30/96 -davidx-
        Cleaner handling of ManualFeed and AutoSelect feature.

    09/24/96 -davidx-
        Implement ResolveUIConflicts.

    09/23/96 -davidx-
        Implement ChangeOptionsViaID.

    08/30/96 -davidx-
        Changes after the 1st code review.

    08/19/96 -davidx-
        Implemented most of the interface functions except:
            ChangeOptionsViaID
            ResolveUIConflicts

    08/16/96 -davidx-
        Created it.

--*/

#include "lib.h"
#include "ppd.h"

#ifndef KERNEL_MODE

#ifndef WINNT_40

#include "appcompat.h"

#else  // WINNT_40

#endif // !WINNT_40

#endif // !KERNEL_MODE

//
// Forward declaration of local static functions
//

BOOL BCheckFeatureConflict(PUIINFO, POPTSELECT, DWORD, PDWORD, DWORD, DWORD);
BOOL BCheckFeatureOptionConflict(PUIINFO, DWORD, DWORD, DWORD, DWORD);
BOOL BSearchConstraintList(PUIINFO, DWORD, DWORD, DWORD);
DWORD DwReplaceFeatureOption(PUIINFO, POPTSELECT, DWORD, DWORD, DWORD);
DWORD DwInternalMapToOptIndex(PUIINFO, PFEATURE, LONG, LONG, PDWORD);


//
// DeleteRawBinaryData only called from driverui
//
#ifndef KERNEL_MODE

void
DeleteRawBinaryData(
    IN PTSTR    ptstrPpdFilename
    )

/*++

Routine Description:

    Delete raw binary printer description data.

Arguments:

    ptstrDataFilename - Specifies the name of the original printer description file

Return Value:

    none

--*/

{
    PTSTR           ptstrBpdFilename;

    // only for test purposes. Upgrades are hard to debug...
    ERR(("Deleting .bpd file\n"));

    //
    // Sanity check
    //

    if (ptstrPpdFilename == NULL)
    {
        RIP(("PPD filename is NULL.\n"));
        return;
    }

    //
    // Generate BPD filename from the specified PPD filename
    //

    if (! (ptstrBpdFilename = GenerateBpdFilename(ptstrPpdFilename)))
        return;

    if (!DeleteFile(ptstrBpdFilename))
        ERR(("DeleteRawBinaryData failed: %d\n", GetLastError()));

    MemFree(ptstrBpdFilename);
}
#endif


PRAWBINARYDATA
LoadRawBinaryData(
    IN PTSTR    ptstrDataFilename
    )

/*++

Routine Description:

    Load raw binary printer description data.

Arguments:

    ptstrDataFilename - Specifies the name of the original printer description file

Return Value:

    Pointer to raw binary printer description data
    NULL if there is an error

--*/

{
    PRAWBINARYDATA  pRawData;

    //
    // Sanity check
    //

    if (ptstrDataFilename == NULL)
    {
        RIP(("PPD filename is NULL.\n"));
        return NULL;
    }

    //
    // Attempt to load cached binary printer description data first
    //

    if ((pRawData = PpdLoadCachedBinaryData(ptstrDataFilename)) == NULL)
    {
        #if !defined(KERNEL_MODE) || defined(USERMODE_DRIVER)

        //
        // If there is no cached binary data or it's out-of-date, we'll parse
        // the ASCII text file and cache the resulting binary data.
        //

        pRawData = PpdParseTextFile(ptstrDataFilename);

        #endif
    }

    //
    // Initialize various pointer fields inside the printer description data
    //

    if (pRawData)
    {
        PINFOHEADER pInfoHdr;
        PUIINFO     pUIInfo;
        PPPDDATA    pPpdData;

        pInfoHdr = (PINFOHEADER) pRawData;
        pUIInfo = GET_UIINFO_FROM_INFOHEADER(pInfoHdr);
        pPpdData = GET_DRIVER_INFO_FROM_INFOHEADER(pInfoHdr);

        ASSERT(pUIInfo != NULL && pUIInfo->dwSize == sizeof(UIINFO));
        ASSERT(pPpdData != NULL && pPpdData->dwSizeOfStruct == sizeof(PPDDATA));

        pRawData->pvReserved = NULL;
        pRawData->pvPrivateData = pRawData;

        pUIInfo->pubResourceData = (PBYTE) pInfoHdr;
        pUIInfo->pInfoHeader = pInfoHdr;

        #ifndef KERNEL_MODE

            #ifndef WINNT_40  // Win2K user mode driver

            if (GetAppCompatFlags2(VER40) & GACF2_NOCUSTOMPAPERSIZES)
            {
                pUIInfo->dwFlags &= ~FLAG_CUSTOMSIZE_SUPPORT;
            }

            #else  // WINNT_40

            /* NT4 solution here */

            #endif // !WINNT_40

        #endif  // !KERNEL_MODE
    }

    if (pRawData == NULL)
        ERR(("LoadRawBinaryData failed: %d\n", GetLastError()));

    return pRawData;
}



VOID
UnloadRawBinaryData(
    IN PRAWBINARYDATA   pRawData
    )

/*++

Routine Description:

    Unload raw binary printer description data previously loaded using LoadRawBinaryData

Arguments:

    pRawData - Points to raw binary printer description data

Return Value:

    NONE

--*/

{
    ASSERT(pRawData != NULL);
    MemFree(pRawData);
}



PINFOHEADER
InitBinaryData(
    IN PRAWBINARYDATA   pRawData,
    IN PINFOHEADER      pInfoHdr,
    IN POPTSELECT       pOptions
    )

/*++

Routine Description:

    Initialize and return an instance of binary printer description data

Arguments:

    pRawData - Points to raw binary printer description data
    pInfoHdr - Points to an existing of binary data instance
    pOptions - Specifies the options used to initialize the binary data instance

Return Value:

    Pointer to an initialized binary data instance

Note:

    If pInfoHdr parameter is NULL, the parser returns a new binary data instance
    which should be freed by calling FreeBinaryData. If pInfoHdr parameter is not
    NULL, the existing binary data instance is reinitialized.

    If pOption parameter is NULL, the parser should use the default option values
    for generating the binary data instance. The parser may have special case
    optimization to handle this case.

--*/

{
    //
    // For PPD parser, all instances of the binary printer description
    // are the same as the original raw binary data.
    //

    ASSERT(pRawData != NULL && pRawData == pRawData->pvPrivateData);
    ASSERT(pInfoHdr == NULL || pInfoHdr == (PINFOHEADER) pRawData);

    return (PINFOHEADER) pRawData;
}



VOID
FreeBinaryData(
    IN PINFOHEADER pInfoHdr
    )

/*++

Routine Description:

    Free an instance of the binary printer description data

Arguments:

    pInfoHdr - Points to a binary data instance previously returned from an
        InitBinaryData(pRawData, NULL, pOptions) call

Return Value:

    NONE

--*/

{
    //
    // For PPD parser, there is nothing to be done here.
    //

    ASSERT(pInfoHdr != NULL);
}



PINFOHEADER
UpdateBinaryData(
    IN PRAWBINARYDATA   pRawData,
    IN PINFOHEADER      pInfoHdr,
    IN POPTSELECT       pOptions
    )

/*++

Routine Description:

    Update an instance of binary printer description data

Arguments:

    pRawData - Points to raw binary printer description data
    pInfoHdr - Points to an existing of binary data instance
    pOptions - Specifies the options used to update the binary data instance

Return Value:

    Pointer to the updated binary data instance
    NULL if there is an error

--*/

{
    //
    // For PPD parser, there is nothing to be done here.
    //

    ASSERT(pRawData != NULL && pRawData == pRawData->pvPrivateData);
    ASSERT(pInfoHdr == NULL || pInfoHdr == (PINFOHEADER) pRawData);

    return pInfoHdr;
}



BOOL
InitDefaultOptions(
    IN PRAWBINARYDATA   pRawData,
    OUT POPTSELECT      pOptions,
    IN INT              iMaxOptions,
    IN INT              iMode
    )

/*++

Routine Description:

    Initialize the option array with default settings from the printer description file

Arguments:

    pRawData - Points to raw binary printer description data
    pOptions - Points to an array of OPTSELECT structures for storing the default settings
    iMaxOptions - Max number of entries in pOptions array
    iMode - Specifies what the caller is interested in:
        MODE_DOCUMENT_STICKY
        MODE_PRINTER_STICKY
        MODE_DOCANDPRINTER_STICKY

Return Value:

    FALSE if the input option array is not large enough to hold
    all default option values, TRUE otherwise.

--*/

{
    INT         iStart, iOptions, iIndex;
    PINFOHEADER pInfoHdr;
    PUIINFO     pUIInfo;
    PFEATURE    pFeature;
    POPTSELECT  pTempOptions;
    BOOL        bResult = TRUE;

    ASSERT(pOptions != NULL);

    //
    // Get pointers to various data structures
    //

    PPD_GET_UIINFO_FROM_RAWDATA(pRawData, pInfoHdr, pUIInfo);

    ASSERT(pUIInfo != NULL);

    iOptions = pRawData->dwDocumentFeatures + pRawData->dwPrinterFeatures;
    ASSERT(iOptions <= MAX_PRINTER_OPTIONS);

    if ((pTempOptions = MemAllocZ(MAX_PRINTER_OPTIONS*sizeof(OPTSELECT))) == NULL)
    {
        ERR(("Memory allocation failed\n"));

        ZeroMemory(pOptions, iMaxOptions*sizeof(OPTSELECT));
        return FALSE;
    }

    //
    // Construct the default option array
    //

    ASSERT(NULL_OPTSELECT == 0);

    for (iIndex = 0; iIndex < iOptions; iIndex++)
    {
        pFeature = PGetIndexedFeature(pUIInfo, iIndex);

        ASSERT(pFeature != NULL);

        pTempOptions[iIndex].ubCurOptIndex = (BYTE)
            ((pFeature->dwFlags & FEATURE_FLAG_NOUI) ?
                OPTION_INDEX_ANY :
                pFeature->dwDefaultOptIndex);
    }

    //
    // Resolve any conflicts between default option selections
    //

    ResolveUIConflicts(pRawData, pTempOptions, MAX_PRINTER_OPTIONS, iMode);

    //
    // Determine if the caller is interested in doc- and/or printer-sticky options
    //

    switch (iMode)
    {
    case MODE_DOCUMENT_STICKY:

        iStart = 0;
        iOptions = pRawData->dwDocumentFeatures;
        break;

    case MODE_PRINTER_STICKY:

        iStart = pRawData->dwDocumentFeatures;
        iOptions = pRawData->dwPrinterFeatures;
        break;

    default:

        ASSERT(iMode == MODE_DOCANDPRINTER_STICKY);
        iStart = 0;
        break;
    }

    //
    // Make sure the input option array is large enough
    //

    if (iOptions > iMaxOptions)
    {
        RIP(("Option array too small: %d < %d\n", iMaxOptions, iOptions));
        iOptions = iMaxOptions;
        bResult = FALSE;
    }

    //
    // Copy the default option array
    //

    CopyMemory(pOptions, pTempOptions+iStart, iOptions*sizeof(OPTSELECT));

    MemFree(pTempOptions);
    return bResult;
}



VOID
ValidateDocOptions(
    IN PRAWBINARYDATA   pRawData,
    IN OUT POPTSELECT   pOptions,
    IN INT              iMaxOptions
    )

/*++

Routine Description:

    Validate the devmode option array and correct any invalid option selections

Arguments:

    pRawData - Points to raw binary printer description data
    pOptions - Points to an array of OPTSELECT structures that need validation
    iMaxOptions - Max number of entries in pOptions array

Return Value:

    None

--*/

{
    INT         cFeatures, iIndex;
    PINFOHEADER pInfoHdr;
    PUIINFO     pUIInfo;

    ASSERT(pOptions != NULL);

    //
    // Get pointers to various data structures
    //

    PPD_GET_UIINFO_FROM_RAWDATA(pRawData, pInfoHdr, pUIInfo);
    ASSERT(pUIInfo != NULL);

    cFeatures = pRawData->dwDocumentFeatures;
    ASSERT(cFeatures <= MAX_PRINTER_OPTIONS);

    if (cFeatures > iMaxOptions)
    {
        RIP(("Option array too small: %d < %d\n", iMaxOptions, cFeatures));
        cFeatures = iMaxOptions;
    }

    //
    // loop through doc-sticky features to validate each option selection(s)
    //

    for (iIndex = 0; iIndex < cFeatures; iIndex++)
    {
        PFEATURE pFeature;
        INT      cAllOptions, cSelectedOptions, iNext;
        BOOL     bValid;

        if ((pOptions[iIndex].ubCurOptIndex == OPTION_INDEX_ANY) &&
            (pOptions[iIndex].ubNext == NULL_OPTSELECT))
        {
            //
            // We use OPTION_INDEX_ANY intentionally, so don't change it.
            //

            continue;
        }

        pFeature = PGetIndexedFeature(pUIInfo, iIndex);
        ASSERT(pFeature != NULL);

        //
        // number of available options
        //

        cAllOptions = pFeature->Options.dwCount;

        //
        // number of selected options
        //

        cSelectedOptions = 0;

        iNext = iIndex;

        bValid = TRUE;

        do
        {
            cSelectedOptions++;

            if ((iNext >= iMaxOptions) ||
                (pOptions[iNext].ubCurOptIndex >= cAllOptions) ||
                (cSelectedOptions > cAllOptions))
            {
                //
                // either the option index is out of range,
                // or the current option selection is invalid,
                // or the number of selected options (for PICKMANY)
                // exceeds available options
                //

                bValid = FALSE;
                break;
            }

            iNext = pOptions[iNext].ubNext;

        } while (iNext != NULL_OPTSELECT);

        if (!bValid)
        {
            ERR(("Corrected invalid option array value for feature %d\n", iIndex));

            pOptions[iIndex].ubCurOptIndex = (BYTE)
                ((pFeature->dwFlags & FEATURE_FLAG_NOUI) ?
                    OPTION_INDEX_ANY :
                    pFeature->dwDefaultOptIndex);

            pOptions[iIndex].ubNext = NULL_OPTSELECT;
        }
    }
}



BOOL
CheckFeatureOptionConflict(
    IN PRAWBINARYDATA   pRawData,
    IN DWORD            dwFeature1,
    IN DWORD            dwOption1,
    IN DWORD            dwFeature2,
    IN DWORD            dwOption2
    )

/*++

Routine Description:

    Check if (dwFeature1, dwOption1) constrains (dwFeature2, dwOption2)

Arguments:

    pRawData - Points to raw binary printer description data
    dwFeature1, dwOption1 - Feature and option indices of the first feature/option pair
    dwFeature2, dwOption2 - Feature and option indices of the second feature/option pair

Return Value:

    TRUE if (dwFeature1, dwOption1) constrains (dwFeature2, dwOption2)
    FALSE otherwise

--*/

{
    PINFOHEADER pInfoHdr;
    PUIINFO     pUIInfo;

    PPD_GET_UIINFO_FROM_RAWDATA(pRawData, pInfoHdr, pUIInfo);

    ASSERT(pUIInfo != NULL);

    return BCheckFeatureOptionConflict(pUIInfo, dwFeature1, dwOption1, dwFeature2, dwOption2);
}



BOOL
ResolveUIConflicts(
    IN PRAWBINARYDATA   pRawData,
    IN OUT POPTSELECT   pOptions,
    IN INT              iMaxOptions,
    IN INT              iMode
    )

/*++

Routine Description:

    Resolve any conflicts between printer feature option selections

Arguments:

    pRawData - Points to raw binary printer description data
    pOptions - Points to an array of OPTSELECT structures for storing the modified options
    iMaxOptions - Max number of entries in pOptions array
    iMode - Specifies how the conflicts should be resolved:
        MODE_DOCUMENT_STICKY - only resolve conflicts between doc-sticky features
        MODE_PRINTER_STICKY - only resolve conflicts between printer-sticky features
        MODE_DOCANDPRINTER_STICKY - resolve conflicts all features

Return Value:

    TRUE if there is no conflicts between printer feature option selection
    FALSE otherwise

--*/

{
    PINFOHEADER pInfoHdr;
    PUIINFO     pUIInfo;
    PFEATURE    pFeatures;
    PDWORD      pdwFlags;
    POPTSELECT  pTempOptions;
    DWORD       dwStart, dwOptions, dwIndex, dwTotalFeatureCount;
    BOOL        bReturnValue = TRUE;
    BOOL        bCheckConflictOnly;

    struct _PRIORITY_INFO {

        DWORD   dwFeatureIndex;
        DWORD   dwPriority;

    } *pPriorityInfo;

    ASSERT(pOptions);

    //
    // Initialize pointers to various data structures
    //

    PPD_GET_UIINFO_FROM_RAWDATA(pRawData, pInfoHdr, pUIInfo);

    ASSERT(pUIInfo != NULL);

    pFeatures = OFFSET_TO_POINTER(pInfoHdr, pUIInfo->loFeatureList);
    dwTotalFeatureCount = pRawData->dwDocumentFeatures + pRawData->dwPrinterFeatures;

    if (iMaxOptions < (INT) dwTotalFeatureCount)
    {
        ERR(("Option array for ResolveUIConflicts is too small.\n"));
        return bReturnValue;
    }

    //
    // Determine if the caller is interested in doc- and/or printer-sticky options
    //

    bCheckConflictOnly = ((iMode & DONT_RESOLVE_CONFLICT) != 0);
    iMode &= ~DONT_RESOLVE_CONFLICT;

    switch (iMode)
    {
    case MODE_DOCUMENT_STICKY:

        dwStart = 0;
        dwOptions = pRawData->dwDocumentFeatures;
        break;

    case MODE_PRINTER_STICKY:

        dwStart = pRawData->dwDocumentFeatures;
        dwOptions = pRawData->dwPrinterFeatures;
        break;

    default:

        ASSERT(iMode == MODE_DOCANDPRINTER_STICKY);
        dwStart = 0;
        dwOptions = dwTotalFeatureCount;
        break;
    }

    if (dwOptions == 0)
        return TRUE;

    //
    // This problem is not completely solvable in the worst case.
    // But the approach below should work if the PPD is well-formed.
    //
    //  for each feature starting from the highest priority one
    //  and down to the lowest priority one do:
    //    for each selected option of the feature do:
    //      if the option is not constrained, continue
    //      else do one of the following:
    //        if the conflict feature has lower priority, continue
    //        else resolve the current feature/option pair:
    //          if UIType is PickMany, deselect the current option
    //          else try to change the option to:
    //            Default option
    //            each option of the feature in sequence
    //            OPTION_INDEX_ANY as the last resort
    //

    pPriorityInfo = MemAlloc(dwOptions * sizeof(struct _PRIORITY_INFO));
    pTempOptions = MemAlloc(iMaxOptions * sizeof(OPTSELECT));
    pdwFlags = MemAllocZ(dwOptions * sizeof(DWORD));

    if (pPriorityInfo && pTempOptions && pdwFlags)
    {
        //
        // Copy the options array into a temporary working buffer
        //

        CopyMemory(pTempOptions, pOptions, sizeof(OPTSELECT) * iMaxOptions);

        //
        // Sort the feature indices according to their priority
        //

        for (dwIndex = 0; dwIndex < dwOptions; dwIndex++)
        {
            pPriorityInfo[dwIndex].dwFeatureIndex = dwIndex + dwStart;
            pPriorityInfo[dwIndex].dwPriority = pFeatures[dwIndex + dwStart].dwPriority;
        }

        for (dwIndex = 0; dwIndex < dwOptions; dwIndex++)
        {
            struct _PRIORITY_INFO tempPriorityInfo;
            DWORD dwLoop, dwMax = dwIndex;

            for (dwLoop = dwIndex + 1; dwLoop < dwOptions; dwLoop++)
            {
                if (pPriorityInfo[dwLoop].dwPriority > pPriorityInfo[dwMax].dwPriority)
                    dwMax = dwLoop;
            }

            if (dwMax != dwIndex)
            {
                tempPriorityInfo = pPriorityInfo[dwMax];
                pPriorityInfo[dwMax] = pPriorityInfo[dwIndex];
                pPriorityInfo[dwIndex] = tempPriorityInfo;
            }
        }

        //
        // Loop through every feature, starting from the highest
        // priority one down to the lowest priority one.
        //

        for (dwIndex = 0; dwIndex < dwOptions; )
        {
            DWORD   dwCurFeature, dwCurOption, dwCurNext;
            BOOL    bConflict = FALSE;

            //
            // Loop through every selected option of the current feature
            //

            dwCurNext = dwCurFeature = pPriorityInfo[dwIndex].dwFeatureIndex;

            do
            {
                DWORD   dwFeature, dwOption, dwNext;

                dwCurOption = pTempOptions[dwCurNext].ubCurOptIndex;
                dwCurNext = pTempOptions[dwCurNext].ubNext;

                //
                // Check if the current feature/option pair is constrained
                //

                for (dwFeature = dwStart; dwFeature < dwStart + dwOptions; dwFeature++)
                {
                    dwNext = dwFeature;

                    do
                    {
                        dwOption = pTempOptions[dwNext].ubCurOptIndex;
                        dwNext = pTempOptions[dwNext].ubNext;

                        if (BCheckFeatureOptionConflict(pUIInfo,
                                                        dwFeature,
                                                        dwOption,
                                                        dwCurFeature,
                                                        dwCurOption))
                        {
                            bConflict = TRUE;
                            break;
                        }
                    }
                    while (dwNext != NULL_OPTSELECT);

                    //
                    // Check if a conflict was detected
                    //

                    if (bConflict)
                    {
                        VERBOSE(("Conflicting option selections: (%d, %d) - (%d, %d)\n",
                                 dwFeature, dwOption,
                                 dwCurFeature, dwCurOption));

                        if (pdwFlags[dwFeature - dwStart] & 0x10000)
                        {
                            //
                            // The conflicting feature has higher priority than
                            // the current feature. Change the selected option
                            // of the current feature.
                            //

                            pdwFlags[dwCurFeature - dwStart] =
                                DwReplaceFeatureOption(pUIInfo,
                                                       pTempOptions,
                                                       dwCurFeature,
                                                       dwCurOption,
                                                       pdwFlags[dwCurFeature - dwStart]);
                        }
                        else
                        {
                            //
                            // The conflicting feature has lower priority than
                            // the current feature. Change the selected option
                            // of the conflicting feature.
                            //

                            pdwFlags[dwFeature - dwStart] =
                                DwReplaceFeatureOption(pUIInfo,
                                                       pTempOptions,
                                                       dwFeature,
                                                       dwOption,
                                                       pdwFlags[dwFeature - dwStart]);
                        }

                        break;
                    }
                }
            }
            while ((dwCurNext != NULL_OPTSELECT) && !bConflict);

            //
            // If no conflict is found for the selected options of
            // the current feature, then move on to the next feature.
            // Otherwise, repeat the loop on the current feature.
            //

            if (! bConflict)
            {
                //
                // Make the current feature as visited
                //

                pdwFlags[dwCurFeature - dwStart] |= 0x10000;

                dwIndex++;
            }
            else
            {
                //
                // If a conflict is found, set the return value to false
                //

                bReturnValue = FALSE;
            }
        }

        //
        // Copy the resolved options array from the temporary working
        // buffer back to the input options array. This results in
        // all option selections being compacted at the beginning
        // of the array.
        //

        if (! bCheckConflictOnly)
        {
            INT iNext = (INT) dwTotalFeatureCount;

            for (dwIndex = 0; dwIndex < dwTotalFeatureCount; dwIndex ++)
            {
                VCopyOptionSelections(pOptions,
                                      dwIndex,
                                      pTempOptions,
                                      dwIndex,
                                      &iNext,
                                      iMaxOptions);
            }
        }
    }
    else
    {
        //
        // If we couldn't allocate temporary working buffer,
        // then return to the caller without doing anything.
        //

        ERR(("Memory allocation failed.\n"));
    }

    MemFree(pTempOptions);
    MemFree(pdwFlags);
    MemFree(pPriorityInfo);

    return bReturnValue;
}



BOOL
EnumEnabledOptions(
    IN PRAWBINARYDATA   pRawData,
    IN POPTSELECT       pOptions,
    IN DWORD            dwFeatureIndex,
    OUT PBOOL           pbEnabledOptions,
    IN INT              iMode
    )

/*++

Routine Description:

    Determine which options of the specified feature should be enabled
    based on the current option selections of printer features

Arguments:

    pRawData - Points to raw binary printer description data
    pOptions - Points to the current feature option selections
    dwFeatureIndex - Specifies the index of the feature in question
    pbEnabledOptions - An array of BOOLs, each entry corresponds to an option
        of the specified feature. On exit, if the entry is TRUE, the corresponding
        option is enabled. Otherwise, the corresponding option should be disabled.
    iMode - Specifies what the caller is interested in:
         MODE_DOCUMENT_STICKY
         MODE_PRINTER_STICKY
         MODE_DOCANDPRINTER_STICKY

Return Value:

    TRUE if any option for the specified feature is enabled,
    FALSE if all options of the specified feature are disabled
    (i.e. the feature itself is disabled)

--*/

{
    PINFOHEADER pInfoHdr;
    PUIINFO     pUIInfo;
    PFEATURE    pFeature;
    DWORD       dwIndex, dwCount;
    BOOL        bFeatureEnabled = FALSE;

    ASSERT(pOptions && pbEnabledOptions);

    //
    // Get pointers to various data structures
    //

    PPD_GET_UIINFO_FROM_RAWDATA(pRawData, pInfoHdr, pUIInfo);

    ASSERT(pUIInfo != NULL);

    if (! (pFeature = PGetIndexedFeature(pUIInfo, dwFeatureIndex)))
    {
        ASSERT(FALSE);
        return FALSE;
    }

    dwCount = pFeature->Options.dwCount;

    //
    // Go through each option of the specified feature and
    // determine whether it should be enabled or disabled.
    //

    for (dwIndex = 0; dwIndex < dwCount; dwIndex++)
    {
        DWORD   dwFeature, dwOption;
        BOOL    bEnabled = TRUE;

        for (dwFeature = 0;
             dwFeature < pRawData->dwDocumentFeatures + pRawData->dwPrinterFeatures;
             dwFeature ++)
        {
            if (BCheckFeatureConflict(pUIInfo,
                                      pOptions,
                                      dwFeature,
                                      &dwOption,
                                      dwFeatureIndex,
                                      dwIndex))
            {
                bEnabled = FALSE;
                break;
            }
        }

        pbEnabledOptions[dwIndex] = bEnabled;
        bFeatureEnabled = bFeatureEnabled || bEnabled;
    }

    return bFeatureEnabled;
}



BOOL
EnumNewUIConflict(
    IN PRAWBINARYDATA   pRawData,
    IN POPTSELECT       pOptions,
    IN DWORD            dwFeatureIndex,
    IN PBOOL            pbSelectedOptions,
    OUT PCONFLICTPAIR   pConflictPair
    )

/*++

Routine Description:

    Check if there are any conflicts between the currently selected options
    for the specified feature an other feature/option selections.

Arguments:

    pRawData - Points to raw binary printer description data
    pOptions - Points to the current feature/option selections
    dwFeatureIndex - Specifies the index of the interested printer feature
    pbSelectedOptions - Specifies which options for the specified feature are selected
    pConflictPair - Return the conflicting pair of feature/option selections

Return Value:

    TRUE if there is a conflict between the selected options for the specified feature
    and other feature option selections.

    FALSE if the selected options for the specified feature is consistent with other
    feature option selections.

--*/

{
    PINFOHEADER pInfoHdr;
    PUIINFO     pUIInfo;
    PFEATURE    pSpecifiedFeature;
    DWORD       dwIndex, dwCount, dwPriority;
    BOOL        bConflict = FALSE;

    ASSERT(pOptions && pbSelectedOptions && pConflictPair);

    //
    // Get pointers to various data structures
    //

    PPD_GET_UIINFO_FROM_RAWDATA(pRawData, pInfoHdr, pUIInfo);

    ASSERT(pUIInfo != NULL);

    if (! (pSpecifiedFeature = PGetIndexedFeature(pUIInfo, dwFeatureIndex)))
    {
        ASSERT(FALSE);
        return FALSE;
    }

    dwCount = pSpecifiedFeature->Options.dwCount;

    //
    // Go through the selected options of the specified feature
    // and check if they are constrained.
    //

    for (dwIndex = 0; dwIndex < dwCount; dwIndex++)
    {
        DWORD       dwFeature, dwOption;
        PFEATURE    pFeature;

        //
        // Skip options which are not selected
        //

        if (! pbSelectedOptions[dwIndex])
            continue;

        for (dwFeature = 0;
             dwFeature < pRawData->dwDocumentFeatures + pRawData->dwPrinterFeatures;
             dwFeature ++)
        {
            if (dwFeature == dwFeatureIndex)
                continue;

            if (BCheckFeatureConflict(pUIInfo,
                                      pOptions,
                                      dwFeature,
                                      &dwOption,
                                      dwFeatureIndex,
                                      dwIndex))
            {
                pFeature = PGetIndexedFeature(pUIInfo, dwFeature);
                ASSERT(pFeature != NULL);

                //
                // Remember the highest priority conflict-pair
                //

                if (!bConflict || pFeature->dwPriority > dwPriority)
                {
                    dwPriority = pFeature->dwPriority;

                    if (dwPriority >= pSpecifiedFeature->dwPriority)
                    {
                        pConflictPair->dwFeatureIndex1 = dwFeature;
                        pConflictPair->dwOptionIndex1 = dwOption;
                        pConflictPair->dwFeatureIndex2 = dwFeatureIndex;
                        pConflictPair->dwOptionIndex2 = dwIndex;
                    }
                    else
                    {
                        pConflictPair->dwFeatureIndex1 = dwFeatureIndex;
                        pConflictPair->dwOptionIndex1 = dwIndex;
                        pConflictPair->dwFeatureIndex2 = dwFeature;
                        pConflictPair->dwOptionIndex2 = dwOption;
                    }
                }

                bConflict = TRUE;
            }
        }

        //
        // For PickMany UI types, the current selections for the specified
        // feature could potentially conflict with each other.
        //

        if (pSpecifiedFeature->dwUIType == UITYPE_PICKMANY)
        {
            for (dwOption = 0; dwOption < dwCount; dwOption++)
            {
                if (BCheckFeatureOptionConflict(pUIInfo,
                                                dwFeatureIndex,
                                                dwOption,
                                                dwFeatureIndex,
                                                dwIndex))
                {
                    if (!bConflict || pSpecifiedFeature->dwPriority > dwPriority)
                    {
                        dwPriority = pSpecifiedFeature->dwPriority;
                        pConflictPair->dwFeatureIndex1 = dwFeatureIndex;
                        pConflictPair->dwOptionIndex1 = dwOption;
                        pConflictPair->dwFeatureIndex2 = dwFeatureIndex;
                        pConflictPair->dwOptionIndex2 = dwIndex;
                    }

                    bConflict = TRUE;
                }
            }
        }
    }

    return bConflict;
}



BOOL
EnumNewPickOneUIConflict(
    IN PRAWBINARYDATA   pRawData,
    IN POPTSELECT       pOptions,
    IN DWORD            dwFeatureIndex,
    IN DWORD            dwOptionIndex,
    OUT PCONFLICTPAIR   pConflictPair
    )

/*++

Routine Description:

    Check if there are any conflicts between the currently selected option
    for the specified feature an other feature/option selections.

    This is similar to EnumNewUIConflict above except that only one selected
    option is allowed for the specified feature.

Arguments:

    pRawData - Points to raw binary printer description data
    pOptions - Points to the current feature/option selections
    dwFeatureIndex - Specifies the index of the interested printer feature
    dwOptionIndex - Specifies the selected option of the specified feature
    pConflictPair - Return the conflicting pair of feature/option selections

Return Value:

    TRUE if there is a conflict between the selected option for the specified feature
    and other feature/option selections.

    FALSE if the selected option for the specified feature is consistent with other
    feature/option selections.

--*/

{
    PINFOHEADER pInfoHdr;
    PUIINFO     pUIInfo;
    PFEATURE    pSpecifiedFeature, pFeature;
    DWORD       dwPriority, dwFeature, dwOption;
    BOOL        bConflict = FALSE;

    ASSERT(pOptions && pConflictPair);

    //
    // Get pointers to various data structures
    //

    PPD_GET_UIINFO_FROM_RAWDATA(pRawData, pInfoHdr, pUIInfo);

    ASSERT(pUIInfo != NULL);

    if ((pSpecifiedFeature = PGetIndexedFeature(pUIInfo, dwFeatureIndex)) == NULL ||
        (dwOptionIndex >= pSpecifiedFeature->Options.dwCount))
    {
        ASSERT(FALSE);
        return FALSE;
    }

    //
    // Check if the specified feature/option is constrained
    //

    for (dwFeature = 0;
         dwFeature < pRawData->dwDocumentFeatures + pRawData->dwPrinterFeatures;
         dwFeature ++)
    {
        if (dwFeature == dwFeatureIndex)
            continue;

        if (BCheckFeatureConflict(pUIInfo,
                                  pOptions,
                                  dwFeature,
                                  &dwOption,
                                  dwFeatureIndex,
                                  dwOptionIndex))
        {
            pFeature = PGetIndexedFeature(pUIInfo, dwFeature);

            ASSERT(pFeature != NULL);

            //
            // Remember the highest priority conflict-pair
            //

            if (!bConflict || pFeature->dwPriority > dwPriority)
            {
                dwPriority = pFeature->dwPriority;

                if (dwPriority >= pSpecifiedFeature->dwPriority)
                {
                    pConflictPair->dwFeatureIndex1 = dwFeature;
                    pConflictPair->dwOptionIndex1 = dwOption;
                    pConflictPair->dwFeatureIndex2 = dwFeatureIndex;
                    pConflictPair->dwOptionIndex2 = dwOptionIndex;
                }
                else
                {
                    pConflictPair->dwFeatureIndex1 = dwFeatureIndex;
                    pConflictPair->dwOptionIndex1 = dwOptionIndex;
                    pConflictPair->dwFeatureIndex2 = dwFeature;
                    pConflictPair->dwOptionIndex2 = dwOption;
                }
            }

            bConflict = TRUE;
        }
    }

    return bConflict;
}



BOOL
ChangeOptionsViaID(
    IN PINFOHEADER      pInfoHdr,
    IN OUT POPTSELECT   pOptions,
    IN DWORD            dwFeatureID,
    IN PDEVMODE         pDevmode
    )

/*++

Routine Description:

    Modifies an option array using the information in public devmode fields

Arguments:

    pInfoHdr - Points to an instance of binary printer description data
    pOptions - Points to the option array to be modified
    dwFeatureID - Specifies which field(s) of the input devmode should be used
    pDevmode - Specifies the input devmode

Return Value:
    TRUE if successful, FALSE if the specified feature ID is not supported
    or there is an error

Note:

    We assume the input devmode fields have been validated by the caller.

--*/

{
    PRAWBINARYDATA  pRawData;
    PUIINFO         pUIInfo;
    PFEATURE        pFeature;
    DWORD           dwFeatureIndex;
    LONG            lParam1, lParam2;
    BOOL            abEnabledOptions[MAX_PRINTER_OPTIONS];
    PDWORD          pdwPaperIndex = (PDWORD)&abEnabledOptions;
    DWORD           dwCount, dwOptionIndex, i;

    ASSERT(pOptions && pDevmode);

    //
    // Get a pointer to the FEATURE structure corresponding to
    // the specified feature ID.
    //

    pRawData = (PRAWBINARYDATA) pInfoHdr;
    PPD_GET_UIINFO_FROM_RAWDATA(pRawData, pInfoHdr, pUIInfo);

    ASSERT(pUIInfo != NULL);

    if ((dwFeatureID >= MAX_GID) ||
        (pFeature = GET_PREDEFINED_FEATURE(pUIInfo, dwFeatureID)) == NULL)
    {
        VERBOSE(("ChangeOptionsViaID failed: feature ID = %d\n", dwFeatureID));
        SetLastError(ERROR_NOT_SUPPORTED);
        return FALSE;
    }

    dwFeatureIndex = GET_INDEX_FROM_FEATURE(pUIInfo, pFeature);

    //
    // Handle it according to what dwFeatureID is specified
    //

    lParam1 = lParam2 = 0;

    switch (dwFeatureID)
    {
    case GID_PAGESIZE:

        //
        // Don't select any PageRegion option by default
        //

        {
            PFEATURE    pPageRgnFeature;
            DWORD       dwPageRgnIndex;

            if (pPageRgnFeature = GET_PREDEFINED_FEATURE(pUIInfo, GID_PAGEREGION))
            {
                dwPageRgnIndex = GET_INDEX_FROM_FEATURE(pUIInfo, pPageRgnFeature);

                pOptions[dwPageRgnIndex].ubCurOptIndex =
                    (BYTE) pPageRgnFeature->dwNoneFalseOptIndex;
            }
        }

        //
        // If the devmode specifies PostScript custom page size,
        // we assume the parameters have already been validated
        // during devmode merge proces. So here we simply return
        // the custom page size option index.
        //

        if ((pDevmode->dmFields & DM_PAPERSIZE) &&
            (pDevmode->dmPaperSize == DMPAPER_CUSTOMSIZE))
        {
            ASSERT(SUPPORT_CUSTOMSIZE(pUIInfo));
            pOptions[dwFeatureIndex].ubCurOptIndex = (BYTE) pUIInfo->dwCustomSizeOptIndex;
            return TRUE;
        }

        lParam1 = pDevmode->dmPaperWidth * DEVMODE_PAPER_UNIT;
        lParam2 = pDevmode->dmPaperLength * DEVMODE_PAPER_UNIT;
        break;

    case GID_INPUTSLOT:

        lParam1 = pDevmode->dmDefaultSource;
        break;

    case GID_RESOLUTION:

        //
        // If none is set, this function is not called with par. GID_RESOLUTION
        //

        ASSERT(pDevmode->dmFields & (DM_PRINTQUALITY | DM_YRESOLUTION));

        switch (pDevmode->dmFields & (DM_PRINTQUALITY | DM_YRESOLUTION))
        {

        case DM_PRINTQUALITY:        // set both if only one is set

            lParam1 = lParam2 = pDevmode->dmPrintQuality;
            break;

        case DM_YRESOLUTION:        // set both if only one is set

            lParam1 = lParam2 = pDevmode->dmYResolution;
            break;

        default:
            lParam1 = pDevmode->dmPrintQuality;
            lParam2 = pDevmode->dmYResolution;
            break;
        }
        break;

    case GID_DUPLEX:

        lParam1 = pDevmode->dmDuplex;
        break;

    case GID_MEDIATYPE:

        lParam1 = pDevmode->dmMediaType;
        break;

    case GID_COLLATE:

        lParam1 = pDevmode->dmCollate;
        break;

    default:

        VERBOSE(("ChangeOptionsViaID failed: feature ID = %d\n", dwFeatureID));
        SetLastError(ERROR_NOT_SUPPORTED);
        return FALSE;
    }

    ASSERT(pFeature->dwUIType != UITYPE_PICKMANY);

    if (dwFeatureID == GID_PAGESIZE)
    {
        dwCount = DwInternalMapToOptIndex(pUIInfo, pFeature, lParam1, lParam2, pdwPaperIndex);

        if (dwCount == 0 )
            return TRUE;

        if (dwCount > 1 )
        {
            POPTION  pOption;
            LPCTSTR  pDisplayName;

            for (i = 0; i < dwCount; i++)
            {
                if (pOption = PGetIndexedOption(pUIInfo, pFeature, pdwPaperIndex[i]))
                {
                    if ((pDisplayName = OFFSET_TO_POINTER(pRawData, pOption->loDisplayName)) &&
                        (_tcsicmp(pDevmode->dmFormName, pDisplayName) == EQUAL_STRING) )
                    {
                        dwOptionIndex = pdwPaperIndex[i];
                        break;
                    }
                }
            }

            if (i >= dwCount)
                dwOptionIndex = pdwPaperIndex[0];
        }
        else
            dwOptionIndex = pdwPaperIndex[0];

        pOptions[dwFeatureIndex].ubCurOptIndex = (BYTE)dwOptionIndex;
    }
    else
    {
        pOptions[dwFeatureIndex].ubCurOptIndex =
            (BYTE) DwInternalMapToOptIndex(pUIInfo, pFeature, lParam1, lParam2, NULL);
    }

    return TRUE;
}



DWORD
MapToDeviceOptIndex(
    IN PINFOHEADER      pInfoHdr,
    IN DWORD            dwFeatureID,
    IN LONG             lParam1,
    IN LONG             lParam2,
    OUT PDWORD          pdwOptionIndexes
    )

/*++

Routine Description:

    Map logical values to device feature option index

Arguments:

    pInfoHdr - Points to an instance of binary printer description data
    dwFeatureID - Indicate which feature the logical values are related to
    lParam1, lParam2  - Parameters depending on dwFeatureID
    pdwOptionIndexes - if Not NULL, means fill this array with all indicies
                       which match the search criteria. In this case the return value
                       is the number of elements in the array initialized. Currently
                       we assume the array is large enough (256 elements).
                       (It should be non-NULL only for GID_PAGESIZE.)

    dwFeatureID = GID_PAGESIZE:
        map logical paper specification to physical page size option

        lParam1 = paper width in microns
        lParam2 = paper height in microns

    dwFeatureID = GID_RESOLUTION:
        map logical resolution to physical resolution option

        lParam1 = x-resolution in dpi
        lParam2 = y-resolution in dpi

Return Value:

    If pdwOptionIndexes is NULL, returns index of the feature option corresponding
    to the specified logical values; OPTION_INDEX_ANY if the specified logical
    values cannot be mapped to any feature option.

    If pdwOptionIndexes is not NULL (for GID_PAGESIZE), returns the number of elements
    filled in the output buffer. Zero means the specified logical values cannot be mapped
    to any feature option.

--*/

{
    PRAWBINARYDATA  pRawData;
    PUIINFO         pUIInfo;
    PFEATURE        pFeature;

    //
    // Get a pointer to the FEATURE structure corresponding to
    // the specified feature ID.
    //

    pRawData = (PRAWBINARYDATA) pInfoHdr;
    PPD_GET_UIINFO_FROM_RAWDATA(pRawData, pInfoHdr, pUIInfo);

    ASSERT(pUIInfo != NULL);

    if ((dwFeatureID >= MAX_GID) ||
        (pFeature = GET_PREDEFINED_FEATURE(pUIInfo, dwFeatureID)) == NULL)
    {
        VERBOSE(("MapToDeviceOptIndex failed: feature ID = %d\n", dwFeatureID));

        if (!pdwOptionIndexes)
            return OPTION_INDEX_ANY;
        else
            return 0;
    }

    //
    // pdwOptionIndexes can be non-NULL only if dwFeatureID is GID_PAGESIZE.
    //

    ASSERT(dwFeatureID == GID_PAGESIZE || pdwOptionIndexes == NULL);

    return DwInternalMapToOptIndex(pUIInfo, pFeature, lParam1, lParam2, pdwOptionIndexes);
}



BOOL
CombineOptionArray(
    IN PRAWBINARYDATA   pRawData,
    OUT POPTSELECT      pCombinedOptions,
    IN INT              iMaxOptions,
    IN POPTSELECT       pDocOptions,
    IN POPTSELECT       pPrinterOptions
    )

/*++

Routine Description:

    Combine doc-sticky with printer-sticky option selections to form a single option array

Arguments:

    pRawData - Points to raw binary printer description data
    pCombinedOptions - Points to an array of OPTSELECTs for holding the combined options
    iMaxOptions - Max number of entries in pCombinedOptions array
    pDocOptions - Specifies the array of doc-sticky options
    pPrinterOptions - Specifies the array of printer-sticky options

Return Value:

    FALSE if the combined option array is not large enough to store
    all the option values, TRUE otherwise.

Note:

    Either pDocOptions or pPrinterOptions could be NULL but not both. If pDocOptions
    is NULL, then in the combined option array, the options for document-sticky
    features will be OPTION_INDEX_ANY. Same is true when pPrinterOptions is NULL.

--*/

{
    PINFOHEADER pInfoHdr;
    PUIINFO     pUIInfo;
    PFEATURE    pFeatures;
    INT         iCount, iDocOptions, iPrinterOptions, iNext;

    //
    // Calculate the number of features: both doc-sticky and printer-sticky
    //

    PPD_GET_UIINFO_FROM_RAWDATA(pRawData, pInfoHdr, pUIInfo);

    ASSERT(pUIInfo != NULL);

    pFeatures = OFFSET_TO_POINTER(pInfoHdr, pUIInfo->loFeatureList);

    iDocOptions = (INT) pRawData->dwDocumentFeatures;
    iPrinterOptions = (INT) pRawData->dwPrinterFeatures;
    iNext = iDocOptions + iPrinterOptions;
    ASSERT(iNext <= iMaxOptions);

    //
    // Copy doc-sticky options into the combined array.
    // Take care of the special case where pDocOptions is NULL.
    //

    if (pDocOptions == NULL)
    {
        for (iCount = 0; iCount < iDocOptions; iCount++)
        {
            pCombinedOptions[iCount].ubCurOptIndex = OPTION_INDEX_ANY;
            pCombinedOptions[iCount].ubNext = NULL_OPTSELECT;
        }
    }
    else
    {
        for (iCount = 0; iCount < iDocOptions; iCount++)
        {
            VCopyOptionSelections(pCombinedOptions,
                                  iCount,
                                  pDocOptions,
                                  iCount,
                                  &iNext,
                                  iMaxOptions);
        }
    }

    //
    // Copy printer-sticky options into the combined option array.
    //

    if (pPrinterOptions == NULL)
    {
        for (iCount = 0; iCount < iPrinterOptions; iCount++)
        {
            pCombinedOptions[iCount + iDocOptions].ubCurOptIndex = OPTION_INDEX_ANY;
            pCombinedOptions[iCount + iDocOptions].ubNext = NULL_OPTSELECT;
        }
    }
    else
    {
        for (iCount = 0; iCount < iPrinterOptions; iCount++)
        {
            VCopyOptionSelections(pCombinedOptions,
                                  iCount + iDocOptions,
                                  pPrinterOptions,
                                  iCount,
                                  &iNext,
                                  iMaxOptions);
        }
    }

    if (iNext > iMaxOptions)
        WARNING(("Option array too small: size = %d, needed = %d\n", iMaxOptions, iNext));

    return (iNext <= iMaxOptions);
}



BOOL
SeparateOptionArray(
    IN PRAWBINARYDATA   pRawData,
    IN POPTSELECT       pCombinedOptions,
    OUT POPTSELECT      pOptions,
    IN INT              iMaxOptions,
    IN INT              iMode
    )

/*++

Routine Description:

    Separate an option array into doc-sticky and for printer-sticky options

Arguments:

    pRawData - Points to raw binary printer description data
    pCombinedOptions - Points to the combined option array to be separated
    pOptions - Points to an array of OPTSELECT structures
        for storing the separated option array
    iMaxOptions - Max number of entries in pOptions array
    iMode - Whether the caller is interested in doc- or printer-sticky options:
        MODE_DOCUMENT_STICKY
        MODE_PRINTER_STICKY

Return Value:

    FALSE if the destination option array is not large enough to hold
    the separated option values, TRUE otherwise.

--*/

{
    INT iStart, iCount, iOptions, iNext;

    //
    // Determine if the caller is interested in doc-sticky or printer-sticky options
    //

    if (iMode == MODE_DOCUMENT_STICKY)
    {
        iStart = 0;
        iOptions = (INT) pRawData->dwDocumentFeatures;
    }
    else
    {
        ASSERT (iMode == MODE_PRINTER_STICKY);
        iStart = (INT) pRawData->dwDocumentFeatures;
        iOptions = (INT) pRawData->dwPrinterFeatures;
    }

    iNext = iOptions;
    ASSERT(iNext <= iMaxOptions);

    //
    // Separate the requested options out of the combined option array
    //

    for (iCount = 0; iCount < iOptions; iCount++)
    {
        VCopyOptionSelections(pOptions,
                              iCount,
                              pCombinedOptions,
                              iStart + iCount,
                              &iNext,
                              iMaxOptions);
    }

    if (iNext > iMaxOptions)
        WARNING(("Option array too small: size = %d, needed = %d\n", iMaxOptions, iNext));

    return (iNext <= iMaxOptions);
}



BOOL
ReconstructOptionArray(
    IN PRAWBINARYDATA   pRawData,
    IN OUT POPTSELECT   pOptions,
    IN INT              iMaxOptions,
    IN DWORD            dwFeatureIndex,
    IN PBOOL            pbSelectedOptions
    )

/*++

Routine Description:

    Modify an option array to change the selected options for the specified feature

Arguments:

    pRawData - Points to raw binary printer description data
    pOptions - Points to an array of OPTSELECT structures to be modified
    iMaxOptions - Max number of entries in pOptions array
    dwFeatureIndex - Specifies the index of printer feature in question
    pbSelectedOptions - Which options of the specified feature is selected

Return Value:

    FALSE if the input option array is not large enough to hold
    all modified option values. TRUE otherwise.

Note:

    Number of BOOLs in pSelectedOptions must match the number of options
    for the specified feature.

    This function always leaves the option array in a compact format (i.e.
    all unused entries are left at the end of the array).

--*/

{
    INT         iNext, iCount, iDest;
    DWORD       dwIndex;
    PINFOHEADER pInfoHdr;
    PUIINFO     pUIInfo;
    PFEATURE    pFeature;
    POPTSELECT  pTempOptions;

    ASSERT(pOptions && pbSelectedOptions);

    //
    // Get pointers to various data structures
    //

    PPD_GET_UIINFO_FROM_RAWDATA(pRawData, pInfoHdr, pUIInfo);

    ASSERT(pUIInfo != NULL);

    if (! (pFeature = PGetIndexedFeature(pUIInfo, dwFeatureIndex)))
    {
        ASSERT(FALSE);
        return FALSE;
    }

    //
    // Assume the entire input option array is used by default. This is
    // not exactly true but it shouldn't have any adverse effects either.
    //

    iNext = iMaxOptions;

    //
    // Special case (faster) for non-PickMany UI types
    //

    if (pFeature->dwUIType != UITYPE_PICKMANY)
    {
        for (dwIndex = 0, iCount = 0;
             dwIndex < pFeature->Options.dwCount;
             dwIndex ++)
        {
            if (pbSelectedOptions[dwIndex])
            {
                pOptions[dwFeatureIndex].ubCurOptIndex = (BYTE) dwIndex;
                ASSERT(pOptions[dwFeatureIndex].ubNext == NULL_OPTSELECT);
                iCount++;
            }
        }

        //
        // Exactly one option is allowed to be selected
        //

        ASSERT(iCount == 1);
    }
    else
    {
        //
        // Handle PickMany UI type:
        //  allocate a temporary option array and copy the input option values
        //  except the option values for the specified feature.
        //

        if (pTempOptions = MemAllocZ(iMaxOptions * sizeof(OPTSELECT)))
        {
            DWORD   dwOptions;

            dwOptions = pRawData->dwDocumentFeatures + pRawData->dwPrinterFeatures;
            iNext = dwOptions;

            if (iNext > iMaxOptions)
            {
                ASSERT(FALSE);
                return FALSE;
            }

            for (dwIndex = 0; dwIndex < dwOptions; dwIndex++)
            {
                if (dwIndex != dwFeatureIndex)
                {
                    VCopyOptionSelections(pTempOptions,
                                          dwIndex,
                                          pOptions,
                                          dwIndex,
                                          &iNext,
                                          iMaxOptions);
                }
            }

            //
            // Reconstruct the option values for the specified feature
            //

            pTempOptions[dwFeatureIndex].ubCurOptIndex = OPTION_INDEX_ANY;
            pTempOptions[dwFeatureIndex].ubNext = NULL_OPTSELECT;

            iDest = dwFeatureIndex;
            iCount = 0;

            for (dwIndex = 0; dwIndex < pFeature->Options.dwCount; dwIndex ++)
            {
                if (pbSelectedOptions[dwIndex])
                {
                    if (iCount++ == 0)
                    {
                        //
                        // The first selected option
                        //

                        pTempOptions[iDest].ubCurOptIndex = (BYTE) dwIndex;
                    }
                    else
                    {
                        //
                        // Subsequent selected options
                        //

                        if (iNext < iMaxOptions)
                        {
                            pTempOptions[iDest].ubNext = (BYTE) iNext;
                            pTempOptions[iNext].ubCurOptIndex = (BYTE) dwIndex;
                            iDest = iNext;
                        }

                        iNext++;
                    }
                }
            }

            pTempOptions[iDest].ubNext = NULL_OPTSELECT;

            //
            // Copy the reconstructed option array from the temporary buffer
            // back to the input option array provided by the caller.
            //

            CopyMemory(pOptions, pTempOptions, iMaxOptions * sizeof(OPTSELECT));
            MemFree(pTempOptions);
        }
        else
        {
            ERR(("Cannot allocate memory for temporary option array\n"));
        }
    }

    return (iNext <= iMaxOptions);
}



PTSTR
GenerateBpdFilename(
    PTSTR   ptstrPpdFilename
    )

/*++

Routine Description:

    Generate a filename for the cached binary PPD data given a PPD filename

Arguments:

    ptstrPpdFilename - Specifies the PPD filename

Return Value:

    Pointer to BPD filename string, NULL if there is an error

--*/

{
    PTSTR   ptstrBpdFilename, ptstrExtension;
    INT     iLength;

    //
    // If the PPD filename has .PPD extension, replace it with .BPD extension.
    // Otherwise, append .BPD extension at the end.
    //

    iLength = _tcslen(ptstrPpdFilename);

    if ((ptstrExtension = _tcsrchr(ptstrPpdFilename, TEXT('.'))) == NULL ||
        _tcsicmp(ptstrExtension, PPD_FILENAME_EXT) != EQUAL_STRING)
    {
        WARNING(("Bad PPD filename extension: %ws\n", ptstrPpdFilename));

        ptstrExtension = ptstrPpdFilename + iLength;
        iLength += _tcslen(BPD_FILENAME_EXT);
    }

    //
    // Allocate memory and compose the BPD filename
    //

    if (ptstrBpdFilename = MemAlloc((iLength + 1) * sizeof(TCHAR)))
    {
        _tcscpy(ptstrBpdFilename, ptstrPpdFilename);
        _tcscpy(ptstrBpdFilename + (ptstrExtension - ptstrPpdFilename), BPD_FILENAME_EXT);

        VERBOSE(("BPD filename: %ws\n", ptstrBpdFilename));
    }
    else
    {
        ERR(("Memory allocation failed: %d\n", GetLastError()));
    }

    return ptstrBpdFilename;
}



PRAWBINARYDATA
PpdLoadCachedBinaryData(
    PTSTR   ptstrPpdFilename
    )

/*++

Routine Description:

    Load cached binary PPD data file into memory

Arguments:

    ptstrPpdFilename - Specifies the PPD filename

Return Value:

    Pointer to PPD data if successful, NULL if there is an error

--*/

{
    HFILEMAP        hFileMap;
    DWORD           dwSize;
    PVOID           pvData;
    PTSTR           ptstrBpdFilename;
    PRAWBINARYDATA  pRawData, pCopiedData;
    BOOL            bValidCache = FALSE;

    //
    // Generate BPD filename from the specified PPD filename
    //

    if (! (ptstrBpdFilename = GenerateBpdFilename(ptstrPpdFilename)))
        return NULL;

    //
    // First map the data file into memory
    //

    if (! (hFileMap = MapFileIntoMemory(ptstrBpdFilename, &pvData, &dwSize)))
    {
        TERSE(("Couldn't map file '%ws' into memory: %d\n", ptstrBpdFilename, GetLastError()));
        MemFree(ptstrBpdFilename);
        return NULL;
    }

    //
    // Verify size, parser version number, and signature.
    // Allocate a memory buffer and copy data into it.
    //

    pRawData = pvData;
    pCopiedData = NULL;

    if ((dwSize > sizeof(INFOHEADER) + sizeof(UIINFO) + sizeof(PPDDATA)) &&
        (dwSize >= pRawData->dwFileSize) &&
        (pRawData->dwParserVersion == PPD_PARSER_VERSION) &&
        (pRawData->dwParserSignature == PPD_PARSER_SIGNATURE) &&
        (BIsRawBinaryDataUpToDate(pRawData)))
    {
        #ifndef WINNT_40

        PPPDDATA  pPpdData;

        //
        // For Win2K+ systems, we support MUI where user can switch UI language
        // and MUI knows to redirect resource loading calls to the correct resource
        // DLL (built by MUI). However, PPD parser caches some display names into
        // the .bpd file, where the display names are obtained based on the UI
        // language when the parsing occurs. To support MUI, we store the UI language
        // ID into the .bpd file and now if we see the current user's UI language ID
        // doesn't match to the one stored in the .bpd file, we need to throw away
        // the old .bpd file and reparse the .ppd, so we can get correct display names
        // under current UI language.
        //

        pPpdData = GET_DRIVER_INFO_FROM_INFOHEADER((PINFOHEADER)pRawData);

        if (pPpdData && pPpdData->dwUserDefUILangID == (DWORD)GetUserDefaultUILanguage())
        {
            bValidCache = TRUE;
        }

        #else

        bValidCache = TRUE;

        #endif // !WINNT_40
    }

    if (bValidCache &&
        (pCopiedData = MemAlloc(dwSize)))
    {
        CopyMemory(pCopiedData, pRawData, dwSize);
    }
    else
    {
        ERR(("Invalid binary PPD data\n"));
        SetLastError(ERROR_INVALID_DATA);
    }

    MemFree(ptstrBpdFilename);
    UnmapFileFromMemory(hFileMap);

    return pCopiedData;
}



BOOL
BSearchConstraintList(
    PUIINFO     pUIInfo,
    DWORD       dwConstraintIndex,
    DWORD       dwFeature,
    DWORD       dwOption
    )

/*++

Routine Description:

    Check if the specified feature/option appears in a constraint list

Arguments:

    pUIInfo - Points to a UIINFO structure
    dwConstraintIndex - Specifies the constraint list to be searched
    dwFeature, dwOption - Specifies the feature/option we're interested in

Return Value:

    TRUE if dwFeature/dwOption appears on the specified constraint list
    FALSE otherwise

--*/

{
    PUICONSTRAINT   pConstraint;
    BOOL            bMatch = FALSE;

    pConstraint = OFFSET_TO_POINTER(pUIInfo->pInfoHeader, pUIInfo->UIConstraints.loOffset);

    //
    // Go through each item on the constraint list
    //

    while (!bMatch && (dwConstraintIndex != NULL_CONSTRAINT))
    {
        ASSERT(dwConstraintIndex < pUIInfo->UIConstraints.dwCount);

        if (pConstraint[dwConstraintIndex].dwFeatureIndex == dwFeature)
        {
            //
            // If the option index is OPTION_INDEX_ANY, it matches
            // any option other than None/False.
            //

            if (pConstraint[dwConstraintIndex].dwOptionIndex == OPTION_INDEX_ANY)
            {
                PFEATURE    pFeature;

                pFeature = PGetIndexedFeature(pUIInfo, dwFeature);
                ASSERT(pFeature != NULL);

                bMatch = (pFeature->dwNoneFalseOptIndex != dwOption);
            }
            else
            {
                bMatch = (pConstraint[dwConstraintIndex].dwOptionIndex == dwOption);
            }
        }

        dwConstraintIndex = pConstraint[dwConstraintIndex].dwNextConstraint;
    }

    return bMatch;
}



BOOL
BCheckFeatureOptionConflict(
    PUIINFO     pUIInfo,
    DWORD       dwFeature1,
    DWORD       dwOption1,
    DWORD       dwFeature2,
    DWORD       dwOption2
    )

/*++

Routine Description:

    Check if there is a conflict between a pair of feature/options

Arguments:

    pUIInfo - Points to a UIINFO structure
    dwFeature1, dwOption1 - Specifies the first feature/option
    dwFeature2, dwOption2 - Specifies the second feature/option

Return Value:

    TRUE if dwFeature1/dwOption1 constrains dwFeature2/dwOption2,
    FALSE otherwise

--*/

{
    PFEATURE    pFeature;
    POPTION     pOption;

    //
    // Check for special case:
    //  either dwOption1 or dwOption2 is OPTION_INDEX_ANY
    //

    if ((dwOption1 == OPTION_INDEX_ANY) ||
        (dwOption2 == OPTION_INDEX_ANY) ||
        (dwFeature1 == dwFeature2 && dwOption1 == dwOption2))
    {
        return FALSE;
    }

    //
    // Go through the constraint list associated with dwFeature1
    //

    if (! (pFeature = PGetIndexedFeature(pUIInfo, dwFeature1)))
        return FALSE;

    if ((dwOption1 != pFeature->dwNoneFalseOptIndex) &&
        BSearchConstraintList(pUIInfo,
                              pFeature->dwUIConstraintList,
                              dwFeature2,
                              dwOption2))
    {
        return TRUE;
    }

    //
    // Go through the constraint list associated with dwFeature1/dwOption1
    //

    if ((pOption = PGetIndexedOption(pUIInfo, pFeature, dwOption1)) &&
        BSearchConstraintList(pUIInfo,
                              pOption->dwUIConstraintList,
                              dwFeature2,
                              dwOption2))
    {
        return TRUE;
    }

    //
    // Automatically check the reciprocal constraint for:
    //  (dwFeature2, dwOption2) => (dwFeature1, dwOption1)
    //

    if (! (pFeature = PGetIndexedFeature(pUIInfo, dwFeature2)))
        return FALSE;

    if ((dwOption2 != pFeature->dwNoneFalseOptIndex) &&
        BSearchConstraintList(pUIInfo,
                              pFeature->dwUIConstraintList,
                              dwFeature1,
                              dwOption1))
    {
        return TRUE;
    }

    if ((pOption = PGetIndexedOption(pUIInfo, pFeature, dwOption2)) &&
        BSearchConstraintList(pUIInfo,
                              pOption->dwUIConstraintList,
                              dwFeature1,
                              dwOption1))
    {
        return TRUE;
    }

    return FALSE;
}



BOOL
BCheckFeatureConflict(
    PUIINFO     pUIInfo,
    POPTSELECT  pOptions,
    DWORD       dwFeature1,
    PDWORD      pdwOption1,
    DWORD       dwFeature2,
    DWORD       dwOption2
    )

/*++

Routine Description:

    Check if there is a conflict between the current option selections
    of a feature and the specified feature/option

Arguments:

    pUIInfo - Points to a UIINFO structure
    pOptions - Points to the current feature option selections
    dwFeature1 - Specifies the feature whose current option selections we're interested in
    pdwOption1 - In case of a conflict, returns the option of dwFeature1
        which caused the conflict
    dwFeature2, dwOption2 - Specifies the feature/option to be checked

Return Value:

    TRUE if there is a conflict between the current selections of dwFeature1
    and dwFeature2/dwOption2, FALSE otherwise.

--*/

{
    DWORD   dwIndex = dwFeature1;

    do
    {
        if (BCheckFeatureOptionConflict(pUIInfo,
                                        dwFeature1,
                                        pOptions[dwIndex].ubCurOptIndex,
                                        dwFeature2,
                                        dwOption2))
        {
            *pdwOption1 = pOptions[dwIndex].ubCurOptIndex;
            return TRUE;
        }

        dwIndex = pOptions[dwIndex].ubNext;

    } while (dwIndex != NULL_OPTSELECT);

    return FALSE;
}



DWORD
DwReplaceFeatureOption(
    PUIINFO     pUIInfo,
    POPTSELECT  pOptions,
    DWORD       dwFeatureIndex,
    DWORD       dwOptionIndex,
    DWORD       dwHint
    )

/*++

Routine Description:

    description-of-function

Arguments:

    pUIInfo - Points to UIINFO structure
    pOptions - Points to the options array to be modified
    dwFeatureIndex, dwOptionIndex - Specifies the feature/option to be replaced
    dwHint - Hint on how to replace the specified feature option.

Return Value:

    New hint value to be used next time this function is called on the same feature.

Note:

    HIWORD of dwHint should be returned untouched. LOWORD of dwHint is
    used by this function to determine how to replace the specified feature/option.

--*/

{
    PFEATURE    pFeature;
    DWORD       dwNext;

    pFeature = PGetIndexedFeature(pUIInfo, dwFeatureIndex);
    ASSERT(pFeature != NULL);

    if (pFeature->dwUIType == UITYPE_PICKMANY)
    {
        //
        // For PickMany feature, simply unselect the specified feature option.
        //

        dwNext = dwFeatureIndex;

        while ((pOptions[dwNext].ubCurOptIndex != dwOptionIndex) &&
               (dwNext = pOptions[dwNext].ubNext) != NULL_OPTSELECT)
        {
        }

        if (dwNext != NULL_OPTSELECT)
        {
            DWORD   dwLast;

            pOptions[dwNext].ubCurOptIndex = OPTION_INDEX_ANY;

            //
            // Compact the list of selected options for the specified
            // feature to filter out any redundant OPTION_INDEX_ANY entries.
            //

            dwLast = dwNext = dwFeatureIndex;

            do
            {
                if (pOptions[dwNext].ubCurOptIndex != OPTION_INDEX_ANY)
                {
                    pOptions[dwLast].ubCurOptIndex = pOptions[dwNext].ubCurOptIndex;
                    dwLast = pOptions[dwLast].ubNext;
                }

                dwNext = pOptions[dwNext].ubNext;
            }
            while (dwNext != NULL_OPTSELECT);

            pOptions[dwLast].ubNext = NULL_OPTSELECT;
        }
        else
        {
            ERR(("Trying to replace non-existent feature/option.\n"));
        }

        return dwHint;
    }
    else
    {
        //
        // For non-PickMany feature, use the hint paramater to determine
        // how to replace the specified feature option:
        //
        //  If this is the first time we're trying to replace the
        //  selected option of the specified feature, then we'll
        //  replace it with the default option for that feature.
        //
        //  Otherwise, we'll try each option of the specified feature in turn.
        //
        //  If we've exhausted all of the options for the specified
        //  (which should happen if the PPD file is well-formed),
        //  then we'll use OPTION_INDEX_ANY as the last resort.
        //

        dwNext = dwHint & 0xffff;

        if (dwNext == 0)
            dwOptionIndex = pFeature->dwDefaultOptIndex;
        else if (dwNext > pFeature->Options.dwCount)
            dwOptionIndex = OPTION_INDEX_ANY;
        else
            dwOptionIndex = dwNext - 1;

        pOptions[dwFeatureIndex].ubCurOptIndex = (BYTE) dwOptionIndex;

        return (dwHint & 0xffff0000) | (dwNext + 1);
    }
}



DWORD
DwInternalMapToOptIndex(
    PUIINFO     pUIInfo,
    PFEATURE    pFeature,
    LONG        lParam1,
    LONG        lParam2,
    OUT PDWORD  pdwOptionIndexes
    )

/*++

Routine Description:

    Map logical values to device feature option index

Arguments:

    pUIInfo - Points to UIINFO structure
    pFeature - Specifies the interested feature
    lParam1, lParam2  - Parameters depending on pFeature->dwFeatureID
    pdwOptionIndexes - if Not NULL, means fill this array with all indicies
                       which match the search criteria. In this case the return value
                       is the number of elements in the array initialized. Currently
                       we assume the array is large enough (256 elements).
                       (It should be non-NULL only for GID_PAGESIZE.)

    GID_PAGESIZE:
        map logical paper specification to physical PageSize option

        lParam1 = paper width in microns
        lParam2 = paper height in microns

    GID_RESOLUTION:
        map logical resolution to physical Resolution option

        lParam1 = x-resolution in dpi
        lParam2 = y-resolution in dpi

    GID_INPUTSLOT:
        map logical paper source to physical InputSlot option

        lParam1 = DEVMODE.dmDefaultSource

    GID_DUPLEX:
        map logical duplex selection to physical Duplex option

        lParam1 = DEVMODE.dmDuplex

    GID_COLLATE:
        map logical collate selection to physical Collate option

        lParam1 = DEVMODE.dmCollate

    GID_MEDIATYPE:
        map logical media type to physical MediaType option

        lParam1 = DEVMODE.dmMediaType

Return Value:

    If pdwOptionIndexes is NULL, returns index of the feature option corresponding
    to the specified logical values; OPTION_INDEX_ANY if the specified logical
    values cannot be mapped to any feature option.

    If pdwOptionIndexes is not NULL (for GID_PAGESIZE), returns the number of elements
    filled in the output buffer. Zero means the specified logical values cannot be mapped
    to any feature option.

--*/

{
    DWORD   dwIndex, dwOptionIndex;

    //
    // Handle it according to what dwFeatureID is specified
    //

    dwOptionIndex = pFeature->dwNoneFalseOptIndex;

    switch (pFeature->dwFeatureID)
    {
    case GID_PAGESIZE:
        {
            PPAGESIZE   pPaper;
            LONG        lXDelta, lYDelta;
            DWORD       dwExactMatch;

            //
            // lParam1 = paper width
            // lParam1 = paper height
            //

            //
            // Go through the list of paper sizes supported by the printer
            // and see if we can find an exact match to the requested size.
            // (The tolerance is 1mm). If not, remember the closest match found.
            //

            dwExactMatch = 0;

            for (dwIndex = 0; dwIndex < pFeature->Options.dwCount; dwIndex++)
            {
                pPaper = PGetIndexedOption(pUIInfo, pFeature, dwIndex);
                ASSERT(pPaper != NULL);

                //
                // Custom page size is handled differently - skip it here.
                //

                if (pPaper->dwPaperSizeID == DMPAPER_CUSTOMSIZE)
                    continue;

                lXDelta = abs(pPaper->szPaperSize.cx - lParam1);
                lYDelta = abs(pPaper->szPaperSize.cy - lParam2);

                if (lXDelta <= 1000 && lYDelta <= 1000)
                {
                    //
                    // Exact match is found
                    //

                    if (pdwOptionIndexes)
                    {
                        pdwOptionIndexes[dwExactMatch++] = dwIndex;
                    }
                    else
                    {
                        dwOptionIndex = dwIndex;
                        break;
                    }
                }
            }

            if (dwExactMatch > 0)
            {
                //
                // Exact match(es) found
                //

                dwOptionIndex = dwExactMatch;
            }
            else if (dwIndex >= pFeature->Options.dwCount)
            {
                //
                // No exact match found
                //

                if (SUPPORT_CUSTOMSIZE(pUIInfo) &&
                    BFormSupportedThruCustomSize((PRAWBINARYDATA) pUIInfo->pInfoHeader, lParam1, lParam2, NULL))
                {
                    dwOptionIndex = pUIInfo->dwCustomSizeOptIndex;
                }
                else
                {
                    //
                    // We used to use dwClosestIndex as dwOptionIndex here, but see bug #124203, we now
                    // choose to behave the same as Unidrv that if there is no exact match, we return no
                    // match instead of the cloest match.
                    //

                    dwOptionIndex = OPTION_INDEX_ANY;
                }

                if (pdwOptionIndexes)
                {
                    if (dwOptionIndex == OPTION_INDEX_ANY)
                        dwOptionIndex = 0;
                    else
                    {
                        pdwOptionIndexes[0] = dwOptionIndex;
                        dwOptionIndex = 1;
                    }
                }
            }
        }
        break;

    case GID_INPUTSLOT:

        //
        // lParam1 = DEVMODE.dmDefaultSource
        //

        dwOptionIndex = OPTION_INDEX_ANY;

        if (lParam1 >= DMBIN_USER)
        {
            //
            // An input slot is specifically requested.
            //

            dwIndex = lParam1 - DMBIN_USER;

            if (dwIndex < pFeature->Options.dwCount)
                dwOptionIndex = dwIndex;
        }
        else if (lParam1 == DMBIN_MANUAL || lParam1 == DMBIN_ENVMANUAL)
        {
            //
            // Manual feed is requested
            //

            for (dwIndex = 0; dwIndex < pFeature->Options.dwCount; dwIndex ++)
            {
                PINPUTSLOT  pInputSlot;

                if ((pInputSlot = PGetIndexedOption(pUIInfo, pFeature, dwIndex)) &&
                    (pInputSlot->dwPaperSourceID == DMBIN_MANUAL))
                {
                    dwOptionIndex = dwIndex;
                    break;
                }
            }
        }

        if (dwOptionIndex == OPTION_INDEX_ANY)
        {
            //
            // Treat all other cases as if no input slot is explicitly requested.
            // At print time, the driver will choose an input slot based on
            // the form-to-tray assignment table.
            //

            dwOptionIndex = 0;
        }
        break;

    case GID_RESOLUTION:

        //
        // lParam1 = x-resolution
        // lParam2 = y-resolution
        //

        {
            PRESOLUTION pRes;

            //
            // check whether it's one of the predefined DMRES_-values
            //

            if ((lParam1 < 0) && (lParam2 < 0))
            {
                DWORD dwHiResId=0, dwLoResId, dwMedResId, dwDraftResId=0;
                DWORD dwHiResProd=0, dwMedResProd=0, dwLoResProd= 0xffffffff, dwDraftResProd= 0xffffffff;
                BOOL  bValid = FALSE; // if there is at least one valid entry
                DWORD dwResProd;

                // no need to sort all the available options, just pick out the interesting ones
                for (dwIndex = 0; dwIndex < pFeature->Options.dwCount; dwIndex++)
                {
                    if ((pRes = PGetIndexedOption(pUIInfo, pFeature, dwIndex)) != NULL)
                    {
                        bValid = TRUE;

                        dwResProd = pRes->iXdpi * pRes->iYdpi; // use product as sort criteria

                        if (dwResProd > dwHiResProd) // take highest as high resolution
                        {
                            // previous max. is now second highest
                            dwMedResProd= dwHiResProd;
                            dwMedResId  = dwHiResId;

                            dwHiResProd = dwResProd;
                            dwHiResId   = dwIndex;
                        }
                        else if (dwResProd == dwHiResProd)
                        {
                            // duplicates possible, if e.g. 300x600 as well as 600x300 supported
                            // skip that
                        }
                        else if (dwResProd > dwMedResProd)  // take second highest as medium,
                        {   // can only be hit if not max.
                            dwMedResProd= dwResProd;
                            dwMedResId  = dwIndex;
                        }

                        if (dwResProd < dwDraftResProd)     // take lowest as draft
                        {
                            // previous min. is now second lowest
                            dwLoResProd    = dwDraftResProd;
                            dwLoResId      = dwDraftResId;

                            dwDraftResProd = dwResProd;
                            dwDraftResId   = dwIndex;
                        }
                        else if (dwResProd == dwDraftResProd)
                        {
                            // duplicates possible, if e.g. 300x600 as well as 600x300 supported
                            // skip that
                        }
                        else if (dwResProd < dwLoResProd)     // take second lowest as low
                        {// can only be hit if not min.
                            dwLoResProd = dwResProd;
                            dwLoResId   = dwIndex;
                        }
                    }
                }

                if (!bValid) // no valid entry ?
                {
                    return OPTION_INDEX_ANY;
                }

                //
                // Correct medium, might not be touched if less than 3 resolution options
                //

                if (dwMedResProd == 0)
                {
                    dwMedResProd = dwHiResProd;
                    dwMedResId   = dwHiResId;
                }

                //
                // Correct low, might not be touched if less than 3 resolution options
                //

                if (dwLoResProd == 0xffffffff)
                {
                    dwLoResProd = dwDraftResProd;
                    dwLoResId   = dwDraftResId;
                }

                //
                // if different, take the higher of the requested resolutions
                //

                switch(min(lParam1, lParam2))
                {
                case DMRES_DRAFT:
                    return dwDraftResId;

                case DMRES_LOW:
                    return dwLoResId;

                case DMRES_MEDIUM:
                    return dwMedResId;

                case DMRES_HIGH:
                    return dwHiResId;
                }

                //
                // requested is not one of the known predefined values
                //

                return OPTION_INDEX_ANY;
            }

            //
            // First try to match both x- and y-resolution exactly
            //

            dwOptionIndex = OPTION_INDEX_ANY;

            for (dwIndex = 0; dwIndex < pFeature->Options.dwCount; dwIndex++)
            {
                if ((pRes = PGetIndexedOption(pUIInfo, pFeature, dwIndex)) &&
                    (pRes->iXdpi == lParam1) &&
                    (pRes->iYdpi == lParam2))
                {
                    dwOptionIndex = dwIndex;
                    break;
                }
            }

            if (dwOptionIndex != OPTION_INDEX_ANY)
                break;

            //
            // If no exact match is found, then relax the criteria a bit and
            // compare the max of x- and y-resolution.
            //

            lParam1 = max(lParam1, lParam2);

            for (dwIndex = 0; dwIndex < pFeature->Options.dwCount; dwIndex++)
            {
                if ((pRes = PGetIndexedOption(pUIInfo, pFeature, dwIndex)) &&
                    (max(pRes->iXdpi, pRes->iYdpi) == lParam1))
                {
                    dwOptionIndex = dwIndex;
                    break;
                }
            }
        }
        break;

    case GID_DUPLEX:

        //
        // lParam1 = DEVMODE.dmDuplex
        //

        for (dwIndex = 0; dwIndex < pFeature->Options.dwCount; dwIndex++)
        {
            PDUPLEX pDuplex;

            if ((pDuplex = PGetIndexedOption(pUIInfo, pFeature, dwIndex)) &&
                ((LONG) pDuplex->dwDuplexID == lParam1))
            {
                dwOptionIndex = dwIndex;
                break;
            }
        }
        break;

    case GID_COLLATE:

        //
        // lParam1 = DEVMODE.dmCollate
        //

        for (dwIndex = 0; dwIndex < pFeature->Options.dwCount; dwIndex++)
        {
            PCOLLATE pCollate;

            if ((pCollate = PGetIndexedOption(pUIInfo, pFeature, dwIndex)) &&
                ((LONG) pCollate->dwCollateID == lParam1))
            {
                dwOptionIndex = dwIndex;
                break;
            }
        }
        break;

    case GID_MEDIATYPE:

        //
        // lParam1 = DEVMODE.dmMediaType
        //

        if (lParam1 >= DMMEDIA_USER)
        {
            dwIndex = lParam1 - DMMEDIA_USER;

            if (dwIndex < pFeature->Options.dwCount)
                dwOptionIndex = dwIndex;
        }
        break;

    default:

        VERBOSE(("DwInternalMapToOptIndex failed: feature ID = %d\n", pFeature->dwFeatureID));
        break;
    }

    return dwOptionIndex;
}



PTSTR
PtstrGetDefaultTTSubstTable(
    PUIINFO pUIInfo
    )

/*++

Routine Description:

    Return a copy of the default font substitution table

Arguments:

    pUIInfo - Pointer to UIINFO structure

Return Value:

    Pointer to a copy of the default font substitution table
    NULL if there is an error

--*/

{
    PTSTR   ptstrDefault, ptstrTable = NULL;
    DWORD   dwSize;

    //
    // Make a copy of the default font substitution table
    //

    if ((ptstrDefault = OFFSET_TO_POINTER(pUIInfo->pubResourceData, pUIInfo->loFontSubstTable)) &&
        (dwSize = pUIInfo->dwFontSubCount) &&
        (ptstrTable = MemAlloc(dwSize)))
    {
        ASSERT(BVerifyMultiSZPair(ptstrDefault, dwSize));
        CopyMemory(ptstrTable, ptstrDefault, dwSize);
    }

    return ptstrTable;
}



VOID
VConvertOptSelectArray(
    PRAWBINARYDATA  pRawData,
    POPTSELECT      pNt5Options,
    DWORD           dwNt5MaxCount,
    PBYTE           pubNt4Options,
    DWORD           dwNt4MaxCount,
    INT             iMode
    )

/*++

Routine Description:

    Convert NT4 feature/option selections to NT5 format

Arguments:

    pRawData - Points to raw binary printer description data
    pNt5Options - Points to NT5 feature/option selection array
    pNt4Options - Points to NT4 feature/option selection array
    iMode - Convert doc- or printer-sticky options?

Return Value:

    NONE

--*/

{
    PPPDDATA    pPpdData;
    PBYTE       pubNt4Mapping;
    DWORD       dwNt5Index, dwNt5Offset, dwCount;
    DWORD       dwNt4Index, dwNt4Offset;

    pPpdData = GET_DRIVER_INFO_FROM_INFOHEADER((PINFOHEADER) pRawData);

    ASSERT(pPpdData != NULL);

    //
    // Determine whether we're converting doc-sticky or
    // printer-sticky feature selections.
    //

    if (iMode == MODE_DOCUMENT_STICKY)
    {
        dwCount = pRawData->dwDocumentFeatures;
        dwNt5Offset = dwNt4Offset = 0;
    }
    else
    {
        dwCount = pRawData->dwPrinterFeatures;
        dwNt5Offset = pRawData->dwDocumentFeatures;
        dwNt4Offset = pPpdData->dwNt4DocFeatures;
    }

    //
    // Get a pointer to the NT4-NT5 feature index mapping table
    //

    pubNt4Mapping = OFFSET_TO_POINTER(pRawData, pPpdData->Nt4Mapping.loOffset);

    ASSERT(pubNt4Mapping != NULL);

    ASSERT(pPpdData->Nt4Mapping.dwCount ==
           pRawData->dwDocumentFeatures + pRawData->dwPrinterFeatures);

    //
    // Convert the feature option selection array
    //

    for (dwNt5Index=0; dwNt5Index < dwCount; dwNt5Index++)
    {
        dwNt4Index = pubNt4Mapping[dwNt5Index + dwNt5Offset] - dwNt4Offset;

        if (dwNt4Index < dwNt4MaxCount && pubNt4Options[dwNt4Index] != OPTION_INDEX_ANY)
            pNt5Options[dwNt5Index].ubCurOptIndex = pubNt4Options[dwNt4Index];
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\parsers\ppd\ppdkwd.c ===
/*++

Copyright (c) 1996-1997  Microsoft Corporation

Module Name:

    ppdkwd.c

Abstract:

    Functions for interpreting the semantics elements of a PPD file

Environment:

    PostScript driver, PPD parser

Revision History:

    09/30/96 -davidx-
        Cleaner handling of ManualFeed and AutoSelect feature.

    08/20/96 -davidx-
        Common coding style for NT 5.0 drivers.

    03/26/96 -davidx-
        Created it.

--*/

#include "lib.h"
#include "ppd.h"
#include "ppdparse.h"
#include <math.h>

//
// Data structure for representing entries in a keyword table
//

typedef PPDERROR (*KWDPROC)(PPARSERDATA);

typedef struct _KWDENTRY {

    PCSTR   pstrKeyword;        // keyword name
    KWDPROC pfnProc;            // keyword handler function
    DWORD   dwFlags;            // misc. flag bits

} KWDENTRY, *PKWDENTRY;

//
// Constants for KWDENTRY.flags field. The low order byte is used to indicate value types.
//

#define REQ_OPTION      0x0100
#define ALLOW_MULTI     0x0200
#define ALLOW_HEX       0x0400
#define DEFAULT_PROC    0x0800

#define INVOCA_VALUE    (VALUETYPE_QUOTED | VALUETYPE_SYMBOL)
#define QUOTED_VALUE    (VALUETYPE_QUOTED | ALLOW_HEX)
#define QUOTED_NOHEX    VALUETYPE_QUOTED
#define STRING_VALUE    VALUETYPE_STRING

#define GENERIC_ENTRY(featureId)    ((featureId) << 16)

//
// Give a warning when there are duplicate entries for the same option
//

#define WARN_DUPLICATE() \
        TERSE(("%ws: Duplicate entries of '*%s %s' on line %d\n", \
               pParserData->pFile->ptstrFileName, \
               pParserData->achKeyword, \
               pParserData->achOption, \
               pParserData->pFile->iLineNumber))

//
// Default keyword prefix string
//

#define HAS_DEFAULT_PREFIX(pstr) \
        (strncmp((pstr), gstrDefault, strlen(gstrDefault)) == EQUAL_STRING)

//
// Determine whether a string starts with JCL prefix
//

#define HAS_JCL_PREFIX(pstr) (strncmp((pstr), "JCL", 3) == EQUAL_STRING)

//
// Forward declaration of local functions
//

PPDERROR IVerifyValueType(PPARSERDATA, DWORD);
PPDERROR IGenericOptionProc(PPARSERDATA, PFEATUREOBJ);
PPDERROR IGenericDefaultProc(PPARSERDATA, PFEATUREOBJ);
PPDERROR IGenericQueryProc(PPARSERDATA, PFEATUREOBJ);
PFEATUREOBJ PCreateFeatureItem(PPARSERDATA, DWORD);
PKWDENTRY PSearchKeywordTable(PPARSERDATA, PSTR, PINT);



PPDERROR
IInterpretEntry(
    PPARSERDATA pParserData
    )

/*++

Routine Description:

    Interpret an entry parsed from a printer description file

Arguments:

    pParserData - Points to parser data structure

Return Value:

    Status code

--*/

{
    PSTR        pstrKeyword, pstrRealKeyword;
    PPDERROR    iStatus;
    PKWDENTRY   pKwdEntry;
    INT         iIndex;
    BOOL        bQuery, bDefault;

    //
    // Get a pointer to the keyword string and look for
    // *? and *Default prefix in front of the keyword.
    //

    pstrRealKeyword = pstrKeyword = pParserData->achKeyword;
    bQuery = bDefault = FALSE;

    // NOTE: We don't have any use for query entries so don't parse them here.
    // This helps us somewhat to preserve the feature index from NT4.

    if (FALSE && *pstrKeyword == QUERY_CHAR)
    {
        bQuery = TRUE;
        pstrRealKeyword++;
    }
    else if (HAS_DEFAULT_PREFIX(pstrKeyword))
    {
        bDefault = TRUE;
        pstrRealKeyword += strlen(gstrDefault);
    }

    //
    // Set up a convenient pointer to the entry value
    //

    pParserData->pstrValue = (PSTR) pParserData->Value.pbuf;

    //
    // If we're within an OpenUI/CloseUI pair and the keyword
    // in the current entry matches what's in OpenUI, then we
    // will handle the current entry using a generic procedure.
    //

    if (pParserData->pOpenFeature &&
        pParserData->pOpenFeature->dwFeatureID == GID_UNKNOWN &&
        strcmp(pstrRealKeyword, pParserData->pOpenFeature->pstrName) == EQUAL_STRING)
    {
        pKwdEntry = NULL;
    }
    else
    {
        //
        // Find out if the keyword has built-in support
        //

        pKwdEntry = PSearchKeywordTable(pParserData, pstrRealKeyword, &iIndex);

        //
        // For *Default keywords, if we failed to find the keyword without
        // the prefix, try it again with the prefix.
        //

        if (bDefault &&
            (pKwdEntry == NULL || pKwdEntry->pfnProc != NULL) &&
            (pKwdEntry = PSearchKeywordTable(pParserData, pstrKeyword, &iIndex)))
        {
            bDefault = FALSE;
        }

        //
        // Ignore unsupported keywords
        //

        if ((pKwdEntry == NULL) ||
            ((bQuery || bDefault) && (pKwdEntry->pfnProc != NULL)))
        {
            VERBOSE(("Keyword not supported: *%s\n", pstrKeyword));
            return PPDERR_NONE;
        }
    }

    //
    // Determine if the entry should be handle by the generic procedure
    //

    if (pKwdEntry == NULL || pKwdEntry->pfnProc == NULL)
    {
        PFEATUREOBJ pFeature;
        DWORD       dwValueType;
        PPDERROR    (*pfnGenericProc)(PPARSERDATA, PFEATUREOBJ);

        //
        // Make sure the value type matches what's expected
        //

        if (bQuery)
        {
            pfnGenericProc = IGenericQueryProc;
            dwValueType = INVOCA_VALUE;
        }
        else if (bDefault)
        {
            pfnGenericProc = IGenericDefaultProc;
            dwValueType = STRING_VALUE;
        }
        else
        {
            pfnGenericProc = IGenericOptionProc;
            dwValueType = INVOCA_VALUE | REQ_OPTION;
        }

        if ((iStatus = IVerifyValueType(pParserData, dwValueType)) != PPDERR_NONE)
            return iStatus;

        //
        // Call the appropriate generic procedure
        //

        pFeature = (pKwdEntry == NULL) ?
                        pParserData->pOpenFeature :
                        PCreateFeatureItem(pParserData, HIWORD(pKwdEntry->dwFlags));

        return pfnGenericProc(pParserData, pFeature);
    }
    else
    {
        //
        // Screen out duplicate keyword entries
        //

        if (! (pKwdEntry->dwFlags & (ALLOW_MULTI|REQ_OPTION)))
        {
            if (pParserData->pubKeywordCounts[iIndex])
            {
                WARN_DUPLICATE();
                return PPDERR_NONE;
            }

            pParserData->pubKeywordCounts[iIndex]++;
        }

        //
        // Make sure the value type matches what's expected
        // Take care of embedded hexdecimal strings if necessary
        //

        if ((iStatus = IVerifyValueType(pParserData, pKwdEntry->dwFlags)) != PPDERR_NONE)
            return iStatus;

        //
        // Invoke the specific procedure to handle built-in keywords
        //

        return (pKwdEntry->pfnProc)(pParserData);
    }
}



PPDERROR
IVerifyValueType(
    PPARSERDATA pParserData,
    DWORD       dwExpectedType
    )

/*++

Routine Description:

    Verify the value type of the current entry matches what's expected

Arguments:

    pParserData - Points to parser data structure
    dwExpectedType - Expected value type

Return Value:

    Status code

--*/

{
    DWORD   dwValueType;

    //
    // Check for following syntax error conditions:
    // 1. The entry requires an option keyword but no option keyword is present
    // 2. The entry doesn't require an option keyword but an option keyword is present
    //

    if ((dwExpectedType & REQ_OPTION) &&
        IS_BUFFER_EMPTY(&pParserData->Option))
    {
        return ISyntaxError(pParserData->pFile, "Missing option keyword");
    }

    if (! (dwExpectedType & REQ_OPTION) &&
        ! IS_BUFFER_EMPTY(&pParserData->Option))
    {
        return ISyntaxError(pParserData->pFile, "Extra option keyword");
    }

    //
    // Tolerate the following syntax error conditions:
    // 1. The entry requires a quoted value but a string value is provided.
    // 2. The entry requires a string value but a quoted value is provided.
    //

    switch (dwValueType = pParserData->dwValueType)
    {
    case VALUETYPE_STRING:

        if (dwExpectedType & VALUETYPE_QUOTED)
        {
            TERSE(("%ws: Expect QuotedValue instead of StringValue on line %d\n",
                   pParserData->pFile->ptstrFileName,
                   pParserData->pFile->iLineNumber));

            dwValueType = VALUETYPE_QUOTED;
        }
        break;

    case VALUETYPE_QUOTED:

        if (dwExpectedType & VALUETYPE_STRING)
        {
            TERSE(("%ws: Expect StringValue instead of QuotedValue on line %d\n",
                   pParserData->pFile->ptstrFileName,
                   pParserData->pFile->iLineNumber));

            if (IS_BUFFER_EMPTY(&pParserData->Value))
                return ISyntaxError(pParserData->pFile, "Empty string value");

            dwValueType = VALUETYPE_STRING;
        }
        break;
    }

    //
    // Return syntax error if the provided value type doesn't match what's expected
    //

    if ((dwExpectedType & dwValueType) == 0)
        return ISyntaxError(pParserData->pFile, "Value type mismatch");

    //
    // If the value field is a quoted string and one of the following conditions
    // is true, then we need to process any embedded hexdecimal strings within
    // the quoted string:
    // 1. The entry expects a QuotedValue.
    // 2. The entry expects an InvocationValue and appears inside JCLOpenUI/JCLCloseUI
    //

    if (dwValueType == VALUETYPE_QUOTED)
    {
        if ((dwExpectedType & ALLOW_HEX) ||
            ((dwExpectedType & VALUETYPE_MASK) == INVOCA_VALUE && pParserData->bJclFeature))
        {
            if (! BConvertHexString(&pParserData->Value))
                return ISyntaxError(pParserData->pFile, "Invalid embedded hexdecimal string");
        }
        else if (! BIs7BitAscii(pParserData->pstrValue))
        {
            //
            // Only allow 7-bit ASCII characters inside invocation string
            //

            return ISyntaxError(pParserData->pFile, "Non-printable ASCII character");
        }
    }

    return PPDERR_NONE;
}



BOOL
BGetIntegerFromString(
    PSTR   *ppstr,
    LONG   *plValue
    )

/*++

Routine Description:

    Parse an unsigned decimal integer value from a character string

Arguments:

    ppstr - Points to a string pointer. On entry, it contains a pointer
        to the beginning of the number string. On exit, it points to
        the first non-space character after the number string.
    plValue - Points to a variable for storing parsed number

Return Value:

    TRUE if a number is successfully parsed, FALSE if there is an error

--*/

{
    LONG    lValue;
    PSTR    pstr = *ppstr;
    BOOL    bNegative = FALSE;

    //
    // Skip any leading space characters and
    // look for the sign character (if any)
    //

    while (IS_SPACE(*pstr))
        pstr++;

    if (*pstr == '-')
    {
        bNegative = TRUE;
        pstr++;
    }

    if (! IS_DIGIT(*pstr))
    {
        TERSE(("Invalid integer number: %s\n", pstr));
        return FALSE;
    }

    //
    // NOTE: Overflow conditions are ignored.
    //

    lValue = 0;

    while (IS_DIGIT(*pstr))
        lValue = lValue * 10 + (*pstr++ - '0');

    //
    // Skip any trailing space characters
    //

    while (IS_SPACE(*pstr))
        pstr++;

    *ppstr = pstr;
    *plValue = bNegative ? -lValue : lValue;
    return TRUE;
}



BOOL
BGetFloatFromString(
    PSTR   *ppstr,
    PLONG   plValue,
    INT     iType
    )

/*++

Routine Description:

    Parse an unsigned floating-point number from a character string

Arguments:

    ppstr - Points to a string pointer. On entry, it contains a pointer
        to the beginning of the number string. On exit, it points to
        the first non-space character after the number string.
    plValue - Points to a variable for storing the parsed number
    iType - How to convert the floating-point number before returning
            FLTYPE_FIX - convert it to 24.8 format fixed-point number
            FLTYPE_INT - convert it to integer
            FLTYPE_POINT - convert it from point to micron
            FLTYPE_POINT_ROUNDUP - round it up and convert it from point to micron
            FLTYPE_POINT_ROUNDDOWN - round it down and convert it from point to micron

Return Value:

    TRUE if successful, FALSE if there is an error

--*/

{
    double  value, scale;
    PSTR    pstr = *ppstr;
    BOOL    bNegative = FALSE, bFraction = FALSE;

    //
    // Skip any leading space characters and
    // look for the sign character (if any)
    //

    while (IS_SPACE(*pstr))
        pstr++;

    if (*pstr == '-')
    {
        bNegative = TRUE;
        pstr++;
    }

    if (!IS_DIGIT(*pstr) && *pstr != '.')
    {
        TERSE(("Invalid floating-point number\n"));
        return FALSE;
    }

    //
    // Integer portion
    //

    value = 0.0;

    while (IS_DIGIT(*pstr))
        value = value * 10.0 + (*pstr++ - '0');

    //
    // Fractional portion
    //

    if (*pstr == '.')
    {
        bFraction = TRUE;
        pstr++;

        if (! IS_DIGIT(*pstr))
        {
            TERSE(("Invalid floating-point number\n"));
            return FALSE;
        }

        scale = 0.1;

        while (IS_DIGIT(*pstr))
        {
            value += scale * (*pstr++ - '0');
            scale *= 0.1;
        }
    }

    //
    // Skip any trailing space characters
    //

    while (IS_SPACE(*pstr))
        pstr++;

    //
    // Perform requested round up or round down only if
    // fractional portion is present.
    //

    if (bFraction)
    {
        if (iType == FLTYPE_POINT_ROUNDUP)
            value = ceil(value);
        else if (iType == FLTYPE_POINT_ROUNDDOWN)
            value = (LONG)value;
    }

    //
    // Convert the return value to the specified format
    //

    switch (iType)
    {
    case FLTYPE_POINT:
    case FLTYPE_POINT_ROUNDUP:
    case FLTYPE_POINT_ROUNDDOWN:

        value = (value * 25400.0) / 72.0;
        break;

    case FLTYPE_FIX:

        value *= FIX_24_8_SCALE;
        break;

    default:

        ASSERT(iType == FLTYPE_INT);
        break;
    }

    //
    // Guard against overflow conditions
    //

    if (value >= MAX_LONG)
    {
        TERSE(("Floating-point number overflow\n"));
        return FALSE;
    }

    *ppstr = pstr;
    *plValue = (LONG) (value + 0.5);

    if (bNegative)
    {
        TERSE(("Negative number treated as 0\n"));
        *plValue = 0;
    }

    return TRUE;
}



BOOL
BSearchStrTable(
    PCSTRTABLE  pTable,
    PSTR        pstrKeyword,
    DWORD      *pdwValue
    )

/*++

Routine Description:

    Search for a keyword from a string table

Arguments:

    pTable - Specifies the string table to be search
    pstrKeyword - Specifies the keyword we're interested in
    pdwValue - Points to a variable for storing value corresponding to the given keyword

Return Value:

    TRUE if the given keyword is found in the table, FALSE otherwise

--*/

{
    ASSERT(pstrKeyword != NULL);

    while (pTable->pstrKeyword != NULL &&
           strcmp(pTable->pstrKeyword, pstrKeyword) != EQUAL_STRING)
    {
        pTable++;
    }

    *pdwValue = pTable->dwValue;
    return (pTable->pstrKeyword != NULL);
}



PSTR
PstrParseString(
    PPARSERDATA pParserData,
    PBUFOBJ     pBufObj
    )

/*++

Routine Description:

    Duplicate a character string from a buffer object

Arguments:

    pParserData - Points to parser data structure
    pBufObj - Specifies the buffer object containing the character string to be duplicated

Return Value:

    Pointer to a copy of the specified string
    NULL if there is an error

--*/

{
    PSTR    pstr;

    ASSERT(! IS_BUFFER_EMPTY(pBufObj));

    if (pstr = ALLOC_PARSER_MEM(pParserData, pBufObj->dwSize + 1))
        CopyMemory(pstr, pBufObj->pbuf, pBufObj->dwSize + 1);
    else
        ERR(("Memory allocation failed: %d\n", GetLastError()));

    return pstr;
}



PPDERROR
IParseInvocation(
    PPARSERDATA pParserData,
    PINVOCOBJ   pInvocation
    )

/*++

Routine Description:

    Parse the content of value buffer to an invocation string

Arguments:

    pParserData - Points to parser data structure
    pInvocation - Specifies a buffer for storing the parsed invocation string

Return Value:

    Status code

--*/

{
    ASSERT(pInvocation->pvData == NULL);

    //
    // Determine if the invocation is a quoted string or a symbol reference.
    // In case of symbol reference, we save the name of the symbol in pvData
    // field (including the leading ^ character).
    //

    if (pParserData->dwValueType == VALUETYPE_SYMBOL)
    {
        PSTR    pstrSymbolName;

        if (! (pstrSymbolName = PstrParseString(pParserData, &pParserData->Value)))
            return PPDERR_MEMORY;

        pInvocation->pvData = pstrSymbolName;
        MARK_SYMBOL_INVOC(pInvocation);
    }
    else
    {
        PVOID   pvData;

        if (! (pvData = ALLOC_PARSER_MEM(pParserData, pParserData->Value.dwSize + 1)))
        {
            ERR(("Memory allocation failed\n"));
            return PPDERR_MEMORY;
        }

        pInvocation->pvData = pvData;
        pInvocation->dwLength = pParserData->Value.dwSize;
        ASSERT(! IS_SYMBOL_INVOC(pInvocation));

        CopyMemory(pvData, pParserData->Value.pbuf, pInvocation->dwLength + 1);
    }

    return PPDERR_NONE;
}



PPDERROR
IParseInteger(
    PPARSERDATA pParserData,
    PDWORD      pdwValue
    )

/*++

Routine Description:

    Intrepret the value field of an entry as unsigned integer

Arguments:

    pParserData - Points to parser data structure
    pdwValue - Points to a variable for storing parsed integer value

Return Value:

    Status code

--*/

{
    PSTR    pstr = pParserData->pstrValue;
    LONG    lValue;

    if (BGetIntegerFromString(&pstr, &lValue))
    {
        if (lValue >= 0)
        {
            *pdwValue = lValue;
            return PPDERR_NONE;

        } else
            TERSE(("Negative integer value not allowed: %s.\n", pParserData->pstrValue));
    }

    *pdwValue = 0;
    return PPDERR_SYNTAX;
}



PPDERROR
IParseBoolean(
    PPARSERDATA pParserData,
    DWORD      *pdwValue
    )

/*++

Routine Description:

    Interpret the value of an entry as a boolen, i.e. True or False

Arguments:

    pParserData - Points to parser data structure
    pdwValue - Points to a variable for storing the parsed boolean value

Return Value:

    Status code

--*/

{
    static const STRTABLE BooleanStrs[] =
    {
        gstrTrueKwd,    TRUE,
        gstrFalseKwd,   FALSE,
        NULL,           FALSE
    };

    if (! BSearchStrTable(BooleanStrs, pParserData->pstrValue, pdwValue))
        return ISyntaxError(pParserData->pFile, "Invalid boolean constant");

    return PPDERR_NONE;
}



BOOL
BFindNextWord(
    PSTR   *ppstr,
    PSTR    pstrWord
    )

/*++

Routine Description:

    Find the next word in a character string. Words are separated by spaces.

Arguments:

    ppstr - Points to a string pointer. On entry, it contains a pointer
        to the beginning of the word string. On exit, it points to
        the first non-space character after the word string.
    pstrWord - Points to a buffer for storing characters from the next word
        The size of this buffer must be at least MAX_WORD_LEN characters

Return Value:

    TRUE if next word is found, FALSE otherwise

--*/

{
    PSTR    pstr = *ppstr;

    pstrWord[0] = NUL;

    //
    // Skip any leading spaces
    //

    while (IS_SPACE(*pstr))
        pstr++;

    if (*pstr != NUL)
    {
        PSTR    pstrStart;
        INT     iWordLen;

        //
        // Go to the end of the word
        //

        pstrStart = pstr;

        while (*pstr && !IS_SPACE(*pstr))
            pstr++;

        //
        // Copy the word into the specified buffer
        //

        if ((iWordLen = (INT)(pstr - pstrStart)) < MAX_WORD_LEN)
        {
            CopyMemory(pstrWord, pstrStart, iWordLen);
            pstrWord[iWordLen] = NUL;
        }

        //
        // Skip to the next non-space character
        //

        while (IS_SPACE(*pstr))
            pstr++;
    }

    *ppstr = pstr;
    return (*pstrWord != NUL);
}



PPDERROR
IParseVersionNumber(
    PPARSERDATA pParserData,
    PDWORD      pdwVersion
    )

/*++

Routine Description:

    Parse a version number. The format of a version number is Version[.Revision]
    where both Version and Revision are integers.

Arguments:

    pParserData - Points to parser data structure
    pdwVersion - Points to a variable for storing the parsed version number

Return Value:

    Status code

--*/

{
    PSTR        pstr;
    LONG        lVersion, lRevision = 0;

    //
    // Parse the major version number followed by minor revision number
    //

    pstr = pParserData->pstrValue;

    if (! BGetIntegerFromString(&pstr, &lVersion))
        return ISyntaxError(pParserData->pFile, "Invalid version number");

    if (*pstr == '.')
    {
        pstr++;

        if (! BGetIntegerFromString(&pstr, &lRevision))
            return ISyntaxError(pParserData->pFile, "Invalid revision number");
    }

    //
    // High-order word contains version number and
    // low-order word contains revision number
    //

    if (lVersion < 0  || lVersion > MAX_WORD ||
        lRevision < 0 || lRevision > MAX_WORD)
    {
        return ISyntaxError(pParserData->pFile, "Version number out-of-range");
    }

    *pdwVersion = (lVersion << 16) | lRevision;
    return PPDERR_NONE;
}



PPDERROR
IParseXlation(
    PPARSERDATA pParserData,
    PINVOCOBJ   pXlation
    )

/*++

Routine Description:

    Parse the information in the translation string field to an INVOCOBJ

Arguments:

    pParserData - Points to parser data structure
    pXlation - Returns information about parsed translation string

Return Value:

    Status code

--*/

{
    PBUFOBJ pBufObj = &pParserData->Xlation;

    //
    // Allocate memory to hold the translation string (plus a null terminator)
    //

    pXlation->pvData = ALLOC_PARSER_MEM(pParserData, pBufObj->dwSize + 1);

    if (pXlation->pvData == NULL)
    {
        ERR(("Memory allocation failed\n"));
        return PPDERR_MEMORY;
    }

    pXlation->dwLength = pBufObj->dwSize;
    ASSERT(! IS_SYMBOL_INVOC(pXlation));
    CopyMemory(pXlation->pvData, pBufObj->pbuf, pBufObj->dwSize);

    return PPDERR_NONE;
}



PCSTR
PstrStripKeywordChar(
    PCSTR   pstrKeyword
    )

/*++

Routine Description:

    Strip off the keyword prefix character from the input string

Arguments:

    pstrKeyword - Points to a string prefixed by the keyword character

Return Value:

    Pointer to the keyword string after the keyword character is stripped
    NULL if the keyword string is empty

--*/

{
    if (IS_KEYWORD_CHAR(*pstrKeyword))
        pstrKeyword++;

    return *pstrKeyword ? pstrKeyword : NULL;
}



PVOID
PvCreateListItem(
    PPARSERDATA pParserData,
    PLISTOBJ   *ppList,
    DWORD       dwItemSize,
    PSTR        pstrListTag
    )

/*++

Routine Description:

    Create a new item in the specified linked-list
    Make sure no existing item has the same name

Arguments:

    pParserData - Points to parser data structure
    ppList - Specifies the linked-list
    dwItemSize - Linked-list item size
    pListTag - Specifies the name of the linked-list (for debugging purpose)

Return Value:

    Pointer to newly created linked-list item
    NULL if there is an error

--*/

{
    PLISTOBJ    pItem;
    PSTR        pstrItemName;

    //
    // Check if the item appeared in the list already
    // Create a new item data structure if not
    //

    pItem = PvFindListItem(*ppList, pParserData->Option.pbuf, NULL);

    if (pItem != NULL)
    {
        if (pstrListTag)
            TERSE(("%s %s redefined\n", pstrListTag, pItem->pstrName));
    }
    else
    {
        if (! (pItem = ALLOC_PARSER_MEM(pParserData, dwItemSize)) ||
            ! (pstrItemName = PstrParseString(pParserData, &pParserData->Option)))
        {
            ERR(("Memory allocation failed: %d\n", GetLastError()));
            return NULL;
        }

        pItem->pstrName = pstrItemName;
        pItem->pNext = NULL;

        //
        // Put the newly created item at the end of the linked-list
        //

        while (*ppList != NULL)
            ppList = (PLISTOBJ *) &((*ppList)->pNext);

        *ppList = pItem;
    }

    return pItem;
}



PFEATUREOBJ
PCreateFeatureItem(
    PPARSERDATA pParserData,
    DWORD       dwFeatureID
    )

/*++

Routine Description:

    Create a new printer feature structure or find an existing one

Arguments:

    pParserData - Points to parser data structure
    dwFeatureID - Printer feature identifier

Return Value:

    Pointer to a newly created or an existing printer feature structure
    NULL if there is an error

--*/

{
    static struct {

        PCSTR   pstrKeyword;
        DWORD   dwFeatureID;
        DWORD   dwOptionSize;

    } FeatureInfo[] = {

        gstrPageSizeKwd,  GID_PAGESIZE,     sizeof(PAPEROBJ),
        "PageRegion",     GID_PAGEREGION,   sizeof(OPTIONOBJ),
        "Duplex",         GID_DUPLEX,       sizeof(OPTIONOBJ),
        gstrInputSlotKwd, GID_INPUTSLOT,    sizeof(TRAYOBJ),
        "Resolution",     GID_RESOLUTION,   sizeof(RESOBJ),
        "JCLResolution",  GID_RESOLUTION,   sizeof(RESOBJ),
        "OutputBin",      GID_OUTPUTBIN,    sizeof(BINOBJ),
        "MediaType",      GID_MEDIATYPE,    sizeof(OPTIONOBJ),
        "Collate",        GID_COLLATE,      sizeof(OPTIONOBJ),
        "InstalledMemory",GID_MEMOPTION,    sizeof(MEMOBJ),
        "LeadingEdge",    GID_LEADINGEDGE,  sizeof(OPTIONOBJ),
        "UseHWMargins",   GID_USEHWMARGINS, sizeof(OPTIONOBJ),
        NULL,             GID_UNKNOWN,      sizeof(OPTIONOBJ)
    };

    PFEATUREOBJ pFeature;
    PCSTR       pstrKeyword;
    BUFOBJ      SavedBuffer;
    INT         iIndex = 0;

    if (dwFeatureID == GID_UNKNOWN)
    {
        //
        // Given a feature name, first find out if it refers to
        // one of the predefined features
        //

        pstrKeyword = PstrStripKeywordChar(pParserData->achOption);
        ASSERT(pstrKeyword != NULL);

        while (FeatureInfo[iIndex].pstrKeyword &&
               strcmp(FeatureInfo[iIndex].pstrKeyword, pstrKeyword) != EQUAL_STRING)
        {
            iIndex++;
        }

        if (FeatureInfo[iIndex].pstrKeyword)
            pParserData->aubOpenUIFeature[FeatureInfo[iIndex].dwFeatureID] = 1;
    }
    else
    {
        //
        // We're given a predefined feature identifier.
        // Map to its corresponding feature name.
        //

        while (FeatureInfo[iIndex].pstrKeyword &&
               dwFeatureID != FeatureInfo[iIndex].dwFeatureID)
        {
            iIndex++;
        }

        pstrKeyword = FeatureInfo[iIndex].pstrKeyword;
        ASSERT(pstrKeyword != NULL);
    }

    //
    // If we're dealing with a predefined feature, the first search the current
    // list of printer features based on the predefined feature identifier.
    //

    pFeature = NULL;

    if (FeatureInfo[iIndex].dwFeatureID != GID_UNKNOWN)
    {
        for (pFeature = pParserData->pFeatures;
             pFeature && pFeature->dwFeatureID != FeatureInfo[iIndex].dwFeatureID;
             pFeature = pFeature->pNext)
        {
        }
    }

    //
    // Create a new printer feature item or find an existing printer feature item
    // based on the feature name.
    //

    if (pFeature == NULL)
    {
        SavedBuffer = pParserData->Option;
        pParserData->Option.pbuf = (PBYTE) pstrKeyword;
        pParserData->Option.dwSize = strlen(pstrKeyword);

        pFeature = PvCreateListItem(pParserData,
                                    (PLISTOBJ *) &pParserData->pFeatures,
                                    sizeof(FEATUREOBJ),
                                    NULL);

        pParserData->Option = SavedBuffer;
    }

    if (pFeature)
    {
        //
        // Parse the translation string for the feature name
        //

        if (dwFeatureID == GID_UNKNOWN &&
            ! IS_BUFFER_EMPTY(&pParserData->Xlation) &&
            ! pFeature->Translation.pvData &&
            IParseXlation(pParserData, &pFeature->Translation) != PPDERR_NONE)
        {
            ERR(("Failed to parse feature name translation string\n"));
            return NULL;
        }

        if (pFeature->dwOptionSize == 0)
        {
            //
            // Store information about newly created feature item
            //

            pFeature->dwOptionSize = FeatureInfo[iIndex].dwOptionSize;
            pFeature->dwFeatureID = FeatureInfo[iIndex].dwFeatureID;

            //
            // All predefined features are doc-sticky except for InstalledMemory/VMOption
            //

            if (pFeature->dwFeatureID == GID_MEMOPTION ||
                pFeature->dwFeatureID == GID_UNKNOWN && pParserData->bInstallableGroup)
            {
                pFeature->bInstallable = TRUE;
            }
        }
    }
    else
    {
        ERR(("Couldn't create printer feature item for: %s\n", pstrKeyword));
    }

    return pFeature;
}



PVOID
PvCreateXlatedItem(
    PPARSERDATA pParserData,
    PVOID       ppList,
    DWORD       dwItemSize
    )

/*++

Routine Description:

    Create a feature option item and parse the associated translation string

Arguments:

    pParserData - Points to parser data structure
    ppList - Points to the list of feature option items
    dwItemSize - Size of a feature option item

Return Value:

    Pointer to newly created feature option item
    NULL if there is an error

--*/

{
    POPTIONOBJ  pOption;

    if (! (pOption = PvCreateListItem(pParserData, ppList, dwItemSize, NULL)) ||
        (! IS_BUFFER_EMPTY(&pParserData->Xlation) &&
         ! pOption->Translation.pvData &&
         IParseXlation(pParserData, &pOption->Translation) != PPDERR_NONE))
    {
        ERR(("Couldn't process entry: *%s %s\n",
             pParserData->achKeyword,
             pParserData->achOption));

        return NULL;
    }

    return pOption;
}



PVOID
PvCreateOptionItem(
    PPARSERDATA pParserData,
    DWORD       dwFeatureID
    )

/*++

Routine Description:

    Create a feature option item for a predefined printer feature

Arguments:

    pParserData - Points to parser data structure
    dwFeatureID - Specifies a predefined feature identifier

Return Value:

    Pointer to an existing feature option item or a newly created one if none exists
    NULL if there is an error

--*/

{
    PFEATUREOBJ pFeature;

    ASSERT(dwFeatureID != GID_UNKNOWN);

    if (! (pFeature = PCreateFeatureItem(pParserData, dwFeatureID)))
        return NULL;

    return PvCreateXlatedItem(pParserData, &pFeature->pOptions, pFeature->dwOptionSize);
}



INT
ICountFeatureList(
    PFEATUREOBJ pFeature,
    BOOL        bInstallable
    )

{
    INT i = 0;

    //
    // Count the number of features of the specified type
    //

    while (pFeature != NULL)
    {
        if (pFeature->bInstallable == bInstallable)
            i++;

        pFeature = pFeature->pNext;
    }

    return i;
}



PPDERROR
IGenericOptionProc(
    PPARSERDATA pParserData,
    PFEATUREOBJ pFeature
    )

/*++

Routine Description:

    Function for handling a generic feature option entry

Arguments:

    pParserData - Points to parser data structure
    pFeature - Points to feature data structure

Return Value:

    Status code

--*/

{
    POPTIONOBJ  pOption;

    //
    // Handle special case
    //

    if (pFeature == NULL)
        return PPDERR_MEMORY;

    //
    // Create a feature option item and parse the option name and translation string
    //

    if (! (pOption = PvCreateXlatedItem(pParserData, &pFeature->pOptions, pFeature->dwOptionSize)))
        return PPDERR_MEMORY;

    if (pOption->Invocation.pvData)
    {
        WARN_DUPLICATE();
        return PPDERR_NONE;
    }

    //
    // Parse the invocation string
    //

    return IParseInvocation(pParserData, &pOption->Invocation);
}



PPDERROR
IGenericDefaultProc(
    PPARSERDATA pParserData,
    PFEATUREOBJ pFeature
    )

/*++

Routine Description:

    Function for handling a generic default option entry

Arguments:

    pParserData - Points to parser data structure
    pFeature - Points to feature data structure

Return Value:

    Status code

--*/

{
    //
    // Check if there is a memory error before this function is called
    //

    if (pFeature == NULL)
        return PPDERR_MEMORY;

    //
    // Watch out for duplicate *Default entries for the same feature
    //

    if (pFeature->pstrDefault)
    {
        WARN_DUPLICATE();
        return PPDERR_NONE;
    }

    //
    // NOTE: Hack to take in account of a bug in NT4 driver.
    // This is used to build up NT4-NT5 feature index mapping.
    //

    if (pFeature->dwFeatureID == GID_MEMOPTION &&
        pParserData->iDefInstallMemIndex < 0)
    {
        pParserData->iDefInstallMemIndex = ICountFeatureList(pParserData->pFeatures, TRUE);
    }

    //
    // Remember the default option keyword
    //

    if (pFeature->pstrDefault = PstrParseString(pParserData, &pParserData->Value))
        return PPDERR_NONE;
    else
        return PPDERR_MEMORY;
}



PPDERROR
IGenericQueryProc(
    PPARSERDATA pParserData,
    PFEATUREOBJ pFeature
    )

/*++

Routine Description:

    Function for handling a generic query invocation entry

Arguments:

    pParserData - Points to parser data structure
    pFeature - Points to feature data structure

Return Value:

    Status code

--*/

{
    //
    // Check if there is a memory error before this function is called
    //

    if (pFeature == NULL)
        return PPDERR_MEMORY;

    //
    // Watch out for duplicate *Default entries for the same feature
    //

    if (pFeature->QueryInvoc.pvData)
    {
        WARN_DUPLICATE();
        return PPDERR_NONE;
    }

    //
    // Parse the query invocation string
    //

    return IParseInvocation(pParserData, &pFeature->QueryInvoc);
}



//
// Functions for handling predefined PPD keywords
//

//
// Specifies the imageable area of a media option
//

PPDERROR
IImageAreaProc(
    PPARSERDATA pParserData
    )

{
    PPAPEROBJ   pOption;
    PSTR        pstr;
    RECT        *pRect;

    if (! (pOption = PvCreateOptionItem(pParserData, GID_PAGESIZE)))
        return PPDERR_MEMORY;

    pRect = &pOption->rcImageArea;

    if (pRect->top > 0 || pRect->right > 0)
    {
        WARN_DUPLICATE();
        return PPDERR_NONE;
    }

    //
    // Parse imageable area: left, bottom, right, top
    //

    pstr = pParserData->pstrValue;

    if (! BGetFloatFromString(&pstr, &pRect->left, FLTYPE_POINT_ROUNDUP) ||
        ! BGetFloatFromString(&pstr, &pRect->bottom, FLTYPE_POINT_ROUNDUP) ||
        ! BGetFloatFromString(&pstr, &pRect->right, FLTYPE_POINT_ROUNDDOWN) ||
        ! BGetFloatFromString(&pstr, &pRect->top, FLTYPE_POINT_ROUNDDOWN) ||
        pRect->left >= pRect->right || pRect->bottom >= pRect->top)
    {
        return ISyntaxError(pParserData->pFile, "Invalid imageable area");
    }

    return PPDERR_NONE;
}

//
// Specifies the paper dimension of a media option
//

PPDERROR
IPaperDimProc(
    PPARSERDATA pParserData
    )

{
    PPAPEROBJ   pOption;
    PSTR        pstr;

    if (! (pOption = PvCreateOptionItem(pParserData, GID_PAGESIZE)))
        return PPDERR_MEMORY;

    if (pOption->szDimension.cx > 0 || pOption->szDimension.cy > 0)
    {
        WARN_DUPLICATE();
        return PPDERR_NONE;
    }

    //
    // Parse paper width and height
    //

    pstr = pParserData->pstrValue;

    if (! BGetFloatFromString(&pstr, &pOption->szDimension.cx, FLTYPE_POINT) ||
        ! BGetFloatFromString(&pstr, &pOption->szDimension.cy, FLTYPE_POINT))
    {
        return ISyntaxError(pParserData->pFile, "Invalid paper dimension");
    }

    return PPDERR_NONE;
}

//
// Interpret PageStackOrder and OutputOrder options
//

BOOL
BParseOutputOrder(
    PSTR    pstr,
    PBOOL   pbValue
    )

{
    static const STRTABLE OutputOrderStrs[] =
    {
        "Normal",   FALSE,
        "Reverse",  TRUE,
        NULL,       FALSE
    };

    DWORD   dwValue;
    BOOL    bResult;

    bResult = BSearchStrTable(OutputOrderStrs, pstr, &dwValue);

    *pbValue = dwValue;
    return bResult;
}

//
// Specifies the page stack order for an output bin
//

PPDERROR
IPageStackOrderProc(
    PPARSERDATA pParserData
    )

{
    PFEATUREOBJ pFeature;
    PBINOBJ     pOutputBin;

    //
    // Have we seen the OutputBin feature yet?
    //

    for (pFeature = pParserData->pFeatures;
         pFeature && pFeature->dwFeatureID != GID_OUTPUTBIN;
         pFeature = pFeature->pNext)
    {
    }

    //
    // If PageStackOrder entry appears before OutputBin feature, ignore it
    //

    if (pFeature == NULL)
    {
        BOOL bReverse;
        if (!BParseOutputOrder(pParserData->pstrValue, &bReverse))
            return ISyntaxError(pParserData->pFile, "Invalid PageStackOrder option");
        if (bReverse)
            TERSE(("%ws: Ignored *PageStackOrder: Reverse on line %d because OutputBin not yet defined\n",
                       pParserData->pFile->ptstrFileName,
                       pParserData->pFile->iLineNumber));

        return PPDERR_NONE;
    }

    //
    // Add an option for OutputBin feature
    //

    pOutputBin = PvCreateXlatedItem(pParserData, &pFeature->pOptions, pFeature->dwOptionSize);

    if (pOutputBin == NULL)
        return PPDERR_MEMORY;

    return BParseOutputOrder(pParserData->pstrValue, &pOutputBin->bReversePrint) ?
                PPDERR_NONE :
                ISyntaxError(pParserData->pFile, "Invalid PageStackOrder option");
}

//
// Specifies the default page output order
// NOTE: This function gets called only if *DefaultOutputOrder
// entry appears outside of OpenUI/CloseUI.
//

PPDERROR
IDefOutputOrderProc(
    PPARSERDATA pParserData
    )

{
    pParserData->bDefOutputOrderSet = BParseOutputOrder(pParserData->pstrValue, &pParserData->bDefReversePrint);

    return pParserData->bDefOutputOrderSet ?
                PPDERR_NONE :
                ISyntaxError(pParserData->pFile, "Invalid DefaultOutputOrder option");
}

//
// Specifies whether an input slot requires page region specification
//

PPDERROR
IReqPageRgnProc(
    PPARSERDATA pParserData
    )

{
    PTRAYOBJ    pOption;
    DWORD       dwValue;

    //
    // NOTE: Hack for doing NT4-NT5 feature index conversion
    //

    if (pParserData->iReqPageRgnIndex < 0)
    {
        PFEATUREOBJ pFeature = pParserData->pFeatures;

        while (pFeature && pFeature->dwFeatureID != GID_INPUTSLOT)
            pFeature = pFeature->pNext;

        if (pFeature == NULL)
            pParserData->iReqPageRgnIndex = ICountFeatureList(pParserData->pFeatures, FALSE);
    }

    //
    // The value should be either True or False
    //

    if (IParseBoolean(pParserData, &dwValue) != PPDERR_NONE)
        return PPDERR_SYNTAX;

    dwValue = dwValue ? REQRGN_TRUE : REQRGN_FALSE;

    //
    // *RequiresPageRegion All: entry has special meaning
    //

    if (strcmp(pParserData->achOption, "All") == EQUAL_STRING)
    {
        if (pParserData->dwReqPageRgn == REQRGN_UNKNOWN)
            pParserData->dwReqPageRgn = dwValue;
        else
            WARN_DUPLICATE();
    }
    else
    {
        if (! (pOption = PvCreateOptionItem(pParserData, GID_INPUTSLOT)))
            return PPDERR_MEMORY;

        if (pOption->dwReqPageRgn == REQRGN_UNKNOWN)
            pOption->dwReqPageRgn = dwValue;
        else
            WARN_DUPLICATE();
    }

    return PPDERR_NONE;
}

//
// Specifies Duplex feature options
//

PPDERROR
IDefaultDuplexProc(
    PPARSERDATA pParserData
    )

{
    return IGenericDefaultProc(pParserData,
                               PCreateFeatureItem(pParserData, GID_DUPLEX));
}

PPDERROR
IDuplexProc(
    PPARSERDATA pParserData
    )

{
    if (strcmp(pParserData->achOption, gstrNoneKwd) != EQUAL_STRING &&
        strcmp(pParserData->achOption, gstrDuplexTumble) != EQUAL_STRING &&
        strcmp(pParserData->achOption, gstrDuplexNoTumble) != EQUAL_STRING)
    {
        return ISyntaxError(pParserData->pFile, "Invalid Duplex option");
    }

    return IGenericOptionProc(pParserData,
                              PCreateFeatureItem(pParserData, GID_DUPLEX));
}

//
// Specifies ManualFeed True/False invocation strings
//

PPDERROR
IDefManualFeedProc(
    PPARSERDATA pParserData
    )

{
    //
    // NOTE: Hack for doing NT4-NT5 feature index conversion
    //

    if (pParserData->iManualFeedIndex < 0)
        pParserData->iManualFeedIndex = ICountFeatureList(pParserData->pFeatures, FALSE);

    return PPDERR_NONE;
}

PPDERROR
IManualFeedProc(
    PPARSERDATA pParserData
    )

{
    POPTIONOBJ  pOption;
    INT         iResult = PPDERR_NONE;

    //
    // NOTE: Hack for doing NT4-NT5 feature index conversion
    //

    if (pParserData->iManualFeedIndex < 0)
        pParserData->iManualFeedIndex = ICountFeatureList(pParserData->pFeatures, FALSE);

    if (strcmp(pParserData->achOption, gstrTrueKwd) == EQUAL_STRING ||
        strcmp(pParserData->achOption, gstrOnKwd) == EQUAL_STRING)
    {
        //
        // The way manual feed is handled in PPD spec is incredibly klugy.
        // Hack here to treat *ManualFeed True as one of the input slot
        // selections so that downstream component can handle it uniformly.
        //

        strcpy(pParserData->achOption, gstrManualFeedKwd);
        pParserData->Option.dwSize = strlen(gstrManualFeedKwd);

        strcpy(pParserData->achXlation, "");
        pParserData->Xlation.dwSize = 0;

        if (! (pOption = PvCreateOptionItem(pParserData, GID_INPUTSLOT)))
        {
            iResult = PPDERR_MEMORY;
        }
        else if (pOption->Invocation.pvData)
        {
            TERSE(("%ws: Duplicate entries of '*ManualFeed True' on line %d\n",
                   pParserData->pFile->ptstrFileName,
                   pParserData->pFile->iLineNumber));
        }
        else
        {
            ((PTRAYOBJ) pOption)->dwTrayIndex = DMBIN_MANUAL;
            iResult = IParseInvocation(pParserData, &pOption->Invocation);
        }
    }
    else if (strcmp(pParserData->achOption, gstrFalseKwd) == EQUAL_STRING ||
             strcmp(pParserData->achOption, gstrNoneKwd) == EQUAL_STRING ||
             strcmp(pParserData->achOption, gstrOffKwd) == EQUAL_STRING)
    {
        //
        // Save *ManualFeed False invocation string separately.
        // It's always emitted before any tray invocation string.
        //

        if (pParserData->ManualFeedFalse.pvData)
        {
            WARN_DUPLICATE();
        }
        else
        {
            iResult = IParseInvocation(pParserData, &pParserData->ManualFeedFalse);
        }
    }
    else
    {
        iResult = ISyntaxError(pParserData->pFile, "Unrecognized ManualFeed option");
    }

    return iResult;
}

//
// Specifies JCLResolution invocation string
//

PPDERROR
IJCLResProc(
    PPARSERDATA pParserData
    )

{
    POPTIONOBJ  pOption;

    if (! (pOption = PvCreateOptionItem(pParserData, GID_RESOLUTION)))
        return PPDERR_MEMORY;

    if (pOption->Invocation.pvData)
    {
        WARN_DUPLICATE();
        return PPDERR_NONE;
    }

    pParserData->dwSetResType = RESTYPE_JCL;
    return IParseInvocation(pParserData, &pOption->Invocation);
}

//
// Specifies the default JCLResolution option
//

PPDERROR
IDefaultJCLResProc(
    PPARSERDATA pParserData
    )

{
    return IGenericDefaultProc(pParserData,
                               PCreateFeatureItem(pParserData, GID_RESOLUTION));
}

//
// Specifies SetResolution invocation string
//

PPDERROR
ISetResProc(
    PPARSERDATA pParserData
    )

{
    POPTIONOBJ  pOption;

    if (! (pOption = PvCreateOptionItem(pParserData, GID_RESOLUTION)))
        return PPDERR_MEMORY;

    if (pOption->Invocation.pvData)
    {
        WARN_DUPLICATE();
        return PPDERR_NONE;
    }

    pParserData->dwSetResType = RESTYPE_EXITSERVER;
    return IParseInvocation(pParserData, &pOption->Invocation);
}

//
// Specifies default halftone screen angle
//

PPDERROR
IScreenAngleProc(
    PPARSERDATA pParserData
    )

{
    PSTR    pstr = pParserData->pstrValue;

    if (! BGetFloatFromString(&pstr, &pParserData->fxScreenAngle, FLTYPE_FIX))
        return ISyntaxError(pParserData->pFile, "Invalid screen angle");

    return PPDERR_NONE;
}

//
// Specifies default halftone screen frequency
//

PPDERROR
IScreenFreqProc(
    PPARSERDATA pParserData
    )

{
    PSTR    pstr = pParserData->pstrValue;

    if (! BGetFloatFromString(&pstr, &pParserData->fxScreenFreq, FLTYPE_FIX) ||
        pParserData->fxScreenFreq <= 0)
    {
        return ISyntaxError(pParserData->pFile, "Invalid screen frequency");
    }
    else
        return PPDERR_NONE;
}

//
// Specifies default halftone screen angle for a resolution option
//

PPDERROR
IResScreenAngleProc(
    PPARSERDATA pParserData
    )

{
    PRESOBJ pOption;
    PSTR    pstr = pParserData->pstrValue;

    if (! (pOption = PvCreateOptionItem(pParserData, GID_RESOLUTION)))
        return PPDERR_MEMORY;

    if (! BGetFloatFromString(&pstr, &pOption->fxScreenAngle, FLTYPE_FIX))
        return ISyntaxError(pParserData->pFile, "Invalid screen angle");

    return PPDERR_NONE;
}

//
// Specifies default halftone screen frequency for a resolution option
//

PPDERROR
IResScreenFreqProc(
    PPARSERDATA pParserData
    )

{
    PRESOBJ pOption;
    PSTR    pstr = pParserData->pstrValue;

    if (! (pOption = PvCreateOptionItem(pParserData, GID_RESOLUTION)))
        return PPDERR_MEMORY;

    if (! BGetFloatFromString(&pstr, &pOption->fxScreenFreq, FLTYPE_FIX) ||
        pOption->fxScreenFreq <= 0)
    {
        return ISyntaxError(pParserData->pFile, "Invalid screen frequency");
    }
    else
        return PPDERR_NONE;
}

//
// Specifies device font information
//

PPDERROR
IFontProc(
    PPARSERDATA pParserData
    )

{
    static const STRTABLE FontStatusStrs[] =
    {
        "ROM",      FONTSTATUS_ROM,
        "Disk",     FONTSTATUS_DISK,
        NULL,       FONTSTATUS_UNKNOWN
    };

    PFONTREC    pFont;
    PSTR        pstr;
    CHAR        achWord[MAX_WORD_LEN];

    //
    // Create a new device font item
    //

    if (! (pFont = PvCreateXlatedItem(pParserData, &pParserData->pFonts, sizeof(FONTREC))))
        return PPDERR_MEMORY;

    if (pFont->pstrEncoding != NULL)
    {
        WARN_DUPLICATE();
        return PPDERR_NONE;
    }

    //
    // encoding
    //

    pstr = pParserData->pstrValue;

    if (! BFindNextWord(&pstr, achWord))
        return ISyntaxError(pParserData->pFile, "Invalid *Font entry");

    if (! (pFont->pstrEncoding = ALLOC_PARSER_MEM(pParserData, strlen(achWord) + 1)))
        return PPDERR_MEMORY;

    strcpy(pFont->pstrEncoding, achWord);

    //
    // version
    //

    (VOID) BFindNextWord(&pstr, achWord);

    {
        PSTR    pstrStart, pstrEnd;

        if (pstrStart = strchr(achWord, '('))
            pstrStart++;
        else
            pstrStart = achWord;

        if (pstrEnd = strrchr(pstrStart, ')'))
            *pstrEnd = NUL;

        if (! (pFont->pstrVersion = ALLOC_PARSER_MEM(pParserData, strlen(pstrStart) + 1)))
            return PPDERR_MEMORY;

        strcpy(pFont->pstrVersion, pstrStart);
    }

    //
    // charset
    //

    (VOID) BFindNextWord(&pstr, achWord);

    if (! (pFont->pstrCharset = ALLOC_PARSER_MEM(pParserData, strlen(achWord) + 1)))
        return PPDERR_MEMORY;

    strcpy(pFont->pstrCharset, achWord);

    //
    // status
    //

    (VOID) BFindNextWord(&pstr, achWord);
    (VOID) BSearchStrTable(FontStatusStrs, achWord, &pFont->dwStatus);

    return PPDERR_NONE;
}

//
// Specifies the default device font
//

PPDERROR
IDefaultFontProc(
    PPARSERDATA pParserData
    )

{
    if (strcmp(pParserData->pstrValue, "Error") == EQUAL_STRING)
        pParserData->pstrDefaultFont = NULL;
    else if (! (pParserData->pstrDefaultFont = PstrParseString(pParserData, &pParserData->Value)))
        return PPDERR_MEMORY;

    return PPDERR_NONE;
}

//
// Mark the beginning of a new printer feature section
//

PPDERROR
IOpenUIProc(
    PPARSERDATA pParserData
    )

{
    static const STRTABLE UITypeStrs[] =
    {
        "PickOne",  UITYPE_PICKONE,
        "PickMany", UITYPE_PICKMANY,
        "Boolean",  UITYPE_BOOLEAN,
        NULL,       UITYPE_PICKONE
    };

    PCSTR   pstrKeyword;

    //
    // Guard against nested or unbalanced OpenUI
    //

    if (pParserData->pOpenFeature != NULL)
    {
        TERSE(("Missing CloseUI for *%s\n", pParserData->pOpenFeature->pstrName));
        pParserData->pOpenFeature = NULL;
    }

    //
    // Make sure the keyword is well-formed
    //

    if (! (pstrKeyword = PstrStripKeywordChar(pParserData->achOption)))
        return ISyntaxError(pParserData->pFile, "Empty keyword");

    //
    // HACK: special-case handling of "*OpenUI: *ManualFeed" entry
    //

    if (strcmp(pstrKeyword, gstrManualFeedKwd) == EQUAL_STRING)
        return PPDERR_NONE;

    if (! (pParserData->pOpenFeature = PCreateFeatureItem(pParserData, GID_UNKNOWN)))
        return PPDERR_MEMORY;

    //
    // Determine the type of feature option list
    //

    if (! BSearchStrTable(UITypeStrs,
                          pParserData->pstrValue,
                          &pParserData->pOpenFeature->dwUIType))
    {
        ISyntaxError(pParserData->pFile, "Unrecognized UI type");
    }

    //
    // Are we dealing with JCLOpenUI?
    //

    pParserData->bJclFeature = HAS_JCL_PREFIX(pstrKeyword);
    return PPDERR_NONE;
}

//
// Mark the end of a new printer feature section
//

PPDERROR
ICloseUIProc(
    PPARSERDATA pParserData
    )

{
    PCSTR       pstrKeyword;
    PFEATUREOBJ pOpenFeature;

    //
    // Make sure the CloseUI entry is balanced with a previous OpenUI entry
    //

    pOpenFeature = pParserData->pOpenFeature;
    pParserData->pOpenFeature = NULL;
    pstrKeyword = PstrStripKeywordChar(pParserData->pstrValue);

    //
    // HACK: special-case handling of "*CloseUI: *ManualFeed" entry
    //

    if (pstrKeyword && strcmp(pstrKeyword, gstrManualFeedKwd) == EQUAL_STRING)
        return PPDERR_NONE;

    if (pOpenFeature == NULL ||
        pstrKeyword == NULL ||
        strcmp(pstrKeyword, pOpenFeature->pstrName) != EQUAL_STRING ||
        pParserData->bJclFeature != HAS_JCL_PREFIX(pstrKeyword))
    {
        return ISyntaxError(pParserData->pFile, "Invalid CloseUI entry");
    }

    return PPDERR_NONE;
}

//
// Process OpenGroup and CloseGroup entries
//
// !!! OpenGroup, CloseGroup, OpenSubGroup, and CloseSubGroup
// keywords are not completely supported. Currently, we
// only pay specific attention to the InstallableOptions group.
//
// If the group information is needed in the future by the
// user interface, the following functions should be beefed up.
//

PPDERROR
IOpenCloseGroupProc(
    PPARSERDATA pParserData,
    BOOL        bOpenGroup
    )

{
    PSTR    pstrGroupName = pParserData->pstrValue;

    //
    // We're only interested in the InstallableOptions group
    //

    if (strcmp(pstrGroupName, "InstallableOptions") == EQUAL_STRING)
    {
        if (pParserData->bInstallableGroup == bOpenGroup)
            return ISyntaxError(pParserData->pFile, "Unbalanced OpenGroup/CloseGroup");

        pParserData->bInstallableGroup = bOpenGroup;
    }
    else
    {
        VERBOSE(("Group %s ignored\n", pstrGroupName));
    }

    return PPDERR_NONE;
}

//
// Process OpenGroup entries
//

PPDERROR
IOpenGroupProc(
    PPARSERDATA pParserData
    )

{
    return IOpenCloseGroupProc(pParserData, TRUE);
}

//
// Process CloseGroup entries
//

PPDERROR
ICloseGroupProc(
    PPARSERDATA pParserData
    )

{
    return IOpenCloseGroupProc(pParserData, FALSE);
}

//
// Handle OpenSubGroup entries
//

PPDERROR
IOpenSubGroupProc(
    PPARSERDATA pParserData
    )

{
    return PPDERR_NONE;
}

//
// Handle CloseSubGroup entries
//

PPDERROR
ICloseSubGroupProc(
    PPARSERDATA pParserData
    )

{
    return PPDERR_NONE;
}

//
// Parse a UIConstraints entry
//

PPDERROR
IUIConstraintsProc(
    PPARSERDATA pParserData
    )

{
    PLISTOBJ    pItem;

    if (! (pItem = ALLOC_PARSER_MEM(pParserData, sizeof(LISTOBJ))) ||
        ! (pItem->pstrName = PstrParseString(pParserData, &pParserData->Value)))
    {
        ERR(("Memory allocation failed\n"));
        return PPDERR_MEMORY;
    }

    pItem->pNext = pParserData->pUIConstraints;
    pParserData->pUIConstraints = pItem;
    return PPDERR_NONE;
}

//
// Parse an OrderDependency entry
//

PPDERROR
IOrderDepProc(
    PPARSERDATA pParserData
    )

{
    PLISTOBJ    pItem;

    if (! (pItem = ALLOC_PARSER_MEM(pParserData, sizeof(LISTOBJ))) ||
        ! (pItem->pstrName = PstrParseString(pParserData, &pParserData->Value)))
    {
        ERR(("Memory allocation failed\n"));
        return PPDERR_MEMORY;
    }

    pItem->pNext = pParserData->pOrderDep;
    pParserData->pOrderDep = pItem;
    return PPDERR_NONE;
}

//
// Parse QueryOrderDependency entries
//

PPDERROR
IQueryOrderDepProc(
    PPARSERDATA pParserData
    )

{
    PLISTOBJ    pItem;

    if (! (pItem = ALLOC_PARSER_MEM(pParserData, sizeof(LISTOBJ))) ||
        ! (pItem->pstrName = PstrParseString(pParserData, &pParserData->Value)))
    {
        ERR(("Memory allocation failed\n"));
        return PPDERR_MEMORY;
    }

    pItem->pNext = pParserData->pQueryOrderDep;
    pParserData->pQueryOrderDep = pItem;
    return PPDERR_NONE;
}

//
// Specifies memory configuration information
//

PPDERROR
IVMOptionProc(
    PPARSERDATA pParserData
    )

{
    PMEMOBJ pOption;

    if (! (pOption = PvCreateOptionItem(pParserData, GID_MEMOPTION)))
        return PPDERR_MEMORY;

    if (pOption->dwFreeVM)
    {
        WARN_DUPLICATE();
        return PPDERR_NONE;
    }

    return IParseInteger(pParserData, &pOption->dwFreeVM);
}

//
// Specifies font cache size information
//

PPDERROR
IFCacheSizeProc(
    PPARSERDATA pParserData
    )

{
    PMEMOBJ pOption;

    if (! (pOption = PvCreateOptionItem(pParserData, GID_MEMOPTION)))
        return PPDERR_MEMORY;

    if (pOption->dwFontMem)
    {
        WARN_DUPLICATE();
        return PPDERR_NONE;
    }

    return IParseInteger(pParserData, &pOption->dwFontMem);
}

//
// Specifies the minimum amount of free VM
//

PPDERROR
IFreeVMProc(
    PPARSERDATA pParserData
    )

{
    return IParseInteger(pParserData, &pParserData->dwFreeMem);
}

//
// Include another file
//

PPDERROR
IIncludeProc(
    PPARSERDATA pParserData
    )

#define MAX_INCLUDE_LEVEL   10

{
    WCHAR       awchFilename[MAX_PATH];
    PFILEOBJ    pPreviousFile;
    PPDERROR    iStatus;

    if (pParserData->iIncludeLevel >= MAX_INCLUDE_LEVEL)
    {
        ERR(("There appears to be recursive *Include.\n"));
        return PPDERR_FILE;
    }

    if (! MultiByteToWideChar(CP_ACP, 0, pParserData->pstrValue, -1, awchFilename,  MAX_PATH))
        return ISyntaxError(pParserData->pFile, "Invalid include filename");

    VERBOSE(("Including file %ws ...\n", awchFilename));

    pPreviousFile = pParserData->pFile;
    pParserData->iIncludeLevel++;

    iStatus = IParseFile(pParserData, awchFilename);

    pParserData->iIncludeLevel--;
    pParserData->pFile = pPreviousFile;

    return iStatus;
}

//
// Specifies the printer description file format version number
//

PPDERROR
IPPDAdobeProc(
    PPARSERDATA pParserData
    )

{
    return IParseVersionNumber(pParserData, &pParserData->dwSpecVersion);
}

//
// Specifies the printer description file format version number
//

PPDERROR
IFormatVersionProc(
    PPARSERDATA pParserData
    )

{
    if (pParserData->dwSpecVersion != 0)
        return PPDERR_NONE;

    return IParseVersionNumber(pParserData, &pParserData->dwSpecVersion);
}

//
// Specifies the PPD file version number
//

PPDERROR
IFileVersionProc(
    PPARSERDATA pParserData
    )

{
    return IParseVersionNumber(pParserData, &pParserData->dwPpdFilever);
}

//
// Specifies the protocols supported by the device
//

PPDERROR
IProtocolsProc(
    PPARSERDATA pParserData
    )

{
    static const STRTABLE ProtocolStrs[] =
    {
        "PJL",  PROTOCOL_PJL,
        "BCP",  PROTOCOL_BCP,
        "TBCP", PROTOCOL_TBCP,
        "SIC",  PROTOCOL_SIC,
        NULL,   0
    };

    CHAR    achWord[MAX_WORD_LEN];
    DWORD   dwProtocol;
    PSTR    pstr = pParserData->pstrValue;

    while (BFindNextWord(&pstr, achWord))
    {
        if (BSearchStrTable(ProtocolStrs, achWord, &dwProtocol))
            pParserData->dwProtocols |= dwProtocol;
        else
            TERSE(("Unknown protocol: %s\n", achWord));
    }

    return PPDERR_NONE;
}

//
// Specifies whether the device supports color output
//

PPDERROR
IColorDeviceProc(
    PPARSERDATA pParserData
    )

{
    return IParseBoolean(pParserData, &pParserData->dwColorDevice);
}

//
// Specifies whether the device fonts already have the Euro
//

PPDERROR
IHasEuroProc(
    PPARSERDATA pParserData
    )

{
    PPDERROR rc;

    if (rc = IParseBoolean(pParserData, &pParserData->bHasEuro) != PPDERR_NONE)
        return rc;

    pParserData->bEuroInformationSet = TRUE;

    return PPDERR_NONE;
}

//
// Specifies whether the device fonts already have the Euro
//

PPDERROR
ITrueGrayProc(
    PPARSERDATA pParserData
    )

{
    return IParseBoolean(pParserData, &pParserData->bTrueGray);
}

//
// Specifies the language extensions supported by the device
//

PPDERROR
IExtensionsProc(
    PPARSERDATA pParserData
    )

{
    static const STRTABLE ExtensionStrs[] =
    {
        "DPS",          LANGEXT_DPS,
        "CMYK",         LANGEXT_CMYK,
        "Composite",    LANGEXT_COMPOSITE,
        "FileSystem",   LANGEXT_FILESYSTEM,
        NULL,           0
    };

    CHAR    achWord[MAX_WORD_LEN];
    INT     dwExtension;
    PSTR    pstr = pParserData->pstrValue;

    while (BFindNextWord(&pstr, achWord))
    {
        if (BSearchStrTable(ExtensionStrs, achWord, &dwExtension))
            pParserData->dwExtensions |= dwExtension;
        else
            TERSE(("Unknown extension: %s\n", achWord));
    }

    return PPDERR_NONE;
}

//
// Specifies whether the device has a file system on disk
//

PPDERROR
IFileSystemProc(
    PPARSERDATA pParserData
    )

{
    DWORD       dwFileSystem;
    PPDERROR    iStatus;

    if ((iStatus = IParseBoolean(pParserData, &dwFileSystem)) == PPDERR_NONE)
    {
        if (dwFileSystem)
            pParserData->dwExtensions |= LANGEXT_FILESYSTEM;
        else
            pParserData->dwExtensions &= ~LANGEXT_FILESYSTEM;
    }

    return iStatus;
}

//
// Specifies the device name
//

PPDERROR
INickNameProc(
    PPARSERDATA pParserData
    )

{
    //
    // Use NickName only if ShortNickName entry is not present
    //

    if (pParserData->NickName.pvData == NULL)
        return IParseInvocation(pParserData, &pParserData->NickName);
    else
        return PPDERR_NONE;
}

//
// Specifies the short device name
//

PPDERROR
IShortNameProc(
    PPARSERDATA pParserData
    )

{
    pParserData->NickName.dwLength = 0;
    pParserData->NickName.pvData = NULL;

    return IParseInvocation(pParserData, &pParserData->NickName);
}

//
// Specifies the PostScript language level
//

PPDERROR
ILangLevelProc(
    PPARSERDATA pParserData
    )

{
    return IParseInteger(pParserData, &pParserData->dwLangLevel);
}

//
// Specifies PPD language encoding options
//

PPDERROR
ILangEncProc(
    PPARSERDATA pParserData
    )

{
    //
    // NOTE: Only the following two language encodings are supported because
    // the rest of them are not used (according to our discussions with Adobe).
    // In any case, we don't have any direct way of translating ANSI strings
    // in other encodings to Unicode.
    //
    // A possible future PPD extension is to allow Unicode encoding directly
    // in translation strings.
    //

    static const STRTABLE LangEncStrs[] =
    {
        "ISOLatin1",    LANGENC_ISOLATIN1,
        "WindowsANSI",  LANGENC_ISOLATIN1, // WindowsANSI means CharSet=0, which is now page 1252->ISO Latin1
        "None",         LANGENC_NONE,
        "Unicode",      LANGENC_UNICODE,
        "JIS83-RKSJ",   LANGENC_JIS83_RKSJ,
        NULL,           LANGENC_NONE
    };

    if (! BSearchStrTable(LangEncStrs, pParserData->pstrValue, &pParserData->dwLangEncoding))
        return ISyntaxError(pParserData->pFile, "Unsupported LanguageEncoding keyword");
    else
        return PPDERR_NONE;
}

//
// Identifies the natural language used in the PPD file
//

PPDERROR
ILangVersProc(
    PPARSERDATA pParserData
    )

{
    static const STRTABLE LangVersionStrs[] = {

        "English",        LANGENC_ISOLATIN1,
        "Danish",         LANGENC_ISOLATIN1,
        "Dutch",          LANGENC_ISOLATIN1,
        "Finnish",        LANGENC_ISOLATIN1,
        "French",         LANGENC_ISOLATIN1,
        "German",         LANGENC_ISOLATIN1,
        "Italian",        LANGENC_ISOLATIN1,
        "Norwegian",      LANGENC_ISOLATIN1,
        "Portuguese",     LANGENC_ISOLATIN1,
        "Spanish",        LANGENC_ISOLATIN1,
        "Swedish",        LANGENC_ISOLATIN1,
        "Japanese",       LANGENC_JIS83_RKSJ,
        "Chinese",        LANGENC_NONE,
        "Russian",        LANGENC_NONE,

        NULL,             LANGENC_NONE
    };

    if (pParserData->dwLangEncoding == LANGENC_NONE &&
        ! BSearchStrTable(LangVersionStrs, pParserData->pstrValue, &pParserData->dwLangEncoding))
    {
        return ISyntaxError(pParserData->pFile, "Unsupported LanguageVersion keyword");
    }

    return PPDERR_NONE;
}

//
// Specifies the available TrueType rasterizer options
//

PPDERROR
ITTRasterizerProc(
    PPARSERDATA pParserData
    )

{
    static const STRTABLE RasterizerStrs[] =
    {
        "None",         TTRAS_NONE,
        "Accept68K",    TTRAS_ACCEPT68K,
        "Type42",       TTRAS_TYPE42,
        "TrueImage",    TTRAS_TRUEIMAGE,
        NULL,           TTRAS_NONE
    };

    if (! BSearchStrTable(RasterizerStrs, pParserData->pstrValue, &pParserData->dwTTRasterizer))
        return ISyntaxError(pParserData->pFile, "Unknown TTRasterizer option");
    else
        return PPDERR_NONE;
}

//
// Specifies the exitserver invocation string
//

PPDERROR
IExitServerProc(
    PPARSERDATA pParserData
    )

{
    return IParseInvocation(pParserData, &pParserData->ExitServer);
}

//
// Specifies the password string
//

PPDERROR
IPasswordProc(
    PPARSERDATA pParserData
    )

{
    return IParseInvocation(pParserData, &pParserData->Password);
}

//
// Specifies the PatchFile invocation string
//

PPDERROR
IPatchFileProc(
    PPARSERDATA pParserData
    )

{
    return IParseInvocation(pParserData, &pParserData->PatchFile);
}

//
// Specifies JobPatchFile invocation strings
//

PPDERROR
IJobPatchFileProc(
    PPARSERDATA pParserData
    )

{
    PJOBPATCHFILEOBJ  pItem;
    PSTR              pTmp;

    //
    // Create a new job patch file item
    //

    if (! (pItem = PvCreateListItem(pParserData,
                                    (PLISTOBJ *) &pParserData->pJobPatchFiles,
                                    sizeof(JOBPATCHFILEOBJ),
                                    "JobPatchFile")))
    {
        return PPDERR_MEMORY;
    }

    //
    // Parse the job patch file invocation string
    //

    if (pItem->Invocation.pvData)
    {
        WARN_DUPLICATE();
        return PPDERR_NONE;
    }

    //
    // warn if number of patch file is invalid
    //

    pTmp = pItem->pstrName;

    if (!BGetIntegerFromString(&pTmp, &pItem->lPatchNo))
    {
        TERSE(("Warning: invalid JobPatchFile number '%s' on line %d\n",
               pParserData->achOption, pParserData->pFile->iLineNumber));
        pItem->lPatchNo = 0;
    }

    return IParseInvocation(pParserData, &pItem->Invocation);
}

//
// Specifies PostScript interpreter version and revision number
//

PPDERROR
IPSVersionProc(
    PPARSERDATA pParserData
    )

{
    PSTR        pstr = pParserData->Value.pbuf;
    DWORD       dwVersion;
    PPDERROR    status;

    //
    // Save the first PSVersion string
    //

    if ((pParserData->PSVersion.pvData == NULL) &&
        ((status = IParseInvocation(pParserData, &pParserData->PSVersion)) != PPDERR_NONE))
    {
        return status;
    }

    //
    // Skip non-digit characters
    //

    while (*pstr && !IS_DIGIT(*pstr))
        pstr++;

    //
    // Extract the PS interpreter version number
    //

    dwVersion = 0;

    while (*pstr && IS_DIGIT(*pstr))
        dwVersion = dwVersion * 10 + (*pstr++ - '0');

    if (dwVersion > 0)
    {
        //
        // Remember the lowest PSVersion number
        //

        if (pParserData->dwPSVersion == 0 || pParserData->dwPSVersion > dwVersion)
            pParserData->dwPSVersion = dwVersion;

        return PPDERR_NONE;
    }
    else
        return ISyntaxError(pParserData->pFile, "Invalid PSVersion entry");
}

//
// Specifies the Product string
//

PPDERROR
IProductProc(
    PPARSERDATA pParserData
    )

{
        //
        // only store the first *Product entry, though there may be multiple
        //

        if (pParserData->Product.dwLength != 0)
                return PPDERR_NONE;

    return IParseInvocation(pParserData, &pParserData->Product);
}

//
// Specifies the default job timeout value
//

PPDERROR
IJobTimeoutProc(
    PPARSERDATA pParserData
    )

{
    return IParseInteger(pParserData, &pParserData->dwJobTimeout);
}

//
// Specifies the default wait timeout value
//

PPDERROR
IWaitTimeoutProc(
    PPARSERDATA pParserData
    )

{
    return IParseInteger(pParserData, &pParserData->dwWaitTimeout);
}

//
// Specifies whether error handler should be enabled by default
//

PPDERROR
IPrintPSErrProc(
    PPARSERDATA pParserData
    )

{
    DWORD   dwValue;

    if (IParseBoolean(pParserData, &dwValue) != PPDERR_NONE)
        return PPDERR_SYNTAX;

    if (dwValue)
        pParserData->dwPpdFlags |= PPDFLAG_PRINTPSERROR;
    else
        pParserData->dwPpdFlags &= ~PPDFLAG_PRINTPSERROR;

    return PPDERR_NONE;
}

//
// Specifies PJL commands to start a job
//

PPDERROR
IJCLBeginProc(
    PPARSERDATA pParserData
    )

{
    pParserData->dwPpdFlags |= PPDFLAG_HAS_JCLBEGIN;
    return IParseInvocation(pParserData, &pParserData->JclBegin);
}

//
// Specifies PJL commands to switch into PostScript language
//

PPDERROR
IJCLToPSProc(
    PPARSERDATA pParserData
    )

{
    pParserData->dwPpdFlags |= PPDFLAG_HAS_JCLENTERPS;
    return IParseInvocation(pParserData, &pParserData->JclEnterPS);
}

//
// Specifies PJL commands to end a job
//

PPDERROR
IJCLEndProc(
    PPARSERDATA pParserData
    )

{
    pParserData->dwPpdFlags |= PPDFLAG_HAS_JCLEND;
    return IParseInvocation(pParserData, &pParserData->JclEnd);
}

//
// Specifies the default landscape orientation mode
//

PPDERROR
ILSOrientProc(
    PPARSERDATA pParserData
    )

{
    static const STRTABLE LsoStrs[] =
    {
        "Any",      LSO_ANY,
        "Plus90",   LSO_PLUS90,
        "Minus90",  LSO_MINUS90,
        NULL,       LSO_ANY
    };

    if (! BSearchStrTable(LsoStrs, pParserData->pstrValue, &pParserData->dwLSOrientation))
        return ISyntaxError(pParserData->pFile, "Unrecognized landscape orientation");
    else
        return PPDERR_NONE;
}



PPAPEROBJ
PCreateCustomSizeOption(
    PPARSERDATA pParserData
    )

/*++

Routine Description:

    Create a CustomPageSize option for PageSize feature (if necessary)

Arguments:

    pParserData - Points to parser data structure

Return Value:

    Pointer to newly created CustomPageSize option item or
    the existing CustomPageSize option item if it already exists.

    NULL if there is an error.

--*/

{
    PPAPEROBJ   pCustomSize;
    BUFOBJ      SavedBuffer;

    //
    // Create an item corresponding to *PageSize feature if needed
    //

    SavedBuffer = pParserData->Option;
    pParserData->Option.pbuf = (PBYTE) gstrCustomSizeKwd;
    pParserData->Option.dwSize = strlen(gstrCustomSizeKwd);

    pCustomSize = PvCreateOptionItem(pParserData, GID_PAGESIZE);

    pParserData->Option = SavedBuffer;

    return pCustomSize;;
}

//
// Specifies custom paper size invocation string
//

PPDERROR
ICustomSizeProc(
    PPARSERDATA pParserData
    )

{
    PPAPEROBJ   pCustomSize;

    if (strcmp(pParserData->achOption, gstrTrueKwd) != EQUAL_STRING)
    {
        ISyntaxError(pParserData->pFile, "Invalid *CustomPageSize option");
        return PPDERR_NONE;
    }

    if (! (pCustomSize = PCreateCustomSizeOption(pParserData)))
        return PPDERR_MEMORY;

    if (pCustomSize->Option.Invocation.pvData)
    {
        WARN_DUPLICATE();
        return PPDERR_NONE;
    }

    return IParseInvocation(pParserData, &pCustomSize->Option.Invocation);
}

//
// Specifies custom paper size parameters
//

PPDERROR
IParamCustomProc(
    PPARSERDATA pParserData
    )

{
    static const STRTABLE CustomParamStrs[] =
    {
        "Width",        CUSTOMPARAM_WIDTH,
        "Height",       CUSTOMPARAM_HEIGHT,
        "WidthOffset",  CUSTOMPARAM_WIDTHOFFSET,
        "HeightOffset", CUSTOMPARAM_HEIGHTOFFSET,
        "Orientation",  CUSTOMPARAM_ORIENTATION,
        NULL,           0
    };

    CHAR    achWord[MAX_WORD_LEN];
    LONG    lMinVal, lMaxVal;
    INT     iType;
    DWORD   dwParam;
    LONG    lOrder;
    PSTR    pstr = pParserData->pstrValue;

    //
    // The format for a ParamCustomPageSize entry:
    //  ParameterName Order Type MinVal MaxVal
    //

    if (! BSearchStrTable(CustomParamStrs, pParserData->achOption, &dwParam) ||
        ! BGetIntegerFromString(&pstr, &lOrder) ||
        ! BFindNextWord(&pstr, achWord) ||
        lOrder <= 0 || lOrder > CUSTOMPARAM_MAX)
    {
        return ISyntaxError(pParserData->pFile, "Bad *ParamCustomPageSize entry");
    }

    //
    // Expected type is "int" for Orientation parameter and "points" for other parameters
    //

    iType = (dwParam == CUSTOMPARAM_ORIENTATION) ?
                ((strcmp(achWord, "int") == EQUAL_STRING) ? FLTYPE_INT : FLTYPE_ERROR) :
                ((strcmp(achWord, "points") == EQUAL_STRING) ? FLTYPE_POINT : FLTYPE_ERROR);

    if (iType == FLTYPE_ERROR ||
        ! BGetFloatFromString(&pstr, &lMinVal, iType) ||
        ! BGetFloatFromString(&pstr, &lMaxVal, iType) ||
        lMinVal > lMaxVal)
    {
        return ISyntaxError(pParserData->pFile, "Bad *ParamCustomPageSize entry");
    }

    pParserData->CustomSizeParams[dwParam].dwOrder = lOrder;
    pParserData->CustomSizeParams[dwParam].lMinVal = lMinVal;
    pParserData->CustomSizeParams[dwParam].lMaxVal = lMaxVal;

    return PPDERR_NONE;
}

//
// Specifies the maximum height of custom paper size
//

PPDERROR
IMaxWidthProc(
    PPARSERDATA pParserData
    )

{
    PPAPEROBJ   pCustomSize;
    LONG        lValue;
    PSTR        pstr = pParserData->pstrValue;

    if (! BGetFloatFromString(&pstr, &lValue, FLTYPE_POINT) || lValue <= 0)
        return ISyntaxError(pParserData->pFile, "Invalid media width");

    if (! (pCustomSize = PCreateCustomSizeOption(pParserData)))
        return PPDERR_MEMORY;

    pCustomSize->szDimension.cx = lValue;
    return PPDERR_NONE;
}

//
// Specifies the maximum height of custom paper size
//

PPDERROR
IMaxHeightProc(
    PPARSERDATA pParserData
    )

{
    PPAPEROBJ   pCustomSize;
    LONG        lValue;
    PSTR        pstr = pParserData->pstrValue;

    if (! BGetFloatFromString(&pstr, &lValue, FLTYPE_POINT) || lValue <= 0)
        return ISyntaxError(pParserData->pFile, "Invalid media height");

    if (! (pCustomSize = PCreateCustomSizeOption(pParserData)))
        return PPDERR_MEMORY;

    pCustomSize->szDimension.cy = lValue;
    return PPDERR_NONE;
}

//
// Specifies the hardware margins on cut-sheet devices
//

PPDERROR
IHWMarginsProc(
    PPARSERDATA pParserData
    )

{
    PPAPEROBJ   pCustomSize;
    RECT        rc;
    PSTR        pstr = pParserData->pstrValue;

    //
    // Parse hardware margins: left, bottom, right, top
    //

    if (! BGetFloatFromString(&pstr, &rc.left, FLTYPE_POINT) ||
        ! BGetFloatFromString(&pstr, &rc.bottom, FLTYPE_POINT) ||
        ! BGetFloatFromString(&pstr, &rc.right, FLTYPE_POINT) ||
        ! BGetFloatFromString(&pstr, &rc.top, FLTYPE_POINT))
    {
        return ISyntaxError(pParserData->pFile, "Invalid HWMargins");
    }

    if (! (pCustomSize = PCreateCustomSizeOption(pParserData)))
        return PPDERR_MEMORY;

    pCustomSize->rcImageArea = rc;

    //
    // The presence of HWMargins entry indicates the device supports cut-sheet
    //

    pParserData->dwCustomSizeFlags |= CUSTOMSIZE_CUTSHEET;
    return PPDERR_NONE;
}

//
// Function to process *CenterRegistered entry
//

PPDERROR
ICenterRegProc(
    PPARSERDATA pParserData
    )

{
    DWORD   dwValue;

    if (IParseBoolean(pParserData, &dwValue) != PPDERR_NONE)
        return PPDERR_SYNTAX;

    if (dwValue)
        pParserData->dwCustomSizeFlags |= CUSTOMSIZE_CENTERREG;
    else
        pParserData->dwCustomSizeFlags &= ~CUSTOMSIZE_CENTERREG;

    return PPDERR_NONE;
}

//
// Function to process *ADORequiresEExec entry
//

PPDERROR
IReqEExecProc(
    PPARSERDATA pParserData
    )

{
    DWORD   dwValue;

    if (IParseBoolean(pParserData, &dwValue) != PPDERR_NONE)
        return PPDERR_SYNTAX;

    if (dwValue)
        pParserData->dwPpdFlags |= PPDFLAG_REQEEXEC;
    else
        pParserData->dwPpdFlags &= ~PPDFLAG_REQEEXEC;

    return PPDERR_NONE;
}

//
// Function to process *ADOTTFontSub entry
//

PPDERROR
ITTFontSubProc(
    PPARSERDATA pParserData
    )

{
    PTTFONTSUB pTTFontSub;

    //
    // Create a new font substitution item
    //

    if (! (pTTFontSub = PvCreateXlatedItem(
                                pParserData,
                                &pParserData->pTTFontSubs,
                                sizeof(TTFONTSUB))))
    {
        return PPDERR_MEMORY;
    }

    //
    // Parse the PS family name
    //

    if (pTTFontSub->PSName.pvData)
    {
        WARN_DUPLICATE();
        return PPDERR_NONE;
    }

    if (*pParserData->pstrValue == NUL)
        return ISyntaxError(pParserData->pFile, "Missing TrueType font family name");

    return IParseInvocation(pParserData, &pTTFontSub->PSName);
}

//
// Function to process *Throughput entry
//

PPDERROR
IThroughputProc(
    PPARSERDATA pParserData
    )

{
    return IParseInteger(pParserData, &pParserData->dwThroughput);
}

//
// Function to ignore the current entry
//

PPDERROR
INullProc(
    PPARSERDATA pParserData
    )

{
    return PPDERR_NONE;
}

//
// Define a named symbol
//

PPDERROR
ISymbolValueProc(
    PPARSERDATA pParserData
    )

{
    PSYMBOLOBJ  pSymbol;

    if (pParserData->dwValueType == VALUETYPE_SYMBOL)
        return ISyntaxError(pParserData->pFile, "Symbol value cannot be another symbol");

    //
    // Create a new symbol item
    //

    if (! (pSymbol = PvCreateListItem(pParserData,
                                      (PLISTOBJ *) &pParserData->pSymbols,
                                      sizeof(SYMBOLOBJ),
                                      "Symbol")))
    {
        return PPDERR_MEMORY;
    }

    //
    // Parse the symbol value
    //

    if (pSymbol->Invocation.pvData)
    {
        WARN_DUPLICATE();
        return PPDERR_NONE;
    }

    return IParseInvocation(pParserData, &pSymbol->Invocation);
}



//
// Built-in keyword table
//

const CHAR gstrDefault[]        = "Default";
const CHAR gstrPageSizeKwd[]    = "PageSize";
const CHAR gstrInputSlotKwd[]   = "InputSlot";
const CHAR gstrManualFeedKwd[]  = "ManualFeed";
const CHAR gstrCustomSizeKwd[]  = "CustomPageSize";
const CHAR gstrLetterSizeKwd[]  = "Letter";
const CHAR gstrA4SizeKwd[]      = "A4";
const CHAR gstrLongKwd[]        = "Long";
const CHAR gstrShortKwd[]       = "Short";
const CHAR gstrTrueKwd[]        = "True";
const CHAR gstrFalseKwd[]       = "False";
const CHAR gstrOnKwd[]          = "On";
const CHAR gstrOffKwd[]         = "Off";
const CHAR gstrNoneKwd[]        = "None";
const CHAR gstrVMOptionKwd[]    = "VMOption";
const CHAR gstrInstallMemKwd[]  = "InstalledMemory";
const CHAR gstrDuplexTumble[]   = "DuplexTumble";
const CHAR gstrDuplexNoTumble[] = "DuplexNoTumble";

const KWDENTRY gPpdBuiltInKeywordTable[] =
{
    { gstrPageSizeKwd,          NULL,                GENERIC_ENTRY(GID_PAGESIZE) },
    { "PageRegion",             NULL,                GENERIC_ENTRY(GID_PAGEREGION) },
    { gstrInputSlotKwd,         NULL,                GENERIC_ENTRY(GID_INPUTSLOT) },
    { "MediaType",              NULL,                GENERIC_ENTRY(GID_MEDIATYPE) },
    { "OutputBin",              NULL,                GENERIC_ENTRY(GID_OUTPUTBIN) },
    { "Collate",                NULL,                GENERIC_ENTRY(GID_COLLATE) },
    { "Resolution",             NULL,                GENERIC_ENTRY(GID_RESOLUTION) },
    { "InstalledMemory",        NULL,                GENERIC_ENTRY(GID_MEMOPTION) },
    { "LeadingEdge",            NULL,                GENERIC_ENTRY(GID_LEADINGEDGE) },
    { "UseHWMargins",           NULL,                GENERIC_ENTRY(GID_USEHWMARGINS) },

    { "Duplex",                 IDuplexProc,         INVOCA_VALUE | REQ_OPTION },
    { "DefaultDuplex",          IDefaultDuplexProc,  STRING_VALUE },
    { "PaperDimension",         IPaperDimProc,       QUOTED_NOHEX | REQ_OPTION },
    { "ImageableArea",          IImageAreaProc,      QUOTED_NOHEX | REQ_OPTION },
    { "RequiresPageRegion",     IReqPageRgnProc,     STRING_VALUE | REQ_OPTION },
    { gstrManualFeedKwd,        IManualFeedProc,     INVOCA_VALUE | REQ_OPTION },
    { "DefaultManualFeed",      IDefManualFeedProc,  STRING_VALUE },
    { "PageStackOrder",         IPageStackOrderProc, STRING_VALUE | REQ_OPTION },
    { "DefaultOutputOrder",     IDefOutputOrderProc, STRING_VALUE },
    { "JCLResolution",          IJCLResProc,         INVOCA_VALUE | REQ_OPTION | ALLOW_HEX },
    { "DefaultJCLResolution",   IDefaultJCLResProc,  STRING_VALUE },
    { "SetResolution",          ISetResProc,         INVOCA_VALUE | REQ_OPTION },
    { "ScreenAngle",            IScreenAngleProc,    QUOTED_VALUE },
    { "ScreenFreq",             IScreenFreqProc,     QUOTED_VALUE },
    { "ResScreenAngle",         IResScreenAngleProc, QUOTED_NOHEX | REQ_OPTION },
    { "ResScreenFreq",          IResScreenFreqProc,  QUOTED_NOHEX | REQ_OPTION },
    { "Font",                   IFontProc,           STRING_VALUE | REQ_OPTION },
    { "DefaultFont",            IDefaultFontProc,    STRING_VALUE },
    { "OpenUI",                 IOpenUIProc,         STRING_VALUE | REQ_OPTION },
    { "CloseUI",                ICloseUIProc,        STRING_VALUE | ALLOW_MULTI },
    { "JCLOpenUI",              IOpenUIProc,         STRING_VALUE | REQ_OPTION },
    { "JCLCloseUI",             ICloseUIProc,        STRING_VALUE | ALLOW_MULTI },
    { "OrderDependency",        IOrderDepProc,       STRING_VALUE | ALLOW_MULTI },
    { "UIConstraints",          IUIConstraintsProc,  STRING_VALUE | ALLOW_MULTI },
    { "QueryOrderDependency",   IQueryOrderDepProc,  STRING_VALUE | ALLOW_MULTI },
    { "NonUIOrderDependency",   IOrderDepProc,       STRING_VALUE | ALLOW_MULTI },
    { "NonUIConstraints",       IUIConstraintsProc,  STRING_VALUE | ALLOW_MULTI },
    { "VMOption",               IVMOptionProc,       QUOTED_NOHEX | REQ_OPTION },
    { "FCacheSize",             IFCacheSizeProc,     STRING_VALUE | REQ_OPTION },
    { "FreeVM",                 IFreeVMProc,         QUOTED_VALUE },
    { "OpenGroup",              IOpenGroupProc,      STRING_VALUE | ALLOW_MULTI },
    { "CloseGroup",             ICloseGroupProc,     STRING_VALUE | ALLOW_MULTI },
    { "OpenSubGroup",           IOpenSubGroupProc,   STRING_VALUE | ALLOW_MULTI },
    { "CloseSubGroup",          ICloseSubGroupProc,  STRING_VALUE | ALLOW_MULTI },
    { "Include",                IIncludeProc,        QUOTED_VALUE | ALLOW_MULTI },
    { "PPD-Adobe",              IPPDAdobeProc,       QUOTED_VALUE },
    { "FormatVersion",          IFormatVersionProc,  QUOTED_VALUE },
    { "FileVersion",            IFileVersionProc,    QUOTED_VALUE },
    { "ColorDevice",            IColorDeviceProc,    STRING_VALUE },
    { "Protocols",              IProtocolsProc,      STRING_VALUE | ALLOW_MULTI },
    { "Extensions",             IExtensionsProc,     STRING_VALUE | ALLOW_MULTI },
    { "FileSystem",             IFileSystemProc,     STRING_VALUE },
    { "NickName",               INickNameProc,       QUOTED_VALUE },
    { "ShortNickName",          IShortNameProc,      QUOTED_VALUE },
    { "LanguageLevel",          ILangLevelProc,      QUOTED_NOHEX },
    { "LanguageEncoding",       ILangEncProc,        STRING_VALUE },
    { "LanguageVersion",        ILangVersProc,       STRING_VALUE },
    { "TTRasterizer",           ITTRasterizerProc,   STRING_VALUE },
    { "ExitServer",             IExitServerProc,     INVOCA_VALUE },
    { "Password",               IPasswordProc,       INVOCA_VALUE },
    { "PatchFile",              IPatchFileProc,      INVOCA_VALUE },
    { "JobPatchFile",           IJobPatchFileProc,   INVOCA_VALUE | REQ_OPTION },
    { "PSVersion",              IPSVersionProc,      QUOTED_NOHEX | ALLOW_MULTI },
    { "ModelName",              INullProc,                       QUOTED_VALUE },
    { "Product",                IProductProc,        QUOTED_NOHEX | ALLOW_MULTI },
    { "SuggestedJobTimeout",    IJobTimeoutProc,     QUOTED_VALUE },
    { "SuggestedWaitTimeout",   IWaitTimeoutProc,    QUOTED_VALUE },
    { "PrintPSErrors",          IPrintPSErrProc,     STRING_VALUE },
    { "JCLBegin",               IJCLBeginProc,       QUOTED_VALUE },
    { "JCLToPSInterpreter",     IJCLToPSProc,        QUOTED_VALUE },
    { "JCLEnd",                 IJCLEndProc,         QUOTED_VALUE },
    { "LandscapeOrientation",   ILSOrientProc,       STRING_VALUE },
    { gstrCustomSizeKwd,        ICustomSizeProc,     INVOCA_VALUE | REQ_OPTION },
    { "ParamCustomPageSize",    IParamCustomProc,    STRING_VALUE | REQ_OPTION },
    { "MaxMediaWidth",          IMaxWidthProc,       QUOTED_VALUE },
    { "MaxMediaHeight",         IMaxHeightProc,      QUOTED_VALUE },
    { "HWMargins",              IHWMarginsProc,      STRING_VALUE },
    { "CenterRegistered",       ICenterRegProc,      STRING_VALUE },
    { "ADORequiresEExec",        IReqEExecProc,       STRING_VALUE },
    { "ADOTTFontSub",            ITTFontSubProc,      QUOTED_VALUE | REQ_OPTION },
    { "ADTrueGray",             ITrueGrayProc,       STRING_VALUE },
    { "ADHasEuro",              IHasEuroProc,        STRING_VALUE },
    { "Throughput",             IThroughputProc,     QUOTED_NOHEX },
    { "SymbolValue",            ISymbolValueProc,    INVOCA_VALUE | REQ_OPTION },
    { "Status",                 INullProc,           QUOTED_VALUE | ALLOW_MULTI },
    { "PrinterError",           INullProc,           QUOTED_VALUE | ALLOW_MULTI },
    { "SymbolLength",           INullProc,           STRING_VALUE | REQ_OPTION },
    { "SymbolEnd",              INullProc,           STRING_VALUE | ALLOW_MULTI },
    { "End",                    INullProc,           VALUETYPE_NONE | ALLOW_MULTI },
};

#define NUM_BUILTIN_KEYWORDS (sizeof(gPpdBuiltInKeywordTable) / sizeof(KWDENTRY))



DWORD
DwHashKeyword(
    PSTR    pstrKeyword
    )

/*++

Routine Description:

    Compute the hash value for the specified keyword string

Arguments:

    pstrKeyword - Pointer to the keyword string to be hashed

Return Value:

    Hash value computed using the specified keyword string

--*/

{
    PBYTE   pub = (PBYTE) pstrKeyword;
    DWORD   dwHashValue = 0;

    while (*pub)
        dwHashValue = (dwHashValue << 1) ^ *pub++;

    return dwHashValue;
}



PKWDENTRY
PSearchKeywordTable(
    PPARSERDATA pParserData,
    PSTR        pstrKeyword,
    INT        *piIndex
    )

/*++

Routine Description:

    Check if a keyword appears in the built-in keyword table

Arguments:

    pParserData - Points to parser data structure
    pstrKeyword - Specifies the keyword to be searched
    piIndex - Returns the index of the entry in the built-in keyword
        table corresponding to the specified keyword.

Return Value:

    Pointer to the entry in the built-in table corresponding to the
    specified keyword. NULL if the specified keyword is not supported.

--*/

{
    DWORD   dwHashValue;
    INT     iIndex;

    ASSERT(pstrKeyword != NULL);
    dwHashValue = DwHashKeyword(pstrKeyword);

    for (iIndex = 0; iIndex < NUM_BUILTIN_KEYWORDS; iIndex++)
    {
        if (pParserData->pdwKeywordHashs[iIndex] == dwHashValue &&
            strcmp(gPpdBuiltInKeywordTable[iIndex].pstrKeyword, pstrKeyword) == EQUAL_STRING)
        {
            *piIndex = iIndex;
            return (PKWDENTRY) &gPpdBuiltInKeywordTable[iIndex];
        }
    }

    return NULL;
}



BOOL
BInitKeywordLookup(
    PPARSERDATA pParserData
    )

/*++

Routine Description:

    Build up data structures to speed up keyword lookup

Arguments:

    pParserData - Points to parser data structure

Return Value:

    TRUE if successful, FALSE if there is an error

--*/

{
    DWORD   iIndex, iCount;

    //
    // Allocate memory to hold extra data structures
    //

    iCount = NUM_BUILTIN_KEYWORDS;
    pParserData->pdwKeywordHashs = ALLOC_PARSER_MEM(pParserData, iCount * sizeof(DWORD));
    pParserData->pubKeywordCounts = ALLOC_PARSER_MEM(pParserData, iCount * sizeof(BYTE));

    if (!pParserData->pdwKeywordHashs || !pParserData->pubKeywordCounts)
    {
        ERR(("Memory allocation failed: %d\n", GetLastError()));
        return FALSE;
    }

    //
    // Precompute the hash values for built-in keywords
    //

    for (iIndex = 0; iIndex < iCount; iIndex++)
    {
        pParserData->pdwKeywordHashs[iIndex] =
            DwHashKeyword((PSTR) gPpdBuiltInKeywordTable[iIndex].pstrKeyword);
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\parsers\ppd\ppdparse.c ===
/*++

Copyright (c) 1996-1997  Microsoft Corporation

Module Name:

    ppdparse.c

Abstract:

    Parser for converting PPD file from ASCII text to binary data

Environment:

    PostScript driver, PPD parser

Revision History:

    12/03/96 -davidx-
        Check binary file date against all source printer description files.

    09/30/96 -davidx-
        Cleaner handling of ManualFeed and AutoSelect feature.

    09/17/96 -davidx-
        Add link field to order dependency structure.

    08/22/96 -davidx-
        New binary data format for NT 5.0.

    08/20/96 -davidx-
        Common coding style for NT 5.0 drivers.

    03/26/96 -davidx-
        Created it.

--*/


#include "lib.h"
#include "ppd.h"
#include "ppdparse.h"
#include "ppdrsrc.h"

//
// Round up n to a multiple of m
//

#define ROUND_UP_MULTIPLE(n, m) ((((n) + (m) - 1) / (m)) * (m))

//
// Round up n to a multiple of sizeof(DWORD) = 4
//

#define DWORD_ALIGN(n) (((n) + 3) & ~3)

//
// Raise an exception to cause VPackBinaryData to fail
//

#define PACK_BINARY_DATA_EXCEPTION() RaiseException(0xC0000000, 0, 0, NULL);

//
// Display a semantic error message
//

#define SEMANTIC_ERROR(arg) { TERSE(arg); pParserData->bErrorFlag = TRUE; }

//
// Data structure to store meta-information about a printer feature
// Note that the default order dependency value is relative to MAX_ORDER_VALUE.
// Explicitly specified order value must be less than MAX_ORDER_VALUE.
//
// We assume all printer-sticky features have higher priority than
// all doc-sticky features. The priority values for printer-sticky
// feature must be >= PRNPROP_BASE_PRIORITY.
//

#define MAX_ORDER_VALUE         0x7fffffff
#define PRNPROP_BASE_PRIORITY   0x10000

typedef struct _FEATUREDATA {

    DWORD   dwFeatureID;        // predefined feature ID
    DWORD   dwOptionSize;       // size of the associated option structure
    DWORD   dwPriority;         // feature priority
    DWORD   dwFlags;            // feature flags

} FEATUREDATA, *PFEATUREDATA;


//
// Special code page value used internally in this file.
// Make sure they don't conflict with standard code page values.
//

#define CP_ERROR        0xffffffff
#define CP_UNICODE      0xfffffffe



PFEATUREDATA
PGetFeatureData(
    DWORD   dwFeatureID
    )

/*++

Routine Description:

    Return meta-information about the requested feature

Arguments:

    dwFeatureID - Specifies what feature the caller is interested in

Return Value:

    Pointer to a FEATUREDATA structure corresponding to the request feature

--*/

{
    static FEATUREDATA FeatureData[] =
    {
        { GID_RESOLUTION,     sizeof(RESOLUTION),  10,  0},
        { GID_PAGESIZE,       sizeof(PAGESIZE),    50,  0},
        { GID_PAGEREGION,     sizeof(OPTION),      40,  FEATURE_FLAG_NOUI},
        { GID_DUPLEX,         sizeof(DUPLEX),      20,  0},
        { GID_INPUTSLOT,      sizeof(INPUTSLOT),   30,  0},
        { GID_MEDIATYPE,      sizeof(MEDIATYPE),   10,  0},
        { GID_COLLATE,        sizeof(COLLATE),     10,  0},
        { GID_OUTPUTBIN,      sizeof(OUTPUTBIN),   10,  0},
        { GID_MEMOPTION,      sizeof(MEMOPTION),   10,  0},
        { GID_LEADINGEDGE,    sizeof(OPTION),      25,  FEATURE_FLAG_NOUI | FEATURE_FLAG_NOINVOCATION},
        { GID_USEHWMARGINS,   sizeof(OPTION),      25,  FEATURE_FLAG_NOUI | FEATURE_FLAG_NOINVOCATION},
        { GID_UNKNOWN,        sizeof(OPTION),       0,  0},
    };

    DWORD   dwIndex;

    for (dwIndex = 0; FeatureData[dwIndex].dwFeatureID != GID_UNKNOWN; dwIndex++)
    {
        if (FeatureData[dwIndex].dwFeatureID == dwFeatureID)
            break;
    }

    return &FeatureData[dwIndex];
}



VOID
VGrowPackBuffer(
    PPARSERDATA pParserData,
    DWORD       dwBytesNeeded
    )

/*++

Routine Description:

    Grow the buffer used to hold packed binary data if necessary

Arguments:

    pParserData - Points to parser data structure
    dwBytesNeeded - Number of bytes needed

Return Value:

    NONE

--*/

#define PACK_BUFFER_MAX 1024    // measured in number of pages

{
    VALIDATE_PARSER_DATA(pParserData);

    //
    // We need to commit more memory if the number of bytes needed plus the
    // number of bytes used is over the maximum number of bytes committed.
    //

    if ((dwBytesNeeded += pParserData->dwBufSize) > pParserData->dwCommitSize)
    {
        //
        // Check if we're being called for the first time.
        // In that case, we'll need to reserved the virtual address space.
        //

        if (pParserData->pubBufStart == NULL)
        {
            SYSTEM_INFO SystemInfo;
            PBYTE       pbuf;

            GetSystemInfo(&SystemInfo);
            pParserData->dwPageSize = SystemInfo.dwPageSize;

            pbuf = VirtualAlloc(NULL,
                                PACK_BUFFER_MAX * SystemInfo.dwPageSize,
                                MEM_RESERVE,
                                PAGE_READWRITE);

            if (pbuf == NULL)
            {
                ERR(("Cannot reserve memory: %d\n", GetLastError()));
                PACK_BINARY_DATA_EXCEPTION();
            }

            pParserData->pubBufStart = pbuf;
            pParserData->pInfoHdr = (PINFOHEADER) pbuf;
            pParserData->pUIInfo = (PUIINFO) (pbuf + sizeof(INFOHEADER));
            pParserData->pPpdData = (PPPDDATA) (pbuf + sizeof(INFOHEADER) + sizeof(UIINFO));
        }

        //
        // Make sure we're not overflowing
        //

        if (dwBytesNeeded > (PACK_BUFFER_MAX * pParserData->dwPageSize))
        {
            ERR(("Binary printer description is too big.\n"));
            PACK_BINARY_DATA_EXCEPTION();
        }

        //
        // Commit the extra amount of memory needed (rounded up
        // to the next page boundary). Note that the memory allocated
        // using VirtualAlloc is zero-initialized.
        //

        dwBytesNeeded -= pParserData->dwCommitSize;
        dwBytesNeeded = ROUND_UP_MULTIPLE(dwBytesNeeded, pParserData->dwPageSize);
        pParserData->dwCommitSize += dwBytesNeeded;

        if (! VirtualAlloc(pParserData->pubBufStart,
                           pParserData->dwCommitSize,
                           MEM_COMMIT,
                           PAGE_READWRITE))
        {
            ERR(("Cannot commit memory: %d\n", GetLastError()));
            PACK_BINARY_DATA_EXCEPTION();
        }
    }
}



PVOID
PvFindListItem(
    PVOID   pvList,
    PCSTR   pstrName,
    PDWORD  pdwIndex
    )

/*++

Routine Description:

    Find a named item from a linked-list

Arguments:

    pParserData - Points to parser data structure
    pstrName - Specifies the item name to be found
    pdwIndex - Points to a variable for returning a zero-based item index

Return Value:

    Points to the named listed item, NULL if the named item is not in the list

Note:

    We're not bothering with fancy data structures here because the parser
    is used infrequently to convert a ASCII printer description file to its
    binary version. After that, the driver will access binary data directly.

--*/

{
    PLISTOBJ pItem;
    DWORD    dwIndex;

    for (pItem = pvList, dwIndex = 0;
        pItem && strcmp(pItem->pstrName, pstrName) != EQUAL_STRING;
        pItem = pItem->pNext, dwIndex++)
    {
    }

    if (pdwIndex)
        *pdwIndex = dwIndex;

    return pItem;
}



DWORD
DwCountListItem(
    PVOID   pvList
    )

/*++

Routine Description:

    Count the number of items in a linked-list

Arguments:

    pvList - Points to a linked-list

Return Value:

    Number of items in a linked-list

--*/

{
    PLISTOBJ pItem;
    DWORD    dwCount;

    for (pItem = pvList, dwCount = 0;
        pItem != NULL;
        pItem = pItem->pNext, dwCount++)
    {
    }

    return dwCount;
}



VOID
VPackStringUnicode(
    PPARSERDATA pParserData,
    PTRREF     *ploDest,
    PWSTR       pwstrSrc
    )

/*++

Routine Description:

    Pack a Unicode string into the binary data file

Arguments:

    pParserData - Points to the parser data structure
    ploDest - Returns the byte offset of the packed Unicode string
    pwstrSrc - Specifies the source Unicode string to be packed

Return Value:

    NONE

--*/

{
    if (pwstrSrc == NULL)
        *ploDest = 0;
    else
    {
        DWORD   dwSize = (wcslen(pwstrSrc) + 1) * sizeof(WCHAR);

        VGrowPackBuffer(pParserData, dwSize);
        CopyMemory(pParserData->pubBufStart + pParserData->dwBufSize, pwstrSrc, dwSize);

        *ploDest = pParserData->dwBufSize;
        pParserData->dwBufSize += DWORD_ALIGN(dwSize);
    }
}



VOID
VPackStringRsrc(
    PPARSERDATA pParserData,
    PTRREF     *ploDest,
    INT         iStringId
    )

/*++

Routine Description:

    Pack a Unicode string resource into the binary data file

Arguments:

    pParserData - Points to the parser data structure
    ploDest - Returns the byte offset of the packed Unicode string
    iStringId - Specifies the resource ID of the Unicode string to be packed

Return Value:

    NONE

--*/

{
    WCHAR   awchBuffer[MAX_XLATION_LEN];

    if (! LoadString(ghInstance, iStringId, awchBuffer, MAX_XLATION_LEN))
        awchBuffer[0] = NUL;

    VPackStringUnicode(pParserData, ploDest, awchBuffer);
}



VOID
VPackStringAnsi(
    PPARSERDATA pParserData,
    PTRREF     *ploDest,
    PSTR        pstrSrc
    )

/*++

Routine Description:

    Pack an ANSI string into the binary data file

Arguments:

    pParserData - Points to the parser data structure
    ploDest - Returns the byte offset of the packed ANSI string
    pstrSrc - Specifies the source ANSI string to be packed

Return Value:

    NONE

--*/

{
    if (pstrSrc == NULL)
        *ploDest = 0;
    else
    {
        DWORD   dwSize = strlen(pstrSrc) + 1;

        VGrowPackBuffer(pParserData, dwSize);
        CopyMemory(pParserData->pubBufStart + pParserData->dwBufSize, pstrSrc, dwSize);

        *ploDest = pParserData->dwBufSize;
        pParserData->dwBufSize += DWORD_ALIGN(dwSize);
    }
}



INT
ITranslateToUnicodeString(
    PWSTR   pwstr,
    PCSTR   pstr,
    INT     iLength,
    UINT    uCodePage
    )

/*++

Routine Description:

    Translate an ANSI string to Unicode string

Arguments:

    pwstr - Buffer for storing Unicode string
    pstr - Pointer to ANSI string to be translated
    iLength - Length of ANSI string, in bytes
    uCodePage - Code page used to do the translation

Return Value:

    Number of Unicode characters translated
    0 if there is an error

--*/

{
    ASSERT(iLength >= 0);

    if (uCodePage == CP_UNICODE)
    {
        INT i;

        //
        // Make sure the Unicode translation string has even number of bytes
        //

        if (iLength & 1)
        {
            TERSE(("Odd number of bytes in Unicode translation string.\n"));
            iLength--;
        }

        //
        // We assume Unicode values are specified in big-endian format in
        // the PPD file. Internally we store Unicode values in little-endian
        // format. So we need to swap bytes here.
        //

        iLength /= sizeof(WCHAR);

        for (i=iLength; i--; pstr += 2)
            *pwstr++ = (pstr[0] << 8) | ((BYTE) pstr[1]);
    }
    else
    {
        if (uCodePage == CP_ERROR)
            uCodePage = CP_ACP;

        iLength = MultiByteToWideChar(uCodePage, 0, pstr, iLength, pwstr, iLength);

        ASSERT(iLength >= 0);
    }

    return iLength;
}



VOID
VPackStringAnsiToUnicode(
    PPARSERDATA pParserData,
    PTRREF     *ploDest,
    PSTR        pstrSrc,
    INT         iLength
    )

/*++

Routine Description:

    Convert an ANSI string to Unicode and pack it into the binary data file

Arguments:

    pParserData - Points to the parser data structure
    ploDest - Returns the byte offset of the packed Unicode string
    pstrSrc - Specifies the source ANSI string to be packed
    iLength - Specifies the byte length of the ANSI string

Return Value:

    NONE

--*/

{
    INT     iSize;
    PTSTR   ptstr;

    //
    // Source string is NULL
    //

    if (pstrSrc == NULL)
    {
        *ploDest = 0;
        return;
    }

    //
    // If source string length is -1, it means
    // the source string is null-terminated.
    //

    if (iLength == -1)
        iLength = strlen(pstrSrc);

    if (pParserData->uCodePage == CP_UNICODE)
    {
        //
        // Source string is Unicode string
        //

        iSize = iLength + sizeof(WCHAR);
    }
    else
    {
        //
        // Source string is ANSI string
        //

        iSize = (iLength + 1) * sizeof(WCHAR);
    }

    VGrowPackBuffer(pParserData, iSize);
    ptstr = (PTSTR) (pParserData->pubBufStart + pParserData->dwBufSize);
    *ploDest = pParserData->dwBufSize;
    pParserData->dwBufSize += DWORD_ALIGN(iSize);

    ITranslateToUnicodeString(ptstr, pstrSrc, iLength, pParserData->uCodePage);
}



VOID
VPackStringXlation(
    PPARSERDATA pParserData,
    PTRREF     *ploDest,
    PSTR        pstrName,
    PINVOCOBJ   pXlation
    )

/*++

Routine Description:

    Figure out the display name of an item, convert it from ANSI
    to Unicode string, and pack it into the binary data

Arguments:

    pParserData - Points to the parser data structure
    ploDest - Returns the byte offset of the packed Unicode string
    pstrName - Specifies the name string associated with the item
    pXlation - Specifies the translation string associated with the item

Return Value:

    NONE

--*/

{
    //
    // The display name of an item is its translation string if there is one.
    // Otherwise, the display name is the same as the name of the item.
    //
    // If the translation is present, use the current language encoding
    // to convert it to Unicode. Otherwise, we always use the ISOLatin1
    // encoding to convert the name of the item to Unicode.
    //

    if (pXlation && pXlation->pvData && pParserData->uCodePage != CP_ERROR)
        VPackStringAnsiToUnicode(pParserData, ploDest, pXlation->pvData, pXlation->dwLength);
    else
    {
        UINT uCodePage = pParserData->uCodePage;

        pParserData->uCodePage = 1252;
        VPackStringAnsiToUnicode(pParserData, ploDest, pstrName, -1);
        pParserData->uCodePage = uCodePage;
    }
}



VOID
VPackInvocation(
    PPARSERDATA pParserData,
    PINVOCATION pInvocation,
    PINVOCOBJ   pInvocObj
    )

/*++

Routine Description:

    Pack an invocation string into the binary data

Arguments:

    pParserData - Points to the parser data structure
    pInvocation - Returns information about the packed invocation string
    pInvocObj - Points to the invocation string to be packed

Return Value:

    NONE

--*/

{
    if (IS_SYMBOL_INVOC(pInvocObj))
    {
        //
        // The invocation is a symbol reference
        //

        PSYMBOLOBJ  pSymbol = pInvocObj->pvData;

        pInvocation->dwCount = pSymbol->Invocation.dwLength;

        //
        // For symbol invocation, Invocation.pvData actually stores the
        // 32-bit offset value (See function VPackSymbolDefinitions), so
        // it's safe to cast it into ULONG/DWORD.
        //

        pInvocation->loOffset = (PTRREF) PtrToUlong(pSymbol->Invocation.pvData);
    }
    else if (pInvocObj->dwLength == 0)
    {
        pInvocation->dwCount = 0;
        pInvocation->loOffset = 0;
    }
    else
    {
        //
        // Notice that we're always padding a zero byte at the end of
        // the invocation string. This byte is not counted in dwLength.
        //

        VGrowPackBuffer(pParserData, pInvocObj->dwLength+1);

        CopyMemory(pParserData->pubBufStart + pParserData->dwBufSize,
                   pInvocObj->pvData,
                   pInvocObj->dwLength);

        pInvocation->dwCount = pInvocObj->dwLength;
        pInvocation->loOffset = pParserData->dwBufSize;
        pParserData->dwBufSize += DWORD_ALIGN(pInvocObj->dwLength+1);
    }
}


VOID
VPackPatch(
    PPARSERDATA pParserData,
    PJOBPATCHFILE     pPackedPatch,
    PJOBPATCHFILEOBJ  pPatchObj
    )

/*++

Routine Description:

    Pack an job file patch invocation string into the binary data

Arguments:

    pParserData - Points to the parser data structure
    pInvocation - Returns information about the packed invocation string
    pInvocObj - Points to the invocation string to be packed

Return Value:

    NONE

--*/

{
    if (pPatchObj->Invocation.dwLength == 0)
    {
        pPackedPatch->dwCount = 0;
        pPackedPatch->loOffset = 0;
    }
    else
    {
        //
        // Notice that we're always padding a zero byte at the end of
        // the invocation string. This byte is not counted in dwLength.
        //

        VGrowPackBuffer(pParserData, pPatchObj->Invocation.dwLength+1);

        CopyMemory(pParserData->pubBufStart + pParserData->dwBufSize,
                   pPatchObj->Invocation.pvData,
                   pPatchObj->Invocation.dwLength);

        pPackedPatch->loOffset = pParserData->dwBufSize;
        pPackedPatch->dwCount = pPatchObj->Invocation.dwLength;

        pParserData->dwBufSize += DWORD_ALIGN(pPatchObj->Invocation.dwLength+1);
    }

    pPackedPatch->lJobPatchNo = pPatchObj->lPatchNo;
}



VOID
VPackSymbolDefinitions(
    PPARSERDATA pParserData
    )

/*++

Routine Description:

    Pack all symbol definitions into the binary data

Arguments:

    pParserData - Points to the parser data structure

Return Value:

    NONE

--*/

{
    PINVOCOBJ   pInvocObj;
    PSYMBOLOBJ  pSymbol;

    VALIDATE_PARSER_DATA(pParserData);

    for (pSymbol = pParserData->pSymbols;
        pSymbol != NULL;
        pSymbol = pSymbol->pNext)
    {
        pInvocObj = &pSymbol->Invocation;
        ASSERT(! IS_SYMBOL_INVOC(pInvocObj));

        if (pInvocObj->dwLength == 0)
            pInvocObj->pvData = NULL;
        else
        {
            //
            // Notice that we're always padding a zero byte at the end of
            // the invocation string. This byte is not counted in dwLength.
            //

            VGrowPackBuffer(pParserData, pInvocObj->dwLength+1);

            CopyMemory(pParserData->pubBufStart + pParserData->dwBufSize,
                       pInvocObj->pvData,
                       pInvocObj->dwLength);

            pInvocObj->pvData = (PVOID)ULongToPtr(pParserData->dwBufSize);
            pParserData->dwBufSize += DWORD_ALIGN(pInvocObj->dwLength+1);
        }
    }
}



VOID
VResolveSymbolInvocation(
    PPARSERDATA pParserData,
    PINVOCOBJ   pInvocObj
    )

/*++

Routine Description:

    Check if an invocation string is a symbol reference and resolve it if necessary

Arguments:

    pParserData - Points to the parser data structure
    pInvocObj - Specifies the invocation string to be resolved

Return Value:

    NONE

--*/

{
    if (IS_SYMBOL_INVOC(pInvocObj))
    {
        PSTR        pstrName;
        PSYMBOLOBJ  pSymbol;

        pstrName = (PSTR) pInvocObj->pvData;

        if ((pSymbol = PvFindListItem(pParserData->pSymbols, pstrName, NULL)) == NULL)
        {
            SEMANTIC_ERROR(("Undefined symbol: %s\n", pstrName));
            pInvocObj->dwLength = 0;
            pInvocObj->pvData = NULL;
        }
        else
            pInvocObj->pvData = (PVOID) pSymbol;
    }
}



VOID
VResolveSymbolReferences(
    PPARSERDATA pParserData
    )

/*++

Routine Description:

    Resolve all symbol references in the parsed PPD data

Arguments:

    pParserData - Points to the parser data structure

Return Value:

    NONE

--*/

{
    PFEATUREOBJ pFeature;
    POPTIONOBJ  pOption;
    PJOBPATCHFILEOBJ  pJobPatchFile;

    VALIDATE_PARSER_DATA(pParserData);

    VResolveSymbolInvocation(pParserData, &pParserData->Password);
    VResolveSymbolInvocation(pParserData, &pParserData->ExitServer);
    VResolveSymbolInvocation(pParserData, &pParserData->PatchFile);
    VResolveSymbolInvocation(pParserData, &pParserData->JclBegin);
    VResolveSymbolInvocation(pParserData, &pParserData->JclEnterPS);
    VResolveSymbolInvocation(pParserData, &pParserData->JclEnd);
    VResolveSymbolInvocation(pParserData, &pParserData->ManualFeedFalse);

    for (pFeature = pParserData->pFeatures;
        pFeature != NULL;
        pFeature = pFeature->pNext)
    {
        VResolveSymbolInvocation(pParserData, &pFeature->QueryInvoc);

        for (pOption = pFeature->pOptions;
            pOption != NULL;
            pOption = pOption->pNext)
        {
            VResolveSymbolInvocation(pParserData, &pOption->Invocation);
        }
    }

    for (pJobPatchFile = pParserData->pJobPatchFiles;
        pJobPatchFile != NULL;
        pJobPatchFile = pJobPatchFile->pNext)
    {
        VResolveSymbolInvocation(pParserData, &pJobPatchFile->Invocation);
    }
}



BOOL
BFindUIConstraintFeatureOption(
    PPARSERDATA pParserData,
    PCSTR       pstrKeyword,
    PFEATUREOBJ *ppFeature,
    PDWORD      pdwFeatureIndex,
    PCSTR       pstrOption,
    POPTIONOBJ  *ppOption,
    PDWORD      pdwOptionIndex
    )

/*++

Routine Description:

    Find the feature/option specified in UIConstraints and OrderDependency entries

Arguments:

    pParserData - Points to the parser data structure
    pstrKeyword - Specifies the feature keyword string
    ppFeature - Return a pointer to the feature structure found
    pdwFeatureIndex - Return the index of the feature found
    pstrOption - Specifies the option keyword string
    ppOption - Return a pointer to the option structure found
    pdwOptionIndex - Return the index of the option found

Return Value:

    TRUE if successful, FALSE if the specified feature/option is not found

--*/

{
    if (! (pstrKeyword = PstrStripKeywordChar(pstrKeyword)))
        return FALSE;

    //
    // HACK:
    //  replace *ManualFeed True option with *InputSlot ManualFeed option
    //  replace *CustomPageSize True option with *PageSize CustomPageSize option
    //

    if ((strcmp(pstrKeyword, gstrManualFeedKwd) == EQUAL_STRING) &&
        (*pstrOption == NUL ||
         strcmp(pstrOption, gstrTrueKwd) == EQUAL_STRING ||
         strcmp(pstrOption, gstrOnKwd) == EQUAL_STRING))
    {
        pstrKeyword = gstrInputSlotKwd;
        pstrOption = gstrManualFeedKwd;
    }
    else if ((strcmp(pstrKeyword, gstrCustomSizeKwd) == EQUAL_STRING) &&
             (*pstrOption == NUL || strcmp(pstrOption, gstrTrueKwd) == EQUAL_STRING))
    {
        pstrKeyword = gstrPageSizeKwd;
        pstrOption = gstrCustomSizeKwd;
    }
    else if (strcmp(pstrKeyword, gstrVMOptionKwd) == EQUAL_STRING)
        pstrKeyword = gstrInstallMemKwd;

    //
    // Find the specified feature
    //

    if (! (*ppFeature = PvFindListItem(pParserData->pFeatures, pstrKeyword, pdwFeatureIndex)))
        return FALSE;

    //
    // Find the specified option
    //

    if (*pstrOption)
    {
        return (*ppOption = PvFindListItem((*ppFeature)->pOptions,
                                           pstrOption,
                                           pdwOptionIndex)) != NULL;
    }
    else
    {
        *ppOption = NULL;
        *pdwOptionIndex = OPTION_INDEX_ANY;
        return TRUE;
    }
}



VOID
VPackUIConstraints(
    PPARSERDATA pParserData
    )

/*++

Routine Description:

    Pack UIConstraints information into binary data

Arguments:

    pParserData - Points to the parser data structure

Return Value:

    NONE

--*/

{
    PUICONSTRAINT   pPackedConstraint;
    PFEATUREOBJ     pFeature;
    POPTIONOBJ      pOption;
    PLISTOBJ        pConstraint;
    DWORD           dwConstraints, dwConstraintBufStart;

    VALIDATE_PARSER_DATA(pParserData);

    //
    // By default, there is no constaint for all features and options
    //

    for (pFeature = pParserData->pFeatures;
        pFeature != NULL;
        pFeature = pFeature->pNext)
    {
        pFeature->dwConstraint = NULL_CONSTRAINT;

        for (pOption = pFeature->pOptions;
            pOption != NULL;
            pOption = pOption->pNext)
        {
            pOption->dwConstraint = NULL_CONSTRAINT;
        }
    }

    //
    // Count the number of *UIConstraints entries
    //

    dwConstraints = DwCountListItem(pParserData->pUIConstraints);

    if (dwConstraints == 0)
        return;
    //
    // Don't yet grow the buffer, we only number the number of constraints after we
    // evaluated the *ManualFeed: False constraints. pPackedConstraint points right
    // after the end of the current buffer
    //
    pPackedConstraint = (PUICONSTRAINT) (pParserData->pubBufStart + pParserData->dwBufSize);
    dwConstraintBufStart = pParserData->dwBufSize;

    //
    // Interpret each *UIConstraints entry
    //

    dwConstraints = 0;

    for (pConstraint = pParserData->pUIConstraints;
        pConstraint != NULL;
        pConstraint = pConstraint->pNext)
    {
        PFEATUREOBJ pFeature2;
        POPTIONOBJ  pOption2;
        DWORD       dwFeatureIndex, dwOptionIndex, dwManFeedFalsePos = 0;
        CHAR        achWord1[MAX_WORD_LEN];
        CHAR        achWord2[MAX_WORD_LEN];
        CHAR        achWord3[MAX_WORD_LEN];
        CHAR        achWord4[MAX_WORD_LEN];
        PSTR        pstr = pConstraint->pstrName;
        BOOL        bSuccess = FALSE;

        //
        // The value for a UIConstraints entry consists of four separate components:
        //  featureName1 [optionName1] featureName2 [optionName2]
        //

        (VOID) BFindNextWord(&pstr, achWord1);

        if (IS_KEYWORD_CHAR(*pstr))
            achWord2[0] = NUL;
        else
            (VOID) BFindNextWord(&pstr, achWord2);

        (VOID) BFindNextWord(&pstr, achWord3);
        (VOID) BFindNextWord(&pstr, achWord4);

        //
        // hack the *ManualFeed False constraints
        //
        if ((IS_KEYWORD_CHAR(achWord1[0])) &&
            (strcmp(&(achWord1[1]), gstrManualFeedKwd) == EQUAL_STRING) &&
            (strcmp(achWord2, gstrFalseKwd) == EQUAL_STRING))
        {
            //
            // check the validity of the constraint feature/option. Fall through if invalid
            //
            if (BFindUIConstraintFeatureOption(pParserData,
                                               achWord3,
                                               &pFeature,
                                               &dwFeatureIndex,
                                               achWord4,
                                               &pOption,
                                               &dwOptionIndex))
                dwManFeedFalsePos = 1;
        }
        else if ((IS_KEYWORD_CHAR(achWord3[0])) &&
                 (strcmp(&(achWord3[1]), gstrManualFeedKwd) == EQUAL_STRING) &&
                 (strcmp(achWord4, gstrFalseKwd) == EQUAL_STRING))
        {
            //
            // check the validity of the constraint feature/option. Fall through if invalid
            //
            if (BFindUIConstraintFeatureOption(pParserData,
                                               achWord1,
                                               &pFeature,
                                               &dwFeatureIndex,
                                               achWord2,
                                               &pOption,
                                               &dwOptionIndex))
                dwManFeedFalsePos = 2;

        }
        if (dwManFeedFalsePos)
        {
            //
            // get the index of the manual feed input slot
            //
            DWORD dwInputSlotFeatIndex, dwManFeedSlotIndex, dwInputSlotCount, dwSlotIndex;
            PFEATUREOBJ pInputSlotFeature;

            if ((pInputSlotFeature = PvFindListItem(pParserData->pFeatures, gstrInputSlotKwd, &dwInputSlotFeatIndex)) == NULL)
            {
                ERR(("Input slot feature not found !!!"));
                continue;
            }

            //
            // get the number of input slots. Note that this includes the dummy "*UseFormTrayTable" slot.
            //
            dwInputSlotCount = DwCountListItem((PVOID) pInputSlotFeature->pOptions);

            if (dwInputSlotCount <= 2) // to make sense there must be at least 3 slot, incl. UseFormTrayTable+ManualFeed
            {
                ERR(("ManualFeed used - internally at least 3 input slots expected !"));
                continue;
            }

            //
            // grow the buffer for constraints. Two less than input slots because
            //      1 input slot is the dummy UseFormTrayTable slot
            //      1 input slot is the ManualFeed slot that I don't want to constraint
            //
            VGrowPackBuffer(pParserData, (dwInputSlotCount -2) * sizeof(UICONSTRAINT));

            if (dwManFeedFalsePos == 1)
            {
                //
                // add constraints to each input slot for the constrained feature
                //
                POPTIONOBJ pNextObj = pInputSlotFeature->pOptions;

                ASSERT(strcmp(pNextObj->pstrName, "*UseFormTrayTable") == EQUAL_STRING); // in case we change the logic some time later...

                //
                // since the UseFormTrayTable is the first option, start with the second
                //
                pNextObj = pNextObj->pNext;
                ASSERT(pNextObj != NULL);

                while (pNextObj)
                {
                    //
                    // skip the manual feed input slot, don't constrain that
                    //
                    if (strcmp(pNextObj->pstrName, gstrManualFeedKwd) == EQUAL_STRING)
                    {
                        pNextObj = pNextObj->pNext;
                        continue;
                    }

                    pPackedConstraint[dwConstraints].dwNextConstraint = pNextObj->dwConstraint;
                    pNextObj->dwConstraint = dwConstraints;

                    pPackedConstraint[dwConstraints].dwFeatureIndex = dwFeatureIndex;
                    pPackedConstraint[dwConstraints].dwOptionIndex = dwOptionIndex;
                    dwConstraints++;

                    pNextObj = pNextObj->pNext;
                }
            }
            else
            {
                //
                // find the option index of the manual feed slot
                //
                if (PvFindListItem(pInputSlotFeature->pOptions, gstrManualFeedKwd, &dwManFeedSlotIndex) == NULL)
                {
                    ERR(("ManualFeed slot not found among InputSlots !!!"));
                    continue;
                }

                //
                // add constraints to the affected feature for all input slots BUT the manual feed slot
                // and the UseFormTrayTable slot
                // start with slot index 1, because the first slot is always *UseFormTrayTable
                //
                for (dwSlotIndex = 1; dwSlotIndex < dwInputSlotCount; dwSlotIndex++)
                {
                    if (dwSlotIndex == dwManFeedSlotIndex)
                        continue;

                    if (pOption == NULL)
                    {
                        //
                        // OptionKeyword1 field is not present
                        //

                        pPackedConstraint[dwConstraints].dwNextConstraint = pFeature->dwConstraint;
                        pFeature->dwConstraint = dwConstraints;
                    }
                    else
                    {
                        //
                        // OptionKeyword1 field is present
                        //

                        pPackedConstraint[dwConstraints].dwNextConstraint = pOption->dwConstraint;
                        pOption->dwConstraint = dwConstraints;
                    }

                    pPackedConstraint[dwConstraints].dwFeatureIndex = dwInputSlotFeatIndex;
                    pPackedConstraint[dwConstraints].dwOptionIndex = dwSlotIndex;
                    dwConstraints++;
                }
            }

            //
            // increase the committed buffer size so additional VGrowPackBuffer calls can allocate
            // additional pages if needed for more *ManualFeed False constraints
            //
            pParserData->dwBufSize += DWORD_ALIGN((dwInputSlotCount -2) * sizeof(UICONSTRAINT));

            continue;
        } // back to the normal course of events.

        if (BFindUIConstraintFeatureOption(pParserData,
                                           achWord1,
                                           &pFeature,
                                           &dwFeatureIndex,
                                           achWord2,
                                           &pOption,
                                           &dwOptionIndex) &&
            BFindUIConstraintFeatureOption(pParserData,
                                           achWord3,
                                           &pFeature2,
                                           &dwFeatureIndex,
                                           achWord4,
                                           &pOption2,
                                           &dwOptionIndex))
        {
            VGrowPackBuffer(pParserData, sizeof(UICONSTRAINT));

            if (pOption == NULL)
            {
                //
                // OptionKeyword1 field is not present
                //

                pPackedConstraint[dwConstraints].dwNextConstraint = pFeature->dwConstraint;
                pFeature->dwConstraint = dwConstraints;
            }
            else
            {
                //
                // OptionKeyword1 field is present
                //

                pPackedConstraint[dwConstraints].dwNextConstraint = pOption->dwConstraint;
                pOption->dwConstraint = dwConstraints;
            }

            pPackedConstraint[dwConstraints].dwFeatureIndex = dwFeatureIndex;
            pPackedConstraint[dwConstraints].dwOptionIndex = dwOptionIndex;

            dwConstraints++;
            bSuccess = TRUE;

            //
            // increase the committed buffer size so additional VGrowPackBuffer calls can allocate
            // additional pages if needed for more *ManualFeed False constraints
            //
            pParserData->dwBufSize += DWORD_ALIGN(sizeof(UICONSTRAINT));

        }

        if (! bSuccess)
            SEMANTIC_ERROR(("Invalid *UIConstraints entry: %s\n", pConstraint->pstrName));
    }

    //
    // Save the packed UIConstraints information in the binary data
    //

    if (dwConstraints == 0)
    {
        pParserData->pUIInfo->UIConstraints.dwCount = 0;
        pParserData->pUIInfo->UIConstraints.loOffset = 0;
    }
    else
    {
        pParserData->pUIInfo->UIConstraints.dwCount = dwConstraints;
        pParserData->pUIInfo->UIConstraints.loOffset = dwConstraintBufStart;
    }
}



VOID
VPackOrderDependency(
    PPARSERDATA pParserData,
    PARRAYREF   parefDest,
    PLISTOBJ    pOrderDep
    )

/*++

Routine Description:

    Pack OrderDependency/QueryOrderDependency information into binary data

Arguments:

    pParserData - Points to the parser data structure
    parefDest - Stores information about where the order dependency info is packed
    pOrderDep - Specifies the list of order dependencies to be packed

Return Value:

    NONE

--*/

{
    static const STRTABLE SectionStrs[] =
    {
        { "DocumentSetup",  SECTION_DOCSETUP},
        { "AnySetup",       SECTION_ANYSETUP},
        { "PageSetup",      SECTION_PAGESETUP},
        { "Prolog",         SECTION_PROLOG},
        { "ExitServer",     SECTION_EXITSERVER},
        { "JCLSetup",       SECTION_JCLSETUP},
        { NULL,             SECTION_UNASSIGNED}
    };

    PORDERDEPEND    pPackedDep;
    PFEATUREOBJ     pFeature;
    POPTIONOBJ      pOption;
    DWORD           dwOrderDep, dwFeatures, dwIndex;
    DWORD           dwFeatureIndex, dwOptionIndex, dwSection;
    LONG            lOrder;

    VALIDATE_PARSER_DATA(pParserData);

    //
    // The maximum number of entries we need is:
    //  number of printer features + number of order dependency entries
    //

    dwFeatures = pParserData->pInfoHdr->RawData.dwDocumentFeatures +
                 pParserData->pInfoHdr->RawData.dwPrinterFeatures;

    dwOrderDep = dwFeatures + DwCountListItem(pOrderDep);
    VGrowPackBuffer(pParserData, dwOrderDep * sizeof(ORDERDEPEND));
    pPackedDep = (PORDERDEPEND) (pParserData->pubBufStart + pParserData->dwBufSize);

    //
    // Create a default order dependency entry for each feature
    //

    for (pFeature = pParserData->pFeatures, dwFeatureIndex = 0;
        pFeature != NULL;
        pFeature = pFeature->pNext, dwFeatureIndex++)
    {
        pPackedDep[dwFeatureIndex].lOrder = MAX_ORDER_VALUE;
        pPackedDep[dwFeatureIndex].dwSection = SECTION_UNASSIGNED;
        pPackedDep[dwFeatureIndex].dwPPDSection = SECTION_UNASSIGNED;
        pPackedDep[dwFeatureIndex].dwFeatureIndex = dwFeatureIndex;
        pPackedDep[dwFeatureIndex].dwOptionIndex = OPTION_INDEX_ANY;
    }

    //
    // Interpret each order dependency entry
    //

    for (dwOrderDep = dwFeatures; pOrderDep != NULL; pOrderDep = pOrderDep->pNext)
    {
        CHAR    achWord1[MAX_WORD_LEN];
        CHAR    achWord2[MAX_WORD_LEN];
        PSTR    pstr = pOrderDep->pstrName;
        BOOL    bSuccess = FALSE;

        //
        // Each order dependency entry has the following components:
        //  order section mainKeyword [optionKeyword]
        //

        if (BGetFloatFromString(&pstr, &lOrder, FLTYPE_INT) &&
            BFindNextWord(&pstr, achWord1) &&
            BSearchStrTable(SectionStrs, achWord1, &dwSection) &&
            BFindNextWord(&pstr, achWord1))
        {
            (VOID) BFindNextWord(&pstr, achWord2);

            if (BFindUIConstraintFeatureOption(pParserData,
                                               achWord1,
                                               &pFeature,
                                               &dwFeatureIndex,
                                               achWord2,
                                               &pOption,
                                               &dwOptionIndex))
            {
                //
                // Check if an OrderDependency for the same feature/option
                // has appeared before.
                //

                for (dwIndex = 0; dwIndex < dwOrderDep; dwIndex++)
                {
                    if (pPackedDep[dwIndex].dwFeatureIndex == dwFeatureIndex &&
                        pPackedDep[dwIndex].dwOptionIndex == dwOptionIndex)
                    {
                        break;
                    }
                }

                if (dwIndex < dwOrderDep && pPackedDep[dwIndex].lOrder < MAX_ORDER_VALUE)
                {
                    TERSE(("Duplicate order dependency entry: %s\n", pOrderDep->pstrName));
                }
                else
                {
                    if (dwIndex >= dwOrderDep)
                        dwIndex = dwOrderDep++;

                    //
                    // Ensure the specified order value is less than MAX_ORDER_VALUE
                    //

                    if (lOrder >= MAX_ORDER_VALUE)
                    {
                        WARNING(("Order dependency value too big: %s\n", pOrderDep->pstrName));
                        lOrder = MAX_ORDER_VALUE - 1;
                    }

                    pPackedDep[dwIndex].dwSection = dwSection;
                    pPackedDep[dwIndex].dwPPDSection = dwSection;
                    pPackedDep[dwIndex].lOrder = lOrder;
                    pPackedDep[dwIndex].dwFeatureIndex = dwFeatureIndex;
                    pPackedDep[dwIndex].dwOptionIndex = dwOptionIndex;
                }

                bSuccess = TRUE;
            }
        }

        if (! bSuccess)
            SEMANTIC_ERROR(("Invalid order dependency: %s\n", pOrderDep->pstrName));
    }

    //
    // Tell the caller where the packed order dependency information is stored
    //

    if (dwOrderDep == 0)
    {
        parefDest->dwCount = 0;
        parefDest->loOffset = 0;
        return;
    }

    parefDest->dwCount = dwOrderDep;
    parefDest->loOffset = pParserData->dwBufSize;
    pParserData->dwBufSize += DWORD_ALIGN(dwOrderDep * sizeof(ORDERDEPEND));

    //
    // Sort order dependency information using the order value
    //

    for (dwIndex = 0; dwIndex+1 < dwOrderDep; dwIndex++)
    {
        DWORD   dwMinIndex, dwLoop;

        //
        // Nothing fancy here - straight-forward selection sort
        //

        dwMinIndex = dwIndex;

        for (dwLoop = dwIndex+1; dwLoop < dwOrderDep; dwLoop++)
        {
            if ((pPackedDep[dwLoop].lOrder < pPackedDep[dwMinIndex].lOrder) ||
                (pPackedDep[dwLoop].lOrder == pPackedDep[dwMinIndex].lOrder &&
                 pPackedDep[dwLoop].dwSection < pPackedDep[dwMinIndex].dwSection))
            {
                dwMinIndex = dwLoop;
            }
        }

        if (dwMinIndex != dwIndex)
        {
            ORDERDEPEND TempDep;

            TempDep = pPackedDep[dwIndex];
            pPackedDep[dwIndex] = pPackedDep[dwMinIndex];
            pPackedDep[dwMinIndex] = TempDep;
        }
    }

    //
    // Resolve AnySetup into either DocumentSetup or PageSetup
    //

    dwSection = SECTION_DOCSETUP;

    for (dwIndex = 0; dwIndex < dwOrderDep; dwIndex++)
    {
        if (pPackedDep[dwIndex].dwSection == SECTION_PAGESETUP)
            dwSection = SECTION_PAGESETUP;
        else if (pPackedDep[dwIndex].dwSection == SECTION_ANYSETUP)
            pPackedDep[dwIndex].dwSection = dwSection;
    }

    //
    // Maintain a linked-list of order dependency entries for each feature
    // starting with the entry whose dwOptionIndex = OPTION_INDEX_ANY.
    //

    for (dwIndex = 0; dwIndex < dwOrderDep; dwIndex++)
        pPackedDep[dwIndex].dwNextOrderDep = NULL_ORDERDEP;

    for (dwIndex = 0; dwIndex < dwOrderDep; dwIndex++)
    {
        DWORD   dwLastIndex, dwLoop;

        if (pPackedDep[dwIndex].dwOptionIndex != OPTION_INDEX_ANY)
            continue;

        dwLastIndex = dwIndex;

        for (dwLoop = 0; dwLoop < dwOrderDep; dwLoop++)
        {
            if (pPackedDep[dwLoop].dwFeatureIndex == pPackedDep[dwIndex].dwFeatureIndex &&
                pPackedDep[dwLoop].dwOptionIndex != OPTION_INDEX_ANY)
            {
                pPackedDep[dwLastIndex].dwNextOrderDep = dwLoop;
                dwLastIndex = dwLoop;
            }
        }

        pPackedDep[dwLastIndex].dwNextOrderDep = NULL_ORDERDEP;
    }

    //
    // !!!CR
    // Needs to flag out-of-order OrderDependency.
    //
}



VOID
VCountAndSortPrinterFeatures(
    PPARSERDATA pParserData
    )

/*++

Routine Description:

    Count the number of doc- and printer-sticky features
    and sort them into two separate groups

Arguments:

    pParserData - Points to the parser data structure

Return Value:

    NONE

--*/

{
    PFEATUREOBJ pFeature, pNext, pDocFeatures, pPrinterFeatures;
    DWORD       dwDocFeatures, dwPrinterFeatures;

    VALIDATE_PARSER_DATA(pParserData);

    //
    // Count the number of doc- and printer-sticky features
    //

    pDocFeatures = pPrinterFeatures = NULL;
    dwDocFeatures = dwPrinterFeatures = 0;
    pFeature = pParserData->pFeatures;

    while (pFeature != NULL)
    {
        pNext = pFeature->pNext;

        if (pFeature->bInstallable)
        {
            pFeature->pNext = pPrinterFeatures;
            pPrinterFeatures = pFeature;
            dwPrinterFeatures++;
        }
        else
        {
            pFeature->pNext = pDocFeatures;
            pDocFeatures = pFeature;
            dwDocFeatures++;
        }

        pFeature = pNext;
    }

    ASSERTMSG((dwDocFeatures + dwPrinterFeatures <= MAX_PRINTER_OPTIONS),
              ("Too many printer features.\n"));

    //
    // Rearrange the features so that all doc-sticky features
    // are in front of printer-sticky features
    //

    pFeature = NULL;

    while (pPrinterFeatures != NULL)
    {
        pNext = pPrinterFeatures->pNext;
        pPrinterFeatures->pNext = pFeature;
        pFeature = pPrinterFeatures;
        pPrinterFeatures = pNext;
    }

    while (pDocFeatures != NULL)
    {
        pNext = pDocFeatures->pNext;
        pDocFeatures->pNext = pFeature;
        pFeature = pDocFeatures;
        pDocFeatures = pNext;
    }

    pParserData->pFeatures = pFeature;
    pParserData->pInfoHdr->RawData.dwDocumentFeatures = dwDocFeatures;
    pParserData->pInfoHdr->RawData.dwPrinterFeatures = dwPrinterFeatures;
}



VOID
VProcessPrinterFeatures(
    PPARSERDATA pParserData
    )

/*++

Routine Description:

    Process printer features and handle any special glitches

Arguments:

    pParserData - Points to parser data structure

Return Value:

    NONE

--*/

{
    PFEATUREOBJ pFeature;
    POPTIONOBJ  pOption;

    for (pFeature = pParserData->pFeatures; pFeature; pFeature = pFeature->pNext)
    {
        //
        // If a feature has no option but has a default specified, then
        // synthesize an option with empty invocation string.
        //

        if (pFeature->pstrDefault && pFeature->pOptions == NULL)
        {
            pOption = ALLOC_PARSER_MEM(pParserData, pFeature->dwOptionSize);

            if (pOption == NULL)
            {
                ERR(("Memory allocation failed: %d\n", GetLastError()));
                PACK_BINARY_DATA_EXCEPTION();
            }

            //
            // NOTE: it's ok for both pOption->pstrName and pFeature->pstrDefault
            // to point to the same string here. The memory is deallocated when
            // the parser heap is destroyed.
            //

            pOption->pstrName = pFeature->pstrDefault;
            pFeature->pOptions = pOption;
        }

        //
        // Special handling of *InputSlot feature
        //  Make sure the very first option is always "*UseFormTrayTable"
        //

        if (pFeature->dwFeatureID == GID_INPUTSLOT)
        {
            pOption = ALLOC_PARSER_MEM(pParserData, pFeature->dwOptionSize);

            if (pOption == NULL)
            {
                ERR(("Memory allocation failed: %d\n", GetLastError()));
                PACK_BINARY_DATA_EXCEPTION();
            }

            pOption->pstrName = "*UseFormTrayTable";
            pOption->pNext = pFeature->pOptions;
            pFeature->pOptions = pOption;

            ((PTRAYOBJ) pOption)->dwTrayIndex = DMBIN_FORMSOURCE;
        }
    }
}



VOID
VPackPrinterFeatures(
    PPARSERDATA pParserData
    )

/*++

Routine Description:

    Pack printer feature and option information into binary data

Arguments:

    pParserData - Points to the parser data structure

Return Value:

    NONE

--*/

{
    PFEATUREOBJ pFeature;
    PFEATURE    pPackedFeature;
    POPTIONOBJ  pOption;
    POPTION     pPackedOption;
    DWORD       dwFeatureIndex, dwOptionIndex, dwCount;

    VALIDATE_PARSER_DATA(pParserData);

    //
    // Reserve space in the binary data for an array of FEATURE structures
    //

    dwCount = pParserData->pInfoHdr->RawData.dwDocumentFeatures +
              pParserData->pInfoHdr->RawData.dwPrinterFeatures;

    VGrowPackBuffer(pParserData, dwCount * sizeof(FEATURE));
    pPackedFeature = (PFEATURE) (pParserData->pubBufStart + pParserData->dwBufSize);
    pParserData->pUIInfo->loFeatureList = pParserData->dwBufSize;
    pParserData->dwBufSize += DWORD_ALIGN(dwCount * sizeof(FEATURE));

    for (pFeature = pParserData->pFeatures, dwFeatureIndex = 0;
        pFeature != NULL;
        pFeature = pFeature->pNext, dwFeatureIndex++, pPackedFeature++)
    {
        PFEATUREDATA    pFeatureData;

        //
        // Pack feature information
        //

        VPackStringAnsi(pParserData, &pPackedFeature->loKeywordName, pFeature->pstrName);

        VPackStringXlation(pParserData,
                           &pPackedFeature->loDisplayName,
                           pFeature->pstrName,
                           &pFeature->Translation);

        VPackInvocation(pParserData, &pPackedFeature->QueryInvocation, &pFeature->QueryInvoc);

        pFeatureData = PGetFeatureData(pFeature->dwFeatureID);
        pPackedFeature->dwFlags = pFeatureData->dwFlags;
        pPackedFeature->dwOptionSize = pFeatureData->dwOptionSize;
        pPackedFeature->dwFeatureID = pFeature->dwFeatureID;
        pPackedFeature->dwUIType = pFeature->dwUIType;
        pPackedFeature->dwUIConstraintList = pFeature->dwConstraint;
        pPackedFeature->dwNoneFalseOptIndex = OPTION_INDEX_ANY;

        if (pFeature->bInstallable)
        {
            pPackedFeature->dwPriority = pFeatureData->dwPriority + PRNPROP_BASE_PRIORITY;
            pPackedFeature->dwFeatureType = FEATURETYPE_PRINTERPROPERTY;
        }
        else
        {
            ASSERT(pFeatureData->dwPriority < PRNPROP_BASE_PRIORITY);
            pPackedFeature->dwPriority = pFeatureData->dwPriority;
            pPackedFeature->dwFeatureType = FEATURETYPE_DOCPROPERTY;
        }

        //
        // For non-PickMany features, use the very first option as the default
        // if none is explicitly specified. Otherwise, default to OPTION_INDEX_ANY.
        //

        pPackedFeature->dwDefaultOptIndex =
        (pFeature->dwUIType == UITYPE_PICKMANY) ? OPTION_INDEX_ANY : 0;

        //
        // If this feature is a predefined feature, save a reference to it
        //

        if (pFeature->dwFeatureID < MAX_GID)
        {
            pParserData->pUIInfo->aloPredefinedFeatures[pFeature->dwFeatureID] =
            pParserData->pUIInfo->loFeatureList + (dwFeatureIndex * sizeof(FEATURE));
        }

        //
        // Reserve space in the binary data for an array of OPTION structures
        //

        if ((dwCount = DwCountListItem(pFeature->pOptions)) == 0)
        {
            TERSE(("No options for feature: %s\n", pFeature->pstrName));
            pPackedFeature->Options.loOffset = 0;
            pPackedFeature->Options.dwCount = 0;
            continue;
        }

        ASSERTMSG((dwCount < OPTION_INDEX_ANY),
                  ("Too many options for feature: %s\n", pFeature->pstrName));

        VGrowPackBuffer(pParserData, dwCount * pFeatureData->dwOptionSize);
        pPackedOption = (POPTION) (pParserData->pubBufStart + pParserData->dwBufSize);
        pPackedFeature->Options.loOffset = pParserData->dwBufSize;
        pPackedFeature->Options.dwCount = dwCount;
        pParserData->dwBufSize += DWORD_ALIGN(dwCount * pFeatureData->dwOptionSize);

        for (pOption = pFeature->pOptions, dwOptionIndex = 0;
            pOption != NULL;
            pOption = pOption->pNext, dwOptionIndex++)
        {
            BOOL bIsDefaultOption = FALSE; // TRUE if current option is default

            //
            // Pack option information
            //

            VPackStringAnsi(pParserData,
                            &pPackedOption->loKeywordName,
                            pOption->pstrName);

            VPackStringXlation(pParserData,
                               &pPackedOption->loDisplayName,
                               pOption->pstrName,
                               &pOption->Translation);

            VPackInvocation(pParserData,
                            &pPackedOption->Invocation,
                            &pOption->Invocation);

            pPackedOption->dwUIConstraintList = pOption->dwConstraint;

            //
            // Check if the current option is the default option
            // or if it's the None/False option
            //

            if (pFeature->pstrDefault &&
                strcmp(pOption->pstrName, pFeature->pstrDefault) == EQUAL_STRING)
            {
                pPackedFeature->dwDefaultOptIndex = dwOptionIndex;
                bIsDefaultOption = TRUE;
            }

            if (strcmp(pOption->pstrName, gstrNoneKwd) == EQUAL_STRING ||
                strcmp(pOption->pstrName, gstrFalseKwd) == EQUAL_STRING)
            {
                pPackedFeature->dwNoneFalseOptIndex = dwOptionIndex;
            }

            //
            // Handle extra fields after the generic OPTION structure
            //

            switch (pFeature->dwFeatureID)
            {
            case GID_PAGESIZE:

                {
                    PPAGESIZE   pPageSize = (PPAGESIZE) pPackedOption;
                    PPAPEROBJ   pPaper = (PPAPEROBJ) pOption;
                    PRECT       prect;
                    PSIZE       psize;

                    if (strcmp(pOption->pstrName, gstrCustomSizeKwd) == EQUAL_STRING)
                    {
                        PPPDDATA    pPpdData;
                        LONG        lMax;

                        //
                        // Special case for CustomPageSize option
                        //

                        pPpdData = pParserData->pPpdData;
                        psize = &pPageSize->szPaperSize;
                        prect = &pPageSize->rcImgArea;

                        pPageSize->szPaperSize = pPaper->szDimension;
                        pPageSize->rcImgArea = pPaper->rcImageArea;
                        pPageSize->dwPaperSizeID = DMPAPER_CUSTOMSIZE;

                        VPackStringRsrc(pParserData,
                                        &pPackedOption->loDisplayName,
                                        IDS_PSCRIPT_CUSTOMSIZE);

                        //
                        // If either MaxMediaWidth or MaxMediaHeight is missing,
                        // we'll use the max width or height values from
                        // ParamCustomPageSize.
                        //

                        if (psize->cx <= 0)
                            psize->cx = MAXCUSTOMPARAM_WIDTH(pPpdData);

                        if (psize->cy <= 0)
                            psize->cy = MAXCUSTOMPARAM_HEIGHT(pPpdData);

                        if (psize->cx > 0 &&
                            psize->cy > 0 &&
                            MINCUSTOMPARAM_ORIENTATION(pPpdData) <= 3)
                        {
                            pParserData->pUIInfo->dwFlags |= FLAG_CUSTOMSIZE_SUPPORT;
                            pParserData->pUIInfo->dwCustomSizeOptIndex = dwOptionIndex;

                            //
                            // Make sure the hardware margins are not larger than
                            // the maximum media width or height.
                            //
                            // This is only significant for cut-sheet device.
                            //

                            if (pParserData->dwCustomSizeFlags & CUSTOMSIZE_CUTSHEET)
                            {
                                lMax = min(psize->cx, psize->cy);

                                if (prect->left < 0 || prect->left >= lMax)
                                    prect->left = 0;

                                if (prect->right < 0 || prect->right >= lMax)
                                    prect->right = 0;

                                if (prect->top < 0 || prect->top >= lMax)
                                    prect->top = 0;

                                if (prect->bottom < 0 || prect->bottom >= lMax)
                                    prect->bottom = 0;
                            }

                            //
                            // Validate custom page size parameters
                            //

                            if (MAXCUSTOMPARAM_WIDTH(pPpdData) > psize->cx)
                                MAXCUSTOMPARAM_WIDTH(pPpdData) = psize->cx;

                            if (MINCUSTOMPARAM_WIDTH(pPpdData) <= MICRONS_PER_INCH)
                                MINCUSTOMPARAM_WIDTH(pPpdData) = MICRONS_PER_INCH;

                            if (MAXCUSTOMPARAM_HEIGHT(pPpdData) > psize->cy)
                                MAXCUSTOMPARAM_HEIGHT(pPpdData) = psize->cy;

                            if (MINCUSTOMPARAM_HEIGHT(pPpdData) <= MICRONS_PER_INCH)
                                MINCUSTOMPARAM_HEIGHT(pPpdData) = MICRONS_PER_INCH;
                        }
                    }
                    else
                    {
                        psize = &pPaper->szDimension;
                        prect = &pPaper->rcImageArea;

                        if (strcmp(pOption->pstrName, gstrLetterSizeKwd) == EQUAL_STRING)
                        {
                            if ((abs(psize->cx - LETTER_PAPER_WIDTH) < 1000) &&
                                (abs(psize->cy - LETTER_PAPER_LENGTH) < 1000))
                            {
                                pParserData->pUIInfo->dwFlags |= FLAG_LETTER_SIZE_EXISTS;
                            }
                        }
                        else if (strcmp(pOption->pstrName, gstrA4SizeKwd) == EQUAL_STRING)
                        {
                            if ((abs(psize->cx - A4_PAPER_WIDTH) < 1000) &&
                                (abs(psize->cy - A4_PAPER_LENGTH) < 1000))
                            {
                                pParserData->pUIInfo->dwFlags |= FLAG_A4_SIZE_EXISTS;
                            }
                        }

                        //
                        // Verify paper dimension
                        //

                        if (psize->cx <= 0 || psize->cy <= 0)
                        {
                            SEMANTIC_ERROR(("Invalid PaperDimension for: %s\n",
                                            pOption->pstrName));

                            psize->cx = DEFAULT_PAPER_WIDTH;
                            psize->cy = DEFAULT_PAPER_LENGTH;
                        }

                        pPageSize->szPaperSize = pPaper->szDimension;

                        //
                        // Verify imageable area
                        //

                        if (prect->left < 0 || prect->left >= prect->right ||
                            prect->bottom < 0|| prect->bottom >= prect->top ||
                            prect->right > psize->cx ||
                            prect->top > psize->cy)
                        {
                            SEMANTIC_ERROR(("Invalid ImageableArea for: %s\n",
                                            pOption->pstrName));

                            prect->left = prect->bottom = 0;
                            prect->right = psize->cx;
                            prect->top = psize->cy;
                        }

                        //
                        // Convert from PS to GDI coordinate system
                        //

                        pPageSize->rcImgArea.left = prect->left;
                        pPageSize->rcImgArea.right = prect->right;
                        pPageSize->rcImgArea.top = psize->cy - prect->top;
                        pPageSize->rcImgArea.bottom = psize->cy - prect->bottom;

                        //
                        // Driver paper size ID starts at DRIVER_PAPERSIZE_ID
                        //

                        pPageSize->dwPaperSizeID = dwOptionIndex + DRIVER_PAPERSIZE_ID;
                    }
                }

                break;

            case GID_RESOLUTION:

                {
                    PRESOLUTION pResolution = (PRESOLUTION) pPackedOption;
                    PRESOBJ     pResObj = (PRESOBJ) pOption;
                    PSTR        pstr = pOption->pstrName;
                    LONG        lXdpi, lYdpi;
                    BOOL        bValid;

                    pResolution->iXdpi = pResolution->iYdpi = DEFAULT_RESOLUTION;
                    pResolution->fxScreenFreq = pResObj->fxScreenFreq;
                    pResolution->fxScreenAngle = pResObj->fxScreenAngle;

                    if (BGetIntegerFromString(&pstr, &lXdpi))
                    {
                        lYdpi = lXdpi;

                        while (*pstr && !IS_DIGIT(*pstr))
                            pstr++;

                        if ((*pstr == NUL || BGetIntegerFromString(&pstr, &lYdpi)) &&
                            (lXdpi > 0 && lXdpi <= MAX_SHORT) &&
                            (lYdpi > 0 && lYdpi <= MAX_SHORT))
                        {
                            pResolution->iXdpi = (INT) lXdpi;
                            pResolution->iYdpi = (INT) lYdpi;
                            bValid = TRUE;
                        }
                    }

                    if (! bValid)
                        SEMANTIC_ERROR(("Invalid resolution option: %s\n", pOption->pstrName));
                }
                break;

            case GID_DUPLEX:

                {
                    PDUPLEX pDuplex = (PDUPLEX) pPackedOption;

                    if (strcmp(pOption->pstrName, gstrDuplexTumble) == EQUAL_STRING)
                    {
                        //
                        // Horizontal == ShortEdge == Tumble
                        //

                        pDuplex->dwDuplexID = DMDUP_HORIZONTAL;
                    }
                    else if (strcmp(pOption->pstrName, gstrDuplexNoTumble) == EQUAL_STRING)
                    {
                        //
                        // Vertical == LongEdge == NoTumble
                        //

                        pDuplex->dwDuplexID = DMDUP_VERTICAL;
                    }
                    else
                        pDuplex->dwDuplexID = DMDUP_SIMPLEX;
                }
                break;

            case GID_COLLATE:

                {
                    PCOLLATE pCollate = (PCOLLATE) pPackedOption;

                    pCollate->dwCollateID =
                    (strcmp(pOption->pstrName, gstrTrueKwd) == EQUAL_STRING ||
                     strcmp(pOption->pstrName, gstrOnKwd) == EQUAL_STRING) ?
                    DMCOLLATE_TRUE :
                    DMCOLLATE_FALSE;
                }
                break;

            case GID_MEDIATYPE:

                ((PMEDIATYPE) pPackedOption)->dwMediaTypeID = dwOptionIndex + DMMEDIA_USER;
                break;

            case GID_INPUTSLOT:

                {
                    PINPUTSLOT  pInputSlot = (PINPUTSLOT) pPackedOption;
                    PTRAYOBJ    pTray = (PTRAYOBJ) pOption;
                    DWORD       dwReqPageRgn;

                    if ((dwReqPageRgn = pTray->dwReqPageRgn) == REQRGN_UNKNOWN)
                        dwReqPageRgn = pParserData->dwReqPageRgn;

                    if (dwReqPageRgn != REQRGN_FALSE)
                        pInputSlot->dwFlags |= INPUTSLOT_REQ_PAGERGN;

                    //
                    // Special handling of predefined input slots:
                    //  ManualFeed and AutoSelect
                    //

                    switch (pTray->dwTrayIndex)
                    {
                    case DMBIN_FORMSOURCE:

                        pInputSlot->dwPaperSourceID = pTray->dwTrayIndex;
                        break;

                    case DMBIN_MANUAL:

                        pInputSlot->dwPaperSourceID = pTray->dwTrayIndex;

                        VPackStringRsrc(pParserData,
                                        &pPackedOption->loDisplayName,
                                        IDS_TRAY_MANUALFEED);
                        break;

                    default:

                        pInputSlot->dwPaperSourceID = dwOptionIndex + DMBIN_USER;
                        break;
                    }
                }
                break;

            case GID_OUTPUTBIN:

                {
                    PBINOBJ pBinObj = (PBINOBJ) pOption;

                    //
                    // if this is the default bin, set the default output order, if specified
                    // by the DefaultOutputOrder entry in the PPD-file
                    //

                    if (bIsDefaultOption && pParserData->bDefOutputOrderSet)
                    {
                        //
                        // If multiple bins: warn if different options specified
                        //

                        if ((dwCount > 1) &&
                            (pBinObj->bReversePrint != pParserData->bDefReversePrint))
                        {
                            TERSE(("Warning: explicit *DefaultPageOrder overwrites PageStackOrder of OutputBin\n"));
                        }


                        ((POUTPUTBIN) pPackedOption)->bOutputOrderReversed = pParserData->bDefReversePrint;
                    }
                    else
                    {
                        //
                        // for non-default bins, the default output order has no effect - the PPD spec says
                        // "*DefaultOutputOrder indicates the default stacking order of the default output bin."
                        //

                        ((POUTPUTBIN) pPackedOption)->bOutputOrderReversed = pBinObj->bReversePrint;
                    }
                }

                break;

            case GID_MEMOPTION:

                {
                    PMEMOPTION  pMemOption = (PMEMOPTION) pPackedOption;
                    PMEMOBJ     pMemObj = (PMEMOBJ) pOption;
                    DWORD       dwMinFreeMem;

                    //
                    // Store PPD's original *VMOption value into dwInstalledMem.
                    // This is only used for the new PPD helper function GetOptionAttribute().
                    // (see comments in inc\parser.h)
                    //

                    pMemOption->dwInstalledMem = pMemObj->dwFreeVM;

                    dwMinFreeMem = pParserData->dwLangLevel <= 1 ? MIN_FREEMEM_L1 : MIN_FREEMEM_L2;
                    if (pMemObj->dwFreeVM < dwMinFreeMem)
                    {
                        SEMANTIC_ERROR(("Invalid memory option: %s\n", pOption->pstrName));
                        pMemObj->dwFreeVM = dwMinFreeMem;
                    }

                    pMemOption->dwFreeMem = pMemObj->dwFreeVM;
                    pMemOption->dwFreeFontMem = pMemObj->dwFontMem;
                }
                break;

            case GID_LEADINGEDGE:

                if (strcmp(pOption->pstrName, gstrLongKwd) == EQUAL_STRING)
                {
                    pParserData->pPpdData->dwLeadingEdgeLong = dwOptionIndex;

                    if (dwOptionIndex == pPackedFeature->dwDefaultOptIndex)
                        pParserData->pPpdData->dwCustomSizeFlags &= ~CUSTOMSIZE_SHORTEDGEFEED;
                }
                else if (strcmp(pOption->pstrName, gstrShortKwd) == EQUAL_STRING)
                {
                    pParserData->pPpdData->dwLeadingEdgeShort = dwOptionIndex;

                    if (dwOptionIndex == pPackedFeature->dwDefaultOptIndex)
                        pParserData->pPpdData->dwCustomSizeFlags |= CUSTOMSIZE_SHORTEDGEFEED;
                }

                break;

            case GID_USEHWMARGINS:

                if (strcmp(pOption->pstrName, gstrTrueKwd) == EQUAL_STRING)
                {
                    pParserData->pPpdData->dwUseHWMarginsTrue = dwOptionIndex;
                    pParserData->pPpdData->dwCustomSizeFlags |= CUSTOMSIZE_CUTSHEET;

                    if (dwOptionIndex == pPackedFeature->dwDefaultOptIndex)
                        pParserData->pPpdData->dwCustomSizeFlags |= CUSTOMSIZE_DEFAULTCUTSHEET;
                }
                else if (strcmp(pOption->pstrName, gstrFalseKwd) == EQUAL_STRING)
                {
                    pParserData->pPpdData->dwUseHWMarginsFalse = dwOptionIndex;
                    pParserData->pPpdData->dwCustomSizeFlags |= CUSTOMSIZE_ROLLFED;

                    if (dwOptionIndex == pPackedFeature->dwDefaultOptIndex)
                        pParserData->pPpdData->dwCustomSizeFlags &= ~CUSTOMSIZE_DEFAULTCUTSHEET;
                }
                break;
            }

            pPackedOption = (POPTION) ((PBYTE) pPackedOption + pFeatureData->dwOptionSize);
        }
    }
}



VOID
VPackNt4Mapping(
    PPARSERDATA pParserData
    )

/*++

Routine Description:

    Pack NT4 feature index mapping information

Arguments:

    pParserData - Points to the parser data structure

Return Value:

    NONE

--*/

{
    PPPDDATA    pPpdData;
    PFEATURE    pPackedFeatures;
    PBYTE       pubNt4Mapping;
    DWORD       dwCount, dwIndex, dwNt4Index;
    INT         iInputSlotIndex;
    BYTE        ubInputSlotOld, ubInputSlotNew;

    pPpdData = pParserData->pPpdData;
    pPpdData->dwNt4Checksum = pParserData->wNt4Checksum;
    pPpdData->dwNt4DocFeatures = pParserData->pUIInfo->dwDocumentFeatures;
    pPpdData->dwNt4PrnFeatures = pParserData->pUIInfo->dwPrinterFeatures;

    iInputSlotIndex = -1;
    ubInputSlotNew = 0xff;

    if (pParserData->iDefInstallMemIndex >= 0)
        pParserData->iDefInstallMemIndex += pPpdData->dwNt4DocFeatures;

    dwCount = pPpdData->dwNt4DocFeatures + pPpdData->dwNt4PrnFeatures;
    pPpdData->Nt4Mapping.dwCount = dwCount;

    VGrowPackBuffer(pParserData, dwCount * sizeof(BYTE));
    pubNt4Mapping = (PBYTE) (pParserData->pubBufStart + pParserData->dwBufSize);
    pPpdData->Nt4Mapping.loOffset = pParserData->dwBufSize;
    pParserData->dwBufSize += DWORD_ALIGN(dwCount * sizeof(BYTE));

    pPackedFeatures = (PFEATURE) (pParserData->pubBufStart + pParserData->pUIInfo->loFeatureList);

    for (dwIndex=dwNt4Index=0; dwIndex <= dwCount; dwIndex++)
    {
        BOOL    bMapped = TRUE;

        //
        // ManualFeed used to be a feature in NT4,
        // but not anymore in NT5
        //

        if (pParserData->iReqPageRgnIndex == (INT) dwIndex)
            ubInputSlotNew = (BYTE) dwNt4Index;

        if (pParserData->iManualFeedIndex == (INT) dwIndex)
        {
            pPpdData->dwNt4DocFeatures++;
            dwNt4Index++;
        }

        //
        // DefaultInstalledMemory causes a bogus feature to be added on NT4
        //

        if (pParserData->iDefInstallMemIndex == (INT) dwIndex)
        {
            pPpdData->dwNt4PrnFeatures++;
            dwNt4Index++;
        }

        if (dwIndex == dwCount)
            break;

        switch (pPackedFeatures[dwIndex].dwFeatureID)
        {
        case GID_MEDIATYPE:
        case GID_OUTPUTBIN:

            // a feature in NT4 only if within Open/CloseUI

            if (pParserData->aubOpenUIFeature[pPackedFeatures[dwIndex].dwFeatureID])
                break;

            // fall through

        case GID_PAGEREGION:
        case GID_LEADINGEDGE:
        case GID_USEHWMARGINS:

            // not a feature in NT4

            bMapped = FALSE;
            break;

        case GID_INPUTSLOT:

            iInputSlotIndex = dwIndex;
            break;
        }

        if (bMapped)
        {
            pubNt4Mapping[dwIndex] = (BYTE) dwNt4Index;
            dwNt4Index++;
        }
        else
        {
            pPpdData->dwNt4DocFeatures--;
            pubNt4Mapping[dwIndex] = 0xff;
        }
    }

    //
    // RequiresPageRegion causes InputSlot feature to be created on NT4
    //

    if (iInputSlotIndex >= 0 && pParserData->iReqPageRgnIndex >= 0)
    {
        ubInputSlotOld = pubNt4Mapping[iInputSlotIndex];

        if (ubInputSlotOld > ubInputSlotNew)
        {
            for (dwIndex=0; dwIndex < dwCount; dwIndex++)
            {
                if (pubNt4Mapping[dwIndex] >= ubInputSlotNew &&
                    pubNt4Mapping[dwIndex] <  ubInputSlotOld)
                {
                    pubNt4Mapping[dwIndex]++;
                }
            }
        }
        else if (ubInputSlotOld < ubInputSlotNew)
        {
            for (dwIndex=0; dwIndex < dwCount; dwIndex++)
            {
                if (pubNt4Mapping[dwIndex] >  ubInputSlotOld &&
                    pubNt4Mapping[dwIndex] <= ubInputSlotNew)
                {
                    pubNt4Mapping[dwIndex]--;
                }
            }
        }

        pubNt4Mapping[iInputSlotIndex] = ubInputSlotNew;
    }
}



VOID
VPackDeviceFonts(
    PPARSERDATA pParserData
    )

/*++

Routine Description:

    Pack device font information into binary data

Arguments:

    pParserData - Points to the parser data structure

Return Value:

    NONE

--*/

{
    PDEVFONT    pDevFont;
    PFONTREC    pFontObj;
    DWORD       dwIndex, dwFonts;

    VALIDATE_PARSER_DATA(pParserData);

    //
    // Count the number of device fonts and
    // reserve enough space in the packed binary data
    //

    if ((dwFonts = DwCountListItem(pParserData->pFonts)) == 0)
        return;

    VGrowPackBuffer(pParserData, dwFonts * sizeof(DEVFONT));
    pParserData->pPpdData->DeviceFonts.dwCount = dwFonts;
    pParserData->pPpdData->DeviceFonts.loOffset = pParserData->dwBufSize;

    pDevFont = (PDEVFONT) (pParserData->pubBufStart + pParserData->dwBufSize);
    pParserData->dwBufSize += DWORD_ALIGN(dwFonts * sizeof(DEVFONT));

    //
    // Pack information about each device font
    //

    for (pFontObj = pParserData->pFonts;
        pFontObj != NULL;
        pFontObj = pFontObj->pNext)
    {
        VPackStringAnsi(pParserData, &pDevFont->loFontName, pFontObj->pstrName);

        VPackStringXlation(pParserData,
                           &pDevFont->loDisplayName,
                           pFontObj->pstrName,
                           &pFontObj->Translation);

        VPackStringAnsi(pParserData, &pDevFont->loEncoding, pFontObj->pstrEncoding);
        VPackStringAnsi(pParserData, &pDevFont->loCharset, pFontObj->pstrCharset);
        VPackStringAnsi(pParserData, &pDevFont->loVersion, pFontObj->pstrVersion);

        pDevFont->dwStatus = pFontObj->dwStatus;
        pDevFont++;
    }

    //
    // Calculate the byte-offset to the default DEVFONT structure (if any)
    //

    if (pParserData->pstrDefaultFont &&
        PvFindListItem(pParserData->pFonts, pParserData->pstrDefaultFont, &dwIndex))
    {
        pParserData->pPpdData->loDefaultFont = pParserData->pPpdData->DeviceFonts.loOffset +
                                               (dwIndex * sizeof(DEVFONT));
    }
}



VOID
VPackJobPatchFiles(
    PPARSERDATA pParserData
    )

/*++

Routine Description:

    Pack *JobPatchFile information into binary data

Arguments:

    pParserData - Points to the parser data structure

Return Value:

    NONE

--*/

{
    PJOBPATCHFILE     pPackedPatch;
    PJOBPATCHFILEOBJ  pJobPatchFile;
    DWORD             dwJobPatchFiles;

    VALIDATE_PARSER_DATA(pParserData);

    //
    // Count the number of *JobPatchFile entries
    //

    dwJobPatchFiles = DwCountListItem((PVOID) pParserData->pJobPatchFiles);

    if (dwJobPatchFiles > 0)
    {
        //
        // Reserve enough space in the packed binary data
        //

        VGrowPackBuffer(pParserData, dwJobPatchFiles * sizeof(JOBPATCHFILE));
        pParserData->pPpdData->JobPatchFiles.dwCount = dwJobPatchFiles;
        pParserData->pPpdData->JobPatchFiles.loOffset = pParserData->dwBufSize;

        pPackedPatch = (PJOBPATCHFILE) (pParserData->pubBufStart + pParserData->dwBufSize);
        pParserData->dwBufSize += DWORD_ALIGN(dwJobPatchFiles * sizeof(JOBPATCHFILE));

        //
        // Pack each *JobPatchFile invocation string
        //

        for (pJobPatchFile = pParserData->pJobPatchFiles;
            pJobPatchFile != NULL;
            pJobPatchFile = pJobPatchFile->pNext)
        {
            VPackPatch(pParserData, pPackedPatch, pJobPatchFile);
            pPackedPatch++;
        }
    }
}



typedef struct _TTFSUBSTRESINFO
{
    BOOL bCJK;
    WORD wIDBegin;
    WORD wIDEnd;
}
TTFSUBSTRESINFO;

static TTFSUBSTRESINFO TTFSubstResInfo[] =
{
    { FALSE, IDS_1252_BEGIN, IDS_1252_END},
    { TRUE,  IDS_932_BEGIN,  IDS_932_END},
    { TRUE,  IDS_936_BEGIN,  IDS_936_END},
    { TRUE,  IDS_949_BEGIN,  IDS_949_END},
};



VOID
VPackDefaultTrueTypeSubstTable(
    PPARSERDATA pParserData
    )

/*++

Routine Description:

    Pack the default TrueType font substitution table into the binary data

Arguments:

    pParserData - Points to the parser data structure

Return Value:

    NONE

--*/

#define MAX_FONT_NAME   256

{
    INT     iNumInfo, iInfo, iCount, iLenTT, iLenPS, i;
    DWORD   dwSize, dwLeft, dw;
    TCHAR   tchBuf[MAX_FONT_NAME];
    PTSTR   ptstrTable;
    HRSRC   hrRcData;
    HGLOBAL hgRcData;
    PWORD   pwRcData;

    VALIDATE_PARSER_DATA(pParserData);

    //
    // Calculate how much memory we need to hold the default TrueType to
    // PostScript substitution names. The counter is initialized to 1, instead
    // of 0, for the last NUL terminator. Count the names from the STRING
    // resource, then from RCDATA resource.
    //
    //
    dwSize = 1;

    iNumInfo = sizeof(TTFSubstResInfo) / sizeof(TTFSUBSTRESINFO);

    for (iInfo = 0; iInfo < iNumInfo; iInfo++)
    {
        iCount = TTFSubstResInfo[iInfo].wIDEnd - TTFSubstResInfo[iInfo].wIDBegin + 1;

        for (i = 0; i < iCount; i++)
        {
            iLenTT = LoadString(ghInstance,
                                TTFSubstResInfo[iInfo].wIDBegin + i,
                                tchBuf, MAX_FONT_NAME);

            if (iLenTT == 0)
            {
                ERR(("VPackDefaultTrueTypeSubstTable: load TT string failed: %d\n", GetLastError()));
                return;
            }

            iLenPS = LoadString(ghInstance,
                                TTFSubstResInfo[iInfo].wIDBegin + i + TT2PS_INTERVAL,
                                tchBuf, MAX_FONT_NAME);

            if (iLenPS == 0)
            {
                ERR(("VPackDefaultTrueTypeSubstTable: load PS string failed: %d\n", GetLastError()));
                return;
            }

            dwSize += (iLenTT + 1) + (iLenPS + 1);

            if (TTFSubstResInfo[iInfo].bCJK == TRUE)
            {
                // We need names beginning with '@' too for CJK.
                dwSize += (1 + iLenTT + 1) + (1 + iLenPS + 1);
            }
        }

        if (TTFSubstResInfo[iInfo].bCJK == TRUE)
        {
            hrRcData = FindResource(ghInstance, (LPCTSTR)TTFSubstResInfo[iInfo].wIDBegin, RT_RCDATA);
            if (hrRcData == NULL)
            {
                ERR(("VPackDefaultTrueTypeSubstTable: find RCDATA failed: %d\n", GetLastError()));
                return;
            }

            // Load the resource and get its size.
            hgRcData = LoadResource(ghInstance, hrRcData);
            if (hgRcData == NULL)
            {
                ERR(("VPackDefaultTrueTypeSubstTable: load RCDATA failed: %d\n", GetLastError()));
                return;
            }

            // The first WORD of the IDR resource tells the size of the strings.
            pwRcData = (PWORD)LockResource(hgRcData);
            if (pwRcData == NULL)
            {
                ERR(("VPackDefaultTrueTypeSubstTable: lock RCDATA failed: %d\n", GetLastError()));
                return;
            }

            dw = *pwRcData;
            if (dw % 2)
            {
                ERR(("VPackDefaultTrueTypeSubstTable: RCDATA size is odd.\n"));
                return;
            }

            dwSize += dw / 2;
        }
    }

    //
    // Reserve enough space in the packed binary data
    //

    dwSize *= sizeof(TCHAR);

    VGrowPackBuffer(pParserData, dwSize);
    ptstrTable = (PTSTR) (pParserData->pubBufStart + pParserData->dwBufSize);

    pParserData->pUIInfo->loFontSubstTable = pParserData->dwBufSize;
    pParserData->pUIInfo->dwFontSubCount = dwSize;
    pParserData->dwBufSize += DWORD_ALIGN(dwSize);

    //
    // Save the default substitution table in the binary data
    //

    dwLeft = dwSize;

    for (iInfo = 0; iInfo < iNumInfo; iInfo++)
    {
        iCount = TTFSubstResInfo[iInfo].wIDEnd - TTFSubstResInfo[iInfo].wIDBegin + 1;

        for (i = 0; i < iCount; i++)
        {
            iLenTT = LoadString(ghInstance,
                                TTFSubstResInfo[iInfo].wIDBegin + i,
                                ptstrTable, dwLeft);

            if (iLenTT == 0)
            {
                ERR(("VPackDefaultTrueTypeSubstTable: load TT string failed: %d\n", GetLastError()));
                goto fail_cleanup;
            }

            ptstrTable += iLenTT + 1;
            dwLeft -= (iLenTT + 1) * sizeof (TCHAR);

            iLenPS = LoadString(ghInstance,
                                TTFSubstResInfo[iInfo].wIDBegin + i + TT2PS_INTERVAL,
                                ptstrTable, dwLeft);

            if (iLenPS == 0)
            {
                ERR(("VPackDefaultTrueTypeSubstTable: load PS string failed: %d\n", GetLastError()));
                goto fail_cleanup;
            }

            ptstrTable += iLenPS + 1;
            dwLeft -= (iLenPS + 1) * sizeof (TCHAR);

            if (TTFSubstResInfo[iInfo].bCJK == TRUE)
            {
                // We need names beginning with '@' too for CJK.

                *ptstrTable++ = L'@';
                dwLeft -= sizeof (TCHAR);

                if (!LoadString(ghInstance, TTFSubstResInfo[iInfo].wIDBegin + i,
                                ptstrTable, dwLeft))
                {
                    ERR(("VPackDefaultTrueTypeSubstTable: load TT string failed: %d\n", GetLastError()));
                    goto fail_cleanup;
                }

                ptstrTable += iLenTT + 1;
                dwLeft -= (iLenTT + 1) * sizeof (TCHAR);

                *ptstrTable++ = L'@';
                dwLeft -= sizeof (TCHAR);

                if (!LoadString(ghInstance, TTFSubstResInfo[iInfo].wIDBegin + i + TT2PS_INTERVAL,
                                ptstrTable, dwLeft))
                {
                    ERR(("VPackDefaultTrueTypeSubstTable: load PS string failed: %d\n", GetLastError()));
                    goto fail_cleanup;
                }

                ptstrTable += iLenPS + 1;
                dwLeft -= (iLenPS + 1) * sizeof (TCHAR);
            }
        }

        if (TTFSubstResInfo[iInfo].bCJK == TRUE)
        {
            hrRcData = FindResource(ghInstance, (LPCTSTR)TTFSubstResInfo[iInfo].wIDBegin, RT_RCDATA);
            if (hrRcData == NULL)
            {
                ERR(("VPackDefaultTrueTypeSubstTable: find RCDATA failed: %d\n", GetLastError()));
                goto fail_cleanup;
            }

            hgRcData = LoadResource(ghInstance, hrRcData);
            if (hgRcData == NULL)
            {
                ERR(("VPackDefaultTrueTypeSubstTable: load RCDATA failed: %d\n", GetLastError()));
                goto fail_cleanup;
            }

            pwRcData = (PWORD)LockResource(hgRcData);
            if (pwRcData == NULL)
            {
                ERR(("VPackDefaultTrueTypeSubstTable: lock RCDATA failed: %d\n", GetLastError()));
                goto fail_cleanup;
            }

            dw = *pwRcData++;
            if (dw % 2)
            {
                ERR(("VPackDefaultTrueTypeSubstTable: RCDATA size is odd.\n"));
                goto fail_cleanup;
            }

            memcpy(ptstrTable, pwRcData, dw);

            ptstrTable += dw / 2;
            dwLeft -= dw;
        }
    }

    //
    // Succeed
    //

    return;

    //
    // Fail
    //

    fail_cleanup:

    pParserData->pUIInfo->loFontSubstTable = 0;
    pParserData->pUIInfo->dwFontSubCount = 0;
}



VOID
VPackTrueTypeSubstTable(
    PPARSERDATA pParserData
    )

/*++

Routine Description:

    Pack the TrueType font substitution table into the binary data

Arguments:

    pParserData - Points to the parser data structure

Return Value:

    NONE

--*/

{
    PTTFONTSUB  pTTFontSub;
    DWORD       dwSize;
    PTSTR       ptstrTable, ptstrStart;

    //
    // Figure out how much space we'll need to store the font substitution table.
    // This is an estimate and may be a little higher than what we actually need.
    //

    ASSERT(pParserData->pTTFontSubs != NULL);

    for (pTTFontSub = pParserData->pTTFontSubs, dwSize = 1;
        pTTFontSub != NULL;
        pTTFontSub = pTTFontSub->pNext)
    {
        if (pTTFontSub->Translation.dwLength)
            dwSize += pTTFontSub->Translation.dwLength + 1;
        else
            dwSize += strlen(pTTFontSub->pstrName) + 1;

        dwSize += pTTFontSub->PSName.dwLength + 1;
    }

    //
    // Reserve enough space in the packed binary data
    //

    dwSize *= sizeof(TCHAR);
    VGrowPackBuffer(pParserData, dwSize);
    ptstrStart = ptstrTable = (PTSTR) (pParserData->pubBufStart + pParserData->dwBufSize);
    pParserData->pUIInfo->loFontSubstTable = pParserData->dwBufSize;
    pParserData->dwBufSize += DWORD_ALIGN(dwSize);

    for (pTTFontSub = pParserData->pTTFontSubs;
        pTTFontSub != NULL;
        pTTFontSub = pTTFontSub->pNext)
    {
        INT iChars;

        //
        // TrueType font family name
        //

        if (pTTFontSub->Translation.dwLength)
        {
            iChars = ITranslateToUnicodeString(
                                              ptstrTable,
                                              pTTFontSub->Translation.pvData,
                                              pTTFontSub->Translation.dwLength,
                                              pParserData->uCodePage);
        }
        else
        {
            iChars = ITranslateToUnicodeString(
                                              ptstrTable,
                                              pTTFontSub->pstrName,
                                              strlen(pTTFontSub->pstrName),
                                              1252);

        }

        if (iChars <= 0)
            break;

        ptstrTable += iChars + 1;

        //
        // PS font family name
        //

        iChars = ITranslateToUnicodeString(
                                          ptstrTable,
                                          pTTFontSub->PSName.pvData,
                                          pTTFontSub->PSName.dwLength,
                                          pParserData->uCodePage);

        if (iChars <= 0)
            break;

        ptstrTable += iChars + 1;
    }

    if (pTTFontSub != NULL)
    {
        ERR(("Error packing font substitution table\n"));
        ptstrTable = ptstrStart;
    }

    *ptstrTable++ = NUL;
    pParserData->pUIInfo->dwFontSubCount = (DWORD)(ptstrTable - ptstrStart) * sizeof(TCHAR);
}



VOID
VPackFileDateInfo(
    PPARSERDATA pParserData
    )

/*++

Routine Description:

    Pack source PPD filenames and dates

Arguments:

    pParserData - Points to parser data structure

Return Value:

    NONE

--*/

{
    PRAWBINARYDATA  pRawData;
    DWORD           dwCount;
    PFILEDATEINFO   pFileDateInfo;
    PTSTR           ptstrFullname;
    PLISTOBJ        pItem;
    HANDLE          hFile;

    pRawData = &pParserData->pInfoHdr->RawData;
    dwCount = DwCountListItem(pParserData->pPpdFileNames);

    if (pRawData->FileDateInfo.dwCount = dwCount)
    {
        VGrowPackBuffer(pParserData, dwCount * sizeof(FILEDATEINFO));
        pRawData->FileDateInfo.loOffset = pParserData->dwBufSize;
        pFileDateInfo = (PFILEDATEINFO) (pParserData->pubBufStart + pParserData->dwBufSize);
        pParserData->dwBufSize += DWORD_ALIGN(dwCount * sizeof(FILEDATEINFO));

        for (pItem = pParserData->pPpdFileNames; pItem; pItem = pItem->pNext)
        {
            dwCount--;
            ptstrFullname = (PTSTR) pItem->pstrName;

            VPackStringUnicode(pParserData,
                               &pFileDateInfo[dwCount].loFileName,
                               ptstrFullname);

            hFile = CreateFile(ptstrFullname,
                               GENERIC_READ,
                               FILE_SHARE_READ,
                               NULL,
                               OPEN_EXISTING,
                               FILE_ATTRIBUTE_NORMAL,
                               NULL);

            if ((hFile == INVALID_HANDLE_VALUE) ||
                !GetFileTime(hFile, NULL, NULL, &pFileDateInfo[dwCount].FileTime))
            {
                ERR(("GetFileTime '%ws' failed: %d\n", ptstrFullname, GetLastError()));
                GetSystemTimeAsFileTime(&pFileDateInfo[dwCount].FileTime);
            }

            if (hFile != INVALID_HANDLE_VALUE)
                CloseHandle(hFile);
        }
    }
}



VOID
VMapLangEncodingToCodePage(
    PPARSERDATA pParserData
    )

/*++

Routine Description:

    Map LanguageEncoding to code page

Arguments:

    pParserData - Points to parser data structure

Return Value:

    NONE

--*/

{
    UINT    uCodePage = CP_ACP;
    CPINFO  cpinfo;

    switch (pParserData->dwLangEncoding)
    {
    case LANGENC_ISOLATIN1:
        uCodePage = 1252;
        break;

    case LANGENC_JIS83_RKSJ:
        uCodePage = 932;
        break;

    case LANGENC_UNICODE:
        uCodePage = CP_UNICODE;
        break;

    case LANGENC_NONE:
        break;

    default:
        RIP(("Unknown language encoding: %d\n", pParserData->dwLangEncoding));
        break;
    }

    //
    // Make sure the requested code page is available
    //

    if (uCodePage != CP_UNICODE &&
        uCodePage != CP_ACP &&
        !GetCPInfo(uCodePage, &cpinfo))
    {
        WARNING(("Code page %d is not available\n", uCodePage));
        uCodePage = CP_ERROR;
    }

    pParserData->uCodePage = uCodePage;
}



BOOL
BPackBinaryData(
    PPARSERDATA pParserData
    )

/*++

Routine Description:

    Pack the parsed PPD information into binary format

Arguments:

    pParserData - Points to parser data structure

Return Value:

    TRUE if successful, FALSE if there is an error

--*/

{
    DWORD   dwSize;
    DWORD   dwMinFreeMem;
    BOOL    bResult = FALSE;

    VALIDATE_PARSER_DATA(pParserData);

    __try
    {
        //
        // Quick-access pointers to various data structures.
        //

        PINFOHEADER pInfoHdr;
        PUIINFO     pUIInfo;
        PPPDDATA    pPpdData;

        //
        // Pack fixed header data structures
        //

        dwSize = sizeof(INFOHEADER) + sizeof(UIINFO) + sizeof(PPDDATA);
        VGrowPackBuffer(pParserData, dwSize);
        pParserData->dwBufSize = DWORD_ALIGN(dwSize);
        pInfoHdr = pParserData->pInfoHdr;
        pUIInfo = pParserData->pUIInfo;
        pPpdData = pParserData->pPpdData;

        pInfoHdr->RawData.dwParserSignature = PPD_PARSER_SIGNATURE;
        pInfoHdr->RawData.dwParserVersion = PPD_PARSER_VERSION;

        #if 0
        pInfoHdr->RawData.dwChecksum32 = pParserData->dwChecksum32;
        #endif

        pInfoHdr->loUIInfoOffset = sizeof(INFOHEADER);
        pInfoHdr->loDriverOffset = sizeof(INFOHEADER) + sizeof(UIINFO);

        //
        // Pack source PPD filenames and dates
        //

        VPackFileDateInfo(pParserData);

        //
        // Perform a few miscellaneous checks
        //

        if (pParserData->pOpenFeature)
            SEMANTIC_ERROR(("Missing CloseUI for: %s\n", pParserData->pOpenFeature->pstrName));

        if (pParserData->bInstallableGroup)
            SEMANTIC_ERROR(("Missing CloseGroup: InstallableOptions\n"));

        if (pParserData->NickName.dwLength == 0)
            SEMANTIC_ERROR(("Missing *NickName and *ShortNickName entry\n"));

        if (pParserData->Product.dwLength == 0)
            SEMANTIC_ERROR(("Missing *Product entry\n"));

        if (pParserData->dwSpecVersion == 0)
            SEMANTIC_ERROR(("Missing *PPD-Adobe and *FormatVersion entry\n"));

        if (pParserData->dwLangLevel == 0)
        {
            SEMANTIC_ERROR(("Missing *LanguageLevel entry\n"));
            pParserData->dwLangLevel = 1;
        }

        dwMinFreeMem = pParserData->dwLangLevel <= 1 ? MIN_FREEMEM_L1 : MIN_FREEMEM_L2;
        if (pParserData->dwFreeMem < dwMinFreeMem)
        {
            SEMANTIC_ERROR(("Invalid *FreeVM entry\n"));
            pParserData->dwFreeMem = dwMinFreeMem;
        }

        //
        // Map LanguageEncoding to code page
        //

        VMapLangEncodingToCodePage(pParserData);

        //
        // Count the number of doc- and printer-sticky features
        // and sort them into two separate groups
        //

        VCountAndSortPrinterFeatures(pParserData);

        //
        // Fill out fields in the UIINFO structure
        //

        pUIInfo->dwSize = sizeof(UIINFO);
        pUIInfo->dwDocumentFeatures = pInfoHdr->RawData.dwDocumentFeatures;
        pUIInfo->dwPrinterFeatures = pInfoHdr->RawData.dwPrinterFeatures;
        pUIInfo->dwTechnology = DT_RASPRINTER;
        pUIInfo->dwMaxCopies = MAX_COPIES;
        pUIInfo->dwMinScale = MIN_SCALE;
        pUIInfo->dwMaxScale = MAX_SCALE;
        pUIInfo->dwSpecVersion = pParserData->dwSpecVersion;
        pUIInfo->dwLangEncoding = pParserData->dwLangEncoding;
        pUIInfo->dwLangLevel = pParserData->dwLangLevel;
        pUIInfo->dwPrintRate = pUIInfo->dwPrintRatePPM = pParserData->dwThroughput;

        #ifndef WINNT_40
        pUIInfo->dwPrintRateUnit = PRINTRATEUNIT_PPM;
        #endif

        //
        // Note: We assume all printers can support binary protocol
        //

        pUIInfo->dwProtocols = pParserData->dwProtocols | PROTOCOL_BINARY;

        pUIInfo->dwJobTimeout = pParserData->dwJobTimeout;
        pUIInfo->dwWaitTimeout = pParserData->dwWaitTimeout;
        pUIInfo->dwTTRasterizer = pParserData->dwTTRasterizer;
        pUIInfo->dwFreeMem = pParserData->dwFreeMem;
        pUIInfo->fxScreenAngle = pParserData->fxScreenAngle;
        pUIInfo->fxScreenFreq = pParserData->fxScreenFreq;
        pUIInfo->dwCustomSizeOptIndex = OPTION_INDEX_ANY;

        pPpdData->dwPpdFilever = pParserData->dwPpdFilever;
        pPpdData->dwFlags = pParserData->dwPpdFlags;

        //
        // Our internal unit is microns, thus 25400 units per inch.
        //

        pUIInfo->ptMasterUnits.x =
        pUIInfo->ptMasterUnits.y = 25400;

        pUIInfo->dwFlags = FLAG_FONT_DOWNLOADABLE |
                           FLAG_ORIENT_SUPPORT;

        if (pParserData->dwColorDevice)
            pUIInfo->dwFlags |= FLAG_COLOR_DEVICE;

        if (pParserData->dwLSOrientation != LSO_MINUS90)
            pUIInfo->dwFlags |= FLAG_ROTATE90;

        if (PvFindListItem(pParserData->pFeatures, "StapleLocation", NULL) ||
            PvFindListItem(pParserData->pFeatures, "StapleX", NULL) &&
            PvFindListItem(pParserData->pFeatures, "StapleY", NULL))
        {
            pUIInfo->dwFlags |= FLAG_STAPLE_SUPPORT;
        }

        if (pParserData->bDefReversePrint)
            pUIInfo->dwFlags |= FLAG_REVERSE_PRINT;

        if (pParserData->dwLangLevel > 1)
        {
            if (pParserData->bEuroInformationSet)
            {
                if (!pParserData->bHasEuro)
                    pUIInfo->dwFlags |= FLAG_ADD_EURO;
            }
            else if (pParserData->dwPSVersion < 3011)
                    pUIInfo->dwFlags |= FLAG_ADD_EURO;
        }

        if (pParserData->bTrueGray)
            pUIInfo->dwFlags |= FLAG_TRUE_GRAY;

        VPackStringAnsiToUnicode(
                                pParserData,
                                &pUIInfo->loNickName,
                                pParserData->NickName.pvData,
                                pParserData->NickName.dwLength);

        //
        // Pack symbol definitions and resolve symbol references
        //

        VPackSymbolDefinitions(pParserData);
        VResolveSymbolReferences(pParserData);

        VPackInvocation(pParserData, &pUIInfo->Password, &pParserData->Password);
        VPackInvocation(pParserData, &pUIInfo->ExitServer, &pParserData->ExitServer);

        //
        // Copy and validate custom page size parameters
        //

        pPpdData->dwUseHWMarginsTrue =
        pPpdData->dwUseHWMarginsFalse =
        pPpdData->dwLeadingEdgeLong =
        pPpdData->dwLeadingEdgeShort = OPTION_INDEX_ANY;
        pPpdData->dwCustomSizeFlags = pParserData->dwCustomSizeFlags;

        CopyMemory(pPpdData->CustomSizeParams,
                   pParserData->CustomSizeParams,
                   sizeof(pPpdData->CustomSizeParams));

        //
        // Process the printer features and handle any special glitches
        //

        VProcessPrinterFeatures(pParserData);

        //
        // Pack UIConstraints information
        //

        VPackUIConstraints(pParserData);

        //
        // Pack OrderDependency and QueryOrderDependency information
        //

        VPackOrderDependency(pParserData, &pPpdData->OrderDeps, pParserData->pOrderDep);
        VPackOrderDependency(pParserData, &pPpdData->QueryOrderDeps, pParserData->pQueryOrderDep);

        //
        // Pack printer features and options
        //

        VPackPrinterFeatures(pParserData);

        //
        // Fill out fields in PPDDATA structure
        //

        pPpdData->dwSizeOfStruct = sizeof(PPDDATA);
        pPpdData->dwExtensions = pParserData->dwExtensions;
        pPpdData->dwSetResType = pParserData->dwSetResType;
        pPpdData->dwPSVersion = pParserData->dwPSVersion;

        //
        // Scan the document-sticky feature list to check if "OutputOrder" is available.
        // If it is, remember its feature index, which will be used by UI code.
        //

        {
            PFEATURE    pFeature;
            DWORD       dwIndex;
            PCSTR       pstrKeywordName;

            pPpdData->dwOutputOrderIndex = INVALID_FEATURE_INDEX;

            pFeature = OFFSET_TO_POINTER(pInfoHdr, pUIInfo->loFeatureList);

            ASSERT(pFeature != NULL);

            for (dwIndex = 0; dwIndex < pUIInfo->dwDocumentFeatures; dwIndex++, pFeature++)
            {
                if ((pstrKeywordName = OFFSET_TO_POINTER(pInfoHdr, pFeature->loKeywordName)) &&
                    strcmp(pstrKeywordName, "OutputOrder") == EQUAL_STRING)
                {
                    pPpdData->dwOutputOrderIndex = dwIndex;
                    break;
                }
            }
        }

        VPackInvocation(pParserData, &pPpdData->PSVersion, &pParserData->PSVersion);
        VPackInvocation(pParserData, &pPpdData->Product, &pParserData->Product);

        if (SUPPORT_CUSTOMSIZE(pUIInfo))
        {
            //
            // If neither roll-fed nor cut-sheet flag is set, assume to be roll-fed
            //

            if (! (pPpdData->dwCustomSizeFlags & (CUSTOMSIZE_CUTSHEET|CUSTOMSIZE_ROLLFED)))
                pPpdData->dwCustomSizeFlags |= CUSTOMSIZE_ROLLFED;

            //
            // If roll-fed flag is not set, default must be cut-sheet
            //

            if (! (pPpdData->dwCustomSizeFlags & CUSTOMSIZE_ROLLFED))
                pPpdData->dwCustomSizeFlags |= CUSTOMSIZE_DEFAULTCUTSHEET;
        }

        VPackInvocation(pParserData, &pPpdData->PatchFile, &pParserData->PatchFile);
        VPackInvocation(pParserData, &pPpdData->JclBegin, &pParserData->JclBegin);
        VPackInvocation(pParserData, &pPpdData->JclEnterPS, &pParserData->JclEnterPS);
        VPackInvocation(pParserData, &pPpdData->JclEnd, &pParserData->JclEnd);
        VPackInvocation(pParserData, &pPpdData->ManualFeedFalse, &pParserData->ManualFeedFalse);

        //
        // Pack NT4 feature index mapping information
        //

        VPackNt4Mapping(pParserData);

        //
        // Pack device font information
        //

        VPackDeviceFonts(pParserData);

        //
        // Pack JobPatchFile information
        //

        VPackJobPatchFiles(pParserData);

        //
        // Pack default TrueType font substitution table
        //

        if (pParserData->pTTFontSubs == NULL || pParserData->uCodePage == CP_ERROR)
            VPackDefaultTrueTypeSubstTable(pParserData);
        else
            VPackTrueTypeSubstTable(pParserData);

        pInfoHdr->RawData.dwFileSize = pParserData->dwBufSize;
        bResult = TRUE;
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        ERR(("PackBinaryData failed.\n"));
    }

    return bResult;
}



BOOL
BSaveBinaryDataToFile(
    PPARSERDATA pParserData,
    PTSTR       ptstrPpdFilename
    )

/*++

Routine Description:

    Cache the binary PPD data in a file

Arguments:

    pParserData - Points to parser data structure
    ptstrPpdFilename - Specifies the PPD filename

Return Value:

    TRUE if successful, FALSE if there is an error

--*/

{
    PTSTR   ptstrBpdFilename;
    HANDLE  hFile;
    DWORD   dwBytesWritten;
    BOOL    bResult = FALSE;

    VALIDATE_PARSER_DATA(pParserData);

    //
    // Generate a binary file name based the original filename
    // Create a file and write data to it
    //

    if ((ptstrBpdFilename = GenerateBpdFilename(ptstrPpdFilename)) != NULL &&
        (hFile = CreateFile(ptstrBpdFilename,
                            GENERIC_WRITE,
                            0,
                            NULL,
                            CREATE_ALWAYS,
                            FILE_ATTRIBUTE_NORMAL | FILE_FLAG_SEQUENTIAL_SCAN,
                            NULL)) != INVALID_HANDLE_VALUE)
    {
        bResult = WriteFile(hFile,
                            pParserData->pubBufStart,
                            pParserData->dwBufSize,
                            &dwBytesWritten,
                            NULL) &&
                  (pParserData->dwBufSize == dwBytesWritten);

        CloseHandle(hFile);
    }

    if (! bResult)
        ERR(("Couldn't cache binary PPD data: %d\n", GetLastError()));

    MemFree(ptstrBpdFilename);
    return bResult;
}



VOID
VFreeParserData(
    PPARSERDATA pParserData
    )

/*++

Routine Description:

    Free up memory used to hold parser data structure

Arguments:

    pParserData - Points to parser data structure

Return Value:

    NONE

--*/

{
    VALIDATE_PARSER_DATA(pParserData);

    if (pParserData->pubBufStart)
        VirtualFree(pParserData->pubBufStart, 0, MEM_RELEASE);

    MemFree(pParserData->Value.pbuf);
    HeapDestroy(pParserData->hHeap);
}



PPARSERDATA
PAllocParserData(
    VOID
    )

/*++

Routine Description:

    Allocate memory to hold PPD parser data

Arguments:

    NONE

Return Value:

    Pointer to allocated parser data structure
    NULL if there is an error

--*/

{
    PPARSERDATA pParserData;
    HANDLE      hHeap;

    //
    // Create a heap and allocate memory space from it
    //

    if (! (hHeap = HeapCreate(0, 16*1024, 0)) ||
        ! (pParserData = HeapAlloc(hHeap, HEAP_ZERO_MEMORY, sizeof(PARSERDATA))))
    {
        ERR(("Memory allocation failed: %d\n", GetLastError()));

        if (hHeap)
            HeapDestroy(hHeap);

        return NULL;
    }

    pParserData->hHeap = hHeap;
    pParserData->pvStartSig = pParserData->pvEndSig = pParserData;

    //
    // Initialize the parser data structure - we only need to worry
    // about non-zero fields here.
    //

    pParserData->dwChecksum32 = 0xFFFFFFFF;
    pParserData->dwFreeMem = min(MIN_FREEMEM_L1, MIN_FREEMEM_L2);
    pParserData->dwJobTimeout = DEFAULT_JOB_TIMEOUT;
    pParserData->dwWaitTimeout = DEFAULT_WAIT_TIMEOUT;
    pParserData->iManualFeedIndex =
    pParserData->iReqPageRgnIndex =
    pParserData->iDefInstallMemIndex = -1;
    pParserData->wNt4Checksum = 0;
    pParserData->dwPpdFlags = PPDFLAG_PRINTPSERROR;

    //
    // Initialize buffers for storing keyword, option, translation, and value.
    // Build up data structures to speed up keyword lookup
    //

    SET_BUFFER(&pParserData->Keyword, pParserData->achKeyword);
    SET_BUFFER(&pParserData->Option,  pParserData->achOption);
    SET_BUFFER(&pParserData->Xlation, pParserData->achXlation);

    if (IGrowValueBuffer(&pParserData->Value) != PPDERR_NONE ||
        ! BInitKeywordLookup(pParserData))
    {
        VFreeParserData(pParserData);
        return NULL;
    }

    return pParserData;
}



BOOL
BRememberSourceFilename(
    PPARSERDATA pParserData,
    PTSTR       ptstrFilename
    )

/*++

Routine Description:

    Remember the full pathname to the source PPD file

Arguments:

    pParserData - Points to parser data structure
    ptstrFilename - Specifies the source PPD filename

Return Value:

    TRUE if successful, FALSE if there is an error

--*/

{
    PLISTOBJ    pItem;
    TCHAR       ptstrFullname[MAX_PATH];
    PTSTR       ptstrFilePart;
    DWORD       dwSize;

    //
    // Get the full pathname to the specified source PPD file
    //

    dwSize = GetFullPathName(ptstrFilename, MAX_PATH, ptstrFullname, &ptstrFilePart);

    if (dwSize == 0)
    {
        ERR(("GetFullPathName failed: %d\n", GetLastError()));
        return FALSE;
    }

    //
    // Remember the source PPD filenames
    //

    dwSize = (dwSize + 1) * sizeof(TCHAR);

    if (! (pItem = ALLOC_PARSER_MEM(pParserData, sizeof(LISTOBJ) + dwSize)))
        return FALSE;

    pItem->pstrName = (PSTR) ((PBYTE) pItem + sizeof(LISTOBJ));
    CopyMemory(pItem->pstrName, ptstrFullname, dwSize);

    pItem->pNext = pParserData->pPpdFileNames;
    pParserData->pPpdFileNames = pItem;
    return TRUE;
}



// 16-bit crc checksum table - copied from win95

static const WORD Crc16Table[] =
{
    0x0000, 0x1021, 0x2042, 0x3063, 0x4084, 0x50a5, 0x60c6, 0x70e7,
    0x8108, 0x9129, 0xa14a, 0xb16b, 0xc18c, 0xd1ad, 0xe1ce, 0xf1ef,
    0x1231, 0x0210, 0x3273, 0x2252, 0x52b5, 0x4294, 0x72f7, 0x62d6,
    0x9339, 0x8318, 0xb37b, 0xa35a, 0xd3bd, 0xc39c, 0xf3ff, 0xe3de,
    0x2462, 0x3443, 0x0420, 0x1401, 0x64e6, 0x74c7, 0x44a4, 0x5485,
    0xa56a, 0xb54b, 0x8528, 0x9509, 0xe5ee, 0xf5cf, 0xc5ac, 0xd58d,
    0x3653, 0x2672, 0x1611, 0x0630, 0x76d7, 0x66f6, 0x5695, 0x46b4,
    0xb75b, 0xa77a, 0x9719, 0x8738, 0xf7df, 0xe7fe, 0xd79d, 0xc7bc,
    0x48c4, 0x58e5, 0x6886, 0x78a7, 0x0840, 0x1861, 0x2802, 0x3823,
    0xc9cc, 0xd9ed, 0xe98e, 0xf9af, 0x8948, 0x9969, 0xa90a, 0xb92b,
    0x5af5, 0x4ad4, 0x7ab7, 0x6a96, 0x1a71, 0x0a50, 0x3a33, 0x2a12,
    0xdbfd, 0xcbdc, 0xfbbf, 0xeb9e, 0x9b79, 0x8b58, 0xbb3b, 0xab1a,
    0x6ca6, 0x7c87, 0x4ce4, 0x5cc5, 0x2c22, 0x3c03, 0x0c60, 0x1c41,
    0xedae, 0xfd8f, 0xcdec, 0xddcd, 0xad2a, 0xbd0b, 0x8d68, 0x9d49,
    0x7e97, 0x6eb6, 0x5ed5, 0x4ef4, 0x3e13, 0x2e32, 0x1e51, 0x0e70,
    0xff9f, 0xefbe, 0xdfdd, 0xcffc, 0xbf1b, 0xaf3a, 0x9f59, 0x8f78,
    0x9188, 0x81a9, 0xb1ca, 0xa1eb, 0xd10c, 0xc12d, 0xf14e, 0xe16f,
    0x1080, 0x00a1, 0x30c2, 0x20e3, 0x5004, 0x4025, 0x7046, 0x6067,
    0x83b9, 0x9398, 0xa3fb, 0xb3da, 0xc33d, 0xd31c, 0xe37f, 0xf35e,
    0x02b1, 0x1290, 0x22f3, 0x32d2, 0x4235, 0x5214, 0x6277, 0x7256,
    0xb5ea, 0xa5cb, 0x95a8, 0x8589, 0xf56e, 0xe54f, 0xd52c, 0xc50d,
    0x34e2, 0x24c3, 0x14a0, 0x0481, 0x7466, 0x6447, 0x5424, 0x4405,
    0xa7db, 0xb7fa, 0x8799, 0x97b8, 0xe75f, 0xf77e, 0xc71d, 0xd73c,
    0x26d3, 0x36f2, 0x0691, 0x16b0, 0x6657, 0x7676, 0x4615, 0x5634,
    0xd94c, 0xc96d, 0xf90e, 0xe92f, 0x99c8, 0x89e9, 0xb98a, 0xa9ab,
    0x5844, 0x4865, 0x7806, 0x6827, 0x18c0, 0x08e1, 0x3882, 0x28a3,
    0xcb7d, 0xdb5c, 0xeb3f, 0xfb1e, 0x8bf9, 0x9bd8, 0xabbb, 0xbb9a,
    0x4a75, 0x5a54, 0x6a37, 0x7a16, 0x0af1, 0x1ad0, 0x2ab3, 0x3a92,
    0xfd2e, 0xed0f, 0xdd6c, 0xcd4d, 0xbdaa, 0xad8b, 0x9de8, 0x8dc9,
    0x7c26, 0x6c07, 0x5c64, 0x4c45, 0x3ca2, 0x2c83, 0x1ce0, 0x0cc1,
    0xef1f, 0xff3e, 0xcf5d, 0xdf7c, 0xaf9b, 0xbfba, 0x8fd9, 0x9ff8,
    0x6e17, 0x7e36, 0x4e55, 0x5e74, 0x2e93, 0x3eb2, 0x0ed1, 0x1ef0
};

WORD
WComputeCrc16Checksum(
    IN PBYTE    pbuf,
    IN DWORD    dwCount,
    IN WORD     wChecksum
    )

/*++

Routine Description:

    Compute the 16-bit CRC checksum on a buffer of data

Arguments:

    pbuf - Points to a data buffer
    dwCount - Number of bytes in the data buffer
    wChecksum - Initial checksum value

Return Value:

    Resulting checksum value

--*/

{
    while (dwCount--)
        wChecksum = Crc16Table[(wChecksum >> 8) ^ *pbuf++] ^ (wChecksum << 8);

    return wChecksum;
}



DWORD
dwComputeFeatureOptionChecksum(
    PPARSERDATA pParserData
    )

/*++

Routine Description:

    Compute checksum for only feature/option keyword strings.

Arguments:

    pParserData - Points to parser data structure

Return Value:

    32bit checksum value

--*/

{
    PINFOHEADER pInfoHdr;
    PUIINFO     pUIInfo;
    PFEATURE    pFeature;
    POPTION     pOption;
    DWORD       dwFeatureCount, dwFeatureIndex, dwOptionCount, dwOptionIndex;
    PBYTE       pBuf;
    DWORD       dwBufSize;

    VALIDATE_PARSER_DATA(pParserData);

    pInfoHdr =  pParserData->pInfoHdr;
    pUIInfo  =  (PUIINFO)((PBYTE)pInfoHdr + sizeof(INFOHEADER));

    dwFeatureCount = pInfoHdr->RawData.dwDocumentFeatures + pInfoHdr->RawData.dwPrinterFeatures;

    pFeature = OFFSET_TO_POINTER(pInfoHdr, pUIInfo->loFeatureList);

    ASSERT(dwFeatureCount == 0 || pFeature != NULL);

    for (dwFeatureIndex = 0; dwFeatureIndex < dwFeatureCount; dwFeatureIndex++, pFeature++)
    {
        pBuf = OFFSET_TO_POINTER(pInfoHdr, pFeature->loKeywordName);

        ASSERT(pBuf != NULL);

        dwBufSize = strlen((PSTR)pBuf) + 1;

        pParserData->dwChecksum32 = ComputeCrc32Checksum(pBuf, dwBufSize, pParserData->dwChecksum32);

        if (dwOptionCount = pFeature->Options.dwCount)
        {
            pOption = OFFSET_TO_POINTER(pInfoHdr, pFeature->Options.loOffset);

            ASSERT(pOption != NULL);

            for (dwOptionIndex = 0; dwOptionIndex < dwOptionCount; dwOptionIndex++)
            {
                pBuf = OFFSET_TO_POINTER(pInfoHdr, pOption->loKeywordName);
                dwBufSize = strlen((PSTR)pBuf) + 1;

                pParserData->dwChecksum32 = ComputeCrc32Checksum(pBuf, dwBufSize, pParserData->dwChecksum32);
                pOption = (POPTION)((PBYTE)pOption + pFeature->dwOptionSize);
            }
        }
    }

    return pParserData->dwChecksum32;
}



DWORD
dwCalcMaxKeywordSize(
    IN PPARSERDATA pParserData,
    IN INT         iMode
    )

/*++

Routine Description:

    Calculate the maximum buffer size for storing feature/option
    keyword pairs in Registry.

Arguments:

    pParserData - Points to parser data structure
    iMode       - For either doc- or printer- sticky features

Return Value:

    The maximum buffer size needed for storing feature/option keyword paris.

--*/

{
    PINFOHEADER pInfoHdr;
    PUIINFO     pUIInfo;
    PFEATURE    pFeature;
    POPTION     pOption;
    DWORD       dwStart, dwFeatureCount, dwFeatureIndex, dwOptionCount, dwOptionIndex;
    PSTR        pBuf;
    DWORD       dwMaxSize, dwOptionSize, dwOptionMax;

    VALIDATE_PARSER_DATA(pParserData);

    dwMaxSize = 0;

    pInfoHdr = pParserData->pInfoHdr;
    pUIInfo  = pParserData->pUIInfo;

    if (iMode == MODE_DOCUMENT_STICKY)
    {
        dwStart = 0;
        dwFeatureCount = pUIInfo->dwDocumentFeatures;
    }
    else
    {
        ASSERT(iMode == MODE_PRINTER_STICKY);

        dwStart = pUIInfo->dwDocumentFeatures;
        dwFeatureCount = pUIInfo->dwPrinterFeatures;
    }

    pFeature = OFFSET_TO_POINTER(pInfoHdr, pUIInfo->loFeatureList);

    ASSERT(dwFeatureCount == 0 || pFeature != NULL);

    pFeature += dwStart;

    for (dwFeatureIndex = 0; dwFeatureIndex < dwFeatureCount; dwFeatureIndex++, pFeature++)
    {
        pBuf = OFFSET_TO_POINTER(pInfoHdr, pFeature->loKeywordName);

        ASSERT(pBuf != NULL);

        dwMaxSize += strlen(pBuf) + 1;

        dwOptionMax = 0;
        if (dwOptionCount = pFeature->Options.dwCount)
        {
            pOption = OFFSET_TO_POINTER(pInfoHdr, pFeature->Options.loOffset);

            ASSERT(pOption != NULL);

            for (dwOptionIndex = 0; dwOptionIndex < dwOptionCount; dwOptionIndex++)
            {
                pBuf = OFFSET_TO_POINTER(pInfoHdr, pOption->loKeywordName);
                dwOptionSize = strlen(pBuf) + 1;

                if (pFeature->dwUIType != UITYPE_PICKMANY)
                {
                    if (dwOptionMax < dwOptionSize)
                        dwOptionMax = dwOptionSize;
                }
                else // count all options for PickMany feature
                    dwMaxSize += dwOptionSize;

                pOption = (POPTION)((PBYTE)pOption + pFeature->dwOptionSize);
            }
        }

        //
        // Add the max option keyword size here for non-PickMany feature
        //

        if (pFeature->dwUIType != UITYPE_PICKMANY)
            dwMaxSize += dwOptionMax;

        //
        // One extra byte for the \0x0A delimiter between features
        //

        dwMaxSize += 1;
    }

    dwMaxSize += KEYWORD_SIZE_EXTRA;

    return dwMaxSize;
}



PPDERROR
IParseFile(
    PPARSERDATA pParserData,
    PTSTR       ptstrFilename
    )

/*++

Routine Description:

    Parse a PPD file

Arguments:

    pParserData - Points to parser data structure
    ptstrFilename - Specifies the name of the file to be parsed

Return Value:

    PPDERR_NONE if successful, error code otherwise

--*/

{
    PPDERROR    iStatus;
    PFILEOBJ    pFile;
    INT         iSyntaxErrors = 0;

    //
    // Map the file into memory for read-only access
    //

    VALIDATE_PARSER_DATA(pParserData);
    ASSERT(ptstrFilename != NULL);

    if (! BRememberSourceFilename(pParserData, ptstrFilename) ||
        ! (pFile = PCreateFileObj(ptstrFilename)))
    {
        return PPDERR_FILE;
    }

    pParserData->pFile = pFile;

    #if 0
    //
    // Compute the 32-bit CRC checksum of the file content
    //

    pParserData->dwChecksum32 =
    ComputeCrc32Checksum(pFile->pubStart, pFile->dwFileSize, pParserData->dwChecksum32);
    #endif

    //
    // Compute the 16-bit CRC checksum as well for PS4 compatibility
    //

    pParserData->wNt4Checksum =
    WComputeCrc16Checksum(pFile->pubStart, pFile->dwFileSize, pParserData->wNt4Checksum);

    //
    // Process entries in the file
    //

    while ((iStatus = IParseEntry(pParserData)) != PPDERR_EOF)
    {
        if (iStatus == PPDERR_SYNTAX)
            iSyntaxErrors++;
        else if (iStatus != PPDERR_NONE)
        {
            VDeleteFileObj(pFile);
            return iStatus;
        }
    }

    if (END_OF_FILE(pFile) && !END_OF_LINE(pFile))
        TERSE(("Incomplete last line ignored.\n"));

    //
    // Unmap the file and return to the caller
    //

    VDeleteFileObj(pFile);

    return (iSyntaxErrors > 0) ? PPDERR_SYNTAX : PPDERR_NONE;
}



PRAWBINARYDATA
PpdParseTextFile(
    PTSTR   ptstrPpdFilename
    )

/*++

Routine Description:

    PPD parser main entry point

Arguments:

    ptstrPpdFilename - Specifies the PPD file to be parsed

Return Value:

    Pointer to parsed binary PPD data, NULL if there is an error

--*/

{
    PPARSERDATA     pParserData;
    PPDERROR        iStatus;
    PRAWBINARYDATA  pRawData = NULL;

    //
    // Allocate parser data structure
    //

    ASSERT(ptstrPpdFilename != NULL);

    if (! (pParserData = PAllocParserData()))
        return NULL;

    //
    // Parse the PPD file
    //

    iStatus = IParseFile(pParserData, ptstrPpdFilename);

    if (iStatus == PPDERR_NONE || iStatus == PPDERR_SYNTAX)
    {
        //
        // Pack the parsed information into binary format
        //

        pParserData->bErrorFlag = FALSE;

        if (BPackBinaryData(pParserData))
        {
            //
            // After binary data is packed, we calculate the 32bit checksum
            // for only feature/option keyword strings (instead of for the
            // whole PPD file). Doing this will enable us to retain option
            // selections when the PPD file is modified without feature/option
            // changes.
            //

            pParserData->pInfoHdr->RawData.dwChecksum32 = dwComputeFeatureOptionChecksum(pParserData);

            //
            // Calculate the maximum buffer sizes for storing feature/option
            // keyword pairs in Registry
            //

            pParserData->pUIInfo->dwMaxDocKeywordSize = dwCalcMaxKeywordSize(pParserData, MODE_DOCUMENT_STICKY);
            pParserData->pUIInfo->dwMaxPrnKeywordSize = dwCalcMaxKeywordSize(pParserData, MODE_PRINTER_STICKY);

            #ifndef WINNT_40

            pParserData->pPpdData->dwUserDefUILangID = (DWORD)GetUserDefaultUILanguage();

            #else

            pParserData->pPpdData->dwUserDefUILangID = 0;

            #endif

            //
            // Save binary data to a file
            //

            (VOID) BSaveBinaryDataToFile(pParserData, ptstrPpdFilename);

            //
            // Here we'll copy the packed binary data to a different buffer.
            // This is necessary because the packed data buffer was allocated
            // using VirtualAlloc. If we return that pointer back to the caller,
            // the caller would need to call VirtualFree to release it.
            //

            if (pRawData = MemAlloc(pParserData->dwBufSize))
            {
                CopyMemory(pRawData, pParserData->pubBufStart, pParserData->dwBufSize);
            }
            else
                ERR(("Memory allocation failed: %d\n", GetLastError()));
        }
    }

    if (iStatus == PPDERR_SYNTAX || pParserData->bErrorFlag)
        WARNING(("Errors found in %ws\n", ptstrPpdFilename));

    VFreeParserData(pParserData);
    return pRawData;
}



PPDERROR
IGrowValueBuffer(
    PBUFOBJ pBufObj
    )

/*++

Routine Description:

    Grow the buffer used for holding the entry value

Arguments:

    pBufObj - Specifies the buffer to be enlarged

Return Value:

    PPDERR_NONE if successful, error code otherwise

--*/

#define VALUE_BUFFER_INCREMENT  (1*KBYTES)

{
    DWORD   dwNewLen = pBufObj->dwMaxLen + VALUE_BUFFER_INCREMENT;
    PBYTE   pbuf;

    if (! IS_BUFFER_FULL(pBufObj))
        WARNING(("Trying to grow buffer while it's not yet full.\n"));

    if (! (pbuf = MemAllocZ(dwNewLen)))
    {
        ERR(("Memory allocation failed: %d\n", GetLastError()));
        return PPDERR_MEMORY;
    }

    if (pBufObj->pbuf)
    {
        CopyMemory(pbuf, pBufObj->pbuf, pBufObj->dwSize);
        MemFree(pBufObj->pbuf);
    }

    pBufObj->pbuf = pbuf;
    pBufObj->dwMaxLen = dwNewLen;
    return PPDERR_NONE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\parsers\ppd\ppdrsrc.h ===
/*++

Copyright (c) 1996-1997  Microsoft Corporation

Module Name:

    ppdrsrc.h

Abstract:

    PPD parser string resource IDs - This is needed because the
    binary printer description data contains the default TrueType
    to Type1 font substitution table and the TrueType font name
    must be localized.

Environment:

    Windows NT PostScript driver

Revision History:

    08/20/96 -davidx-
        Created it.

    dd-mm-yy -author-
        description

--*/


#ifndef _PPDRSRC_H_
#define _PPDRSRC_H_

//
// Resource IDs starts at 30K to minimize the chance of conflicting
// with other string resources in the driver DLL.
//

#define IDS_TRAY_MANUALFEED                     30700
#define IDS_PSCRIPT_CUSTOMSIZE                  30701


//
// String IDs for TT->PS substitution
//

#define TT2PS_INTERVAL                          20

// Roman
#define IDR_1252                                30800

#define IDS_1252_BEGIN                          30800

#define IDS_TT_ARIAL                            30800
#define IDS_TT_ARIAL_NARROW                     30801
#define IDS_TT_BOOK_ANTIQUA                     30802
#define IDS_TT_BOOKMAN_OLD_STYLE                30803
#define IDS_TT_CENTURY_GOTHIC                   30804
#define IDS_TT_CENTURY_SCHOOLBOOK               30805
#define IDS_TT_COURIER_NEW                      30806
#define IDS_TT_MONOTYPE_CORSIVA                 30807
#define IDS_TT_MONOTYPE_SORTS                   30808
#define IDS_TT_TIMES_NEW_ROMAN                  30809
#define IDS_TT_SYMBOL                           30810

#define IDS_PS_HELVETICA						(IDS_TT_ARIAL				+ TT2PS_INTERVAL)
#define IDS_PS_HELVETICA_NARROW					(IDS_TT_ARIAL_NARROW		+ TT2PS_INTERVAL)
#define IDS_PS_PALATINO							(IDS_TT_BOOK_ANTIQUA		+ TT2PS_INTERVAL)
#define IDS_PS_ITC_BOOKMAN						(IDS_TT_BOOKMAN_OLD_STYLE	+ TT2PS_INTERVAL)
#define IDS_PS_AVANTEGARDE						(IDS_TT_CENTURY_GOTHIC		+ TT2PS_INTERVAL)
#define IDS_PS_NEWCENTURYSCHLBK					(IDS_TT_CENTURY_SCHOOLBOOK	+ TT2PS_INTERVAL)
#define IDS_PS_COURIER							(IDS_TT_COURIER_NEW			+ TT2PS_INTERVAL)
#define IDS_PS_ZAPFCHANCERY						(IDS_TT_MONOTYPE_CORSIVA	+ TT2PS_INTERVAL)
#define IDS_PS_ZAPFDINGBATS						(IDS_TT_MONOTYPE_SORTS		+ TT2PS_INTERVAL)
#define IDS_PS_TIMES							(IDS_TT_TIMES_NEW_ROMAN		+ TT2PS_INTERVAL)
#define IDS_PS_SYMBOL							(IDS_TT_SYMBOL				+ TT2PS_INTERVAL)

#define IDS_1252_END                            30810


// Japanese
#define IDR_932                                 30900

#define IDS_932_BEGIN                           30900

#define IDS_TT_MS_MINCHO                        30900
#define IDS_TT_MS_GOTHIC                        30901

#define IDS_PS_RYUMIN_LIGHT                     (IDS_TT_MS_MINCHO           + TT2PS_INTERVAL)
#define IDS_PS_GOTHICBBB_MEDIUM 				(IDS_TT_MS_GOTHIC           + TT2PS_INTERVAL)

#define IDS_932_END                             30901


// Chinese Simplified
#define IDR_936                                 31000

#define IDS_936_BEGIN                           31000

#define IDS_TT_KAITI_GB2312                     31000
#define IDS_TT_FANGSONG_GB2312                  31001

#define IDS_PS_STKAITI_REGULAR                  (IDS_TT_KAITI_GB2312        + TT2PS_INTERVAL)
#define IDS_PS_STFANGSONG_LIGHT                 (IDS_TT_FANGSONG_GB2312     + TT2PS_INTERVAL)

#define IDS_936_END                             31001


// Korean
#define IDR_949                                 31100

#define IDS_949_BEGIN                           31100

#define IDS_TT_BATANG                           31100
#define IDS_TT_BATANGCHE                        31101
#define IDS_TT_GUNGSUH                          31102
#define IDS_TT_GUNGSUHCHE                       31103
#define IDS_TT_GULIM                            31104
#define IDS_TT_GULIMCHE                         31105
#define IDS_TT_DOTUM                            31106
#define IDS_TT_DOTUMCHE                         31107

#define IDS_PS_HYSMYEONGJO_MEDIUM               (IDS_TT_BATANG              + TT2PS_INTERVAL)
#define IDS_PS_HYSMYEONGJO_MEDIUM_HW            (IDS_TT_BATANGCHE           + TT2PS_INTERVAL)
#define IDS_PS_HYGUNGSO_BOLD                    (IDS_TT_GUNGSUH             + TT2PS_INTERVAL)
#define IDS_PS_HYGUNGSO_BOLD_HW                 (IDS_TT_GUNGSUHCHE          + TT2PS_INTERVAL)
#define IDS_PS_HYRGOTHIC_MEDIUM                 (IDS_TT_GULIM               + TT2PS_INTERVAL)
#define IDS_PS_HYRGOTHIC_MEDIUM_HW              (IDS_TT_GULIMCHE            + TT2PS_INTERVAL)
#define IDS_PS_HYGOTHIC_MEDIUM                  (IDS_TT_DOTUM               + TT2PS_INTERVAL)
#define IDS_PS_HYGOTHIC_MEDIUM_HW               (IDS_TT_DOTUMCHE            + TT2PS_INTERVAL)

#define IDS_949_END                             31107


#endif  // !_PPDRSRC_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\parsers\ppd\ppdparse.h ===
/*++

Copyright (c) 1996-1997  Microsoft Corporation

Module Name:

    ppdparse.h

Abstract:

    Declarations for PPD parser

Environment:

    PostScript driver, PPD parser

Revision History:

    08/20/96 -davidx-
        Common coding style for NT 5.0 drivers.

    03/26/96 -davidx-
        Created it.

--*/


#ifndef _PPDPARSE_H_
#define _PPDPARSE_H_

//
// PPD parser memory management functions
//
// NOTE: newly allocated memory is always zero initialized
// The parser allocates its working memory from the heap and
// everything is freed at the end when the heap is destroyed.
//

#define ALLOC_PARSER_MEM(pParserData, size) \
        ((PVOID) HeapAlloc((pParserData)->hHeap, HEAP_ZERO_MEMORY, (size)))

//
// Character constants
//

#define KEYWORD_CHAR    '*'
#define COMMENT_CHAR    '%'
#define SYMBOL_CHAR     '^'
#define SEPARATOR_CHAR  ':'
#define XLATION_CHAR    '/'
#define QUERY_CHAR      '?'
#define QUOTE_CHAR      '"'
#define TAB             '\t'
#define SPACE           ' '
#define CR              '\r'
#define LF              '\n'
#define IS_SPACE(c)     ((c) == SPACE || (c) == TAB)
#define IS_NEWLINE(c)   ((c) == CR || (c) == LF)

//
// Masks to indicate which characters can appear in what fields
//

#define KEYWORD_MASK        0x01
#define XLATION_MASK        0x02
#define QUOTED_MASK         0x04
#define STRING_MASK         0x08
#define DIGIT_MASK          0x10
#define HEX_DIGIT_MASK      0x20

extern const BYTE gubCharMasks[256];

#define IS_VALID_CHAR(ch)        (gubCharMasks[(BYTE) (ch)] != 0)
#define IS_MASKED_CHAR(ch, mask) (gubCharMasks[(BYTE) (ch)] & (mask))
#define IS_DIGIT(ch)             (gubCharMasks[(BYTE) (ch)] & DIGIT_MASK)
#define IS_HEX_DIGIT(ch)         (gubCharMasks[(BYTE) (ch)] & (DIGIT_MASK|HEX_DIGIT_MASK))
#define IS_KEYWORD_CHAR(ch)      ((ch) == KEYWORD_CHAR)

//
// Tags to identify various data types
//

#define VALUETYPE_NONE      0x01
#define VALUETYPE_STRING    0x02
#define VALUETYPE_QUOTED    0x04
#define VALUETYPE_SYMBOL    0x08

#define VALUETYPE_MASK      0xff

//
// Error code constants
//

#define PPDERR_NONE         0
#define PPDERR_MEMORY       (-1)
#define PPDERR_FILE         (-2)
#define PPDERR_SYNTAX       (-3)
#define PPDERR_EOF          (-4)

typedef INT PPDERROR;

//
// Special length value to indicate that an invocation string is defined by a symbol.
// Normal invocation strings must be shorter than this length.
//

#define SYMBOL_INVOCATION_LENGTH    0x80000000

#define MARK_SYMBOL_INVOC(pInvoc)  ((pInvoc)->dwLength |= SYMBOL_INVOCATION_LENGTH)
#define CLEAR_SYMBOL_INVOC(pInvoc) ((pInvoc)->dwLength &= ~SYMBOL_INVOCATION_LENGTH)
#define IS_SYMBOL_INVOC(pInvoc)    ((pInvoc)->dwLength & SYMBOL_INVOCATION_LENGTH)

typedef struct _INVOCOBJ {

    DWORD   dwLength;   // length of invocation string
    PVOID   pvData;     // points to invocation string data

} INVOCOBJ, *PINVOCOBJ;

//
// Data structure for representing a data buffer
//

typedef struct _BUFOBJ {

    DWORD       dwMaxLen;
    DWORD       dwSize;
    PBYTE       pbuf;

} BUFOBJ, *PBUFOBJ;

//
// Always reserve one byte in a buffer so that we can append a zero byte at the end.
//

#define IS_BUFFER_FULL(pbo)        ((pbo)->dwSize + 1 >= (pbo)->dwMaxLen)
#define IS_BUFFER_EMPTY(pbo)       ((pbo)->dwSize == 0)
#define CLEAR_BUFFER(pbo)          { (pbo)->dwSize = 0; (pbo)->pbuf[0] = 0; }
#define ADD_CHAR_TO_BUFFER(pbo, c) (pbo)->pbuf[(pbo)->dwSize++] = (BYTE)(c)
#define SET_BUFFER(pbo, buf)       \
        { (pbo)->pbuf = (PBYTE) (buf); (pbo)->dwMaxLen = sizeof(buf); (pbo)->dwSize = 0; }

//
// Maximum length for keyword, option, and translation strings.
// NOTE: we are being very lenient here because these limits are arbitrary and
// there is nothing that prevents us from handling longer lengths.
//

#define MAX_KEYWORD_LEN     64
#define MAX_OPTION_LEN      64
#define MAX_XLATION_LEN     256

//
// Constants to indicate whether an input slot requires PageRegion invocation
//

#define REQRGN_UNKNOWN      0
#define REQRGN_TRUE         1
#define REQRGN_FALSE        2

//
// Data structure for representing a mapped file object
//

typedef struct _FILEOBJ {

    HFILEMAP    hFileMap;
    PBYTE       pubStart;
    PBYTE       pubEnd;
    PBYTE       pubNext;
    DWORD       dwFileSize;
    PTSTR       ptstrFileName;
    INT         iLineNumber;
    BOOL        bNewLine;

} FILEOBJ, *PFILEOBJ;

#define END_OF_FILE(pFile) ((pFile)->pubNext >= (pFile)->pubEnd)
#define END_OF_LINE(pFile) ((pFile)->bNewLine)

//
// Data structure for representing a singly-linked list
//

typedef struct _LISTOBJ {

    PVOID       pNext;          // pointer to next node
    PSTR        pstrName;       // item name

} LISTOBJ, *PLISTOBJ;

//
// Data structure for representing symbol information
//

typedef struct _SYMBOLOBJ {

    PVOID       pNext;          // pointer to the next symbol
    PSTR        pstrName;       // symbol name
    INVOCOBJ    Invocation;     // symbol data

} SYMBOLOBJ, *PSYMBOLOBJ;

//
// Data structure for representing job patch file information
//

typedef struct _PATCHFILEOBJ {

    PVOID       pNext;          // pointer to the next patch
    PSTR        pstrName;       // string of the patch number
    LONG        lPatchNo;       // number of the patch as set in the PPD file
    INVOCOBJ    Invocation;     // symbol data

} JOBPATCHFILEOBJ, *PJOBPATCHFILEOBJ;

//
// Data structure for representing a default font substitution entry
//

typedef struct _TTFONTSUB {

    PVOID       pNext;          // pointer to the next entry
    PSTR        pstrName;       // TT font family name
    INVOCOBJ    Translation;    // TT font family name translation
    INVOCOBJ    PSName;         // PS font family name

} TTFONTSUB, *PTTFONTSUB;

//
// Data structure for representing printer feature option information
//
//  Need to change translation string field to make it ready for Unicode encoding.
//

typedef struct _OPTIONOBJ {

    PVOID       pNext;          // pointer to the next option
    PSTR        pstrName;       // option name
    INVOCOBJ    Translation;    // translation string
    INVOCOBJ    Invocation;     // invocation string
    DWORD       dwConstraint;   // list of UIConstraints associated with this option

} OPTIONOBJ, *POPTIONOBJ;

//
// Data structure for representing paper size information
//

typedef struct _PAPEROBJ {

    OPTIONOBJ   Option;         // generic option information
    SIZE        szDimension;    // paper dimension
    RECT        rcImageArea;    // imageable area

} PAPEROBJ, *PPAPEROBJ;

//
// Default paper size when the information in the PPD file is invalid
//

#define DEFAULT_PAPER_WIDTH     215900  // 8.5 inch measured in microns
#define DEFAULT_PAPER_LENGTH    279400  // 11 inch measured in microns

//
// paper size values for Letter and A4
//

#define LETTER_PAPER_WIDTH      215900  // 8.5 inch measured in microns
#define LETTER_PAPER_LENGTH     279400  // 11 inch measured in microns

#define A4_PAPER_WIDTH          210058  // 8.27 inch measured in microns
#define A4_PAPER_LENGTH         296926  // 11.69 inch measured in microns

//
// Data structure for representing input slot information
//

typedef struct _TRAYOBJ {

    OPTIONOBJ   Option;         // generic option information
    DWORD       dwReqPageRgn;   // whether PageRegion invocation is required
    DWORD       dwTrayIndex;    // index used for DEVMODE.dmDefaultSource field

} TRAYOBJ, *PTRAYOBJ;

//
// Data structure for representing output bin information
//

typedef struct _BINOBJ {

    OPTIONOBJ   Option;         // generic option information
    BOOL        bReversePrint;  // first page comes out at bottom?

} BINOBJ, *PBINOBJ;

//
// Data structure for representing memory configuration information
//

typedef struct _MEMOBJ {

    OPTIONOBJ   Option;         // generic option information
    DWORD       dwFreeVM;       // amount of free VM
    DWORD       dwFontMem;      // size of font cache memory

} MEMOBJ, *PMEMOBJ;

//
// Data structure for representing memory configuration information
//

typedef struct _RESOBJ {

    OPTIONOBJ   Option;         // generic option information
    FIX_24_8    fxScreenAngle;  // suggested screen angle
    FIX_24_8    fxScreenFreq;   // suggested screen frequency

} RESOBJ, *PRESOBJ;

//
// Data structure for representing printer feature information
//

typedef struct _FEATUREOBJ {

    PVOID       pNext;              // pointer to next printer feature
    PSTR        pstrName;           // feature name
    INVOCOBJ    Translation;        // translation string
    PSTR        pstrDefault;        // default option name
    DWORD       dwFeatureID;        // predefined feature identifier
    BOOL        bInstallable;       // whether the feature is an installble option
    DWORD       dwUIType;           // type of feature option list
    INVOCOBJ    QueryInvoc;         // query invocation string
    DWORD       dwConstraint;       // list of UIConstraints associated with this feature
    DWORD       dwOptionSize;       // size of each option item
    POPTIONOBJ  pOptions;           // pointer to list of options

} FEATUREOBJ, *PFEATUREOBJ;

//
// Data structure for representing device font information
//
// NOTE: The first three fields of this structure must match the
// first three fields of OPTIONOBJ structure.
//

typedef struct {

    PVOID       pNext;              // pointer to next device font
    PSTR        pstrName;           // font name
    INVOCOBJ    Translation;        // translation string
    PSTR        pstrEncoding;       // font encoding information
    PSTR        pstrCharset;        // charsets supported
    PSTR        pstrVersion;        // version string
    DWORD       dwStatus;           // status

} FONTREC, *PFONTREC;

//
// Data structure for maintain information used by the parser
//

typedef struct _PARSERDATA {

    PVOID       pvStartSig;         // signature used for debugging
    HANDLE      hHeap;              // memory heap used by the parser
    PFILEOBJ    pFile;              // pointer to current file object
    PDWORD      pdwKeywordHashs;    // precomputed hash values for built-in keywords
    PBYTE       pubKeywordCounts;   // count the occurrence of built-in keywords
    BOOL        bErrorFlag;         // semantic error flag
    INT         iIncludeLevel;      // current include level
    PFEATUREOBJ pOpenFeature;       // pointer to the open feature
    BOOL        bJclFeature;        // whether we're inside JCLOpenUI/JCLCloseUI
    BOOL        bInstallableGroup;  // whether we're inside InstallableOptions group
    PLISTOBJ    pPpdFileNames;      // list of source PPD filenames

    INVOCOBJ    NickName;           // printer model name
    DWORD       dwChecksum32;       // 32-bit CRC checksum of ASCII text PPD file
    DWORD       dwPpdFilever;       // PPD file version
    DWORD       dwSpecVersion;      // PPD spec version number
    DWORD       dwPSVersion;        // PostScript interpreter version number
    INVOCOBJ    PSVersion;          // PSVersion string
    INVOCOBJ    Product;            // Product string

    PFEATUREOBJ pFeatures;          // List of printer features
    PLISTOBJ    pUIConstraints;     // List of UIConstraints
    PLISTOBJ    pOrderDep;          // List of OrderDependency
    PLISTOBJ    pQueryOrderDep;     // List of QueryOrderPendency
    PFONTREC    pFonts;             // List of device fonts
    PJOBPATCHFILEOBJ  pJobPatchFiles;     // List of JobPatchFile invocation strings
    PSYMBOLOBJ  pSymbols;           // List of symbol definitions
    PTTFONTSUB  pTTFontSubs;        // List of TT font substitution entries

    INVOCOBJ    Password;           // password invocation string
    INVOCOBJ    ExitServer;         // exitserver invocation string
    INVOCOBJ    PatchFile;          // PatchFile invocation string
    INVOCOBJ    JclBegin;           // PJL job start invocation string
    INVOCOBJ    JclEnterPS;         // PJL enter PS  invocation string
    INVOCOBJ    JclEnd;             // PJL job end invocation string
    INVOCOBJ    ManualFeedFalse;    // ManualFeed False invocation string

    DWORD       dwLangEncoding;     // language encoding
    UINT        uCodePage;          // code page corresponding to language encoding
    DWORD       dwLangLevel;        // PostScript language level
    DWORD       dwFreeMem;          // default amount of free VM
    DWORD       dwThroughput;       // throughput
    DWORD       dwJobTimeout;       // suggested job timeout value
    DWORD       dwWaitTimeout;      // suggested wait timeout value
    DWORD       dwColorDevice;      // whether the device supports color
    DWORD       dwProtocols;        // protocols supported by the device
    DWORD       dwTTRasterizer;     // TrueType rasterizer option
    DWORD       dwLSOrientation;    // default landscape orientation
    FIX_24_8    fxScreenFreq;       // default halftone screen frequency
    FIX_24_8    fxScreenAngle;      // default halftone screen angle

    BOOL        bDefReversePrint;   // DefaultOutputOrder
    BOOL        bDefOutputOrderSet; // TRUE if bDefReversePrint is set through PPD
    DWORD       dwExtensions;       // language extensions
    DWORD       dwSetResType;       // how to set resolution
    DWORD       dwReqPageRgn;       // RequiresPageRegion All: information
    DWORD       dwPpdFlags;         // misc. PPD flags
    PSTR        pstrDefaultFont;    // DefaultFont: information

    DWORD       dwCustomSizeFlags;  // custom page size flags and parameters
    CUSTOMSIZEPARAM CustomSizeParams[CUSTOMPARAM_MAX];

    BOOL        bEuroInformationSet;// the Euro keyword was found in the PPD
    BOOL        bHasEuro;           // printer device fonts have the Euro

    BOOL        bTrueGray;          // TrueGray shall be detected by default

    //
    // Use for mapping NT4 feature indices to NT5 feature indices
    //

    WORD        wNt4Checksum;
    INT         iManualFeedIndex;
    INT         iDefInstallMemIndex;
    INT         iReqPageRgnIndex;
    BYTE        aubOpenUIFeature[MAX_GID];

    //
    // Buffers used to hold the content of various fields in the current entry
    //

    BUFOBJ      Keyword;
    BUFOBJ      Option;
    BUFOBJ      Xlation;
    BUFOBJ      Value;
    DWORD       dwValueType;

    CHAR        achKeyword[MAX_KEYWORD_LEN];
    CHAR        achOption[MAX_OPTION_LEN];
    CHAR        achXlation[MAX_XLATION_LEN];
    PSTR        pstrValue;

    //
    // These are used for compacting parsed PPD information into
    // binary printer description data.
    //

    PBYTE       pubBufStart;
    DWORD       dwPageSize;
    DWORD       dwCommitSize;
    DWORD       dwBufSize;
    PINFOHEADER pInfoHdr;
    PUIINFO     pUIInfo;
    PPPDDATA    pPpdData;

    PVOID       pvEndSig;           // signature used for debugging

} PARSERDATA, *PPARSERDATA;

//
// Simple integrity check on the parser data structure
//

#define VALIDATE_PARSER_DATA(pParserData) \
        ASSERT((pParserData) != NULL && \
               (pParserData)->pvStartSig == pParserData && \
               (pParserData)->pvEndSig == pParserData)

//
// Parse a PPD file
//

PPDERROR
IParseFile(
    PPARSERDATA pParserData,
    PTSTR       ptstrFilename
    );

//
// Grow a buffer object when it becomes full
//

PPDERROR
IGrowValueBuffer(
    PBUFOBJ pBufObj
    );

//
// Parse one entry from a PPD file
//

PPDERROR
IParseEntry(
    PPARSERDATA pParserData
    );

//
// Interpret an entry parsed from a PPD file
//

PPDERROR
IInterpretEntry(
    PPARSERDATA pParserData
    );

//
// Build up data structures to speed up keyword lookup
//

BOOL
BInitKeywordLookup(
    PPARSERDATA pParserData
    );

//
// Find a named item from a linked-list
//

PVOID
PvFindListItem(
    PVOID   pvList,
    PCSTR   pstrName,
    PDWORD  pdwIndex
    );

//
// Convert embedded hexdecimal strings into binary data
//

BOOL
BConvertHexString(
    PBUFOBJ pBufObj
    );

//
// Search for a keyword from a string table
//

typedef struct _STRTABLE {

    PCSTR   pstrKeyword;    // keyword name
    DWORD   dwValue;        // corresponding value

} STRTABLE;

typedef const STRTABLE *PCSTRTABLE;

BOOL
BSearchStrTable(
    PCSTRTABLE  pTable,
    PSTR        pstrKeyword,
    DWORD      *pdwValue
    );

//
// Parse an unsigned floating-point number from a character string
//

BOOL
BGetFloatFromString(
    PSTR   *ppstr,
    PLONG   plValue,
    INT     iType
    );

#define FLTYPE_ERROR            (-1)
#define FLTYPE_POINT            0
#define FLTYPE_INT              1
#define FLTYPE_FIX              2
#define FLTYPE_POINT_ROUNDUP    3
#define FLTYPE_POINT_ROUNDDOWN  4

//
// Parse an unsigned decimal integer value from a character string
//

BOOL
BGetIntegerFromString(
    PSTR   *ppstr,
    LONG   *plValue
    );

//
// Strip off the keyword prefix character from the input string
//

PCSTR
PstrStripKeywordChar(
    PCSTR   pstrKeyword
    );

//
// Find the next word in a character string (Words are separated by spaces)
//

BOOL
BFindNextWord(
    PSTR   *ppstr,
    PSTR    pstrWord
    );

#define MAX_WORD_LEN    MAX_KEYWORD_LEN

//
// Create an input file object
//

PFILEOBJ
PCreateFileObj(
    PTSTR       ptstrFilename
    );

//
// Delete an input file object
//

VOID
VDeleteFileObj(
    PFILEOBJ    pFile
    );

//
// Read the next character from the input file
// Special character to indicate end-of-file condition
//

INT
IGetNextChar(
    PFILEOBJ    pFile
    );

#define EOF_CHAR    (-1)

//
// Return the last character read to the input file
//

VOID
VUngetChar(
    PFILEOBJ    pFile
    );

//
// Skip all characters until the next non-space character
//

VOID
VSkipSpace(
    PFILEOBJ    pFile
    );

//
// Skip the remaining characters on the current input line
//

VOID
VSkipLine(
    PFILEOBJ    pFile
    );

//
// Check if a character string only consists of printable 7-bit ASCII characters
//

BOOL
BIs7BitAscii(
    PSTR        pstr
    );

//
// Display a syntax error message
//

PPDERROR
ISyntaxErrorMessage(
    PFILEOBJ    pFile,
    PSTR        pstrMsg
    );

#if DBG
#define ISyntaxError(pFile, errmsg) ISyntaxErrorMessage(pFile, errmsg)
#else
#define ISyntaxError(pFile, errmsg) ISyntaxErrorMessage(pFile, NULL)
#endif

//
// Keyword string for various predefined features
//

extern const CHAR gstrDefault[];
extern const CHAR gstrPageSizeKwd[];
extern const CHAR gstrInputSlotKwd[];
extern const CHAR gstrManualFeedKwd[];
extern const CHAR gstrCustomSizeKwd[];
extern const CHAR gstrLetterSizeKwd[];
extern const CHAR gstrA4SizeKwd[];
extern const CHAR gstrLongKwd[];
extern const CHAR gstrShortKwd[];
extern const CHAR gstrTrueKwd[];
extern const CHAR gstrFalseKwd[];
extern const CHAR gstrOnKwd[];
extern const CHAR gstrOffKwd[];
extern const CHAR gstrNoneKwd[];
extern const CHAR gstrVMOptionKwd[];
extern const CHAR gstrInstallMemKwd[];
extern const CHAR gstrDuplexTumble[];
extern const CHAR gstrDuplexNoTumble[];

#endif  // !_PPDPARSE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\parsers\ppd\sources.inc ===
!IF 0

Copyright (c) 1996  Microsoft Corporation

Common sources shared by both um and km directory

!ENDIF

SOURCES=\
    ..\ppd.c \
    ..\custsize.c
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\tools\kdexts\font.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    font.c

Abstract:

    Dump IFIMETRICS

Environment:

    Windows NT printer drivers

Revision History:

    04/16/97 -eigos-
        Created it.

--*/

#include "precomp.h"

#define KERNEL_MODE
#include "unidrv\font\font.h"


#define IFIMETRICS_DumpInt(field) \
        dprintf("  %-16s = %d\n", #field, ifimetrics.field)

#define IFIMETRICS_DumpHex(field) \
        dprintf("  %-16s = 0x%x\n", #field, ifimetrics.field)

#define IFIMETRICS_DumpWStr(field) \
        dprintf("  %-16s = %s\n", #field, (PBYTE)pifimetrics + ifimetrics.field)

#define IFIMETRICS_DumpRec(field) \
        dprintf("  %-16s = 0x%x L 0x%x\n", \
                #field, \
                (ULONG) pifimetrics + offsetof(IFIMETRICS, field), \
                sizeof(ifimetrics.field))


VOID
dump_unidrv_ifimetrics(
    IFIMETRICS    *pifimetrics
    )

{
    IFIMETRICS ifimetrics;

    dprintf("\nUNIDRV device data (%x):\n", pifimetrics);
    debugger_copy_memory(&ifimetrics, pifimetrics, sizeof(ifimetrics));


    IFIMETRICS_DumpInt(cjThis);
    IFIMETRICS_DumpInt(cjIfiExtra);
    IFIMETRICS_DumpWStr(dpwszFamilyName);
    IFIMETRICS_DumpWStr(dpwszStyleName);
    IFIMETRICS_DumpWStr(dpwszFaceName);
    IFIMETRICS_DumpWStr(dpwszUniqueName);
    IFIMETRICS_DumpHex(dpFontSim);
    IFIMETRICS_DumpInt(lEmbedId);
    IFIMETRICS_DumpInt(lItalicAngle);
    IFIMETRICS_DumpInt(lCharBias);
    IFIMETRICS_DumpHex(dpCharSets);
    IFIMETRICS_DumpInt(jWinCharSet);
    IFIMETRICS_DumpInt(jWinPitchAndFamily);
    IFIMETRICS_DumpInt(usWinWeight);
    IFIMETRICS_DumpInt(flInfo);
    IFIMETRICS_DumpInt(fsSelection);
    IFIMETRICS_DumpInt(fsType);
    IFIMETRICS_DumpInt(fwdUnitsPerEm);
    IFIMETRICS_DumpInt(fwdLowestPPEm);
    IFIMETRICS_DumpInt(fwdWinAscender);
    IFIMETRICS_DumpInt(fwdWinDescender);
    IFIMETRICS_DumpInt(fwdMacAscender);
    IFIMETRICS_DumpInt(fwdMacDescender);
    IFIMETRICS_DumpInt(fwdMacLineGap);
    IFIMETRICS_DumpInt(fwdTypoAscender);
    IFIMETRICS_DumpInt(fwdTypoDescender);
    IFIMETRICS_DumpInt(fwdTypoLineGap);
    IFIMETRICS_DumpInt(fwdAveCharWidth);
    IFIMETRICS_DumpInt(fwdMaxCharInc);
    IFIMETRICS_DumpInt(fwdCapHeight);
    IFIMETRICS_DumpInt(fwdXHeight);
    IFIMETRICS_DumpInt(fwdSubscriptXSize);
    IFIMETRICS_DumpInt(fwdSubscriptYSize);
    IFIMETRICS_DumpInt(fwdSubscriptXOffset);
    IFIMETRICS_DumpInt(fwdSubscriptYOffset);
    IFIMETRICS_DumpInt(fwdSuperscriptXSize);
    IFIMETRICS_DumpInt(fwdSuperscriptYSize);
    IFIMETRICS_DumpInt(fwdSuperscriptXOffset);
    IFIMETRICS_DumpInt(fwdSuperscriptYOffset);
    IFIMETRICS_DumpInt(fwdUnderscoreSize);
    IFIMETRICS_DumpInt(fwdUnderscorePosition);
    IFIMETRICS_DumpInt(fwdStrikeoutSize);
    IFIMETRICS_DumpInt(fwdStrikeoutPosition);
    IFIMETRICS_DumpHex(chFirstChar);
    IFIMETRICS_DumpHex(chLastChar);
    IFIMETRICS_DumpHex(chDefaultChar);
    IFIMETRICS_DumpHex(chBreakChar);
    IFIMETRICS_DumpHex(wcFirstChar);
    IFIMETRICS_DumpHex(wcLastChar);
    IFIMETRICS_DumpHex(wcDefaultChar);
    IFIMETRICS_DumpHex(wcBreakChar);
    IFIMETRICS_DumpInt(ptlBaseline.x);
    IFIMETRICS_DumpInt(ptlBaseline.y);
    IFIMETRICS_DumpInt(ptlAspect.x);
    IFIMETRICS_DumpInt(ptlAspect.y);
    IFIMETRICS_DumpInt(ptlCaret.x);
    IFIMETRICS_DumpInt(ptlCaret.y);
    IFIMETRICS_DumpInt(rclFontBox.left);
    IFIMETRICS_DumpInt(rclFontBox.top);
    IFIMETRICS_DumpInt(rclFontBox.right);
    IFIMETRICS_DumpInt(rclFontBox.bottom);
    IFIMETRICS_DumpInt(achVendId[0]);
    IFIMETRICS_DumpInt(achVendId[1]);
    IFIMETRICS_DumpInt(achVendId[2]);
    IFIMETRICS_DumpInt(achVendId[3]);
    IFIMETRICS_DumpInt(cKerningPairs);
    IFIMETRICS_DumpInt(ulPanoseCulture);
    //IFIMETRICS_DumpInt(panose);
}


DECLARE_API(ifi)
{
    LONG param;

    if (*args == '\0')
    {
        dprintf("usage: ifimetrics addr\n");
        return;
    }

    sscanf(args, "%lx", &param);
    dump_unidrv_ifimetrics((IFIMETRICS*) param);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\tools\kdexts\makefile.inc ===
!ifdef BETA2
prnkdx.def: prnkdx.txt
    sed "s/\;BETA2//g" prnkdx.txt > prnkdx.def
!else
prnkdx.def: prnkdx.txt
    sed "s/\;BETA1//g" prnkdx.txt > prnkdx.def
!endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\tools\kdexts\dm.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    dm.c

Abstract:

    Dump public devmode structure

Environment:

	Windows NT printer drivers

Revision History:

	02/28/97 -davidx-
		Created it.

--*/

#include "precomp.h"

#include <wingdi.h>


#define DM_DumpInt(field) \
        dprintf("  %-16s = %d\n", #field, dm.field)

#define DM_DumpHex(field) \
        dprintf("  %-16s = 0x%x\n", #field, dm.field)

#define DM_DumpRec(field) \
        dprintf("  %-16s = 0x%x L 0x%x\n", \
                #field, \
                (ULONG) pdm + offsetof(DEVMODE, field), \
                sizeof(dm.field))


VOID
dump_public_devmode(
    PDEVMODE    pdm
    )

{
    DEVMODE dm;

    dprintf("\nPublic devmode data (%x):\n", pdm);
    debugger_copy_memory(&dm, pdm, sizeof(dm));

    DM_DumpRec(dmDeviceName);
    DM_DumpInt(dmSpecVersion);
    DM_DumpInt(dmDriverVersion);
    DM_DumpInt(dmSize);
    DM_DumpInt(dmDriverExtra);
    DM_DumpHex(dmFields);
    DM_DumpInt(dmOrientation);
    DM_DumpInt(dmPaperSize);
    DM_DumpInt(dmPaperLength);
    DM_DumpInt(dmPaperWidth);
    DM_DumpInt(dmScale);
    DM_DumpInt(dmCopies);
    DM_DumpInt(dmDefaultSource);
    DM_DumpInt(dmPrintQuality);
    DM_DumpInt(dmColor);
    DM_DumpInt(dmDuplex);
    DM_DumpInt(dmYResolution);
    DM_DumpInt(dmTTOption);
    DM_DumpInt(dmCollate);
    DM_DumpRec(dmFormName);
    DM_DumpInt(dmLogPixels);
    DM_DumpInt(dmBitsPerPel);
    DM_DumpInt(dmPelsWidth);
    DM_DumpInt(dmPelsHeight);
    DM_DumpInt(dmDisplayFlags);
    DM_DumpInt(dmDisplayFrequency);
    DM_DumpInt(dmICMMethod);
    DM_DumpInt(dmICMIntent);
    DM_DumpInt(dmMediaType);
    DM_DumpInt(dmDitherType);
    DM_DumpInt(dmPanningWidth);
    DM_DumpInt(dmPanningHeight);
}


DECLARE_API(dm)
{
    LONG param;

    if (*args == '\0')
    {
        dprintf("usage: dm addr\n");
        return;
    }

    sscanf(args, "%lx", &param);
    dump_public_devmode((PDEVMODE) param);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\tools\kdexts\gpddata.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    gpddata.c

Abstract:

    Dump GLOBALS structure

Environment:

    Windows NT printer drivers

Revision History:

    03/31/97 -eigos-
        Created it.

--*/

#include "precomp.h"

#define KERNEL_MODE
#include "lib.h"
#include "gpd.h"


#define GPD_DumpInt(field) \
        dprintf("  %-16s = %d\n", #field, globals.field)

#define GPD_DumpHex(field) \
        dprintf("  %-16s = 0x%x\n", #field, globals.field)

#define GPD_DumpWStr(field) \
        dprintf("  %-16s = %s\n", #field, globals.field)

#define GPD_DumpRec(field) \
        dprintf("  %-16s = 0x%x L 0x%x\n", \
                #field, \
                    (ULONG) pGlobals + offsetof(GLOBALS, field), \
                sizeof(globals.field))


VOID
dump_globals(
    PGLOBALS pGlobals
    )

{
    GLOBALS globals;

    dprintf("\nGLOBALS structure (%x):\n", pGlobals);
    debugger_copy_memory(&globals, pGlobals, sizeof(globals));

    GPD_DumpWStr(pwstrGPDSpecVersion);
    GPD_DumpInt(ptMasterUnits.x);
    GPD_DumpInt(ptMasterUnits.y);
    GPD_DumpWStr(pwstrModelName);
    GPD_DumpRec(printertype);
    GPD_DumpWStr(pwstrIncludeFiles);
    GPD_DumpWStr(pwstrResourceDLL);
    GPD_DumpInt(dwMaxCopies);
    GPD_DumpInt(dwFontCartSlots);
    GPD_DumpHex(bRotateCoordinate);
    GPD_DumpHex(bRotateRasterData);
    GPD_DumpRec(liTextCaps);
    GPD_DumpHex(bRotateFont);
    GPD_DumpRec(cxaftercr);
    GPD_DumpRec(liBadCursorMoveInGrxMode);
    GPD_DumpInt(dwMaxLineSpacing);
    GPD_DumpInt(bEjectPageWithFF);
    GPD_DumpInt(dwXMoveThreshold);
    GPD_DumpInt(ptDeviceUnits.x);
    GPD_DumpInt(ptDeviceUnits.y);
    GPD_DumpHex(bChangeColorMode);
    GPD_DumpInt(dwMaxNumPalettes);
    GPD_DumpRec(liPaletteSizes);
    GPD_DumpRec(liPaletteScope);
    GPD_DumpRec(outputdataformat);
    GPD_DumpHex(bOptimizeLeftBound);
    GPD_DumpHex(liStripBlanks);
    GPD_DumpHex(bRasterSendAllData);
    GPD_DumpRec(cxafterblock);
    GPD_DumpRec(cyafterblock);
    GPD_DumpHex(bUseCmdSendBlockDataForColor);
    GPD_DumpHex(bMoveToX0BeforeColor);
    GPD_DumpHex(bSendMultipleRows);
    GPD_DumpRec(liDeviceFontList);
    GPD_DumpInt(dwDefaultFont);
    GPD_DumpInt(dwMaxFontUsePerPage);
    GPD_DumpInt(dwDefaultCTT);
    GPD_DumpInt(dwLookaheadRegion);
    GPD_DumpInt(iTextYOffset);
    GPD_DumpRec(charpos);
    GPD_DumpHex(bTTFSEnabled);
    GPD_DumpInt(dwMinFontID);
    GPD_DumpInt(dwMaxFontID);
    GPD_DumpInt(dwMaxNumDownFonts);
    GPD_DumpRec(dlsymbolset);
    GPD_DumpInt(dwMinGlyphID);
    GPD_DumpInt(dwMaxGlyphID);
    GPD_DumpRec(fontformat);
    GPD_DumpHex(bDiffFontsPerByteMode);
    GPD_DumpRec(cxafterfill);
    GPD_DumpRec(cyafterfill);
    GPD_DumpInt(dwMinGrayFill);
    GPD_DumpInt(dwMaxGrayFill);
}


DECLARE_API(globals)
{
    LONG param;

    if (*args == '\0')
    {
        dprintf("usage: globals addr\n");
        return;
    }

    sscanf(args, "%lx", &param);
    dump_globals((PGLOBALS) param);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\tools\kdexts\memdump.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    memdump.c

Abstract:

    Dump currently allocated memory blocks

Environment:

	Windows NT printer drivers

Revision History:

	02/28/97 -davidx-
		Created it.

--*/

#include "precomp.h"


//
// Doubly-linked list of all currently allocated memory blocks
//

#define MAX_DEBUGMEM_FILENAME   16

typedef struct _DEBUGMEMHDR {

    struct  _DEBUGMEMHDR *pPrev;
    struct  _DEBUGMEMHDR *pNext;
    CHAR    strFilename[MAX_DEBUGMEM_FILENAME];
    INT     iLineNumber;
    DWORD   dwSize;
    PVOID   pvSignature;

} DEBUGMEMHDR, *PDEBUGMEMHDR;


VOID
dump_allocated_memory(
    PDEBUGMEMHDR pMemHdr
    )

{
    DEBUGMEMHDR     MemHdr;
    PDEBUGMEMHDR    p, prev;
    INT             count = 0;

    dprintf("Currently allocated memory blocks (%x):\n", pMemHdr);
    debugger_copy_memory(&MemHdr, pMemHdr, sizeof(MemHdr));
    p = pMemHdr;

    while (TRUE)
    {
        if (CheckControlC())
            break;

        prev = p;

        if ((p = MemHdr.pNext) == NULL)
        {
            dprintf("*** Doubly-linked list is broken\n");
            break;
        }

        if (p == pMemHdr)
            break;
        
        if (p == prev)
        {
            dprintf("*** Doubly-linked list is circular\n");
            break;
        }

        count++;
        debugger_copy_memory(&MemHdr, p, sizeof(MemHdr));

        dprintf("  0x%08X L 0x%-4X line %-4d %s",
                (ULONG) p + sizeof(DEBUGMEMHDR),
                MemHdr.dwSize,
                MemHdr.iLineNumber,
                MemHdr.strFilename);

        if (p != MemHdr.pvSignature)
            dprintf(" - corrupted!!!");
        
        dprintf("\n");
    }

    if (count > 0)
        dprintf("Total number of memory blocks used: %d\n", count);
}


DECLARE_API(memdump)
{
    LONG param;

    if (*args == '\0')
    {
        dprintf("usage: memdump addr\n");
        return;
    }

    sscanf(args, "%lx", &param);
    dump_allocated_memory((PDEBUGMEMHDR) param);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\tools\kdexts\precomp.h ===
#include <stddef.h>
#include <stdlib.h>
#include <stdarg.h>
#include <stdio.h>
#include <wtypes.h>
#include <windef.h>
#include <wdbgexts.h>
#include <objbase.h>

extern ULONG BytesRead;

typedef struct _FLAGDEF {
    char *psz;          // description
    FLONG fl;           // flag
} FLAGDEF;

#define debugger_copy_memory(dest, src, size) \
        ReadMemory((ULONG) (src), dest, size, &BytesRead)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\tools\kdexts\help.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    help.c

Abstract:

    Display help information about printer driver kernel debugger extensions

Environment:

	Windows NT printer drivers

Revision History:

	02/28/97 -davidx-
		Created it.

--*/

#include "precomp.h"

static CHAR gstrHelpString[] = 
    "\n\n"
    "prnkdx - Printer Driver Kernel Debugger Extensions\n"
    "\n"
    "memdump addr  -- dump currently allocated memory blocks\n"
    "    only works on drivers built with DBG and MEMDEBUG flags set\n"
    "    addr is the address of global variable gMemListHdr\n"
    "dm addr       -- dump public devmode data\n"
    "prndata addr  -- dump PRINTERDATA structure\n"
    "uiinfo addr   -- dump UIINFO structure\n"
    "\n< PostScript >\n"
    "psdev addr    -- dump PSCRIPT's device data structure\n"
    "psdm addr     -- dump PSCRIPT's private devmode data\n"
    "ppddata addr  -- dump PPDDATA structure\n"
    "dlfont addr   -- dump PSCRIPT's DLFONT data structure\n"
    "\n< Unidrv >\n"
    "unidev addr   -- dump UNIDRV's device data structure\n"
    "unidm addr    -- dump UNIDRV's devmode data structure\n"
    "globals addr  -- dump UNIDRV's GLOBALS data structure\n"
    "fontpdev addr -- dump UNIDRV's fontpdev data structure\n"
    "fm addr       -- dump UNIDRV's fontmap data structure\n"
    "devfm addr    -- dump UNIDRV's device font fontmap data structure\n"
    "bmpfm addr    -- dump UNIDRV's BMPDownload font fontmap data structure\n"
    "tod addr      -- dump UNIDRV's to_data data structure\n"
    "wt addr       -- dump UNIDRV's whitetext data structure\n"
    "\n";

DECLARE_API(help)
{
    dprintf("%s", gstrHelpString);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\tools\kdexts\ppddata.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    ppddata.c

Abstract:

    Dump PPDDATA structure

Environment:

	Windows NT printer drivers

Revision History:

	02/28/97 -davidx-
		Created it.

--*/

#include "precomp.h"

#define KERNEL_MODE
#include "lib.h"
#include "ppd.h"


#define PPD_DumpInt(field) \
        dprintf("  %-16s = %d\n", #field, ppddata.field)

#define PPD_DumpHex(field) \
        dprintf("  %-16s = 0x%x\n", #field, ppddata.field)

#define PPD_DumpRec(field) \
        dprintf("  %-16s = 0x%x L 0x%x\n", \
                #field, \
                (ULONG) pPpdData + offsetof(PPDDATA, field), \
                sizeof(ppddata.field))


VOID
dump_ppddata(
    PPPDDATA pPpdData
    )

{
    PPDDATA ppddata;

    dprintf("\nPPDDATA structure (%x):\n", pPpdData);
    debugger_copy_memory(&ppddata, pPpdData, sizeof(ppddata));

    PPD_DumpInt(dwSizeOfStruct);
    PPD_DumpHex(dwFlags);
    PPD_DumpHex(dwExtensions);
    PPD_DumpInt(dwSetResType);
    PPD_DumpInt(dwPSVersion);
    PPD_DumpRec(PSVersion);
    PPD_DumpRec(Product);
    PPD_DumpHex(dwCustomSizeFlags);
    PPD_DumpInt(dwLeadingEdgeLong);
    PPD_DumpInt(dwLeadingEdgeShort);
    PPD_DumpInt(dwUseHWMarginsTrue);
    PPD_DumpInt(dwUseHWMarginsFalse);
    PPD_DumpRec(CustomSizeParams);

    PPD_DumpHex(dwNt4Checksum);
    PPD_DumpInt(dwNt4DocFeatures);
    PPD_DumpInt(dwNt4PrnFeatures);
    PPD_DumpRec(Nt4Mapping);

    PPD_DumpRec(PatchFile);
    PPD_DumpRec(JclBegin);
    PPD_DumpRec(JclEnterPS);
    PPD_DumpRec(JclEnd);
    PPD_DumpRec(ManualFeedFalse);

    PPD_DumpHex(loDefaultFont);
    PPD_DumpRec(DeviceFonts);
    PPD_DumpRec(OrderDeps);
    PPD_DumpRec(QueryOrderDeps);
    PPD_DumpRec(JobPatchFiles);
}


DECLARE_API(ppddata)
{
    LONG param;

    if (*args == '\0')
    {
        dprintf("usage: ppddata addr\n");
        return;
    }

    sscanf(args, "%lx", &param);
    dump_ppddata((PPPDDATA) param);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\tools\kdexts\prndata.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    prndata.c

Abstract:

    Dump printer-sticky property data

Environment:

	Windows NT printer drivers

Revision History:

	02/28/97 -davidx-
		Created it.

--*/

#include "precomp.h"

#define KERNEL_MODE
#include "lib.h"


#define PRN_DumpInt(field) \
        dprintf("  %-16s = %d\n", #field, printerdata.field)

#define PRN_DumpHex(field) \
        dprintf("  %-16s = 0x%x\n", #field, printerdata.field)

#define PRN_DumpRec(field) \
        dprintf("  %-16s = 0x%x L 0x%x\n", \
                #field, \
                (ULONG) pPrinterData + offsetof(PRINTERDATA, field), \
                sizeof(printerdata.field))


VOID
dump_printer_data(
    PPRINTERDATA    pPrinterData
    )

{
    PRINTERDATA printerdata;

    dprintf("\nPublic printer-sticky data (%x):\n", pPrinterData);
    debugger_copy_memory(&printerdata, pPrinterData, sizeof(printerdata));

    PRN_DumpInt(wDriverVersion);
    PRN_DumpInt(wSize);
    PRN_DumpHex(dwFlags);
    PRN_DumpInt(dwFreeMem);
    PRN_DumpInt(dwJobTimeout);
    PRN_DumpInt(dwWaitTimeout);
    PRN_DumpInt(wMinoutlinePPEM);
    PRN_DumpInt(wMaxbitmapPPEM);
    PRN_DumpInt(wReserved2);
    PRN_DumpInt(wProtocol);
    PRN_DumpHex(dwChecksum32);
    PRN_DumpInt(dwOptions);
    PRN_DumpRec(aOptions);
}


DECLARE_API(prndata)
{
    LONG param;

    if (*args == '\0')
    {
        dprintf("usage: prndata addr\n");
        return;
    }

    sscanf(args, "%lx", &param);
    dump_printer_data((PPRINTERDATA) param);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\tools\kdexts\prnkdx.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    prnkdx.c

Abstract:

    Main entrypoint for printer driver kernel debugger extensions

Environment:

	Windows NT printer drivers

Revision History:

	02/28/97 -davidx-
		Created it.

--*/

#include "precomp.h"
#include <ntverp.h>


WINDBG_EXTENSION_APIS   ExtensionApis;
USHORT                  SavedMajorVersion;
USHORT                  SavedMinorVersion;
ULONG                   BytesRead;

EXT_API_VERSION        ApiVersion =
{
    (VER_PRODUCTVERSION_W >> 8) & 0xff,
    VER_PRODUCTVERSION_W & 0xff,
    EXT_API_VERSION_NUMBER,
    0
};


VOID
WinDbgExtensionDllInit(
    PWINDBG_EXTENSION_APIS lpExtensionApis,
    USHORT MajorVersion,
    USHORT MinorVersion
    )
{
    ExtensionApis = *lpExtensionApis;

    SavedMajorVersion = MajorVersion;
    SavedMinorVersion = MinorVersion;
}


LPEXT_API_VERSION
ExtensionApiVersion(
    VOID
    )
{
    return &ApiVersion;
}


#if DBG
#define EXPECTED_MAJOR_VERSION  0x0c
#else
#define EXPECTED_MAJOR_VERSION  0x0f
#endif

#define CHECK_BUILD_STRING  "Checked"
#define FREE_BUILD_STRING   "Free"

#define BUILD_TYPE_STRING(MajorVersion) \
        ((MajorVersion) == 0x0c ? CHECK_BUILD_STRING : FREE_BUILD_STRING)

VOID
CheckVersion(
    VOID
    )
{
    if (SavedMajorVersion != EXPECTED_MAJOR_VERSION || SavedMinorVersion != VER_PRODUCTBUILD)
    {
        dprintf("*** Extension DLL (%d %s) does not match target system (%d %s)\n",
                VER_PRODUCTBUILD,
                BUILD_TYPE_STRING(EXPECTED_MAJOR_VERSION),
                SavedMinorVersion,
                BUILD_TYPE_STRING(SavedMajorVersion));
    }
}


DECLARE_API(version)
{
    dprintf("%s Extension dll for Build %d debugging %s kernel for Build %d\n",
            BUILD_TYPE_STRING(EXPECTED_MAJOR_VERSION),
            VER_PRODUCTBUILD,
            BUILD_TYPE_STRING(SavedMajorVersion),
            SavedMinorVersion);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\tools\kdexts\psdev.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    psdev.c

Abstract:

    Dump PSCRIPT's device data structure

Environment:

        Windows NT printer drivers

Revision History:

        02/28/97 -davidx-
                Created it.

--*/

#include "precomp.h"

#define KERNEL_MODE
#include "pscript\pscript.h"


#define PDEV_DumpInt(field) \
        dprintf("  %-16s = %d\n", #field, dev.field)

#define PDEV_DumpHex(field) \
        dprintf("  %-16s = 0x%x\n", #field, dev.field)

#define PDEV_DumpRec(field) \
        dprintf("  %-16s = 0x%x L 0x%x\n", \
                #field, \
                (ULONG) pdev + offsetof(DEV, field), \
                sizeof(dev.field))


VOID
dump_pscript_dev(
    PDEV    pdev
    )

{
    DEV dev;

    dprintf("\nPSCRIPT device data (%x):\n", pdev);
    debugger_copy_memory(&dev, pdev, sizeof(dev));

    if (dev.dwUniqueID != PSCRIPT_PDEV_UNIQUEID || dev.pvEndSig != pdev)
    {
        dprintf("*** invalid pscript device data\n");
    }

    PDEV_DumpRec(devobj);
    PDEV_DumpHex(pstrNTVersion);
    PDEV_DumpHex(dwDebugFlags);
    PDEV_DumpHex(pdm);
    PDEV_DumpHex(pdmPrivate);
    PDEV_DumpHex(hModule);
    PDEV_DumpHex(hSurface);
    PDEV_DumpHex(hPalette);
    PDEV_DumpRec(PrinterData);
    PDEV_DumpHex(pTTSubTable);
    PDEV_DumpHex(pDriverInfo3);
    PDEV_DumpInt(iAppType);
    PDEV_DumpInt(bUseTrueColor);
    PDEV_DumpInt(iCurrentDpi);
    PDEV_DumpInt(iOrientAngle);
    PDEV_DumpInt(dwSaveLevel);
    PDEV_DumpRec(procset);
    PDEV_DumpRec(gsstack);
    PDEV_DumpInt(drvstate);
    PDEV_DumpHex(pRawData);
    PDEV_DumpHex(pUIInfo);
    PDEV_DumpHex(pPpdData);
    PDEV_DumpRec(job);
    PDEV_DumpRec(vm);
    PDEV_DumpRec(szPaper);
    PDEV_DumpRec(rcImageArea);
    PDEV_DumpRec(rcBBox);
    PDEV_DumpInt(lPaperWidth);
    PDEV_DumpInt(lPaperHeight);
    PDEV_DumpInt(lOriginX);
    PDEV_DumpInt(lOriginY);
    PDEV_DumpInt(lImageWidth);
    PDEV_DumpInt(lImageHeight);
    PDEV_DumpInt(lCustomWidth);
    PDEV_DumpInt(lCustomHeight);
    PDEV_DumpInt(lCustomWidthOffset);
    PDEV_DumpInt(lCustomHeightOffset);
    PDEV_DumpInt(lOrientation);
    PDEV_DumpHex(pInjectData);
    PDEV_DumpHex(pDocResources);
    PDEV_DumpRec(aPrinterOptions);
    PDEV_DumpHex(dwAscii85Val);
    PDEV_DumpInt(dwAscii85Cnt);
    PDEV_DumpInt(dwFilterLineLen);
    PDEV_DumpHex(pSpoolBuf);
    PDEV_DumpRec(achDocName);
    PDEV_DumpRec(colres);
    PDEV_DumpRec(psfns);
    PDEV_DumpInt(bErrorFlag);
    PDEV_DumpHex(pubRleData);
    PDEV_DumpHex(pOemPlugins);
    PDEV_DumpHex(pOemHookInfo);
    PDEV_DumpInt(bCallingOem);
    PDEV_DumpInt(ulPSFontNumber);
    PDEV_DumpInt(ulFontID);
    PDEV_DumpHex(pout);
    PDEV_DumpHex(pufl);
    PDEV_DumpHex(pDLFonts);
    PDEV_DumpHex(pPSFonts);
    PDEV_DumpHex(pTextoutBuffer);
    PDEV_DumpHex(pfo);
    PDEV_DumpHex(pifi);
    PDEV_DumpHex(pvTTFile);
    PDEV_DumpInt(ulTTSize);
    PDEV_DumpInt(cNtfFiles);
    PDEV_DumpRec(pNtfFiles);
    PDEV_DumpHex(pDevFont);
}


DECLARE_API(psdev)
{
    LONG param;

    if (*args == '\0')
    {
        dprintf("usage: psdev addr\n");
        return;
    }

    sscanf(args, "%lx", &param);
    dump_pscript_dev((PDEV) param);
}


#define DLFONT_DumpInt(field) \
        dprintf("  %-16s = %d\n", #field, dlfont.field)

#define DLFONT_DumpHex(field) \
        dprintf("  %-16s = 0x%x\n", #field, dlfont.field)

#define DLFONT_DumpRec(field) \
        dprintf("  %-16s = 0x%x L 0x%x\n", \
                #field, \
                (ULONG) pDLFont + offsetof(DLFONT, field), \
                sizeof(dlfont.field))


VOID
dump_pscript_dlfont(
    PDLFONT pDLFont
    )

{
    DLFONT  dlfont;

    dprintf("\nPSCRIPT DLFONT data structure (%x):\n", pDLFont);
    debugger_copy_memory(&dlfont, pDLFont, sizeof(dlfont));


    DLFONT_DumpHex(pNext);
    DLFONT_DumpHex(pdev);
    DLFONT_DumpRec(strFontName);
    DLFONT_DumpRec(strPSName);
    DLFONT_DumpHex(iUnique);
    DLFONT_DumpHex(ulDLStyles);
    DLFONT_DumpInt(ulPSFontFmt);
    DLFONT_DumpRec(subFont);
    DLFONT_DumpRec(giToSoi);
    DLFONT_DumpHex(ulTTFileSize);
    DLFONT_DumpHex(pTTFile);
}


DECLARE_API(dlfont)
{
    LONG param;

    if (*args == '\0')
    {
        dprintf("usage: dlfont addr\n");
        return;
    }

    sscanf(args, "%lx", &param);
    dump_pscript_dlfont((PDLFONT) param);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\tools\kdexts\psdm.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    psdm.c

Abstract:

    Dump PSCRIPT's private devmode data

Environment:

	Windows NT printer drivers

Revision History:

	02/28/97 -davidx-
		Created it.

--*/

#include "precomp.h"

#define KERNEL_MODE
#include "lib.h"


#define PSDM_DumpInt(field) \
        dprintf("  %-16s = %d\n", #field, dmpriv.field)

#define PSDM_DumpHex(field) \
        dprintf("  %-16s = 0x%x\n", #field, dmpriv.field)

#define PSDM_DumpRec(field) \
        dprintf("  %-16s = 0x%x L 0x%x\n", \
                #field, \
                (ULONG) psdm + offsetof(PSDRVEXTRA, field), \
                sizeof(dmpriv.field))


VOID
dump_pscript_devmode(
    PPSDRVEXTRA psdm
    )

{
    PSDRVEXTRA  dmpriv;

    dprintf("\nPSCRIPT private devmode data (%x):\n", psdm);
    debugger_copy_memory(&dmpriv, psdm, sizeof(dmpriv));

    if (dmpriv.dwSignature != PSDEVMODE_SIGNATURE)
    {
        dprintf("*** invalid pscript private devmode data: 0x%x\n", dmpriv.dwSignature);
        return;
    }

    PSDM_DumpHex(dwFlags);
    PSDM_DumpRec(wchEPSFile);
    PSDM_DumpRec(coloradj);
    PSDM_DumpInt(wReserved1);
    PSDM_DumpInt(wSize);
    PSDM_DumpHex(fxScrFreq);
    PSDM_DumpHex(fxScrAngle);
    PSDM_DumpInt(iDialect);
    PSDM_DumpInt(iTTDLFmt);
    PSDM_DumpInt(iLayout);
    PSDM_DumpInt(iPSLevel);
    PSDM_DumpInt(wOEMExtra);
    PSDM_DumpInt(wVer);
    PSDM_DumpRec(csdata);
    PSDM_DumpHex(dwChecksum32);
    PSDM_DumpInt(dwOptions);
    PSDM_DumpRec(aOptions);
}


DECLARE_API(psdm)
{
    LONG param;

    if (*args == '\0')
    {
        dprintf("usage: psdm addr\n");
        return;
    }

    sscanf(args, "%lx", &param);
    dump_pscript_devmode((PPSDRVEXTRA) param);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\tools\kdexts\unidm.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    unidm.c

Abstract:

    Dump UNIDRV's private devmode data

Environment:

    Windows NT printer drivers

Revision History:

    03/31/97 -eigos-
        Created it.

--*/

#include "precomp.h"

#define KERNEL_MODE
#include "lib.h"


#define UNIDM_DumpInt(field) \
        dprintf("  %-16s = %d\n", #field, dmpriv.field)

#define UNIDM_DumpHex(field) \
        dprintf("  %-16s = 0x%x\n", #field, dmpriv.field)

#define UNIDM_DumpRec(field) \
        dprintf("  %-16s = 0x%x L 0x%x\n", \
                #field, \
                (ULONG) punidm + offsetof(UNIDRVEXTRA, field), \
                sizeof(dmpriv.field))


VOID
dump_unidrv_devmode(
    PUNIDRVEXTRA punidm
    )

{
    UNIDRVEXTRA  dmpriv;

    dprintf("\nUNIDRV private devmode data (%x):\n", punidm);
    debugger_copy_memory(&dmpriv, punidm, sizeof(dmpriv));

    UNIDM_DumpHex(dwSignature);
    UNIDM_DumpHex(wVer);
    UNIDM_DumpInt(sPadding);
    UNIDM_DumpInt(wSize);
    UNIDM_DumpInt(wOEMExtra);
    UNIDM_DumpInt(dwChecksum32);
    UNIDM_DumpInt(dwFlags);
    UNIDM_DumpInt(bReversePrint);
    UNIDM_DumpInt(iLayout);
    UNIDM_DumpInt(iQuality);
    UNIDM_DumpInt(dwOptions);
    UNIDM_DumpRec(aOptions);
}


DECLARE_API(unidm)
{
    LONG param;

    if (*args == '\0')
    {
        dprintf("usage: unidm addr\n");
        return;
    }

    sscanf(args, "%lx", &param);
    dump_unidrv_devmode((PUNIDRVEXTRA) param);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\tools\kdexts\unidev.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    unidev.c

Abstract:

    Dump UNIDRV's device data structure

Environment:

    Windows NT printer drivers

Revision History:

    03/31/97  -eigos-
        Created it.

--*/

#include "precomp.h"

#define KERNEL_MODE
#include "unidrv2\control\unidrv.h"


#define PDEV_DumpInt(field) \
        dprintf("  %-16s = %d\n", #field, pdev.field)

#define PDEV_DumpHex(field) \
        dprintf("  %-16s = 0x%x\n", #field, pdev.field)

#define PDEV_DumpRec(field) \
        dprintf("  %-16s = 0x%x L 0x%x\n", \
                #field, \
                (ULONG) ppdev + offsetof(PDEV, field), \
                sizeof(pdev.field))


VOID
dump_unidrv_pdev(
    PPDEV    ppdev
    )

{
    PDEV pdev;

    dprintf("\nUNIDRV device data (%x):\n", ppdev);
    debugger_copy_memory(&pdev, ppdev, sizeof(pdev));

    PDEV_DumpInt(ulID);
    PDEV_DumpHex(devobj.hEngine);
    PDEV_DumpHex(devobj.hPrinter);
    PDEV_DumpHex(hUniResDLL);
    PDEV_DumpHex(hbm);
    PDEV_DumpHex(fMode);
    PDEV_DumpHex(fHooks);
    PDEV_DumpHex(WinResData.hModule);
    PDEV_DumpHex(WinResData.fStatus);
    PDEV_DumpHex(WinResData.pwstrDataFile);
    PDEV_DumpHex(bTTY);
    PDEV_DumpInt(dwFreeMem);
    PDEV_DumpHex(bBanding);
    PDEV_DumpInt(iBandDirection);
    PDEV_DumpInt(rcClipRgn.left);
    PDEV_DumpInt(rcClipRgn.right);
    PDEV_DumpInt(rcClipRgn.top);
    PDEV_DumpInt(rcClipRgn.bottom);
    PDEV_DumpHex(pDriverInfo);
    PDEV_DumpHex(pRawData);
    PDEV_DumpHex(pInfoHeader);
    PDEV_DumpHex(pUIInfo);
    PDEV_DumpRec(PrinterData);
    PDEV_DumpHex(pOptionsArray);
    PDEV_DumpInt(sBitsPixel);
    PDEV_DumpHex(pGlobals);
    PDEV_DumpRec(arCmdTable);
    PDEV_DumpInt(sCopies);
    PDEV_DumpHex(dwRop3);
    PDEV_DumpInt(dwNumOfDataBytes);
    PDEV_DumpInt(dwWidthInBytes);
    PDEV_DumpInt(dwHeightInPixels);
    PDEV_DumpInt(dwRectXSize);
    PDEV_DumpInt(dwRectYSize);
    PDEV_DumpInt(dwGrayPercentage);
    PDEV_DumpInt(dwPrintDirection);
    PDEV_DumpInt(dwNextFontID);
    PDEV_DumpInt(dwFontHeight);
    PDEV_DumpInt(dwFontWidth);
    PDEV_DumpInt(dwFontBold);
    PDEV_DumpInt(dwFontItalic);
    PDEV_DumpInt(dwFontUnderline);
    PDEV_DumpInt(dwFontStrikeThru);
    PDEV_DumpInt(dwCurrentFontID);
    PDEV_DumpHex(pOrientation);
    PDEV_DumpRec(pResolution);
    PDEV_DumpHex(pColorMode);
    PDEV_DumpHex(pColorModeEx);
    PDEV_DumpHex(pDuplex);
    PDEV_DumpHex(pPageSize);
    PDEV_DumpHex(pPageSizeEx);
    PDEV_DumpHex(pInputSlot);
    PDEV_DumpHex(pMemOption);
    PDEV_DumpHex(pHalftone);
    PDEV_DumpHex(pPageProtect);
    PDEV_DumpInt(ptGrxRes.x);
    PDEV_DumpInt(ptGrxRes.y);
    PDEV_DumpInt(ptTextRes.x);
    PDEV_DumpInt(ptTextRes.y);
    PDEV_DumpInt(ptGrxScale.x);
    PDEV_DumpInt(ptGrxScale.y);
    PDEV_DumpInt(ptDeviceFac.x);
    PDEV_DumpInt(ptDeviceFac.y);
    PDEV_DumpHex(pdm);
    PDEV_DumpHex(pdmPrivate);
    PDEV_DumpRec(ctl);
    PDEV_DumpRec(pf);
    PDEV_DumpRec(sf);
    PDEV_DumpInt(fYMove);
    PDEV_DumpInt(iSpool);
    PDEV_DumpHex(pbOBuf);
    PDEV_DumpInt(iFonts);
    PDEV_DumpInt(dwLookAhead);
    PDEV_DumpInt(ptDefaultFont.x);
    PDEV_DumpInt(ptDefaultFont.y);
    PDEV_DumpHex(pFontPDev);
    PDEV_DumpHex(pFontProcs);
    PDEV_DumpHex(pFileList);
    PDEV_DumpHex(pRasterPDEV);
    PDEV_DumpHex(pRasterProcs);
    PDEV_DumpHex(pPalData);
    PDEV_DumpHex(pVectorPDEV);
    PDEV_DumpHex(pVectorProcs);
}


DECLARE_API(unidev)
{
    LONG param;

    if (*args == '\0')
    {
        dprintf("usage: unidev addr\n");
        return;
    }

    sscanf(args, "%lx", &param);
    dump_unidrv_pdev((PPDEV) param);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\tools\kdexts\uiinfo.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    uiinfo.c

Abstract:

    Dump UIINFO structure

Environment:

	Windows NT printer drivers

Revision History:

	02/28/97 -davidx-
		Created it.

--*/

#include "precomp.h"

#define KERNEL_MODE
#include "lib.h"


#define UIINFO_DumpInt(field) \
        dprintf("  %-16s = %d\n", #field, uiinfo.field)

#define UIINFO_DumpHex(field) \
        dprintf("  %-16s = 0x%x\n", #field, uiinfo.field)

#define UIINFO_DumpRec(field) \
        dprintf("  %-16s = 0x%x L 0x%x\n", \
                #field, \
                (ULONG) pUIInfo + offsetof(UIINFO, field), \
                sizeof(uiinfo.field))


VOID
dump_uiinfo(
    PUIINFO pUIInfo
    )

{
    UIINFO  uiinfo;

    dprintf("\nUIINFO structure (%x):\n", pUIInfo);
    debugger_copy_memory(&uiinfo, pUIInfo, sizeof(uiinfo));

    UIINFO_DumpInt(dwSize);
    UIINFO_DumpHex(loResourceName);
    UIINFO_DumpHex(loNickName);
    UIINFO_DumpHex(dwSpecVersion);
    UIINFO_DumpInt(dwTechnology);
    UIINFO_DumpInt(dwDocumentFeatures);
    UIINFO_DumpInt(dwPrinterFeatures);
    UIINFO_DumpHex(loFeatureList);
    UIINFO_DumpHex(loFontSubstTable);
    UIINFO_DumpInt(dwFontSubCount);
    UIINFO_DumpRec(UIConstraints);
    UIINFO_DumpRec(UIGroups);
    UIINFO_DumpInt(dwMaxCopies);
    UIINFO_DumpInt(dwMinScale);
    UIINFO_DumpInt(dwMaxScale);
    UIINFO_DumpInt(dwLangEncoding);
    UIINFO_DumpInt(dwLangLevel);
    UIINFO_DumpRec(Password);
    UIINFO_DumpRec(ExitServer);
    UIINFO_DumpHex(dwProtocols);
    UIINFO_DumpInt(dwJobTimeout);
    UIINFO_DumpInt(dwWaitTimeout);
    UIINFO_DumpInt(dwTTRasterizer);
    UIINFO_DumpInt(dwFreeMem);
    UIINFO_DumpInt(dwPrintRate);
    UIINFO_DumpInt(dwPrintRateUnit);
    UIINFO_DumpHex(fxScreenAngle);
    UIINFO_DumpHex(fxScreenFreq);
    UIINFO_DumpHex(dwFlags);
    UIINFO_DumpInt(dwCustomSizeOptIndex);
    UIINFO_DumpHex(loPrinterIcon);
    UIINFO_DumpInt(dwCartridgeSlotCount);
    UIINFO_DumpRec(CartridgeSlot);
    UIINFO_DumpHex(loFontInstallerName);
    UIINFO_DumpHex(loHelpFileName);
    UIINFO_DumpRec(ptMasterUnits);
    UIINFO_DumpRec(aloPredefinedFeatures);
    UIINFO_DumpInt(dwMaxDocKeywordSize);
    UIINFO_DumpInt(dwMaxPrnKeywordSize);
    UIINFO_DumpHex(pubResourceData);
    UIINFO_DumpHex(pInfoHeader);
}


DECLARE_API(uiinfo)
{
    LONG param;

    if (*args == '\0')
    {
        dprintf("usage: uiinfo addr\n");
        return;
    }

    sscanf(args, "%lx", &param);
    dump_uiinfo((PUIINFO) param);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\tools\kdexts\unifont2.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    unifont.c

Abstract:

    Dump UNIDRV font module's device data structure

Environment:

    Windows NT printer drivers

Revision History:

    03/31/97 -eigos-
        Created it.

--*/

#include "precomp.h"

#define KERNEL_MODE
#include "unidrv2\font\font.h"


//
//
// UNIDRV FONTPDEV
//
//

#define UNIFONTPDEV_DumpInt(field) \
        dprintf("  %-16s = %d\n", #field, fontpdev.field)

#define UNIFONTPDEV_DumpHex(field) \
        dprintf("  %-16s = 0x%x\n", #field, fontpdev.field)

#define UNIFONTPDEV_DumpWStr(field) \
        dprintf("  %-16s = %s\n", #field, fontpdev.field)

#define UNIFONTPDEV_DumpRec(field) \
        dprintf("  %-16s = 0x%x L 0x%x\n", \
                #field, \
                (ULONG) pfontpdev + offsetof(FONTPDEV, field), \
                sizeof(fontpdev.field))

FLAGDEF afdPDEVflFlags[] = {
    { "FDV_ROTATE_FONT_ABLE", FDV_ROTATE_FONT_ABLE},
    { "FDV_ALIGN_BASELINE",   FDV_ALIGN_BASELINE},
    { "FDV_TT_FS_ENABLED",    FDV_TT_FS_ENABLED},
    { "FDV_DL_INCREMENTAL",   FDV_DL_INCREMENTAL},
    { "FDV_TRACK_FONT_MEM",   FDV_TRACK_FONT_MEM},
    { "FDV_WHITE_TEXT",       FDV_WHITE_TEXT},
    { "FDV_DLTT",             FDV_DLTT},
    { "FDV_DLTT_ASTT_PREF",   FDV_DLTT_ASTT_PREF},
    { "FDV_DLTT_BITM_PR EF",  FDV_DLTT_BITM_PREF},
    { "FDV_DLTT_OEMCALLBACK", FDV_DLTT_OEMCALLBACK},
    { "FDV_MD_SERIAL",        FDV_MD_SERIAL},
    { "FDV_GRX_ON_TXT_BAND",  FDV_GRX_ON_TXT_BAND},
    { "FDV_GRX_UNDER_TEXT",   FDV_GRX_UNDER_TEXT},
    { "FDV_BKSP_OK",          FDV_BKSP_OK},
    { "FDV_90DEG_ROTATION",   FDV_90DEG_ROTATION},
    { "FDV_ANYDEG_ROTATION",  FDV_ANYDEG_ROTATION},
    { "FDV_SUPPORTS_FGCOLOR", FDV_SUPPORTS_FGCOLOR},
    { "FDV_SUBSTITUTE_TT",    FDV_SUBSTITUTE_TT},
    { "FDV_SINGLE_BYTE",      FDV_SINGLE_BYTE},
    { "FDV_DOUBLE_BYTE",      FDV_DOUBLE_BYTE},
    { 0,                      0}
};

FLAGDEF afdSTROflAccel[] = {
    { "SO_FLAG_DEFAULT_PLACEMENT", SO_FLAG_DEFAULT_PLACEMENT},
    { "SO_HORIZONTAL",             SO_HORIZONTAL},
    { "SO_VERTICAL",               SO_VERTICAL},
    { "SO_REVERSED",               SO_REVERSED},
    { "SO_ZERO_BEARINGS",          SO_ZERO_BEARINGS},
    { "SO_MAXEXT_EQUAL_BM_SIDE",   SO_MAXEXT_EQUAL_BM_SIDE},
    { 0,                           0}
};

FLAGDEF afdFontAttr[] = {
    { "FONTATTR_BOLD",     FONTATTR_BOLD},
    { "FONTATTR_ITALIC",   FONTATTR_ITALIC},
    { "FONTATTR_UNDERLINE",FONTATTR_UNDERLINE},
    { "FONTATTR_STRIKEOUT",FONTATTR_STRIKEOUT},
    { "FONTATTR_SUBSTFONT",FONTATTR_SUBSTFONT},
    { 0,                           0}
};

VOID
dump_unidrv_fontpdev(
    PFONTPDEV    pfontpdev
    )

{
    FONTPDEV fontpdev;
    FLAGDEF *pfd;

    dprintf("\nUNIDRV device data (%x):\n", pfontpdev);
    debugger_copy_memory(&fontpdev, pfontpdev, sizeof(fontpdev));

    if (fontpdev.dwSignature != FONTPDEV_ID)
    {
        dprintf("*** invalid unidrv font device data\n");
        return;
    }

    UNIFONTPDEV_DumpHex(dwSignature);
    UNIFONTPDEV_DumpHex(dwSize);
    UNIFONTPDEV_DumpHex(pPDev);
    UNIFONTPDEV_DumpHex(flFlags);
    for (pfd=afdPDEVflFlags; pfd->psz; pfd ++)
    {
        if ((FLONG)fontpdev.flFlags & pfd->fl)
        {
            dprintf("  = %s\n",pfd->psz);
        }
    }
    UNIFONTPDEV_DumpHex(flText);
    UNIFONTPDEV_DumpInt(dwFontMem);
    UNIFONTPDEV_DumpInt(dwFontMemUsed);
    UNIFONTPDEV_DumpInt(dwSelBits);
    UNIFONTPDEV_DumpInt(ptTextScale.x);
    UNIFONTPDEV_DumpInt(ptTextScale.y);
    UNIFONTPDEV_DumpInt(iUsedSoftFonts);
    UNIFONTPDEV_DumpInt(iNextSFIndex);
    UNIFONTPDEV_DumpInt(iFirstSFIndex);
    UNIFONTPDEV_DumpInt(iLastSFIndex);
    UNIFONTPDEV_DumpInt(iMaxSoftFonts);
    UNIFONTPDEV_DumpInt(iDevResFontsCt);
    UNIFONTPDEV_DumpInt(iSoftFontsCt);
    UNIFONTPDEV_DumpInt(iCurXFont);
    UNIFONTPDEV_DumpInt(iWhiteIndex);
    UNIFONTPDEV_DumpInt(iBlackIndex);
    UNIFONTPDEV_DumpInt(sDefCTT);
    UNIFONTPDEV_DumpInt(dwDefaultFont);
    UNIFONTPDEV_DumpHex(pso);
    UNIFONTPDEV_DumpHex(pPSHeader);
    UNIFONTPDEV_DumpHex(pvWhiteTextFirst);
    UNIFONTPDEV_DumpHex(pvWhiteTextLast);
    UNIFONTPDEV_DumpHex(pTTFile);
    UNIFONTPDEV_DumpHex(ptod);
    UNIFONTPDEV_DumpHex(pFontMap);
    UNIFONTPDEV_DumpHex(pFMDefault);
    UNIFONTPDEV_DumpHex(pvDLMap);
    UNIFONTPDEV_DumpRec(FontList);
    UNIFONTPDEV_DumpRec(FontCartInfo);
    UNIFONTPDEV_DumpRec(ctl);
    UNIFONTPDEV_DumpHex(pTTFontSubReg);
    UNIFONTPDEV_DumpHex(pUFObj);
}


DECLARE_API(fontpdev)
{
    LONG param;

    if (*args == '\0')
    {
        dprintf("usage: fontpdev addr\n");
        return;
    }

    sscanf(args, "%lx", &param);
    dump_unidrv_fontpdev((PFONTPDEV) param);
}

//
//
// UNIDRV FONTMAP
//
//

#define UNIFONTMAP_DumpInt(field) \
        dprintf("  %-16s = %d\n", #field, fontmap.field)

#define UNIFONTMAP_DumpHex(field) \
        dprintf("  %-16s = 0x%x\n", #field, fontmap.field)

#define UNIFONTMAP_DumpWStr(field) \
        dprintf("  %-16s = %s\n", #field, fontmap.field)

#define UNIFONTMAP_DumpRec(field) \
        dprintf("  %-16s = 0x%x L 0x%x\n", \
                #field, \
                (ULONG) pfontpdev + offsetof(FONTMAP, field), \
                sizeof(fontmap.field))

FLAGDEF afdflFlags[] = {
    { "FM_SCALABLE",     FM_SCALABLE},
    { "FM_DEFAULT",      FM_DEFAULT},
    { "FM_EXTCART",      FM_EXTCART},
    { "FM_FREE_GLYDATA", FM_FREE_GLYDATA},
    { "FM_FONTCMD",      FM_FONTCMD},
    { "FM_WIDTHRES",     FM_WIDTHRES},
    { "FM_IFIRES",       FM_IFIRES},
    { "FM_KERNRES",      FM_KERNRES},
    { "FM_IFIVER40",     FM_IFIVER40},
    { "FM_GLYVER40",     FM_GLYVER40},
    { "FM_FINVOC",       FM_FINVOC},
    { "FM_SOFTFONT",     FM_SOFTFONT},
    { "FM_GEN_SFONT",    FM_GEN_SFONT},
    { "FM_SENT",         FM_SENT},
    { "FM_TT_BOUND",     FM_TT_BOUND},
    { "FM_TO_PROP",      FM_TO_PROP},
    { 0,                 0}
};


VOID
dump_unidrv_fontmap(
    PFONTMAP    pfontmap
    )

{
    FONTMAP fontmap;
    FLAGDEF *pfd;

    dprintf("\nUNIDRV fontmap data (%x):\n", pfontmap);
    debugger_copy_memory(&fontmap, pfontmap, sizeof(fontmap));

    if (fontmap.dwSignature != FONTMAP_ID)
    {
        dprintf("*** invalid unidrv fontmap data\n");
        return;
    }

    UNIFONTMAP_DumpHex(dwSignature);
    UNIFONTMAP_DumpHex(dwSize);
    UNIFONTMAP_DumpInt(dwFontType);
    UNIFONTMAP_DumpHex(flFlags);
    for (pfd=afdflFlags; pfd->psz; pfd ++)
    {
        if ((FLONG)fontmap.flFlags & pfd->fl)
        {
            dprintf("  = %s\n",pfd->psz);
        }
    }
    UNIFONTMAP_DumpHex(pIFIMet);
    UNIFONTMAP_DumpHex(wFirstChar);
    UNIFONTMAP_DumpHex(wLastChar);
    UNIFONTMAP_DumpInt(ulDLIndex);
    UNIFONTMAP_DumpInt(wXRes);
    UNIFONTMAP_DumpInt(wYRes);
    UNIFONTMAP_DumpInt(syAdj);
    UNIFONTMAP_DumpHex(pSubFM);
    UNIFONTMAP_DumpHex(pfnGlyphOut);
    UNIFONTMAP_DumpHex(pfnSelectFont);
    UNIFONTMAP_DumpHex(pfnDeSelectFont);
    UNIFONTMAP_DumpHex(pfnDownloadFontHeader);
    UNIFONTMAP_DumpHex(pfnDownloadGlyph);
    UNIFONTMAP_DumpHex(pfnCheckCondition);
    UNIFONTMAP_DumpHex(pfnFreePFM);
}

DECLARE_API(fm)
{
    LONG param;

    if (*args == '\0')
    {
        dprintf("usage: fm addr\n");
        return;
    }

    sscanf(args, "%lx", &param);
    dump_unidrv_fontmap((PFONTMAP) param);
}


//
//
// UNIDRV Device font FONTMAP
//
//

#define UNIFONTMAPDEV_DumpInt(field) \
        dprintf("  %-16s = %d\n", #field, fontmapdev.field)

#define UNIFONTMAPDEV_DumpHex(field) \
        dprintf("  %-16s = 0x%x\n", #field, fontmapdev.field)

#define UNIFONTMAPDEV_DumpWStr(field) \
        dprintf("  %-16s = %s\n", #field, fontmapdev.field)

VOID
dump_unidrv_fontmapdev(
    PFONTMAP_DEV    pfontmapdev
    )

{
    FONTMAP_DEV fontmapdev;

    dprintf("\nUNIDRV device font fontmap data (%x):\n", pfontmapdev);
    debugger_copy_memory(&fontmapdev, pfontmapdev, sizeof(fontmapdev));

    UNIFONTMAPDEV_DumpInt(wDevFontType);
    UNIFONTMAPDEV_DumpInt(dwResID);
    UNIFONTMAPDEV_DumpInt(sCTTid);
    UNIFONTMAPDEV_DumpHex(fCaps);
    UNIFONTMAPDEV_DumpInt(sYAdjust);
    UNIFONTMAPDEV_DumpInt(sYMoved);
    UNIFONTMAPDEV_DumpHex(pETM);
    UNIFONTMAPDEV_DumpInt(ulCodepage);
    UNIFONTMAPDEV_DumpInt(ulCodepageID);
    UNIFONTMAPDEV_DumpHex(pUCTree);
    UNIFONTMAPDEV_DumpHex(pUCKernTree);
    UNIFONTMAPDEV_DumpHex(pvNTGlyph);
    UNIFONTMAPDEV_DumpHex(pvFontRes);
    UNIFONTMAPDEV_DumpHex(pvPredefGTT);
    if (fontmapdev.fCaps & FM_IFIVER40)
    {
        UNIFONTMAPDEV_DumpHex(W.psWidth);
        UNIFONTMAPDEV_DumpHex(cmdFontSel.pCD);
        UNIFONTMAPDEV_DumpHex(cmdFontDesel.pCD);
    }
    else
    {
        UNIFONTMAPDEV_DumpHex(W.pWidthTable);
        UNIFONTMAPDEV_DumpHex(cmdFontSel.FInv);
        UNIFONTMAPDEV_DumpHex(cmdFontDesel.FInv);
    }
}

DECLARE_API(devfm)
{
    LONG param;

    if (*args == '\0')
    {
        dprintf("usage: devfm addr\n");
        return;
    }

    sscanf(args, "%lx", &param);
    dump_unidrv_fontmapdev((PFONTMAP_DEV) param);
}


DECLARE_API(bmpfm)
{
    LONG param;

    if (*args == '\0')
    {
        dprintf("usage: bmpfm addr\n");
        return;
    }

    sscanf(args, "%lx", &param);
}

#define UNITO_DATA_DumpInt(field) \
        dprintf("  %-16s = %d\n", #field, to_data.field)

#define UNITO_DATA_DumpHex(field) \
        dprintf("  %-16s = 0x%x\n", #field, to_data.field)

#define UNITO_DATA_DumpWStr(field) \
        dprintf("  %-16s = %s\n", #field, to_data.field)

#define UNITO_DATA_DumpRec(field) \
        dprintf("  %-16s = 0x%x L 0x%x\n", \
                #field, \
                (ULONG) pfontpdev + offsetof(TO_DATA, field), \
                sizeof(to_data.field))
VOID
dump_unidrv_to_data(
    TO_DATA    *pto_data
    )

{
    TO_DATA to_data;
    FLAGDEF *pfd;

    dprintf("\nUNIDRV device font to_data data (%x):\n", pto_data);
    debugger_copy_memory(&to_data, pto_data, sizeof(to_data));

    UNITO_DATA_DumpHex(pPDev);
    UNITO_DATA_DumpHex(pfm);
    UNITO_DATA_DumpHex(pfo);
    UNITO_DATA_DumpHex(flAccel);
    for (pfd=afdSTROflAccel; pfd->psz; pfd ++)
    {
        if ((FLONG)to_data.flAccel & pfd->fl)
        {
            dprintf("  = %s\n",pfd->psz);
        }
    }
    UNITO_DATA_DumpHex(pgp);
    UNITO_DATA_DumpHex(apdlGlyph);
    UNITO_DATA_DumpHex(phGlyph);
    UNITO_DATA_DumpHex(pwt);
    UNITO_DATA_DumpHex(pvColor);
    UNITO_DATA_DumpInt(cGlyphsToPrint);
    UNITO_DATA_DumpHex(dwCurrGlyph);
    UNITO_DATA_DumpInt(iFace);
    UNITO_DATA_DumpInt(iSubstFace);
    UNITO_DATA_DumpHex(dwAttrFlags);
    UNITO_DATA_DumpHex(flFlags);
    UNITO_DATA_DumpInt(ptlFirstGlyph.x);
    UNITO_DATA_DumpInt(ptlFirstGlyph.y);
}

DECLARE_API(tod)
{
    LONG param;

    if (*args == '\0')
    {
        dprintf("usage: tod addr\n");
        return;
    }

    sscanf(args, "%lx", &param);
    dump_unidrv_to_data((TO_DATA*) param);
}


#define UNIWHITETEXT_DumpInt(field) \
        dprintf("  %-16s = %d\n", #field, whitetext.field)

#define UNIWHITETEXT_DumpHex(field) \
        dprintf("  %-16s = 0x%x\n", #field, whitetext.field)

#define UNIWHITETEXT_DumpWStr(field) \
        dprintf("  %-16s = %s\n", #field, whitetext.field)

#define UNIWHITETEXT_DumpRec(field) \
        dprintf("  %-16s = 0x%x L 0x%x\n", \
                #field, \
                (ULONG) pfontpdev + offsetof(whitetext, field), \
                sizeof(whitetext.field))
VOID
dump_unidrv_whitetext(
    WHITETEXT    *pwhitetext
    )

{
    WHITETEXT whitetext;
    FLAGDEF *pfd;

    dprintf("\nUNIDRV device font whitetext data (%x):\n", pwhitetext);
    debugger_copy_memory(&whitetext, pwhitetext, sizeof(whitetext));

    UNIWHITETEXT_DumpHex(next);
    UNIWHITETEXT_DumpInt(sCount);
    UNIWHITETEXT_DumpHex(pvColor);
    UNIWHITETEXT_DumpInt(iFontId);
    UNIWHITETEXT_DumpHex(dwAttrFlags);
    for (pfd=afdFontAttr; pfd->psz; pfd ++)
    {
        if ((FLONG)whitetext.dwAttrFlags & pfd->fl)
        {
            dprintf("  = %s\n",pfd->psz);
        }
    }
    UNIWHITETEXT_DumpHex(flAccel);
    for (pfd=afdSTROflAccel; pfd->psz; pfd ++)
    {
        if ((FLONG)whitetext.flAccel & pfd->fl)
        {
            dprintf("  = %s\n",pfd->psz);
        }
    }
    UNIWHITETEXT_DumpHex(pgp);
}

DECLARE_API(wt)
{
    LONG param;

    if (*args == '\0')
    {
        dprintf("usage: tod addr\n");
        return;
    }

    sscanf(args, "%lx", &param);
    dump_unidrv_whitetext((WHITETEXT*) param);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\tools\ps\cpsi2tif\tiffcomp.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    tiffcomp.c

Abstract:

    Implement CCITT group 4 compression scheme

Revision History:

	12/30/96 -davidx-
		Created it.

--*/


// converting the bitmap from CPSI to a TIFF file
//  implementation of CCITT group 4 compression algorithm

// TIFF field tag and type constants

#define TIFFTYPE_ASCII              2
#define TIFFTYPE_SHORT              3
#define TIFFTYPE_LONG               4
#define TIFFTYPE_RATIONAL           5

#define TIFFTAG_NEWSUBFILETYPE      254
#define     SUBFILETYPE_PAGE        2
#define TIFFTAG_IMAGEWIDTH          256
#define TIFFTAG_IMAGEHEIGHT         257
#define TIFFTAG_BITSPERSAMPLE       258
#define TIFFTAG_COMPRESSION         259
#define     COMPRESSION_G3FAX       3
#define     COMPRESSION_G4FAX       4
#define TIFFTAG_PHOTOMETRIC         262
#define     PHOTOMETRIC_WHITEIS0    0
#define     PHOTOMETRIC_BLACKIS0    1
#define TIFFTAG_FILLORDER           266
#define     FILLORDER_MSB           1
#define     FILLORDER_LSB           2
#define TIFFTAG_STRIPOFFSETS        273
#define TIFFTAG_SAMPLESPERPIXEL     277
#define TIFFTAG_ROWSPERSTRIP        278
#define TIFFTAG_STRIPBYTECOUNTS     279
#define TIFFTAG_XRESOLUTION         282
#define     TIFFF_RES_X             204
#define TIFFTAG_YRESOLUTION         283
#define     TIFFF_RES_Y             196
#define     TIFFF_RES_Y_DRAFT       98
#define TIFFTAG_G3OPTIONS           292
#define     G3_2D                   1
#define     G3_ALIGNEOL             4
#define TIFFTAG_G4OPTIONS           293
#define TIFFTAG_RESUNIT             296
#define     RESUNIT_INCH            2
#define TIFFTAG_PAGENUMBER          297
#define TIFFTAG_SOFTWARE            305
#define TIFFTAG_CLEANFAXDATA        327

// Data structure for representing our TIFF output file header information

typedef struct {

    INT16   magic1;         // II
    INT16   magic2;         // 42
    INT32   firstIFDOffset; // offset to first IFD

} TIFF_FILEHEADER;

static TIFF_FILEHEADER  tiffFileHeader = { 'II', 42, 0 };

// Data structure for representing a single IFD entry

typedef struct {

    INT16   tag;        // field tag
    INT16   type;       // field type
    INT32   count;      // number of values
    INT32   value;      // value or value offset

} IFDENTRY;

typedef struct {

    IFDENTRY    ifdNewSubFileType;
    IFDENTRY    ifdImageWidth;
    IFDENTRY    ifdImageHeight;
    IFDENTRY    ifdBitsPerSample;
    IFDENTRY    ifdCompression;
    IFDENTRY    ifdPhotometric;
    IFDENTRY    ifdFillOrder;
    IFDENTRY    ifdStripOffsets;
    IFDENTRY    ifdSamplesPerPixel;
    IFDENTRY    ifdRowsPerStrip;
    IFDENTRY    ifdStripByteCounts;
    IFDENTRY    ifdXResolution;
    IFDENTRY    ifdYResolution;
    IFDENTRY    ifdG4Options;
    IFDENTRY    ifdResolutionUnit;
    IFDENTRY    ifdPageNumber;
    IFDENTRY    ifdSoftware;
    IFDENTRY    ifdCleanFaxData;
    INT32       nextIFDOffset;
    INT32       reserved;
    INT32       xresNum;
    INT32       xresDenom;
    INT32       yresNum;
    INT32       yresDenom;
    char        software[32];

} IFD;

#define IFD_COUNT (offsetof(IFD, nextIFDOffset) / sizeof(IFDENTRY))

#define tiffCopyright "Microsoft"

static IFD ifdTemplate = {

    { TIFFTAG_NEWSUBFILETYPE, TIFFTYPE_LONG, 1, SUBFILETYPE_PAGE },
    { TIFFTAG_IMAGEWIDTH, TIFFTYPE_LONG, 1, 0 },
    { TIFFTAG_IMAGEHEIGHT, TIFFTYPE_LONG, 1, 0 },
    { TIFFTAG_BITSPERSAMPLE, TIFFTYPE_SHORT, 1, 1 },
    { TIFFTAG_COMPRESSION, TIFFTYPE_SHORT, 1, COMPRESSION_G4FAX },
    { TIFFTAG_PHOTOMETRIC, TIFFTYPE_SHORT, 1, PHOTOMETRIC_WHITEIS0 },
    { TIFFTAG_FILLORDER, TIFFTYPE_SHORT, 1, FILLORDER_MSB },
    { TIFFTAG_STRIPOFFSETS, TIFFTYPE_LONG, 1, 0 },
    { TIFFTAG_SAMPLESPERPIXEL, TIFFTYPE_SHORT, 1, 1 },
    { TIFFTAG_ROWSPERSTRIP, TIFFTYPE_LONG, 1, 0 },
    { TIFFTAG_STRIPBYTECOUNTS, TIFFTYPE_LONG, 1, 0 },
    { TIFFTAG_XRESOLUTION, TIFFTYPE_RATIONAL, 1, 0 },
    { TIFFTAG_YRESOLUTION, TIFFTYPE_RATIONAL, 1, 0 },
    { TIFFTAG_G4OPTIONS, TIFFTYPE_LONG, 1, 0 },
    { TIFFTAG_RESUNIT, TIFFTYPE_SHORT, 1, RESUNIT_INCH },
    { TIFFTAG_PAGENUMBER, TIFFTYPE_SHORT, 2, 0 },
    { TIFFTAG_SOFTWARE, TIFFTYPE_ASCII, sizeof(tiffCopyright), 0 },
    { TIFFTAG_CLEANFAXDATA, TIFFTYPE_SHORT, 1, 0 },

    0,
    0,
    0,
    1,
    0,
    1,
    tiffCopyright
};

// Find the next pixel on the scanline whose color is opposite of
// the specified color, starting from the specified starting point

#define NextChangingElement(buf, startBit, stopBit, isBlack) \
        ((startBit) + ((isBlack) ? FindBlackRun((buf), (startBit), (stopBit)) : \
                                   FindWhiteRun((buf), (startBit), (stopBit))))

// Check if the specified pixel on the scanline is black or white
//  1 - the specified pixel is black
//  0 - the specified pixel is white

#define GetBit(buf, bit)   (((buf)[(bit) >> 3] >> (((bit) ^ 7) & 7)) & 1)

// Write a single byte of compressed data to the output

#define OutputByte(data) { \
            fputc((data), fout); \
            outputByteCnt++; \
        }

// Output a sequence of compressed bits

#define OutputBits(length, code) { \
            tiffData |= ((UINT32) (code) << (tiffDataBits - (length))); \
            if ((tiffDataBits -= (length)) <= 16) { \
                OutputByte(tiffData >> 24); \
                OutputByte(tiffData >> 16); \
                tiffData <<= 16; \
                tiffDataBits += 16; \
            } \
        }

// Data structure for representing code table entries

typedef struct {

    UINT16  length;     // code length
    UINT16  code;       // code word itself

} CODETABLE;

typedef const CODETABLE *PCODETABLE;

// Code word for end-of-line (EOL)
//  000000000001

#define EOL_CODE        1
#define EOL_LENGTH      12

// Code word for 2D encoding - pass mode
//  0001

#define PASSCODE        1
#define PASSCODE_LENGTH 4

// Code word for 2D encoding - horizontal mode prefix
//  001

#define HORZCODE        1
#define HORZCODE_LENGTH 3

// Code word for 2D encoding - vertical mode

static const CODETABLE VertCodes[] = {

    {  7, 0x02 },       // 0000010         VL3
    {  6, 0x02 },       // 000010          VL2
    {  3, 0x02 },       // 010             VL1
    {  1, 0x01 },       // 1                V0
    {  3, 0x03 },       // 011             VR1
    {  6, 0x03 },       // 000011          VR2
    {  7, 0x03 },       // 0000011         VR3
};

// Code table for white runs

static const CODETABLE WhiteRunCodes[] = {
    
    {  8, 0x35 },       // 00110101          0
    {  6, 0x07 },       // 000111            1
    {  4, 0x07 },       // 0111              2
    {  4, 0x08 },       // 1000              3
    {  4, 0x0b },       // 1011              4
    {  4, 0x0c },       // 1100              5
    {  4, 0x0e },       // 1110              6
    {  4, 0x0f },       // 1111              7
    {  5, 0x13 },       // 10011             8
    {  5, 0x14 },       // 10100             9
    {  5, 0x07 },       // 00111            10
    {  5, 0x08 },       // 01000            11
    {  6, 0x08 },       // 001000           12
    {  6, 0x03 },       // 000011           13
    {  6, 0x34 },       // 110100           14
    {  6, 0x35 },       // 110101           15
    {  6, 0x2a },       // 101010           16
    {  6, 0x2b },       // 101011           17
    {  7, 0x27 },       // 0100111          18
    {  7, 0x0c },       // 0001100          19
    {  7, 0x08 },       // 0001000          20
    {  7, 0x17 },       // 0010111          21
    {  7, 0x03 },       // 0000011          22
    {  7, 0x04 },       // 0000100          23
    {  7, 0x28 },       // 0101000          24
    {  7, 0x2b },       // 0101011          25
    {  7, 0x13 },       // 0010011          26
    {  7, 0x24 },       // 0100100          27
    {  7, 0x18 },       // 0011000          28
    {  8, 0x02 },       // 00000010         29
    {  8, 0x03 },       // 00000011         30
    {  8, 0x1a },       // 00011010         31
    {  8, 0x1b },       // 00011011         32
    {  8, 0x12 },       // 00010010         33
    {  8, 0x13 },       // 00010011         34
    {  8, 0x14 },       // 00010100         35
    {  8, 0x15 },       // 00010101         36
    {  8, 0x16 },       // 00010110         37
    {  8, 0x17 },       // 00010111         38
    {  8, 0x28 },       // 00101000         39
    {  8, 0x29 },       // 00101001         40
    {  8, 0x2a },       // 00101010         41
    {  8, 0x2b },       // 00101011         42
    {  8, 0x2c },       // 00101100         43
    {  8, 0x2d },       // 00101101         44
    {  8, 0x04 },       // 00000100         45
    {  8, 0x05 },       // 00000101         46
    {  8, 0x0a },       // 00001010         47
    {  8, 0x0b },       // 00001011         48
    {  8, 0x52 },       // 01010010         49
    {  8, 0x53 },       // 01010011         50
    {  8, 0x54 },       // 01010100         51
    {  8, 0x55 },       // 01010101         52
    {  8, 0x24 },       // 00100100         53
    {  8, 0x25 },       // 00100101         54
    {  8, 0x58 },       // 01011000         55
    {  8, 0x59 },       // 01011001         56
    {  8, 0x5a },       // 01011010         57
    {  8, 0x5b },       // 01011011         58
    {  8, 0x4a },       // 01001010         59
    {  8, 0x4b },       // 01001011         60
    {  8, 0x32 },       // 00110010         61
    {  8, 0x33 },       // 00110011         62
    {  8, 0x34 },       // 00110100         63
    {  5, 0x1b },       // 11011            64
    {  5, 0x12 },       // 10010           128
    {  6, 0x17 },       // 010111          192
    {  7, 0x37 },       // 0110111         256
    {  8, 0x36 },       // 00110110        320
    {  8, 0x37 },       // 00110111        384
    {  8, 0x64 },       // 01100100        448
    {  8, 0x65 },       // 01100101        512
    {  8, 0x68 },       // 01101000        576
    {  8, 0x67 },       // 01100111        640
    {  9, 0xcc },       // 011001100       704
    {  9, 0xcd },       // 011001101       768
    {  9, 0xd2 },       // 011010010       832
    {  9, 0xd3 },       // 011010011       896
    {  9, 0xd4 },       // 011010100       960
    {  9, 0xd5 },       // 011010101      1024
    {  9, 0xd6 },       // 011010110      1088
    {  9, 0xd7 },       // 011010111      1152
    {  9, 0xd8 },       // 011011000      1216
    {  9, 0xd9 },       // 011011001      1280
    {  9, 0xda },       // 011011010      1344
    {  9, 0xdb },       // 011011011      1408
    {  9, 0x98 },       // 010011000      1472
    {  9, 0x99 },       // 010011001      1536
    {  9, 0x9a },       // 010011010      1600
    {  6, 0x18 },       // 011000         1664
    {  9, 0x9b },       // 010011011      1728
    { 11, 0x08 },       // 00000001000    1792
    { 11, 0x0c },       // 00000001100    1856
    { 11, 0x0d },       // 00000001101    1920
    { 12, 0x12 },       // 000000010010   1984
    { 12, 0x13 },       // 000000010011   2048
    { 12, 0x14 },       // 000000010100   2112
    { 12, 0x15 },       // 000000010101   2176
    { 12, 0x16 },       // 000000010110   2240
    { 12, 0x17 },       // 000000010111   2304
    { 12, 0x1c },       // 000000011100   2368
    { 12, 0x1d },       // 000000011101   2432
    { 12, 0x1e },       // 000000011110   2496
    { 12, 0x1f },       // 000000011111   2560
};

// Code table for black runs

static const CODETABLE BlackRunCodes[] = {
    
    { 10, 0x37 },       // 0000110111        0
    {  3, 0x02 },       // 010               1
    {  2, 0x03 },       // 11                2
    {  2, 0x02 },       // 10                3
    {  3, 0x03 },       // 011               4
    {  4, 0x03 },       // 0011              5
    {  4, 0x02 },       // 0010              6
    {  5, 0x03 },       // 00011             7
    {  6, 0x05 },       // 000101            8
    {  6, 0x04 },       // 000100            9
    {  7, 0x04 },       // 0000100          10
    {  7, 0x05 },       // 0000101          11
    {  7, 0x07 },       // 0000111          12
    {  8, 0x04 },       // 00000100         13
    {  8, 0x07 },       // 00000111         14
    {  9, 0x18 },       // 000011000        15
    { 10, 0x17 },       // 0000010111       16
    { 10, 0x18 },       // 0000011000       17
    { 10, 0x08 },       // 0000001000       18
    { 11, 0x67 },       // 00001100111      19
    { 11, 0x68 },       // 00001101000      20
    { 11, 0x6c },       // 00001101100      21
    { 11, 0x37 },       // 00000110111      22
    { 11, 0x28 },       // 00000101000      23
    { 11, 0x17 },       // 00000010111      24
    { 11, 0x18 },       // 00000011000      25
    { 12, 0xca },       // 000011001010     26
    { 12, 0xcb },       // 000011001011     27
    { 12, 0xcc },       // 000011001100     28
    { 12, 0xcd },       // 000011001101     29
    { 12, 0x68 },       // 000001101000     30
    { 12, 0x69 },       // 000001101001     31
    { 12, 0x6a },       // 000001101010     32
    { 12, 0x6b },       // 000001101011     33
    { 12, 0xd2 },       // 000011010010     34
    { 12, 0xd3 },       // 000011010011     35
    { 12, 0xd4 },       // 000011010100     36
    { 12, 0xd5 },       // 000011010101     37
    { 12, 0xd6 },       // 000011010110     38
    { 12, 0xd7 },       // 000011010111     39
    { 12, 0x6c },       // 000001101100     40
    { 12, 0x6d },       // 000001101101     41
    { 12, 0xda },       // 000011011010     42
    { 12, 0xdb },       // 000011011011     43
    { 12, 0x54 },       // 000001010100     44
    { 12, 0x55 },       // 000001010101     45
    { 12, 0x56 },       // 000001010110     46
    { 12, 0x57 },       // 000001010111     47
    { 12, 0x64 },       // 000001100100     48
    { 12, 0x65 },       // 000001100101     49
    { 12, 0x52 },       // 000001010010     50
    { 12, 0x53 },       // 000001010011     51
    { 12, 0x24 },       // 000000100100     52
    { 12, 0x37 },       // 000000110111     53
    { 12, 0x38 },       // 000000111000     54
    { 12, 0x27 },       // 000000100111     55
    { 12, 0x28 },       // 000000101000     56
    { 12, 0x58 },       // 000001011000     57
    { 12, 0x59 },       // 000001011001     58
    { 12, 0x2b },       // 000000101011     59
    { 12, 0x2c },       // 000000101100     60
    { 12, 0x5a },       // 000001011010     61
    { 12, 0x66 },       // 000001100110     62
    { 12, 0x67 },       // 000001100111     63
    { 10, 0x0f },       // 0000001111       64
    { 12, 0xc8 },       // 000011001000    128
    { 12, 0xc9 },       // 000011001001    192
    { 12, 0x5b },       // 000001011011    256
    { 12, 0x33 },       // 000000110011    320
    { 12, 0x34 },       // 000000110100    384
    { 12, 0x35 },       // 000000110101    448
    { 13, 0x6c },       // 0000001101100   512
    { 13, 0x6d },       // 0000001101101   576
    { 13, 0x4a },       // 0000001001010   640
    { 13, 0x4b },       // 0000001001011   704
    { 13, 0x4c },       // 0000001001100   768
    { 13, 0x4d },       // 0000001001101   832
    { 13, 0x72 },       // 0000001110010   896
    { 13, 0x73 },       // 0000001110011   960
    { 13, 0x74 },       // 0000001110100  1024
    { 13, 0x75 },       // 0000001110101  1088
    { 13, 0x76 },       // 0000001110110  1152
    { 13, 0x77 },       // 0000001110111  1216
    { 13, 0x52 },       // 0000001010010  1280
    { 13, 0x53 },       // 0000001010011  1344
    { 13, 0x54 },       // 0000001010100  1408
    { 13, 0x55 },       // 0000001010101  1472
    { 13, 0x5a },       // 0000001011010  1536
    { 13, 0x5b },       // 0000001011011  1600
    { 13, 0x64 },       // 0000001100100  1664
    { 13, 0x65 },       // 0000001100101  1728
    { 11, 0x08 },       // 00000001000    1792
    { 11, 0x0c },       // 00000001100    1856
    { 11, 0x0d },       // 00000001101    1920
    { 12, 0x12 },       // 000000010010   1984
    { 12, 0x13 },       // 000000010011   2048
    { 12, 0x14 },       // 000000010100   2112
    { 12, 0x15 },       // 000000010101   2176
    { 12, 0x16 },       // 000000010110   2240
    { 12, 0x17 },       // 000000010111   2304
    { 12, 0x1c },       // 000000011100   2368
    { 12, 0x1d },       // 000000011101   2432
    { 12, 0x1e },       // 000000011110   2496
    { 12, 0x1f },       // 000000011111   2560
};


UINT32 tiffData;
int tiffDataBits;


void
OutputRun(
    int         run,
    PCODETABLE  pCodeTable
    )

{
    PCODETABLE  pTableEntry;

    // Use make-up code word for 2560 for any runs of at least 2624 pixels
    // This is currently not necessary for us since our scanlines always
    // have 1728 pixels.

    while (run >= 2624) {

        pTableEntry = pCodeTable + (63 + (2560 >> 6));
        OutputBits(pTableEntry->length, pTableEntry->code);
        run -= 2560;
    }

    // Use appropriate make-up code word if the run is longer than 63 pixels

    if (run >= 64) {

        pTableEntry = pCodeTable + (63 + (run >> 6));
        OutputBits(pTableEntry->length, pTableEntry->code);
        run &= 0x3f;
    }

    // Output terminating code word

    OutputBits(pCodeTable[run].length, pCodeTable[run].code);
}


int
FindWhiteRun(
    UINT8*      buf,
    int         startBit,
    int         stopBit
    )

{
    static const UINT8 WhiteRuns[256] = {

        8, 7, 6, 6, 5, 5, 5, 5, 4, 4, 4, 4, 4, 4, 4, 4,
        3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
        2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
        2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
        1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
        1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
        1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
        1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
    };

    int run, bits, n;

    buf += (startBit >> 3);
    if ((bits = stopBit-startBit) <= 0)
        return 0;

    // Take care of the case where starting bit index is not a multiple of 8

    if (n = (startBit & 7)) {

        run = WhiteRuns[(*buf << n) & 0xff];
        if (run > 8-n)
            run = 8-n;
        if (n+run < 8)
            return run;
        bits -= run;
        buf++;

    } else
        run = 0;

    // Look for consecutive UINT32 value = 0

    if (bits >= 32 * 2) {

        UINT32* pdw;

        // Align to a UINT32 boundary first

        while ((int) buf & 3) {

            if (*buf != 0)
                return run + WhiteRuns[*buf];

            run += 8;
            bits -= 8;
            buf++;
        }

        pdw = (UINT32*) buf;

        while (bits >= 32 && *pdw == 0) {

            pdw++;
            run += 32;
            bits -= 32;
        }

        buf = (UINT8*) pdw;
    }

    // Look for consecutive UINT8 value = 0

    while (bits >= 8) {

        if (*buf != 0)
            return run + WhiteRuns[*buf];

        buf++;
        run += 8;
        bits -= 8;
    }

    // Count the number of white pixels in the last byte

    if (bits > 0)
        run += WhiteRuns[*buf];

    return run;
}


int
FindBlackRun(
    UINT8*      buf,
    int         startBit,
    int         stopBit
    )

{
    static const UINT8 BlackRuns[256] = {

        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
        1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
        1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
        1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
        2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
        2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
        3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
        4, 4, 4, 4, 4, 4, 4, 4, 5, 5, 5, 5, 6, 6, 7, 8
    };

    int run, bits, n;

    buf += (startBit >> 3);
    if ((bits = stopBit-startBit) <= 0)
        return 0;

    // Take care of the case where starting bit index is not a multiple of 8

    if (n = (startBit & 7)) {

        run = BlackRuns[(*buf << n) & 0xff];
        if (run > 8-n)
            run = 8-n;
        if (n+run < 8)
            return run;
        bits -= run;
        buf++;

    } else
        run = 0;

    // Look for consecutive UINT32 value = 0xffffffff

    if (bits >= 32 * 2) {

        UINT32* pdw;

        // Align to a UINT32 boundary first

        while ((int) buf & 3) {

            if (*buf != 0xff)
                return run + BlackRuns[*buf];

            run += 8;
            bits -= 8;
            buf++;
        }

        pdw = (UINT32*) buf;

        while (bits >= 32 && *pdw == 0xffffffff) {

            pdw++;
            run += 32;
            bits -= 32;
        }

        buf = (UINT8*) pdw;
    }

    // Look for consecutive UINT8 value = 0xff

    while (bits >= 8) {

        if (*buf != 0xff)
            return run + BlackRuns[*buf];

        buf++;
        run += 8;
        bits -= 8;
    }

    // Count the number of white pixels in the last byte

    if (bits > 0)
        run += BlackRuns[*buf];

    return run;
}


void
init_tiff_encoder(
    void
    )

{
    tiffData = 0;
    tiffDataBits = 32;
}


void
cleanup_tiff_encoder(
    void
    )

{
    // Output EOB (two EOLs) after the last scanline

    OutputBits(EOL_LENGTH, EOL_CODE);
    OutputBits(EOL_LENGTH, EOL_CODE);

    while (tiffDataBits < 32)
    {
        tiffDataBits += 8;
        OutputByte(tiffData >> 24);
        tiffData <<= 8;
    }

    tiffData = 0;
    tiffDataBits = 32;
}

void
compress_tiff_line(
    UINT8*  cur_line,
    UINT8*  ref_line,
    int     lineWidth
    )

{
    int a0, a1, a2, b1, b2, distance;

    // Use 2-dimensional encoding scheme

    a0 = 0;
    a1 = GetBit(cur_line, 0) ? 0 : NextChangingElement(cur_line, 0, lineWidth, 0);
    b1 = GetBit(ref_line, 0) ? 0 : NextChangingElement(ref_line, 0, lineWidth, 0);

    while (1) {

        b2 = (b1 >= lineWidth) ?
                lineWidth :
                NextChangingElement(ref_line, b1, lineWidth, GetBit(ref_line, b1));

        if (b2 < a1) {

            // Pass mode

            OutputBits(PASSCODE_LENGTH, PASSCODE);
            a0 = b2;

        } else if ((distance = a1 - b1) <= 3 && distance >= -3) {

            // Vertical mode

            OutputBits(VertCodes[distance+3].length, VertCodes[distance+3].code);
            a0 = a1;

        } else {

            // Horizontal mode

            a2 = (a1 >= lineWidth) ?
                    lineWidth :
                    NextChangingElement(cur_line, a1, lineWidth, GetBit(cur_line, a1));

            OutputBits(HORZCODE_LENGTH, HORZCODE);

            if (a1 != 0 && GetBit(cur_line, a0)) {

                OutputRun(a1-a0, BlackRunCodes);
                OutputRun(a2-a1, WhiteRunCodes);

            } else {

                OutputRun(a1-a0, WhiteRunCodes);
                OutputRun(a2-a1, BlackRunCodes);
            }

            a0 = a2;
        }

        if (a0 >= lineWidth)
            break;

        a1 = NextChangingElement(cur_line, a0, lineWidth, GetBit(cur_line, a0));
        b1 = NextChangingElement(ref_line, a0, lineWidth, !GetBit(cur_line, a0));
        b1 = NextChangingElement(ref_line, b1, lineWidth, GetBit(cur_line, a0));
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\tools\ps\makentf\afm2ntm.c ===
/*++

Copyright (c) 1996 Adobe Systems Incorporated
Copyright (c) 1996  Microsoft Corporation

Module Name:

    afm2ntm.c

Abstract:

    Convert AFM to NTM.

Environment:

    Windows NT PostScript driver: makentf utility.

Revision History:

    09/11/97 -ksuzuki-
        Added code to support localized menu name, fixed pitch CJK font, and
        two IFIMETRICS.

    12/11/96 -rkiesler-
        Wrote functions.

    09/16/96 -slam-
        Created initial framework.

--*/


#include "lib.h"
#include "ppd.h"
#include "pslib.h"
#include "psglyph.h"
#include "afm2ntm.h"
#include "cjkfonts.h"
#include "winfont.h"


//
// Extarnals
//
extern pAFMFileName;
extern bVerbose;
extern bOptimize;

VOID
SortWinCPT(
    IN OUT  WINCPT      *pSortedWinCpts,
    IN      WINCPTOPS   *pCPtoPS
);

//
// Globals.
//
#define NUM_DPCHARSET 16

PUPSCODEPT  pPsNames;
BOOL        isSymbolCharSet=FALSE;

//
// The purpose of the NTMSIZEINFO and IFIMETRICSSIZEINFO structures is
// to hold aligned size of each structure element.
//
typedef struct _NTMSIZEINFO
{
    int nSize;
    int nFontNameSize;
    int nDisplayNameSize;
    int nGlyphSetNameSize;
    int nCharWidthSize;
    int nKernPairSize;
    int nCharDefSize;
    int nTotalSize;
}
NTMSIZEINFO;

typedef struct _IFIMETRICSSIZEINFO
{
    int nSize;
    int nIfiExtraSize;
    int nFamilyNameSize;
    int nStyleNameSize;
    int nFaceNameSize;
    int nUniqueNameSize;
    int nFontSimSize;
    int nBoldSize;
    int nItalicSize;
    int nBoldItalicSize;
    int nCharSetSize;
    int nTotalSize;
}
IFIMETRICSSIZEINFO;

#define INIT_NTMSIZEINFO(nsi) \
{\
    (nsi).nSize = -1;\
    (nsi).nFontNameSize = -1;\
    (nsi).nDisplayNameSize = -1;\
    (nsi).nGlyphSetNameSize = -1;\
    (nsi).nCharWidthSize = -1;\
    (nsi).nKernPairSize = -1;\
    (nsi).nCharDefSize = -1;\
    (nsi).nTotalSize = -1;\
};

#define INIT_IFIMETRICSSIZEINFO(isi) \
{\
    (isi).nSize = -1;\
    (isi).nIfiExtraSize = -1;\
    (isi).nFamilyNameSize = -1;\
    (isi).nStyleNameSize = -1;\
    (isi).nFaceNameSize = -1;\
    (isi).nUniqueNameSize = -1;\
    (isi).nFontSimSize = -1;\
    (isi).nBoldSize = -1;\
    (isi).nItalicSize = -1;\
    (isi).nBoldItalicSize = -1;\
    (isi).nCharSetSize = -1;\
    (isi).nTotalSize = -1;\
};

#define GET_NTMTOTALSIZE(nsi) \
{\
    if ((nsi).nSize == -1 \
        || (nsi).nFontNameSize == -1 \
        || (nsi).nDisplayNameSize == -1 \
        || (nsi).nGlyphSetNameSize == -1 \
        || (nsi).nCharWidthSize == -1 \
        || (nsi).nKernPairSize == -1 \
        || (nsi).nCharDefSize == -1)\
    {\
        ERR(("makentf - afm2ntm: GET_NTMTOTALSIZE\n"));\
    }\
    (nsi).nTotalSize = (nsi).nSize \
                        + (nsi).nFontNameSize \
                        + (nsi).nDisplayNameSize \
                        + (nsi).nGlyphSetNameSize \
                        + (nsi).nCharWidthSize \
                        + (nsi).nKernPairSize \
                        + (nsi).nCharDefSize;\
};

#define GET_IFIMETRICSTOTALSIZE(isi) \
{\
    if ((isi).nSize == -1 \
        || (isi).nIfiExtraSize == -1 \
        || (isi).nFamilyNameSize == -1 \
        || (isi).nStyleNameSize == -1 \
        || (isi).nFaceNameSize == -1 \
        || (isi).nUniqueNameSize == -1 \
        || (isi).nFontSimSize == -1 \
        || (isi).nBoldSize == -1 \
        || (isi).nItalicSize == -1 \
        || (isi).nBoldItalicSize == -1 \
        || (isi).nCharSetSize == -1)\
    {\
        ERR(("makentf - afm2ntm: GET_IFIMETRICSTOTALSIZE\n"));\
    }\
    (isi).nTotalSize = (isi).nSize \
                        + (isi).nIfiExtraSize \
                        + (isi).nFamilyNameSize \
                        + (isi).nStyleNameSize \
                        + (isi).nFaceNameSize \
                        + (isi).nUniqueNameSize \
                        + (isi).nFontSimSize \
                        + (isi).nBoldSize \
                        + (isi).nItalicSize \
                        + (isi).nBoldItalicSize \
                        + (isi).nCharSetSize;\
};

#define FREE_AFMTONTM_MEMORY \
{\
    if (pNameStr2 != pNameStr) MemFree(pNameStr2);\
    MemFree(pNameStr);\
    MemFree(pFontChars);\
    MemFree(pCharDefTbl);\
};


PNTM
AFMToNTM(
    PBYTE           pAFM,
    PGLYPHSETDATA   pGlyphSetData,
    PULONG          pUniPs,
    CHSETSUPPORT    *pCharSet,
    BOOL            bIsCJKFont,
    BOOL            bIsPitchChanged
    )

/*++

Routine Description:

    Convert AFM to NTM.

Arguments:

    pAFM - pointer to memory mapped AFM file.

    pGlyphSetData - pointer to the GLYPHSETDATA struct which represents
    this font's preferred charset.

    pUniPs - Points to a table which maps 0-based Glyph Indices of chars
    in the GLYPHRUNS of the GLYPHSETDATA struct for this font to indices
    into the UnicodetoPs structure which maps Unicode points to PS char
    information. This mapping array is created by the CreateGlyphSets
    function defined in this module.

Return Value:

    NULL => error
    otherwise => ptr to a NTM.

--*/

{
    USHORT          multiCharSet=0;
    IFIEXTRA        *pifiEx;
    PBYTE           pChMetrics, pToken, pChWidthTok, pCharDefTbl, pby;
    CHSETSUPPORT    chSets;
    PSZ             pszGlyphSetName, pszFontName, pszFamilyName, pszEngFamilyName;
    int             cGlyphSetNameLen, cFontNameLen, cFamilyNameLen, cEngFamilyNameLen;
    int             cNameStrLen, wcNameStrLen, cNameStr2Len, wcNameStr2Len, chCnt;
    PNTM            pNTM;
    PIFIMETRICS     pifi, pifi2;
    PWIDTHRUN       pWidthRuns;
    SHORT           sIntLeading, sAscent, sExternalLeading;
    ULONG           ulNTMSize, ulIFISize, ulIFISize2;
    ULONG           ulChCnt, ulCharDefTbl, ulKernPairs, ulAliases;
    ETMINFO         EtmInfo;
    PPSFAMILYINFO   pFamilyInfo;
    RECT            rcBBox;
    LPPANOSE        ppanose;
    PGLYPHRUN       pGlyphRun;
    PSTR            pNameStr, pNameStr2;
    FD_KERNINGPAIR  *pKernPairs;
    PPSCHARMETRICS  pFontChars;
    BOOLEAN         bIsVGlyphSet, bIsMSFaceName, bIsFixedPitch, bIsItalic, bIsBold;
    USHORT          jWinCharSet;
    CHARSETINFO     csi;
    char            szStyleName[64], szUniqueID[32];
    int             i, j;
    BOOL            bRightFamilyInfo = TRUE;

    NTMSIZEINFO         nsi;
    IFIMETRICSSIZEINFO  isi;

    VERBOSE(("Entering AFMToNTM...\n"));

    INIT_NTMSIZEINFO(nsi);
    INIT_IFIMETRICSSIZEINFO(isi);

    pNTM = NULL;
    pFontChars = NULL;
    pCharDefTbl = NULL;
    pNameStr = pNameStr2 = NULL;
    szStyleName[0] = szUniqueID[0] = '\0';

    if (bVerbose) printf("AFM file name:%s\n", pAFMFileName);


    //////////////////////////////////////////////////////////////////////////
    //
    // We support two kinds of CJK AFM files: Adobe CID font AFM or
    // clone PS font AFM. Adobe CID font AFM always has the following
    // key-value pairs.
    //
    //      FontName Ryumin-Light
    //      CharacterSet Adobe-Japan1-1 (or others except 'Adobe-Japan1-0')
    //      IsCIDFont true (must be there)
    //
    // Note that the FontName value does not include encoding name.
    // Just font family name only.
    //
    // Clone PS font AFM has the following special key-value pairs.
    //
    //      FontName RicohKaisho
    //      CharacterSet Adobe-Japan1-0
    //      IsCIDFont false (or must not be there)
    //
    // The FontName value of clone PS font AFM shouldn't include encoding
    // name neither, the CharacterSet value is 'Adobe-Japan1-0' for J, and
    // IsCIDFont key should not be specified or must be 'false'.
    //
    //////////////////////////////////////////////////////////////////////////

    //
    // Find which glyphset we are dealing with.
    //
    bIsVGlyphSet = IsVGlyphSet(pGlyphSetData);

    pszGlyphSetName = (PSTR)MK_PTR(pGlyphSetData, dwGlyphSetNameOffset);

    cGlyphSetNameLen = strlen(pszGlyphSetName);

    if (bOptimize)
    {
        //
        // Set referense mark if optimization option is specified. This mark is
        // checked later by the WriteNTF function to exclude unreferenced
        // glyphset data when writing to an NTF file.
        //
        pGlyphSetData->dwReserved[0] = 1;
    }


    //
    // Save number of chars defined in the font.
    // Get ptr to AFM char metrics, then the current
    // pos should be the character count field.
    //
    pToken = FindAFMToken(pAFM, PS_CH_METRICS_TOK);
    if (pToken == NULL)    // Fixed bug 354007
    {
        ERR(("makentf - afm2ntm: CH Metrics missing\n"));
        return NULL;
    }

    for (i = 0; i < (int) StrLen(pToken); i++)
    {
        if (!IS_NUM(&pToken[i]))
        {
            ERR(("makentf - afm2ntm: CH Metrics is not a number\n"));
            return NULL;
        }
    }

    chCnt = atoi(pToken);

    //
    // Get number of GLYPHs from GlyphsetData. We'll need to use define
    // char width table entries and char defined entries for all
    // possible glyphs in the glyphset, even those that are not defined
    // in this particular font.
    //
    ulChCnt = pGlyphSetData->dwGlyphCount;

    //
    // Alloc memory for an array of PSCHARMETRICS structs, one for each char
    // in the font, and build the table of char metrics.
    //
    if ((pFontChars =
        (PPSCHARMETRICS)
        MemAllocZ((size_t) chCnt * sizeof(PSCHARMETRICS))) == NULL)
    {
        ERR(("makentf - afm2ntm: malloc\n"));
        return NULL;
    }

    //
    // Alloc memory for the IsCharDefined table, an array of bits which
    // indicate which chars in the GLYPHSET are defined in this font.
    //
    ulCharDefTbl = ((ulChCnt + 7) / 8) * sizeof (BYTE);

    if ((pCharDefTbl = (PBYTE)MemAllocZ((size_t)ulCharDefTbl)) == NULL)
    {
        ERR(("makentf - afm2ntm: malloc\n"));
        MemFree(pFontChars);
        return NULL;
    }

    //
    // Build table of PSCHARMETRICS info.
    //
    if (!BuildPSCharMetrics(pAFM, pUniPs, pFontChars, pCharDefTbl, ulChCnt))
    {
        ERR(("makentf - afm2ntm: BuildPSCharMetrics\n"));
        MemFree(pFontChars);
        MemFree(pCharDefTbl);
        return NULL;
    }

    //
    // Get font name from AFM and use it to obtain the MS family name
    // from the table in memory.
    //
    pszEngFamilyName = NULL;
    cEngFamilyNameLen = 0;

    pFamilyInfo = NULL;
    pszFontName = FindAFMToken(pAFM, PS_FONT_NAME_TOK);
    if (pszFontName == NULL)   // Fixed bug 354007
    {
        ERR(("makentf - afm2ntm: Font Name Missing\n"));
        FREE_AFMTONTM_MEMORY;
        return NULL;
    }

    for (cFontNameLen = 0; !EOL(&pszFontName[cFontNameLen]); cFontNameLen++);

    pFamilyInfo = (PPSFAMILYINFO) bsearch(pszFontName,
                                    (PBYTE) (((PPSFAMILYINFO) (pFamilyTbl->pTbl))[0].pFontName),
                                    pFamilyTbl->usNumEntries,
                                    sizeof(PSFAMILYINFO),
                                    StrCmp);

    if (bIsMSFaceName = (pFamilyInfo != NULL))
    {
        bRightFamilyInfo = TRUE;
        if (bIsPitchChanged && (pFamilyInfo->usPitch == DEFAULT_PITCH))
        {
            bRightFamilyInfo = FALSE;
            if (pFamilyInfo > ((PPSFAMILYINFO) (pFamilyTbl->pTbl)))
            {
                pFamilyInfo = pFamilyInfo - 1;
                if (!StrCmp(pFamilyInfo->pFontName, pszFontName) &&
                    (pFamilyInfo->usPitch != DEFAULT_PITCH ))
                    bRightFamilyInfo = TRUE;
            }
            if (bRightFamilyInfo == FALSE)
            {
                pFamilyInfo = pFamilyInfo + 1;
                if (pFamilyInfo <
                    (((PPSFAMILYINFO) (pFamilyTbl->pTbl)) + pFamilyTbl->usNumEntries))
                {
                    pFamilyInfo = pFamilyInfo + 1;
                    if (!StrCmp(pFamilyInfo->pFontName, pszFontName) &&
                        (pFamilyInfo->usPitch != DEFAULT_PITCH))
                        bRightFamilyInfo = TRUE;
                }
            }
        }
        else if (!bIsPitchChanged && (pFamilyInfo->usPitch != DEFAULT_PITCH))
        {
            bRightFamilyInfo = FALSE;
            if (pFamilyInfo > ((PPSFAMILYINFO) (pFamilyTbl->pTbl)))
            {
                pFamilyInfo = pFamilyInfo - 1;
                if (!StrCmp(pFamilyInfo->pFontName, pszFontName) &&
                    (pFamilyInfo->usPitch == DEFAULT_PITCH))
                    bRightFamilyInfo = TRUE;
            }
            if (bRightFamilyInfo == FALSE)
            {
                pFamilyInfo = pFamilyInfo + 1;
                if (pFamilyInfo <
                    (((PPSFAMILYINFO) (pFamilyTbl->pTbl)) + pFamilyTbl->usNumEntries))
                {
                    pFamilyInfo = pFamilyInfo + 1;
                    if (!StrCmp(pFamilyInfo->pFontName, pszFontName) &&
                        (pFamilyInfo->usPitch == DEFAULT_PITCH))
                        bRightFamilyInfo = TRUE;
                }
            }
        }

    }
    if (bIsMSFaceName && (bRightFamilyInfo == TRUE))
    {
        pszFamilyName = pFamilyInfo->FamilyKey.pName;
        cFamilyNameLen = strlen(pszFamilyName);

        pszEngFamilyName = pFamilyInfo->pEngFamilyName;
        cEngFamilyNameLen = strlen(pszEngFamilyName);

        if (!cEngFamilyNameLen) pszEngFamilyName = NULL;
    }
    else if ((pszFamilyName =
            FindAFMToken(pAFM, PS_FONT_FAMILY_NAME_TOK)) != NULL)
    {
        for (cFamilyNameLen = 0; !EOL(&pszFamilyName[cFamilyNameLen]); cFamilyNameLen++);
    }
    else
    {
        pszFamilyName = pszFontName;
        cFamilyNameLen = cFontNameLen;
    }

    if (bVerbose)
    {
        printf("MSFaceName%sfound:", bIsMSFaceName ? " " : " not ");
        printf("%s\n", bIsMSFaceName ? pszFamilyName : "n/a");
        printf("MSFaceName length:%d\n", bIsMSFaceName ? cFamilyNameLen : -1);
        printf("This is a %s font.\n", bIsVGlyphSet ? "vertical" : "horizontal");
    }

    //
    // Predetermine if this font supports multiple charsets.
    //
    if (pCharSet)
    {
        if (CSET_SUPPORT(*pCharSet, CS_ANSI))
            multiCharSet++;
        if (CSET_SUPPORT(*pCharSet, CS_EASTEUROPE))
            multiCharSet++;
        if (CSET_SUPPORT(*pCharSet, CS_RUSSIAN))
            multiCharSet++;
        if (CSET_SUPPORT(*pCharSet, CS_GREEK))
            multiCharSet++;
        if (CSET_SUPPORT(*pCharSet, CS_TURKISH))
            multiCharSet++;
        if (CSET_SUPPORT(*pCharSet, CS_HEBREW))
            multiCharSet++;
        if (CSET_SUPPORT(*pCharSet, CS_ARABIC))
            multiCharSet++;
        if (CSET_SUPPORT(*pCharSet, CS_BALTIC))
            multiCharSet++;
        if (CSET_SUPPORT(*pCharSet, CS_SYMBOL))
            multiCharSet++;

        //
        // Save Windows Codepage id. Just use the id stored in the first
        // CODEPAGEINFO in the GLYPHSETDATA for this font.
        //
        // The order of this check is important since jWinCharSet
        // should match the first dpCharSets array if it exists.
        //
        if (CSET_SUPPORT(*pCharSet, CS_ANSI))
            jWinCharSet = ANSI_CHARSET;
        else if (CSET_SUPPORT(*pCharSet, CS_EASTEUROPE))
            jWinCharSet = EASTEUROPE_CHARSET;
        else if (CSET_SUPPORT(*pCharSet, CS_RUSSIAN))
            jWinCharSet = RUSSIAN_CHARSET;
        else if (CSET_SUPPORT(*pCharSet, CS_GREEK))
            jWinCharSet = GREEK_CHARSET;
        else if (CSET_SUPPORT(*pCharSet, CS_TURKISH))
            jWinCharSet = TURKISH_CHARSET;
        else if (CSET_SUPPORT(*pCharSet, CS_HEBREW))
            jWinCharSet = HEBREW_CHARSET;
        else if (CSET_SUPPORT(*pCharSet, CS_ARABIC))
            jWinCharSet = ARABIC_CHARSET;
        else if (CSET_SUPPORT(*pCharSet, CS_BALTIC))
            jWinCharSet = BALTIC_CHARSET;
        else if (CSET_SUPPORT(*pCharSet, CS_SYMBOL))
            jWinCharSet = SYMBOL_CHARSET;
    }
    else
    {
        PCODEPAGEINFO cpi = (PCODEPAGEINFO)MK_PTR(pGlyphSetData, dwCodePageOffset);
        jWinCharSet = (USHORT)(cpi->dwWinCharset & 0xffff);
    }

    //
    // Get codepage info for the MultiByteToWideChar function calls.
    //
    // We want to translate a string into a readable one, not into a symbolic
    // one, so that we use ANSI charset when dealing with SYMBOL charset.
    //
    if (jWinCharSet == SYMBOL_CHARSET)
    {
        DWORD dwTmp = ANSI_CHARSET;
        if (!TranslateCharsetInfo(&dwTmp, &csi, TCI_SRCCHARSET))
            csi.ciACP = CP_ACP;
    }
    else if (!TranslateCharsetInfo((DWORD FAR*)jWinCharSet, &csi, TCI_SRCCHARSET))
        csi.ciACP = CP_ACP;


    //////////////////////////////////////////////////////////////////////////
    //
    // Get the size of each element of NTM structure
    //
    //////////////////////////////////////////////////////////////////////////

    //
    // Sizes known so far.
    //
    nsi.nSize = ALIGN4(sizeof (NTM));
    nsi.nGlyphSetNameSize = ALIGN4(cGlyphSetNameLen + 1);
    nsi.nCharDefSize = ALIGN4(ulCharDefTbl);

    //
    // Size of the font name. Glyphset name is required for CJK font.
    //
    nsi.nFontNameSize = ALIGN4(cFontNameLen + 1);

    if (bIsCJKFont)
    {
        nsi.nFontNameSize += nsi.nGlyphSetNameSize;
    }

    //
    // Size of the display name. Use pszFamilyName regardless of
    // Roman, C, J, and K fonts. Add one for '@' if it's CJK
    // vertical font.
    //
    i = cFamilyNameLen + 1;
    if (bIsCJKFont && bIsVGlyphSet) i++;
    nsi.nDisplayNameSize = ALIGN4(i);

    //
    // Determine if font is fixed pitch.
    //
    bIsFixedPitch = FALSE;

    if (bIsCJKFont)
    {
        bIsFixedPitch = IsCJKFixedPitchEncoding(pGlyphSetData);
    }
    else if ((pToken = FindAFMToken(pAFM, PS_PITCH_TOK)) != NULL)
    {
        if (!StrCmp(pToken, "true"))
        {
            //
            // This is a fixed pitch font.
            //
            bIsFixedPitch = !StrCmp(pToken, "true");

        }
    }

    if (bIsFixedPitch)
    {
        nsi.nCharWidthSize = 0;
    }
    else
    {
        //
        // Proportional font. Determine number of WIDTHRUNs for this font.
        //
        // Fix bug 240339, jjia, 8/3/98
        nsi.nCharWidthSize =
                GetAFMCharWidths(pAFM, NULL, pFontChars, pUniPs,
                pGlyphSetData->dwGlyphCount, NULL, NULL);
    }

    //
    // Determine if there is the pair kerning info for this font.
    //
    if (ulKernPairs = GetAFMKernPairs(pAFM, NULL, pGlyphSetData))
    {
        //
        // Account for size of kern pairs.
        //
        nsi.nKernPairSize = ALIGN4((ulKernPairs + 1) * sizeof(FD_KERNINGPAIR));
    }
    else
    {
        nsi.nKernPairSize = 0;
    }


    //////////////////////////////////////////////////////////////////////////
    //
    // Get the size of each element of IFIMETRICS structure
    //
    //////////////////////////////////////////////////////////////////////////

    isi.nSize = ALIGN4(sizeof (IFIMETRICS));
    //
    // From AdobePS5-NT4 5.1, make the size of NT4 IFIEXTRA same as the one
    // of NT5 or later versions. NT4 IFIEXTRA size is 16 and NT5 IFIEXTRA
    // size is 24.
    //
    if (sizeof (IFIEXTRA) <= 16)
        isi.nIfiExtraSize = 24;
    else
        isi.nIfiExtraSize = ALIGN4(sizeof (IFIEXTRA));

    //
    // For Roman we provide single IFIMETRICS, but we provide two IFIMETRICS
    // for CJK. Font family name element of the first IFIMETRICS begins with
    // a menu name in English then localized one. Font family name element of
    // the second IFIMETRICS begins with a localized menu name then English
    // one. We use pNameStr and pNameStr2 for the English and localized menu
    // names respectively.
    //
    // Prepare pNameStr. Account for encoding name if we are dealing with
    // CJK font.
    //
    i = 0;
    if (bIsCJKFont)
    {
        if (bIsVGlyphSet)
        {
            //
            // V GS, account for preceding '@' char.
            //
            i++;
        }

        if (pszEngFamilyName)
        {
            //
            // IFIMetrics English menu name = [@]fontname
            //
            if ((pNameStr = (PSTR) MemAllocZ(i + cEngFamilyNameLen + 1)) == NULL)
            {
                ERR(("makentf - afm2ntm: malloc\n"));
                FREE_AFMTONTM_MEMORY;
                return NULL;
            }

            if (i) pNameStr[0] = '@';
            memcpy(&(pNameStr[i]), pszEngFamilyName, cEngFamilyNameLen);
            i += cEngFamilyNameLen;
        }
        else
        {
            int cGsNameLen;

            //
            // IFIMetrics English menu name = [@]fontname + GS name string,
            // but it does not end with '-H' or '-V'.
            //
            cGsNameLen = cGlyphSetNameLen - 2;

            if ((pNameStr = (PSTR) MemAllocZ(i + cFontNameLen + cGsNameLen + 1)) == NULL)
            {
                ERR(("makentf - afm2ntm: malloc\n"));
                FREE_AFMTONTM_MEMORY;
                return NULL;
            }

            if (i) pNameStr[0] = '@';
            memcpy(&(pNameStr[i]), pszFontName, cFontNameLen);
            memcpy(&(pNameStr[i + cFontNameLen]), pszGlyphSetName, cGsNameLen);

            i += cFontNameLen + cGsNameLen;
        }
    }
    else
    {
        if ((pNameStr = (PSTR) MemAllocZ(cFamilyNameLen + 1)) == NULL)
        {
            ERR(("makentf - afm2ntm: malloc\n"));
            FREE_AFMTONTM_MEMORY;
            return NULL;
        }
        memcpy(pNameStr, pszFamilyName, cFamilyNameLen);
        i += cFamilyNameLen;
    }
    pNameStr[i] = '\0';

    cNameStrLen = strlen(pNameStr);
    wcNameStrLen = MultiByteToWideChar(csi.ciACP, 0,
                                        pNameStr, cNameStrLen, 0, 0);
    if (!wcNameStrLen)
    {
        ERR(("makentf - afm2ntm: MultiByteToWideChar\n"));
        FREE_AFMTONTM_MEMORY;
        return NULL;
    }

    //
    // Prepair pNameStr2. This if for CJK font only. If MS face name
    // is not available, use same name as pNameStr.
    //
    pNameStr2 = NULL;
    cNameStr2Len = wcNameStr2Len = 0;
    if (bIsCJKFont)
    {
        if (bIsMSFaceName)
        {
            //
            // If we are dealing with V encoding, its MS menu name can not be
            // found in psfamily.dat so that add '@' to make it a V menu name.
            //
            i = bIsVGlyphSet ? 1 : 0;

            if ((pNameStr2 = (PSTR)MemAllocZ(i + cFamilyNameLen + 1)) == NULL)
            {
                ERR(("makentf - afm2ntm: malloc\n"));
                FREE_AFMTONTM_MEMORY;
                return NULL;
            }

            if (i) pNameStr2[0] = '@';
            memcpy(&(pNameStr2[i]), pszFamilyName, cFamilyNameLen);
            pNameStr2[i + cFamilyNameLen] = '\0';
        }
        else
        {
            pNameStr2 = pNameStr;
        }

        cNameStr2Len = strlen(pNameStr2);
        wcNameStr2Len = MultiByteToWideChar(csi.ciACP, 0,
                                            pNameStr2, cNameStr2Len, 0, 0);
        if (!wcNameStr2Len)
        {
            ERR(("makentf - afm2ntm: MultiByteToWideChar\n"));
            FREE_AFMTONTM_MEMORY;
            return NULL;
        }
    }


    if (bVerbose)
    {
        printf("Font menu name in English:%s\n", pNameStr);
        printf("Localized Font menu name%savailable:", pNameStr2 ? " " : " not ");
        printf("%s\n", pNameStr2 ? pNameStr2 : "n/a");
    }

    //
    // WIN31 COMPATABILITY!  Check to see if this face name has aliases.
    // if it does, then we need to set the FM_INFO_FAMILY_EQUIV bit of
    // pTmpIFI->flInfo, and fill in an array of family aliases. Note that
    // the cjGetFamilyAliases function gives us the number in Unicode size.
    //
    isi.nFamilyNameSize = ALIGN4(cjGetFamilyAliases(NULL, pNameStr, 0));

    if (pNameStr2)
    {
        //
        // We add one more face name. Thus, set FM_INFO_FAMILY_EQUIV bit
        // (later) and add two, instead of one, for the two-null terminators.
        //
        isi.nFamilyNameSize += ALIGN4((wcNameStr2Len + 2) * sizeof (WCHAR));
    }

    //
    // Account for size of Adobe PS font name. This is zero because it
    // shares the face name for Win3.1 compatibility.
    //
    isi.nFaceNameSize = 0;

    //
    // Account for the sizes of the style and unique names in Unicode string.
    //
    // Style name: conbine Weight and ' Italic' if non-zero ItalicAngle values
    // is present.
    //
    // Unique name: convert UniqueID value into Unicode string. If UniqueID
    // is not found, leave the name blank.
    //
    pToken = FindAFMToken(pAFM, PS_WEIGHT_TOK);
    if (pToken == NULL)
    {
        ERR(("makentf - afm2ntm: Weight value missing\n"));
        FREE_AFMTONTM_MEMORY;
        return NULL;
    }
    StrCpy(szStyleName, pToken);

    pToken = FindAFMToken(pAFM, PS_ITALIC_TOK);
    if (pToken)
    {
        if (atoi(pToken) > 0)
            strcat(szStyleName, " Italic");
    }

    isi.nStyleNameSize = ALIGN4((strlen(szStyleName) + 1) * 2);

    pToken = FindUniqueID(pAFM);
    if (pToken)
    {
        StrCpy(szUniqueID, pToken);
        isi.nUniqueNameSize = ALIGN4((strlen(szUniqueID) + 1) * 2);
    }
    else
        isi.nUniqueNameSize = 0;

    //
    // If font doesn't support (Italics OR Bold), reserve additional memory
    // at end of IFIMETRICS for structures required to do Italics simulation.
    //
    bIsItalic = FALSE;
    bIsBold = FALSE;
    j = bIsCJKFont ? 1 : 0;

    if ((pToken = FindAFMToken(pAFM, PS_ITALIC_TOK)) != NULL)
    {
        if ( StrCmp(pToken, "0") && StrCmp(pToken, "0.0") )
             bIsItalic = TRUE;
    }

    if ((pToken = FindAFMToken(pAFM, PS_WEIGHT_TOK)) != NULL)
    {
        for (i = 0; i < WeightKeyTbl[j].usNumEntries; i++)
        {
            if (!StrCmp(pToken, (PBYTE)(((PKEY) (WeightKeyTbl[j].pTbl))[i].pName)))
            {
                if ((((PKEY) (WeightKeyTbl[j].pTbl))[i].usValue) == FW_BOLD)
                {
                    bIsBold = TRUE;
                }
                break;
            }
        }
    }

    // Reserve space for dpFontSim
    if (!bIsBold || !bIsItalic)
        isi.nFontSimSize = ALIGN4(sizeof(FONTSIM));
    else
        isi.nFontSimSize = 0;

    // Reserve space for dpBold
    if (!bIsBold)
        isi.nBoldSize = ALIGN4(sizeof(FONTDIFF));
    else
        isi.nBoldSize = 0;

    // Reserve space for dpItalic
    if (!bIsItalic)
        isi.nItalicSize = ALIGN4(sizeof(FONTDIFF));
    else
        isi.nItalicSize = 0;

    // Reserve space for dpBoldItalic
    if (!bIsBold || !bIsItalic)
        isi.nBoldItalicSize = ALIGN4(sizeof(FONTDIFF));
    else
        isi.nBoldItalicSize = 0;

    // Determine if this font supports multiple char sets.
    if (pCharSet)
    {
        if (multiCharSet > 1)
            isi.nCharSetSize = ALIGN4(NUM_DPCHARSET);
        else
            isi.nCharSetSize = 0;
    }
    else
    {
        isi.nCharSetSize = 0;
    }


    //////////////////////////////////////////////////////////////////////////
    //
    // Allocate memory for NTM, IFIMETRICS, and strings. We provide
    // the secondary IFIMETRICS and strings if we are dealing with
    // CJK font.
    //
    //////////////////////////////////////////////////////////////////////////

    GET_NTMTOTALSIZE(nsi);
    ulNTMSize = (ULONG)nsi.nTotalSize;

    GET_IFIMETRICSTOTALSIZE(isi);
    ulIFISize = (ULONG)isi.nTotalSize;

    ulIFISize2 = bIsCJKFont ? ulIFISize * 2 : ulIFISize;

    pNTM = (PNTM) MemAllocZ((size_t)(ulNTMSize + ulIFISize2));
    if (pNTM == NULL)
    {
        ERR(("makentf - afm2ntm: malloc\n"));
        FREE_AFMTONTM_MEMORY;
        return NULL;
    }


    //////////////////////////////////////////////////////////////////////////
    //
    // Construct NTM structure
    //
    //////////////////////////////////////////////////////////////////////////

    pNTM->dwSize = ulNTMSize + ulIFISize2;
    pNTM->dwVersion = NTM_VERSION;
    pNTM->dwFlags = 0;

    //
    // Store the font name.
    //
    pNTM->dwFontNameOffset = ALIGN4(sizeof(NTM));

    pby = (PBYTE)MK_PTR(pNTM, dwFontNameOffset);
    memcpy(pby, pszFontName, cFontNameLen);
    pby += cFontNameLen;

    if (bIsCJKFont)
    {
        //
        // Append glyphset name string to the font name.
        //
        memcpy(pby, pszGlyphSetName, cGlyphSetNameLen);
        pby += cGlyphSetNameLen;
    }

    *pby = '\0';

    //
    // Store the display name.
    //
    pNTM->dwDisplayNameOffset = pNTM->dwFontNameOffset
                                    + (DWORD)nsi.nFontNameSize;

    pby = (PBYTE)MK_PTR(pNTM, dwDisplayNameOffset);
    if (bIsCJKFont && bIsVGlyphSet) *pby++ = '@';
    memcpy(pby, pszFamilyName, cFamilyNameLen);
    *(pby + cFamilyNameLen) = '\0';

    //
    // Get PS font version from AFM and store in NTM.
    //
    pToken = FindAFMToken(pAFM, PS_FONT_VERSION_TOK);
    if (pToken == NULL)  // Fixed bug 354007
    {
        ERR(("makentf - afm2ntm: Font Version value missing\n"));
        FREE_AFMTONTM_MEMORY;
        return NULL;
    }

    pNTM->dwFontVersion = atoi(pToken) << 16 | atoi(&pToken[4]);

    //
    // Get the name string of the GLYPHSETDATA associated with this font
    // and store it in NTM.
    //
    pNTM->dwGlyphSetNameOffset = pNTM->dwDisplayNameOffset
                                    + (DWORD)nsi.nDisplayNameSize;

    strcpy((PBYTE)MK_PTR(pNTM, dwGlyphSetNameOffset), pszGlyphSetName);

    //
    // Store the count of Glyphs.
    //
    pNTM->dwGlyphCount = ulChCnt;

    //
    // Calculate offset, create ptr to IFIMETRICS.
    //
    pNTM->dwIFIMetricsOffset = ulNTMSize;
    pifi = (PIFIMETRICS) MK_PTR(pNTM, dwIFIMetricsOffset);

    //
    // Calculate offset, create ptr to the secondly IFIMETRICS if necessary.
    //
    if (bIsCJKFont)
    {
        pNTM->dwIFIMetricsOffset2 = ulNTMSize + ulIFISize;
        pifi2 = (PIFIMETRICS)MK_PTR(pNTM, dwIFIMetricsOffset2);
    }
    else
    {
        pNTM->dwIFIMetricsOffset2 = 0;
        pifi2 = NULL;
    }

    //
    // For both Fixed and Prop fonts, we need to get the ETMInfo.
    // (Fix bug 211966, PPeng, 6-6-97)
    //
    GetAFMETM(pAFM, pFontChars, &EtmInfo);

    //
    // According to AFM spec, if a 'CharWidth' token is found in AFM, the
    // font must be fixed pitch.
    //
    if (bIsFixedPitch)
    {
        //
        // This is a fixed pitch font. Get the AvgWidth - which is anyone's width
        //
        pNTM->dwDefaultCharWidth = 0;
        pNTM->dwCharWidthCount = 0;
        pNTM->dwCharWidthOffset = 0;

        //
        // We just get a reasonable number from the AFM different from zero.
        // This number is used in computing font transfroms.
        //
        if ((pToken = FindAFMToken(pAFM, PS_CH_METRICS_TOK)) != NULL)
        {
            //
            // Get width of first char defined in AFM and use as
            // average width.
            //
            NEXT_TOKEN(pToken);
            pChWidthTok = FindAFMToken(pToken, PS_CH_WIDTH_TOK);
            if (pChWidthTok == NULL)
            {
                pChWidthTok = FindAFMToken(pToken, PS_CH_WIDTH0_TOK);
            }
            if (pChWidthTok != NULL)
            {
                pToken = pChWidthTok;
                pifi->fwdAveCharWidth =
                    pifi->fwdMaxCharInc = (FWORD)atoi(pToken);
            }
        }

        pifi->fwdMaxCharInc = pifi->fwdAveCharWidth ;

        if (bIsCJKFont)
        {
            // DCR: couldn't divide by 2 simply for C and K.
            pifi->fwdAveCharWidth /= 2;
        }

        ASSERTMSG(pifi->fwdAveCharWidth, ("PSCRIPT: pifi->fwdAveCharWidth == 0\n"));
    }
    else
    {
        //
        // Proportional font. Generate WIDTHRUNs.
        //
        pNTM->dwCharWidthOffset = pNTM->dwGlyphSetNameOffset
                                    + (DWORD)nsi.nGlyphSetNameSize;

        pWidthRuns = (PWIDTHRUN) MK_PTR(pNTM, dwCharWidthOffset);
        pNTM->dwCharWidthCount = GetAFMCharWidths(pAFM,
                                                    &pWidthRuns,
                                                    pFontChars,
                                                    pUniPs,
                                                    pGlyphSetData->dwGlyphCount,
                                                    &pifi->fwdAveCharWidth,
                                                    &pifi->fwdMaxCharInc);

        // Fix bug 240339, jjia, 8/3/98
        if (pWidthRuns[0].dwCharWidth == WIDTHRUN_COMPLEX)
        {
            pWidthRuns[0].dwCharWidth = WIDTHRUN_COMPLEX +
                                        sizeof(WIDTHRUN);
        }
    }

    //
    // For both Prop and Fixed fonts
    // (Fix bug 210314, PPeng, 6-10-97)
    //
    pNTM->dwDefaultCharWidth = pifi->fwdAveCharWidth;

    //
    // Construct kerning pairs.
    //
    if (ulKernPairs)
    {
        //
        // Fill NTM with kern pair data.
        //
        pNTM->dwKernPairOffset = pNTM->dwGlyphSetNameOffset
                                    + (DWORD)nsi.nGlyphSetNameSize
                                    + (DWORD)nsi.nCharWidthSize;

        pKernPairs = (FD_KERNINGPAIR *) MK_PTR(pNTM, dwKernPairOffset);
        pNTM->dwKernPairCount = GetAFMKernPairs(pAFM, pKernPairs, pGlyphSetData);
    }
    else
    {
        //
        // No pair kerning info for this font.
        //
        pNTM->dwKernPairCount = 0;
        pNTM->dwKernPairOffset = 0;
    }

    //
    // Store the CharDefined tbl.
    //
    pNTM->dwCharDefFlagOffset = pNTM->dwGlyphSetNameOffset
                                    + (DWORD)nsi.nGlyphSetNameSize
                                    + (DWORD)nsi.nCharWidthSize
                                    + (DWORD)nsi.nKernPairSize;

    memcpy((PBYTE) MK_PTR(pNTM, dwCharDefFlagOffset), pCharDefTbl, ulCharDefTbl);

    //
    // Get font character set from AFM and store in NTM
    //
    pToken = pAFMCharacterSetString;
    if (pToken != NULL)
    {
        if (StrCmp(pToken, PS_STANDARD_CHARSET_TOK) == 0)
            pNTM->dwCharSet = CHARSET_STANDARD;
        else if (StrCmp(pToken, PS_SPECIAL_CHARSET_TOK) == 0)
            pNTM->dwCharSet = CHARSET_SPECIAL;
        else if (StrCmp(pToken, PS_EXTENDED_CHARSET_TOK) == 0)
            pNTM->dwCharSet = CHARSET_EXTENDED;
        else
            pNTM->dwCharSet = CHARSET_UNKNOWN;
    }

    //
    // Save the codepage of the font if there is only one of it is used for
    // the font.
    //
    if (pGlyphSetData->dwCodePageCount == 1)
        pNTM->dwCodePage = ((PCODEPAGEINFO)MK_PTR(pGlyphSetData, dwCodePageOffset))->dwCodePage;
    else
        pNTM->dwCodePage = 0;

    //
    // Cleare the reserved area.
    //
    pNTM->dwReserved[0] =
    pNTM->dwReserved[1] =
    pNTM->dwReserved[2] = 0;


    //////////////////////////////////////////////////////////////////////////
    //
    // Construct IFIMETRICS structure
    //
    //////////////////////////////////////////////////////////////////////////

    pifi->cjThis = ulIFISize;
    pifi->cjIfiExtra = isi.nIfiExtraSize;
    pifi->lEmbedId  = 0; // only useful for tt fonts
    pifi->lCharBias = 0; // only useful for tt fonts

    pifi->flInfo =  FM_INFO_ARB_XFORMS                  |
                    FM_INFO_NOT_CONTIGUOUS              |
                    FM_INFO_TECH_OUTLINE_NOT_TRUETYPE   |
                    FM_INFO_1BPP                        |
                    FM_INFO_RIGHT_HANDED;

    //
    // Everything in IFIEXTRA is leave blank for now.
    // Only the number of glyphs is filled in.
    //
    pifiEx = (PIFIEXTRA)((PBYTE)pifi + isi.nSize);
    pifiEx->cig = pGlyphSetData->dwGlyphCount;

    //
    // Store font family name to IFIMETRICS. Copy font name aliases too if any.
    // Note that this routine also converts the appropriate family name str to
    // unicode prior to storing it in IFIMETRICS.
    //
    pifi->dpwszFamilyName = (PTRDIFF)(isi.nSize + isi.nIfiExtraSize);
    ulAliases = cjGetFamilyAliases(pifi, pNameStr, csi.ciACP);

    //
    // Adjust ulAliases to the first null terminator if FM_INFO_FAMILY_EQUIV
    // bit is set.
    //
    if (pifi->flInfo & FM_INFO_FAMILY_EQUIV)
        ulAliases -= sizeof (WCHAR);

    if (pNameStr2)
    {
        pifi->flInfo |= FM_INFO_FAMILY_EQUIV;

        pby = (PBYTE)MK_PTR(pifi, dpwszFamilyName) + ulAliases;
        MultiByteToWideChar(csi.ciACP, 0,
                            pNameStr2, cNameStr2Len,
                            (PWSTR)pby, wcNameStr2Len);
        pby += wcNameStr2Len * sizeof (WCHAR);

        //
        // Terminate with two WCHAR nulls.
        //
        *((PWSTR)pby) = (WCHAR)'\0';
        pby += sizeof (WCHAR);
        *((PWSTR)pby) = (WCHAR)'\0';
        pby += sizeof (WCHAR);
    }

    //
    // Face name shares the family name/aliases for Win3.1 compatibility.
    //
    pifi->dpwszFaceName = pifi->dpwszFamilyName;

    //
    // Store style and unique names. Style name has to be available but
    // unique name may not be available.
    //
    pifi->dpwszStyleName = pifi->dpwszFamilyName + (PTRDIFF)isi.nFamilyNameSize;
    pby = (PBYTE)MK_PTR(pifi, dpwszStyleName);
    MULTIBYTETOUNICODE((LPWSTR)pby, isi.nStyleNameSize, NULL, szStyleName, strlen(szStyleName));

    if (isi.nUniqueNameSize)
    {
        pifi->dpwszUniqueName = pifi->dpwszStyleName + (PTRDIFF)isi.nStyleNameSize;
        pby = (PBYTE)MK_PTR(pifi, dpwszUniqueName);
        MULTIBYTETOUNICODE((LPWSTR)pby, isi.nUniqueNameSize, NULL, szUniqueID, strlen(szUniqueID));
    }
    else
    {
        pifi->dpwszUniqueName = pifi->dpwszStyleName + isi.nStyleNameSize - sizeof (WCHAR);
    }

    //
    // Save Windows characterset.
    //
    pifi->jWinCharSet = (BYTE)jWinCharSet;

    //
    // Store the font's family type flags.
    //
    if (pFamilyInfo != NULL)
    {
        pifi->jWinPitchAndFamily = (BYTE) pFamilyInfo->FamilyKey.usValue & 0xff;
    }
    else
    {
        pifi->jWinPitchAndFamily = FF_SWISS;
    }

    //
    // Set pitch flags.
    //
    if (bIsFixedPitch)
    {
        pifi->jWinPitchAndFamily |= FIXED_PITCH;
        pifi->flInfo |= FM_INFO_OPTICALLY_FIXED_PITCH;

        if (!bIsCJKFont)
            pifi->flInfo |= FM_INFO_CONSTANT_WIDTH;
        else
            pifi->flInfo |= FM_INFO_DBCS_FIXED_PITCH;
    }
    else
    {
        pifi->jWinPitchAndFamily |= VARIABLE_PITCH;
    }

    //
    // Get weight from AFM key.
    //
    pifi->usWinWeight = FW_NORMAL;
    pifi->fsSelection = 0;
    j = bIsCJKFont ? 1 : 0;

    if ((pToken = FindAFMToken(pAFM, PS_WEIGHT_TOK)) != NULL)
        for (i = 0; i < WeightKeyTbl[j].usNumEntries; i++)
        {
            if (!StrCmp(pToken, (PBYTE) (((PKEY) (WeightKeyTbl[j].pTbl))[i].pName)))
            {
                pifi->usWinWeight = (((PKEY) (WeightKeyTbl[j].pTbl))[i].usValue);
                if (pifi->usWinWeight == FW_BOLD)
                {
                    pifi->fsSelection = FM_SEL_BOLD;
                }
                break;
            }
        }

    //
    // Is this really how to set font selection flags?
    // AFMtoPFM converter treats angle as a float, but etm.etmslant
    // field is a short.
    //
    //
    // Set Italic sel flag if necessary.
    //
    if ((pToken = FindAFMToken(pAFM, PS_ITALIC_TOK)) != NULL)
        pNTM->etm.etmSlant = (SHORT)atoi(pToken);
    if (pNTM->etm.etmSlant)
    {
        pifi->fsSelection |= FM_SEL_ITALIC;
    }


#if 0
    //
    // DCR: so, what are we gonna do with this?
    //
    FSHORT fsSelection = 0;

    //
    // Excerpts from bodind's code. Not sure if we need this
    // useful.
    //
    if (pjPFM[OFF_Underline])
        fsSelection |= FM_SEL_UNDERSCORE;
    if (pjPFM[OFF_StrikeOut])
        fsSelection |= FM_SEL_STRIKEOUT;
    if (READ_WORD(&pjPFM[OFF_Weight]) > FW_NORMAL)
        fsSelection |= FM_SEL_BOLD;
#endif


    pifi->fsType = FM_NO_EMBEDDING;
    pifi->fwdUnitsPerEm = EM; // hardcoded for type 1 fonts

    //
    // Use FontBBox2 if found. Otherwise, use FontBBox. FontBBox2 is
    // the bounding box values of the characters not the union of all
    // the characters described in the AFM file but the characters
    // actually used in a specific character set such as 90ms.
    //
    if (((pToken = FindAFMToken(pAFM, PS_FONT_BBOX2_TOK)) == NULL) &&
        ((pToken = FindAFMToken(pAFM, PS_FONT_BBOX_TOK)) == NULL))
    {
        ERR(("makentf - afm2ntm: FontBBox not found\n"));
        FREE_AFMTONTM_MEMORY;
        return NULL;
    }
    //
    // Save font bounding box.
    //
    PARSE_RECT(pToken, rcBBox);
    sIntLeading = (SHORT) (rcBBox.top - rcBBox.bottom) - EM;
    if (sIntLeading < 0)
        sIntLeading = 0;

    sAscent                = (USHORT) rcBBox.top & 0xffff;
    pifi->fwdWinAscender   = sAscent;

    //
    // Poof! Magic Metrics...
    //
    sExternalLeading = 196;

    // see pfm.c, win31 sources, this computation
    // produces quantity that is >= |rcBBox.bottom|

    pifi->fwdWinDescender  = EM - sAscent + sIntLeading;

    pifi->fwdMacAscender   =  sAscent;
    pifi->fwdMacDescender  = -pifi->fwdWinDescender;
    pifi->fwdMacLineGap    =  (FWORD) sExternalLeading - sIntLeading;
    if (pifi->fwdMacLineGap < 0)
        pifi->fwdMacLineGap = 0;

    pifi->fwdTypoAscender  = pifi->fwdMacAscender;
    pifi->fwdTypoDescender = pifi->fwdMacDescender;
    pifi->fwdTypoLineGap   = pifi->fwdMacLineGap;

    if (pifi->fwdAveCharWidth > pifi->fwdMaxCharInc)
    {
        //
        // fix the bug in the header if there is one,
        // We do not want to change AveCharWidht, it is used for
        // computing font xforms, Max is used for nothing as fas as I know.
        //
        pifi->fwdMaxCharInc = pifi->fwdAveCharWidth;
    }

    //
    // Create EXTTEXTMETRICs. Poof! More magic.
    //
    pNTM->etm.etmSize = sizeof(EXTTEXTMETRIC);
    pNTM->etm.etmCapHeight = EtmInfo.etmCapHeight;
    pNTM->etm.etmXHeight = EtmInfo.etmXHeight;
    pNTM->etm.etmLowerCaseAscent = EtmInfo.etmLowerCaseAscent;
    pNTM->etm.etmLowerCaseDescent = EtmInfo.etmLowerCaseDescent;
    pNTM->etm.etmPointSize = 12 * 20;   /* Nominal point size = 12 */
    pNTM->etm.etmOrientation = 0;
    pNTM->etm.etmMasterHeight = 1000;
    pNTM->etm.etmMinScale = 3;
    pNTM->etm.etmMaxScale = 1000;
    pNTM->etm.etmMasterUnits = 1000;

    if ((pToken = FindAFMToken(pAFM, PS_UNDERLINE_POS_TOK)) != NULL)
        pNTM->etm.etmUnderlineOffset = (SHORT)atoi(pToken);

    if ((pToken = FindAFMToken(pAFM, PS_UNDERLINE_THICK_TOK)) != NULL)
        pNTM->etm.etmUnderlineWidth = (SHORT)atoi(pToken);

    pNTM->etm.etmSuperScript = -500;
    pNTM->etm.etmSubScript = 250;
    pNTM->etm.etmSuperScriptSize = 500;
    pNTM->etm.etmSubScriptSize = 500;
    pNTM->etm.etmDoubleUpperUnderlineOffset = pNTM->etm.etmUnderlineOffset / 2;
    pNTM->etm.etmDoubleLowerUnderlineOffset = pNTM->etm.etmUnderlineOffset;

    pNTM->etm.etmDoubleUpperUnderlineWidth = // same as LowerUnderlineWidth
    pNTM->etm.etmDoubleLowerUnderlineWidth = pNTM->etm.etmUnderlineWidth / 2;

    pNTM->etm.etmStrikeOutOffset = 500;
    pNTM->etm.etmStrikeOutWidth = 50;  // ATM sets it to 50 (also all PFMs have 50)
    pNTM->etm.etmNKernPairs = (USHORT) ulKernPairs & 0xffff;

    //
    // No track kerning. This mimics the behavior of old AFM->PFM utility.
    //
    pNTM->etm.etmNKernTracks = 0;

    //
    // SuperScripts and Subscripts come from etm:
    //
    pifi->fwdSubscriptXSize      =  // same as YSize
    pifi->fwdSubscriptYSize      = pNTM->etm.etmSubScriptSize;

    pifi->fwdSubscriptXOffset    = 0;
    pifi->fwdSubscriptYOffset    = pNTM->etm.etmSubScript;

    pifi->fwdSuperscriptXSize    = // same as YSize
    pifi->fwdSuperscriptYSize    = pNTM->etm.etmSuperScriptSize;

    pifi->fwdSuperscriptXOffset  = 0;
    pifi->fwdSuperscriptYOffset  = pNTM->etm.etmSuperScript;

    pifi->fwdUnderscoreSize = pNTM->etm.etmUnderlineWidth;

    //
    // fwdUnderscorePosition is typically negative - AFM may have negative value already
    //
    if (pNTM->etm.etmUnderlineOffset <0)
        pifi->fwdUnderscorePosition = -pNTM->etm.etmUnderlineOffset;
    else
        pifi->fwdUnderscorePosition = pNTM->etm.etmUnderlineOffset;

    // Make it compatible with ATM. Fix bug Adobe #211202
    pifi->fwdUnderscorePosition = -(pifi->fwdUnderscorePosition -
                                    pifi->fwdUnderscoreSize / 2);

    pifi->fwdStrikeoutSize = pNTM->etm.etmStrikeOutWidth;

    //
    // This is what KentSe was using to position strikeout and it looked good [bodind]
    // Instead we could have used etmStrikeoutOffset (usually equal to 500) which
    // was too big.
    //

    // Make it compatible with ATM. Fix bug Adobe #211202
    // pifi->fwdStrikeoutPosition = ((LONG)pNTM->etm.etmLowerCaseAscent / 2);
    if (pNTM->etm.etmCapHeight != 0)
        pifi->fwdStrikeoutPosition = (pNTM->etm.etmCapHeight - pifi->fwdUnderscoreSize) / 2;
    else
        pifi->fwdStrikeoutPosition = (pNTM->etm.etmXHeight - pifi->fwdUnderscoreSize) / 2;

    pifi->fwdLowestPPEm = pNTM->etm.etmMinScale;

    //
    // Per bodind, Win 3.1 values for first, last, break and default char can
    // be hardcoded.
    //
    pifi->chFirstChar   = 0x20;
    pifi->chLastChar    = 0xff;

    if (!bIsCJKFont)
    {
        pifi->chBreakChar   = 0x20;

        // The following line of code should work, however, there seems to be
        // a bug in afm -> pfm conversion utility which makes
        // DefaultChar == 0x20 instead of 149 - 20 (for bullet).

        // pifi->chDefaultChar = pjPFM[OFF_DefaultChar] + pjPFM[OFF_FirstChar];

        // Therefore, instead, I will use 149 which seems to work for all fonts.

        pifi->chDefaultChar = 149;
    }
    else
    {
        pifi->chBreakChar   =
        pifi->chDefaultChar = 0x00;
    }

    //
    // Get Unicode values for first and last char from GLYPHSETDATA. We
    // should do this on a per GLYPHSETDATA basis rather than a per font
    // basis, but the calculations are so simple just do it on the fly,
    // rather than dragging first and last char around with the
    // GLYPHSETDATA.
    //
    pGlyphRun = (PGLYPHRUN) MK_PTR(pGlyphSetData, dwRunOffset);
    pifi->wcFirstChar = pGlyphRun->wcLow;
    (ULONG_PTR) pGlyphRun += (pGlyphSetData->dwRunCount - 1) * sizeof(GLYPHRUN);
    pifi->wcLastChar = pGlyphRun->wcLow + pGlyphRun->wGlyphCount - 1;

    MultiByteToWideChar(csi.ciACP, 0,
                        &pifi->chDefaultChar, 1,
                        &pifi->wcDefaultChar, sizeof(WCHAR));
    MultiByteToWideChar(csi.ciACP, 0,
                        &pifi->chBreakChar, 1,
                        &pifi->wcBreakChar, sizeof(WCHAR));

    pifi->fwdCapHeight = pNTM->etm.etmCapHeight;
    pifi->fwdXHeight   = pNTM->etm.etmXHeight;

    // All the fonts that this font driver will see are to be rendered left
    // to right

    pifi->ptlBaseline.x = 1;
    pifi->ptlBaseline.y = 0;

    pifi->ptlAspect.y = 300;
    pifi->ptlAspect.x = 300;

    // italic angle from etm.

    pifi->lItalicAngle = pNTM->etm.etmSlant;

    if (pifi->lItalicAngle == 0)
    {
        // The base class of font is not italicized,

        pifi->ptlCaret.x = 0;
        pifi->ptlCaret.y = 1;
    }
    else
    {
        // ptlCaret.x = -sin(lItalicAngle);
        // ptlCaret.y =  cos(lItalicAngle);
        //!!! until I figure out the fast way to get sin and cos I cheat: [bodind]

        pifi->ptlCaret.x = 1;
        pifi->ptlCaret.y = 3;
    }

    //!!! The font box; This is bogus, this info is not in .pfm file!!! [bodind]
    //!!! but I suppose that this info is not too useful anyway, it is nowhere
    //!!! used in the engine or elsewhere in the ps driver.
    //!!! left and right are bogus, top and bottom make sense.

    pifi->rclFontBox.left   = 0;                              // bogus
    pifi->rclFontBox.top    = (LONG) pifi->fwdTypoAscender;   // correct
    pifi->rclFontBox.right  = (LONG) pifi->fwdMaxCharInc;     // bogus
    pifi->rclFontBox.bottom = (LONG) pifi->fwdTypoDescender;  // correct

    // achVendorId, unknown, don't bother figure it out from copyright msg

    pifi->achVendId[0] = 'U';
    pifi->achVendId[1] = 'n';
    pifi->achVendId[2] = 'k';
    pifi->achVendId[3] = 'n';
    pifi->cKerningPairs = ulKernPairs;

    // Panose

    pifi->ulPanoseCulture = FM_PANOSE_CULTURE_LATIN;
    ppanose = &(pifi->panose);
    ppanose->bFamilyType = PAN_ANY;
    ppanose->bSerifStyle =
        ((pifi->jWinPitchAndFamily & 0xf0) == FF_SWISS) ?
            PAN_SERIF_NORMAL_SANS : PAN_ANY;

    ppanose->bWeight = (BYTE) WINWT_TO_PANWT(pifi->usWinWeight);
    ppanose->bProportion = (pifi->jWinPitchAndFamily & FIXED_PITCH) ?
                                PAN_PROP_MONOSPACED : PAN_ANY;
    ppanose->bContrast        = PAN_ANY;
    ppanose->bStrokeVariation = PAN_ANY;
    ppanose->bArmStyle        = PAN_ANY;
    ppanose->bLetterform      = PAN_ANY;
    ppanose->bMidline         = PAN_ANY;
    ppanose->bXHeight         = PAN_ANY;
    // If the font is not italic or Not-Bold, the driver can simulate it
    // Set the dpBold, dpItalic, and dpBoldItalic correctly, PPeng, 6-3-1997

    // Depends on AFM, we need to set some of the sim structure:
    // Normal - need dpBold, dpItalic, and dpBoldItalic
    // Bold   - need dpItalic
    // Italic - need dpBoldItalic
    // BoldItalic - Nothing

    // Don't move code around !!
    // At this point, bIsBold and bIsItalic should be set already
    // Don't move code around !!

    if (!bIsBold || !bIsItalic)
    {

        FONTSIM *pFontSim;
        FONTDIFF *pFontDiff;
        FONTDIFF FontDiff;

        // Preset temporary FontDiff structure
        FontDiff.jReserved1         =   0;
        FontDiff.jReserved2         =   0;
        FontDiff.jReserved3         =   0;
        FontDiff.bWeight            =   pifi->panose.bWeight;
        FontDiff.usWinWeight        =   pifi->usWinWeight;
        FontDiff.fsSelection        =   pifi->fsSelection;
        FontDiff.fwdAveCharWidth    =   pifi->fwdAveCharWidth;
        FontDiff.fwdMaxCharInc      =   pifi->fwdMaxCharInc;
        FontDiff.ptlCaret           =   pifi->ptlCaret;

        // Initialize FONTSIM structure
        pifi->dpFontSim = pifi->dpwszStyleName + (PTRDIFF)(isi.nStyleNameSize + isi.nUniqueNameSize);

        pFontSim = (FONTSIM *) MK_PTR(pifi, dpFontSim);

        pFontSim->dpBold = pFontSim->dpBoldItalic = pFontSim->dpItalic = 0;

        // Notice the FontDiff data are arranged right after FontSim
        // in the following order: dpBold, dpItalic, dpBoldItalic

        if (!bIsBold)
        {
            // Right after FontSim.
            pFontSim->dpBold = ALIGN4(sizeof(FONTSIM));

            pFontDiff = (FONTDIFF *) MK_PTR(pFontSim, dpBold);
            *pFontDiff = FontDiff;

            pFontDiff->bWeight = PAN_WEIGHT_BOLD;
            pFontDiff->fsSelection |= FM_SEL_BOLD;
            pFontDiff->usWinWeight = FW_BOLD;
            pFontDiff->fwdAveCharWidth += 1;
            pFontDiff->fwdMaxCharInc += 1;

            // if already Italic, CANNOT Un-italic it
            if (bIsItalic)
            {
                pFontDiff->ptlCaret.x = 1;
                pFontDiff->ptlCaret.y = 3;
            }
            else
            {
                pFontDiff->ptlCaret.x = 0;
                pFontDiff->ptlCaret.y = 1;
            }
        }

        if (!bIsItalic)
        {
            if (pFontSim->dpBold)
            {
                // Right after FontDiff for dpBold, or...
                pFontSim->dpItalic = pFontSim->dpBold + ALIGN4(sizeof(FONTDIFF));
            }
            else
            {
                // ...right after FontSim.
                pFontSim->dpItalic = ALIGN4(sizeof(FONTSIM));
            }

            pFontDiff = (FONTDIFF *) MK_PTR(pFontSim, dpItalic);
            *pFontDiff = FontDiff;

            pFontDiff->fsSelection |= FM_SEL_ITALIC;

            // Italic angle is approximately 18 degree
            pFontDiff->ptlCaret.x = 1;
            pFontDiff->ptlCaret.y = 3;
        }

        // Make BoldItalic simulation if necessary - besides dpBold or dpItalic
        if (!bIsItalic || !bIsBold)
        {
            if (pFontSim->dpItalic)
            {
                // Right after FontDiff for dpItalic, or...
                pFontSim->dpBoldItalic = pFontSim->dpItalic + ALIGN4(sizeof(FONTDIFF));
            }
            else if (pFontSim->dpBold)
            {
                // ...right after FontDiff for dpBold if dpItalic is not set, or...
                pFontSim->dpBoldItalic = pFontSim->dpBold + ALIGN4(sizeof(FONTDIFF));
            }
            else
            {
                // ...right after FontSim if none of other two is set.
                pFontSim->dpBoldItalic = ALIGN4(sizeof(FONTSIM));
            }

            pFontDiff = (FONTDIFF *) MK_PTR(pFontSim, dpBoldItalic);
            *pFontDiff = FontDiff;

            pFontDiff->bWeight = PAN_WEIGHT_BOLD;
            pFontDiff->fsSelection |= (FM_SEL_BOLD | FM_SEL_ITALIC);
            pFontDiff->usWinWeight = FW_BOLD;
            pFontDiff->fwdAveCharWidth += 1;
            pFontDiff->fwdMaxCharInc += 1;

            // Italic angle is approximately 18 degree
            pFontDiff->ptlCaret.x = 1;
            pFontDiff->ptlCaret.y = 3;
        }
    }
    else
        pifi->dpFontSim = 0;

    if (multiCharSet > 1)
    {
        PBYTE pDpCharSet;

        pifi->dpCharSets = ulIFISize - ALIGN4(NUM_DPCHARSET);
        pDpCharSet = (BYTE *)MK_PTR(pifi, dpCharSets);

        // The order of this check is important since jWinCharSet
        // should match the first dpCharSets array if it exists.
        i = 0;
        if (CSET_SUPPORT(*pCharSet, CS_ANSI))
            pDpCharSet[i++] = ANSI_CHARSET;
        if (CSET_SUPPORT(*pCharSet, CS_EASTEUROPE))
            pDpCharSet[i++] = EASTEUROPE_CHARSET;
        if (CSET_SUPPORT(*pCharSet, CS_RUSSIAN))
            pDpCharSet[i++] = RUSSIAN_CHARSET;
        if (CSET_SUPPORT(*pCharSet, CS_GREEK))
            pDpCharSet[i++] = GREEK_CHARSET;
        if (CSET_SUPPORT(*pCharSet, CS_TURKISH))
            pDpCharSet[i++] = TURKISH_CHARSET;
        if (CSET_SUPPORT(*pCharSet, CS_HEBREW))
            pDpCharSet[i++] = HEBREW_CHARSET;
        if (CSET_SUPPORT(*pCharSet, CS_ARABIC))
            pDpCharSet[i++] = ARABIC_CHARSET;
        if (CSET_SUPPORT(*pCharSet, CS_BALTIC))
            pDpCharSet[i++] = BALTIC_CHARSET;
        if (CSET_SUPPORT(*pCharSet, CS_SYMBOL))
            pDpCharSet[i++] = SYMBOL_CHARSET;

        while (i < 16)
            pDpCharSet[i++] = DEFAULT_CHARSET;

    }
    else
        pifi->dpCharSets = 0; // no multiple charsets in ps fonts

    //
    // Copy the first IFIMETRICS to the secondly if necessary, and then
    // switch English and localized font menu names.
    //
    if (bIsCJKFont)
    {
        ASSERT(pifi2 != NULL);

        memcpy(pifi2, pifi, isi.nTotalSize);

        pifi2->flInfo &= ~FM_INFO_FAMILY_EQUIV;

        ulAliases = cjGetFamilyAliases(pifi2, pNameStr2, csi.ciACP);

        if (pifi2->flInfo & FM_INFO_FAMILY_EQUIV)
            ulAliases -= sizeof (WCHAR);

        pifi2->flInfo |= FM_INFO_FAMILY_EQUIV;

        pby = (PBYTE)MK_PTR(pifi2, dpwszFamilyName) + ulAliases;
        MultiByteToWideChar(csi.ciACP, 0,
                                pNameStr, cNameStrLen,
                                (PWSTR)pby, wcNameStrLen);
        pby += wcNameStrLen * sizeof (WCHAR);

        //
        // Terminate with two WCHAR nulls.
        //
        *((PWSTR)pby) = (WCHAR)'\0';
        pby += sizeof (WCHAR);
        *((PWSTR)pby) = (WCHAR)'\0';
        pby += sizeof (WCHAR);

        //
        // Face name shares the family name/aliases for Win3.1 compatibility.
        //
        pifi2->dpwszFaceName = pifi2->dpwszFamilyName;

#if 1
        //
        // We now support style and unique names too.
        //
        pifi2->dpwszStyleName = pifi2->dpwszFamilyName + (PTRDIFF)isi.nFamilyNameSize;
        pby = (PBYTE)MK_PTR(pifi2, dpwszStyleName);
        MULTIBYTETOUNICODE((LPWSTR)pby, isi.nStyleNameSize, NULL, szStyleName, strlen(szStyleName));

        if (isi.nUniqueNameSize)
        {
            pifi2->dpwszUniqueName = pifi2->dpwszStyleName + (PTRDIFF)isi.nStyleNameSize;
            pby = (PBYTE)MK_PTR(pifi2, dpwszUniqueName);
            MULTIBYTETOUNICODE((LPWSTR)pby, isi.nUniqueNameSize, NULL, szUniqueID, strlen(szUniqueID));
        }
        else
        {
            pifi2->dpwszUniqueName = pifi2->dpwszStyleName + isi.nStyleNameSize - sizeof (WCHAR);
        }
#else
        //
        // These names don't exist, so point to the NULL char.
        // This is too for Win3.1 compatibility.
        //
        pifi2->dpwszStyleName = pifi2->dpwszFamilyName + ulAliases - sizeof (WCHAR);
        pifi2->dpwszUniqueName = pifi2->dpwszStyleName;
#endif

#ifdef FORCE_2NDIFIMETRICS_FIRST
        {
            DWORD dw = pNTM->dwIFIMetricsOffset;

            pNTM->dwIFIMetricsOffset  = pNTM->dwIFIMetricsOffset2;
            pNTM->dwIFIMetricsOffset2 = dw;
        }
#endif
    }


    if (bVerbose)
    {
        printf("NTM:dwFontNameOffset:%s\n", (PSZ)MK_PTR(pNTM, dwFontNameOffset));
        printf("NTM:dwDisplayNameOffset:%s\n", (PSZ)MK_PTR(pNTM, dwDisplayNameOffset));
        printf("NTM:dwGlyphSetNameOffset:%s\n", (PSZ)MK_PTR(pNTM, dwGlyphSetNameOffset));
        printf("NTM:dwGlyphCount:%ld\n", pNTM->dwGlyphCount);
        printf("NTM:dwCharWidthCount:%ld\n", pNTM->dwCharWidthCount);
        printf("NTM:dwDefaultCharWidth:%ld\n", pNTM->dwDefaultCharWidth);
        printf("NTM:dwCharSet:%ld\n", pNTM->dwCharSet);
        printf("NTM:dwCodePage:%ld\n", pNTM->dwCodePage);

        pifi = (PIFIMETRICS)MK_PTR(pNTM, dwIFIMetricsOffset);

        printf("IFIMETRICS:dpwszFamilyName:%S\n", (LPWSTR)MK_PTR(pifi, dpwszFamilyName));
        printf("IFIMETRICS:dpwszStyleName:%S\n", (LPWSTR)MK_PTR(pifi, dpwszStyleName));
        printf("IFIMETRICS:dpwszFaceName:%S\n", (LPWSTR)MK_PTR(pifi, dpwszFaceName));
        printf("IFIMETRICS:dpwszUniqueName:%S\n", (LPWSTR)MK_PTR(pifi, dpwszUniqueName));

        printf("IFIMETRICS:jWinCharSet:%d\n", (WORD)pifi->jWinCharSet);
        printf("IFIMETRICS:jWinPitchAndFamily:%02X\n", (WORD)pifi->jWinPitchAndFamily);
        printf("IFIMETRICS:usWinWeight:%d\n", (int)pifi->usWinWeight);
        printf("IFIMETRICS:flInfo:%08lX\n", pifi->flInfo);
        printf("IFIMETRICS:fsSelection:%04X\n", (WORD)pifi->fsSelection);
        printf("IFIMETRICS:fsType:%04X\n", (WORD)pifi->fsType);

        printf("IFIMETRICS:fwdUnitsPerEm:%d\n", (int)pifi->fwdUnitsPerEm);
        printf("IFIMETRICS:fwdLowestPPEm:%d\n", (int)pifi->fwdLowestPPEm);

        printf("IFIMETRICS:fwdWinAscender:%d\n", (int)pifi->fwdWinAscender);
        printf("IFIMETRICS:fwdWinDescender:%d\n", (int)pifi->fwdWinDescender);
        printf("IFIMETRICS:fwdMacAscender:%d\n", (int)pifi->fwdMacAscender);
        printf("IFIMETRICS:fwdMacDescender:%d\n", (int)pifi->fwdMacDescender);
        printf("IFIMETRICS:fwdMacLineGap:%d\n", (int)pifi->fwdMacLineGap);
        printf("IFIMETRICS:fwdTypoAscender:%d\n", (int)pifi->fwdTypoAscender);
        printf("IFIMETRICS:fwdTypoDescender:%d\n", (int)pifi->fwdTypoDescender);
        printf("IFIMETRICS:fwdTypoLineGap:%d\n", (int)pifi->fwdTypoLineGap);
        printf("IFIMETRICS:fwdAveCharWidth:%d\n", (int)pifi->fwdAveCharWidth);
        printf("IFIMETRICS:fwdMaxCharInc:%d\n", (int)pifi->fwdMaxCharInc);
        printf("IFIMETRICS:fwdCapHeight:%d\n", (int)pifi->fwdCapHeight);
        printf("IFIMETRICS:fwdXHeight:%d\n", (int)pifi->fwdXHeight);

        printf("IFIMETRICS:fwdSubscriptXSize:%d\n", (int)pifi->fwdSubscriptXSize);
        printf("IFIMETRICS:fwdSubscriptYSize:%d\n", (int)pifi->fwdSubscriptYSize);
        printf("IFIMETRICS:fwdSubscriptXOffset:%d\n", (int)pifi->fwdSubscriptXOffset);
        printf("IFIMETRICS:fwdSubscriptYOffset:%d\n", (int)pifi->fwdSubscriptYOffset);
        printf("IFIMETRICS:fwdSuperscriptXSize:%d\n", (int)pifi->fwdSuperscriptXSize);
        printf("IFIMETRICS:fwdSuperscriptYSize:%d\n", (int)pifi->fwdSuperscriptYSize);
        printf("IFIMETRICS:fwdSuperscriptXOffset:%d\n", (int)pifi->fwdSuperscriptXOffset);
        printf("IFIMETRICS:fwdSuperscriptYOffset:%d\n", (int)pifi->fwdSuperscriptYOffset);
        printf("IFIMETRICS:fwdUnderscoreSize:%d\n", (int)pifi->fwdUnderscoreSize);
        printf("IFIMETRICS:fwdUnderscorePosition:%d\n", (int)pifi->fwdUnderscorePosition);
        printf("IFIMETRICS:fwdStrikeoutSize:%d\n", (int)pifi->fwdStrikeoutSize);
        printf("IFIMETRICS:fwdStrikeoutPosition:%d\n", (int)pifi->fwdStrikeoutPosition);

        printf("IFIMETRICS:chFirstChar:%02X\n", (WORD)pifi->chFirstChar);
        printf("IFIMETRICS:chLastChar:%02X\n", (WORD)pifi->chLastChar);
        printf("IFIMETRICS:chDefaultChar:%02X\n", (WORD)pifi->chDefaultChar);
        printf("IFIMETRICS:chBreakChar:%02X\n", (WORD)pifi->chBreakChar);
        printf("IFIMETRICS:ptlBaseline:(%ld, %ld)\n", pifi->ptlBaseline.x, pifi->ptlBaseline.y);
        printf("IFIMETRICS:ptlAspect:(%ld, %ld)\n", pifi->ptlAspect.x, pifi->ptlAspect.y);
        printf("IFIMETRICS:ptlCaret:(%ld, %ld)\n", pifi->ptlCaret.x, pifi->ptlCaret.y);
        printf("IFIMETRICS:rclFontBox:(%ld, %ld, %ld, %ld)\n",
                    pifi->rclFontBox.left, pifi->rclFontBox.top,
                    pifi->rclFontBox.right, pifi->rclFontBox.bottom);

        if (pifi->dpFontSim)
        {
            FONTSIM* pFontSim = (FONTSIM*)MK_PTR(pifi, dpFontSim);

            if (pFontSim->dpBold)
                printf("FONTSIM:Bold\n");
            if (pFontSim->dpItalic)
                printf("FONTSIM:Italic\n");
            if (pFontSim->dpBoldItalic)
                printf("FONTSIM:BoldItalic\n");
        }

        printf("GLYPHSETDATA:dwFlags:%08X\n", pGlyphSetData->dwFlags);
        printf("GLYPHSETDATA:dwGlyphSetNameOffset:%s\n",
                    (PSZ)MK_PTR(pGlyphSetData, dwGlyphSetNameOffset));
        printf("GLYPHSETDATA:dwGlyphCount:%ld\n", pGlyphSetData->dwGlyphCount);
        printf("GLYPHSETDATA:dwRunCount:%ld\n", pGlyphSetData->dwRunCount);
        printf("GLYPHSETDATA:dwCodePageCount:%ld\n", pGlyphSetData->dwCodePageCount);
        {
            DWORD dw;
            PCODEPAGEINFO pcpi = (PCODEPAGEINFO)MK_PTR(pGlyphSetData, dwCodePageOffset);
            for (dw = 1; dw <= pGlyphSetData->dwCodePageCount; dw++)
            {
                printf("CODEPAGEINFO#%ld:dwCodePage:%ld\n", dw, pcpi->dwCodePage);
                printf("CODEPAGEINFO#%ld:dwWinCharset:%ld\n", dw, pcpi->dwWinCharset);
                printf("CODEPAGEINFO#%ld:dwEncodingNameOffset:%s\n",
                            dw, (PSZ)MK_PTR(pcpi, dwEncodingNameOffset));
                pcpi++;
            }
        }

        printf("\n");
    }


    //////////////////////////////////////////////////////////////////
    //
    // Free strings and char metrics info.
    //
    //////////////////////////////////////////////////////////////////

    FREE_AFMTONTM_MEMORY;

    return(pNTM);
}

PBYTE
FindAFMToken(
    PBYTE   pAFM,
    PSZ     pszToken
    )

/*++

Routine Description:

    Finds an AFM token in a memory mapped AFM file stream.

Arguments:

    pAFM - pointer to memory mapped AFM file.
    pszToken - pointer to null-term string containing token to search for

Return Value:

    NULL => error
    otherwise => ptr to token's value. This is defined as the first non-blank
    char after the token name. If EOL(FindAfmToken(pAFM, pszToken)) then
    pszToken was found but it has no value (e.g. EndCharMetrics).


--*/

{
    PBYTE   pCurToken;
    int     i;

    VERBOSE(("Entering FindAFMToken... %s\n", pszToken));

    while (TRUE)
    {
        PARSE_TOKEN(pAFM, pCurToken);
        if (!(StrCmp(pCurToken, PS_COMMENT_TOK)))
        {
            NEXT_LINE(pAFM);
        }
        else
        {
            for (i = 0; i < MAX_TOKENS; i++)
            {
                if (!(StrCmp(pCurToken, pszToken)))
                {
                    return(pAFM);
                }
                else if (!(StrCmp(pCurToken, PS_EOF_TOK)))
                {
                    return NULL;
                }
            }
            NEXT_TOKEN(pAFM);
        }
    }

    return NULL;
}

CHSETSUPPORT
GetAFMCharSetSupport(
    PBYTE           pAFM,
    CHSETSUPPORT    *pGlyphSet
    )

/*++

Routine Description:

    Given a ptr to a memory mapped AFM, determine which Windows charset(s)
    it supports.

Arguments:

    pAFMetrx - pointer to CharMetrics in a memory mapped AFM file.

Return Value:

    Contains bit fields which indicate which csets are supported. Use
    CS_SUP(CS_xxx) macro to determine if a particular cset is supported.

--*/

{
    PBYTE           pToken;
    USHORT          i, chCnt;
    CHSETSUPPORT    flCsetSupport;
    PBYTE           pAFMMetrx;

    isSymbolCharSet = FALSE;

    *pGlyphSet = CS_NOCHARSET;

    //
    // Check to see if this is a CJK font.
    //
    if ((flCsetSupport = IsCJKFont(pAFM)))
    {
        return(flCsetSupport);
    }

    pToken = pAFMCharacterSetString;
    if (pToken != NULL)
    {
        if (StrCmp(pToken, PS_STANDARD_CHARSET_TOK) == 0)
            *pGlyphSet = CS_228;
        else
            *pGlyphSet = CS_314;
    }
    else
        *pGlyphSet = CS_228;

    //
    // Check to see if a EncodingScheme token in the AFM file. If so, check
    // if this is a standard encoding font or a Pi (Symbol) font.
    //
    if ((pToken = FindAFMToken(pAFM, PS_ENCODING_TOK)) != NULL)
    {
        if (StrCmp(pToken, PS_STANDARD_ENCODING) == 0)
        {
            return(CSUP(CS_ANSI));
        }
    }

    //
    // Find the beginning of the char metrics.
    //
    pAFMMetrx = FindAFMToken(pAFM, PS_CH_METRICS_TOK);
    if (pAFMMetrx == NULL)    // Fixed bug 354007
    {
        *pGlyphSet = CS_NOCHARSET;
        ERR(("makentf - invalid StartCharMetrics\n"));
        return(CS_NOCHARSET);
    }

    //
    // Current pos should be the character count field.
    //
    for (i = 0; i < StrLen(pAFMMetrx); i++)
    {
        if (!IS_NUM(&pAFMMetrx[i]))
        {
            *pGlyphSet = CS_NOCHARSET;
            ERR(("makentf - invalid StartCharMetrics\n"));
            return(CS_NOCHARSET);
        }
    }
    chCnt = (USHORT)atoi(pAFMMetrx);
    (ULONG_PTR) pAFMMetrx += i;

    //
    // Process each char.
    //
    flCsetSupport = 0;
    i = 0;
    do
    {
        PARSE_TOKEN(pAFMMetrx, pToken);

        if (StrCmp(pToken, PS_CH_NAME_TOK) == 0)
        {
            if (StrCmp(pAFMMetrx, PS_CH_NAME_EASTEUROPE) == 0)
                flCsetSupport |= CSUP(CS_EASTEUROPE);

            else if (StrCmp(pAFMMetrx, PS_CH_NAME_RUSSIAN) == 0)
                flCsetSupport |= CSUP(CS_RUSSIAN);

            else if (StrCmp(pAFMMetrx, PS_CH_NAME_ANSI) == 0)
                flCsetSupport |= CSUP(CS_ANSI);

            else if (StrCmp(pAFMMetrx, PS_CH_NAME_GREEK) == 0)
                flCsetSupport |= CSUP(CS_GREEK);

            else if (StrCmp(pAFMMetrx, PS_CH_NAME_TURKISH) == 0)
                flCsetSupport |= CSUP(CS_TURKISH);

            else if (StrCmp(pAFMMetrx, PS_CH_NAME_HEBREW) == 0)
                flCsetSupport |= CSUP(CS_HEBREW);

            else if (StrCmp(pAFMMetrx, PS_CH_NAME_ARABIC) == 0)
                flCsetSupport |= CSUP(CS_ARABIC);

            else if (StrCmp(pAFMMetrx, PS_CH_NAME_BALTIC) == 0)
                flCsetSupport |= CSUP(CS_BALTIC);

            i++;
        }
        else if (StrCmp(pToken, PS_EOF_TOK) == 0)
        {
            break;
        }

        NEXT_TOKEN(pAFMMetrx);

    } while (i < chCnt);

    //
    // Assume symbol if none of the other char set is supported.
    //
    if (flCsetSupport == 0)
    {
        *pGlyphSet = CS_NOCHARSET;
        flCsetSupport = CSUP(CS_SYMBOL);
        isSymbolCharSet = TRUE;
    }

    return flCsetSupport;
}

int __cdecl
StrCmp(
    const VOID *str1,
    const VOID *str2
    )
/*++

Routine Description:

    Compare two strings which are terminated by either a null char or a
    space.

Arguments:

    str1, str2 - Strings to compare.

Return Value:

    -1  => str1 < str2
     1  => str1 > str2
     0  => str1 = str2

--*/

{
    PBYTE   s1 = (PBYTE) str1, s2 = (PBYTE) str2;

    // Error case, just return less then.
    if ((s1 == NULL) || (s2 == NULL))
        return(-1);

    while (!IS_WHTSPACE(s1) && !IS_WHTSPACE(s2))
    {
        if (*s1 < *s2)
        {
            return(-1);
        }
        else if (*s1 > *s2)
        {
            return(1);
        }
        s1++;
        s2++;
     }
     //
     // Strings must be same length to be an exact match.
     //
     if (IS_WHTSPACE(s1) && IS_WHTSPACE(s2))
     {
        return(0);
     }
     else if (IS_WHTSPACE(s1))
     // else if ((*s1 == ' ') || (*s1 == '\0'))
     {
        //
        // s1 is shorter, so is lower in collating sequence than s2.
        //
        return(-1);
     }
     else
        //
        // s2 is shorter, so is lower in collating sequence than s1.
        //
        return(1);
}

size_t
StrLen(
    PBYTE   pString
    )
{
    ULONG   i;

    //
    // Scan for next space, ';' token seperator, or end of line.
    //
    for (i = 0; !EOL(&pString[i]); i++)
        if(pString[i] == ';' || pString[i] == ' ')
            break;
    return(i);
}

int
StrCpy(
    const VOID *str1,
    const VOID *str2
    )
/*++

Routine Description:

    Copies str2 to str1. Strings may be terminated by either a null char or a
    space.

Arguments:

    str2 - source string
    str1 - dest string

Return Value:

    Number of bychars copied

--*/

{
    PBYTE   s1 = (PBYTE) str1, s2 = (PBYTE) str2;
    ULONG   n = 0;

    while (!IS_WHTSPACE(&s2[n]))
        s1[n] = s2[n++];
    s1[n] = '\0';
    return(n);
}

static int __cdecl
StrPos(
    const PBYTE str1,
    CHAR c
    )
/*++

Routine Description:

    Retuns index of char c in str1. String may be terminated by either a
    CR/LF, or a ':'.

Arguments:

    str1 - string to search
    c - search char

Return Value:

    Index of c in str1, or -1 if not found

--*/

{
    ULONG   i = 0;

    while (!EOL(&str1[i]))
    {
        if (str1[i++] == c)
            return(i - 1);
    }
    return(-1);
}

int __cdecl
CmpUniCodePts(
    const VOID *p1,
    const VOID *p2
    )
/*++

Routine Description:

    Compares the Unicode char code field of two UPSCODEPT structs.

Arguments:

    p1, p2 - Strings to compare.

Return Value:

    -1  => p1 < p2
     1  => p1 > p2
     0  => p1 = p2

--*/
{
    PUPSCODEPT ptr1 = (PUPSCODEPT) p1, ptr2 = (PUPSCODEPT) p2;

    //
    // Compare Unicode code point fields.
    //
    if (ptr1->wcUnicodeid > ptr2->wcUnicodeid)
        return(1);
    else if (ptr1->wcUnicodeid < ptr2->wcUnicodeid)
        return(-1);
    else
        return(0);
}

static int __cdecl
CmpUnicodePsNames(
    const VOID  *p1,
    const VOID  *p2
    )

/*++

Routine Description:

    Compares two strings. This routine is meant to be used only for looking
    up a char name key in an array of UPSCODEPT structs.

Arguments:
    p1 - a null or whitespace terminated string.
    p2 - points to a UPSCODEPT struct.

Return Value:

    -1  => p1 < p2
     1  => p1 > p2
     0  => p1 = p2

--*/
{
    PBYTE ptr1 = (PBYTE) p1;
    PUPSCODEPT ptr2 = (PUPSCODEPT) p2;

    //
    // Compare name fields.
    //
    return (StrCmp(ptr1, ptr2->pPsName));
}

static int __cdecl
CmpPsChars(
    const VOID  *p1,
    const VOID  *p2
    )

/*++

Routine Description:

    Compares a null or space terminated string to the pPsName string field
    of a PSCHARMETRICS struct.

Arguments:
    p1 - a null or whitespace terminated string.
    p2 - points to a PSCHARMETRICS struct.

Return Value:

    -1  => p1 < p2
     1  => p1 > p2
     0  => p1 = p2

--*/
{
    PBYTE ptr1 = (PBYTE) p1;
    PPSCHARMETRICS ptr2 = (PPSCHARMETRICS) p2;

    //
    // Compare name fields.
    //
    return (StrCmp(ptr1, ptr2->pPsName));
}

static int __cdecl
CmpPsNameWinCpt(
    const VOID  *p1,
    const VOID  *p2
    )

/*++

Routine Description:

    Compares a null or space terminated string to the pPsName string field
    of a WINCPT struct.

Arguments:
    p1 - a null or whitespace terminated string.
    p2 - points to a WINCPT struct.

Return Value:

    -1  => p1 < p2
     1  => p1 > p2
     0  => p1 = p2

--*/
{
    PBYTE ptr1 = (PBYTE) p1;
    PWINCPT ptr2 = (PWINCPT) p2;

    //
    // Compare name fields.
    //
    return(StrCmp(ptr1, ptr2->pPsName));
}

static int __cdecl
CmpKernPairs(
    const VOID  *p1,
    const VOID  *p2
    )

/*++

Routine Description:

    Compares 2 FD_KERNINGPAIR structs according to a key = wcSecond << 16 +
    wcFirst.

Arguments:
    p1, p2 - ptrs to FD_KERNINGPAIRS to compare.

Return Value:

    -1  => p1 < p2
     1  => p1 > p2
     0  => p1 = p2

--*/
{
    FD_KERNINGPAIR *ptr1 = (FD_KERNINGPAIR *) p1;
    FD_KERNINGPAIR *ptr2 = (FD_KERNINGPAIR *) p2;
    ULONG   key1, key2;

    //
    // Compute key for each kern pair.
    //
    key1 = (ptr1->wcSecond << 16) + ptr1->wcFirst;
    key2 = (ptr2->wcSecond << 16) + ptr2->wcFirst;

    if (key1 > key2)
    {
        return(1);
    }
    else if (key2 > key1)
    {
        return(-1);
    }
    else
    {
        return(0);
    }
}

int __cdecl
CmpGlyphRuns(
    const VOID *p1,
    const VOID *p2
    )
/*++

Routine Description:

    Compares the starting Unicode point of two GLYPHRUN structs.

Arguments:

    p1, p2 - GLYPHRUNs to compare.

Return Value:

    -1  => p1 < p2
     1  => p1 > p2
     0  => p1 = p2

--*/
{
    PGLYPHRUN ptr1 = (PGLYPHRUN) p1, ptr2 = (PGLYPHRUN) p2;

    //
    // Compare Unicode code point fields.
    //
    if (ptr1->wcLow > ptr2->wcLow)
        return(1);
    else if (ptr1->wcLow < ptr2->wcLow)
        return(-1);
    else
        return(0);
}

ULONG
CreateGlyphSets(
    PGLYPHSETDATA  *pGlyphSet,
    PWINCODEPAGE    pWinCodePage,
    PULONG         *pUniPs
    )

/*++

Routine Description:

    Create a GLYPHSETDATA data structure, which maps Unicode pts to Windows
    codepage/codepoints.

Arguments:

    pGlyphSet - A PGLYPHSETDATA pointer which upon successful
    completion contains the address of the newly allocated GLYPHSETDATA
    struct.

    pWinCodePage - a pointer to a windows code page info struct
    used to create the GLYPHSETDATA struct.

    pUniPs - Upon successful completion, -> a table which maps 0-based Glyph
    Indices of chars in the GLYPHRUNS of the GLYPHSETDATA struct for this
    charset to indices into the UnicodetoPs structure which maps Unicode
    points to PS char information.

Return Value:

    NULL => error
    Otherwise total size of all GLYPHSETDATAs and related structs which are
    created.

--*/

{
    int             i, j;
    ULONG           c;
    int             cRuns;
    int             cChars;
    int             cCharRun;
    WCHAR           wcLast;
    WCHAR           wcRunStrt;
    PGLYPHSETDATA   pGlyphSetData;
    PGLYPHRUN       pGlyphRuns;
    ULONG           ulSize;
    PVOID           pMapTable;
    PWINCPT         pWinCpt;
    PCODEPAGEINFO   pCodePageInfo;
    BOOLEAN         bFound, bIsPiFont;
    DWORD           dwEncodingNameOffset;
    DWORD           dwGSNameSize, dwCodePageInfoSize, dwCPIGSNameSize, dwGlyphRunSize;
    BOOL            bSingleCodePage;

    bSingleCodePage = (pWinCodePage->usNumBaseCsets == 1) ? TRUE : FALSE;

    ulSize = 0;
    cChars = cRuns = i = 0;

    if ((bIsPiFont = pWinCodePage->pCsetList[0] == CS_SYMBOL))
    {
        //
        // This is a symbol font. We takes care of PS char codes from 0x20 to
        // 0xff. We also map PS char codes to a single run in the Unicode
        // private range.
        //
        cChars = (256 - 32) + 256;
        cRuns = 1 * 2;
        bSingleCodePage = FALSE;
        VERBOSE(("Pi Font"));
    }
    else
    {
        //
        // Process all unicode code pts. to determine the number of Unicode
        // point runs present in this windows codepage.
        //

        do
        {
            //
            // Proceed until the starting codepoint of next run is found.
            //
            // for (j = 0; j < pWinCodePage->usNumBaseCsets &&
            //         i < NUM_PS_CHARS;
            //         j++)
            //     if (CSET_SUPPORT(UnicodetoPs[i].flCharSets, pWinCodePage->pCsetList[j]))
            //         break;
            //     else
            //        i++;
            //
            bFound = FALSE;

            for (; i < NUM_PS_CHARS; i++)
            {
                for (j = 0; j < pWinCodePage->usNumBaseCsets; j++)
                {
                    if (CSET_SUPPORT(UnicodetoPs[i].flCharSets, pWinCodePage->pCsetList[j]))
                    {
                        bFound = TRUE;
                        break;
                    }
                }
                if (bFound)
                    break;
            }

            //
            // Check to see if we've scanned all Unicode points.
            //
            if (i == NUM_PS_CHARS)
                break;

            //
            // Start a new run.
            //
            cCharRun = 0;
            wcRunStrt = UnicodetoPs[i].wcUnicodeid;

            //
            // Chars are only part of the run if they are supported
            // in the current charset.
            //
            while (i < NUM_PS_CHARS &&
                UnicodetoPs[i].wcUnicodeid == wcRunStrt + cCharRun)
            {
                for (j = 0; j < pWinCodePage->usNumBaseCsets; j++)
                {
                    if (CSET_SUPPORT(UnicodetoPs[i].flCharSets, pWinCodePage->pCsetList[j]))
                    {
                        cCharRun++;
                        break;
                    }
                }
                i++;
            }
            if (cCharRun)
            {
                cChars += cCharRun;
                cRuns++;
            }
        } while (i < NUM_PS_CHARS);
    }

    //
    // Compute the total amount of memory required for the GLYPHSETDATA array
    // and all other related data. We need
    // 1. one CODEPAGEINFO struct for each base charset supported by this font,
    // 2. one GLYPHRUN struct for each run, and
    // 3. four bytes per char to store codepage and codepoint or two bytes per
    //    char to store only codepoint for the mapping table.
    //
    dwGSNameSize = ALIGN4(strlen(pWinCodePage->pszCPname) + 1);
    dwCodePageInfoSize = ALIGN4(pWinCodePage->usNumBaseCsets * sizeof (CODEPAGEINFO));
    dwGlyphRunSize = ALIGN4(cRuns * sizeof (GLYPHRUN));

    ulSize = ALIGN4(sizeof(GLYPHSETDATA))
                + dwGSNameSize
                + dwCodePageInfoSize
                + dwGlyphRunSize;

    //
    // Account for the size of the mapping table.
    //
    ulSize += bSingleCodePage ? ALIGN4((cChars * sizeof (WORD))) : (cChars * sizeof (DWORD));

    //
    // Account for the size of CODEPAGE name strings found in CODEPAGEINFO
    // struct(s).
    //
    for (dwCPIGSNameSize = 0, j = 0; j < pWinCodePage->usNumBaseCsets; j++)
    {
        dwCPIGSNameSize += ALIGN4(strlen(aPStoCP[pWinCodePage->pCsetList[j]].pGSName) + 1);
    }
    ulSize += dwCPIGSNameSize;

    //
    // Allocate memory for the GLYPHSETDATA struct.
    //
    if ((pGlyphSetData = (PGLYPHSETDATA) MemAllocZ((size_t) ulSize)) == NULL)
    {
        ERR(("makentf - CreateGlyphSets: malloc\n"));
        return(FALSE);
    }

    //
    // Allocate an array of ULONGs to store the index of each char into
    // the Unicode->Ps translation table.
    //
    if (!bIsPiFont)
    {
        if ((*pUniPs = (PULONG) MemAllocZ((size_t)(cChars * sizeof(ULONG)))) == NULL)
        {
            ERR(("makentf - CreateGlyphSets: malloc\n"));
            return(FALSE);
        }
    }

    //
    // Init GLYPHSETDATA fields.
    //
    pGlyphSetData->dwSize = ulSize;
    pGlyphSetData->dwVersion = GLYPHSETDATA_VERSION;
    pGlyphSetData->dwFlags = 0;
    pGlyphSetData->dwGlyphSetNameOffset = ALIGN4(sizeof(GLYPHSETDATA));
    pGlyphSetData->dwGlyphCount = cChars;
    pGlyphSetData->dwCodePageCount = pWinCodePage->usNumBaseCsets;
    pGlyphSetData->dwCodePageOffset = pGlyphSetData->dwGlyphSetNameOffset + dwGSNameSize;
    pGlyphSetData->dwRunCount = cRuns;
    pGlyphSetData->dwRunOffset = pGlyphSetData->dwCodePageOffset + dwCodePageInfoSize + dwCPIGSNameSize;
    pGlyphSetData->dwMappingTableOffset = pGlyphSetData->dwRunOffset + dwGlyphRunSize;

    //
    // Set the mapping table type flag to dwFlags field.
    //
    pGlyphSetData->dwFlags |= bSingleCodePage ? GSD_MTT_WCC : GSD_MTT_DWCPCC;

    //
    // Store code page name
    //
    strcpy((PSZ) MK_PTR(pGlyphSetData, dwGlyphSetNameOffset), pWinCodePage->pszCPname);

    //
    // Initialize a CODEPAGEINFO struct for each base charset supported
    // by this font.
    //
    pCodePageInfo = (PCODEPAGEINFO) MK_PTR(pGlyphSetData, dwCodePageOffset);
    dwEncodingNameOffset = dwCodePageInfoSize;

    for (j = 0; j < pWinCodePage->usNumBaseCsets; j++, pCodePageInfo++)
    {
        //
        // Save CODEPAGEINFO. We don't use PS encoding vectors.
        //
        pCodePageInfo->dwCodePage = aPStoCP[pWinCodePage->pCsetList[j]].usACP;
        pCodePageInfo->dwWinCharset = (DWORD)aPStoCP[pWinCodePage->pCsetList[j]].jWinCharset;
        pCodePageInfo->dwEncodingNameOffset = dwEncodingNameOffset;
        pCodePageInfo->dwEncodingVectorDataSize = 0;
        pCodePageInfo->dwEncodingVectorDataOffset = 0;

        //
        // Copy codepage name string to end of array of CODEPAGEINFOs.
        //
        strcpy((PBYTE)MK_PTR(pCodePageInfo, dwEncodingNameOffset),
                aPStoCP[pWinCodePage->pCsetList[j]].pGSName);

        //
        // Adjust the offset to the codepage name for the next CODEPAGINFO structure
        //
        dwEncodingNameOffset -= ALIGN4(sizeof (CODEPAGEINFO));
        dwEncodingNameOffset += ALIGN4(strlen((PBYTE)MK_PTR(pCodePageInfo, dwEncodingNameOffset)) + 1);
    }

    //
    // Init ptr to the mapping table.
    //
    pGlyphRuns = GSD_GET_GLYPHRUN(pGlyphSetData);
    pMapTable = GSD_GET_MAPPINGTABLE(pGlyphSetData);

    //
    // Make another pass through the Unicode points to initialize the Unicode
    // runs and gi->codepage/codept mapping array for this codepage.
    //
    cRuns = 0;
    if (bIsPiFont)
    {
        //
        // Glyphset for Pi fonts has 1 run of 256 minus 0x20(it's 0x1f
        // actually) chars over the Unicode private range.
        //
        pGlyphRuns[cRuns].wcLow = NOTDEF1F;
        pGlyphRuns[cRuns].wGlyphCount = 256 - NOTDEF1F;

        pGlyphRuns[cRuns + 1].wcLow = UNICODE_PRV_STRT;
        pGlyphRuns[cRuns + 1].wGlyphCount = 256;

        //
        // We know that Pi fonts support only single encoding, but we also
        // provide the mapping table for Unicode range f000...f0ff, which
        // is mapped to PS code point 00...ff.
        //
        for (i = 0; i < 256 - NOTDEF1F; i++)
        {
            ((DWORD*)pMapTable)[i] =
                aPStoCP[pWinCodePage->pCsetList[0]].usACP << 16 | (i + NOTDEF1F);
        }

        for (i = 0; i < 256; i++)
        {
            ((DWORD*)pMapTable)[i + 256 - NOTDEF1F] =
                aPStoCP[pWinCodePage->pCsetList[0]].usACP << 16 | i;
        }
    }
    else
    {
        cChars = i = 0;
        do
        {
            //
            // Proceed until the starting codepoint of next run is found.
            //
            // for (j = 0; j < pWinCodePage->usNumBaseCsets &&
            //         i < NUM_PS_CHARS;
            //         j++)
            //     if (CSET_SUPPORT(UnicodetoPs[i].flCharSets, pWinCodePage->pCsetList[j]))
            //         break;
            //     else
            //         i++;
            //
            bFound = FALSE;
            for (; i < NUM_PS_CHARS; i++)
            {
                for (j = 0; j < pWinCodePage->usNumBaseCsets; j++)
                {
                    if (CSET_SUPPORT(UnicodetoPs[i].flCharSets, pWinCodePage->pCsetList[j]))
                    {
                        bFound = TRUE;
                        break;
                    }
                }
                if (bFound)
                    break;
            }


            //
            // Check to see if we've scanned all Unicode points.
            //
            if (i == NUM_PS_CHARS)
                break;

            //
            // Start a new run.
            //
            cCharRun = 0;
            wcRunStrt = UnicodetoPs[i].wcUnicodeid;

            //
            // Chars are only part of the run if they are supported
            // in the current charset.
            //
            while (i < NUM_PS_CHARS &&
                    UnicodetoPs[i].wcUnicodeid == wcRunStrt + cCharRun)
            {
                for (j = 0, bFound = FALSE;
                    j < pWinCodePage->usNumBaseCsets && !bFound; j++)
                {
                    if (CSET_SUPPORT(UnicodetoPs[i].flCharSets, pWinCodePage->pCsetList[j]))
                    {
                        if (((pWinCpt =
                            (PWINCPT) bsearch(UnicodetoPs[i].pPsName,
                                                aPStoCP[pWinCodePage->pCsetList[j]].aWinCpts,
                                                aPStoCP[pWinCodePage->pCsetList[j]].ulChCnt,
                                                sizeof(WINCPT),
                                                CmpPsNameWinCpt))
                                                != NULL))
                        {
                            //
                            // Found a corresponding PS char in the current
                            // windows codepage. Save it in the mapping table.
                            //
                            if (bSingleCodePage)
                            {
                                ((WORD*)pMapTable)[cChars] = pWinCpt->usWinCpt;
                            }
                            else
                            {
                                ((DWORD*)pMapTable)[cChars] =
                                    aPStoCP[pWinCodePage->pCsetList[j]].usACP << 16 | pWinCpt->usWinCpt;
                            }
                            bFound = TRUE;
                        }
                        else if (j == (pWinCodePage->usNumBaseCsets - 1))
                        {
                            //
                            // Corresponding PS char was not found. Use Win
                            // codept 0 as .notdef char and base codepage.
                            //
                            if (bSingleCodePage)
                                ((WORD*)pMapTable)[cChars] = 0;
                            else
                                ((DWORD*)pMapTable)[cChars] =
                                    aPStoCP[pWinCodePage->pCsetList[0]].usACP << 16;
                            bFound = TRUE;
                        }

                        //
                        // If char is present in this codepage, save index in
                        // Unicode->Ps table.
                        //
                        if (bFound)
                        {
                            (*pUniPs)[cChars] = i;
                            cChars++;
                            cCharRun++;
                        }
                    }
                }
                i++;
            }
            if (cCharRun)
            {
                pGlyphRuns[cRuns].wcLow = wcRunStrt;
                pGlyphRuns[cRuns].wGlyphCount = (WORD)cCharRun;
                cRuns++;
            }
        } while (i < NUM_PS_CHARS);
    }

    //
    // Return success.
    //
    *pGlyphSet = pGlyphSetData;

    if (bVerbose && !bOptimize)
    {
        printf("GLYPHSETDATA:dwFlags:%08X\n", pGlyphSetData->dwFlags);
        printf("GLYPHSETDATA:dwGlyphSetNameOffset:%s\n",
                    (PSZ)MK_PTR(pGlyphSetData, dwGlyphSetNameOffset));
        printf("GLYPHSETDATA:dwGlyphCount:%ld\n", pGlyphSetData->dwGlyphCount);
        printf("GLYPHSETDATA:dwRunCount:%ld\n", pGlyphSetData->dwRunCount);
        printf("GLYPHSETDATA:dwCodePageCount:%ld\n", pGlyphSetData->dwCodePageCount);
        {
            DWORD dw;
            PCODEPAGEINFO pcpi = (PCODEPAGEINFO)MK_PTR(pGlyphSetData, dwCodePageOffset);
            for (dw = 1; dw <= pGlyphSetData->dwCodePageCount; dw++)
            {
                printf("CODEPAGEINFO#%ld:dwCodePage:%ld\n", dw, pcpi->dwCodePage);
                printf("CODEPAGEINFO#%ld:dwWinCharset:%ld\n", dw, pcpi->dwWinCharset);
                printf("CODEPAGEINFO#%ld:dwEncodingNameOffset:%s\n",
                            dw, (PSZ)MK_PTR(pcpi, dwEncodingNameOffset));
                pcpi++;
            }
        }

        if (bIsPiFont)
        {
            printf("(Single codepage with dwFlags bit 0 cleared.)\n");
            printf("(Special for Symbol glyphset)\n");
        }

        printf("\n");
    }

    return(ulSize);
}

LONG
FindClosestCodePage(
    PWINCODEPAGE    *pWinCodePages,
    ULONG           ulNumCodePages,
    CHSETSUPPORT    chSets,
    PCHSETSUPPORT   pchCsupMatch
    )

/*++

Routine Description:

    Given a list of ptrs to WINCODEPAGE structs, determine which WINCODEPAGE's
    component charsets best match the charsets value in chSets.

Arguments:

    pWinCodePages - List of PWINCODEPAGES.

    ulNumCodePages - Number of entries in pWinCodePages

    chSets - CHSETSUPPORT value which indicates which standard charsets
    are supported by this font.

    pchCsupMatch - Pointer to a CHSETSUPPORT variable which returns the
    supported charsets of the code page which most closely matches the
    chSets value. If no matching codepages are found, the value will be 0.

Return Value:

    -1 => no matching Codepages were found.
    Otherwise this is the index in pWinCodePages of the "best match" codepage.

--*/

{
    ULONG   c;
    LONG    j;
    LONG    cpMatch;
    LONG    nCurCsets, nLastCsets;
    FLONG   flCurCset;

    cpMatch = -1;

    //
    // Scan the list of Windows codepages.
    //
    for (c = 0, nLastCsets = 0; c < ulNumCodePages; c++)
    {
        //
        // Hack..Hack! If this is the Unicode codepage, ignore it as
        // no NTMs should reference it!
        //
        if (strcmp(pWinCodePages[c]->pszCPname, UNICODE_GS_NAME))
        {
            nCurCsets = flCurCset = 0;

            //
            // Determine which charsets in the current codepage are
            // a match for those supported by the current font.
            //
            for (j = 0; j < pWinCodePages[c]->usNumBaseCsets; j++)
            {
                if (CSET_SUPPORT(chSets, pWinCodePages[c]->pCsetList[j]))
                {
                    nCurCsets++;
                }
                flCurCset |= CSUP(pWinCodePages[c]->pCsetList[j]);
            }

            if (flCurCset == (FLONG) chSets)
            {
                //
                // Found a charset which supports ALL of the font's charsets.
                //
                cpMatch = (LONG) c;
                *pchCsupMatch = flCurCset;
                break;
            }
            else if (nCurCsets > nLastCsets)
            {
                //
                // This Windows codepage is the maximal match so far.
                //
                nLastCsets = nCurCsets;
                cpMatch = (LONG) c;
                *pchCsupMatch = flCurCset;
            }
        }
    }

    return(cpMatch);
}

ULONG
GetAFMCharWidths(
    PBYTE           pAFM,
    PWIDTHRUN       *pWidthRuns,
    PPSCHARMETRICS  pFontChars,
    PULONG          pUniPs,
    ULONG           ulChCnt,
    PUSHORT         pusAvgCharWidth,
    PUSHORT         pusMaxCharWidth

    )
/*++

Routine Description:

    Given a memory mapped AFM file ptr and a ptr to a which maps glyph indices
    to UPSCODEPT Unicode->Ps translation structs, fill memory with a list of
    WIDTHRUN structs which provide char width information.

Arguments:

    pAFM - Pointer to memory mapped AFM file.

    pWidthRuns - If NULL, this is a size request and the function returns the
    total size in bytes of all WIDTHRUN structs required for this font.
    Otherwise the ptr is assumed to point to a buffer large enough to
    hold the number of required WIDTHRUNs.

    pFontChars - pointer a table of PS font char metrics info previously
    created by calling the BuildPSCharMetrics function. This array contains
    per char metric information.

    pUniPs - Points to a table which maps 0-based Glyph Indices of chars
    in the GLYPHRUNS of the GLYPHSETDATA struct for this font to indices
    into the UnicodetoPs structure which maps Unicode points to PS char
    information. This mapping array is created by the CreateGlyphSet function
    defined in this module.

    ulChCnt - Number of chars in the GLYPHSET for this font. This most likely
    is not the same as the number of chars defined in the font's AFM.

    pulAvgCharWidth - pts to a USHORT used to return the average char
    width of the font. If NULL the average char width is not returned.

    pulMaxCharWidth - pts to a USHORT used to return the max char
    width of the font. If NULL the max char width is not returned.

Return Value:

    0 => error.
    Otherwise returns number of WIDTHRUN structs required for this font.

--*/

{
    ULONG i, j, curChar;
    int cRuns, cRealRuns;
    int cChars;
    int cCharRun;
    ULONG firstCharWidth;
    ULONG curCharWidth;
    ULONG notdefwidth;
    WCHAR wcRunStrt;
    USHORT  chCnt;
    PBYTE   pToken;
    PBYTE   pChMet;
    PPSCHARMETRICS pCurChar;
    BOOLEAN bIsPiFont, bIsCJKFont;
    CHAR    ch;
    BYTE    CharNameBuffer[32];
    PBYTE   pChName;
    // fix bug 240339, jjia, 8/3/98
    BOOLEAN bWidthRunComplex;
    PWORD   pWidthArray;
    // Fixed bug Adobe #367195.
    // In this program, when handling PiFont, we always assume the first character 
    // in the CharMetrics is a space (32) char. However, some special font such as 
    // HoeflerText-Ornaments does not follow this rule. the 1st char in the font is 9, 
    // the 2ed char is 32. Added this flag to handle this kind of fonts.
    BOOLEAN bTwoSpace = FALSE;

    //
    // Determine if this is a Pi or CJK font.
    //
    bIsPiFont = IsPiFont(pAFM);
    bIsCJKFont = (IsCJKFont(pAFM) != 0);

    //
    // Get ptr to AFM char metrics.
    //
    pChMet = FindAFMToken(pAFM, PS_CH_METRICS_TOK);
    if (pChMet == NULL)    // Fixed bug 354007
        return (FALSE);

    //
    // Current pos should be the character count field.
    //
    for (i = 0; i < (int) StrLen(pChMet); i++)
    {
        if (!IS_NUM(&pChMet[i]))
        {
            return(FALSE);
        }
    }
    chCnt = (USHORT)atoi(pChMet);
    (ULONG_PTR) pChMet += i;

    //
    // If requested, make a pass through the PS Char Metrics to determine
    // the max char width.
    //
    if (pusMaxCharWidth != NULL)
    {
        *pusMaxCharWidth = 0;
        for (i = 0; i < chCnt; i++)
        {
            if (pFontChars[i].chWidth > *pusMaxCharWidth)
            {
                *pusMaxCharWidth = (USHORT) pFontChars[i].chWidth & 0xffff;
            }
        }
    }

    //
    // Search for .notdef char in list of PS chars, get .notdef char width.
    //
    if (bIsPiFont)
    {
        notdefwidth = pFontChars[0].chWidth;
    }
    else if ((pCurChar = (PPSCHARMETRICS) bsearch("space",
                                            pFontChars[0].pPsName,
                                            (size_t) chCnt,
                                            sizeof(PSCHARMETRICS),
                                            strcmp)) != NULL)
        notdefwidth = pCurChar->chWidth;
    else
        notdefwidth = 0;

    //
    // If average width was requested, process string of sample chars 1
    // at a time to compute average char width.
    // DCR --: Assume the sample is western alphabetic + space.
    // Need to fix this for non-western fonts !!!.
    //
    if (pusAvgCharWidth != NULL)
    {

        LONG    lWidth, count;  // a long to prevent OverFlow
        WINCPTOPS           *pCPtoPS;
        WINCPT              sortedWinCpts[MAX_CSET_CHARS]; // maxiaml 255 chars
        CHSETSUPPORT flCsupGlyphSet;
        ULONG   k;
        BYTE    *pSampleStr;


        //
        // Determine which charsets this font supports.
        //
        (VOID)GetAFMCharSetSupport(pAFM, &flCsupGlyphSet);
        if (flCsupGlyphSet == CS_228 || flCsupGlyphSet == CS_314)
        {
            pCPtoPS = &aPStoCP[CS_228];
        }
        else
        {
            // default - use the ANSI code page table
            pCPtoPS = &aPStoCP[CS_ANSI];
        }

        SortWinCPT(&(sortedWinCpts[0]), pCPtoPS);

        lWidth = 0;
        count = 0;
        k = 0x20; // start from FirstChar !!
        for (i = 0; i < pCPtoPS->ulChCnt && k <= 0xFF; i++, k++)
        {

            pCurChar = NULL;

            if (bIsPiFont)
            {
                if (i<chCnt)
                    pCurChar = &(pFontChars[ i ]);
                // We don't need Not-Encoded characters in a PiFont.
                if (pCurChar && strcmp(pCurChar->pPsName, "-1") == 0 )
                    pCurChar = NULL;
            }
            else
            {
                // sortedWinCpts is sorted by usWinCpt, so skip UP to what we want
                while (k > sortedWinCpts[i].usWinCpt && i < pCPtoPS->ulChCnt )
                {
                    i++;
                }

                // Take notdef chars in the 0x20 to 0xff range - gaps
                while (k < sortedWinCpts[i].usWinCpt && k <= 0xFF )
                {
                    k++;
                    lWidth += notdefwidth;
                    count++;
                }

                pSampleStr = NULL;
                if (k == sortedWinCpts[i].usWinCpt)
                    pSampleStr = sortedWinCpts[i].pPsName;
                if (pSampleStr == NULL)
                    continue;

                pCurChar = (PPSCHARMETRICS) bsearch(pSampleStr,
                                                        pFontChars[0].pPsName,
                                                        (size_t) chCnt,
                                                        sizeof(PSCHARMETRICS),
                                                        strcmp);
            }

            if (pCurChar != NULL && pCurChar->pPsName && pCurChar->pPsName[0] != 0 &&
                pCurChar->chWidth > 0)
            {
                lWidth += (LONG) pCurChar->chWidth;
                count++;
            }
            else
            {
                lWidth += notdefwidth;
                count++;
            }
        }

        if (count)
            lWidth = (lWidth + count/2)/count;

        if (lWidth == 0)
        {
            lWidth = 0 ;
            // This is a buggy font.  Or CJK font!!!
            // In this case we must come up with the reasonable number different from
            // zero. This number is used in computing font trasfroms.
            for (i = 0; i <= chCnt; i++)
                lWidth += (LONG) (pFontChars[i].chWidth & 0xffff);

            lWidth =  (lWidth + chCnt / 2) / chCnt ;

            // ASSERTMSG(*pusAvgCharWidth, ("PSCRIPT: pifi->fwdAveCharWidth == 0\n"));
        }

        // Now assign it to the original (short) width
        *pusAvgCharWidth = (FWORD) lWidth;


        if (*pusAvgCharWidth == 0 || (bIsCJKFont && *pusAvgCharWidth < EM))
        {
            *pusAvgCharWidth = EM;
        }
        if (bIsCJKFont)
        {
            // DCR: couldn't divide by 2 simply for C and K.
            *pusAvgCharWidth = *pusAvgCharWidth / 2;
        }
    }

    //
    // Determine the amount of memory required for the WIDTHRUNS which cover
    // all possible points in the font's charset.
    //
    i = cRuns = 0;
    if (bIsPiFont)
    {
        curChar = 1;
        if (atoi(pFontChars[i].pPsName) == (BYTE) ' ')
        {
            curCharWidth = pFontChars[i].chWidth;
        }
        else
        {
            // Fixed bug Adobe #367195  
            if (atoi(pFontChars[i + 1].pPsName) == (BYTE) ' ')
                bTwoSpace = TRUE;
         
            curCharWidth = notdefwidth;
        }
    }
    else
    {
        //
        // Setup ptr to "char name" based on whether this is a
        // western or CJK font.
        //
        if (bIsCJKFont)
        {
            _ultoa(pUniPs[i], CharNameBuffer, 10);
            pChName = CharNameBuffer;
        }
        else
        {
            pChName = UnicodetoPs[pUniPs[i]].pPsName;
        }

        if ((pCurChar = (PPSCHARMETRICS) bsearch(pChName,
                                               pFontChars,
                                                (size_t) chCnt,
                                                sizeof(PSCHARMETRICS),
                                                CmpPsChars)) == NULL)
        {
            curCharWidth = notdefwidth;
        }
        else
        {
            curCharWidth = pCurChar->chWidth;
        }
    }
    do
    {
        //
        // Start new run.
        //
        cCharRun = 1;
        wcRunStrt = (USHORT) (i & 0xffff);

        for (firstCharWidth = curCharWidth, i++; i < ulChCnt; i++)
        {
            if (bIsPiFont)
            {
                if (curChar < chCnt)
                {
                    // Fixed bug Adobe #367185
                    if ((bTwoSpace) &&
                        ((ULONG) atoi(pFontChars[curChar].pPsName) == (i - 1 + (BYTE) ' ')))
                    {
                        curCharWidth = pFontChars[curChar].chWidth;
                        curChar++;
                    }
                    else if ((!bTwoSpace) &&
                        ((ULONG) atoi(pFontChars[curChar].pPsName) == (i + (BYTE) ' ')))
                    {
                        curCharWidth = pFontChars[curChar].chWidth;
                        curChar++;
                    }
                    else
                    {
                        curCharWidth = notdefwidth;
                    }
                }
                else
                {
                    curCharWidth = notdefwidth;
                }

            }
            else
            {
                //
                // Setup ptr to "char name" based on whether this is a
                // western or CJK font.
                //
                if (bIsCJKFont)
                {
                    _ultoa(pUniPs[i], CharNameBuffer, 10);
                    pChName = CharNameBuffer;
                }
                else
                {
                    pChName = UnicodetoPs[pUniPs[i]].pPsName;
                }
                if((pCurChar = (PPSCHARMETRICS) bsearch(pChName,
                                                           pFontChars,
                                                            (size_t) chCnt,
                                                            sizeof(PSCHARMETRICS),
                                                            CmpPsChars)) != NULL)
                {
                    curCharWidth = pCurChar->chWidth;
                }
                else
                {
                    curCharWidth = notdefwidth;
                }
            }
            if ((curCharWidth == firstCharWidth) &&
                    ((SHORT) i == (wcRunStrt + cCharRun)))
            {
                cCharRun++;
            }
            else
            {
                break;
            }
        }
        cRuns++;
    } while (i < ulChCnt);

    // Fix bug 240339, jjia, 8/3/98
    if ((cRuns * sizeof(WIDTHRUN)) >
        (ulChCnt * sizeof(WORD) + sizeof(WIDTHRUN)))
        bWidthRunComplex = TRUE;
    else
        bWidthRunComplex = FALSE;

    if (pWidthRuns == NULL)
    {
        //
        // Return number of WIDTHRUNs only.
        //
        if (!bIsPiFont)
        {
            // Fix bug 240339, jjia, 8/3/98
            if (bWidthRunComplex)
                return (ALIGN4(ulChCnt * sizeof(WORD) + sizeof(WIDTHRUN)));
            else
                return (ALIGN4(cRuns * sizeof(WIDTHRUN)));
        }
        else
        {
            //
            // Hack to support 2 Unicode runs.
            //
            return (ALIGN4(cRuns * 2 * sizeof(WIDTHRUN)));

        }
    }

    //
    // Create the list of WIDTHRUNs.
    //
    cRealRuns = cRuns;
    i = cRuns = 0;

    // Fix bug 240339, jjia, 8/3/98
    if (bWidthRunComplex && (!bIsPiFont))
    {
        (*pWidthRuns)[0].wStartGlyph = (WORD) (i & 0xffff);
        (*pWidthRuns)[0].dwCharWidth = WIDTHRUN_COMPLEX;
        (*pWidthRuns)[0].wGlyphCount = (WORD)ulChCnt;
        cRuns = 1;
        pWidthArray = (PWORD)&(*pWidthRuns)[1];

        for (; i < ulChCnt; i++)
        {
            if (bIsCJKFont)
            {
                _ultoa(pUniPs[i], CharNameBuffer, 10);
                pChName = CharNameBuffer;
            }
            else
            {
                pChName = UnicodetoPs[pUniPs[i]].pPsName;
            }
            if((pCurChar = (PPSCHARMETRICS) bsearch(pChName,
                                                    pFontChars,
                                                    (size_t) chCnt,
                                                    sizeof(PSCHARMETRICS),
                                                    CmpPsChars)) == NULL)
            {
                //
                // Char is not defined in this font.
                //
                pWidthArray[i] = (WORD)notdefwidth;
            }
            else
            {
                //
                // Char is defined in this font.
                //
                pWidthArray[i] = (WORD)(pCurChar->chWidth);
            }
        }
        return (cRuns);
    }


    if (bIsPiFont)
    {
        curChar = 1;
        if (atoi(pFontChars[i].pPsName) == (BYTE) ' ')
        {
            curCharWidth = pFontChars[i].chWidth;
        }
        else
        {
            // Fixed bug Adobe #367195  
            if (atoi(pFontChars[i + 1].pPsName) == (BYTE) ' ')
                bTwoSpace = TRUE;

            curCharWidth = notdefwidth;
        }
    }
    else
    {
        //
        // Setup ptr to "char name" based on whether this is a
        // western or CJK font.
        //
        if (bIsCJKFont)
        {
            _ultoa(pUniPs[i], CharNameBuffer, 10);
            pChName = CharNameBuffer;
        }
        else
        {
            pChName = UnicodetoPs[pUniPs[i]].pPsName;
        }
        if ((pCurChar = (PPSCHARMETRICS) bsearch(pChName,
                                                   pFontChars,
                                                    (size_t) chCnt,
                                                    sizeof(PSCHARMETRICS),
                                                    CmpPsChars)) != NULL)
        {
            curCharWidth = pCurChar->chWidth;
        }
        else
        {
            curCharWidth = notdefwidth;
        }
    }

    do
    {
        //
        // Start new run.
        //
        cCharRun = 1;
        wcRunStrt = (USHORT) (i & 0xffff);
        for (firstCharWidth = curCharWidth, i++; i < ulChCnt; i++)
        {
            if (bIsPiFont)
            {
                if (curChar < chCnt)
                {
                    // Fixed bug Adobe #367185
                    if ((bTwoSpace) &&
                        ((ULONG) atoi(pFontChars[curChar].pPsName) == (i - 1 + (BYTE) ' ')))
                    {
                        curCharWidth = pFontChars[curChar].chWidth;
                        curChar++;
                    }
                    else if ((!bTwoSpace) &&
                        ((ULONG) atoi(pFontChars[curChar].pPsName) == (i + (BYTE) ' ')))
                    {
                        curCharWidth = pFontChars[curChar].chWidth;
                        curChar++;
                    }
                    else
                    {
                        curCharWidth = notdefwidth;
                    }
                }
                else
                {
                    curCharWidth = notdefwidth;
                }

            }
            else
            {
                //
                // Setup ptr to "char name" based on whether this is a
                // western or CJK font.
                //
                if (bIsCJKFont)
                {
                    _ultoa(pUniPs[i], CharNameBuffer, 10);
                    pChName = CharNameBuffer;
                }
                else
                {
                    pChName = UnicodetoPs[pUniPs[i]].pPsName;
                }
                if((pCurChar = (PPSCHARMETRICS) bsearch(pChName,
                                                       pFontChars,
                                                        (size_t) chCnt,
                                                        sizeof(PSCHARMETRICS),
                                                        CmpPsChars)) == NULL)
                {
                    //
                    // Char is not defined in this font.
                    //
                    curCharWidth = notdefwidth;
                }
                else
                {
                    //
                    // Char is defined in this font.
                    //
                    curCharWidth = pCurChar->chWidth;
                }
            }
            if ((curCharWidth == firstCharWidth) &&
                ((SHORT) i == (wcRunStrt + cCharRun)))
            {
                cCharRun++;
            }
            else
            {
                break;
            }
        }
        (*pWidthRuns)[cRuns].wStartGlyph = wcRunStrt;
        (*pWidthRuns)[cRuns].dwCharWidth = firstCharWidth;
        (*pWidthRuns)[cRuns].wGlyphCount = (WORD)cCharRun;
        if (bIsPiFont)
        {
            //
            // Hack to support 2 unicode runs.
            //
            (*pWidthRuns)[cRuns + cRealRuns].wStartGlyph = wcRunStrt;
            (*pWidthRuns)[cRuns + cRealRuns].dwCharWidth = firstCharWidth;
            (*pWidthRuns)[cRuns + cRealRuns].wGlyphCount = (WORD)cCharRun;
        }
        cRuns++;
    } while (cRuns < cRealRuns);


    if (bIsPiFont)
    {
        return(cRuns * 2);
    }
    else
    {
        return(cRuns);
    }
}

ULONG
GetAFMETM(
    PBYTE           pAFM,
    PPSCHARMETRICS  pFontChars,
    PETMINFO        pEtmInfo
    )
/*++

Routine Description:

    Given a memory mapped AFM file ptr and a ptr to a which maps glyph indices
    to UPSCODEPT Unicode->Ps translation structs, fill memory with a list of
    WIDTHRUN structs which provide char width information.

Arguments:

    pAFM - Pointer to memory mapped AFM file.

    pFontChars - pointer a table of PS font char metrics info previously
    created by calling the BuildPSCharMetrics function. This array contains
    per char metric information.

    pulEtmInfo - pts to an ETMINFO struct used to return EXTEXTMETRIC
    info which must be derived from the AFM char metrics. If NULL the
    structure is not returned.

Return Value:

    0 => error.
    1 => success

--*/

{
    ULONG i;
    USHORT  chCnt;
    PPSCHARMETRICS pCurChar;
    BOOLEAN bIsPiFont;
    CHSETSUPPORT csIsCJKFont;
    PBYTE   pChMet;
    PSTR    pCJKCapH, pCJKx;

    //
    // Determine if this is a Pi or CJK font.
    //
    bIsPiFont = IsPiFont(pAFM);
    csIsCJKFont = IsCJKFont(pAFM);

    //
    // Get ptr to AFM char metrics.
    //
    pChMet = FindAFMToken(pAFM, PS_CH_METRICS_TOK);
    if (pChMet == NULL)    // Fixed bug 354007
        return (FALSE);

    //
    // Current pos should be the character count field.
    //
    for (i = 0; i < (int) StrLen(pChMet); i++)
    {
        if (!IS_NUM(&pChMet[i]))
        {
            return(FALSE);
        }
    }
    chCnt = (USHORT)atoi(pChMet);
    (ULONG_PTR) pChMet += i;

    //
    // Get EXTEXTMETRIC info if requested.
    //
    if (pEtmInfo != NULL)
    {
        if (bIsPiFont)
        {
            //
            // For Pi Fonts, chars are indexed by char code.
            //

            if ((BYTE) CAP_HEIGHT_CH - (BYTE) ' ' < chCnt)
                pCurChar = &(pFontChars[(BYTE) CAP_HEIGHT_CH - (BYTE) ' ']);
            else
                pCurChar = NULL;  // default to 0 CapHeight

        }
        else
        {
            if (!csIsCJKFont)
            {
                pCurChar = (PPSCHARMETRICS) bsearch(CAP_HEIGHT_CHAR,
                                                    pFontChars[0].pPsName,
                                                    (size_t) chCnt,
                                                    sizeof(PSCHARMETRICS),
                                                    strcmp);
            }
            else
            {
                // We need CID of "H" in CJK
                if (csIsCJKFont & (CSUP(CS_CHINESEBIG5) | CSUP(CS_GB2312)))
                    pCJKCapH = "853";
                else if (csIsCJKFont & (CSUP(CS_SHIFTJIS) | CSUP(CS_SHIFTJIS83)))
                    pCJKCapH = "271";
                else if (csIsCJKFont & (CSUP(CS_HANGEUL) | CSUP(CS_JOHAB)))
                    pCJKCapH = "8134";
                else
                    pCJKCapH = CAP_HEIGHT_CHAR;

                pCurChar = (PPSCHARMETRICS) bsearch(pCJKCapH,
                                                    pFontChars[0].pPsName,
                                                    (size_t) chCnt,
                                                    sizeof(PSCHARMETRICS),
                                                    strcmp);
            }
        }

        if (pCurChar != NULL)
        {
            pEtmInfo->etmCapHeight = (USHORT) pCurChar->rcChBBox.top & 0xffff;
        }
        else
        {
            pEtmInfo->etmCapHeight = 0;
        }

        if (bIsPiFont)
        {
            //
            // For Pi Fonts, chars are indexed by char code.
            //
            if ((BYTE) X_HEIGHT_CH - (BYTE) ' ' < chCnt)
                pCurChar = &(pFontChars[(BYTE) X_HEIGHT_CH - (BYTE) ' ']);
            else
                pCurChar = NULL;  // default to 0
        }
        else
        {
            if (!csIsCJKFont)
            {
                pCurChar = (PPSCHARMETRICS) bsearch(X_HEIGHT_CHAR,
                                                    pFontChars[0].pPsName,
                                                    (size_t) chCnt,
                                                    sizeof(PSCHARMETRICS),
                                                    strcmp);
            }
            else
            {
                // We need CID of "x" in CJK
                if (csIsCJKFont & (CSUP(CS_CHINESEBIG5) | CSUP(CS_GB2312)))
                    pCJKx = "901";
                else if (csIsCJKFont & (CSUP(CS_SHIFTJIS) | CSUP(CS_SHIFTJIS83)))
                    pCJKx = "319";
                else if (csIsCJKFont & (CSUP(CS_HANGEUL) | CSUP(CS_JOHAB)))
                    pCJKx = "8182";
                else
                    pCJKx = X_HEIGHT_CHAR;

                pCurChar = (PPSCHARMETRICS) bsearch(pCJKx,
                                                    pFontChars[0].pPsName,
                                                    (size_t) chCnt,
                                                    sizeof(PSCHARMETRICS),
                                                    strcmp);
            }
        }

        if (pCurChar != NULL)
        {
            pEtmInfo->etmXHeight = (USHORT) pCurChar->rcChBBox.top & 0xffff;
        }
        else
        {
            pEtmInfo->etmXHeight = 0;
        }

        if (bIsPiFont)
        {
            //
            // For Pi Fonts, chars are indexed by char code.
            //
            if ((BYTE) LWR_ASCENT_CH - (BYTE) ' ' < chCnt)
                pCurChar = &(pFontChars[(BYTE) LWR_ASCENT_CH - (BYTE) ' ']);
            else
                pCurChar = NULL;  // default to 0
        }
        else
        {
            pCurChar = (PPSCHARMETRICS) bsearch(LWR_ASCENT_CHAR,
                                                pFontChars[0].pPsName,
                                                (size_t) chCnt,
                                                sizeof(PSCHARMETRICS),
                                                strcmp);
        }

        if (pCurChar != NULL)
        {
            pEtmInfo->etmLowerCaseAscent = (USHORT) pCurChar->rcChBBox.top & 0xffff;
        }
        else
        {
            pEtmInfo->etmLowerCaseAscent = 0;
        }

        if (bIsPiFont)
        {
            //
            // For Pi Fonts, chars are indexed by char code.
            //
            if ((BYTE) LWR_DESCENT_CH - (BYTE) ' '  < chCnt)
                pCurChar = &(pFontChars[(BYTE) LWR_DESCENT_CH - (BYTE) ' ']);
            else
                pCurChar = NULL;  // default to 0
        }
        else
        {
            pCurChar = (PPSCHARMETRICS) bsearch(LWR_DESCENT_CHAR,
                                                pFontChars[0].pPsName,
                                                (size_t) chCnt,
                                                sizeof(PSCHARMETRICS),
                                                strcmp);
        }

        if (pCurChar != NULL)
        {
            pEtmInfo->etmLowerCaseDescent = (USHORT) pCurChar->rcChBBox.bottom & 0xffff;
        }
        else
        {
            pEtmInfo->etmLowerCaseDescent = 0;
        }
    }

    return TRUE;

}

ULONG
GetAFMKernPairs(
    PBYTE           pAFM,
    FD_KERNINGPAIR  *pKernPairs,
    PGLYPHSETDATA   pGlyphSetData
    )

/*++

Routine Description:

    Given a memory mapped AFM file ptr and a ptr to a GLYPHSETDATA which
    describes the supported charset for the font, fill memory with a list of
    FD_KERNINGPAIR structs which provide pair kerning information.

Arguments:

    pAFM - Pointer to memory mapped AFM file.

    pKernPairs - If NULL, this is a size request and the function returns the
    total size in bytes of all FD_KERNINGPAIR structs required for this font.
    Otherwise the ptr is assumed to point to a buffer large enough to
    hold the number of required FD_KERNINGPAIRs.

    pGlyphSetData - Points to a GLYPHSETDATA structure which describes the
    Unicode->code point mappings for the charset to be used with this font.

Return Value:

    0 => no kerning.
    Otherwise returns number of FD_KERNINGPAIR structs required for this font.

--*/

{
    PBYTE       pKernData;
    PBYTE       pToken;
    PUPSCODEPT  pKernStrtChar, pKernEndChar;
    PGLYPHRUN   pGlyphRuns;
    ULONG       i, cMaxKernPairs, cKernPairs;
    BOOLEAN     bFound;

    //
    // for the time being, no kerning for Pi or CJK fonts.
    //
    if (IsPiFont(pAFM) || IsCJKFont(pAFM))
    {
        return(FALSE);
    }

    //
    // Is there kerning info for this font?
    //
    if ((pKernData = FindAFMToken(pAFM, PS_KERN_DATA_TOK)) == NULL)
    {
        //
        // There is no kerning info for this font.
        //
        return(FALSE);
    }

    //
    // Get ptr to AFM kerning data.
    //
    if ((pKernData = FindAFMToken(pAFM, PS_NUM_KERN_PAIRS_TOK)) == NULL)
    {
        //
        // There is no kerning info for this font.
        //
        return(FALSE);
    }

    //
    // Current pos should be the kern pair count field.
    //
    for (i = 0; i < (int) StrLen(pKernData); i++)
    {
        if (!IS_NUM(&pKernData[i]))
        {
            return(FALSE);
        }
    }
    cMaxKernPairs = atoi(pKernData);
    NEXT_LINE(pKernData);
    cKernPairs = 0;
    pGlyphRuns = (PGLYPHRUN) (MK_PTR(pGlyphSetData, dwRunOffset));

    //
    // Get the kern pairs from the AFM.
    //
    do
    {
        PARSE_TOKEN(pKernData, pToken);

        if (!StrCmp(pToken, PS_KERN_PAIR_TOK))
        {
            //
            // Kern pair token found. Get Unicode id for start and end
            // chars. Determine if these chars are supported in the
            // charset to be used with the current font.
            //
            if((pKernStrtChar = (PUPSCODEPT) bsearch(pKernData,
                                                       PstoUnicode,
                                                        (size_t) NUM_PS_CHARS,
                                                        sizeof(UPSCODEPT),
                                                        CmpUnicodePsNames)) == NULL)
            {
                //
                // No Unicode code pt for this char.
                //
                break;
            }

            //
            // Determine if the char is present in the Unicode runs for
            // this glyphset.
            //
            bFound = FALSE;
            for (i = 0; i < pGlyphSetData->dwRunCount &&
                    pKernStrtChar->wcUnicodeid >= pGlyphRuns[i].wcLow &&
                    !bFound;
                    i++)
            {
                bFound =
                    pKernStrtChar->wcUnicodeid <
                        pGlyphRuns[i].wcLow + pGlyphRuns[i].wGlyphCount;
            }

            if (!bFound)
            {
                //
                // Char is not supported, so ignore this kern pair.
                //
                NEXT_LINE(pKernData);
                break;
            }

            //
            // Get the 2nd char in the kern pair.
            //
            PARSE_TOKEN(pKernData, pToken);

            //
            // Determine if the 2nd char is supported in this charset.
            //
            if((pKernEndChar = (PUPSCODEPT) bsearch(pKernData,
                                                       PstoUnicode,
                                                        (size_t) NUM_PS_CHARS,
                                                        sizeof(UPSCODEPT),
                                                        CmpUnicodePsNames)) == NULL)
            {
                //
                // No Unicode code pt for this char.
                //
                break;
            }

            //
            // Determine if the char is present in the Unicode runs for
            // this glyphset.
            //
            bFound = FALSE;
            for (i = 0; i < pGlyphSetData->dwRunCount &&
                    pKernEndChar->wcUnicodeid >= pGlyphRuns[i].wcLow &&
                    !bFound;
                    i++)
            {
                bFound =
                    pKernEndChar->wcUnicodeid <
                        pGlyphRuns[i].wcLow + pGlyphRuns[i].wGlyphCount;
            }

            if (!bFound)
            {
                //
                // Char is not supported, so ignore this kern pair.
                //
                NEXT_LINE(pKernData);
                break;
            }

            //
            // Account for another kern pair.
            //
            if (pKernPairs != NULL)
            {
                pKernPairs[cKernPairs].wcFirst = pKernStrtChar->wcUnicodeid;
                pKernPairs[cKernPairs].wcSecond = pKernEndChar->wcUnicodeid;
                PARSE_TOKEN(pKernData, pToken);
                pKernPairs[cKernPairs].fwdKern = (FWORD)atoi(pKernData);
            }
            cKernPairs++;
        }
        else if (!StrCmp(pToken, PS_EOF_TOK) ||
            !StrCmp(pToken, PS_END_KERN_PAIRS_TOK))
        {
            break;
        }
        NEXT_TOKEN(pKernData);
    } while (cKernPairs < cMaxKernPairs);

    if (pKernPairs != NULL)
    {
        //
        // Sort kerning pairs by key = wcSecond << 16 + wcFIrst.
        //
        qsort(pKernPairs, (size_t) cKernPairs, (size_t) sizeof(FD_KERNINGPAIR),
            CmpKernPairs);

        //
        // Array of kerning pairs is terminated by a FD_KERNINGPAIR with
        // all fields set to 0.
        //
        pKernPairs[cKernPairs].wcFirst = 0;
        pKernPairs[cKernPairs].wcSecond = 0;
        pKernPairs[cKernPairs].fwdKern = 0;
    }
    return(cKernPairs);
}

ULONG
BuildPSFamilyTable(
    PBYTE   pDatFile,
    PTBL    *pPsFamilyTbl,
    ULONG   ulFileSize
)
/*++

Routine Description:

    Builds a table of PSFAMILYINFO structs from a text file of font info.
    The table is sorted in family name sequence. See the file PSFAMILY.DAT
    for info on the input file format.

Arguments:

    pDatFile - Ptr to memory mapped file image of .DAT file.

    pPsFamilyTbl - Ptr to memory to contain a ptr to a table of PSFAMILYINFO
    structs, which will be sorted in sFamilyName order.

    ulFileSize - size in bytes of memory mapped file stream.

Return Value:

    Number of entries in newly created table pointed to by *pPsFamilyTbl.
    0 => error

--*/
{
    USHORT  cFams;
    ULONG   i, j;
    CHAR    pFamilyType[CHAR_NAME_LEN];
    CHAR    pPitchType[CHAR_NAME_LEN];
    CHAR    *pStartLine;
    ULONG   cNameSize, cEngFamilyNameSize;
    ULONG   cFamilyTypeSize, cFamilyNameSize;
    ULONG   cDelimiters;
    PPSFAMILYINFO pPsFontFamMap;

    //
    // Make a pass through the file to determine number of families.
    //
    i = 0;
    cFams = 0;
    do
    {
        cDelimiters = 0;
        //
        // Skip leading whitespace.
        //
        while (IS_WHTSPACE(&pDatFile[i]) && i < ulFileSize)
            i++;

        //
        // We're at start of new line. If this is a comment, skip
        // this line.
        //
        if (IS_COMMENT(&pDatFile[i]))
            while (i <= ulFileSize && !EOL(&pDatFile[i]))
                i++;

        while (!EOL(&pDatFile[i]) && i < ulFileSize)
        {
            //
            // Search for lines with 3 ':' delimiters.
            //
            if (pDatFile[i++] == ':')
            {
                cDelimiters++;
            }
        }
        if (cDelimiters >= 3)
        {

            //
            // Found another family name mapping.
            //
            cFams++;
        }
    } while (i < ulFileSize);

    //
    // Allocate memory for family info table.
    //
    if ((*pPsFamilyTbl =
        (PTBL) MemAllocZ((size_t) (cFams * sizeof(PSFAMILYINFO)) + sizeof(TBL))) == NULL)
        return(FALSE);
    (*pPsFamilyTbl)->pTbl = (PVOID) ((ULONG_PTR) *pPsFamilyTbl + sizeof(TBL));
    pPsFontFamMap = (PPSFAMILYINFO) ((*pPsFamilyTbl)->pTbl);

    //
    // Parse file again, building table of PSFAMILYINFOs.
    //
    i = 0;
    cFams = 0;
    do
    {
        //
        // Skip leading whitespace.
        //
        while (IS_WHTSPACE(&pDatFile[i]) && i < ulFileSize)
            i++;

        //
        // We're at start of new line. If this is a comment, skip
        // this line.
        //
        if (IS_COMMENT(&pDatFile[i]))
            while (i <= ulFileSize && !EOL(&pDatFile[i]))
                i++;
        else
            pStartLine = &pDatFile[i];

        while (!EOL(&pDatFile[i]) && i < ulFileSize)
            //
            // Search for lines with 3 ':' delimiters.
            //
            if (pDatFile[i++] == ':')
            {
                //
                // Check for English family name mapping.
                //
                if (pDatFile[i] == ':')
                {
                    cEngFamilyNameSize = 0;
                }
                else if ((cEngFamilyNameSize = StrPos(&pDatFile[i], ':')) == -1)
                {
                    //
                    // No more delimeters on this line, skip it.
                    //
                    i += StrLen(&pDatFile[i]);
                    break;
                }

                i += cEngFamilyNameSize + 1;

                //
                // Check for another family name mapping. If present, build
                // a FAMILYINFO struct for it.
                //
                if ((cFamilyNameSize = StrPos(&pDatFile[i], ':')) == -1)
                {
                    //
                    // No more delimeters on this line, skip it.
                    //
                    i += StrLen(&pDatFile[i]);
                    break;
                }

                i +=  cFamilyNameSize + 1;

                //
                // Check for font family type name
                //
                if ((cFamilyTypeSize = StrPos(&pDatFile[i], ':')) != -1)
                {
                    i +=  cFamilyTypeSize + 1;
                }
                else
                {
                    cFamilyTypeSize = 0;
                }

                //
                // Make sure there are still chars for Win family type name
                // or pitch name.
                //
                if (EOL(&pDatFile[i]) || i >= ulFileSize)
                {
                    //
                    // Just ran out of file buffer.
                    //
                    break;
                }

                //
                // Get the font and family names.
                //
                cNameSize = StrPos(pStartLine, ':');
                memcpy(pPsFontFamMap[cFams].pFontName, pStartLine, cNameSize);
                pPsFontFamMap[cFams].pFontName[cNameSize] = '\0';
                pStartLine += cNameSize + 1;

                if (cEngFamilyNameSize)
                {
                    memcpy(pPsFontFamMap[cFams].pEngFamilyName, pStartLine, cEngFamilyNameSize);
                    pPsFontFamMap[cFams].pEngFamilyName[cEngFamilyNameSize] = '\0';
                }
                pStartLine += cEngFamilyNameSize + 1;

                memcpy(pPsFontFamMap[cFams].FamilyKey.pName, pStartLine, cFamilyNameSize);
                pPsFontFamMap[cFams].FamilyKey.pName[cFamilyNameSize] = '\0';

                // if cFamilyTypeSize != 0, means there must be a pitch name
                if (cFamilyTypeSize)
                {
                    pStartLine += cFamilyNameSize + 1;
                    memcpy(pFamilyType, pStartLine, cFamilyTypeSize);
                    pFamilyType[cFamilyTypeSize] = '\0';

                    StrCpy(pPitchType, &pDatFile[i]);
                    i += strlen(pPitchType);
                }
                else
                {
                    //
                    // Get Win family type name (e.g. Swiss, Roman, etc.). Store
                    // appropriate family type value in the FAMILYINFO.
                    //
                    StrCpy(pFamilyType, &pDatFile[i]);
                    i += strlen(pFamilyType);
                }

                //
                // Search for family type in table. Default is FF_DONTCARE.
                //
                pPsFontFamMap[cFams].FamilyKey.usValue = FF_DONTCARE;
                for (j = 0; j < FamilyKeyTbl.usNumEntries; j++)
                {
                    if (!strcmp(pFamilyType, ((PKEY) (FamilyKeyTbl.pTbl))[j].pName))
                    {
                        pPsFontFamMap[cFams].FamilyKey.usValue = ((PKEY) (FamilyKeyTbl.pTbl))[j].usValue;
                        break;
                    }
                }

                //
                // Search for family type in table. Default is FF_DONTCARE.
                //
                pPsFontFamMap[cFams].usPitch = DEFAULT_PITCH;
                if (cFamilyTypeSize)
                {
                    for (j = 0; j < PitchKeyTbl.usNumEntries; j++)
                    {
                        if (!strcmp(pPitchType, ((PKEY) (PitchKeyTbl.pTbl))[j].pName))
                        {
                            pPsFontFamMap[cFams].usPitch = ((PKEY) (PitchKeyTbl.pTbl))[j].usValue;
                            break;
                        }
                    }
                }

                cFams++;
            }
    } while (i < ulFileSize);

    (*pPsFamilyTbl)->usNumEntries = cFams;

    //
    // Sort FAMILYINFO table in font name order.
    //
    qsort(&(pPsFontFamMap[0].pFontName), (size_t) cFams,
        (size_t) sizeof(PSFAMILYINFO), strcmp);

    return(cFams);
}

ULONG
BuildPSCharMetrics(
    PBYTE           pAFM,
    PULONG          pUniPs,
    PPSCHARMETRICS  pFontChars,
    PBYTE           pCharDefTbl,
    ULONG           cGlyphSetChars
)
/*++

Routine Description:

    Builds a array of bit flags used to determine if a particular char is
    defined for a given font.

Arguments:

    pAFM - Ptr to memory mapped file image of .AFM file.

    pUniPs - Points to a table which maps 0-based Glyph Indices of chars
    in the GLYPHRUNS of the GLYPHSETDATA struct for this font to indices
    into the UnicodetoPs structure which maps Unicode points to PS char
    information. This mapping array is created by the CreateGlyphSet function
    defined in this module.

    pFontChars - Ptr to memory to contains an array of PSCHARMETRICS structs,
    which contains PS char name, and char width info for each char defined
    in the font's AFM. The amount of memory required in bytes is
    sizeof(PSCHARMETRICS) * num of chars in the font.

    pCharDefTbl - Ptr to memory of size ((cGlyphSetChars + 7) /8)) bytes,
    will contain bit flags indicating if a char is supported in the given font.

    cGlyphSetChars - Number of chars in the GLYPHSET for this font. This
    most likely is NOT the same as the number of chars defined in the
    font's AFM.

Return Value:

    TRUE => success
    FALSE => error

--*/
{
    ULONG i, j;
    PBYTE   pChMet, pToken;
    USHORT  chCnt;
    ULONG curCharWidth;
    PBYTE   pCharNameTok;
    BOOLEAN bIsPiFont, bIsCJKFont;
    BYTE    CharNameBuffer[32];
    PBYTE   pChName;

    //
    // Is this is a symbol font, the char "names" will actually be the
    // default char codes in the AFM.
    //
    if (bIsPiFont = IsPiFont(pAFM))
    {
        pCharNameTok = PS_CH_CODE_TOK;
    }
    else
    {
        pCharNameTok = PS_CH_NAME_TOK;
    }
    bIsCJKFont = (IsCJKFont(pAFM) != 0);

    //
    // Check validity of output pointers.
    //
    if (pFontChars == NULL || pCharDefTbl == NULL)
    {
        return(FALSE);
    }

    //
    // Get ptr to AFM char metrics.
    //
    pChMet = FindAFMToken(pAFM, PS_CH_METRICS_TOK);
    if (pChMet == NULL)    // Fixed bug 354007
        return (FALSE);

    //
    // Current pos should be the character count field.
    //
    for (i = 0; i < (int) StrLen(pChMet); i++)
    {
        if (!IS_NUM(&pChMet[i]))
        {
            return(FALSE);
        }
    }
    chCnt = (USHORT)atoi(pChMet);
    (ULONG_PTR) pChMet += i;

    //
    // Make a pass through the AFM Char Metrics, creating an array of
    // PSCHARMETRICS structs.
    //
    i = 0;

    do
    {
        PARSE_TOKEN(pChMet, pToken);

        if (!StrCmp(pToken, PS_CH_WIDTH_TOK) ||
            !StrCmp(pToken, PS_CH_WIDTH0_TOK))
        {
            pFontChars[i].chWidth = atoi(pChMet);
        }

        if (!StrCmp(pToken, pCharNameTok))
        {
            StrCpy(pFontChars[i].pPsName, pChMet);
        }
        if (!StrCmp(pToken, PS_CH_BBOX_TOK))
        {
            //
            // Save char bounding box.
            //
            PARSE_RECT(pChMet, pFontChars[i].rcChBBox);
            i++;
        }
        else if (!StrCmp(pToken, PS_EOF_TOK))
        {
            break;
        }
        NEXT_TOKEN(pChMet);

    } while (i < chCnt);

    //
    // Sort the list of PSCHARMETRICSs in PS Name sequence. If this is
    // a Pi font, chars are already sorted in CC order.
    //
    if (!bIsPiFont)
    {
        qsort(pFontChars, (size_t) chCnt, (size_t) sizeof(PSCHARMETRICS),
            CmpPsChars);
    }

    //
    // Build array of bit flags which indicate whether each char in the
    // GLYPHSETDATA is actually defined in the AFM.
    //
    for (i = 0; i < ((cGlyphSetChars + 7) / 8); i++)
    {
        pCharDefTbl[i] = 0;
    }

    for (i = 0; i < cGlyphSetChars; i++)
    {
        if (bIsPiFont)
        {
            //
            // Make the first char (0x1f:'.notdef1f') undefined.
            //
            if (i == 0)
                continue;

            //
            // Char is defined unless there are < 256 chars in the font.
            //
            if (i < chCnt)
                DEFINE_CHAR(i, pCharDefTbl);
            else
                break;
        }
        else
        {
            //
            // Setup ptr to "char name" based on whether this is a
            // western or CJK font.
            //
            if (bIsCJKFont)
            {
                // Make CID 0 undefined glyph.
                if (pUniPs[i] == 0)
                    continue;

                _ultoa(pUniPs[i], CharNameBuffer, 10);
                pChName = CharNameBuffer;
            }
            else
            {
                pChName = UnicodetoPs[pUniPs[i]].pPsName;
            }

            if (((PPSCHARMETRICS) bsearch(pChName,
                                            pFontChars,
                                            (size_t) chCnt,
                                            sizeof(PSCHARMETRICS),
                                            CmpPsChars)) != NULL)
            {
                //
                // Char is defined in this font.
                //
                DEFINE_CHAR(i, pCharDefTbl);
            }
        }
    }
    return(TRUE);
}

ULONG
cjGetFamilyAliases(
    IFIMETRICS *pifi,
    PSTR        pstr,
    UINT        cp
    )

/*++

Routine Description:

    Fill in the family name of the IFIMETRICS structure.

Arguments:

    pifi - Ptr to IFIMETRICS. If NULL, return size of family alias strings
           only.
    pstr - Ptr to null terminated Font Menu Name string.
    cp   - Codepage value.

Return Value:

    ?

--*/

{
    PSTR       *pTable;
    PWSTR       pwstr;
    DWORD       cWchars, cw;
    ULONG       ulLength;

    // assume no alias table found.

    pTable = (PSTR *)(NULL);

    // This is a hardcoded Win31 Hack that we need to be compatible
    // with since some apps have hardcoded font names.

    if (!(strcmp(pstr, "Times")))
        pTable = TimesAlias;

    else if (!(strcmp(pstr, "Helvetica")))
        pTable = HelveticaAlias;

#if 0
// Disabled due to bug #259664 fix
    else if (!(strcmp(pstr, "Courier")))
        pTable = CourierAlias;
#endif

    else if (!(strcmp(pstr, "Helvetica Narrow")))
        pTable = HelveticaNarrowAlias;

    else if (!(strcmp(pstr, "Palatino")))
        pTable = PalatinoAlias;

    else if (!(strcmp(pstr, "Bookman")))
        pTable = BookmanAlias;

    else if (!(strcmp(pstr, "NewCenturySchlbk")))
        pTable = NewCenturySBAlias;

    else if (!(strcmp(pstr, "AvantGarde")))
        pTable = AvantGardeAlias;

    else if (!(strcmp(pstr, "ZapfChancery")))
        pTable = ZapfChanceryAlias;

    else if (!(strcmp(pstr, "ZapfDingbats")))
        pTable = ZapfDingbatsAlias;


    //
    // If font name does not match any of the family alias names,
    // use font name itself as IFIMETRICS family name.
    //
    if (pTable == NULL)
    {
        ulLength = strlen(pstr);
        cWchars = MultiByteToWideChar(cp, 0, pstr, ulLength, 0, 0);
        if (pifi != NULL)
        {
            pwstr = (PWSTR)MK_PTR(pifi, dpwszFamilyName);
            MultiByteToWideChar(cp, 0, pstr, ulLength, pwstr, cWchars);
            pwstr[cWchars]= (WCHAR)'\0';
        }
        return((cWchars + 1) * sizeof (WCHAR));
    }

    //
    // A family alias name match was found.
    //
    if (pifi != NULL)
    {
        //
        // This call is a request to actually copy the string table.
        //
        pwstr = (PWSTR)MK_PTR(pifi, dpwszFamilyName);
        pifi->flInfo |= FM_INFO_FAMILY_EQUIV;
    }

    cWchars = 0;
    while (*pTable)
    {
        ulLength = strlen(*pTable);
        cw = MultiByteToWideChar(cp, 0, *pTable, ulLength, 0, 0);
        if (pifi != NULL)
        {
            MultiByteToWideChar(cp, 0, *pTable, ulLength, &pwstr[cWchars], cw);
            pwstr[cWchars + cw] = (WCHAR)'\0';
        }
        cWchars += cw + 1;
        pTable++;
    }
    if (pifi != NULL)
    {
        //
        // Add terminator to end of string array.
        //
        pwstr[cWchars] = (WCHAR)'\0';
    }
    return((cWchars + 1) * sizeof(WCHAR));
}

PBYTE
FindStringToken(
    PBYTE   pPSFile,
    PBYTE   pToken
    )
/*++

Routine Description:

    Find the first occurrence of pToken occurring in the stream pPSFile.
    pToken is terminated by the first occurrence of a space or NULL char.

Arguments:

    pPSFile - Ptr to memory mapped file stream to search.
    pToken - Ptr to string token to search for.

Return Value:

    !=NULL => ptr to first occurence of pToken
    ==NULL => token not found

--*/
{
    while (TRUE)
    {
        while (IS_WHTSPACE(pPSFile) && !EOL(pPSFile))
        {
            pPSFile++;
        }
        if (!StrCmp(pPSFile, DSC_EOF_TOK))
        {
            break;
        }
        else if (!StrCmp(pPSFile, pToken))
        {
            return(pPSFile);
        }
        else
        {
            pPSFile += StrLen(pPSFile) + 1;
        }
    }
    return(FALSE);
}

BOOLEAN
AsciiToHex(
    PBYTE   pStr,
    PUSHORT pNum
    )
/*++

Routine Description:

    Treat the the space or null terminated input string as a series of hex
    digits convert it to a USHORT.

Arguments:

    pStr - Ptr to string to convert.
    pNum - Ptr to variable which returns numeric value.

Return Value:

    TRUE => String converted
    FALSE => String could not be converted
--*/
{
    USHORT  usHexNum, ulDigit;
    CHAR    curChar;

    usHexNum = 0;
    while (!EOL(pStr) && !IS_HEX_DIGIT(pStr))
    {
        pStr++;
    }

    for( ; IS_HEX_DIGIT(pStr); pStr++);

    ulDigit = 1;
    for (pStr--; IS_HEX_DIGIT(pStr) && !EOL(pStr) && ulDigit; pStr--)
    {
        if (IS_NUM(pStr))
        {
            usHexNum += (*pStr - '0') * ulDigit;
        }
        else
        {
            curChar = (CHAR)toupper(*pStr);
            usHexNum += ((curChar - 'A') + 10) * ulDigit;
        }
        ulDigit <<= 4;
    }
    if (usHexNum)
    {
        *pNum = usHexNum;
        return(TRUE);
    }
    else
    {
        return(FALSE);
    }
}

BOOLEAN
IsPiFont(
    PBYTE   pAFM
    )
/*++

Routine Description:

    Determine if the font represented by the passed AFM is a font which
    uses the Symbol charset.

Arguments:

    pAFM - Ptr to AFM.

Return Value:

    TRUE => Font is PI font, uses "Symbol" Glyphset
    FALSE => Font not PI font
--*/
{
    // This routine used to do a lot more. Should change
    // to a macro later.
    return((BOOLEAN)isSymbolCharSet);
}

BOOLEAN
IsCJKFixedPitchEncoding(
    PGLYPHSETDATA pGlyphSetData
    )
/*++

Routine Description:

    Determine if the encoding is the one for fixed pitch font.

Arguments:

    pGlyphSetData - Ptr to GLYPHSETDATA

Return Value:

    TRUE => Fixed pitch font's encoding
    FALSE => Proportional font's encoding
--*/
{
    BOOLEAN bResult;
    char*   pszGlyphSetName;
    char**  pszPropCjkGsName;

    bResult = TRUE;

    pszGlyphSetName = (char*)MK_PTR(pGlyphSetData, dwGlyphSetNameOffset);

    for (pszPropCjkGsName = PropCjkGsNames; *pszPropCjkGsName; pszPropCjkGsName++)
    {
        if (!strcmp(pszGlyphSetName, *pszPropCjkGsName))
        {
            bResult = FALSE;
            break;
        }
    }

    return bResult;
}

PBYTE
FindUniqueID(
    PBYTE   pAFM
    )

/*++

Routine Description:

    Finds UniqueID token in a memory mapped AFM file stream.
    UniqueID is assumed on 'Comment UniqueID' line.

Arguments:

    pAFM - pointer to memory mapped AFM file.

Return Value:

    NULL => error
    otherwise => ptr to UniqueID value.

--*/

{
    PBYTE   pCurToken;

    while (TRUE)
    {
        PARSE_TOKEN(pAFM, pCurToken);
        if (!StrCmp(pCurToken, PS_COMMENT_TOK))
        {
            if (!StrCmp(pAFM, "UniqueID"))
            {
                pAFM += 8;
                while (IS_WHTSPACE(pAFM)) pAFM++;
                return pAFM;
            }
        }
        else if (!StrCmp(pCurToken, PS_EOF_TOK))
        {
            return NULL;
        }
        NEXT_LINE(pAFM);
    }

    return NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\tools\ps\cpsi2tif\cpsi2tif.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    cpsi2tif.c

Abstract:

    converting the bitmap from CPSI to a TIFF file
    usage: cpsi2tif input-file output-file

Revision History:

	12/30/96 -davidx-
		Created it.

--*/


#include <stddef.h>
#include <stdio.h>
#include <stdlib.h>
#include <stdarg.h>

#define LITTLE_ENDIAN   1

#define PAGE_HEADER     0x00000101
#define PAGE_TRAILER    0x00000004
#define BAND_HEADER     0x00000003

// we assume 32-bit integer values are stored in
// big-endian format in the input file.

#if LITTLE_ENDIAN

#define swap_integer(n) \
        ((((n) >> 24) & 0x00ff) | \
         (((n) >>  8) & 0xff00) | \
         (((n) & 0xff00) <<  8) | \
         (((n) & 0x00ff) << 24))

#else //!LITTLE_ENDIAN

#define swap_integer(n) (n)

#endif //!LITTLE_ENDIAN

#define ASSERT(cond) { \
            if (! (cond)) \
                error("assertion failed on line %d\n", __LINE__); \
        }


// bitmap header structure at the beginning of each page

typedef long INT32;
typedef unsigned long UINT32;
typedef short INT16;
typedef unsigned short UINT16;
typedef unsigned char UINT8;

typedef struct {

	INT32   byteWidth;
	INT32   height;
	INT32   topMargin;
	INT32   leftMargin;
	INT32   bandHeight;
	INT32   xResolution;
	INT32   yResolution;
	INT32   imagingOrder;
	INT32   planeOrder;
	INT32   depth;
	INT32   dcc;
	INT32   firstColor;
	INT32   redFirst;
	INT32   redN;
	INT32   redDelta;
	INT32   greenFirst;
	INT32   greenN;
	INT32   greenDelta;
	INT32   blueFirst;
	INT32   blueN;
	INT32   blueDelta;
	INT32   grayFirst;
	INT32   grayN;
	INT32   grayDelta;
	INT32   isPlanar;
	INT32   scanUnit;
	INT32   swapBits;

} BITMAP_HEADER, *PBITMAP_HEADER;


char*   progname;
FILE*   fin;
FILE*   fout;
INT32   outputByteCnt;
int     useStrips = 1;


void
error(
    char *fmtstr,
    ...
    )

{
    va_list arglist;

    fprintf(stderr, "%s: ", progname);

    va_start(arglist, fmtstr);
    vfprintf(stderr, fmtstr, arglist);
    va_end(arglist);

    exit(-1);
}


void*
alloc_memory(
    int size
    )

{
    void*   p;

    if ((p = malloc(size)) == NULL)
        error("out of memory\n");
    
    memset(p, 0, size);
    return p;
}


INT32
read_integer(
    void
    )

{
    INT32 n;

    if (fread(&n, sizeof(n), 1, fin) != 1)
        error("error reading input file\n");

    return swap_integer(n);
}


void
write_output_data(
    void*   p,
    int     size
    )

{
    if (fwrite(p, size, 1, fout) != 1)
        error("error writing output file\n");
    
    outputByteCnt += size;
}


#include "tiffcomp.c"


int
write_tiff_fileheader(
    void
    )

{
    write_output_data(&tiffFileHeader, sizeof(tiffFileHeader));
    return offsetof(TIFF_FILEHEADER, firstIFDOffset);
}


void
align_output_data(
    void
    )

{
    if (outputByteCnt & 1)
    {
        char ch = 0;
        write_output_data(&ch, 1);
    }
}


void
write_nextifd_offset(
    int     offset,
    INT32   value
    )

{
    // update the next IFD offset and move to end of file

    if (fseek(fout, offset, SEEK_SET) != 0 ||
        fwrite(&value, sizeof(value), 1, fout) != 1 ||
        fseek(fout, 0, SEEK_END) != 0)
    {
        error("couldn't write IFD offset\n");
    }
}


int
process_page(
    int     prevIFDOffset
    )

{
    BITMAP_HEADER   bitmapHeader;
    int             ifd_offset;
    int             strip_count, strip_index;
    INT16           ifd_count;
    IFD             ifd;
    UINT8*          cur_line;
    UINT8*          ref_line;
    int             totalLines, bandLines, lineBytes, lineBits;
    static int      pageNumber = 0;

    // read in bitmap header

    if (fread(&bitmapHeader, sizeof(bitmapHeader), 1, fin) != 1)
        error("couldn't read bitmap header\n");
    
    if (LITTLE_ENDIAN)
    {
        INT32*  p;
        int     n;

        p = (INT32*) &bitmapHeader;
        n = sizeof(bitmapHeader) / sizeof(INT32);
        ASSERT(sizeof(bitmapHeader) % sizeof(INT32) == 0)

        while (n--)
        {
            *p = swap_integer(*p);
            p++;
        }
    }

    // valid bitmap header fields
    // we're only able to deal with 1-bpp monochrome images for now

    if (bitmapHeader.byteWidth <= 0 ||
        bitmapHeader.height <= 0 ||
        bitmapHeader.topMargin != 0 ||
        bitmapHeader.leftMargin != 0 ||
        bitmapHeader.bandHeight <= 0 ||
        bitmapHeader.bandHeight > bitmapHeader.height ||
        bitmapHeader.xResolution <= 0 ||
        bitmapHeader.yResolution <= 0 ||
        bitmapHeader.imagingOrder != 0 ||
        bitmapHeader.planeOrder != 0 ||
        bitmapHeader.depth != 1 ||
        bitmapHeader.dcc != 0 ||
        bitmapHeader.firstColor != 0 ||
        bitmapHeader.redFirst != 0 ||
        bitmapHeader.redN != 0 ||
        bitmapHeader.redDelta != 0 ||
        bitmapHeader.greenFirst != 0 ||
        bitmapHeader.greenN != 0 ||
        bitmapHeader.greenDelta != 0 ||
        bitmapHeader.blueFirst != 0 ||
        bitmapHeader.blueN != 0 ||
        bitmapHeader.blueDelta != 0 ||
        bitmapHeader.grayFirst != 0 ||
        bitmapHeader.grayN != 2 ||
        bitmapHeader.grayDelta != 1 ||
        bitmapHeader.isPlanar != 0 ||
        bitmapHeader.scanUnit != 4 ||
        bitmapHeader.swapBits != 0)
    {
        error("invalid bitmap header\n");
    }

    totalLines = bitmapHeader.height;
    lineBytes = bitmapHeader.byteWidth;
    lineBits = lineBytes * 8;

    // allocate memory for various data structures:
    //  reference line
    //  current line
    //  strip offsets
    //  strip bytecounts

    memcpy(&ifd, &ifdTemplate, sizeof(ifd));

    strip_count = (totalLines + bitmapHeader.bandHeight - 1) / bitmapHeader.bandHeight;
    ref_line = alloc_memory(lineBytes);
    cur_line = alloc_memory(lineBytes);

    if (useStrips)
    {
        INT32*  strip_offsets;
        INT32*  strip_bytecounts;

        strip_offsets = alloc_memory(sizeof(INT32) * strip_count);
        strip_bytecounts = alloc_memory(sizeof(INT32) * strip_count);

        // process one band at a time
        
        for (strip_index=0; strip_index < strip_count; strip_index++)
        {
            strip_offsets[strip_index] = outputByteCnt;

            // read band header

            if (read_integer() != BAND_HEADER ||
                (bandLines = read_integer()) > bitmapHeader.bandHeight ||
                bandLines <= 0)
            {
                error("invalid band header\n");
            }

            init_tiff_encoder();
            memset(ref_line, 0, lineBytes);

            while (bandLines--)
            {
                UINT8* p;

                // read input scanline

                if (fread(cur_line, lineBytes, 1, fin) != 1)
                    error("error reading scanline\n");
                
                // compress it

                compress_tiff_line(cur_line, ref_line, lineBits);

                // switch current and reference line buffer

                p = ref_line;
                ref_line = cur_line;
                cur_line = p;
            }

            cleanup_tiff_encoder();

            // calculate the size of compressed data for the current strip

            strip_bytecounts[strip_index] = outputByteCnt - strip_offsets[strip_index];
            align_output_data();
        }

        // output strip offsets and strip bytecounts

        ifd.ifdRowsPerStrip.value = bitmapHeader.bandHeight;
        ifd.ifdStripOffsets.count = strip_count;
        ifd.ifdStripOffsets.value = outputByteCnt;
        write_output_data(strip_offsets, strip_count * sizeof(INT32));

        ifd.ifdStripByteCounts.count = strip_count;
        ifd.ifdStripByteCounts.value = outputByteCnt;
        write_output_data(strip_bytecounts, strip_count * sizeof(INT32));

        free(strip_offsets);
        free(strip_bytecounts);
    }
    else
    {
        ifd.ifdStripOffsets.count = 1;
        ifd.ifdStripOffsets.value = outputByteCnt;
        ifd.ifdRowsPerStrip.value = totalLines;

        init_tiff_encoder();
        memset(ref_line, 0, lineBytes);

        // process one band at a time
        
        for (strip_index=0; strip_index < strip_count; strip_index++)
        {
            // read band header

            if (read_integer() != BAND_HEADER ||
                (bandLines = read_integer()) > bitmapHeader.bandHeight ||
                bandLines <= 0)
            {
                error("invalid band header\n");
            }

            while (bandLines--)
            {
                UINT8* p;

                // read input scanline

                if (fread(cur_line, lineBytes, 1, fin) != 1)
                    error("error reading scanline\n");
                
                // compress it

                compress_tiff_line(cur_line, ref_line, lineBits);

                // switch current and reference line buffer

                p = ref_line;
                ref_line = cur_line;
                cur_line = p;
            }
        }

        cleanup_tiff_encoder();

        ifd.ifdStripByteCounts.count = 1;
        ifd.ifdStripByteCounts.value = outputByteCnt - ifd.ifdStripOffsets.value;
        align_output_data();
    }

    // update the nextIFDOffset field in the previous IFD

    write_nextifd_offset(prevIFDOffset, outputByteCnt);

    // write out IFD

    ASSERT(sizeof(ifd_count) == 2);
    ifd_count = IFD_COUNT;
    write_output_data(&ifd_count, 2);
    ifd_offset = outputByteCnt;

    ifd.ifdImageWidth.value = lineBits;
    ifd.ifdImageHeight.value = totalLines;
    ifd.ifdXResolution.value = ifd_offset + offsetof(IFD, xresNum);
    ifd.xresNum = bitmapHeader.xResolution;
    ifd.ifdYResolution.value = ifd_offset + offsetof(IFD, yresNum);
    ifd.yresNum = bitmapHeader.yResolution;
    ifd.ifdPageNumber.value = pageNumber++;
    ifd.ifdSoftware.value = ifd_offset + offsetof(IFD, software);

    write_output_data(&ifd, sizeof(ifd));

    free(ref_line);
    free(cur_line);

    return ifd_offset + offsetof(IFD, nextIFDOffset);
}


int
end_of_file(
    FILE*   fin
    )

{
    int ch;

    if ((ch = fgetc(fin)) == EOF)
        return 1;
    
    ungetc(ch, fin);
    return 0;
}


int __cdecl
main(
    int argc,
    char **argv
    )

{
    int offset;

    // check command line arguments

    progname = *argv;

    if (argc != 3)
    {
        fprintf(stderr, "usage: %s input-file output-file\n", progname);
        return 1;
    }

    // open input and output file

    if ((fin = fopen(argv[1], "r")) == NULL)
        error("couldn't open input file '%s'\n", argv[1]);

    if ((fout = fopen(argv[2], "w")) == NULL)
        error("couldn't open output file '%s'\n", argv[2]);

    // output tiff file header

    offset = write_tiff_fileheader();

    while (! end_of_file(fin))
    {
        // look for page header

        if (read_integer() != PAGE_HEADER)
            error("invalid page header\n");

        // process a single page

        offset = process_page(offset);

        // look for page trailer

        if (read_integer() != PAGE_TRAILER)
            error("invalid page trailer\n");
    }

    write_nextifd_offset(offset, 0);

    fclose(fin);
    fclose(fout);
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\tools\ps\makentf\cjkfonts.c ===
/*++

Copyright (c) 1996 Adobe Systems Incorporated
Copyright (c) 1996  Microsoft Corporation

Module Name:

    cjkfonts.c

Abstract:

    Convert CJK AFMs to NTMs.

Environment:

    Windows NT PostScript driver: makentf utility.

Revision History:

    02/10/98 -ksuzuki-
        Added OCF font support using 83pv font; did code cleanup, especially
        of the CreateCJKGlyphSets function.

    01/13/96 -rkiesler-
        Wrote it.
-*/

#include "lib.h"
#include "ppd.h"
#include "pslib.h"
#include "psglyph.h"
#include "afm2ntm.h"
#include "cjkfonts.h"
#include "winfont.h"

extern BOOL bVerbose;

ULONG
CreateCJKGlyphSets(
    PBYTE         *pUV2CCMaps,
    PBYTE         *pUV2CIDMaps,
    PGLYPHSETDATA *pGlyphSets,
    PWINCODEPAGE   pWinCodePage,
    PULONG        *pUniPsTbl
    )
/*++

Routine Description:

    Given memory mapped file ptrs to H and V Unicode to CharCode map files
    and H and V Unicode to CID map files, create 2 GLYPHSETDATA structures
    which represent H and V variants of the character collection. Create
    ptrs to 2 tables which map glyph indices to CIDs for each variant.

Arguments:

    pUV2CCMaps - Pointer to two memory mapped map files. These map Unicode
    value to corresponding character code. pUV2CCMaps[0] and pUV2CCMaps[1]
    for H and V respectively.

    pUV2CIDMaps - Pointer to two memory mapped map files. These Unicode to
    corresponding CID. pUV2CIDMaps[0] and pUV2CIDMaps[1] for H and V
    respectively.

    pGlyphSets - two position array of GLYPHSETDATA pointers which upon
    successful completion contain the addresses of the newly allocated
    GLYPHSETDATA structs representing the H and V variants of the char
    collection.

    pWinCodePage - Pts to a WINCODEPAGE struct which provides Windows
    specific info about this charset.

    pUniPsTbl - two position array of ULONG ptrs which each pts to a table
    which maps 0-based Glyph Indices of chars in the GLYPHRUNS of the
    GLYPHSETDATA for this char collection to CIDs.

Return Value:

    TRUE  => success.
    FALSE => error.

--*/

{
    PBYTE           pToken, pGlyphSetName;
    ULONG           cChars, cRuns, cRanges, curCID;
    USHORT          cCharRun;
    PGLYPHRUN       pGlyphRuns;
    PCMAP           pUv2CcMap[NUM_VARIANTS];
    PCMAP           pUv2CidMap[NUM_VARIANTS];
    ULONG           c, i, uv;
    PVOID           pMapTbl;
    PCMAPRANGE      pCMapRange;
    PCMAP           pSrchCMap;
    ULONG           cGlyphSetBytes[NUM_VARIANTS], cSizeBytes[NUM_VARIANTS];
    BOOLEAN         bFound, bInRun;
    USHORT          wcRunStrt;
    DWORD           dwGSNameSize, dwCodePageInfoSize, dwGlyphRunSize, dwCPIGSNameSize;
    DWORD           dwEncodingNameOffset;
    PCODEPAGEINFO   pCodePageInfo;
	BOOL			bSingleCodePage;


	if (bVerbose) printf("%%%%[Begin Create CJK glyphset]%%%%\n\n");

    //////////////////////////////////////////////////////////////////////////
    //
    // Create the local Unicode->CharCode and Unicode->CID Maps sorted in
    // starting Unicode order.
    //
    //////////////////////////////////////////////////////////////////////////

    //
    // Get pointer to, and determine size of, the name strings for each variant.
    //
    for (i = 0; i < NUM_VARIANTS; i++)
    {
        //
        // Process the Unicode->CharCode map to determine the number of its
        // chars and runs.
        //
        if (NumUV2CCRuns(pUV2CCMaps[i], &cRuns, &cChars) == FALSE)
        {
            return(FALSE);
        }

        //
        // Alloc memory for create local CMap structs needed to build
        // GLYPHSETs.
        //
        pUv2CcMap[i] = (PCMAP)MemAllocZ(sizeof(CMAP) + sizeof(CMAPRANGE) * (cRuns - 1));
        if (pUv2CcMap[i] == NULL)
        {
            ERR(("makentf - CreateCJKGlyphSets: MemAllocZ\n"));
            return(FALSE);
        }
        pUv2CcMap[i]->cChars = cChars;

        if (BuildUV2CCMap(pUV2CCMaps[i], pUv2CcMap[i]) == FALSE)
        {
            return(FALSE);
        }

        //
        // Sort the CMap ranges in starting Unicode order.
        //
        qsort(pUv2CcMap[i]->CMapRange,
                (size_t)pUv2CcMap[i]->cRuns,
                (size_t)sizeof(CMAPRANGE),
                CmpCMapRunsChCode);

        //
        // Process the Unicode->CID map to determine the number of its
        // chars and runs.
        //
        if (NumUV2CIDRuns(pUV2CIDMaps[i], &cRuns, &cChars) == FALSE)
        {
            return(FALSE);
        }

        pUv2CidMap[i] = (PCMAP)MemAllocZ(sizeof(CMAP) + sizeof(CMAPRANGE) * (cRuns - 1));
        if (pUv2CidMap[i] == NULL)
        {
            ERR(("makentf - CreateCJKGlyphSets: MemAllocZ\n"));
            return(FALSE);
        }
        pUv2CidMap[i]->cChars = cChars;

        if (BuildUV2CIDMap(pUV2CIDMaps[i], pUv2CidMap[i]) == FALSE)
        {
            return(FALSE);
        }

        //
        // Sort CMap Ranges in Starting char code order.
        //
        qsort(pUv2CidMap[i]->CMapRange,
                (size_t)pUv2CidMap[i]->cRuns,
                (size_t)sizeof(CMAPRANGE),
                CmpCMapRunsChCode);
    }

	//
	// CJK fonts never have multiple codepages, but, we figure it out anyway
	// just in case.
	//
	bSingleCodePage = (pWinCodePage->usNumBaseCsets == 1) ? TRUE : FALSE;


    //////////////////////////////////////////////////////////////////////////
    //
    // Create H GLYPHSETDATA
    //
    //////////////////////////////////////////////////////////////////////////

    //
    // Count chars and runs in H CMaps.
    //
    // Look up all Unicode points in the H Unicode->CID map and the H Unicode->
    // CharCode map to determine number of GLYPHRUNs required for the
    // GLYPHSETDATA we are about to create.
    //
    cChars = cRuns = 0;
    bInRun = bFound = FALSE;

    for (uv = 0; uv < NUM_UNICODE_CHARS; uv++)
    {
        //
        // Search for the Unicode value in H Unicode->CharCode map.
        //
        pCMapRange = (PCMAPRANGE)bsearch(&uv,
                                            pUv2CidMap[H_CMAP]->CMapRange,
                                            pUv2CidMap[H_CMAP]->cRuns,
                                            sizeof(CMAPRANGE),
                                            FindChCodeRun);

        bFound = (pCMapRange != NULL);

        if (bFound)
        {
            //
            // Found this unicode value in H Unicode->CID map. Determine if it
            // maps to a CharCode in H Unicode->CharCode map.
            //
            bFound = (bsearch(&uv,
                                pUv2CcMap[H_CMAP]->CMapRange,
                                pUv2CcMap[H_CMAP]->cRuns,
                                sizeof(CMAPRANGE),
                                FindChCodeRun) != NULL);

            if (bFound)
            {
                cChars++;
            }
        }

        //
        // Determine if this is a new run.
        //
        bInRun = bFound && bInRun;
        if (bFound && !bInRun)
        {
            cRuns++;
            bInRun = TRUE;
        }
    }

    //
    // Compute amount of memory required for H GLYPHSET.
    // Note to account for the H/V char appended to the GlyphSet name.
    //
    dwGSNameSize = ALIGN4(strlen(pWinCodePage->pszCPname) + 2);
    dwCodePageInfoSize = ALIGN4(pWinCodePage->usNumBaseCsets * sizeof(CODEPAGEINFO));
    dwGlyphRunSize = ALIGN4(cRuns * sizeof(GLYPHRUN));

    cGlyphSetBytes[H_CMAP]  = ALIGN4(sizeof(GLYPHSETDATA));
    cGlyphSetBytes[H_CMAP] += dwGSNameSize;
    cGlyphSetBytes[H_CMAP] += dwCodePageInfoSize;
    cGlyphSetBytes[H_CMAP] += dwGlyphRunSize;

	//
	// Account for the size of the mapping table.
	//
	cGlyphSetBytes[H_CMAP] += bSingleCodePage ? ALIGN4((cChars * sizeof (WORD))) : (cChars * sizeof (DWORD));

    //
    // Account for size of CODEPAGE name strings found in CODEPAGEINFO
    // struct(s).
    //
    for (dwCPIGSNameSize = 0, i = 0; i < pWinCodePage->usNumBaseCsets; i++)
    {
        dwCPIGSNameSize += ALIGN4(strlen(aPStoCP[pWinCodePage->pCsetList[i]].pGSName) + 1);
    }
    cGlyphSetBytes[H_CMAP] += dwCPIGSNameSize;

    //
    // Alloc memory for H GLYPHSET, Unicode->CID mapping table.
    //
    pGlyphSets[H_CMAP] = (PGLYPHSETDATA)MemAllocZ(cGlyphSetBytes[H_CMAP]);
    if (pGlyphSets[H_CMAP] == NULL)
    {
        ERR(("makentf - CreateCJKGlyphSets: malloc\n"));
        return(FALSE);
    }

    pUniPsTbl[H_CMAP] = (PULONG)MemAllocZ(cChars * sizeof(ULONG));
    if (pUniPsTbl[H_CMAP] == NULL)
    {
        ERR(("makentf - CreateCJKGlyphSets: malloc\n"));
        return(FALSE);
    }

    //
    // Init GLYPHSETDATA for H.
    //
    pGlyphSets[H_CMAP]->dwSize = cGlyphSetBytes[H_CMAP];
    pGlyphSets[H_CMAP]->dwVersion = GLYPHSETDATA_VERSION;
    pGlyphSets[H_CMAP]->dwFlags = 0;
    pGlyphSets[H_CMAP]->dwGlyphSetNameOffset = ALIGN4(sizeof(GLYPHSETDATA));
    pGlyphSets[H_CMAP]->dwGlyphCount = cChars;
    pGlyphSets[H_CMAP]->dwCodePageCount = pWinCodePage->usNumBaseCsets;
    pGlyphSets[H_CMAP]->dwCodePageOffset = pGlyphSets[H_CMAP]->dwGlyphSetNameOffset + dwGSNameSize;
    pGlyphSets[H_CMAP]->dwRunCount = cRuns;
    pGlyphSets[H_CMAP]->dwRunOffset = pGlyphSets[H_CMAP]->dwCodePageOffset + dwCodePageInfoSize + dwCPIGSNameSize;
    pGlyphSets[H_CMAP]->dwMappingTableOffset = pGlyphSets[H_CMAP]->dwRunOffset + dwGlyphRunSize;

	//
	// Set the mapping table type flag to dwFlags field.
	//
	pGlyphSets[H_CMAP]->dwFlags |= bSingleCodePage ? GSD_MTT_WCC : GSD_MTT_DWCPCC;

    //
    // Store GlyphSet name
    //
    pGlyphSetName = (PBYTE)MK_PTR(pGlyphSets[H_CMAP], dwGlyphSetNameOffset);
    strcpy(pGlyphSetName, pWinCodePage->pszCPname);
    pGlyphSetName[strlen(pWinCodePage->pszCPname)] = 'H';
    pGlyphSetName[strlen(pWinCodePage->pszCPname) + 1] = '\0';

    //
    // Initialize a CODEPAGEINFO struct for each base charset supported
    // by this font.
    //
    pCodePageInfo = (PCODEPAGEINFO)MK_PTR(pGlyphSets[H_CMAP], dwCodePageOffset);
    dwEncodingNameOffset = dwCodePageInfoSize;

    for (i = 0; i < pWinCodePage->usNumBaseCsets; i++, pCodePageInfo++)
    {
        //
        // Save CODEPAGEINFO name, id. We don't use PS encoding vectors.
        //
        pCodePageInfo->dwCodePage = aPStoCP[pWinCodePage->pCsetList[i]].usACP;
        pCodePageInfo->dwWinCharset = (DWORD)aPStoCP[pWinCodePage->pCsetList[i]].jWinCharset;
        pCodePageInfo->dwEncodingNameOffset = dwEncodingNameOffset;
        pCodePageInfo->dwEncodingVectorDataSize = 0;
        pCodePageInfo->dwEncodingVectorDataOffset = 0;

        //
        // Copy codepage name string to end of array of CODEPAGEINFOs.
        //
        strcpy((PBYTE)MK_PTR(pCodePageInfo, dwEncodingNameOffset),
                aPStoCP[pWinCodePage->pCsetList[i]].pGSName);

        //
        // Adjust the offset to the CodePage name for the next CODEPAGEINFO structure.
        //
        dwEncodingNameOffset -= ALIGN4(sizeof (CODEPAGEINFO));
        dwEncodingNameOffset += ALIGN4(strlen(aPStoCP[pWinCodePage->pCsetList[i]].pGSName) + 1);
    }

    //
    // Process H Unicode->CID/CharCode maps to determine the number of its
    // chars and runs.
    //
    cRuns = 0;
    cCharRun = 0;
    bInRun = FALSE;
    pGlyphRuns = GSD_GET_GLYPHRUN(pGlyphSets[H_CMAP]);
    pMapTbl = GSD_GET_MAPPINGTABLE(pGlyphSets[H_CMAP]);

    for (uv = c = 0; (uv < NUM_UNICODE_CHARS) && (c < cChars); uv++)
    {
        pCMapRange = bsearch(&uv,
                                pUv2CidMap[H_CMAP]->CMapRange,
                                pUv2CidMap[H_CMAP]->cRuns,
                                sizeof(CMAPRANGE),
                                FindChCodeRun);

        bFound = (pCMapRange != NULL);

        if (bFound)
        {
            curCID = pCMapRange->CIDStrt + uv - pCMapRange->ChCodeStrt;

            pCMapRange = bsearch(&uv,
                                    pUv2CcMap[H_CMAP]->CMapRange,
                                    pUv2CcMap[H_CMAP]->cRuns,
                                    sizeof(CMAPRANGE),
                                    FindChCodeRun);

            bFound = (pCMapRange != NULL);

            if (bFound)
            {
                //
                // Found this Unicode value in Unicode->CharCode map. Store in
                // mapping table. Note that CJK fonts only support 1 charset
                // per font.
                //
                pUniPsTbl[H_CMAP][c] = curCID;

				if (bSingleCodePage)
				{
					if (pCMapRange != NULL)
						((WORD*)pMapTbl)[c] = (WORD)(pCMapRange->CIDStrt + (uv - pCMapRange->ChCodeStrt));
					else
						((WORD*)pMapTbl)[c] = (WORD)uv;
				}
				else
				{
                	((DWORD*)pMapTbl)[c] = aPStoCP[pWinCodePage->pCsetList[0]].usACP << 16;
                	if (pCMapRange != NULL)
                	{
                    	((DWORD*)pMapTbl)[c] |= pCMapRange->CIDStrt + (uv - pCMapRange->ChCodeStrt);
                	}
                	else
                	{
                    	((DWORD*)pMapTbl)[c] |= uv;
                	}
				}

                c++;
                cCharRun++;
            }
        }

        //
        // Determine if this is a new Unicode run.
        //
        if (bFound && !bInRun)
        {
            //
            // This is the beginning of a new run.
            //
            bInRun = TRUE;
            pGlyphRuns[cRuns].wcLow = (USHORT) (uv & 0xffff);
        }

        //
        // Determine if this is the end of a run.
        //
        if (bInRun && (!bFound || uv == NUM_UNICODE_CHARS || c == cChars))
        {
            //
            // This is the end of a run.
            //
            bInRun = FALSE;
            pGlyphRuns[cRuns].wGlyphCount = cCharRun;
            cRuns++;
            cCharRun = 0;
        }
    }

    //////////////////////////////////////////////////////////////////////////
    //
    // Create V GLYPHSETDATA
    //
    //////////////////////////////////////////////////////////////////////////

    //
    // Count chars and runs in V maps.
    //
    // For the V GLYPHSETDATA, if a Unicode value is not found in V Unicode->
    // CID map, we will then need to check H Unicode->CID map.
    //
    cChars = cRuns = 0;
    bInRun = bFound = FALSE;

    for (uv = 0; uv < NUM_UNICODE_CHARS; uv++)
    {
        //
        // Search for the Unicode value in V, and then H Unicode->CID maps if
        // not found.
        //
        pCMapRange = bsearch(&uv,
                                pUv2CidMap[V_CMAP]->CMapRange,
                                pUv2CidMap[V_CMAP]->cRuns,
                                sizeof(CMAPRANGE),
                                FindChCodeRun);

        bFound = (pCMapRange != NULL);

        if (bFound == FALSE)
        {
            pCMapRange = bsearch(&uv,
                                    pUv2CidMap[H_CMAP]->CMapRange,
                                    pUv2CidMap[H_CMAP]->cRuns,
                                    sizeof(CMAPRANGE),
                                    FindChCodeRun);

            bFound = (pCMapRange != NULL);
        }

        if (bFound)
        {
            //
            // Found this unicode value. Determine if it maps to a CharCode in
            // H or V Unicode->CharCode map.
            //
            pCMapRange = bsearch(&uv,
                                    pUv2CcMap[V_CMAP]->CMapRange,
                                    pUv2CcMap[V_CMAP]->cRuns,
                                    sizeof(CMAPRANGE),
                                    FindChCodeRun);

            bFound = (pCMapRange != NULL);

            if (bFound == FALSE)
            {
                pCMapRange = bsearch(&uv,
                                        pUv2CcMap[H_CMAP]->CMapRange,
                                        pUv2CcMap[H_CMAP]->cRuns,
                                        sizeof(CMAPRANGE),
                                        FindChCodeRun);

                bFound = (pCMapRange != NULL);
            }

            if (bFound)
            {
                cChars++;
            }
        }

        //
        // Determine if this is a new run.
        //
        bInRun = bFound && bInRun;
        if (bFound && !bInRun)
        {
            cRuns++;
            bInRun = TRUE;
        }
    }

    //
    // Compute amount of memory required for V GLYPHSET.
    //
    dwGSNameSize = ALIGN4(strlen(pWinCodePage->pszCPname) + 2);
    dwCodePageInfoSize = ALIGN4(pWinCodePage->usNumBaseCsets * sizeof(CODEPAGEINFO));
    dwGlyphRunSize = ALIGN4(cRuns * sizeof(GLYPHRUN));

    cGlyphSetBytes[V_CMAP]  = ALIGN4(sizeof(GLYPHSETDATA));
    cGlyphSetBytes[V_CMAP] += dwGSNameSize;
    cGlyphSetBytes[V_CMAP] += dwCodePageInfoSize;
    cGlyphSetBytes[V_CMAP] += dwGlyphRunSize;

	//
	// Account for the size of the mapping table.
	//
	cGlyphSetBytes[V_CMAP] += bSingleCodePage ? ALIGN4((cChars * sizeof (WORD))) : (cChars * sizeof (DWORD));

    //
    // Account for size of CODEPAGE name strings found in CODEPAGEINFO
    // struct(s).
    //
    for (dwCPIGSNameSize = 0, i = 0; i < pWinCodePage->usNumBaseCsets; i++)
    {
        dwCPIGSNameSize += ALIGN4(strlen(aPStoCP[pWinCodePage->pCsetList[i]].pGSName) + 1);
    }
    cGlyphSetBytes[V_CMAP] += dwCPIGSNameSize;

    //
    // Alloc memory for V GLYPHSET, Unicode->CID mapping table.
    //
    pGlyphSets[V_CMAP] = (PGLYPHSETDATA)MemAllocZ(cGlyphSetBytes[V_CMAP]);
    if (pGlyphSets[V_CMAP] == NULL)
    {
        ERR(("makentf - CreateCJKGlyphSets: malloc\n"));
        return(FALSE);
    }

    pUniPsTbl[V_CMAP] = (PULONG)MemAllocZ(cChars * sizeof(ULONG));
    if (pUniPsTbl[V_CMAP] == NULL)
    {
        ERR(("makentf - CreateCJKGlyphSets: malloc\n"));
        return(FALSE);
    }

    //
    // Init GLYPHSETDATA for V.
    //
    pGlyphSets[V_CMAP]->dwSize = cGlyphSetBytes[V_CMAP];
    pGlyphSets[V_CMAP]->dwVersion = GLYPHSETDATA_VERSION;
    pGlyphSets[V_CMAP]->dwFlags = 0;
    pGlyphSets[V_CMAP]->dwGlyphSetNameOffset = ALIGN4(sizeof(GLYPHSETDATA));
    pGlyphSets[V_CMAP]->dwGlyphCount = cChars;
    pGlyphSets[V_CMAP]->dwCodePageCount = pWinCodePage->usNumBaseCsets;
    pGlyphSets[V_CMAP]->dwCodePageOffset = pGlyphSets[V_CMAP]->dwGlyphSetNameOffset + dwGSNameSize;
    pGlyphSets[V_CMAP]->dwRunCount = cRuns;
    pGlyphSets[V_CMAP]->dwRunOffset = pGlyphSets[V_CMAP]->dwCodePageOffset + dwCodePageInfoSize + dwCPIGSNameSize;
    pGlyphSets[V_CMAP]->dwMappingTableOffset = pGlyphSets[V_CMAP]->dwRunOffset + dwGlyphRunSize;

	//
	// Set the mapping table type flag to dwFlags field.
	//
	pGlyphSets[V_CMAP]->dwFlags |= bSingleCodePage ? GSD_MTT_WCC : GSD_MTT_DWCPCC;

    //
    // Store GlyphSet name
    //
    pGlyphSetName = (PBYTE)MK_PTR(pGlyphSets[V_CMAP], dwGlyphSetNameOffset);
    strcpy(pGlyphSetName, pWinCodePage->pszCPname);
    pGlyphSetName[strlen(pWinCodePage->pszCPname)] = 'V';
    pGlyphSetName[strlen(pWinCodePage->pszCPname) + 1] = '\0';

    //
    // Initialize a CODEPAGEINFO struct for each base charset supported
    // by this font.
    //
    pCodePageInfo = (PCODEPAGEINFO) MK_PTR(pGlyphSets[V_CMAP], dwCodePageOffset);
    dwEncodingNameOffset = dwCodePageInfoSize;

    for (i = 0; i < pWinCodePage->usNumBaseCsets; i++, pCodePageInfo++)
    {
        //
        // Save CODEPAGEINFO name, id. We don't use PS encoding vectors.
        //
        pCodePageInfo->dwCodePage = aPStoCP[pWinCodePage->pCsetList[i]].usACP;
        pCodePageInfo->dwWinCharset = (DWORD)aPStoCP[pWinCodePage->pCsetList[i]].jWinCharset;
        pCodePageInfo->dwEncodingNameOffset = dwEncodingNameOffset;
        pCodePageInfo->dwEncodingVectorDataSize = 0;
        pCodePageInfo->dwEncodingVectorDataOffset = 0;

        //
        // Copy codepage name string to end of array of CODEPAGEINFOs.
        //
        strcpy((PBYTE)MK_PTR(pCodePageInfo, dwEncodingNameOffset),
                aPStoCP[pWinCodePage->pCsetList[i]].pGSName);

        //
        // Adjust the offset to the CodePage name for the next CODEPAGEINFO structure.
        //
        dwEncodingNameOffset -= sizeof(CODEPAGEINFO);
        dwEncodingNameOffset += ALIGN4(strlen((PSZ)MK_PTR(pCodePageInfo, dwEncodingNameOffset)) + 1);
    }

    //
    // Create V Glyphset by merging V and H Maps.
    //

    //
    // Determine number of runs, chars in the Glyphset created when V and H
    // Maps are merged.
    //
    cRuns = 0;
    cCharRun = 0;
    bInRun = bFound = FALSE;
    pGlyphRuns = GSD_GET_GLYPHRUN(pGlyphSets[V_CMAP]);
    pMapTbl = GSD_GET_MAPPINGTABLE(pGlyphSets[V_CMAP]);

    for (uv = c = 0; (uv < NUM_UNICODE_CHARS) && (c < cChars); uv++)
    {
        pCMapRange = bsearch(&uv,
                                pUv2CidMap[V_CMAP]->CMapRange,
                                pUv2CidMap[V_CMAP]->cRuns,
                                sizeof(CMAPRANGE),
                                FindChCodeRun);

        bFound = (pCMapRange != NULL);

        if (bFound == FALSE)
        {
            pCMapRange = bsearch(&uv,
                                    pUv2CidMap[H_CMAP]->CMapRange,
                                    pUv2CidMap[H_CMAP]->cRuns,
                                    sizeof(CMAPRANGE),
                                    FindChCodeRun);

            bFound = (pCMapRange != NULL);
        }

        //
        // Found this Unicode value. Determine if it maps to a CharCode in H
        // or V Unicode->CC map.
        //
        if (bFound)
        {
            curCID = pCMapRange->CIDStrt + (uv - pCMapRange->ChCodeStrt);

            pCMapRange = bsearch(&uv,
                                    pUv2CcMap[V_CMAP]->CMapRange,
                                    pUv2CcMap[V_CMAP]->cRuns,
                                    sizeof(CMAPRANGE),
                                    FindChCodeRun);

            bFound = (pCMapRange != NULL);

            if (bFound == FALSE)
            {
                pCMapRange = bsearch(&uv,
                                        pUv2CcMap[H_CMAP]->CMapRange,
                                        pUv2CcMap[H_CMAP]->cRuns,
                                        sizeof(CMAPRANGE),
                                        FindChCodeRun);

                bFound = (pCMapRange != NULL);
            }

            if (bFound)
            {
                //
                // Found this Unicode value in Unicode->CharCode map. Store in
                // mapping table. Note that CJK fonts only support 1 charset
                // per font.
                //
                pUniPsTbl[V_CMAP][c] = curCID;

				if (bSingleCodePage)
				{
					if (pCMapRange != NULL)
						((WORD*)pMapTbl)[c] = (WORD)(pCMapRange->CIDStrt + (uv - pCMapRange->ChCodeStrt));
					else
						((WORD*)pMapTbl)[c] = (WORD)uv;
				}
				else
				{
                	((DWORD*)pMapTbl)[c] = aPStoCP[pWinCodePage->pCsetList[0]].usACP << 16;
                	if (pCMapRange != NULL)
                	{
                    	((DWORD*)pMapTbl)[c] |= pCMapRange->CIDStrt + (uv - pCMapRange->ChCodeStrt);
                	}
                	else
                	{
                    	((DWORD*)pMapTbl)[c] |= uv;
                	}
				}

                c++;
                cCharRun++;
            }
        }

        //
        // Determine if this is a new Unicode run.
        //
        if (bFound && !bInRun)
        {
            //
            // This is the beginning of a new run.
            //
            bInRun = TRUE;
            pGlyphRuns[cRuns].wcLow = (USHORT) (uv & 0xffff);
        }

        //
        // Determine if this is the end of a run.
        //
        if (bInRun && (!bFound || uv == NUM_UNICODE_CHARS || c == cChars))
        {
            //
            // This is the end of a run.
            //
            bInRun = FALSE;
            pGlyphRuns[cRuns].wGlyphCount = cCharRun;
            cRuns++;
            cCharRun = 0;
        }
    }

	if (bVerbose)
	{
		for (i = 0; i < NUM_VARIANTS; i++)
		{
			printf("GLYPHSETDATA:dwFlags:%08X\n", pGlyphSets[i]->dwFlags);
			printf("GLYPHSETDATA:dwGlyphSetNameOffset:%s\n",
						(PSZ)MK_PTR(pGlyphSets[i], dwGlyphSetNameOffset));
			printf("GLYPHSETDATA:dwGlyphCount:%ld\n", pGlyphSets[i]->dwGlyphCount);
			printf("GLYPHSETDATA:dwRunCount:%ld\n", pGlyphSets[i]->dwRunCount);
			printf("GLYPHSETDATA:dwCodePageCount:%ld\n", pGlyphSets[i]->dwCodePageCount);
			{
				DWORD dw;
				PCODEPAGEINFO pcpi = (PCODEPAGEINFO)MK_PTR(pGlyphSets[i], dwCodePageOffset);
				for (dw = 1; dw <= pGlyphSets[i]->dwCodePageCount; dw++)
				{
					printf("CODEPAGEINFO#%ld:dwCodePage:%ld\n", dw, pcpi->dwCodePage);
					printf("CODEPAGEINFO#%ld:dwWinCharset:%ld\n", dw, pcpi->dwWinCharset);
					printf("CODEPAGEINFO#%ld:dwEncodingNameOffset:%s\n",
								dw, (PSZ)MK_PTR(pcpi, dwEncodingNameOffset));
					pcpi++;
				}
			}
			printf("\n");
		}
	}

    //
    // Clean-up: free the local Maps.
    //
    for (i = 0; i < NUM_VARIANTS; i++)
    {
        //
        // Free temporary data structs.
        //
        if (pUv2CcMap[i] != NULL)
        {
            MemFree(pUv2CcMap[i]);
        }
        if (pUv2CidMap[i] != NULL)
        {
            MemFree(pUv2CidMap[i]);
        }
    }

	if (bVerbose) printf("%%[End Create CJK glyphset]%%%%\n\n");

    return(TRUE);
}

BOOLEAN
NumUV2CIDRuns(
    PBYTE   pCMapFile,
    PULONG  pcRuns,
    PULONG  pcChars
    )
/*++

Routine Description:

    Given a memory mapped file ptr to a Postscript CMap, determine
    the number of CIDRanges (Runs) and total number of chars.

Arguments:

    pCMapFile - Pointer to a memory mapped CMap file.
    pcRuns - Pointer to a ULONG which will contain the number of runs.
    pcChars - Pointer to a ULONG which will contain the number of chars.

Return Value:

    TRUE => success
    FALSE => error

--*/
{
    PBYTE   pToken;
    ULONG   cRanges, i;
    USHORT  chRunStrt, chRunEnd;
    BYTE    LineBuffer[25];
    USHORT  usLineLen;

    *pcRuns = *pcChars = 0;

    //
    // Search for the CID ranges, and determine the number of runs and
    // total number of chars in this GLYPHSET.
    //
    for (; (pCMapFile = FindStringToken(pCMapFile, CID_RANGE_TOK)) != NULL; )
    {
        GET_NUM_CID_RANGES(pCMapFile, cRanges);
        *pcRuns += cRanges;
        NEXT_LINE(pCMapFile);
        for (i = 0; i < cRanges; i++)
        {
            PARSE_TOKEN(pCMapFile, pToken);
            //
            // Get begin and end range codes.
            //
            if (!AsciiToHex(pToken, &chRunStrt))
            {
                return(FALSE);
            }
            if (!AsciiToHex(pCMapFile, &chRunEnd))
            {
                return(FALSE);
            }

            //
            // Compute size of run.
            //
            *pcChars += chRunEnd - chRunStrt + 1;
            NEXT_LINE(pCMapFile);
        }
    }
    return(TRUE);
}

BOOLEAN
BuildUV2CIDMap(
    PBYTE   pCMapFile,
    PCMAP   pCMap
    )
/*++

Routine Description:

    Given a memory mapped file ptr to a Postscript CMap, create a CMAP
    struture which contains char run information.

Arguments:

    pCMapFile - Pointer to a memory mapped CMap file.
    pCMap - Pointer to pre allocated memory large enough to contain the CMap.

Return Value:

    TRUE => success.
    FALSE => error.

--*/
{
    ULONG   i, cRuns, cRanges;
    USHORT  chRunStrt, chRunEnd;
    PBYTE   pToken;

    //
    // Process the CMap to determine the number of CID runs
    // and the number of chars in this char collection.
    //
    cRuns = cRanges = 0;
    for (; (pCMapFile = FindStringToken(pCMapFile, CID_RANGE_TOK)) != NULL; )
    {
        GET_NUM_CID_RANGES(pCMapFile, cRanges);

        //
        // Skip to first range.
        //
        NEXT_LINE(pCMapFile);
        for (i = 0; i < cRanges; i++)
        {
            //
            // Retrieve the start and stop codes.
            //
            PARSE_TOKEN(pCMapFile, pToken);

            //
            // Get begin and end range codes.
            //
            if (!AsciiToHex(pToken, &chRunStrt))
            {
                return(FALSE);
            }
            if (!AsciiToHex(pCMapFile, &chRunEnd))
            {
                return(FALSE);
            }
            pCMap->CMapRange[cRuns + i].ChCodeStrt = chRunStrt;
            pCMap->CMapRange[cRuns + i].cChars = chRunEnd - chRunStrt + 1;

            //
            // Get CID.
            //
            PARSE_TOKEN(pCMapFile, pToken);
            pCMap->CMapRange[cRuns + i].CIDStrt = atol(pCMapFile);
            NEXT_LINE(pCMapFile);
        }
        cRuns += cRanges;
    }
    pCMap->cRuns = cRuns;
    return(TRUE);
}

BOOLEAN
NumUV2CCRuns(
    PBYTE   pFile,
    PULONG  pcRuns,
    PULONG  pcChars
    )
/*++

Routine Description:

    Given a memory mapped file ptr to a Unicode to CharCode mapping,
    determine the number of runs and total number of chars.

Arguments:

    pFile - Pointer to a memory mapped file.
    pcRuns - Pointer to a ULONG which will contain the number of runs.
    pcChars - Pointer to a ULONG which will contain the number of chars.

Return Value:

    TRUE => success
    FALSE => error

--*/
{
    PBYTE   pToken;
    USHORT  lastUnicode, lastCharCode;
    USHORT  currentUnicode, currentCharCode;
    ULONG   numChars, numRuns;

    *pcRuns = *pcChars = 0;
    numChars = numRuns = 0;

    lastUnicode = lastCharCode = 0;
    currentUnicode = currentCharCode = 0;

    while (TRUE)
    {
        PARSE_TOKEN(pFile, pToken);
        if (StrCmp(pToken, "EOF") != 0)
        {
            if (!AsciiToHex(pToken, &currentUnicode))
            {
                return(FALSE);
            }

            PARSE_TOKEN(pFile, pToken);
            if (StrCmp(pToken, "EOF") != 0)
            {
                if (!AsciiToHex(pToken, &currentCharCode))
                {
                    return(FALSE);
                }
            }
            else
                return(FALSE);

            (*pcChars)++;
        }
        else
            return(TRUE);

        if ((currentUnicode > (lastUnicode + 1)) ||
            (currentCharCode != (lastCharCode + 1)))
        {
            (*pcRuns)++;
        }

        lastUnicode = currentUnicode;
        lastCharCode = currentCharCode;
    }
}

BOOLEAN
BuildUV2CCMap(
    PBYTE   pFile,
    PCMAP   pCMap
    )
/*++

Routine Description:

    Given a memory mapped file ptr to a Unicode to CharCode mapping,
    create a CMAP struture which contains char run information.

Arguments:

    pFile - Pointer to a memory mapped file.
    pCMap - Pointer to pre allocated memory large enough to contain the CMAP.

Return Value:

    TRUE => success.
    FALSE => error.

--*/
{
    PBYTE   pToken;
    USHORT  startUnicode, startCharCode;
    USHORT  lastUnicode, lastCharCode;
    USHORT  currentUnicode, currentCharCode;
    ULONG   cRuns;
    BOOL    done = FALSE;

    startUnicode = startCharCode = 0;
    lastUnicode = lastCharCode = 0;
    currentUnicode = currentCharCode = 0;
    cRuns = 0;

    while (!done)
    {
        PARSE_TOKEN(pFile, pToken);
        if (StrCmp(pToken, "EOF") != 0)
        {
            if (!AsciiToHex(pToken, &currentUnicode))
            {
                return(FALSE);
            }

            PARSE_TOKEN(pFile, pToken);
            if (StrCmp(pToken, "EOF") != 0)
            {
                if (!AsciiToHex(pToken, &currentCharCode))
                {
                    return(FALSE);
                }
            }
            else
                return(FALSE);
        }
        else
            done = TRUE;

        if ((currentUnicode > (lastUnicode + 1)) ||
            (currentCharCode != (lastCharCode + 1)) ||
            (done))
        {
            if (startUnicode > 0)
            {
                pCMap->CMapRange[cRuns].ChCodeStrt = startUnicode;
                pCMap->CMapRange[cRuns].cChars = lastUnicode - startUnicode + 1;
                pCMap->CMapRange[cRuns].CIDStrt = startCharCode;
                cRuns++;
            }
            startUnicode = currentUnicode;
            startCharCode = currentCharCode;
        }

        lastUnicode = currentUnicode;
        lastCharCode = currentCharCode;
    }

    pCMap->cRuns = cRuns;

    return(TRUE);
}

int __cdecl
CmpCMapRunsCID(
    const VOID *p1,
    const VOID *p2
    )
/*++

Routine Description:

    Compares the starting CID of two CMAPRANGE structs.

Arguments:

    p1, p2 - CMAPRANGEs to compare.

Return Value:

    -1  => p1 < p2
     1  => p1 > p2
     0  => p1 = p2

--*/
{
    PCMAPRANGE ptr1 = (PCMAPRANGE) p1, ptr2 = (PCMAPRANGE) p2;

    //
    // Compare starting CIDs of the ranges.
    //
    if (ptr1->CIDStrt > ptr2->CIDStrt)
        return(1);
    else if (ptr1->CIDStrt < ptr2->CIDStrt)
        return(-1);
    else
        return(0);
}

int __cdecl
CmpCMapRunsChCode(
    const VOID *p1,
    const VOID *p2
    )
/*++

Routine Description:

    Compares the starting Char Code of two CMAPRANGE structs.

Arguments:

    p1, p2 - CMAPRANGEs to compare.

Return Value:

    -1  => p1 < p2
     1  => p1 > p2
     0  => p1 = p2

--*/
{
    PCMAPRANGE ptr1 = (PCMAPRANGE) p1, ptr2 = (PCMAPRANGE) p2;

    //
    // Compare starting CIDs of the ranges.
    //
    if (ptr1->ChCodeStrt < ptr2->ChCodeStrt)
        return(-1);
    else if (ptr1->ChCodeStrt > ptr2->ChCodeStrt)
        return(1);
    else
        return(0);
}

int __cdecl
FindChCodeRun(
    const VOID *p1,
    const VOID *p2
    )
/*++

Routine Description:

    Determines if a Charcode falls within a particular CMap run.

Arguments:

    p1 - CID
    p2 - PCMAPRANGE to check

Return Value:

    -1  => p1 < p2
     1  => p1 > p2
     0  => p1 = p2

--*/
{
    PULONG ptr1 = (PULONG) p1;
    PCMAPRANGE ptr2 = (PCMAPRANGE) p2;

    //
    // Determine if CID is in the current range.
    //
    if (*ptr1 < ptr2->ChCodeStrt)
        return(-1);
    else if (*ptr1 >= (ULONG) ptr2->ChCodeStrt + ptr2->cChars)
        return(1);
    else
        return(0);
}

int __cdecl
FindCIDRun(
    const VOID *p1,
    const VOID *p2
    )
/*++

Routine Description:

    Determines if a CID falls within a particular CMap run.

Arguments:

    p1 - CID
    p2 - PCMAPRANGE to check

Return Value:

    -1  => p1 < p2
     1  => p1 > p2
     0  => p1 = p2

--*/
{
    PULONG ptr1 = (PULONG) p1;
    PCMAPRANGE ptr2 = (PCMAPRANGE) p2;

    //
    // Determine if CID is in the current range.
    //
    if (*ptr1 < ptr2->CIDStrt)
        return(-1);
    else if (*ptr1 >= ptr2->CIDStrt + ptr2->cChars)
        return(1);
    else
        return(0);
}

CHSETSUPPORT
IsCJKFont(
    PBYTE   pAFM
    )
/*++

Routine Description:

    Determine if a font is a CJK (Far Eastern) font.

Arguments:

    pAFM - ptr to memory mapped AFM file

Return Value:

    0 - Font not CJK
    Otherwise, font is CJK, and return value is the Win Codepage value

--*/
{
    PBYTE   pToken;
    USHORT  i;

    //
    // Search for CharacterSet token.
    //
    pToken = pAFMCharacterSetString;
    if (pToken == NULL)
    {
        //
        // We can't determine if this font is CJK, so assume it isn't.
        //
        return 0;
    }

    //
    // Search for CharSet (actually Adobe Char Collection) name in CJK table.
    //
    for (i = 0; i < CjkColTbl.usNumEntries; i++)
    {
        if (!StrCmp(pToken, (PBYTE) (((PKEY) (CjkColTbl.pTbl))[i].pName)))
        {
            return(CSUP(((PKEY) (CjkColTbl.pTbl))[i].usValue));
        }
    }

    //
    // Not a recognized CJK font.
    //
    return 0;
}

BOOLEAN
IsVGlyphSet(
    PGLYPHSETDATA   pGlyphSetData
    )
/*++

Routine Description:

    Determine if a Glyphset is a CJK V variant. Should ONLY be used with
    CJK Glyphsets, otherwise result could be unpredictable!

Arguments:

    pGlyphSetData - ptr to GLYPHSETDATA

Return Value:

    TRUE - this is a V variant
    FALSE - not a V variant

--*/
{
    PBYTE   pName;

    pName = (PBYTE) MK_PTR(pGlyphSetData, dwGlyphSetNameOffset);
    return((pName[strlen(pName) - 1] == 'V'));
}

BOOLEAN
IsCIDFont(
    PBYTE   pAFM
    )
/*++

Routine Description:

    Determine if a font is a CID font.

Arguments:

    pAFM - ptr to memory mapped AFM file

Return Value:

    0 - Font not clone.
    Otherwise, font is a CID font, and return value non-zero.

--*/
{
    PBYTE   pToken;

    if (pToken = FindAFMToken(pAFM, PS_CIDFONT_TOK))
    {
        if (!StrCmp(pToken, "true"))
            return TRUE;
    }
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\tools\ps\makentf\cjkfonts.h ===
/*+

Copyright (c) 1996 Adobe Systems Incorporated
Copyright (c) 1996  Microsoft Corporation

Module Name:

    cjkfonts.h

Abstract:

    Convert CJK AFMs to NTMs.

Environment:

    Windows NT PostScript driver: makentf utility.

Revision History:

    1/13/96 -rkiesler-
        Wrote it.
-*/

//
// Various #defines.
//
#define NUM_CJK_CHAR_ORDERINGS   4

//
// Some defines to make stuff read nice.
//
#define H_CMAP 0                // Horizontal variant CMAP info
#define V_CMAP 1                // Index of Vertical variant CMAP info
#define NUM_VARIANTS    V_CMAP + 1  // Total number of variants

//
// CMap specific tokens
//
#define CMAP_NAME_TOK "/CMapName"
#define CID_RANGE_TOK "begincidrange"
#define DSC_EOF_TOK "%%EOF"

//
// CJK specific data structures.
//
typedef struct _CMAPRANGE
{
    ULONG   CIDStrt;
    USHORT  ChCodeStrt;
    USHORT  cChars;
} CMAPRANGE, *PCMAPRANGE;

typedef struct _CMAP
{
    ULONG   cRuns;
    ULONG   cChars;
    CMAPRANGE   CMapRange[1];
} CMAP, *PCMAP;

//
// Macros for parsing a Postscript CMap.
//
#define GET_NUM_CID_RANGES(pToken, numRanges)                   \
while (!IS_WHTSPACE(pToken))                                    \
{                                                               \
    pToken--;                                                   \
}                                                               \
while (IS_WHTSPACE(pToken))                                     \
{                                                               \
    pToken--;                                                   \
}                                                               \
while (!IS_WHTSPACE(pToken))                                    \
{                                                               \
    pToken--;                                                   \
}                                                               \
pToken++;                                                       \
numRanges = atoi(pToken)

ULONG
CreateCJKGlyphSets(
    PBYTE           *pColCMaps,
    PBYTE           *pUniCMaps,
    PGLYPHSETDATA   *pGlyphSets,
    PWINCODEPAGE    pWinCodePage,
    PULONG          *pUniPsTbl
    );

BOOLEAN
NumUV2CIDRuns(
    PBYTE   pCMapFile,
    PULONG  pcRuns,
    PULONG  pcChars
    );

BOOLEAN
BuildUV2CIDMap(
    PBYTE   pCMapFile,
    PCMAP   pCMap
    );

BOOLEAN
NumUV2CCRuns(
    PBYTE   pFile,
    PULONG  pcRuns,
    PULONG  pcChars
    );

BOOLEAN
BuildUV2CCMap(
    PBYTE   pFile,
    PCMAP   pCMap
    );

int __cdecl
CmpCMapRunsCID(
    const VOID *p1,
    const VOID *p2
    );

int __cdecl
CmpCMapRunsChCode(
    const VOID *p1,
    const VOID *p2
    );

int __cdecl
FindCIDRun(
    const VOID *p1,
    const VOID *p2
    );

int __cdecl
FindChCodeRun(
    const VOID *p1,
    const VOID *p2
    );

CHSETSUPPORT
IsCJKFont(
    PBYTE   pAFM
    );

BOOLEAN
IsVGlyphSet(
    PGLYPHSETDATA   pGlyphSetData
    );

BOOLEAN
BIsCloneFont(
    PBYTE pAFM
    );

BOOLEAN
IsCIDFont(
    PBYTE pAFM
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\tools\ps\makentf\unipstbl.c ===
/*++

Copyright (c) 1996  Adobe Systems Incorporated
Copyright (c) 1996  Microsoft Corporation

Module Name:
    UniPsTbl

Abstract:
    This module contains global data used to create NTM data from AFM files.

Author:
    Rob Kiesler (rkiesler@adobe.com) 10/24/1996

Environment:

Revision History:
    09/10/1997  ksuzuki
            Added WeightKeysCJK table.

    10/28/1996   rkiesler@adobe.com
           Created.

--*/

#include "lib.h"
#include "ppd.h"
#include "pslib.h"
#include "psglyph.h"
#include "afm2ntm.h"


//
// Name of family .DAT file.
//
PWCHAR DatFileName = L"\\psfamily.dat";

//
// Unicode -> PS Char name xlat table, sorted by PS char name.
//
UPSCODEPT PstoUnicode[NUM_PS_CHARS] =
{
    //
    // U+001f => '.notdef1f': this mapping guarantees that the very first
    // bit of the character defintion bitmap (pointed to by NTM.dwCharDefFlagOffset)
    // is clear to make the device glyph index zero a '.notdef' glyph.
    //
    { 0x001F, ".notdef1f", CS_ALL },

    { 0x0041, "A",  CS_ALL },
    { 0x00C6, "AE", CSUP(CS_ANSI) | CSUP(CS_TURKISH) | CSUP(CS_BALTIC) | CSUP(CS_228) },
    { 0x00C1, "Aacute", CSUP(CS_EASTEUROPE) | CSUP(CS_ANSI) | CSUP(CS_TURKISH) | CSUP(CS_228) },
    { 0x0102, "Abreve", CSUP(CS_EASTEUROPE) | CSUP(CS_314) },
    { 0x00C2, "Acircumflex", CSUP(CS_EASTEUROPE) | CSUP(CS_ANSI) | CSUP(CS_TURKISH) | CSUP(CS_228) },
    { 0x00C4, "Adieresis", CSUP(CS_EASTEUROPE) | CSUP(CS_ANSI) | CSUP(CS_TURKISH) | CSUP(CS_BALTIC) | CSUP(CS_228) },
    { 0x00C0, "Agrave", CSUP(CS_ANSI) | CSUP(CS_TURKISH) | CSUP(CS_228) },
    { 0x0391, "Alpha", CSUP(CS_GREEK) },
    { 0x0386, "Alphatonos", CSUP(CS_GREEK) },
    { 0x0100, "Amacron", CSUP(CS_BALTIC) | CSUP(CS_314) },
    { 0x0104, "Aogonek", CSUP(CS_EASTEUROPE) | CSUP(CS_BALTIC) | CSUP(CS_314) },
    { 0x00C5, "Aring", CSUP(CS_ANSI) | CSUP(CS_TURKISH) | CSUP(CS_BALTIC) | CSUP(CS_228) },
    { 0x00C3, "Atilde", CSUP(CS_ANSI) | CSUP(CS_TURKISH) | CSUP(CS_228) },
    { 0x0042, "B", CS_ALL },
    { 0x0392, "Beta", CSUP(CS_GREEK) },
    { 0x0043, "C", CS_ALL },
    { 0x0106, "Cacute", CSUP(CS_EASTEUROPE) | CSUP(CS_BALTIC) | CSUP(CS_314) },
    { 0x010C, "Ccaron", CSUP(CS_EASTEUROPE) | CSUP(CS_BALTIC) | CSUP(CS_314) },
    { 0x00C7, "Ccedilla", CSUP(CS_EASTEUROPE) | CSUP(CS_ANSI) | CSUP(CS_TURKISH) | CSUP(CS_228) },
    { 0x03A7, "Chi", CSUP(CS_GREEK) },
    { 0x0044, "D", CS_ALL },
    { 0x010E, "Dcaron", CSUP(CS_EASTEUROPE) | CSUP(CS_314) },
    { 0x0110, "Dcroat", CSUP(CS_EASTEUROPE) | CSUP(CS_314) },
    { 0x0394, "Delta", CSUP(CS_GREEK) | CSUP(CS_314) },
    { 0x0045, "E", CS_ALL },
    { 0x00C9, "Eacute", CSUP(CS_EASTEUROPE) | CSUP(CS_ANSI) | CSUP(CS_TURKISH) | CSUP(CS_BALTIC) | CSUP(CS_228) },
    { 0x011A, "Ecaron", CSUP(CS_EASTEUROPE) | CSUP(CS_314) },
    { 0x00CA, "Ecircumflex", CSUP(CS_ANSI) | CSUP(CS_TURKISH) | CSUP(CS_228) },
    { 0x00CB, "Edieresis", CSUP(CS_EASTEUROPE) | CSUP(CS_ANSI) | CSUP(CS_TURKISH) | CSUP(CS_228) },
    { 0x0116, "Edotaccent", CSUP(CS_314) },
    { 0x0116, "Edot", CSUP(CS_BALTIC) },
    { 0x00C8, "Egrave", CSUP(CS_ANSI) | CSUP(CS_TURKISH) | CSUP(CS_228) },
    { 0x0112, "Emacron", CSUP(CS_BALTIC) | CSUP(CS_314) },
    { 0x0118, "Eogonek", CSUP(CS_EASTEUROPE) | CSUP(CS_BALTIC) | CSUP(CS_314) },
    { 0x0395, "Epsilon", CSUP(CS_GREEK) },
    { 0x0388, "Epsilontonos", CSUP(CS_GREEK) },
    { 0x0397, "Eta", CSUP(CS_GREEK) },
    { 0x0389, "Etatonos", CSUP(CS_GREEK) },
    { 0x00D0, "Eth", CSUP(CS_ANSI) | CSUP(CS_228) },
    { 0x20AC, "Euro", CS_EURO },
    { 0x0046, "F", CS_ALL },
    { 0x0047, "G", CS_ALL },
    { 0x0393, "Gamma", CSUP(CS_GREEK) },
    { 0x011E, "Gbreve", CSUP(CS_TURKISH) | CSUP(CS_314) },
    { 0x0122, "Gcedilla", CSUP(CS_BALTIC) }, // TODO
    { 0x0122, "Gcommaaccent", CSUP(CS_314) },
    { 0x0048, "H", CS_ALL },
    { 0x0049, "I", CS_ALL },
    { 0x00CD, "Iacute", CSUP(CS_EASTEUROPE) | CSUP(CS_ANSI) | CSUP(CS_TURKISH) | CSUP(CS_228) },
    { 0x00CE, "Icircumflex", CSUP(CS_EASTEUROPE) | CSUP(CS_ANSI) | CSUP(CS_TURKISH) | CSUP(CS_228) },
    { 0x00CF, "Idieresis", CSUP(CS_ANSI) | CSUP(CS_TURKISH) | CSUP(CS_228) },
    { 0x0130, "Idotaccent", CSUP(CS_TURKISH) | CSUP(CS_314) },
    { 0x00CC, "Igrave", CSUP(CS_ANSI) | CSUP(CS_TURKISH) | CSUP(CS_228) },
    { 0x012A, "Imacron", CSUP(CS_BALTIC) | CSUP(CS_314) },
    { 0x012E, "Iogonek", CSUP(CS_BALTIC) | CSUP(CS_314) },
    { 0x0399, "Iota", CSUP(CS_GREEK) },
    { 0x03AA, "Iotadieresis", CSUP(CS_GREEK) },
    { 0x038A, "Iotatonos", CSUP(CS_GREEK) },
    { 0x004A, "J", CS_ALL },
    { 0x004B, "K", CS_ALL },
    { 0x039A, "Kappa", CSUP(CS_GREEK) },
    { 0x0136, "Kcedilla", CSUP(CS_BALTIC) }, // TODO
    { 0x0136, "Kcommaaccent", CSUP(CS_314) },
    { 0x004C, "L", CS_ALL },
    { 0x0139, "Lacute", CSUP(CS_EASTEUROPE) | CSUP(CS_314) },
    { 0x039B, "Lambda", CSUP(CS_GREEK) },
    { 0x013D, "Lcaron", CSUP(CS_EASTEUROPE) | CSUP(CS_314) },
    { 0x013B, "Lcedilla", CSUP(CS_BALTIC) }, // TODO
    { 0x013B, "Lcommaaccent", CSUP(CS_314) },
    { 0x0141, "Lslash", CSUP(CS_EASTEUROPE) | CSUP(CS_BALTIC) | CSUP(CS_228) },
    { 0x004D, "M", CS_ALL },
    { 0x039C, "Mu", CSUP(CS_GREEK) },
    { 0x004E, "N", CS_ALL },
    { 0x0143, "Nacute", CSUP(CS_EASTEUROPE) | CSUP(CS_BALTIC) | CSUP(CS_314) },
    { 0x0147, "Ncaron", CSUP(CS_EASTEUROPE) | CSUP(CS_314) },
    { 0x0145, "Ncedilla", CSUP(CS_BALTIC) }, // TODO
    { 0x0145, "Ncommaaccent", CSUP(CS_314) },
    { 0x00D1, "Ntilde", CSUP(CS_ANSI) | CSUP(CS_TURKISH) | CSUP(CS_228) },
    { 0x039D, "Nu", CSUP(CS_GREEK) },
    { 0x004F, "O", CS_ALL },
    { 0x0152, "OE", CSUP(CS_ANSI) | CSUP(CS_TURKISH) | CSUP(CS_ARABIC) | CSUP(CS_228) },
    { 0x00D3, "Oacute", CSUP(CS_EASTEUROPE) | CSUP(CS_ANSI) | CSUP(CS_TURKISH) | CSUP(CS_BALTIC) | CSUP(CS_228) },
    { 0x00D4, "Ocircumflex", CSUP(CS_EASTEUROPE) | CSUP(CS_ANSI) | CSUP(CS_TURKISH) | CSUP(CS_228) },
    { 0x00D6, "Odieresis", CSUP(CS_EASTEUROPE) | CSUP(CS_ANSI) | CSUP(CS_TURKISH) | CSUP(CS_BALTIC) | CSUP(CS_228) },
    { 0x00D2, "Ograve", CSUP(CS_ANSI) | CSUP(CS_TURKISH) | CSUP(CS_228) },
    { 0x0150, "Ohungarumlaut", CSUP(CS_EASTEUROPE) | CSUP(CS_314) },
    { 0x014C, "Omacron", CSUP(CS_BALTIC) | CSUP(CS_314) },
    { 0x03A9, "Omega", CSUP(CS_GREEK) },
    { 0x038F, "Omegatonos", CSUP(CS_GREEK) },
    { 0x039F, "Omicron", CSUP(CS_GREEK) },
    { 0x038C, "Omicrontonos", CSUP(CS_GREEK) },
    { 0x00D8, "Oslash", CSUP(CS_ANSI) | CSUP(CS_TURKISH) | CSUP(CS_228) },
    { 0x00D5, "Otilde", CSUP(CS_ANSI) | CSUP(CS_TURKISH) | CSUP(CS_BALTIC) | CSUP(CS_228) },
    { 0x0050, "P", CS_ALL },
    { 0x03A6, "Phi", CSUP(CS_GREEK) },
    { 0x03A0, "Pi", CSUP(CS_GREEK) },
    { 0x03A8, "Psi", CSUP(CS_GREEK) },
    { 0x0051, "Q", CS_ALL },
    { 0x0052, "R", CS_ALL },
    { 0x0154, "Racute", CSUP(CS_EASTEUROPE) | CSUP(CS_314) },
    { 0x0158, "Rcaron", CSUP(CS_EASTEUROPE) | CSUP(CS_314) },
    { 0x0156, "Rcedilla", CSUP(CS_BALTIC) }, // TODO
    { 0x0156, "Rcommaaccent", CSUP(CS_314) },
    { 0x03A1, "Rho", CSUP(CS_GREEK) },
    { 0x0053, "S", CS_ALL },
    { 0x015A, "Sacute", CSUP(CS_EASTEUROPE) | CSUP(CS_BALTIC) | CSUP(CS_314) },
    { 0x0160, "Scaron", CSUP(CS_EASTEUROPE) | CSUP(CS_ANSI) | CSUP(CS_TURKISH) | CSUP(CS_BALTIC) | CSUP(CS_228) },
    { 0xF6C1, "Scedilla", CSUP(CS_314) },
    { 0x015E, "Scommaaccent", CSUP(CS_EASTEUROPE) | CSUP(CS_TURKISH) | CSUP(CS_314) },
    { 0x03A3, "Sigma", CSUP(CS_GREEK) },
    { 0x0054, "T", CS_ALL },
    { 0x03A4, "Tau", CSUP(CS_GREEK) },
    { 0x0164, "Tcaron", CSUP(CS_EASTEUROPE) | CSUP(CS_314) },
    { 0x0162, "Tcommaaccent", CSUP(CS_EASTEUROPE) | CSUP(CS_314) },
    { 0x0398, "Theta", CSUP(CS_GREEK) },
    { 0x00DE, "Thorn", CSUP(CS_ANSI) | CSUP(CS_228) },
    { 0x0055, "U", CS_ALL },
    { 0x00DA, "Uacute", CSUP(CS_EASTEUROPE) | CSUP(CS_ANSI) | CSUP(CS_TURKISH) | CSUP(CS_228) },
    { 0x00DB, "Ucircumflex", CSUP(CS_ANSI) | CSUP(CS_TURKISH) | CSUP(CS_228) },
    { 0x00DC, "Udieresis", CSUP(CS_EASTEUROPE) | CSUP(CS_ANSI) | CSUP(CS_TURKISH) | CSUP(CS_BALTIC) | CSUP(CS_228) },
    { 0x00D9, "Ugrave", CSUP(CS_ANSI) | CSUP(CS_TURKISH) | CSUP(CS_228) },
    { 0x0170, "Uhungarumlaut", CSUP(CS_EASTEUROPE) | CSUP(CS_314) },
    { 0x016A, "Umacron", CSUP(CS_BALTIC) | CSUP(CS_314) },
    { 0x0172, "Uogonek", CSUP(CS_BALTIC) | CSUP(CS_314) },
    { 0x03A5, "Upsilon", CSUP(CS_GREEK) },
    { 0x03AB, "Upsilondieresis", CSUP(CS_GREEK) },
    { 0x038E, "Upsilontonos", CSUP(CS_GREEK) },
    { 0x016E, "Uring", CSUP(CS_EASTEUROPE) | CSUP(CS_314) },
    { 0x0056, "V", CS_ALL },
    { 0x0057, "W", CS_ALL },
    { 0x0058, "X", CS_ALL },
    { 0x039E, "Xi", CSUP(CS_GREEK) },
    { 0x0059, "Y", CS_ALL },
    { 0x00DD, "Yacute", CSUP(CS_EASTEUROPE) | CSUP(CS_ANSI) | CSUP(CS_228) },
    { 0x0178, "Ydieresis", CSUP(CS_ANSI) | CSUP(CS_TURKISH) | CSUP(CS_228) },
    { 0x005A, "Z", CS_ALL },
    { 0x0179, "Zacute", CSUP(CS_EASTEUROPE) | CSUP(CS_BALTIC) | CSUP(CS_314) },
    { 0x017D, "Zcaron", CSUP(CS_EASTEUROPE) | CSUP(CS_BALTIC) | CSUP(CS_228) | CSUP(CS_ANSI)},
    { 0x017B, "Zdotaccent", CSUP(CS_EASTEUROPE) | CSUP(CS_BALTIC) | CSUP(CS_314) },
    { 0x0396, "Zeta", CSUP(CS_GREEK) },
    { 0x0061, "a", CS_ALL },
    { 0x00E1, "aacute", CSUP(CS_EASTEUROPE) | CSUP(CS_ANSI) | CSUP(CS_TURKISH) | CSUP(CS_228) },
    { 0x0103, "abreve", CSUP(CS_EASTEUROPE) | CSUP(CS_314) },
    { 0x00E2, "acircumflex", CSUP(CS_EASTEUROPE) | CSUP(CS_ANSI) | CSUP(CS_TURKISH) | CSUP(CS_ARABIC) | CSUP(CS_228) },
    { 0x00B4, "acute", CSUP(CS_EASTEUROPE) | CSUP(CS_ANSI) | CSUP(CS_TURKISH) | CSUP(CS_HEBREW) | CSUP(CS_ARABIC) | CSUP(CS_BALTIC) | CSUP(CS_228) },
    { 0x00E4, "adieresis", CSUP(CS_EASTEUROPE) | CSUP(CS_ANSI) | CSUP(CS_TURKISH) | CSUP(CS_BALTIC) | CSUP(CS_228) },
    { 0x00E6, "ae", CSUP(CS_ANSI) | CSUP(CS_TURKISH) | CSUP(CS_BALTIC) | CSUP(CS_228) },
    { 0x2015, "afii00208", CSUP(CS_GREEK) },
    { 0x0410, "afii10017", CSUP(CS_RUSSIAN) },
    { 0x0411, "afii10018", CSUP(CS_RUSSIAN) },
    { 0x0412, "afii10019", CSUP(CS_RUSSIAN) },
    { 0x0413, "afii10020", CSUP(CS_RUSSIAN) },
    { 0x0414, "afii10021", CSUP(CS_RUSSIAN) },
    { 0x0415, "afii10022", CSUP(CS_RUSSIAN) },
    { 0x0401, "afii10023", CSUP(CS_RUSSIAN) },
    { 0x0416, "afii10024", CSUP(CS_RUSSIAN) },
    { 0x0417, "afii10025", CSUP(CS_RUSSIAN) },
    { 0x0418, "afii10026", CSUP(CS_RUSSIAN) },
    { 0x0419, "afii10027", CSUP(CS_RUSSIAN) },
    { 0x041A, "afii10028", CSUP(CS_RUSSIAN) },
    { 0x041B, "afii10029", CSUP(CS_RUSSIAN) },
    { 0x041C, "afii10030", CSUP(CS_RUSSIAN) },
    { 0x041D, "afii10031", CSUP(CS_RUSSIAN) },
    { 0x041E, "afii10032", CSUP(CS_RUSSIAN) },
    { 0x041F, "afii10033", CSUP(CS_RUSSIAN) },
    { 0x0420, "afii10034", CSUP(CS_RUSSIAN) },
    { 0x0421, "afii10035", CSUP(CS_RUSSIAN) },
    { 0x0422, "afii10036", CSUP(CS_RUSSIAN) },
    { 0x0423, "afii10037", CSUP(CS_RUSSIAN) },
    { 0x0424, "afii10038", CSUP(CS_RUSSIAN) },
    { 0x0425, "afii10039", CSUP(CS_RUSSIAN) },
    { 0x0426, "afii10040", CSUP(CS_RUSSIAN) },
    { 0x0427, "afii10041", CSUP(CS_RUSSIAN) },
    { 0x0428, "afii10042", CSUP(CS_RUSSIAN) },
    { 0x0429, "afii10043", CSUP(CS_RUSSIAN) },
    { 0x042A, "afii10044", CSUP(CS_RUSSIAN) },
    { 0x042B, "afii10045", CSUP(CS_RUSSIAN) },
    { 0x042C, "afii10046", CSUP(CS_RUSSIAN) },
    { 0x042D, "afii10047", CSUP(CS_RUSSIAN) },
    { 0x042E, "afii10048", CSUP(CS_RUSSIAN) },
    { 0x042F, "afii10049", CSUP(CS_RUSSIAN) },
    { 0x0490, "afii10050", CSUP(CS_RUSSIAN) },
    { 0x0402, "afii10051", CSUP(CS_RUSSIAN) },
    { 0x0403, "afii10052", CSUP(CS_RUSSIAN) },
    { 0x0404, "afii10053", CSUP(CS_RUSSIAN) },
    { 0x0405, "afii10054", CSUP(CS_RUSSIAN) },
    { 0x0406, "afii10055", CSUP(CS_RUSSIAN) },
    { 0x0407, "afii10056", CSUP(CS_RUSSIAN) },
    { 0x0408, "afii10057", CSUP(CS_RUSSIAN) },
    { 0x0409, "afii10058", CSUP(CS_RUSSIAN) },
    { 0x040A, "afii10059", CSUP(CS_RUSSIAN) },
    { 0x040B, "afii10060", CSUP(CS_RUSSIAN) },
    { 0x040C, "afii10061", CSUP(CS_RUSSIAN) },
    { 0x040E, "afii10062", CSUP(CS_RUSSIAN) },
    { 0x0430, "afii10065", CSUP(CS_RUSSIAN) },
    { 0x0431, "afii10066", CSUP(CS_RUSSIAN) },
    { 0x0432, "afii10067", CSUP(CS_RUSSIAN) },
    { 0x0433, "afii10068", CSUP(CS_RUSSIAN) },
    { 0x0434, "afii10069", CSUP(CS_RUSSIAN) },
    { 0x0435, "afii10070", CSUP(CS_RUSSIAN) },
    { 0x0451, "afii10071", CSUP(CS_RUSSIAN) },
    { 0x0436, "afii10072", CSUP(CS_RUSSIAN) },
    { 0x0437, "afii10073", CSUP(CS_RUSSIAN) },
    { 0x0438, "afii10074", CSUP(CS_RUSSIAN) },
    { 0x0439, "afii10075", CSUP(CS_RUSSIAN) },
    { 0x043A, "afii10076", CSUP(CS_RUSSIAN) },
    { 0x043B, "afii10077", CSUP(CS_RUSSIAN) },
    { 0x043C, "afii10078", CSUP(CS_RUSSIAN) },
    { 0x043D, "afii10079", CSUP(CS_RUSSIAN) },
    { 0x043E, "afii10080", CSUP(CS_RUSSIAN) },
    { 0x043F, "afii10081", CSUP(CS_RUSSIAN) },
    { 0x0440, "afii10082", CSUP(CS_RUSSIAN) },
    { 0x0441, "afii10083", CSUP(CS_RUSSIAN) },
    { 0x0442, "afii10084", CSUP(CS_RUSSIAN) },
    { 0x0443, "afii10085", CSUP(CS_RUSSIAN) },
    { 0x0444, "afii10086", CSUP(CS_RUSSIAN) },
    { 0x0445, "afii10087", CSUP(CS_RUSSIAN) },
    { 0x0446, "afii10088", CSUP(CS_RUSSIAN) },
    { 0x0447, "afii10089", CSUP(CS_RUSSIAN) },
    { 0x0448, "afii10090", CSUP(CS_RUSSIAN) },
    { 0x0449, "afii10091", CSUP(CS_RUSSIAN) },
    { 0x044A, "afii10092", CSUP(CS_RUSSIAN) },
    { 0x044B, "afii10093", CSUP(CS_RUSSIAN) },
    { 0x044C, "afii10094", CSUP(CS_RUSSIAN) },
    { 0x044D, "afii10095", CSUP(CS_RUSSIAN) },
    { 0x044E, "afii10096", CSUP(CS_RUSSIAN) },
    { 0x044F, "afii10097", CSUP(CS_RUSSIAN) },
    { 0x0491, "afii10098", CSUP(CS_RUSSIAN) },
    { 0x0452, "afii10099", CSUP(CS_RUSSIAN) },
    { 0x0453, "afii10100", CSUP(CS_RUSSIAN) },
    { 0x0454, "afii10101", CSUP(CS_RUSSIAN) },
    { 0x0455, "afii10102", CSUP(CS_RUSSIAN) },
    { 0x0456, "afii10103", CSUP(CS_RUSSIAN) },
    { 0x0457, "afii10104", CSUP(CS_RUSSIAN) },
    { 0x0458, "afii10105", CSUP(CS_RUSSIAN) },
    { 0x0459, "afii10106", CSUP(CS_RUSSIAN) },
    { 0x045A, "afii10107", CSUP(CS_RUSSIAN) },
    { 0x045B, "afii10108", CSUP(CS_RUSSIAN) },
    { 0x045C, "afii10109", CSUP(CS_RUSSIAN) },
    { 0x045E, "afii10110", CSUP(CS_RUSSIAN) },
    { 0x040F, "afii10145", CSUP(CS_RUSSIAN) },
    { 0x045F, "afii10193", CSUP(CS_RUSSIAN) },
    { 0x060C, "afii57388", CSUP(CS_ARABIC) },
    { 0x061B, "afii57403", CSUP(CS_ARABIC) },
    { 0x061F, "afii57407", CSUP(CS_ARABIC) },
    { 0x0621, "afii57409", CSUP(CS_ARABIC) },
    { 0x0622, "afii57410", CSUP(CS_ARABIC) },
    { 0x0623, "afii57411", CSUP(CS_ARABIC) },
    { 0x0624, "afii57412", CSUP(CS_ARABIC) },
    { 0x0625, "afii57413", CSUP(CS_ARABIC) },
    { 0x0626, "afii57414", CSUP(CS_ARABIC) },
    { 0x0627, "afii57415", CSUP(CS_ARABIC) },
    { 0x0628, "afii57416", CSUP(CS_ARABIC) },
    { 0x0629, "afii57417", CSUP(CS_ARABIC) },
    { 0x062A, "afii57418", CSUP(CS_ARABIC) },
    { 0x062B, "afii57419", CSUP(CS_ARABIC) },
    { 0x062C, "afii57420", CSUP(CS_ARABIC) },
    { 0x062D, "afii57421", CSUP(CS_ARABIC) },
    { 0x062E, "afii57422", CSUP(CS_ARABIC) },
    { 0x062F, "afii57423", CSUP(CS_ARABIC) },
    { 0x0630, "afii57424", CSUP(CS_ARABIC) },
    { 0x0631, "afii57425", CSUP(CS_ARABIC) },
    { 0x0632, "afii57426", CSUP(CS_ARABIC) },
    { 0x0633, "afii57427", CSUP(CS_ARABIC) },
    { 0x0634, "afii57428", CSUP(CS_ARABIC) },
    { 0x0635, "afii57429", CSUP(CS_ARABIC) },
    { 0x0636, "afii57430", CSUP(CS_ARABIC) },
    { 0x0637, "afii57431", CSUP(CS_ARABIC) },
    { 0x0638, "afii57432", CSUP(CS_ARABIC) },
    { 0x0639, "afii57433", CSUP(CS_ARABIC) },
    { 0x063A, "afii57434", CSUP(CS_ARABIC) },
    { 0x0640, "afii57440", CSUP(CS_ARABIC) },
    { 0x0641, "afii57441", CSUP(CS_ARABIC) },
    { 0x0642, "afii57442", CSUP(CS_ARABIC) },
    { 0x0643, "afii57443", CSUP(CS_ARABIC) },
    { 0x0644, "afii57444", CSUP(CS_ARABIC) },
    { 0x0645, "afii57445", CSUP(CS_ARABIC) },
    { 0x0646, "afii57446", CSUP(CS_ARABIC) },
    { 0x0648, "afii57448", CSUP(CS_ARABIC) },
    { 0x0649, "afii57449", CSUP(CS_ARABIC) },
    { 0x064A, "afii57450", CSUP(CS_ARABIC) },
    { 0x064B, "afii57451", CSUP(CS_ARABIC) },
    { 0x064C, "afii57452", CSUP(CS_ARABIC) },
    { 0x064D, "afii57453", CSUP(CS_ARABIC) },
    { 0x064E, "afii57454", CSUP(CS_ARABIC) },
    { 0x064F, "afii57455", CSUP(CS_ARABIC) },
    { 0x0650, "afii57456", CSUP(CS_ARABIC) },
    { 0x0651, "afii57457", CSUP(CS_ARABIC) },
    { 0x0652, "afii57458", CSUP(CS_ARABIC) },
    { 0x0647, "afii57470", CSUP(CS_ARABIC) },
    { 0x067E, "afii57506", CSUP(CS_ARABIC) },
    { 0x0686, "afii57507", CSUP(CS_ARABIC) },
    { 0x0698, "afii57508", CSUP(CS_ARABIC) },
    { 0x06AF, "afii57509", CSUP(CS_ARABIC) },
    { 0x200E, "afii57596", CSUP(CS_HEBREW) | CSUP(CS_ARABIC) },
    { 0x200F, "afii57597", CSUP(CS_HEBREW) | CSUP(CS_ARABIC) },
    { 0x200D, "afii57598", CSUP(CS_ARABIC) },
    { 0x20AA, "afii57636", CSUP(CS_HEBREW) },
    { 0x05BE, "afii57645", CSUP(CS_HEBREW) },
    { 0x05C3, "afii57658", CSUP(CS_HEBREW) },
    { 0x05D0, "afii57664", CSUP(CS_HEBREW) },
    { 0x05D1, "afii57665", CSUP(CS_HEBREW) },
    { 0x05D2, "afii57666", CSUP(CS_HEBREW) },
    { 0x05D3, "afii57667", CSUP(CS_HEBREW) },
    { 0x05D4, "afii57668", CSUP(CS_HEBREW) },
    { 0x05D5, "afii57669", CSUP(CS_HEBREW) },
    { 0x05D6, "afii57670", CSUP(CS_HEBREW) },
    { 0x05D7, "afii57671", CSUP(CS_HEBREW) },
    { 0x05D8, "afii57672", CSUP(CS_HEBREW) },
    { 0x05D9, "afii57673", CSUP(CS_HEBREW) },
    { 0x05DA, "afii57674", CSUP(CS_HEBREW) },
    { 0x05DB, "afii57675", CSUP(CS_HEBREW) },
    { 0x05DC, "afii57676", CSUP(CS_HEBREW) },
    { 0x05DD, "afii57677", CSUP(CS_HEBREW) },
    { 0x05DE, "afii57678", CSUP(CS_HEBREW) },
    { 0x05DF, "afii57679", CSUP(CS_HEBREW) },
    { 0x05E0, "afii57680", CSUP(CS_HEBREW) },
    { 0x05E1, "afii57681", CSUP(CS_HEBREW) },
    { 0x05E2, "afii57682", CSUP(CS_HEBREW) },
    { 0x05E3, "afii57683", CSUP(CS_HEBREW) },
    { 0x05E4, "afii57684", CSUP(CS_HEBREW) },
    { 0x05E5, "afii57685", CSUP(CS_HEBREW) },
    { 0x05E6, "afii57686", CSUP(CS_HEBREW) },
    { 0x05E7, "afii57687", CSUP(CS_HEBREW) },
    { 0x05E8, "afii57688", CSUP(CS_HEBREW) },
    { 0x05E9, "afii57689", CSUP(CS_HEBREW) },
    { 0x05EA, "afii57690", CSUP(CS_HEBREW) },
    { 0x05F0, "afii57716", CSUP(CS_HEBREW) },
    { 0x05F1, "afii57717", CSUP(CS_HEBREW) },
    { 0x05F2, "afii57718", CSUP(CS_HEBREW) },
    { 0x05B4, "afii57793", CSUP(CS_HEBREW) },
    { 0x05B5, "afii57794", CSUP(CS_HEBREW) },
    { 0x05B6, "afii57795", CSUP(CS_HEBREW) },
    { 0x05BB, "afii57796", CSUP(CS_HEBREW) },
    { 0x05B8, "afii57797", CSUP(CS_HEBREW) },
    { 0x05B7, "afii57798", CSUP(CS_HEBREW) },
    { 0x05B0, "afii57799", CSUP(CS_HEBREW) },
    { 0x05B2, "afii57800", CSUP(CS_HEBREW) },
    { 0x05B1, "afii57801", CSUP(CS_HEBREW) },
    { 0x05B3, "afii57802", CSUP(CS_HEBREW) },
    { 0x05C2, "afii57803", CSUP(CS_HEBREW) },
    { 0x05C1, "afii57804", CSUP(CS_HEBREW) },
    { 0x05B9, "afii57806", CSUP(CS_HEBREW) },
    { 0x05BC, "afii57807", CSUP(CS_HEBREW) },
    { 0x05BD, "afii57839", CSUP(CS_HEBREW) },
    { 0x05BF, "afii57841", CSUP(CS_HEBREW) },
    { 0x05C0, "afii57842", CSUP(CS_HEBREW) },
    { 0x2116, "afii61352", CSUP(CS_RUSSIAN) },
    { 0x200C, "afii61664", CSUP(CS_ARABIC) },
    { 0x00E0, "agrave", CSUP(CS_ANSI) | CSUP(CS_TURKISH) | CSUP(CS_ARABIC) | CSUP(CS_228) },
    { 0x03B1, "alpha", CSUP(CS_GREEK) },
    { 0x03AC, "alphatonos", CSUP(CS_GREEK) },
    { 0x0101, "amacron", CSUP(CS_BALTIC) | CSUP(CS_314) },
    { 0x0026, "ampersand", CS_ALL },
    { 0x0105, "aogonek", CSUP(CS_EASTEUROPE) | CSUP(CS_BALTIC) | CSUP(CS_314) },
    { 0x00E5, "aring", CSUP(CS_ANSI) | CSUP(CS_TURKISH) | CSUP(CS_BALTIC) | CSUP(CS_228) },
    { 0x005E, "asciicircum", CS_ALL },
    { 0x007E, "asciitilde", CS_ALL },
    { 0x002A, "asterisk", CS_ALL },
    { 0x0040, "at", CS_ALL },
    { 0x00E3, "atilde", CSUP(CS_ANSI) | CSUP(CS_TURKISH) | CSUP(CS_228) },
    { 0x0062, "b", CS_ALL },
    { 0x005C, "backslash", CS_ALL },
    { 0x007C, "bar", CS_ALL },
    { 0x03B2, "beta", CSUP(CS_GREEK) },
    { 0x007B, "braceleft", CS_ALL },
    { 0x007D, "braceright", CS_ALL },
    { 0x005B, "bracketleft", CS_ALL },
    { 0x005D, "bracketright", CS_ALL },
    { 0x02D8, "breve", CSUP(CS_EASTEUROPE) | CSUP(CS_BALTIC) | CSUP(CS_228) },
    { 0x00A6, "brokenbar", CS_ALL },
    { 0x2022, "bullet", CS_ALL },
    { 0x0063, "c", CS_ALL },
    { 0x0107, "cacute", CSUP(CS_EASTEUROPE) | CSUP(CS_BALTIC) | CSUP(CS_314) },
    { 0x02C7, "caron", CSUP(CS_EASTEUROPE) | CSUP(CS_BALTIC) | CSUP(CS_228) },
    { 0x010D, "ccaron", CSUP(CS_EASTEUROPE) | CSUP(CS_BALTIC) | CSUP(CS_314) },
    { 0x00E7, "ccedilla", CSUP(CS_EASTEUROPE) | CSUP(CS_ANSI) | CSUP(CS_TURKISH) | CSUP(CS_ARABIC) | CSUP(CS_228) },
    { 0x00B8, "cedilla", CSUP(CS_EASTEUROPE) | CSUP(CS_ANSI) | CSUP(CS_TURKISH) | CSUP(CS_ARABIC) | CSUP(CS_BALTIC) | CSUP(CS_228) },
    { 0x00A2, "cent", CSUP(CS_ANSI) | CSUP(CS_TURKISH) | CSUP(CS_HEBREW) | CSUP(CS_ARABIC) | CSUP(CS_228) },
    { 0x03C7, "chi", CSUP(CS_GREEK) },
    { 0x02C6, "circumflex", CSUP(CS_ANSI) | CSUP(CS_TURKISH) | CSUP(CS_HEBREW) | CSUP(CS_ARABIC) | CSUP(CS_228) },
    { 0x003A, "colon", CS_ALL },
    { 0x002C, "comma", CS_ALL },
    { 0xF6C3, "commaaccent", CSUP(CS_314) },
    { 0x00A9, "copyright", CS_ALL },
    { 0x00A4, "currency", CSUP(CS_EASTEUROPE) | CSUP(CS_RUSSIAN) | CSUP(CS_ANSI) | CSUP(CS_GREEK) | CSUP(CS_TURKISH) | CSUP(CS_ARABIC) | CSUP(CS_BALTIC) | CSUP(CS_228) },
    { 0x0064, "d", CS_ALL },
    { 0x2020, "dagger", CS_ALL },
    { 0x2021, "daggerdbl", CS_ALL },
    { 0x010F, "dcaron", CSUP(CS_EASTEUROPE) | CSUP(CS_314) },
    { 0x0111, "dcroat", CSUP(CS_EASTEUROPE) | CSUP(CS_314) },
    { 0x00B0, "degree", CSUP(CS_EASTEUROPE) | CSUP(CS_RUSSIAN) | CSUP(CS_ANSI) | CSUP(CS_GREEK) | CSUP(CS_TURKISH) | CSUP(CS_HEBREW) | CSUP(CS_ARABIC) | CSUP(CS_228) },
    { 0x03B4, "delta", CSUP(CS_GREEK) },
    { 0x00A8, "dieresis", CSUP(CS_EASTEUROPE) | CSUP(CS_ANSI) | CSUP(CS_GREEK) | CSUP(CS_TURKISH) | CSUP(CS_HEBREW) | CSUP(CS_ARABIC) | CSUP(CS_BALTIC) | CSUP(CS_228) },
    { 0x0385, "dieresistonos", CSUP(CS_GREEK) },
    { 0x00F7, "divide", CSUP(CS_EASTEUROPE) | CSUP(CS_ANSI) | CSUP(CS_TURKISH) | CSUP(CS_ARABIC) | CSUP(CS_BALTIC) | CSUP(CS_228) },
    { 0x0024, "dollar", CS_ALL },
    { 0x02D9, "dotaccent", CSUP(CS_EASTEUROPE) | CSUP(CS_BALTIC) | CSUP(CS_228) },
    { 0x0131, "dotlessi", CSUP(CS_TURKISH) | CSUP(CS_228) },
    { 0x0065, "e", CS_ALL },
    { 0x00E9, "eacute", CSUP(CS_EASTEUROPE) | CSUP(CS_ANSI) | CSUP(CS_TURKISH) | CSUP(CS_ARABIC) | CSUP(CS_BALTIC) | CSUP(CS_228) },
    { 0x011B, "ecaron", CSUP(CS_EASTEUROPE) | CSUP(CS_314) },
    { 0x00EA, "ecircumflex", CSUP(CS_ANSI) | CSUP(CS_TURKISH) | CSUP(CS_ARABIC) | CSUP(CS_228) },
    { 0x00EB, "edieresis", CSUP(CS_EASTEUROPE) | CSUP(CS_ANSI) | CSUP(CS_TURKISH) | CSUP(CS_ARABIC) | CSUP(CS_228) },
    { 0x0117, "edot", CSUP(CS_BALTIC) }, // TODO
    { 0x0117, "edotaccent", CSUP(CS_314) },
    { 0x00E8, "egrave", CSUP(CS_ANSI) | CSUP(CS_TURKISH) | CSUP(CS_ARABIC) | CSUP(CS_228) },
    { 0x0038, "eight", CS_ALL },
    { 0x2026, "ellipsis", CS_ALL },
    { 0x0113, "emacron", CSUP(CS_BALTIC) | CSUP(CS_314) },
    { 0x2014, "emdash", CS_ALL },
    { 0x2013, "endash", CS_ALL },
    { 0x0119, "eogonek", CSUP(CS_EASTEUROPE) | CSUP(CS_BALTIC) | CSUP(CS_314) },
    { 0x03B5, "epsilon", CSUP(CS_GREEK) },
    { 0x03AD, "epsilontonos", CSUP(CS_GREEK) },
    { 0x003D, "equal", CS_ALL },
    { 0x03B7, "eta", CSUP(CS_GREEK) },
    { 0x03AE, "etatonos", CSUP(CS_GREEK) },
    { 0x00F0, "eth", CSUP(CS_ANSI) | CSUP(CS_228) },
    { 0x0021, "exclam", CS_ALL },
    { 0x00A1, "exclamdown", CSUP(CS_ANSI) | CSUP(CS_TURKISH) | CSUP(CS_228) },
    { 0x0066, "f", CS_ALL },
    { 0xFB01, "fi", CSUP(CS_228) },
    { 0x0035, "five", CS_ALL },
    { 0xFB02, "fl", CSUP(CS_228) },
    { 0x0192, "florin", CSUP(CS_ANSI) | CSUP(CS_GREEK) | CSUP(CS_TURKISH) | CSUP(CS_HEBREW) | CSUP(CS_ARABIC) | CSUP(CS_228) },
    { 0x0034, "four", CS_ALL },
    { 0x2044, "fraction", CSUP(CS_228) },
    { 0x0067, "g", CS_ALL },
    { 0x03B3, "gamma", CSUP(CS_GREEK) },
    { 0x011F, "gbreve", CSUP(CS_TURKISH) | CSUP(CS_314) },
    { 0x0123, "gcedilla", CSUP(CS_BALTIC) }, // TODO
    { 0x0123, "gcommaaccent", CSUP(CS_314) },
    { 0x00DF, "germandbls", CSUP(CS_EASTEUROPE) | CSUP(CS_ANSI) | CSUP(CS_TURKISH) | CSUP(CS_BALTIC) | CSUP(CS_228) },
    { 0x0060, "grave", CS_ALL },
    { 0x003E, "greater", CS_ALL },
    { 0x2265, "greaterequal", CSUP(CS_314) },
    { 0x00AB, "guillemotleft", CS_ALL },
    { 0x00BB, "guillemotright", CS_ALL },
    { 0x2039, "guilsinglleft", CS_ALL },
    { 0x203A, "guilsinglright", CS_ALL },
    { 0x0068, "h", CS_ALL },
    { 0x02DD, "hungarumlaut", CSUP(CS_EASTEUROPE) | CSUP(CS_228) },
    { 0x002D, "hyphen", CS_ALL },
    { 0x0069, "i", CS_ALL },
    { 0x00ED, "iacute", CSUP(CS_EASTEUROPE) | CSUP(CS_ANSI) | CSUP(CS_TURKISH) | CSUP(CS_228) },
    { 0x00EE, "icircumflex", CSUP(CS_EASTEUROPE) | CSUP(CS_ANSI) | CSUP(CS_TURKISH) | CSUP(CS_ARABIC) | CSUP(CS_228) },
    { 0x00EF, "idieresis", CSUP(CS_ANSI) | CSUP(CS_TURKISH) | CSUP(CS_ARABIC) | CSUP(CS_228) },
    { 0x00EC, "igrave", CSUP(CS_ANSI) | CSUP(CS_TURKISH) | CSUP(CS_228) },
    { 0x012B, "imacron", CSUP(CS_BALTIC) | CSUP(CS_314) },
    { 0x012F, "iogonek", CSUP(CS_BALTIC) | CSUP(CS_314) },
    { 0x03B9, "iota", CSUP(CS_GREEK) },
    { 0x0390, "iotadieresistonos", CSUP(CS_GREEK) },
    { 0x03CA, "iotadieresis", CSUP(CS_GREEK) },
    { 0x03AF, "iotatonos", CSUP(CS_GREEK) },
    { 0x006A, "j", CS_ALL },
    { 0x006B, "k", CS_ALL },
    { 0x03BA, "kappa", CSUP(CS_GREEK) },
    { 0x0137, "kcedilla", CSUP(CS_BALTIC) }, // TODO
    { 0x0137, "kcommaaccent", CSUP(CS_314) },
    { 0x006C, "l", CS_ALL },
    { 0x013A, "lacute", CSUP(CS_EASTEUROPE) | CSUP(CS_314) },
    { 0x03BB, "lambda", CSUP(CS_GREEK) },
    { 0x013E, "lcaron", CSUP(CS_EASTEUROPE) | CSUP(CS_314) },
    { 0x013C, "lcedilla", CSUP(CS_BALTIC) }, // TODO
    { 0x013C, "lcommaaccent", CSUP(CS_314) },
    { 0x003C, "less", CS_ALL },
    { 0x2264, "lessequal", CSUP(CS_314) },
    { 0x00AC, "logicalnot", CS_ALL },
    { 0x25CA, "lozenge", CSUP(CS_314) },
    { 0x0142, "lslash", CSUP(CS_EASTEUROPE) | CSUP(CS_BALTIC) | CSUP(CS_228) },
    { 0x006D, "m", CS_ALL },
    { 0x00AF, "macron", CSUP(CS_ANSI) | CSUP(CS_TURKISH) | CSUP(CS_HEBREW) | CSUP(CS_ARABIC) | CSUP(CS_228) },
    { 0x2212, "minus", CSUP(CS_228) },
    { 0x00B5, "mu", CS_ALL },
    { 0x03BC, "mu", CSUP(CS_GREEK) },
    { 0x00D7, "multiply", CSUP(CS_EASTEUROPE) | CSUP(CS_ANSI) | CSUP(CS_TURKISH) | CSUP(CS_ARABIC) | CSUP(CS_BALTIC) | CSUP(CS_228) },
    { 0x006E, "n", CS_ALL },
    { 0x0144, "nacute", CSUP(CS_EASTEUROPE) | CSUP(CS_BALTIC) | CSUP(CS_314) },
    { 0x00A0, "space", CS_ALL }, // 'nbspace'
    { 0x0148, "ncaron", CSUP(CS_EASTEUROPE) | CSUP(CS_314) },
    { 0x0146, "ncedilla", CSUP(CS_BALTIC) }, // TODO
    { 0x0146, "ncommaaccent", CSUP(CS_314) },
    { 0x0039, "nine", CS_ALL },
    { 0x2260, "notequal", CSUP(CS_314) },
    { 0x00F1, "ntilde", CSUP(CS_ANSI) | CSUP(CS_TURKISH) | CSUP(CS_228) },
    { 0x03BD, "nu", CSUP(CS_GREEK) },
    { 0x0023, "numbersign", CS_ALL },
    { 0x006F, "o", CS_ALL },
    { 0x00F3, "oacute", CSUP(CS_EASTEUROPE) | CSUP(CS_ANSI) | CSUP(CS_TURKISH) | CSUP(CS_BALTIC) | CSUP(CS_228) },
    { 0x00F4, "ocircumflex", CSUP(CS_EASTEUROPE) | CSUP(CS_ANSI) | CSUP(CS_TURKISH) | CSUP(CS_ARABIC) | CSUP(CS_228) },
    { 0x00F6, "odieresis", CSUP(CS_EASTEUROPE) | CSUP(CS_ANSI) | CSUP(CS_TURKISH) | CSUP(CS_BALTIC) | CSUP(CS_228) },
    { 0x0153, "oe", CSUP(CS_ANSI) | CSUP(CS_TURKISH) | CSUP(CS_ARABIC) | CSUP(CS_228) },
    { 0x02DB, "ogonek", CSUP(CS_EASTEUROPE) | CSUP(CS_BALTIC) | CSUP(CS_228) },
    { 0x00F2, "ograve", CSUP(CS_ANSI) | CSUP(CS_TURKISH) | CSUP(CS_228) },
    { 0x0151, "ohungarumlaut", CSUP(CS_EASTEUROPE) | CSUP(CS_314) },
    { 0x014D, "omacron", CSUP(CS_BALTIC) | CSUP(CS_314) },
    { 0x03C9, "omega", CSUP(CS_GREEK) },
    { 0x03CE, "omegatonos", CSUP(CS_GREEK) },
    { 0x03BF, "omicron", CSUP(CS_GREEK) },
    { 0x03CC, "omicrontonos", CSUP(CS_GREEK) },
    { 0x0031, "one", CS_ALL },
    { 0x00BD, "onehalf", CSUP(CS_ANSI) | CSUP(CS_GREEK) | CSUP(CS_TURKISH) | CSUP(CS_HEBREW) | CSUP(CS_ARABIC) | CSUP(CS_BALTIC) | CSUP(CS_228) },
    { 0x00BC, "onequarter", CSUP(CS_ANSI) | CSUP(CS_TURKISH) | CSUP(CS_HEBREW) | CSUP(CS_ARABIC) | CSUP(CS_BALTIC) | CSUP(CS_228) },
    { 0x00B9, "onesuperior", CSUP(CS_ANSI) | CSUP(CS_TURKISH) | CSUP(CS_HEBREW) | CSUP(CS_ARABIC) | CSUP(CS_BALTIC) | CSUP(CS_228) },
    { 0x00AA, "ordfeminine", CSUP(CS_ANSI) | CSUP(CS_GREEK) | CSUP(CS_TURKISH) | CSUP(CS_228) },
    { 0x00BA, "ordmasculine", CSUP(CS_ANSI) | CSUP(CS_TURKISH) | CSUP(CS_228) },
    { 0x00F8, "oslash", CSUP(CS_ANSI) | CSUP(CS_TURKISH) | CSUP(CS_228) },
    { 0x00F5, "otilde", CSUP(CS_ANSI) | CSUP(CS_TURKISH) | CSUP(CS_BALTIC) | CSUP(CS_228) },
    { 0x0070, "p", CS_ALL },
    { 0x00B6, "paragraph", CS_ALL },
    { 0x0028, "parenleft", CS_ALL },
    { 0x0029, "parenright", CS_ALL },
    { 0x2202, "partialdiff", CSUP(CS_314) },
    { 0x0025, "percent", CS_ALL },
    { 0x002E, "period", CS_ALL },
    { 0x00B7, "periodcentered", CS_ALL },
    { 0x2030, "perthousand", CS_ALL },
    { 0x03C6, "phi", CSUP(CS_GREEK) },
    { 0x03C0, "pi", CSUP(CS_GREEK) },
    { 0x002B, "plus", CS_ALL },
    { 0x00B1, "plusminus", CS_ALL },
    { 0x03C8, "psi", CSUP(CS_GREEK) },
    { 0x0071, "q", CS_ALL },
    { 0x003F, "question", CS_ALL },
    { 0x00BF, "questiondown", CSUP(CS_ANSI) | CSUP(CS_TURKISH) | CSUP(CS_228) },
    { 0x0022, "quotedbl", CS_ALL },
    { 0x201E, "quotedblbase", CS_ALL },
    { 0x201C, "quotedblleft", CS_ALL },
    { 0x201D, "quotedblright", CS_ALL },
    { 0x2018, "quoteleft", CS_ALL },
    { 0x2019, "quoteright", CS_ALL },
    { 0x201A, "quotesinglbase", CS_ALL },
    { 0x0027, "quotesingle", CS_ALL },
    { 0x0072, "r", CS_ALL },
    { 0x0155, "racute", CSUP(CS_EASTEUROPE) | CSUP(CS_314) },
    { 0x221A, "radical", CSUP(CS_314) },
    { 0x0159, "rcaron", CSUP(CS_EASTEUROPE) | CSUP(CS_314) },
    { 0x0157, "rcedilla", CSUP(CS_BALTIC) }, // TODO
    { 0x0157, "rcommaaccent", CSUP(CS_314) },
    { 0x00AE, "registered", CS_ALL },
    { 0x03C1, "rho", CSUP(CS_GREEK) },
    { 0x02DA, "ring", CSUP(CS_BALTIC) | CSUP(CS_228) },
    { 0x0073, "s", CS_ALL },
    { 0x015B, "sacute", CSUP(CS_EASTEUROPE) | CSUP(CS_BALTIC) | CSUP(CS_314) },
    { 0x0161, "scaron", CSUP(CS_EASTEUROPE) | CSUP(CS_ANSI) | CSUP(CS_TURKISH) | CSUP(CS_BALTIC) | CSUP(CS_228) },
    { 0xF6C2, "scedilla", CSUP(CS_314) },
    { 0x015F, "scommaaccent", CSUP(CS_EASTEUROPE) | CSUP(CS_TURKISH) | CSUP(CS_314) },
    { 0x00A7, "section", CS_ALL },
    { 0x003B, "semicolon", CS_ALL },
    { 0x0037, "seven", CS_ALL },
    { 0x00AD, "hyphen", CS_ALL }, // 'sfthyphen'
    { 0x03C3, "sigma", CSUP(CS_GREEK) },
    { 0x03C2, "sigma1", CSUP(CS_GREEK) },
    { 0x0036, "six", CS_ALL },
    { 0x002F, "slash", CS_ALL },
    { 0x0020, "space", CS_ALL },
    { 0x00A3, "sterling", CSUP(CS_ANSI) | CSUP(CS_GREEK) | CSUP(CS_TURKISH) | CSUP(CS_HEBREW) | CSUP(CS_ARABIC) | CSUP(CS_BALTIC) | CSUP(CS_228) },
    { 0x2211, "summation", CSUP(CS_314) },
    { 0x0074, "t", CS_ALL },
    { 0x03C4, "tau", CSUP(CS_GREEK) },
    { 0x0165, "tcaron", CSUP(CS_EASTEUROPE) | CSUP(CS_314) },
    { 0x0163, "tcommaaccent", CSUP(CS_EASTEUROPE) | CSUP(CS_314) },
    { 0x03B8, "theta", CSUP(CS_GREEK) },
    { 0x00FE, "thorn", CSUP(CS_ANSI) | CSUP(CS_228) },
    { 0x0033, "three", CS_ALL },
    { 0x00BE, "threequarters", CSUP(CS_ANSI) | CSUP(CS_TURKISH) | CSUP(CS_HEBREW) | CSUP(CS_ARABIC) | CSUP(CS_BALTIC) | CSUP(CS_228) },
    { 0x00B3, "threesuperior", CSUP(CS_ANSI) | CSUP(CS_GREEK) | CSUP(CS_TURKISH) | CSUP(CS_HEBREW) | CSUP(CS_ARABIC) | CSUP(CS_BALTIC) | CSUP(CS_228) },
    { 0x02DC, "tilde", CSUP(CS_ANSI) | CSUP(CS_TURKISH) | CSUP(CS_HEBREW) | CSUP(CS_228) },
    { 0x0384, "tonos", CSUP(CS_GREEK) },
    { 0x2122, "trademark", CS_ALL },
    { 0x0032, "two", CS_ALL },
    { 0x00B2, "twosuperior", CSUP(CS_ANSI) | CSUP(CS_GREEK) | CSUP(CS_TURKISH) | CSUP(CS_HEBREW) | CSUP(CS_ARABIC) | CSUP(CS_228) },
    { 0x0075, "u", CS_ALL },
    { 0x00FA, "uacute", CSUP(CS_EASTEUROPE) | CSUP(CS_ANSI) | CSUP(CS_TURKISH) | CSUP(CS_228) },
    { 0x00FB, "ucircumflex", CSUP(CS_ANSI) | CSUP(CS_TURKISH) | CSUP(CS_ARABIC) | CSUP(CS_228) },
    { 0x00FC, "udieresis", CSUP(CS_EASTEUROPE) | CSUP(CS_ANSI) | CSUP(CS_TURKISH) | CSUP(CS_ARABIC) | CSUP(CS_BALTIC) | CSUP(CS_228) },
    { 0x00F9, "ugrave", CSUP(CS_ANSI) | CSUP(CS_TURKISH) | CSUP(CS_ARABIC) | CSUP(CS_228) },
    { 0x0171, "uhungarumlaut", CSUP(CS_EASTEUROPE) | CSUP(CS_314) },
    { 0x016B, "umacron", CSUP(CS_BALTIC) | CSUP(CS_314) },
    { 0x005F, "underscore", CS_ALL },
    { 0x0173, "uogonek", CSUP(CS_BALTIC) | CSUP(CS_314) },
    { 0x03C5, "upsilon", CSUP(CS_GREEK) },
    { 0x03B0, "upsilon-dieresistonos", CSUP(CS_GREEK) },
    { 0x03CB, "upsilondieresis", CSUP(CS_GREEK) },
    { 0x03CD, "upsilontonos", CSUP(CS_GREEK) },
    { 0x016F, "uring", CSUP(CS_EASTEUROPE) | CSUP(CS_314) },
    { 0x0076, "v", CS_ALL },
    { 0x0077, "w", CS_ALL },
    { 0x0078, "x", CS_ALL },
    { 0x03BE, "xi", CSUP(CS_GREEK) },
    { 0x0079, "y", CS_ALL },
    { 0x00FD, "yacute", CSUP(CS_EASTEUROPE) | CSUP(CS_ANSI) | CSUP(CS_228) },
    { 0x00FF, "ydieresis", CSUP(CS_ANSI) | CSUP(CS_TURKISH) | CSUP(CS_228) },
    { 0x00A5, "yen", CSUP(CS_ANSI) | CSUP(CS_GREEK) | CSUP(CS_TURKISH) | CSUP(CS_HEBREW) | CSUP(CS_ARABIC) | CSUP(CS_228) },
    { 0x007A, "z", CS_ALL },
    { 0x017A, "zacute", CSUP(CS_EASTEUROPE) | CSUP(CS_BALTIC) | CSUP(CS_314) },
    { 0x017E, "zcaron", CSUP(CS_EASTEUROPE) | CSUP(CS_BALTIC) | CSUP(CS_228) | CSUP(CS_ANSI)},
    { 0x017C, "zdotaccent", CSUP(CS_EASTEUROPE) | CSUP(CS_BALTIC) | CSUP(CS_314) },
    { 0x0030, "zero", CS_ALL },
    { 0x03B6, "zeta", CSUP(CS_GREEK) },
};

//
// List of standard codepages. These are codepages for which we store
// predefined GLYPHSETDATA structures. The order of WINCODEPAGE structs
// in this list MUST correspond to the order of codepages (charsets) defined
// in the CHSETSUPPORT enumerated type.
//
WINCODEPAGE aStdCPList[] =
{
    { 1, ADOBE228_GS_NAME,              { CS_228 } },
    { 2, ADOBE314_GS_NAME,              { CS_228, CS_314 } },
    { 1, EASTEUROPE_GS_NAME,            { CS_EASTEUROPE } },
    { 1, SYMBOL_GS_NAME,                { CS_SYMBOL } },
    { 1, CYRILLIC_GS_NAME,              { CS_RUSSIAN } },
    { 1, ANSI_GS_NAME,                  { CS_ANSI } },
    { 1, GREEK_GS_NAME,                 { CS_GREEK } },
    { 1, TURKISH_GS_NAME,               { CS_TURKISH } },
    { 1, HEBREW_GS_NAME,                { CS_HEBREW } },
    { 1, ARABIC_GS_NAME,                { CS_ARABIC } },
    { 1, BALTIC_GS_NAME,                { CS_BALTIC } },
    { 2, ANSI_CYR_GS_NAME,              { CS_ANSI, CS_RUSSIAN } },
    { 5, ANSI_CYR_EE_BAL_TURK_GS_NAME,  { CS_ANSI, CS_RUSSIAN, CS_EASTEUROPE, CS_BALTIC, CS_TURKISH } },

    { 1, CHN_BIG5_GS_NAME,              { CS_CHINESEBIG5 } },
    { 1, CHN_SMPL_GBK_GS_NAME,          { CS_GB2312 } },
    { 1, SHIFTJIS_GS_NAME,              { CS_SHIFTJIS } },
    { 1, SHIFTJIS_P_GS_NAME,            { CS_SHIFTJISP } },
    { 1, SHIFTJIS_83PV_GS_NAME,         { CS_SHIFTJIS83 } },
    { 1, KSCMS_UHC_GS_NAME,             { CS_HANGEUL } },
    { 1, KSCMS_UHC_HW_GS_NAME,          { CS_HANGEULHW } },
    { 1, KSC_JOHAB_GS_NAME,             { CS_JOHAB } }
};

//
// The Unicode CodePage. This is used primarily for support of .PFB fonts
// when we need to obtain CP/CC from a Unicode value. This code page is
// not placed in aStdCPList above since we don't actually want any NTMs
// to reference this GLYPHSET.
//
WINCODEPAGE UnicodePage =
{
    8, UNICODE_GS_NAME,
    {
        CS_ANSI,
        CS_EASTEUROPE,
        CS_RUSSIAN,
        CS_GREEK,
        CS_TURKISH,
        CS_HEBREW,
        CS_ARABIC,
        CS_BALTIC
    }
};

WINCPTOPS aPStoCP[CS_MAX] =
{
    //
    // Made up code page.
    //
    { 0xFFF1, ADOBE228_CHARSET, ADOBE228_GS_NAME, 229,
        {
        { "A", 0x0041 },
        { "AE", 0x00C6 },
        { "Aacute", 0x00C1 },
        { "Acircumflex", 0x00C2 },
        { "Adieresis", 0x00C4 },
        { "Agrave", 0x00C0 },
        { "Aring", 0x00C5 },
        { "Atilde", 0x00C3 },
        { "B", 0x0042 },
        { "C", 0x0043 },
        { "Ccedilla", 0x00C7 },
        { "D", 0x0044 },
        { "E", 0x0045 },
        { "Eacute", 0x00C9 },
        { "Ecircumflex", 0x00CA },
        { "Edieresis", 0x00CB },
        { "Egrave", 0x00C8 },
        { "Eth", 0x00D0 },
        { "Euro", 0x0080 },
        { "F", 0x0046 },
        { "G", 0x0047 },
        { "H", 0x0048 },
        { "I", 0x0049 },
        { "Iacute", 0x00CD },
        { "Icircumflex", 0x00CE },
        { "Idieresis", 0x00CF },
        { "Igrave", 0x00CC },
        { "J", 0x004A },
        { "K", 0x004B },
        { "L", 0x004C },
        { "Lslash", 0x0009 },
        { "M", 0x004D },
        { "N", 0x004E },
        { "Ntilde", 0x00D1 },
        { "O", 0x004F },
        { "OE", 0x008C },
        { "Oacute", 0x00D3 },
        { "Ocircumflex", 0x00D4 },
        { "Odieresis", 0x00D6 },
        { "Ograve", 0x00D2 },
        { "Oslash", 0x00D8 },
        { "Otilde", 0x00D5 },
        { "P", 0x0050 },
        { "Q", 0x0051 },
        { "R", 0x0052 },
        { "S", 0x0053 },
        { "Scaron", 0x008A },
        { "T", 0x0054 },
        { "Thorn", 0x00DE },
        { "U", 0x0055 },
        { "Uacute", 0x00DA },
        { "Ucircumflex", 0x00DB },
        { "Udieresis", 0x00DC },
        { "Ugrave", 0x00D9 },
        { "V", 0x0056 },
        { "W", 0x0057 },
        { "X", 0x0058 },
        { "Y", 0x0059 },
        { "Yacute", 0x00DD },
        { "Ydieresis", 0x009F },
        { "Z", 0x005A },
        { "Zcaron", 0x000E },
        { "a", 0x0061 },
        { "aacute", 0x00E1 },
        { "acircumflex", 0x00E2 },
        { "acute", 0x00B4 },
        { "adieresis", 0x00E4 },
        { "ae", 0x00E6 },
        { "agrave", 0x00E0 },
        { "ampersand", 0x0026 },
        { "aring", 0x00E5 },
        { "asciicircum", 0x005E },
        { "asciitilde", 0x007E },
        { "asterisk", 0x002A },
        { "at", 0x0040 },
        { "atilde", 0x00E3 },
        { "b", 0x0062 },
        { "backslash", 0x005C },
        { "bar", 0x007C },
        { "braceleft", 0x007B },
        { "braceright", 0x007D },
        { "bracketleft", 0x005B },
        { "bracketright", 0x005D },
        { "breve", 0x0001 },
        { "brokenbar", 0x00A6 },
        { "bullet", 0x0095 },
        { "c", 0x0063 },
        { "caron", 0x0002 },
        { "ccedilla", 0x00E7 },
        { "cedilla", 0x00B8 },
        { "cent", 0x00A2 },
        { "circumflex", 0x0088 },
        { "colon", 0x003A },
        { "comma", 0x002C },
        { "copyright", 0x00A9 },
        { "currency", 0x00A4 },
        { "d", 0x0064 },
        { "dagger", 0x0086 },
        { "daggerdbl", 0x0087 },
        { "degree", 0x00B0 },
        { "dieresis", 0x00A8 },
        { "divide", 0x00F7 },
        { "dollar", 0x0024 },
        { "dotaccent", 0x0003 },
        { "dotlessi", 0x0004 },
        { "e", 0x0065 },
        { "eacute", 0x00E9 },
        { "ecircumflex", 0x00EA },
        { "edieresis", 0x00EB },
        { "egrave", 0x00E8 },
        { "eight", 0x0038 },
        { "ellipsis", 0x0085 },
        { "emdash", 0x0097 },
        { "endash", 0x0096 },
        { "equal", 0x003D },
        { "eth", 0x00F0 },
        { "exclam", 0x0021 },
        { "exclamdown", 0x00A1 },
        { "f", 0x0066 },
        { "fi", 0x0005 },
        { "five", 0x0035 },
        { "fl", 0x0006 },
        { "florin", 0x0083 },
        { "four", 0x0034 },
        { "fraction", 0x0007 },
        { "g", 0x0067 },
        { "germandbls", 0x00DF },
        { "grave", 0x0060 },
        { "greater", 0x003E },
        { "guillemotleft", 0x00AB },
        { "guillemotright", 0x00BB },
        { "guilsinglleft", 0x008B },
        { "guilsinglright", 0x009B },
        { "h", 0x0068 },
        { "hungarumlaut", 0x0008 },
        { "hyphen", 0x002D },
        { "i", 0x0069 },
        { "iacute", 0x00ED },
        { "icircumflex", 0x00EE },
        { "idieresis", 0x00EF },
        { "igrave", 0x00EC },
        { "j", 0x006A },
        { "k", 0x006B },
        { "l", 0x006C },
        { "less", 0x003C },
        { "logicalnot", 0x00AC },
        { "lslash", 0x000A },
        { "m", 0x006D },
        { "macron", 0x00AF },
        { "minus", 0x000B },
        { "mu", 0x00B5 },
        { "multiply", 0x00D7 },
        { "n", 0x006E },
        { "nine", 0x0039 },
        { "ntilde", 0x00F1 },
        { "numbersign", 0x0023 },
        { "o", 0x006F },
        { "oacute", 0x00F3 },
        { "ocircumflex", 0x00F4 },
        { "odieresis", 0x00F6 },
        { "oe", 0x009C },
        { "ogonek", 0x000C },
        { "ograve", 0x00F2 },
        { "one", 0x0031 },
        { "onehalf", 0x00BD },
        { "onequarter", 0x00BC },
        { "onesuperior", 0x00B9 },
        { "ordfeminine", 0x00AA },
        { "ordmasculine", 0x00BA },
        { "oslash", 0x00F8 },
        { "otilde", 0x00F5 },
        { "p", 0x0070 },
        { "paragraph", 0x00B6 },
        { "parenleft", 0x0028 },
        { "parenright", 0x0029 },
        { "percent", 0x0025 },
        { "period", 0x002E },
        { "periodcentered", 0x00B7 },
        { "perthousand", 0x0089 },
        { "plus", 0x002B },
        { "plusminus", 0x00B1 },
        { "q", 0x0071 },
        { "question", 0x003F },
        { "questiondown", 0x00BF },
        { "quotedbl", 0x0022 },
        { "quotedblbase", 0x0084 },
        { "quotedblleft", 0x0093 },
        { "quotedblright", 0x0094 },
        { "quoteleft", 0x0091 },
        { "quoteright", 0x0092 },
        { "quotesinglbase", 0x0082 },
        { "quotesingle", 0x0027 },
        { "r", 0x0072 },
        { "registered", 0x00AE },
        { "ring", 0x000D },
        { "s", 0x0073 },
        { "scaron", 0x009A },
        { "section", 0x00A7 },
        { "semicolon", 0x003B },
        { "seven", 0x0037 },
        { "six", 0x0036 },
        { "slash", 0x002F },
        { "space", 0x0020 },
        { "sterling", 0x00A3 },
        { "t", 0x0074 },
        { "thorn", 0x00FE },
        { "three", 0x0033 },
        { "threequarters", 0x00BE },
        { "threesuperior", 0x00B3 },
        { "tilde", 0x0098 },
        { "trademark", 0x0099 },
        { "two", 0x0032 },
        { "twosuperior", 0x00B2 },
        { "u", 0x0075 },
        { "uacute", 0x00FA },
        { "ucircumflex", 0x00FB },
        { "udieresis", 0x00FC },
        { "ugrave", 0x00F9 },
        { "underscore", 0x005F },
        { "v", 0x0076 },
        { "w", 0x0077 },
        { "x", 0x0078 },
        { "y", 0x0079 },
        { "yacute", 0x00FD },
        { "ydieresis", 0x00FF },
        { "yen", 0x00A5 },
        { "z", 0x007A },
        { "zcaron", 0x000F },
        { "zero", 0x0030 },
        }
    },

    //
    // Made up code page.
    // remember to increase the count (follows ADOBE314_GS_NAME) when addin gnew chars to this Encoding
    //
    { 0xFFF2, ADOBE314_CHARSET, ADOBE314_GS_NAME, 0x0056,
        {
        { "Abreve", 0x0001 },
        { "Amacron", 0x0002 },
        { "Aogonek", 0x0003 },
        { "Cacute", 0x0004 },
        { "Ccaron", 0x0005 },
        { "Dcaron", 0x0006 },
        { "Dcroat", 0x0007 },
        { "Delta", 0x0008 },
        { "Ecaron", 0x0009 },
        { "Edotaccent", 0x000A },
        { "Emacron", 0x000B },
        { "Eogonek", 0x000C },
        { "Gbreve", 0x000D },
        { "Gcommaaccent", 0x000E },
        { "Idotaccent", 0x000F },
        { "Imacron", 0x0010 },
        { "Iogonek", 0x0011 },
        { "Kcommaaccent", 0x0012 },
        { "Lacute", 0x0013 },
        { "Lcaron", 0x0014 },
        { "Lcommaaccent", 0x0015 },
        { "Nacute", 0x0016 },
        { "Ncaron", 0x0017 },
        { "Ncommaaccent", 0x0018 },
        { "Ohungarumlaut", 0x0019 },
        { "Omacron", 0x001A },
        { "Racute", 0x001B },
        { "Rcaron", 0x001C },
        { "Rcommaaccent", 0x001D },
        { "Sacute", 0x001E },
        { "Scedilla", 0x001F },
        { "Scommaaccent", 0x0020 },
        { "Tcaron", 0x0021 },
        { "Tcommaaccent", 0x0022 },
        { "Uhungarumlaut", 0x0023 },
        { "Umacron", 0x0024 },
        { "Uogonek", 0x0025 },
        { "Uring", 0x0026 },
        { "Zacute", 0x0027 },
        { "Zdotaccent", 0x0028 },
        { "abreve", 0x0029 },
        { "amacron", 0x002A },
        { "aogonek", 0x002B },
        { "cacute", 0x002C },
        { "ccaron", 0x002D },
        { "commaaccent", 0x002E },
        { "dcaron", 0x002F },
        { "dcroat", 0x0030 },
        { "ecaron", 0x0031 },
        { "edotaccent", 0x0032 },
        { "emacron", 0x0033 },
        { "eogonek", 0x0034 },
        { "gbreve", 0x0035 },
        { "gcommaaccent", 0x0036 },
        { "greaterequal", 0x0037 },
        { "imacron", 0x0038 },
        { "iogonek", 0x0039 },
        { "kcommaaccent", 0x003A },
        { "lacute", 0x003B },
        { "lcaron", 0x003C },
        { "lcommaaccent", 0x003D },
        { "lessequal", 0x003E },
        { "lozenge", 0x003F },
        { "nacute", 0x0040 },
        { "ncaron", 0x0041 },
        { "ncommaaccent", 0x0042 },
        { "notequal", 0x0043 },
        { "ohungarumlaut", 0x0044 },
        { "omacron", 0x0045 },
        { "partialdiff", 0x0046 },
        { "racute", 0x0047 },
        { "radical", 0x0048 },
        { "rcaron", 0x0049 },
        { "rcommaaccent", 0x004A },
        { "sacute", 0x004B },
        { "scedilla", 0x004C },
        { "scommaaccent", 0x004D },
        { "summation", 0x004E },
        { "tcaron", 0x004F },
        { "tcommaaccent", 0x0050 },
        { "uhungarumlaut", 0x0051 },
        { "umacron", 0x0052 },
        { "uogonek", 0x0053 },
        { "uring", 0x0054 },
        { "zacute", 0x0055 },
        { "zdotaccent", 0x0056 },
        }
    },

    //
    // Code page 1250: Win 3.1 Eastern European
    //
    { 1250, EASTEUROPE_CHARSET, EASTEUROPE_GS_NAME, 218,
        {
        { "A", 0x0041 },
        { "Aacute", 0x00C1 },
        { "Abreve", 0x00C3 },
        { "Acircumflex", 0x00C2 },
        { "Adieresis", 0x00C4 },
        { "Aogonek", 0x00A5 },
        { "B", 0x0042 },
        { "C", 0x0043 },
        { "Cacute", 0x00C6 },
        { "Ccaron", 0x00C8 },
        { "Ccedilla", 0x00C7 },
        { "D", 0x0044 },
        { "Dcaron", 0x00CF },
        { "Dcroat", 0x00D0 },
        { "E", 0x0045 },
        { "Eacute", 0x00C9 },
        { "Ecaron", 0x00CC },
        { "Edieresis", 0x00CB },
        { "Eogonek", 0x00CA },
        { "Euro", 0x0080 },
        { "F", 0x0046 },
        { "G", 0x0047 },
        { "H", 0x0048 },
        { "I", 0x0049 },
        { "Iacute", 0x00CD },
        { "Icircumflex", 0x00CE },
        { "J", 0x004A },
        { "K", 0x004B },
        { "L", 0x004C },
        { "Lacute", 0x00C5 },
        { "Lcaron", 0x00BC },
        { "Lslash", 0x00A3 },
        { "M", 0x004D },
        { "N", 0x004E },
        { "Nacute", 0x00D1 },
        { "Ncaron", 0x00D2 },
        { "O", 0x004F },
        { "Oacute", 0x00D3 },
        { "Ocircumflex", 0x00D4 },
        { "Odieresis", 0x00D6 },
        { "Ohungarumlaut", 0x00D5 },
        { "P", 0x0050 },
        { "Q", 0x0051 },
        { "R", 0x0052 },
        { "Racute", 0x00C0 },
        { "Rcaron", 0x00D8 },
        { "S", 0x0053 },
        { "Sacute", 0x008C },
        { "Scaron", 0x008A },
        { "Scommaaccent", 0x00AA },
        { "T", 0x0054 },
        { "Tcaron", 0x008D },
        { "Tcommaaccent", 0x00DE },
        { "U", 0x0055 },
        { "Uacute", 0x00DA },
        { "Udieresis", 0x00DC },
        { "Uhungarumlaut", 0x00DB },
        { "Uring", 0x00D9 },
        { "V", 0x0056 },
        { "W", 0x0057 },
        { "X", 0x0058 },
        { "Y", 0x0059 },
        { "Yacute", 0x00DD },
        { "Z", 0x005A },
        { "Zacute", 0x008F },
        { "Zcaron", 0x008E },
        { "Zdotaccent", 0x00AF },
        { "a", 0x0061 },
        { "aacute", 0x00E1 },
        { "abreve", 0x00E3 },
        { "acircumflex", 0x00E2 },
        { "acute", 0x00B4 },
        { "adieresis", 0x00E4 },
        { "ampersand", 0x0026 },
        { "aogonek", 0x00B9 },
        { "asciicircum", 0x005E },
        { "asciitilde", 0x007E },
        { "asterisk", 0x002A },
        { "at", 0x0040 },
        { "b", 0x0062 },
        { "backslash", 0x005C },
        { "bar", 0x007C },
        { "braceleft", 0x007B },
        { "braceright", 0x007D },
        { "bracketleft", 0x005B },
        { "bracketright", 0x005D },
        { "breve", 0x00A2 },
        { "brokenbar", 0x00A6 },
        { "bullet", 0x0095 },
        { "c", 0x0063 },
        { "cacute", 0x00E6 },
        { "caron", 0x00A1 },
        { "ccaron", 0x00E8 },
        { "ccedilla", 0x00E7 },
        { "cedilla", 0x00B8 },
        { "colon", 0x003A },
        { "comma", 0x002C },
        { "copyright", 0x00A9 },
        { "currency", 0x00A4 },
        { "d", 0x0064 },
        { "dagger", 0x0086 },
        { "daggerdbl", 0x0087 },
        { "dcaron", 0x00EF },
        { "dcroat", 0x00F0 },
        { "degree", 0x00B0 },
        { "dieresis", 0x00A8 },
        { "divide", 0x00F7 },
        { "dollar", 0x0024 },
        { "dotaccent", 0x00FF },
        { "e", 0x0065 },
        { "eacute", 0x00E9 },
        { "ecaron", 0x00EC },
        { "edieresis", 0x00EB },
        { "eight", 0x0038 },
        { "ellipsis", 0x0085 },
        { "emdash", 0x0097 },
        { "endash", 0x0096 },
        { "eogonek", 0x00EA },
        { "equal", 0x003D },
        { "exclam", 0x0021 },
        { "f", 0x0066 },
        { "five", 0x0035 },
        { "four", 0x0034 },
        { "g", 0x0067 },
        { "germandbls", 0x00DF },
        { "grave", 0x0060 },
        { "greater", 0x003E },
        { "guillemotleft", 0x00AB },
        { "guillemotright", 0x00BB },
        { "guilsinglleft", 0x008B },
        { "guilsinglright", 0x009B },
        { "h", 0x0068 },
        { "hungarumlaut", 0x00BD },
        { "hyphen", 0x002D },
        { "i", 0x0069 },
        { "iacute", 0x00ED },
        { "icircumflex", 0x00EE },
        { "j", 0x006A },
        { "k", 0x006B },
        { "l", 0x006C },
        { "lacute", 0x00E5 },
        { "lcaron", 0x00BE },
        { "less", 0x003C },
        { "logicalnot", 0x00AC },
        { "lslash", 0x00B3 },
        { "m", 0x006D },
        { "mu", 0x00B5 },
        { "multiply", 0x00D7 },
        { "n", 0x006E },
        { "nacute", 0x00F1 },
        { "nbspace", 0x00A0 },
        { "ncaron", 0x00F2 },
        { "nine", 0x0039 },
        { "numbersign", 0x0023 },
        { "o", 0x006F },
        { "oacute", 0x00F3 },
        { "ocircumflex", 0x00F4 },
        { "odieresis", 0x00F6 },
        { "ogonek", 0x00B2 },
        { "ohungarumlaut", 0x00F5 },
        { "one", 0x0031 },
        { "p", 0x0070 },
        { "paragraph", 0x00B6 },
        { "parenleft", 0x0028 },
        { "parenright", 0x0029 },
        { "percent", 0x0025 },
        { "period", 0x002E },
        { "periodcentered", 0x00B7 },
        { "perthousand", 0x0089 },
        { "plus", 0x002B },
        { "plusminus", 0x00B1 },
        { "q", 0x0071 },
        { "question", 0x003F },
        { "quotedbl", 0x0022 },
        { "quotedblbase", 0x0084 },
        { "quotedblleft", 0x0093 },
        { "quotedblright", 0x0094 },
        { "quoteleft", 0x0091 },
        { "quoteright", 0x0092 },
        { "quotesinglbase", 0x0082 },
        { "quotesingle", 0x0027 },
        { "r", 0x0072 },
        { "racute", 0x00E0 },
        { "rcaron", 0x00F8 },
        { "registered", 0x00AE },
        { "s", 0x0073 },
        { "sacute", 0x009C },
        { "scaron", 0x009A },
        { "scommaaccent", 0x00BA },
        { "section", 0x00A7 },
        { "semicolon", 0x003B },
        { "seven", 0x0037 },
        { "sfthyphen", 0x00AD },
        { "six", 0x0036 },
        { "slash", 0x002F },
        { "space", 0x0020 },
        { "t", 0x0074 },
        { "tcaron", 0x009D },
        { "tcommaaccent", 0x00FE },
        { "three", 0x0033 },
        { "trademark", 0x0099 },
        { "two", 0x0032 },
        { "u", 0x0075 },
        { "uacute", 0x00FA },
        { "udieresis", 0x00FC },
        { "uhungarumlaut", 0x00FB },
        { "underscore", 0x005F },
        { "uring", 0x00F9 },
        { "v", 0x0076 },
        { "w", 0x0077 },
        { "x", 0x0078 },
        { "y", 0x0079 },
        { "yacute", 0x00FD },
        { "z", 0x007A },
        { "zacute", 0x009F },
        { "zcaron", 0x009E },
        { "zdotaccent", 0x00BF },
        { "zero", 0x0030 }
        }
    },

    //
    // !!SPECIAL!! Code page SYMBOL_CODEPAGE(4): Symbol
    //
    { SYMBOL_CODEPAGE, SYMBOL_CHARSET, SYMBOL_GS_NAME, 0,
        {
        {"", }
        }
    },

    //
    // Code page 1251: Win 3.1 Cyrillic
    //
    { 1251, RUSSIAN_CHARSET, CYRILLIC_GS_NAME, 222,
        {
        { "A", 0x0041 },
        { "B", 0x0042 },
        { "C", 0x0043 },
        { "D", 0x0044 },
        { "E", 0x0045 },
        { "Euro", 0x0088 },
        { "F", 0x0046 },
        { "G", 0x0047 },
        { "H", 0x0048 },
        { "I", 0x0049 },
        { "J", 0x004A },
        { "K", 0x004B },
        { "L", 0x004C },
        { "M", 0x004D },
        { "N", 0x004E },
        { "O", 0x004F },
        { "P", 0x0050 },
        { "Q", 0x0051 },
        { "R", 0x0052 },
        { "S", 0x0053 },
        { "T", 0x0054 },
        { "U", 0x0055 },
        { "V", 0x0056 },
        { "W", 0x0057 },
        { "X", 0x0058 },
        { "Y", 0x0059 },
        { "Z", 0x005A },
        { "a", 0x0061 },
        { "afii10017", 0x00C0 },
        { "afii10018", 0x00C1 },
        { "afii10019", 0x00C2 },
        { "afii10020", 0x00C3 },
        { "afii10021", 0x00C4 },
        { "afii10022", 0x00C5 },
        { "afii10023", 0x00A8 },
        { "afii10024", 0x00C6 },
        { "afii10025", 0x00C7 },
        { "afii10026", 0x00C8 },
        { "afii10027", 0x00C9 },
        { "afii10028", 0x00CA },
        { "afii10029", 0x00CB },
        { "afii10030", 0x00CC },
        { "afii10031", 0x00CD },
        { "afii10032", 0x00CE },
        { "afii10033", 0x00CF },
        { "afii10034", 0x00D0 },
        { "afii10035", 0x00D1 },
        { "afii10036", 0x00D2 },
        { "afii10037", 0x00D3 },
        { "afii10038", 0x00D4 },
        { "afii10039", 0x00D5 },
        { "afii10040", 0x00D6 },
        { "afii10041", 0x00D7 },
        { "afii10042", 0x00D8 },
        { "afii10043", 0x00D9 },
        { "afii10044", 0x00DA },
        { "afii10045", 0x00DB },
        { "afii10046", 0x00DC },
        { "afii10047", 0x00DD },
        { "afii10048", 0x00DE },
        { "afii10049", 0x00DF },
        { "afii10050", 0x00A5 },
        { "afii10051", 0x0080 },
        { "afii10052", 0x0081 },
        { "afii10053", 0x00AA },
        { "afii10054", 0x00BD },
        { "afii10055", 0x00B2 },
        { "afii10056", 0x00AF },
        { "afii10057", 0x00A3 },
        { "afii10058", 0x008A },
        { "afii10059", 0x008C },
        { "afii10060", 0x008E },
        { "afii10061", 0x008D },
        { "afii10062", 0x00A1 },
        { "afii10065", 0x00E0 },
        { "afii10066", 0x00E1 },
        { "afii10067", 0x00E2 },
        { "afii10068", 0x00E3 },
        { "afii10069", 0x00E4 },
        { "afii10070", 0x00E5 },
        { "afii10071", 0x00B8 },
        { "afii10072", 0x00E6 },
        { "afii10073", 0x00E7 },
        { "afii10074", 0x00E8 },
        { "afii10075", 0x00E9 },
        { "afii10076", 0x00EA },
        { "afii10077", 0x00EB },
        { "afii10078", 0x00EC },
        { "afii10079", 0x00ED },
        { "afii10080", 0x00EE },
        { "afii10081", 0x00EF },
        { "afii10082", 0x00F0 },
        { "afii10083", 0x00F1 },
        { "afii10084", 0x00F2 },
        { "afii10085", 0x00F3 },
        { "afii10086", 0x00F4 },
        { "afii10087", 0x00F5 },
        { "afii10088", 0x00F6 },
        { "afii10089", 0x00F7 },
        { "afii10090", 0x00F8 },
        { "afii10091", 0x00F9 },
        { "afii10092", 0x00FA },
        { "afii10093", 0x00FB },
        { "afii10094", 0x00FC },
        { "afii10095", 0x00FD },
        { "afii10096", 0x00FE },
        { "afii10097", 0x00FF },
        { "afii10098", 0x00B4 },
        { "afii10099", 0x0090 },
        { "afii10100", 0x0083 },
        { "afii10101", 0x00BA },
        { "afii10102", 0x00BE },
        { "afii10103", 0x00B3 },
        { "afii10104", 0x00BF },
        { "afii10105", 0x00BC },
        { "afii10106", 0x009A },
        { "afii10107", 0x009C },
        { "afii10108", 0x009E },
        { "afii10109", 0x009D },
        { "afii10110", 0x00A2 },
        { "afii10145", 0x008F },
        { "afii10193", 0x009F },
        { "afii61352", 0x00B9 },
        { "ampersand", 0x0026 },
        { "asciicircum", 0x005E },
        { "asciitilde", 0x007E },
        { "asterisk", 0x002A },
        { "at", 0x0040 },
        { "b", 0x0062 },
        { "backslash", 0x005C },
        { "bar", 0x007C },
        { "braceleft", 0x007B },
        { "braceright", 0x007D },
        { "bracketleft", 0x005B },
        { "bracketright", 0x005D },
        { "brokenbar", 0x00A6 },
        { "bullet", 0x0095 },
        { "c", 0x0063 },
        { "colon", 0x003A },
        { "comma", 0x002C },
        { "copyright", 0x00A9 },
        { "currency", 0x00A4 },
        { "d", 0x0064 },
        { "dagger", 0x0086 },
        { "daggerdbl", 0x0087 },
        { "degree", 0x00B0 },
        { "dollar", 0x0024 },
        { "e", 0x0065 },
        { "eight", 0x0038 },
        { "ellipsis", 0x0085 },
        { "emdash", 0x0097 },
        { "endash", 0x0096 },
        { "equal", 0x003D },
        { "exclam", 0x0021 },
        { "f", 0x0066 },
        { "five", 0x0035 },
        { "four", 0x0034 },
        { "g", 0x0067 },
        { "grave", 0x0060 },
        { "greater", 0x003E },
        { "guillemotleft", 0x00AB },
        { "guillemotright", 0x00BB },
        { "guilsinglleft", 0x008B },
        { "guilsinglright", 0x009B },
        { "h", 0x0068 },
        { "hyphen", 0x002D },
        { "i", 0x0069 },
        { "j", 0x006A },
        { "k", 0x006B },
        { "l", 0x006C },
        { "less", 0x003C },
        { "logicalnot", 0x00AC },
        { "m", 0x006D },
        { "mu", 0x00B5 },
        { "n", 0x006E },
        { "nbspace", 0x00A0 },
        { "nine", 0x0039 },
        { "numbersign", 0x0023 },
        { "o", 0x006F },
        { "one", 0x0031 },
        { "p", 0x0070 },
        { "paragraph", 0x00B6 },
        { "parenleft", 0x0028 },
        { "parenright", 0x0029 },
        { "percent", 0x0025 },
        { "period", 0x002E },
        { "periodcentered", 0x00B7 },
        { "perthousand", 0x0089 },
        { "plus", 0x002B },
        { "plusminus", 0x00B1 },
        { "q", 0x0071 },
        { "question", 0x003F },
        { "quotedbl", 0x0022 },
        { "quotedblbase", 0x0084 },
        { "quotedblleft", 0x0093 },
        { "quotedblright", 0x0094 },
        { "quoteleft", 0x0091 },
        { "quoteright", 0x0092 },
        { "quotesinglbase", 0x0082 },
        { "quotesingle", 0x0027 },
        { "r", 0x0072 },
        { "registered", 0x00AE },
        { "s", 0x0073 },
        { "section", 0x00A7 },
        { "semicolon", 0x003B },
        { "seven", 0x0037 },
        { "sfthyphen", 0x00AD },
        { "six", 0x0036 },
        { "slash", 0x002F },
        { "space", 0x0020 },
        { "t", 0x0074 },
        { "three", 0x0033 },
        { "trademark", 0x0099 },
        { "two", 0x0032 },
        { "u", 0x0075 },
        { "underscore", 0x005F },
        { "v", 0x0076 },
        { "w", 0x0077 },
        { "x", 0x0078 },
        { "y", 0x0079 },
        { "z", 0x007A },
        { "zero", 0x0030 },
        }
    },

    //
    // Code page 1252: Win 3.1 US
    //
    { 1252, ANSI_CHARSET, ANSI_GS_NAME, 218,
        {
        { "A", 0x0041 },
        { "AE", 0x00C6 },
        { "Aacute", 0x00C1 },
        { "Acircumflex", 0x00C2 },
        { "Adieresis", 0x00C4 },
        { "Agrave", 0x00C0 },
        { "Aring", 0x00C5 },
        { "Atilde", 0x00C3 },
        { "B", 0x0042 },
        { "C", 0x0043 },
        { "Ccedilla", 0x00C7 },
        { "D", 0x0044 },
        { "E", 0x0045 },
        { "Eacute", 0x00C9 },
        { "Ecircumflex", 0x00CA },
        { "Edieresis", 0x00CB },
        { "Egrave", 0x00C8 },
        { "Eth", 0x00D0 },
        { "Euro", 0x0080 },
        { "F", 0x0046 },
        { "G", 0x0047 },
        { "H", 0x0048 },
        { "I", 0x0049 },
        { "Iacute", 0x00CD },
        { "Icircumflex", 0x00CE },
        { "Idieresis", 0x00CF },
        { "Igrave", 0x00CC },
        { "J", 0x004A },
        { "K", 0x004B },
        { "L", 0x004C },
        { "M", 0x004D },
        { "N", 0x004E },
        { "Ntilde", 0x00D1 },
        { "O", 0x004F },
        { "OE", 0x008C },
        { "Oacute", 0x00D3 },
        { "Ocircumflex", 0x00D4 },
        { "Odieresis", 0x00D6 },
        { "Ograve", 0x00D2 },
        { "Oslash", 0x00D8 },
        { "Otilde", 0x00D5 },
        { "P", 0x0050 },
        { "Q", 0x0051 },
        { "R", 0x0052 },
        { "S", 0x0053 },
        { "Scaron", 0x008A },
        { "T", 0x0054 },
        { "Thorn", 0x00DE },
        { "U", 0x0055 },
        { "Uacute", 0x00DA },
        { "Ucircumflex", 0x00DB },
        { "Udieresis", 0x00DC },
        { "Ugrave", 0x00D9 },
        { "V", 0x0056 },
        { "W", 0x0057 },
        { "X", 0x0058 },
        { "Y", 0x0059 },
        { "Yacute", 0x00DD },
        { "Ydieresis", 0x009F },
        { "Z", 0x005A },
        { "Zcaron", 0x008E },
        { "a", 0x0061 },
        { "aacute", 0x00E1 },
        { "acircumflex", 0x00E2 },
        { "acute", 0x00B4 },
        { "adieresis", 0x00E4 },
        { "ae", 0x00E6 },
        { "agrave", 0x00E0 },
        { "ampersand", 0x0026 },
        { "aring", 0x00E5 },
        { "asciicircum", 0x005E },
        { "asciitilde", 0x007E },
        { "asterisk", 0x002A },
        { "at", 0x0040 },
        { "atilde", 0x00E3 },
        { "b", 0x0062 },
        { "backslash", 0x005C },
        { "bar", 0x007C },
        { "braceleft", 0x007B },
        { "braceright", 0x007D },
        { "bracketleft", 0x005B },
        { "bracketright", 0x005D },
        { "brokenbar", 0x00A6 },
        { "bullet", 0x0095 },
        { "c", 0x0063 },
        { "ccedilla", 0x00E7 },
        { "cedilla", 0x00B8 },
        { "cent", 0x00A2 },
        { "circumflex", 0x0088 },
        { "colon", 0x003A },
        { "comma", 0x002C },
        { "copyright", 0x00A9 },
        { "currency", 0x00A4 },
        { "d", 0x0064 },
        { "dagger", 0x0086 },
        { "daggerdbl", 0x0087 },
        { "degree", 0x00B0 },
        { "dieresis", 0x00A8 },
        { "divide", 0x00F7 },
        { "dollar", 0x0024 },
        { "e", 0x0065 },
        { "eacute", 0x00E9 },
        { "ecircumflex", 0x00EA },
        { "edieresis", 0x00EB },
        { "egrave", 0x00E8 },
        { "eight", 0x0038 },
        { "ellipsis", 0x0085 },
        { "emdash", 0x0097 },
        { "endash", 0x0096 },
        { "equal", 0x003D },
        { "eth", 0x00F0 },
        { "exclam", 0x0021 },
        { "exclamdown", 0x00A1 },
        { "f", 0x0066 },
        { "five", 0x0035 },
        { "florin", 0x0083 },
        { "four", 0x0034 },
        { "g", 0x0067 },
        { "germandbls", 0x00DF },
        { "grave", 0x0060 },
        { "greater", 0x003E },
        { "guillemotleft", 0x00AB },
        { "guillemotright", 0x00BB },
        { "guilsinglleft", 0x008B },
        { "guilsinglright", 0x009B },
        { "h", 0x0068 },
        { "hyphen", 0x002D },
        { "i", 0x0069 },
        { "iacute", 0x00ED },
        { "icircumflex", 0x00EE },
        { "idieresis", 0x00EF },
        { "igrave", 0x00EC },
        { "j", 0x006A },
        { "k", 0x006B },
        { "l", 0x006C },
        { "less", 0x003C },
        { "logicalnot", 0x00AC },
        { "m", 0x006D },
        { "macron", 0x00AF },
        { "mu", 0x00B5 },
        { "multiply", 0x00D7 },
        { "n", 0x006E },
        { "nbspace", 0x00A0 },
        { "nine", 0x0039 },
        { "ntilde", 0x00F1 },
        { "numbersign", 0x0023 },
        { "o", 0x006F },
        { "oacute", 0x00F3 },
        { "ocircumflex", 0x00F4 },
        { "odieresis", 0x00F6 },
        { "oe", 0x009C },
        { "ograve", 0x00F2 },
        { "one", 0x0031 },
        { "onehalf", 0x00BD },
        { "onequarter", 0x00BC },
        { "onesuperior", 0x00B9 },
        { "ordfeminine", 0x00AA },
        { "ordmasculine", 0x00BA },
        { "oslash", 0x00F8 },
        { "otilde", 0x00F5 },
        { "p", 0x0070 },
        { "paragraph", 0x00B6 },
        { "parenleft", 0x0028 },
        { "parenright", 0x0029 },
        { "percent", 0x0025 },
        { "period", 0x002E },
        { "periodcentered", 0x00B7 },
        { "perthousand", 0x0089 },
        { "plus", 0x002B },
        { "plusminus", 0x00B1 },
        { "q", 0x0071 },
        { "question", 0x003F },
        { "questiondown", 0x00BF },
        { "quotedbl", 0x0022 },
        { "quotedblbase", 0x0084 },
        { "quotedblleft", 0x0093 },
        { "quotedblright", 0x0094 },
        { "quoteleft", 0x0091 },
        { "quoteright", 0x0092 },
        { "quotesinglbase", 0x0082 },
        { "quotesingle", 0x0027 },
        { "r", 0x0072 },
        { "registered", 0x00AE },
        { "s", 0x0073 },
        { "scaron", 0x009A },
        { "section", 0x00A7 },
        { "semicolon", 0x003B },
        { "seven", 0x0037 },
        { "sfthyphen", 0x00AD },
        { "six", 0x0036 },
        { "slash", 0x002F },
        { "space", 0x0020 },
        { "sterling", 0x00A3 },
        { "t", 0x0074 },
        { "thorn", 0x00FE },
        { "three", 0x0033 },
        { "threequarters", 0x00BE },
        { "threesuperior", 0x00B3 },
        { "tilde", 0x0098 },
        { "trademark", 0x0099 },
        { "two", 0x0032 },
        { "twosuperior", 0x00B2 },
        { "u", 0x0075 },
        { "uacute", 0x00FA },
        { "ucircumflex", 0x00FB },
        { "udieresis", 0x00FC },
        { "ugrave", 0x00F9 },
        { "underscore", 0x005F },
        { "v", 0x0076 },
        { "w", 0x0077 },
        { "x", 0x0078 },
        { "y", 0x0079 },
        { "yacute", 0x00FD },
        { "ydieresis", 0x00FF },
        { "yen", 0x00A5 },
        { "z", 0x007A },
        { "zcaron", 0x009E },
        { "zero", 0x0030 },
        }
    },

    //
    // Code page 1253: Win 3.1 Greek
    //
    { 1253, GREEK_CHARSET, GREEK_GS_NAME, 207,
        {
        { "A", 0x0041 },
        { "Alpha", 0x00C1 },
        { "Alphatonos", 0x00A2 },
        { "B", 0x0042 },
        { "Beta", 0x00C2 },
        { "C", 0x0043 },
        { "Chi", 0x00D7 },
        { "D", 0x0044 },
        { "Delta", 0x00C4 },
        { "E", 0x0045 },
        { "Epsilon", 0x00C5 },
        { "Epsilontonos", 0x00B8 },
        { "Eta", 0x00C7 },
        { "Etatonos", 0x00B9 },
        { "Euro", 0x0080 },
        { "F", 0x0046 },
        { "G", 0x0047 },
        { "Gamma", 0x00C3 },
        { "H", 0x0048 },
        { "I", 0x0049 },
        { "Iota", 0x00C9 },
        { "Iotadieresis", 0x00DA },
        { "Iotatonos", 0x00BA },
        { "J", 0x004A },
        { "K", 0x004B },
        { "Kappa", 0x00CA },
        { "L", 0x004C },
        { "Lambda", 0x00CB },
        { "M", 0x004D },
        { "Mu", 0x00CC },
        { "N", 0x004E },
        { "Nu", 0x00CD },
        { "O", 0x004F },
        { "Omega", 0x00D9 },
        { "Omegatonos", 0x00BF },
        { "Omicron", 0x00CF },
        { "Omicrontonos", 0x00BC },
        { "P", 0x0050 },
        { "Phi", 0x00D6 },
        { "Pi", 0x00D0 },
        { "Psi", 0x00D8 },
        { "Q", 0x0051 },
        { "R", 0x0052 },
        { "Rho", 0x00D1 },
        { "S", 0x0053 },
        { "Sigma", 0x00D3 },
        { "T", 0x0054 },
        { "Tau", 0x00D4 },
        { "Theta", 0x00C8 },
        { "U", 0x0055 },
        { "Upsilon", 0x00D5 },
        { "Upsilondieresis", 0x00DB },
        { "Upsilontonos", 0x00BE },
        { "V", 0x0056 },
        { "W", 0x0057 },
        { "X", 0x0058 },
        { "Xi", 0x00CE },
        { "Y", 0x0059 },
        { "Z", 0x005A },
        { "Zeta", 0x00C6 },
        { "a", 0x0061 },
        { "afii00208", 0x00AF },
        { "alpha", 0x00E1 },
        { "alphatonos", 0x00DC },
        { "ampersand", 0x0026 },
        { "asciicircum", 0x005E },
        { "asciitilde", 0x007E },
        { "asterisk", 0x002A },
        { "at", 0x0040 },
        { "b", 0x0062 },
        { "backslash", 0x005C },
        { "bar", 0x007C },
        { "beta", 0x00E2 },
        { "braceleft", 0x007B },
        { "braceright", 0x007D },
        { "bracketleft", 0x005B },
        { "bracketright", 0x005D },
        { "brokenbar", 0x00A6 },
        { "bullet", 0x0095 },
        { "c", 0x0063 },
        { "chi", 0x00F7 },
        { "colon", 0x003A },
        { "comma", 0x002C },
        { "copyright", 0x00A9 },
        { "currency", 0x00A4 },
        { "d", 0x0064 },
        { "dagger", 0x0086 },
        { "daggerdbl", 0x0087 },
        { "degree", 0x00B0 },
        { "delta", 0x00E4 },
        { "dieresis", 0x00A8 },
        { "dieresistonos", 0x00A1 },
        { "dollar", 0x0024 },
        { "e", 0x0065 },
        { "eight", 0x0038 },
        { "ellipsis", 0x0085 },
        { "emdash", 0x0097 },
        { "endash", 0x0096 },
        { "epsilon", 0x00E5 },
        { "epsilontonos", 0x00DD },
        { "equal", 0x003D },
        { "eta", 0x00E7 },
        { "etatonos", 0x00DE },
        { "exclam", 0x0021 },
        { "f", 0x0066 },
        { "five", 0x0035 },
        { "florin", 0x0083 },
        { "four", 0x0034 },
        { "g", 0x0067 },
        { "gamma", 0x00E3 },
        { "grave", 0x0060 },
        { "greater", 0x003E },
        { "guillemotleft", 0x00AB },
        { "guillemotright", 0x00BB },
        { "guilsinglleft", 0x008B },
        { "guilsinglright", 0x009B },
        { "h", 0x0068 },
        { "hyphen", 0x002D },
        { "i", 0x0069 },
        { "iota", 0x00E9 },
        { "iotadieresis", 0x00FA },
        { "iotadieresistonos", 0x00C0 },
        { "iotatonos", 0x00DF },
        { "j", 0x006A },
        { "k", 0x006B },
        { "kappa", 0x00EA },
        { "l", 0x006C },
        { "lambda", 0x00EB },
        { "less", 0x003C },
        { "logicalnot", 0x00AC },
        { "m", 0x006D },
        { "mu", 0x00B5 },
        { "mu", 0x00EC },
        { "n", 0x006E },
        { "nbspace", 0x00A0 },
        { "nine", 0x0039 },
        { "nu", 0x00ED },
        { "numbersign", 0x0023 },
        { "o", 0x006F },
        { "omega", 0x00F9 },
        { "omegatonos", 0x00FE },
        { "omicron", 0x00EF },
        { "omicrontonos", 0x00FC },
        { "one", 0x0031 },
        { "onehalf", 0x00BD },
        { "ordfeminine", 0x00AA },
        { "p", 0x0070 },
        { "paragraph", 0x00B6 },
        { "parenleft", 0x0028 },
        { "parenright", 0x0029 },
        { "percent", 0x0025 },
        { "period", 0x002E },
        { "periodcentered", 0x00B7 },
        { "perthousand", 0x0089 },
        { "phi", 0x00F6 },
        { "pi", 0x00F0 },
        { "plus", 0x002B },
        { "plusminus", 0x00B1 },
        { "psi", 0x00F8 },
        { "q", 0x0071 },
        { "question", 0x003F },
        { "quotedbl", 0x0022 },
        { "quotedblbase", 0x0084 },
        { "quotedblleft", 0x0093 },
        { "quotedblright", 0x0094 },
        { "quoteleft", 0x0091 },
        { "quoteright", 0x0092 },
        { "quotesinglbase", 0x0082 },
        { "quotesingle", 0x0027 },
        { "r", 0x0072 },
        { "registered", 0x00AE },
        { "rho", 0x00F1 },
        { "s", 0x0073 },
        { "section", 0x00A7 },
        { "semicolon", 0x003B },
        { "seven", 0x0037 },
        { "sfthyphen", 0x00AD },
        { "sigma", 0x00F3 },
        { "sigma1", 0x00F2 },
        { "six", 0x0036 },
        { "slash", 0x002F },
        { "space", 0x0020 },
        { "sterling", 0x00A3 },
        { "t", 0x0074 },
        { "tau", 0x00F4 },
        { "theta", 0x00E8 },
        { "three", 0x0033 },
        { "threesuperior", 0x00B3 },
        { "tonos", 0x00B4 },
        { "trademark", 0x0099 },
        { "two", 0x0032 },
        { "twosuperior", 0x00B2 },
        { "u", 0x0075 },
        { "underscore", 0x005F },
        { "upsilon", 0x00F5 },
        { "upsilon-dieresistonos", 0x00E0},
        { "upsilondieresis", 0x00FB },
        { "upsilontonos", 0x00FD },
        { "v", 0x0076 },
        { "w", 0x0077 },
        { "x", 0x0078 },
        { "xi", 0x00EE },
        { "y", 0x0079 },
        { "yen", 0x00A5 },
        { "z", 0x007A },
        { "zero", 0x0030 },
        { "zeta", 0x00E6 },
        }
    },

    //
    // Code page 1254: Win 3.1 Turkish
    //
    { 1254, TURKISH_CHARSET, TURKISH_GS_NAME, 216,
        {
        { "A", 0x0041 },
        { "AE", 0x00C6 },
        { "Aacute", 0x00C1 },
        { "Acircumflex", 0x00C2 },
        { "Adieresis", 0x00C4 },
        { "Agrave", 0x00C0 },
        { "Aring", 0x00C5 },
        { "Atilde", 0x00C3 },
        { "B", 0x0042 },
        { "C", 0x0043 },
        { "Ccedilla", 0x00C7 },
        { "D", 0x0044 },
        { "E", 0x0045 },
        { "Eacute", 0x00C9 },
        { "Ecircumflex", 0x00CA },
        { "Edieresis", 0x00CB },
        { "Egrave", 0x00C8 },
        { "Euro", 0x0080 },
        { "F", 0x0046 },
        { "G", 0x0047 },
        { "Gbreve", 0x00D0 },
        { "H", 0x0048 },
        { "I", 0x0049 },
        { "Iacute", 0x00CD },
        { "Icircumflex", 0x00CE },
        { "Idieresis", 0x00CF },
        { "Idotaccent", 0x00DD },
        { "Igrave", 0x00CC },
        { "J", 0x004A },
        { "K", 0x004B },
        { "L", 0x004C },
        { "M", 0x004D },
        { "N", 0x004E },
        { "Ntilde", 0x00D1 },
        { "O", 0x004F },
        { "OE", 0x008C },
        { "Oacute", 0x00D3 },
        { "Ocircumflex", 0x00D4 },
        { "Odieresis", 0x00D6 },
        { "Ograve", 0x00D2 },
        { "Oslash", 0x00D8 },
        { "Otilde", 0x00D5 },
        { "P", 0x0050 },
        { "Q", 0x0051 },
        { "R", 0x0052 },
        { "S", 0x0053 },
        { "Scaron", 0x008A },
        { "Scommaaccent", 0x00DE },
        { "T", 0x0054 },
        { "U", 0x0055 },
        { "Uacute", 0x00DA },
        { "Ucircumflex", 0x00DB },
        { "Udieresis", 0x00DC },
        { "Ugrave", 0x00D9 },
        { "V", 0x0056 },
        { "W", 0x0057 },
        { "X", 0x0058 },
        { "Y", 0x0059 },
        { "Ydieresis", 0x009F },
        { "Z", 0x005A },
        { "a", 0x0061 },
        { "aacute", 0x00E1 },
        { "acircumflex", 0x00E2 },
        { "acute", 0x00B4 },
        { "adieresis", 0x00E4 },
        { "ae", 0x00E6 },
        { "agrave", 0x00E0 },
        { "ampersand", 0x0026 },
        { "aring", 0x00E5 },
        { "asciicircum", 0x005E },
        { "asciitilde", 0x007E },
        { "asterisk", 0x002A },
        { "at", 0x0040 },
        { "atilde", 0x00E3 },
        { "b", 0x0062 },
        { "backslash", 0x005C },
        { "bar", 0x007C },
        { "braceleft", 0x007B },
        { "braceright", 0x007D },
        { "bracketleft", 0x005B },
        { "bracketright", 0x005D },
        { "brokenbar", 0x00A6 },
        { "bullet", 0x0095 },
        { "c", 0x0063 },
        { "ccedilla", 0x00E7 },
        { "cedilla", 0x00B8 },
        { "cent", 0x00A2 },
        { "circumflex", 0x0088 },
        { "colon", 0x003A },
        { "comma", 0x002C },
        { "copyright", 0x00A9 },
        { "currency", 0x00A4 },
        { "d", 0x0064 },
        { "dagger", 0x0086 },
        { "daggerdbl", 0x0087 },
        { "degree", 0x00B0 },
        { "dieresis", 0x00A8 },
        { "divide", 0x00F7 },
        { "dollar", 0x0024 },
        { "dotlessi", 0x00FD },
        { "e", 0x0065 },
        { "eacute", 0x00E9 },
        { "ecircumflex", 0x00EA },
        { "edieresis", 0x00EB },
        { "egrave", 0x00E8 },
        { "eight", 0x0038 },
        { "ellipsis", 0x0085 },
        { "emdash", 0x0097 },
        { "endash", 0x0096 },
        { "equal", 0x003D },
        { "exclam", 0x0021 },
        { "exclamdown", 0x00A1 },
        { "f", 0x0066 },
        { "five", 0x0035 },
        { "florin", 0x0083 },
        { "four", 0x0034 },
        { "g", 0x0067 },
        { "gbreve", 0x00F0 },
        { "germandbls", 0x00DF },
        { "grave", 0x0060 },
        { "greater", 0x003E },
        { "guillemotleft", 0x00AB },
        { "guillemotright", 0x00BB },
        { "guilsinglleft", 0x008B },
        { "guilsinglright", 0x009B },
        { "h", 0x0068 },
        { "hyphen", 0x002D },
        { "i", 0x0069 },
        { "iacute", 0x00ED },
        { "icircumflex", 0x00EE },
        { "idieresis", 0x00EF },
        { "igrave", 0x00EC },
        { "j", 0x006A },
        { "k", 0x006B },
        { "l", 0x006C },
        { "less", 0x003C },
        { "logicalnot", 0x00AC },
        { "m", 0x006D },
        { "macron", 0x00AF },
        { "mu", 0x00B5 },
        { "multiply", 0x00D7 },
        { "n", 0x006E },
        { "nbspace", 0x00A0 },
        { "nine", 0x0039 },
        { "ntilde", 0x00F1 },
        { "numbersign", 0x0023 },
        { "o", 0x006F },
        { "oacute", 0x00F3 },
        { "ocircumflex", 0x00F4 },
        { "odieresis", 0x00F6 },
        { "oe", 0x009C },
        { "ograve", 0x00F2 },
        { "one", 0x0031 },
        { "onehalf", 0x00BD },
        { "onequarter", 0x00BC },
        { "onesuperior", 0x00B9 },
        { "ordfeminine", 0x00AA },
        { "ordmasculine", 0x00BA },
        { "oslash", 0x00F8 },
        { "otilde", 0x00F5 },
        { "p", 0x0070 },
        { "paragraph", 0x00B6 },
        { "parenleft", 0x0028 },
        { "parenright", 0x0029 },
        { "percent", 0x0025 },
        { "period", 0x002E },
        { "periodcentered", 0x00B7 },
        { "perthousand", 0x0089 },
        { "plus", 0x002B },
        { "plusminus", 0x00B1 },
        { "q", 0x0071 },
        { "question", 0x003F },
        { "questiondown", 0x00BF },
        { "quotedbl", 0x0022 },
        { "quotedblbase", 0x0084 },
        { "quotedblleft", 0x0093 },
        { "quotedblright", 0x0094 },
        { "quoteleft", 0x0091 },
        { "quoteright", 0x0092 },
        { "quotesinglbase", 0x0082 },
        { "quotesingle", 0x0027 },
        { "r", 0x0072 },
        { "registered", 0x00AE },
        { "s", 0x0073 },
        { "scaron", 0x009A },
        { "scommaaccent", 0x00FE },
        { "section", 0x00A7 },
        { "semicolon", 0x003B },
        { "seven", 0x0037 },
        { "sfthyphen", 0x00AD },
        { "six", 0x0036 },
        { "slash", 0x002F },
        { "space", 0x0020 },
        { "sterling", 0x00A3 },
        { "t", 0x0074 },
        { "three", 0x0033 },
        { "threequarters", 0x00BE },
        { "threesuperior", 0x00B3 },
        { "tilde", 0x0098 },
        { "trademark", 0x0099 },
        { "two", 0x0032 },
        { "twosuperior", 0x00B2 },
        { "u", 0x0075 },
        { "uacute", 0x00FA },
        { "ucircumflex", 0x00FB },
        { "udieresis", 0x00FC },
        { "ugrave", 0x00F9 },
        { "underscore", 0x005F },
        { "v", 0x0076 },
        { "w", 0x0077 },
        { "x", 0x0078 },
        { "y", 0x0079 },
        { "ydieresis", 0x00FF },
        { "yen", 0x00A5 },
        { "z", 0x007A },
        { "zero", 0x0030 },
        }
    },

    //
    // Code page 1255: Hebrew
    //
    { 1255, HEBREW_CHARSET, HEBREW_GS_NAME, 223,
        {
        { ".notdef", 0x0081 },
        { ".notdef", 0x008A },
        { ".notdef", 0x008C },
        { ".notdef", 0x008D },
        { ".notdef", 0x008E },
        { ".notdef", 0x008F },
        { ".notdef", 0x0090 },
        { ".notdef", 0x009A },
        { ".notdef", 0x009C },
        { ".notdef", 0x009D },
        { ".notdef", 0x009E },
        { ".notdef", 0x009F },
        { ".notdef", 0x00A1 },
        { ".notdef", 0x00AA },
        { ".notdef", 0x00B8 },
        { ".notdef", 0x00BA },
        { ".notdef", 0x00BF },
        { ".notdef", 0x00CA },
        { ".notdef", 0x00D7 },
        { ".notdef", 0x00D8 },
        { ".notdef", 0x00D9 },
        { ".notdef", 0x00DA },
        { ".notdef", 0x00DB },
        { ".notdef", 0x00DC },
        { ".notdef", 0x00DD },
        { ".notdef", 0x00DE },
        { ".notdef", 0x00DF },
        { ".notdef", 0x00FB },
        { ".notdef", 0x00FC },
        { ".notdef", 0x00FF },
        { "A", 0x0041 },
        { "B", 0x0042 },
        { "C", 0x0043 },
        { "D", 0x0044 },
        { "E", 0x0045 },
        { "Euro", 0x0080 },
        { "F", 0x0046 },
        { "G", 0x0047 },
        { "H", 0x0048 },
        { "I", 0x0049 },
        { "J", 0x004A },
        { "K", 0x004B },
        { "L", 0x004C },
        { "M", 0x004D },
        { "N", 0x004E },
        { "O", 0x004F },
        { "P", 0x0050 },
        { "Q", 0x0051 },
        { "R", 0x0052 },
        { "S", 0x0053 },
        { "T", 0x0054 },
        { "U", 0x0055 },
        { "V", 0x0056 },
        { "W", 0x0057 },
        { "X", 0x0058 },
        { "Y", 0x0059 },
        { "Z", 0x005A },
        { "a", 0x0061 },
        { "acute", 0x00B4 },
        { "afii299", 0x00FD },
        { "afii300", 0x00FE },
        { "afii57636", 0x00A4 },
        { "afii57645", 0x00CE },
        { "afii57658", 0x00D3 },
        { "afii57664", 0x00E0 },
        { "afii57665", 0x00E1 },
        { "afii57666", 0x00E2 },
        { "afii57667", 0x00E3 },
        { "afii57668", 0x00E4 },
        { "afii57669", 0x00E5 },
        { "afii57670", 0x00E6 },
        { "afii57671", 0x00E7 },
        { "afii57672", 0x00E8 },
        { "afii57673", 0x00E9 },
        { "afii57674", 0x00EA },
        { "afii57675", 0x00EB },
        { "afii57676", 0x00EC },
        { "afii57677", 0x00ED },
        { "afii57678", 0x00EE },
        { "afii57679", 0x00EF },
        { "afii57680", 0x00F0 },
        { "afii57681", 0x00F1 },
        { "afii57682", 0x00F2 },
        { "afii57683", 0x00F3 },
        { "afii57684", 0x00F4 },
        { "afii57685", 0x00F5 },
        { "afii57686", 0x00F6 },
        { "afii57687", 0x00F7 },
        { "afii57688", 0x00F8 },
        { "afii57689", 0x00F9 },
        { "afii57690", 0x00FA },
        { "afii57716", 0x00D4 },
        { "afii57717", 0x00D5 },
        { "afii57718", 0x00D6 },
        { "afii57793", 0x00C4 },
        { "afii57794", 0x00C5 },
        { "afii57795", 0x00C6 },
        { "afii57796", 0x00CB },
        { "afii57797", 0x00C8 },
        { "afii57798", 0x00C7 },
        { "afii57799", 0x00C0 },
        { "afii57800", 0x00C2 },
        { "afii57801", 0x00C1 },
        { "afii57802", 0x00C3 },
        { "afii57803", 0x00D2 },
        { "afii57804", 0x00D1 },
        { "afii57806", 0x00C9 },
        { "afii57807", 0x00CC },
        { "afii57839", 0x00CD },
        { "afii57841", 0x00CF },
        { "afii57842", 0x00D0 },
        { "ampersand", 0x0026 },
        { "asciicircum", 0x005E },
        { "asciitilde", 0x007E },
        { "asterisk", 0x002A },
        { "at", 0x0040 },
        { "b", 0x0062 },
        { "backslash", 0x005C },
        { "bar", 0x007C },
        { "braceleft", 0x007B },
        { "braceright", 0x007D },
        { "bracketleft", 0x005B },
        { "bracketright", 0x005D },
        { "brokenbar", 0x00A6 },
        { "bullet", 0x0095 },
        { "c", 0x0063 },
        { "cent", 0x00A2 },
        { "circumflex", 0x0088 },
        { "colon", 0x003A },
        { "comma", 0x002C },
        { "copyright", 0x00A9 },
        { "d", 0x0064 },
        { "dagger", 0x0086 },
        { "daggerdbl", 0x0087 },
        { "degree", 0x00B0 },
        { "dieresis", 0x00A8 },
        { "dollar", 0x0024 },
        { "e", 0x0065 },
        { "eight", 0x0038 },
        { "ellipsis", 0x0085 },
        { "emdash", 0x0097 },
        { "endash", 0x0096 },
        { "equal", 0x003D },
        { "exclam", 0x0021 },
        { "f", 0x0066 },
        { "five", 0x0035 },
        { "florin", 0x0083 },
        { "four", 0x0034 },
        { "g", 0x0067 },
        { "grave", 0x0060 },
        { "greater", 0x003E },
        { "guillemotleft", 0x00AB },
        { "guillemotright", 0x00BB },
        { "guilsinglleft", 0x008B },
        { "guilsinglright", 0x009B },
        { "h", 0x0068 },
        { "hyphen", 0x002D },
        { "i", 0x0069 },
        { "j", 0x006A },
        { "k", 0x006B },
        { "l", 0x006C },
        { "less", 0x003C },
        { "logicalnot", 0x00AC },
        { "m", 0x006D },
        { "macron", 0x00AF },
        { "mu", 0x00B5 },
        { "n", 0x006E },
        { "nbspace", 0x00A0 },
        { "nine", 0x0039 },
        { "numbersign", 0x0023 },
        { "o", 0x006F },
        { "one", 0x0031 },
        { "onehalf", 0x00BD },
        { "onequarter", 0x00BC },
        { "onesuperior", 0x00B9 },
        { "p", 0x0070 },
        { "paragraph", 0x00B6 },
        { "parenleft", 0x0028 },
        { "parenright", 0x0029 },
        { "percent", 0x0025 },
        { "period", 0x002E },
        { "periodcentered", 0x00B7 },
        { "perthousand", 0x0089 },
        { "plus", 0x002B },
        { "plusminus", 0x00B1 },
        { "q", 0x0071 },
        { "question", 0x003F },
        { "quotedbl", 0x0022 },
        { "quotedblbase", 0x0084 },
        { "quotedblleft", 0x0093 },
        { "quotedblright", 0x0094 },
        { "quoteleft", 0x0091 },
        { "quoteright", 0x0092 },
        { "quotesinglbase", 0x0082 },
        { "quotesingle", 0x0027 },
        { "r", 0x0072 },
        { "registered", 0x00AE },
        { "s", 0x0073 },
        { "section", 0x00A7 },
        { "semicolon", 0x003B },
        { "seven", 0x0037 },
        { "sfthyphen", 0x00AD },
        { "six", 0x0036 },
        { "slash", 0x002F },
        { "space", 0x0020 },
        { "sterling", 0x00A3 },
        { "t", 0x0074 },
        { "three", 0x0033 },
        { "threequarters", 0x00BE },
        { "threesuperior", 0x00B3 },
        { "tilde", 0x0098 },
        { "trademark", 0x0099 },
        { "two", 0x0032 },
        { "twosuperior", 0x00B2 },
        { "u", 0x0075 },
        { "underscore", 0x005F },
        { "v", 0x0076 },
        { "w", 0x0077 },
        { "x", 0x0078 },
        { "y", 0x0079 },
        { "yen", 0x00A5 },
        { "z", 0x007A },
        { "zero", 0x0030 }
        }
    },

    //
    // Code page 1256: Arabic
    //
    { 1256, ARABIC_CHARSET, ARABIC_GS_NAME, 215,
        {
        { "A", 0x0041 },
        { "B", 0x0042 },
        { "C", 0x0043 },
        { "D", 0x0044 },
        { "E", 0x0045 },
        { "Euro", 0x0080 },
        { "F", 0x0046 },
        { "G", 0x0047 },
        { "H", 0x0048 },
        { "I", 0x0049 },
        { "J", 0x004A },
        { "K", 0x004B },
        { "L", 0x004C },
        { "M", 0x004D },
        { "N", 0x004E },
        { "O", 0x004F },
        { "OE", 0x008C },
        { "P", 0x0050 },
        { "Q", 0x0051 },
        { "R", 0x0052 },
        { "S", 0x0053 },
        { "T", 0x0054 },
        { "U", 0x0055 },
        { "V", 0x0056 },
        { "W", 0x0057 },
        { "X", 0x0058 },
        { "Y", 0x0059 },
        { "Z", 0x005A },
        { "a", 0x0061 },
        { "acircumflex", 0x00E2 },
        { "acute", 0x00B4 },
        { "afii299", 0x00FD },
        { "afii300", 0x00FE },
        { "afii301", 0x009E },
        { "afii57388", 0x00A1 },
        { "afii57403", 0x00BA },
        { "afii57407", 0x00BF },
        { "afii57409", 0x00C1 },
        { "afii57410", 0x00C2 },
        { "afii57411", 0x00C3 },
        { "afii57412", 0x00C4 },
        { "afii57413", 0x00C5 },
        { "afii57414", 0x00C6 },
        { "afii57415", 0x00C7 },
        { "afii57416", 0x00C8 },
        { "afii57417", 0x00C9 },
        { "afii57418", 0x00CA },
        { "afii57419", 0x00CB },
        { "afii57420", 0x00CC },
        { "afii57421", 0x00CD },
        { "afii57422", 0x00CE },
        { "afii57423", 0x00CF },
        { "afii57424", 0x00D0 },
        { "afii57425", 0x00D1 },
        { "afii57426", 0x00D2 },
        { "afii57427", 0x00D3 },
        { "afii57428", 0x00D4 },
        { "afii57429", 0x00D5 },
        { "afii57430", 0x00D6 },
        { "afii57431", 0x00D8 },
        { "afii57432", 0x00D9 },
        { "afii57433", 0x00DA },
        { "afii57434", 0x00DB },
        { "afii57440", 0x00DC },
        { "afii57441", 0x00DD },
        { "afii57442", 0x00DE },
        { "afii57443", 0x00DF },
        { "afii57444", 0x00E1 },
        { "afii57445", 0x00E3 },
        { "afii57446", 0x00E4 },
        { "afii57448", 0x00E6 },
        { "afii57449", 0x00EC },
        { "afii57450", 0x00ED },
        { "afii57451", 0x00F0 },
        { "afii57452", 0x00F1 },
        { "afii57453", 0x00F2 },
        { "afii57454", 0x00F3 },
        { "afii57455", 0x00F5 },
        { "afii57456", 0x00F6 },
        { "afii57457", 0x00F8 },
        { "afii57458", 0x00FA },
        { "afii57470", 0x00E5 },
        { "afii57506", 0x0081 },
        { "afii57507", 0x008D },
        { "afii57508", 0x008E },
        { "afii57509", 0x0090 },
        { "afii61664", 0x009D },
        { "agrave", 0x00E0 },
        { "ampersand", 0x0026 },
        { "asciicircum", 0x005E },
        { "asciitilde", 0x007E },
        { "asterisk", 0x002A },
        { "at", 0x0040 },
        { "b", 0x0062 },
        { "backslash", 0x005C },
        { "bar", 0x007C },
        { "braceleft", 0x007B },
        { "braceright", 0x007D },
        { "bracketleft", 0x005B },
        { "bracketright", 0x005D },
        { "brokenbar", 0x00A6 },
        { "bullet", 0x0095 },
        { "c", 0x0063 },
        { "ccedilla", 0x00E7 },
        { "cedilla", 0x00B8 },
        { "cent", 0x00A2 },
        { "circumflex", 0x0088 },
        { "colon", 0x003A },
        { "comma", 0x002C },
        { "copyright", 0x00A9 },
        { "currency", 0x00A4 },
        { "d", 0x0064 },
        { "dagger", 0x0086 },
        { "daggerdbl", 0x0087 },
        { "degree", 0x00B0 },
        { "dieresis", 0x00A8 },
        { "divide", 0x00F7 },
        { "dollar", 0x0024 },
        { "e", 0x0065 },
        { "eacute", 0x00E9 },
        { "ecircumflex", 0x00EA },
        { "edieresis", 0x00EB },
        { "egrave", 0x00E8 },
        { "eight", 0x0038 },
        { "ellipsis", 0x0085 },
        { "emdash", 0x0097 },
        { "endash", 0x0096 },
        { "equal", 0x003D },
        { "exclam", 0x0021 },
        { "f", 0x0066 },
        { "five", 0x0035 },
        { "florin", 0x0083 },
        { "four", 0x0034 },
        { "g", 0x0067 },
        { "grave", 0x0060 },
        { "greater", 0x003E },
        { "guillemotleft", 0x00AB },
        { "guillemotright", 0x00BB },
        { "guilsinglleft", 0x008B },
        { "guilsinglright", 0x009B },
        { "h", 0x0068 },
        { "hyphen", 0x002D },
        { "i", 0x0069 },
        { "icircumflex", 0x00EE },
        { "idieresis", 0x00EF },
        { "j", 0x006A },
        { "k", 0x006B },
        { "l", 0x006C },
        { "less", 0x003C },
        { "logicalnot", 0x00AC },
        { "m", 0x006D },
        { "macron", 0x00AF },
        { "mu", 0x00B5 },
        { "multiply", 0x00D7 },
        { "n", 0x006E },
        { "nbspace", 0x00A0 },
        { "nine", 0x0039 },
        { "numbersign", 0x0023 },
        { "o", 0x006F },
        { "ocircumflex", 0x00F4 },
        { "oe", 0x009C },
        { "one", 0x0031 },
        { "onehalf", 0x00BD },
        { "onequarter", 0x00BC },
        { "onesuperior", 0x00B9 },
        { "p", 0x0070 },
        { "paragraph", 0x00B6 },
        { "parenleft", 0x0028 },
        { "parenright", 0x0029 },
        { "percent", 0x0025 },
        { "period", 0x002E },
        { "periodcentered", 0x00B7 },
        { "perthousand", 0x0089 },
        { "plus", 0x002B },
        { "plusminus", 0x00B1 },
        { "q", 0x0071 },
        { "question", 0x003F },
        { "quotedbl", 0x0022 },
        { "quotedblbase", 0x0084 },
        { "quotedblleft", 0x0093 },
        { "quotedblright", 0x0094 },
        { "quoteleft", 0x0091 },
        { "quoteright", 0x0092 },
        { "quotesinglbase", 0x0082 },
        { "quotesingle", 0x0027 },
        { "r", 0x0072 },
        { "registered", 0x00AE },
        { "s", 0x0073 },
        { "section", 0x00A7 },
        { "semicolon", 0x003B },
        { "seven", 0x0037 },
        { "sfthyphen", 0x00AD },
        { "six", 0x0036 },
        { "slash", 0x002F },
        { "space", 0x0020 },
        { "sterling", 0x00A3 },
        { "t", 0x0074 },
        { "three", 0x0033 },
        { "threequarters", 0x00BE },
        { "threesuperior", 0x00B3 },
        { "trademark", 0x0099 },
        { "two", 0x0032 },
        { "twosuperior", 0x00B2 },
        { "u", 0x0075 },
        { "ucircumflex", 0x00FB },
        { "udieresis", 0x00FC },
        { "ugrave", 0x00F9 },
        { "underscore", 0x005F },
        { "v", 0x0076 },
        { "w", 0x0077 },
        { "x", 0x0078 },
        { "y", 0x0079 },
        { "yen", 0x00A5 },
        { "z", 0x007A },
        { "zero", 0x0030 }
        }
    },

    //
    // Code page 1257: Baltic
    //
    { 1257, BALTIC_CHARSET, BALTIC_GS_NAME, 223,
        {
        { ".notdef", 0x0081 },
        { ".notdef", 0x0083 },
        { ".notdef", 0x0088 },
        { ".notdef", 0x008A },
        { ".notdef", 0x008C },
        { ".notdef", 0x008D },
        { ".notdef", 0x008E },
        { ".notdef", 0x008F },
        { ".notdef", 0x0090 },
        { ".notdef", 0x0098 },
        { ".notdef", 0x009A },
        { ".notdef", 0x009C },
        { ".notdef", 0x009D },
        { ".notdef", 0x009E },
        { ".notdef", 0x009F },
        { ".notdef", 0x00A5 },
        { "A", 0x0041 },
        { "AE", 0x00AF },
        { "Adieresis", 0x00C4 },
        { "Amacron", 0x00C2 },
        { "Aogonek", 0x00C0 },
        { "Aring", 0x00C5 },
        { "B", 0x0042 },
        { "C", 0x0043 },
        { "Cacute", 0x00C3 },
        { "Ccaron", 0x00C8 },
        { "D", 0x0044 },
        { "E", 0x0045 },
        { "Eacute", 0x00C9 },
        { "Edot", 0x00CB },
        { "Emacron", 0x00C7 },
        { "Eogonek", 0x00C6 },
        { "Euro", 0x0080 },
        { "F", 0x0046 },
        { "G", 0x0047 },
        { "Gcedilla", 0x00CC },
        { "H", 0x0048 },
        { "I", 0x0049 },
        { "Imacron", 0x00CE },
        { "Iogonek", 0x00C1 },
        { "J", 0x004A },
        { "K", 0x004B },
        { "Kcedilla", 0x00CD },
        { "L", 0x004C },
        { "Lcedilla", 0x00CF },
        { "Lslash", 0x00D9 },
        { "M", 0x004D },
        { "N", 0x004E },
        { "Nacute", 0x00D1 },
        { "Ncedilla", 0x00D2 },
        { "O", 0x004F },
        { "Oacute", 0x00D3 },
        { "Odieresis", 0x00D6 },
        { "Omacron", 0x00D4 },
        { "Otilde", 0x00D5 },
        { "P", 0x0050 },
        { "Q", 0x0051 },
        { "R", 0x0052 },
        { "Rcedilla", 0x00AA },
        { "S", 0x0053 },
        { "Sacute", 0x00DA },
        { "Scaron", 0x00D0 },
        { "T", 0x0054 },
        { "U", 0x0055 },
        { "Udieresis", 0x00DC },
        { "Umacron", 0x00DB },
        { "Uogonek", 0x00D8 },
        { "V", 0x0056 },
        { "W", 0x0057 },
        { "X", 0x0058 },
        { "Y", 0x0059 },
        { "Z", 0x005A },
        { "Zacute", 0x00CA },
        { "Zcaron", 0x00DE },
        { "Zdotaccent", 0x00DD },
        { "a", 0x0061 },
        { "acute", 0x00B4 },
        { "adieresis", 0x00E4 },
        { "ae", 0x00BF },
        { "amacron", 0x00E2 },
        { "ampersand", 0x0026 },
        { "aogonek", 0x00E0 },
        { "aring", 0x00E5 },
        { "asciicircum", 0x005E },
        { "asciitilde", 0x007E },
        { "asterisk", 0x002A },
        { "at", 0x0040 },
        { "b", 0x0062 },
        { "backslash", 0x005C },
        { "bar", 0x007C },
        { "braceleft", 0x007B },
        { "braceright", 0x007D },
        { "bracketleft", 0x005B },
        { "bracketright", 0x005D },
        { "breve", 0x00A2 },
        { "brokenbar", 0x00A6 },
        { "bullet", 0x0095 },
        { "c", 0x0063 },
        { "cacute", 0x00E3 },
        { "caron", 0x00A1 },
        { "ccaron", 0x00E8 },
        { "cedilla", 0x00B8 },
        { "colon", 0x003A },
        { "comma", 0x002C },
        { "copyright", 0x00A9 },
        { "currency", 0x00A4 },
        { "d", 0x0064 },
        { "dagger", 0x0086 },
        { "daggerdbl", 0x0087 },
        { "dieresis", 0x00A8 },
        { "divide", 0x00F7 },
        { "dollar", 0x0024 },
        { "dotaccent", 0x00FF },
        { "e", 0x0065 },
        { "eacute", 0x00E9 },
        { "edot", 0x00EB },
        { "eight", 0x0038 },
        { "ellipsis", 0x0085 },
        { "emacron", 0x00E7 },
        { "emdash", 0x0097 },
        { "endash", 0x0096 },
        { "eogonek", 0x00E6 },
        { "equal", 0x003D },
        { "exclam", 0x0021 },
        { "f", 0x0066 },
        { "five", 0x0035 },
        { "four", 0x0034 },
        { "g", 0x0067 },
        { "gcedilla", 0x00EC },
        { "germandbls", 0x00DF },
        { "grave", 0x0060 },
        { "greater", 0x003E },
        { "guillemotleft", 0x00AB },
        { "guillemotright", 0x00BB },
        { "guilsinglleft", 0x008B },
        { "guilsinglright", 0x009B },
        { "h", 0x0068 },
        { "hyphen", 0x002D },
        { "i", 0x0069 },
        { "imacron", 0x00EE },
        { "iogonek", 0x00E1 },
        { "j", 0x006A },
        { "k", 0x006B },
        { "kcedilla", 0x00ED },
        { "l", 0x006C },
        { "lcedilla", 0x00EF },
        { "less", 0x003C },
        { "logicalnot", 0x00AC },
        { "lslash", 0x00F9 },
        { "m", 0x006D },
        { "mu", 0x00B5 },
        { "multiply", 0x00D7 },
        { "n", 0x006E },
        { "nacute", 0x00F1 },
        { "nbspace", 0x00A0 },
        { "ncedilla", 0x00F2 },
        { "nine", 0x0039 },
        { "numbersign", 0x0023 },
        { "o", 0x006F },
        { "oacute", 0x00F3 },
        { "odieresis", 0x00F6 },
        { "ogonek", 0x00B2 },
        { "omacron", 0x00F4 },
        { "one", 0x0031 },
        { "onehalf", 0x00BD },
        { "onequarter", 0x00BC },
        { "onesuperior", 0x00B9 },
        { "otilde", 0x00F5 },
        { "p", 0x0070 },
        { "paragraph", 0x00B6 },
        { "parenleft", 0x0028 },
        { "parenright", 0x0029 },
        { "percent", 0x0025 },
        { "period", 0x002E },
        { "periodcentered", 0x00B7 },
        { "perthousand", 0x0089 },
        { "plus", 0x002B },
        { "plusminus", 0x00B1 },
        { "q", 0x0071 },
        { "question", 0x003F },
        { "quotedbl", 0x0022 },
        { "quotedblbase", 0x0084 },
        { "quotedblleft", 0x0093 },
        { "quotedblright", 0x0094 },
        { "quoteleft", 0x0091 },
        { "quoteright", 0x0092 },
        { "quotesinglbase", 0x0082 },
        { "quotesingle", 0x0027 },
        { "r", 0x0072 },
        { "rcedilla", 0x00BA },
        { "registered", 0x00AE },
        { "ring", 0x00B0 },
        { "s", 0x0073 },
        { "sacute", 0x00FA },
        { "scaron", 0x00F0 },
        { "section", 0x00A7 },
        { "semicolon", 0x003B },
        { "seven", 0x0037 },
        { "sfthyphen", 0x00AD },
        { "six", 0x0036 },
        { "slash", 0x002F },
        { "space", 0x0020 },
        { "sterling", 0x00A3 },
        { "t", 0x0074 },
        { "three", 0x0033 },
        { "threequarters", 0x00BE },
        { "threesuperior", 0x00B3 },
        { "trademark", 0x0099 },
        { "two", 0x0032 },
        { "u", 0x0075 },
        { "udieresis", 0x00FC },
        { "umacron", 0x00FB },
        { "underscore", 0x005F },
        { "uogonek", 0x00F8 },
        { "v", 0x0076 },
        { "w", 0x0077 },
        { "x", 0x0078 },
        { "y", 0x0079 },
        { "z", 0x007A },
        { "zacute", 0x00EA },
        { "zcaron", 0x00FE },
        { "zdotaccent", 0x00FD },
        { "zero", 0x0030 }
        }
    },

    //
    // (jWinCharset) Placeholder for Composite Charset: CS_ANSI_RUS
    //
    // We can remove following two charsets since the driver does not support them.
    // However, we should change some other structures such as aStdCPList and 
    // CHARSETSUPPORT. To make it safer, I would like to keep them unchanged. 
    // Jack Jia,  4/5/00
    //         
    //
    { 0, RUSSIAN_CHARSET, ANSI_CYR_GS_NAME, 0,
        {
        {"", }
        }
    },

    //
    // (jWinCharset) Placeholder for Composite Charset: CS_ANSI_RUS_EE_BAL_TURK
    //
    { 0, RUSSIAN_CHARSET, ANSI_CYR_EE_BAL_TURK_GS_NAME, 0,
        {
        {"", }
        }
    },

    //
    // Code page 950: Chinese Big5
    //
    { 950, CHINESEBIG5_CHARSET, CHN_BIG5_GS_NAME, 0,
        {
        {"", }
        }
    },

    //
    // Code page 936: Simplified Chinese
    //
    { 936, GB2312_CHARSET, CHN_SMPL_GBK_GS_NAME, 0,
        {
        {"", }
        }
    },

    //
    // Code page 932: Japanese (Shift JIS)
    //
    { 932, SHIFTJIS_CHARSET, SHIFTJIS_GS_NAME, 0,
        {
        {"", }
        }
    },

    //
    // Code page 932: Japanese (Shift JIS) 90msp
    //

    { 932, SHIFTJIS_CHARSET, SHIFTJIS_P_GS_NAME, 0,
        {
        {"", }
        }
    },

    //
    // Code page 932: Japanese (Shift JIS 1983 character collection)
    //
    { 932, SHIFTJIS_CHARSET, SHIFTJIS_83PV_GS_NAME, 0,
        {
        {"", }
        }
    },

    //
    // Code page 949: Korean (Hangeul)
    //
    { 949, HANGEUL_CHARSET, KSCMS_UHC_GS_NAME, 0,
        {
        {"", }
        }
    },

    //
    // Code page 949: Korean (Hangeul) HW
    //
    { 949, HANGEUL_CHARSET, KSCMS_UHC_HW_GS_NAME, 0,
        {
        {"", }
        }
    },

    //
    // Code page 1361: Korean (Johab)
    //
    { 1361, JOHAB_CHARSET, KSC_JOHAB_GS_NAME, 0,
        {
        {"", }
        }
    }
};

//
// Mapping from family names to Windows FF_ family types.
//
#define NUM_FONT_FAM_TYPES 5

KEY FontFamilies[NUM_FONT_FAM_TYPES] =
{
    { "Roman",      FF_ROMAN        },
    { "Swiss",      FF_SWISS        },
    { "Decorative", FF_DECORATIVE   },
    { "Modern",     FF_MODERN       },
    { "Script",     FF_SCRIPT       }
};

TBL FamilyKeyTbl = { NUM_FONT_FAM_TYPES, FontFamilies };

//
// Mapping from pitch names to Windows FF_ ptich types.
//
#define NUM_FONT_PITCH_TYPES 3

KEY FontPitch[NUM_FONT_PITCH_TYPES] =
{
    { "Default",        DEFAULT_PITCH },
    { "Fixed",          FIXED_PITCH   },
    { "Proportional",   VARIABLE_PITCH}
};

TBL PitchKeyTbl = { NUM_FONT_PITCH_TYPES, FontPitch };

//
// Mapping from AFM Weight Token values to Windows Weight values.
//
#define NUM_FONT_WEIGHT_TYPES 16

KEY WeightKeys[NUM_FONT_WEIGHT_TYPES] =
{
    { "Light",              FW_NORMAL   },
    { "LightCondensed",     FW_NORMAL   },
    { "Book",               FW_NORMAL   },
    { "Medium",             FW_NORMAL   },
    { "Roman",              FW_NORMAL   },
    { "Regular",            FW_NORMAL   },
    { "Italic",             FW_NORMAL   },
    { "MediumCondensed",    FW_NORMAL   },
    { "Bold",               FW_BOLD     },
    { "BoldItalic",         FW_BOLD     },
    { "Demi",               FW_BOLD     },
    { "Poster",             FW_BOLD     },
    { "Heavy",              FW_BOLD     },
    { "Black",              FW_BOLD     },
    { "BlackCondensed",     FW_BOLD     },
    { "BoldCondensed",      FW_BOLD     }
};

#define NUM_FONT_WEIGHT_TYPES_CJK 27
KEY WeightKeysCJK[NUM_FONT_WEIGHT_TYPES_CJK] =
{
    { "Light",              FW_NORMAL   },
    { "LightCondensed",     FW_NORMAL   },
    { "Book",               FW_NORMAL   },
    { "Roman",              FW_NORMAL   },
    { "Regular",            FW_NORMAL   },
    { "Italic",             FW_NORMAL   },
    { "Medium",             FW_NORMAL   },
    { "MediumCondensed",    FW_NORMAL   },
    { "Bold",               FW_BOLD     },
    { "BoldItalic",         FW_BOLD     },
    { "Demi",               FW_BOLD     },
    { "Poster",             FW_BOLD     },
    { "Heavy",              FW_BOLD     },
    { "Black",              FW_BOLD     },
    { "BlackCondensed",     FW_BOLD     },
    { "BoldCondensed",      FW_BOLD     },
    { "W3",                 FW_NORMAL   },
    { "W3H",                FW_NORMAL   },
    { "W4",                 FW_NORMAL   },
    { "W5",                 FW_NORMAL   },
    { "W7",                 FW_BOLD     },
    { "W9",                 FW_BOLD     },

    { "regular",            FW_NORMAL   },
    { "heavy",              FW_BOLD     },
    { "Ultra",              FW_BOLD     },
    { "MA31",               FW_BOLD     },
    { "MB31",               FW_BOLD     },
};

TBL WeightKeyTbl[] =
{
    NUM_FONT_WEIGHT_TYPES,     WeightKeys,
    NUM_FONT_WEIGHT_TYPES_CJK, WeightKeysCJK
};


//
// Alias Family Tables.
// The first element is the base name and is the one displayed on the font menu
// name list. The rest of the elements are its alias names.
// (Basicall these alias names are of PostScript only. All the TrueType names
// which were originally there are disabled to fix Adobe bug #259664.)
//
// Make sure to have the same lists in pfmtontm.c too.
//

char *TimesAlias[] =
{"Times",
    "Times Roman",
    "TimesRoman",
    "Tms Rmn",
    "TmsRmn",
    "Varitimes",
    "Dutch",
    "TimesNewRomanPS",
    // "Times New Roman",
    NULL
};

char *HelveticaAlias[] =
{"Helvetica",
    "Helv",
    "Swiss",
    // "Arial",
    NULL
};

/*
char *CourierAlias[] =
{"Courier",
    "Courier New",
    NULL
};
*/

char *HelveticaNarrowAlias[] =
{"Helvetica-Narrow",
    "Helvetica Narrow",
    // "Arial-Narrow",
    // "Arial Narrow",
    NULL
};

char *PalatinoAlias[] =
{"Palatino",
    "Zapf Calligraphic",
    "ZapfCalligraphic",
    // "Bookman Antiqua",
    // "Book Antiqua",
    NULL
};

char *BookmanAlias[] =
{"Bookman",
    "ITC Bookman",
    // "Bookman Old Style",
    NULL
};

char *NewCenturySBAlias[] =
{"NewCenturySchlbk",
    "New Century Schoolbook",
    "NewCenturySchoolBook",
    // "Century Schoolbook",
    // "CenturySchoolBook",
    NULL
};

char *AvantGardeAlias[] =
{"AvantGarde",
    "ITC Avant Garde Gothic",
    "ITC Avant Garde",
    // "Century Gothic",
    NULL
};

char *ZapfChanceryAlias[] =
{"ZapfChancery",
    "ITC Zapf Chancery",
    // "Monotype Corsiva",
    NULL
};

char *ZapfDingbatsAlias[] =
{"ZapfDingbats",
    "Zapf Dingbats",
    "ITC Zapf Dingbats",
    // "Monotype Sorts",
    NULL
};

//
// Table of char width biases for average width computation. In order
// from 'a' to 'z'.
//
ULONG CharWidthBias[] =
{
    //   a    b    c    d    e    f    g    h    i    j    k    l    m    n
        64,  14,  27,  35, 100,  20,  14,  42,  63,   3,   6,  35,  20,  56,
    //   o    p    q    r    s    t    u    v    w    x    y    z
        56,  17,   4,  49,  56,  71,  31,  10,  18,   3,  18,   2
};

//
//
// Mapping from Adobe CJK Char Collection names to Win Codepage values.
//
#define NUM_CJK_CHAR_COLS 8

KEY CjkCollections[NUM_CJK_CHAR_COLS] =
{
    { "Adobe-CNS1-0",   CS_CHINESEBIG5  },
    { "Adobe-GB1-1",    CS_GB2312       },

    { "Adobe-Japan1-0", CS_SHIFTJIS83   },
    { "Adobe-Japan1-1", CS_SHIFTJIS     },
    { "Adobe-Japan1-2", CS_SHIFTJIS     },
    { "Adobe-Japan2-0", CS_SHIFTJIS     },

    { "Adobe-Korea1-0", CS_HANGEUL      },
    { "Adobe-Korea1-1", CS_HANGEUL      }
};

TBL CjkColTbl = { NUM_CJK_CHAR_COLS, CjkCollections };

PWCHAR CjkFnameTbl[8][CMAPS_PER_COL] =
{
    // Caution: each line has to match a CS in the CHSETSUPPORT enum list.

    { L"ucs2bg5.map", L"ucs2bg5.map", L"Unicnsh.PS",  L"Unicnsv.PS"  }, // CS_CHINESEBIG5
    { L"ucs2gbk.map", L"ucs2gbk.map", L"Unigbh.PS",   L"Unigbv.PS"   }, // CS_GB2312

    { L"ucs2msj.map", L"ucs2msj.map", L"Unijish.PS",  L"Unijisv.PS"  }, // CS_SHIFTJIS
    { L"ucs2msj.map", L"ucs2msj.map", L"Unijish.PS",  L"Unijisv.PS"  }, // CS_SHIFTJISP
    { L"ucs283h.map", L"ucs283v.map", L"Uni83h.PS",   L"Uni83v.PS"   }, // CS_SHIFTJIS83

    { L"ucs2uhc.map", L"ucs2uhc.map", L"UniKSh.PS",   L"UniKSv.PS"   }, // CS_HANGEUL
    { L"ucs2uhc.map", L"ucs2uhc.map", L"UniKSh.PS",   L"UniKSv.PS"   }, // CS_HANGEULHW
    { L"ucs2jhb.map", L"ucs2jhb.map", L"UniKSh.PS",   L"UniKSv.PS"   }, // CS_JOHAB
};

//
// PropCjkGsNames: a list of GlyphSet names of which font is proportional.
// (The last element has to be NULL.)
//
char* PropCjkGsNames[] =
{
    KSCMS_UHC_GS_NAME,
    SHIFTJIS_P_GS_HNAME,
    SHIFTJIS_P_GS_VNAME,
    KSCMS_UHC_GS_HNAME,
    KSCMS_UHC_GS_VNAME,
    NULL
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\tools\ps\ntfdump\precomp.h ===
/*++

Copyright (c) 1996-1997  Microsoft Corporation

Module Name:

    precomp.h

Abstract:

    UNI_GLYPHSETDATA dump tool precompile header.
    All other header files should be included in this precompiled header.

Environment:

    Windows NT printer drivers

Revision History:

    11/01/96 -eigos-
        Created it.

--*/


#ifndef _PRECOMP_H_
#define _PRECOMP_H_

#include        <lib.h>
#include        <pslib.h>

#endif // _PRECOMP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\tools\ps\makentf\writentf.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    writentf.c

Abstract:

    Write a NTF file.

Environment:

    Windows NT PostScript driver.

Revision History:

    07/08/98 -ksuzuki-
        Modified to support -v(verbose) and -o(optimize) options.

    11/21/96 -slam-
        Created.

    dd-mm-yy -author-
        description

--*/


#include "writentf.h"

extern bVerbose;
extern bOptimize;

int __cdecl compareGlyphSet(const void *elem1, const void *elem2)
{
    PGLYPHSETDATA   *p1;
    PGLYPHSETDATA   *p2;
    PGLYPHSETDATA   pGlyphSet1;
    PGLYPHSETDATA   pGlyphSet2;
    DWORD           hashValue1, hashValue2;

    p1 = (PGLYPHSETDATA*)elem1;
    p2 = (PGLYPHSETDATA*)elem2;

    pGlyphSet1 = *p1;
    pGlyphSet2 = *p2;

    hashValue1 = HashKeyword(MK_PTR(pGlyphSet1, dwGlyphSetNameOffset));
    hashValue2 = HashKeyword(MK_PTR(pGlyphSet2, dwGlyphSetNameOffset));

    if (hashValue1 == hashValue2)
        return(0);
    else if (hashValue1 < hashValue2)
        return(-1);
    else
        return(1);
}


int __cdecl compareFontMtx(const void *elem1, const void *elem2)
{
    PNTM    *p1;
    PNTM    *p2;
    PNTM    pNTM1;
    PNTM    pNTM2;
    DWORD   hashValue1, hashValue2;

    p1 = (PNTM*)elem1;
    p2 = (PNTM*)elem2;

    pNTM1 = *p1;
    pNTM2 = *p2;

    hashValue1 = HashKeyword(MK_PTR(pNTM1, dwFontNameOffset));
    hashValue2 = HashKeyword(MK_PTR(pNTM2, dwFontNameOffset));

    if (hashValue1 == hashValue2)
        return(0);
    else if (hashValue1 < hashValue2)
        return(-1);
    else
        return(1);
}


BOOL
WriteNTF(
    IN  PWSTR           pwszNTFFile,
    IN  DWORD           dwGlyphSetCount,
    IN  DWORD           dwGlyphSetTotalSize,
    IN  PGLYPHSETDATA   *pGlyphSetData,
    IN  DWORD           dwFontMtxCount,
    IN  DWORD           dwFontMtxTotalSize,
    IN  PNTM            *pNTM
    )
{
    HANDLE              hNTFFile;
    NTF_FILEHEADER      fileHeader;
    PNTF_GLYPHSETENTRY  pGlyphSetEntry;
    PNTF_FONTMTXENTRY   pFontMtxEntry;
    ULONG               ulGlyphSetEntrySize;
    ULONG               ulFontMtxEntrySize;
    ULONG               ulByteWritten;
    ULONG               i, j;
    DWORD               dwOffset;
    DWORD               dwGlyphSetCount2, dwGlyphSetTotalSize2;
    PGLYPHSETDATA       pgsd;
    DWORD               dwEofMark = NTF_EOF_MARK;


    dwGlyphSetCount2 = dwGlyphSetTotalSize2 = 0;

    //
    // Count the number of glyphsets necessary or referenced and their total
    // size. When optimization option is specified, don't count the glyphsets
    // without reference mark.
    //
    for (i = 0; i < dwGlyphSetCount; i++)
    {
        if (!bOptimize || pGlyphSetData[i]->dwReserved[0])
        {
            dwGlyphSetCount2++;
            dwGlyphSetTotalSize2 += pGlyphSetData[i]->dwSize;
        }
    }

    if (!bOptimize && (dwGlyphSetTotalSize != dwGlyphSetTotalSize2))
    {
        ERR(("WriteNTF:total size mismatch on optimization\n"));
        return FALSE;
    }

    if (bVerbose)
    {
        printf("Number of glyphset:%ld(total:%ld)\n",
                        dwGlyphSetCount, dwGlyphSetTotalSize);
        if (bOptimize)
        {
            printf("Number of glyphset referenced:%ld(total:%ld)\n",
                                dwGlyphSetCount2, dwGlyphSetTotalSize2);
        }

        printf("Number of font matrix:%ld(total:%ld)\n",
                        dwFontMtxCount, dwFontMtxTotalSize);

        printf("\n");
    }

    // Fill in NTF file header.

    fileHeader.dwSignature = NTF_FILE_MAGIC;
    fileHeader.dwDriverType = NTF_DRIVERTYPE_PS;
    fileHeader.dwVersion = NTF_VERSION_NUMBER;

    for (i = 0; i < 5; i++)
        fileHeader.dwReserved[i] = 0;

    fileHeader.dwGlyphSetCount = dwGlyphSetCount2;
    fileHeader.dwFontMtxCount = dwFontMtxCount;

    ulGlyphSetEntrySize = dwGlyphSetCount2 * sizeof(NTF_GLYPHSETENTRY);
    ulFontMtxEntrySize = dwFontMtxCount * sizeof(NTF_FONTMTXENTRY);

    fileHeader.dwGlyphSetOffset = sizeof(NTF_FILEHEADER);

    fileHeader.dwFontMtxOffset = fileHeader.dwGlyphSetOffset + ulGlyphSetEntrySize;

    // Fill in glyph set entries.

    qsort(pGlyphSetData, dwGlyphSetCount, sizeof(PGLYPHSETDATA), compareGlyphSet);

    pGlyphSetEntry = MemAllocZ(ulGlyphSetEntrySize);
    if (!pGlyphSetEntry)
    {
        ERR(("WriteNTF:MemAllocZ\n"));
        return(FALSE);
    }

    dwOffset = fileHeader.dwFontMtxOffset + ulFontMtxEntrySize;

    for (i = j = 0; i < dwGlyphSetCount; i++)
    {
        pgsd = pGlyphSetData[i];

        // If no refernce mark is set with optimization option, ignore this
        // glyphset data.
        if (bOptimize && !(pgsd->dwReserved[0]))
        {
            pgsd = NULL;
        }

        if (pgsd)
        {
            pGlyphSetEntry[j].dwNameOffset   = dwOffset + pgsd->dwGlyphSetNameOffset;
            pGlyphSetEntry[j].dwHashValue    = HashKeyword(MK_PTR(pgsd, dwGlyphSetNameOffset));
            pGlyphSetEntry[j].dwDataSize     = pgsd->dwSize;
            pGlyphSetEntry[j].dwDataOffset   = dwOffset;
            pGlyphSetEntry[j].dwGlyphSetType = 0;
            pGlyphSetEntry[j].dwFlags        = 0;
            pGlyphSetEntry[j].dwReserved[0]  = 0;
            pGlyphSetEntry[j].dwReserved[1]  = 0;

            dwOffset += pgsd->dwSize;
            j++;
        }
    }

    // Fill in font metrics entries.

    qsort(pNTM, dwFontMtxCount, sizeof(PNTM), compareFontMtx);

    pFontMtxEntry = MemAllocZ(ulFontMtxEntrySize);
    if (!pFontMtxEntry)
    {
        ERR(("WriteNTF:MemAllocZ\n"));
        MemFree(pGlyphSetEntry);
        return(FALSE);
    }

    if (dwOffset != (fileHeader.dwFontMtxOffset +
                     ulFontMtxEntrySize +
                     dwGlyphSetTotalSize2))
    {
        ERR(("WriteNTF:dwOffset\n"));
        MemFree(pGlyphSetEntry);
        MemFree(pFontMtxEntry);
        return(FALSE);
    }
    for (i = 0; i < dwFontMtxCount; i++)
    {
        pFontMtxEntry[i].dwFontNameOffset = dwOffset + pNTM[i]->dwFontNameOffset;
        pFontMtxEntry[i].dwHashValue      = HashKeyword(MK_PTR(pNTM[i], dwFontNameOffset));
        pFontMtxEntry[i].dwDataSize       = pNTM[i]->dwSize;
        pFontMtxEntry[i].dwDataOffset     = dwOffset;
        pFontMtxEntry[i].dwVersion        = 0;
        pFontMtxEntry[i].dwReserved[0]    = 0;
        pFontMtxEntry[i].dwReserved[1]    = 0;
        pFontMtxEntry[i].dwReserved[2]    = 0;

        dwOffset += pNTM[i]->dwSize;
    }


    //
    // Begin to write everything into the NTF file!
    //
    hNTFFile = CreateFile(pwszNTFFile, GENERIC_WRITE, FILE_SHARE_READ, NULL,
                          CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);

    if (hNTFFile == INVALID_HANDLE_VALUE)
    {
        ERR(("WriteNTF:CreateFile\n"));
        MemFree(pGlyphSetEntry);
        MemFree(pFontMtxEntry);
        return(FALSE);
    }

    if (!WriteFile(hNTFFile, (LPVOID)&fileHeader, sizeof(NTF_FILEHEADER),
                   (LPDWORD)&ulByteWritten, (LPOVERLAPPED)NULL)
            || (ulByteWritten != sizeof(NTF_FILEHEADER)))
    {
        ERR(("WriteNTF:WriteFile\n"));
        MemFree(pGlyphSetEntry);
        MemFree(pFontMtxEntry);
        CloseHandle(hNTFFile);
        return(FALSE);
    }
    if (bVerbose)
    {
        char s[5];
        s[0] = (char)(fileHeader.dwSignature >> 24);
        s[1] = (char)(fileHeader.dwSignature >> 16);
        s[2] = (char)(fileHeader.dwSignature >>  8);
        s[3] = (char)(fileHeader.dwSignature      );
        s[4] = '\0';
        printf("NTF_FILEHEADER:dwSignature:%08X('%s')\n", fileHeader.dwSignature, s);
        s[0] = (char)(fileHeader.dwDriverType >> 24);
        s[1] = (char)(fileHeader.dwDriverType >> 16);
        s[2] = (char)(fileHeader.dwDriverType >>  8);
        s[3] = (char)(fileHeader.dwDriverType      );
        s[4] = '\0';
        printf("NTF_FILEHEADER:dwDriverType:%08X('%s')\n", fileHeader.dwDriverType, s);
        printf("NTF_FILEHEADER:dwVersion:%08X\n", fileHeader.dwVersion);
        printf("NTF_FILEHEADER:dwGlyphSetCount:%ld\n", fileHeader.dwGlyphSetCount);
        printf("NTF_FILEHEADER:dwFontMtxCount:%ld\n", fileHeader.dwFontMtxCount);
        printf("\n");
    }

    if (!WriteFile(hNTFFile, (LPVOID)pGlyphSetEntry, ulGlyphSetEntrySize,
                   (LPDWORD)&ulByteWritten, (LPOVERLAPPED)NULL)
            || (ulByteWritten != ulGlyphSetEntrySize))
    {
        ERR(("WriteNTF:WriteFile\n"));
        MemFree(pGlyphSetEntry);
        MemFree(pFontMtxEntry);
        CloseHandle(hNTFFile);
        return(FALSE);
    }
    if (bVerbose)
    {
        for (i = 0; i < dwGlyphSetCount2; i++)
        {
            printf("NTF_GLYPHSETENTRY for GLYPHSETDATA #%d\n", i + 1);
            printf("NTF_GLYPHSETENTRY:dwHashValue:%08X\n", pGlyphSetEntry[i].dwHashValue);
            printf("NTF_GLYPHSETENTRY:dwDataSize:%ld\n", pGlyphSetEntry[i].dwDataSize);
            printf("\n");
        }
    }

    if (!WriteFile(hNTFFile, (LPVOID)pFontMtxEntry, ulFontMtxEntrySize,
                   (LPDWORD)&ulByteWritten, (LPOVERLAPPED)NULL)
            || (ulByteWritten != ulFontMtxEntrySize))
    {
        ERR(("WriteNTF:WriteFile\n"));
        MemFree(pGlyphSetEntry);
        MemFree(pFontMtxEntry);
        CloseHandle(hNTFFile);
        return(FALSE);
    }
    if (bVerbose)
    {
        for (i = 0; i < dwFontMtxCount; i++)
        {
            printf("NTF_FONTMTXENTRY for NTM #%d\n", i + 1);
            printf("NTF_FONTMTXENTRY:dwHashValue:%08X\n", pFontMtxEntry[i].dwHashValue);
            printf("NTF_FONTMTXENTRY:dwDataSize:%ld\n", pFontMtxEntry[i].dwDataSize);
            printf("NTF_FONTMTXENTRY:dwVersion:%08X\n", pFontMtxEntry[i].dwVersion);
            printf("\n");
        }
    }

    for (i = j = 0; i < dwGlyphSetCount; i++)
    {
        pgsd = pGlyphSetData[i];

        // If no refernce mark is set with optimization option, ignore this
        // glyphset data.
        if (bOptimize && !(pgsd->dwReserved[0]))
        {
            pgsd = NULL;
        }

        if (pgsd)
        {
            LONG lBytes, lSize = pgsd->dwSize;
            PBYTE pTemp = (PBYTE)pgsd;

            pgsd->dwReserved[0] = 0; // Make sure it's cleared always.

            while (lSize > 0)
            {
                lBytes = (lSize > 20000) ? 20000 : lSize;
                if (!WriteFile(hNTFFile, (LPVOID)pTemp, lBytes,
                                (LPDWORD)&ulByteWritten, (LPOVERLAPPED)NULL)
                        || (ulByteWritten != (ULONG)lBytes))
                {
                    ERR(("WriteNTF:WriteFile\n"));
                    MemFree(pGlyphSetEntry);
                    MemFree(pFontMtxEntry);
                    CloseHandle(hNTFFile);
                    return(FALSE);
                }
                lSize -= 20000;
                pTemp += 20000;
            }
        }

        if (bVerbose && pgsd)
        {
            printf("GLYPHSETDATA #%d\n", j++ + 1);
            printf("GLYPHSETDATA:dwSize:%ld\n", pgsd->dwSize);
            printf("GLYPHSETDATA:dwVersion:%08X\n", pgsd->dwVersion);
            printf("GLYPHSETDATA:dwFlags:%08X\n", pgsd->dwFlags);
            printf("GLYPHSETDATA:dwGlyphSetNameOffset:%s\n", (PSZ)MK_PTR(pgsd, dwGlyphSetNameOffset));
            printf("GLYPHSETDATA:dwGlyphCount:%ld\n", pgsd->dwGlyphCount);
            printf("GLYPHSETDATA:dwRunCount:%ld\n", pgsd->dwRunCount);
            printf("GLYPHSETDATA:dwCodePageCount:%ld\n", pgsd->dwCodePageCount);
            printf("\n");
        }
    }

    for (i = 0; i < dwFontMtxCount; i++)
    {
        if (!WriteFile(hNTFFile, (LPVOID)pNTM[i], pNTM[i]->dwSize,
                       (LPDWORD)&ulByteWritten, (LPOVERLAPPED)NULL)
                || (ulByteWritten != pNTM[i]->dwSize))
        {
            ERR(("WriteNTF:WriteFile\n"));
            MemFree(pGlyphSetEntry);
            MemFree(pFontMtxEntry);
            CloseHandle(hNTFFile);
            return(FALSE);
        }

        if (bVerbose)
        {
            printf("NTM #%d\n", i + 1);
            printf("NTM:dwSize:%ld\n", pNTM[i]->dwSize);
            printf("NTM:dwVersion:%08X\n", pNTM[i]->dwVersion);
            printf("NTM:dwFlags:%08X\n", pNTM[i]->dwFlags);
            printf("NTM:dwFontNameOffset:%s\n", (PSZ)MK_PTR(pNTM[i], dwFontNameOffset));
            printf("NTM:dwDisplayNameOffset:%S\n", (PTSTR)MK_PTR(pNTM[i], dwDisplayNameOffset));
            printf("NTM:dwFontVersion:%08X\n", pNTM[i]->dwFontVersion);
            printf("NTM:dwGlyphSetNameOffset:%s\n", (PSZ)MK_PTR(pNTM[i], dwGlyphSetNameOffset));
            printf("NTM:dwGlyphCount:%ld\n", pNTM[i]->dwGlyphCount);
            printf("NTM:dwCharWidthCount:%ld\n", pNTM[i]->dwCharWidthCount);
            printf("NTM:dwDefaultCharWidth:%ld\n", pNTM[i]->dwDefaultCharWidth);
            printf("NTM:dwKernPairCount:%ld\n", pNTM[i]->dwKernPairCount);
            printf("NTM:dwCharSet:%ld\n", pNTM[i]->dwCharSet);
            printf("NTM:dwCodePage:%ld\n", pNTM[i]->dwCodePage);
            printf("\n");
        }
    }

    //
    // Write EOF marker
    //
    if (!WriteFile(hNTFFile, (LPVOID)&dwEofMark, sizeof (DWORD),
                   (LPDWORD)&ulByteWritten, (LPOVERLAPPED)NULL)
            || (ulByteWritten != sizeof (DWORD)))
    {
        ERR(("WriteNTF:WriteFile:EOF\n"));
        MemFree(pGlyphSetEntry);
        MemFree(pFontMtxEntry);
        CloseHandle(hNTFFile);
        return (FALSE);
    }

    MemFree(pGlyphSetEntry);
    MemFree(pFontMtxEntry);
    CloseHandle(hNTFFile);
    return(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\tools\ps\makentf\writentf.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    writentf.h

Abstract:

    Write a NTF file.

Environment:

    Windows NT PostScript driver.

Revision History:

	11/21/96 -slam-
		Created.

	dd-mm-yy -author-
		description

--*/


#ifndef _WRITENTF_H_
#define _WRITENTF_H_


#include "lib.h"
#include "ppd.h"
#include "pslib.h"


BOOL
WriteNTF(
    IN  PWSTR           pwszNTFFile,
    IN  DWORD           dwGlyphSetCount,
    IN  DWORD           dwGlyphSetTotalSize,
    IN  PGLYPHSETDATA   *pGlyphSetData,
    IN  DWORD           dwFontMtxCount,
    IN  DWORD           dwFontMtxTotalSize,
    IN  PNTM            *pNTM
    );


#endif	//!_WRITENTF_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\tools\ps\makentf\makentf.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    makentf.c

Abstract:

    Utility to convert AFM file(s) to NTF file.

Environment:

    Windows NT PostScript driver.

Revision History:

    02/16/98 -ksuzuki-
        Added OCF font support.

    09/08/97 -ksuzuki-
        Added code to look for PSFAMILY.DAT file from the directory where
        makentf is invoked.

    09/16/96 -PPeng-
        Add the fucntion to write PS Encoding vectors out - for debugging and
        create PS Encoding Arrays as PScript resource files.

    09/16/96 -slam-
        Created.

    mm/dd/yy -author-
        description

--*/

#include <windows.h>

#include "lib.h"
#include "ppd.h"
#include "pslib.h"
#include "afm2ntm.h"
#include "cjkfonts.h"
#include "writentf.h"

//
// Globals
//
HINSTANCE   ghInstance;
PUPSCODEPT  UnicodetoPs;
PTBL        pFamilyTbl;
PSTR        pAFMCharacterSetString;
PSTR        Adobe_Japan1_0 = "Adobe-Japan1-0\n";
DWORD           dwLastErr;
PSTR		pAFMFileName = NULL;
BOOL		bVerbose = FALSE;
BOOL		bOptimize = FALSE;

// Number of auxiliary character set. Its cheif
// purpose is to support 83pv.
#define NUM_AUX_CS 1

// This macro is used to see whether the argument
// matches the differential between CS_SHIFTJIS
// and CS_WEST_MAX.
#define IS_CS_SHIFTJIS(delta) \
    ((delta) == (CS_SHIFTJIS - CS_WEST_MAX))

//
// Prototype
//
BOOL
WritePSEncodings(
    IN  PWSTR           pwszFileName,
    IN  WINCPTOPS       *CPtoPSList,
    IN  DWORD           dwPages
    );
BOOL NeedBuildMoreNTM(
    PBYTE pAFM
    );


void __cdecl
main(
    int     argc,
    char    **argv
    )

/*++

Routine Description:

    Makentf takes four steps to create a .NTF file.

    Step 1: Initialization.

    Step 2: Convert AFM(s) to NTM(s).

    Step 3: Write GLYPHSETDATA(s) and NTM(s) to a .NTF file.

    Step 4: Clean up.

Arguments:

    argc - The path of and arguments given to this program.
    argv - The number of elements pointed to by argc.

Return Value:

    None.

--*/

{
    WCHAR           wstrNTFFile[MAX_PATH];
    WCHAR           wstrAFMFile[MAX_PATH];
    WCHAR           wstrDATFile[MAX_PATH];
    WCHAR           DatFilePath[MAX_PATH];
    PNTM            *aPNTM;
    PNTM            pNTM;
    PGLYPHSETDATA   *aGlyphSets;
    PWINCODEPAGE    *aWinCodePages;
    PWINCODEPAGE    pAllWinCodePages[CS_MAX];
    PUPSCODEPT      pFontChars;
    CHSETSUPPORT    flCsupFont, flCsupGlyphSet, flCsupMatch, flCsupAll;
    ULONG           cNumNTM, cSizeNTM, ulLength, nUnicodeChars;
    PULONG          *aUniPsTbl;
    LONG            lMatch, lMatchAll;
    PBYTE           pAFM;
    FLONG           flCurCset, flLastCset;
    ULONG           cNumGlyphSets, cSizeGlyphSets;
    DWORD           ulFileSize;
    PBYTE           pFamDatFile;
    PBYTE           pCMaps[CMAPS_PER_COL];
    HANDLE          hmodule, hModCMaps[CMAPS_PER_COL];
    USHORT          cNTMCurFont;
	INT				nArgcOffset;
    LONG            c;
    ULONG           i, j;
    BOOL            bIs90mspFont;
    BOOL            bIsKSCmsHWFont;
  
    //////////////////////////////////////////////////////////////////////////
    //
    // Step 1: Initialization.
    //
    //////////////////////////////////////////////////////////////////////////

    //
    // Check if there are enough parameters.
    //
	if (argc == 1)
	{
		printf("MakeNTF usage:\n");
		printf("1. MakeNTF [-v] [-o] <NTF> <AFMs>\n");
		printf("       Create an NTF file from AFM files.\n");
		printf("       -v: verbose  (print various info)\n");
		printf("       -o: optimize (write glyphset only referenced)\n");
		printf("\n");
		printf("2. MakeNTF <PSEncodingNameList>\n");
		printf("       Generate PS encoding name list.\n");
		return;
	}

    wstrNTFFile[0] = 0;

    if (argc == 2)
    {
		ulLength = strlen(argv[1]) + 1;
		MULTIBYTETOUNICODE(wstrNTFFile,
							ulLength*sizeof(WCHAR),
							NULL,
							argv[1],
							ulLength);
		WritePSEncodings(wstrNTFFile, &aPStoCP[0], CS_MAX);
		return;
    }
	else
	{
		nArgcOffset = 0;

		for (i = 1; i <= 2; i++)
		{
			if (!strcmp(argv[i], "-v"))
			{
				bVerbose = TRUE;
				nArgcOffset++;
			}
			if (!strcmp(argv[i], "-o"))
			{
				bOptimize = TRUE;
				nArgcOffset++;
			}
		}
	}

	if (bVerbose) printf("%%%%[Begin MakeNTF]%%%%\n\n");

    //
    // Initiliaze variables that relate to memory allocation.
    //
    aPNTM = NULL;
    aGlyphSets = NULL;
    pFamilyTbl = NULL;
    UnicodetoPs = NULL;
    aUniPsTbl = NULL;
    aWinCodePages = NULL;
    cNumNTM = cSizeNTM = 0;
    cNumGlyphSets = cSizeGlyphSets = 0;

    //
    // Initialize Glyphset counter, list of all possible Windows charsets.
    //
    for (i =0; i < CS_MAX; i++)
    {
        pAllWinCodePages[i] = &aStdCPList[i];
    }

    //
    // Create a copy of the Unicode->PS char mapping table and sort it
    // in Unicode point order.
    //
    if ((UnicodetoPs =
            (PUPSCODEPT) MemAllocZ((size_t) sizeof(UPSCODEPT) * NUM_PS_CHARS))
                == NULL)
    {
                dwLastErr = GetLastError();
        ERR(("makentf - main: malloc for UnicodetoPs (%ld)\n", dwLastErr));
        return;
    }
    memcpy(UnicodetoPs, PstoUnicode, (size_t) sizeof(UPSCODEPT) * NUM_PS_CHARS);
    qsort(UnicodetoPs,
            (size_t) NUM_PS_CHARS,
            (size_t) sizeof(UPSCODEPT),
            CmpUniCodePts);

    //
    // Build complete path name for PS family DAT file.
    //
    GetCurrentDirectory(MAX_PATH, DatFilePath);
    wcscat(DatFilePath, DatFileName);

    //
    // Open PS font family .DAT file and build the font family table.
    //
    if (!(hmodule = MapFileIntoMemory(DatFilePath, &pFamDatFile, &ulFileSize)))
    {
        //
        // One more try: look for it from the directory where makentf is
        // invoked (or from the root directory).
        //
        DECLSPEC_IMPORT LPWSTR* APIENTRY CommandLineToArgvW(LPCWSTR, int*);
        LPWSTR p, pLast, *pCmdLine;
        int nArgc;

        pCmdLine = CommandLineToArgvW(GetCommandLineW(), &nArgc);
        if (pCmdLine == NULL)
        {
                        dwLastErr = GetLastError();
            ERR(("makentf - main: CommandLineToArgvW (%ld)\n", dwLastErr));
            UnmapFileFromMemory(hmodule);
            goto CLEAN_UP;
        }
        wcscpy(DatFilePath, pCmdLine[0]);
        GlobalFree(pCmdLine);

        p = pLast = DatFilePath;
        while ((p = wcsstr(p, L"\\")) != NULL)
                {
                        pLast = p;
                        p += 2;
                }
        wcscpy(pLast, DatFileName);
        hmodule = MapFileIntoMemory(DatFilePath, &pFamDatFile, &ulFileSize);
        if (!hmodule)
        {
                        dwLastErr = GetLastError();
            ERR(("makentf - main: can't open PSFAMILY.DAT file (%ld)\n", dwLastErr));
            UnmapFileFromMemory(hmodule);
            goto CLEAN_UP;
        }
    }
    BuildPSFamilyTable(pFamDatFile, &pFamilyTbl, ulFileSize);
    UnmapFileFromMemory(hmodule);

    //
    // Allocate memory to store NTM pointers.
    //
    // We quadruple the number of the arguments of this program to get the
    // number of NTM pointer. This is because
    //
    // 1) we need four NTM pointers maximum (two for H and V plus two for J
    //    90ms and 83pv) for a CJK AFM, but,
    // 2) we don't know at this time that how many of CJK AFMs we are going
    //    to process.
    //
    // Since we're only allocating pointers here it's usually OK to quadruple
    // the number of the arguments and use it as the number of NTM pointers
    // we need. (Don't forget to subtract two - one for the name of this
    // program and the other for the target NTM file name - from the number
    // of the arguments prior to quadruple.)
    //

    // Add 90msp-RKSJ support. we need 2 more NTFs - H and V for 90msp.
    // So I change the estimation number from 4 to 6.  Jack 3/15/2000
    // aPNTM = MemAllocZ(((argc - 2 - nArgcOffset) * 4) * sizeof(PNTM));
    
    aPNTM = MemAllocZ(((argc - 2 - nArgcOffset) * 6) * sizeof(PNTM));
    if (aPNTM == NULL)
    {
                dwLastErr = GetLastError();
        ERR(("makentf - main: malloc for aPNTM (%ld)\n", dwLastErr));
        goto CLEAN_UP;
    }

    //
    // Allocate memory to store pointers to Glyphset related data. We don't
    // know how many Glyphsets we will need - but we know it will be at most
    // equal to the number of character sets we support, although this will
    // probably never occur. Since we're only allocating ptrs here we'll go
    // ahead and alloc the max. Don't forget an extra entry for the Unicode
    // GLYPHSET data.
    //

    i = CS_WEST_MAX + (CS_MAX - CS_WEST_MAX + NUM_AUX_CS) * 2;

    if ((aGlyphSets = MemAllocZ(i * sizeof(PGLYPHSETDATA))) == NULL)
    {
                dwLastErr = GetLastError();
        ERR(("makentf - main: malloc for aGlyphSets (%ld)\n", dwLastErr));
        goto CLEAN_UP;
    }
    if ((aUniPsTbl = MemAllocZ(i * sizeof(PULONG))) == NULL)
    {
                dwLastErr = GetLastError();
        ERR(("makentf - main: malloc for aUniPsTbl (%ld)\n", dwLastErr));
        goto CLEAN_UP;
    }
    if ((aWinCodePages = MemAllocZ(i * sizeof(PWINCODEPAGE))) == NULL)
    {
                dwLastErr = GetLastError();
        ERR(("makentf - main: malloc for aWinCodePages (%ld)\n", dwLastErr));
        goto CLEAN_UP;
    }

    //
    // Precreate Western GLYPHSETs.
    // Note that this for loop assumes that the enum numbers from CS_228 to
    // CS_WEST_MAX are in ascending order incrementally.
    //
	if (bVerbose && !bOptimize) printf("%%%%[Begin Precreate Western Glyphsets]%%%%\n\n");

    for (i = CS_228; i < CS_WEST_MAX; i++, cNumGlyphSets++)
    {
        aWinCodePages[cNumGlyphSets] = &aStdCPList[i];
        CreateGlyphSets(&aGlyphSets[cNumGlyphSets],
                            aWinCodePages[cNumGlyphSets],
                            &aUniPsTbl[cNumGlyphSets]);
        cSizeGlyphSets += aGlyphSets[cNumGlyphSets]->dwSize;
    }

	if (bVerbose && !bOptimize) printf("%%%%[End Precreate Western Glyphsets]%%%%\n\n");


    //////////////////////////////////////////////////////////////////////////
    //
    // Step 2: Convert AFM(s) to NTM(s).
    //
    //////////////////////////////////////////////////////////////////////////

	if (bVerbose) printf("%%%%[Begin Covert AFM to NTM]%%%%\n\n");

    for (i = 2 + nArgcOffset; i < (ULONG)argc; i++)
    {
        //
        // Get AFM filename.
        //
        ulLength = strlen(argv[i]) + 1;
        MULTIBYTETOUNICODE(wstrAFMFile,
                            ulLength*sizeof(WCHAR),
                            NULL,
                            argv[i],
                            ulLength);

        //
        // Map AFM file into memory.
        //
        if (!(hmodule = MapFileIntoMemory(wstrAFMFile, &pAFM, NULL)))
        {
                        dwLastErr = GetLastError();
            ERR(("makentf - main: MapFileIntoMemory (%ld)\n", dwLastErr));
            goto CLEAN_UP;
        }

		pAFMFileName = argv[i];

        bIs90mspFont = FALSE;
        bIsKSCmsHWFont = FALSE;

        //
        // Initialization of pAFMCharacterSet must be done here
        // *before* CREATE_OCF_DATA_FROM_CID_DATA tag. The cheif
        // purpose of the initialization here is to support
        // OCF/83pv font.
        //
        pAFMCharacterSetString = FindAFMToken(pAFM, PS_CHARSET_TOK);
CREATE_OCF_DATA_FROM_CID_DATA:

        //
        // Determine which charsets this font supports. To find that,
        // we use the following variables.
        //
        // flCsupFont:      Combination of charset of the target font
        // flCsupGlyphSet:  Charset of the target font's glyphset
        // lMatch:          Index corresponding to CHSETSUPPORT, or -1
        // flCsupMatch:     Combination of charset of a closest font, or 0
        //
        flCsupFont = GetAFMCharSetSupport(pAFM, &flCsupGlyphSet);

CREATE_90MSP_RKSJ_NTM:
CREATE_KSCMS_HW_NTM:
        lMatch = -1;
        flCsupMatch = 0;
        if (flCsupGlyphSet == CS_NOCHARSET)
        {
            //
            // Determine if the current font matches any of the codepages
            // we have created so far.
            //
            lMatch = FindClosestCodePage(aWinCodePages,
                                              cNumGlyphSets,
                                              flCsupFont,
                                              &flCsupMatch);
        }
        else
        {
            if (flCsupGlyphSet == CS_228)
                lMatch = 0;
            else if (flCsupGlyphSet == CS_314)
                lMatch = 1;
            flCsupMatch = flCsupFont;
        }

        if ((flCsupGlyphSet == CS_NOCHARSET)
                &&
            ((lMatch == -1) || ((flCsupMatch & flCsupFont) != flCsupFont)))
        {
            //
            // Either:
            // We haven't created a charset which could be used to represent
            // this font so far.
            //      -or-
            // We know this font supports at least 1 of the charsets we have
            // created, but there might be a better match in the list of all
            // possible charsets.
            //
            lMatchAll = FindClosestCodePage(pAllWinCodePages,
                                                CS_MAX,
                                                flCsupFont,
                                                &flCsupAll);
            if ((flCsupAll == flCsupFont)
                || (flCsupAll & flCsupFont) > (flCsupMatch & flCsupFont))
            {
                //
                // Found a better match in a codepage which has not yet
                // been created.
                //
                lMatch = lMatchAll;

                //
                // Create a GLYPHSETDATA struct for this codepage and add
                // it to the list of those we've created so far.
                //
                aWinCodePages[cNumGlyphSets] = &aStdCPList[lMatch];

                //
                // Determine if this is a CJK font.
                //
                if (lMatch < CS_WEST_MAX)
                {
                    //
                    // Western font.
                    //
                    CreateGlyphSets(&aGlyphSets[cNumGlyphSets],
                                        aWinCodePages[cNumGlyphSets],
                                        &aUniPsTbl[cNumGlyphSets]);

                    cSizeGlyphSets += aGlyphSets[cNumGlyphSets]->dwSize;

                    //
                    // Glyphset for this font is the one we just created.
                    //
                    lMatch = cNumGlyphSets;
                    cNumGlyphSets += 1;
                }
                else
                {
                    //
                    // CJK font.
                    //
                    // Map the CMap files on memory first.
                    //
                    j = (ULONG)lMatch - CS_WEST_MAX;

                    for (c = 0; c < CMAPS_PER_COL; c++)
                    {
                        hModCMaps[c] = MapFileIntoMemory(CjkFnameTbl[j][c],
                                                            &pCMaps[c], NULL);
                        if (hModCMaps[c] == NULL)
                        {
                            while (--c >= 0)
                            {
                                UnmapFileFromMemory(hModCMaps[c]);
                            }
                                                        dwLastErr = GetLastError();
                            ERR(("makentf - main: MapFileIntoMemory (%ld)\n", dwLastErr));
                            goto CLEAN_UP;
                        }
                    }

                    //
                    // Since we're creating 2 GLYPHSETs (H and V variants)
                    // Create 2 codepage entries which point to the same
                    // Win codepage.
                    //
                    aWinCodePages[cNumGlyphSets + 1] = &aStdCPList[lMatch];

                    //
                    // Use the CMap files to create the new GLYPHSETs.
                    //
                    CreateCJKGlyphSets(&pCMaps[0],
                                        &pCMaps[2],
                                        &aGlyphSets[cNumGlyphSets],
                                        aWinCodePages[cNumGlyphSets],
                                        &aUniPsTbl[cNumGlyphSets]);

                    //
                    // Unmap the CMap files.
                    //
                    for (c = 0; c < CMAPS_PER_COL; c++)
                    {
                        UnmapFileFromMemory(hModCMaps[c]);
                    }

                    //
                    // We've created both an H and V GLYPHSET.
                    //
                    cSizeGlyphSets += aGlyphSets[cNumGlyphSets]->dwSize;
                    cSizeGlyphSets += aGlyphSets[cNumGlyphSets + 1]->dwSize;

                    //
                    // Glyphsets for this font are the ones we just created.
                    //
                    lMatch = cNumGlyphSets;
                    cNumGlyphSets += 2;
                }
            }
        }

        //
        // Determine number of NTMs to be created for this font.
        //
        cNTMCurFont =
            (aWinCodePages[lMatch]->pCsetList[0] < CS_WEST_MAX) ? 1 : 2;

        do
        {
            //
            // Generate NTM from AFM.
            //
            aPNTM[cNumNTM] = AFMToNTM(pAFM,
                                        aGlyphSets[lMatch],
                                        aUniPsTbl[lMatch],
                                        ((flCsupGlyphSet != CS_NOCHARSET) ? &flCsupFont : NULL),
                                        ((flCsupFont & CS_CJK) ? TRUE : FALSE),
                                        bIs90mspFont | bIsKSCmsHWFont);

            if (aPNTM[cNumNTM] != NULL)
            {
                //
                // Put the NTMs into a data array for WriteNTF.
                //
                cSizeNTM += NTM_GET_SIZE(aPNTM[cNumNTM]);
                cNumNTM++;
            }
            else
            {
                ERR(("makentf - main: AFMToNTM failed to create NTM:%s\n", argv[i]));
            }

            cNTMCurFont--;
            lMatch++;
        } while (cNTMCurFont);

        //
        // 90msp font support. jjia 3/16/2000
        //
        if (flCsupFont == CSUP(CS_SHIFTJIS))
        {
            if (NeedBuildMoreNTM(pAFM))
            {
                flCsupFont = CSUP(CS_SHIFTJISP);
                bIs90mspFont = TRUE;
                goto CREATE_90MSP_RKSJ_NTM; // here we go again!
            }
        }
        bIs90mspFont = FALSE;

        if (flCsupFont == CSUP(CS_HANGEUL))
        {
            if (NeedBuildMoreNTM(pAFM))
            {
                flCsupFont = CSUP(CS_HANGEULHW);
                bIsKSCmsHWFont = TRUE;
                goto CREATE_KSCMS_HW_NTM;   // here we go again!
            }
        }
        bIsKSCmsHWFont = FALSE;

        //
        // OCF/83pv font support. Create OCF glyphset and NTM data from
        // CID AFM file.
        //
        if ((flCsupFont == CSUP(CS_SHIFTJIS)) || 
            (flCsupFont == CSUP(CS_SHIFTJISP)))
        {
            pAFMCharacterSetString = Adobe_Japan1_0;
            goto CREATE_OCF_DATA_FROM_CID_DATA; // here we go again!
        }

        UnmapFileFromMemory(hmodule);
    }

	if (bVerbose) printf("%%%%[End Convert AFM to NTM]%%%%\n\n");

    //
    // Create Unicode GLYPHSET. This glyphset is created here since we don't
	// want any NTMs to reference this glyphset.
    //
	if (bVerbose && !bOptimize) printf("%%%%[Begin Create Unicode glyphset]%%%%\n\n");

    CreateGlyphSets(&aGlyphSets[cNumGlyphSets],
                    &UnicodePage,
                    &aUniPsTbl[cNumGlyphSets]);
    cSizeGlyphSets += aGlyphSets[cNumGlyphSets]->dwSize;
    cNumGlyphSets++;

	if (bVerbose && !bOptimize) printf("%%%%[End Create Unicode glyphset]%%%%\n\n");


    //////////////////////////////////////////////////////////////////////////
    //
    // Step 3: Write GLYPHSETDATA(s) and NTM(s) to a .NTF file.
    //
    //////////////////////////////////////////////////////////////////////////

	if (bVerbose) printf("%%%%[Begin Write NTF]%%%%\n\n");

    ulLength = strlen(argv[1 + nArgcOffset]) + 1;
    MULTIBYTETOUNICODE(
        wstrNTFFile,
        ulLength*sizeof(WCHAR),
        NULL,
        argv[1 + nArgcOffset],
        ulLength);

    if (!WriteNTF(wstrNTFFile,
                    cNumGlyphSets,
                    cSizeGlyphSets,
                    aGlyphSets,
                    cNumNTM,
                    cSizeNTM,
                    aPNTM
                    ))
    {
        ERR(("makentf: main - Can't write .NTF file\n"));
    }

	if (bVerbose) printf("%%%%[End Write NTF]%%%%\n\n");


    //////////////////////////////////////////////////////////////////////////
    //
    // Step 4: Clean up.
    //
    //////////////////////////////////////////////////////////////////////////
CLEAN_UP:
    for (i = 0; i < cNumNTM; i++)
    {
        MemFree(aPNTM[i]);
    }
    for (i = 0; i < cNumGlyphSets; i++)
    {
        MemFree(aGlyphSets[i]);
        if (aUniPsTbl[i] != NULL)
        {
            //
            // Could have a null ptr if this is a Pi Font.
            //
            MemFree(aUniPsTbl[i]);
        }
    }

    MemFree(aPNTM ? aPNTM : NULL);
    MemFree(aGlyphSets ? aGlyphSets : NULL);
    MemFree(pFamilyTbl ? pFamilyTbl : NULL);
    MemFree(UnicodetoPs ? UnicodetoPs : NULL);
    MemFree(aUniPsTbl ? aUniPsTbl : NULL);
    MemFree(aWinCodePages ? aWinCodePages : NULL);

	if (bVerbose) printf("%%%%[End MakeNTF]%%%%\n\n");
}


//
// Formating functions - copied from PScript\Output.c
//
INT
OPVsprintf(
    OUT LPSTR   buf,
    IN  LPCSTR  fmtstr,
    IN  va_list arglist
    )

/*++

Routine Description:

    Takes a pointer to an argument list, then formats and writes
    the given data to the memory pointed to by buffer.

Arguments:

    buf     Storage location for output
    fmtstr  Format specification
    arglist Pointer to list of arguments

Return Value:

    Return the number of characters written, not including
    the terminating null character, or a negative value if
    an output error occurs.

[Note:]

    This is NOT a full implementation of "vsprintf" as found
    in the C runtime library. Specifically, the only form of
    format specification allowed is %type, where "type" can
    be one of the following characters:

    d   INT     signed decimal integer
    l   LONG    signed decimal integer
    u   ULONG   unsigned decimal integer
    s   CHAR*   character string
    c   CHAR    character
    x,X DWORD   hex number (emits at least two digits, uppercase)
    b   BOOL    boolean (true or false)
    f   LONG    24.8 fixed-pointed number
    o   CHAR    octal number

--*/

{
    LPSTR   ptr = buf;

    ASSERT(buf && fmtstr);

    while (*fmtstr != NUL) {

        if (*fmtstr != '%') {

            // Normal character

            *ptr++ = *fmtstr++;

        } else {

            // Format specification

            switch (*++fmtstr) {

            case 'd':       // signed decimal integer

                _ltoa((LONG) va_arg(arglist, INT), ptr, 10);
                ptr += strlen(ptr);
                break;

            case 'l':       // signed decimal integer

                _ltoa(va_arg(arglist, LONG), ptr, 10);
                ptr += strlen(ptr);
                break;

            case 'u':       // unsigned decimal integer

                _ultoa(va_arg(arglist, ULONG), ptr, 10);
                ptr += strlen(ptr);
                break;

            case 's':       // character string

                {   LPSTR   s = va_arg(arglist, LPSTR);

                    while (*s)
                        *ptr++ = *s++;
                }
                break;

            case 'c':       // character

                *ptr++ = va_arg(arglist, CHAR);
                break;

            case 'x':
            case 'X':       // hexdecimal number

                {   ULONG   ul = va_arg(arglist, ULONG);
                    INT     ndigits = 8;

                    while (ndigits > 2 && ((ul >> (ndigits-1)*4) & 0xf) == 0)
                        ndigits--;

                    while (ndigits-- > 0)
                        *ptr++ = HexDigit(ul >> ndigits*4);
                }
                break;

            case 'o':

                {   CHAR    ch = va_arg(arglist, CHAR);

                    *ptr++ = (char)((ch & 0xC0) >> 6) + (char)'0';
                    *ptr++ = (char)((ch & 0x38) >> 3) + (char)'0';
                    *ptr++ = (char)(ch & 0x07) + (char)'0';
                }
                break;

            case 'b':       // boolean

                strcpy(ptr, (va_arg(arglist, BOOL)) ? "true" : "false");
                ptr += strlen(ptr);
                break;

            case 'f':       // 24.8 fixed-pointed number

                {
                    LONG    l = va_arg(arglist, LONG);
                    ULONG   ul, scale;

                    // sign character

                    if (l < 0) {
                        *ptr++ = '-';
                        ul = -l;
                    } else
                        ul = l;

                    // integer portion

                    _ultoa(ul >> 8, ptr, 10);
                    ptr += strlen(ptr);

                    // fraction

                    ul &= 0xff;
                    if (ul != 0) {

                        // We output a maximum of 3 digits after the
                        // decimal point, but we'll compute to the 5th
                        // decimal point and round it to 3rd.

                        ul = ((ul*100000 >> 8) + 50) / 100;
                        scale = 100;

                        *ptr++ = '.';

                        do {

                            *ptr++ = (CHAR) (ul/scale + '0');
                            ul %= scale;
                            scale /= 10;

                        } while (scale != 0 && ul != 0) ;
                    }
                }
                break;

            default:

                if (*fmtstr != NUL)
                    *ptr++ = *fmtstr;
                else {
                    ERR(("Invalid format specification\n"));
                    fmtstr--;
                }
                break;
            }

            // Skip the type characterr

            fmtstr++;
        }
    }

    *ptr = NUL;
    return (INT)(ptr - buf);
}



INT
OPSprintf(
    OUT LPSTR   buf,
    IN  LPCSTR  fmtstr,
    IN  ...
    )

{
    va_list arglist;
    INT     iRc;

    va_start(arglist, fmtstr);
    iRc = OPVsprintf(buf, fmtstr, arglist);
    va_end(arglist);

    return iRc;
}


int __cdecl compareWinCpt(const void *elem1, const void *elem2)
{
    PWINCPT  p1;
    PWINCPT  p2;

    p1 = (PWINCPT)elem1;
    p2 = (PWINCPT)elem2;

    if (p1->usWinCpt == p2->usWinCpt)
        return(0);
    else if (p1->usWinCpt < p2->usWinCpt)
        return(-1);
    else
        return(1);
}


VOID
SortWinCPT(
    IN OUT  WINCPT      *pSortedWinCpts,
    IN      WINCPTOPS   *pCPtoPS
)
{
    // pSortedWinCpts must point to a buffer big enough sizeof(WINCPT)* MAX_CSET_CHARS)

    memcpy(pSortedWinCpts, &(pCPtoPS->aWinCpts), sizeof(WINCPT)* MAX_CSET_CHARS);

    qsort(pSortedWinCpts, pCPtoPS->ulChCnt, sizeof(WINCPT), compareWinCpt);

}


//
// This function reads a list of CP to PS Name tables and writes an Text file
// with the corresponding PostScript Encoding arrays
// Need to run this whenever we changed the Mapping tables
//
// Format:
//          10        20        30        40
// 1234567890123456789012345678901234567890
//        CodePage = dddd (name)
// /name_up_to_32                   % XX
//

BOOL
WritePSEncodings(
    IN  PWSTR           pwszFileName,
    IN  WINCPTOPS       *CPtoPSList,
    IN  DWORD           dwPages
    )
{
    HANDLE              hFile;
    ULONG               i, j, k, l;
    WINCPTOPS           *pCPtoPS;
    WINCPT              sortedWinCpts[MAX_CSET_CHARS]; // maxiaml 255 chars
    char                buffer[256];
    DWORD               dwLen, ulByteWritten;


    hFile = CreateFile(pwszFileName, GENERIC_WRITE, FILE_SHARE_READ, NULL,
                          CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);

    if (hFile == INVALID_HANDLE_VALUE)
    {
        ERR(("WritePSEncodings:CreateFile\n"));
        return(FALSE);
    }


    for (i = 0; i < dwPages; i++)
    {
        pCPtoPS = CPtoPSList + i;

        dwLen = OPSprintf(buffer, "\n\n       CodePage = %d (%s)\n",
                pCPtoPS->usACP, pCPtoPS->pGSName);

        if (!WriteFile(hFile, buffer, dwLen, (LPDWORD)&ulByteWritten, (LPOVERLAPPED)NULL)
            || ulByteWritten != dwLen)
        {
            ERR(("WritePSEncodings:WriteFile\n"));
            CloseHandle(hFile);
            return(FALSE);
        }

        SortWinCPT(&(sortedWinCpts[0]), pCPtoPS);

        k = sortedWinCpts[0].usWinCpt;
        for (j = 0; j < pCPtoPS->ulChCnt; j++, k++)
        {
            while (k < sortedWinCpts[j].usWinCpt)
			{
            dwLen = OPSprintf(buffer, "                                 %% %X\n", k);
                if (!WriteFile(hFile, buffer, dwLen, (LPDWORD)&ulByteWritten, (LPOVERLAPPED)NULL)
                    || ulByteWritten != dwLen)
                {
                    ERR(("WritePSEncodings:WriteFile\n"));
                    CloseHandle(hFile);
                    return(FALSE);
                }
                k++;
			}

            dwLen = OPSprintf(buffer, "                                 %% %X\n", sortedWinCpts[j].usWinCpt);
			strncpy(buffer, "/", 1);
			l = strlen(sortedWinCpts[j].pPsName);
			strncpy(buffer + 1, sortedWinCpts[j].pPsName, l);
            if (!WriteFile(hFile, buffer, dwLen, (LPDWORD)&ulByteWritten, (LPOVERLAPPED)NULL)
                || ulByteWritten != dwLen)
            {
                ERR(("WritePSEncodings:WriteFile\n"));
                CloseHandle(hFile);
                return(FALSE);
            }
        }
    }

    CloseHandle(hFile);
    return(TRUE);
}


//
// This causes the error message to show up in your command window
// instead of the kernel debugger window.
//

ULONG _cdecl
DbgPrint(
    PCSTR    pstrFormat,
    ...
    )

{
    va_list ap;

    va_start(ap, pstrFormat);
    vprintf(pstrFormat, ap);
    va_end(ap);

    return 0;
}


VOID
DbgBreakPoint(
    VOID
    )

{
    exit(-1);
}


BOOL NeedBuildMoreNTM(
     PBYTE pAFM
     )
{
    PPSFAMILYINFO   pFamilyInfo;
    PSZ             pszFontName;

    pFamilyInfo = NULL;
    pszFontName = FindAFMToken(pAFM, PS_FONT_NAME_TOK);
    
    if (NULL ==pszFontName) return FALSE;

    pFamilyInfo = (PPSFAMILYINFO) bsearch(pszFontName,
                                    (PBYTE) (((PPSFAMILYINFO) (pFamilyTbl->pTbl))[0].pFontName),
                                    pFamilyTbl->usNumEntries,
                                    sizeof(PSFAMILYINFO),
                                    StrCmp);
    if (pFamilyInfo)
    {
        if (pFamilyInfo->usPitch != DEFAULT_PITCH)
            return TRUE;
        if (pFamilyInfo > ((PPSFAMILYINFO) (pFamilyTbl->pTbl)))
        {
            pFamilyInfo = pFamilyInfo - 1;
            if (!StrCmp(pFamilyInfo->pFontName, pszFontName) &&
                (pFamilyInfo->usPitch != DEFAULT_PITCH))
                return TRUE;
        }
        pFamilyInfo = pFamilyInfo + 1;
        if (pFamilyInfo < 
            (((PPSFAMILYINFO) (pFamilyTbl->pTbl)) + pFamilyTbl->usNumEntries))
        {
            pFamilyInfo = pFamilyInfo + 1;
            if (!StrCmp(pFamilyInfo->pFontName, pszFontName) &&
                (pFamilyInfo->usPitch != DEFAULT_PITCH))
                return TRUE;
        }
    }
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\tools\ps\pfbdump\pfbdump.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    pfbdump.c

Abstract:

    dump out PFB files as ASCII text
    
Revision History:

	12/30/96 -davidx-
		Created it.

--*/


#include <stdio.h>
#include <stdlib.h>
#include <windows.h>
#include <ctype.h>
#include <string.h>

char *progname;
char hexdigits[] = "0123456789ABCDEF";
PBYTE pOutputBuffer;

#define MAX_OUTPUT_SIZE 0x400000

PVOID
MapFileIntoMemory(
    PSTR    pFilename,
    PDWORD  pFileSize
    )

{
    HANDLE  hFile, hFileMap;
    PVOID   pData;

    // Open a handle to the specified file

    hFile = CreateFile(pFilename,
                       GENERIC_READ,
                       FILE_SHARE_READ,
                       NULL,
                       OPEN_EXISTING,
                       FILE_ATTRIBUTE_NORMAL,
                       NULL);

    if (hFile == INVALID_HANDLE_VALUE)
        return NULL;

    // Obtain the file size if requested

    if (pFileSize != NULL)
    {
        *pFileSize = GetFileSize(hFile, NULL);

        if (*pFileSize == 0xFFFFFFFF)
        {
            CloseHandle(hFile);
            return NULL;
        }
    }

    // Map the file into memory

    hFileMap = CreateFileMapping(hFile, NULL, PAGE_READONLY, 0, 0, NULL);

    if (hFileMap != NULL)
    {
        pData = MapViewOfFile(hFileMap, FILE_MAP_READ, 0, 0, 0);
        CloseHandle(hFileMap);
    }
    else
        pData = NULL;

    // We can safely close both the file mapping object and the file object itself.

    CloseHandle(hFile);

    return pData;
}

BOOL
WriteOutputData(
    PSTR    pFilename,
    PBYTE   pData,
    DWORD   size
    )

{
    HANDLE  hFile;

    // open a handle to the specified file

    hFile = CreateFile(pFilename,
                       GENERIC_WRITE,
                       0,
                       NULL,
                       CREATE_ALWAYS,
                       FILE_ATTRIBUTE_NORMAL,
                       NULL);

    if (hFile == INVALID_HANDLE_VALUE)
{ fprintf(stderr, "last error = %d\n", GetLastError());
        return FALSE;
}

    // write data to file

    if (WriteFile(hFile, pData, size, &size, NULL))
    {
        CloseHandle(hFile);
        return TRUE;
    }
    else
    {
        CloseHandle(hFile);
        DeleteFile(pFilename);
        return FALSE;
    }
}

BOOL
DecodePFBData(
    PBYTE   pInput,
    DWORD   inputSize,
    PBYTE   pOutput,
    PDWORD  pOutputSize
    )

{
    PBYTE   pin, pend, pout;

    pin = pInput;
    pend = pInput + inputSize;
    pout = pOutput;

    while (pin < pend)
    {
        INT     seglen, index;
        BYTE    segtype;

        // each segment must start with 0x80

        if ((pend - pin) < 2 || *pin++ != 128)
            return FALSE;

        // check segment type

        segtype = *pin++;
        if (segtype == 3)       // EOF segment
            break;

        if ((pend - pin) < 4)
            return FALSE;
        
        seglen = ((DWORD) pin[0]      ) |
                 ((DWORD) pin[1] <<  8) |
                 ((DWORD) pin[2] << 16) |
                 ((DWORD) pin[3] << 24);

        pin += 4;
        if ((pend - pin) < seglen)
            return FALSE;

        if (segtype == 1)       // ASCII segment
        {
            // copy input data to output and
            // convert CR to CR/LF combination

            while (seglen--)
            {
                if ((*pout++ = *pin++) == '\r')
                    *pout++ = '\n';
            }
        }
        else if (segtype == 2)  // binary segment
        {
            // copy binary data to hex

            for (index=1; index <= seglen; index++)
            {
                *pout++ = hexdigits[*pin >> 4];
                *pout++ = hexdigits[*pin & 15];
                pin++;

                if (index%32 == 0 || index == seglen)
                {
                    *pout++ = '\r';
                    *pout++ = '\n';
                }
            }
        }
        else
            return FALSE;
    }

    *pOutputSize = (pout - pOutput);
    return TRUE;
}

BOOL
PFBDump(
    PSTR    pFilename
    )

{
    BOOL    result = FALSE;
    PBYTE   pInputData = NULL;
    CHAR    outputFilenameBuffer[MAX_PATH];
    PSTR    p, pEnd;
    DWORD   inputDataSize, outputDataSize;

    // make sure the input filename ends with .pfb extension

    if ((p = strrchr(pFilename, '.')) == NULL || _stricmp(p, ".pfb") != 0)
    {
        fprintf(stderr,
                "%s: file '%s' ignored because it doesn't have .PFB extension\n",
                progname,
                pFilename);

        return FALSE;
    }

    // map the input file into memory

    if (! (pInputData = MapFileIntoMemory(pFilename, &inputDataSize)))
    {
        fprintf(stderr,
                "%s: couldn't open input file '%s'\n",
                progname,
                pFilename);

        return FALSE;
    }

    // decode PFB data

    if (! DecodePFBData(pInputData, inputDataSize, pOutputBuffer, &outputDataSize))
    {
        fprintf(stderr,
                "%s: file '%s' doesn't seem to contain valid PFB data\n",
                progname,
                pFilename);

        goto exitdump;
    }

    if (outputDataSize > MAX_OUTPUT_SIZE)
    {
        fprintf(stderr,
                "%s: choked on '%s' because the output file is too big\n",
                progname,
                pFilename);

        exit(-1);
    }

    // name the output file with /FontName information in the PFB file
    // is there something similar to strstr() for searching a memory block?

    p = pOutputBuffer;
    pEnd = p + outputDataSize;

    while (p < pEnd)
    {
        if ((*p++ == '/') &&
            (pEnd - p) >= 8 &&
            memcmp(p, "FontName", 8) == 0)
        {
            p += 8;

            while (p < pEnd && isspace(*p))
                p++;
            
            if (p < pEnd && *p++ == '/')
            {
                PSTR s;
                INT  len;

                for (s=p; s < pEnd && !isspace(*s); s++)
                    ;

                len = s - p;

                if (len > 0 && len < MAX_PATH)
                {
                    CopyMemory(outputFilenameBuffer, p, len);
                    outputFilenameBuffer[len] = '\0';
                    break;
                }
            }

            p = pEnd;
        }
    }

    if (p == pEnd)
    {
        fprintf(stderr,
                "%s: couldn't find FontName in PFB file '%s'\n",
                progname,
                pFilename);

        goto exitdump;
    }

    // write data to output file

    if (! (result = WriteOutputData(outputFilenameBuffer, pOutputBuffer, outputDataSize)))
    {
        fprintf(stderr,
                "%s: couldn't write to output file '%s'\n",
                progname,
                outputFilenameBuffer);
    }

exitdump:

    UnmapViewOfFile(pInputData);
    return result;
}

int _cdecl
main(
    int argc,
    char **argv
    )

{
    progname = *argv++;
    argc--;

    if (argc == 0)
    {
        fprintf(stderr, "usage: %s filename ...\n", progname);
        return -1;
    }

    if (! (pOutputBuffer = malloc(MAX_OUTPUT_SIZE)))
    {
        fprintf(stderr, "%s: not enough memory\n");
        return -1;
    }

    while (argc--)
        PFBDump(*argv++);

    free(pOutputBuffer);
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\tools\ps\ntfdump\ntfdump.c ===
/*++

Copyright (c) 1996-1997  Microsoft Corporation

Module Name:

    ntfdump.c

Abstract:

    UFM dump tool

Environment:

    Windows NT PostScript driver

Revision History:

    12/20/96 -eigos-
    Created it.

--*/

#include        "precomp.h"

//
// Macros
//

#define FILENAME_SIZE 256

//
// Globals
//

BYTE gcstrError1[] = "Usage:  ntfdump *.ufm\n";
BYTE gcstrError2[] = "Cannot open file \"%ws\".\n";

//
// Internal prototype
//

BOOL Bntfdump(IN PNTF_FILEHEADER);

int  __cdecl
main(
    IN int     argc,
    IN char  **argv)
/*++

Routine Description:

    main

Arguments:

    argc - Number of parameters in the following
    argv - The parameters, starting with our name

Return Value:

    Return error code 

Note:


--*/
{
    HFILEMAP          hUFMData;
    DWORD             dwUFMSize;
    WORD              wSize;
    WCHAR             awchFile[FILENAME_SIZE];
    PNTF_FILEHEADER   pNTF;

    //RIP(("Start ntfdump.exe\n"));

    if (argc != 2)
    {
        fprintf( stderr, gcstrError1);
        return  -1;
    }

    argv++;

    MultiByteToWideChar(CP_ACP,
                        0,
                        *argv,
                        strlen(*argv)+1,
                        awchFile,
                        FILENAME_SIZE);

    hUFMData = MapFileIntoMemory( awchFile,
                                  (PVOID)&pNTF,
                                  &dwUFMSize );

    if (!hUFMData)
    {
        fprintf( stderr, gcstrError2, *argv);
        return  -2;
    }

    Bntfdump(pNTF);

    UnmapFileFromMemory(hUFMData);

    return 0;
}


BOOL
Bntfdump(
    IN PNTF_FILEHEADER pNTF)
{
    PNTF_FONTMTXENTRY  pFM;
    PNTF_GLYPHSETENTRY pGL;
    PGLYPHSETDATA      pGlyph;

    DWORD dwFMCount, dwGLCount, dwI;

    pFM = (PNTF_FONTMTXENTRY)((PBYTE)pNTF + pNTF->dwFontMtxOffset);
    pGL = (PNTF_GLYPHSETENTRY)((PBYTE)pNTF + pNTF->dwGlyphSetOffset);

    dwFMCount = pNTF->dwFontMtxCount;
    dwGLCount = pNTF->dwGlyphSetCount;

    printf("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
    printf("   NTF DUMP\n");
    printf("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
    printf(" NTF_FILEHEADER\n");
    printf("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
    printf("dwSignature      = 0x%x\n", pNTF->dwSignature);
    printf("dwDriverType     = 0x%x\n", pNTF->dwDriverType);
    printf("dwVersion        = 0x%x\n", pNTF->dwVersion);
    printf("dwGlyphSetCount  = %d\n",   pNTF->dwGlyphSetCount);
    printf("dwGlyphSetOffset = 0x%x\n", pNTF->dwGlyphSetOffset);
    printf("dwFontMtxCount   = %d\n",   pNTF->dwFontMtxOffset);
    printf("dwFontMtxOffset  = 0x%x\n", pNTF->dwFontMtxOffset);

    printf("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
    printf(" NTF_FONTMTXENTRY\n");
    printf("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
    for (dwI = 0; dwI < dwFMCount; dwI ++, pFM++)
    {
        printf("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
        printf("dwFontNameOffset = 0x%x\n", pFM->dwFontNameOffset);
        printf("dwHashValue      = 0x%x\n", pFM->dwHashValue);
        printf("dwDataSize       = 0x%x\n", pFM->dwDataSize);
        printf("dwDataOffset     = 0x%x\n", pFM->dwDataOffset);
        printf("dwVersion        = 0x%x\n", pFM->dwVersion);

    }

    printf("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
    printf(" NTF_GLYPHSETENTRY\n");
    printf("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
    for (dwI = 0; dwI < dwGLCount; dwI ++, pGL++)
    {
        pGlyph = (PGLYPHSETDATA)((PBYTE) pNTF + pGL->dwDataOffset);
        printf("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
        printf("dwNameOffset     = 0x%x\n", pGL->dwNameOffset);
        printf("dwHashValue      = 0x%x\n", pGL->dwHashValue);
        printf("dwDataSize       = 0x%x\n", pGL->dwDataSize);
        printf("dwDataOffset     = 0x%x\n", pGL->dwDataOffset);
        printf("dwFlags          = 0x%x\n", pGL->dwFlags);
        printf("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
        printf("dwSize               = 0x%x\n", pGlyph->dwSize);
        printf("dwVersion            = 0x%x\n", pGlyph->dwVersion);
        printf("dwFlags              = 0x%x\n", pGlyph->dwFlags);
        printf("dwGlyphSetNameOffset = 0x%x\n", pGlyph->dwGlyphSetNameOffset);
        printf("dwGlyphCount         = 0x%x\n", pGlyph->dwGlyphCount);
        printf("dwRunCount           = 0x%x\n", pGlyph->dwRunCount);
        printf("dwRunOffset          = 0x%x\n", pGlyph->dwRunOffset);
        printf("dwCodePageCount      = 0x%x\n", pGlyph->dwCodePageCount);
        printf("dwCodePageOffset     = 0x%x\n", pGlyph->dwCodePageOffset);
        printf("dwMappingTableOffset = 0x%x\n", pGlyph->dwMappingTableOffset);

    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\tools\ps\ppdcheck\w_char.c ===
//
// Copyright (c) 1998 Microsoft Corporation
//
// This is just a wrapper file to allow a building the ppdcheck.exe
// in free builds without changes, since the output relies on the
// DBG define, which for ppdcheck is set in "sources"
//
#include "ppdchar.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\tools\ps\ppdcheck\w_csize.c ===
//
// Copyright (c) 1998 Microsoft Corporation
//
// This is just a wrapper file to allow a building the ppdcheck.exe
// in free builds without changes, since the output relies on the
// DBG define, which for ppdcheck is set in "sources"
//
#include "custsize.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\tools\ps\ppdcheck\pass2.cpp ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    pass2.cpp

Abstract:

    Functions for additional checking of a PPD file

Environment:

    PostScript driver, PPD parser

Revision History:

    09/15/98 -rorleth-
        Created it.

--*/

#include <lib.h>
#include <iostream.h>

#include "pass2.h"

enum FeatureId
{
    FID_PAGE_SIZE,
    FID_PAGE_REGION,
    FID_INPUT_SLOT,
    FID_SMOOTHING,
    FID_MEDIA_COLOR,
    FID_MEDIA_TYPE,
    FID_MEDIA_WEIGHT,
    FID_OUTPUT_MODE,
    FID_PAPER_DIMENSION,
    FID_IMAGE_AREA,
    FID_OUTPUT_ORDER,
    NO_OF_FEATURES
};

typedef struct _PPD_FEATURE
{
    FeatureId   eId;
    LPSTR       lpszName;
} PPD_FEATURE, *PPPD_FEATURE;

//
// features whose options we have to check
//

static PPD_FEATURE aCheckFeat[] =
{
    { FID_PAGE_SIZE,    "PageSize" },
    { FID_PAGE_REGION,  "PageRegion" },
    { FID_INPUT_SLOT,   "InputSlot" },
    { FID_SMOOTHING,    "Smoothing" },
    { FID_MEDIA_COLOR,  "MediaColor" },
    { FID_MEDIA_TYPE,   "MediaType" },
    { FID_MEDIA_WEIGHT, "MediaWeight" },
    { FID_OUTPUT_MODE,  "OutputMode" },
    { FID_PAPER_DIMENSION, "PaperDimension" },
    { FID_IMAGE_AREA,   "ImageableArea" },
    { FID_OUTPUT_ORDER, "OutputOrder" },
    { NO_OF_FEATURES, NULL}
};

typedef struct _PPD_OPTION
{
    FeatureId   eId;
    LPSTR       lpszName;
} PPD_OPTION, *PPPD_OPTION;

//
// keywords that require defined feature options
//
static PPD_OPTION gaCheckKeyword[] =
{
    { FID_INPUT_SLOT, "RequiresPageRegion"},
    { NO_OF_FEATURES, NULL }
};

//
// special option names
//
static PPD_OPTION gaSpecialOptions[] =
{
    { NO_OF_FEATURES,   "None" }, // NO_OF_FEATURES means valid for all features in that case
    { NO_OF_FEATURES,   "All" },
    { NO_OF_FEATURES,   "Unknown" },
    { FID_OUTPUT_ORDER, "Normal" }, // Normal and Reverse are predefined options for OutputOrder
    { FID_OUTPUT_ORDER, "Reverse" },
    { NO_OF_FEATURES, NULL},
};

//
//  keywords that have a length limitation for the UI
//
typedef struct _PPD_LENGTH_CHECK
{
    FeatureId   eId;
    size_t      iMaxLen;
} PPD_LENGTH_CHECK, *PPPD_LENGTH_CHECK;

static PPD_LENGTH_CHECK gaCheckLength[] =
{
    { FID_INPUT_SLOT, 23},
    { NO_OF_FEATURES, 0 }
};

const char *pDefaultKeyword = "Default";
const int MaxOptionNameLen = 40;
const int MaxTranslationNameLen = 128;

typedef struct _OPTION_LIST
{
    char        aName[MaxOptionNameLen+1];
    char        aTransName[MaxTranslationNameLen+1];
    _OPTION_LIST *pNext;
} OPTION_LIST, *POPTION_LIST;


static POPTION_LIST gaOptionList[NO_OF_FEATURES]; // stores all defined options


/*++

Routine Description:

    checks whether a references option is defined

Arguments:

    char        **ppString  : Pointer to pointer to option, is advanced by the option name length
    FeatureId   FeatId      : ID of the feature, which should have the option
    char        *pOptionName: pointer to buffer, where the option name shall be stored for error messages

Return Value:

    TRUE if the identified feature has that option, FALSE if not

--*/

static BOOL IsOptionDefined(char **ppString, FeatureId FeatId, char *pOptionName)
{
    char *pEndName, *pName = *ppString;

    while (isspace(*pName))
        pName++;

    pEndName = strpbrk(pName, "/: \t\n\r\0");

    *ppString = pEndName; // advance current pointer

    strncpy(pOptionName, pName, min((DWORD)(pEndName - pName), MaxOptionNameLen));
    pOptionName[pEndName-pName] = 0;

    //
    // check special cases that do not have to be defined
    //
    int i=0;

    while (gaSpecialOptions[i].lpszName != NULL)
    {
        if ((gaSpecialOptions[i].eId == NO_OF_FEATURES) ||
            (gaSpecialOptions[i].eId == FeatId))
        {
            if (!strcmp(gaSpecialOptions[i].lpszName, pOptionName))
                return TRUE;
        }
        i++;
    }

    POPTION_LIST pList = gaOptionList[FeatId], pNew;

    while (pList != NULL)
    {
        if (!strcmp(pList->aName, pOptionName))
            return TRUE;  // found it, it's defined

        pList = pList->pNext;
    }

    return FALSE;
}



/*++

Routine Description:

    checks a whole PPD-file, whether all referenced options are defined

Arguments:

      PTSTR FileName: Name of the PPD-file to check

--*/

extern "C" void CheckOptionIntegrity(PTSTR ptstrPpdFilename)
{

    ZeroMemory(gaOptionList, sizeof(gaOptionList)); // initialise the list header

    _flushall(); // to avoid sync problems with the DbgPrint output

    //
    // create the file mapping
    //
    HANDLE hFile = CreateFile(ptstrPpdFilename, GENERIC_READ, FILE_SHARE_READ,
                              NULL, OPEN_EXISTING,FILE_ATTRIBUTE_NORMAL, NULL);

    if (hFile == INVALID_HANDLE_VALUE)
    {
        return;
    }

    DWORD dwFileSize = GetFileSize(hFile, NULL);

    if (dwFileSize == 0xffffffff)
    {
        CloseHandle(hFile);
        return;
    }

    HANDLE hMap = CreateFileMapping(hFile, NULL, PAGE_READONLY,0, 0,NULL);

    if (hMap == NULL)
    {
        CloseHandle(hFile);
        return;
    }

    LPCVOID pView = MapViewOfFile(hMap, FILE_MAP_READ, 0,0,0);
    if (pView == NULL)
    {
        CloseHandle(hMap);
        CloseHandle(hFile);
        return;
    }

    //
    // copy the whole file into an allocated buffer just to get zero-termination
    //
    LPSTR  pFile, pFileStart;

    pFileStart = (LPSTR) VirtualAlloc(NULL, dwFileSize+1, MEM_COMMIT, PAGE_READWRITE);

    if (pFileStart != NULL)
    {
        CopyMemory(pFileStart, pView, dwFileSize);
        *(pFileStart + dwFileSize) = 0;
    }

    UnmapViewOfFile(pView);
    CloseHandle(hMap);
    CloseHandle(hFile);

    if (pFileStart == NULL)
    {
        cout << "ppdcheck.exe out of memory" << endl;
        return;
    }

    pFile = pFileStart;

    //
    // now the whole PPD-file is a giant string
    // extract all the features/options
    //
    char *pCurOption = (char *) pFileStart;
    char OptionName[MaxOptionNameLen+1];


    //
    // step 1 : extract all valid feature options
    //
    while ((pFile != NULL) &&
           (pCurOption = strchr(pFile, '*')) != NULL)
    {
        pCurOption++;

        char *pNextLine = strpbrk(pCurOption, "\n\r");
        pFile = pNextLine;

        if (*pCurOption == '%') // skip comments
            continue;

        //
        // scan whether this is one of the features to look for
        //
        int Index = 0;

        while (aCheckFeat[Index].eId != NO_OF_FEATURES)
        {
            if (strncmp(aCheckFeat[Index].lpszName, pCurOption, strlen(aCheckFeat[Index].lpszName)))
            {
                Index++;
                continue;
            }

            //
            // this is one of the monitored features: make entry in list
            //
            POPTION_LIST pList = gaOptionList[aCheckFeat[Index].eId], pNew;

            pNew = new OPTION_LIST;

            pNew->pNext = gaOptionList[aCheckFeat[Index].eId];
            gaOptionList[aCheckFeat[Index].eId] = pNew;

            char *pName = pCurOption + strlen(aCheckFeat[Index].lpszName), *pEndName;

            while (isspace(*pName))
                pName++;

            pEndName = strpbrk(pName, "/: \0");

            DWORD dwNameLen = min((DWORD)(pEndName - pName), MaxOptionNameLen);
            strncpy(pNew->aName, pName, dwNameLen);
            pNew->aName[dwNameLen] = 0;

            dwNameLen = 0;

            if (*pEndName == '/') // there is a translation string
            {
                pName = pEndName +1;
                pEndName = strpbrk(pName, ":\n\r\0");

                dwNameLen = min((DWORD) (pEndName - pName), MaxTranslationNameLen);
                strncpy(pNew->aTransName, pName, dwNameLen);
            }
            pNew->aTransName[dwNameLen] = 0;
            break;
        }

    }

    //
    // step 2: check whether all referenced options are featured
    //
    pFile = pFileStart;
    pCurOption = (char *) pFile;

    while ((pFile != NULL) &&
           (pCurOption = strchr(pFile, '*')) != NULL)
    {
        pCurOption++;

        char *pNextLine = strpbrk(pCurOption, "\n\r");
        pFile = pNextLine;

        //
        // skip comments
        //
        if (*pCurOption == '%')
            continue;

        //
        // check whether it starts with "Default", if yes, check that feature option
        //
        if (!strncmp(pDefaultKeyword, pCurOption, strlen(pDefaultKeyword)))
        {
            pCurOption += strlen(pDefaultKeyword);

            int Index = 0;

            while (aCheckFeat[Index].eId != NO_OF_FEATURES)
            {
                if (strncmp(aCheckFeat[Index].lpszName, pCurOption, strlen(aCheckFeat[Index].lpszName)))
                {
                    Index++;
                    continue;
                }

                //
                // it's one of the checked featurs
                //
                pCurOption += strlen(aCheckFeat[Index].lpszName);

                char *pOption = strpbrk(pCurOption, ":");

                if (pOption == NULL)
                {
                    cout << "Warning: default option for '" << aCheckFeat[Index].lpszName << "' is not completed !" << endl;
                    break;
                }
                pCurOption = pOption + 1;

                if (!IsOptionDefined(&pCurOption, aCheckFeat[Index].eId, OptionName))
                    cout << "Warning: default option '" << OptionName << "' for feature '*" << aCheckFeat[Index].lpszName <<"' is not defined!" << endl;
                break;
            }
        }
        else
        {
            //
            // scan whether this is one of the keywords to look for
            //
            int Index = 0;

            while (gaCheckKeyword[Index].eId != NO_OF_FEATURES)
            {
                if (strncmp(gaCheckKeyword[Index].lpszName, pCurOption, strlen(gaCheckKeyword[Index].lpszName)))
                {
                    Index++;
                    continue;
                }

                //
                // this is one of the monitored features: get the option it references
                //
                pCurOption += strlen(gaCheckKeyword[Index].lpszName);

                if (!IsOptionDefined(&pCurOption, gaCheckKeyword[Index].eId, OptionName))
                    cout << "Warning: option '" << OptionName << "' for keyword '*" << gaCheckKeyword[Index].lpszName <<"' is not defined!" << endl;
                break;
            }
            Index++;
        }
    }

    //
    // step 3: check that all option names are different and don't have trailing or leading spaces
    //
    for (int i = 0; i < NO_OF_FEATURES;i++)
    {
        POPTION_LIST pCheck = gaOptionList[i], pCur;

        while (pCheck != NULL)
        {
            pCur = pCheck->pNext;

            while (pCur != NULL)
            {
                if (strlen(pCheck->aName) &&
                    !strcmp(pCheck->aName, pCur->aName))
                    cout << "Warning: option name '" << pCheck->aName << "' used twice" << endl;
                if (strlen(pCheck->aTransName) &&
                    !strcmp(pCheck->aTransName, pCur->aTransName))
                    cout << "Warning: translation name '" << pCheck->aTransName << "' used twice" << endl;

                pCur = pCur->pNext;
            }
            size_t TransNameLen = strlen(pCheck->aTransName);

            if (isspace(pCheck->aTransName[0]))
                cout << "Warning: translation name '" << pCheck->aTransName << "' has leading whitespace" << endl;
            if ((TransNameLen > 1) &&
                isspace(pCheck->aTransName[TransNameLen-1]))
                cout << "Warning: translation name '" << pCheck->aTransName << "' has trailing whitespace" << endl;

            pCheck = pCheck->pNext;
        }
    }

    //
    // step 4: warn if the string that is used for the display is too long
    //
    i = 0;
    while (gaCheckLength[i].eId != NO_OF_FEATURES)
    {
        POPTION_LIST pCheck = gaOptionList[gaCheckLength[i].eId], pCur;
        while (pCheck != NULL)
        {
            size_t TransNameLen = strlen(pCheck->aTransName);

            if (TransNameLen > gaCheckLength[i].iMaxLen)
                cout << "Warning: translation name '" << pCheck->aTransName << "' will be truncated to "<< (unsigned int) gaCheckLength[i].iMaxLen << " characters"<< endl;
            else if ((TransNameLen == 0) && (strlen(pCheck->aName) > gaCheckLength[i].iMaxLen))
                cout << "Warning: option name '" << pCheck->aName << "' will be truncated to "<< (unsigned int) gaCheckLength[i].iMaxLen << " characters"<< endl;

            pCheck = pCheck->pNext;
        }
        i++;
    }


    //
    // clean up
    //
    for (i = 0; i < NO_OF_FEATURES;i++)
    {
        POPTION_LIST pTmp = gaOptionList[i], pCur;

        while (pTmp != NULL)
        {
            pCur = pTmp->pNext;
            delete pTmp;
            pTmp = pCur;
        }
        gaOptionList[i] = NULL;
    }

    _flushall(); // to avoid sync problems with the DbgPrint output

    VirtualFree((LPVOID) pFileStart, 0, MEM_RELEASE);
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\tools\ps\ppdcheck\w_kwd.c ===
//
// Copyright (c) 1998 Microsoft Corporation
//
// This is just a wrapper file to allow a building the ppdcheck.exe
// in free builds without changes, since the output relies on the
// DBG define, which for ppdcheck is set in "sources"
//
#include "ppdkwd.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\tools\ps\ppdcheck\pass2.h ===
/*++

Copyright (c) 1996-1998  Microsoft Corporation

Module Name:

    pass2.h

Abstract:

    checks whether all referenced options in a file are actually defined

--*/

#ifndef _PASS2_H_
#define _PASS2_H_

#ifdef __cplusplus

extern "C" {

#endif

void CheckOptionIntegrity(PTSTR ptstrPpdFilename);

#ifdef __cplusplus

}

#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\tools\ps\ppdcheck\w_parse.c ===
//
// Copyright (c) 1998 Microsoft Corporation
//
// This is just a wrapper file to allow a building the ppdcheck.exe
// in free builds without changes, since the output relies on the
// DBG define, which for ppdcheck is set in "sources"
//
#include "ppdparse.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\tools\ps\ppdcheck\w_entry.c ===
//
// Copyright (c) 1998 Microsoft Corporation
//
// This is just a wrapper file to allow a building the ppdcheck.exe
// in free builds without changes, since the output relies on the
// DBG define, which for ppdcheck is set in "sources"
//
#include "ppdentry.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\tools\ps\ppdcheck\ppdcheck.c ===
/*++

Copyright (c) 1996-1997  Microsoft Corporation

Module Name:

    ppdcheck.c

Abstract:

    PPD parser test program

Environment:

    PostScript driver, PPD parser, Check build only

Revision History:

    09/17/96 -davidx-
        Implement PpdDump.

    03/27/96 -davidx-
        Created it.

--*/

#include "lib.h"
#include "ppd.h"

#include "pass2.h"


INT giDebugLevel;


HINSTANCE       ghInstance;
PSTR            gstrProgName;
PRAWBINARYDATA  gpRawData;
PINFOHEADER     gpInfoHdr;
PUIINFO         gpUIInfo;
PPPDDATA        gpPpdData;
DWORD           gdwTotalSize, gdwNumFiles, gdwMaxFileSize;

extern const CHAR gstrFalseKwd[];
extern const CHAR gstrNoneKwd[];

#define DumpInt(label, n)       DbgPrint("%s: %d\n", label, n)
#define DumpHex(label, n)       DbgPrint("%s: 0x%x\n", label, n)
#define DumpStrW(label, offset) DbgPrint("%s: %ws\n", label, OFFSET_TO_POINTER(gpRawData, offset))
#define DumpStrA(label, offset) DbgPrint("%s: %s\n", label, OFFSET_TO_POINTER(gpRawData, offset))
#define DumpFix(label, n)       DbgPrint("%s: %f\n", label, (FLOAT) (n) / FIX_24_8_SCALE)
#define DumpInvo(label, p)      DbgPrint("%s: %d bytes\n", label, (p)->dwCount)
#define DumpSize(label, p)      DbgPrint("%s: %d x %d\n", label, (p)->cx, (p)->cy)
#define DumpRect(label, p)      DbgPrint("%s: (%d, %d) - (%d, %d)\n", label, \
                                         (p)->left, (p)->top, (p)->right, (p)->bottom)




VOID
PpdDump(
    VOID
    )

{
    DWORD           index, dwFeatures;
    PFEATURE        pFeature;
    POPTION         pOption;
    LPTSTR          ptstrTable;
    PUICONSTRAINT   pUIConstraint;
    PORDERDEPEND    pOrderDep;
    PFILEDATEINFO   pFileDateInfo;

    DbgPrint("\nRAWBINARYDATA:\n");
    DumpInt ("  dwFileSize", gpRawData->dwFileSize);
    DumpHex ("  dwParserSignature", gpRawData->dwParserSignature);
    DumpHex ("  dwParserVersion", gpRawData->dwParserVersion);
    DumpHex ("  dwChecksum32", gpRawData->dwChecksum32);
    DumpInt ("  dwDocumentFeatures", gpRawData->dwDocumentFeatures);
    DumpInt ("  dwPrinterFeatures", gpRawData->dwPrinterFeatures);
    DumpInt ("  Source PPD files", gpRawData->FileDateInfo.dwCount);

    pFileDateInfo = OFFSET_TO_POINTER(gpRawData, gpRawData->FileDateInfo.loOffset);

    ASSERT(gpRawData->FileDateInfo.dwCount == 0 || pFileDateInfo != NULL);

    for (index=0; index < gpRawData->FileDateInfo.dwCount; index++, pFileDateInfo++)
    {
        FILETIME    FileTime;
        SYSTEMTIME  SystemTime;
        TCHAR       TimeDateString[64];

        DumpStrW("    loFileName", pFileDateInfo->loFileName);

        FileTimeToLocalFileTime(&pFileDateInfo->FileTime, &FileTime);
        FileTimeToSystemTime(&FileTime, &SystemTime);

        GetDateFormat(LOCALE_USER_DEFAULT, 0, &SystemTime, NULL, TimeDateString, 64);
        DbgPrint("    FileTime: %ws ", TimeDateString);

        GetTimeFormat(LOCALE_USER_DEFAULT, 0, &SystemTime, NULL, TimeDateString, 64);
        DbgPrint("%ws\n", TimeDateString);
    }

    DbgPrint("\nUIINFO:\n");
    DumpInt ("  dwSize", gpUIInfo->dwSize);
    DumpStrW("  loNickName", gpUIInfo->loNickName);
    DumpHex ("  dwSpecVersion", gpUIInfo->dwSpecVersion);
    DumpHex ("  dwTechnology", gpUIInfo->dwTechnology);
    DumpInt ("  dwDocumentFeatures", gpUIInfo->dwDocumentFeatures);
    DumpInt ("  dwPrinterFeatures", gpUIInfo->dwPrinterFeatures);
    DumpInt ("  UIConstraints.dwCount", gpUIInfo->UIConstraints.dwCount);
    DumpInt ("  dwMaxCopies", gpUIInfo->dwMaxCopies);
    DumpInt ("  dwMinScale", gpUIInfo->dwMinScale);
    DumpInt ("  dwMaxScale", gpUIInfo->dwMaxScale);
    DumpInt ("  dwLangEncoding", gpUIInfo->dwLangEncoding);
    DumpInt ("  dwLangLevel", gpUIInfo->dwLangLevel);

    if (gpUIInfo->dwLangLevel >= 2 && gpPpdData->dwPSVersion < 2000)
        DbgPrint("  *** Level 2 clone\n");

    DumpInvo("  Password", &gpUIInfo->Password);
    DumpInvo("  ExitServer", &gpUIInfo->ExitServer);
    DumpHex ("  dwProtocols", gpUIInfo->dwProtocols);
    DumpInt ("  dwJobTimeout", gpUIInfo->dwJobTimeout);
    DumpInt ("  dwWaitTimeout", gpUIInfo->dwWaitTimeout);
    DumpInt ("  dwTTRasterizer", gpUIInfo->dwTTRasterizer);
    DumpInt ("  dwFreeMem", gpUIInfo->dwFreeMem);
    DumpInt ("  dwPrintRate", gpUIInfo->dwPrintRate);
    DumpInt ("  dwPrintRateUnit", gpUIInfo->dwPrintRateUnit);
    DumpFix ("  fxScreenAngle", gpUIInfo->fxScreenAngle);
    DumpFix ("  fxScreenFreq", gpUIInfo->fxScreenFreq);
    DumpHex ("  dwFlags", gpUIInfo->dwFlags);
    DumpInt ("  dwCustomSizeOptIndex", gpUIInfo->dwCustomSizeOptIndex);
    DumpInt ("  ptMasterUnits.x", gpUIInfo->ptMasterUnits.x);
    DumpInt ("  ptMasterUnits.y", gpUIInfo->ptMasterUnits.y);

    dwFeatures = gpUIInfo->dwDocumentFeatures + gpUIInfo->dwPrinterFeatures;
    pFeature = OFFSET_TO_POINTER(gpRawData, gpUIInfo->loFeatureList);
    pUIConstraint = OFFSET_TO_POINTER(gpRawData, gpUIInfo->UIConstraints.loOffset);

    DbgPrint("\n  FEATURES: count = %d\n", dwFeatures);

    for (index = 0; index < dwFeatures; index++, pFeature++)
    {
        DWORD       dwConstIndex, dwFeatureIndex, dwOptionIndex, dwOptionCount;
        PFEATURE    pConstFeature;
        POPTION     pConstOption;

        DumpStrA("\n  loKeywordName", pFeature->loKeywordName);
        DumpStrW("    loDisplayName", pFeature->loDisplayName);
        DumpHex ("    dwFlags", pFeature->dwFlags);
        DumpInt ("    dwDefaultOptIndex", pFeature->dwDefaultOptIndex);
        DumpInt ("    dwNoneFalseOptIndex", pFeature->dwNoneFalseOptIndex);
        DumpInt ("    dwFeatureID", pFeature->dwFeatureID);
        DumpInt ("    dwUIType", pFeature->dwUIType);
        DumpInt ("    dwPriority", pFeature->dwPriority);
        DumpInt ("    dwFeatureType", pFeature->dwFeatureType);
        DumpInt ("    dwOptionSize", pFeature->dwOptionSize);

        if (dwOptionCount = pFeature->Options.dwCount)
        {
            pOption = OFFSET_TO_POINTER(gpRawData, pFeature->Options.loOffset);
            DbgPrint("\n    OPTIONS: count = %d\n", dwOptionCount);

            while (dwOptionCount--)
            {
                DumpStrA("\n    loKeywordName", pOption->loKeywordName);
                DumpStrW("      loDisplayName", pOption->loDisplayName);
                DumpInvo("      Invocation", &pOption->Invocation);

                switch (pFeature->dwFeatureID)
                {
                case GID_PAGESIZE:

                    {   PPAGESIZE   pPaper = (PPAGESIZE) pOption;

                        DumpSize("      szPaperSize", &pPaper->szPaperSize);
                        DumpRect("      rcImgArea", &pPaper->rcImgArea);
                        DumpInt ("      dwPaperSizeID", pPaper->dwPaperSizeID);
                        DumpHex ("      dwFlags", pPaper->dwFlags);
                    }
                    break;

                case GID_RESOLUTION:

                    {   PRESOLUTION pRes = (PRESOLUTION) pOption;

                        DumpInt ("      iXdpi", pRes->iXdpi);
                        DumpInt ("      iYdpi", pRes->iYdpi);
                        DumpFix ("      fxScreenAngle", pRes->fxScreenAngle);
                        DumpFix ("      fxScreenFreq", pRes->fxScreenFreq);
                    }
                    break;

                case GID_DUPLEX:

                    DumpInt ("      dwDuplexID", ((PDUPLEX) pOption)->dwDuplexID);
                    break;

                case GID_COLLATE:

                    DumpInt ("      dwCollateID", ((PCOLLATE) pOption)->dwCollateID);
                    break;

                case GID_MEDIATYPE:

                    DumpInt ("      dwMediaTypeID", ((PMEDIATYPE) pOption)->dwMediaTypeID);
                    break;

                case GID_OUTPUTBIN:

                    DumpInt ("      bOutputOrderReversed", ((POUTPUTBIN) pOption)->bOutputOrderReversed);
                    break;

                case GID_INPUTSLOT:

                    {   PINPUTSLOT  pTray = (PINPUTSLOT) pOption;

                        DumpHex ("      dwFlags", pTray->dwFlags);
                        DumpInt ("      dwPaperSourceID", pTray->dwPaperSourceID);
                    }
                    break;

                case GID_MEMOPTION:

                    {   PMEMOPTION  pMemOption = (PMEMOPTION) pOption;

                        DumpInt ("      dwInstalledMem", pMemOption->dwInstalledMem);
                        DumpInt ("      dwFreeMem", pMemOption->dwFreeMem);
                        DumpInt ("      dwFreeFontMem", pMemOption->dwFreeFontMem);
                    }
                    break;
                }

                if ((dwConstIndex = pOption->dwUIConstraintList) != NULL_CONSTRAINT)
                {
                    ASSERT(pUIConstraint != NULL);
                    DbgPrint("\n      UICONSTRAINTS:\n");

                    while (dwConstIndex != NULL_CONSTRAINT)
                    {
                        ASSERT(dwConstIndex < gpUIInfo->UIConstraints.dwCount);

                        dwFeatureIndex = pUIConstraint[dwConstIndex].dwFeatureIndex;
                        dwOptionIndex = pUIConstraint[dwConstIndex].dwOptionIndex;
                        dwConstIndex = pUIConstraint[dwConstIndex].dwNextConstraint;

                        ASSERT(dwFeatureIndex < dwFeatures);
                        pConstFeature = PGetIndexedFeature(gpUIInfo, dwFeatureIndex);
                        DbgPrint("        %s", OFFSET_TO_POINTER(gpRawData, pConstFeature->loKeywordName));

                        if (dwOptionIndex != OPTION_INDEX_ANY)
                        {
                            ASSERT(dwOptionIndex < pConstFeature->Options.dwCount);
                            pConstOption = PGetIndexedOption(gpUIInfo, pConstFeature, dwOptionIndex);
                            DbgPrint(" %s", OFFSET_TO_POINTER(gpRawData, pConstOption->loKeywordName));
                        }

                        DbgPrint("\n");
                    }
                }

                pOption = (POPTION) ((PBYTE) pOption + pFeature->dwOptionSize);
            }
        }

        if ((dwConstIndex = pFeature->dwUIConstraintList) != NULL_CONSTRAINT)
        {
            ASSERT(pUIConstraint != NULL);
            DbgPrint("\n    UICONSTRAINTS:\n");

            while (dwConstIndex != NULL_CONSTRAINT)
            {
                ASSERT(dwConstIndex < gpUIInfo->UIConstraints.dwCount);

                dwFeatureIndex = pUIConstraint[dwConstIndex].dwFeatureIndex;
                dwOptionIndex = pUIConstraint[dwConstIndex].dwOptionIndex;
                dwConstIndex = pUIConstraint[dwConstIndex].dwNextConstraint;

                ASSERT(dwFeatureIndex < dwFeatures);
                pConstFeature = PGetIndexedFeature(gpUIInfo, dwFeatureIndex);
                DbgPrint("      %s", OFFSET_TO_POINTER(gpRawData, pConstFeature->loKeywordName));

                if (dwOptionIndex != OPTION_INDEX_ANY)
                {
                    ASSERT(dwOptionIndex < pConstFeature->Options.dwCount);
                    pConstOption = PGetIndexedOption(gpUIInfo, pConstFeature, dwOptionIndex);

                    DbgPrint(" %s", OFFSET_TO_POINTER(gpRawData, pConstOption->loKeywordName));
                }

                DbgPrint("\n");
            }
        }
    }

    DbgPrint("\n  PREDEFINED FEATURES:\n");

    for (index = 0; index < MAX_GID; index++)
    {
        if (pFeature = GET_PREDEFINED_FEATURE(gpUIInfo, index))
            DbgPrint("    %s\n", OFFSET_TO_POINTER(gpRawData, pFeature->loKeywordName));
    }

    DbgPrint("\n  DEFAULT FONT SUBSTITUTION TABLE: %d bytes\n", gpUIInfo->dwFontSubCount);

    ptstrTable = OFFSET_TO_POINTER(gpRawData, gpUIInfo->loFontSubstTable);

    if (ptstrTable) {

        while (*ptstrTable) {

            DbgPrint("    %ws => ", ptstrTable);
            ptstrTable += _tcslen(ptstrTable) + 1;
            DbgPrint("%ws\n", ptstrTable);
            ptstrTable += _tcslen(ptstrTable) + 1;
        }
    }

    DbgPrint("\nPPDDATA:\n");

    #ifndef WINNT_40
    DumpHex ("  GetUserDefaultUILanguage() returns", GetUserDefaultUILanguage());
    #endif

    DumpHex ("  dwUserDefUILangID", gpPpdData->dwUserDefUILangID);
    DumpHex ("  dwPpdFilever", gpPpdData->dwPpdFilever);
    DumpHex ("  dwFlags", gpPpdData->dwFlags);
    DumpHex ("  dwExtensions", gpPpdData->dwExtensions);
    DumpInt ("  dwSetResType", gpPpdData->dwSetResType);
    DumpInt ("  dwPSVersion", gpPpdData->dwPSVersion);
    DumpInvo("  PSVersion", &gpPpdData->PSVersion);
    DumpInvo("  Product", &gpPpdData->Product);

    DumpHex ("  dwOutputOrderIndex", gpPpdData->dwOutputOrderIndex);
    DumpHex ("  dwCustomSizeFlags", gpPpdData->dwCustomSizeFlags);
    DumpInt ("  dwLeadingEdgeLong", gpPpdData->dwLeadingEdgeLong);
    DumpInt ("  dwLeadingEdgeShort", gpPpdData->dwLeadingEdgeShort);
    DumpInt ("  dwUseHWMarginsTrue", gpPpdData->dwUseHWMarginsTrue);
    DumpInt ("  dwUseHWMarginsFalse", gpPpdData->dwUseHWMarginsFalse);

    for (index = 0; index < CUSTOMPARAM_MAX; index++)
    {
        DbgPrint("    param %d: dwOrder = %d, lMinVal = %d, lMaxVal = %d\n", index,
                 gpPpdData->CustomSizeParams[index].dwOrder,
                 gpPpdData->CustomSizeParams[index].lMinVal,
                 gpPpdData->CustomSizeParams[index].lMaxVal);
    }

    DumpInvo("  PatchFile", &gpPpdData->PatchFile);
    DumpInvo("  JclBegin", &gpPpdData->JclBegin);
    DumpInvo("  JclEnterPS", &gpPpdData->JclEnterPS);
    DumpInvo("  JclEnd", &gpPpdData->JclEnd);
    DumpInvo("  ManualFeedFalse", &gpPpdData->ManualFeedFalse);

    DumpHex ("  dwNt4Checksum", gpPpdData->dwNt4Checksum);
    DumpInt ("  dwNt4DocFeatures", gpPpdData->dwNt4DocFeatures);
    DumpInt ("  dwNt4PrnFeatures", gpPpdData->dwNt4PrnFeatures);

    if (gpPpdData->Nt4Mapping.dwCount)
    {
        PBYTE   pubNt4Mapping;

        pubNt4Mapping = OFFSET_TO_POINTER(gpRawData, gpPpdData->Nt4Mapping.loOffset);

        ASSERT(pubNt4Mapping != NULL);

        for (index=0; index < gpPpdData->Nt4Mapping.dwCount; index++)
            DbgPrint("    %2d => %d\n", index, pubNt4Mapping[index]);
    }

    if (gpPpdData->DeviceFonts.dwCount)
    {
        PDEVFONT    pDevFont;

        DbgPrint("\n  DEVICE FONTS:\n");

        if (pDevFont = OFFSET_TO_POINTER(gpRawData, gpPpdData->loDefaultFont))
            DumpStrA("    default", pDevFont->loFontName);

        pDevFont = OFFSET_TO_POINTER(gpRawData, gpPpdData->DeviceFonts.loOffset);

        for (index = 0; index < gpPpdData->DeviceFonts.dwCount; index++, pDevFont++)
        {
            DumpStrA("\n    loFontName", pDevFont->loFontName);
            DumpStrW("      loDisplayName", pDevFont->loDisplayName);
            DumpStrA("      loEncoding", pDevFont->loEncoding);
            DumpStrA("      loCharset", pDevFont->loCharset);
            DumpStrA("      loVersion", pDevFont->loVersion);
            DumpInt ("      dwStatus", pDevFont->dwStatus);
        }
    }

    if (gpPpdData->OrderDeps.dwCount)
    {
        pOrderDep = OFFSET_TO_POINTER(gpRawData, gpPpdData->OrderDeps.loOffset);
        ASSERT(pOrderDep != NULL);

        DbgPrint("\n  ORDER DEPENDENCIES:\n");

        for (index=0; index < gpPpdData->OrderDeps.dwCount; index++, pOrderDep++)
        {
            DbgPrint("    %d: order = %d section = 0x%x (in PPD: 0x%x) ",
                     index, pOrderDep->lOrder, pOrderDep->dwSection, pOrderDep->dwPPDSection);

            pFeature = PGetIndexedFeature(gpUIInfo, pOrderDep->dwFeatureIndex);
            ASSERT(pFeature != NULL);
            DbgPrint("%s", OFFSET_TO_POINTER(gpRawData, pFeature->loKeywordName));

            if (pOrderDep->dwOptionIndex != OPTION_INDEX_ANY)
            {
                pOption = PGetIndexedOption(gpUIInfo, pFeature, pOrderDep->dwOptionIndex);
                ASSERT(pOption != NULL);
                DbgPrint(" %s", OFFSET_TO_POINTER(gpRawData, pOption->loKeywordName));
            }

            DbgPrint(", next = %d\n", pOrderDep->dwNextOrderDep);
        }
    }

    if (gpPpdData->QueryOrderDeps.dwCount)
    {
        pOrderDep = OFFSET_TO_POINTER(gpRawData, gpPpdData->QueryOrderDeps.loOffset);
        ASSERT(pOrderDep != NULL);

        DbgPrint("\n  QUERY ORDER DEPENDENCIES:\n");

        for (index=0; index < gpPpdData->QueryOrderDeps.dwCount; index++, pOrderDep++)
        {
            DbgPrint("    %d: order = %d section = 0x%x (in PPD: 0x%x) ",
                     index, pOrderDep->lOrder, pOrderDep->dwSection, pOrderDep->dwPPDSection);

            pFeature = PGetIndexedFeature(gpUIInfo, pOrderDep->dwFeatureIndex);
            ASSERT(pFeature != NULL);
            DbgPrint("%s", OFFSET_TO_POINTER(gpRawData, pFeature->loKeywordName));

            if (pOrderDep->dwOptionIndex != OPTION_INDEX_ANY)
            {
                pOption = PGetIndexedOption(gpUIInfo, pFeature, pOrderDep->dwOptionIndex);
                ASSERT(pOption != NULL);
                DbgPrint(" %s", OFFSET_TO_POINTER(gpRawData, pOption->loKeywordName));
            }

            DbgPrint(", next = %d\n", pOrderDep->dwNextOrderDep);
        }
    }

    if (gpPpdData->JobPatchFiles.dwCount)
    {
        PJOBPATCHFILE pJobPatchFiles;

        pJobPatchFiles = OFFSET_TO_POINTER(gpRawData, gpPpdData->JobPatchFiles.loOffset);
        ASSERT(pJobPatchFiles);

        DbgPrint("\n  JOB PATCH FILES:\n");

        for (index = 0; index < gpPpdData->JobPatchFiles.dwCount; index++, pJobPatchFiles++)
        {
            DbgPrint("    %2d No %li", index, pJobPatchFiles->lJobPatchNo);
            DbgPrint(": '%s'\n", OFFSET_TO_POINTER(gpRawData, pJobPatchFiles->loOffset));
        }
    }
}



VOID
DumpNt4Mapping(
    VOID
    )

{
    PFEATURE    pFeatures;
    PBYTE       pubNt4Mapping;
    DWORD       iNt4, iNt5, cNt4, cNt5;
    PSTR        pName;

    DbgPrint("checksum: 0x%x\n", gpPpdData->dwNt4Checksum);
    DbgPrint("number of doc-sticky features: %d\n", gpPpdData->dwNt4DocFeatures);
    DbgPrint("number of printer-sticky features: %d\n", gpPpdData->dwNt4PrnFeatures);

    pubNt4Mapping = OFFSET_TO_POINTER(gpRawData, gpPpdData->Nt4Mapping.loOffset);
    pFeatures = OFFSET_TO_POINTER(gpRawData, gpUIInfo->loFeatureList);

    ASSERT(pubNt4Mapping != NULL);

    cNt4 = gpPpdData->dwNt4DocFeatures + gpPpdData->dwNt4PrnFeatures;
    cNt5 = gpPpdData->Nt4Mapping.dwCount;

    ASSERT(cNt5 == 0 || pFeatures != NULL);

    for (iNt4=0; iNt4 < cNt4; iNt4++)
    {
        for (iNt5=0; iNt5 < cNt5; iNt5++)
        {
            if (pubNt4Mapping[iNt5] == iNt4)
            {
                pName = OFFSET_TO_POINTER(gpRawData, pFeatures[iNt5].loKeywordName);

                ASSERT(pName != NULL);

                if (strcmp(pName, "JCLResolution") == EQUAL_STRING ||
                    strcmp(pName, "SetResolution") == EQUAL_STRING)
                {
                    pName = "Resolution";
                }

                DbgPrint("  %2d: %s\n", pubNt4Mapping[iNt5], pName);
                break;
            }
        }
    }
}



ULONG _cdecl
DbgPrint(
    PCSTR    pstrFormat,
    ...
    )

{
    va_list ap;

    va_start(ap, pstrFormat);
    vprintf(pstrFormat, ap);
    va_end(ap);

    return 0;
}

typedef enum {
    Free,
    InBracket,
    InHexDigitOdd,
    InHexDigitEven
} eInvState;

static void CheckInvocationValue(POPTION pOption, LPSTR pstrFeatureName)
{
    eInvState State = Free;
    DWORD i;
    LPSTR pInv = OFFSET_TO_POINTER(gpRawData, pOption->Invocation.loOffset);

    ASSERT(pOption->Invocation.dwCount == 0 || pInv != NULL);

    for (i=0; i< pOption->Invocation.dwCount; i++)
    {
        switch (State)
        {
        case Free:
            if (*(pInv + i) == '<')
                State = InBracket;
            break;
        case InBracket:
            if (isxdigit(*(pInv + i)))
                State = InHexDigitOdd;
            else
                State = Free;
            break;
        case InHexDigitOdd:
            if (isxdigit(*(pInv + i)))
                State = InHexDigitEven;
            else
                State = Free;
            break;
        case InHexDigitEven:
            if (isxdigit(*(pInv + i)))
                State = InHexDigitOdd;
            else if (*(pInv + i) == '>')
            {
                LPSTR pstrOptionName = OFFSET_TO_POINTER(gpRawData, pOption->loKeywordName);
                DbgPrint("Warning: invocation value of feature '%s', option '%s' contains hex digits\n   - possibly forgotten to use 'JCL' as start of keyword ?\n",
                          pstrFeatureName, pstrOptionName);
                return;
            }
            else
                State = Free;
            break;
        }
    }
}


VOID
PpdVerify(
    VOID
    )

{
    DWORD           index, dwFeatures;
    PFEATURE        pFeature;
    POPTION         pOption;
    PSTR            pstrFeatureName, pstrOptionName;
    BOOL            bNoneOption, bFalseOption;
    PUICONSTRAINT   pConstraint;
    DWORD           NoOfConstraints = gpUIInfo->UIConstraints.dwCount;


    dwFeatures = gpUIInfo->dwDocumentFeatures + gpUIInfo->dwPrinterFeatures;
    pFeature = OFFSET_TO_POINTER(gpRawData, gpUIInfo->loFeatureList);
    pConstraint = OFFSET_TO_POINTER(gpRawData, gpUIInfo->UIConstraints.loOffset);

    ASSERT(dwFeatures == 0 || pFeature != NULL);

    for (index = 0; index < dwFeatures; index++, pFeature++)
    {
        DWORD       dwOptionCount, dwOptionIndex = 0;

        pstrFeatureName = OFFSET_TO_POINTER(gpRawData, pFeature->loKeywordName);

        if (dwOptionCount = pFeature->Options.dwCount)
        {
            pOption = OFFSET_TO_POINTER(gpRawData, pFeature->Options.loOffset);
            bNoneOption = bFalseOption = FALSE;

            ASSERT(dwOptionCount == 0 || pOption != NULL);

            while (dwOptionCount--)
            {
                pstrOptionName = OFFSET_TO_POINTER(gpRawData, pOption->loKeywordName);

                ASSERT(pstrOptionName);

                if (!strcmp(pstrOptionName, gstrNoneKwd))
                    bNoneOption = TRUE;
                else if (!strcmp(pstrOptionName, gstrFalseKwd))
                    bFalseOption = TRUE;

                if (giDebugLevel <= 2)
                {
                    CheckInvocationValue(pOption, pstrFeatureName);

                    //
                    // check self constraining constraints
                    //
                    if (pOption->dwUIConstraintList != NULL_CONSTRAINT)
                    {
                        DWORD dwConstIndex = pOption->dwUIConstraintList;
                        do
                        {
                            if ((pConstraint[dwConstIndex].dwFeatureIndex == index) &&
                                ((pConstraint[dwConstIndex].dwOptionIndex == dwOptionIndex) ||
                                 (pConstraint[dwConstIndex].dwOptionIndex == OPTION_INDEX_ANY)))
                                DbgPrint("Warning : self constraining constraint found for feature '%s', Option '%s'\n", pstrFeatureName, pstrOptionName);
                            dwConstIndex = pConstraint[dwConstIndex].dwNextConstraint;
                        } while (dwConstIndex != NULL_CONSTRAINT);
                    }
                }
                pOption = (POPTION) ((PBYTE) pOption + pFeature->dwOptionSize);
                dwOptionIndex++;
            }

            if (bNoneOption && bFalseOption)
                DbgPrint("Error: Feature '%s' has both None and False options!\n",pstrFeatureName);

        }
    }

}



VOID
usage(
    VOID
    )

{
    DbgPrint("usage: %s [-options] filenames ...\n", gstrProgName);
    DbgPrint("where options are:\n");
    DbgPrint("  -b  attempt to read cached binary PPD data first\n");
    DbgPrint("  -k  keep the binary PPD data\n");
    DbgPrint("  -wN set warning level to N\n");
    DbgPrint("  -h  display help information\n");
    exit(-1);
}


INT _cdecl
main(
    INT     argc,
    CHAR    **argv
    )

{
    BOOL    bUseCache, bKeepBPD;
    DWORD   dwTime;

    //
    // Go through the command line arguments
    //

    ghInstance = GetModuleHandle(NULL);
    bUseCache = bKeepBPD = FALSE;
    giDebugLevel = DBG_TERSE;
    gdwTotalSize = gdwNumFiles = gdwMaxFileSize;

    gstrProgName = *argv++;
    argc--;

    if (argc == 0)
        usage();

    dwTime = GetTickCount();

    for ( ; argc--; argv++)
    {
        PSTR    pArg = *argv;

        if (*pArg == '-' || *pArg == '/')
        {
            //
            // The argument is an option flag
            //

            switch (*++pArg) {

            case 'b':
            case 'B':

                bUseCache = bKeepBPD = TRUE;
                break;

            case 'k':
            case 'K':

                bKeepBPD = TRUE;
                break;

            case 'w':
            case 'W':

                if (*++pArg >= '0' && *pArg <= '9')
                {
                    giDebugLevel = *pArg - '0';
                    break;
                }

            default:

                usage();
                break;
            }

        }
        else
        {
            WCHAR   wstrFilename[MAX_PATH];
            PTSTR   ptstrBpdFilename;

            //
            // Convert ANSI filename to Unicode filename
            //

            MultiByteToWideChar(CP_ACP, 0, pArg, -1, wstrFilename, MAX_PATH);

            TERSE(("\n*** %ws\n", wstrFilename));

            //
            // If -b option is given, try to read cached binary data first
            //

            if (bUseCache)
                gpRawData = PpdLoadCachedBinaryData(wstrFilename);
            else
            {
                gpRawData = PpdParseTextFile(wstrFilename);
                if (giDebugLevel <= 2)
                    CheckOptionIntegrity(wstrFilename);
            }

            if (gpRawData)
            {
                gpInfoHdr = (PINFOHEADER) gpRawData;
                gpUIInfo = (PUIINFO) ((PBYTE) gpInfoHdr + gpInfoHdr->loUIInfoOffset);
                gpPpdData = (PPPDDATA) ((PBYTE) gpInfoHdr + gpInfoHdr->loDriverOffset);
                gpUIInfo->pInfoHeader = gpInfoHdr;

                if (giDebugLevel == 8)
                {
                    DbgPrint("*** PPD file: %s\n", StripDirPrefixA(pArg));

                    DumpNt4Mapping();
                }
                else if (giDebugLevel == 9)
                    PpdDump();

                //
                // extra error checking
                //

                PpdVerify();

                gdwTotalSize += gpRawData->dwFileSize;
                gdwNumFiles++;

                if (gpRawData->dwFileSize > gdwMaxFileSize)
                    gdwMaxFileSize = gpRawData->dwFileSize;

                MemFree(gpRawData);

                //
                // If -k option is not given, get rid of the BPD file after we're done
                //

                if (! bKeepBPD && (ptstrBpdFilename = GenerateBpdFilename(wstrFilename)))
                {
                    DeleteFile(ptstrBpdFilename);
                    MemFree(ptstrBpdFilename);
                }
            }
        }
    }

    #ifdef COLLECT_STATS

    if (gdwNumFiles > 0)
    {
        dwTime = GetTickCount() - dwTime;

        TERSE(("Number of files parsed: %d\n", gdwNumFiles));
        TERSE(("Average binary file size: %d\n", gdwTotalSize / gdwNumFiles));
        TERSE(("Maximum binary file size: %d\n", gdwMaxFileSize));
        TERSE(("Average parsing time per file (ms): %d\n", dwTime / gdwNumFiles));
    }

    #endif // COLLECT_STATS

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\tools\uexts\gdifont.cxx ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:


Abstract:

Environment:

    Windows NT usermode printer drivers debugger GDI data structure dump

Revision History:

    Changed for Usermode printer driver debugger by Eigo Shimizu.

--*/

#include "precomp.hxx"

//
// SUROBJ
//



BOOL
TDebugExt::
bDumpSURFOBJ(
    PVOID pso_,
    DWORD dwAttr)

{
    PSURFOBJ  pso = (PSURFOBJ)pso_;
    Print("\nGDI SURFOBJ(%x):\n", pso_);
    DumpHex(pso, dhsurf);
    DumpHex(pso, hsurf);
    DumpHex(pso, dhpdev);
    DumpHex(pso, hdev);
    DumpSIZEL(pso, sizlBitmap);
    DumpInt(pso, cjBits);
    DumpHex(pso, pvBits);
    DumpHex(pso, pvScan0);
    DumpInt(pso, lDelta);
    DumpInt(pso, iUniq);
    DumpInt(pso, iBitmapFormat);
    DumpInt(pso, iType);
    DumpHex(pso, fjBitmap);

    return TRUE;
}

DEBUG_EXT_ENTRY( so, SURFOBJ, bDumpSURFOBJ, NULL, FALSE );


//
// FONTOBJ
//


DEBUG_FLAGS gafdFONTOBJ_flFontType[] = {
    { "FO_TYPE_RASTER",   FO_TYPE_RASTER},
    { "FO_TYPE_DEVICE",   FO_TYPE_DEVICE},
    { "FO_TYPE_TRUETYPE", FO_TYPE_TRUETYPE},
    { "FO_TYPE_OPENTYPE", 0x8},
    { "FO_SIM_BOLD",      FO_SIM_BOLD},
    { "FO_SIM_ITALIC",    FO_SIM_ITALIC},
    { "FO_EM_HEIGHT",     FO_EM_HEIGHT},
    { "FO_GRAY16",        FO_GRAY16},
    { "FO_NOGRAY16",      FO_NOGRAY16},
    { "FO_NOHINTS",       FO_NOHINTS},
    { "FO_NO_CHOICE",     FO_NO_CHOICE},
    { "FO_CFF",           FO_CFF},
    { NULL, 0}
};

BOOL
TDebugExt::
bDumpFONTOBJ(
    PVOID pfo_,
    DWORD dwAttr)

{
    PFONTOBJ  pfo = (PFONTOBJ)pfo_;
    Print("\nGDI FONTOBJ(%x):\n", pfo_);

    DumpInt(pfo, iUniq);
    DumpInt(pfo, iFace);
    DumpInt(pfo, cxMax);
    DumpHex(pfo, flFontType);
    vDumpFlags(pfo->flFontType, gafdFONTOBJ_flFontType);
    DumpInt(pfo, iTTUniq);
    DumpInt(pfo, iFile);
    DumpHex(pfo, sizLogResPpi);
    DumpInt(pfo, ulStyleSize);
    DumpHex(pfo, pvConsumer);
    DumpHex(pfo, pvProducer);
    return TRUE;
}

DEBUG_EXT_ENTRY( fo, FONTOBJ, bDumpFONTOBJ, NULL, FALSE );

//
// GLYPHPOS
//

BOOL
TDebugExt::
bDumpGP(
    PVOID pgp_,
    DWORD dwAttr)

{
    PGLYPHPOS  pgp = (PGLYPHPOS)pgp_;
    Print("\nGDI GLYPHPOS(%x):\n", pgp_);

    DumpHex(pgp, hg);
    DumpHex(pgp, pgdf);
    DumpInt(pgp, ptl.x);
    DumpInt(pgp, ptl.y);

    return TRUE;
}

DEBUG_EXT_ENTRY( gp, GLYPHPOS, bDumpGP, NULL, FALSE );


//
// RECTL
//

BOOL
TDebugExt::
bDumpRECTL(
    PVOID prectl_,
    DWORD dwAttr)

{
    PRECTL prectl = (PRECTL)prectl_;

    Print("\nGDI RECTL(%x):\n", prectl_);

    Print("  %RECTL(left, top, right, bottom) = (%d, %d, %d, %d)\n",
           prectl->left,
           prectl->top,
           prectl->right,
           prectl->bottom);
    return TRUE;
}

DEBUG_EXT_ENTRY( rectl, RECTL, bDumpRECTL, NULL, FALSE );


#define GDISTRO_DumpWStr(field) \
        { \
        WCHAR wstrTmp[256]; \
        move2(wstrTmp, pstro->field, pstro->cGlyphs * 2); \
        Print("  %-16s = 0x%x (%ws)\n", #field, pstro->field, wstrTmp); \
        }


//
// STROBJ
//

DEBUG_FLAGS gafdSTROBJ_flAccel[] = {
    { "SO_FLAG_DEFAULT_PLACEMENT", SO_FLAG_DEFAULT_PLACEMENT},
    { "SO_HORIZONTAL", SO_HORIZONTAL},
    { "SO_VERTICAL", SO_VERTICAL},
    { "SO_REVERSED", SO_REVERSED},
    { "SO_ZERO_BEARINGS", SO_ZERO_BEARINGS},
    { "SO_CHAR_INC_EQUAL_BM_BASE", SO_CHAR_INC_EQUAL_BM_BASE},
    { "SO_MAXEXT_EQUAL_BM_SIDE", SO_MAXEXT_EQUAL_BM_SIDE},
    { "SO_DO_NOT_SUBSTITUTE_DEVICE_FONT", SO_DO_NOT_SUBSTITUTE_DEVICE_FONT},
    { "SO_GLYPHINDEX_TEXTOUT", SO_GLYPHINDEX_TEXTOUT},
    { "SO_ESC_NOT_ORIENT", SO_ESC_NOT_ORIENT},
    { "SO_DXDY", SO_DXDY},
    { "SO_CHARACTER_EXTRA", SO_CHARACTER_EXTRA},
    { "SO_BREAK_EXTRA", SO_BREAK_EXTRA}
};

BOOL
TDebugExt::
bDumpSTRO(
    PVOID pstro_,
    DWORD dwAttr)

{
    PSTROBJ  pstro = (PSTROBJ)pstro_;
    Print("\nGDI STROBJ(%x):\n", pstro_);

    DumpInt(pstro, cGlyphs);
    DumpHex(pstro, flAccel);
    vDumpFlags(pstro->flAccel, gafdSTROBJ_flAccel);
    DumpInt(pstro, ulCharInc);
    DumpRectl(pstro, rclBkGround);
    DumpHex(pstro, pgp);
    GDISTRO_DumpWStr(pwszOrg);

    return TRUE;
}

DEBUG_EXT_ENTRY( stro, STROBJ, bDumpSTRO, NULL, FALSE );


//
// IFIMETRICS
//

BOOL
TDebugExt::
bDumpIFI(
    PVOID pifi_,
    DWORD dwAttr)

{
    PIFIMETRICS  pifi = (PIFIMETRICS)pifi_;
    Print("\nGDI IFIMETRICS(%x):\n", pifi_);

    DumpInt(pifi, cjThis);
    DumpInt(pifi, cjIfiExtra);
    DumpHex(pifi, dpwszFamilyName);
    DumpHex(pifi, dpwszStyleName);
    DumpHex(pifi, dpwszFaceName);
    DumpHex(pifi, dpwszUniqueName);
    DumpHex(pifi, dpFontSim);
    DumpInt(pifi, lEmbedId);
    DumpInt(pifi, lItalicAngle);
    DumpInt(pifi, lCharBias);
    DumpHex(pifi, dpCharSets);
    DumpInt(pifi, jWinCharSet);
    DumpHex(pifi, jWinPitchAndFamily);
    DumpInt(pifi, usWinWeight);
    DumpHex(pifi, flInfo);
    DumpHex(pifi, fsSelection);
    DumpHex(pifi, fsType);
    DumpInt(pifi, fwdUnitsPerEm);
    DumpInt(pifi, fwdLowestPPEm);
    DumpInt(pifi, fwdWinAscender);
    DumpInt(pifi, fwdWinDescender);
    DumpInt(pifi, fwdMacAscender);
    DumpInt(pifi, fwdMacDescender);
    DumpInt(pifi, fwdMacLineGap);
    DumpInt(pifi, fwdTypoAscender);
    DumpInt(pifi, fwdTypoDescender);
    DumpInt(pifi, fwdTypoLineGap);
    DumpInt(pifi, fwdAveCharWidth);
    DumpInt(pifi, fwdMaxCharInc);
    DumpInt(pifi, fwdCapHeight);
    DumpInt(pifi, fwdXHeight);
    DumpInt(pifi, fwdSubscriptXSize);
    DumpInt(pifi, fwdSubscriptYSize);
    DumpInt(pifi, fwdSubscriptXOffset);
    DumpInt(pifi, fwdSubscriptYOffset);
    DumpInt(pifi, fwdSuperscriptXSize);
    DumpInt(pifi, fwdSuperscriptYSize);
    DumpInt(pifi, fwdSuperscriptXOffset);
    DumpInt(pifi, fwdSuperscriptYOffset);
    DumpInt(pifi, fwdUnderscoreSize);
    DumpInt(pifi, fwdUnderscorePosition);
    DumpInt(pifi, fwdStrikeoutSize);
    DumpInt(pifi, fwdStrikeoutPosition);
    DumpHex(pifi, chFirstChar);
    DumpHex(pifi, chLastChar);
    DumpHex(pifi, chDefaultChar);
    DumpHex(pifi, chBreakChar);
    DumpHex(pifi, wcFirstChar);
    DumpHex(pifi, wcLastChar);
    DumpHex(pifi, wcDefaultChar);
    DumpHex(pifi, wcBreakChar);
    DumpHex(pifi, ptlBaseline);
    DumpHex(pifi, ptlAspect);
    DumpHex(pifi, ptlCaret);
    DumpHex(pifi, rclFontBox);
    DumpInt(pifi, achVendId[0]);
    DumpInt(pifi, achVendId[1]);
    DumpInt(pifi, achVendId[2]);
    DumpInt(pifi, achVendId[3]);
    DumpInt(pifi, cKerningPairs);
    DumpInt(pifi, ulPanoseCulture);
    return TRUE;
}

DEBUG_EXT_ENTRY( ifi, IFIMETRICS, bDumpIFI, NULL, FALSE );



//
// FD_GLYPHSET
//

BOOL
TDebugExt::
bDumpFD_GLYPHSET(
    PVOID pfdg_,
    DWORD dwAttr)

{
    FD_GLYPHSET* pfdg = (FD_GLYPHSET*)pfdg_;
    Print("\nGDI FD_GLYPHSET(%x):\n", pfdg_);

    DumpInt(pfdg, cjThis);
    DumpHex(pfdg, flAccel);
    DumpInt(pfdg, cGlyphsSupported);
    DumpInt(pfdg, cRuns);
    DumpHex(pfdg, awcrun[0].wcLow);
    DumpInt(pfdg, awcrun[0].cGlyphs);
    DumpHex(pfdg, awcrun[0].phg);

    return TRUE;
}

DEBUG_EXT_ENTRY( fdg, FD_GLYPHSET, bDumpFD_GLYPHSET, NULL, FALSE );



//
// GDIINFO
//

BOOL
TDebugExt::
bDumpGDIINFO(
    PVOID pgdiinfo_,
    DWORD dwAttr)

{
    PGDIINFO pgdiinfo = (GDIINFO*)pgdiinfo_;
    Print("\nGDI GDIINFO(%x):\n", pgdiinfo_);

    DumpHex(pgdiinfo, ulVersion);
    DumpHex(pgdiinfo, ulTechnology);
    DumpHex(pgdiinfo, ulHorzSize);
    DumpHex(pgdiinfo, ulVertSize);
    DumpHex(pgdiinfo, ulHorzRes);
    DumpHex(pgdiinfo, ulVertRes);
    DumpInt(pgdiinfo, cBitsPixel);
    DumpInt(pgdiinfo, cPlanes);
    DumpInt(pgdiinfo, ulNumColors);
    DumpHex(pgdiinfo, flRaster);
    DumpHex(pgdiinfo, ulLogPixelsX);
    DumpHex(pgdiinfo, ulLogPixelsY);
    DumpHex(pgdiinfo, flTextCaps);
    DumpHex(pgdiinfo, ulDACRed);
    DumpHex(pgdiinfo, ulDACGreen);
    DumpHex(pgdiinfo, ulDACBlue);
    DumpHex(pgdiinfo, ulAspectX);
    DumpHex(pgdiinfo, ulAspectY);
    DumpHex(pgdiinfo, ulAspectXY);
    DumpHex(pgdiinfo, xStyleStep);
    DumpHex(pgdiinfo, yStyleStep);
    DumpHex(pgdiinfo, denStyleStep);
    DumpHex(pgdiinfo, ptlPhysOffset.x);
    DumpHex(pgdiinfo, ptlPhysOffset.y);
    DumpInt(pgdiinfo, szlPhysSize);
    DumpHex(pgdiinfo, ulNumPalReg);
    DumpInt(pgdiinfo, ciDevice);
    DumpInt(pgdiinfo, ulDevicePelsDPI);
    DumpHex(pgdiinfo, ulPrimaryOrder);
    DumpHex(pgdiinfo, ulHTPatternSize);
    DumpHex(pgdiinfo, ulHTOutputFormat);
    DumpHex(pgdiinfo, flHTFlags);
    DumpHex(pgdiinfo, ulVRefresh);
    DumpHex(pgdiinfo, ulBltAlignment);
    DumpHex(pgdiinfo, ulPanningHorzRes);
    DumpHex(pgdiinfo, ulPanningVertRes);
    DumpHex(pgdiinfo, xPanningAlignment);
    DumpHex(pgdiinfo, yPanningAlignment);
    DumpHex(pgdiinfo, cxHTPat);
    DumpHex(pgdiinfo, cyHTPat);
    DumpHex(pgdiinfo, pHTPatA);
    DumpHex(pgdiinfo, pHTPatB);
    DumpHex(pgdiinfo, pHTPatC);
    DumpHex(pgdiinfo, flShadeBlend);


    return TRUE;
}

DEBUG_EXT_ENTRY( gdiinfo, GDIINFO, bDumpGDIINFO, NULL, FALSE );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\tools\uexts\unidev.cxx ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    unidev.c

Abstract:

    Dump UNIDRV's device data structure

Environment:

    Windows NT printer drivers

Revision History:

    03/31/97  -eigos-
        Created it.

--*/

#include "precomp.hxx"
#include "unidrv2\inc\pdev.h"


#define PDEV_DumpInt(field) \
        Print("  %-16s = %d\n", #field, pPDev->field)

#define PDEV_DumpHex(field) \
        Print("  %-16s = 0x%x\n", #field, pPDev->field)

#define PDEV_DumpRec(field) \
        Print("  %-16s = 0x%x L 0x%x\n", \
                #field, \
                (ULONG) pPDev + offsetof(PDEV, field), \
                sizeof(pPDev->field))

BOOL
TDebugExt::
bDumpUNIDRVPDev(
    PVOID    pPDev_,
    DWORD    dwAddr
    )
{
    PDEV *pPDev = (PDEV*)pPDev_;

    dprintf("\nUNIDRV device data (%x):\n", pPDev_);

    PDEV_DumpHex(devobj.hEngine);
    PDEV_DumpHex(devobj.hPrinter);
    PDEV_DumpInt(ulID);
    PDEV_DumpHex(hUniResDLL);
    PDEV_DumpHex(hbm);
    PDEV_DumpHex(hSurface);
    PDEV_DumpHex(pso);
    PDEV_DumpHex(fMode);
    PDEV_DumpHex(fHooks);
    PDEV_DumpHex(WinResData.hResDLLModule);
    PDEV_DumpHex(bTTY);
    PDEV_DumpHex(pDriverInfo3);
    PDEV_DumpInt(dwDelta);
    PDEV_DumpInt(pbScanBuf);
    PDEV_DumpInt(pbRasterScanBuf);
    PDEV_DumpInt(dwFreeMem);
    PDEV_DumpHex(bBanding);
    PDEV_DumpInt(iBandDirection);
    PDEV_DumpInt(rcClipRgn.left);
    PDEV_DumpInt(rcClipRgn.right);
    PDEV_DumpInt(rcClipRgn.top);
    PDEV_DumpInt(rcClipRgn.bottom);
    PDEV_DumpHex(pDriverInfo);
    PDEV_DumpHex(pRawData);
    PDEV_DumpHex(pInfoHeader);
    PDEV_DumpHex(pUIInfo);
    PDEV_DumpRec(PrinterData);
    PDEV_DumpHex(pOptionsArray);
    PDEV_DumpInt(sBitsPixel);
    PDEV_DumpHex(pGlobals);
    PDEV_DumpRec(arCmdTable);
    PDEV_DumpInt(sCopies);
    PDEV_DumpHex(dwRop3);
    PDEV_DumpInt(dwNumOfDataBytes);
    PDEV_DumpInt(dwWidthInBytes);
    PDEV_DumpInt(dwHeightInPixels);
    PDEV_DumpInt(dwRectXSize);
    PDEV_DumpInt(dwRectYSize);
    PDEV_DumpInt(dwGrayPercentage);
    PDEV_DumpInt(dwPrintDirection);
    PDEV_DumpInt(dwNextFontID);
    PDEV_DumpInt(dwFontHeight);
    PDEV_DumpInt(dwFontWidth);
    PDEV_DumpInt(dwFontMaxWidth);
    PDEV_DumpInt(dwFontBold);
    PDEV_DumpInt(dwFontItalic);
    PDEV_DumpInt(dwFontUnderline);
    PDEV_DumpInt(dwFontStrikeThru);
    PDEV_DumpInt(dwCurrentFontID);
    PDEV_DumpHex(pOrientation);
    PDEV_DumpRec(pResolution);
    PDEV_DumpHex(pColorMode);
    PDEV_DumpHex(pColorModeEx);
    PDEV_DumpHex(pDuplex);
    PDEV_DumpHex(pPageSize);
    PDEV_DumpHex(pPageSizeEx);
    PDEV_DumpHex(pInputSlot);
    PDEV_DumpHex(pMemOption);
    PDEV_DumpHex(pHalftone);
    PDEV_DumpHex(pPageProtect);
    PDEV_DumpInt(ptGrxRes.x);
    PDEV_DumpInt(ptGrxRes.y);
    PDEV_DumpInt(ptTextRes.x);
    PDEV_DumpInt(ptTextRes.y);
    PDEV_DumpInt(ptGrxScale.x);
    PDEV_DumpInt(ptGrxScale.y);
    PDEV_DumpInt(ptDeviceFac.x);
    PDEV_DumpInt(ptDeviceFac.y);
    PDEV_DumpHex(pdm);
    PDEV_DumpHex(pdmPrivate);
    PDEV_DumpRec(ctl);
    PDEV_DumpRec(pf);
    PDEV_DumpRec(sf);
    PDEV_DumpInt(fYMove);
    PDEV_DumpInt(iSpool);
    PDEV_DumpHex(pbOBuf);
    PDEV_DumpInt(iFonts);
    PDEV_DumpInt(dwLookAhead);
    PDEV_DumpInt(ptDefaultFont.x);
    PDEV_DumpInt(ptDefaultFont.y);
    PDEV_DumpHex(pFontPDev);
    PDEV_DumpHex(pFontProcs);
    PDEV_DumpHex(pFileList);
    PDEV_DumpHex(pRasterPDEV);
    PDEV_DumpHex(pRasterProcs);
    PDEV_DumpHex(pPalData);
    PDEV_DumpHex(pVectorPDEV);
    PDEV_DumpHex(pVectorProcs);

    return TRUE;
}

DEBUG_EXT_ENTRY( unidev, PDEV, bDumpUNIDRVPDev, NULL, FALSE );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\tools\uexts\debug.cxx ===
/*++

Copyright (c) 1995  Microsoft Corporation
All rights reserved.

Module Name:

    debug.cxx

Abstract:

    Generic debug extensions.

Author:

    Albert Ting (AlbertT)  19-Feb-1995

Revision History:

    Changed for Usermode printer driver debugger by Eigo Shimizu.

--*/

#include "precomp.hxx"

HANDLE hCurrentProcess;
WINDBG_EXTENSION_APIS ExtensionApis;

PWINDBG_OUTPUT_ROUTINE Print;
PWINDBG_GET_EXPRESSION EvalExpression;
PWINDBG_GET_SYMBOL GetSymbolRtn;
PWINDBG_CHECK_CONTROL_C CheckControlCRtn;

USHORT SavedMajorVersion;
USHORT SavedMinorVersion;

BOOL bWindbg = FALSE;

VOID
WinDbgExtensionDllInit(
    PWINDBG_EXTENSION_APIS lpExtensionApis,
    USHORT MajorVersion,
    USHORT MinorVersion
    )
{
    ::ExtensionApis = *lpExtensionApis;

    SavedMajorVersion = MajorVersion;
    SavedMinorVersion = MinorVersion;

    bWindbg = TRUE;

    return;
}



VOID
TDebugExt::
vDumpStr(
    LPCWSTR pszString
    )
{
    WCHAR szString[MAX_PATH];

    if( (LPCWSTR)pszString == NULL ){

        Print( "(NULL)\n" );
        return;
    }

    szString[0] = 0;

    //
    // First try reading to the end of 1k (pages are 4k on x86, but
    // most strings are < 1k ).
    //
    UINT cbShort = 0x400 - ( (DWORD)pszString & 0x3ff );
    BOOL bFound = FALSE;

    if( cbShort < sizeof( szString )){

        UINT i;

        move2( szString, pszString, cbShort );

        //
        // Look for a NULL.
        //
        for( i=0; i< cbShort/sizeof( pszString[0] ); ++i )
        {
            if( !szString[i] ){
                bFound = TRUE;
            }
        }

    }

    if( !bFound ){

        move( szString, pszString );
    }

    if( szString[0] == 0 ){
        Print( "\"\"\n" );
    } else {
        Print( "%ws\n", szString );
    }
}

VOID
TDebugExt::
vDumpStrA(
    LPCSTR pszString
    )
{
    CHAR szString[MAX_PATH];

    if( (LPCSTR)pszString == NULL ){

        Print( "(NULL)\n" );
        return;
    }

    szString[0] = 0;

    //
    // First try reading to the end of 1k (pages are 4k on x86, but
    // most strings are < 1k ).
    //
    UINT cbShort = 0x400 - ( (DWORD)pszString & 0x3ff );
    BOOL bFound = FALSE;

    if( cbShort < sizeof( szString )){

        UINT i;

        move2( szString, pszString, cbShort );

        //
        // Look for a NULL.
        //
        for( i=0; i< cbShort/sizeof( pszString[0] ); ++i )
        {
            if( !szString[i] ){
                bFound = TRUE;
            }
        }

    }

    if( !bFound ){

        move( szString, pszString );
    }

    if( szString[0] == 0 ){
        Print( "\"\"\n" );
    } else {
        Print( "%hs\n", szString );
    }
}

VOID
TDebugExt::
vDumpTime(
    const SYSTEMTIME& st
    )
{
    Print( "%d/%d/%d %d %d:%d:%d.%d\n",
           st.wMonth,
           st.wDay,
           st.wYear,
           st.wDayOfWeek,
           st.wHour,
           st.wMinute,
           st.wSecond,
           st.wMilliseconds );
}


VOID
TDebugExt::
vDumpFlags(
    DWORD dwFlags,
    PDEBUG_FLAGS pDebugFlags
    )
{
    DWORD dwFound = 0;

    Print( "  %x [ ", dwFlags );

    for( ; pDebugFlags->dwFlag; ++pDebugFlags ){

        if( dwFlags & pDebugFlags->dwFlag ){
            Print( "%s ", pDebugFlags->pszFlag );
            dwFound |= pDebugFlags->dwFlag;
        }
    }

    Print( "]" );

    //
    // Check if there are extra bits set that we don't understand.
    //
    if( dwFound != dwFlags ){
        Print( "  <ExtraBits: %x>", dwFlags & ~dwFound );
    }
    Print( "\n" );
}

VOID
TDebugExt::
vDumpValue(
    DWORD dwValue,
    PDEBUG_VALUES pDebugValues
    )
{
    Print( "%x ", dwValue );

    for( ; pDebugValues->dwValue; ++pDebugValues ){

        if( dwValue == pDebugValues->dwValue ){
            Print( "%s ", pDebugValues->pszValue );
        }
    }
    Print( "\n" );
}

DWORD
TDebugExt::
dwEval(
    LPSTR& lpArgumentString,
    BOOL   bParam
    )
{
    DWORD dwReturn;
    LPSTR pSpace = NULL;

    while( *lpArgumentString == ' ' ){
        lpArgumentString++;
    }

    //
    // If it's a parameter, scan to next space and delimit.
    //
    if( bParam ){

        for( pSpace = lpArgumentString; *pSpace && *pSpace != ' '; ++pSpace )
            ;

        if( *pSpace == ' ' ){
            *pSpace = 0;
        }
    }

    dwReturn = (DWORD)EvalExpression( lpArgumentString );

    while( *lpArgumentString != ' ' && *lpArgumentString ){
        lpArgumentString++;
    }

    if( pSpace ){
        *pSpace = ' ';
    }

    return dwReturn;
}

/********************************************************************

    Extension entrypoints.

********************************************************************/

DEBUG_EXT_HEAD( help )
{
    DEBUG_EXT_SETUP_VARS();

    Print( "Prnx: Printer Driver Debug Extensions\n" );
    Print( "---------------------------------------------------------\n" );
    Print( "unidev dumps UNIDRV device data structure\n\n" );
    Print( "unidm  dumps UNIDRV DEVMODE data structure\n" );
    Print( "fpdev  dumps UNIDRV FONTPDEV data structure\n");
    Print( "fm     dumps UNIDRV FONTMAP data structure\n");
    Print( "devfm  dumps UNIDRV FONTMAP_DEV data structure\n");
    Print( "tod    dumps UNIDRV TO_DATA data structure\n");
    Print( "wt     dumps UNIDRV WHITETEXT data structure\n");
    Print( "dlm    dumps UNIDRV DL_MAP data structure\n");
    Print( "ufo    dumps UNIDRV UNIFONTOBJ data structure\n");
    Print( "devbrush dumps UNIDRV DEVBRUSH data structure\n");

    Print( "---------------------------------------------------------\n" );
    Print( "gb     dumps UNIDRV's GLOBALS data structure\n" );

    Print( "---------------------------------------------------------\n" );
    Print( "so     dumps SURFOBJ\n");
    Print( "stro   dumps STROBJ\n");
    Print( "fo     dumps FONTOBJ\n");
    Print( "gp     dumps GLYPHPOS\n");
    Print( "ifi    dumps IFIMETRICS\n");
    Print( "fdg    dumps FD_GLYPHSET\n");
    Print( "rectl  dumps RECTL\n");
    Print( "gdiinfo dumps GDIINFO\n");

    Print( "---------------------------------------------------------\n" );
    Print( "psdev  dumps PSCRIPT5 device data structure\n" );
    Print( "psdm   dumps PSCRIPT5 private devmode data\n\n" );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\tools\uexts\psdev.cxx ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    psdev.cxx

Abstract:

    Dump PSCRIPT5's device data structure

Environment:

    Windows NT printer drivers

Revision History:

    06/18/98 -fengy-
        Created it.

--*/

#include "precomp.hxx"

typedef PVOID HFILEMAP;
#include "inc\ppd.h"
#include "inc\psntf.h"
#include "inc\psntm.h"
#include "inc\psglyph.h"
#include "pscript\devfont.h"
#include "pscript\oemkm.h"
#include "pscript\ntf.h"
#include "pscript\pdev.h"

#define PDEV_DumpInt(field) \
        Print("  %-16s = %d\n", #field, pdev->field)

#define PDEV_DumpHex(field) \
        Print("  %-16s = 0x%x\n", #field, pdev->field)

#define PDEV_DumpRec(field) \
        Print("  %-16s = 0x%x L 0x%x\n", \
                #field, \
                (ULONG) pdev + offsetof(DEV, field), \
                sizeof(pdev->field))

BOOL
TDebugExt::
bDumpPSPDev(
    PVOID    pPDev_,
    DWORD    dwAddr
    )
{
    DEV *pdev = (DEV *)pPDev_;

    dprintf("\nPSCRIPT5 device data (%x):\n", pdev);

    PDEV_DumpRec(devobj);
    PDEV_DumpHex(dwUniqueID);
    PDEV_DumpHex(pstrNTVersion);
    PDEV_DumpHex(dwDebugFlags);
    PDEV_DumpHex(pdm);
    PDEV_DumpHex(pdmPrivate);
    PDEV_DumpHex(hModule);
    PDEV_DumpHex(hSurface);
    PDEV_DumpHex(hPalette);
    PDEV_DumpRec(PrinterData);
    PDEV_DumpHex(pTTSubTable);
    PDEV_DumpHex(pDriverInfo3);
    PDEV_DumpInt(iAppType);
    PDEV_DumpInt(bUseTrueColor);
    PDEV_DumpInt(iCurrentDpi);
    PDEV_DumpInt(iOrientAngle);
    PDEV_DumpInt(dwSaveLevel);
    PDEV_DumpRec(procset);
    PDEV_DumpRec(gsstack);
    PDEV_DumpInt(drvstate);
    PDEV_DumpHex(pRawData);
    PDEV_DumpHex(pUIInfo);
    PDEV_DumpHex(pPpdData);
    PDEV_DumpRec(job);
    PDEV_DumpInt(dwJobId);
    PDEV_DumpRec(vm);
    PDEV_DumpRec(szPaper);
    PDEV_DumpRec(rcImageArea);
    PDEV_DumpRec(rcBBox);
    PDEV_DumpInt(lPaperWidth);
    PDEV_DumpInt(lPaperHeight);
    PDEV_DumpInt(lOriginX);
    PDEV_DumpInt(lOriginY);
    PDEV_DumpInt(lImageWidth);
    PDEV_DumpInt(lImageHeight);
    PDEV_DumpInt(lCustomWidth);
    PDEV_DumpInt(lCustomHeight);
    PDEV_DumpInt(lCustomWidthOffset);
    PDEV_DumpInt(lCustomHeightOffset);
    PDEV_DumpInt(lOrientation);
    PDEV_DumpHex(pInjectData);
    PDEV_DumpHex(pDocResources);
    PDEV_DumpInt(bOptionsInited);
    PDEV_DumpRec(aPrinterOptions);
    PDEV_DumpHex(dwAscii85Val);
    PDEV_DumpInt(dwAscii85Cnt);
    PDEV_DumpInt(dwFilterLineLen);
    PDEV_DumpHex(pSpoolBuf);
    PDEV_DumpRec(achDocName);
    PDEV_DumpRec(colres);
    PDEV_DumpRec(psfns);
    PDEV_DumpInt(bErrorFlag);
    PDEV_DumpHex(pubRleData);
    PDEV_DumpHex(pOemPlugins);
    PDEV_DumpHex(pOemHookInfo);
    PDEV_DumpInt(bCallingOem);
    PDEV_DumpInt(ulPSFontNumber);
    PDEV_DumpInt(ulFontID);
    PDEV_DumpHex(pout);
    PDEV_DumpHex(pufl);
    PDEV_DumpHex(pDLFonts);
    PDEV_DumpHex(pPSFonts);
    PDEV_DumpHex(pTextoutBuffer);
    PDEV_DumpHex(pfo);
    PDEV_DumpHex(pifi);
    PDEV_DumpHex(pvTTFile);
    PDEV_DumpInt(ulTTSize);
    PDEV_DumpHex(pco);
    PDEV_DumpInt(cNtfFiles);
    PDEV_DumpRec(pNtfFiles);
    PDEV_DumpHex(pRegNtfData);
    PDEV_DumpHex(pDevFont);
    PDEV_DumpInt(bCopyToSpecial);
    PDEV_DumpInt(cNumFonts);
    PDEV_DumpHex(pSpecialPSDataHead);
    PDEV_DumpHex(pSpecialPSDataCurr);
    PDEV_DumpHex(pvEndSig);

    return TRUE;
}

DEBUG_EXT_ENTRY( psdev, DEV, bDumpPSPDev, NULL, FALSE );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\tools\uexts\psdm.cxx ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    psdm.cxx

Abstract:

    Dump PSCRIPT5's private devmode data

Environment:

    Windows NT printer drivers

Revision History:

    06/18/98 -fengy-
        Created it.

--*/

#include "precomp.hxx"

/*
typedef PVOID HFILEMAP;

#include "inc\ppd.h"
#include "inc\psntf.h"
#include "inc\psntm.h"
#include "inc\psglyph.h"
#include "pscript\devfont.h"
#include "pscript\oemkm.h"
#include "pscript\ntf.h"
#include "pscript\pdev.h"
*/

LPSTR PS_Dialect[] = {"SPEED", "PORTABILITY", "EPS", "ARCHIVE"};
LPSTR PS_Layout[] = {"ONE_UP", "TWO_UP", "FOUR_UP", "SIX_UP", "NINE_UP", "SIXTEEN_UP"};

#include "inc\devmode.h"

#define PSDM_DumpInt(field) \
        dprintf("  %-16s = %d\n", #field, psdm->field)

#define PSDM_DumpHex(field) \
        dprintf("  %-16s = 0x%x\n", #field, psdm->field)

#define PSDM_DumpRec(field) \
        dprintf("  %-16s = 0x%x L 0x%x\n", \
                #field, \
                (ULONG) psdm + offsetof(PSDRVEXTRA, field), \
                sizeof(psdm->field))


BOOL
TDebugExt::
bDumpPSDM(
    PVOID    pPSDM_,
    DWORD    dwAddr
    )
{
    PSDRVEXTRA *psdm = (PSDRVEXTRA *)pPSDM_;

    dprintf("\nPSCRIPT5 private devmode data (%x):\n", psdm);

    dprintf("  %-16s = '%c%c%c%c'\n",
            "dwSignature",
            (psdm->dwSignature >> 24) & 0xff,
            (psdm->dwSignature >> 16) & 0xff,
            (psdm->dwSignature >> 8) & 0xff,
            psdm->dwSignature & 0xff);
    PSDM_DumpHex(dwFlags);
    PSDM_DumpRec(wchEPSFile);
    PSDM_DumpRec(coloradj);
    PSDM_DumpInt(wReserved1);
    PSDM_DumpInt(wSize);
    PSDM_DumpHex(fxScrFreq);
    PSDM_DumpHex(fxScrAngle);
    dprintf("  %-16s = %d (%s)\n", "iDialect", psdm->iDialect, PS_Dialect[psdm->iDialect]);
    PSDM_DumpInt(iTTDLFmt);
    PSDM_DumpInt(bReversePrint);
    dprintf("  %-16s = %d (%s)\n", "iLayout", psdm->iLayout, PS_Layout[psdm->iLayout]);
    PSDM_DumpInt(iPSLevel);
    PSDM_DumpHex(dwReserved2);
    PSDM_DumpInt(wOEMExtra);
    PSDM_DumpInt(wVer);
    PSDM_DumpRec(csdata);
    PSDM_DumpRec(dwReserved3);
    PSDM_DumpHex(dwChecksum32);
    PSDM_DumpInt(dwOptions);
    PSDM_DumpRec(aOptions);

    return TRUE;
}

DEBUG_EXT_ENTRY( psdm, PSDRVEXTRA, bDumpPSDM, NULL, FALSE );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\tools\uexts\dbgext.h ===
/******************************Module*Header*******************************\
* Module Name: dbgext.h
*
* Created: 10-Sep-1993 08:36:42
* Author:  Eric Kutter [erick]
*
* Copyright (c) 1993 Microsoft Corporation
*
* Dependencies:
*
* common macros for debugger extensions
*
*
\**************************************************************************/


/**************************************************************************\
 *
 * GetAddress - symbol of another module
 *
\**************************************************************************/

#define GetAddress(dst, src)                                                    \
__try {                                                                         \
    char *pj = (char *)(src);                                                   \
/* if it is NTSD, don't want the trailing & */                                  \
    if ((ExtensionApis.nSize < sizeof(WINDBG_EXTENSION_APIS)) &&                \
        (*pj == '&'))                                                           \
    {                                                                           \
        pj++;                                                                   \
    }                                                                           \
    *((ULONG *) &dst) = EvalExpression(pj);                                     \
} __except (GetExceptionCode() == EXCEPTION_ACCESS_VIOLATION ?                  \
            EXCEPTION_EXECUTE_HANDLER : EXCEPTION_CONTINUE_SEARCH) {            \
    Print("NTSD: Access violation on \"%s\", switch to server context\n", src); \
}

#define GetValue(dst,src)                                                       \
    GetAddress(dst,src)                                                         \
    if (TRUE || ExtensionApis.nSize < sizeof(WINDBG_EXTENSION_APIS))            \
    {                                                                           \
        move(dst,dst);                                                          \
    }

/**************************************************************************\
 *
 * move(dst, src ptr)
 *
\**************************************************************************/

#define move(dst, src)                                              \
__try {                                                             \
    if (ExtensionApis.nSize >= sizeof(WINDBG_EXTENSION_APIS))       \
    {                                                               \
        (*ExtensionApis.lpReadProcessMemoryRoutine)(                \
             (DWORD) (src), &(dst), sizeof(dst), NULL);             \
    } else                                                          \
    {                                                               \
        NtReadVirtualMemory(hCurrentProcess, (LPVOID) (src), &(dst), sizeof(dst), NULL);\
    }                                                               \
                                                                    \
} __except (EXCEPTION_EXECUTE_HANDLER) {                            \
    Print("exception in move()\n");                                 \
}

/**************************************************************************\
 *
 * move2(dst ptr, src ptr, num bytes)
 *
\**************************************************************************/

#define move2(dst, src,bytes)                                       \
__try {                                                             \
    if (ExtensionApis.nSize >= sizeof(WINDBG_EXTENSION_APIS))       \
    {                                                               \
        (*ExtensionApis.lpReadProcessMemoryRoutine)(                \
             (DWORD) (src), (dst), (bytes), NULL);                  \
    } else                                                          \
    {                                                               \
        NtReadVirtualMemory(hCurrentProcess, (LPVOID) (src), (dst), (bytes), NULL);\
    }                                                               \
                                                                    \
} __except (EXCEPTION_EXECUTE_HANDLER) {                            \
    Print("exception in move2()\n");                                \
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\tools\ps\ppdcheck\w_ppd.c ===
//
// Copyright (c) 1998 Microsoft Corporation
//
// This is just a wrapper file to allow a building the ppdcheck.exe
// in free builds without changes, since the output relies on the
// DBG define, which for ppdcheck is set in "sources"
//
#include "ppd.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\tools\uexts\unidm.cxx ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    unidm.c

Abstract:

    Dump UNIDRV's private devmode data

Environment:

    Windows NT printer drivers

Revision History:

    03/31/97 -eigos-
        Created it.

--*/

#include "precomp.hxx"

//
// This is from unidrv2\inc\state.h
//
typedef struct _DEVBRUSH{

    DWORD       dwBrushType;       // One of BRUSH_XXX types listed above
    INT         iColor;            // Color of the brush, depending on the type
                                   // it could be one of the following:
                                   // 2. RGB Color
                                   // 3. User define pattern ID
                                   // 4. Shading percentage
    PVOID       pNext;             // Pointed to next brush in list

}DEVBRUSH, *PDEVBRUSH;

#define UNIDM_DumpInt(field) \
        Print("  %-16s = %d\n", #field, pUMExtra->field)

#define UNIDM_DumpHex(field) \
        Print("  %-16s = 0x%x\n", #field, pUMExtra->field)

#define UNIDM_DumpRec(field) \
        Print("  %-16s = 0x%x L 0x%x\n", \
                #field, \
                (ULONG) pUMExtra + offsetof(UNIDRVEXTRA, field), \
                sizeof(pUMExtra->field))


BOOL
TDebugExt::
bDumpUNIDRVExtra(
    PVOID pUMExtra_,
    DWORD dwAttr)

{
    PUNIDRVEXTRA  pUMExtra = (PUNIDRVEXTRA)pUMExtra_;

    Print("\nUNIDRV private devmode data (%x):\n", pUMExtra);
    UNIDM_DumpHex(dwSignature);
    UNIDM_DumpHex(wVer);
    UNIDM_DumpInt(sPadding);
    UNIDM_DumpInt(wSize);
    UNIDM_DumpInt(wOEMExtra);
    UNIDM_DumpInt(dwChecksum32);
    UNIDM_DumpInt(dwFlags);
    UNIDM_DumpInt(bReversePrint);
    UNIDM_DumpInt(iLayout);
    UNIDM_DumpInt(iQuality);
    UNIDM_DumpInt(dwOptions);
    UNIDM_DumpRec(aOptions);

    return TRUE;
}

DEBUG_EXT_ENTRY( unidm, UNIDRVEXTRA, bDumpUNIDRVExtra, NULL, FALSE );


#define UNIDEVBRUSH_DumpInt(field) \
        Print("  %-16s = %d\n", #field, pDevBrush->field)

#define UNIDEVBRUSH_DumpHex(field) \
        Print("  %-16s = 0x%x\n", #field, pDevBrush->field)

#define UNIDEVBRUSH_DumpRec(field) \
        Print("  %-16s = 0x%x L 0x%x\n", \
                #field, \
                (ULONG) pDevBrush + offsetof(DEVBRUSH, field), \
                sizeof(pDevBrush->field))

const CHAR* strBRUSHTYPE[] = {
	"BRUSH_BLKWHITE",
	"BRUSH_SHADING",
	"BRUSH_CROSSHATCH",
	"BRUSH_USERPATTERN",
	"BRUSH_PROGCOLOR",
	"BRUSH_NONPROGCOLOR",
	 NULL
};

BOOL
TDebugExt::
bDumpDEVBRUSH(
    PVOID pDevBrush_,
    DWORD dwAttr)

{
    PDEVBRUSH  pDevBrush = (PDEVBRUSH)pDevBrush_;

    Print("\nUNIDRV DEVBRUSH data (%x):\n", pDevBrush);
    UNIDEVBRUSH_DumpInt(dwBrushType);
    Print("%d [ %s ]\n", pDevBrush->dwBrushType, strBRUSHTYPE[pDevBrush->dwBrushType+1]);
    UNIDEVBRUSH_DumpInt(iColor);
    UNIDEVBRUSH_DumpHex(pNext);

    return TRUE;
}

DEBUG_EXT_ENTRY( devbrush, DEVBRUSH, bDumpDEVBRUSH, NULL, FALSE );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\tools\uni\ctt2gtt\local.h ===
/*++

Copyright (c) 1996-1997  Microsoft Corporation

Module Name:

    local.h

Abstract:


Environment:

    Windows NT printer drivers

Revision History:

    11/01/96 -eigos-
        Created it.

--*/

BOOL BGetInfo(PBYTE, DWORD, PDWORD, PBYTE, PBYTE);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\tools\uni\dumpgly\dumpgly.c ===
/*++

Copyright (c) 1996-1997  Microsoft Corporation

Module Name:

    dumpgly.c

Abstract:

    GLYPHSETDATA dump tool

Environment:

    Windows NT PostScript driver

Revision History:

    11/08/96 -eigos-
    Created it.

--*/

#include        "precomp.h"

//
// Macros
//

#define FILENAME_SIZE 256

#define GLYPHSET_VERSION_1 0x00010000

//
// Globals
//

BYTE gcstrError1[] = "Usage:  dumpgly *.gly\n";
BYTE gcstrError2[] = "Cannot open file \"%ws\".\n";
BYTE gcstrError3[] = "Invalid gly file \"%ws\".\n";

DWORD gdwOutputFlags;


PSTR gcstrCCType[] = { 
    "MTYPE_COMPOSE",
    "MTYPE_DIRECT",
    "MTYPE_PAIRED"};


int  __cdecl
main(
    IN int     argc,
    IN char  **argv)
/*++

Routine Description:

    main

Arguments:

    argc - Number of parameters in the following
    argv - The parameters, starting with our name

Return Value:

    Return error code 

Note:


--*/
{
    PUNI_GLYPHSETDATA pGly;
    PUNI_CODEPAGEINFO pCP;
    PGLYPHRUN         pGlyphRun;
    PMAPTABLE         pMapTable;
    TRANSDATA        *pTrans;
    HFILEMAP          hGlyphSetData;
    DWORD             dwGlySize;
    DWORD             dwI, dwJ;
    INT               iRet;
    WORD              wSize, wJ;
    WCHAR             awchFile[FILENAME_SIZE];
    BYTE              pFormatCmd[256];
    PBYTE             pCommand;

    if (argc != 2)
    {
        fprintf( stderr, gcstrError1);
        return  -1;
    }

    argv++;

    iRet = MultiByteToWideChar(CP_ACP,
                               0,
                               *argv,
                               strlen(*argv),
                               awchFile,
                               FILENAME_SIZE);

    *(awchFile + iRet) = (WCHAR)NULL;

    hGlyphSetData = MapFileIntoMemory( awchFile,
                                       (PVOID)&pGly,
                                       &dwGlySize );

    if (!hGlyphSetData)
    {
        fprintf( stderr, gcstrError2, *argv);
        return  -2;
    }

    if (pGly->dwVersion != GLYPHSET_VERSION_1)
    {
        fprintf( stderr, gcstrError3, *argv);
        return -2;
    }

    printf("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
    printf("G L Y P H S E T   D A T A   F I L E\n");
    printf("FILE=%s\n",*argv);
    printf("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
    printf("GLYPHSETDATA\n");
    printf("GLYPHSETDATA.dwSize              : %d\n", pGly->dwSize);
    printf("             dwVersion           : %d.%d\n", (pGly->dwVersion) >>16,
                                                 0x0000ffff&pGly->dwVersion);
    printf("             dwFlags             : %d\n", pGly->dwFlags);
    printf("             lPredefinedID       : %d\n", pGly->lPredefinedID);
    printf("             dwGlyphCount        : %d\n", pGly->dwGlyphCount);
    printf("             dwRunCount          : %d\n", pGly->dwRunCount);
    printf("             loRunOffset         : 0x%x\n", pGly->loRunOffset);
    printf("             dwCodePageCount     : %d\n", pGly->dwCodePageCount);
    printf("             loCodePageOffset    : 0x%x\n", pGly->loCodePageOffset);
    printf("             loMapTableOffset    : 0x%x\n", pGly->loMapTableOffset);
    printf("\n");

    pCP = (PUNI_CODEPAGEINFO)((PBYTE) pGly + pGly->loCodePageOffset);

    printf("\n");
    printf("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
    printf("CODEPAGEINFO\n");
    for (dwI = 0; dwI < pGly->dwCodePageCount; dwI ++)
    {
        printf ("UNI_CODEPAGEINFO[%d].dwCodePage                    = %d\n",
            dwI, pCP->dwCodePage);
        printf ("UNI_CODEPAGEINFO[%d].SelectSymbolSet.dwCount       = %d\n",
            dwI, pCP->SelectSymbolSet.dwCount);
        printf ("UNI_CODEPAGEINFO[%d].SelectSymbolSet:Command(%d)   = %s\n",
            dwI,
            pCP->SelectSymbolSet.loOffset,
            (PBYTE)pCP+pCP->SelectSymbolSet.loOffset);
        printf ("UNI_CODEPAGEINFO[%d].UnSelectSymbolSet.dwCount     = %d\n",
            dwI, pCP->UnSelectSymbolSet.dwCount);
        printf ("UNI_CODEPAGEINFO[%d].UnSelectSymbolSet:Command(%d) = %s\n",
            dwI,
            pCP->UnSelectSymbolSet.loOffset,
            (PBYTE)pCP+pCP->UnSelectSymbolSet.loOffset);
        pCP++;
    }

    pGlyphRun = (PGLYPHRUN) ((PBYTE)pGly + pGly->loRunOffset);

    printf("\n");
    printf("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
    printf("GLYPHRUN\n");

    dwJ = 1;
    for (dwI = 0; dwI < pGly->dwRunCount; dwI ++)
    {
         printf("GLYPHRUN[%2d].wcLow       = 0x%-4x\n",
             dwI, pGlyphRun->wcLow);
         printf("GLYPHRUN[%2d].wGlyphCount = %d\n",
             dwI, pGlyphRun->wGlyphCount);
         printf("Starting Glyph ID         = %d\n", dwJ);
         dwJ += pGlyphRun->wGlyphCount;
         pGlyphRun++;
    }

    pMapTable = (PMAPTABLE) ((PBYTE)pGly + pGly->loMapTableOffset);
    pTrans    = pMapTable->Trans;

    printf("\n");
    printf("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
    printf("MAPTABLE\n");
    printf("MAPTABLE.dwSize     = %d\n", pMapTable->dwSize);
    printf("MAPTABLE.dwGlyphNum = %d\n", pMapTable->dwGlyphNum);

    for (dwI = 0; dwI < pMapTable->dwGlyphNum; dwI ++)
    {
        printf("MAPTABLE.pTrans[%5d].ubCodePageID = %d\n",
            dwI+1, pTrans[dwI].ubCodePageID);
        printf("MAPTABLE.pTrans[%5d].ubType       = 0x%x\n",
            dwI+1, pTrans[dwI].ubType);
        switch(pTrans[dwI].ubType & MTYPE_FORMAT_MASK)
        {
        case MTYPE_DIRECT:
            printf("MAPTABLE.pTrans[%5d].ubCode       = 0x%02x\n",
                dwI+1, pTrans[dwI].uCode.ubCode);
            break;
        case MTYPE_PAIRED:
            printf("MAPTABLE.pTrans[%5d].ubPairs[0]   = 0x%02x\n",
                dwI+1, pTrans[dwI].uCode.ubPairs[0]);
            printf("MAPTABLE.pTrans[%5d].ubPairs[1]   = 0x%02x\n",
                dwI+1, pTrans[dwI].uCode.ubPairs[1]);
            break;
        case MTYPE_COMPOSE:
                printf("MAPTABLE.pTrans[%5d].sCode        = 0x%02x\n",
                    dwI+1, pTrans[dwI].uCode.sCode);
                pCommand = (PBYTE)pMapTable + pTrans[dwI].uCode.sCode;
                wSize = *(WORD*)pCommand;
                pCommand += 2;
                printf("Size                                = 0x%d\n", wSize);
                printf("Command                             = 0x");
                for (wJ = 0; wJ < wSize; wJ ++)
                {
                    printf("%02x",pCommand[wJ]);
                }
                printf("\n");
            break;
        }
    }

    UnmapFileFromMemory(hGlyphSetData);

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\tools\uni\ctt2gtt\cttconv.c ===
/*++

Copyright (c) 1996-1997  Microsoft Corporation

Module Name:

    cttconv.c

Abstract:

    Convert Win 3.1 CTT format tables to NT's GTT spec.

Environment:

    Windows NT PostScript driver

Revision History:

--*/

#include        "precomp.h"

//
// Debug flags
//

#define SET_PRINT 0
#define SET_RIP   0

//
//   Some macro definitions.
//

#define BBITS      8                          /* Bits in a byte */
#define DWBITS     (BBITS * sizeof( DWORD ))  /* Bits in a DWORD */
#define DW_MASK    (DWBITS - 1)

//
// Local
//

BYTE ubGetAnsi(WCHAR, INT, PWCHAR, PBYTE);

//
// Conversion function
//

BOOL
BConvertCTT2GTT(
    IN     HANDLE             hHeap,
    IN     PTRANSTAB          pCTTData,
    IN     DWORD              dwCodePage,
    IN     WCHAR              wchFirst,
    IN     WCHAR              wchLast,
    IN     PBYTE              pCPSel,
    IN     PBYTE              pCPUnSel,
    IN OUT PUNI_GLYPHSETDATA *ppGlyphSetData,
    IN     DWORD              dwGlySize)
/*++

Routine Description:

    Conversion from CTT to GLYPHSETDATA

Arguments:

    hHeap - Heap handle
    pCTTData - Pointer to the 3.1 format translate table
    dwCodePage - additonal codepage
    pCPSel - symbol set selection command null terminate string.
    pCPUnsel - symbol set selection command null terminate string.
    ppGlyphSetData - Pointer to the GlyphSetData pointer

Return Value:

    If TRUE, function succeeded. Othewise FALSE.

Note:

    Allocates memory from the heap for this.

--*/
{
    UNI_CODEPAGEINFO  CodePageInfo; 
    UNI_GLYPHSETDATA  GlyphSetData;
    PGLYPHRUN         pOldGlyphRun, pOldGlyphFirst,
                      pNewGlyphRun, pNewGlyphFirst;
    PMAPTABLE         pOldMapTable, pNewMapTable;
    PUNI_CODEPAGEINFO pOldCodePageInfo;
    TRANSDATA        *pTrans;

    WCHAR             awchUnicode[ 256 ];   // Converted array of points
    WCHAR             wchMin;           /* Find the first unicode value */
    WCHAR             wchMax;           /* Find the last unicode value */
    WCHAR             wchChar;

    DWORD            *pdwBits;   /* For figuring out runs */
    DWORD             dwFlags;
    DWORD             dwOldCodePageCount;
    DWORD             dwOldCPCmdSize;
    DWORD             dwI;
    DWORD             dwcbBits;   /* Size of this area */
    DWORD             dwMapTableCommandOffset;

    WORD              wType;
    WORD              wcbData;
    WORD              wI;

    INT               iI, iJ;        // Loop index
    INT               iIndex;
    INT               iNumOfHandle;  // The number of handles we need
    INT               iNumOfHandleInCTT;  // The number of handles in CTT
    INT               iTotalOffsetCmd;
    INT               iTotalGlyphSetDataSize;
    INT               iTotalCommandSize;
    INT               iAdditionalGlyphRun;
    INT               iAdditionalMapTable;
    INT               iSizeOfSelUnsel;
    INT               iNumOfRuns;     /* Number of runs we create */

    BYTE              aubAnsi[ 256 ];
    BYTE             *pbBase;
    BYTE              ubCodePageID;
    BYTE             *pMapTableCommand;
    BYTE             *pubData;
    BYTE              ubAnsi;

    BOOL              bInRun;    /* For processing run accumulations */


#define DWFLAGS_NEWCREATION 0x00000001

    //
    // Assertion
    //

    ASSERT(hHeap != NULL && pCTTData != NULL);

    //
    // Check if this is additional CTT.
    //

    #if 0
    if (*ppGlyphSetData == 0 || dwGlySize == 0)
    {
        dwFlags = DWFLAGS_NEWCREATION;
    }
    else
    {
        dwFlags = 0;
    }
    #else
    dwFlags = DWFLAGS_NEWCREATION;
    #endif

    //
    // 1. Create UNI_GLYPHSETDATA header
    // 2. Count total size of command in CTT.
    // 3. Create Unicode table
    // 4. Get min and max Unicode value
    // 5. Create Unicode bits table from CTT.
    // 6. Count the number of run.
    // 7. Create GLYPHRUN. 
    // 8. Create UNI_CODEPAGEINFO.
    // 9. Calculate total size of this file.
    // 10. Allocate memory for header, GLYPYRUN, CODEPAGEINFO
    // 11. Create MAPTABLE
    // 

    //
    //
    // 1. Initialize basic members of GLYPHSETDATA if necessary
    //
    //
    #if SET_RIP
    RIP(("1. Initialize basic members of GLYPHSETDATA if necessary.\n"));
    #elif SET_PRINT
    printf("1. Initialize basic members of GLYPHSETDATA if necessary.\n");
    #endif

    if (dwFlags & DWFLAGS_NEWCREATION)
    {
        GlyphSetData.dwVersion        = UNI_GLYPHSETDATA_VERSION_1_0;
        GlyphSetData.dwFlags          = 0;
        GlyphSetData.lPredefinedID    = CC_NOPRECNV;
        GlyphSetData.dwGlyphCount     = 0;
        GlyphSetData.dwRunCount       = 0;
        GlyphSetData.dwCodePageCount  = 1;
        GlyphSetData.loCodePageOffset = (DWORD)0;
        GlyphSetData.loMapTableOffset = (DWORD)0;

    }
    else
    {
        GlyphSetData.dwVersion        = (*ppGlyphSetData)->dwVersion;
        GlyphSetData.dwFlags          = (*ppGlyphSetData)->dwFlags;
        GlyphSetData.lPredefinedID    = (*ppGlyphSetData)->lPredefinedID;
        GlyphSetData.dwGlyphCount     = (*ppGlyphSetData)->dwGlyphCount;
        GlyphSetData.dwRunCount       = (*ppGlyphSetData)->dwRunCount;
        GlyphSetData.dwCodePageCount  = (*ppGlyphSetData)->dwCodePageCount +
                                        1;
        GlyphSetData.loCodePageOffset = (DWORD)0;
        GlyphSetData.loMapTableOffset = (DWORD)0;

        dwOldCodePageCount = (*ppGlyphSetData)->dwCodePageCount;
        pOldGlyphFirst =
        pOldGlyphRun = (PGLYPHRUN)((PBYTE)*ppGlyphSetData+
                                 (*ppGlyphSetData)->loRunOffset);
        pOldCodePageInfo = (PUNI_CODEPAGEINFO)((PBYTE)*ppGlyphSetData+
                                 (*ppGlyphSetData)->loCodePageOffset);
        pOldMapTable = (PMAPTABLE)((PBYTE)*ppGlyphSetData + 
                                 (*ppGlyphSetData)->loMapTableOffset);
    }

    //
    // 2. Total size of WTYPE_OFFSET format command in CTT.
    //
    #if SET_RIP
    RIP(("2. Count total number of run in CTT.\n"));
    #elif SET_PRINT
    printf("2. Count total number of run in CTT.\n");
    #endif

    wchFirst = min(pCTTData->chFirstChar, wchFirst);
    wchLast  = max(pCTTData->chLastChar, wchLast);

    GlyphSetData.dwGlyphCount =
    iNumOfHandle      = wchLast - wchFirst + 1;
    iNumOfHandleInCTT =  pCTTData->chLastChar - pCTTData->chFirstChar + 1;

    switch (pCTTData->wType)
    {
    case CTT_WTYPE_COMPOSE:
        iTotalOffsetCmd = pCTTData->uCode.psCode[iNumOfHandleInCTT] -
                          pCTTData->uCode.psCode[0] +
                          iNumOfHandleInCTT * 2;
        break;
    case CTT_WTYPE_DIRECT:
        iTotalOffsetCmd = 0;
        break;

    case CTT_WTYPE_PAIRED:
        iTotalOffsetCmd = 0;
        break;
    }


    //
    //  3. Create Unicode table
    //  We need to figure out how many runs are required to describe
    //  this font.  First obtain the correct Unicode encoding of these
    //  values,  then examine them to find the number of runs, and
    //  hence much extra storage is required.
    //
    #if SET_RIP
    RIP(("3. Create Unicode table.\n"));
    #elif SET_PRINT
    printf("3. Create Unicode table.\n");
    #endif
    
    //
    // We know it is < 256
    //

    for( iI = 0; iI < iNumOfHandle; ++iI )
        aubAnsi[ iI ] = (BYTE)(iI + wchFirst);

#ifdef NTGDIKM

    if( -1 == EngMultiByteToWideChar(dwCodePage,
                                     awchUnicode,
                                     (ULONG)(iNumOfHandle * sizeof(WCHAR)),
                                     (PCH) aubAnsi,
                                     (ULONG) iNumOfHandle))
    {
        return FALSE;
    }

#else

    if( ! MultiByteToWideChar(dwCodePage,
                              0,
                              aubAnsi,
                              iNumOfHandle,
                              awchUnicode,
                              iNumOfHandle))
    {
        return FALSE;
    }

#endif

    //
    //  4. Get min and max Unicode value
    //  Find the largest Unicode value, then allocate storage to allow us
    //  to  create a bit array of valid unicode points.  Then we can
    //  examine this to determine the number of runs.
    //
    #if SET_RIP
    RIP(("4. Get min and max Unicode value.\n"));
    #elif SET_PRINT
    printf("4. Get min and max Unicode value.\n");
    #endif

    for( wchMax = 0, wchMin = 0xffff, iI = 0; iI < iNumOfHandle; ++iI )
    {
        if( awchUnicode[ iI ] > wchMax )
            wchMax = awchUnicode[ iI ];
        if( awchUnicode[ iI ] < wchMin )
            wchMin = awchUnicode[ iI ];
    }

    //
    //  5. Create Unicode bits table from CTT.
    //  Note that the expression 1 + wchMax IS correct.   This comes about
    //  from using these values as indices into the bit array,  and that
    //  this is essentially 1 based.
    //
    #if SET_RIP
    RIP(("5. Create Unicode bits table from CTT.\n"));
    #elif SET_PRINT
    printf("5. Create Unicode bits table from CTT.\n");
    #endif

    dwcbBits = (1 + wchMax + DWBITS - 1) / DWBITS * sizeof( DWORD );

    if( !(pdwBits = (DWORD *)HeapAlloc( hHeap, 0, dwcbBits )) )
    {
        return  FALSE;     /*  Nothing going */
    }

    ZeroMemory( pdwBits, dwcbBits );

    //
    //   Set bits in this array corresponding to Unicode code points
    //

    for( iI = 0; iI < iNumOfHandle; ++iI )
    {
        pdwBits[ awchUnicode[ iI ] / DWBITS ] 
                    |= (1 << (awchUnicode[ iI ] & DW_MASK));
    }

    //
    //
    // 6. Count the number of run.
    //
    //
    #if SET_RIP
    RIP(("6. Count the number of run.\n"));
    #elif SET_PRINT
    printf("6. Count the number of run.\n");
    #endif

    if (dwFlags & DWFLAGS_NEWCREATION)
    {
        //
        //  Now we can examine the number of runs required.  For starters,
        //  we stop a run whenever a hole is discovered in the array of 1
        //  bits we just created.  Later we MIGHT consider being a little
        //  less pedantic.
        //

        bInRun = FALSE;
        iNumOfRuns = 0;

        for( iI = 0; iI <= (INT)wchMax; ++iI )
        {
            if( pdwBits[ iI / DWBITS ] & (1 << (iI & DW_MASK)) )
            {
                /*   Not in a run: is this the end of one? */
                if( !bInRun )
                {
                    /*   It's time to start one */
                    bInRun = TRUE;
                    ++iNumOfRuns;

                }

            }
            else
            {
                if( bInRun )
                {
                    /*   Not any more!  */
                    bInRun = FALSE;
                }
            }
        }

        GlyphSetData.dwRunCount = iNumOfRuns;

    }
    else
    {
        //
        // CTT addition case
        //

        iNumOfRuns = (*ppGlyphSetData)->dwRunCount;

        //
        // Merge CTT and GlyphRun
        //

        for (iI = 0; iI < iNumOfRuns; iI ++)
        {
            for (iJ = 0; iJ < pOldGlyphRun->wGlyphCount; iJ ++)
            {
                INT iGlyph = iJ + pOldGlyphRun->wcLow;

                pdwBits[ iGlyph / DWBITS ] |= (1 << (iGlyph & DW_MASK));
            }

            pOldGlyphRun++;
        }

        bInRun = FALSE;
        iNumOfRuns = 0;
        iNumOfHandle = 0;

        for( iI = 0; iI <= (INT)wchMax; ++iI )
        {
            if( pdwBits[ iI / DWBITS ] & (1 << (iI & DW_MASK)) )
            {
                /*   Not in a run: is this the end of one? */
                if( !bInRun )
                {
                    /*   It's time to start one */
                    bInRun = TRUE;
                    ++iNumOfRuns;

                }
                iNumOfHandle ++;

            }
            else
            {
                if( bInRun )
                {
                    /*   Not any more!  */
                    bInRun = FALSE;
                }
            }
        }
    }

    //
    // 7. Create GLYPHRUN
    //
    #if SET_RIP
    RIP(("7. Create GLYPHRUN.\n"));
    #elif SET_PRINT
    printf("7. Create GLYPHRUN.\n");
    #endif

    if( !(pNewGlyphFirst = pNewGlyphRun = 
        (PGLYPHRUN)HeapAlloc( hHeap, 0, iNumOfRuns * sizeof(GLYPHRUN) )) )
    {
        return  FALSE;     /*  Nothing going */
    }

    bInRun = FALSE;

    for (wI = 0; wI <= wchMax; wI ++)
    {
        if (pdwBits[ wI / DWBITS ] & (1 << (wI  & DW_MASK)) )
        {
            if (!bInRun)
            {
                bInRun = TRUE;
                pNewGlyphRun->wcLow = wI ;
                pNewGlyphRun->wGlyphCount = 1;
            }
            else
            {
                pNewGlyphRun->wGlyphCount++;
            }
        }
        else
        {

            if (bInRun)
            {
                bInRun = FALSE;
                pNewGlyphRun++;
            }
        }
    }


    pNewGlyphRun = pNewGlyphFirst;

    //
    //
    // 8. Create UNI_CODEPAGEINFO.
    //
    //
    #if SET_RIP
    RIP(("8. Create UNI_CODEPAGEINFO.\n"));
    #elif SET_PRINT
    printf("8. Create UNI_CODEPAGEINFO.\n");
    #endif

    CodePageInfo.dwCodePage              = dwCodePage;

    if (pCPSel)
    {
        CodePageInfo.SelectSymbolSet.dwCount = strlen(pCPSel) + 1;
    }
    else
    {
        CodePageInfo.SelectSymbolSet.dwCount = 0;
    }

    if (pCPUnSel)
    {
        CodePageInfo.UnSelectSymbolSet.dwCount = strlen(pCPUnSel) + 1;
    }
    else
    {
        CodePageInfo.UnSelectSymbolSet.dwCount = 0;
    }

    if (dwFlags & DWFLAGS_NEWCREATION)
    {
        if (pCPSel)
        {
            CodePageInfo.SelectSymbolSet.loOffset = sizeof(UNI_CODEPAGEINFO);
        }
        else
        {
            CodePageInfo.SelectSymbolSet.loOffset = 0;
        }
        if (pCPUnSel)
        {
            CodePageInfo.UnSelectSymbolSet.loOffset = sizeof(UNI_CODEPAGEINFO) +
                                         CodePageInfo.SelectSymbolSet.dwCount;
        }
        else
        {
            CodePageInfo.UnSelectSymbolSet.loOffset = 0;
        }
    }
    else
    {

        dwOldCPCmdSize = 0;

        for (dwI = 0; dwI < dwOldCodePageCount; dwI++)
        {
            dwOldCPCmdSize += (pOldCodePageInfo+dwI)->SelectSymbolSet.dwCount +
                              (pOldCodePageInfo+dwI)->UnSelectSymbolSet.dwCount;
            (pOldCodePageInfo+dwI)->SelectSymbolSet.loOffset +=
                                                       sizeof(UNI_CODEPAGEINFO);
            (pOldCodePageInfo+dwI)->UnSelectSymbolSet.loOffset +=
                                                       sizeof(UNI_CODEPAGEINFO);
        }

        CodePageInfo.SelectSymbolSet.loOffset =
                                    sizeof(UNI_CODEPAGEINFO) +
                                    dwOldCPCmdSize;
        CodePageInfo.UnSelectSymbolSet.loOffset =
                                    sizeof(UNI_CODEPAGEINFO) +
                                    dwOldCPCmdSize +
                                    CodePageInfo.SelectSymbolSet.dwCount; 
    }

    //
    //
    // 9. Calculate total size of this file.
    //
    //
    #if SET_RIP
    RIP(("9. Calculate total size of this file.\n"));
    #elif SET_PRINT
    printf("9. Calculate total size of this file.\n");
    #endif

    iSizeOfSelUnsel = CodePageInfo.SelectSymbolSet.dwCount +
                      CodePageInfo.UnSelectSymbolSet.dwCount;

    if (dwFlags & DWFLAGS_NEWCREATION)
    {

        iTotalGlyphSetDataSize = sizeof(UNI_GLYPHSETDATA) +
                                 sizeof(UNI_CODEPAGEINFO) +
                                 iSizeOfSelUnsel +
                                 iNumOfRuns * sizeof( GLYPHRUN ) +
                                 sizeof(MAPTABLE) +
                                 (iNumOfHandle - 1) * sizeof(TRANSDATA) +
                                 iTotalOffsetCmd;
    }
    else
    {
        iTotalGlyphSetDataSize = sizeof(UNI_GLYPHSETDATA) +
                                 dwOldCodePageCount * sizeof(UNI_CODEPAGEINFO) +
                                 sizeof(UNI_CODEPAGEINFO) +
                                 dwOldCPCmdSize + 
                                 iSizeOfSelUnsel +
                                 iNumOfRuns * sizeof( GLYPHRUN ) +
                                 sizeof(MAPTABLE) +
                                 (iNumOfHandle - 1) * sizeof(TRANSDATA);
    }

    //
    //
    // 10. Allocate memory and set header, copy GLYPHRUN, CODEPAGEINFO
    //
    //
    #if SET_RIP
    RIP(("10. Allocate memory and set header, copy GLYPHRUN, CODEPAGEINFO.\n"));
    #elif SET_PRINT
    printf("10. Allocate memory and set header, copy GLYPHRUN, CODEPAGEINFO.\n");
    #endif

    if( !(pbBase = HeapAlloc( hHeap, 0, iTotalGlyphSetDataSize )) )
    {
        HeapFree( hHeap, 0, (LPSTR)pbBase );
        return  FALSE;
    }


    ZeroMemory( pbBase, iTotalGlyphSetDataSize );  //Safer if we miss something

    if (dwFlags & DWFLAGS_NEWCREATION)
    {
        GlyphSetData.dwSize           = iTotalGlyphSetDataSize;
        GlyphSetData.loRunOffset      = sizeof(UNI_GLYPHSETDATA);
        GlyphSetData.loCodePageOffset = sizeof(UNI_GLYPHSETDATA) +
                                        sizeof(GLYPHRUN) * iNumOfRuns;
        GlyphSetData.loMapTableOffset = sizeof(UNI_GLYPHSETDATA) +
                                        sizeof(GLYPHRUN) * iNumOfRuns +
                                        sizeof(UNI_CODEPAGEINFO) +
                                        CodePageInfo.SelectSymbolSet.dwCount +
                                        CodePageInfo.UnSelectSymbolSet.dwCount;
        CopyMemory(pbBase,
                   &GlyphSetData,
                   sizeof(UNI_GLYPHSETDATA));

        CopyMemory(pbBase+sizeof(UNI_GLYPHSETDATA),
                   pNewGlyphRun,
                   sizeof(GLYPHRUN) * iNumOfRuns);


        CopyMemory(pbBase +
                   GlyphSetData.loCodePageOffset,
                   &CodePageInfo,
                   sizeof(UNI_CODEPAGEINFO));

        if (pCPSel)
        {
            CopyMemory(pbBase +
                       GlyphSetData.loCodePageOffset +
                       sizeof(UNI_CODEPAGEINFO),
                       pCPSel,
                       CodePageInfo.SelectSymbolSet.dwCount);
        }

        if (pCPUnSel)
        {
            CopyMemory(pbBase +
                       GlyphSetData.loCodePageOffset +
                       sizeof(UNI_CODEPAGEINFO) +
                       CodePageInfo.SelectSymbolSet.dwCount,
                       pCPUnSel,
                   CodePageInfo.UnSelectSymbolSet.dwCount);
        }

        pNewMapTable = (PMAPTABLE)(pbBase + GlyphSetData.loMapTableOffset);
                                            
    }
    else
    {
        GlyphSetData.dwSize           = iTotalGlyphSetDataSize;
        GlyphSetData.loRunOffset      = sizeof(UNI_GLYPHSETDATA);
        GlyphSetData.loCodePageOffset = sizeof(UNI_GLYPHSETDATA) +
                                        sizeof(GLYPHRUN) * iNumOfRuns;
        GlyphSetData.loMapTableOffset = sizeof(UNI_GLYPHSETDATA) +
                                        sizeof(GLYPHRUN) * iNumOfRuns +
                                        sizeof(UNI_CODEPAGEINFO) *
                                        (dwOldCodePageCount + 1),
                                        dwOldCPCmdSize +
                                        CodePageInfo.SelectSymbolSet.dwCount +
                                        CodePageInfo.UnSelectSymbolSet.dwCount;

        CopyMemory(pbBase, &GlyphSetData, sizeof(UNI_GLYPHSETDATA));

        CopyMemory(pbBase + sizeof(UNI_GLYPHSETDATA),
                   pNewGlyphRun,
                   iNumOfRuns * sizeof (GLYPHRUN));

        CopyMemory(pbBase +
                   sizeof(UNI_GLYPHSETDATA) +
                   sizeof(GLYPHRUN) * iNumOfRuns,
                   pOldCodePageInfo,
                   sizeof(UNI_CODEPAGEINFO) * dwOldCodePageCount);

        CopyMemory(pbBase +
                   sizeof(UNI_GLYPHSETDATA) +
                   sizeof(GLYPHRUN) * iNumOfRuns +
                   sizeof(UNI_CODEPAGEINFO) * dwOldCodePageCount,
                   &CodePageInfo,
                   sizeof(UNI_CODEPAGEINFO));

        CopyMemory(pbBase +
                   sizeof(UNI_GLYPHSETDATA) +
                   sizeof(GLYPHRUN) * iNumOfRuns +
                   sizeof(UNI_CODEPAGEINFO) * (dwOldCodePageCount + 1),
                   (PBYTE)pOldCodePageInfo +
                   sizeof(UNI_CODEPAGEINFO) * dwOldCodePageCount,
                   dwOldCPCmdSize);

        if (pCPSel)
        {
            CopyMemory(pbBase +
                       sizeof(UNI_GLYPHSETDATA) +
                       sizeof(GLYPHRUN) * iNumOfRuns +
                       sizeof(UNI_CODEPAGEINFO) * (dwOldCodePageCount + 1) +
                       dwOldCPCmdSize,
                       pCPSel,
                       CodePageInfo.SelectSymbolSet.dwCount);
        }

        if (pCPUnSel)
        {
            CopyMemory(pbBase +
                       sizeof(UNI_GLYPHSETDATA) +
                       sizeof(GLYPHRUN)*iNumOfRuns +
                       sizeof(UNI_CODEPAGEINFO) * (dwOldCodePageCount + 1) +
                       dwOldCPCmdSize + CodePageInfo.SelectSymbolSet.dwCount,
                       pCPUnSel,
                       CodePageInfo.UnSelectSymbolSet.dwCount);
        }

        pNewMapTable = (PMAPTABLE)(pbBase + GlyphSetData.loMapTableOffset);
    }

    //
    //
    // 11. Now we create MAPTABLE.
    // size = MAPTABLE + (number of glyph - 1) x TRANSDATA
    //
    //
    #if SET_RIP
    RIP(("11. Now We create MAPTABLE.\n"));
    #elif SET_PRINT
    printf("11. Now We create MAPTABLE.\n");
    #endif

    pNewMapTable->dwSize = sizeof(MAPTABLE) +
                           (iNumOfHandle - 1) * sizeof(TRANSDATA) +
                           iTotalOffsetCmd;

    pNewMapTable->dwGlyphNum =  iNumOfHandle;

    pNewGlyphRun = pNewGlyphFirst;

    pTrans = pNewMapTable->Trans;

    if (dwFlags & DWFLAGS_NEWCREATION)
        ubCodePageID = 0;
    else
        ubCodePageID = (BYTE)((*ppGlyphSetData)->dwCodePageCount) - 1; 

    pMapTableCommand = (PBYTE)&(pNewMapTable->Trans[iNumOfHandle]);
    dwMapTableCommandOffset = sizeof(MAPTABLE) + 
                        (iNumOfHandle - 1) * sizeof(TRANSDATA);

    iTotalCommandSize = 0;
    iIndex = 0;

    for( iI = 0;  iI < iNumOfRuns; iI ++, pNewGlyphRun ++)
    {
        for( iJ = 0;  iJ < pNewGlyphRun->wGlyphCount; iJ ++)
        {
            wchChar = pNewGlyphRun->wcLow + iJ;

            ubAnsi = ubGetAnsi(wchChar, iNumOfHandle, awchUnicode, aubAnsi);
            
            if( ubAnsi >= pCTTData->chFirstChar &&
                ubAnsi <= pCTTData->chLastChar   )
            {
                BYTE   chTemp;

                chTemp = ubAnsi - pCTTData->chFirstChar;

                switch( pCTTData->wType )
                {
                case  CTT_WTYPE_DIRECT:
                    pTrans[iIndex].ubCodePageID = ubCodePageID;
                    pTrans[iIndex].ubType = MTYPE_DIRECT;
                    pTrans[iIndex].uCode.ubCode = 
                                      pCTTData->uCode.bCode[ chTemp ];
                    break;

                case  CTT_WTYPE_PAIRED:
                    pTrans[iIndex].ubCodePageID = ubCodePageID;
                    pTrans[iIndex].ubType = MTYPE_PAIRED;
                    pTrans[iIndex].uCode.ubPairs[0] = 
                                pCTTData->uCode.bPairs[ chTemp ][ 0 ];
                    pTrans[iIndex].uCode.ubPairs[1] = 
                                pCTTData->uCode.bPairs[ chTemp ][ 1 ];
                    break;

                case  CTT_WTYPE_COMPOSE:
                    wcbData = pCTTData->uCode.psCode[ chTemp + 1 ] -
                              pCTTData->uCode.psCode[ chTemp ];
                    pubData = (BYTE *)pCTTData +
                              pCTTData->uCode.psCode[chTemp];

                    pTrans[iIndex].ubCodePageID = ubCodePageID;
                    pTrans[iIndex].ubType       = MTYPE_COMPOSE;
                    pTrans[iIndex].uCode.sCode = (SHORT)dwMapTableCommandOffset;

                    #if SET_PRINT
                    {
                    DWORD dwK;

                    printf("ubAnsi  = 0x%x\n", ubAnsi);
                    printf("Offset  = 0x%x\n", dwMapTableCommandOffset);
                    printf("Size    = %d\n", wcbData);
                    printf("Command = ");
                    for (dwK = 0; dwK < wcbData; dwK ++)
                    {
                        printf("%02x", pubData[dwK]);
                    }
                    }
                    printf("\n");
                    #endif

                    *(WORD*)pMapTableCommand = (WORD)wcbData;
                    pMapTableCommand += 2;
                    CopyMemory(pMapTableCommand, pubData, wcbData);
                    pMapTableCommand += wcbData;
                    dwMapTableCommandOffset += 2 + wcbData;
                    iTotalCommandSize += wcbData + 2;
                    break;
                }
            }
            else
            {
                pTrans[iIndex].ubCodePageID = ubCodePageID;
                pTrans[iIndex].ubType = MTYPE_DIRECT;
                pTrans[iIndex].uCode.ubCode = ubAnsi;
            }

            iIndex++;
        }
    }

    //
    //
    // Set pointer.
    //
    //

    *ppGlyphSetData = (PUNI_GLYPHSETDATA)pbBase;

    return  TRUE;

}

BYTE
ubGetAnsi(
    WCHAR wchChar,
    INT   iNumOfHandle,
    PWCHAR pwchUnicode,
    PBYTE  pchAnsi)
{

    BYTE ubRet;
    INT iI;

    for (iI = 0; iI < iNumOfHandle; iI ++)
    {
        if (wchChar == pwchUnicode[iI])
        {
            ubRet =  pchAnsi[iI];
            break;
        }
    }

    return ubRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\tools\uni\ctt2gtt\precomp.h ===
/*++

Copyright (c) 1996-1997  Microsoft Corporation

Module Name:

    precomp.h

Abstract:

    CTT to UNI_GLYPHSETDATA conversion tool precompile header.
    All other header files should be included in this precompiled header.

Environment:

    Windows NT printer drivers

Revision History:

    11/01/96 -eigos-
        Created it.

--*/


#ifndef _PRECOMP_H_
#define _PRECOMP_H_

#include        <lib.h>
#include        <win30def.h>
#include        <uni16gpc.h>
#include        <uni16res.h>
#include        <prntfont.h>
#include        <unilib.h>

#include        "local.h"
#include        "fmlib.h"

#endif // _PRECOMP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\tools\uexts\unifont.cxx ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    unifont.c

Abstract:

    Dump UNIDRV font module's device data structure

Environment:

    Windows NT printer drivers

Revision History:

    03/31/97 -eigos-
        Created it.

--*/

#include "precomp.hxx"
#include "unidrv2\inc\pdev.h"

#include "winnls.h"
#include "unilib.h"

//
// UNIDRV resource ID
//

#include "unirc.h"

//
// Font resource format
//
#include <prntfont.h>
#include "unidrv2\inc\fmoldrle.h"

//
// GPC and GPD header
//

#include "unidrv2\inc\uni16res.h"

//
// Internal resource data format
//

#include "unidrv2\inc\palette.h"
#include "unidrv2\inc\fontif.h"
#include "unidrv2\font\fmcallbk.h"
#include "unidrv2\font\fmtxtout.h"
#include "unidrv2\font\fontmap.h"
#include "unidrv2\font\fontpdev.h"
#include "unidrv2\font\download.h"
#include "unidrv2\font\posnsort.h"
#include "unidrv2\font\sfinst.h"

#include "unidrv2\font\fmfnprot.h"
#include "unidrv2\font\fmdevice.h"
#include "unidrv2\font\sfttpcl.h"

//
// Misc
//

#include "unidrv2\font\fmmacro.h"
#include "unidrv2\font\fmdebug.h"

//
//
// UNIDRV FONTPDEV
//
//

DEBUG_FLAGS gafdPDEVflFlags[] = {
    { "FDV_ROTATE_FONT_ABLE", FDV_ROTATE_FONT_ABLE},
    { "FDV_ALIGN_BASELINE",   FDV_ALIGN_BASELINE},
    { "FDV_TT_FS_ENABLED",    FDV_TT_FS_ENABLED},
    { "FDV_DL_INCREMENTAL",   FDV_DL_INCREMENTAL},
    { "FDV_TRACK_FONT_MEM",   FDV_TRACK_FONT_MEM},
    { "FDV_WHITE_TEXT",       FDV_WHITE_TEXT},
    { "FDV_DLTT",             FDV_DLTT},
    { "FDV_DLTT_ASTT_PREF",   FDV_DLTT_ASTT_PREF},
    { "FDV_DLTT_BITM_PR EF",  FDV_DLTT_BITM_PREF},
    { "FDV_DLTT_OEMCALLBACK", FDV_DLTT_OEMCALLBACK},
    { "FDV_MD_SERIAL",        FDV_MD_SERIAL},
    { "FDV_GRX_ON_TXT_BAND",  FDV_GRX_ON_TXT_BAND},
    { "FDV_GRX_UNDER_TEXT",   FDV_GRX_UNDER_TEXT},
    { "FDV_BKSP_OK",          FDV_BKSP_OK},
    { "FDV_90DEG_ROTATION",   FDV_90DEG_ROTATION},
    { "FDV_ANYDEG_ROTATION",  FDV_ANYDEG_ROTATION},
    { "FDV_SUPPORTS_FGCOLOR", FDV_SUPPORTS_FGCOLOR},
    { "FDV_SUBSTITUTE_TT",    FDV_SUBSTITUTE_TT},
    { "FDV_SINGLE_BYTE",      FDV_SINGLE_BYTE},
    { "FDV_DOUBLE_BYTE",      FDV_DOUBLE_BYTE},
    { NULL,0}
};

DEBUG_FLAGS gafdFONTMAPflFlags[] = {
    {"FM_SCALABLE", FM_SCALABLE},
    {"FM_DEFAULT", FM_DEFAULT},
    {"FM_EXTCART", FM_EXTCART},
    {"FM_FREE_GLYDATA", FM_FREE_GLYDATA},
    {"FM_FONTCMD", FM_FONTCMD},
    {"FM_WIDTHRES", FM_WIDTHRES},
    {"FM_IFIRES", FM_IFIRES},
    {"FM_KERNRES", FM_KERNRES},
    {"FM_IFIVER40", FM_IFIVER40},
    {"FM_GLYVER40", FM_GLYVER40},
    {"FM_FINVOC", FM_FINVOC},
    {"FM_SOFTFONT", FM_SOFTFONT},
    {"FM_GEN_SFONT", FM_GEN_SFONT},
    {"FM_SENT", FM_SENT},
    {"FM_TT_BOUND", FM_TT_BOUND},
    {"FM_TO_PROP", FM_TO_PROP},
    {"FM_EXTERNAL", FM_EXTERNAL},
    { NULL, 0}
};

DEBUG_FLAGS gafdPDEVflText[] = {
    {"TC_OP_CHARACTER", TC_OP_CHARACTER},
    {"TC_OP_STROKE", TC_OP_STROKE },
    {"TC_CP_STROKE", TC_CP_STROKE },
    {"TC_CR_90", TC_CR_90 },
    {"TC_CR_ANY", TC_CR_ANY },
    {"TC_SF_X_YINDEP", TC_SF_X_YINDEP},
    {"TC_SA_DOUBLE", TC_SA_DOUBLE},
    {"TC_SA_INTEGER", TC_SA_INTEGER},
    {"TC_SA_CONTIN", TC_SA_CONTIN},
    {"TC_EA_DOUBLE", TC_EA_DOUBLE},
    {"TC_IA_ABLE", TC_IA_ABLE},
    {"TC_UA_ABLE", TC_UA_ABLE},
    {"TC_SO_ABLE", TC_SO_ABLE},
    {"TC_RA_ABLE", TC_RA_ABLE},
    {"TC_VA_ABLE", TC_VA_ABLE},
    {"TC_RESERVED", TC_RESERVED},
    {"TC_SCROLLBLT", TC_SCROLLBLT},
    { NULL, 0}
};

DEBUG_FLAGS gafdSTROflAccel[] = {
    { "SO_FLAG_DEFAULT_PLACEMENT", SO_FLAG_DEFAULT_PLACEMENT},
    { "SO_HORIZONTAL",             SO_HORIZONTAL},
    { "SO_VERTICAL",               SO_VERTICAL},
    { "SO_REVERSED",               SO_REVERSED},
    { "SO_ZERO_BEARINGS",          SO_ZERO_BEARINGS},
    { "SO_MAXEXT_EQUAL_BM_SIDE",   SO_MAXEXT_EQUAL_BM_SIDE},
    { NULL,0}
};

DEBUG_FLAGS gafdFontAttr[] = {
    { "FONTATTR_BOLD",     FONTATTR_BOLD},
    { "FONTATTR_ITALIC",   FONTATTR_ITALIC},
    { "FONTATTR_UNDERLINE",FONTATTR_UNDERLINE},
    { "FONTATTR_STRIKEOUT",FONTATTR_STRIKEOUT},
    { "FONTATTR_SUBSTFONT",FONTATTR_SUBSTFONT},
    { NULL,0}
};

BOOL
TDebugExt::
bDumpFONTPDev(
    PVOID    pFontPDev_,
    DWORD     dwAttr)
{
    DEBUG_FLAGS *pfd;
    PFONTPDEV pFontPDev = (PFONTPDEV)pFontPDev_;

    Print("\nUNIDRV font pdev data (%x):\n", pFontPDev);
    if (pFontPDev->dwSignature != FONTPDEV_ID)
    {
        Print("*** invalid unidrv font device data\n");
        return FALSE;
    }

    DumpHex(pFontPDev, dwSignature);
    DumpHex(pFontPDev, dwSize);
    DumpHex(pFontPDev, pPDev);
    DumpHex(pFontPDev, flFlags);
    vDumpFlags(pFontPDev->flFlags, gafdPDEVflFlags);
    DumpHex(pFontPDev, flText);
    vDumpFlags(pFontPDev->flText, gafdPDEVflText);
    DumpInt(pFontPDev, dwFontMem);
    DumpInt(pFontPDev, dwFontMemUsed);
    DumpInt(pFontPDev, dwSelBits);
    DumpInt(pFontPDev, ptTextScale.x);
    DumpInt(pFontPDev, ptTextScale.y);
    DumpInt(pFontPDev, iUsedSoftFonts);
    DumpInt(pFontPDev, iNextSFIndex);
    DumpInt(pFontPDev, iFirstSFIndex);
    DumpInt(pFontPDev, iLastSFIndex);
    DumpInt(pFontPDev, iMaxSoftFonts);
    DumpInt(pFontPDev, iDevResFontsCt);
    DumpInt(pFontPDev, iSoftFontsCt);
    DumpInt(pFontPDev, iCurXFont);
    DumpInt(pFontPDev, iWhiteIndex);
    DumpInt(pFontPDev, iBlackIndex);
    DumpInt(pFontPDev, dwDefaultFont);
    DumpInt(pFontPDev, sDefCTT);
    DumpHex(pFontPDev, pso);
    DumpHex(pFontPDev, pPSHeader);
    DumpHex(pFontPDev, pvWhiteTextFirst);
    DumpHex(pFontPDev, pvWhiteTextLast);
    DumpHex(pFontPDev, pTTFile);
    DumpHex(pFontPDev, ptod);
    DumpHex(pFontPDev, pFontMap);
    DumpHex(pFontPDev, pFMDefault);
    DumpHex(pFontPDev, pvDLMap);
    DumpRec(pFontPDev, FontList);
    DumpRec(pFontPDev, FontCartInfo);
    DumpRec(pFontPDev, ctl);
    DumpHex(pFontPDev, pIFI);
    DumpHex(pFontPDev, hUFFFile);
    DumpHex(pFontPDev, pTTFontSubReg);
    DumpHex(pFontPDev, pUFObj);

    return TRUE;
}


DEBUG_EXT_ENTRY(fpdev, FONTPDEV, bDumpFONTPDev, NULL, FALSE );

//*******************************************************************************

BOOL
TDebugExt::
bDumpFONTMAP(
    PVOID     pFontMap_,
    DWORD     dwAttr)
{
    PFONTMAP pFontMap = (PFONTMAP)pFontMap_;
    WCHAR  *pwstrFontType[4] = { L"FMTYPE_DEVICE",
                                 L"FMTYPE_TTBITMAP",
	 L"FMTYPE_TTOUTLINE",
	 L"FMTYPE_TTOEM"};

    Print("\nFONTMAP(%x):\n", pFontMap);
    if (pFontMap->dwSignature != FONTMAP_ID)
    {
        Print("\nBroken fontmap\n");
        return FALSE;
    }

    DumpInt(pFontMap, dwSize);
    DumpInt(pFontMap, dwFontType);
    Print("  FontType: %ws\n", pwstrFontType[pFontMap->dwFontType - 1]);
    DumpInt(pFontMap, flFlags);
    vDumpFlags(pFontMap->flFlags, gafdFONTMAPflFlags);
    DumpHex(pFontMap, pIFIMet);
    DumpHex(pFontMap, wFirstChar);
    DumpHex(pFontMap, wLastChar);
    DumpInt(pFontMap, ulDLIndex);
    DumpInt(pFontMap, wXRes);
    DumpInt(pFontMap, wYRes);
    DumpInt(pFontMap, syAdj);
    DumpHex(pFontMap, pSubFM);
    DumpHex(pFontMap, pfnGlyphOut);
    DumpHex(pFontMap, pfnSelectFont);
    DumpHex(pFontMap, pfnDeSelectFont);
    DumpHex(pFontMap, pfnDownloadFontHeader);
    DumpHex(pFontMap, pfnDownloadGlyph);
    DumpHex(pFontMap, pfnCheckCondition);
    DumpHex(pFontMap, pfnFreePFM);

    return TRUE;
}

DEBUG_EXT_ENTRY(fm, FONTMAP, bDumpFONTMAP, NULL, FALSE );

//*******************************************************************************

WCHAR *pwstrDevFontType[] = {
    L"DF_TYPE_HPINTELLIFONT",
    L"DF_TYPE_TRUETYPE",
    L"DF_TYPE_PST1",
    L"DF_TYPE_CAPSL",
    L"DF_TYPE_OEM1",
    L"DF_TYPE_OEM2" };

BOOL
TDebugExt::
bDumpDEVFM(
    PVOID pDevFM_,
    DWORD dwAttr)
{
    PFONTMAP_DEV pDevFM = (PFONTMAP_DEV)pDevFM_;
    Print("\nFONTMAP_DEV(%x):\n", pDevFM);

    DumpInt(pDevFM, wDevFontType);
    Print("  Device Font Type: %ws\n", pwstrDevFontType[pDevFM->wDevFontType]);
    DumpInt(pDevFM, dwResID);
    DumpInt(pDevFM, sCTTid);
    DumpInt(pDevFM, sYAdjust);
    DumpInt(pDevFM, sYMoved);
    DumpHex(pDevFM, pETM);
    DumpInt(pDevFM, fwdFOAveCharWidth);
    DumpInt(pDevFM, fwdFOUnitsPerEm);
    DumpInt(pDevFM, ulCodepage);
    DumpInt(pDevFM, ulCodepageID);
    DumpHex(pDevFM, pUCTree);
    DumpHex(pDevFM, pUCKernTree);
    DumpHex(pDevFM, pvMapTable);
    DumpHex(pDevFM, pFontDir);
    DumpHex(pDevFM, pfnDevSelFont);
    DumpHex(pDevFM, pvNTGlyph);
    DumpHex(pDevFM, pvFontRes);
    DumpHex(pDevFM, pvPredefGTT);
    DumpOffset(pDevFM, W);
    DumpOffset(pDevFM, cmdFontSel);
    DumpOffset(pDevFM, cmdFontDesel);
    return TRUE;
}
DEBUG_EXT_ENTRY(devfm, FONTMAP_DEV, bDumpDEVFM, NULL, FALSE );


//*******************************************************************************

BOOL
TDebugExt::
bDumpTOD(
    PVOID    pTod_,
    DWORD    dwAttr)
{
    PTO_DATA pTod = (PTO_DATA)pTod_;
    Print("\nTO_DATA(%x):\n", pTod);

    DumpHex(pTod, pPDev);
    DumpHex(pTod, pfm);
    DumpHex(pTod, pfo);
    DumpHex(pTod, flAccel);
    vDumpFlags(pTod->flAccel, gafdSTROflAccel);
    DumpHex(pTod, pgp);
    DumpHex(pTod, apdlGlyph);
    DumpHex(pTod, phGlyph);
    DumpHex(pTod, pwt);
    DumpHex(pTod, pvColor);
    DumpInt(pTod, cGlyphsToPrint);
    DumpInt(pTod, dwCurrGlyph);
    DumpInt(pTod, iFace);
    DumpInt(pTod, iSubstFace);
    DumpHex(pTod, dwAttrFlags);
    DumpHex(pTod, flFlags);
    DumpHex(pTod, ptlFirstGlyph);

    return TRUE;
}

DEBUG_EXT_ENTRY(tod, TO_DATA, bDumpTOD, NULL, FALSE );


//*******************************************************************************

BOOL
TDebugExt::
bDumpWT(
    PVOID      pWT_,
    DWORD      dwAttr)
{
    PWHITETEXT pWT = (PWHITETEXT)pWT_;
    Print("\n WHITETEXT(%x):\n", pWT);

    DumpHex(pWT, next);
    DumpInt(pWT, sCount);
    DumpHex(pWT, pvColor);
    DumpInt(pWT, iFontId);
    DumpHex(pWT, dwAttrFlags);
    DumpHex(pWT, flAccel);
    vDumpFlags(pWT->flAccel, gafdSTROflAccel);
    DumpHex(pWT, pgp);
    DumpInt(pWT, iRot);
    DumpOffset(pWT, eXScale);
    DumpOffset(pWT, eYScale);
    DumpRectl(pWT, rcClipRgn);

    return TRUE;
}

DEBUG_EXT_ENTRY(wt, WHITETEXT, bDumpWT, NULL, FALSE );

//*******************************************************************************

DEBUG_FLAGS gafdUFOdwFlags[] = {
    {"UFOFLAG_TTFONT",UFOFLAG_TTFONT},
    {"UFOFLAG_TTDOWNLOAD_BITMAP",UFOFLAG_TTDOWNLOAD_BITMAP},
    {"UFOFLAG_TTDOWNLOAD_TTOUTLINE",UFOFLAG_TTDOWNLOAD_TTOUTLINE},
    { NULL, 0}
};

BOOL
TDebugExt::
bDumpUFO(
    PVOID      pUFObj_,
    DWORD      dwAttr)
{
    PI_UNIFONTOBJ pUFObj = (PI_UNIFONTOBJ)pUFObj_;
    Print("\nUNIFONTOBJ (%x):\n", pUFObj);

    DumpInt(pUFObj, ulFontID);
    DumpHex(pUFObj, dwFlags);
    vDumpFlags(pUFObj->dwFlags, gafdUFOdwFlags);
    DumpHex(pUFObj, pIFIMetrics);
    DumpHex(pUFObj, pfnGetInfo);
    DumpHex(pUFObj, pFontObj);
    DumpHex(pUFObj, pStrObj);
    DumpHex(pUFObj, pFontMap);
    DumpHex(pUFObj, pPDev);
    DumpHex(pUFObj, ptGrxRes);
    DumpHex(pUFObj, pGlyph);
    DumpHex(pUFObj, apdlGlyph);
    DumpHex(pUFObj, dwNumInGlyphTbl);

    return TRUE;
}

DEBUG_EXT_ENTRY(ufo, I_UNIFONTOBJ, bDumpUFO, NULL, FALSE );


//*******************************************************************************

DEBUG_FLAGS gafdDLMwFlags[] = {
    {"DLM_BOUNDED", DLM_BOUNDED},
    {"DLM_UNBOUNDED",DLM_UNBOUNDED},
    { NULL, 0}
};

BOOL
TDebugExt::
bDumpDLMap(
    PVOID      pDLM_,
    DWORD      dwAttr)
{
    PDL_MAP pDLM = (PDL_MAP)pDLM_;
    Print("\nDL_MAP (%x):\n", pDLM);

    DumpInt(pDLM, iUniq);
    DumpInt(pDLM, iTTUniq);
    DumpInt(pDLM, cGlyphs);
    DumpInt(pDLM, cTotalGlyphs);
    DumpInt(pDLM, wMaxGlyphSize);
    DumpInt(pDLM, cHashTableEntries);
    DumpInt(pDLM, wFirstDLGId);
    DumpInt(pDLM, wLastDLGId);
    DumpInt(pDLM, wNextDLGId);
    DumpInt(pDLM, wBaseDLFontid);
    DumpInt(pDLM, wCurrFontId);
    DumpInt(pDLM, wFlags);
    vDumpFlags(pDLM->wFlags, gafdDLMwFlags);
    DumpHex(pDLM, pfm);
    DumpHex(pDLM, GlyphTab.pGLTNext);
    DumpHex(pDLM, GlyphTab.pGlyph);
    DumpInt(pDLM, GlyphTab.cEntries);

    return TRUE;
}

DEBUG_EXT_ENTRY(dlm, DL_MAP, bDumpDLMap, NULL, FALSE );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\tools\uni\ctt2gtt\cpinfo.c ===
/*++

Copyright (c) 1996-1997  Microsoft Corporation

Module Name:

    cpinfo.c

Abstract:

    Copepage information handling.
    Extract codepage information from codepage text file.

Environment:

    Windows NT PostScript driver

Revision History:

--*/

#include        "precomp.h"

//
// Macros
//

#define IS_COMMENT(c)  ((c) == (BYTE)';')
#define EOL    '\n'

//
// Local function prototypes
//

PBYTE PubSkipComment( PBYTE );
INT IGetCommand(PBYTE, PBYTE);


//
// Main function
//

BOOL
BGetInfo(
    PBYTE pData,
    DWORD dwSize,
    DWORD *pdwCodePage,
    PBYTE pSelectCmd,
    PBYTE pUnSelectCmd)
{

    BYTE  aubType[32];
    PBYTE pstrType;
    PBYTE pTextData;
    INT   iRet;

    ASSERT(pData         != NULL && 
           pdwCodePage   != NULL &&
           pSelectCmd    != NULL &&
           pUnSelectCmd  != NULL );

    pstrType = aubType;
    pTextData = pData;


    do 
    {
        pTextData = PubSkipComment(pTextData);

        if (pTextData == NULL)
        {
            iRet = EOF;
            break;
        }

        iRet = sscanf( pTextData, "%s:", pstrType);

        if (iRet != 0 && iRet != EOF)
        {
            pTextData += strlen(pstrType);
        }

        pTextData = PubSkipComment(pTextData);

        switch(*pstrType) 
        {
        case 'c':
        case 'C':
            if(!_stricmp(pstrType, "codepage:"))
            {
                iRet = sscanf(pTextData, "%d", pdwCodePage);

                if (iRet != 0 && iRet != EOF)
                {
                    while (*pTextData != EOL)
                        pTextData ++;
                    pTextData ++;
                }

            }
            break;

        case 's':
        case 'S':
            if(!_stricmp(pstrType, "selectcmd:"))
            {
                iRet = IGetCommand(pTextData, pSelectCmd);

                if (iRet != 0 && iRet != EOF)
                {
                    while (*pTextData != EOL)
                        pTextData ++;
                    pTextData ++;
                }
            }
            break;
        case 'u':
        case 'U':
            if(!_stricmp(pstrType, "unselectcmd:"))
            {
                iRet = IGetCommand(pTextData, pUnSelectCmd);

                if (iRet != 0 && iRet != EOF)
                {
                    while (*pTextData != EOL)
                        pTextData ++;
                    pTextData ++;
                }
            }
            break;

        default:
            pTextData++;
        }
    }
    while(*pTextData != EOF && dwSize > (DWORD)(pTextData - pData));

    return TRUE;
}

PBYTE
PubSkipComment(
    PBYTE pData)
{
    ASSERT(pData != NULL);

    do
    {
        if (IS_COMMENT(*pData))
        {
            while (*pData != EOL)
                pData++;
            pData++;
        }
        else if (*pData == ' ')
        {
            pData++;
        }
        else if (*pData == 0x0d)
        {
            pData++;
        }
        else if (*pData == EOL)
        {
            pData++;
        }
        else if (*pData == EOF)
        {
            pData = NULL;
            break;
        }
        else
            break;

    } while (TRUE);

    return pData;
}

INT
IGetCommand(
    PBYTE pData,
    PBYTE pDestBuf)
{

    INT iCount;

    if (*pData == EOF)
    {
        return EOF;
    }

    if (*pData == '"')
    {
        pData ++;
    }
    else
    {
        return 0;
    }

    iCount = 0;

    while (*pData != '"')
    {
        *pDestBuf = *pData;
        pDestBuf ++;
        pData++;
        iCount++;
    }

    *pDestBuf = (BYTE)NULL;
    iCount++;

    return iCount;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\tools\uni\ctt2gtt\ctt2gtt.c ===
/*++

Copyright (c) 1996-1997  Microsoft Corporation

Module Name:

    ctt2gtt.c

Abstract:


Environment:

    Windows NT PostScript driver

Revision History:

--*/

#include        "precomp.h"

//
// Macros
//

#define FILENAME_SIZE 256
#define CMD_SIZE      256

DWORD             gdwOutputFlags;

//
// flag definitions for gdwOutputFlags
//

#define OUTPUT_VERBOSE 0x00000001

//
// Local function prototypes
//

BOOL BiArgcheck(IN int, IN char**, IN OUT PWSTR, IN OUT PWSTR, IN OUT PWSTR);

//
// Globals
//

BYTE gcstrError1[] = "Usage:  ctt2gtt [-v] CP_file CTT_file GLY_file\n";
BYTE gcstrError2[] = "ctt2gtt: HeapCreate() failed\n.";
BYTE gcstrError3[] = "Cannot open file \"%ws\".\n";
BYTE gcstrError4[] = "Cannot create output file '%ws'.\n";
BYTE gcstrError5[] = "Failed to convert CTT to GlyphSetData.\n";
BYTE gcstrError6[] = "WriteFile fails: writes %ld bytes\n";
BYTE gcstrError7[] = "Failure of BGetInfo\n";


PSTR gcstrCTTType[] = { 
    "CTT_WTYPE_COMPOSE",
    "CTT_WTYPE_DIRECT",
    "CTT_WTYPE_PAIRED"};


INT  __cdecl
main(
    IN INT     iArgc,
    IN CHAR  **ppArgv)
/*++

Routine Description:

    main

Arguments:

    iArgc - Number of parameters in the following
    ppArgv - The parameters, starting with our name

Return Value:

    Return error code 

Note:


--*/
{

    HANDLE            hHeap;    // Acces to heap, to simulate driver environment
    HANDLE            hOutput;

    PWSTR             pwstrCTTName; // The file name being processed
    PWSTR             pwstrGlyName; // The output file 
    PWSTR             pwstrCPTName; // The Codepage info text

    WCHAR             awchCTTName[FILENAME_SIZE];  // The file name being processed
    WCHAR             awchGlyName[FILENAME_SIZE];  // The output file 
    WCHAR             awchCPTName[FILENAME_SIZE];  // The Codepage info text

    BYTE              aubSelectCmd[CMD_SIZE];
    BYTE              aubUnSelectCmd[CMD_SIZE];
    PBYTE             pubSelectCmd, pubUnSelectCmd;

    BYTE              aubFormatCmd[256];
    PBYTE             pCommand;
    WORD              wSize, wJ;

    PTRANSTAB         pCTTData;
    DWORD             dwCTTSize;
    PUNI_GLYPHSETDATA pGlyphSetData;
    DWORD             dwGlySize;
    DWORD             dwCodePage;

    PBYTE             pCPText;
    DWORD             dwCPTextSize;

    DWORD             dwWrittenSize; // Returned size from WriteFile
    HFILEMAP          hCTTFile, hCPText, hGlyphFile;

    pwstrCTTName = awchCTTName;
    pwstrGlyName = awchGlyName;
    pwstrCPTName = awchCPTName;

    if (!BiArgcheck(iArgc, ppArgv, pwstrCPTName, pwstrCTTName, pwstrGlyName))
    {
        fprintf( stderr, gcstrError1);
        return  -1;
    }

    if (gdwOutputFlags & OUTPUT_VERBOSE)
    {

        printf("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
        printf("                      GlyphSetData\n");
        printf("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
        printf("\n");
        printf("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
        printf("CODEPAGEINFO file\n");
        printf("Codepage info text file: %ws\n", pwstrCPTName);
        printf("CTT file               : %ws\n", pwstrCTTName);
        printf("Glyphset data          : %ws\n", pwstrGlyName);
    }

    hCPText = MapFileIntoMemory( (PWSTR)pwstrCPTName, 
                                 (PVOID)&pCPText,
                                 &dwCPTextSize );

    if (!hCPText)
    {
        fprintf( stderr, gcstrError3, pwstrCPTName);
        return  -2;
    }

    pubSelectCmd   = aubSelectCmd;
    pubUnSelectCmd = aubUnSelectCmd;

    if (!BGetInfo(pCPText,
                  dwCPTextSize,
                  &dwCodePage,
                  pubSelectCmd,
                  pubUnSelectCmd))
    {
        return -2;
    }

    if (gdwOutputFlags & OUTPUT_VERBOSE)
    {
        printf("\n");
        printf("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
        printf("CODEPAGE\n");
        printf ("Codepage: %d\n        : %s\n        : %s\n",
                     dwCodePage,
                     pubSelectCmd,
                     pubUnSelectCmd);
    }

    if (*pubSelectCmd == (BYTE)NULL)
        pubSelectCmd = NULL;

    if (*pubUnSelectCmd == (BYTE)NULL)
        pubUnSelectCmd = NULL;

    UnmapFileFromMemory(hCPText);

    hHeap = HeapCreate( HEAP_NO_SERIALIZE, 0x10000, 0x100000 );

    if (!hHeap)
    {
        fprintf( stderr, gcstrError2);
        return  -2;
    }

    hCTTFile = MapFileIntoMemory( (PTSTR)pwstrCTTName,
                                  (PVOID)&pCTTData,
                                  &dwCTTSize );

    if (!pCTTData || dwCTTSize == 0)
    {
        fprintf( stderr, gcstrError3, pwstrCTTName);
        return  -2;
    }

    if (gdwOutputFlags & OUTPUT_VERBOSE)
    {
        printf("\n");
        printf("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
        printf("CTT FILE INFORMATION\n");
        printf( "Type: %s\nFirst Char = 0x%x\nLast Char  = 0x%x\n",
                                      gcstrCTTType[ pCTTData->wType ],
                                      pCTTData->chFirstChar,
                                      pCTTData->chLastChar );
    }

    hGlyphFile = MapFileIntoMemory( (PTSTR)pwstrGlyName,
                                    (PVOID)&pGlyphSetData,
                                    &dwGlySize );

    if (!hGlyphFile)
    {
        pGlyphSetData = NULL;
        dwGlySize = 0;
    }

    if (!BConvertCTT2GTT( hHeap,
                          pCTTData,
                          dwCodePage,
                          0x20,
                          0xFF,
                          pubSelectCmd,
                          pubUnSelectCmd,
                          &pGlyphSetData,
                          dwGlySize))
    {
        fprintf( stderr,  gcstrError5);
        return  -3;
    }

    if (gdwOutputFlags & OUTPUT_VERBOSE)
    {
        PUNI_CODEPAGEINFO pCodePageInfo;
        PGLYPHRUN         pGlyphRun;
        PMAPTABLE         pMapTable;
        TRANSDATA        *pTrans;
        DWORD             dwI;

        printf("\n");
        printf("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
        printf("GLYPHSETDATA\n");
        printf ("GLYPHSETDATA.dwSize           : %d\n", pGlyphSetData->dwSize);
        printf ("             dwVersion        : %d\n", pGlyphSetData->dwVersion);
        printf ("             dwFlags          : %d\n", pGlyphSetData->dwFlags);
        printf ("             lPredefinedID    : %d\n", pGlyphSetData->lPredefinedID);
        printf ("             dwGlyphCount     : %d\n", pGlyphSetData->dwGlyphCount);
        printf ("             loRunOffset      : 0x%x\n", pGlyphSetData->loRunOffset);
        printf ("             dwRunCount       : %d\n", pGlyphSetData->dwRunCount);
        printf ("             dwCodePageCount  : 0x%d\n", pGlyphSetData->dwCodePageCount);
        printf ("             loCodePageOffset : 0x%x\n", pGlyphSetData->loCodePageOffset);
        printf ("             loMapTableOffset : 0x%x\n", pGlyphSetData->loMapTableOffset);
        printf("\n");

        pCodePageInfo = 
     (PUNI_CODEPAGEINFO)((PBYTE) pGlyphSetData + pGlyphSetData->loCodePageOffset);

        printf("\n");
        printf("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
        printf("CODEPAGEINFO\n");
        for (dwI = 0; dwI < pGlyphSetData->dwCodePageCount; dwI ++)
        {
            printf ("UNI_CODEPAGEINFO[%d].dwCodePage                = %d\n",
                                                dwI, pCodePageInfo->dwCodePage);
            printf ("UNI_CODEPAGEINFO[%d].SelectSymbolSet.dwCount   = %d\n",
                                   dwI, pCodePageInfo->SelectSymbolSet.dwCount);
            printf ("UNI_CODEPAGEINFO[%d].SelectSymbolSet:Command   = %s\n",
             dwI, (PBYTE)pCodePageInfo+pCodePageInfo->SelectSymbolSet.loOffset);
            printf ("UNI_CODEPAGEINFO[%d].UnSelectSymbolSet.dwCount = %d\n",
                                 dwI, pCodePageInfo->UnSelectSymbolSet.dwCount);
            printf ("UNI_CODEPAGEINFO[%d].UnSelectSymbolSet:Command = %s\n",
           dwI, (PBYTE)pCodePageInfo+pCodePageInfo->UnSelectSymbolSet.loOffset);
            pCodePageInfo++;
        }

        pGlyphRun =
                (PGLYPHRUN) ((PBYTE)pGlyphSetData + pGlyphSetData->loRunOffset);

        printf("\n");
        printf("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
        printf("GLYPHRUN\n");
        for (dwI = 0; dwI < pGlyphSetData->dwRunCount; dwI ++)
        {
             printf("GLYPHRUN[%2d].wcLow       = 0x%-4x\n", dwI, pGlyphRun->wcLow);
             printf("GLYPHRUN[%2d].wGlyphCount = %d\n", dwI, pGlyphRun->wGlyphCount);
             pGlyphRun++;
        }

        pMapTable = (PMAPTABLE) ((PBYTE)pGlyphSetData +
                                 pGlyphSetData->loMapTableOffset);
        pTrans = pMapTable->Trans;

        printf("\n");
        printf("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
        printf("MAPTABLE\n");
        printf("MAPTABLE.dwSize     = %d\n", pMapTable->dwSize);
        printf("MAPTABLE.dwGlyphNum = %d\n", pMapTable->dwGlyphNum);

        for (dwI = 0; dwI < pMapTable->dwGlyphNum; dwI ++)
        {
            printf("MAPTABLE.pTrans[%5d].ubCodePageID = %d\n",
                dwI, pTrans[dwI].ubCodePageID);
            printf("MAPTABLE.pTrans[%5d].ubType       = %d\n",
                dwI, pTrans[dwI].ubType);

            switch(pTrans[dwI].ubType)
            {
            case MTYPE_DIRECT:
                printf("MAPTABLE.pTrans[%5d].ubCode       = %d\n",
                    dwI+1, pTrans[dwI].uCode.ubCode);
                break;
            case MTYPE_PAIRED:
                printf("MAPTABLE.pTrans[%5d].ubPairs[0]   = %d\n",
                    dwI+1, pTrans[dwI].uCode.ubPairs[0]);
                printf("MAPTABLE.pTrans[%5d].ubPairs[1]   = %d\n",
                    dwI+1, pTrans[dwI].uCode.ubPairs[1]);
                break;
            case MTYPE_COMPOSE:
                printf("MAPTABLE.pTrans[%5d].sCode        = %x\n",
                    dwI+1, pTrans[dwI].uCode.sCode);
                pCommand = (PBYTE)pMapTable + pTrans[dwI].uCode.sCode;
                wSize = *(WORD*)pCommand;
                pCommand += 2;
                printf("Size                              = 0x%d\n", wSize);
                printf("Command                           = 0x");
                for (wJ = 0; wJ < wSize; wJ ++)
                {
                    printf("%02x",pCommand[wJ]);
                }
                printf("\n");
                break;
            }
        }

    }

    UnmapFileFromMemory(hCTTFile);

    hOutput = CreateFile(pwstrGlyName,
                         GENERIC_WRITE,
                         0,
                         NULL,
                         CREATE_ALWAYS,
                         FILE_ATTRIBUTE_NORMAL,
                         NULL );

    if( hOutput == INVALID_HANDLE_VALUE )
    {
        fprintf( stderr, gcstrError4,  pwstrGlyName);
        return -2;
    }

    WriteFile( hOutput,
               pGlyphSetData,
               pGlyphSetData->dwSize,
               &dwWrittenSize,
               NULL );

    if( dwWrittenSize != pGlyphSetData->dwSize)
    {
        fprintf( stderr, gcstrError6, dwWrittenSize);
        return  -4;
    }

    HeapDestroy(hHeap);

    return  0;

}


BOOL
BiArgcheck(
    IN     INT    iArgc,
    IN     CHAR **ppArgv,
    IN OUT PWSTR   pwstrCPTName,
    IN OUT PWSTR   pwstrCTTName,
    IN OUT PWSTR   pwstrGlyName)
/*++

Routine Description:

    iArgcheck

Arguments:

    iArgc - Number of parameters in the following
    ppArgv - The parameters, starting with our name
    pwstrCPTName -
    pwstrCTTName -
    pwstrGlyName -

Return Value:

    If TRUE, function succeeded. Othewise FALSE.

Note:


--*/
{
    INT iI;
    INT iRet;

    if (iArgc > 5 || iArgc < 4)
    {
        return  FALSE;
    }

    if (iArgc == 5)
    {
        gdwOutputFlags |= OUTPUT_VERBOSE;
        ppArgv++;
    }

    ppArgv++;
    iRet = MultiByteToWideChar(CP_ACP, 0, *ppArgv, strlen(*ppArgv), pwstrCPTName, FILENAME_SIZE);
    *(pwstrCPTName + iRet) = (WCHAR)NULL;
    ppArgv++;
    iRet = MultiByteToWideChar(CP_ACP, 0, *ppArgv, strlen(*ppArgv), pwstrCTTName, FILENAME_SIZE);
    *(pwstrCTTName + iRet) = (WCHAR)NULL;
    ppArgv++;
    iRet = MultiByteToWideChar(CP_ACP, 0, *ppArgv, strlen(*ppArgv), pwstrGlyName, FILENAME_SIZE);
    *(pwstrGlyName + iRet) = (WCHAR)NULL;




    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\tools\uni\dumpgly\precomp.h ===
/*++

Copyright (c) 1996-1997  Microsoft Corporation

Module Name:

    precomp.h

Abstract:

    UNI_GLYPHSETDATA dump tool precompile header.
    All other header files should be included in this precompiled header.

Environment:

    Windows NT printer drivers

Revision History:

    11/01/96 -eigos-
        Created it.

--*/


#ifndef _PRECOMP_H_
#define _PRECOMP_H_

#include        <lib.h>
#include        <win30def.h>
//#include        <uni16gpc.h>
#include        <uni16res.h>
#include        <prntfont.h>
#include        <unilib.h>

#endif // _PRECOMP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\tools\uni\dumpuff\dumpuff.c ===
/*++

Copyright (c) 1996-1997  Microsoft Corporation

Module Name:

    dumpUFF.c

Abstract:

    UFF dump tool

Environment:

    Windows NT PostScript driver

Revision History:

    12/20/96 -eigos-
    Created it.

--*/

#include        "precomp.h"

//
// Macros
//

#define FILENAME_SIZE 256

//
// Globals
//

BYTE gcstrError1[] = "Usage:  dumpuff *.uff\n";
BYTE gcstrError2[] = "Cannot open file \"%ws\".\n";

BYTE *gcstrdwFlags1[] = {
                        "FONT_DIR_SORTED"
};
BYTE *gcstrdwFlags2[] = {
                        "FONT_FL_UFM",
                        "FONT_FL_IFI",
                        "FONT_FL_SOFTFONT",
                        "FONT_FL_PERMANENT_SF",
                        "FONT_FL_DEVICEFONT",
                        "FONT_FL_GLYPHET_GTT",
                        "FONT_FL_GLYPHSET_RLE",
                        "FONT_FL_RESERVED"
};

//
// Internal prototype
//

BOOL BDumpUFF(IN PUFF_FILEHEADER);
VOID DumpData(IN PBYTE pData);

int  __cdecl
main(
    IN int     argc,
    IN char  **argv)
/*++

Routine Description:

    main

Arguments:

    argc - Number of parameters in the following
    argv - The parameters, starting with our name

Return Value:

    Return error code 

Note:


--*/
{
    HFILEMAP          hUFFData;
    DWORD             dwUFFSize;
    WORD              wSize;
    WCHAR             awchFile[FILENAME_SIZE];
    PUFF_FILEHEADER   pUFF;

    //RIP(("Start dumpUFF.exe\n"));

    if (argc != 2)
    {
        fprintf( stderr, gcstrError1);
        return  -1;
    }

    argv++;

    MultiByteToWideChar(CP_ACP,
                        0,
                        *argv,
                        strlen(*argv)+1,
                        awchFile,
                        FILENAME_SIZE);

    hUFFData = MapFileIntoMemory( awchFile,
                                  (PVOID)&pUFF,
                                  &dwUFFSize );

    if (!hUFFData)
    {
        fprintf( stderr, gcstrError2, *argv);
        return  -2;
    }

    printf("%ws\n", awchFile);
    BDumpUFF(pUFF);

    UnmapFileFromMemory(hUFFData);

    return 0;
}


BOOL
BDumpUFF(
    IN PUFF_FILEHEADER pUFF)
{

    PUFF_FONTDIRECTORY pFontDir;
    DWORD dwI, dwJ;

#if 0
    printf("%x%x%x%x\n", *(PDWORD)pUFF,
                         *((PDWORD)pUFF+1),
                         *((PDWORD)pUFF+2),
                         *((PDWORD)pUFF+3));
#endif

    printf("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
    printf(" UFF File\n");
    printf("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
    printf("UFF.dwSignature          = 0x%x\n", pUFF->dwSignature);
    printf("                         = %c%c%c%c\n",
                                      (0x00FF & pUFF->dwSignature),
                                      (0xFF00 & pUFF->dwSignature) >> 8,
                                      (0xFF0000 & pUFF->dwSignature) >> 16,
                                      (0xFF000000 & pUFF->dwSignature) >> 24);
    printf("UFF.dwVersion            = %d\n", pUFF->dwVersion);
    printf("UFF.dwSize               = %d\n", pUFF->dwSize);
    printf("UFF.nFonts               = %d\n", pUFF->nFonts);
    printf("UFF.nGlyphSets           = %d\n", pUFF->nGlyphSets);
    printf("UFF.nVarData             = %d\n", pUFF->nVarData);
    printf("UFF.offFontDir           = 0x%x\n", pUFF->offFontDir);
    printf("UFF.dwFlags              = 0x%x\n", pUFF->dwFlags);
    for( dwI = 0; dwI < 32; dwI ++ )
    {
        if (pUFF->dwFlags & (0x00000001 << dwI))
            printf("                           %s\n", gcstrdwFlags1[dwI]);
    }

    pFontDir = (PUFF_FONTDIRECTORY)((PBYTE)pUFF + pUFF->offFontDir);
    for (dwI = 0; dwI < pUFF->nFonts; dwI ++, pFontDir ++)
    {
        printf("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
        printf("UFF_FONTREC.dwSignature    = 0x%x\n",   pFontDir->dwSignature);
        printf("                           = %c%c%c%c\n",
                                  (0x00FF & pFontDir->dwSignature),
                                  (0xFF00 & pFontDir->dwSignature) >> 8,
                                  (0xFF0000 & pFontDir->dwSignature) >> 16,
                                  (0xFF000000 & pFontDir->dwSignature) >> 24);
        printf("UFF_FONTREC.wSize          = %d\n",   pFontDir->wSize);
        printf("UFF_FONTREC.wFontID        = %d\n",   pFontDir->wFontID);
        printf("UFF_FONTREC.sGlyphID       = %d\n",   pFontDir->sGlyphID);
        printf("UFF_FONTREC.wFlags         = %d\n",   pFontDir->wFlags);
        for( dwJ = 0; dwJ < 32; dwJ ++ )
        {
            if (pUFF->dwFlags & (0x00000001 << dwJ))
                printf("                           %s\n", gcstrdwFlags2[dwJ]);
        }
        printf("UFF_FONTREC.dwInstallerSig = %d\n",   pFontDir->dwInstallerSig);
        printf("                         = %c%c%c%c\n",
                              (0x00FF & pFontDir->dwInstallerSig),
                              (0xFF00 & pFontDir->dwInstallerSig) >> 8,
                              (0xFF0000 & pFontDir->dwInstallerSig) >> 16,
                              (0xFF000000 & pFontDir->dwInstallerSig) >> 24);
        printf("UFF.offFontName            = 0x%x\n", pFontDir->offFontName);
        printf("                           = %ws\n", (PBYTE)pUFF+pFontDir->offFontName);
        printf("UFF.offCartridgeName       = 0x%x\n", pFontDir->offCartridgeName);
        printf("                           = %ws\n", (PBYTE)pUFF+pFontDir->offCartridgeName);
        printf("UFF.offFontData            = 0x%x\n", pFontDir->offFontData);
        printf("UFF.offGlyphData           = 0x%x\n", pFontDir->offGlyphData);
        printf("UFF.offVarData             = 0x%x\n", pFontDir->offVarData);
        if (pFontDir->offFontData)
        {
            printf("FontData+++++++++++++++++++++++++++++++++++++++++++++++++\n");
            DumpData((PBYTE)pUFF + pFontDir->offFontData);
        }
        if (pFontDir->offGlyphData)
        {
            printf("GlyphData++++++++++++++++++++++++++++++++++++++++++++++++\n");
            DumpData((PBYTE)pUFF + pFontDir->offGlyphData);
        }
        if (pFontDir->offVarData)
        {
            printf("VarData+++++++++++++++++++++++++++++++++++++++++++++++++++\n");
            DumpData((PBYTE)pUFF + pFontDir->offVarData);
        }
    }

    return TRUE;
}


VOID
DumpData(
        IN PBYTE pData)
{
    PDATA_HEADER pDataHeader = (PDATA_HEADER)pData;
    DWORD dwI;

    printf("dwSignature = 0x%x\n", pDataHeader->dwSignature);
    printf("            = %c%c%c%c\n",
                          (0x00FF & pDataHeader->dwSignature),
                          (0xFF00 & pDataHeader->dwSignature) >> 8,
                          (0xFF0000 & pDataHeader->dwSignature) >> 16,
                          (0xFF000000 & pDataHeader->dwSignature) >> 24);
    printf("wSize       = %d\n", pDataHeader->wSize);
    printf("wDataID     = %d(0x%x)\n", pDataHeader->wDataID, pDataHeader->wDataID);
    printf("dwDataSize  = %d\n", pDataHeader->dwDataSize);

    pData += sizeof(DATA_HEADER);

    for (dwI = 0; dwI < 16; dwI ++, pData += 16)
    {
        printf(" %08x %08x %08x %08x\n", *(PDWORD)pData, *(PDWORD)(pData+4), *(PDWORD)(pData+8), *(PDWORD)(pData+12));
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\tools\uni\dumpuff\precomp.h ===
/*++

Copyright (c) 1996-1997  Microsoft Corporation

Module Name:

    precomp.h

Abstract:

    UNI_GLYPHSETDATA dump tool precompile header.
    All other header files should be included in this precompiled header.

Environment:

    Windows NT printer drivers

Revision History:

    11/01/96 -eigos-
        Created it.

--*/


#ifndef _PRECOMP_H_
#define _PRECOMP_H_

#include        <lib.h>
#include        <win30def.h>
#include        <unilib.h>
#include        <prntfont.h>
#include        <fmoldfm.h>

#endif // _PRECOMP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\tools\uni\dumpufm\dumpufm.c ===
/*++

Copyright (c) 1996-1997  Microsoft Corporation

Module Name:

    dumpufm.c

Abstract:

    UFM dump tool

Environment:

    Windows NT PostScript driver

Revision History:

    12/20/96 -eigos-
    Created it.

--*/

#include        "precomp.h"

//
// Macros
//

#define FILENAME_SIZE 256

//
// Globals
//

BYTE gcstrError1[] = "Usage:  dumpufm *.ufm\n";
BYTE gcstrError2[] = "Cannot open file \"%ws\".\n";
BYTE *gcstrflInfo[] = {"FM_INFO_TECH_TRUETYPE",
                       "FM_INFO_TECH_BITMAP",
                       "FM_INFO_TECH_STROKE",
                       "FM_INFO_TECH_OUTLINE_NOT_TRUETYPE",
                       "FM_INFO_ARB_XFORMS",
                       "FM_INFO_1BPP",
                       "FM_INFO_4BPP",
                       "FM_INFO_8BPP",
                       "FM_INFO_16BPP",
                       "FM_INFO_24BPP",
                       "FM_INFO_32BPP",
                       "FM_INFO_INTEGER_WIDTH",
                       "FM_INFO_CONSTANT_WIDTH",
                       "FM_INFO_NOT_CONTIGUOUS",
                       "FM_INFO_TECH_MM",
                       "FM_INFO_RETURNS_OUTLINES",
                       "FM_INFO_RETURNS_STROKES",
                       "FM_INFO_RETURNS_BITMAPS",
                       "FM_INFO_UNICODE_COMPLIANT",
                       "FM_INFO_RIGHT_HANDED",
                       "FM_INFO_INTEGRAL_SCALING",
                       "FM_INFO_90DEGREE_ROTATIONS",
                       "FM_INFO_OPTICALLY_FIXED_PITCH",
                       "FM_INFO_DO_NOT_ENUMERATE",
                       "FM_INFO_ISOTROPIC_SCALING_ONLY",
                       "FM_INFO_ANISOTROPIC_SCALING_ONLY",
                       "FM_INFO_MM_INSTANCE",
                       "FM_INFO_FAMILY_EQUIV",
                       "FM_INFO_DBCS_FIXED_PITCH",
                       "FM_INFO_NONNEGATIVE_AC",
                       "FM_INFO_IGNORE_TC_RA_ABLE",
                       "FM_INFO_TECH_TYPE1"};

//
// Internal prototype
//

BOOL BDumpUFM(IN PUNIFM_HDR);

int  __cdecl
main(
    IN int     argc,
    IN char  **argv)
/*++

Routine Description:

    main

Arguments:

    argc - Number of parameters in the following
    argv - The parameters, starting with our name

Return Value:

    Return error code 

Note:


--*/
{
    HFILEMAP          hUFMData;
    DWORD             dwUFMSize;
    WORD              wSize;
    WCHAR             awchFile[FILENAME_SIZE];
    PUNIFM_HDR        pUFM;

    //RIP(("Start dumpufm.exe\n"));

    if (argc != 2)
    {
        fprintf( stderr, gcstrError1);
        return  -1;
    }

    argv++;

    MultiByteToWideChar(CP_ACP,
                        0,
                        *argv,
                        strlen(*argv)+1,
                        awchFile,
                        FILENAME_SIZE);

    hUFMData = MapFileIntoMemory( awchFile,
                                  (PVOID)&pUFM,
                                  &dwUFMSize );

    if (!hUFMData)
    {
        fprintf( stderr, gcstrError2, *argv);
        return  -2;
    }

    printf(" File = %ws\n", awchFile);
    BDumpUFM(pUFM);

    UnmapFileFromMemory(hUFMData);

    return 0;
}


BOOL
BDumpUFM(
    IN PUNIFM_HDR pUFM)
{

    PUNIDRVINFO     pUnidrvInfo;
    PIFIMETRICS     pIFI;
    PIFIEXTRA       pIFIExtra;
    FONTSIM        *pFontSim;
    FONTDIFF       *pFontDiff;
    EXTTEXTMETRIC  *pExtTextMetric;
    PWIDTHTABLE     pWidthTable;
    PKERNDATA       pKerningData;
    FD_KERNINGPAIR *pKernPair;
    PANOSE         *ppan;
    PTRDIFF         dpTmp;

    PWSTR pwszFamilyName;
    PWSTR pwszStyleName;
    PWSTR pwszFaceName;
    PWSTR pwszUniqueName;

    DWORD          dwI, dwJ;
    PSHORT         psWidth;
    PCHAR          pCommand;
    BYTE           ubCommand[256];

    pUnidrvInfo     = (PUNIDRVINFO)    ((PBYTE)pUFM + pUFM->loUnidrvInfo);
    pIFI            = (PIFIMETRICS)    ((PBYTE)pUFM + pUFM->loIFIMetrics);
    if (pIFI->cjIfiExtra)
        pIFIExtra       = (PIFIEXTRA)  (pIFI + 1);
    else
        pIFIExtra       = (PIFIEXTRA)   NULL;
    if (pIFI->dpFontSim)
        pFontSim        = (FONTSIM*)   ((PBYTE)pIFI + pIFI->dpFontSim);
    else
        pFontSim        = (FONTSIM*)   NULL;
    if (pUFM->loExtTextMetric)
        pExtTextMetric  = (EXTTEXTMETRIC*) ((PBYTE)pUFM + pUFM->loExtTextMetric);
    else
        pExtTextMetric  = NULL;
    pWidthTable     = (PWIDTHTABLE)    ((PBYTE)pUFM + pUFM->loWidthTable);
    pKerningData    = (PKERNDATA)      ((PBYTE)pUFM + pUFM->loKernPair);
    ppan            = &pIFI->panose;

    printf("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
    printf(" Universal Printer Driver Font Metrics Data (UFM)\n");
    printf("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
    printf("UNIFM_HDR.dwSize            = %d\n", pUFM->dwSize);
    printf("UNIFM_HDR.dwVersion         = %d.%d\n", pUFM->dwVersion >> 16,
                                                    pUFM->dwVersion & 0xFFFF);
    printf("UNIFM_HDR.ulDefaultCodepage = %d\n", pUFM->ulDefaultCodepage);
    printf("UNIFM_HDR.lGlyphSetDataRCID = %d\n", pUFM->lGlyphSetDataRCID);
    printf("UNIFM_HDR.loUnidrvInfo      = 0x%x\n", pUFM->loUnidrvInfo);
    printf("UNIFM_HDR.loIFIMetrics      = 0x%x\n", pUFM->loIFIMetrics);
    printf("UNIFM_HDR.loExtTextMetric   = 0x%x\n", pUFM->loExtTextMetric);
    printf("UNIFM_HDR.loWidthTable      = 0x%x\n", pUFM->loWidthTable);
    printf("UNIFM_HDR.loKernPair        = 0x%x\n", pUFM->loKernPair);
    printf("\n");

    printf("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
    printf("UNIDRVINFO\n");
    printf("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
    printf("UNIDRVINFO.dwSize       = %d\n", pUnidrvInfo->dwSize);
    printf("UNIDRVINFO.flGenFlags   = %d\n", pUnidrvInfo->flGenFlags);
    printf("UNIDRVINFO.wType        = %d\n", pUnidrvInfo->wType);
    printf("UNIDRVINFO.fCaps        = %d\n", pUnidrvInfo->fCaps);
    printf("UNIDRVINFO.wXRes        = %d\n", pUnidrvInfo->wXRes);
    printf("UNIDRVINFO.wYRes        = %d\n", pUnidrvInfo->wYRes);
    printf("UNIDRVINFO.sYAdjust     = %d\n", pUnidrvInfo->sYAdjust);
    printf("UNIDRVINFO.sYMoved      = %d\n", pUnidrvInfo->sYMoved);
    printf("UNIDRVINFO.wPrivateData = %d\n", pUnidrvInfo->wPrivateData);

    if (pUnidrvInfo->SelectFont.dwCount && pUnidrvInfo->SelectFont.loOffset)
    {
        pCommand = (PCHAR)pUnidrvInfo + pUnidrvInfo->SelectFont.loOffset;
        printf("UNIDRVINFO.SelectFont   = ");

        for  (dwI = 0; dwI < pUnidrvInfo->SelectFont.dwCount; dwI ++, pCommand++)
        {
            if (*pCommand < 0x20 || 0x7e < *pCommand )
            {
                printf("\\x%X",*pCommand);
            }
            else
            {
                printf("%c",*pCommand);
            }
        }
    }

    if (pUnidrvInfo->UnSelectFont.dwCount && pUnidrvInfo->UnSelectFont.loOffset)
    {
        pCommand = (PCHAR)pUnidrvInfo + pUnidrvInfo->UnSelectFont.loOffset;
        printf("\nUNIDRVINFO.UnSelectFont = ");
        for  (dwI = 0; dwI < pUnidrvInfo->UnSelectFont.dwCount; dwI ++, pCommand++)
        {
            if (*pCommand < 0x32 || 0x7e < *pCommand )
            {
                printf("\\x%X",*pCommand);
            }
            else
            {
                printf("%c",*pCommand);
            }
        }
    }
    printf("\n");

    pwszFamilyName = (PWSTR)(((BYTE*) pIFI) + pIFI->dpwszFamilyName);
    pwszStyleName  = (PWSTR)(((BYTE*) pIFI) + pIFI->dpwszStyleName) ;
    pwszFaceName   = (PWSTR)(((BYTE*) pIFI) + pIFI->dpwszFaceName)  ;
    pwszUniqueName = (PWSTR)(((BYTE*) pIFI) + pIFI->dpwszUniqueName);

    printf("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
    printf("IFIMETRICS\n");
    printf("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
    printf("IFIMETIRCS.cjThis               = %-#8lx\n" , pIFI->cjThis );
    printf("IFIMETIRCS.cjIfiExtra           = %-#8lx\n" , pIFI->cjIfiExtra);
    printf("IFIMETIRCS.pwszFamilyName       = \"%ws\"\n", pwszFamilyName );
    printf("                                = %02x%02x%02x%02x%02x\n", *(PWCHAR)pwszFamilyName,*((PWCHAR)pwszFamilyName+1),*((PWCHAR)pwszFamilyName+2),*((PWCHAR)pwszFamilyName+3),*((PWCHAR)pwszFamilyName+4));
    if( pIFI->flInfo & FM_INFO_FAMILY_EQUIV )
    {
        while( *(pwszFamilyName += wcslen( pwszFamilyName ) + 1) )
            printf("                               \"%ws\"\n", pwszFamilyName );
    }
    printf("IFIMETRICS.pwszStyleName        = \"%ws\"\n", pwszStyleName );
    printf("IFIMETRICS.pwszFaceName         = \"%ws\"\n", pwszFaceName );
    printf("IFIMETRICS.pwszUniqueName       = \"%ws\"\n", pwszUniqueName );
    printf("IFIMETRICS.dpFontSim            = %-#8lx\n" , pIFI->dpFontSim );
    printf("IFIMETRICS.lEmbedId             = %d\n",      pIFI->lEmbedId    );
    printf("IFIMETRICS.lItalicAngle         = %d\n",      pIFI->lItalicAngle);
    printf("IFIMETRICS.lCharBias            = %d\n",      pIFI->lCharBias   );
    printf("IFIMETRICS.dpCharSets           = %d\n",      pIFI->dpCharSets   );
    printf("IFIMETRICS.jWinCharSet          = %04x\n"   , pIFI->jWinCharSet );
    printf("IFIMETRICS.jWinPitchAndFamily   = %04x\n"   , pIFI->jWinPitchAndFamily );
    printf("IFIMETRICS.usWinWeight          = %d\n"     , pIFI->usWinWeight );
    printf("IFIMETRICS.flInfo               = %-#8lx\n" , pIFI->flInfo );
    for( dwI = 0; dwI < 32; dwI ++ )
    {
        if (pIFI->flInfo & (0x00000001 << dwI))
        {
            printf("                                  %s\n", gcstrflInfo[dwI]);
        }
    }
    printf("IFIMETRICS.fsSelection          = %-#6lx\n" , pIFI->fsSelection );
    printf("IFIMETRICS.fsType               = %-#6lx\n" , pIFI->fsType );
    printf("IFIMETRICS.fwdUnitsPerEm        = %d\n"     , pIFI->fwdUnitsPerEm );
    printf("IFIMETRICS.fwdLowestPPEm        = %d\n"     , pIFI->fwdLowestPPEm );
    printf("IFIMETRICS.fwdWinAscender       = %d\n"     , pIFI->fwdWinAscender );
    printf("IFIMETRICS.fwdWinDescender      = %d\n"     , pIFI->fwdWinDescender );
    printf("IFIMETRICS.fwdMacAscender       = %d\n"     , pIFI->fwdMacAscender );
    printf("IFIMETRICS.fwdMacDescender      = %d\n"     , pIFI->fwdMacDescender );
    printf("IFIMETRICS.fwdMacLineGap        = %d\n"     , pIFI->fwdMacLineGap );
    printf("IFIMETRICS.fwdTypoAscender      = %d\n"     , pIFI->fwdTypoAscender );
    printf("IFIMETRICS.fwdTypoDescender     = %d\n"     , pIFI->fwdTypoDescender );
    printf("IFIMETRICS.fwdTypoLineGap       = %d\n"     , pIFI->fwdTypoLineGap );
    printf("IFIMETRICS.fwdAveCharWidth      = %d\n"     , pIFI->fwdAveCharWidth );
    printf("IFIMETRICS.fwdMaxCharInc        = %d\n"     , pIFI->fwdMaxCharInc );
    printf("IFIMETRICS.fwdCapHeight         = %d\n"     , pIFI->fwdCapHeight );
    printf("IFIMETRICS.fwdXHeight           = %d\n"     , pIFI->fwdXHeight );
    printf("IFIMETRICS.fwdSubscriptXSize    = %d\n"     , pIFI->fwdSubscriptXSize );
    printf("IFIMETRICS.fwdSubscriptYSize    = %d\n"     , pIFI->fwdSubscriptYSize );
    printf("IFIMETRICS.fwdSubscriptXOffset  = %d\n"     , pIFI->fwdSubscriptXOffset );
    printf("IFIMETRICS.fwdSubscriptYOffset  = %d\n"     , pIFI->fwdSubscriptYOffset );
    printf("IFIMETRICS.fwdSuperscriptXSize  = %d\n"     , pIFI->fwdSuperscriptXSize );
    printf("IFIMETRICS.fwdSuperscriptYSize  = %d\n"     , pIFI->fwdSuperscriptYSize );
    printf("IFIMETRICS.fwdSuperscriptXOffset= %d\n"     , pIFI->fwdSuperscriptXOffset);
    printf("IFIMETRICS.fwdSuperscriptYOffset= %d\n"     , pIFI->fwdSuperscriptYOffset);
    printf("IFIMETRICS.fwdUnderscoreSize    = %d\n"     , pIFI->fwdUnderscoreSize );
    printf("IFIMETRICS.fwdUnderscorePosition= %d\n"     , pIFI->fwdUnderscorePosition);
    printf("IFIMETRICS.fwdStrikeoutSize     = %d\n"     , pIFI->fwdStrikeoutSize );
    printf("IFIMETRICS.fwdStrikeoutPosition = %d\n"     , pIFI->fwdStrikeoutPosition );
    printf("IFIMETRICS.chFirstChar          = %-#4x\n"  , (int) (BYTE) pIFI->chFirstChar );
    printf("IFIMETRICS.chLastChar           = %-#4x\n"  , (int) (BYTE) pIFI->chLastChar );
    printf("IFIMETRICS.chDefaultChar        = %-#4x\n"  , (int) (BYTE) pIFI->chDefaultChar );
    printf("IFIMETRICS.chBreakChar          = %-#4x\n"  , (int) (BYTE) pIFI->chBreakChar );
    printf("IFIMETRICS.wcFirsChar           = %-#6x\n"  , pIFI->wcFirstChar );
    printf("IFIMETRICS.wcLastChar           = %-#6x\n"  , pIFI->wcLastChar );
    printf("IFIMETRICS.wcDefaultChar        = %-#6x\n"  , pIFI->wcDefaultChar );
    printf("IFIMETRICS.wcBreakChar          = %-#6x\n"  , pIFI->wcBreakChar );
    printf("IFIMETRICS.ptlBaseline          = {%d,%d}\n"  , pIFI->ptlBaseline.x,
            pIFI->ptlBaseline.y);
    printf("IFIMETRICS.ptlAspect            = {%d,%d}\n"  , pIFI->ptlAspect.x,
            pIFI->ptlAspect.y );
    printf("IFIMETRICS.ptlCaret             = {%d,%d}\n"  , pIFI->ptlCaret.x,
            pIFI->ptlCaret.y );
    printf("IFIMETRICS.rclFontBox           = {%d,%d,%d,%d}\n",pIFI->rclFontBox.left,
                                                    pIFI->rclFontBox.top,
                                                    pIFI->rclFontBox.right,
                                                    pIFI->rclFontBox.bottom );
    printf("IFIMETRICS.achVendId            = \"%c%c%c%c\"\n",pIFI->achVendId[0],
                                               pIFI->achVendId[1],
                                               pIFI->achVendId[2],
                                               pIFI->achVendId[3] );
    printf("IFIMETRICS.cKerningPairs        = %d\n"     , pIFI->cKerningPairs );
    printf("IFIMETRICS.ulPanoseCulture      = %-#8lx\n" , pIFI->ulPanoseCulture);
    printf(
           "IFIMETRICS.panose               = {%02x,%02x,%02x,%02x,%02x,%02x,%02x,%02x,%02x,%02x}\n"
                                             , ppan->bFamilyType
                                             , ppan->bSerifStyle
                                             , ppan->bWeight
                                             , ppan->bProportion
                                             , ppan->bContrast
                                             , ppan->bStrokeVariation
                                             , ppan->bArmStyle
                                             , ppan->bLetterform
                                             , ppan->bMidline
                                             , ppan->bXHeight);

    printf("\n");

    if (pIFIExtra)
    {
        printf("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
        printf("IFIEXTRA\n");
        printf("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
        printf("IFIEXTRA.ulIdentifier           = %d\n", pIFIExtra->ulIdentifier);
        printf("IFIEXTRA.dpFontSig              = %d\n", pIFIExtra->dpFontSig);
        printf("IFIEXTRA.cig                    = %d\n", pIFIExtra->cig);
        printf("IFIEXTRA.dpDesignVector         = %d\n", pIFIExtra->dpDesignVector);
        printf("IFIEXTRA.dpAxesInfoW            = %d\n", pIFIExtra->dpAxesInfoW);
        printf("\n");
    }

    if (pFontSim)
    {
        printf("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
        printf("FONTSIM\n");
        printf("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
        printf("FONTSIM.dpBold                  = %d\n", pFontSim->dpBold);
        printf("FONTSIM.dpItalic                = %d\n", pFontSim->dpItalic);
        printf("FONTSIM.dpBoldItalic            = %d\n", pFontSim->dpBoldItalic);
        for (dwI = 0; dwI < 3; dwI ++)
        {
            printf("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
            switch(dwI)
            { 
            case 0:
                printf("dpBold\n");
                dpTmp = pFontSim->dpBold;
                break;
            case 1:
                printf("dpItalic\n");
                dpTmp = pFontSim->dpItalic;
                break;
            case 2:
                printf("dpBoldItalic\n");
                dpTmp = pFontSim->dpBoldItalic;
                break;
            }
            printf("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
            if (dpTmp)
            {
                pFontDiff = (FONTDIFF*)((PBYTE)pFontSim + dpTmp);
                                        
                printf("FONTDIFF.bWeight           = %d\n",pFontDiff->bWeight);
                printf("FONTDIFF.usWinWeight       = %d\n",pFontDiff->usWinWeight);
                printf("FONTDIFF.fsSelection       = %d\n",pFontDiff->fsSelection);
                printf("FONTDIFF.fwdAveCharWidth   = %d\n",pFontDiff->fwdAveCharWidth);
                printf("FONTDIFF.fwdMaxCharInc     = %d\n",pFontDiff->fwdMaxCharInc);
                printf("FONTDIFF.ptlCaret          = %d\n",pFontDiff->ptlCaret);
            }
        }
        printf("\n");
    }

    if (pExtTextMetric)
    {
        printf("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
        printf("EXTTEXTMETRIC\n");
        printf("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
        printf("EXTTEXTMETRIC.emSize                       = %d\n",pExtTextMetric->emSize);
        printf("EXTTEXTMETRIC.emPointSize                  = %d\n",pExtTextMetric->emPointSize);
        printf("EXTTEXTMETRIC.emOrientation                = %d\n",pExtTextMetric->emOrientation);
        printf("EXTTEXTMETRIC.emMinScale                   = %d\n",pExtTextMetric->emMinScale);
        printf("EXTTEXTMETRIC.emMaxScale                   = %d\n",pExtTextMetric->emMaxScale);
        printf("EXTTEXTMETRIC.emMasterUnits                = %d\n",pExtTextMetric->emMasterUnits);
        printf("EXTTEXTMETRIC.emCapHeight                  = %d\n",pExtTextMetric->emCapHeight);
        printf("EXTTEXTMETRIC.emXHeight                    = %d\n",pExtTextMetric->emXHeight);
        printf("EXTTEXTMETRIC.emLowerCaseAscent            = %d\n",pExtTextMetric->emLowerCaseAscent);
        printf("EXTTEXTMETRIC.emLowerCaseDescent           = %d\n",pExtTextMetric->emLowerCaseDescent);
        printf("EXTTEXTMETRIC.emSlant                      = %d\n",pExtTextMetric->emSlant);
        printf("EXTTEXTMETRIC.emSuperScript                = %d\n",pExtTextMetric->emSuperScript);
        printf("EXTTEXTMETRIC.emSubScript                  = %d\n",pExtTextMetric->emSubScript);
        printf("EXTTEXTMETRIC.emSuperScriptSize            = %d\n",pExtTextMetric->emSuperScriptSize);
        printf("EXTTEXTMETRIC.emSubScriptSize              = %d\n",pExtTextMetric->emSubScriptSize);
        printf("EXTTEXTMETRIC.emUnderlineOffset            = %d\n",pExtTextMetric->emUnderlineOffset);
        printf("EXTTEXTMETRIC.emUnderlineWidth             = %d\n",pExtTextMetric->emUnderlineWidth);
        printf("EXTTEXTMETRIC.emDoubleUpperUnderlineOffset = %d\n",pExtTextMetric->emDoubleUpperUnderlineOffset);
        printf("EXTTEXTMETRIC.emDoubleLowerUnderlineOffset = %d\n",pExtTextMetric->emDoubleLowerUnderlineOffset);
        printf("EXTTEXTMETRIC.emDoubleUpperUnderlineWidth  = %d\n",pExtTextMetric->emDoubleUpperUnderlineWidth);
        printf("EXTTEXTMETRIC.emDoubleLowerUnderlineWidth  = %d\n",pExtTextMetric->emDoubleLowerUnderlineWidth);
        printf("EXTTEXTMETRIC.emStrikeOutOffset            = %d\n",pExtTextMetric->emStrikeOutOffset);
        printf("EXTTEXTMETRIC.emStrikeOutWidth             = %d\n",pExtTextMetric->emStrikeOutWidth);
        printf("EXTTEXTMETRIC.emKernPairs                  = %d\n",pExtTextMetric->emKernPairs);
        printf("EXTTEXTMETRIC.emKernTracks                 = %d\n",pExtTextMetric->emKernTracks);
    }

    if (pUFM->loWidthTable)
    {
        printf("\n");
        printf("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
        printf("WIDTHTABLE\n");
        printf("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
        printf("WIDTHTABLE.dwSize   = %d\n", pWidthTable->dwSize);
        printf("WIDTHTABLE.dwRunNum = %d\n", pWidthTable->dwRunNum);
        for (dwI = 0; dwI < pWidthTable->dwRunNum; dwI ++)
        {
            printf("WidthRun[%d].wStartGlyph = %x\n",
                              dwI+1, pWidthTable->WidthRun[dwI].wStartGlyph);
            printf("WidthRun[%d].wGlyphCount = %d\n",
                              dwI+1, pWidthTable->WidthRun[dwI].wGlyphCount);
            psWidth = (PSHORT)((PBYTE)pWidthTable +
                               pWidthTable->WidthRun[dwI].loCharWidthOffset);
            for (dwJ = 0; dwJ < pWidthTable->WidthRun[dwI].wGlyphCount; dwJ ++, psWidth++)
            {
                printf("Width[%d] = %d\n", dwJ, *psWidth);
            }
        }
    }

    if (pUFM->loKernPair)
    {
        printf("\n");
        printf("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
        printf("KERNDATA\n");
        printf("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
        printf("KERNDATA.dwSize = %d\n", pKerningData->dwSize);
        pKernPair = pKerningData->KernPair;
        for (dwI = 0; dwI < pKerningData->dwKernPairNum; dwI++, pKernPair++)
        {
            printf("KERNDATA.KernPair[%d].wcFirst  = %x\n", dwI+1, pKernPair->wcFirst);
            printf("KERNDATA.KernPair[%d].wcSecond = %x\n", dwI+1, pKernPair->wcSecond);
            printf("KERNDATA.KernPair[%d].fwdKern  = %d\n", dwI+1, pKernPair->fwdKern);
        }
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\tools\uni\dumpufm\precomp.h ===
/*++

Copyright (c) 1996-1997  Microsoft Corporation

Module Name:

    precomp.h

Abstract:

    UNI_GLYPHSETDATA dump tool precompile header.
    All other header files should be included in this precompiled header.

Environment:

    Windows NT printer drivers

Revision History:

    11/01/96 -eigos-
        Created it.

--*/


#ifndef _PRECOMP_H_
#define _PRECOMP_H_

#include        <lib.h>
#include        <win30def.h>
#include        <uni16res.h>
#include        <uni16gpc.h>
#include        <prntfont.h>
#include        <unilib.h>
#include        <fmlib.h>
#include        <unirc.h>

#endif // _PRECOMP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\tools\uni\gpc2gpd\gpc2gpd.h ===
/*++

Copyright (c) 1996-1997  Microsoft Corporation

Module Name:

    gpc2gpd.h

Abstract:

    Declarations for GPC-to-GPD converter

Environment:

    User-mode, stand-alone utility tool

Revision History:

    10/16/96 -zhanw-
        Created it.

--*/

#ifndef _GPC2GPD_H_
#define _GPC2GPD_H_

#include <lib.h>

// include GPC data structure definition.
#include <win30def.h>
#include <uni16gpc.h>
#include <uni16cid.h>

#include <gpd.h>

typedef const TCHAR *PCTSTR;

#define MAX_GPD_CMD_LINE_LENGTH  80
#define MAX_GPD_ENTRY_BUFFER_SIZE    512  // may be multiple lines in GPD
#define MAX_OPTION_NAME_LENGTH  64

//
// structure to track which PAPERSIZE or PAPERSOURCE structure has _EJECTFF
// flag set.
//
typedef struct _PAPERINFO {
    BYTE aubOptName[MAX_OPTION_NAME_LENGTH];
    BOOL bEjectFF;
    DWORD dwPaperType;  // GPC's PS_T_xxx bit flags
    DWORD dwTopMargin;  // used by PaperSource only
    DWORD dwBottomMargin; // same as above
} PAPERINFO, * PPAPERINFO;

typedef struct _RESINFO {
    BYTE    aubOptName[MAX_OPTION_NAME_LENGTH];
    DWORD   dwXScale;  // scale of this resolution, masterX/xdpi
    DWORD   dwYScale;
    BOOL    bColor;     // whether this resolution can print color

} RESINFO, * PRESINFO;

//
// Converter state tracking and info caching structure
//
typedef struct _CONVINFO {
    DWORD dwErrorCode;  // error bit flags
    DWORD dwMode;       // op mode flags. Used to pass info between routines
    DWORD dwStrType;    // how to output display strings: macro, string, id
    BOOL    bUseSystemPaperNames ;  //  emit  RCID_DMPAPER_SYSTEM_NAME
#if defined(__cplusplus)
    CStringArray    *pcsaGPD;   //  Pointer to GPD memory image as array of strings
#else
    HANDLE hGPDFile;    // handle to the output file
#endif
    PDH pdh;            // pointer to the GPC data header
    PMODELDATA pmd;     // pointer to MODELDATA structure of the given model
    PPAGECONTROL ppc;   // pointer to PAGECONTROL structure used by the model
    OCD ocdPPOn;        // OCD for PageProtection-On command
    OCD ocdPPOff;       // OCD for PageProtection-Off command
    //
    // follow 3 fields are used to compose GPD cmds.
    //
    BYTE aubCmdBuf[MAX_GPD_ENTRY_BUFFER_SIZE];     // buffer for building cmd str
    WORD wCmdLen;       // the cmd length, not including the terminating NUL
    WORD wCmdCallbackID;    // 0 if no callback
    //
    // following dynamic buffers are used to track EJECTFF flag which could
    // come from either PAPERSIZE or PAPERSOURCE structures
    //
    DWORD dwNumOfSize;
    PPAPERINFO ppiSize;      // track PAPERSIZE structures
    DWORD dwNumOfSrc;
    PPAPERINFO ppiSrc;       // track PAPERSOURCE structures

    DWORD dwNumOfRes;
    PRESINFO    presinfo;   // track RESOLUTION structures
    //
    // other working buffers
    //
    PCURSORMOVE pcm;    // the CURSORMOVE structure for the model
    PGPCRESOLUTION pres;// the current RESOLUTION structure being examined.
                        // Used when CM_YM_RES_DEPENDENT bit is set.
    POINTw  ptMoveScale;    // masterUnit/moveUnit
#if defined(__cplusplus)
    CMapWordToDWord *pcmw2dFonts;   //  Font mapping for PFM -> multiple UFM fix
#endif

} CONVINFO, * PCONVINFO;

//
// bit flags for dwErrorCode
//
#define ERR_BAD_GPCDATA                     0x0001
#define ERR_OUT_OF_MEMORY                   0x0002
#define ERR_WRITE_FILE                      0x0004
#define ERR_MD_CMD_CALLBACK                 0x0008
#define ERR_CM_GEN_FAV_XY                   0x0010
#define ERR_CM_XM_RESET_FONT                0x0020
#define ERR_CM_XM_ABS_NO_LEFT               0x0040
#define ERR_CM_YM_TRUNCATE                  0x0080
#define ERR_RF_MIN_IS_WHITE                 0x0100
#define ERR_INCONSISTENT_PAGEPROTECT        0x0200
#define ERR_NON_ZERO_FEED_MARGINS_ON_RT90_PRINTER   0x0400
#define ERR_BAD_GPC_CMD_STRING              0x0800
#define ERR_RES_BO_RESET_FONT               0x1000
#define ERR_RES_BO_OEMGRXFILTER             0x2000
#define ERR_CM_YM_RES_DEPENDENT             0x4000
#define ERR_MOVESCALE_NOT_FACTOR_OF_MASTERUNITS            0x8000
#define ERR_NO_CMD_CALLBACK_PARAMS          0x00010000
#define ERR_HAS_DUPLEX_ON_CMD               0x00020000
#define ERR_PSRC_MAN_PROMPT                 0x00040000
#define ERR_PS_SUGGEST_LNDSCP               0x00080000
#define ERR_HAS_SECOND_FONT_ID_CMDS         0x00100000
#define ERR_DLI_FMT_CAPSL                   0x00200000
#define ERR_DLI_FMT_PPDS                    0x00400000
#define ERR_DLI_GEN_DLPAGE                  0x00800000
#define ERR_DLI_GEN_7BIT_CHARSET            0x01000000
#define ERR_DC_SEND_PALETTE                 0x02000000
#define ERR_RES_BO_NO_ADJACENT              0x04000000
#define ERR_MD_NO_ADJACENT                  0x08000000
#define ERR_CURSOR_ORIGIN_ADJUSTED          0x10000000
#define ERR_PRINTABLE_ORIGIN_ADJUSTED       0x20000000
#define ERR_PRINTABLE_AREA_ADJUSTED         0x40000000
#define ERR_MOVESCALE_NOT_FACTOR_INTO_SOME_RESSCALE 0x80000000

#define NUM_ERRS  32 // increment this number when defining new ERR_xxx!!!

#if defined(__cplusplus)
extern "C" {
#endif

extern DWORD gdwErrFlag[NUM_ERRS];
extern PSTR gpstrErrMsg[NUM_ERRS];

#if defined(__cplusplus)
}
#endif

//
// bit flags for dwMode
//
#define FM_SYN_PAGEPROTECT                  0x0001
#define FM_VOUT_LIST                        0x0002
#define FM_RES_DM_GDI                       0x0004
#define FM_RES_DM_DOWNLOAD_OUTLINE          0x0008
#define FM_NO_RES_DM_DOWNLOAD_OUTLINE       0x0010
#define FM_MEMORY_FEATURE_EXIST             0x0020
#define FM_HAVE_SEEN_NON_ZERO_FEED_MARGINS  0x0040
#define FM_HAVE_SAME_TOP_BOTTOM_MARGINS     0x0080
#define FM_SET_CURSOR_ORIGIN         0x0100

//
// values for dwStrType field
//
#define STR_DIRECT  0   // output display strings directly. The default.
#define STR_MACRO   1   // output display strings as value macros (see stdnames.gpd)
#define STR_RCID    2   // output display strings as RC id's (see common.rc)
#define STR_RCID_SYSTEM_PAPERNAMES    3   // output display strings as RC id's (see common.rc)
                                                                //  Except use spooler standard papernames

//
// macro definitions to hide differences between GPC2.0 and GPC3.0
//
#define GETEXTCD(pdh, pcd) (PEXTCD)((PBYTE)(pcd+1) + (pcd)->wLength +    \
                                    (((pdh)->wVersion >= GPC_VERSION3) ? \
                                    (((pcd)->wLength) & 1) : 0))

#define LETTER300X300MEM 1028 // page protection memory constant in GPC2

#define GETPAGEPROMEM(pdh, pps) (((pdh)->wVersion >= GPC_VERSION3) ? \
                                 pps->wPageProtMem : LETTER300X300MEM)

#define DHOFFSET(pdh, sHeapOffset) ((PSHORT)(((PBYTE)(pdh)) + (pdh)->loHeap + \
                                sHeapOffset))

// utility functions for accessing GPC data & file ops.
#if defined(__cplusplus)
extern "C" {
#endif

#if defined(DEVSTUDIO) && defined(__cplusplus)
#include    "..\GPC2GPD\Utils.H"
#else
#include "utils.h"
#endif

//
// function prototypes
//
DWORD
DwCalcMoveUnit(
    IN PCONVINFO pci,
    IN PCURSORMOVE pcm,
    IN WORD wMasterUnit,
    IN WORD wStartOCD,
    IN WORD wEndOCD);

WORD WGetDefaultIndex(IN PCONVINFO pci, IN WORD wMDOI);

void VOutputUIEntries(IN OUT PCONVINFO pci);

void VOutputPrintingEntries(IN OUT PCONVINFO pci);

#if defined(DEVSTUDIO)
void    vMapFontList(IN OUT PWORD pwFonts, IN DWORD dwcFonts, IN PCONVINFO pci);
#endif

#if defined(__cplusplus)
}
#endif
#endif // !_GPC2GPD_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\tools\uni\gpc2gpd\uientry.c ===
/*++

Copyright (c) 1996-1998  Microsoft Corporation

Module Name:

    uientry.c

Abstract:

    This file implements functions that generate UI related GPD entries, such
    as *Feature, *Option, etc.

Environment:

    User-mode, stand-alone utility tool

Revision History:

    10/16/96 -zhanw-
        Created it.

    04/16/97 -zhanw-
        Generated Halftone and palette ColorMode options.

--*/

#include "gpc2gpd.h"

//
// the following constant definitions must match "printer5\inc\common.rc".
//
#define RCID_ORIENTATION    11100
#define RCID_PAPERSIZE      11101
#define RCID_INPUTBIN       11102
#define RCID_RESOLUTION     11103
#define RCID_MEDIATYPE      11104
#define RCID_TEXTQUALITY    11105
#define RCID_COLORMODE      11106
#define RCID_MEMORY         11107
#define RCID_DUPLEX         11108
#define RCID_PAGEPROTECTION 11109
#define RCID_HALFTONE       11110

#define RCID_PORTRAIT       11025
#define RCID_LANDSCAPE      11026

#define RCID_MONO           11030
#define RCID_COLOR          11031
#define RCID_8BPP           11032
#define RCID_24BPP          11033

#define RCID_NONE               11040
#define RCID_FLIP_ON_LONG_EDGE  11041
#define RCID_FLIP_ON_SHORT_EDGE 11042

#define RCID_HT_AUTO_SELECT 11050
#define RCID_HT_SUPERCELL   11051
#define RCID_HT_DITHER6X6   11052
#define RCID_HT_DITHER8X8   11053

#define RCID_ON             11090
#define RCID_OFF            11091

#define RCID_DOTS_PER_INCH  11400

#define RCID_PAPER_SYSTEMNAME 0x7fffffff
    //  secret value that the UI code will understand
    //  to mean, do enumForms to determine the actual paper name


void
VOutputOrientation(
    IN OUT PCONVINFO pci)
{
    BOOL bDocSetup;
    WORD wOrder;

    VOut(pci, "*Feature: Orientation\r\n");
    VOut(pci, "{\r\n");

    if (pci->dwStrType == STR_MACRO)
        VOut(pci, "    *rcNameID: =ORIENTATION_DISPLAY\r\n");
    else if (pci->dwStrType == STR_DIRECT)
        VOut(pci, "    *Name: \"Orientation\"\r\n");
    else
        VOut(pci, "    *rcNameID: %d\r\n", RCID_ORIENTATION);

    VOut(pci, "    *DefaultOption: PORTRAIT\r\n");
    VOut(pci, "    *Option: PORTRAIT\r\n");
    VOut(pci, "    {\r\n");

    if (pci->dwStrType == STR_MACRO)
        VOut(pci, "        *rcNameID: =PORTRAIT_DISPLAY\r\n");
    else if (pci->dwStrType == STR_DIRECT)
        VOut(pci, "        *Name: \"Portrait\"\r\n");
    else
        VOut(pci, "        *rcNameID: %d\r\n", RCID_PORTRAIT);

    //
    // check if there is orientation selection commands.
    //
    bDocSetup = BInDocSetup(pci, PC_ORD_ORIENTATION, &wOrder);
    if (wOrder > 0 &&
        BBuildCmdStr(pci, CMD_PC_PORTRAIT, pci->ppc->rgocd[PC_OCD_PORTRAIT]))
        VOutputSelectionCmd(pci, bDocSetup, wOrder);
    VOut(pci, "    }\r\n");
    //
    // now compose Landscape option
    //
    if (pci->pmd->fGeneral & MD_LANDSCAPE_RT90)
        VOut(pci, "    *Option: LANDSCAPE_CC90\r\n");
    else
        VOut(pci, "    *Option: LANDSCAPE_CC270\r\n");

    VOut(pci, "    {\r\n");

    if (pci->dwStrType == STR_MACRO)
        VOut(pci, "        *rcNameID: =LANDSCAPE_DISPLAY\r\n");
    else if (pci->dwStrType == STR_DIRECT)
        VOut(pci, "        *Name: \"Landscape\"\r\n");
    else
        VOut(pci, "        *rcNameID: %d\r\n", RCID_LANDSCAPE);

    if (wOrder > 0 &&
        BBuildCmdStr(pci, CMD_PC_LANDSCAPE, pci->ppc->rgocd[PC_OCD_LANDSCAPE]))
    {
        VOutputSelectionCmd(pci, bDocSetup, wOrder);
        pci->dwMode |= FM_SET_CURSOR_ORIGIN;
    }
    VOut(pci, "    }\r\n");        // close Landscape option

    VOut(pci, "}\r\n");            // close Orientation feature
}

WORD
WGetDefaultIndex(
    IN PCONVINFO pci,
    IN WORD wMDOI)
{
    WORD wDefault;      // 1-based option index
    PWORD pwDefList;
    WORD wOffset;

    //
    // it's guaranteed that there is at least one element in the list
    //
    if (pci->pdh->wVersion >= GPC_VERSION3 && pci->pmd->orgoiDefaults)
    {
        pwDefList = (PWORD)((PBYTE)(pci->pdh) + pci->pdh->loHeap + pci->pmd->orgoiDefaults);
        if (wMDOI > MD_OI_MAX)
            wOffset = wMDOI - MD_I_MAX;     // skip over rgi[] array
        else
            wOffset = wMDOI;
        wDefault = pwDefList[wOffset];
    }
    else
        wDefault = 1;
    return wDefault;
}

void
VGetOptionName(
    OUT PSTR    pBuf,   // output buffer
    IN  short   sID,    // paper size id
    IN  WORD    wIndex, // paper size option index (1-based)
    IN  PSTR    *pstrStdName,    // array of standard names indexed by id
    IN  BOOL    bUser)  // whether there is a special 256 id. Only
                        // PaperSize uses this option.
{
    if (sID < 256)
    {
        //
        // standard id
        //
        sprintf(pBuf, "%s", pstrStdName[sID-1]);
    }
    else if (sID == 256)
    {
        //
        // custom paper size
        //
        sprintf(pBuf, "%s", "CUSTOMSIZE");
    }
    else
    {
        //
        // driver defined paper size. Use the artificial name OptionX where
        // X is the 1-based index of this option. It's guaranteed not to
        // collide with other option names.
        //
        sprintf(pBuf, "Option%d", wIndex);
    }
}

void
VOutputInputBin(
    IN OUT PCONVINFO pci,
    IN PSHORT psIndex)
{
    WORD wDefaultOption;
    PPAPERSOURCE    pps;
    WORD wCount;
    BOOL bDocSetup;
    WORD wOrder;

    VOut(pci, "*Feature: InputBin\r\n");
    VOut(pci, "{\r\n");

    if (pci->dwStrType == STR_MACRO)
        VOut(pci, "    *rcNameID: =PAPER_SOURCE_DISPLAY\r\n");
    else if (pci->dwStrType == STR_DIRECT)
        VOut(pci, "    *Name: \"Paper Source\"\r\n");
    else
        VOut(pci, "    *rcNameID: %d\r\n", RCID_INPUTBIN);

    wDefaultOption = WGetDefaultIndex(pci, MD_OI_PAPERSOURCE);
    pps = (PPAPERSOURCE)GetTableInfo(pci->pdh, HE_PAPERSOURCE,
                                *(psIndex + wDefaultOption - 1) - 1);
    //
    // steal pci->aubCmdBuf to hold the composed option name temporarily
    //
    VGetOptionName((PSTR)pci->aubCmdBuf, pps->sPaperSourceID, wDefaultOption,
                   gpstrStdIBName, FALSE);
    VOut(pci, "    *DefaultOption: %s\r\n", (PSTR)pci->aubCmdBuf);
    //
    // loop through index list to create one option for each element
    //
    wCount = 1;
    while (*psIndex)
    {
        pps = (PPAPERSOURCE)GetTableInfo(pci->pdh, HE_PAPERSOURCE, *psIndex - 1);
        VGetOptionName((PSTR)pci->aubCmdBuf, pps->sPaperSourceID, wCount,
                       gpstrStdIBName, FALSE);
        //
        // set up info needed later
        //
        CopyStringA(pci->ppiSrc[wCount-1].aubOptName, pci->aubCmdBuf,
                    MAX_OPTION_NAME_LENGTH);
        pci->ppiSrc[wCount-1].bEjectFF = pps->fGeneral & PSRC_EJECTFF;
        pci->ppiSrc[wCount-1].dwPaperType = (DWORD)pps->fPaperType;

        VOut(pci, "    *Option: %s\r\n", (PSTR)pci->aubCmdBuf);
        VOut(pci, "    {\r\n");
        //
        // for standard InputBin options, use *Name. Otherwise,
        // use *rcNameID.
        //
        if (pps->sPaperSourceID < DMBIN_USER)
        {
            if (pci->dwStrType == STR_MACRO)
                VOut(pci, "        *rcNameID: =%s\r\n",
                     gpstrStdIBDisplayNameMacro[pps->sPaperSourceID - 1]);
            else if (pci->dwStrType == STR_DIRECT)
                VOut(pci, "        *Name: \"%s\"\r\n",
                     gpstrStdIBDisplayName[pps->sPaperSourceID - 1]);
            else
                VOut(pci, "        *rcNameID: %d\r\n",
                     STD_IB_DISPLAY_NAME_ID_BASE + pps->sPaperSourceID - 1);
        }
        else    // must be driver defined media type
        {
            VOut(pci, "        *rcNameID: %d\r\n", pps->sPaperSourceID);
            if (pps->sPaperSourceID > DMBIN_USER)
                VOut(pci, "        *OptionID: %d\r\n", pps->sPaperSourceID);
        }

        //
        // check for fields not used by RASDD but used by Win95 Unidrv.
        //
        if (pps->fGeneral & PSRC_MAN_PROMPT)
        {
            pci->dwErrorCode |= ERR_PSRC_MAN_PROMPT;
            VOut(pci, "*%% Warning: this input bin has PSRC_MAN_PROMPT set in GPC, which is ignored by GPD.\r\n");

        }
#if 0   // move *FeedMargins into CUSTOMSIZE option

        //
        // check paper feed margins
        //
        if (pps->sTopMargin > 0 || pps->sBottomMargin > 0)
            VOut(pci, "        *FeedMargins: PAIR(%d, %d)\r\n",
                                                pps->sTopMargin > 0 ? pps->sTopMargin : 0,
                                                pps->sBottomMargin > 0 ? pps->sBottomMargin : 0);
#else
        if (pps->sTopMargin > 0 || pps->sBottomMargin > 0)
        {
            pci->dwMode |= FM_HAVE_SEEN_NON_ZERO_FEED_MARGINS;
            if (pci->pmd->fGeneral & MD_LANDSCAPE_RT90)
                VOut(pci, "*%% Error: this input bin has non-zero top/bottom margins which are ignored by the converter.\r\n");
            pci->ppiSrc[wCount-1].dwTopMargin =
                            pps->sTopMargin > 0 ? (DWORD)pps->sTopMargin : 0;
            pci->ppiSrc[wCount-1].dwBottomMargin =
                            pps->sBottomMargin > 0 ? (DWORD)pps->sBottomMargin : 0;
        }
#endif

#if 0
        //
        // bin adjustment flags have never been used on NT. Remove them.
        //
        VOut(pci, "        *PaperFeed: %s_%s\r\n",
             gpstrPositionName[pps->sBinAdjust & 0x00FF],
             gpstrPositionName[pps->sBinAdjust & 0xFF00]);
#endif
        //
        // check selection command.
        //
        bDocSetup = BInDocSetup(pci, PC_ORD_PAPER_SOURCE, &wOrder);
        if (wOrder > 0 && BBuildCmdStr(pci, CMD_PAPERSOURCE, pps->ocdSelect))
            VOutputSelectionCmd(pci, bDocSetup, wOrder);

        VOut(pci, "    }\r\n");    // close the option

        psIndex++;
        wCount++;
    }
    pci->dwNumOfSrc = wCount - 1;
    //
    // for optimization: check if all feed margins happen to be
    // the same. If so, don't need to create dependency on
    // InputBin feature later on.
    //
    {
        BOOL bSame = TRUE;
        DWORD i;

        for (i = 1; bSame && i < pci->dwNumOfSrc; i++)
            bSame = bSame &&
                    (pci->ppiSrc[i].dwTopMargin==pci->ppiSrc[0].dwTopMargin) &&
                    (pci->ppiSrc[i].dwBottomMargin==pci->ppiSrc[0].dwBottomMargin);
        if (bSame)
            pci->dwMode |= FM_HAVE_SAME_TOP_BOTTOM_MARGINS;
    }

    VOut(pci, "}\r\n"); // close InputBin feature
}

void
VOutputDummyInputBin(
    IN OUT PCONVINFO pci)
{
    VOut(pci, "*Feature: InputBin\r\n");
    VOut(pci, "{\r\n");

    if (pci->dwStrType == STR_MACRO)
        VOut(pci, "    *rcNameID: =PAPER_SOURCE_DISPLAY\r\n");
    else if (pci->dwStrType == STR_DIRECT)
        VOut(pci, "    *Name: \"Paper Source\"\r\n");
    else
        VOut(pci, "    *rcNameID: %d\r\n", RCID_INPUTBIN);

    VOut(pci, "    *DefaultOption: AUTO\r\n");

    VOut(pci, "    *Option: AUTO\r\n");
    VOut(pci, "    {\r\n");

    if (pci->dwStrType == STR_MACRO)
        VOut(pci, "        *rcNameID: =%s\r\n",
             gpstrStdIBDisplayNameMacro[6]);
    else if (pci->dwStrType == STR_DIRECT)
        VOut(pci, "        *Name: \"%s\"\r\n",
             gpstrStdIBDisplayName[6]);
    else
        VOut(pci, "        *rcNameID: 10262\r\n");

    VOut(pci, "    }\r\n");	// Close option

    VOut(pci, "}\r\n");		// Close feature

}
void
VOutputPSOthers(
    IN OUT PCONVINFO pci,
    IN POINTw * pptSize,
    IN BOOL     bRotateSize,
    IN RECTw  * prcMargins,
    IN POINTw * pptCursorOrig,
    IN OCD      ocd,
    IN BOOL     bL4Indentation)
/*++
Routine Description:
    This function outputs other left-over PAPERSIZE fields, i.e. printable area,
    printable origin, cursor origin, and selection command. The
    indentation is either 8 or 16 spaces if bL4Indentation is TRUE.

    Enforce that *PrintableArea and *PrintableOrigin are divisible by the scale
    of any resolution. If not, truncate *PrintableArea and/or round up
    *PrintableOrigin.

    Enforce that if the printer can rotate the logical coordinate, then
    *CursorOrigin are divisible by the scale of
    the move units. If not, round up *CursorOrigin.

Arguments:
    pci: conversion relatedi info
    pptSize: 2 short's describing the physical x/y dimensions in Portrait
    prcMargins: 4 short's describing the margins
    pptCursorOrig: 2 short's describing the cursor origin in Portrait
    ocd: the heap offset of the command
        bL4Indentation: whether to use Level 4 or Level 2 indentation

Return Value:
    None

--*/
{
    WORD x, y;  // temporary variables
    WORD xSize, ySize; // temporary variables
    POINTw  ptSize; // store printable area values
    WORD xScale, yScale;
    BOOL bOutputResDependency = FALSE;
    BOOL bOutputSwitch = TRUE;
    BOOL bDocSetup;
    WORD wOrder;
    WORD i;

    if (pptSize && prcMargins)
    {
        if (bRotateSize)
        {
            ptSize.x = pptSize->y - prcMargins->left - prcMargins->right;
            ptSize.y = pptSize->x - prcMargins->top - prcMargins->bottom;
        }
        else
        {
            ptSize.x = pptSize->x - prcMargins->left - prcMargins->right;
            ptSize.y = pptSize->y - prcMargins->top - prcMargins->bottom;
        }
        //
        // use the original value as the base. Generate the dependency on
        // Resolution only if there is at least one resolution that requires
        // adjustement.
        //
        VOut(pci, "%s        *PrintableArea: PAIR(%d, %d)\r\n",
                  bL4Indentation? "        " : "", ptSize.x, ptSize.y);
        VOut(pci, "%s        *PrintableOrigin: PAIR(%d, %d)\r\n",
                  bL4Indentation? "        " : "",
                  prcMargins->left, prcMargins->top);
        //
        // ensure that the printable area and origin are divisible by the
        // scale of any resolution. Truncate the printable area if needed.
        // Round up the printable origin if needed. Also, must ensure that
        // the new printable area is contained within the old printable area.
        //
        for (i = 0; i < (WORD)pci->dwNumOfRes; i++)
        {
            xScale = (WORD)pci->presinfo[i].dwXScale;
            yScale = (WORD)pci->presinfo[i].dwYScale;

            xSize = (ptSize.x / xScale) * xScale;
            ySize = (ptSize.y / yScale) * yScale;
            x = ((prcMargins->left + xScale - 1) / xScale) * xScale;
            y = ((prcMargins->top + yScale - 1) / yScale) * yScale;
            //
            // check if the new printable area is contained within the old
            // printable area. If not, truncate the printable width or
            // length further.
            //
            if (x + xSize > prcMargins->left + ptSize.x)
                xSize -= xScale;
            if (y + ySize > prcMargins->top + ptSize.y)
                ySize -= yScale;

            if (xSize == ptSize.x && ySize == ptSize.y &&
                x == prcMargins->left && y == prcMargins->top)
                continue;   // no adjustment needed for this resolution
            //
            // otherwise, some adjustment is needed.
            //
            bOutputResDependency = TRUE;
            if (bOutputSwitch)
            {
                VOut(pci, "%s        *switch: Resolution\r\n%s        {\r\n",
                          bL4Indentation? "        " : "",
                          bL4Indentation? "        " : "");
                bOutputSwitch = FALSE;
            }
            VOut(pci, "%s            *case: %s\r\n%s            {\r\n",
                          bL4Indentation? "        " : "",
                          pci->presinfo[i].aubOptName,
                          bL4Indentation? "        " : "");

            if (xSize != ptSize.x || ySize != ptSize.y)
            {
                pci->dwErrorCode |= ERR_PRINTABLE_AREA_ADJUSTED;
                if (xSize != ptSize.x)
                    VOut(pci,
                        "*%% Warning: the following printable width is adjusted (%d->%d) so it is divisible by the resolution X scale.\r\n",
                        ptSize.x, xSize);
                if (ySize != ptSize.y)
                    VOut(pci,
                        "*%% Warning: the following printable length is adjusted (%d->%d) so it is divisible by the resolution Y scale.\r\n",
                        ptSize.y, ySize);
                VOut(pci, "%s                *PrintableArea: PAIR(%d, %d)\r\n",
                          bL4Indentation? "        " : "",
                          xSize, ySize);
            }
            if (x != prcMargins->left || y != prcMargins->top)
            {
                pci->dwErrorCode |= ERR_PRINTABLE_ORIGIN_ADJUSTED;
                if (x != prcMargins->left)
                    VOut(pci,
                        "*%% Warning: the following printable origin X is adjusted (%d->%d) so it is divisible by the resolution X scale.\r\n",
                        prcMargins->left, x);
                if (y != prcMargins->top)
                    VOut(pci,
                        "*%% Warning: the following printable origin Y is adjusted (%d->%d) so it is divisible by the resolution Y scale.\r\n",
                        prcMargins->top, y);

                VOut(pci, "%s                *PrintableOrigin: PAIR(%d, %d)\r\n",
                      bL4Indentation? "        " : "", x, y);
            }
            //
            // close the *case construct
            //
            VOut(pci, "%s            }\r\n", bL4Indentation? "        " : "");
        }   // end for loop
        if (bOutputResDependency)
            //
            // close *switch construct
            //
            VOut(pci, "%s        }\r\n", bL4Indentation? "        " : "");

    }

    if (pptCursorOrig)  // should output *CursorOrigin entry
    {
        //
        // ensure that cursor origin are divisible by the scale of
        // move unit if the printer is not a dot-matrix printer. We are
        // assuming that for dot-matrix printers, the *CursorOrigin entry
        // is always missing. If it's not missing, then the printing offset
        // may be off a little. But we don't think the accuracy is so
        // important for dot-matrix printers.
        //
        // Round up if needed.
        //
        x = pptCursorOrig->x;
        y = pptCursorOrig->y;
        if (pci->dwMode & FM_RES_DM_GDI)
        {
            if (pci->ptMoveScale.x > 1)
            {
                x = ((x + pci->ptMoveScale.x - 1) / pci->ptMoveScale.x) *
                       pci->ptMoveScale.x;
                if (x != pptCursorOrig->x)
                {
                    pci->dwErrorCode |= ERR_CURSOR_ORIGIN_ADJUSTED;
                    VOut(pci,
                     "*%% Warning: the following *CursorOrigin X value is adjusted (%d->%d) so it is divisible by scale of X move unit.\r\n",
                     pptCursorOrig->x, x);
                }
            }
            if (pci->ptMoveScale.y > 1)
            {
                y = ((y + pci->ptMoveScale.y - 1) / pci->ptMoveScale.y) *
                    pci->ptMoveScale.y;
                if (y != pptCursorOrig->y)
                {
                    pci->dwErrorCode |= ERR_CURSOR_ORIGIN_ADJUSTED;
                    VOut(pci,
                     "*%% Warning: the following *CursorOrigin Y value is adjusted (%d->%d) so it is divisible by scale of Y move unit.\r\n",
                     pptCursorOrig->y, y);
                }
            }
        }
        VOut(pci, "%s        *CursorOrigin: PAIR(%d, %d)\r\n",
                                bL4Indentation? "        " : "",
                                x, y);
    }

    if (ocd != NOOCD)
    {
        bDocSetup = BInDocSetup(pci, PC_ORD_PAPER_SIZE, &wOrder);
        //
        // this selection command has 3-level indentation instead of 2. So
        // can't call VOutputSelectionCmd().
        //
        if (wOrder > 0 && BBuildCmdStr(pci, CMD_PAPERSIZE, ocd))
        {
            VOut(pci, "%s        *Command: CmdSelect\r\n%s        {\r\n",
                                        bL4Indentation? "        " : "",
                                        bL4Indentation? "        " : "");
            VOut(pci, "%s            *Order: %s.%d\r\n",
                                bL4Indentation? "        " : "",
                                bDocSetup? "DOC_SETUP" : "PAGE_SETUP",
                                wOrder);
            if (pci->wCmdCallbackID > 0)
                VOut(pci, "%s            *CallbackID: %d\r\n",
                                        bL4Indentation? "        " : "",
                                        pci->wCmdCallbackID);
            else
                VOut(pci, "%s            *Cmd: %s\r\n",
                                        bL4Indentation? "        " : "",
                                        pci->aubCmdBuf);
            VOut(pci, "%s        }\r\n",
                                bL4Indentation? "        " : "");
        }
    }
}

void
VAdjustHMargins(
    PCONVINFO   pci,
    PPAPERSIZE  pps,
    RECTw   *   prcInMargins,
    RECTw   *   prcOutMargins)
{
    DWORD   dwWidth, dwHMargin, dwLeftMargin, dwRightMargin;

    //
    // handle -1 case (treated the same as 0, no margin)
    //
    prcOutMargins->top = prcInMargins->top > 0 ? prcInMargins->top : 0;
    prcOutMargins->bottom = prcInMargins->bottom > 0 ? prcInMargins->bottom : 0;
    prcOutMargins->left = prcInMargins->left > 0 ? prcInMargins->left : 0;
    prcOutMargins->right = prcInMargins->right > 0 ? prcInMargins->right : 0;

    dwWidth = (DWORD)((pps->fGeneral & PS_ROTATE) ? pps->ptSize.y : pps->ptSize.x);
    if (dwWidth > (DWORD)pci->pmd->ptMax.x)
    {
        dwHMargin = dwWidth - (DWORD)pci->pmd->ptMax.x;
            VOut(pci, "*%% Warning: this paper size exceeds the MaxWidth, imageable width is truncated . \r\n");
    }
    else
        dwHMargin = 0;
    if (pps->fGeneral & PS_CENTER)
        dwLeftMargin = dwHMargin / 2;
        else
                dwLeftMargin = 0;
    if (dwLeftMargin < (DWORD)pci->pmd->sLeftMargin)
        dwLeftMargin = (DWORD)pci->pmd->sLeftMargin;

    if ((DWORD)prcOutMargins->left < dwLeftMargin)
        prcOutMargins->left = (WORD)dwLeftMargin;

    if (dwHMargin > (DWORD)prcOutMargins->left)
        dwRightMargin = dwHMargin - (DWORD)prcOutMargins->left;
    else
        dwRightMargin = 0;

    if ((DWORD)prcOutMargins->right < dwRightMargin)
        prcOutMargins->right = (WORD)dwRightMargin;
}

void
VAdjustHAndVMargins(
    PCONVINFO   pci,
    PPAPERSIZE  pps,
    RECTw   *   prcInMargins,
    DWORD       dwTopMargin,
    DWORD       dwBottomMargin,
    RECTw   *   prcOutMargins)
{
    VAdjustHMargins(pci, pps, prcInMargins, prcOutMargins);

    if ((DWORD)prcOutMargins->top < dwTopMargin)
        prcOutMargins->top = (WORD)dwTopMargin;

    if ((DWORD)prcOutMargins->bottom < dwBottomMargin)
        prcOutMargins->bottom = (WORD)dwBottomMargin;

}


void
VOutputPaperSize(
    IN OUT PCONVINFO pci,
    IN PSHORT psIndex)
{
    WORD wDefaultOption, wCount;
    PPAPERSIZE  pps;
    BOOL bGPC3 = pci->pdh->wVersion >= GPC_VERSION3;
    RECTw rcOutMargins;

    VOut(pci, "*Feature: PaperSize\r\n");
    VOut(pci, "{\r\n");

    if (pci->dwStrType == STR_MACRO)
        VOut(pci, "    *rcNameID: =PAPER_SIZE_DISPLAY\r\n");
    else if (pci->dwStrType == STR_DIRECT)
        VOut(pci, "    *Name: \"Paper Size\"\r\n");
    else
        VOut(pci, "    *rcNameID: %d\r\n", RCID_PAPERSIZE);

    wDefaultOption = WGetDefaultIndex(pci, MD_OI_PAPERSIZE);
    pps = (PPAPERSIZE)GetTableInfo(pci->pdh, HE_PAPERSIZE,
                                   *(psIndex + wDefaultOption - 1) - 1);
    //
    // steal pci->aubCmdBuf to hold composed option name temporarily
    //
    VGetOptionName((PSTR)pci->aubCmdBuf, pps->sPaperSizeID, wDefaultOption,
                   gpstrStdPSName, TRUE);
    VOut(pci, "    *DefaultOption: %s\r\n", (PSTR)pci->aubCmdBuf);

    //
    // loop through index list to create one option for each element
    //
    wCount = 1;
    while (*psIndex)
    {
        pps = (PPAPERSIZE)GetTableInfo(pci->pdh, HE_PAPERSIZE, *psIndex - 1);
        VGetOptionName((PSTR)pci->aubCmdBuf, pps->sPaperSizeID, wCount,
                       gpstrStdPSName, TRUE);
        //
        // set up info needed later
        //
        CopyStringA(pci->ppiSize[wCount-1].aubOptName, pci->aubCmdBuf,
                    MAX_OPTION_NAME_LENGTH);
        pci->ppiSize[wCount-1].bEjectFF = pps->fGeneral & PS_EJECTFF;
        pci->ppiSize[wCount-1].dwPaperType = (DWORD)pps->fPaperType;

        VOut(pci, "    *Option: %s\r\n", (PSTR)pci->aubCmdBuf);
        VOut(pci, "    {\r\n");
        //
        // for standard PaperSize options, use *Name. Otherwise,
        // use *rcNameID.
        //
        if (pps->sPaperSizeID < DMPAPER_USER)
        {
            if (pci->bUseSystemPaperNames)
                VOut(pci, "        *rcNameID: =RCID_DMPAPER_SYSTEM_NAME\r\n");
            else if (pci->dwStrType == STR_MACRO)
                VOut(pci, "        *rcNameID: =%s\r\n",
                     gpstrStdPSDisplayNameMacro[pps->sPaperSizeID - 1]);
            else if (pci->dwStrType == STR_DIRECT)
                VOut(pci, "        *Name: \"%s\"\r\n",
                     gpstrStdPSDisplayName[pps->sPaperSizeID - 1]);
            else
                VOut(pci, "        *rcNameID: %d\r\n",
                     STD_PS_DISPLAY_NAME_ID_BASE + pps->sPaperSizeID - 1);

        }
        else if (pps->sPaperSizeID == DMPAPER_USER)
        {
            if (pci->dwStrType == STR_MACRO)
                VOut(pci, "        *rcNameID: =USER_DEFINED_SIZE_DISPLAY\r\n");
            else if (pci->dwStrType == STR_DIRECT)
                VOut(pci, "        *Name: \"User Defined Size\"\r\n");
            else
                VOut(pci, "        *rcNameID: %d\r\n",
                     STD_PS_DISPLAY_NAME_ID_BASE + DMPAPER_USER - 1);

            VOut(pci, "        *MinSize: PAIR(%d, %d)\r\n", pci->pmd->ptMin.x,
                                                     pci->pmd->ptMin.y);
            VOut(pci, "        *MaxSize: PAIR(%d, %d)\r\n", pci->pmd->sMaxPhysWidth,
                 (pci->pmd->ptMax.y == NOT_USED) ? 0x7FFF : pci->pmd->ptMax.y);

            VOut(pci, "        *MaxPrintableWidth: %d\r\n", (DWORD)pci->pmd->ptMax.x);
            VOut(pci, "        *MinLeftMargin: %d\r\n", pci->pmd->sLeftMargin);
            VOut(pci, "        *CenterPrintable?: %s\r\n",
                      (pps->fGeneral & PS_CENTER)? "TRUE" : "FALSE");
            if ((pci->dwMode & FM_HAVE_SEEN_NON_ZERO_FEED_MARGINS) &&
                (pci->dwMode & FM_HAVE_SAME_TOP_BOTTOM_MARGINS))
            {
                VOut(pci, "        *TopMargin: %d\r\n", pci->ppiSrc[0].dwTopMargin);
                VOut(pci, "        *BottomMargin: %d\r\n", pci->ppiSrc[0].dwBottomMargin);
            }
            else if (pci->dwMode & FM_HAVE_SEEN_NON_ZERO_FEED_MARGINS)
            {
                DWORD i;

                //
                // need to create dependency on InputBin.
                //
                VOut(pci, "        *switch: InputBin\r\n");
                VOut(pci, "        {\r\n");

                for (i = 0; i < pci->dwNumOfSrc; i++)
                {
                    VOut(pci, "            *case: %s\r\n", pci->ppiSrc[i].aubOptName);
                    VOut(pci, "            {\r\n");
                    VOut(pci, "                *TopMargin: %d\r\n", pci->ppiSrc[i].dwTopMargin);
                    VOut(pci, "                *BottomMargin: %d\r\n", pci->ppiSrc[i].dwBottomMargin);
                    VOut(pci, "            }\r\n");    // close *case
                }
                VOut(pci, "        }\r\n"); // close *switch
            }

        }
        else
        {
            VOut(pci, "        *rcNameID: %d\r\n", pps->sPaperSizeID);
            VOut(pci, "        *OptionID: %d\r\n", pps->sPaperSizeID);
            VOut(pci, "        *PageDimensions: PAIR(%d, %d)\r\n", pps->ptSize.x,
                                                            pps->ptSize.y);
        }
        if (pps->fGeneral & PS_ROTATE)
            VOut(pci, "        *RotateSize? : TRUE\r\n");
        if (pps->fGeneral & PS_SUGGEST_LNDSCP)
        {
            pci->dwErrorCode |= ERR_PS_SUGGEST_LNDSCP;
            VOut(pci, "*%% Warning: this paper size has PS_SUGGEST_LNDSCP set in GPC, which is ignored by GPD. \r\n");
        }
        if (pci->pmd->fGeneral & MD_PCL_PAGEPROTECT)
        {
            VOut(pci, "        *PageProtectMem: %d\r\n", GETPAGEPROMEM(pci->pdh, pps));
            //
            // check if we should synthesize a PageProtect feature later.
            // Note that we assume that all paper size options have the same
            // commands to turn on/off page protection feature. This is a bit
            // hacky, but it's really because GPC defined it in a awkward way.
            // All existing GPC minidrivers are consistent with the assumption.
            //
            if (bGPC3)
            {
                //
                // the first option establish the PP feature
                //
                if (wCount == 1)
                {
                    if ((pci->ocdPPOn = pps->rgocd[PSZ_OCD_PAGEPROTECT_ON])
                        != NOOCD &&
                        (pci->ocdPPOff = pps->rgocd[PSZ_OCD_PAGEPROTECT_OFF])
                        != NOOCD)
                        pci->dwMode |= FM_SYN_PAGEPROTECT;
                }
                //
                // make sure following options are consistent with the
                // first option. If not, report error and don't synthesize.
                //
                else if (pci->dwMode & FM_SYN_PAGEPROTECT)
                {
                    if (pps->rgocd[PSZ_OCD_PAGEPROTECT_ON] == NOOCD ||
                        pps->rgocd[PSZ_OCD_PAGEPROTECT_OFF] == NOOCD)
                    {
                        pci->dwMode &= ~FM_SYN_PAGEPROTECT;
                        pci->dwErrorCode |= ERR_INCONSISTENT_PAGEPROTECT;
                    }
                }
                else // wCount > 1 && !(pci->dwMode & FM_SYN_PAGEPROTECT)
                {
                    if (pps->rgocd[PSZ_OCD_PAGEPROTECT_ON] != NOOCD ||
                        pps->rgocd[PSZ_OCD_PAGEPROTECT_OFF] != NOOCD)
                        pci->dwErrorCode |= ERR_INCONSISTENT_PAGEPROTECT;
                }
            }
        } // end if (pci->pmd->fGeneral & MD_PCL_PAGEPROTECT)...
        //
        // Output margin related entries and selection cmd
        //
        //
        // check GPC version. If 3.0 or above, and if MD_LANDSCAPE_RT90 bit
        // if set (i.e. different margins and cursor origins might be used
        // for different orientations, and there are cmds to set the logical
        // orientation), then generate *switch/*case dependency on Orientation.
        // The dependency clause contains *PrintableArea, *PrintableOrigin,
        // *CursorOrigin and the selection command.
        //

        if (bGPC3 && (pci->pmd->fGeneral & MD_LANDSCAPE_RT90))
        {
            POINTw  ptCursor;
            BOOL    bUseCursorOrigin;

            bUseCursorOrigin = (pci->dwMode & FM_SET_CURSOR_ORIGIN) ||
                               (pci->pmd->fGeneral & MD_USE_CURSOR_ORIG);
            //
            // assume that in this case there is no margins resulted from
            // input slot. Verify that.
            //
            if (pci->dwMode & FM_HAVE_SEEN_NON_ZERO_FEED_MARGINS)
                pci->dwErrorCode |= ERR_NON_ZERO_FEED_MARGINS_ON_RT90_PRINTER;

            VOut(pci, "        *switch: Orientation\r\n");
            VOut(pci, "        {\r\n");
            VOut(pci, "            *case: PORTRAIT\r\n");
            VOut(pci, "            {\r\n");
            //
            // take into account MODELDATA.sMinLeftMargin & MODELDATA.ptMax.x
            //
            if (pps->sPaperSizeID == DMPAPER_USER)
            {
                //
                // for use-defined size, we don't output *CursorOrigin
                // since it doesn't make sense.
                //
                VOutputPSOthers(pci, NULL, FALSE, NULL, NULL,
                                pps->rgocd[PSZ_OCD_SELECTPORTRAIT], TRUE);
            }
            else
            {
                VAdjustHMargins(pci, pps, &pps->rcMargins, &rcOutMargins);
                if (pci->pmd->fGeneral & MD_USE_CURSOR_ORIG)
                {
                    ptCursor.x = pps->ptCursorOrig.x;
                    ptCursor.y = pps->ptCursorOrig.y;
                }
                else if (pci->dwMode & FM_SET_CURSOR_ORIGIN)
                {
                    ptCursor.x = rcOutMargins.left;
                    ptCursor.y = rcOutMargins.top;
                }
                VOutputPSOthers(pci, &pps->ptSize, pps->fGeneral & PS_ROTATE,
                                &rcOutMargins,
                                bUseCursorOrigin ? &ptCursor : NULL,
                                pps->rgocd[PSZ_OCD_SELECTPORTRAIT], TRUE);
            }
            VOut(pci, "            }\r\n");    // close *case: Portrait

            VOut(pci, "            *case: LANDSCAPE_CC90\r\n");
            VOut(pci, "            {\r\n");
            if (pps->sPaperSizeID == DMPAPER_USER)
            {
                VOutputPSOthers(pci, NULL, FALSE, NULL, NULL,
                                pps->rgocd[PSZ_OCD_SELECTLANDSCAPE], TRUE);
            }
            else
            {
                VAdjustHMargins(pci, pps, &pps->rcLMargins, &rcOutMargins);
                //
                // convert ptLCursorOrig (in Landscape) to corresponding values
                // as in Portrait orientation.
                //
                if (pci->pmd->fGeneral & MD_USE_CURSOR_ORIG)
                {
                    ptCursor.x = pps->ptLCursorOrig.y;
                    ptCursor.y = ((pps->fGeneral & PS_ROTATE) ?
                                  pps->ptSize.x : pps->ptSize.y) -
                                 pps->ptLCursorOrig.x;
                }
                else if (pci->dwMode & FM_SET_CURSOR_ORIGIN)
                {
                    ptCursor.x = rcOutMargins.left;
                    ptCursor.y = ((pps->fGeneral & PS_ROTATE) ?
                                  pps->ptSize.x : pps->ptSize.y) -
                                 rcOutMargins.bottom;
                }
                VOutputPSOthers(pci, &pps->ptSize, pps->fGeneral & PS_ROTATE,
                                &rcOutMargins,
                                bUseCursorOrigin ? &ptCursor : NULL,
                                pps->rgocd[PSZ_OCD_SELECTLANDSCAPE], TRUE);
            }
            VOut(pci, "            }\r\n");    // close *case: Landscape
            VOut(pci, "        }\r\n"); // close *switch: Orientation
        }
        else if (pps->sPaperSizeID == DMPAPER_USER)
        {
            //
            // output CmdSelect, if any.
            //
            VOutputPSOthers(pci, NULL, FALSE, NULL, NULL,
                            pps->rgocd[PSZ_OCD_SELECTPORTRAIT], FALSE);
        }
        else
        {
            //
            // in this case, there is no separate commands to set
            // logical orientation.
            //
            BOOL bUseCO = pci->pmd->fGeneral & MD_USE_CURSOR_ORIG;

            if (pci->dwMode & FM_HAVE_SEEN_NON_ZERO_FEED_MARGINS)
            {
                DWORD i;

                if (pci->dwMode & FM_HAVE_SAME_TOP_BOTTOM_MARGINS)
                {
                    VAdjustHAndVMargins(pci, pps, &pps->rcMargins,
                                        pci->ppiSrc[0].dwTopMargin,
                                        pci->ppiSrc[0].dwBottomMargin,
                                        &rcOutMargins);
                    VOutputPSOthers(pci, &pps->ptSize, pps->fGeneral & PS_ROTATE,
                                    &rcOutMargins,
                                    bUseCO ? &pps->ptCursorOrig : NULL,
                                    pps->rgocd[PSZ_OCD_SELECTPORTRAIT], FALSE);
                }
                else
                {
                    //
                    // need to create dependency on InputBin. But leave
                    // *CursorOrigin and CmdSelect out of it.
                    //
                    VOutputPSOthers(pci, NULL, FALSE, NULL,
                                    bUseCO ? &pps->ptCursorOrig : NULL,
                                    pps->rgocd[PSZ_OCD_SELECTPORTRAIT], FALSE);

                    VOut(pci, "        *switch: InputBin\r\n");
                    VOut(pci, "        {\r\n");

                    for (i = 0; i < pci->dwNumOfSrc; i++)
                    {
                        VOut(pci, "            *case: %s\r\n", pci->ppiSrc[i].aubOptName);
                        VOut(pci, "            {\r\n");
                        VAdjustHAndVMargins(pci, pps, &pps->rcMargins,
                                                pci->ppiSrc[i].dwTopMargin,
                                                pci->ppiSrc[i].dwBottomMargin,
                                                &rcOutMargins);
                        VOutputPSOthers(pci, &pps->ptSize, pps->fGeneral & PS_ROTATE,
                                        &rcOutMargins, NULL, NOOCD, TRUE);
                        VOut(pci, "            }\r\n");    // close *case
                    }
                    VOut(pci, "        }\r\n");
                }
            }
            else
            {
                VAdjustHMargins(pci, pps, &pps->rcMargins, &rcOutMargins);
                VOutputPSOthers(pci, &pps->ptSize, pps->fGeneral & PS_ROTATE,
                                &rcOutMargins,
                                bUseCO ? &pps->ptCursorOrig : NULL,
                                pps->rgocd[PSZ_OCD_SELECTPORTRAIT], FALSE);
            }
        }

        VOut(pci, "    }\r\n");    // close the option

        psIndex++;
        wCount++;
    }
    pci->dwNumOfSize = wCount - 1;

    VOut(pci, "}\r\n");
}

void
VOutputResolution(
    IN OUT PCONVINFO pci,
    IN PSHORT  psIndex)
{
    PGPCRESOLUTION pres;
    WORD wCount;
    WORD wDefaultOption;
    BOOL bDocSetup;
    BOOL bColor;
    WORD wOrder;

    //
    // check if this is a color device
    //
    bColor = *((PSHORT)((PBYTE)pci->pdh + pci->pdh->loHeap +
                pci->pmd->rgoi[MD_OI_COLOR])) != 0;
    VOut(pci, "*Feature: Resolution\r\n");
    VOut(pci, "{\r\n");
    if (pci->dwStrType == STR_MACRO)
        VOut(pci, "    *rcNameID: =RESOLUTION_DISPLAY\r\n");
    else if (pci->dwStrType == STR_DIRECT)
        VOut(pci, "    *Name: \"Resolution\"\r\n");
    else
        VOut(pci, "    *rcNameID: %d\r\n", RCID_RESOLUTION);

    wDefaultOption = WGetDefaultIndex(pci, MD_OI_RESOLUTION);
    VOut(pci, "    *DefaultOption: Option%d\r\n", wDefaultOption);
    //
    // loop through index list to create one option for each element
    //
    wCount = 1;
    while (*psIndex)
    {
        WORD wXdpi, wYdpi;

        pres = (PGPCRESOLUTION)GetTableInfo(pci->pdh, HE_RESOLUTION, *psIndex - 1);
        //
        // set up pci->pres for CmdSendBlockData special case in BBuildCmdStr
        //
        pci->pres = pres;
        wXdpi = (WORD)pci->pdh->ptMaster.x / pres->ptTextScale.x;
        wYdpi = (WORD)pci->pdh->ptMaster.y / pres->ptTextScale.y;
        //
        // gather information for later use
        //
        sprintf(pci->presinfo[wCount-1].aubOptName, "Option%d", wCount);
        pci->presinfo[wCount-1].dwXScale = pres->ptTextScale.x << pres->ptScaleFac.x;
        pci->presinfo[wCount-1].dwYScale = pres->ptTextScale.y << pres->ptScaleFac.y;
        pci->presinfo[wCount-1].bColor = pres->fDump & RES_DM_COLOR;

        //
        // assume all GPCRESOLUTION structures use the same dump format.
        //
        if (wCount == 1 && (pres->fDump & RES_DM_GDI))
            pci->dwMode |= FM_RES_DM_GDI;
        VOut(pci, "    *Option: Option%d\r\n", wCount);
        VOut(pci, "    {\r\n");
        //
        // have to compose the actual display name
        //
        if (pci->dwStrType == STR_MACRO)
            VOut(pci, "        *Name: \"%d x %d \" =DOTS_PER_INCH\r\n",
                 wXdpi >> pres->ptScaleFac.x, wYdpi >> pres->ptScaleFac.y);
        else
            VOut(pci, "        *Name: \"%d x %d dots per inch\"\r\n",
                 wXdpi >> pres->ptScaleFac.x, wYdpi >> pres->ptScaleFac.y);

        VOut(pci, "        *DPI: PAIR(%d, %d)\r\n",
                  wXdpi >> pres->ptScaleFac.x, wYdpi >> pres->ptScaleFac.y);
        VOut(pci, "        *TextDPI: PAIR(%d, %d)\r\n", wXdpi, wYdpi);
        if (pres->sNPins > 1)
            VOut(pci, "        *PinsPerLogPass: %d\r\n", pres->sNPins);
        if (pres->sPinsPerPass > 1)
            VOut(pci, "        *PinsPerPhysPass: %d\r\n", pres->sPinsPerPass);
        if (pres->sMinBlankSkip > 0)
            VOut(pci, "        *MinStripBlankPixels: %d\r\n",
                      pres->sMinBlankSkip);
        if (pres->fBlockOut & RES_BO_UNIDIR)
            VOut(pci, "        *RequireUniDir?: TRUE\r\n");

        //
        // Some printers (ex. LJ III) have different stripping flags for
        // different resolutions.
        //
        if (pres->fBlockOut &
            (RES_BO_LEADING_BLNKS | RES_BO_TRAILING_BLNKS | RES_BO_ENCLOSED_BLNKS))
        {
            pci->dwMode |= FM_VOUT_LIST;

            VOut(pci, "        EXTERN_GLOBAL: *StripBlanks: LIST(%s%s%s)\r\n",
                 (pres->fBlockOut & RES_BO_LEADING_BLNKS) ? "LEADING," : "",
                 (pres->fBlockOut & RES_BO_ENCLOSED_BLNKS) ? "ENCLOSED," : "",
                 (pres->fBlockOut & RES_BO_TRAILING_BLNKS) ? "TRAILING" : "");

            pci->dwMode &= ~FM_VOUT_LIST;
        }
        if (pres->fBlockOut & RES_BO_MULTIPLE_ROWS)
            VOut(pci, "        EXTERN_GLOBAL: *SendMultipleRows?: TRUE\r\n");

        //
        // RES_BO_RESET_FONT is used by Win95 Unidrv but not by RASDD.
        // Warn if this flag is set.
        //
        if (pres->fBlockOut & RES_BO_RESET_FONT)
        {
            pci->dwErrorCode |= ERR_RES_BO_RESET_FONT;
            //  set a flag to cause this to be output *ReselectFont in VoutputPrintingEntries
            VOut(pci, "*%% Warning: this resolution has RES_BO_RESET_FONT set in GPC.   *ReselectFont  added\r\n");
        }
        if (pres->fBlockOut & RES_BO_OEMGRXFILTER)
        {
            pci->dwErrorCode |= ERR_RES_BO_OEMGRXFILTER;
            VOut(pci, "*%% Error: this resolution has RES_BO_OEMGRXFILTER set in GPC. You must port over the custom code. \r\n");
        }
        if (pres->fBlockOut & RES_BO_NO_ADJACENT)
        {
            pci->dwErrorCode |= ERR_RES_BO_NO_ADJACENT;
            VOut(pci, "*%% Warning: this resolution has RES_BO_NO_ADJACENT set in GPC, which is ignored by GPD. Custom code is needed.\r\n");
        }
        if (pres->sTextYOffset != 0)
            VOut(pci, "        EXTERN_GLOBAL: *TextYOffset: %d\r\n",
                                  pres->sTextYOffset);

        VOut(pci, "        *SpotDiameter: %d\r\n", pres->sSpotDiameter);
        //
        // output printing commands that come from GPCRESOLUTION structure.
        //
        if (BBuildCmdStr(pci, CMD_RES_BEGINGRAPHICS, pres->rgocd[RES_OCD_BEGINGRAPHICS]))
            VOutputExternCmd(pci, "CmdBeginRaster");

        if (BBuildCmdStr(pci, CMD_RES_ENDGRAPHICS, pres->rgocd[RES_OCD_ENDGRAPHICS]))
            VOutputExternCmd(pci, "CmdEndRaster");

        if (BBuildCmdStr(pci, CMD_RES_SENDBLOCK, pres->rgocd[RES_OCD_SENDBLOCK]))
            VOutputExternCmd(pci, "CmdSendBlockData");

        if (BBuildCmdStr(pci, CMD_RES_ENDBLOCK, pres->rgocd[RES_OCD_ENDBLOCK]))
            VOutputExternCmd(pci, "CmdEndBlockData");

        //
        // check selection command.
        //
        bDocSetup = BInDocSetup(pci, PC_ORD_RESOLUTION,&wOrder);
        if (wOrder > 0 &&
            BBuildCmdStr(pci, CMD_RES_SELECTRES, pres->rgocd[RES_OCD_SELECTRES]))
            VOutputSelectionCmd(pci, bDocSetup, wOrder);
        //
        // gather info for later use
        //
        if (pres->fDump & RES_DM_DOWNLOAD_OUTLINE)
            pci->dwMode |= FM_RES_DM_DOWNLOAD_OUTLINE;
        else
            pci->dwMode |= FM_NO_RES_DM_DOWNLOAD_OUTLINE;

        VOut(pci, "    }\r\n");    // close the option

        psIndex++;
        wCount++;
    }
    pci->dwNumOfRes = wCount - 1;
    VOut(pci, "}\r\n");
}

void
VOutputMediaType(
    IN OUT PCONVINFO pci,
    IN PSHORT psIndex)
{
    WORD wDefaultOption;
    PPAPERQUALITY   ppq;
    WORD wCount;
    BOOL bDocSetup;
    WORD wOrder;

    VOut(pci, "*Feature: MediaType\r\n");
    VOut(pci, "{\r\n");
    if (pci->dwStrType == STR_MACRO)
        VOut(pci, "    *rcNameID: =MEDIA_TYPE_DISPLAY\r\n");
    else if (pci->dwStrType == STR_DIRECT)
        VOut(pci, "    *Name: \"Media Type\"\r\n");
    else
        VOut(pci, "    *rcNameID: %d\r\n", RCID_MEDIATYPE);

    wDefaultOption = WGetDefaultIndex(pci, MD_OI_PAPERQUALITY);
    ppq = (PPAPERQUALITY)GetTableInfo(pci->pdh, HE_PAPERQUALITY,
                                *(psIndex + wDefaultOption - 1) - 1);
    //
    // steal pci->aubCmdBuf as temp buffer for option names
    //
    VGetOptionName((PSTR)pci->aubCmdBuf, ppq->sPaperQualID, wDefaultOption,
                   gpstrStdMTName, FALSE);
    VOut(pci, "    *DefaultOption: %s\r\n", (PSTR)pci->aubCmdBuf);
    //
    // loop through index list to create one option for each element
    //
    wCount = 1;
    while (*psIndex)
    {
        ppq = (PPAPERQUALITY)GetTableInfo(pci->pdh, HE_PAPERQUALITY, *psIndex - 1);
        VGetOptionName((PSTR)pci->aubCmdBuf, ppq->sPaperQualID, wCount,
                       gpstrStdMTName, FALSE);
        VOut(pci, "    *Option: %s\r\n", (PSTR)pci->aubCmdBuf);
        VOut(pci, "    {\r\n");
        //
        // for standard MediaType options, use *Name. Otherwise,
        // use *rcNameID.
        //
        if (ppq->sPaperQualID < DMMEDIA_USER)
        {
            if (pci->dwStrType == STR_MACRO)
                VOut(pci, "        *rcNameID: =%s\r\n",
                     gpstrStdMTDisplayNameMacro[ppq->sPaperQualID - 1]);
            else if (pci->dwStrType == STR_DIRECT)
                VOut(pci, "        *Name: \"%s\"\r\n",
                     gpstrStdMTDisplayName[ppq->sPaperQualID - 1]);
            else
                VOut(pci, "        *rcNameID: %d\r\n",
                     STD_MT_DISPLAY_NAME_ID_BASE + ppq->sPaperQualID - 1);
        }
        else    // must be driver defined media type
        {
            VOut(pci, "        *rcNameID: %d\r\n", ppq->sPaperQualID);
            if (ppq->sPaperQualID > DMMEDIA_USER)
                VOut(pci, "        *OptionID: %d\r\n", ppq->sPaperQualID);
        }
        //
        // check selection command.
        //
        bDocSetup = BInDocSetup(pci, PC_ORD_PAPER_QUALITY, &wOrder);
        if (wOrder > 0 &&
            BBuildCmdStr(pci, CMD_PAPERQUALITY, ppq->ocdSelect))
            VOutputSelectionCmd(pci, bDocSetup, wOrder);
        VOut(pci, "    }\r\n");    // close the option

        psIndex++;
        wCount++;
    }
        VOut(pci, "}\r\n");
}

void
VOutputTextQuality(
    IN OUT PCONVINFO pci,
    IN PSHORT psIndex)
{
    WORD wDefaultOption;
    PTEXTQUALITY   ptq;
    WORD wCount;
    BOOL bDocSetup;
    WORD wOrder;

    VOut(pci, "*Feature: PrintQuality\r\n");
    VOut(pci, "{\r\n");
    if (pci->dwStrType == STR_MACRO)
        VOut(pci, "    *rcNameID: =TEXT_QUALITY_DISPLAY\r\n");
    else if (pci->dwStrType == STR_DIRECT)
        VOut(pci, "    *Name: \"Print Quality\"\r\n");
    else
        VOut(pci, "    *rcNameID: %d\r\n", RCID_TEXTQUALITY);

    wDefaultOption = WGetDefaultIndex(pci, MD_OI_TEXTQUAL);
    ptq = (PTEXTQUALITY)GetTableInfo(pci->pdh, HE_TEXTQUAL,
                                *(psIndex + wDefaultOption - 1) - 1);
    //
    // steal pci->aubCmdBuf as temp buffer for option names
    //
    VGetOptionName((PSTR)pci->aubCmdBuf, ptq->sID, wDefaultOption,
                   gpstrStdTQName, FALSE);
    VOut(pci, "    *DefaultOption: %s\r\n", (PSTR)pci->aubCmdBuf);
    //
    // loop through index list to create one option for each element
    //
    wCount = 1;
    while (*psIndex)
    {
        ptq = (PTEXTQUALITY)GetTableInfo(pci->pdh, HE_TEXTQUAL, *psIndex - 1);
        VGetOptionName((PSTR)pci->aubCmdBuf, ptq->sID, wCount,
                       gpstrStdTQName, FALSE);
        VOut(pci, "    *Option: %s\r\n", (PSTR)pci->aubCmdBuf);
        VOut(pci, "    {\r\n");

        if (ptq->sID < DMTEXT_USER)
        {
            if (pci->dwStrType == STR_MACRO)
                VOut(pci, "        *rcNameID: =%s\r\n",
                          gpstrStdTQDisplayNameMacro[ptq->sID - 1]);
            else if (pci->dwStrType == STR_DIRECT)
                VOut(pci, "        *Name: \"%s\"\r\n",
                          gpstrStdTQDisplayName[ptq->sID - 1]);
            else
                VOut(pci, "        *rcNameID: %d\r\n",
                          STD_TQ_DISPLAY_NAME_ID_BASE + ptq->sID - 1);
        }
        else    // must be driver defined text quality
            VOut(pci, "        *rcNameID: %d\r\n", ptq->sID);
        //
        // check selection command.
        //
        bDocSetup = BInDocSetup(pci, PC_ORD_TEXTQUALITY, &wOrder);
        if (wOrder > 0 &&
            BBuildCmdStr(pci, CMD_TEXTQUALITY, ptq->ocdSelect))
            VOutputSelectionCmd(pci, bDocSetup, wOrder);
        VOut(pci, "    }\r\n");    // close the option

        psIndex++;
        wCount++;
    }
        VOut(pci, "}\r\n");
}

void
VOutputFeature(
    IN OUT PCONVINFO pci,
    IN FEATUREID fid,
    IN PSHORT psIndex)
/*++
Routine Description:
    This function outputs a generic feature in GPC. A generic feature has
    only name and ocdCmdSelect for each option and there is no standard
    option, i.e. all "sID" referenced in the GPC structure are really
    string resource id's. The generated GPD options will be named "OptionX"
    where X is 1, 2, ..., <# of options>. The default option is derived
    from the GPC data. The option's display name comes from "sID".

Arguments:
    fid: identification of the specific feature
    psIndex: pointer to a list of structure indicies (1-based) each
             corresponding to one option.

Return Value:
    None

--*/
{
    WORD wDefaultOption;
    WORD wCount;
    PWORD pwStruct;
    BOOL bDocSetup;
    WORD wOrder;

    VOut(pci, "*Feature: %s\r\n", gpstrFeatureName[fid]);
    VOut(pci, "{\r\n");
    //
    // display name references the corresponding value macro
    //
    if (pci->dwStrType == STR_MACRO)
        VOut(pci, "    *rcNameID: =%s\r\n", gpstrFeatureDisplayNameMacro[fid]);
    else if (pci->dwStrType == STR_DIRECT)
        VOut(pci, "    *Name: \"%s\"\r\n", gpstrFeatureDisplayName[fid]);
    else
        VOut(pci, "    *rcNameID: %d\r\n", gintFeatureDisplayNameID[fid]);

    wDefaultOption = WGetDefaultIndex(pci, gwFeatureMDOI[fid]);
    VOut(pci, "    *DefaultOption: Option%d\r\n", wDefaultOption);
    //
    // loop through each element and output option constructs. Each option
    // is named "OptionX", where X is 1, 2, ... <# of options>.
    //
    wCount = 1;
    while (*psIndex)
    {
        pwStruct = (PWORD)GetTableInfo(pci->pdh, gwFeatureHE[fid], *psIndex - 1);

        VOut(pci, "    *Option: Option%d\r\n", wCount);
        VOut(pci, "    {\r\n");
        //
        // it's guaranteed that the 2nd WORD in a GPC structure
        // is the RC string id for the name.
        //
        VOut(pci, "        *rcNameID: %d\r\n", *(pwStruct+1));
        //
        // check selection command.
        //
        bDocSetup = BInDocSetup(pci, gwFeatureORD[fid], &wOrder);
        if (wOrder > 0 &&
            BBuildCmdStr(pci, gwFeatureCMD[fid],
                               *(pwStruct + gwFeatureOCDWordOffset[fid])))
            VOutputSelectionCmd(pci, bDocSetup, wOrder);
        VOut(pci, "    }\r\n");    // close the option
        //
        // continue on to process next option
        //
        psIndex++;
        wCount++;
    }
    VOut(pci, "}\r\n");            // close the feature
}

void
VOutputColorMode(
    IN OUT PCONVINFO pci,
    PSHORT psIndex)
/*++
Routine Description:
    This function output ColorMode options including the artifical Mono mode.
    The Color option is derived from GPC.

Arguments:
    psIndex: pointer to list of DEVCOLOR structure indicies (1-based).

Return Value:
    None
--*/
{
    PDEVCOLOR   pdc;
    BOOL bDocSetup;
    INT i;
    WORD wDefaultOption, wOrder;

    VOut(pci, "*Feature: ColorMode\r\n");
    VOut(pci, "{\r\n");
    if (pci->dwStrType == STR_MACRO)
        VOut(pci, "    *rcNameID: =COLOR_PRINTING_MODE_DISPLAY\r\n");
    else if (pci->dwStrType == STR_DIRECT)
        VOut(pci, "    *Name: \"Color Printing Mode\"\r\n");
    else
        VOut(pci, "    *rcNameID: %d\r\n", RCID_COLORMODE);

    wDefaultOption = WGetDefaultIndex(pci, MD_OI_COLOR);
    pdc = (PDEVCOLOR)GetTableInfo(pci->pdh, HE_COLOR,
                                *(psIndex + wDefaultOption - 1) - 1);
    //
    // 3 possibilities: planar mode, 8bpp, 24bpp
    //
    VOut(pci, "    *DefaultOption: %s\r\n",
         (pdc->sPlanes > 1 ? "Color" :
            (pdc->sBitsPixel == 8 ? "8bpp" : "24bpp")));

    bDocSetup = BInDocSetup(pci, PC_ORD_SETCOLORMODE, &wOrder);

    //
    // synthesize the Mono option.
    //
    VOut(pci, "    *Option: Mono\r\n    {\r\n");
    if (pci->dwStrType == STR_MACRO)
        VOut(pci, "        *rcNameID: =MONO_DISPLAY\r\n");
    else if (pci->dwStrType == STR_DIRECT)
        VOut(pci, "        *Name: \"Monochrome\"\r\n");
    else
        VOut(pci, "        *rcNameID: %d\r\n", RCID_MONO);

    VOut(pci, "        *DevNumOfPlanes: 1\r\n");
    VOut(pci, "        *DevBPP: 1\r\n");
    VOut(pci, "        *Color? : FALSE\r\n");
    //
    // no selection command for MONO mode
    //
    VOut(pci, "    }\r\n");    // close Mono option

    //
    // output color options based on GPC data
    //
    while (*psIndex)
    {
        pdc = (PDEVCOLOR)GetTableInfo(pci->pdh, HE_COLOR, *psIndex - 1);
        if (!(pdc->sBitsPixel==1 && (pdc->sPlanes==3 || pdc->sPlanes==4)) &&
            !(pdc->sPlanes==1 && (pdc->sBitsPixel==8 || pdc->sBitsPixel==24)))
            continue;   // skip this un-supported color format

        VOut(pci, "    *Option: %s\r\n    {\r\n",
             (pdc->sPlanes > 1 ? "Color" :
                (pdc->sBitsPixel == 8 ? "8bpp" : "24bpp")));

        if (pci->dwStrType == STR_MACRO)
            VOut(pci, "        *rcNameID: =%s\r\n",
                 (pdc->sPlanes > 1 ? "COLOR_DISPLAY" :
                    (pdc->sBitsPixel == 8 ? "8BPP_DISPLAY" : "24BPP_DISPLAY")));
        else if (pci->dwStrType == STR_DIRECT)
            VOut(pci, "        *Name: \"%s\"\r\n",
                 (pdc->sPlanes > 1 ? "8 Color (Halftoned)" :
                    (pdc->sBitsPixel == 8 ? "256 Color (Halftoned)" : "True Color (24bpp)")));
        else
            VOut(pci, "        *rcNameID: %d\r\n",
                 (pdc->sPlanes > 1 ? RCID_COLOR :
                    (pdc->sBitsPixel == 8 ? RCID_8BPP : RCID_24BPP)));

        VOut(pci, "        *DevNumOfPlanes: %d\r\n", pdc->sPlanes);
        VOut(pci, "        *DevBPP: %d\r\n", pdc->sBitsPixel);
        VOut(pci, "        *DrvBPP: %d\r\n",
                (pdc->sPlanes > 1 ? max(pdc->sPlanes * pdc->sBitsPixel, 4) :
                                    pdc->sBitsPixel) );
        //
        // output color printing attributes
        //
        if ((pdc->fGeneral & DC_CF_SEND_CR) &&
            (pdc->fGeneral & DC_EXPLICIT_COLOR))
            VOut(pci, "        EXTERN_GLOBAL: *MoveToX0BeforeSetColor? : TRUE\r\n");
        if ((pdc->fGeneral & DC_SEND_ALL_PLANES) ||
            //
            // GPC2.x and older minidrivers assume sending all color
            // planes if using H_BYTE format dump. Ex. HP PaintJet.
            //
            (pci->pdh->wVersion < GPC_VERSION3 && (pci->dwMode & FM_RES_DM_GDI)))
            VOut(pci, "        EXTERN_GLOBAL: *RasterSendAllData? : TRUE\r\n");
        if ((pdc->fGeneral & DC_EXPLICIT_COLOR) ||
            //
            // GPC1.x and GPC2.x minidrivers don'thave DC_EXPLICIT_COLOR bit
            // the driver code assumes that if it's V_BYTE style dump.
            //
            (pci->pdh->wVersion < GPC_VERSION3 && !(pci->dwMode & FM_RES_DM_GDI)))
            VOut(pci, "        EXTERN_GLOBAL: *UseExpColorSelectCmd? : TRUE\r\n");
        //
        // warn flags that have no corresponding GPD entries
        //
        if (pdc->fGeneral & DC_SEND_PALETTE)
            pci->dwErrorCode |= ERR_DC_SEND_PALETTE;

        if (pdc->sPlanes > 1)
        {
            //
            // figure out the color plane order
            //
            BYTE aubOrder[4];
            OCD  aocdPlanes[4];
            POCD pocd;
            OCD  ocd;
            SHORT i;

            //if (!(pdc->fGeneral & DC_EXPLICIT_COLOR))
            {
                //
                // copy color plane data cmds. May need to swap their order
                //
                pocd = (POCD)((PBYTE)pci->pdh + pci->pdh->loHeap + pdc->orgocdPlanes);
                for (i = 0; i < pdc->sPlanes; i++)
                    aocdPlanes[i] = *pocd++;
            }

            if (pci->pdh->wVersion >= GPC_VERSION3)
                *((PDWORD)aubOrder) = *((PDWORD)(pdc->rgbOrder));
            else if (pdc->fGeneral & DC_PRIMARY_RGB)
                *((PDWORD)aubOrder) =
                        (DWORD)DC_PLANE_RED         |
                        (DWORD)DC_PLANE_GREEN << 8  |
                        (DWORD)DC_PLANE_BLUE  << 16 |
                        (DWORD)DC_PLANE_NONE  << 24  ;
            else if (pdc->fGeneral & DC_EXTRACT_BLK)
            {
                //
                // assume it's YMCK model (printing light color first).
                // There was no DC_EXTRACT_BLK support in RES_DM_GDI path.
                //
                *((PDWORD)aubOrder) =
                        (DWORD)DC_PLANE_YELLOW        |
                        (DWORD)DC_PLANE_MAGENTA << 8  |
                        (DWORD)DC_PLANE_CYAN << 16    |
                        (DWORD)DC_PLANE_BLACK << 24    ;
                //if (!(pdc->fGeneral & DC_EXPLICIT_COLOR))
                {
                    //
                    // swap cmds: 0 <-> 3; 1 <-> 3
                    //
                    ocd = aocdPlanes[0];
                    aocdPlanes[0] = aocdPlanes[3];
                    aocdPlanes[3] = ocd;

                    ocd = aocdPlanes[1];
                    aocdPlanes[1] = aocdPlanes[2];
                    aocdPlanes[2] = ocd;
                }
            }
            else // YMC cases
            {
                //
                // the data order was different for RES_DM_GDI and non RES_DM_GDI
                // dump paths.
                if (pci->dwMode & FM_RES_DM_GDI)
                    *((PDWORD)aubOrder) =
                            (DWORD)DC_PLANE_CYAN          |
                            (DWORD)DC_PLANE_MAGENTA << 8  |
                            (DWORD)DC_PLANE_YELLOW  << 16 |
                            (DWORD)DC_PLANE_NONE    << 24  ;
                else
                {
                    *((PDWORD)aubOrder) =
                            (DWORD)DC_PLANE_YELLOW        |
                            (DWORD)DC_PLANE_MAGENTA << 8  |
                            (DWORD)DC_PLANE_CYAN    << 16 |
                            (DWORD)DC_PLANE_NONE    << 24  ;

                    //if (!(pdc->fGeneral & DC_EXPLICIT_COLOR))
                    {
                        //
                        // swap cmds: 0 <-> 2
                        //
                        ocd = aocdPlanes[0];
                        aocdPlanes[0] = aocdPlanes[2];
                        aocdPlanes[2] = ocd;
                    }
                }
            }
            if (aubOrder[3] == DC_PLANE_NONE)
                VOut(pci, "        *ColorPlaneOrder: LIST(%s, %s, %s)\r\n",
                                             gpstrColorName[aubOrder[0]],
                                             gpstrColorName[aubOrder[1]],
                                             gpstrColorName[aubOrder[2]]);
            else
                VOut(pci, "        *ColorPlaneOrder: LIST(%s, %s, %s, %s)\r\n",
                                             gpstrColorName[aubOrder[0]],
                                             gpstrColorName[aubOrder[1]],
                                             gpstrColorName[aubOrder[2]],
                                             gpstrColorName[aubOrder[3]]);
            //
            // output send-color-plane-data cmds
            //
            //if (!(pdc->fGeneral & DC_EXPLICIT_COLOR))
            {
                for (i = 0; i < pdc->sPlanes; i++)
                    if (BBuildCmdStr(pci, gwColorPlaneCmdID[i], aocdPlanes[i]))
                        VOutputExternCmd(pci, gpstrColorPlaneCmdName[aubOrder[i]]);
            }
            //
            // output foreground (text) color selection commands
            //
            if (BBuildCmdStr(pci, CMD_DC_TC_BLACK, pdc->rgocd[DC_OCD_TC_BLACK]))
                VOutputExternCmd(pci, "CmdSelectBlackColor");
            if (BBuildCmdStr(pci, CMD_DC_TC_RED, pdc->rgocd[DC_OCD_TC_RED]))
                VOutputExternCmd(pci, "CmdSelectRedColor");
            if (BBuildCmdStr(pci, CMD_DC_TC_GREEN, pdc->rgocd[DC_OCD_TC_GREEN]))
                VOutputExternCmd(pci, "CmdSelectGreenColor");
            if (BBuildCmdStr(pci, CMD_DC_TC_YELLOW, pdc->rgocd[DC_OCD_TC_YELLOW]))
                VOutputExternCmd(pci, "CmdSelectYellowColor");
            if (BBuildCmdStr(pci, CMD_DC_TC_BLUE, pdc->rgocd[DC_OCD_TC_BLUE]))
                VOutputExternCmd(pci, "CmdSelectBlueColor");
            if (BBuildCmdStr(pci, CMD_DC_TC_MAGENTA, pdc->rgocd[DC_OCD_TC_MAGENTA]))
                VOutputExternCmd(pci, "CmdSelectMagentaColor");
            if (BBuildCmdStr(pci, CMD_DC_TC_CYAN, pdc->rgocd[DC_OCD_TC_CYAN]))
                VOutputExternCmd(pci, "CmdSelectCyanColor");
            if (BBuildCmdStr(pci, CMD_DC_TC_WHITE, pdc->rgocd[DC_OCD_TC_WHITE]))
                VOutputExternCmd(pci, "CmdSelectWhiteColor");

        }
        else // palette color
        {
            VOut(pci, "        *PaletteSize: 256\r\n");     // match RASDD behavior
            VOut(pci, "        *PaletteProgrammable? : TRUE\r\n");
            //
            // output palette commands
            //
            if (BBuildCmdStr(pci, CMD_DC_PC_START, pdc->rgocd[DC_OCD_PC_START]))
                VOutputExternCmd(pci, "CmdBeginPaletteDef");

            if (BBuildCmdStr(pci, CMD_DC_PC_END, pdc->rgocd[DC_OCD_PC_END]))
                VOutputExternCmd(pci, "CmdEndPaletteDef");

            if (BBuildCmdStr(pci, CMD_DC_PC_ENTRY, pdc->rgocd[DC_OCD_PC_ENTRY]))
                VOutputExternCmd(pci, "CmdDefinePaletteEntry");

            if (BBuildCmdStr(pci, CMD_DC_PC_SELECTINDEX, pdc->rgocd[DC_OCD_PC_SELECTINDEX]))
                VOutputExternCmd(pci, "CmdSelectPaletteEntry");

        }
        //
        // output the selection command
        //
        if (wOrder > 0 &&
            BBuildCmdStr(pci, CMD_DC_SETCOLORMODE, pdc->rgocd[DC_OCD_SETCOLORMODE]))
            VOutputSelectionCmd(pci, bDocSetup, wOrder);

        //
        // output any constraints w.r.t. Resolution
        //
        for (i = 0; i < (INT)pci->dwNumOfRes; i++)
        {
            if (!pci->presinfo[i].bColor)
                VOut(pci, "        *Constraints: Resolution.%s\r\n",
                        pci->presinfo[i].aubOptName);
        }
        VOut(pci, "    }\r\n");    // close Color option

        psIndex++;
    }

    VOut(pci, "}\r\n");    // close ColorMode feature
}

void
VOutputHalftone(
    IN OUT PCONVINFO pci)
{
    //
    // Generate 4 standard options: Auto, SuperCell, 6x6, 8x8
    //

    VOut(pci, "*Feature: Halftone\r\n{\r\n");
    if (pci->dwStrType == STR_MACRO)
        VOut(pci, "    *rcNameID: =HALFTONING_DISPLAY\r\n");
    else if (pci->dwStrType == STR_DIRECT)
        VOut(pci, "    *Name: \"Halftoning\"\r\n");
    else
        VOut(pci, "    *rcNameID: %d\r\n", RCID_HALFTONE);

    VOut(pci, "    *DefaultOption: HT_PATSIZE_AUTO\r\n");

    VOut(pci, "    *Option: HT_PATSIZE_AUTO\r\n    {\r\n");
    if (pci->dwStrType == STR_MACRO)
        VOut(pci, "        *rcNameID: =HT_AUTO_SELECT_DISPLAY\r\n    }\r\n");
    else if (pci->dwStrType == STR_DIRECT)
        VOut(pci, "        *Name: \"Auto Select\"\r\n    }\r\n");
    else
        VOut(pci, "        *rcNameID: %d\r\n    }\r\n", RCID_HT_AUTO_SELECT);

    VOut(pci, "    *Option: HT_PATSIZE_SUPERCELL_M\r\n    {\r\n");
    if (pci->dwStrType == STR_MACRO)
        VOut(pci, "        *rcNameID: =HT_SUPERCELL_DISPLAY\r\n    }\r\n");
    else if (pci->dwStrType == STR_DIRECT)
        VOut(pci, "        *Name: \"Super Cell\"\r\n    }\r\n");
    else
        VOut(pci, "        *rcNameID: %d\r\n    }\r\n", RCID_HT_SUPERCELL);

    VOut(pci, "    *Option: HT_PATSIZE_6x6_M\r\n    {\r\n");
    if (pci->dwStrType == STR_MACRO)
        VOut(pci, "        *rcNameID: =HT_DITHER6X6_DISPLAY\r\n    }\r\n");
    else if (pci->dwStrType == STR_DIRECT)
        VOut(pci, "        *Name: \"Dither 6x6\"\r\n    }\r\n");
    else
        VOut(pci, "        *rcNameID: %d\r\n    }\r\n", RCID_HT_DITHER6X6);

    VOut(pci, "    *Option: HT_PATSIZE_8x8_M\r\n    {\r\n");
    if (pci->dwStrType == STR_MACRO)
        VOut(pci, "        *rcNameID: =HT_DITHER8X8_DISPLAY\r\n    }\r\n");
    else if (pci->dwStrType == STR_DIRECT)
        VOut(pci, "        *Name: \"Dither 8x8\"\r\n    }\r\n");
    else
        VOut(pci, "        *rcNameID: %d\r\n    }\r\n", RCID_HT_DITHER8X8);

    VOut(pci, "}\r\n");     // close Halftone feature
}

void
VOutputMemConfig(
    IN OUT PCONVINFO pci,
    PWORD pwMems)
{
    WORD    wDefaultOption;
    BOOL    bGPC3 = pci->pdh->wVersion >= GPC_VERSION3;

    VOut(pci, "*Feature: Memory\r\n");
    VOut(pci, "{\r\n");
    if (pci->dwStrType == STR_MACRO)
        VOut(pci, "    *rcNameID: =PRINTER_MEMORY_DISPLAY\r\n");
    else if (pci->dwStrType == STR_DIRECT)
        VOut(pci, "    *Name: \"Printer Memory\"\r\n");
    else
        VOut(pci, "    *rcNameID: %d\r\n", RCID_MEMORY);

    wDefaultOption = WGetDefaultIndex(pci, MD_OI_MEMCONFIG);
    VOut(pci, "    *DefaultOption: %dKB\r\n", bGPC3?
                              *(((PDWORD)pwMems)+ 2*(wDefaultOption-1)) :
                              *pwMems);
    //
    // loop through each index which maps to one *MemConfigKB entry
    //
    while (bGPC3? *((PDWORD)pwMems) : *pwMems)
    {
        DWORD dwInstalled, dwAvailable;

        dwInstalled = (bGPC3? *((PDWORD)pwMems)++ : (DWORD)*pwMems++);
        dwAvailable = (bGPC3? *((PDWORD)pwMems)++ : (DWORD)*pwMems++);
        //
        // have to use two temp variables. If we put the above two
        // expressions directly in the VOut call, the actual values
        // are reversed for some reason.
        //
        VOut(pci, "    *Option: %dKB\r\n    {\r\n", dwInstalled);
        if (dwInstalled % 1024 != 0)
            VOut(pci, "        *Name: \"%dKB\"\r\n", dwInstalled);
        else
            VOut(pci, "        *Name: \"%dMB\"\r\n", (dwInstalled >> 10));

        VOut(pci, "        *MemoryConfigKB: PAIR(%d, %d)\r\n", dwInstalled, dwAvailable);
        VOut(pci, "    }\r\n");
    }

    VOut(pci, "}\r\n");    // close Memory feature
}

void
VOutputDuplex(
    IN OUT PCONVINFO pci)
{
    BOOL bDocSetup;
    WORD wOrder;

    VOut(pci, "*Feature: Duplex\r\n");
    VOut(pci, "{\r\n");
    if (pci->dwStrType == STR_MACRO)
        VOut(pci, "    *rcNameID: =TWO_SIDED_PRINTING_DISPLAY\r\n");
    else if (pci->dwStrType == STR_DIRECT)
        VOut(pci, "    *Name: \"Two Sided Printing\"\r\n");
    else
        VOut(pci, "    *rcNameID: %d\r\n", RCID_DUPLEX);

    VOut(pci, "    *DefaultOption: NONE\r\n");
    VOut(pci, "    *Option: NONE\r\n    {\r\n");
    if (pci->dwStrType == STR_MACRO)
        VOut(pci, "        *rcNameID: =NONE_DISPLAY\r\n");
    else if (pci->dwStrType == STR_DIRECT)
        VOut(pci, "        *Name: \"None\"\r\n");
    else
        VOut(pci, "        *rcNameID: %d\r\n", RCID_NONE);
    //
    // output the selection command
    //
    bDocSetup = BInDocSetup(pci, PC_ORD_DUPLEX, &wOrder);
    if (wOrder > 0 &&
        BBuildCmdStr(pci, CMD_PC_DUPLEX_OFF, pci->ppc->rgocd[PC_OCD_DUPLEX_OFF]))
        VOutputSelectionCmd(pci, bDocSetup, wOrder);
    VOut(pci, "    }\r\n");    // close NONE option

    //
    // assume there is no PC_OCD_DUPLEX_ON command. True for PCL printers.
    //
    if (pci->ppc->rgocd[PC_OCD_DUPLEX_ON] != NOOCD)
        pci->dwErrorCode |= ERR_HAS_DUPLEX_ON_CMD;

    VOut(pci, "    *Option: VERTICAL\r\n    {\r\n");
    if (pci->dwStrType == STR_MACRO)
        VOut(pci, "        *rcNameID: =FLIP_ON_LONG_EDGE_DISPLAY\r\n");
    else if (pci->dwStrType == STR_DIRECT)
        VOut(pci, "        *Name: \"Flip on long edge\"\r\n");
    else
        VOut(pci, "        *rcNameID: %d\r\n", RCID_FLIP_ON_LONG_EDGE);
    //
    // output the selection command
    //
    bDocSetup = BInDocSetup(pci, PC_ORD_DUPLEX_TYPE, &wOrder);
    if (wOrder > 0 &&
        BBuildCmdStr(pci, CMD_PC_DUPLEX_VERT, pci->ppc->rgocd[PC_OCD_DUPLEX_VERT]))
        VOutputSelectionCmd(pci, bDocSetup, wOrder);
    VOut(pci, "    }\r\n");    // close VERTICAL option

    VOut(pci, "    *Option: HORIZONTAL\r\n    {\r\n");
    if (pci->dwStrType == STR_MACRO)
        VOut(pci, "        *rcNameID: =FLIP_ON_SHORT_EDGE_DISPLAY\r\n");
    else if (pci->dwStrType == STR_DIRECT)
        VOut(pci, "        *Name: \"Flip on short edge\"\r\n");
    else
        VOut(pci, "        *rcNameID: %d\r\n", RCID_FLIP_ON_SHORT_EDGE);
    //
    // output the selection command. Same order as VERTICAL case.
    //
    if (wOrder > 0 &&
        BBuildCmdStr(pci, CMD_PC_DUPLEX_HORZ, pci->ppc->rgocd[PC_OCD_DUPLEX_HORZ]))
        VOutputSelectionCmd(pci, bDocSetup, wOrder);
    VOut(pci, "    }\r\n");    // close HORIZONTAL option

    VOut(pci, "}\r\n");        // close Duplex feature
}

void
VOutputPageProtect(
    IN OUT PCONVINFO pci)
{
    BOOL bDocSetup;
    WORD wOrder;

    VOut(pci, "*Feature: PageProtect\r\n");
    VOut(pci, "{\r\n");
    if (pci->dwStrType == STR_MACRO)
        VOut(pci, "    *rcNameID: =PAGE_PROTECTION_DISPLAY\r\n");
    else if (pci->dwStrType == STR_DIRECT)
        VOut(pci, "    *Name: \"Page Protection\"\r\n");
    else
        VOut(pci, "    *rcNameID: %d\r\n", RCID_PAGEPROTECTION);

    VOut(pci, "    *DefaultOption: OFF\r\n");
    VOut(pci, "    *Option: ON\r\n    {\r\n");
    if (pci->dwStrType == STR_MACRO)
        VOut(pci, "        *rcNameID: =ON_DISPLAY\r\n");
    else if (pci->dwStrType == STR_DIRECT)
        VOut(pci, "        *Name: \"On\"\r\n");
    else
        VOut(pci, "        *rcNameID: %d\r\n", RCID_ON);
    //
    // output the selection command
    //
    bDocSetup = BInDocSetup(pci, PC_ORD_PAGEPROTECT, &wOrder);
    if (wOrder > 0 &&
        BBuildCmdStr(pci, CMD_PAGEPROTECT_ON, pci->ocdPPOn))
        VOutputSelectionCmd(pci, bDocSetup, wOrder);
    VOut(pci, "    }\r\n");    // close ON option

    VOut(pci, "    *Option: OFF\r\n    {\r\n");
    if (pci->dwStrType == STR_MACRO)
        VOut(pci, "        *rcNameID: =OFF_DISPLAY\r\n");
    else if (pci->dwStrType == STR_DIRECT)
        VOut(pci, "        *Name: \"Off\"\r\n");
    else
        VOut(pci, "        *rcNameID: %d\r\n", RCID_OFF);
    //
    // output the selection command
    //
    if (wOrder > 0 &&
        BBuildCmdStr(pci, CMD_PAGEPROTECT_OFF, pci->ocdPPOff))
        VOutputSelectionCmd(pci, bDocSetup, wOrder);
    VOut(pci, "    }\r\n");    // close OFF option

    VOut(pci, "}\r\n");        // close PageProtect feature
}

void
VOutputPaperConstraints(
    IN OUT PCONVINFO pci)
{
    DWORD i, j;

    for (i = 0; i < pci->dwNumOfSrc; i++)
    {
        for (j = 0; j < pci->dwNumOfSize; j++)
        {
            if (!(pci->ppiSrc[i].dwPaperType & pci->ppiSize[j].dwPaperType))
                VOut(pci, "*InvalidCombination: LIST(InputBin.%s, PaperSize.%s)\r\n",
                        pci->ppiSrc[i].aubOptName, pci->ppiSize[j].aubOptName);
        }
    }
}

void
VOutputUIEntries(
    IN OUT PCONVINFO pci)
{
    PSHORT  psIndex;
    BOOL    bGPC3 = pci->pdh->wVersion >= GPC_VERSION3;

    //
    // check if this is a TTY device. If so, do not generate the Orientation
    // feature.
    //
    if (pci->pdh->fTechnology != GPC_TECH_TTY)
        VOutputOrientation(pci);
    //
    // check input bins. This must come before VOutputPaperSize to gather
    // info about feed margins.
    //
    // patryan - if no PAPERSOURCE structure is found in GPC then output a dummy
    // feature, containing just one option. This is to satisfy GPD parser, which 
    // fail if GPD contains no InputBin feature.

    if (*(psIndex = DHOFFSET(pci->pdh, pci->pmd->rgoi[MD_OI_PAPERSOURCE])) != 0)
        VOutputInputBin(pci, psIndex);
    else
        VOutputDummyInputBin(pci);
  
    //
    // check Resolution
    //
    if (*(psIndex = DHOFFSET(pci->pdh, pci->pmd->rgoi[MD_OI_RESOLUTION])) != 0)
        VOutputResolution(pci, psIndex);
    //
    // set up pci->ptMoveScale for use in generating *PrintableOrigin
    // and *CursorOrigin.
    // Assume that all X-move cmds have the same units. Same for Y-move cmds.
    //
    {
        PCURSORMOVE pcm;
        DWORD   tmp;

        pcm = (PCURSORMOVE)GetTableInfo(pci->pdh, HE_CURSORMOVE,
                                        pci->pmd->rgi[MD_I_CURSORMOVE]);
        pci->ptMoveScale.x = pci->ptMoveScale.y = 1;
        if (pcm && !(pcm->fYMove & CM_YM_RES_DEPENDENT))
        {
            if (tmp = DwCalcMoveUnit(pci, pcm, pci->pdh->ptMaster.x,
                                     CM_OCD_XM_ABS, CM_OCD_XM_RELLEFT))
            {
                //  Verify move scale factor is not zero.  Otherwise an essential
                //  GPD assumption is violated.
                if(!(pci->pdh->ptMaster.x / (WORD)tmp)  ||  pci->pdh->ptMaster.x % (WORD)tmp)
                    pci->dwErrorCode |= ERR_MOVESCALE_NOT_FACTOR_OF_MASTERUNITS;
                else
                    pci->ptMoveScale.x = pci->pdh->ptMaster.x / (WORD)tmp;
            }
            if (tmp = DwCalcMoveUnit(pci, pcm, pci->pdh->ptMaster.y,
                                     CM_OCD_YM_ABS, CM_OCD_YM_RELUP))
            {
                if(!(pci->pdh->ptMaster.y / (WORD)tmp)  ||  pci->pdh->ptMaster.y % (WORD)tmp)
                    pci->dwErrorCode |= ERR_MOVESCALE_NOT_FACTOR_OF_MASTERUNITS;
                else
                    pci->ptMoveScale.y = pci->pdh->ptMaster.y / (WORD)tmp;
            }


            //
            // Verify that the move scale factor evenly into every resolution
            // scale if RES_DM_GDI is set. This is TRUE for most, if not all,
            // inkjet and page printers. With this assumption, we can simplify
            // checking the printable origin values later on.
            //
            if (pci->dwMode & FM_RES_DM_GDI)
                for (tmp = 0; tmp < pci->dwNumOfRes; tmp++)
                {
                    if ((pci->presinfo[tmp].dwXScale % pci->ptMoveScale.x != 0) ||
                        (pci->presinfo[tmp].dwYScale % pci->ptMoveScale.y != 0) )
                    {
                        pci->dwErrorCode |= ERR_MOVESCALE_NOT_FACTOR_INTO_SOME_RESSCALE;
                        break;
                    }
                }
        }
    }

    //
    // check PAPERSIZE.
    //
    if (*(psIndex = DHOFFSET(pci->pdh, pci->pmd->rgoi[MD_OI_PAPERSIZE])) != 0)
        VOutputPaperSize(pci, psIndex);
    //
    // output PaperSize & InputBin constraints, if any.
    // RES_DM_COLOR is handled in VOutputResolutions.
    // RES_DM_DOWNLOAD_OUTLINE is handled in VOutputPrintingEntries.
    //
    VOutputPaperConstraints(pci);

    //
    // check PaperQuality, a.k.a. MediaType
    //
    if (*(psIndex = DHOFFSET(pci->pdh, pci->pmd->rgoi[MD_OI_PAPERQUALITY])) != 0)
        VOutputMediaType(pci, psIndex);
    //
    // check TextQuality (ex. "Letter Quality")
    //
    if (*(psIndex = DHOFFSET(pci->pdh, pci->pmd->rgoi[MD_OI_TEXTQUAL])) != 0)
        VOutputTextQuality(pci, psIndex);
    //
    // check PaperDestination
    //
    if (*(psIndex = DHOFFSET(pci->pdh, pci->pmd->rgoi[MD_OI_PAPERDEST])) != 0)
        VOutputFeature(pci, FID_PAPERDEST, psIndex);
    //
    // check ImageControl
    //
    if (bGPC3 &&
        *(psIndex = DHOFFSET(pci->pdh, pci->pmd->rgoi2[MD_OI2_IMAGECONTROL])) != 0)
        VOutputFeature(pci, FID_IMAGECONTROL, psIndex);
    //
    // check PrintDensity
    //
    if (bGPC3 &&
        *(psIndex = DHOFFSET(pci->pdh, pci->pmd->rgoi2[MD_OI2_PRINTDENSITY])) != 0)
        VOutputFeature(pci, FID_PRINTDENSITY, psIndex);
    //
    // check DEVCOLOR
    //
    if (*(psIndex = DHOFFSET(pci->pdh, pci->pmd->rgoi[MD_OI_COLOR])) != 0)
        VOutputColorMode(pci, psIndex);
    //
    // synthesize Halftone feature
    //
    VOutputHalftone(pci);
    //
    // check MemConfig
    //
    if (*(psIndex = DHOFFSET(pci->pdh, pci->pmd->rgoi[MD_OI_MEMCONFIG])) != 0)
    {
        VOutputMemConfig(pci, (PWORD)psIndex);
        pci->dwMode |= FM_MEMORY_FEATURE_EXIST;
    }
    //
    // synthesize Duplex feature if necessary.
    //
    if (pci->pmd->fGeneral & MD_DUPLEX)
        VOutputDuplex(pci);
    //
    // synthesize PageProtect feature if necessary
    //
    if ((pci->pmd->fGeneral & MD_PCL_PAGEPROTECT) &&
        (pci->dwMode & FM_SYN_PAGEPROTECT))
        VOutputPageProtect(pci);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\tools\uni\gpc2gpd\prentry.c ===
/*++

Copyright (c) 1996-1998  Microsoft Corporation

Module Name:

    prentry.c

Abstract:

    This file implements functions that generate printing related GPD entries.

Environment:

    User-mode, stand-alone utility tool

Revision History:

    10/16/96 -zhanw-
        Created it.

--*/

#include "gpc2gpd.h"


DWORD
DwCalcMoveUnit(
    IN PCONVINFO pci,
    IN PCURSORMOVE pcm,
    IN WORD wMasterUnit,
    IN WORD wStartOCD,
    IN WORD wEndOCD)
/*++
Routine Description:
    This function calculates the unit used by movement commands in the
    given range.

Arguments:
    pci: conversion related info
    pcm: the current CURSORMOVE structure
        wMasterUnit: X or Y master unit depending on the OCD range
    wStartOCD: the starting OCD to scan
    wEndOCD: the ending OCD to scan

Return Value:
    the movement command unit. If there is no movement command, return 0.

--*/
{
    WORD    i;
    OCD     ocd;
    PCD     pcd;
    PEXTCD  pextcd = NULL;      // points the parameter's EXTCD.

    for (ocd = (WORD)NOOCD, i = wStartOCD; i <= wEndOCD; i++)
        if (pcm->rgocd[i] != NOOCD)
        {
            ocd = pcm->rgocd[i];
            break;
        }
    if (ocd != NOOCD)
    {
        pcd = (PCD)((PBYTE)(pci->pdh) + (pci->pdh)->loHeap + ocd);
        if (pcd->wCount != 0)
            pextcd = GETEXTCD(pci->pdh, pcd);
        if (pextcd)
        {
            short sMult, sDiv;

            if ((sMult = pextcd->sUnitMult) == 0)
                sMult = 1;
            if ((sDiv = pextcd->sUnitDiv) == 0)
                sDiv = 1;

            if (pextcd->fGeneral & XCD_GEN_MODULO)
                return (DWORD)((((wMasterUnit + pextcd->sPreAdd) * sMult) %
                                sDiv) + pextcd->sUnitAdd);
            else
                return (DWORD)((((wMasterUnit + pextcd->sPreAdd) * sMult) /
                                sDiv) + pextcd->sUnitAdd);
        }
        else // no modification needed
            return (DWORD)wMasterUnit;
    }
    else
        return 0;

}


void
VOutTextCaps(
    IN OUT PCONVINFO pci,
    WORD fText,
    BOOL bIndent)
{
    //
    // at most 15 text capability flags can be used. In reality,
    // only less than 5 are used. So we don't break into multiple lines
    // for simplicity.
    //
    pci->dwMode |= FM_VOUT_LIST; // special handling for erasing last comma
    VOut(pci, "%s*TextCaps: LIST(%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s)\r\n",
         bIndent ? "        " : "",
         (fText & TC_OP_CHARACTER) ? "TC_OP_CHARACTER," : "",
         (fText & TC_OP_STROKE) ? "TC_OP_STROKE," : "",
         (fText & TC_CP_STROKE) ? "TC_CP_STROKE," : "",
         (fText & TC_CR_90) ? "TC_CR_90," : "",
         (fText & TC_CR_ANY) ? "TC_CR_ANY," : "",
         (fText & TC_SF_X_YINDEP) ? "TC_SF_X_YINDEP," : "",
         (fText & TC_SA_DOUBLE) ? "TC_SA_DOUBLE," : "",
         (fText & TC_SA_INTEGER) ? "TC_SA_INTEGER," : "",
         (fText & TC_SA_CONTIN) ? "TC_SA_CONTIN," : "",
         (fText & TC_EA_DOUBLE) ? "TC_EA_DOUBLE," : "",
         (fText & TC_IA_ABLE) ? "TC_IA_ABLE," : "",
         (fText & TC_UA_ABLE) ? "TC_UA_ABLE," : "",
         (fText & TC_SO_ABLE) ? "TC_SO_ABLE," : "",
         (fText & TC_RA_ABLE) ? "TC_RA_ABLE," : "",
         (fText & TC_VA_ABLE) ? "TC_VA_ABLE" : "");
    pci->dwMode &= ~FM_VOUT_LIST;

}

//
// values for dwType param below.
//
#define FF_INPUTBIN     1
#define FF_PAPERSIZE    2
#define FF_BOTH         3

void
VCreateEjectFFDependency(
    PCONVINFO pci,
    DWORD dwType,           // type of dependency
    BOOL bIndentation)      // whether to add extra 2 levels of indentation
//
// Generate dependency on either InputBin or PaperSize options.
// Always use the 1st option to establish the base value.
//
{
    PPAPERINFO ppi;
    DWORD dwCount;
    DWORD i;

    if (dwType == FF_INPUTBIN)
    {
        ppi = pci->ppiSrc;
        dwCount = pci->dwNumOfSrc;
    }
    else // either FF_PAPERSIZE or FF_BOTH
    {
        ppi = pci->ppiSize;
        dwCount = pci->dwNumOfSize;
    }

    VOut(pci, "%s*EjectPageWithFF?: %s\r\n",
                bIndentation? "        " : "",
                (ppi[0].bEjectFF) ? "TRUE" : "FALSE");
    VOut(pci, "%s*switch: %s\r\n%s{\r\n",
                bIndentation? "        " : "",
                dwType == FF_INPUTBIN? "InputBin" : "PaperSize",
                bIndentation? "        " : "");
    //
    // loop through the rest of options. If it's different
    // than the first one, create a *case construct for it.
    //
    for (i = 1; i < dwCount; i++)
        if (ppi[i].bEjectFF != ppi[0].bEjectFF)
        {
            VOut(pci, "%s    *case: %s\r\n%s    {\r\n",
                        bIndentation? "        " : "",
                        ppi[i].aubOptName,
                        bIndentation? "        " : "");
            if (dwType == FF_BOTH)
                VCreateEjectFFDependency(pci, FF_INPUTBIN, TRUE);
            else
                VOut(pci, "%s        *EjectPageWithFF?: %s\r\n",
                        bIndentation? "        " : "",
                        ppi[0].bEjectFF ? "FALSE" : "TRUE");
            VOut(pci, "%s    }\r\n", bIndentation? "        " : "");

        }
    VOut(pci, "%s}\r\n", bIndentation? "        " : ""); // close *switch construct
}

DWORD
DwMergeFonts(
    PWORD pwBuf,
    DWORD dwStartIndex,
    PWORD pwList)
{
    DWORD i, count;
    WORD id;
    WORD low, high;

    if (!*pwList)
        return 0;
    low = *pwList;
    high = *(pwList + 1);

    for (count = 0, id = low; id <= high; id++)
    {
        for (i = 0; i < dwStartIndex; i++)
        {
            if (pwBuf[i] == id)
                break;
        }
        if (i == dwStartIndex)  // this is not a repeat
        {
            pwBuf[dwStartIndex + count] = id;
            count++;
        }
    }
    pwList += 2;    // skip the range numbers
    while (id = *pwList)
    {
        for (i = 0; i < dwStartIndex; i++)
        {
            if (pwBuf[i] == id)
                break;
        }
        if (i == dwStartIndex)  // this is not a repeat
        {
            pwBuf[dwStartIndex + count] = id;
            count++;
        }
        pwList++;
    }
    return count;
}
void
VOutputFontList(
    IN OUT PCONVINFO pci,
    IN PWORD pwPFonts,
    IN PWORD pwLFonts)
/*++
Routine Description:
    This function outputs the font id list: LIST( , , ...) which ends with a
    a newline character. If two font lists are given, merge them first and
    remove the repeated id's.

Arguments:
    pci: point to CONVINFO
    pwPFonts: point to list of font id's available in Portrait orientation.
              Note that as in GPC, the first two numbers represent the
              inclusive range of the font id's. Can be NULL.
    pwLFonts: Landscape font list. Can be NULL.

Return Value:
    NONE.
--*/
{

    DWORD i, count;
    WORD awFonts[1000] = {0}; // assume at most 1000 resident fonts per printer

    //
    // first, collect the list of fonts (unique id's)
    //
    count = 0;
    if (pwPFonts)
        count += DwMergeFonts(awFonts, count, pwPFonts);
    if (pwLFonts)
        count += DwMergeFonts(awFonts, count, pwLFonts);

    if (count == 0)
    {
        VOut(pci, "LIST()\r\n");
        return;
    }

#if defined(DEVSTUDIO)  //  Must map these lists to account for multi PFM-> UFM
    vMapFontList(awFonts, count, pci);
#endif

    VOut(pci, "LIST(");
    for (i = 0; i < count - 1; i++)
    {
        //
        // check if need to move to a new line. Estimate 16 fonts id's
        // per line.
        //
        if (i && i % 16 == 0)
            VOut(pci, "\r\n+                   ");
        VOut(pci, "%d,", awFonts[i]);
    }
    VOut(pci, "%d)\r\n", awFonts[i]);  // last one
}

void
VOutputPrintingEntries(
    IN OUT PCONVINFO pci)
{
    PDH pdh = pci->pdh;
    PMODELDATA pmd = pci->pmd;
    PCURSORMOVE pcm;
    PGPCRESOLUTION pres;
    PPAPERSIZE  pps;
    PSHORT      psIndex;
    WORD        wCount;

    pcm = (PCURSORMOVE)GetTableInfo(pdh, HE_CURSORMOVE,
                                    pmd->rgi[MD_I_CURSORMOVE]);
    if (*(psIndex = DHOFFSET(pdh, pmd->rgoi[MD_OI_RESOLUTION])) == 0)
        pres = NULL;
    else
        pres = (PGPCRESOLUTION)GetTableInfo(pdh, HE_RESOLUTION,
               *(psIndex + WGetDefaultIndex(pci, MD_OI_RESOLUTION) - 1) - 1);
    if (*(psIndex = DHOFFSET(pdh, pmd->rgoi[MD_OI_PAPERSIZE])) == 0)
        pps = NULL;
    else
        pps = (PPAPERSIZE)GetTableInfo(pdh, HE_PAPERSIZE,
              *(psIndex + WGetDefaultIndex(pci, MD_OI_PAPERSIZE) - 1) - 1);
    //
    // ASSUMPTIONS:
    // 1. all GPCRESOLUTION structs have same fCursor field value
    // 2. all PAPERSIZE structs have the same setting for PS_CENTER flag
    // 3. RES_DM_GDI and RES_DM_LEFT_BOUND bits are set consistently for
    //    all GPCRESOLUTION options.
    //

    //
    // Printer Configuration Commands
    //
    {
        BOOL bDocSetup;
        WORD wOrder;
        POCD pocd = (POCD)(pci->ppc->rgocd);

        //
        // Note that both in RASDD and Win95 Unidrv, the configuration
        // commands and selection commands are classified as follows:
        // 1. All commands before PC_OCD_BEGIN_PAGE (exclusive) are sent per
        //    job and per ResetDC. So they should be in DOC_SETUP section.
        // 2. All commands after PC_OCD_BEGIN_PAGE (inclusive) is sent at the
        //    beginning of each page. So they should be in PAGE_SETUP section.
        // 3. PC_OCD_ENDDOC is sent only once per job. So it should be in
        //    JOB_FINISH section.
        // 4. PC_OCD_ENDPAGE is sent only once at the end of each page. So
        //    it should be in PAGE_FINISH section.
        // 5. There is nothing in JOB_SETUP section when converting from GPC.
        // 6. There is nothing in DOC_FINISH section when converting from
        //    GPC.
        //
        bDocSetup = BInDocSetup(pci, PC_ORD_BEGINDOC, &wOrder);
        if (wOrder > 0 &&
            BBuildCmdStr(pci, CMD_PC_BEGIN_DOC, pocd[PC_OCD_BEGIN_DOC]))
            VOutputConfigCmd(pci, "CmdStartDoc",
                             bDocSetup? SS_DOCSETUP : SS_PAGESETUP, wOrder);

        if (BBuildCmdStr(pci, CMD_PC_BEGIN_PAGE, pocd[PC_OCD_BEGIN_PAGE]))
            VOutputConfigCmd(pci, "CmdStartPage", SS_PAGESETUP, 1);

        if (BBuildCmdStr(pci, CMD_PC_ENDDOC, pocd[PC_OCD_ENDDOC]))
            VOutputConfigCmd(pci, "CmdEndJob", SS_JOBFINISH, 1);

        if (BBuildCmdStr(pci, CMD_PC_ENDPAGE, pocd[PC_OCD_ENDPAGE]))
            VOutputConfigCmd(pci, "CmdEndPage", SS_PAGEFINISH, 1);

        bDocSetup = BInDocSetup(pci, PC_ORD_MULT_COPIES, &wOrder);
        if (wOrder > 0 && pci->ppc->sMaxCopyCount > 1 &&
            BBuildCmdStr(pci, CMD_PC_MULT_COPIES, pocd[PC_OCD_MULT_COPIES]))
            VOutputConfigCmd(pci, "CmdCopies",
                             bDocSetup? SS_DOCSETUP : SS_PAGESETUP, wOrder);
    }
    //
    // Printer Capabilities
    //
    VOut(pci, "*RotateCoordinate?: %s\r\n",
              (pmd->fGeneral & MD_LANDSCAPE_RT90) ? "TRUE" : "FALSE");
    VOut(pci, "*RotateRaster?: %s\r\n",
              (pmd->fGeneral & MD_LANDSCAPE_GRX_ABLE) ? "TRUE" : "FALSE");
    VOut(pci, "*RotateFont?: %s\r\n",
              (pmd->fGeneral & MD_ROTATE_FONT_ABLE) ? "TRUE" : "FALSE");
    if (pmd->fText || pmd->fLText)
    {
        if (pmd->fText == pmd->fLText)
            VOutTextCaps(pci, pmd->fText, FALSE);
        else
        {
            VOut(pci, "*switch: Orientation\r\n{\r\n");
            VOut(pci, "    *case: PORTRAIT\r\n    {\r\n");
            VOutTextCaps(pci, pmd->fText, TRUE);
            VOut(pci, "    }\r\n");
            if (pmd->fGeneral & MD_LANDSCAPE_RT90)
                VOut(pci, "    *case: LANDSCAPE_CC90\r\n    {\r\n");
            else
                VOut(pci, "    *case: LANDSCAPE_CC270\r\n    {\r\n");
            VOutTextCaps(pci, pmd->fLText, TRUE);
            VOut(pci, "    }\r\n}\r\n");
        }
    }
    if (pci->dwMode & FM_MEMORY_FEATURE_EXIST)
        VOut(pci, "*MemoryUsage: LIST(%s)\r\n",
             (pmd->fGeneral & MD_FONT_MEMCFG) ? "FONT" : "FONT, RASTER, VECTOR");

    //
    // Cursor Control
    //
    if (pres)
        VOut(pci, "*CursorXAfterCR: %s\r\n", (pres->fCursor & RES_CUR_CR_GRX_ORG)?
                              "AT_PRINTABLE_X_ORIGIN" : "AT_CURSOR_X_ORIGIN");
    if (pcm)
    {
        enum {Y_MOVE_NONE = 0, Y_MOVE_UP = 1, Y_MOVE_DOWN = 2, Y_MOVE_ABS = 4 }
            eCmdsPresent = Y_MOVE_NONE,
            eRelativeYCmds = /* Y_MOVE_UP | */   Y_MOVE_DOWN;    // use as bit field
            // for now just Y_MOVE_DOWN is sufficient for Relative Y move support.

        pci->pcm = pcm;
        //
        // check for flags that are ignored by NT4.0 RASDD but used by
        // Win95 Unidrv. When these flags are found, we expect minidriver
        // developers to double-check the generated GPD file to ensure
        // identical output under the new driver.
        //
        if (pcm->fGeneral & CM_GEN_FAV_XY)
            pci->dwErrorCode |= ERR_CM_GEN_FAV_XY;
        if (pcm->fXMove & CM_XM_RESET_FONT)
            pci->dwErrorCode |= ERR_CM_XM_RESET_FONT;

        if(pci->dwErrorCode & ERR_RES_BO_RESET_FONT)
            VOut(pci, "        *ReselectFont: LIST(%sAFTER_GRXDATA)\r\n",
            (pci->dwErrorCode & ERR_CM_XM_RESET_FONT)? "AFTER_XMOVE, ":"");
        else if(pci->dwErrorCode & ERR_CM_XM_RESET_FONT)
            VOut(pci, "        *ReselectFont: LIST(AFTER_XMOVE)\r\n");

        if (pcm->fXMove & CM_XM_ABS_NO_LEFT)
            pci->dwErrorCode |= ERR_CM_XM_ABS_NO_LEFT;
        if (pcm->fYMove & CM_YM_TRUNCATE)
            pci->dwErrorCode |= ERR_CM_YM_TRUNCATE;

        if ((pcm->fXMove & (CM_XM_NO_POR_GRX | CM_XM_NO_LAN_GRX)) ||
            (pcm->fYMove & (CM_YM_NO_POR_GRX | CM_YM_NO_LAN_GRX)))
        {
            pci->dwMode |= FM_VOUT_LIST;
            VOut(pci, "*BadCursorMoveInGrxMode: LIST(%s%s%s%s)\r\n",
                 (pcm->fXMove & CM_XM_NO_POR_GRX) ? "X_PORTRAIT," : "",
                 (pcm->fXMove & CM_XM_NO_LAN_GRX) ? "X_LANDSCAPE," : "",
                 (pcm->fYMove & CM_YM_NO_POR_GRX) ? "Y_PORTRAIT," : "",
                 (pcm->fYMove & CM_YM_NO_LAN_GRX) ? "Y_LANDSCAPE" : "");

            pci->dwMode &= ~FM_VOUT_LIST;
        }
        if ((pcm->fYMove & CM_YM_CR) ||
            ((pcm->fYMove & CM_YM_LINESPACING) &&
             pcm->rgocd[CM_OCD_YM_LINESPACING] != NOOCD) )
        {
            pci->dwMode |= FM_VOUT_LIST;

            VOut(pci, "*YMoveAttributes: LIST(%s%s)\r\n",
                 (pcm->fYMove & CM_YM_CR) ? "SEND_CR_FIRST," : "",
                 (pcm->fYMove & CM_YM_LINESPACING) ? "FAVOR_LF" : "");

            pci->dwMode &= ~FM_VOUT_LIST;
        }
        if (pcm->rgocd[CM_OCD_YM_LINESPACING] != NOOCD) // it takes 1 param.
        {
            PCD     pcd;
            PEXTCD  pextcd;      // points the parameter's EXTCD.

            pcd = (PCD)((PBYTE)(pdh) + pdh->loHeap +
                                      pcm->rgocd[CM_OCD_YM_LINESPACING]);
            pextcd = GETEXTCD(pdh, pcd);
            if (!(pextcd->fGeneral & XCD_GEN_NO_MAX))
                VOut(pci, "*MaxLineSpacing: %d\r\n",pextcd->sMax);
        }
        //
        // Three cases:
        // 1) if only absolute X-move command is specified,*XMoveThreshold
        //    should be 0, i.e. always use absolute cmd.
        // 2) if only relative X-move command is specified, *XMoveThreshold
        //    should be *, i.e always use relative cmds.
        // 3) if both are specified, both RASDD and Win95 Unidrv prefers
        //    absolute X-move cmd regardless of CM_XM_FAVOR_ABS bit. In that
        //    case, *XMoveThreshold should be 0, which is the default value.
        //
        if (pcm->rgocd[CM_OCD_XM_ABS] == NOOCD)
        {
            if (pcm->rgocd[CM_OCD_XM_REL] != NOOCD ||
                pcm->rgocd[CM_OCD_XM_RELLEFT] != NOOCD)
                VOut(pci, "*XMoveThreshold: *\r\n");
        }
        else
            VOut(pci, "*XMoveThreshold: 0\r\n");

        //
        // But CM_YM_FAV_ABS bit is honored by both drivers, except Win95 Unidrv
        // adds a hack: if the y-move is relative upward (i.e. genative diff)
        // with less than 10 pixels (in master Y unit), then always use
        // the relative Y movement. I don't see a strong reason to preserve
        // this hack.
        //
        if ((pcm->fYMove & CM_YM_FAV_ABS) && pcm->rgocd[CM_OCD_YM_ABS] != NOOCD)
            VOut(pci, "*YMoveThreshold: 0\r\n");
        else if (pcm->rgocd[CM_OCD_YM_REL] != NOOCD ||
                 pcm->rgocd[CM_OCD_YM_RELUP] != NOOCD)
            VOut(pci, "*YMoveThreshold: *\r\n");
        //
        // Figure out the X & Y movement units.
        // Assume that all X-move cmds have the same units. Same for Y-move cmds.
        //
        {
            DWORD    dwMoveUnit;

            if (dwMoveUnit = DwCalcMoveUnit(pci, pcm, pdh->ptMaster.x,
                                          CM_OCD_XM_ABS, CM_OCD_XM_RELLEFT))
                VOut(pci, "*XMoveUnit: %d\r\n", dwMoveUnit);
            if (dwMoveUnit = DwCalcMoveUnit(pci, pcm, pdh->ptMaster.y,
                                          CM_OCD_YM_ABS, CM_OCD_YM_RELUP))
                VOut(pci, "*YMoveUnit: %d\r\n", dwMoveUnit);
        }
        //
        // dump commands in CURSORMOVE structure
        //
        if (BBuildCmdStr(pci, CMD_CM_XM_ABS, pcm->rgocd[CM_OCD_XM_ABS]))
            VOutputCmd(pci, "CmdXMoveAbsolute");
        if (BBuildCmdStr(pci, CMD_CM_XM_REL, pcm->rgocd[CM_OCD_XM_REL]))
            VOutputCmd(pci, "CmdXMoveRelRight");
        if (BBuildCmdStr(pci, CMD_CM_XM_RELLEFT, pcm->rgocd[CM_OCD_XM_RELLEFT]))
            VOutputCmd(pci, "CmdXMoveRelLeft");
        if ((pcm->fYMove & CM_YM_RES_DEPENDENT) &&
            (pcm->rgocd[CM_OCD_YM_ABS] != NOOCD ||
             pcm->rgocd[CM_OCD_YM_REL] != NOOCD ||
             pcm->rgocd[CM_OCD_YM_RELUP] != NOOCD ||
             pcm->rgocd[CM_OCD_YM_LINESPACING] != NOOCD))
        {
            pci->dwErrorCode |= ERR_CM_YM_RES_DEPENDENT;
            VOut(pci, "*%% Error: the above *YMoveUnit value is wrong. It should be dependent on the resolution. Correct it manually.\r\n");
            //
            // Create dependency on Resolution options by
            // looping through each option and feed the multiplication
            // factor (ptTextScale.y) for building the command string.
            //
            VOut(pci, "*switch: Resolution\r\n{\r\n");
            psIndex = DHOFFSET(pdh, pmd->rgoi[MD_OI_RESOLUTION]);
            wCount = 1;
            while (*psIndex)
            {
                pci->pres = (PGPCRESOLUTION)GetTableInfo(pdh, HE_RESOLUTION,
                                                      *psIndex - 1);
                VOut(pci, "    *case: Option%d\r\n    {\r\n", wCount);
                if (BBuildCmdStr(pci, CMD_CM_YM_ABS, pcm->rgocd[CM_OCD_YM_ABS]))
                    VOutputCmd2(pci, "CmdYMoveAbsolute"),
                    eCmdsPresent |= Y_MOVE_ABS;
                if (BBuildCmdStr(pci, CMD_CM_YM_REL, pcm->rgocd[CM_OCD_YM_REL]))
                    VOutputCmd2(pci, "CmdYMoveRelDown"),
                    eCmdsPresent |= Y_MOVE_DOWN;
                if (BBuildCmdStr(pci, CMD_CM_YM_RELUP, pcm->rgocd[CM_OCD_YM_RELUP]))
                    VOutputCmd2(pci, "CmdYMoveRelUp"),
                    eCmdsPresent |= Y_MOVE_UP;
                if (BBuildCmdStr(pci, CMD_CM_YM_LINESPACING, pcm->rgocd[CM_OCD_YM_LINESPACING]))
                    VOutputCmd2(pci, "CmdSetLineSpacing");
                VOut(pci, "    }\r\n"); // close *case construct
                psIndex++;
                wCount++;
            }
            VOut(pci, "}\r\n"); // close *switch construct
        }
        else
        {
            if (BBuildCmdStr(pci, CMD_CM_YM_ABS, pcm->rgocd[CM_OCD_YM_ABS]))
                VOutputCmd(pci, "CmdYMoveAbsolute"),
                eCmdsPresent |= Y_MOVE_ABS;
            if (BBuildCmdStr(pci, CMD_CM_YM_REL, pcm->rgocd[CM_OCD_YM_REL]))
                VOutputCmd(pci, "CmdYMoveRelDown"),
                eCmdsPresent |= Y_MOVE_DOWN;
            if (BBuildCmdStr(pci, CMD_CM_YM_RELUP, pcm->rgocd[CM_OCD_YM_RELUP]))
                VOutputCmd(pci, "CmdYMoveRelUp"),
                eCmdsPresent |= Y_MOVE_UP;
            if (BBuildCmdStr(pci, CMD_CM_YM_LINESPACING, pcm->rgocd[CM_OCD_YM_LINESPACING]))
                VOutputCmd(pci, "CmdSetLineSpacing");
        }
        if (BBuildCmdStr(pci, CMD_CM_CR, pcm->rgocd[CM_OCD_CR]))
            VOutputCmd(pci, "CmdCR");
        if (BBuildCmdStr(pci, CMD_CM_LF, pcm->rgocd[CM_OCD_LF]))
            VOutputCmd(pci, "CmdLF");
        if (BBuildCmdStr(pci, CMD_CM_FF, pcm->rgocd[CM_OCD_FF]))
            VOutputCmd(pci, "CmdFF");
        if (BBuildCmdStr(pci, CMD_CM_BS, pcm->rgocd[CM_OCD_BS]))
            VOutputCmd(pci, "CmdBackSpace");
        if (BBuildCmdStr(pci, CMD_CM_UNI_DIR, pcm->rgocd[CM_OCD_UNI_DIR]))
            VOutputCmd(pci, "CmdUniDirectionOn");
        if (BBuildCmdStr(pci, CMD_CM_UNI_DIR_OFF, pcm->rgocd[CM_OCD_UNI_DIR_OFF]))
            VOutputCmd(pci, "CmdUniDirectionOff");
        if (BBuildCmdStr(pci, CMD_CM_PUSH_POS, pcm->rgocd[CM_OCD_PUSH_POS]))
            VOutputCmd(pci, "CmdPushCursor");
        if (BBuildCmdStr(pci, CMD_CM_POP_POS, pcm->rgocd[CM_OCD_POP_POS]))
            VOutputCmd(pci, "CmdPopCursor");

        if(!(eCmdsPresent & Y_MOVE_ABS)  &&
            ((eCmdsPresent & eRelativeYCmds) != eRelativeYCmds))
        VOut(pci, "*%% Error: no Abs or Rel YMoveCommands found. Correct it manually.\r\n");
    }
    if ((pci->pmd->fText & TC_CR_90) &&
        BBuildCmdStr(pci, CMD_PC_PRINT_DIR, pci->ppc->rgocd[PC_OCD_PRN_DIRECTION]))
        VOutputCmd(pci, "CmdSetSimpleRotation");
    //
    // In GPC, information regarding *EjectPageWithFF is spread out
    // among PAPERSIZE and PAPERSOURCE structures. For almost all
    // printers, the real dependency is not so pervasive. For example,
    // on dot-matrix printers, only PAPERSOURCE really uses this bit.
    // On most page printers, FF is always used to eject page.
    // We check for the reality and generate *switch/*case constructs
    // only when really needed.
    //
    {
        DWORD   i;
        BOOL    bSizeSame, bSrcSame; // whether all options same

        bSizeSame = TRUE;
        for (i = 1; bSizeSame && i < pci->dwNumOfSize; i++)
            bSizeSame = bSizeSame &&
                        (pci->ppiSize[i].bEjectFF == pci->ppiSize[0].bEjectFF);
        bSrcSame = TRUE;
        for (i = 1; bSrcSame && i < pci->dwNumOfSrc; i++)
            bSrcSame = bSrcSame &&
                       (pci->ppiSrc[i].bEjectFF == pci->ppiSrc[0].bEjectFF);

        if ((bSizeSame && pci->ppiSize[0].bEjectFF) ||
            (bSrcSame && pci->ppiSrc[0].bEjectFF) )
            VOut(pci, "*EjectPageWithFF?: TRUE\r\n");
        else if ((bSizeSame && !pci->ppiSize[0].bEjectFF) &&
                 (bSrcSame && !pci->ppiSrc[0].bEjectFF))
            VOut(pci, "*EjectPageWithFF?: FALSE\r\n");
        else if (bSizeSame && !pci->ppiSize[0].bEjectFF)
            VCreateEjectFFDependency(pci, FF_INPUTBIN, FALSE);
        else if (bSrcSame && !pci->ppiSize[0].bEjectFF)
            VCreateEjectFFDependency(pci, FF_PAPERSIZE, FALSE);
        else
            //
            // Have dependency on both PaperSize and InputBin.
            // Is this any sensible reason for this case? Assume not
            // for now until we find a minidriver that does.
            //
            VCreateEjectFFDependency(pci, FF_BOTH, FALSE);
    }
    //
    // Color attributes and commands are output in ColorMode options.
    //
    //

    // Raster Printing
    // Source: MD_OI_COMPRESSION, GPCRESOLUTION (RES_DM_GDI, RES_DM_LEFT_BOUND)
    // GPCRESOLUTION.fBlockOut, GPCRESOLUTION.fCursor (all flags),
    //
    // Rater Printing --- Raster Data Compression
    //
    {
        PCOMPRESSMODE pcmode;
        BOOL bDisableCmdDone = FALSE;

        psIndex = DHOFFSET(pdh, pmd->rgoi[MD_OI_COMPRESSION]);
        while (*psIndex != 0)
        {
            pcmode = (PCOMPRESSMODE)GetTableInfo(pdh, HE_COMPRESSION, *psIndex - 1);
            if (pcmode->iMode == CMP_ID_TIFF40 &&
                BBuildCmdStr(pci, CMD_CMP_TIFF, pcmode->rgocd[CMP_OCD_BEGIN]))
                VOutputCmd(pci, "CmdEnableTIFF4");
            else if (pcmode->iMode == CMP_ID_DELTAROW &&
                BBuildCmdStr(pci, CMD_CMP_DELTAROW, pcmode->rgocd[CMP_OCD_BEGIN]))
                VOutputCmd(pci, "CmdEnableDRC");
            else if (pcmode->iMode == CMP_ID_FE_RLE &&
                BBuildCmdStr(pci, CMD_CMP_FE_RLE, pcmode->rgocd[CMP_OCD_BEGIN]))
                VOutputCmd(pci, "CmdEnableFE_RLE");

            if (!bDisableCmdDone &&
                BBuildCmdStr(pci, CMD_CMP_NONE, pcmode->rgocd[CMP_OCD_END]))
            {
                VOutputCmd(pci, "CmdDisableCompression");
                bDisableCmdDone = TRUE;
            }
            psIndex++;
        }
    }

    //
    // Raster Printing --- Raster Data Emission
    //
    if (pres)
    {
        VOut(pci, "*OutputDataFormat: %s\r\n",
             (pres->fDump & RES_DM_GDI) ? "H_BYTE" : "V_BYTE");
        VOut(pci, "*OptimizeLeftBound?: %s\r\n",
             (pres->fDump & RES_DM_LEFT_BOUND) ? "TRUE" : "FALSE");

        VOut(pci, "*CursorXAfterSendBlockData: %s\r\n",
             (pres->fCursor & RES_CUR_X_POS_ORG)? "AT_GRXDATA_ORIGIN" :
             ((pres->fCursor & RES_CUR_X_POS_AT_0)? "AT_CURSOR_X_ORIGIN" :
                "AT_GRXDATA_END"));
        VOut(pci, "*CursorYAfterSendBlockData: %s\r\n",
             (pres->fCursor & RES_CUR_Y_POS_AUTO)? "AUTO_INCREMENT" : "NO_MOVE");

    }
    if (pmd->fGeneral & MD_NO_ADJACENT)
        pci->dwErrorCode |= ERR_MD_NO_ADJACENT;

    //
    // Device Fonts.
    // Source: MODELDATA, MD_OI_PORT_FONTS and MD_OI_LAND_FONTS.
    //
    if (pmd->sLookAhead > 0)
        VOut(pci, "*LookAheadRegion: %d\r\n", pmd->sLookAhead);

#if defined(DEVSTUDIO)  //  Must map this ID to account for multi PFM-> UFM
    vMapFontList(&pmd->sDefaultFontID, 1, pci);
#endif

    if (pmd->sDefaultFontID > 0)
        VOut(pci, "*DefaultFont: %d\r\n", pmd->sDefaultFontID);
    if (pmd->sDefaultCTT >= 0)
        VOut(pci, "*DefaultCTT: %d\r\n", pmd->sDefaultCTT);
    else
        VOut(pci, "*DefaultCTT: -%d\r\n", -pmd->sDefaultCTT);

    if (pmd->sMaxFontsPage > 0)
        VOut(pci, "*MaxFontUsePerPage: %d\r\n", pmd->sMaxFontsPage);
    if (pmd->fGeneral & MD_ALIGN_BASELINE)
        VOut(pci, "*CharPosition: BASELINE\r\n");
    {
        PWORD pwPFonts, pwLFonts;

        pwPFonts = (PWORD)((PBYTE)pdh + pdh->loHeap + pmd->rgoi[MD_OI_PORT_FONTS]);
        pwLFonts = (PWORD)((PBYTE)pdh + pdh->loHeap + pmd->rgoi[MD_OI_LAND_FONTS]);

        if (*pwPFonts || *pwLFonts)
        {
            if (pmd->fGeneral & MD_ROTATE_FONT_ABLE)
            {
                VOut(pci, "*DeviceFonts: ");
                VOutputFontList(pci, pwPFonts, pwLFonts);
            }
            else
            {
                VOut(pci, "*switch: Orientation\r\n{\r\n");
                VOut(pci, "    *case: PORTRAIT\r\n    {\r\n");
                VOut(pci, "        *DeviceFonts: ");
                VOutputFontList(pci, pwPFonts, NULL);
                VOut(pci, "    }\r\n");

                if (pmd->fGeneral & MD_LANDSCAPE_RT90)
                    VOut(pci, "    *case: LANDSCAPE_CC90\r\n    {\r\n");
                else
                    VOut(pci, "    *case: LANDSCAPE_CC270\r\n    {\r\n");
                VOut(pci, "        *DeviceFonts: ");
                VOutputFontList(pci, NULL, pwLFonts);
                VOut(pci, "    }\r\n}\r\n");
            }
        }
    }
    //
    // Built-in Font Cartridges.
    // Source: MD_OI_FONTCART
    //
    {
        PGPCFONTCART pfc;

        psIndex = DHOFFSET(pdh, pmd->rgoi[MD_OI_FONTCART]);
        wCount = 1;
        while (*psIndex != 0)
        {
            pfc = (PGPCFONTCART)GetTableInfo(pdh, HE_FONTCART, *psIndex - 1);
            VOut(pci, "*FontCartridge: FC%d\r\n{\r\n", wCount);
            VOut(pci, "    *rcCartridgeNameID: %d\r\n", pfc->sCartNameID);
            if (pmd->fGeneral & MD_ROTATE_FONT_ABLE)
            {
                VOut(pci, "    *Fonts: ");
                VOutputFontList(pci,
                    (PWORD)((PBYTE)pdh + pdh->loHeap + pfc->orgwPFM[FC_ORGW_PORT]),
                    (PWORD)((PBYTE)pdh + pdh->loHeap + pfc->orgwPFM[FC_ORGW_LAND]));
            }
            else
            {
                VOut(pci, "    *PortraitFonts: ");
                VOutputFontList(pci,
                    (PWORD)((PBYTE)pdh + pdh->loHeap + pfc->orgwPFM[FC_ORGW_PORT]),
                    NULL);
                VOut(pci, "    *LandscapeFonts: ");
                VOutputFontList(pci,
                    NULL,
                    (PWORD)((PBYTE)pdh + pdh->loHeap + pfc->orgwPFM[FC_ORGW_LAND]));
            }
            VOut(pci, "}\r\n"); // close *FontCartridge
            psIndex++;
            wCount++;
        }
    }

    //
    // Font Downloading
    // Source: MODELDATA, DOWNLOADINFO.
    //
    if (pmd->rgi[MD_I_DOWNLOADINFO] != NOT_USED)
    {
        PDOWNLOADINFO pdi;

        pdi = (PDOWNLOADINFO)GetTableInfo(pdh, HE_DOWNLOADINFO,
                                               pmd->rgi[MD_I_DOWNLOADINFO]);
        VOut(pci, "*MinFontID: %d\r\n*MaxFontID: %d\r\n", pdi->wIDMin, pdi->wIDMax);
        if (pdi->sMaxFontCount != -1)
            VOut(pci, "*MaxNumDownFonts: %d\r\n", pdi->sMaxFontCount);
        if (pdi->rgocd[DLI_OCD_SET_SECOND_FONT_ID] != NOOCD ||
            pdi->rgocd[DLI_OCD_SELECT_SECOND_FONT_ID] != NOOCD)
            pci->dwErrorCode |= ERR_HAS_SECOND_FONT_ID_CMDS;
        if (pdi->fFormat & DLI_FMT_CAPSL)
            pci->dwErrorCode |= ERR_DLI_FMT_CAPSL;
        if (pdi->fFormat & DLI_FMT_PPDS)
            pci->dwErrorCode |= ERR_DLI_FMT_PPDS;
        if (pdi->fGeneral & DLI_GEN_DLPAGE)
            pci->dwErrorCode |= ERR_DLI_GEN_DLPAGE;
        if (pdi->fGeneral & DLI_GEN_7BIT_CHARSET)
            pci->dwErrorCode |= ERR_DLI_GEN_7BIT_CHARSET;

#if 0
    // delete this entry --- assume always TRUE since the driver
    // doesn't even have code to handle non-incremental case.

        VOut(pci, "*IncrementalDownload?: %s\r\n",
                (pdi->fFormat & DLI_FMT_INCREMENT)? "TRUE" : "FALSE");
#endif
        if (pdi->fFormat & DLI_FMT_CALLBACK)
            VOut(pci, "*FontFormat: OEM_CALLBACK\r\n");
        else
        {
            if (pdi->fFormat & DLI_FMT_OUTLINE)
            {
                //
                // check for potential Resolution dependency
                //
                if ((pci->dwMode & FM_RES_DM_DOWNLOAD_OUTLINE) &&
                    (pci->dwMode & FM_NO_RES_DM_DOWNLOAD_OUTLINE))
                {
                    VOut(pci, "*switch: Resolution\r\n{\r\n");
                    psIndex = DHOFFSET(pdh, pmd->rgoi[MD_OI_RESOLUTION]);
                    wCount = 1;
                    while (*psIndex)
                    {
                        pres = (PGPCRESOLUTION)GetTableInfo(pdh, HE_RESOLUTION,
                                                              *psIndex - 1);
                        VOut(pci, "    *case: Option%d\r\n    {\r\n", wCount);
                        VOut(pci, "        *FontFormat: %s\r\n",
                                (pres->fDump & RES_DM_DOWNLOAD_OUTLINE) ?
                                    "HPPCL_OUTLINE" : "HPPCL_RES");
                        VOut(pci, "    }\r\n"); // close *case construct
                        psIndex++;
                        wCount++;
                    }
                    VOut(pci, "}\r\n");
                }
                else if (pci->dwMode & FM_RES_DM_DOWNLOAD_OUTLINE)
                    VOut(pci, "*FontFormat: HPPCL_OUTLINE\r\n");
                else
                    //
                    // assume all HPPCL_OUTLINE capable printers support
                    // resolution specific bitmap download format.
                    //
                    VOut(pci, "*FontFormat: HPPCL_RES\r\n");
            }
            else if (pdi->fFormat & DLI_FMT_RES_SPECIFIED)
                VOut(pci, "*FontFormat: HPPCL_RES\r\n");
            else if (pdi->fFormat & DLI_FMT_PCL)
                VOut(pci, "*FontFormat: HPPCL\r\n");
        }


        if (BBuildCmdStr(pci, CMD_SET_FONT_ID, pdi->rgocd[DLI_OCD_SET_FONT_ID]))
            VOutputCmd(pci, "CmdSetFontID");
        if (BBuildCmdStr(pci, CMD_SELECT_FONT_ID, pdi->rgocd[DLI_OCD_SELECT_FONT_ID]))
            VOutputCmd(pci, "CmdSelectFontID");
        if (BBuildCmdStr(pci, CMD_SET_CHAR_CODE, pdi->rgocd[DLI_OCD_SET_CHAR_CODE]))
            VOutputCmd(pci, "CmdSetCharCode");

    }

    //
    // Font Simulation
    // Source: FONTSIMULATION.
    //
    if (pmd->rgi[MD_I_FONTSIM] != NOT_USED)
    {
        PFONTSIMULATION pfs;

        pfs = (PFONTSIMULATION)GetTableInfo(pdh, HE_FONTSIM, pmd->rgi[MD_I_FONTSIM]);
        if (pmd->fText & TC_EA_DOUBLE)
        {
            if (BBuildCmdStr(pci, CMD_FS_BOLD_ON, pfs->rgocd[FS_OCD_BOLD_ON]))
                VOutputCmd(pci, "CmdBoldOn");
            if (BBuildCmdStr(pci, CMD_FS_BOLD_OFF, pfs->rgocd[FS_OCD_BOLD_OFF]))
                VOutputCmd(pci, "CmdBoldOff");
        }
        if (pmd->fText & TC_IA_ABLE)
        {
            if (BBuildCmdStr(pci, CMD_FS_ITALIC_ON, pfs->rgocd[FS_OCD_ITALIC_ON]))
                VOutputCmd(pci, "CmdItalicOn");
            if (BBuildCmdStr(pci, CMD_FS_ITALIC_OFF, pfs->rgocd[FS_OCD_ITALIC_OFF]))
                VOutputCmd(pci, "CmdItalicOff");
        }
        if (pmd->fText & TC_UA_ABLE)
        {
            if (BBuildCmdStr(pci, CMD_FS_UNDERLINE_ON, pfs->rgocd[FS_OCD_UNDERLINE_ON]))
                VOutputCmd(pci, "CmdUnderlineOn");
            if (BBuildCmdStr(pci, CMD_FS_UNDERLINE_OFF, pfs->rgocd[FS_OCD_UNDERLINE_OFF]))
                VOutputCmd(pci, "CmdUnderlineOff");
        }
        if (pmd->fText & TC_SO_ABLE)
        {
            if (BBuildCmdStr(pci, CMD_FS_STRIKETHRU_ON, pfs->rgocd[FS_OCD_STRIKETHRU_ON]))
                VOutputCmd(pci, "CmdStrikeThruOn");
            if (BBuildCmdStr(pci, CMD_FS_STRIKETHRU_OFF, pfs->rgocd[FS_OCD_STRIKETHRU_OFF]))
                VOutputCmd(pci, "CmdStrikeThruOff");
        }
        if (pmd->fGeneral & MD_WHITE_TEXT)
        {
            if (BBuildCmdStr(pci, CMD_FS_WHITE_TEXT_ON, pfs->rgocd[FS_OCD_WHITE_TEXT_ON]))
                VOutputCmd(pci, "CmdWhiteTextOn");
            if (BBuildCmdStr(pci, CMD_FS_WHITE_TEXT_OFF, pfs->rgocd[FS_OCD_WHITE_TEXT_OFF]))
                VOutputCmd(pci, "CmdWhiteTextOff");
        }
        if (pfs->rgocd[FS_OCD_SINGLE_BYTE] != NOOCD &&
            pfs->rgocd[FS_OCD_DOUBLE_BYTE] != NOOCD)
        {
            if (BBuildCmdStr(pci, CMD_FS_SINGLE_BYTE, pfs->rgocd[FS_OCD_SINGLE_BYTE]))
                VOutputCmd(pci, "CmdSelectSingleByteMode");
            if (BBuildCmdStr(pci, CMD_FS_DOUBLE_BYTE, pfs->rgocd[FS_OCD_DOUBLE_BYTE]))
                VOutputCmd(pci, "CmdSelectDoubleByteMode");
        }
        if (pfs->rgocd[FS_OCD_VERT_ON] != NOOCD &&
            pfs->rgocd[FS_OCD_VERT_OFF] != NOOCD)
        {
            if (BBuildCmdStr(pci, CMD_FS_VERT_ON, pfs->rgocd[FS_OCD_VERT_ON]))
                VOutputCmd(pci, "CmdVerticalPrintingOn");
            if (BBuildCmdStr(pci, CMD_FS_VERT_OFF, pfs->rgocd[FS_OCD_VERT_OFF]))
                VOutputCmd(pci, "CmdVerticalPrintingOff");
        }
    }

    //
    // Rectangle Area Fill entries
    //
    if (pmd->rgi[MD_I_RECTFILL] != NOT_USED)
    {
        PRECTFILL prf;

        prf = (PRECTFILL)GetTableInfo(pdh, HE_RECTFILL, pmd->rgi[MD_I_RECTFILL]);

        if (prf->fGeneral & RF_MIN_IS_WHITE)
            pci->dwErrorCode |= ERR_RF_MIN_IS_WHITE;

        if (prf->fGeneral & RF_CUR_X_END)
            VOut(pci, "*CursorXAfterRectFill: AT_RECT_X_END\r\n");
        if (prf->fGeneral & RF_CUR_Y_END)
            VOut(pci, "*CursorYAfterRectFill: AT_RECT_Y_END\r\n");

        VOut(pci, "*MinGrayFill: %d\r\n", prf->wMinGray);
        VOut(pci, "*MaxGrayFill: %d\r\n", prf->wMaxGray);

        if (BBuildCmdStr(pci, CMD_RF_X_SIZE, prf->rgocd[RF_OCD_X_SIZE]))
            VOutputCmd(pci, "CmdSetRectWidth");
        if (BBuildCmdStr(pci, CMD_RF_Y_SIZE, prf->rgocd[RF_OCD_Y_SIZE]))
            VOutputCmd(pci, "CmdSetRectHeight");
        if (BBuildCmdStr(pci, CMD_RF_GRAY_FILL, prf->rgocd[RF_OCD_GRAY_FILL]))
            VOutputCmd(pci, "CmdRectGrayFill");
        if (BBuildCmdStr(pci, CMD_RF_WHITE_FILL, prf->rgocd[RF_OCD_WHITE_FILL]))
            VOutputCmd(pci, "CmdRectWhiteFill");
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\tools\uni\gpc2gpd\gpc2gpd.c ===
/*++

Copyright (c) 1996-1998  Microsoft Corporation

Module Name:

    gpc2gpd.c

Abstract:

    GPC-to-GPD conversion program

Environment:

    User-mode, stand-alone utility tool

Revision History:

    10/16/96 -zhanw-
        Created it.

--*/

#include "gpc2gpd.h"

#if !defined(DEVSTUDIO) //  MDT only uses onre routine

VOID
VUsage(
    PSTR pstrProgName
    )

{
    printf("usage: gpc2gpd -I<GPC file>\r\n");
    printf("               -M<model index>\r\n");
    printf("               -R<resource DLL>\r\n");
    printf("               -O<GPD file>\r\n");
    printf("               -N<Model Name>\r\n");
    printf("               -S<0>      -- output display strings directly \r\n");
    printf("                 <1>      -- output display strings as value macros\r\n");
    printf("                             (see stdnames.gpd) \r\n");
    printf("                 <2>      -- output display strings as RC id's (see common.rc)\r\n");
    printf("               -P    -- if present, use spooler names for standard papersizes\r\n");
}

#endif  //!defined(DEVSTUDIO)

void
VOutputGlobalEntries(
    IN OUT PCONVINFO pci,
    IN PSTR pstrModelName,
    IN PSTR pstrResourceDLLName,
    IN PSTR pstrGPDFileName)
{
    VOut(pci, "*GPDSpecVersion: \"1.0\"\r\n");


    //
    // *CodePage should be defined in the included GPD file
    //
    if (pci->dwStrType == STR_MACRO)
        VOut(pci, "*Include: \"StdNames.gpd\"\r\n");
    else
        VOut(pci, "*CodePage: 1252\r\n");

    VOut(pci, "*GPDFileVersion: \"1.0\"\r\n");
    VOut(pci, "*GPDFileName: \"%s\"\r\n", pstrGPDFileName);

    VOut(pci, "*ModelName: \"%s\"\r\n", pstrModelName);
    VOut(pci, "*MasterUnits: PAIR(%d, %d)\r\n", pci->pdh->ptMaster.x, pci->pdh->ptMaster.y);
    VOut(pci, "*ResourceDLL: \"%s\"\r\n", pstrResourceDLLName);

    if (pci->pdh->fTechnology == GPC_TECH_TTY)
        VOut(pci, "*PrinterType: TTY\r\n");
    else if (pci->pmd->fGeneral & MD_SERIAL)
        VOut(pci, "*PrinterType: SERIAL\r\n");
    else
        VOut(pci, "*PrinterType: PAGE\r\n");

    if ((pci->pmd->fGeneral & MD_COPIES) && pci->ppc->sMaxCopyCount > 1)
        VOut(pci, "*MaxCopies: %d\r\n", pci->ppc->sMaxCopyCount);
    if (pci->pmd->sCartSlots > 0)
        VOut(pci, "*FontCartSlots: %d\r\n", pci->pmd->sCartSlots);

    if (pci->pmd->fGeneral & MD_CMD_CALLBACK)
        pci->dwErrorCode |= ERR_MD_CMD_CALLBACK;
}

#if !defined(DEVSTUDIO) //  MDT only uses the above code

void
VPrintErrors(
    IN HANDLE hLogFile,
    IN DWORD dwError)
{
    DWORD dwNumBytesWritten;
    DWORD i, len;

    for (i = 0; i < NUM_ERRS; i++)
    {
        if (dwError & gdwErrFlag[i])
        {
            len = strlen(gpstrErrMsg[i]);

            if (!WriteFile(hLogFile, gpstrErrMsg[i], len, &dwNumBytesWritten, NULL) ||
                dwNumBytesWritten != len)
                return;     // abort
        }
    }
}

INT _cdecl
main(
    INT     argc,
    CHAR   **argv
    )
/*++

Routine Desscription:

This routine parses the command line parameters, maps the GPC file into memory
and creates the output GPD file. It then starts converting GPC data by calling
various sub-routines. If any error occurs, it reports errors and tries to
continue if possible.

The following command line parameters are supported:
    -I<GPC_file> : the file name does not need double quotes. Ex. -Icanon330.gpc
    -M<model_id>: an integer, such as 1, which is the string resource id of the
                  the model name in the .rc file that comes with the given GPC
                  file.
    -N<model_name>: a string, such as "HP LaserJet 4L".
    -R<resource_dll>: the resource dll to be associated with the generated GPD
                      file. Ex. -Rcanon330.dll
    -O<GPD_file>: the output GPD file name. Ex. -Ohplj4l.gpd
    -S<style>: the string style used in generating the GPD file for standard names.
               -S0 means using the direct strings for *Name entries.
               -S1 means using string value macros for *Name entries. This is
                   mainly used for on-the-fly conversion. The value macros are
                   defined in printer5\inc\stdnames.gpd.
               -S2 means using RC string id's. These strings are defined in
                   printer5\inc\common.rc.
    -P         rcNameID: 0x7fffffff  for standard papersizes.

Arguments:
        argc - number of arguments
        **argv - pointer to an array of strings

Return value:
        0

--*/
{
    PSTR pstrProgName;
    PSTR pstrGPCFileName = NULL;
    WCHAR wstrGPCFile[MAX_PATH];
    PSTR pstrGPDFileName = NULL;
    WCHAR wstrGPDFile[MAX_PATH];
    PSTR pstrResourceDLLName = NULL;
    PSTR pstrModelName = NULL;
    HFILEMAP hGPCFileMap;
    CONVINFO    ci;     // structure to keep track conversion information
    DWORD   dwStrType = STR_MACRO; // default
    WORD wModelIndex;
    BOOL    bUseSystemPaperNames = FALSE;


    //
    // Go through the command line arguments
    //

    pstrProgName = *argv++;
    argc--;

    if (argc == 0)
        goto error_exit;

    for ( ; argc--; argv++)
    {
        PSTR    pArg = *argv;

        if (*pArg == '-' || *pArg == '/')
        {
            switch (*++pArg)
            {
            case 'I':
                pstrGPCFileName = ++pArg;
                break;

            case 'M':
                wModelIndex = (WORD)atoi(++pArg);
                break;

            case 'R':
                pstrResourceDLLName = ++pArg;
                break;

            case 'O':
                pstrGPDFileName = ++pArg;
                break;

            case 'N':
                pstrModelName = ++pArg;
                break;

            case 'S':
                dwStrType = atoi(++pArg);
                break;

            case 'P':
                bUseSystemPaperNames = TRUE;
                break;

            default:
                goto error_exit;
            }
        }
        else
            goto error_exit;
    }

    //
    // check if we have all the arguments needed
    //
    if (!pstrGPCFileName || !pstrGPDFileName || !pstrResourceDLLName ||
        !wModelIndex || !pstrModelName)
        goto error_exit;

    ZeroMemory((PVOID)&ci, sizeof(CONVINFO));

    //
    // Open the GPC file and map it into memory.
    //
    MultiByteToWideChar(CP_ACP, 0, pstrGPCFileName, -1, wstrGPCFile, MAX_PATH);
    hGPCFileMap = MapFileIntoMemory((LPCTSTR)wstrGPCFile, (PVOID *)&(ci.pdh), NULL);
    if (!hGPCFileMap)
    {
        ERR(("Couldn't open file: %ws\r\n", pstrGPCFileName));
        return (-1);
    }
    //
    // create the output GPD file. If the given file already exists,
    // overwrite it.
    //
    MultiByteToWideChar(CP_ACP, 0, pstrGPDFileName, -1, wstrGPDFile, MAX_PATH);
    ci.hGPDFile = CreateFile((PCTSTR)wstrGPDFile, GENERIC_WRITE, 0, NULL,
                          CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
    if (ci.hGPDFile == INVALID_HANDLE_VALUE)
    {
        ERR(("Couldn't create file: %ws\r\n", pstrGPDFileName));
        UnmapFileFromMemory(hGPCFileMap);
        return (-1);
    }

    //
    // GPC file sanity check
    //
    if (ci.pdh->sMagic != 0x7F00 ||
        !(ci.pmd = (PMODELDATA)GetTableInfo(ci.pdh, HE_MODELDATA, wModelIndex-1)) ||
        !(ci.ppc = (PPAGECONTROL)GetTableInfo(ci.pdh, HE_PAGECONTROL,
                                            ci.pmd->rgi[MD_I_PAGECONTROL])))
    {
        ci.dwErrorCode |= ERR_BAD_GPCDATA;
        goto exit;
    }
    //
    // allocate dynamic buffers needed for conversion
    //
    if (!(ci.ppiSize=(PPAPERINFO)MemAllocZ(ci.pdh->rghe[HE_PAPERSIZE].sCount*sizeof(PAPERINFO))) ||
        !(ci.ppiSrc=(PPAPERINFO)MemAllocZ(ci.pdh->rghe[HE_PAPERSOURCE].sCount*sizeof(PAPERINFO))) ||
        !(ci.presinfo=(PRESINFO)MemAllocZ(ci.pdh->rghe[HE_RESOLUTION].sCount*sizeof(RESINFO))))
    {
        ci.dwErrorCode |= ERR_OUT_OF_MEMORY;
        goto exit;
    }

    ci.dwStrType = dwStrType;
    ci.bUseSystemPaperNames = bUseSystemPaperNames ;

    //
    // generate GPD data
    //
    VOutputGlobalEntries(&ci, pstrModelName, pstrResourceDLLName, pstrGPDFileName);
    VOutputUIEntries(&ci);
    VOutputPrintingEntries(&ci);

exit:
    UnmapFileFromMemory(hGPCFileMap);
    CloseHandle(ci.hGPDFile);
    if (ci.ppiSize)
        MemFree(ci.ppiSize);
    if (ci.ppiSrc)
        MemFree(ci.ppiSrc);
    if (ci.presinfo)
        MemFree(ci.presinfo);
    if (ci.dwErrorCode)
    {
        PWSTR   pwstrLogFileName;
        INT     i;
        HANDLE  hLogFile;

        //
        // Open the log file and print out errors/warnings.
        // Borrow the GPD file name buffer.
        //
        pwstrLogFileName = wstrGPDFile;
        i = _tcslen((PTSTR)pwstrLogFileName);
        if (_tcsrchr((PTSTR)pwstrLogFileName, TEXT('.')) != NULL)
            i = i - 4; // there is a .GPD extension
        _tcscpy((PTSTR)pwstrLogFileName + i, TEXT(".log"));

        hLogFile = CreateFile((PCTSTR)pwstrLogFileName, GENERIC_WRITE, 0, NULL,
                         CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
        if (hLogFile == INVALID_HANDLE_VALUE)
        {
            ERR(("Couldn't create the log file\r\n"));
            return (-1);
        }
        VPrintErrors(hLogFile, ci.dwErrorCode);
        CloseHandle(hLogFile);
    }

    return 0;

error_exit:
    VUsage(pstrProgName);
    return (-1);
}

#endif  //  !defined(DEVSTUDIO)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\tools\uni\gpc2gpd\utils.c ===
/*++

Copyright (c) 1996-1997  Microsoft Corporation

Module Name:

    utils.c

Abstract:

    Utility functions used by the GPC-to-GPD converter

Environment:

    user-mode only.

Revision History:

    10/17/96 -zhanw-
        Created it.

--*/

#include "gpc2gpd.h"

//
// define global read-only variables
//

BYTE gbHexChar[16] = {'0','1','2','3','4','5','6','7','8','9',
                 'A','B','C','D','E','F'};

DWORD gdwErrFlag[NUM_ERRS] = {
    ERR_BAD_GPCDATA,
    ERR_OUT_OF_MEMORY,
    ERR_WRITE_FILE,
    ERR_MD_CMD_CALLBACK,
    ERR_CM_GEN_FAV_XY,
    ERR_CM_XM_RESET_FONT,
    ERR_CM_XM_ABS_NO_LEFT,
    ERR_CM_YM_TRUNCATE,
    ERR_RF_MIN_IS_WHITE,
    ERR_INCONSISTENT_PAGEPROTECT,
    ERR_NON_ZERO_FEED_MARGINS_ON_RT90_PRINTER,
    ERR_BAD_GPC_CMD_STRING,
    ERR_RES_BO_RESET_FONT,
    ERR_RES_BO_OEMGRXFILTER,
    ERR_CM_YM_RES_DEPENDENT,
    ERR_MOVESCALE_NOT_FACTOR_OF_MASTERUNITS,
    ERR_NO_CMD_CALLBACK_PARAMS,
    ERR_HAS_DUPLEX_ON_CMD,
    ERR_PSRC_MAN_PROMPT,
    ERR_PS_SUGGEST_LNDSCP,
    ERR_HAS_SECOND_FONT_ID_CMDS,
    ERR_DLI_FMT_CAPSL,
    ERR_DLI_FMT_PPDS,
    ERR_DLI_GEN_DLPAGE,
    ERR_DLI_GEN_7BIT_CHARSET,
    ERR_DC_SEND_PALETTE,
    ERR_RES_BO_NO_ADJACENT,
    ERR_MD_NO_ADJACENT,
    ERR_CURSOR_ORIGIN_ADJUSTED,
    ERR_PRINTABLE_ORIGIN_ADJUSTED,
    ERR_PRINTABLE_AREA_ADJUSTED,
    ERR_MOVESCALE_NOT_FACTOR_INTO_SOME_RESSCALE
};

PSTR gpstrErrMsg[NUM_ERRS] = {
    "Error: Bad GPC data.\r\n",
    "Error: Out of system memory.\r\n",
    "Error: Cannot write to the GPD file.\r\n",
    "Warning: MODELDATA.fGeneral MD_CMD_CALLBACK is set.\r\n",
    "Warning: CURSORMODE.fGeneral CM_GEN_FAV_XY is set.\r\n",
    "Warning: CURSORMOVE.fXMove CM_XM_RESET_FONT is set.\r\n",
    "Warning: CURSORMOVE.fXMove CM_XM_ABS_NO_LEFT is set.\r\n",
    "Warning: CURSORMOVE.fYMove CM_YM_TRUNCATE is set.\r\n",
    "Warning: RECTFILL.fGeneral RF_MIN_IS_WHITE is set.\r\n",
    "Error: Inconsistent GPC data: some PAPERSIZE have PageProtect On/Off cmds while others do not. PageProtect feature is not generated.\r\n",
    "Error: Some PAPERSOURCE have non-zero top/bottom margins on this RT90 printer. Check the GPD file for details.\r\n",
    "Error: Some GPC command strings are illegal. Search for !ERR! in the GPD file.\r\n",
    "Warning: Some RESOLUTION have RES_BO_RESET_FONT flag set. Check the GPD file for details.\r\n",
    "Error: Some RESOLUTION have RES_BO_OEMGRXFILTER flag set. Check the GPD file for details.\r\n",
    "Error: The generated *YMoveUnit value is wrong because Y move cmds have dependency on the resolution. Correct it manually.\r\n",
    "Error: The MoveUnits are not factors of the MasterUnits.  Correct the GPC using Unitool before converting.\r\n",
    "Error: At least one callback command is generated. Check the GPD file to see if you need any parameters.\r\n",
    "Warning: PAGECONTROL has non-NULL DUPLEX_ON command.\r\n",
    "Warning: Some PAPERSOURCE have PSRC_MAN_PROMPT flag set. Check the GPD file for details.\r\n",
    "Warning: Some PAPERSIZE have PS_SUGGEST_LNDSCP flag set. Check the GPD file for details.\r\n",
    "Warning: DOWNLOADINFO has non-NULL xxx_SECOND_FONT_ID_xxx commands.\r\n",
    "Error: DLI_FMT_CAPSL flag is set. Must supply custom code to support this font format.\r\n",
    "Error: DLI_FMT_PPDS flag is set. Must supply custom code to support this font format.\r\n",
    "Warning: DLI_GEN_DLPAGE flag is set.\r\n",
    "Warning: DLI_GEN_7BIT_CHARSET flag is set.\r\n",
    "Warning: DEVCOLOR.fGeneral DC_SEND_PALETTE flag is set.\r\n",
    "Warning: Some RESOLUTION have RES_BO_NO_ADJACENT flag set. Check the GPD file for details.\r\n",
    "Warning: MODELDATA.fGeneral MD_NO_ADJACENT is set.\r\n",
    "Warning: Some *CursorOrigin values have been adjusted. Check the GPD file for details.\r\n",
    "Warning: Some *PrintableOrigin values have been adjusted. Check the GPD file for details.\r\n",
    "Warning: Some *PrintableArea values have been adjusted. Check the GPD file for details.\r\n",
    "Warning: Please check that every *PrintableOrigin (X,Y) factor evenly into the move unit scale X/Y.\r\n"
};

//
// define standard variable name strings
//
PSTR gpstrSVNames[SV_MAX] = {
    "NumOfDataBytes",
    "RasterDataWidthInBytes",
    "RasterDataHeightInPixels",
    "NumOfCopies",
    "PrintDirInCCDegrees",
    "DestX",
    "DestY",
    "DestXRel",
    "DestYRel",
    "LinefeedSpacing",
    "RectXSize",
    "RectYSize",
    "GrayPercentage",
    "NextFontID",
    "NextGlyph",
    "PhysPaperLength",
    "PhysPaperWidth",
    "FontHeight",
    "FontWidth",
    "FontMaxWidth",
    "FontBold",
    "FontItalic",
    "FontUnderline",
    "FontStrikeThru",
    "CurrentFontID",
    "TextYRes",
    "TextXRes",
    "GraphicsYRes",
    "GraphicsXRes",
    "Rop3",
    "RedValue",
    "GreenValue",
    "BlueValue",
    "PaletteIndexToProgram",
    "CurrentPaletteIndex"

};
//
// define the standard variable id heap. It consists of a series of id runs.
// Each run is a sequence of standard variable id's (SV_xxx value, 0-based)
// ended by -1 (0xFFFFFFFF). The runs are constructed based on the need of
// GPC commands. Basically, one run corresponds to one GPC command that
// requires parameters. If more than one GPC command share the same set of
// parameters, then they can share the same run.
//
DWORD gdwSVLists[] = {
    EOR,        // place holder for all GPC commands that has no parameter
    SV_NUMDATABYTES,    // CMD_RES_SENDBLOCK can have 3 params
    SV_HEIGHTINPIXELS,
    SV_WIDTHINBYTES,
    EOR,
    SV_COPIES,          // offset 5. CMD_PC_MULT_COPIES
    EOR,
    SV_DESTX,           // offset 7
    EOR,
    SV_DESTY,           // offset 9
    EOR,
    SV_DESTXREL,        // offset 11
    EOR,
    SV_DESTYREL,        // offset 13
    EOR,
    SV_LINEFEEDSPACING, // offset 15
    EOR,
    SV_DESTXREL,        // offset 17
    SV_DESTYREL,
    EOR,
    SV_DESTX,           // offset 20
    SV_DESTY,
    EOR,
    SV_RECTXSIZE,       // offset 23
    EOR,
    SV_RECTYSIZE,       // offset 25
    EOR,
    SV_GRAYPERCENT,     // offset 27
    EOR,
    SV_NEXTFONTID,      // offset 29
    EOR,
    SV_CURRENTFONTID,   // offset 31
    EOR,
    SV_NEXTGLYPH,       // offset 33
    EOR,
    SV_PHYSPAPERLENGTH, // offset 35
    SV_PHYSPAPERWIDTH,
    EOR,
    SV_PRINTDIRECTION,  // offset 38
    EOR,
    SV_NUMDATABYTES,    // offset 40
    EOR,
    SV_REDVALUE,        // offset 42
    SV_GREENVALUE,
    SV_BLUEVALUE,
    SV_PALETTEINDEXTOPROGRAM,
    EOR,
    SV_CURRENTPALETTEINDEX, // offset 47
    EOR
};
//
// map CMD_xxx id to the corresponding DWORD offset to the standard variable
// id heap. That is, gdwSVLists[gawCmdtoSVOffset[CMD_RES_SELECTRES]] is the
// beginning of a parameter run for GPC's command CMD_RES_SELECTRES. If the
// first element in the run of EOR, that means the command takes no param.
//
WORD gawCmdtoSVOffset[MAXCMD+MAXECMD] = {
    0,  // CMD_RES_SELECTRES
    0,  // CMD_RES_BEGINGRAPHICS
    0,  // CMD_RES_ENDGRAPHICS
    1,  // CMD_RES_SENDBLOCK
    0,  // CMD_RES_ENDBLOCK

    0,  // CMD_CMP_NONE
    0,  // CMD_CMP_RLE
    0,  // CMD_CMP_TIFF
    0,  // CMD_CMP_DELTAROW
    0,  // CMD_CMP_BITREPEAT
    0,  // CMD_CMP_FE_RLE

    0,  // CMD_PC_BEGIN_DOC
    0,  // CMD_PC_BEGIN_PAGE
    0,  // CMD_PC_DUPLEX_ON
    0,  // CMD_PC_ENDDOC
    0,  // CMD_PC_ENDPAGE
    0,  // CMD_PC_DUPLEX_OFF
    0,  // CMD_PC_ABORT
    0,  // CMD_PC_PORTRAIT, CMD_PC_ORIENTATION
    0,  // CMD_PC_LANDSCAPE
    5,  // CMD_PC_MULT_COPIES
    0,  // CMD_PC_DUPLEX_VERT
    0,  // CMD_PC_DUPLEX_HORZ
    38, // CMD_PC_PRINT_DIR
    0,  // CMD_PC_JOB_SEPARATION

    7,  // CMD_CM_XM_ABS
    11, // CMD_CM_XM_REL
    11, // CMD_CM_XM_RELLEFT
    9,  // CMD_CM_YM_ABS
    13, // CMD_CM_YM_REL
    13, // CMD_CM_YM_RELUP
    15, // CMD_CM_YM_LINESPACING
    17, // CMD_CM_XY_REL
    20, // CMD_CM_XY_ABS
    0,  // CMD_CM_CR
    0,  // CMD_CM_LF
    0,  // CMD_CM_FF
    0,  // CMD_CM_BS
    0,  // CMD_CM_UNI_DIR
    0,  // CMD_CM_UNI_DIR_OFF
    0,  // CMD_CM_PUSH_POS
    0,  // CMD_CM_POP_POS

    0,  // CMD_FS_BOLD_ON
    0,  // CMD_FS_BOLD_OFF
    0,  // CMD_FS_ITALIC_ON
    0,  // CMD_FS_ITALIC_OFF
    0,  // CMD_FS_UNDERLINE_ON
    0,  // CMD_FS_UNDERLINE_OFF
    0,  // CMD_FS_DOUBLEUNDERLINE_ON
    0,  // CMD_FS_DOUBLEUNDERLINE_OFF
    0,  // CMD_FS_STRIKETHRU_ON
    0,  // CMD_FS_STRIKETHRU_OFF
    0,  // CMD_FS_WHITE_TEXT_ON
    0,  // CMD_FS_WHITE_TEXT_OFF
    0,  // CMD_FS_SINGLE_BYTE
    0,  // CMD_FS_DOUBLE_BYTE
    0,  // CMD_FS_VERT_ON
    0,  // CMD_FS_VERT_OFF

    0,  // CMD_DC_TC_BLACK
    0,  // CMD_DC_TC_RED
    0,  // CMD_DC_TC_GREEN
    0,  // CMD_DC_TC_YELLOW
    0,  // CMD_DC_TC_BLUE
    0,  // CMD_DC_TC_MAGENTA
    0,  // CMD_DC_TC_CYAN
    0,  // CMD_DC_TC_WHITE
    0,  // CMD_DC_GC_SETCOLORMODE
    0,  // CMD_DC_PC_START
    42, // CMD_DC_PC_ENTRY
    0,  // CMD_DC_PC_END
    47, // CMD_DC_PC_SELECTINDEX
    0,  // CMD_DC_SETMONOMODE

    40, // CMD_DC_GC_PLANE1
    40, // CMD_DC_GC_PLANE2
    40, // CMD_DC_GC_PLANE3
    40, // CMD_DC_GC_PLANE4

    23, // CMD_RF_X_SIZE
    25, // CMD_RF_Y_SIZE
    27, // CMD_RF_GRAY_FILL
    0,  // CMD_RF_WHITE_FILL

    0,  // Reserved
    0,  // CMD_BEGIN_DL_JOB
    0,  // CMD_BEGIN_FONT_DL
    29, // CMD_SET_FONT_ID
    0,  // CMD_SEND_FONT_DCPT --- this command is no longer used.
    31, // CMD_SELECT_FONT_ID
    33, // CMD_SET_CHAR_CODE
    0,  // CMD_SEND_CHAR_DCPT --- this command is no longer used.
    0,  // CMD_END_FONT_DL
    0,  // CMD_MAKE_PERM
    0,  // CMD_MAKE_TEMP
    0,  // CMD_END_DL_JOB
    0,  // CMD_DEL_FONT
    0,  // CMD_DEL_ALL_FONTS
    0,  // CMD_SET_SECOND_FONT_ID    --- used only by CAPSL. Obsolete.
    0,  // CMD_SELECT_SECOND_FONT_ID --- used only by CAPSL. Obsolete.

    0,  // CMD_TEXTQUALITY
    0,  // CMD_PAPERSOURCE
    0,  // CMD_PAPERQUALITY
    0,  // CMD_PAPERDEST
    35, // CMD_PAPERSIZE
    35, // CMD_PAPERSIZE_LAND
    0,  // CMD_PAGEPROTECT_ON
    0,  // CMD_PAGEPROTECT_OFF
    0,  // CMD_IMAGECONTROL
    0   // CMD_PRINTDENSITY
};

PSTR gpstrFeatureName[FID_MAX] = {
    "OutputBin",
    "ImageControl",
    "PrintDensity"
};

PSTR gpstrFeatureDisplayNameMacro[FID_MAX] = {   // reference value macro names
    "OUTPUTBIN_DISPLAY",
    "IMAGECONTROL_DISPLAY",
    "PRINTDENSITY_DISPLAY"
};

PSTR gpstrFeatureDisplayName[FID_MAX] = {   // reference names
    "Output Bin",
    "Image Control",
    "Print Density"
};

INT gintFeatureDisplayNameID[FID_MAX] = {   // reference string resource ids
    2111,   // these values must match definitions in printer5\inc\common.rc
    2112,
    2113
};

WORD gwFeatureMDOI[FID_MAX] = {
    MD_OI_PAPERDEST,
    MD_OI_IMAGECONTROL,
    MD_OI_PRINTDENSITY
};

WORD gwFeatureOCDWordOffset[FID_MAX] = {
    3,
    3,
    2
};

WORD gwFeatureHE[FID_MAX] = {
    HE_PAPERDEST,
    HE_IMAGECONTROL,
    HE_PRINTDENSITY
};

WORD gwFeatureORD[FID_MAX] = {
    PC_ORD_PAPER_DEST,
    PC_ORD_IMAGECONTROL,
    PC_ORD_PRINTDENSITY
};

WORD gwFeatureCMD[FID_MAX] = {
    CMD_PAPERDEST,
    CMD_IMAGECONTROL,
    CMD_PRINTDENSITY
};
//
// define the mapping between standard paper size id to the standard
// PaperSize option name
//
PSTR gpstrStdPSName[DMPAPER_COUNT] = {
    "LETTER",
    "LETTERSMALL",
    "TABLOID",
    "LEDGER",
    "LEGAL",
    "STATEMENT",
    "EXECUTIVE",
    "A3",
    "A4",
    "A4SMALL",
    "A5",
    "B4",
    "B5",
    "FOLIO",
    "QUARTO",
    "10X14",
    "11X17",
    "NOTE",
    "ENV_9",
    "ENV_10",
    "ENV_11",
    "ENV_12",
    "ENV_14",
    "CSHEET",
    "DSHEET",
    "ESHEET",
    "ENV_DL",
    "ENV_C5",
    "ENV_C3",
    "ENV_C4",
    "ENV_C6",
    "ENV_C65",
    "ENV_B4",
    "ENV_B5",
    "ENV_B6",
    "ENV_ITALY",
    "ENV_MONARCH",
    "ENV_PERSONAL",
    "FANFOLD_US",
    "FANFOLD_STD_GERMAN",
    "FANFOLD_LGL_GERMAN",
    "ISO_B4",
    "JAPANESE_POSTCARD",
    "9X11",
    "10X11",
    "15X11",
    "ENV_INVITE",
    "",     // RESERVED_48
    "",     // RESERVED_49
    "LETTER_EXTRA",
    "LEGAL_EXTRA",
    "TABLOID_EXTRA",
    "A4_EXTRA",
    "LETTER_TRANSVERSE",
    "A4_TRANSVERSE",
    "LETTER_EXTRA_TRANSVERSE",
    "A_PLUS",
    "B_PLUS",
    "LETTER_PLUS",
    "A4_PLUS",
    "A5_TRANSVERSE",
    "B5_TRANSVERSE",
    "A3_EXTRA",
    "A5_EXTRA",
    "B5_EXTRA",
    "A2",
    "A3_TRANSVERSE",
    "A3_EXTRA_TRANSVERSE",
    "DBL_JAPANESE_POSTCARD",
    "A6",
    "JENV_KAKU2",
    "JENV_KAKU3",
    "JENV_CHOU3",
    "JENV_CHOU4",
    "LETTER_ROTATED",
    "A3_ROTATED",
    "A4_ROTATED",
    "A5_ROTATED",
    "B4_JIS_ROTATED",
    "B5_JIS_ROTATED",
    "JAPANESE_POSTCARD_ROTATED",
    "DBL_JAPANESE_POSTCARD_ROTATED",
    "A6_ROTATED",
    "JENV_KAKU2_ROTATED",
    "JENV_KAKU3_ROTATED",
    "JENV_CHOU3_ROTATED",
    "JENV_CHOU4_ROTATED",
    "B6_JIS",
    "B6_JIS_ROTATED",
    "12X11",
    "JENV_YOU4",
    "JENV_YOU4_ROTATED",
    "P16K",
    "P32K",
    "P32KBIG",
    "PENV_1",
    "PENV_2",
    "PENV_3",
    "PENV_4",
    "PENV_5",
    "PENV_6",
    "PENV_7",
    "PENV_8",
    "PENV_9",
    "PENV_10",
    "P16K_ROTATED",
    "P32K_ROTATED",
    "P32KBIG_ROTATED",
    "PENV_1_ROTATED",
    "PENV_2_ROTATED",
    "PENV_3_ROTATED",
    "PENV_4_ROTATED",
    "PENV_5_ROTATED",
    "PENV_6_ROTATED",
    "PENV_7_ROTATED",
    "PENV_8_ROTATED",
    "PENV_9_ROTATED",
    "PENV_10_ROTATED"
};

PSTR gpstrStdPSDisplayNameMacro[DMPAPER_COUNT] = {
    "LETTER_DISPLAY",
    "LETTERSMALL_DISPLAY",
    "TABLOID_DISPLAY",
    "LEDGER_DISPLAY",
    "LEGAL_DISPLAY",
    "STATEMENT_DISPLAY",
    "EXECUTIVE_DISPLAY",
    "A3_DISPLAY",
    "A4_DISPLAY",
    "A4SMALL_DISPLAY",
    "A5_DISPLAY",
    "B4_DISPLAY",
    "B5_DISPLAY",
    "FOLIO_DISPLAY",
    "QUARTO",
    "10X14_DISPLAY",
    "11X17_DISPLAY",
    "NOTE_DISPLAY",
    "ENV_9_DISPLAY",
    "ENV_10_DISPLAY",
    "ENV_11_DISPLAY",
    "ENV_12_DISPLAY",
    "ENV_14_DISPLAY",
    "CSHEET_DISPLAY",
    "DSHEET_DISPLAY",
    "ESHEET_DISPLAY",
    "ENV_DL_DISPLAY",
    "ENV_C5_DISPLAY",
    "ENV_C3_DISPLAY",
    "ENV_C4_DISPLAY",
    "ENV_C6_DISPLAY",
    "ENV_C65_DISPLAY",
    "ENV_B4_DISPLAY",
    "ENV_B5_DISPLAY",
    "ENV_B6_DISPLAY",
    "ENV_ITALY_DISPLAY",
    "ENV_MONARCH_DISPLAY",
    "ENV_PERSONAL_DISPLAY",
    "FANFOLD_US_DISPLAY",
    "FANFOLD_STD_GERMAN_DISPLAY",
    "FANFOLD_LGL_GERMAN_DISPLAY",
    "ISO_B4_DISPLAY",
    "JAPANESE_POSTCARD_DISPLAY",
    "9X11_DISPLAY",
    "10X11_DISPLAY",
    "15X11_DISPLAY",
    "ENV_INVITE_DISPLAY",
    "",            // RESERVED--DO NOT USE
    "",            // RESERVED--DO NOT USE
    "LETTER_EXTRA_DISPLAY",
    "LEGAL_EXTRA_DISPLAY",
    "TABLOID_EXTRA_DISPLAY",
    "A4_EXTRA_DISPLAY",
    "LETTER_TRANSVERSE_DISPLAY",
    "A4_TRANSVERSE_DISPLAY",
    "LETTER_EXTRA_TRANSVERSE_DISPLAY",
    "A_PLUS_DISPLAY",
    "B_PLUS_DISPLAY",
    "LETTER_PLUS_DISPLAY",
    "A4_PLUS_DISPLAY",
    "A5_TRANSVERSE_DISPLAY",
    "B5_TRANSVERSE_DISPLAY",
    "A3_EXTRA_DISPLAY",
    "A5_EXTRA_DISPLAY",
    "B5_EXTRA_DISPLAY",
    "A2_DISPLAY",
    "A3_TRANSVERSE_DISPLAY",
    "A3_EXTRA_TRANSVERSE_DISPLAY",
    "DBL_JAPANESE_POSTCARD_DISPLAY",
    "A6_DISPLAY",
    "JENV_KAKU2_DISPLAY",
    "JENV_KAKU3_DISPLAY",
    "JENV_CHOU3_DISPLAY",
    "JENV_CHOU4_DISPLAY",
    "LETTER_ROTATED_DISPLAY",
    "A3_ROTATED_DISPLAY",
    "A4_ROTATED_DISPLAY",
    "A5_ROTATED_DISPLAY",
    "B4_JIS_ROTATED_DISPLAY",
    "B5_JIS_ROTATED_DISPLAY",
    "JAPANESE_POSTCARD_ROTATED_DISPLAY",
    "DBL_JAPANESE_POSTCARD_ROTATED_DISPLAY",
    "A6_ROTATED_DISPLAY",
    "JENV_KAKU2_ROTATED_DISPLAY",
    "JENV_KAKU3_ROTATED_DISPLAY",
    "JENV_CHOU3_ROTATED_DISPLAY",
    "JENV_CHOU4_ROTATED_DISPLAY",
    "B6_JIS_DISPLAY",
    "B6_JIS_ROTATED_DISPLAY",
    "12X11_DISPLAY",
    "JENV_YOU4_DISPLAY",
    "JENV_YOU4_ROTATED_DISPLAY",
    "P16K_DISPLAY",
    "P32K_DISPLAY",
    "P32KBIG_DISPLAY",
    "PENV_1_DISPLAY",
    "PENV_2_DISPLAY",
    "PENV_3_DISPLAY",
    "PENV_4_DISPLAY",
    "PENV_5_DISPLAY",
    "PENV_6_DISPLAY",
    "PENV_7_DISPLAY",
    "PENV_8_DISPLAY",
    "PENV_9_DISPLAY",
    "PENV_10_DISPLAY",
    "P16K_ROTATED_DISPLAY",
    "P32K_ROTATED_DISPLAY",
    "P32KBIG_ROTATED_DISPLAY",
    "PENV_1_ROTATED_DISPLAY",
    "PENV_2_ROTATED_DISPLAY",
    "PENV_3_ROTATED_DISPLAY",
    "PENV_4_ROTATED_DISPLAY",
    "PENV_5_ROTATED_DISPLAY",
    "PENV_6_ROTATED_DISPLAY",
    "PENV_7_ROTATED_DISPLAY",
    "PENV_8_ROTATED_DISPLAY",
    "PENV_9_ROTATED_DISPLAY",
    "PENV_10_ROTATED_DISPLAY",
};

PSTR gpstrStdPSDisplayName[DMPAPER_COUNT] = {
    "Letter",
    "Letter Small",
    "Tabloid",
    "Ledger",
    "Legal",
    "Statement",
    "Executive",
    "A3",
    "A4",
    "A4 Small",
    "A5",
    "B4 (JIS)",
    "B5 (JIS)",
    "Folio",
    "Quarto",
    "10x14",
    "11x17",
    "Note",
    "Envelope #9",
    "Envelope #10",
    "Envelope #11",
    "Envelope #12",
    "Envelope #14",
    "C size sheet",
    "D size sheet",
    "E size sheet",
    "Envelope DL",
    "Envelope C5",
    "Envelope C3",
    "Envelope C4",
    "Envelope C6",
    "Envelope C65",
    "Envelope B4",
    "Envelope B5",
    "Envelope B6",
    "Envelope",
    "Envelope Monarch",
    "6 3/4 Envelope",
    "US Std Fanfold",
    "German Std Fanfold",
    "German Legal Fanfold",
    "B4 (ISO)",
    "Japanese Postcard",
    "9x11",
    "10x11",
    "15x11",
    "Envelope Invite",
    "",
    "",
    "Letter Extra",
    "Legal Extra",
    "Tabloid Extra",
    "A4 Extra",
    "Letter Transverse",
    "A4 Transverse",
    "Letter Extra Transverse",
    "Super A",
    "Super B",
    "Letter Plus",
    "A4 Plus",
    "A5 Transverse",
    "B5 (JIS) Transverse",
    "A3 Extra",
    "A5 Extra",
    "B5 (ISO) Extra",
    "A2",
    "A3 Transverse",
    "A3 Extra Transverse",
    "Japanese Double Postcard",
    "A6",
    "Japanese Envelope Kaku #2",
    "Japanese Envelope Kaku #3",
    "Japanese Envelope Chou #3",
    "Japanese Envelope Chou #4",
    "Letter Rotated",
    "A3 Rotated",
    "A4 Rotated",
    "A5 Rotated",
    "B4 (JIS) Rotated",
    "B5 (JIS) Rotated",
    "Japanese Postcard Rotated",
    "Double Japanese Postcard Rotated",
    "A6 Rotated",
    "Japanese Envelope Kaku #2 Rotated",
    "Japanese Envelope Kaku #3 Rotated",
    "Japanese Envelope Chou #3 Rotated",
    "Japanese Envelope Chou #4 Rotated",
    "B6 (JIS)",
    "B6 (JIS) Rotated",
    "12x11",
    "Japanese Envelope You #4",
    "Japanese Envelope You #4 Rotated",
    "PRC 16K",
    "PRC 32K",
    "PRC 32K(Big)",
    "PRC Envelope #1",
    "PRC Envelope #2",
    "PRC Envelope #3",
    "PRC Envelope #4",
    "PRC Envelope #5",
    "PRC Envelope #6",
    "PRC Envelope #7",
    "PRC Envelope #8",
    "PRC Envelope #9",
    "PRC Envelope #10",
    "PRC 16K Rotated",
    "PRC 32K Rotated",
    "PRC 32K(Big) Rotated",
    "PRC Envelope #1 Rotated",
    "PRC Envelope #2 Rotated",
    "PRC Envelope #3 Rotated",
    "PRC Envelope #4 Rotated",
    "PRC Envelope #5 Rotated",
    "PRC Envelope #6 Rotated",
    "PRC Envelope #7 Rotated",
    "PRC Envelope #8 Rotated",
    "PRC Envelope #9 Rotated",
    "PRC Envelope #10 Rotated"
};


PSTR gpstrStdIBName[DMBIN_LAST] = {
    "UPPER",
    "LOWER",
    "MIDDLE",
    "MANUAL",
    "ENVFEED",
    "ENVMANUAL",
    "AUTO",
    "TRACTOR",
    "SMALLFMT",
    "LARGEFMT",
    "LARGECAPACITY",
    "",     // non-contiguous id's
    "",
    "CASSETTE",
    ""
};

PSTR gpstrStdIBDisplayNameMacro[DMBIN_LAST] = {
    "UPPER_TRAY_DISPLAY",
    "LOWER_TRAY_DISPLAY",
    "MIDDLE_TRAY_DISPLAY",
    "MANUAL_FEED_DISPLAY",
    "ENV_FEED_DISPLAY",
    "ENV_MANUAL_DISPLAY",
    "AUTO_DISPLAY",
    "TRACTOR_DISPLAY",
    "SMALL_FORMAT_DISPLAY",
    "LARGE_FORMAT_DISPLAY",
    "LARGE_CAP_DISPLAY",
    "",            // non-contiguous id's
    "",
    "CASSETTE_DISPLAY",
    ""
};

PSTR gpstrStdIBDisplayName[DMBIN_LAST] = {
    "Upper Paper tray",      // DMBIN_FIRST
    "Lower Paper tray",      // DMBIN_UPPER
    "Middle Paper tray",     // DMBIN_LOWER
    "Manual Paper feed",     // DMBIN_MANUAL
    "Envelope Feeder",       // DMBIN_ENVELOPE
    "Envelope, Manual Feed", // DMBIN_ENVMANUAL
    "Auto",                  // DMBIN_AUTO
    "Tractor feed",          // DMBIN_TRACTOR
    "Small Format",          // DMBIN_SMALLFMT
    "Large Format",          // DMBIN_LARGEFMT
    "Large Capacity"         // DMBIN_LARGECAPACITY(11)
    "",
    "",
    "Cassette",              // DMBIN_CASETTE(14)
    "Automatically Select"   // DMBIN_FORMSOURCE(15)
};


PSTR gpstrStdMTName[DMMEDIA_LAST] = {
    "STANDARD",
    "TRANSPARENCY",
    "GLOSSY"
};

PSTR gpstrStdMTDisplayNameMacro[DMMEDIA_LAST] = {
    "PLAIN_PAPER_DISPLAY",
    "TRANSPARENCY_DISPLAY",
    "GLOSSY_PAPER_DISPLAY"
};

PSTR gpstrStdMTDisplayName[DMMEDIA_LAST] = {
    "Plain Paper",
    "Transparency",
    "Glossy Paper"
};


PSTR gpstrStdTQName[DMTEXT_LAST] = {
    "LETTER_QUALITY",
    "NEAR_LETTER_QUALITY",
    "MEMO_QUALITY",
    "DRAFT_QUALITY",
    "TEXT_QUALITY"
};

PSTR gpstrStdTQDisplayNameMacro[DMTEXT_LAST] = {
    "LETTER_QUALITY_DISPLAY",
    "NEAR_LETTER_QUALITY_DISPLAY",
    "MEMO_QUALITY_DISPLAY",
    "DRAFT_QUALITY_DISPLAY",
    "TEXT_QUALITY_DISPLAY"
};

PSTR gpstrStdTQDisplayName[DMTEXT_LAST] = {
    "Letter Quality",
    "Near Letter Quality",
    "Memo Quality",
    "Draft",
    "Text Quality"
};


PSTR gpstrPositionName[BAPOS_MAX] = {
    "NONE",
    "CENTER",
    "LEFT",
    "RIGHT"
};

PSTR gpstrFaceDirName[FD_MAX] = {
    "FACEUP",
    "FACEDOWN"
};

PSTR gpstrColorName[8] = {
    "NONE",
    "RED",
    "GREEN",
    "BLUE",
    "CYAN",
    "MAGENTA",
    "YELLOW",
    "BLACK"
};

WORD gwColorPlaneCmdID[4] = {
    CMD_DC_GC_PLANE1,
    CMD_DC_GC_PLANE2,
    CMD_DC_GC_PLANE3,
    CMD_DC_GC_PLANE4
};

PSTR gpstrColorPlaneCmdName[8] = {
    "NONE",
    "CmdSendRedData",
    "CmdSendGreenData",
    "CmdSendBlueData",
    "CmdSendCyanData",
    "CmdSendMagentaData",
    "CmdSendYellowData",
    "CmdSendBlackData"
};

PSTR gpstrSectionName[7] = {
    "",             // SS_UNINITIALIZED
    "JOB_SETUP",    // SS_JOBSETUP
    "DOC_SETUP",    // SS_DOCSETUP
    "PAGE_SETUP",   // SS_PAGESETUP
    "PAGE_FINISH",  // SS_PAGEFINISH
    "DOC_FINISH",   // SS_DOCFINISH
    "JOB_FINISH"    // SS_JOBFINISH
};


void *
GetTableInfo(
    IN PDH pdh,                 /* Base address of GPC data */
    IN int iResType,            /* Resource type - HE_... values */
    IN int iIndex)              /* Desired index for this entry */
{
    int   iLimit;

    //
    // Returns NULL if the requested data is out of range.
    //
    if (iResType >= pdh->sMaxHE)
        return NULL;
    iLimit = pdh->rghe[iResType].sCount;

    if (iLimit <= 0 || iIndex < 0 || iIndex >= iLimit )
        return  NULL;

    return  (PBYTE)pdh + pdh->rghe[iResType].sOffset +
                         pdh->rghe[iResType].sLength * iIndex;
}

#if !defined(DEVSTUDIO) //  MDS has its own version of this
void _cdecl
VOut(
    PCONVINFO pci,
    PSTR pstrFormat,
    ...)
/*++
Routine Description:
    This function formats a sequence of bytes and writes to the GPD file.

Arguments:
    pci - conversionr related info
    pstrFormat - the formatting string
    ... - optional arguments needed by formatting

Return Value:
    None
--*/
{
    va_list ap;
    DWORD dwNumBytesWritten;
    BYTE aubBuf[MAX_GPD_ENTRY_BUFFER_SIZE];
    int iSize;

    va_start(ap, pstrFormat);
    iSize = vsprintf((PSTR)aubBuf, pstrFormat, ap);
    va_end(ap);
    if (pci->dwMode & FM_VOUT_LIST)
    {
        //
        // check for the extra comma before the closing bracket
        //
        if (aubBuf[iSize-4] == ',' && aubBuf[iSize-3] == ')')
        {
            aubBuf[iSize-4] = aubBuf[iSize-3];  // ')'
            aubBuf[iSize-3] = aubBuf[iSize-2];  // '\r'
            aubBuf[iSize-2] = aubBuf[iSize-1];  // '\n'
            iSize--;
        }
    }
    if (!WriteFile(pci->hGPDFile, aubBuf, iSize, &dwNumBytesWritten, NULL) ||
        dwNumBytesWritten != (DWORD)iSize)
        pci->dwErrorCode |= ERR_WRITE_FILE;
    // continue even if an error has occurred.
}

#endif  //  defined(DEVSTUDIO)

void
EnterStringMode(
    OUT    PBYTE    pBuf,
    IN OUT PINT     pIndex,
    IN OUT PWORD    pwCMode)
/*++
Routine Description:
    This function enters the STRING mode and emits necessary characters to
    the output buffer.

Arguments:
    pBuf: the output buffer
    pIndex: pBuf[*pIndex] is where the next character should be written.
            The index should be updated if any character is emitted.
    pwCMode: pointer to the current mode value. It's updated per request.

Return Value:
    None

--*/
{
    if (!(*pwCMode & MODE_STRING))
    {
        pBuf[(*pIndex)++] = '"';
        *pwCMode |= MODE_STRING;
    }
    //
    // if we are also in HEX mode, exit HEX mode.
    //
    else if (*pwCMode & MODE_HEX)
    {
        pBuf[(*pIndex)++] = '>';
        *pwCMode &= ~MODE_HEX;
    }
}

void
ExitStringMode(
    OUT    PBYTE    pBuf,
    IN OUT PINT     pIndex,
    IN OUT PWORD    pwCMode)
/*++
Routine Description:
    This function exits the STRING mode and emits necessary characters to
    the output buffer. Check to see if we need to exit HEX mode first.

Arguments:
    pBuf: the output buffer
    pIndex: pBuf[*pIndex] is where the next character should be written.
            The index should be updated if any character is emitted.
    pwCMode: pointer to the current mode value. It's updated per request.

Return Value:
    None

--*/
{
    if (*pwCMode & MODE_HEX)
    {
        pBuf[(*pIndex)++] = '>';
        *pwCMode &= ~MODE_HEX;
    }
    if (*pwCMode & MODE_STRING)
    {
        pBuf[(*pIndex)++] = '"';
        *pwCMode &= ~MODE_STRING;
    }

}

void
EnterHexMode(
    OUT    PBYTE    pBuf,
    IN OUT PINT     pIndex,
    IN OUT PWORD    pwCMode)
/*++
Routine Description:
    This function enters the HEX mode and emits necessary characters to
    the output buffer.

Arguments:
    pBuf: the output buffer
    pIndex: pBuf[*pIndex] is where the next character should be written.
            The index should be updated if any character is emitted.
    pwCMode: pointer to the current mode value. It's updated per request.

Return Value:
    None

--*/
{
    //
    // if we are not in STRING mode, enter STRING mode first.
    //
    if (!(*pwCMode & MODE_STRING))
    {
        pBuf[(*pIndex)++] = '"';
        *pwCMode |= MODE_STRING;
    }
    if (!(*pwCMode & MODE_HEX))
    {
        pBuf[(*pIndex)++] = '<';
        *pwCMode |= MODE_HEX;
    }
}

BOOL
BBuildCmdStr(
    IN OUT PCONVINFO pci,
    IN  WORD    wCmdID,
    IN  WORD    ocd)
/*++
Routine Description:
    This function builds the null-terminated GPD command string, including
    double quotes, stadard variable references, parameter format, newlines
    (except the ending newline), and continuation character "+" if
    applicable. If the GPC command contains a callback id, fill the id in
    pci->wCmdCallbackID. Otherwise, fill it with 0 and fill pci->wCmdLen with
    the command length. If there is no command (NOOCD), fill both with 0.

    This function handles the special case where CM_YM_RES_DEPENDENT bit
    is set. In that case, the parameter expression needs to add
    (ValueIn / ptTextScale.y) as the first thing before considering other
    fields in EXTCD structure. All values passed in by Unidrv5 are in the
    master units, no exception. For this case, pci->pcm is set to the model's
    CURSORMOVE structure, and pci->pres is set to the current resolution
    being considered.

    This function handles the special case where RES_DM_GDI is not set (i.e.
    V_BYTE style output) and wCmdID is CMD_RES_SENDBLOCK. In that case, we need
    to add artifical divider equal to (pci->pres->sPinsPerPass / 8).
    This is to match the hard-coded conversion from NumOfDataBytes to the number
    of columns (in both Win95 Unidrv and NT4 RASDD).

    This function handles the special case for compression commands --- it would
    generate the "" command string (length == 2) even if it's NOOCD because the
    driver relies on its existence to enable compression code.

Arguments:
    pci: the conversion related info
    wCmdID: GPC command id. It's unique for each command in GPC.
    ocd: offset to the GPC CD structure on the GPC heap. The offset is
         relative to the beginning of the heap (instead of beginning of
         GPC data).

Return Value:
    TRUE if there is a real command. Otherwise, return FALSE (i.e. NOOCD).

--*/
{
    PCD     pcd;        // pointer to GPC's CD structure
    PBYTE   pBuf;   // buffer to hold the composed GPD cmd
    INT     i = 0;  // the next byte to write in the buffer
    INT     iPrevLines = 0; // the total # of bytes written for previous lines

    pci->wCmdCallbackID = 0;
    pBuf = pci->aubCmdBuf;

    if (ocd != (WORD)NOOCD)
    {
        pcd = (PCD)((PBYTE)(pci->pdh) + (pci->pdh)->loHeap + ocd);
        if (pcd->bCmdCbId > 0)
        {
            //
            // Command callback case. For simplicity, we do not write out
            // any parameters since each command takes different parameters.
            // Instead, we give a warning and ask the minidriver developer
            // to fill in *Param entry. After all, he may need different
            // parameters than what GPC dictates.
            //
            pci->wCmdCallbackID = (WORD)pcd->bCmdCbId;
            pci->dwErrorCode |= ERR_NO_CMD_CALLBACK_PARAMS;
        }
        else
        {
            WORD   wCMode = 0;  // bit flags indicating the conversion mode
            WORD   wFmtLen;     // size of command string remaining
            PSTR   pFmt;        // pointer into command string
            PEXTCD pextcd;      // points at next parameter's EXTCD
            WORD   wCount;      // number of parameters
            WORD   wNextParam=0;   // index of the next actual param
            PDWORD pdwSVList;

            pFmt = (PSTR)(pcd + 1);
            wFmtLen = pcd->wLength;
            pextcd = GETEXTCD(pci->pdh, pcd);
            wCount = pcd->wCount;
            pdwSVList = &(gdwSVLists[gawCmdtoSVOffset[wCmdID]]);


            while (wFmtLen > 0)
            {
                if (*pFmt != CMD_MARKER)
                {
                    if (IS_CHAR_READABLE(*pFmt))
                    {
                        EnterStringMode(pBuf, &i, &wCMode);
                        //
                        // check if it's the special character: ", <.
                        // If so, add the escape letter '%'
                        //
                        if (*pFmt == '"' || *pFmt == '<' )
                            pBuf[i++] = '%';
                        pBuf[i++] = *(pFmt++);
                    }
                    else    // non-readable ASCII: write out hex strings.
                    {
                        EnterHexMode(pBuf, &i, &wCMode);
                        pBuf[i++] = gbHexChar[(*pFmt & 0xF0) >> 4];
                        pBuf[i++] = gbHexChar[*pFmt & 0x0F];
                        *(pFmt++);
                    }
                    wFmtLen --;
                }
                else if (wFmtLen > 1 && *(++pFmt) == CMD_MARKER)
                {
                    //
                    // We have 2 '%' character to write out.
                    //
                    EnterStringMode(pBuf, &i, &wCMode);
                    pBuf[i++] = *pFmt;
                    pBuf[i++] = *(pFmt++);
                    wFmtLen -= 2;
                }
                else if (wFmtLen > 1) // we have a parameter format string
                {
                    INT iParam;     // index of the actual param used
                    DWORD   dwSV;   // GPD standard variable id


                    wFmtLen--;  // to account for already eaten '%'
                    ExitStringMode(pBuf, &i, &wCMode);
                    //
                    // insert a white space before the param segment
                    //
                    pBuf[i++] = ' ';
                    pBuf[i++] = '%';
                    //
                    // first, the format string
                    //
                    while (wFmtLen > 0 && *pFmt >= '0' && *pFmt <= '9')
                    {
                        pBuf[i++] = *(pFmt++);
                        wFmtLen--;
                    }
                                        if (wFmtLen > 0)
                                        {
                                                pBuf[i++] = *(pFmt++);    // copy the format letter d,D,...
                                                wFmtLen--;
                                        }
                                        else
                                        {
                                                pci->dwErrorCode |= ERR_BAD_GPC_CMD_STRING;
                                                pBuf[i++] = '!';
                                                pBuf[i++] = 'E';
                                                pBuf[i++] = 'R';
                                                pBuf[i++] = 'R';
                                                pBuf[i++] = '!';
                                                break;  // exit the while (wFmtLen > 0) loop
                                        }
                    //
                    // second, the limits if applicable.
                    //
                    // 12/19/97 zhanw
                    // Note: Win95 Unidrv uses !XCD_GEN_NO_MAX and
                    // pextcd->sMax if it's greater than 0 (for the cases of
                    // CMD_XM_LINESPACING and CMD_GEN_MAY_REPEAT), and it
                    // does NOT use pextcd->sMin at all. NT4 RASDD uses
                    // !XCD_GEN_NO_MIN and pextcd->sMin (any value, no
                    // particular purpose), and it uses pextcd->sMax without
                    // checking !XCD_GEN_NO_MAX (hacky way to handle
                    // max-repeat for CMD_RES_SENDBLOCK). Also, Unitool
                    // defaults pextcd->sMin to 0.
                    // Given that NT4 and Win95 share the same GPC source,
                    // the following code should suit both drivers' behavior.
                    //
                    //
                    if (pcd->wCount > 0)
                    {
                        //
                        // in this case, a valid EXTCD may specify limits
                        //
                        if (!(pextcd->fGeneral & XCD_GEN_NO_MAX) &&
                            pextcd->sMax > 0)
                            i += sprintf((PSTR)&(pBuf[i]), "[%d,%d]",
                                         (pextcd->fGeneral & XCD_GEN_NO_MIN) ?
                                          0 : (WORD)pextcd->sMin,
                                          (WORD)pextcd->sMax);        
                    }
        	    // PatRyan - add limits for CmdCopies
		    if (wCmdID == CMD_PC_MULT_COPIES)
                      i += sprintf((PSTR)&(pBuf[i]), "[1,%d]", pci->ppc->sMaxCopyCount);
                    //
                    // third, the value.
                    //
                    if (pcd->wCount == 0)
                    {
                        //
                        // For this case, each format string wants
                        // the next parameter without modification
                        //
                        dwSV = pdwSVList[wNextParam++];
                        if (wCmdID == CMD_RES_SENDBLOCK &&
                            !(pci->pres->fDump & RES_DM_GDI) &&
                            dwSV == SV_NUMDATABYTES &&
                            pci->pres->sPinsPerPass != 8)

                        {
                            i += sprintf((PSTR)&(pBuf[i]), "{%s / %d}",
                                          gpstrSVNames[dwSV],
                                          pci->pres->sPinsPerPass / 8);
                        }
                        else
                            i += sprintf((PSTR)&(pBuf[i]), "{%s}",
                                          gpstrSVNames[dwSV]);
                    }
                    else
                    {
                        short sSBDDiv = 1; // special case for CmdSendBlockData

                        if (pci->pdh->wVersion < GPC_VERSION3)
                            // For this case, each EXTCD wants the next parameter
                            iParam = wNextParam++;
                        else
                            // For this case, each EXTCD specifies the parameter
                            iParam = pextcd->wParam;

                        dwSV = pdwSVList[iParam];

                        if (wCmdID == CMD_RES_SENDBLOCK &&
                            !(pci->pres->fDump & RES_DM_GDI) &&
                            dwSV == SV_NUMDATABYTES)
                        {
                            //
                            // sPinsPerPass is always a multiplier of 8.
                            //
                            sSBDDiv = pci->pres->sPinsPerPass / 8;
                        }

                        pBuf[i++] = '{';
                        //
                        // check if max_repeat is needed.
                        // Special case for CMD_CM_YM_LINESPACING: never use
                        // "max_repeat" by definition.
                        //
                        if (!(pextcd->fGeneral & XCD_GEN_NO_MAX) &&
                            pextcd->sMax > 0 &&
                            (pcd->fGeneral & CMD_GEN_MAY_REPEAT) &&
                            wCmdID != CMD_CM_YM_LINESPACING)
                            i += sprintf((PSTR)&(pBuf[i]), "max_repeat(");
                        //
                        // compose the expression.
                        // Optimize for special cases.
                        //
                        if (pextcd->sPreAdd != 0)
                            pBuf[i++] = '(';
                        if (pextcd->sUnitMult > 1)
                            pBuf[i++] = '(';
                        if (pextcd->sUnitDiv > 1 || sSBDDiv > 1)
                            pBuf[i++] = '(';
                        i += sprintf((PSTR)&(pBuf[i]), "%s ", gpstrSVNames[dwSV]);
                        //
                        // special check for CM_YM_RES_DEPENDENT flag
                        //
                        if ((wCmdID == CMD_CM_YM_ABS ||
                             wCmdID == CMD_CM_YM_REL ||
                             wCmdID == CMD_CM_YM_RELUP ||
                             wCmdID == CMD_CM_YM_LINESPACING) &&
                            (pci->pcm->fYMove & CM_YM_RES_DEPENDENT) &&
                            pci->pres->ptTextScale.y != 1)
                            i += sprintf((PSTR)&(pBuf[i]), "/ %d ",
                                          pci->pres->ptTextScale.y);
                        //
                        // continue with normal processing
                        //
                        if (pextcd->sPreAdd > 0)
                            i += sprintf((PSTR)&(pBuf[i]), "+ %d) ",
                                         pextcd->sPreAdd);
                        else if (pextcd->sPreAdd < 0)
                            i += sprintf((PSTR)&(pBuf[i]), "- %d) ",
                                         -pextcd->sPreAdd);

                        if (pextcd->sUnitMult > 1)
                            i += sprintf((PSTR)&(pBuf[i]), "* %d) ",
                                          pextcd->sUnitMult);
                        if (pextcd->sUnitDiv > 1 || sSBDDiv > 1)
                            i += sprintf((PSTR)&(pBuf[i]),
                                        ((pextcd->fGeneral & XCD_GEN_MODULO) ?
                                        "MOD %d) " : "/ %d) "),
                                        ((pextcd->sUnitDiv) ? pextcd->sUnitDiv : 1) * sSBDDiv);
                        if (pextcd->sUnitAdd > 0)
                            i += sprintf((PSTR)&(pBuf[i]), "+ %d",
                                          pextcd->sUnitAdd);
                        else if (pextcd->sUnitAdd < 0)
                            i += sprintf((PSTR)&(pBuf[i]), "- %d",
                                          -pextcd->sUnitAdd);
                        //
                        // check if need to close max_repeat
                        //
                        if (!(pextcd->fGeneral & XCD_GEN_NO_MAX) &&
                            pextcd->sMax > 0 &&
                            (pcd->fGeneral & CMD_GEN_MAY_REPEAT) &&
                            wCmdID != CMD_CM_YM_LINESPACING)
                            pBuf[i++] = ')';

                        pBuf[i++] = '}';    // close the value portion
                    }
                    pextcd++;   // advance to next EXTCD
                }  // end param case
                                else
                                {
                                        pci->dwErrorCode |= ERR_BAD_GPC_CMD_STRING;
                                        pBuf[i++] = '!';
                                        pBuf[i++] = 'E';
                                        pBuf[i++] = 'R';
                                        pBuf[i++] = 'R';
                                        pBuf[i++] = '!';

                                        break;  // exit the while (wFmtLen > 0) loop
                                }
                //
                // check if the string is already quite long. If so,
                // start a new line.
                //
                if ((i - iPrevLines) >= MAX_GPD_CMD_LINE_LENGTH)
                {
                    ExitStringMode(pBuf, &i, &wCMode);
                    pBuf[i++] = '\r';
                                        pBuf[i++] = '\n';
                    iPrevLines = i;
                    pBuf[i++] = '+';
                    pBuf[i++] = ' ';
                }
            } // while (wFmtLen > 0)
            //
            // finished processing the format string. Exit properly
            //
            ExitStringMode(pBuf, &i, &wCMode);
        }
    }    // !NOOCD case
    else if (wCmdID == CMD_CMP_TIFF || wCmdID == CMD_CMP_DELTAROW ||
             wCmdID == CMD_CMP_FE_RLE)
    {
        pBuf[i++] = '"';    // generate "" command string
        pBuf[i++] = '"';
    }
    pBuf[i] = 0;
    pci->wCmdLen = (WORD)i;
    return (i != 0 || pci->wCmdCallbackID != 0);
}

void
VOutputOrderedCmd(
    IN OUT PCONVINFO pci,// contain info about the cmd to output
    PSTR    pstrCmdName, // cmd name such as "CmdSelect"
    SEQSECTION  ss,     // sequence section id (ENUM type defined in GPD.H)
    WORD    wOrder,     // order number within the section
    BOOL    bIndent)    // whether to use 2-level indentation or not
{
    //
    // check for no-cmd case
    //
    if (wOrder > 0 && (pci->wCmdLen > 0 || pci->wCmdCallbackID > 0))
    {
        VOut(pci, "%s*Command: %s\r\n%s{\r\n",
                  bIndent? "        " : "",
                  pstrCmdName,
                  bIndent? "        " : "");
        VOut(pci, "%s*Order: %s.%d\r\n",
                  bIndent? "            " : "    ",
                  gpstrSectionName[ss],
                  wOrder);
        if (pci->wCmdCallbackID > 0)
        {
            VOut(pci, "%s*CallbackID: %d\r\n",
                      bIndent? "            " : "    ",
                      pci->wCmdCallbackID);
            VOut(pci, "*%% Error: you must check if this command callback requires any parameters!\r\n");
        }
        else
            VOut(pci, "%s*Cmd: %s\r\n",
                      bIndent? "            " : "    ",
                      pci->aubCmdBuf);
        VOut(pci, "%s}\r\n", bIndent? "        " : "");
    }
}

void
VOutputSelectionCmd(
    IN OUT PCONVINFO pci,// contain info about the cmd to output
    IN BOOL    bDocSetup,  // whether in DOC_SETUP or PAGE_SETUP section
    IN WORD    wOrder)     // order number within the section
//
// This function outputs an option selection command which uses level 2
// indentation.
//
{
    VOutputOrderedCmd(pci, "CmdSelect",
                      bDocSetup? SS_DOCSETUP : SS_PAGESETUP,
                      wOrder, TRUE);
}

void
VOutputConfigCmd(
    IN OUT PCONVINFO pci,// contain info about the cmd to output
    IN PSTR pstrCmdName, // command name
    IN SEQSECTION  ss,      // sequence section id
    IN WORD    wOrder)      // order number within the section
//
// This function outputs a printer configuration command at the root level.
//
{
    VOutputOrderedCmd(pci, pstrCmdName, ss, wOrder, FALSE);
}


void
VOutputCmdBase(
    IN OUT PCONVINFO pci,   // contain info about the cmd to output
    PSTR    pstrCmdName,    // cmd name such as "CmdXMoveAbsolute"
    BOOL    bExtern,        // whether to add EXTERN_GLOBAL prefix
    BOOL    bIndent)        // whter to use level 2 indentation
{
    if (pci->wCmdLen > 0)
        VOut(pci, "%s%s*Command: %s { *Cmd : %s }\r\n",
                  bIndent? "        " : "",
                  bExtern ? "EXTERN_GLOBAL: " : "",
                  pstrCmdName, pci->aubCmdBuf);
    else if (pci->wCmdCallbackID > 0)
        VOut(pci, "%s%s*Command: %s { *CallbackID: %d }\r\n",
                  bIndent? "        " : "",
                  bExtern ? "EXTERN_GLOBAL: " : "",
                  pstrCmdName,
                  pci->wCmdCallbackID);
}

void
VOutputCmd(
    IN OUT PCONVINFO pci,   // contain info about the cmd to output
    IN PSTR    pstrCmdName)
//
// This function outputs printing commands at the root level (i.e. no
// indentation). It uses the shortcut format: *Command: <name> : <cmd>
// unless the callback is used.
//
{
    VOutputCmdBase(pci, pstrCmdName, FALSE, FALSE);
}

void
VOutputExternCmd(
    IN OUT PCONVINFO pci,
    IN PSTR pstrCmdName)
//
// This function outputs the printing commands inside feature option
// construct, i.e. they should be prefixed with "EXTERN_GLOBAL" and use
// level 2 indentation.
//
{
    //
    // 1/7/97 ZhanW
    // According to PeterWo, constructs don't need EXTERN_GLOBAL prefix
    //
    VOutputCmdBase(pci, pstrCmdName, FALSE, TRUE);
}

void
VOutputCmd2(
    IN OUT PCONVINFO pci,
    IN PSTR pstrCmdName)
//
// This function outputs printing commands with one level dependency,
// i.e. they should use level 2 indentation.
//
{
    VOutputCmdBase(pci, pstrCmdName, FALSE, TRUE);
}

WORD gwDefaultCmdOrder[] = {
    PC_ORD_PAPER_SOURCE,
    PC_ORD_PAPER_DEST,
    PC_ORD_PAPER_SIZE,
    PC_ORD_RESOLUTION,
    PC_ORD_TEXTQUALITY,
    0,
};

BOOL
BInDocSetup(
    IN PCONVINFO pci,
    IN WORD ord,
    OUT PWORD pwOrder)
/*++
Routine Description:
    This function determines the section and the order number of the given
    command.

Arguments:
    pci: pointer to CONVINFO
    ord: PC_ORD_xxx id identifying the command.
    pwOrder: to store the order number as in GPC

Return:
    TRUE if the command should be in DOC_SETUP section.
    Note that for both NT RASDD and Win95 Unidrv:
    1. All commands before PC_ORD_BEGINPAGE (exclusive) are sent per
       job and per ResetDC. So they should be in DOC_SETUP section.
    2. All commands after PC_ORD_BEGINPAGE (inclusive) is sent at the
       beginning of each page. So they should be in PAGE_SETUP section.

--*/
{
    PWORD pOrds;
    BOOL bDocSetup = TRUE;
    WORD count;

    if (pci->ppc->orgwOrder == (WORD)NOT_USED)
        pOrds = gwDefaultCmdOrder;
    else
        pOrds = (PWORD)((PBYTE)pci->pdh + pci->pdh->loHeap +
                                                pci->ppc->orgwOrder);

    for (count = 1; *pOrds != 0 && *pOrds != ord; count++, pOrds++)
    {
        if (bDocSetup && *pOrds == PC_ORD_BEGINPAGE)
            bDocSetup = FALSE;
    }
    if (*pOrds == 0)
        *pwOrder = 0;   // didn't find the cmd in the sequence
    else // *pOrds == ord
    {
        *pwOrder = count;
        if (ord == PC_ORD_BEGINPAGE)
            bDocSetup = FALSE;
    }
    return bDocSetup;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\tools\uni\gpdchkr\gpdcheck.c ===
/*++

Copyright (c) 1996-1999  Microsoft Corporation

Module Name:

    gpdcheck.c

Abstract:

    gpd parser test program

Environment:

    uni driver, gpd parser, Check build only

Revision History:


    03/27/97 -peterwo-
        Created it.

--*/

#include "lib.h"


PTSTR  pwstrGenerateGPDfilename(
    PTSTR   ptstrSrcFilename
    ) ;

BOOL   BcreateGPDbinary(
    PWSTR   pwstrFileName,  // root GPD file
    DWORD   dwVerbosity );


// ----  functions defined in treewalk.c ---- //
BOOL    GetGPDResourceIDs(
PDWORD pdwResArray,
DWORD   dwArraySize,    //  number of elements in array.
PDWORD   pdwNeeded,
BOOL bFontIDs,
PRAWBINARYDATA prbd) ;



#ifndef DBG

//
// Variable to control the amount of debug messages generated
//

INT giDebugLevel = DBG_WARNING;

PCSTR
StripDirPrefixA(
    IN PCSTR    pstrFilename
    )

/*++

Routine Description:

    Strip the directory prefix off a filename (ANSI version)

Arguments:

    pstrFilename - Pointer to filename string

Return Value:

    Pointer to the last component of a filename (without directory prefix)

--*/

{
    PCSTR   pstr;

    if (pstr = strrchr(pstrFilename, PATH_SEPARATOR))
        return pstr + 1;

    return pstrFilename;
}



#endif


HINSTANCE       ghInstance;
PSTR            gstrProgName;
PINFOHEADER     gpInfoHdr;
PUIINFO         gpUIInfo;
DWORD           gdwTotalSize, gdwNumFiles, gdwMaxFileSize;
FILE            *stream ;


#define DumpInt(label, n)       DbgPrint("%s: %d\n", label, n)
#define DumpHex(label, n)       DbgPrint("%s: 0x%x\n", label, n)
#define DumpStrW(label, offset) DbgPrint("%s: %ws\n", label, OFFSET_TO_POINTER(gpRawData, offset))
#define DumpStrA(label, offset) DbgPrint("%s: %s\n", label, OFFSET_TO_POINTER(gpRawData, offset))
#define DumpFix(label, n)       DbgPrint("%s: %f\n", label, (FLOAT) (n) / FIX_24_8_SCALE)
#define DumpInvo(label, p)      DbgPrint("%s: %d bytes\n", label, (p)->dwCount)
#define DumpSize(label, p)      DbgPrint("%s: %d x %d\n", label, (p)->cx, (p)->cy)
#define DumpRect(label, p)      DbgPrint("%s: (%d, %d) - (%d, %d)\n", label, \
                                         (p)->left, (p)->top, (p)->right, (p)->bottom)





ULONG _cdecl
DbgPrint(
    PCSTR    pstrFormat,
    ...
    )

{
    va_list ap;

    va_start(ap, pstrFormat);
    vfprintf(stream, pstrFormat, ap);
    va_end(ap);

    return 0;
}



VOID
usage(
    VOID
    )

{
    printf("usage: %s [-options] filenames ...\n", gstrProgName);
    printf("where options are:\n");
    printf("  -n  delete existing log file, instead of appending to it\n");
    printf("  -k  keep the binary GPD data\n");
    printf("  -x  perform additional semantics check\n") ;
    printf("  -s  suppress all console output\n") ;
    printf("  -v(0-4)  set verbosity level -v0 lowest, -v4 highest\n") ;
    printf("  -h  display help information\n");
    exit(-1);
}


INT _cdecl
main(
    INT     argc,
    CHAR    **argv
    )

{
    BOOL    bDeleteLog, bKeepBUD, bFirstFile, bSuppress, bSemantics;
    DWORD   dwTime;
    DWORD   dwVerbosity = 0;

    //
    // Go through the command line arguments
    //

    ghInstance = GetModuleHandle(NULL);
    bSuppress = bDeleteLog = bKeepBUD = bSemantics = FALSE;
    bFirstFile = TRUE ;
    giDebugLevel = DBG_TERSE;
    gdwTotalSize = gdwNumFiles = gdwMaxFileSize = 0 ;

    gstrProgName = *argv++;
    argc--;

    if (argc == 0)
        usage();

    dwTime = GetTickCount();

    for ( ; argc--; argv++)
    {
        PSTR    pArg = *argv;

        if (*pArg == '-' || *pArg == '/')
        {
            //
            // The argument is an option flag
            //

            switch (*++pArg) {

            case 'n':
            case 'N':

                bDeleteLog  = TRUE;
                break;

            case 'k':
            case 'K':

                bKeepBUD = TRUE;
                break;

            case 's':
            case 'S':

                bSuppress = TRUE;
                break;


            case 'x':
            case 'X':

                bSemantics = TRUE;
                break;


            case 'v':
            case 'V':

                if (*++pArg >= '0' && *pArg <= '4')
                {
                    dwVerbosity = *pArg - '0';
                }
                break;
            default:

                if(!bSuppress)
                    usage();
                break;
            }

        }
        else
        {
            WCHAR   wstrFilename[MAX_PATH];
            PTSTR   ptstrBudFilename;


            if(bFirstFile  &&   bDeleteLog)
            {   // truncate
                stream = fopen("gpdparse.log", "w") ;
            }
            else
                stream = fopen("gpdparse.log", "a+") ;

            if(!stream)
            {
                printf("unable to open gpdparse.log for write access.\n");
                exit(-1);
            }

            bFirstFile = FALSE ;


            //
            // Convert ANSI filename to Unicode filename
            //

            MultiByteToWideChar(CP_ACP, 0, pArg, -1, wstrFilename, MAX_PATH);

            fprintf(stream, "\n*** GPD parsing errors for %ws\n", wstrFilename);


            if (BcreateGPDbinary(wstrFilename, dwVerbosity))
            {

//                gdwTotalSize += gpRawData->dwFileSize;
                gdwNumFiles++;

//                if (gpRawData->dwFileSize > gdwMaxFileSize)
//                    gdwMaxFileSize = gpRawData->dwFileSize;

//                MemFree(gpRawData);

                if(bSemantics)
                {
                    PRAWBINARYDATA  pRawData ;
                    PINFOHEADER     pInfoHdr ;

                    fprintf(stream, "\n\tsnapshot and semantics errors: \n");

                    pRawData = LoadRawBinaryData(wstrFilename) ;

#if 0
//  this part to test treewalk.c functions
{
    BOOL    bStatus  ;
    PDWORD pdwResArray = NULL;
    DWORD   dwArraySize = 0;    //  number of elements in array.
    DWORD   dwNeeded = 0;
    BOOL bFontIDs ;


    bStatus =    GetGPDResourceIDs(
                            pdwResArray,
                            dwArraySize,    //  number of elements in array.
                            &dwNeeded,
                            bFontIDs = TRUE,
                            pRawData) ;
    if(bStatus)
    {
        pdwResArray = (PDWORD) VirtualAlloc(
          NULL, // address of region to reserve or commit
          dwNeeded * sizeof(DWORD),     // size of region
          MEM_COMMIT,
                            // type of allocation
          PAGE_READWRITE   // type of access protection
        );

    }
    if(pdwResArray)
    {
        dwArraySize = dwNeeded ;
        bStatus =    GetGPDResourceIDs(
                                pdwResArray,
                                dwArraySize,    //  number of elements in array.
                                &dwNeeded,
                                bFontIDs = TRUE,
                                pRawData) ;
    }
     VirtualFree(
      pdwResArray,  // address of region of committed pages
      0,      // size of region
      MEM_RELEASE   // type of free operation
    );
     pdwResArray = NULL ;

     bStatus =    GetGPDResourceIDs(
                             pdwResArray,
                             dwArraySize,    //  number of elements in array.
                             &dwNeeded,
                             bFontIDs = FALSE,
                             pRawData) ;
     if(bStatus)
     {
         pdwResArray = (PDWORD) VirtualAlloc(
           NULL, // address of region to reserve or commit
           dwNeeded * sizeof(DWORD),     // size of region
           MEM_COMMIT,
                             // type of allocation
           PAGE_READWRITE   // type of access protection
         );

     }
     if(pdwResArray)
     {
         dwArraySize = dwNeeded ;
         bStatus =    GetGPDResourceIDs(
                                 pdwResArray,
                                 dwArraySize,    //  number of elements in array.
                                 &dwNeeded,
                                 bFontIDs = FALSE,
                                 pRawData) ;
     }
      VirtualFree(
       pdwResArray,  // address of region of committed pages
       0,      // size of region
       MEM_RELEASE   // type of free operation
     );
      pdwResArray = NULL ;

}


//  end treewalk test
#endif


                    if(pRawData)
                        pInfoHdr = InitBinaryData(pRawData, NULL, NULL ) ;
                    if(pRawData  &&  pInfoHdr)
                        FreeBinaryData(pInfoHdr) ;
                    if(pRawData)
                        UnloadRawBinaryData(pRawData) ;
                }

                //
                // If -k option is not given, get rid of the Bud file after we're done
                //

                if (! bKeepBUD && (ptstrBudFilename = pwstrGenerateGPDfilename(wstrFilename)))
                {
                    DeleteFile(ptstrBudFilename);
                    MemFree(ptstrBudFilename);
                }
            }
            fclose(stream) ;
        }
    }


    if ((gdwNumFiles > 0)  &&  !bSuppress)
    {
        dwTime = GetTickCount() - dwTime;

        printf("Number of files parsed: %d\n", gdwNumFiles);
        printf("Average parsing time per file (ms): %d\n", dwTime / gdwNumFiles);
    }

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\tools\uni\lib\precomp.h ===
/*++

Copyright (c) 1996-1997  Microsoft Corporation

Module Name:

    precomp.h

Abstract:

    Pre-compile header for Unidrv tool library

Environment:

    Windows NT printer drivers

Revision History:

    12/30/96 -eigos-
        Created it.
--*/

#ifndef _PRECOMP_H_
#define _PRECOMP_H_

#include <lib.h>
#include <unilib.h>
#include <winddi.h>
#include <win30def.h>
#include <uni16res.h>
#include <uni16gpc.h>
#include <fmoldrle.h>
#include <fmnewfm.h>
#include <fmnewgly.h>
#include <fmoldfm.h>
#include <fmlib.h>


#endif // !_PRECOMP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\tools\uni\gpc2gpd\utils.h ===
/*++

Copyright (c) 1996-1997  Microsoft Corporation

Module Name:

    utils.h

Abstract:

    header file for utility functions

Environment:

    user-mode only

Revision History:

    10/17/96 -zhanw-
        Created it.

--*/

//
// define bit flags for command conversion mode
//
#define MODE_STRING 0x0001  // within double quotes  "...". Writing out the
                            // openning double quote causes this bit be set
                            // and the closing double quote causes it be reset.
#define MODE_HEX    0x0002  // within angle brackets <...>. Writing out the
                            // left angle bracket causes this bit be set and
                            // the right angle bracket causes it be reset.
                            // To set MODE_HEX, MODE_STRING must be set first.
#define MODE_PARAM  0x0004  // within a parameter segment. It's mutual
                            // exclusive with MODE_STRING and MODE_HEX.

#define IS_CHAR_READABLE(ch) ((ch) >= 0x20 && (ch) <= 0x7E)

extern BYTE gbHexChar[16];

#define CMD_LINE_LENGTH_MAX     63
#define EOR 0xFFFFFFFF

extern PSTR gpstrSVNames[SV_MAX];
extern DWORD gdwSVLists[];
extern WORD gawCmdtoSVOffset[MAXCMD+MAXECMD];

typedef enum _FEATUREID {
    FID_PAPERDEST,
    FID_IMAGECONTROL,
    FID_PRINTDENSITY,
    FID_MAX
} FEATUREID;

extern PSTR gpstrFeatureName[FID_MAX];
extern PSTR gpstrFeatureDisplayName[FID_MAX];
extern PSTR gpstrFeatureDisplayNameMacro[FID_MAX];
extern INT  gintFeatureDisplayNameID[FID_MAX];
extern WORD gwFeatureMDOI[FID_MAX];
extern WORD gwFeatureOCDWordOffset[FID_MAX];
extern WORD gwFeatureHE[FID_MAX];
extern WORD gwFeatureORD[FID_MAX];
extern WORD gwFeatureCMD[FID_MAX];

#define STD_PS_DISPLAY_NAME_ID_BASE 10000
#define STD_IB_DISPLAY_NAME_ID_BASE 10256
#define STD_MT_DISPLAY_NAME_ID_BASE 10512
#define STD_TQ_DISPLAY_NAME_ID_BASE 10768

//
// standard paper size id's. Copied from Win95 source
//
#define DMPAPER_FIRST               DMPAPER_LETTER
#define DMPAPER_LETTER              1   /* Letter 8 1/2 x 11 in               */
#define DMPAPER_LETTERSMALL         2   /* Letter Small 8 1/2 x 11 in         */
#define DMPAPER_TABLOID             3   /* Tabloid 11 x 17 in                 */
#define DMPAPER_LEDGER              4   /* Ledger 17 x 11 in                  */
#define DMPAPER_LEGAL               5   /* Legal 8 1/2 x 14 in                */
#define DMPAPER_STATEMENT           6   /* Statement 5 1/2 x 8 1/2 in         */
#define DMPAPER_EXECUTIVE           7   /* Executive 7 1/4 x 10 1/2 in        */
#define DMPAPER_A3                  8   /* A3 297 x 420 mm                    */
#define DMPAPER_A4                  9   /* A4 210 x 297 mm                    */
#define DMPAPER_A4SMALL             10  /* A4 Small 210 x 297 mm              */
#define DMPAPER_A5                  11  /* A5 148 x 210 mm                    */
#define DMPAPER_B4                  12  /* B4 (JIS) 257 x 364 mm              */
#define DMPAPER_B5                  13  /* B5 (JIS) 182 x 257 mm              */
#define DMPAPER_FOLIO               14  /* Folio 8 1/2 x 13 in                */
#define DMPAPER_QUARTO              15  /* Quarto 215 x 275 mm                */
#define DMPAPER_10X14               16  /* 10 x 14 in                         */
#define DMPAPER_11X17               17  /* 11 x 17 in                         */
#define DMPAPER_NOTE                18  /* Note 8 1/2 x 11 in                 */
#define DMPAPER_ENV_9               19  /* Envelope #9 3 7/8 x 8 7/8 in       */
#define DMPAPER_ENV_10              20  /* Envelope #10 4 1/8 x 9 1/2 in      */
#define DMPAPER_ENV_11              21  /* Envelope #11 4 1/2 x 10 3/8 in     */
#define DMPAPER_ENV_12              22  /* Envelope #12 4 3/4 x 11 in         */
#define DMPAPER_ENV_14              23  /* Envelope #14 5 x 11 1/2 in         */
#define DMPAPER_CSHEET              24  /* C size sheet                       */
#define DMPAPER_DSHEET              25  /* D size sheet                       */
#define DMPAPER_ESHEET              26  /* E size sheet                       */
#define DMPAPER_ENV_DL              27  /* Envelope DL  110 x 220 mm          */
#define DMPAPER_ENV_C5              28  /* Envelope C5  162 x 229 mm          */
#define DMPAPER_ENV_C3              29  /* Envelope C3  324 x 458 mm          */
#define DMPAPER_ENV_C4              30  /* Envelope C4  229 x 324 mm          */
#define DMPAPER_ENV_C6              31  /* Envelope C6  114 x 162 mm          */
#define DMPAPER_ENV_C65             32  /* Envelope C65 114 x 229 mm          */
#define DMPAPER_ENV_B4              33  /* Envelope B4  250 x 353 mm          */
#define DMPAPER_ENV_B5              34  /* Envelope B5  176 x 250 mm          */
#define DMPAPER_ENV_B6              35  /* Envelope B6  176 x 125 mm          */
#define DMPAPER_ENV_ITALY           36  /* Envelope 110 x 230 mm              */
#define DMPAPER_ENV_MONARCH         37  /* Envelope Monarch 3 7/8 x 7 1/2 in  */
#define DMPAPER_ENV_PERSONAL        38  /* 6 3/4 Envelope 3 5/8 x 6 1/2 in    */
#define DMPAPER_FANFOLD_US          39  /* US Standard Fanfold 14 7/8 x 11 in */
#define DMPAPER_FANFOLD_STD_GERMAN  40  /* German Standard Fanfold 8 1/2 x 12 in  */
#define DMPAPER_FANFOLD_LGL_GERMAN  41  /* German Legal Fanfold 8 1/2 x 13 in */
/*
** the following sizes are new in Windows 95
*/
#define DMPAPER_ISO_B4              42  /* B4 (ISO) 250 x 353 mm              */
#define DMPAPER_JAPANESE_POSTCARD   43  /* Japanese Postcard 100 x 148 mm     */
#define DMPAPER_9X11                44  /* 9 x 11 in                          */
#define DMPAPER_10X11               45  /* 10 x 11 in                         */
#define DMPAPER_15X11               46  /* 15 x 11 in                         */
#define DMPAPER_ENV_INVITE          47  /* Envelope Invite 220 x 220 mm       */
#define DMPAPER_RESERVED_48         48  /* RESERVED--DO NOT USE               */
#define DMPAPER_RESERVED_49         49  /* RESERVED--DO NOT USE               */
/*
** the following sizes were used in Windows 3.1 WDL PostScript driver
** and are retained here for compatibility with the old driver.
** Tranverse is used as in the PostScript language, and indicates that
** the physical page is rotated, but that the logical page is not.
*/
#define DMPAPER_LETTER_EXTRA          50  /* Letter Extra 9 1/2 x 12 in         */
#define DMPAPER_LEGAL_EXTRA           51  /* Legal Extra 9 1/2 x 15 in          */
#define DMPAPER_TABLOID_EXTRA         52  /* Tabloid Extra 11.69 x 18 in        */
#define DMPAPER_A4_EXTRA              53  /* A4 Extra 9.27 x 12.69 in           */
#define DMPAPER_LETTER_TRANSVERSE     54  /* Letter Transverse 8 1/2 x 11 in    */
#define DMPAPER_A4_TRANSVERSE         55  /* A4 Transverse 210 x 297 mm         */
#define DMPAPER_LETTER_EXTRA_TRANSVERSE 56/* Letter Extra Transverse 9 1/2 x 12 in  */
#define DMPAPER_A_PLUS              57  /* SuperA/SuperA/A4 227 x 356 mm      */
#define DMPAPER_B_PLUS              58  /* SuperB/SuperB/A3 305 x 487 mm      */
#define DMPAPER_LETTER_PLUS         59  /* Letter Plus 8.5 x 12.69 in         */
#define DMPAPER_A4_PLUS             60  /* A4 Plus 210 x 330 mm               */
#define DMPAPER_A5_TRANSVERSE       61  /* A5 Transverse 148 x 210 mm         */
#define DMPAPER_B5_TRANSVERSE       62  /* B5 (JIS) Transverse 182 x 257 mm   */
#define DMPAPER_A3_EXTRA            63  /* A3 Extra 322 x 445 mm              */
#define DMPAPER_A5_EXTRA            64  /* A5 Extra 174 x 235 mm              */
#define DMPAPER_B5_EXTRA            65  /* B5 (ISO) Extra 201 x 276 mm        */
#define DMPAPER_A2                  66  /* A2 420 x 594 mm                    */
#define DMPAPER_A3_TRANSVERSE       67  /* A3 Transverse 297 x 420 mm         */
#define DMPAPER_A3_EXTRA_TRANSVERSE 68  /* A3 Extra Transverse 322 x 445 mm   */

/*
** the following sizes are reserved for the Far East version of Win95.
** Rotated papers rotate the physical page but not the logical page.
*/
#define DMPAPER_DBL_JAPANESE_POSTCARD 69/* Japanese Double Postcard 200 x 148 mm */
#define DMPAPER_A6                  70  /* A6 105 x 148 mm                 */
#define DMPAPER_JENV_KAKU2          71  /* Japanese Envelope Kaku #2       */
#define DMPAPER_JENV_KAKU3          72  /* Japanese Envelope Kaku #3       */
#define DMPAPER_JENV_CHOU3          73  /* Japanese Envelope Chou #3       */
#define DMPAPER_JENV_CHOU4          74  /* Japanese Envelope Chou #4       */
#define DMPAPER_LETTER_ROTATED      75  /* Letter Rotated 11 x 8 1/2 11 in */
#define DMPAPER_A3_ROTATED          76  /* A3 Rotated 420 x 297 mm         */
#define DMPAPER_A4_ROTATED          77  /* A4 Rotated 297 x 210 mm         */
#define DMPAPER_A5_ROTATED          78  /* A5 Rotated 210 x 148 mm         */
#define DMPAPER_B4_JIS_ROTATED      79  /* B4 (JIS) Rotated 364 x 257 mm   */
#define DMPAPER_B5_JIS_ROTATED      80  /* B5 (JIS) Rotated 257 x 182 mm   */
#define DMPAPER_JAPANESE_POSTCARD_ROTATED 81 /* Japanese Postcard Rotated 148 x 100 mm */
#define DMPAPER_DBL_JAPANESE_POSTCARD_ROTATED 82 /* Double Japanese Postcard Rotated 148 x 200 mm */
#define DMPAPER_A6_ROTATED          83  /* A6 Rotated 148 x 105 mm         */
#define DMPAPER_JENV_KAKU2_ROTATED  84  /* Japanese Envelope Kaku #2 Rotated*/
#define DMPAPER_JENV_KAKU3_ROTATED  85  /* Japanese Envelope Kaku #3 Rotated*/
#define DMPAPER_JENV_CHOU3_ROTATED  86  /* Japanese Envelope Chou #3 Rotated*/
#define DMPAPER_JENV_CHOU4_ROTATED  87  /* Japanese Envelope Chou #4 Rotated*/
#define DMPAPER_B6_JIS              88  /* B6 (JIS) 128 x 182 mm           */
#define DMPAPER_B6_JIS_ROTATED      89  /* B6 (JIS) Rotated 182 x 128 mm   */
#define DMPAPER_12X11               90  /* 12 x 11 in                      */
#define DMPAPER_JENV_YOU4           91  /* Japanese Envelope You #4        */
#define DMPAPER_JENV_YOU4_ROTATED   92  /* Japanese Envelope You #4 Rotated*/
#define DMPAPER_P16K                93  /* PRC 16K 146 x 215 mm            */
#define DMPAPER_P32K                94  /* PRC 32K 97 x 151 mm             */
#define DMPAPER_P32KBIG             95  /* PRC 32K(Big) 97 x 151 mm        */
#define DMPAPER_PENV_1              96  /* PRC Envelope #1 102 x 165 mm    */
#define DMPAPER_PENV_2              97  /* PRC Envelope #2 102 x 176 mm    */
#define DMPAPER_PENV_3              98  /* PRC Envelope #3 125 x 176 mm    */
#define DMPAPER_PENV_4              99  /* PRC Envelope #4 110 x 208 mm    */
#define DMPAPER_PENV_5              100 /* PRC Envelope #5 110 x 220 mm    */
#define DMPAPER_PENV_6              101 /* PRC Envelope #6 120 x 230 mm    */
#define DMPAPER_PENV_7              102 /* PRC Envelope #7 160 x 230 mm    */
#define DMPAPER_PENV_8              103 /* PRC Envelope #8 120 x 309 mm    */
#define DMPAPER_PENV_9              104 /* PRC Envelope #9 229 x 324 mm    */
#define DMPAPER_PENV_10             105 /* PRC Envelope #10 324 x 458 mm   */
#define DMPAPER_P16K_ROTATED        106 /* PRC 16K Rotated                 */
#define DMPAPER_P32K_ROTATED        107 /* PRC 32K Rotated                 */
#define DMPAPER_P32KBIG_ROTATED     108 /* PRC 32K(Big) Rotated            */
#define DMPAPER_PENV_1_ROTATED      109 /* PRC Envelope #1 Rotated 165 x 102 mm*/
#define DMPAPER_PENV_2_ROTATED      110 /* PRC Envelope #2 Rotated 176 x 102 mm*/
#define DMPAPER_PENV_3_ROTATED      111 /* PRC Envelope #3 Rotated 176 x 125 mm*/
#define DMPAPER_PENV_4_ROTATED      112 /* PRC Envelope #4 Rotated 208 x 110 mm*/
#define DMPAPER_PENV_5_ROTATED      113 /* PRC Envelope #5 Rotated 220 x 110 mm*/
#define DMPAPER_PENV_6_ROTATED      114 /* PRC Envelope #6 Rotated 230 x 120 mm*/
#define DMPAPER_PENV_7_ROTATED      115 /* PRC Envelope #7 Rotated 230 x 160 mm*/
#define DMPAPER_PENV_8_ROTATED      116 /* PRC Envelope #8 Rotated 309 x 120 mm*/
#define DMPAPER_PENV_9_ROTATED      117 /* PRC Envelope #9 Rotated 324 x 229 mm*/
#define DMPAPER_PENV_10_ROTATED     118 /* PRC Envelope #10 Rotated 458 x 324 mm */
#define DMPAPER_COUNT               DMPAPER_PENV_10_ROTATED

#define DMPAPER_USER        256
//
// define the mapping between standard paper size id to the standard
// PaperSize option name
//
extern PSTR gpstrStdPSName[DMPAPER_COUNT];
extern PSTR gpstrStdPSDisplayName[DMPAPER_COUNT];
extern PSTR gpstrStdPSDisplayNameMacro[DMPAPER_COUNT];

//
// standard input bin id's. Copied from Win95 source
//
#define DMBIN_FIRST         DMBIN_UPPER
#define DMBIN_UPPER         1
#define DMBIN_ONLYONE       1
#define DMBIN_LOWER         2
#define DMBIN_MIDDLE        3
#define DMBIN_MANUAL        4
#define DMBIN_ENVELOPE      5
#define DMBIN_ENVMANUAL     6
#define DMBIN_AUTO          7
#define DMBIN_TRACTOR       8
#define DMBIN_SMALLFMT      9
#define DMBIN_LARGEFMT      10
#define DMBIN_LARGECAPACITY 11
#define DMBIN_CASSETTE      14
#define DMBIN_FORMSOURCE    15      /* not supported under windows 95  */
#define DMBIN_LAST          DMBIN_FORMSOURCE

#define DMBIN_USER          256     /* device specific bins start here */

extern PSTR gpstrStdIBName[DMBIN_LAST];
extern PSTR gpstrStdIBDisplayName[DMBIN_LAST];
extern PSTR gpstrStdIBDisplayNameMacro[DMBIN_LAST];

//
// standard MediaType id's. Copied from Win95 source.
//
#define DMMEDIA_STANDARD      1   /* Standard paper */
#define DMMEDIA_TRANSPARENCY  2   /* Transparency */
#define DMMEDIA_GLOSSY        3   /* Glossy paper */
#define DMMEDIA_LAST          DMMEDIA_GLOSSY

#define DMMEDIA_USER        256   /* Device-specific media start here */

extern PSTR gpstrStdMTName[DMMEDIA_LAST];
extern PSTR gpstrStdMTDisplayName[DMMEDIA_LAST];
extern PSTR gpstrStdMTDisplayNameMacro[DMMEDIA_LAST];

//
// standard TextQuality id's. Copies from minidriv.h
//
#define DMTEXT_LQ               1
#define DMTEXT_NLQ              2
#define DMTEXT_MEMO             3
#define DMTEXT_DRAFT    4
#define DMTEXT_TEXT             5
#define DMTEXT_LAST             DMTEXT_TEXT
#define DMTEXT_USER             256

extern PSTR gpstrStdTQName[DMTEXT_LAST];
extern PSTR gpstrStdTQDisplayName[DMTEXT_LAST];
extern PSTR gpstrStdTQDisplayNameMacro[DMTEXT_LAST];

typedef enum _BAPOS {
    NONE,
    CENTER,
    LEFT,
    RIGHT,
    BAPOS_MAX
} BAPOS;

typedef enum _FACEDIR {
    UP,
    DOWN,
    FD_MAX
} FACEDIR;

extern PSTR gpstrPositionName[BAPOS_MAX];
extern PSTR gpstrFaceDirName[FD_MAX];
extern PSTR gpstrColorName[8];
extern WORD gwColorPlaneCmdID[4];
extern PSTR gpstrColorPlaneCmdName[8];
extern PSTR gpstrSectionName[7];

//
// function prototypes
//
//

void *
GetTableInfo(
    IN PDH pdh,                 /* Base address of GPC data */
    IN int iResType,            /* Resource type - HE_... values */
    IN int iIndex);              /* Desired index for this entry */

void _cdecl
VOut(
    PCONVINFO,
    PSTR,
    ...);

BOOL
BBuildCmdStr(
    IN OUT PCONVINFO pci,
    IN  WORD    wCmdID,
    IN  WORD    ocd);

void
VOutputSelectionCmd(
    IN OUT PCONVINFO pci,// contain info about the cmd to output
    IN BOOL    bDocSetup,  // whether in DOC_SETUP or PAGE_SETUP section
    IN WORD    wOrder);     // order number within the section

void
VOutputConfigCmd(
    IN OUT PCONVINFO pci,// contain info about the cmd to output
    IN PSTR pstrCmdName, // command name
    IN SEQSECTION  ss,      // sequence section id
    IN WORD    wOrder);      // order number within the section

void
VOutputCmd(
    IN OUT PCONVINFO pci,   // contain info about the cmd to output
    IN PSTR    pstrCmdName);

void
VOutputExternCmd(
    IN OUT PCONVINFO pci,
    IN PSTR pstrCmdName);

void
VOutputCmd2(
    IN OUT PCONVINFO pci,
    IN PSTR pstrCmdName);

BOOL
BInDocSetup(
    IN PCONVINFO pci,
    IN WORD pc_ord,     // PC_ORD_xxx id
    OUT PWORD pwOrder); // to store the order number as in GPC
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\tools\uni\lib\makefile.inc ===
#
#

!ifndef PRNROOT
PRNROOT=$(PROJECT_ROOT)\print\drivers\usermode
!endif

cttconv.c: $(PRNROOT)\tools\uni\ctt2gtt\cttconv.c
    copy $(PRNROOT)\tools\uni\ctt2gtt\cttconv.c

pfmconv.c: $(PRNROOT)\tools\uni\pfm2ufm\pfmconv.c
    copy $(PRNROOT)\tools\uni\pfm2ufm\pfmconv.c
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\tools\uni\minidev\addcdpt.cpp ===
/******************************************************************************

  Source File:  Add Code Points.CPP

  This implements the CAddCodePoints class, which manages a dialog that allows
  the user to add additional code points to a glyph set.

  Copyright (c) 1997 by Microsoft Corporation.  All rights Reserved.

  A Pretty Penny Enterprises Production

  Change History:
  03-01-1997    Bob_Kjelgaard@Prodigy.Net   Created it

******************************************************************************/

#include    "StdAfx.H"
#include    "MiniDev.H"
#include    "addcdpt.h"
#include    <codepage.h>

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

static CCodePageInformation ccpi;

/******************************************************************************

  CAddCodePoints::CAddCodePoints

  The class constructor primarily initializes the base class and reference
  members.

******************************************************************************/

CAddCodePoints::CAddCodePoints(CWnd* pParent, CMapWordToDWord& cmw2d, 
                               CDWordArray& cda, CString csItemName)
	: CDialog(CAddCodePoints::IDD, pParent), m_cmw2dPoints(cmw2d),
    m_cdaPages(cda) {
    m_csItem = csItemName;
    for (int i= 0; i < m_cdaPages.GetSize(); i++)
        m_csaNames.Add(ccpi.Name(m_cdaPages[i]));
    m_pos = 0;
    m_uTimer = 0;
	//{{AFX_DATA_INIT(CAddCodePoints)
	//}}AFX_DATA_INIT
}

/******************************************************************************

  CAddCodePoints::DoDataExchange

  DDX override for the dialog- I'm not sure I need to keep this around.

******************************************************************************/

void CAddCodePoints::DoDataExchange(CDataExchange* pDX) {
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CAddCodePoints)
	DDX_Control(pDX, IDC_Banner, m_cpcBanner);
	DDX_Control(pDX, IDC_GlyphList, m_clbList);
	//}}AFX_DATA_MAP
}

BEGIN_MESSAGE_MAP(CAddCodePoints, CDialog)
	//{{AFX_MSG_MAP(CAddCodePoints)
	ON_WM_TIMER()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/******************************************************************************

  CAddCodePoints::OnInitDialog

  This is the primary dialog intialization member.  It uses the passed
  information to customize the title, then kicks off a timer so the UI appears
  while the list box is filled.

******************************************************************************/

BOOL CAddCodePoints::OnInitDialog() {
	CDialog::OnInitDialog();

    GetWindowText(m_csHolder);
    SetWindowText(m_csHolder + m_csItem);
	
	m_uTimer = SetTimer(IDD, 10, NULL);

    if  (!m_uTimer) {   //  No timer- fall back to filling the box slowly
        CWaitCursor cwc;
        OnTimer(m_uTimer);
    }
	
	return TRUE;  // No need to change the default focus
}

/******************************************************************************

  CAddCodePoints::OnOK

  This is called when the OK button is pressed.  We check the selection state
  of each item in the list.  If it is not selected, we remove it from the map.

  Thus, we return a map with only the desired entries to the caller.

******************************************************************************/

void CAddCodePoints::OnOK() {

    CWaitCursor cwc;    //  This could get slow

    for (unsigned u = 0; u < (unsigned) m_clbList.GetCount(); u++)
        if  (!m_clbList.GetSel(u))
            m_cmw2dPoints.RemoveKey((WORD) m_clbList.GetItemData(u));

	CDialog::OnOK();
}

/******************************************************************************

  CAddCodePoints::OnInitDialog

  This is invoked after the timer expires.  It uses the passed information to 
  fill the code point list.

******************************************************************************/

void CAddCodePoints::OnTimer(UINT nIDEvent) {

    if  (nIDEvent != m_uTimer)	{
	    CDialog::OnTimer(nIDEvent);
        return;
    }
	
	WORD        wKey;
    DWORD       dwIndex;
    CString     csWork;

    if  (m_uTimer)
        KillTimer(m_uTimer);

    if  (!m_pos) {
        m_cpcBanner.SetRange(0, m_cmw2dPoints.GetCount() - 1);
        m_cpcBanner.SetStep(1);
        m_cpcBanner.SetPos(0);
        csWork.LoadString(IDS_WaitToFill);
        CDC *pcdc = m_cpcBanner.GetDC();
        CRect   crBanner;
        m_cpcBanner.GetClientRect(crBanner);
        pcdc -> SetBkMode(TRANSPARENT);
        pcdc -> DrawText(csWork, crBanner, DT_CENTER | DT_VCENTER);
        m_cpcBanner.ReleaseDC(pcdc);
        if  (m_uTimer)
            m_clbList.EnableWindow(FALSE);
        else {
            m_clbList.LockWindowUpdate();
            m_clbList.ResetContent();
        }

        m_pos = m_cmw2dPoints.GetStartPosition();
    }

    //  Put in just 100 items, unless the timer is off

    for (unsigned u = 0; m_pos && (!m_uTimer || u < 100); u++) {
        m_cmw2dPoints.GetNextAssoc(m_pos, wKey, dwIndex);

        csWork.Format(_TEXT("%4.4X: "), wKey);
        csWork += m_csaNames[dwIndex];

        int id = m_clbList.AddString(csWork);
        m_clbList.SetItemData(id, wKey);
    }

    if  (!m_pos) {
        if  (m_uTimer)
            m_clbList.EnableWindow(TRUE);
        else
            m_clbList.UnlockWindowUpdate();
        m_uTimer = 0;
        m_cpcBanner.SetPos(0);
        m_cpcBanner.ShowWindow(SW_HIDE);
        SetFocus();
    }

    if  (m_uTimer) {
        m_cpcBanner.OffsetPos(u);
        csWork.LoadString(IDS_WaitToFill);
        CDC *pcdc = m_cpcBanner.GetDC();
        CRect   crBanner;
        m_cpcBanner.GetClientRect(crBanner);
        pcdc -> SetBkMode(TRANSPARENT);
        pcdc -> DrawText(csWork, crBanner, DT_CENTER | DT_VCENTER);
        m_cpcBanner.ReleaseDC(pcdc);
        m_uTimer = SetTimer(IDD, 10, NULL);
        if  (!m_uTimer) {
            CWaitCursor cwc;    //  Might be a while...
            m_clbList.EnableWindow(TRUE);
            m_clbList.LockWindowUpdate();
            OnTimer(m_uTimer);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\tools\uni\minidev\addcpt.h ===
/******************************************************************************

  Header File:  Add Code Points.H

  This defines the CAddCodePoints class, which uses passed lists to present a 
  list of code points and their associated code pages for selection.  This
  class should be usable for both the glyph map and font structure editors.

  Copyright (c) 1997 by Microsoft Corporation.  All Rights Reserved.

  A Pretty Penny Enterprises Production

  Change History:
  03-01-1997    Bob_Kjelgaard@Prodigy.Net   Created it

******************************************************************************/

#if defined(LONG_NAMES)
#include    <Utility Classes.H>
#else
#include    <Utility.H>
#endif

class CAddCodePoints : public CDialog {

    CMapWordToDWord&    m_cmw2dPoints;
    CDWordArray&        m_cdaPages;
    CString             m_csItem;   //  Name of the item being edited
// Construction
public:
	CAddCodePoints(CWnd* pParent, CMapWordToDWord& cmw2d, CDWordArray& cda,
                   CString csItemName);

// Dialog Data
	//{{AFX_DATA(CAddCodePoints)
	enum { IDD = IDD_AddCodePoints };
	CListBox	m_clbList;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CAddCodePoints)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CAddCodePoints)
	virtual BOOL OnInitDialog();
	virtual void OnOK();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\tools\uni\minidev\addcdpt.h ===
/******************************************************************************

  Header File:  Add Code Points.H

  This defines the CAddCodePoints class, which uses passed lists to present a 
  list of code points and their associated code pages for selection.  This
  class should be usable for both the glyph map and font structure editors.

  Copyright (c) 1997 by Microsoft Corporation.  All Rights Reserved.

  A Pretty Penny Enterprises Production

  Change History:
  03-01-1997    Bob_Kjelgaard@Prodigy.Net   Created it

******************************************************************************/

#include    <Utility.H>

class CAddCodePoints : public CDialog {

    CMapWordToDWord&    m_cmw2dPoints;
    CDWordArray&        m_cdaPages;
    CString             m_csItem;   //  Name of the item being edited
    CStringArray        m_csaNames; //  Names of the pages.
    unsigned            m_uTimer;   //  Timer ID
    POSITION            m_pos;      //  Position in input list
    CString             m_csHolder;
// Construction
public:
	CAddCodePoints(CWnd* pParent, CMapWordToDWord& cmw2d, CDWordArray& cda,
                   CString csItemName);

// Dialog Data
	//{{AFX_DATA(CAddCodePoints)
	enum { IDD = IDD_AddCodePoints };
	CProgressCtrl	m_cpcBanner;
	CListBox	m_clbList;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CAddCodePoints)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CAddCodePoints)
	virtual BOOL OnInitDialog();
	virtual void OnOK();
	afx_msg void OnTimer(UINT nIDEvent);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\tools\uni\minidev\childfrm.cpp ===
/******************************************************************************

  Source File:  Child Frame.CPP

  This implements the class for MDI child windows' frames in this application.
  Our primary change is that in most cases, the frame window is not sizable,
  since we use property sheets so extensively.

  Copyright (c) 1997 by Microsoft Corporation.  All Rights Reserved.

  A Pretty Penny Enterprises Production.

  Change History:
  02-03-1997    Bob_Kjelgaard@Prodigy.Net   Created it

******************************************************************************/

#include    "StdAfx.H"
#if defined(LONG_NAMES)
#include    "MiniDriver Developer Studio.H"

#include    "Child Frame.H"
#else
#include    "MiniDev.H"
#include    "ChildFrm.H"
#endif

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CChildFrame

IMPLEMENT_DYNCREATE(CChildFrame, CMDIChildWnd)

BEGIN_MESSAGE_MAP(CChildFrame, CMDIChildWnd)
	//{{AFX_MSG_MAP(CChildFrame)
		// NOTE - the ClassWizard will add and remove mapping macros here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CChildFrame construction/destruction

CChildFrame::CChildFrame() {
	// TODO: add member initialization code here
	
}

CChildFrame::~CChildFrame() {
}

BOOL CChildFrame::PreCreateWindow(CREATESTRUCT& cs) {
	// TODO: Modify the Window class or styles here by modifying
	//  the CREATESTRUCT cs

	cs.style = WS_CHILD | WS_OVERLAPPED | WS_CAPTION | WS_SYSMENU
		| FWS_ADDTOTITLE | WS_MINIMIZEBOX;

	return CMDIChildWnd::PreCreateWindow(cs);
}

/////////////////////////////////////////////////////////////////////////////
// CChildFrame diagnostics

#ifdef _DEBUG
void CChildFrame::AssertValid() const {
	CMDIChildWnd::AssertValid();
}

void CChildFrame::Dump(CDumpContext& dc) const {
	CMDIChildWnd::Dump(dc);
}

#endif //_DEBUG

/////////////////////////////////////////////////////////////////////////////
// CChildFrame message handlers

/******************************************************************************

  CToolTipPage class implementation

  Derive from this class rather than CPropertyPage if you wish to use to use
  tool tips on your property page.

******************************************************************************/

CToolTipPage::CToolTipPage(int id) : CPropertyPage(id) {
	//{{AFX_DATA_INIT(CToolTipPage)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT
}

CToolTipPage::~CToolTipPage() {
}

void CToolTipPage::DoDataExchange(CDataExchange* pDX) {
	CPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CToolTipPage)
		// NOTE: the ClassWizard will add DDX and DDV calls here
	//}}AFX_DATA_MAP
}

BEGIN_MESSAGE_MAP(CToolTipPage, CPropertyPage)
	//{{AFX_MSG_MAP(CToolTipPage)
	//}}AFX_MSG_MAP
    ON_NOTIFY(TTN_NEEDTEXT, 0, OnNeedText)
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CToolTipPage message handlers

/******************************************************************************

  CToolTipPage::OnInitDialog

  This message handler is simple- it simply uses CWnd::EnableToolTips to turn
  on tool tips for this page.

******************************************************************************/

BOOL CToolTipPage::OnInitDialog() {
	CPropertyPage::OnInitDialog();
	
	EnableToolTips(TRUE);
	
	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

/******************************************************************************

  CToolTipPage::OnNeedText

  This handles the tool tip notification message that tip text is needed.  This
  notification is handled by using the control's ID as the key to the string 
  table.

******************************************************************************/

void    CToolTipPage::OnNeedText(LPNMHDR pnmh, LRESULT *plr) {
    TOOLTIPTEXT *pttt = (TOOLTIPTEXT *) pnmh;

    long    lid = (pttt -> uFlags & TTF_IDISHWND) ? 
        GetWindowLong((HWND) pnmh -> idFrom, GWL_ID) : pnmh -> idFrom;

    m_csTip.LoadString(lid);
    m_csTip.TrimLeft();
    m_csTip.TrimRight();
    if  (m_csTip.IsEmpty())
        m_csTip.Format("Window ID is %X", lid);
    pttt -> lpszText = const_cast <LPTSTR> ((LPCTSTR) m_csTip);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\tools\uni\minidev\fontview.cpp ===
/******************************************************************************

  Source File:  Font Viewer.CPP

  This implements the various classes that make up the font editor for the
  studio.  The editor is basically a property sheet with a sizable collection
  of pages.

  Copyright (c) 1997 by Microsoft Corporation.  All Rights Reserved.

  A Pretty Penny Enterprises Production.

  Change History:
  03-05-1997    Bob_Kjelgaard@Prodigy.Net

******************************************************************************/

#include    "StdAfx.H"
#if defined(LONG_NAMES)
#include    "MiniDriver Developer Studio.H"
#include    "Child Frame.H"     //  Definition of Tool Tips Property Page class
#include    "Font Viewer.H"
#else
#include    "MiniDev.H"
#include    "ChildFrm.H"
#include    "FontView.H"
#endif

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/******************************************************************************

  CFontViewer class- this is the guy who owns the overall control of the view,
  although he wisely delegates the work to the MFC Property Sheet class and the
  other view classes.  I should be so wise.

******************************************************************************/

IMPLEMENT_DYNCREATE(CFontViewer, CView)

CFontViewer::CFontViewer() {
}

CFontViewer::~CFontViewer() {
}


BEGIN_MESSAGE_MAP(CFontViewer, CView)
	//{{AFX_MSG_MAP(CFontViewer)
	ON_WM_DESTROY()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CFontViewer drawing

void CFontViewer::OnDraw(CDC* pDC) {
	CDocument* pDoc = GetDocument();
}

/////////////////////////////////////////////////////////////////////////////
// CFontViewer diagnostics

#ifdef _DEBUG
void CFontViewer::AssertValid() const {
	CView::AssertValid();
}

void CFontViewer::Dump(CDumpContext& dc) const {
	CView::Dump(dc);
}
#endif //_DEBUG

/////////////////////////////////////////////////////////////////////////////
// CFontViewer message handlers

/******************************************************************************

  CFontViewer::OnInitialUpdate

  This handles the initial update of the view, meaning all of the background 
  noise of creation is essentially complete.

  I initialize the property pages by pointing each to the underlying CFontInfo,
  add them to the property sheet as needed, then create the sheet, position it
  so it aligns with the view, then adjust the owning frame's size and style so
  that everything looks like it really belongs where it is.

******************************************************************************/

void CFontViewer::OnInitialUpdate() {

	CFontInfo   *pcfi = GetDocument() -> Font();

    if  (pcfi -> Name().IsEmpty()) {
        pcfi -> Rename(GetDocument() -> GetTitle());
        GetDocument() -> SetModifiedFlag(FALSE);    //  Rename sets it
    }

    m_cps.Construct(IDR_MAINFRAME, this);
    
    m_cfgp.Init(pcfi);
    m_cfgp2.Init(pcfi);
    m_cfhp.Init(pcfi);
    m_cfsp.Init(pcfi);
    m_cfdp.Init(pcfi);
    m_cfcp.Init(pcfi);
    m_cfwp.Init(pcfi);
    m_cfkp.Init(pcfi);

    m_cps.AddPage(&m_cfgp);
    m_cps.AddPage(&m_cfgp2);
    m_cps.AddPage(&m_cfhp);
    m_cps.AddPage(&m_cfcp);
    m_cps.AddPage(&m_cfdp);
    m_cps.AddPage(&m_cfsp);
    m_cps.AddPage(&m_cfwp);
    m_cps.AddPage(&m_cfkp);

    //  Create the property sheet

    m_cps.Create(this, WS_CHILD, WS_EX_CLIENTEDGE);

    //  Get the bounding rectangle, and use it to set the frame size,
    //  after first using it to align the origin with this view.

    CRect   crPropertySheet;
    m_cps.GetWindowRect(crPropertySheet);

	crPropertySheet -= crPropertySheet.TopLeft();
    m_cps.MoveWindow(crPropertySheet, FALSE);
    GetParentFrame() -> CalcWindowRect(crPropertySheet);
    GetParentFrame() -> SetWindowPos(NULL, 0, 0, crPropertySheet.Width(),
        crPropertySheet.Height(), 
        SWP_NOZORDER | SWP_NOMOVE | SWP_NOOWNERZORDER | SWP_NOACTIVATE);
	CView::OnInitialUpdate();
    m_cps.ShowWindow(SW_SHOWNA);
    GetParentFrame() -> ShowWindow(SW_SHOW);
}

/******************************************************************************

  CFontViewer::OnActivateView

  For some reason, the property sheet does not get the focus when the frame is
  activated (probably the view class takes it away from us).  This little gem
  makes sure keyboard users don't get miffed by this.

******************************************************************************/

void    CFontViewer::OnActivateView(BOOL bActivate, CView* pcvActivate,
                                    CView* pcvDeactivate) {
    //  In case the base class does anything else of value, pass it on...

	CView::OnActivateView(bActivate, pcvActivate, pcvDeactivate);

    if  (bActivate)
        m_cps.SetFocus();
}

/******************************************************************************

  CFontViewer::OnDestroy

  This override is used to inform the embedded font that we are being
  destroyed.  If we were created by the font, then it will NULL its pointer
  to us, and won't try to detroy us when it is destroyed.

******************************************************************************/

void CFontViewer::OnDestroy() {
	CView::OnDestroy();
	
	if  (GetDocument() -> Font())
        GetDocument() -> Font() -> OnEditorDestroyed();
}

/******************************************************************************

  CFontGeneralPage class

  This implements the class that handles the General information page for the
  font viewer/editor.

  Even this page is an incredibly busy one, with about 20 controls on it.

******************************************************************************/

CFontGeneralPage::CFontGeneralPage() : CToolTipPage(CFontGeneralPage::IDD) {
	//{{AFX_DATA_INIT(CFontGeneralPage)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT
}

CFontGeneralPage::~CFontGeneralPage() {
}

void CFontGeneralPage::DoDataExchange(CDataExchange* pDX){
	CPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CFontGeneralPage)
	DDX_Control(pDX, IDC_UniqueName, m_ceUnique);
	DDX_Control(pDX, IDC_StyleName, m_ceStyle);
	DDX_Control(pDX, IDC_FaceName, m_ceFace);
	DDX_Control(pDX, IDC_RemoveFamily, m_cbRemoveFamily);
	DDX_Control(pDX, IDC_AddFamily, m_cbAddFamily);
	DDX_Control(pDX, IDC_FamilyNames, m_ccbFamilies);
	//}}AFX_DATA_MAP
}

BEGIN_MESSAGE_MAP(CFontGeneralPage, CToolTipPage)
	//{{AFX_MSG_MAP(CFontGeneralPage)
	ON_CBN_EDITCHANGE(IDC_FamilyNames, OnEditchangeFamilyNames)
	ON_BN_CLICKED(IDC_AddFamily, OnAddFamily)
	ON_BN_CLICKED(IDC_RemoveFamily, OnRemoveFamily)
	ON_EN_KILLFOCUS(IDC_FaceName, OnKillfocusFaceName)
	ON_EN_KILLFOCUS(IDC_StyleName, OnKillfocusStyleName)
	ON_EN_KILLFOCUS(IDC_UniqueName, OnKillfocusUniqueName)
	ON_BN_CLICKED(IDC_VariablePitch, OnVariablePitch)
	ON_BN_CLICKED(IDC_FixedPitch, OnFixedPitch)
	ON_BN_CLICKED(IDC_Scalable, OnScalable)
	//}}AFX_MSG_MAP
    ON_CONTROL_RANGE(BN_CLICKED, IDC_Italic, IDC_StrikeOut, OnStyleClicked)
END_MESSAGE_MAP()

/******************************************************************************

  CFontGeneralPage::OnInitDialog

  This is an override which is used to initialize the controls on the property
  page.  Since there are a lot of controls, there's a bit of substance to this
  one.

******************************************************************************/

BOOL    CFontGeneralPage::OnInitDialog() {
	CToolTipPage::OnInitDialog();

    //  Fill in the various name controls
	
	SetDlgItemText(IDC_FaceName, m_pcfi -> FaceName());
    SetDlgItemText(IDC_StyleName, m_pcfi -> StyleName());
    SetDlgItemText(IDC_UniqueName, m_pcfi -> UniqueName());
    for (unsigned u = 0; u < m_pcfi -> Families(); u++)
        m_ccbFamilies.AddString(m_pcfi -> Family(u));

    m_ccbFamilies.SetCurSel(0);
    m_cbRemoveFamily.EnableWindow(m_pcfi -> Families() > 1);
    m_cbAddFamily.EnableWindow(FALSE);

    //  Character Styles group box

    CheckDlgButton(IDC_Italic, m_pcfi -> GetStyle() & CFontInfo::Italic);
    CheckDlgButton(IDC_Underline, 
        m_pcfi -> GetStyle() & CFontInfo::Underscore);
    CheckDlgButton(IDC_StrikeOut, 
        m_pcfi -> GetStyle() & CFontInfo::StrikeOut);

    //  Pitch Buttons
    CheckRadioButton(IDC_FixedPitch, IDC_VariablePitch, 
        IDC_FixedPitch + m_pcfi -> IsVariableWidth());

    CheckDlgButton(IDC_Scalable, m_pcfi -> IsScalable());

    return TRUE;  // return TRUE unless you set the focus to a control
}

/******************************************************************************

  CFontGeneralPage::OnEditChangeFamilyNames

  When the name in the edit control changes, compare the contents to the list
  of names currently in the control.  If it is new, enable the Add Family
  button.

******************************************************************************/

void    CFontGeneralPage::OnEditchangeFamilyNames() {
	CString csContents;
    m_ccbFamilies.GetWindowText(csContents);

    for (unsigned u = 0; u < m_pcfi -> Families(); u++)
        if  (!csContents.CompareNoCase(m_pcfi -> Family(u)))
            break;

    //  Handle the button enabling- we can either add or delete, or neither,
    //  but we can never do both!

    m_cbAddFamily.EnableWindow(u >= m_pcfi -> Families());
    m_cbRemoveFamily.EnableWindow(m_pcfi -> Families() > 1 && 
        u < m_pcfi -> Families());
}

/******************************************************************************

  CFontGeneralPage::OnAddFamily

  This handles presses of the Add Family button, by adding the name in the edit
  control to the list in the box (as well as to the real list), and then making
  it the current selection.

******************************************************************************/

void    CFontGeneralPage::OnAddFamily() {
	CString csNew;

	m_ccbFamilies.GetWindowText(csNew);
    if  (!m_pcfi -> AddFamily(csNew)) {
        m_ccbFamilies.SelectString(-1, csNew);
        return;
    }

    int id = m_ccbFamilies.AddString(csNew);
    m_ccbFamilies.SetCurSel(id);

    //  Disable the Add button, and set focus to the family list

    m_ccbFamilies.SetFocus();
    m_cbAddFamily.EnableWindow(FALSE);
}

/******************************************************************************

  CFontGeneralPage::OnRemoveFamily

  This function removes the family name currently in the edit control from the
  list.  This may or may not be the current selection, but if this function is
  entered, then it was recognized as an existing name.

******************************************************************************/

void    CFontGeneralPage::OnRemoveFamily() {
	
    CString csDead;

    m_ccbFamilies.GetWindowText(csDead);
    int id = m_ccbFamilies.SelectString(-1, csDead);

    if  (id != CB_ERR) {
        m_ccbFamilies.DeleteString(id);
        m_ccbFamilies.SetCurSel(id - (id >= m_ccbFamilies.GetCount()));
    }
	else
        m_ccbFamilies.SetCurSel(0);
    m_pcfi -> RemoveFamily(csDead);
}

/******************************************************************************

  CFontGeneralPage::OnKillfocusFaceName
  CFontGeneralPage::OnKillfocusStyleName
  CFontGeneralPage::OnKillfocusUniqueName

  These functions get called when the associated control loses focus.  I check
  and see if the text has been changed.  If it has, then I update the related
  name.  This is more effective and less intervention than updating the name 
  every time the user strikes a key (not to mention it makes cut, paste, and
  undo features of the control transparent to this UI function).

******************************************************************************/

void    CFontGeneralPage::OnKillfocusFaceName() {
    if  (!m_ceFace.GetModify())
        return;

    CString csFace;
    m_ceFace.GetWindowText(csFace);
    m_pcfi -> SetFaceName(csFace);
    m_ceFace.SetModify(FALSE);
}

void    CFontGeneralPage::OnKillfocusStyleName() {
    if  (!m_ceStyle.GetModify())
        return;

    CString csStyle;
    m_ceStyle.GetWindowText(csStyle);
    m_pcfi -> SetStyleName(csStyle);
    m_ceStyle.SetModify(FALSE);
}

void    CFontGeneralPage::OnKillfocusUniqueName() {
    if  (!m_ceUnique.GetModify())
        return;

    CString csUnique;
    m_ceUnique.GetWindowText(csUnique);
    m_pcfi -> SetUniqueName(csUnique);
    m_ceUnique.SetModify(FALSE);
}

/******************************************************************************

  CFontGeneralPage::OnStyleClicked

  This is our final control range handler, called whenever any of the font
  style flags is modified.  We assemble the current settings, and pass the
  info on to the CFontInfo class for processing.

******************************************************************************/

void    CFontGeneralPage::OnStyleClicked(unsigned uid) {

    unsigned uStyle = 0;

    if  (IsDlgButtonChecked(IDC_Italic))
        uStyle |= CFontInfo::Italic;

    if  (IsDlgButtonChecked(IDC_Underline))
        uStyle |= CFontInfo::Underscore;

    if  (IsDlgButtonChecked(IDC_StrikeOut))
        uStyle |= CFontInfo::StrikeOut;

    m_pcfi -> SetStyle(uStyle);
}

/******************************************************************************

  CFontGeneralPage::OnVariablePitch
  CFontGeneralPage::OnFixedPitch

  These handle the user pressing the radio buttons for variable/fixed pitch.  
  This gets passed to the font to handle.

******************************************************************************/

void CFontGeneralPage::OnVariablePitch() {
	m_pcfi -> ChangePitch();
}

void CFontGeneralPage::OnFixedPitch() {
	m_pcfi -> ChangePitch(TRUE);
}

/******************************************************************************

  CFontGeneralPage::OnScalable

  This will be called whwnever the font scalability button is clicked.  Since
  it is a check box, it will toggle, but all we need do is pass its value back
  to the font.

******************************************************************************/

void    CFontGeneralPage::OnScalable() {
	m_pcfi -> SetScalability(IsDlgButtonChecked(IDC_Scalable));
}

/******************************************************************************

  CFontHeightPage class

  This class defines the page which shows the bounding box for the font along
  with the height subdivisions (leading, ascender, etc.)

******************************************************************************/

static WORD awFamilies[] = {FF_MODERN, FF_ROMAN, FF_SWISS, FF_SCRIPT, 
                            FF_DECORATIVE},
            awCharSets[] = {ANSI_CHARSET, SYMBOL_CHARSET, SHIFTJIS_CHARSET,
                            HANGEUL_CHARSET, CHINESEBIG5_CHARSET, 
                            GB2312_CHARSET, OEM_CHARSET},
            awSpecial[] = {IDS_CapH, IDS_LowerX, IDS_SuperSizeX, 
                            IDS_SuperSizeY, IDS_SubSizeX, IDS_SubSizeY, 
                            IDS_SuperMoveX, IDS_SuperMoveY, IDS_SubMoveX, 
                            IDS_SubMoveY, IDS_ItalicAngle, IDS_UnderSize, 
                            IDS_UnderOffset, IDS_StrikeSize, IDS_StrikeOffset, 
                            IDS_Baseline, IDS_InterlineGap, IDS_Lowerp, 
                            IDS_Lowerd, IDS_InternalLeading};

/******************************************************************************

  CFontHeightPage::ShowCharacters

  This fills in the special character edit controls with either the byte or
  WORD values, as specified by the radio buttons on the sheet.

******************************************************************************/

void    CFontHeightPage::ShowCharacters() {
    for (unsigned u = CFontInfo::First; u <= CFontInfo::Break; u++) {
        CString csWork;

        csWork.Format(_T("%X"), m_pcfi -> SignificantChar(u, 
            IsDlgButtonChecked(IDC_UnicodeShown)));
        SetDlgItemText(IDC_FirstCharacter + u, csWork);
        SendDlgItemMessage(IDC_FirstCharacter + u, EM_LIMITTEXT,
            2 << IsDlgButtonChecked(IDC_UnicodeShown), 0);
    }
}

/******************************************************************************

  CFontHeightPage::Demonstrate

  This private member demonstrates the specified font metric

******************************************************************************/

void    CFontHeightPage::Demonstrate(unsigned uMetric) {
    CWnd    *pcwDemo = GetDlgItem(IDC_FontAnimation);
    pcwDemo -> RedrawWindow();
    CDC *pcdc = pcwDemo -> GetDC();
    if  (!pcdc)
        return;

    CRect   crWindow, crDemo;
    pcwDemo -> GetClientRect(crWindow);
    crDemo.SetRectEmpty();  //  Unless it is needed later.

    CHAR    cDisplayMain = 'A';
    int     iPenWidth = 1, iWidth, iHeight;
    CPoint  cptStart(5, m_pcfi -> SpecialMetric(uMetric)), 
            cptEnd(-6 + 2 * m_pcfi -> MaxWidth(), 
                m_pcfi -> SpecialMetric(uMetric));
    BOOL    bMoreText = FALSE;

    switch  (uMetric) {
    case    CFontInfo::CapH:
        cptStart.y = cptEnd.y = m_pcfi -> SpecialMetric(CFontInfo::Baseline) -
            cptEnd.y;
        cDisplayMain = 'H';
        break;

    case    CFontInfo::LowerX:
        cptStart.y = cptEnd.y = m_pcfi -> SpecialMetric(CFontInfo::Baseline) -
            cptEnd.y;
        cDisplayMain = 'x';
        break;

    case    CFontInfo::Lowerp:
        cptStart.y = cptEnd.y = m_pcfi -> SpecialMetric(CFontInfo::Baseline) +
            cptEnd.y;
        cDisplayMain = 'p';
        break;

    case    CFontInfo::Lowerd:
        cptStart.y = cptEnd.y = m_pcfi -> SpecialMetric(CFontInfo::Baseline) -
            cptEnd.y;
        cDisplayMain = 'd';
        break;

    case    CFontInfo::SuperSizeX:
    case    CFontInfo::SuperSizeY:
    case    CFontInfo::SuperMoveX:
    case    CFontInfo::SuperMoveY:
        cptStart.x += m_pcfi -> SpecialMetric(CFontInfo::SuperMoveX);
        cptStart.y = m_pcfi -> SpecialMetric(CFontInfo::Baseline) -
            m_pcfi -> SpecialMetric(CFontInfo::SuperMoveY);
        iWidth = m_pcfi -> SpecialMetric(CFontInfo::SuperSizeX);
        iHeight = m_pcfi -> SpecialMetric(CFontInfo::SuperSizeY);
        iPenWidth = 0;  //  No pen!
        bMoreText = TRUE;
        break;

    case    CFontInfo::SubSizeX:
    case    CFontInfo::SubSizeY:
    case    CFontInfo::SubMoveX:
    case    CFontInfo::SubMoveY:
        cptStart.x += m_pcfi -> SpecialMetric(CFontInfo::SubMoveX);
        cptStart.y = m_pcfi -> SpecialMetric(CFontInfo::Baseline) -
            m_pcfi -> SpecialMetric(CFontInfo::SubMoveY);
        iWidth = m_pcfi -> SpecialMetric(CFontInfo::SubSizeX);
        iHeight = m_pcfi -> SpecialMetric(CFontInfo::SubSizeY);
        iPenWidth = 0;  //  No pen!
        bMoreText = TRUE;
        break;

    case    CFontInfo::InterlineGap:
        iPenWidth = 0;  //  No pen!
        crDemo.right = -10 + m_pcfi -> MaxWidth() * 2;
        crDemo.bottom = m_pcfi -> SpecialMetric(uMetric);
        crDemo.OffsetRect(5, m_pcfi -> Height());
        break;

    case    CFontInfo::InternalLeading:
        iPenWidth = 0;  //  No pen!
        crDemo.right = -10 + m_pcfi -> MaxWidth() * 2;
        crDemo.bottom = m_pcfi -> SpecialMetric(uMetric);
        crDemo.OffsetRect(5, 0);
        break;

    case    CFontInfo::UnderOffset:
    case    CFontInfo::UnderSize:
        iPenWidth = m_pcfi -> SpecialMetric(CFontInfo::UnderSize);
        cptStart.y = cptEnd.y = 
            m_pcfi -> SpecialMetric(CFontInfo::Baseline) -
            m_pcfi -> SpecialMetric(CFontInfo::UnderOffset);
        break;

    case    CFontInfo::StrikeOffset:
    case    CFontInfo::StrikeSize:
        iPenWidth = m_pcfi -> SpecialMetric(CFontInfo::StrikeSize);
        cptStart.y = cptEnd.y = 
            m_pcfi -> SpecialMetric(CFontInfo::Baseline) -
            m_pcfi -> SpecialMetric(CFontInfo::StrikeOffset);
        break;

    case    CFontInfo::ItalicAngle:
        cptStart.y = m_pcfi -> SpecialMetric(CFontInfo::Baseline);
        m_pcfi -> InterceptItalic(cptEnd);
        break;

    }

    //  All of the fonts requested should resemble the printer font as far
    //  as serifs, weight, italics, etc.  The face name is not used, and as
    //  much as possible, we demand a TrueType font so the image looks good.

    CFont   cfDemo;

    cfDemo.CreateFont(m_pcfi -> Height(), m_pcfi -> AverageWidth(), 0, 0,
        m_pcfi -> Weight(), m_pcfi -> GetStyle() & CFontInfo::Italic, 0, 0,
        (BYTE) m_pcfi -> CharSet(), OUT_TT_PRECIS, CLIP_TT_ALWAYS, 
        DEFAULT_QUALITY, m_pcfi -> Family() | TMPF_TRUETYPE, NULL);

    //  Use an Anisotropic mapping so we can use font units directly in the
    //  animation, and let GDI do any needed transforms.  Then clip everything
    //  to the area we really want to draw in.  This keeps things less messy.

    //  The device space is the size of one line plus any interline gap in
    //  height, and twice the maximum character width.  It scales as these
    //  valuse do.

    pcdc -> SetMapMode(MM_ANISOTROPIC);
    pcdc -> SetWindowExt(m_pcfi -> MaxWidth() * 2, 
        m_pcfi -> Height() + m_pcfi -> SpecialMetric(CFontInfo::InterlineGap));
    pcdc -> SetViewportExt(crWindow.Width(), crWindow.Height());
    pcdc -> IntersectClipRect(5, 0, -6 + 2 * m_pcfi -> MaxWidth(), 
        m_pcfi -> Height() + m_pcfi -> SpecialMetric(CFontInfo::InterlineGap));

    //  Output the main character
    CFont   *pcfOld = pcdc -> SelectObject(&cfDemo);
    pcdc -> SetBkMode(TRANSPARENT);
    pcdc -> TextOut(5, 0, &cDisplayMain, 1);
    pcdc -> SelectObject(pcfOld);

    //  Output any other characters
    if  (bMoreText) {

        CFont   cfDemo;

        cfDemo.CreateFont(iHeight, iWidth, 0, 0, m_pcfi -> Weight(), 
            m_pcfi -> GetStyle() & CFontInfo::Italic, 0, 0,
            (BYTE) m_pcfi -> CharSet(), OUT_TT_PRECIS, CLIP_TT_ALWAYS, 
            DEFAULT_QUALITY, m_pcfi -> Family() | TMPF_TRUETYPE, NULL);

        //  Output the main character
        CString csWork(_T("Sample"));
        CFont   *pcfOld = pcdc -> SelectObject(&cfDemo);
        pcdc -> SetBkMode(TRANSPARENT);
        pcdc -> TextOut(cptStart.x, cptStart.y, csWork);
        pcdc -> SelectObject(pcfOld);
    }

    //  Draw any lines that were requested
    if  (iPenWidth) {
        CPen    cpen;

        cpen.CreatePen(PS_SOLID, iPenWidth, RGB(0,0,0));
        CPen    *pcpOld = pcdc -> SelectObject(&cpen);
        pcdc -> MoveTo(cptStart);
        pcdc -> LineTo(cptEnd);
        pcdc -> SelectObject(pcpOld);
    }

    //  Draw any filled areas that might need it.

    if  (!crDemo.IsRectEmpty()) {
        CGdiObject* cpOld = pcdc -> SelectStockObject(BLACK_PEN);
        CGdiObject* cbOld = pcdc -> SelectStockObject(LTGRAY_BRUSH);
        pcdc -> Rectangle(crDemo);
        pcdc -> SelectObject(cpOld);
        pcdc -> SelectObject(cbOld);
    }
    pcwDemo -> ReleaseDC(pcdc);
}

/******************************************************************************

  CFontHeightPage constructor, destructor, et al.

******************************************************************************/

CFontHeightPage::CFontHeightPage() : CToolTipPage(CFontHeightPage::IDD) {
	//{{AFX_DATA_INIT(CFontHeightPage)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT
    m_bSpun = FALSE;
    m_uTimer = 0;
}

CFontHeightPage::~CFontHeightPage() {
}

/******************************************************************************

  CFontHeightPage::OnSetActive

  When the page is made active, we have to update the Maximum and average
  character widths, as changes elsewhere could have affected them.

******************************************************************************/

BOOL    CFontHeightPage::OnSetActive() {
    //  Show the current maximum width.  It can only be altered if the font is
    //  fixed pitch.
    SetDlgItemInt(IDC_FontWidth, m_pcfi -> MaxWidth());
    m_ceMaxWidth.EnableWindow(!m_pcfi -> IsVariableWidth());
    
    CString csWork;

    csWork.Format("Average: %d", m_pcfi -> AverageWidth());
    SetDlgItemText(IDC_AverageWidth, csWork);

    //  If scalability has changed, then the EXTTEXTMETRIC metrics may need
    //  to be added or removed.

    if  (m_pcfi -> IsScalable() && 
        m_ccbSpecial.GetCount() < CFontInfo::InternalLeading) {
        csWork.LoadString(awSpecial[CFontInfo::Lowerd]);
        int id = m_ccbSpecial.AddString(csWork);
        m_ccbSpecial.SetItemData(id, CFontInfo::Lowerd);
        csWork.LoadString(awSpecial[CFontInfo::Lowerp]);
        id = m_ccbSpecial.AddString(csWork);
        m_ccbSpecial.SetItemData(id, CFontInfo::Lowerp);
    }

    if  (!m_pcfi -> IsScalable() &&
        m_ccbSpecial.GetCount() > CFontInfo::InternalLeading) {

        for (int i = m_ccbSpecial.GetCount(); i--; )
            switch  (m_ccbSpecial.GetItemData(i)) {
            case    CFontInfo::Lowerd:
            case    CFontInfo::Lowerp:
                m_ccbSpecial.DeleteString(i);
                continue;
        }
    }

    //  Hack- set a timer so we can animate after the dialog is painted

    m_uTimer = SetTimer(IDD, 200, NULL);
    return  TRUE;
}

void CFontHeightPage::DoDataExchange(CDataExchange* pDX) {
	CToolTipPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CFontHeightPage)
	DDX_Control(pDX, IDC_FontWeight, m_ceMaxWidth);
	DDX_Control(pDX, IDC_FontSpecialValue, m_ceSpecial);
	DDX_Control(pDX, IDC_SpecialMetric, m_ccbSpecial);
	//}}AFX_DATA_MAP
}

BEGIN_MESSAGE_MAP(CFontHeightPage, CToolTipPage)
	//{{AFX_MSG_MAP(CFontHeightPage)
	ON_CBN_SELCHANGE(IDC_SpecialMetric, OnSelchangeSpecialMetric)
	ON_EN_KILLFOCUS(IDC_FontSpecialValue, OnKillfocusFontSpecialValue)
	ON_NOTIFY(UDN_DELTAPOS, IDC_SpinFontSpecial, OnDeltaposSpinFontSpecial)
	ON_EN_KILLFOCUS(IDC_FontWidth, OnKillfocusFontWidth)
	ON_EN_KILLFOCUS(IDC_FontHeight, OnKillfocusFontHeight)
	ON_EN_KILLFOCUS(IDC_FontWeight, OnKillfocusFontWeight)
	ON_CBN_SELCHANGE(IDC_FamilyBits, OnSelchangeFamilyBits)
	ON_CBN_SELCHANGE(IDC_CharSet, OnSelchangeCharSet)
	ON_WM_TIMER()
	//}}AFX_MSG_MAP
    ON_CONTROL_RANGE(BN_CLICKED, IDC_ShowANSI, IDC_UnicodeShown, OnEncoding)
    ON_CONTROL_RANGE(EN_KILLFOCUS, IDC_DefaultCharacter, IDC_BreakCharacter, 
        OnKillfocusSignificant)
END_MESSAGE_MAP()

/******************************************************************************
  CFontHeightPage::OnInitDialog

  This handles the WM_INITDIALOG message.  We fill the controls with their
  initial values.

******************************************************************************/

BOOL CFontHeightPage::OnInitDialog() {
	CToolTipPage::OnInitDialog();

    //  Family control

    for (unsigned u = 0; u < sizeof awFamilies / sizeof awFamilies[0]; u++)
        if  (m_pcfi -> Family() == awFamilies[u])
            break;

    SendDlgItemMessage(IDC_FamilyBits,CB_SETCURSEL, u, 0);

    //  CharSet Control

    for (u = 0; u < sizeof awCharSets / sizeof awCharSets[0]; u++)
        if  (m_pcfi -> CharSet() == awCharSets[u])
            break;

    SendDlgItemMessage(IDC_CharSet,CB_SETCURSEL, u, 0);

    //  Simple numerics

    SetDlgItemInt(IDC_FontWeight, m_pcfi -> Weight());
    SetDlgItemInt(IDC_FontHeight, m_pcfi -> Height());
    //  Character codes- default to Unicode

    CheckRadioButton(IDC_ShowANSI, IDC_UnicodeShown, IDC_UnicodeShown);

    ShowCharacters();

    //  Fill in the special metrics controls

    CString csWork;

    for (u = 0; u <= CFontInfo::InternalLeading; u++) {
        if  (!m_pcfi -> IsScalable() && (u == CFontInfo::Lowerd ||
            u == CFontInfo::Lowerp))
            continue;
        csWork.LoadString(awSpecial[u]);

        int id = m_ccbSpecial.AddString(csWork);
        m_ccbSpecial.SetItemData(id, u);
    }

    m_ccbSpecial.SetCurSel(0);
    OnSelchangeSpecialMetric(); //  Reflect the selected item!
	
    return TRUE;  
}

/******************************************************************************

  CFontHeightPage::OnSelchangeSpecialMetric

  This is called whwnever a new special metric is selected.  The value is
  loaded into the edit control, the new range is set in the spic control, and
  the animation is updated.

******************************************************************************/

void CFontHeightPage::OnSelchangeSpecialMetric() {

    int id = m_ccbSpecial.GetCurSel();

    if  (id < 0)
        return;     //  Can't do anything if nothing is selected

    unsigned    uMetric = m_ccbSpecial.GetItemData(id);
    
    SetDlgItemInt(IDC_FontSpecialValue, m_pcfi -> SpecialMetric(uMetric));
    SendDlgItemMessage(IDC_FontSpecialValue, EM_SETMODIFY, FALSE, 0);

    short   sMax = m_pcfi -> Height(), sMin = 0;

    switch  (uMetric) {
    case    CFontInfo::SuperSizeX:
    case    CFontInfo::SubSizeX:
        sMax = m_pcfi -> MaxWidth();
        sMin = 1;
        break;

    case    CFontInfo::StrikeSize:
        sMax = m_pcfi -> SpecialMetric(CFontInfo::Baseline);
        sMin = 1;
        break;

    case    CFontInfo::UnderSize:
        sMax -= m_pcfi -> SpecialMetric(CFontInfo::Baseline);
        sMin = 1;
        break;

    case    CFontInfo::Lowerp:
        sMax -= m_pcfi -> SpecialMetric(CFontInfo::Baseline);
        break;

    case    CFontInfo::Lowerd:
    case    CFontInfo::LowerX:
        if  (m_pcfi -> SpecialMetric(CFontInfo::CapH))
            sMax = m_pcfi -> SpecialMetric(CFontInfo::CapH);
        break;

    case    CFontInfo::InterlineGap:
        sMax <<= 1; //  Should be overkill!
        break;

    case    CFontInfo::ItalicAngle:
        sMax = 800; //  Should be more than enough, really.
        break;

    case    CFontInfo::UnderOffset:
    case    CFontInfo::SubMoveY:
        sMax = 0;
        sMin = m_pcfi -> SpecialMetric(CFontInfo::Baseline) -
            m_pcfi -> Height();
    }

    SendDlgItemMessage(IDC_SpinFontSpecial, UDM_SETRANGE, 0, 
        MAKELONG(sMax, sMin));
	Demonstrate(uMetric);
}

/******************************************************************************

  CFontHeightPage::OnKillfocusFontSpecialValue

  This is called when the edit control for the special metric loses focus.  The
  updated value, if any, is read from the control, and the animation updated to
  reflect this.

******************************************************************************/

void CFontHeightPage::OnKillfocusFontSpecialValue() {
    if  ((!m_bSpun && !m_ceSpecial.GetModify()) || 
        m_ccbSpecial.GetCurSel() < 0)
        return; //  Nothing changed, or nothing to change
    short   sSpecial = GetDlgItemInt(IDC_FontSpecialValue);
    m_pcfi -> SetSpecial(m_ccbSpecial.GetItemData(m_ccbSpecial.GetCurSel()),
        sSpecial);
    m_ceSpecial.SetModify(FALSE);
    m_bSpun = FALSE;
    Demonstrate(m_ccbSpecial.GetItemData(m_ccbSpecial.GetCurSel()));
}

/******************************************************************************

  CFontHeightPage::OnDeltaposSpinFontSpecial

  This is called when the spinnrer is used to change the value in the font
  special value box.  We set the modify flag, as this doesn't happen when the
  spin control sets the value using SetWindowText.

******************************************************************************/

void    CFontHeightPage::OnDeltaposSpinFontSpecial(NMHDR* pnmh, LRESULT* plr) {
	m_bSpun = TRUE;
    if  (m_uTimer)
        KillTimer(m_uTimer);
    m_uTimer = SetTimer(IDD, 50, NULL);
	*plr = 0;
}

/******************************************************************************

  CFontHeightPage::OnEncoding

  This member is called when either of the character encoding buttons is
  selected.  It simply calls ShowCharacters to do its thing.

******************************************************************************/

void    CFontHeightPage::OnEncoding(unsigned uid) {
    ShowCharacters();
}

/******************************************************************************

  CFontHeightPage::OnKillfocusFontWidth

  This is called when the font width control loses the input focus.  If the
  width has been modified, we pass that information on to the font, then
  use other functions to update the various affected controls.

******************************************************************************/

void    CFontHeightPage::OnKillfocusFontWidth() {
    m_pcfi -> SetMaxWidth(GetDlgItemInt(IDC_FontWidth));
    OnSetActive();  //  Update the display as needed
}

/******************************************************************************

  CFontHeightPage::OnKillfocusFontHeight

  This member gets called when the focus leaves the font height control.  
  Update the font with the latest info is all that's necessary.

******************************************************************************/

void    CFontHeightPage::OnKillfocusFontHeight() {
    if  (m_pcfi -> SetHeight(GetDlgItemInt(IDC_FontHeight)))
        OnSelchangeSpecialMetric(); //  Just in case the current one did
    else
        SetDlgItemInt(IDC_FontHeight, m_pcfi -> Height());
}

/******************************************************************************

  CFontHeightPage::OnKillfocusFontWeight

  This member will be called when the font weight control is exited.  If it has
  changed, it will be limit checked, and passed to the font if it is OK.

******************************************************************************/

void    CFontHeightPage::OnKillfocusFontWeight() {
	WORD    wWeight = GetDlgItemInt(IDC_FontWeight, NULL, FALSE);
    if  (wWeight == m_pcfi -> Weight())
        return; //  Nothing to change

    if  (wWeight > 1000) {
        AfxMessageBox(IDS_Overweight);
        GetDlgItem(IDC_FontWeight) -> SetFocus();
        SendDlgItemMessage(IDC_FontWeight, EM_SETSEL, 0, -1);
        return;
    }

    m_pcfi -> SetWeight(wWeight);
}

/******************************************************************************

  CFontHeightPage::OnSelchangeFamilyBits

  This member will get called when the selection changes in the font family
  combo box.  This one is pretty simple, but I probably should be hard-nosed
  about Modern being fixed pitch, while Swiss and Roman are not.

******************************************************************************/

void    CFontHeightPage::OnSelchangeFamilyBits() {
    switch  (SendDlgItemMessage(IDC_FamilyBits, CB_GETCURSEL, 0, 0)) {
    case    sizeof awFamilies / sizeof awFamilies[0]:
        m_pcfi -> SetFamily(FF_DONTCARE);

    case    LB_ERR:
    case    LB_ERRSPACE:
        return; //  Nothing selected

    default:
        m_pcfi -> SetFamily((BYTE) awFamilies[
            SendDlgItemMessage(IDC_FamilyBits, CB_GETCURSEL, 0, 0)]);
    }
}

/******************************************************************************

  CFontHeightPage::OnSelchangeCharSet

  This is another fairly simple one- we tell the font to use the selected
  character set.  However, it must validate it with the font, as otherwise,
  some rather nasty invalid combinations could result.

******************************************************************************/

void    CFontHeightPage::OnSelchangeCharSet() {
	if  (0 > SendDlgItemMessage(IDC_CharSet, CB_GETCURSEL, 0, 0))
        return; //  Nothing has changed

    if  (!m_pcfi -> SetCharacterSet((BYTE) awCharSets[
        SendDlgItemMessage(IDC_CharSet, CB_GETCURSEL, 0, 0)])) {
        AfxMessageBox(IDS_InvalidCharSet);

        for (unsigned u = 0; u < sizeof awCharSets / sizeof awCharSets[0]; u++)
            if  (m_pcfi -> CharSet() == awCharSets[u])
                break;

        SendDlgItemMessage(IDC_CharSet,CB_SETCURSEL, u, 0);
    }
}

/******************************************************************************

  CFontHeightPage::OnKillfocusSignificant

  This is called whenever we losr focus on one of the editable significant
  character controls (break or default).  We let the font decide if the new
  value is OK, but we display any requisite error messages ourselves.

******************************************************************************/

void    CFontHeightPage::OnKillfocusSignificant(unsigned uid) {

    CString csWork;
    WORD    wChar;

    GetDlgItemText(uid, csWork);

    if  (1 == _stscanf(csWork, " %x ", &wChar)) 

        switch  (m_pcfi -> SetSignificant(uid - IDC_FirstCharacter, wChar,
            IsDlgButtonChecked(IDC_UnicodeShown))) {
        case    CFontInfo::OK:
            return;

        case    CFontInfo::InvalidChar:
            AfxMessageBox(IDS_InvalidCharacter);
            break;

        case    CFontInfo::DoubleByte:
            AfxMessageBox(IDS_NoDBCS);
        }
    else
        AfxMessageBox(IDS_InvalidNumberFormat);

    GetDlgItem(uid) -> SetFocus();
    SendDlgItemMessage(uid, EM_SETSEL, 0, -1);
}

/******************************************************************************

  CFontHeightPage::OnTimer

  This is a bit of a hack.  It it is our timer, go ahead and animate the 
  current settings.

******************************************************************************/

void    CFontHeightPage::OnTimer(UINT nIDEvent) {
    if  (nIDEvent != m_uTimer)
	    CToolTipPage::OnTimer(nIDEvent);
    KillTimer(m_uTimer);
    //  Cause a demonstration!
    if  (m_bSpun)
        OnKillfocusFontSpecialValue();  //  Pick up the altered value!
    else
        OnSelchangeSpecialMetric(); 
}

/******************************************************************************

  CFontWidthsPage property page class

  This class handles the UFM editor Character Widths page.  It is derived from
  the Tool Tip Page class.  The page consists of a list view control in which
  the code points and their associated widths are displayed.

******************************************************************************/

/******************************************************************************

  CFontWidthsPage::Sort(LPARAM lp1, LPARAM lp2, LPARAM lp3)

  This is a private static member function- a callback for sorting the list.
  The first two parameters are the LPARAM members of two list view items- in
  this case, the indices of two code points.  The final one is supplied by the
  caller of the sort routine.  In this case, it is a pointer to the caller.

  Handling it is trivial- dereference the this pointer, and let the private
  member function for sorting handle it.

******************************************************************************/

int CALLBACK    CFontWidthsPage::Sort(LPARAM lp1, LPARAM lp2, LPARAM lp3) {
    CFontWidthsPage *pcfwp = (CFontWidthsPage *) lp3;
    _ASSERT(pcfwp);

    return  pcfwp -> Sort(lp1, lp2);
}

/******************************************************************************

  CFontWidthsPage::Sort(unsigned id1, unsigned id2)

  This is a private member function which compares the two glyph handles at the
  two indices given by the established sort criteria.

  It returns negative for 1 < 2, positive for 1 > 2, and 0 for 1 = 2- pretty
  standard stuff.

  The sort column member determines the order of precedence in which the 
  sorting is to be done, while the SortDescending member is a bitfield showing 
  the sort direction in each column.

*******************************************************************************/

int CFontWidthsPage::Sort(unsigned id1, unsigned id2) {
    
    //  If the Primnary sort is by widths- weed it out first.

    if  (!m_iSortColumn)
        switch  (m_pcfi -> CompareWidths(id1, id2)) {
        case    CFontInfo::More:
            return  (m_bSortDescending & 1) ? -1 : 1;
        case    CFontInfo::Less:
            return  (m_bSortDescending & 1) ? 1 : -1;
        }

    //  Sort is by Unicode point- this is always well-ordered
    //  Furthermore, the glyph handles are always in ascending order, making
    //  This test trivial.

    return  (!(m_bSortDescending & 2) ^ (id1 < id2)) ? 1 : -1;
}
    
CFontWidthsPage::CFontWidthsPage() : CToolTipPage(CFontWidthsPage::IDD) {
	//{{AFX_DATA_INIT(CFontWidthsPage)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT
    m_bSortDescending = 0;
    m_iSortColumn = 1;
}

CFontWidthsPage::~CFontWidthsPage() {
}

void CFontWidthsPage::DoDataExchange(CDataExchange* pDX) {
	CPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CFontWidthsPage)
	DDX_Control(pDX, IDC_CharacterWidths, m_clcView);
	//}}AFX_DATA_MAP
}

/******************************************************************************

  CFontWidthsPage::OnSetActive

  This member will be called by the framework when the page is made active.
  The base class gets this first, and it will initialize everything the first
  time.

  This is here to update the view on subsequent activations, so we can 
  seamlessly handle changes from fixed to variable pitch and back.

******************************************************************************/

BOOL    CFontWidthsPage::OnSetActive() {
    if  (!CToolTipPage::OnSetActive())
        return  FALSE;

    //  IsVariableWidth is either 0 or 1, so == is safe, here

    if  (m_pcfi -> IsVariableWidth() == !!m_clcView.GetItemCount())
        return  TRUE;   //  Everything is copacetic

    if  (m_clcView.GetItemCount())
        m_clcView.DeleteAllItems();
    else
        m_pcfi -> FillWidths(m_clcView);

    m_clcView.EnableWindow(m_pcfi -> IsVariableWidth());

    return  TRUE;
}

BEGIN_MESSAGE_MAP(CFontWidthsPage, CToolTipPage)
	//{{AFX_MSG_MAP(CFontWidthsPage)
	ON_NOTIFY(LVN_ENDLABELEDIT, IDC_CharacterWidths, OnEndlabeleditCharacterWidths)
	ON_NOTIFY(LVN_COLUMNCLICK, IDC_CharacterWidths, OnColumnclickCharacterWidths)
	ON_NOTIFY(LVN_KEYDOWN, IDC_CharacterWidths, OnKeydownCharacterWidths)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CFontWidthsPage message handlers

/******************************************************************************

  CFontWidthsPage::OnInitDialog

  This member function fills initializes the list view and fills it with the 
  font width information.

******************************************************************************/

BOOL CFontWidthsPage::OnInitDialog() {
	CToolTipPage::OnInitDialog();
	
    CString csWork;

    csWork.LoadString(IDS_WidthColumn0);

    m_clcView.InsertColumn(0, csWork, LVCFMT_CENTER, 
        m_clcView.GetStringWidth(csWork) << 1, 0);

    csWork.LoadString(IDS_WidthColumn1);

    m_clcView.InsertColumn(1, csWork, LVCFMT_CENTER, 
        m_clcView.GetStringWidth(csWork) << 1, 1);
	
    m_pcfi -> FillWidths(m_clcView);
    m_clcView.SetItemState(0, LVIS_SELECTED | LVIS_FOCUSED, 
        LVIS_SELECTED | LVIS_FOCUSED);
	
	return TRUE;  
}

/******************************************************************************

  CFontWidthsPage::OnEndlabeleditCharacterWidths

  This is where we find out the user actually wanted to change the width of a
  character.  So, not too surprisingly, we do just that (and also update the
  maximum and average widths if this isn't a DBCS font).

******************************************************************************/

void CFontWidthsPage::OnEndlabeleditCharacterWidths(NMHDR* pnmh, LRESULT* plr){
	LV_DISPINFO* plvdi = (LV_DISPINFO*) pnmh;
	
	*plr = 0;   //  Assume failure

    if  (!plvdi -> item.pszText) //  Editing canceled?
        return;

    CString csNew(plvdi -> item.pszText);

    csNew.TrimRight();
    csNew.TrimLeft();

    if  (csNew.SpanIncluding("1234567890").GetLength() != csNew.GetLength()) {
        AfxMessageBox(IDS_InvalidNumberFormat);
        return;
    }

    m_pcfi -> SetWidth(plvdi -> item.iItem, (WORD) atoi(csNew));
    *plr = TRUE;
}

/******************************************************************************

  CFontWidthsPage::OnColumnClickCharacterWidths

  This little ditty tells us one of the column headers was clicked.  We 
  obligingly either change sort direction or precednce to match, and then sort
  the list.

******************************************************************************/

void CFontWidthsPage::OnColumnclickCharacterWidths(NMHDR* pnmh, LRESULT* plr) {
	NM_LISTVIEW* pnmlv = (NM_LISTVIEW*) pnmh;

    if  (m_iSortColumn == pnmlv -> iSubItem)
        m_bSortDescending ^= 1 << m_iSortColumn;    //  Flip sort direction
    else
        m_iSortColumn = pnmlv -> iSubItem;

    m_clcView.SortItems(Sort, (LPARAM) this);    //  Sort the list!
	
	*plr = 0;
}

/******************************************************************************

  CFontWidthsPage::OnKeydownCharacterWidths

  I'd hoped to do thiw when ENTER was pressed, but finding out which class is
  eating the keystroke took too long.  Here, we look for F2 as the key to
  signal the need to edit the width of interest.

  Pretty straightforward- find out who has the focus and is selected, and edit
  their label.

******************************************************************************/

void    CFontWidthsPage::OnKeydownCharacterWidths(NMHDR* pnmh, LRESULT* plr) {
	LV_KEYDOWN * plvkd = (LV_KEYDOWN *) pnmh;

	*plr = 0;

    if  (plvkd -> wVKey != VK_F2)
        return;
    
    int idItem = m_clcView.GetNextItem(-1, LVIS_FOCUSED | LVIS_SELECTED);

    if  (idItem == -1)
        return;

    CEdit   *pce = m_clcView.EditLabel(idItem);

    if  (pce)
        pce -> ModifyStyle(0, ES_NUMBER);
}

/******************************************************************************

  CAddKernPair dialog class

  This class handles the dialog displayed when the user wishes to add a kern
  pair to the kern pair array.

  This class is used by the CFontKerningPage class

******************************************************************************/

class CAddKernPair : public CDialog {
    CSafeMapWordToOb    &m_csmw2oFirst, &m_csmw2oSecond;
    CWordArray          &m_cwaPoints;
    WORD                m_wFirst, m_wSecond;

// Construction
public:
	CAddKernPair(CSafeMapWordToOb& cmsw2o1, CSafeMapWordToOb& cmsw2o2,
        CWordArray& cwaPoints, CWnd* pParent);

    WORD    First() const { return m_wFirst; }
    WORD    Second() const { return m_wSecond; }

// Dialog Data
	//{{AFX_DATA(CAddKernPair)
	enum { IDD = IDD_AddKernPair };
	CButton	m_cbOK;
	CComboBox	m_ccbSecond;
	CComboBox	m_ccbFirst;
	short	m_sAmount;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CAddKernPair)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CAddKernPair)
	virtual BOOL OnInitDialog();
	afx_msg void OnSelchangeKernFirst();
	afx_msg void OnSelchangeKernSecond();
	afx_msg void OnChangeKernAmount();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

CAddKernPair::CAddKernPair(CSafeMapWordToOb& csmw2o1, 
                           CSafeMapWordToOb& csmw2o2, CWordArray& cwaPoints,
                           CWnd* pParent)
	: CDialog(CAddKernPair::IDD, pParent), m_csmw2oFirst(csmw2o1),
    m_csmw2oSecond(csmw2o2), m_cwaPoints(cwaPoints) {
	//{{AFX_DATA_INIT(CAddKernPair)
	m_sAmount = 0;
	//}}AFX_DATA_INIT
    m_wFirst = m_wSecond = 0;
}

void CAddKernPair::DoDataExchange(CDataExchange* pDX) {
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CAddKernPair)
	DDX_Control(pDX, IDOK, m_cbOK);
	DDX_Control(pDX, IDC_KernSecond, m_ccbSecond);
	DDX_Control(pDX, IDC_KernFirst, m_ccbFirst);
	DDX_Text(pDX, IDC_KernAmount, m_sAmount);
	//}}AFX_DATA_MAP
}

BEGIN_MESSAGE_MAP(CAddKernPair, CDialog)
	//{{AFX_MSG_MAP(CAddKernPair)
	ON_CBN_SELCHANGE(IDC_KernFirst, OnSelchangeKernFirst)
	ON_CBN_SELCHANGE(IDC_KernSecond, OnSelchangeKernSecond)
	ON_EN_CHANGE(IDC_KernAmount, OnChangeKernAmount)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CAddKernPair message handlers

/******************************************************************************

  CAddKernPair::OnInitDialog

  This member function initializes the dialog box, by filling both combo boxes,
  and disabling the OK button.

******************************************************************************/

BOOL    CAddKernPair::OnInitDialog() {
    CDialog::OnInitDialog();    //  Initialize everything

    //  Fill in the first combo box

    CString csWork;
    for (int i = 0; i < m_cwaPoints.GetSize(); i++) {
        csWork.Format("%4.4X", m_cwaPoints[i]);
        int id = m_ccbFirst.AddString(csWork);
        m_ccbFirst.SetItemData(id, m_cwaPoints[i]);
    }

    m_ccbFirst.SetCurSel(0);
    OnSelchangeKernFirst(); //  Fill the second box with this code.

    m_cbOK.EnableWindow(FALSE);

	return  TRUE;
}

/******************************************************************************

  CAddKernPair::OnSelchangeKernFirst

  This member is called whenever the selection changes in the first character
  combo box.  It screens out any already paired characters from the second
  character combo box, while preserving the currently selected character (if 
  possible).

******************************************************************************/

void    CAddKernPair::OnSelchangeKernFirst() {
	int id = m_ccbFirst.GetCurSel();

    if  (id < 0)
        return;

    m_wFirst = (WORD) m_ccbFirst.GetItemData(id);

    //  See which character is selected in the second box, so we can keep it
    //  if it is still valid.

    id = m_ccbSecond.GetCurSel();

    m_wSecond = (id > -1) ? (WORD) m_ccbSecond.GetItemData(id) : 0;
    m_ccbSecond.ResetContent();
    CString csWork;

    for (id = 0; id < m_cwaPoints.GetSize(); id++) {
        
        union {
            CObject *pco;
            CMapWordToDWord *pcmw2dFirst;
        };

        DWORD   dwIgnore;

        if  (m_csmw2oFirst.Lookup(m_wFirst, pco) && 
            pcmw2dFirst -> Lookup(m_cwaPoints[id], dwIgnore)) {
            //  There is already a kern pair for this second point
            //  Don't include it in the list, and drop it if it is
            //  the currently selected second point.
            if  (m_wSecond == m_cwaPoints[id])
                m_wSecond = 0;
            continue;
        }

        csWork.Format("%4.4X", m_cwaPoints[id]);

        int id2 = m_ccbSecond.AddString(csWork);
        m_ccbSecond.SetItemData(id2, m_cwaPoints[id]);
        if  (m_wSecond == m_cwaPoints[id])
            m_ccbSecond.SetCurSel(id2);
    }

    if  (!m_wSecond) {
        m_ccbSecond.SetCurSel(0);
        m_wSecond = (WORD) m_ccbSecond.GetItemData(0);
    }
}

/******************************************************************************

  CAddKernPair::OnSelchangeKernSecond

  This member is called whenever the selection changes in the second character
  combo box.  It screens out any already paired characters from the first
  character combo box, while preserving the currently selected character (if 
  possible).

******************************************************************************/

void    CAddKernPair::OnSelchangeKernSecond() {
	int id = m_ccbSecond.GetCurSel();

    if  (id < 0)
        return;

    m_wSecond = (WORD) m_ccbSecond.GetItemData(id);

    //  See which character is selected in the first box, so we can keep it
    //  if it is still valid.

    id = m_ccbFirst.GetCurSel();

    m_wFirst = (id > -1) ? (WORD) m_ccbFirst.GetItemData(id) : 0;
    m_ccbFirst.ResetContent();
    
    CString csWork;

    for (id = 0; id < m_cwaPoints.GetSize(); id++) {
        
        union {
            CObject *pco;
            CMapWordToDWord *pcmw2dSecond;
        };

        DWORD   dwIgnore;

        if  (m_csmw2oSecond.Lookup(m_wSecond, pco) && 
            pcmw2dSecond -> Lookup(m_cwaPoints[id], dwIgnore)) {
            //  There is already a kern pair for this first point
            //  Don't include it in the list, and drop it if it is
            //  the currently selected first point.
            if  (m_wFirst == m_cwaPoints[id])
                m_wFirst = 0;
            continue;
        }

        csWork.Format("%4.4X", m_cwaPoints[id]);

        int id2 = m_ccbFirst.AddString(csWork);
        m_ccbFirst.SetItemData(id2, m_cwaPoints[id]);
        if  (m_wFirst == m_cwaPoints[id])
            m_ccbFirst.SetCurSel(id2);
    }

    if  (!m_wFirst) {
        m_ccbFirst.SetCurSel(0);
        m_wFirst = (WORD) m_ccbFirst.GetItemData(0);
    }
}

/******************************************************************************

  CAddKernPair::OnChangeKernAmount

  This member gets called when a change is made to the amount edit box.  It
  enables the OK button if a non-zero amount seems to be there.  The DDX/DDV
  functions called from OnOK (by default) will handle any garbage that may
  have been entered, so this needn't be a complete screen.

******************************************************************************/

void    CAddKernPair::OnChangeKernAmount() {

    //  Don't use DDX/DDV, as it will complain if the user's just typed a 
    //  minus sign. All we care about is the amount is non-zero, so we can
    //  enable/disable the OK button, as needed.

    m_cbOK.EnableWindow(!!GetDlgItemInt(IDC_KernAmount));
}

/******************************************************************************

  CFontKerningPage class

  This class handles the font kerning page- the UI here consists of a list view
  showing the pairs- the view can be sorted several ways, and pairs can be
  added or deleted.

******************************************************************************/

/******************************************************************************

  CFontKerningPage::Sort(LPARAM lp1, LPARAM lp2, LPARAM lpThis)

  This is a static private function used to interface the listview's sort
  callback requirements (to which this adheres) to the classes sort routine,
  which follows.

******************************************************************************/

int CALLBACK    CFontKerningPage::Sort(LPARAM lp1, LPARAM lp2, LPARAM lpThis) {
    CFontKerningPage    *pcfkp = (CFontKerningPage *) lpThis;

    return  pcfkp -> Sort(lp1, lp2);
}

/******************************************************************************

  CFontKerningPage::Sort(unsigned u1, unsigned u2)

  This member returns -1, 0, 0r 1 to indiciate if the kern pair at index u1 is
  less than, equal to, or greater than the pair at u2, respectively.  The sort
  criteria are based on the internal control members.

******************************************************************************/

int CFontKerningPage::Sort(unsigned u1, unsigned u2) {
    for (unsigned u = 0; u < 3; u++) {
        switch  (m_uPrecedence[u]) {
        case    Amount:
            switch  (m_pcfi -> CompareKernAmount(u1, u2)) {
            case    CFontInfo::Less:
                return  (m_ufDescending & 1) ? 1 : -1;
            case    CFontInfo::More:
                return  (m_ufDescending & 1) ? -1 : 1;
            }
            continue;   //  If they are equal

        case    First:
            switch  (m_pcfi -> CompareKernFirst(u1, u2)) {
            case    CFontInfo::Less:
                return  (m_ufDescending & 2) ? 1 : -1;
            case    CFontInfo::More:
                return  (m_ufDescending & 2) ? -1 : 1;
            }
            continue;   //  If they are equal

        default:    //  Assume this is always second
            switch  (m_pcfi -> CompareKernSecond(u1, u2)) {
            case    CFontInfo::Less:
                return  (m_ufDescending & 4) ? 1 : -1;
            case    CFontInfo::More:
                return  (m_ufDescending & 4) ? -1 : 1;
            }
            continue;   //  If they are equal
        }
    }

    _ASSERT(FALSE);

    return  0;  //  This should never happen- two items can never be equal
}

/******************************************************************************

  CFontKerningPage Constructor, destructor, message map, and DDX/DDV.

  Except for some trivial construction, all of this is pretty standard MFC
  wizard-maintained stuff.

******************************************************************************/

CFontKerningPage::CFontKerningPage() : CToolTipPage(CFontKerningPage::IDD) {
	//{{AFX_DATA_INIT(CFontKerningPage)
	//}}AFX_DATA_INIT
    m_idSelected = -1;
    m_ufDescending = 0;
    m_uPrecedence[0] = Second;  //  This is the default precedence in UFM
    m_uPrecedence[1] = First;
    m_uPrecedence[2] = Amount;
}

CFontKerningPage::~CFontKerningPage() {
}

void CFontKerningPage::DoDataExchange(CDataExchange* pDX) {
	CPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CFontKerningPage)
	DDX_Control(pDX, IDC_KerningTree, m_clcView);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CFontKerningPage, CToolTipPage)
	//{{AFX_MSG_MAP(CFontKerningPage)
	ON_WM_CONTEXTMENU()
	ON_NOTIFY(LVN_KEYDOWN, IDC_KerningTree, OnKeydownKerningTree)
	ON_NOTIFY(LVN_ENDLABELEDIT, IDC_KerningTree, OnEndlabeleditKerningTree)
	ON_NOTIFY(LVN_COLUMNCLICK, IDC_KerningTree, OnColumnclickKerningTree)
	//}}AFX_MSG_MAP
    ON_COMMAND(ID_AddItem, OnAddItem)
    ON_COMMAND(ID_DeleteItem, OnDeleteItem)
    ON_COMMAND(ID_ChangeAmount, OnChangeAmount)
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CFontKerningPage message handlers

/******************************************************************************

  CFontKerningPage::OnSetActive
  
  Kerning only makes sense for variable pitch fonts, sio if this font has
  changed, we will enable/disable, and change what we display accordingly.

******************************************************************************/

BOOL    CFontKerningPage::OnSetActive() {
    if  (!CToolTipPage::OnSetActive())
        return  FALSE;

    //  IsVariableWidth is either 0 or 1, so == is safe, here

    if  (m_pcfi -> IsVariableWidth() == !!m_clcView.GetItemCount())
        return  TRUE;   //  Everything is copacetic

    m_clcView.EnableWindow(m_pcfi -> IsVariableWidth());

    if  (m_clcView.GetItemCount())
        m_clcView.DeleteAllItems();
    else {
        m_pcfi -> FillKern(m_clcView);
        m_clcView.SortItems(Sort, (LPARAM) this);
    }

    return  TRUE;
}

/******************************************************************************

  CFontKerningPage::OnInitDialog

  This member handles initialization of the dialog.  In this case, we format
  and fill in the kerning tree, if there is one to fill in.

******************************************************************************/

BOOL CFontKerningPage::OnInitDialog() {
	CToolTipPage::OnInitDialog();

    CString csWork;

    csWork.LoadString(IDS_KernColumn0);

    m_clcView.InsertColumn(0, csWork, LVCFMT_CENTER, 
        (3 * m_clcView.GetStringWidth(csWork)) >>
        1, 0);

    csWork.LoadString(IDS_KernColumn1);

    m_clcView.InsertColumn(1, csWork, LVCFMT_CENTER, 
        m_clcView.GetStringWidth(csWork) << 1, 1);

    csWork.LoadString(IDS_KernColumn2);

    m_clcView.InsertColumn(2, csWork, LVCFMT_CENTER, 
        m_clcView.GetStringWidth(csWork) << 1, 2);
	
    m_pcfi -> FillKern(m_clcView);
	
	return TRUE;
}

/******************************************************************************

  CFontKerningPage::OnContextMenu

  This member function is called whenever the user right-clicks the mouse
  anywhere within the dialog.  If it turns out not to have been within the list
  control, we ignore it.  Otherwise, we put up an appropriate context menu.

******************************************************************************/

void    CFontKerningPage::OnContextMenu(CWnd* pcwnd, CPoint cpt) {

    if  (pcwnd -> m_hWnd != m_clcView.m_hWnd) { //  Clicked with in the list?
        CToolTipPage::OnContextMenu(pcwnd, cpt);
        return;
    }

    CPoint  cptThis(cpt);   //  For hit test purposes, we will adjust this.
    m_clcView.ScreenToClient(&cptThis);

    cptThis.x = 5;  //  An arbitrary point sure to be within the label.

    m_idSelected = m_clcView.HitTest(cptThis);
    if  (m_idSelected == -1) {   //  Nothing selected, allow the "Add" item
        CMenu   cmThis;
        CString csWork;

        cmThis.CreatePopupMenu();
        csWork.LoadString(ID_AddItem);
        cmThis.AppendMenu(MF_STRING | MF_ENABLED, ID_AddItem, csWork);
        cmThis.TrackPopupMenu(TPM_LEFTALIGN | TPM_RIGHTBUTTON, cpt.x, cpt.y, 
            this);

        return;
    }

    //  We'll draw our own selection rectangle covering the entire item
    CRect   crItem;

    m_clcView.GetItemRect(m_idSelected, crItem, LVIR_BOUNDS);

    CDC *pcdc = m_clcView.GetDC();

    pcdc -> InvertRect(crItem);
    m_clcView.ReleaseDC(pcdc);

    CMenu   cmThis;
    CString csWork;

    cmThis.CreatePopupMenu();
    csWork.LoadString(ID_ChangeAmount);
    cmThis.AppendMenu(MF_STRING | MF_ENABLED, ID_ChangeAmount, csWork);
    cmThis.AppendMenu(MF_SEPARATOR);
    csWork.LoadString(ID_AddItem);
    cmThis.AppendMenu(MF_STRING | MF_ENABLED, ID_AddItem, csWork);
    csWork.LoadString(ID_DeleteItem);
    cmThis.AppendMenu(MF_STRING | MF_ENABLED, ID_DeleteItem,
        csWork);
    cmThis.TrackPopupMenu(TPM_LEFTALIGN | TPM_RIGHTBUTTON, cpt.x, cpt.y, 
        this);

    //  Undo the selection rectangle

    pcdc = m_clcView.GetDC();

    pcdc -> InvertRect(crItem);
    m_clcView.ReleaseDC(pcdc);
}

/******************************************************************************

  CFontKerningPage::OnAddItem

  This member will be called whenever the user asks to add an additional
  kerning pair to the list.

******************************************************************************/

void    CFontKerningPage::OnAddItem() {
    CSafeMapWordToOb    csmw2oFirst, csmw2oSecond;
    CWordArray  cwaPoints;

    m_pcfi -> MapKerning(csmw2oFirst, csmw2oSecond, cwaPoints);
    CAddKernPair    cakp(csmw2oFirst, csmw2oSecond, cwaPoints, this);

    if  (cakp.DoModal() == IDOK) {
        m_pcfi -> AddKern(cakp.First(), cakp.Second(), cakp.m_sAmount,
            m_clcView);        
    }
}

/******************************************************************************

  CFontKerningPage::OnDeleteItem

  This will be called if we try to delete an item from the context menu.

******************************************************************************/

void    CFontKerningPage::OnDeleteItem() {
    if  (m_idSelected < 0)
        return; //  Nothing to delete?

    m_pcfi -> RemoveKern(m_clcView.GetItemData(m_idSelected));
    m_clcView.DeleteItem(m_idSelected);
    m_idSelected = -1;
}

/******************************************************************************

  CFontKerningPage::OnChangeAmount

  This is called when the user selects the menu item stating they wish to
  change the kerning amount.  It just needs to initiate a label edit.

******************************************************************************/

void    CFontKerningPage::OnChangeAmount() {
    if  (m_idSelected < 0)
        return;

    m_clcView.EditLabel(m_idSelected);
    m_idSelected = -1;
}

/******************************************************************************

  CFontKerningPage::OnKeydownKerningTree

  This is called most of the time when a key is pressed while the list control
  has the keyboard focus.  Unfortunately, the enter key is one of those we do
  not get to see.

  Currently, the F2, F10, and delete keys get special processing.  F2 opens
  an edit label on the current item, while F10 displays the context menu, and
  the delete key deletes it.

******************************************************************************/

void    CFontKerningPage::OnKeydownKerningTree(NMHDR* pnmh, LRESULT* plr) {
	LV_KEYDOWN  *plvkd = (LV_KEYDOWN *) pnmh;
	*plr = 0;

    m_idSelected = m_clcView.GetNextItem(-1, LVIS_FOCUSED | LVIS_SELECTED);
    if  (m_idSelected < 0) {
        if  (plvkd -> wVKey == VK_F10)  //  Do an add item, in this case.
            OnAddItem();
        return;
    }
	
    switch  (plvkd -> wVKey) {
    case    VK_F2:
        m_clcView.EditLabel(m_idSelected);
        break;

    case    VK_DELETE:
        OnDeleteItem();
        break;

    case    VK_F10:
        {
            CRect   crItem;
            
            m_clcView.GetItemRect(m_idSelected, crItem, LVIR_LABEL);
            m_clcView.ClientToScreen(crItem);
            OnContextMenu(&m_clcView, crItem.CenterPoint());
            break;
        }
    }
}

/******************************************************************************

  CFontKerningPage::OnEndLabelEdit

  This method gets called when the user finishes editing a kern amount, either
  by canceling it or pressing the enter key.

******************************************************************************/

void    CFontKerningPage::OnEndlabeleditKerningTree(NMHDR* pnmh, LRESULT* plr){
	LV_DISPINFO *plvdi = (LV_DISPINFO*) pnmh;	
	*plr = 0;   //  Assume failure

    if  (!plvdi -> item.pszText) //  Editing canceled?
        return;

    CString csNew(plvdi -> item.pszText);

    csNew.TrimRight();
    csNew.TrimLeft();

    CString csTemp = (csNew[1] == _T('-')) ? csNew.Mid(1) : csNew;

    if  (csTemp.SpanIncluding("1234567890").GetLength() != 
         csTemp.GetLength()) {
        AfxMessageBox(IDS_InvalidNumberFormat);
        return;
    }

    m_pcfi -> SetKernAmount(plvdi -> item.lParam, (WORD) atoi(csNew));
    *plr = TRUE;
}

/******************************************************************************

  CFontKerningPage::OnColumnclikKerningTree

  This member gets called whn one of the sort headers is clicked.  If it is
  already the primary column, we revers the sort order fot that column.
  Otherwise, we retain the current order, and make this column the primary
  column, moving the other columns down in precedence.

******************************************************************************/

void    CFontKerningPage::OnColumnclickKerningTree(NMHDR* pnmh, LRESULT* plr) {
	NM_LISTVIEW *pnmlv = (NM_LISTVIEW*) pnmh;
	*plr = 0;

    if  (m_uPrecedence[0] == (unsigned) pnmlv -> iSubItem)
        m_ufDescending ^= (1 << pnmlv -> iSubItem);
    else {
        if  (m_uPrecedence[2] == (unsigned) pnmlv -> iSubItem)
            m_uPrecedence[2] = m_uPrecedence[1];
        m_uPrecedence[1] = m_uPrecedence[0];
        m_uPrecedence[0] = pnmlv -> iSubItem;
    }

    m_clcView.SortItems(Sort, (LPARAM) this);
}

/******************************************************************************

  CFontScalingPage property page

******************************************************************************/

CFontScalingPage::CFontScalingPage() : CToolTipPage(CFontScalingPage::IDD) {
	//{{AFX_DATA_INIT(CFontScalingPage)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT
}

CFontScalingPage::~CFontScalingPage() {
}

void CFontScalingPage::DoDataExchange(CDataExchange* pDX) {
	CPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CFontScalingPage)
		// NOTE: the ClassWizard will add DDX and DDV calls here
	//}}AFX_DATA_MAP
}

BEGIN_MESSAGE_MAP(CFontScalingPage, CToolTipPage)
	//{{AFX_MSG_MAP(CFontScalingPage)
	ON_EN_KILLFOCUS(IDC_MasterDevice, OnKillfocusMasterDevice)
	//}}AFX_MSG_MAP
    ON_CONTROL_RANGE(BN_CLICKED, IDC_ScalePoints, IDC_ScaleDevice, 
        OnUnitChange)
    ON_CONTROL_RANGE(EN_KILLFOCUS, IDC_MinimumScale, IDC_MaximumScale,
        OnRangeChange)
    ON_CONTROL_RANGE(BN_CLICKED, IDC_PortraitFont, IDC_LandscapeFont,
        OnClickOrientation)
END_MESSAGE_MAP()

/******************************************************************************

  CFontScalingPage::OnSetActive

  This is called whenever the sheet becomes active.  We enable or disable the
  controls as appropriate.  Then the controls are filled in.

******************************************************************************/

BOOL    CFontScalingPage::OnSetActive() {
    GetDlgItem(IDC_PortraitFont) -> EnableWindow(m_pcfi -> IsScalable());
    GetDlgItem(IDC_LandscapeFont) -> EnableWindow(m_pcfi -> IsScalable());
    GetDlgItem(IDC_MasterDevice) -> EnableWindow(m_pcfi -> IsScalable());
    GetDlgItem(IDC_MasterFont) -> EnableWindow(m_pcfi -> IsScalable());
    GetDlgItem(IDC_MinimumScale) -> EnableWindow(m_pcfi -> IsScalable());
    GetDlgItem(IDC_MaximumScale) -> EnableWindow(m_pcfi -> IsScalable());
    GetDlgItem(IDC_ScalePoints) -> EnableWindow(m_pcfi -> IsScalable());
    GetDlgItem(IDC_ScaleDevice) -> EnableWindow(m_pcfi -> IsScalable());

    //  Orientation Flags
    CheckDlgButton(IDC_PortraitFont, !(m_pcfi -> ScaleOrientation() & 2));
    CheckDlgButton(IDC_LandscapeFont, !(m_pcfi -> ScaleOrientation() & 1));

    //  Device-to-font unit mapping stuff

    SetDlgItemInt(IDC_MasterDevice, m_pcfi -> ScaleUnits());
    SetDlgItemInt(IDC_MasterFont, m_pcfi -> ScaleUnits(FALSE));

    //  Scaling range controls
    if  (IsDlgButtonChecked(IDC_ScaleDevice)) {  // Show Device Units
        SetDlgItemInt(IDC_MinimumScale, m_pcfi -> ScaleLimit(FALSE));
        SetDlgItemInt(IDC_MaximumScale, m_pcfi -> ScaleLimit());
    }
    else {  //  Show Points
        SetDlgItemInt(IDC_MinimumScale, 
            (72 * m_pcfi -> ScaleLimit(FALSE)) / m_pcfi -> Resolution(FALSE));
        SetDlgItemInt(IDC_MaximumScale, 
            (72 * m_pcfi -> ScaleLimit()) / m_pcfi -> Resolution(FALSE));
    }

    return  TRUE;
}

/////////////////////////////////////////////////////////////////////////////
// CFontScalingPage message handlers

/******************************************************************************

  CFontScalingPage::OnInitDialog

  This performs the necessary one-time initialization of the dialog.  Since
  most of it is done in OnSetActive, only the one-time only things get done
  here.

******************************************************************************/

BOOL CFontScalingPage::OnInitDialog() {
	CToolTipPage::OnInitDialog();
    CheckRadioButton(IDC_ScalePoints, IDC_ScaleDevice, IDC_ScaleDevice);
    return TRUE;
}

/******************************************************************************

  CFontScalingPage::OnUnitChange

  This gets called when either device units or font units get clicked.  Just
  recalculate the affected fields, and proceed.

******************************************************************************/

void    CFontScalingPage::OnUnitChange(unsigned uid) {
    if  (IsDlgButtonChecked(IDC_ScaleDevice)) {  // Show Device Units
        SetDlgItemInt(IDC_MinimumScale, m_pcfi -> ScaleLimit(FALSE));
        SetDlgItemInt(IDC_MaximumScale, m_pcfi -> ScaleLimit());
    }
    else {  //  Show Points
        SetDlgItemInt(IDC_MinimumScale, 
            (72 * m_pcfi -> ScaleLimit(FALSE)) / m_pcfi -> Resolution(FALSE));
        SetDlgItemInt(IDC_MaximumScale, 
            (72 * m_pcfi -> ScaleLimit()) / m_pcfi -> Resolution(FALSE));
    }
}

/******************************************************************************

  CFontScalingPage::OnRangeChange

  This is called when the focus leaves either of the scale controls.  We 
  attempt to set the new value, and if it is refused, provide some feedback as 
  to why.

******************************************************************************/

void    CFontScalingPage::OnRangeChange(unsigned uid) {

    WORD    wValue = GetDlgItemInt(uid, NULL, FALSE);

    if  (IsDlgButtonChecked(IDC_ScalePoints)) {
        wValue *= m_pcfi -> Resolution(FALSE);
        wValue /= 72;
    }

    switch  (m_pcfi -> SetScaleLimit(uid - IDC_MinimumScale, wValue)) {
    case    CFontInfo::ScaleOK:
        return;

    case    CFontInfo::Reversed:
        AfxMessageBox(IDS_LimitsSwapped);
        break;

    case    CFontInfo::NotWindowed:
        AfxMessageBox(IDS_NotWindowed);
        break;
    }

    SendDlgItemMessage(uid, EM_SETSEL, 0, -1);
    GetDlgItem(uid) -> SetFocus();
}

/******************************************************************************

  CFontScalingPage::OnClickOrientation

  This will be called if either of the orientation buttons gets clicked.  Just
  collect the new flags, and pass them to the font.  Pretty straightforward,
  except that if interpreted as a bitfield, the bits are negative in sense.

******************************************************************************/

void    CFontScalingPage::OnClickOrientation(unsigned uid) {
    BYTE    bFlags = IsDlgButtonChecked(IDC_PortraitFont) ? 0 : 2;

    bFlags |= IsDlgButtonChecked(IDC_LandscapeFont) ? 0 : 1;

    m_pcfi -> SetScaleOrientation(bFlags);
}

/******************************************************************************

  CFontScalingPage::OnKillfocusMasterDevice

  This is called when the edit control for the device scaling units loses 
  focus.  It passes the new values to the font, which validates them and 
  reports back any problems.  If there are any, we provide the feedback here.

******************************************************************************/

void    CFontScalingPage::OnKillfocusMasterDevice() {
    WORD    wNew = GetDlgItemInt(IDC_MasterDevice, NULL, FALSE);

    switch  (m_pcfi -> SetDeviceEmHeight(wNew)) {
    case    CFontInfo::ScaleOK:
        return;

    case    CFontInfo::NotWindowed:
        AfxMessageBox(IDS_NotWindowed);
        break;

    case    CFontInfo::Reversed:
        AfxMessageBox(IDS_ScaleReversed);
        break;
    }

    SendDlgItemMessage(IDC_MasterDevice, EM_SETSEL, 0, -1);
    GetDlgItem(IDC_MasterDevice) -> SetFocus();
}

/******************************************************************************

  CFontDifferencePage property page class

  This page is rather complex- it allows specification of changed values for
  italic, bold, or both simulations on a font.

******************************************************************************/

CFontDifferencePage::CFontDifferencePage() : 
CToolTipPage(CFontDifferencePage::IDD) {
	//{{AFX_DATA_INIT(CFontDifferencePage)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT
    m_pcfdBold = m_pcfdItalic = m_pcfdBoth = NULL;
}

CFontDifferencePage::~CFontDifferencePage() {
    //  Discard any cached but unused data
    if  (m_pcfdBold && !m_pcfi -> Diff(CFontInfo::BoldDiff))
        delete  m_pcfdBold;
    if  (m_pcfdItalic && !m_pcfi -> Diff(CFontInfo::ItalicDiff))
        delete  m_pcfdItalic;
    if  (m_pcfdBoth && m_pcfi -> Diff(CFontInfo::BothDiff))
        delete  m_pcfdBoth;    
}

void CFontDifferencePage::DoDataExchange(CDataExchange* pDX) {
	CPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CFontDifferencePage)
		// NOTE: the ClassWizard will add DDX and DDV calls here
	//}}AFX_DATA_MAP
}

BEGIN_MESSAGE_MAP(CFontDifferencePage, CToolTipPage)
	//{{AFX_MSG_MAP(CFontDifferencePage)
	//}}AFX_MSG_MAP
    ON_CONTROL_RANGE(BN_CLICKED, IDC_EnableItalicSim, IDC_EnableBISim,
        OnEnableAnySim)
    ON_CONTROL_RANGE(EN_KILLFOCUS, IDC_ItalicWeight, IDC_BoldItalicSlant,
        OnKillFocusAnyNumber)
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CFontDifferencePage message handlers

/******************************************************************************

  CFontDifferencePage::OnInitDialog

  This initializes the sheet's controls based upon the current font structure.

******************************************************************************/

BOOL CFontDifferencePage::OnInitDialog() {
	CToolTipPage::OnInitDialog();

    //  Enable the check boxes based upon what the font has, then let the UI
    //  update procedures do the rest of the work for us

    for (unsigned u = CFontInfo::ItalicDiff; u <= CFontInfo::BothDiff; u++) {
        CheckDlgButton(IDC_EnableItalicSim + u, !!m_pcfi -> Diff(u));
        OnEnableAnySim(IDC_EnableItalicSim + u);
    }
	
	return TRUE;
}

static WORD awBaseDiff[] = {IDC_ItalicWeight, IDC_BoldWeight, IDC_BIWeight};

/******************************************************************************

  CFontDifferencePage::OnEnableAnySim

  Called when any simulation is enabled or disabled.  Updates the font and UI
  appropriately.  We decode which simulation it is, and init any values we
  ought to.

******************************************************************************/

void    CFontDifferencePage::OnEnableAnySim(unsigned uid) {

    BOOL    bEnable = IsDlgButtonChecked(uid);
    WORD    wDiff = uid - IDC_EnableItalicSim;
    CFontDifference*& pcfdTarget = wDiff ? wDiff ==CFontInfo::BothDiff ?
        m_pcfdBoth : m_pcfdBold : m_pcfdItalic;

    m_pcfi -> EnableSim(wDiff, bEnable, pcfdTarget);

    for (unsigned u = CFontDifference::Weight; 
         u <= CFontDifference::Angle; 
         u++) {
        if  (!GetDlgItem(awBaseDiff[wDiff] + u))
            break;
        GetDlgItem(awBaseDiff[wDiff] + u) -> EnableWindow(bEnable);
        if  (bEnable)
            SetDlgItemInt(awBaseDiff[wDiff] + u,  pcfdTarget -> Metric(u));
    }
}

/******************************************************************************

  CFontDifferencePage::OnKillFocusAnyNumber

  This is called whenever any of the numeric values in the sheet loses focus.
  We just pull it out of the control and shoot it off to the font.

******************************************************************************/

void    CFontDifferencePage::OnKillFocusAnyNumber(unsigned uid) {
    WORD    wDiff = (uid > IDC_BAverage) + (uid > IDC_ItalicSlant);
    WORD    wItem = uid - awBaseDiff[wDiff];

    switch  (m_pcfi -> Diff(wDiff) -> 
        SetMetric(wItem, GetDlgItemInt(uid, NULL, FALSE))) {
    case    CFontDifference::OK:
        return; //  It worked!

    case    CFontDifference::Reversed:
        AfxMessageBox(IDS_WidthReversed);
        break;

    case    CFontDifference::TooBig:
        AfxMessageBox(wItem ? IDS_Overweight : IDS_AngleTooBig);
    }

    GetDlgItem(uid) -> SetFocus();
    SendDlgItemMessage(uid, EM_SETSEL, 0, -1);
}

/******************************************************************************

  CFontCommandPage property page class

  One of the simpler classes- the sheet has two edit controls and a set of
  check boxes, and the check boxes can be handled by a single routine.

******************************************************************************/

CFontCommandPage::CFontCommandPage() : CToolTipPage(CFontCommandPage::IDD) {
	//{{AFX_DATA_INIT(CFontCommandPage)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT
}

CFontCommandPage::~CFontCommandPage() {
}

void CFontCommandPage::DoDataExchange(CDataExchange* pDX) {
	CPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CFontCommandPage)
	DDX_Control(pDX, IDC_FontUnselector, m_ceDeselect);
	DDX_Control(pDX, IDC_FontSelector, m_ceSelect);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CFontCommandPage, CToolTipPage)
	//{{AFX_MSG_MAP(CFontCommandPage)
	ON_EN_KILLFOCUS(IDC_FontSelector, OnKillfocusFontSelector)
	ON_EN_KILLFOCUS(IDC_FontUnselector, OnKillfocusFontUnselector)
	//}}AFX_MSG_MAP
    ON_CONTROL_RANGE(BN_CLICKED, IDC_ItalicSim, IDC_Backspace, OnFlagChange)
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CFontCommandPage message handlers

/******************************************************************************

  CFFontCommandPage::OnInitDialog

  This initializes the dialog.  It does so by letting the base class do its 
  thing, after which we copy the invocation strings into the controls, and set
  the check boxes to reflect the other flags.

******************************************************************************/

BOOL CFontCommandPage::OnInitDialog() {
	CToolTipPage::OnInitDialog();
	
	CString csCommand;
    m_pcfi -> Selector().GetInvocation(csCommand);
    m_ceSelect.SetWindowText(csCommand);

    m_pcfi -> Selector(FALSE).GetInvocation(csCommand);
    m_ceDeselect.SetWindowText(csCommand);

    //  Now just set up theflags, and we're done!

    for (WORD w = CFontInfo::ItalicSim; w <= CFontInfo::UseBKSP; w++) 
        CheckDlgButton(IDC_ItalicSim + w, m_pcfi -> SimFlag(w));
	
	return TRUE;
}

/******************************************************************************

  CFontCommandPage::OnKillFocusFontSelector

  This will be called whenever the control with the selector string loses
  focus.  If the contents have changed, the necessary updates will take place.

******************************************************************************/

void CFontCommandPage::OnKillfocusFontSelector() {

    if  (!m_ceSelect.GetModify())
        return; //  Nothing to deal with!

	//  Retrieve the current text

    CString csCommand;
    m_ceSelect.GetWindowText(csCommand);

    //  Pass it on to the underlying font info.
    m_pcfi -> Selector().SetInvocation(csCommand);

    //  Update the control to refelect the new setting
    m_pcfi -> Selector().GetInvocation(csCommand);
    m_ceSelect.SetWindowText(csCommand);
    m_ceSelect.SetModify(FALSE);
}

/******************************************************************************

  CFontCommandPage::OnKillFocusFontUnselector

  This will be called whenever the control with the unselector string loses
  focus.  If the contents have changed, the necessary updates will take place.

******************************************************************************/

void CFontCommandPage::OnKillfocusFontUnselector()  {

    if  (!m_ceDeselect.GetModify())
        return; //  Nothing to deal with!

	//  Retrieve the current text

    CString csCommand;
    m_ceDeselect.GetWindowText(csCommand);

    //  Pass it on to the underlying font info.
    m_pcfi -> Selector(FALSE).SetInvocation(csCommand);

    //  Update the control to reflect the new setting
    m_pcfi -> Selector(FALSE).GetInvocation(csCommand);
    m_ceDeselect.SetWindowText(csCommand);
    m_ceDeselect.SetModify(FALSE);
}

/******************************************************************************

  CFontCommandPage::OnFlagChange

  This member function handles the clicking of any of the check boxes used for
  flags.  The control IDs are purposely in flag order, so a simple XOR of the
  appropriate bit is all of the action that's required.

******************************************************************************/

void    CFontCommandPage::OnFlagChange(unsigned uid) {
    m_pcfi -> ToggleSimFlag(uid - IDC_ItalicSim);
}

/******************************************************************************

  CFontGeneralPage2 property page class

******************************************************************************/

CFontGeneralPage2::CFontGeneralPage2() : CToolTipPage(CFontGeneralPage2::IDD) {
	//{{AFX_DATA_INIT(CFontGeneralPage2)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT
}

CFontGeneralPage2::~CFontGeneralPage2() {
}

void CFontGeneralPage2::DoDataExchange(CDataExchange* pDX) {
	CPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CFontGeneralPage2)
		// NOTE: the ClassWizard will add DDX and DDV calls here
	//}}AFX_DATA_MAP
}

BEGIN_MESSAGE_MAP(CFontGeneralPage2, CToolTipPage)
	//{{AFX_MSG_MAP(CFontGeneralPage2)
	ON_EN_KILLFOCUS(IDC_CenteringAdjustment, OnKillfocusCenteringAdjustment)
	ON_CBN_SELCHANGE(IDC_FontLocation, OnSelchangeFontLocation)
	ON_CBN_SELCHANGE(IDC_FontTechnology, OnSelchangeFontTechnology)
	ON_EN_KILLFOCUS(IDC_PrivateData, OnKillfocusPrivateData)
	//}}AFX_MSG_MAP
    ON_CONTROL_RANGE(EN_KILLFOCUS, IDC_PreAdjustY, IDC_PostAdjustY,
        OnKillfocusBaselineAdjustment)
    ON_CONTROL_RANGE(EN_KILLFOCUS, IDC_HorizontalResolution, 
        IDC_VerticalResolution, OnKillfocusResolution)
END_MESSAGE_MAP()


/******************************************************************************

  CFontGeneralPage::OnSetActive

  This handles the page activation.  The only real work is that just in case
  the scalability has changed, the enabling of the technology control may need
  to be changed.

******************************************************************************/

BOOL CFontGeneralPage2::OnSetActive() {
	if  (!CToolTipPage::OnSetActive())
        return  FALSE;
	
	if  (m_pcfi -> IsScalable())
        SendDlgItemMessage(IDC_FontTechnology, CB_SETCURSEL, 
            m_pcfi -> Technology(), 0);

    GetDlgItem(IDC_FontTechnology) -> EnableWindow(m_pcfi -> IsScalable());

	return TRUE;  
}

/////////////////////////////////////////////////////////////////////////////
// CFontGeneralPage2 message handlers

/******************************************************************************

  CFontGeneralPage::OnInitDialog

  This handler the page initialization.  The controls are set up to reflect the
  current font settings.

******************************************************************************/

BOOL CFontGeneralPage2::OnInitDialog() {
	CToolTipPage::OnInitDialog();
	
	SendDlgItemMessage(IDC_FontLocation, CB_SETCURSEL, m_pcfi -> Location(), 
        0);

    if  (m_pcfi -> IsScalable())
        SendDlgItemMessage(IDC_FontTechnology, CB_SETCURSEL, 
            m_pcfi -> Technology(), 0);
    else
        GetDlgItem(IDC_FontTechnology) -> EnableWindow(FALSE);

    SetDlgItemInt(IDC_HorizontalResolution, m_pcfi -> Resolution(), FALSE);
    SetDlgItemInt(IDC_VerticalResolution, m_pcfi -> Resolution(FALSE), FALSE);
    SetDlgItemInt(IDC_PreAdjustY, m_pcfi -> BaselineAdjustment());
    SetDlgItemInt(IDC_PostAdjustY, m_pcfi -> BaselineAdjustment(FALSE));
    SetDlgItemInt(IDC_CenteringAdjustment, m_pcfi -> CenterAdjustment());
    SetDlgItemInt(IDC_PrivateData, m_pcfi -> PrivateData());

    SetDlgItemText(IDC_GTTDescription, m_pcfi -> GTTDescription());
	
	return TRUE;  
}

/******************************************************************************

  CFontGeneralPage Edit control focus loss handlers

  These all work basically the same way.  If the control's contents have
  changed, the contents are translated, passed to the underlying font, and then
  updated with the value the font has stored- this let's the font object do any
  validation, etc., it deems necessary.

******************************************************************************/

void    CFontGeneralPage2::OnKillfocusCenteringAdjustment() {
    if  (!SendDlgItemMessage(IDC_CenteringAdjustment, EM_GETMODIFY, 0, 0))
        return;
    m_pcfi -> SetCenterAdjustment(GetDlgItemInt(IDC_CenteringAdjustment));
    SetDlgItemInt(IDC_CenteringAdjustment, m_pcfi -> CenterAdjustment());
}

/******************************************************************************

  CFontGeneralPage2::OnSelchangeFontLocation

  This handles changes in the selection which specifies the font location
  (firmware / cartridge / downloadable).  Thye get passed on rather directly
  to the font.

******************************************************************************/

void    CFontGeneralPage2::OnSelchangeFontLocation() {
    int id = SendDlgItemMessage(IDC_FontLocation, CB_GETCURSEL, 0, 0);

    if  (id < 0)
        return;

    m_pcfi -> SetLocation(id);
}

/******************************************************************************

  CFontGeneralPage2::OnSelchangeFontTechnology

  This handles changes in the selection which specifies the font technology
  This get handled directly by the font

******************************************************************************/

void    CFontGeneralPage2::OnSelchangeFontTechnology() {
    int id = SendDlgItemMessage(IDC_FontTechnology, CB_GETCURSEL, 0, 0);

    if  (id < 0)
        return;

    m_pcfi -> SetTechnology(id);
}

/******************************************************************************

  CFontGeneralPAge2::OnKillfocusPrivateData

  Reads the contents of the edit control out, and passes them back to the font.

******************************************************************************/

void    CFontGeneralPage2::OnKillfocusPrivateData() {
    short   s = (short) GetDlgItemInt(IDC_PrivateData);

    m_pcfi -> SetPrivateData(s);

	SetDlgItemInt(IDC_PrivateData, m_pcfi -> PrivateData());
}

/******************************************************************************

  CFontGeneralPAge2::OnKillfocusBaselineAdjustment

  This is called when the focus leaves either of the baseline adjustment boxes.
  Just read the number out, send it off to the font, then refresh the box with
  the current setting.

******************************************************************************/

void    CFontGeneralPage2::OnKillfocusBaselineAdjustment(unsigned uid) {
    short   sNew = GetDlgItemInt(uid);
    BOOL    bPre = uid == IDC_PreAdjustY;

    m_pcfi -> SetBaselineAdjustment(bPre, sNew);
    SetDlgItemInt(uid, m_pcfi -> BaselineAdjustment(bPre));
}

/******************************************************************************

  CFontGeneralPAge2::OnKillfocusResolution

  This is called when the focus leaves either of the resolution edit controls.
  Just read the number out, send it off to the font, then refresh the box with
  the current setting.

******************************************************************************/

void    CFontGeneralPage2::OnKillfocusResolution(unsigned uid) {
    WORD    wNew = GetDlgItemInt(uid, NULL, FALSE);
    BOOL    bX = uid == IDC_HorizontalResolution;

    m_pcfi -> SetResolution(bX, wNew);
    SetDlgItemInt(uid, m_pcfi -> Resolution(bX), FALSE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\tools\uni\minidev\fontview.h ===
/******************************************************************************

  Header File:  Font Viewer.H

  This defines the classes used in viewing and editing font information for the
  studio.  The view consists of a property sheet with several pages to allow
  viewing and editing of the large quantity of data that describes the font.

  Copyright (c) 1997 by Microsoft Corporation.  All Rights Reserved.

  A Pretty Penny Enterprises Production

  Change History:
  03-05-1997    Bob_Kjelgaard@Prodigy.Net   Created it.

******************************************************************************/

#include    <GTT.H>
#include    <FontInfo.H>

/******************************************************************************

  CFontGeneralPage class

  This class implements the General Information page in the Font Viewer.

******************************************************************************/

class CFontGeneralPage : public CToolTipPage {
    CFontInfo   *m_pcfi;

// Construction
public:
	CFontGeneralPage();
	~CFontGeneralPage();

    void    Init(CFontInfo *pcfi) { m_pcfi = pcfi; }

// Dialog Data
	//{{AFX_DATA(CFontGeneralPage)
	enum { IDD = IDD_FontGeneralPage };
	CEdit	m_ceUnique;
	CEdit	m_ceStyle;
	CEdit	m_ceFace;
	CButton	m_cbRemoveFamily;
	CButton	m_cbAddFamily;
	CComboBox	m_ccbFamilies;
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CFontGeneralPage)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
    afx_msg void    OnStyleClicked(unsigned uid);
	// Generated message map functions
	//{{AFX_MSG(CFontGeneralPage)
	virtual BOOL OnInitDialog();
	afx_msg void OnEditchangeFamilyNames();
	afx_msg void OnAddFamily();
	afx_msg void OnRemoveFamily();
	afx_msg void OnKillfocusFaceName();
	afx_msg void OnKillfocusStyleName();
	afx_msg void OnKillfocusUniqueName();
	afx_msg void OnVariablePitch();
	afx_msg void OnFixedPitch();
	afx_msg void OnScalable();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

/******************************************************************************
  CFontHeightPage class

  This defines a property sheet which describes the font's bounding box and
  height.

******************************************************************************/

class CFontHeightPage : public CToolTipPage {
    CFontInfo   *m_pcfi;
    BOOL        m_bSpun;    //  Modify flag gets reset by up/down control!
    unsigned    m_uTimer;   //  Used to hack some of the animation

    void    ShowCharacters();
    void    Demonstrate(unsigned uMetric);

// Construction
public:
	CFontHeightPage();
	~CFontHeightPage();

    void    Init(CFontInfo *pcfi) { m_pcfi = pcfi; }

// Dialog Data
	//{{AFX_DATA(CFontHeightPage)
	enum { IDD = IDD_FontMetrics };
	CEdit	m_ceMaxWidth;
	CEdit	m_ceSpecial;
	CComboBox	m_ccbSpecial;
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CFontHeightPage)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
    virtual BOOL OnSetActive();
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CFontHeightPage)
	virtual BOOL OnInitDialog();
	afx_msg void OnSelchangeSpecialMetric();
	afx_msg void OnKillfocusFontSpecialValue();
	afx_msg void OnDeltaposSpinFontSpecial(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnKillfocusFontWidth();
	afx_msg void OnKillfocusFontHeight();
	afx_msg void OnKillfocusFontWeight();
	afx_msg void OnSelchangeFamilyBits();
	afx_msg void OnSelchangeCharSet();
	afx_msg void OnTimer(UINT nIDEvent);
	//}}AFX_MSG
    afx_msg void OnEncoding(unsigned uid);
    afx_msg void OnKillfocusSignificant(unsigned uid);
	DECLARE_MESSAGE_MAP()

};

/******************************************************************************

  CFontWidthsPage class

  This class implements the character widths page for the font editor

******************************************************************************/

class CFontWidthsPage : public CToolTipPage {
    CFontInfo   *m_pcfi;
    BYTE        m_bSortDescending;
    int         m_iSortColumn;

    static int CALLBACK Sort(LPARAM lp1, LPARAM lp2, LPARAM lpThis);

    int Sort(unsigned id1, unsigned id2);

// Construction
public:
	CFontWidthsPage();
	~CFontWidthsPage();

    void    Init(CFontInfo *pcfi) { m_pcfi = pcfi; }

// Dialog Data
	//{{AFX_DATA(CFontWidthsPage)
	enum { IDD = IDD_CharacterWidths };
	CListCtrl	m_clcView;
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CFontWidthsPage)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
    virtual BOOL OnSetActive();
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CFontWidthsPage)
	virtual BOOL OnInitDialog();
	afx_msg void OnEndlabeleditCharacterWidths(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnColumnclickCharacterWidths(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnKeydownCharacterWidths(NMHDR* pNMHDR, LRESULT* pResult);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};

/******************************************************************************

  CFontKerningPage class

  This class handles the Font Kerning structures, if there are any to be had.

******************************************************************************/

class CFontKerningPage : public CToolTipPage {
    CFontInfo   *m_pcfi;
    int         m_idSelected;   //  Tracks selected item 
    unsigned    m_ufDescending; //  Sort order flags by column- 0 = Ascending;
    unsigned    m_uPrecedence[3];   //  Sort precedence, by column

    static int CALLBACK Sort(LPARAM lp1, LPARAM lp2, LPARAM lpThis);

    int Sort(unsigned u1, unsigned u2);

    enum    {Amount, First, Second};    //  Internal enum to control sorting

// Construction
public:
	CFontKerningPage();
	~CFontKerningPage();

    void    Init(CFontInfo *pcfi) { m_pcfi = pcfi; }

// Dialog Data
	//{{AFX_DATA(CFontKerningPage)
	enum { IDD = IDD_KerningPairs };
	CListCtrl	m_clcView;
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CFontKerningPage)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
    virtual BOOL OnSetActive();
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CFontKerningPage)
	virtual BOOL OnInitDialog();
	afx_msg void OnContextMenu(CWnd* pWnd, CPoint point);
	afx_msg void OnKeydownKerningTree(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnEndlabeleditKerningTree(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnColumnclickKerningTree(NMHDR* pNMHDR, LRESULT* pResult);
	//}}AFX_MSG
    afx_msg void OnAddItem();
    afx_msg void OnDeleteItem();
    afx_msg void OnChangeAmount();
	DECLARE_MESSAGE_MAP()

};

/******************************************************************************

  CFontScalingPage class

  This class implements the property page for editing the semantic content of
  the EXTTEXTMETRIC structure.

******************************************************************************/

class CFontScalingPage : public CToolTipPage {
    CFontInfo   *m_pcfi;

// Construction
public:
	CFontScalingPage();
	~CFontScalingPage();

    void    Init(CFontInfo *pcfi) { m_pcfi = pcfi; }

// Dialog Data
	//{{AFX_DATA(CFontScalingPage)
	enum { IDD = IDD_FontScaling };
		// NOTE - ClassWizard will add data members here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CFontScalingPage)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
    virtual BOOL OnSetActive();
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CFontScalingPage)
	virtual BOOL OnInitDialog();
	afx_msg void OnKillfocusMasterDevice();
	//}}AFX_MSG
    afx_msg void OnUnitChange(unsigned uid);
    afx_msg void OnRangeChange(unsigned uid);
    afx_msg void OnClickOrientation(unsigned uid);
	DECLARE_MESSAGE_MAP()

};

/******************************************************************************

  CFontDifferencePage class

  This handles the page for font simulation differences

******************************************************************************/

class CFontDifferencePage : public CToolTipPage {
    CFontInfo       *m_pcfi;
    CFontDifference *m_pcfdBold, *m_pcfdItalic, *m_pcfdBoth;

// Construction
public:
	CFontDifferencePage();
	~CFontDifferencePage();

    void    Init(CFontInfo *pcfi) { m_pcfi = pcfi; }

// Dialog Data
	//{{AFX_DATA(CFontDifferencePage)
	enum { IDD = IDD_FontSimulations };
		// NOTE - ClassWizard will add data members here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CFontDifferencePage)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CFontDifferencePage)
	virtual BOOL OnInitDialog();
	//}}AFX_MSG
    afx_msg void OnEnableAnySim(unsigned uid);
    afx_msg void OnKillFocusAnyNumber(unsigned uid);
	DECLARE_MESSAGE_MAP()

};

/******************************************************************************

  CFontCommandPage class

  This class handles the page with the selection and deselection strings for
  the font.

******************************************************************************/

class CFontCommandPage : public CToolTipPage {
    CFontInfo   *m_pcfi;

// Construction
public:
	CFontCommandPage();
	~CFontCommandPage();

    void    Init(CFontInfo *pcfi) { m_pcfi = pcfi; }

// Dialog Data
	//{{AFX_DATA(CFontCommandPage)
	enum { IDD = IDD_FontSelection };
	CEdit	m_ceDeselect;
	CEdit	m_ceSelect;
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CFontCommandPage)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
    afx_msg void    OnFlagChange(unsigned uid); //  Handles flag changes
	// Generated message map functions
	//{{AFX_MSG(CFontCommandPage)
	virtual BOOL OnInitDialog();
	afx_msg void OnKillfocusFontSelector();
	afx_msg void OnKillfocusFontUnselector();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};

/******************************************************************************

  CFontGeneralPage2 class

  This class handles the second page of general font information for the tool.

******************************************************************************/

class CFontGeneralPage2 : public CToolTipPage {
    CFontInfo   *m_pcfi;

// Construction
public:
	CFontGeneralPage2();
	~CFontGeneralPage2();

    void    Init(CFontInfo *pcfi) { m_pcfi = pcfi; }

// Dialog Data
	//{{AFX_DATA(CFontGeneralPage2)
	enum { IDD = IDD_FontGeneralPage2 };
		// NOTE - ClassWizard will add data members here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CFontGeneralPage2)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
    virtual BOOL OnSetActive();
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CFontGeneralPage2)
	virtual BOOL OnInitDialog();
	afx_msg void OnKillfocusCenteringAdjustment();
	afx_msg void OnSelchangeFontLocation();
	afx_msg void OnSelchangeFontTechnology();
	afx_msg void OnKillfocusPrivateData();
	//}}AFX_MSG
    afx_msg void OnKillfocusBaselineAdjustment(unsigned uid);
    afx_msg void OnKillfocusResolution(unsigned uid);
	DECLARE_MESSAGE_MAP()

};

/******************************************************************************

  CFontViewer class

  This is the CView-derived class which implements the font viewer.  It 
  actually uses CPropertySheet and the preceding property page classes to do
  most of its work.

******************************************************************************/

class CFontViewer : public CView {
    CPropertySheet      m_cps;
    CFontGeneralPage    m_cfgp;
    CFontGeneralPage2   m_cfgp2;
    CFontHeightPage     m_cfhp;
    CFontWidthsPage     m_cfwp;
    CFontKerningPage    m_cfkp;
    CFontScalingPage    m_cfsp;
    CFontDifferencePage m_cfdp;
    CFontCommandPage    m_cfcp;

protected:
	CFontViewer();           // protected constructor used by dynamic creation
	DECLARE_DYNCREATE(CFontViewer)

// Attributes
public:
    CFontInfoContainer  *GetDocument() { 
        return (CFontInfoContainer *) m_pDocument;
    }

// Operations
public:

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CFontViewer)
	public:
	virtual void OnInitialUpdate();
	protected:
	virtual void OnDraw(CDC* pDC);      // overridden to draw this view
	virtual void OnActivateView(BOOL bActivate, CView* pActivateView, CView* pDeactiveView);
	//}}AFX_VIRTUAL

// Implementation
protected:
	virtual ~CFontViewer();
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif

	// Generated message map functions
protected:
	//{{AFX_MSG(CFontViewer)
	afx_msg void OnDestroy();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\tools\uni\minidev\childfrm.h ===
/******************************************************************************

  Header File:  Child Frame.H

  This defines the CChildFrame class, which is the MFC CMDIChild with some
  minor wrapping around it.

  Copyright (c) 1997 by Microsoft Corporation.  All Rights Reserved.

  A Pretty Penny Enterprises Production.

  Change History:
  02-03-1997    Bob_Kjelgaard@Prodigy.Net

******************************************************************************/

// Child Frame.h : interface of the CChildFrame class
//
/////////////////////////////////////////////////////////////////////////////

#if !defined(CHILD_FRAME_CLASS)
#define CHILD_FRAME_CLASS

class CChildFrame : public CMDIChildWnd {
	DECLARE_DYNCREATE(CChildFrame)
public:
	CChildFrame();

// Attributes
public:

// Operations
public:

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CChildFrame)
	public:
	virtual BOOL PreCreateWindow(CREATESTRUCT& cs);
	//}}AFX_VIRTUAL

// Implementation
public:
	virtual ~CChildFrame();
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif

// Generated message map functions
protected:
	//{{AFX_MSG(CChildFrame)
		// NOTE - the ClassWizard will add and remove member functions here.
		//    DO NOT EDIT what you see in these blocks of generated code!
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

/******************************************************************************

  CToolTipPage class

  This class implements a page that displays tool tips for its controls using
  strings from the string table matching the control IDs.  Derive from this
  class, and everything else works just as it ought to!

******************************************************************************/

class CToolTipPage : public CPropertyPage {

    CString m_csTip;    //  Can't use auto variables or you lose them!

// Construction
public:
	CToolTipPage(int id);
	~CToolTipPage();

// Dialog Data
	//{{AFX_DATA(CToolTipPage)
	enum { IDD = IDD_TIP };
		// NOTE - ClassWizard will add data members here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_DATA

// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CToolTipPage)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
    afx_msg void    OnNeedText(LPNMHDR pnmh, LRESULT *plr);
	// Generated message map functions
	//{{AFX_MSG(CToolTipPage)
	virtual BOOL OnInitDialog();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\tools\uni\minidev\gpdview.cpp ===
/******************************************************************************

  Source File:  GPD Viewer.CPP

  This file implements the GPD viewing/editing class.

  Copyright (c) 1997 by Microsoft Corporation.  All Rights Reserved.

  A Pretty Penny Enterprises Production.

  Change History:
  03-24-1997    Bob_Kjelgaard@Prodigy.Net   Created it

******************************************************************************/

#include    "StdAfx.H"
#include    <ProjNode.H>
#include    "ModlData\Resource.H"
#include    <GPDFile.H>
#include    "GPDView.H"
#include    "Resource.H"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/******************************************************************************

  CGPDViewer class

  This class implements the GPD viewer.

******************************************************************************/

/******************************************************************************

  CGPDViewer::MarkError

  This private member highlights the given line in the error display.

******************************************************************************/

void    CGPDViewer::MarkError(unsigned u) {
    CWnd    *pcwndErrors = m_cdbError.GetDlgItem(IDC_Errors);

    unsigned uStart = pcwndErrors -> SendMessage(EM_LINEINDEX, u, 0);

    if  (uStart == (unsigned) -1)
        return; //  Index requested is out of range
    unsigned uEnd = uStart + 
        pcwndErrors -> SendMessage(EM_LINELENGTH, uStart, 0);
    m_iLine = (int) u;
    pcwndErrors -> SendMessage(EM_SETSEL, uStart, uEnd);
    CString csError = GetDocument() -> ModelData() -> Error(u);
    m_csb.SetPaneText(0, csError);
    SetFocus();
    //  If the string starts with the GPD name, scroll to the line
    if  (!csError.Find(GetDocument() -> ModelData() -> Name()) &&
         0 < csError.Mid(3 + 
         GetDocument() -> ModelData() -> Name().GetLength()).Find(_T('('))) {
        //  Extract the line number, and bop on down to it!
        csError = csError.Mid(3 + GetDocument() -> ModelData() -> 
            Name().GetLength());
        int iLine = atoi(csError.Mid(1 + csError.Find(_T('('))));
        GetRichEditCtrl().SetSel(GetRichEditCtrl().LineIndex(-1 + iLine), 
            GetRichEditCtrl().LineIndex(-1 + iLine));
        GetRichEditCtrl().LineScroll(iLine  - (7 +
            GetRichEditCtrl().GetFirstVisibleLine()));
    }
    pcwndErrors -> SendMessage(WM_HSCROLL, SB_TOP, NULL);
}

/******************************************************************************

  CGPDViewer::FillErrorBar

  This fills the error dialog bar with the current set if errors, if there are
  any...

******************************************************************************/

void    CGPDViewer::FillErrorBar() {
    CModelData& cmd = *GetDocument() -> ModelData();
    if  (cmd.HasErrors()) {
        m_cdbError.Create(GetParentFrame(), IDD_GPDErrors, CBRS_BOTTOM, 
            IDD_GPDErrors);
        GetParentFrame() -> RecalcLayout();

        //  Make a big string out of all of the messages and insert it into the
        //  rich edit control.

        CString csErrors;

        for (unsigned u = 0; u < cmd.Errors(); u++)
            csErrors += cmd.Error(u) + _TEXT("\r\n");

        m_cdbError.SetDlgItemText(IDC_Errors, csErrors);
        MarkError(0);
        SetFocus();
    }
    else {
        CString csWork;
        csWork.LoadString(IDS_NoSyntaxErrors);
        m_csb.SetPaneText(0, csWork);
    }
}

/******************************************************************************

  CGPDViewer::Color

  This private member syntax colors the rich edit controls contents using the
  information gleaned from the GPD file's analysis.

******************************************************************************/

void    CGPDViewer::Color() {
    CHARRANGE   crCurrentSel;
    CHARFORMAT  cf;
    CModelData& cmd = *(GetDocument() -> ModelData());
    CRichEditCtrl&  crec = GetRichEditCtrl();
    m_bInColor = TRUE;


    //  Turn off change and selection notification messages
    crec.SetEventMask(GetRichEditCtrl().GetEventMask() & 
        ~(ENM_CHANGE | ENM_SELCHANGE | ENM_SCROLLEVENTS));

    crec.GetSel(crCurrentSel);
    crec.GetDefaultCharFormat(cf);
    cf.dwEffects &= ~CFE_AUTOCOLOR;
    cf.dwMask |= CFM_COLOR;

    //  Color each visible line as it was classsified visibility is
    //  determined by checking the character bounds against the client
    //  rectangle for the control.
    
    int iTop = m_iTopLineColored = crec.GetFirstVisibleLine();
    int i    = iTop;
    int iLineHeight = crec.GetCharPos(crec.LineIndex(i+1)).y - 
        crec.GetCharPos(crec.LineIndex(i)).y;

    CRect   crEdit;
    crec.GetClientRect(crEdit);
    crec.LockWindowUpdate();    //  Don't let this show until done!
    crec.HideSelection(TRUE, TRUE);

    do {
        cf.crTextColor = LineColor(i);
        crec.SetSel(crec.LineIndex(i), crec.LineIndex(i) + 
            crec.LineLength(crec.LineIndex(i)));
        crec.SetSelectionCharFormat(cf);
    }
    while   (++i < cmd.LineCount() && 
        crec.GetCharPos(crec.LineIndex(i)).y + iLineHeight < 
        crEdit.bottom - 1);

    //  Restore the original position of the cursor, and then the original
    //  line (in case the cursor is no longer on this page).
    
    crec.SetSel(crCurrentSel);
    crec.LineScroll(iTop - crec.GetFirstVisibleLine());  
    crec.HideSelection(FALSE, TRUE);
    crec.UnlockWindowUpdate();    //  Let it shine!

    //  Restore the notification mask
    crec.SetEventMask(GetRichEditCtrl().GetEventMask() | 
        ENM_CHANGE | ENM_SELCHANGE | ENM_SCROLLEVENTS);
    if  (m_bStart)
        FillErrorBar();
    m_bInColor = FALSE;
}


/******************************************************************************

  CGPDViewer::LineColor

  This determines what color to make a line.  It is copmplicated a bit by the
  fact that the Rich Edit control gives false values for line length on long
  files.  Probably some 64K thing, but I sure can't fix it.

******************************************************************************/

unsigned    CGPDViewer::LineColor(int i) {

    CByteArray  cba;
    CRichEditCtrl&  crec = GetRichEditCtrl();

    cba.SetSize(max(crec.LineLength(i) + sizeof (unsigned), 100));
    CString csLine((LPCTSTR) cba.GetData(), 
        crec.GetLine(i, (LPSTR) cba.GetData(), 
            cba.GetSize() - sizeof (unsigned)));

    if  (csLine.Find(_T("*%")) == -1)
        return  RGB(0, 0, 0);

    //  Errors

    if  (csLine.Find(_T("Error:")) > csLine.Find(_T("*%")))
        return  RGB(0x80, 0, 0);

    //  Warnings

    if  (csLine.Find(_T("Warning:")) > csLine.Find(_T("*%")))
        return  RGB(0x80, 0x80, 0);

    return  RGB(0, 0x80, 0);
}

/******************************************************************************

  CGPDViewer::UpdateNow

  This private member updates the underlying GPD and marks the document as
  changed, and the edit control as unmodified.  It is called whenever this
  needs to be done.

*******************************************************************************/

void    CGPDViewer::UpdateNow() {
    
    //  Don't do this if nothing's chenged...
    if  (!GetRichEditCtrl().GetModify())
        return;

    CWaitCursor cwc;    //  Just in case

    if  (m_uTimer)
        KillTimer(m_uTimer);
    m_uTimer = 0;

    GetDocument() -> ModelData() -> UpdateFrom(GetRichEditCtrl());
    GetDocument() -> SetModifiedFlag();
    GetRichEditCtrl().SetModify(FALSE);
}

IMPLEMENT_DYNCREATE(CGPDViewer, CRichEditView)

CGPDViewer::CGPDViewer() {
    m_iLine = m_uTimer = 0;
    m_bInColor = FALSE;
    m_bStart = TRUE;
    m_iTopLineColored = -1;
}

CGPDViewer::~CGPDViewer() {
}

BEGIN_MESSAGE_MAP(CGPDViewer, CRichEditView)
	//{{AFX_MSG_MAP(CGPDViewer)
	ON_WM_DESTROY()
	ON_COMMAND(ID_FILE_PARSE, OnFileParse)
	ON_CONTROL_REFLECT(EN_CHANGE, OnChange)
	ON_WM_TIMER()
	ON_CONTROL_REFLECT(EN_VSCROLL, OnVscroll)
	ON_WM_VSCROLL()
	ON_COMMAND(ID_FILE_SAVE, OnFileSave)
	ON_COMMAND(ID_FILE_SAVE_AS, OnFileSaveAs)
	ON_UPDATE_COMMAND_UI(ID_EDIT_PASTE, OnUpdateEditPaste)
	ON_UPDATE_COMMAND_UI(ID_EDIT_UNDO, OnUpdateEditUndo)
	//}}AFX_MSG_MAP
    ON_UPDATE_COMMAND_UI(IDC_Next, OnUpdateNext)
    ON_UPDATE_COMMAND_UI(IDC_Previous, OnUpdatePrevious)
    ON_COMMAND(IDC_RemoveError, OnRemoveError)
    ON_COMMAND(IDC_Next, OnNext)
    ON_COMMAND(IDC_Previous, OnPrevious)
    ON_NOTIFY_REFLECT(EN_SELCHANGE, OnSelChange)
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CGPDViewer diagnostics

#ifdef _DEBUG
void CGPDViewer::AssertValid() const {
	CRichEditView::AssertValid();
}

void CGPDViewer::Dump(CDumpContext& dc) const {
	CRichEditView::Dump(dc);
}

#endif //_DEBUG

/******************************************************************************

  CGPDViewer::OnDestroy

  Handles the required project node notification when the view is destroyed.
  A GP Fault is a terrible thing to signal.

******************************************************************************/

void CGPDViewer::OnDestroy() {
	CRichEditView::OnDestroy();
	
	if  (GetDocument() -> ModelData())
        GetDocument() -> ModelData() -> OnEditorDestroyed();
	
}

/******************************************************************************

  CGPDViewer::OnInitialUpdate

  This is the wake-up call.  We fill the view from the GPD's contents, and
  eventually color things to suit us.

******************************************************************************/

void CGPDViewer::OnInitialUpdate()  {
    GetParentFrame() -> ModifyStyle(0, WS_OVERLAPPEDWINDOW);
	CRichEditView::OnInitialUpdate();
    
    if  (m_csb.Create(GetParentFrame())) {
        static UINT auid[] = {ID_SEPARATOR, ID_LineIndicator};
        m_csb.SetIndicators(auid, 2);
        m_csb.SetPaneInfo(1, ID_LineIndicator, SBPS_NORMAL, 200);
        GetParentFrame() -> RecalcLayout();
    }

    //  We don't want EN_CHANGE messages while we load the control
    GetRichEditCtrl().SetEventMask(GetRichEditCtrl().GetEventMask() & 
        ~ENM_CHANGE);
    //  We also do not want the control to wrap lines for us, as it messes up
    //  syntax coloring
    m_nWordWrap = WrapNone;
    WrapChanged();
	GetDocument() -> ModelData() -> Fill(GetRichEditCtrl());
    SetFocus();
    //  We want EN_CHANGE messages now, so we can update the cache
    GetRichEditCtrl().SetEventMask(GetRichEditCtrl().GetEventMask() | 
        ENM_CHANGE);
    m_uTimer = SetTimer((UINT) this, 500, NULL);
    
    GetRichEditCtrl().SetSel(1, 1); //  Have to change the selection!
    GetRichEditCtrl().SetSel(0, 0);
}

/******************************************************************************

  CGPDViewer::OnUpdateNext

  Handles the proper enabling and disabling of the Next Error button

******************************************************************************/

void    CGPDViewer::OnUpdateNext(CCmdUI *pccu) {
    pccu -> Enable((unsigned) m_iLine < -1 +
        GetDocument() -> ModelData() -> Errors());
}

/******************************************************************************

  CGPDViewer::OnUpdatePrevious

  Handles the proper enabling and disabling of the previous error button

******************************************************************************/

void    CGPDViewer::OnUpdatePrevious(CCmdUI *pccu) {
    pccu -> Enable(m_iLine);
}

/******************************************************************************

  CGPDViewer::OnRemoveError

  This handles the "Remove Error" button.  The line is removed from the edit
  control and the log in the model data.

******************************************************************************/

void    CGPDViewer::OnRemoveError() {

    CModelData& cmd = *GetDocument() -> ModelData();
    cmd.RemoveError((unsigned) m_iLine);
    
    if  (!cmd.HasErrors()) {
        m_cdbError.DestroyWindow();
        GetParentFrame() -> RecalcLayout();
        SetFocus();
        return;
    }

    CString csError;

    for (unsigned u = 0; u < cmd.Errors(); u++)
        csError += cmd.Error(u) + _TEXT("\r\n");

    m_cdbError.SetDlgItemText(IDC_Errors, csError);

    MarkError(m_iLine - ((unsigned) m_iLine == cmd.Errors()));
}

/******************************************************************************

  CGPDViewer::OnNext

  This handles the "Next" button by highlighting the next error.

******************************************************************************/

void    CGPDViewer::OnNext() {
    MarkError((unsigned) m_iLine + 1);
}

/******************************************************************************

  CGPDViewer::OnPrevious

  This marks the previous error in the list

******************************************************************************/

void    CGPDViewer::OnPrevious() {
    MarkError((unsigned) m_iLine - 1);
}

/******************************************************************************

  CGPDViewer::OnFileParse

  Syntax check the GPD file, and show us the results

******************************************************************************/

void CGPDViewer::OnFileParse() {
    CWaitCursor cwc;

    if  (GetDocument() -> ModelData() -> HasErrors()) {
        m_cdbError.DestroyWindow();
        GetParentFrame() -> RecalcLayout();
    }

    //  Save any changes made to the file.

    if  (GetRichEditCtrl().GetModify() || GetDocument() -> IsModified()) {
        UpdateNow();    //  Pick up any new changes
        GetDocument() -> ModelData() -> Store();
        GetDocument() -> SetModifiedFlag(FALSE);
    }

	if  (!GetDocument() -> ModelData() -> Parse())
        AfxMessageBox("Unusual and Fatal Error:  Syntax Checker failed!");

    FillErrorBar();
    MessageBeep(MB_ICONASTERISK);
}

/******************************************************************************

  CGPDViewer::OnChange

  This gets called whenever a change is made to the contents of the file.
  The coloring (now done only on the visible page) is updated, and the 
  appropriate flags are set.  To keep performance smooth, the document is no
  longer updated as a result of this message.

******************************************************************************/

void CGPDViewer::OnChange() {
	//  Since this is a RICHEDIT control, I override the 
    //  CRichEditView::OnInitialUpdate() function to or the ENM_CHANGE flag 
    //  into the control's event mask.  Otherwise this message wouldn't be
    //  sent
	
	//  To avoid thrashing the GPD contents unneedfully, we wait for 1 second 
    //  of inactivity before bashing the changes into the GPD.
    GetDocument() -> SetModifiedFlag();

    if  (!m_bInColor)
        Color();
}

/******************************************************************************

  CGPDViewer::OnTimer

  This handles the timeout of the timer used to batch changes into the
  underlying document.  If this isn't for that timer, we pass it on to the base
  class.

******************************************************************************/

void CGPDViewer::OnTimer(UINT uEvent) {

	// If this isn't our timer, let the base class do what it will with it.
	
    if  (m_uTimer == uEvent)
        if  (m_bStart) {
            if  (GetRichEditCtrl().GetLineCount() < 
                GetDocument() -> ModelData() -> LineCount())
                return; //  The rich edit control isn't ready, yet...
            KillTimer(m_uTimer);
            Color();
            m_uTimer = 0;
            m_bStart = FALSE;
        }
        else
            UpdateNow();
    else
	    CRichEditView::OnTimer(uEvent);
}

/******************************************************************************

  CGPDViewer::OnSelChange

  This handles the message sent by the control when the selection changes.  I'm
  hoping this means whenever the caret moves, since the selection, while empty,
  has changed.

******************************************************************************/

void    CGPDViewer::OnSelChange(LPNMHDR pnmh, LRESULT *plr) {
    SELCHANGE*  psc = (SELCHANGE *) pnmh;

    long    lLine = GetRichEditCtrl().LineFromChar(psc -> chrg.cpMax);

    CString csWork;

    csWork.Format(_T("Line %d, Column %d"), lLine + 1,
         1 + psc -> chrg.cpMax - GetRichEditCtrl().LineIndex(lLine));

    m_csb.SetPaneText(1, csWork);
}

/******************************************************************************

  CGPDViewer::OnUpdate

  If the first update hasn't been made, do nothing.  Otherwise, redo the error
  bar, because someone just syntax checked the workspace.

******************************************************************************/
       
void    CGPDViewer::OnUpdate(CView* pSender, LPARAM lHint, CObject* pHint) {
    if  (m_bStart) //  Have we already done the first update?
        return;

    //  If there's a dialog bar, can it, and refill as needed
    if  (m_cdbError.GetSafeHwnd()) {
        m_cdbError.DestroyWindow();
        GetParentFrame() -> RecalcLayout();
    }

    FillErrorBar();
}

/******************************************************************************

  CGPDViewer::QueryAcceptData

  Override the Rich Edit Control default behavior, because we (a) don't have
  an associated RichEditDoc, and (b) we don't want to paste anything but text.
  Not even rich text, because we control the formatting, and don't want to
  paste it.

******************************************************************************/

HRESULT CGPDViewer::QueryAcceptData(LPDATAOBJECT lpdo, CLIPFORMAT* lpcf, DWORD,
                                    BOOL bReally, HGLOBAL hgMetaFile) {
	_ASSERTE(lpcf != NULL);

	COleDataObject codo;
	codo.Attach(lpdo, FALSE);
	// if format is 0, then force particular formats if available
	if (*lpcf == 0 && (m_nPasteType == 0)&& codo.IsDataAvailable(CF_TEXT)) {
	    *lpcf = CF_TEXT;
		return S_OK;
	}
	return E_FAIL;
}

/******************************************************************************

  CGPDViewer::OnVScroll()

  This function is called when EN_VSCROLL messages are refelected from the 
  edit control.  As long as we are not coloring, we color the new page.  The
  documentation says this message comes BEFORE the scolling occurs, but it
  obviously occurs afterwards.

******************************************************************************/

void    CGPDViewer::OnVscroll() {
    //  Even though we turn scroll notifications off in the color routine,
    //  we still get them, so use a flag to keep from recursive death.

    if  (m_iTopLineColored != GetRichEditCtrl().GetFirstVisibleLine() &&
        !m_bInColor)
        Color();
}

/******************************************************************************

  CGPDViewer::OnVScroll(UINT uCode, UINT uPosition, CScrollBar *pcsb)

  This is called whwnever the scoll bar gets clicked.  This may seem
  redundant, but EN_VSCROLL messages don't get sent when the thumb itself is
  moved with the mouse, and WM_VSCROLL doesn't get sent when the keyboard
  interface is used.  So you get to lose either way.

  This control is buggy as can be, IMHO.  Next time I want to do text editing,
  I'll use a third party tool.  They starve if they don't get it right.

******************************************************************************/

void CGPDViewer::OnVScroll(UINT uCode, UINT uPosition, CScrollBar* pcsb) {
	CRichEditView::OnVScroll(uCode, uPosition, pcsb);
    OnVscroll();
}

/******************************************************************************

  CGPDViewer::OnFileSave
  CGPDViewer::OnFileSaveAs

  Since we don't update the document as changes are made in the editor, we have
  to intercept these, update the document, and then pass these on to the 
  document.

******************************************************************************/

void CGPDViewer::OnFileSave() {
	UpdateNow();
    GetDocument() -> OnFileSave();
}

void CGPDViewer::OnFileSaveAs() {
	UpdateNow();
    GetDocument() -> OnFileSaveAs();
}

/******************************************************************************

  CGPDViewer::OnUpdateEditPaste
  CGPDViewer::OnUpdateEditUndo

  These override the default processing for these menu items.  Undo isn't
  possible, because of the syntax coloring.  Paste is only possible with a text 
  format.

*******************************************************************************/

void CGPDViewer::OnUpdateEditPaste(CCmdUI* pccui) {
	pccui -> Enable(IsClipboardFormatAvailable(CF_TEXT));	
}

void CGPDViewer::OnUpdateEditUndo(CCmdUI* pccui) {
	pccui -> Enable(FALSE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\tools\uni\minidev\mainfrm.cpp ===
/******************************************************************************

  Source File:  Main Frame.CPP

  This implements the main frame class for the application.  Since MFC does
  so much for us, this file's going to be pretty empty, for a while, at least.

  Copyright (c) 1997 by Microsoft Corporaiton.  All Rights Reserved.

  A Pretty Penny Enterprises Production

  Change History:
  02-03-1997    Bob_Kjelgaard@Prodigy.Net   Created it

******************************************************************************/

#include    "StdAfx.h"
#if defined(LONG_NAMES)
#include    "MiniDriver Developer Studio.H"

#include    "Main Frame.h"
#else
#include    "MiniDev.H"
#include    "MainFrm.H"
#endif

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CMainFrame

IMPLEMENT_DYNAMIC(CMainFrame, CMDIFrameWnd)

BEGIN_MESSAGE_MAP(CMainFrame, CMDIFrameWnd)
	ON_WM_INITMENU()
	//{{AFX_MSG_MAP(CMainFrame)
	ON_WM_CREATE()
	ON_WM_DESTROY()
	//}}AFX_MSG_MAP
	// Global help commands
	ON_COMMAND(ID_HELP_FINDER, CMDIFrameWnd::OnHelpFinder)
	ON_COMMAND(ID_HELP, CMDIFrameWnd::OnHelp)
	ON_COMMAND(ID_CONTEXT_HELP, CMDIFrameWnd::OnContextHelp)
	ON_COMMAND(ID_DEFAULT_HELP, CMDIFrameWnd::OnHelpFinder)
END_MESSAGE_MAP()

static UINT indicators[] = {
	ID_SEPARATOR,           // status line indicator
	ID_INDICATOR_CAPS,
	ID_INDICATOR_NUM,
	ID_INDICATOR_SCRL,
};

/////////////////////////////////////////////////////////////////////////////
// CMainFrame construction/destruction

CMainFrame::CMainFrame() {
	// TODO: add member initialization code here
	
}

CMainFrame::~CMainFrame() {
}

static TCHAR    sacToolBarSettings[] = _TEXT("Tool Bar Settings");

/******************************************************************************

  CMainFrame::OnCreate

  This is a standard App-Wizard supplied skeleton for the code to be called
  when the main window frame is created.  Primary modification made to date is
  the addition of an additional toolbar, and toolbar state restoration.

******************************************************************************/

int CMainFrame::OnCreate(LPCREATESTRUCT lpCreateStruct) {
	if (CMDIFrameWnd::OnCreate(lpCreateStruct) == -1)
		return -1;
	
	if (!m_ctbMain.Create(this) || !m_ctbBuild.Create(this, WS_CHILD |
        WS_VISIBLE | CBRS_TOP, AFX_IDW_TOOLBAR + 1) ||
		!m_ctbMain.LoadToolBar(IDR_MAINFRAME) || 
        !m_ctbBuild.LoadToolBar(IDR_GPD_VIEWER)) {
		TRACE0("Failed to create toolbars\n");
		return -1;      // fail to create
	}

	if (!m_wndStatusBar.Create(this) ||
		!m_wndStatusBar.SetIndicators(indicators,
		  sizeof(indicators)/sizeof(UINT))) {
		TRACE0("Failed to create status bar\n");
		return -1;      // fail to create
	}

	m_ctbMain.SetBarStyle(m_ctbMain.GetBarStyle() |
		CBRS_TOOLTIPS | CBRS_FLYBY | CBRS_SIZE_DYNAMIC);
    m_ctbBuild.SetBarStyle(m_ctbBuild.GetBarStyle() |
        CBRS_TOOLTIPS | CBRS_FLYBY | CBRS_SIZE_DYNAMIC);

	// Dock the tool bars
	m_ctbMain.EnableDocking(CBRS_ALIGN_ANY);
    m_ctbBuild.EnableDocking(CBRS_ALIGN_ANY);
	EnableDocking(CBRS_ALIGN_ANY);
	DockControlBar(&m_ctbMain);
    DockControlBar(&m_ctbBuild);
    LoadBarState(sacToolBarSettings);

	return 0;
}

BOOL CMainFrame::PreCreateWindow(CREATESTRUCT& cs) {
	// TODO: Modify the Window class or styles here by modifying
	//  the CREATESTRUCT cs

	return CMDIFrameWnd::PreCreateWindow(cs);
}

/////////////////////////////////////////////////////////////////////////////
// CMainFrame diagnostics

#ifdef _DEBUG
void CMainFrame::AssertValid() const {
	CMDIFrameWnd::AssertValid();
}

void CMainFrame::Dump(CDumpContext& dc) const {
	CMDIFrameWnd::Dump(dc);
}

#endif //_DEBUG

/////////////////////////////////////////////////////////////////////////////
// CMainFrame message handlers

void CMainFrame::OnInitMenu(CMenu* pMenu)
{
   CMDIFrameWnd::OnInitMenu(pMenu);

#if defined(NOPOLLO)   //  CSRUS
  
	// CG: This block added by 'Tip of the Day' component.
	{
		// TODO: This code adds the "Tip of the Day" menu item
		// on the fly.  It may be removed after adding the menu
		// item to all applicable menu items using the resource
		// editor.

		// Add Tip of the Day menu item on the fly!
		static CMenu* pSubMenu = NULL;

		CString strHelp; strHelp.LoadString(CG_IDS_TIPOFTHEDAYHELP);
		CString strMenu;
		int nMenuCount = pMenu->GetMenuItemCount();
		BOOL bFound = FALSE;
		for (int i=0; i < nMenuCount; i++) 
		{
			pMenu->GetMenuString(i, strMenu, MF_BYPOSITION);
			if (strMenu == strHelp)
			{ 
				pSubMenu = pMenu->GetSubMenu(i);
				bFound = TRUE;
				ASSERT(pSubMenu != NULL);
			}
		}

		CString strTipMenu;
		strTipMenu.LoadString(CG_IDS_TIPOFTHEDAYMENU);
		if (!bFound)
		{
			// Help menu is not available. Please add it!
			if (pSubMenu == NULL) 
			{
				// The same pop-up menu is shared between mainfrm and frame 
				// with the doc.
				static CMenu popUpMenu;
				pSubMenu = &popUpMenu;
				pSubMenu->CreatePopupMenu();
				pSubMenu->InsertMenu(0, MF_STRING|MF_BYPOSITION, 
					CG_IDS_TIPOFTHEDAY, strTipMenu);
			} 
			pMenu->AppendMenu(MF_STRING|MF_BYPOSITION|MF_ENABLED|MF_POPUP, 
				(UINT)pSubMenu->m_hMenu, strHelp);
			DrawMenuBar();
		} 
		else
		{      
			// Check to see if the Tip of the Day menu has already been added.
			pSubMenu->GetMenuString(0, strMenu, MF_BYPOSITION);

			if (strMenu != strTipMenu) 
			{
				// Tip of the Day submenu has not been added to the 
				// first position, so add it.
				pSubMenu->InsertMenu(0, MF_BYPOSITION);  // Separator
				pSubMenu->InsertMenu(0, MF_STRING|MF_BYPOSITION, 
					CG_IDS_TIPOFTHEDAY, strTipMenu);
			}
		}
	}
#endif
}

/******************************************************************************

  CMainFrame::OnDestroy

  This member function. called when the frame is to be destroyed, saves the
  toolbar states, before proceeding to do the normal kinds of stuff...

******************************************************************************/

void CMainFrame::OnDestroy() {

    //  Save the tool bar states.
    SaveBarState(sacToolBarSettings);

    CMDIFrameWnd::OnDestroy();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\tools\uni\minidev\gpdview.h ===
/******************************************************************************

  Header File:  GPD Viewer.H

  This defines the class which implements the GPD viewer / editor.  Looks
  pretty painless for the nonce.

  Copyright (c) 1997 by Microsoft Corporation.  All Rights Reserved.

  A Pretty Penny Enterprises Production

  Change History:
  03/24/1997    Bob_Kjelgaard@Prodigy.Net   Created it

******************************************************************************/

#if !defined(AFX_GPDVIEWER_H__1BDEA163_A492_11D0_9505_444553540000__INCLUDED_)
#define AFX_GPDVIEWER_H__1BDEA163_A492_11D0_9505_444553540000__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

class CGPDViewer : public CRichEditView {
    int         m_iLine, m_iTopLineColored; //  Used for work items
    UINT        m_uTimer;
    CDialogBar  m_cdbError;
    CStatusBar  m_csb;
    CFindReplaceDialog  m_cfrd;
    BOOL        m_bInColor, m_bStart;       //  Flags to avoid recursion

    void        MarkError(unsigned u);
    void        FillErrorBar();
    void        UpdateNow();
    void        Color();
    unsigned    LineColor(int i);

protected: // create from serialization only
	CGPDViewer();
	DECLARE_DYNCREATE(CGPDViewer)

// Attributes
public:
    CGPDContainer*  GetDocument() { return (CGPDContainer *) m_pDocument; }

// Operations
public:

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CGPDViewer)
	public:
	virtual void OnInitialUpdate();
	protected:
	virtual void OnUpdate(CView* pSender, LPARAM lHint, CObject* pHint);
	//}}AFX_VIRTUAL
    virtual HRESULT QueryAcceptData(LPDATAOBJECT lpdo, CLIPFORMAT FAR *pcf,
        DWORD dwUnused, BOOL bReally, HGLOBAL hgMetaFile);

// Implementation
public:
	virtual ~CGPDViewer();
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif

protected:
    afx_msg void    OnUpdateNext(CCmdUI *pccu);
    afx_msg void    OnUpdatePrevious(CCmdUI *pccu);
    afx_msg void    OnRemoveError();
    afx_msg void    OnNext();
    afx_msg void    OnPrevious();
    afx_msg void    OnSelChange(LPNMHDR pnmh, LRESULT *plr);
      
	// Generated message map functions
	//{{AFX_MSG(CGPDViewer)
	afx_msg void OnDestroy();
	afx_msg void OnFileParse();
	afx_msg void OnChange();
	afx_msg void OnTimer(UINT nIDEvent);
	afx_msg void OnVscroll();
	afx_msg void OnVScroll(UINT nSBCode, UINT nPos, CScrollBar* pScrollBar);
	afx_msg void OnFileSave();
	afx_msg void OnFileSaveAs();
	afx_msg void OnUpdateEditPaste(CCmdUI* pCmdUI);
	afx_msg void OnUpdateEditUndo(CCmdUI* pCmdUI);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_GPDVIEWER_H__1BDEA163_A492_11D0_9505_444553540000__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\tools\uni\minidev\mainfrm.h ===
/******************************************************************************

  Header File:  Main Frame.H

  This defines the class which handles the application's main window's frame.
  It will begin life, at the least, as a standaard MFC App Wizard creation.

  Copyright (c) 1997 by Microsoft Corporation.  All Rights Reserved.

  A Pretty Penny Enterprises Production.

  Change History:
  03-04-2997    Bob_Kjelgaard@Prodigy.Net   Created it

******************************************************************************/

class CMainFrame : public CMDIFrameWnd {
	DECLARE_DYNAMIC(CMainFrame)
public:
	CMainFrame();

// Attributes
public:

// Operations
public:

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CMainFrame)
	virtual BOOL PreCreateWindow(CREATESTRUCT& cs);
	//}}AFX_VIRTUAL

// Implementation
public:
	virtual ~CMainFrame();
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif

protected:  // control bar embedded members
	afx_msg void OnInitMenu(CMenu* pMenu);
	CStatusBar  m_wndStatusBar;
	CToolBar    m_ctbMain, m_ctbBuild;

// Generated message map functions
protected:
	//{{AFX_MSG(CMainFrame)
	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
	afx_msg void OnDestroy();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\tools\uni\minidev\gttview.cpp ===
/******************************************************************************

  Source File:  Glyph Map View.CPP

  This file implements the items that make up the glyph mapping editor

  Copyright (c) 1997 by Microsoft Corporation.  All Rights Reserved.

  A Pretty Penny Enterprises Production

  Change History:
  02-20-1997    Bob_Kjelgaard@Prodigy.Net   Created it.

******************************************************************************/

#include    "StdAfx.H"
#include    "MiniDev.H"
#include    "GTT.H"
#include    "ChildFrm.H"
#include    "GTTView.H"
#include    "ModlData\Resource.H"
#include    "NewProj.H"
#include    <CodePage.H>
#include    "AddCdPt.H"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/******************************************************************************

  CGlyphMapView class implementation

  This is the view class for glyph translation tables.  It presents a property
  sheet for display of all of the relevant items in the glyph map.

******************************************************************************/

IMPLEMENT_DYNCREATE(CGlyphMapView, CView)

CGlyphMapView::CGlyphMapView() {
}

CGlyphMapView::~CGlyphMapView() {
}

BEGIN_MESSAGE_MAP(CGlyphMapView, CView)
	//{{AFX_MSG_MAP(CGlyphMapView)
	ON_WM_DESTROY()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/******************************************************************************

  CGlyphMapView::OnInitialUpdate

  This member function is an override which handles the initial call to display
  the view.  It creates the property sheet, positions it within the view, then
  sets the frame size to match.

******************************************************************************/

void CGlyphMapView::OnInitialUpdate() {

    if  (GetDocument() -> GlyphMap() -> Name().IsEmpty()) {
        GetDocument() -> GlyphMap() -> Rename(GetDocument() -> GetTitle());
        GetDocument() -> SetModifiedFlag(FALSE);    //  Rename sets it
    }

    m_cps.Construct(IDR_MAINFRAME, this);
    m_cgmp.Init(GetDocument() -> GlyphMap());
    m_ccpp.Init(GetDocument() -> GlyphMap());
    m_cpm.Init(GetDocument() -> GlyphMap());
    m_cps.AddPage(&m_cgmp);
    m_cps.AddPage(&m_ccpp);
#if defined(NOPOLLO)    //  RAID 106376
    m_cps.AddPage(&m_cpm);
#endif
    
    m_cps.Create(this, WS_CHILD, WS_EX_CLIENTEDGE);

    CRect   crPropertySheet;
    m_cps.GetWindowRect(crPropertySheet);

	crPropertySheet -= crPropertySheet.TopLeft();
    m_cps.MoveWindow(crPropertySheet, FALSE);
    GetParentFrame() -> CalcWindowRect(crPropertySheet);
    GetParentFrame() -> SetWindowPos(NULL, 0, 0, crPropertySheet.Width(),
        crPropertySheet.Height(), 
        SWP_NOZORDER | SWP_NOMOVE | SWP_NOOWNERZORDER | SWP_NOACTIVATE);
	CView::OnInitialUpdate();
    m_cps.ShowWindow(SW_SHOWNA);
    GetParentFrame() -> ShowWindow(SW_SHOW);
}

void CGlyphMapView::OnDraw(CDC* pDC) {
	CDocument* pDoc = GetDocument();
	// TODO: add draw code here
}

/////////////////////////////////////////////////////////////////////////////
// CGlyphMapView diagnostics

#ifdef _DEBUG
void CGlyphMapView::AssertValid() const {
	CView::AssertValid();
}

void CGlyphMapView::Dump(CDumpContext& dc) const {
	CView::Dump(dc);
}
#endif //_DEBUG

/////////////////////////////////////////////////////////////////////////////
// CGlyphMapView message handlers

void CGlyphMapView::OnDestroy() {
	CView::OnDestroy();
	
	if  (GetDocument() -> GlyphMap())
        GetDocument() -> GlyphMap() -> OnEditorDestroyed();
	
}

/******************************************************************************

  CGlyphMapView::OnActivateView

  For some reason, the property sheet does not get the focus when the frame is
  activated (probably the view class takes it away from us).  This member 
  function guarantees keyboard afficionados aren't perturbed by this.

******************************************************************************/

void CGlyphMapView::OnActivateView(BOOL bActivate, CView* pActivateView, 
                                   CView* pDeactiveView) {

	CView::OnActivateView(bActivate, pActivateView, pDeactiveView);

    if  (bActivate)
        m_cps.SetFocus();
}

/******************************************************************************

  CGlyphMappingPage class

  This class implements the property page for viewing and editing the gory code
  point-by-code point details.

******************************************************************************/

//  Even before the constructor, we have the list sorting routine
int CALLBACK    CGlyphMappingPage::MapSorter(LPARAM lp1, LPARAM lp2, 
                                             LPARAM lpThis) {
    //  A negative return means the first is less...

    //  First, let's uncast those LPARAMs
    CGlyphMappingPage   *pcgmp = (CGlyphMappingPage *) lpThis;
    CGlyphHandle *pcgh1 = (CGlyphHandle*) lp1;
    CGlyphHandle *pcgh2 = (CGlyphHandle*) lp2;

    //  We'll use 3 columns to store the sort possibilities.
    int aiResult[Columns];
    aiResult[Codes] = pcgh1 -> CodePoint() - pcgh2 -> CodePoint();
    aiResult[Pages] = pcgh1 -> CodePage() - pcgh2 -> CodePage();
    CString cs1, cs2;
    pcgh1 -> GetEncoding(cs1);
    pcgh2 -> GetEncoding(cs2);
    aiResult[Strings] = lstrcmp(cs1, cs2);

    if  (aiResult[pcgmp -> m_bSortFirst])
        return  pcgmp -> m_abDirection[pcgmp -> m_bSortFirst] ? 
        aiResult[pcgmp -> m_bSortFirst] : -aiResult[pcgmp -> m_bSortFirst];

    if  (aiResult[pcgmp -> m_bSortSecond])
        return  pcgmp -> m_abDirection[pcgmp -> m_bSortSecond] ? 
        aiResult[pcgmp -> m_bSortSecond] : -aiResult[pcgmp -> m_bSortSecond];

    return  pcgmp -> m_abDirection[pcgmp -> m_bSortLast] ? 
        aiResult[pcgmp -> m_bSortLast] : -aiResult[pcgmp -> m_bSortLast];
}

/******************************************************************************

  CGlyphMappingPage constructor

  As befits a class of this complexity, there's a bit of work to do here.

******************************************************************************/

CGlyphMappingPage::CGlyphMappingPage() : 
    CPropertyPage(CGlyphMappingPage::IDD) {

    m_pcgm = NULL;
    for (unsigned u = 0; u < Columns; u++)
        m_abDirection[u] = TRUE;

    m_bSortFirst = Codes;
    m_bSortSecond = Strings;
    m_bSortLast = Pages;
    m_bJustChangedSelectString = FALSE;
    m_uTimer = m_uidGlyph = 0;

	//{{AFX_DATA_INIT(CGlyphMappingPage)
	//}}AFX_DATA_INIT
}

CGlyphMappingPage::~CGlyphMappingPage() {
}

void CGlyphMappingPage::DoDataExchange(CDataExchange* pDX) {
	CPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CGlyphMappingPage)
	DDX_Control(pDX, IDC_Banner, m_cpcBanner);
	DDX_Control(pDX, IDC_GlyphMapping, m_clcMap);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CGlyphMappingPage, CPropertyPage)
	//{{AFX_MSG_MAP(CGlyphMappingPage)
	ON_WM_CONTEXTMENU()
	ON_NOTIFY(LVN_ENDLABELEDIT, IDC_GlyphMapping, OnEndlabeleditGlyphMapping)
	ON_NOTIFY(LVN_ITEMCHANGED, IDC_GlyphMapping, OnItemchangedGlyphMapping)
	ON_NOTIFY(LVN_COLUMNCLICK, IDC_GlyphMapping, OnColumnclickGlyphMapping)
	ON_NOTIFY(LVN_GETDISPINFO, IDC_GlyphMapping, OnGetdispinfoGlyphMapping)
	ON_NOTIFY(LVN_KEYDOWN, IDC_GlyphMapping, OnKeydownGlyphMapping)
	ON_WM_TIMER()
	ON_WM_DESTROY()
	//}}AFX_MSG_MAP
    ON_COMMAND(ID_ChangeInvocation, OnChangeInvocation)
    ON_COMMAND(ID_ChangeCodePage, OnChangeCodePage)
    ON_COMMAND(ID_DeleteItem, OnDeleteItem)
    ON_COMMAND(ID_AddItem, OnAddItem)
END_MESSAGE_MAP()

/******************************************************************************

  CGlyphMappingPage::OnInitDialog

  This member intializes the controls on this page, which in this case means a
  list view with a sizeable numer of items.

******************************************************************************/

BOOL CGlyphMappingPage::OnInitDialog() {
	CPropertyPage::OnInitDialog();
	
	//  Initialize the list control
    CString csWork;

    csWork.LoadString(IDS_MapColumn0);
    m_clcMap.InsertColumn(0, csWork, LVCFMT_LEFT, 
        m_clcMap.GetStringWidth(csWork) * 2, 2);

    csWork.LoadString(IDS_MapColumn1);
    m_clcMap.InsertColumn(1, csWork, LVCFMT_LEFT, 
        m_clcMap.GetStringWidth(csWork) * 2, 1);

    csWork.LoadString(IDS_MapColumn2);
    m_clcMap.InsertColumn(2, csWork, LVCFMT_LEFT, 
        m_clcMap.GetStringWidth(csWork) * 2, 0);

    m_lPredefinedID = m_pcgm -> PredefinedID();

    //  Put up a message about the wait, then kick off a quick timer so the
    //  message is seen...

    m_uTimer = SetTimer(IDD, 10, NULL);

    if  (!m_uTimer) {
        CWaitCursor cwc;
        OnTimer(m_uTimer);
    }

	return TRUE;
}

/******************************************************************************

  CGlyphMappingPage::OnContextMenu

  This member function is called when a right-click with the mouse is detected.
  If it is within the area of the list view, we display an appropriate context
  menu.  Otherwise, we default to the normal system handling of the message.

******************************************************************************/

void CGlyphMappingPage::OnContextMenu(CWnd* pcw, CPoint cpt) {
	CPoint  cptThis = cpt;

    m_clcMap.ScreenToClient(&cptThis);

    //  Toss it out if it isn't within the view.

    CRect   crMap;
    m_clcMap.GetClientRect(crMap);
    if  (!crMap.PtInRect(cptThis))
        return;

    cptThis.x = 5;  //  Keep it well within the first column

    int idContext = m_clcMap.HitTest(cptThis);
    if  (idContext == -1) {   //  Nothing selected, allow the "Add" item
        CMenu   cmThis;
        CString csWork;

        cmThis.CreatePopupMenu();
        csWork.LoadString(ID_AddItem);
        cmThis.AppendMenu(MF_STRING | MF_ENABLED, ID_AddItem, csWork);
        cmThis.TrackPopupMenu(TPM_LEFTALIGN | TPM_RIGHTBUTTON, cpt.x, cpt.y, 
            this);

        return;
    }

    m_clcMap.SetItemState(idContext, LVIS_SELECTED | LVIS_FOCUSED, 
        LVIS_SELECTED | LVIS_FOCUSED);

    CMenu   cmThis;
    CString csWork;

    cmThis.CreatePopupMenu();
    csWork.LoadString(ID_ChangeInvocation);
    cmThis.AppendMenu(MF_STRING | MF_ENABLED, ID_ChangeInvocation,
        csWork);

    if  (m_pcgm -> CodePages() > 1) {
        csWork.LoadString(ID_ChangeCodePage);
        cmThis.AppendMenu(MF_STRING | MF_ENABLED, ID_ChangeCodePage,
            csWork);
    }

    cmThis.AppendMenu(MF_SEPARATOR);
    csWork.LoadString(ID_AddItem);
    cmThis.AppendMenu(MF_STRING | MF_ENABLED, ID_AddItem, csWork);
    csWork.LoadString(ID_DeleteItem);
    cmThis.AppendMenu(MF_STRING | MF_ENABLED, ID_DeleteItem,
        csWork);

    cmThis.TrackPopupMenu(TPM_LEFTALIGN | TPM_RIGHTBUTTON, cpt.x, cpt.y, this);
}

/******************************************************************************

  CGlyphMappingPage::OnChangeInvocation

  Called when the user decides to change the invocation for the code point.
  Simply initiate a label edit.

******************************************************************************/

void    CGlyphMappingPage::OnChangeInvocation() {
    int idContext = m_clcMap.GetNextItem(-1, 
        LVNI_ALL | LVNI_FOCUSED | LVNI_SELECTED);

    if  (idContext < 0 || idContext >= m_clcMap.GetItemCount())
        return;

    m_clcMap.EditLabel(idContext);
}

/******************************************************************************

  CGlyphMappingPage::OnChangeCodePage

  This handles a code page change request.

******************************************************************************/

void    CGlyphMappingPage::OnChangeCodePage() {

    int idContext = m_clcMap.GetNextItem(-1, 
        LVNI_ALL | LVNI_FOCUSED | LVNI_SELECTED);

    if  (idContext < 0 || idContext >= m_clcMap.GetItemCount())
        return;
    //  Create a string naming the item, and invoke the CSelectCodePage
    //  dialog...

    CGlyphHandle *pcgh = (CGlyphHandle*) m_clcMap.GetItemData(idContext);
    
    CSelectCodePage cscp(this, m_pcgm -> Name() + _TEXT(" ") + 
        m_clcMap.GetItemText(idContext, 1), 
        m_pcgm -> PageID(pcgh -> CodePage()));

    CDWordArray cdaPages;

    m_pcgm -> CodePages(cdaPages);
    cdaPages.RemoveAt(pcgh -> CodePage());

    cscp.LimitTo(cdaPages);

    if  (cscp.DoModal() != IDOK)
        return;

    //  Change the code page.   For maximum flexibility, we'll use an array
    //  for this.  This is because if this is to correct a perceived mistake,
    //  the codes should be translated to MBCS and then back.

    //  NOTE: This was also to support multiple selection, which isn't allowed.

    CPtrArray   cpaThis;
    cpaThis.Add((void *) m_clcMap.GetItemData(idContext));
    m_pcgm -> ChangeCodePage(cpaThis, cscp.SelectedCodePage());

    m_clcMap.SetItemText(idContext, 2, cscp.GetCodePageName());
}

/******************************************************************************

  CGlyphMappingPage::OnDeleteItem

  This handles the Delete Item message from the context menu, by verifying 
  this is what is wanted, and then doing it.

******************************************************************************/

void    CGlyphMappingPage::OnDeleteItem() {
    int idContext = m_clcMap.GetNextItem(-1, 
        LVNI_ALL | LVNI_FOCUSED | LVNI_SELECTED);

    if  (idContext < 0 || idContext >= m_clcMap.GetItemCount())
        return;

    if  (IDYES != AfxMessageBox(IDS_DeleteItemQuery, 
         MB_YESNO | MB_ICONQUESTION))
        return;

    //  Delete the entry from the glyph map
    CGlyphHandle*   pcgh = (CGlyphHandle*) m_clcMap.GetItemData(idContext);
    m_pcgm -> DeleteGlyph(pcgh -> CodePoint());

    m_clcMap.DeleteItem(idContext);
    _ASSERTE((unsigned) m_clcMap.GetItemCount() == m_pcgm -> Glyphs());
}

/******************************************************************************

  CGlyphMappingPage::OnAddItem

  This is called whenever the user wishes to add new code points to the map.  I
  ask the glyph map which points exist, and if there are any, invoke a modal
  dialog to allow the selection of new glyphs.

******************************************************************************/

void    CGlyphMappingPage::OnAddItem() {

    CMapWordToDWord cmw2dAvailable;

    m_pcgm -> UndefinedPoints(cmw2dAvailable);

    if  (!cmw2dAvailable.Count()) {
        AfxMessageBox(IDS_NoUnmappedGlyphs);
        return;
    }

    CDWordArray cdaPages;

    m_pcgm -> CodePages(cdaPages);

    CAddCodePoints  cacp(this, cmw2dAvailable, cdaPages, m_pcgm -> Name());

    if  (cacp.DoModal() != IDOK)    return;

    //  The map will now contain only the new code points...
    m_pcgm -> AddPoints(cmw2dAvailable);

    m_uTimer = SetTimer(IDD, 10, NULL);

    if  (!m_uTimer)
        OnTimer(m_uTimer);

    //  Reset the sort criteria so we don't have to sort the data
    for (unsigned u = 0; u < Columns; u++)
        m_abDirection[u] = TRUE;

    m_bSortFirst = Codes;
    m_bSortSecond = Strings;
    m_bSortLast = Pages;
}

/******************************************************************************

  CGlyphMappingPage::OnEndlabeleditGlyphMapping

  This is called when a user clicks outside the edit control to end editing of
  a selection string.  We pass the string down, and do some finagling to force
  the system to accept the value as we display it, which isn't as the user
  typed it, in some cases.

******************************************************************************/

void CGlyphMappingPage::OnEndlabeleditGlyphMapping(NMHDR* pnmh, LRESULT* plr) {
	LV_DISPINFO* plvdi = (LV_DISPINFO*) pnmh;

	// Pass the new invocation string to the glyph map to handle
    CGlyphHandle*   pcgh = (CGlyphHandle*) plvdi -> item.lParam;
    m_pcgm -> ChangeEncoding(pcgh -> CodePoint(), plvdi -> item.pszText);

    m_bJustChangedSelectString = TRUE;
	
	*plr = TRUE;
}

/******************************************************************************

  CGlyphMappingPage::OnItemchangedGlyphMapping

  This is called whenever anything changes in the list box- we are primarily
  interested in text changes (since we have to adjust encodings once entered)
  and selection changes (so we can move the "cursor" accordingly.

******************************************************************************/

void CGlyphMappingPage::OnItemchangedGlyphMapping(NMHDR* pnmh, LRESULT* plr) {
	NM_LISTVIEW* pnmlv = (NM_LISTVIEW*) pnmh;

    int idContext = m_clcMap.GetNextItem(-1, 
        LVNI_ALL | LVNI_FOCUSED | LVNI_SELECTED);

    //  We only care if this notes a text change in the selected item and we 
    //  haven't fixed it, yet.

    if  (pnmlv -> iItem != idContext || !(pnmlv -> uChanged & LVIF_TEXT) ||
        !m_bJustChangedSelectString) 
        return;

    CGlyphHandle*   pcgh = (CGlyphHandle*) m_clcMap.GetItemData(idContext);

    CString csWork;
    m_bJustChangedSelectString = FALSE;
    pcgh -> GetEncoding(csWork);
    m_clcMap.SetItemText(idContext, 0, csWork);
	
	*plr = 0;
}

/******************************************************************************

  CGlyphMappingPage::OnColumnclickGlyphMapping

  Called when the user wants to sort the list- so that's what we do!

******************************************************************************/

void CGlyphMappingPage::OnColumnclickGlyphMapping(NMHDR* pnmh, LRESULT* plr) {
	NM_LISTVIEW* pnmlv = (NM_LISTVIEW*) pnmh;
	//  Resort the list based upon the selected column, and the current sort 
    //  order

    if  (pnmlv -> iSubItem == m_bSortFirst)
        m_abDirection[m_bSortFirst] = !m_abDirection[m_bSortFirst]; //  Reverse
    else {
        if  (pnmlv -> iSubItem == m_bSortSecond)
            m_bSortSecond = m_bSortFirst;
        else {
            m_bSortLast = m_bSortSecond;
            m_bSortSecond = m_bSortFirst;
        }
        m_bSortFirst = pnmlv -> iSubItem;
    }

    CWaitCursor cwc;    //  On FE tables, this can take a while...

    m_clcMap.SortItems(&MapSorter, (DWORD) this);
	
	*plr = 0;
}

/******************************************************************************

  CGlyphMappingPage::OnGetdispinfoGlyphMapping

  This member function is an attempt to speed handling of large tables, and
  also to handle code page changes more gracefully.  All items are initially
  declared as callbacks, so the control requests names for items as they are 
  displayed, via this member.

******************************************************************************/

void CGlyphMappingPage::OnGetdispinfoGlyphMapping(NMHDR* pnmh, LRESULT* plr) {
	LV_DISPINFO* plvdi = (LV_DISPINFO*) pnmh;
	
	*plr = 0;

    //  If the window is obstructed when an item is deleted, there might not
    //  be a glpyh at this point, so watch out!

    CGlyphHandle*   pcgh = (CGlyphHandle*) plvdi -> item.lParam;
    if  (!pcgh)
        return;

    CString csWork;

    switch  (plvdi -> item.iSubItem) {
        case    0:
             pcgh -> GetEncoding(csWork);
            break;

        case    1:
            csWork.Format(_TEXT("0x\\%4.4X"), pcgh -> CodePoint());
            plvdi -> item.mask |= LVIF_DI_SETITEM;  //  This never changes
            break;

        case    2:
            csWork = m_pcgm -> PageName(pcgh -> CodePage());
    }

    lstrcpyn(plvdi -> item.pszText, csWork, plvdi -> item.cchTextMax);
}

/******************************************************************************

  CGlyphMappingPage::OnSetActive

  Called when the page is activated, but after OnInitDialog on the first 
  activation.  If the predefined code page ID has changed, we must rebuild the
  page.

******************************************************************************/

BOOL CGlyphMappingPage::OnSetActive() {

    if  (m_lPredefinedID != m_pcgm -> PredefinedID()) {
        m_lPredefinedID = m_pcgm -> PredefinedID();
        m_uTimer = SetTimer(IDD, 10, NULL);
        if  (!m_uTimer)
            OnTimer(m_uTimer);
    }
	
	return CPropertyPage::OnSetActive();
}

/******************************************************************************

  CGlyphMappingPage::OnKeydownGlyphMapping

  This is called whenever the user presses a key.  We use it to provide an
  extended interface from the keyboard, to match the other editors.

******************************************************************************/

void    CGlyphMappingPage::OnKeydownGlyphMapping(NMHDR* pnmh, LRESULT* plr) {
	LV_KEYDOWN* plvkd = (LV_KEYDOWN*)pnmh;

	*plr = 0;
    
    int idItem = m_clcMap.GetNextItem(-1, LVIS_FOCUSED | LVIS_SELECTED);

    if  (idItem == -1) {
        if  (plvkd -> wVKey == VK_F10)
            OnAddItem();
        return;
    }

    switch  (plvkd -> wVKey) {

    case    VK_F2:
        OnChangeInvocation();
        break;

    case    VK_DELETE:
        OnDeleteItem();
        break;

    case    VK_F10: {
            CRect   crItem;
            
            m_clcMap.GetItemRect(idItem, crItem, LVIR_LABEL);
            m_clcMap.ClientToScreen(crItem);
            OnContextMenu(&m_clcMap, crItem.CenterPoint());
        }
    }
}

/******************************************************************************

  CGlhpyMappingPage::OnTimer

  The only event currently using a timer is the need to fill the list.

******************************************************************************/

void    CGlyphMappingPage::OnTimer(UINT uEvent) {
    if  (uEvent != m_uTimer) {
	    CPropertyPage::OnTimer(uEvent);
        return;
    }

    CString csWork;

    if  (m_uTimer)
        KillTimer(m_uTimer);
    
    if  (!m_uidGlyph) {
        m_clcMap.DeleteAllItems();
        m_cpcBanner.SetRange(0, m_pcgm -> Glyphs() -1);
        m_cpcBanner.SetStep(1);
        m_cpcBanner.SetPos(0);
        m_cpcBanner.ShowWindow(SW_SHOW);
        csWork.LoadString(IDS_WaitToFill);
        CDC *pcdc = m_cpcBanner.GetDC();
        CRect   crBanner;
        m_cpcBanner.GetClientRect(crBanner);
        pcdc -> SetBkMode(TRANSPARENT);
        pcdc -> DrawText(csWork, crBanner, DT_CENTER | DT_VCENTER);
        m_cpcBanner.ReleaseDC(pcdc);
        if  (m_uTimer)
            m_clcMap.EnableWindow(FALSE);
        else
            m_clcMap.LockWindowUpdate();
        m_clcMap.SetItemCount(m_pcgm -> Glyphs());
    }

    for (unsigned u = 0; 
         m_uidGlyph < m_pcgm -> Glyphs() && (!m_uTimer || u < 100);
         u++, m_uidGlyph++) {

        CGlyphHandle*   pcgh = m_pcgm -> Glyph(m_uidGlyph);

        int idItem = m_clcMap.InsertItem(m_uidGlyph, LPSTR_TEXTCALLBACK);
        m_clcMap.SetItemData(idItem, (LPARAM) pcgh);
        
        m_clcMap.SetItem(idItem, 1, LVIF_TEXT, LPSTR_TEXTCALLBACK, -1, 0, 0,
            (LPARAM) pcgh);
        m_clcMap.SetItem(idItem, 2, LVIF_TEXT, LPSTR_TEXTCALLBACK, -1, 0, 0, 
            (LPARAM) pcgh);
    }

    if  (m_uidGlyph == m_pcgm -> Glyphs()) {
        if  (m_uTimer)
            m_clcMap.EnableWindow(TRUE);
        else
            m_clcMap.UnlockWindowUpdate();
        m_uTimer = 0;
        m_cpcBanner.SetPos(0);
        m_cpcBanner.ShowWindow(SW_HIDE);
        SetFocus();
        m_uidGlyph = 0;
    }

    if  (m_uTimer) {
        m_cpcBanner.SetPos(m_uidGlyph);
        csWork.LoadString(IDS_WaitToFill);
        CDC *pcdc = m_cpcBanner.GetDC();
        CRect   crBanner;
        m_cpcBanner.GetClientRect(crBanner);
        pcdc -> SetBkMode(TRANSPARENT);
        pcdc -> DrawText(csWork, crBanner, DT_CENTER | DT_VCENTER);
        m_cpcBanner.ReleaseDC(pcdc);
        m_uTimer = SetTimer(IDD, 10, NULL);
        if  (!m_uTimer) {
            CWaitCursor cwc;    //  Might be a while...
            m_clcMap.EnableWindow(TRUE);
            m_clcMap.LockWindowUpdate();
            OnTimer(m_uTimer);
        }
    }
}

/******************************************************************************

  CGlyphMappingPage::OnDestroy

  Since this also can be time-consuming, kill the list here, and throw up the 
  wait cursor.

******************************************************************************/

void    CGlyphMappingPage::OnDestroy() {
    CWaitCursor cwc;
    if  (m_uTimer)
        KillTimer(m_uTimer);
    m_clcMap.DeleteAllItems();
	CPropertyPage::OnDestroy();	
}

/******************************************************************************

  CCodePagePage class implementation

  This class implements the code page property page, providing an interface for
  viewing and implementing the code page assignments.

******************************************************************************/

CCodePagePage::CCodePagePage() : CToolTipPage(CCodePagePage::IDD) {
	//{{AFX_DATA_INIT(CCodePagePage)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT
}

CCodePagePage::~CCodePagePage() {
}

void CCodePagePage::DoDataExchange(CDataExchange* pDX) {
	CPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CCodePagePage)
	DDX_Control(pDX, IDC_SelectString, m_ceSelect);
	DDX_Control(pDX, IDC_DeselectString, m_ceDeselect);
	DDX_Control(pDX, IDC_RemovePage, m_cbRemove);
	DDX_Control(pDX, IDC_CodePageList, m_clbPages);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CCodePagePage, CToolTipPage)
	//{{AFX_MSG_MAP(CCodePagePage)
	ON_EN_KILLFOCUS(IDC_SelectString, OnKillfocusSelectString)
	ON_EN_KILLFOCUS(IDC_DeselectString, OnKillfocusDeselectString)
	ON_BN_CLICKED(IDC_AddPage, OnAddPage)
	ON_LBN_SELCHANGE(IDC_CodePageList, OnSelchangeCodePageList)
	ON_BN_CLICKED(IDC_RemovePage, OnRemovePage)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/******************************************************************************

  CCodePagePage::OnInitDialog

  This member function handles the WM_INITDIALOG message by initializing the 
  various controls of the dialog.

******************************************************************************/

BOOL CCodePagePage::OnInitDialog() {
	CToolTipPage::OnInitDialog();

    for (unsigned u = 0; u < m_pcgm -> CodePages(); u++) {
        int id = 
            m_clbPages.AddString(m_pcgm -> PageName(u));
        m_clbPages.SetItemData(id, u);
        if  (!u)
            m_clbPages.SetCurSel(id);
    }

    //  Let the list box selection change handler do the rest

    OnSelchangeCodePageList();
	
	return TRUE;
}

/******************************************************************************

  CCodePagePage::OnKillfocusSelectString

  This member function is called when the user leaves the Select String control
  I check to see if it is modified, and if it is, update the structure 
  accordingly.  I then flag it as unmodified...

******************************************************************************/

void CCodePagePage::OnKillfocusSelectString() {
	if  (!m_ceSelect.GetModify())
        return;
    CString csWork;

    m_ceSelect.GetWindowText(csWork);

    m_pcgm -> SetInvocation(m_clbPages.GetItemData(m_clbPages.GetCurSel()),
        csWork, TRUE);

    m_ceSelect.SetModify(FALSE);

    m_pcgm -> Invocation(m_clbPages.GetItemData(m_clbPages.GetCurSel()), csWork,
        TRUE);
    m_ceSelect.SetWindowText(csWork);
}

/******************************************************************************

  CCodePagePage::OnKillfocusDeselectString

  This member function is called when the user leaves the Deselect String 
  control.  I check to see if it is modified, and if it is, update the 
  structure accordingly.  I then flag it as unmodified...

******************************************************************************/

void CCodePagePage::OnKillfocusDeselectString() {
	if  (!m_ceDeselect.GetModify())
        return;
    CString csWork;

    m_ceDeselect.GetWindowText(csWork);

    m_pcgm -> SetInvocation(m_clbPages.GetItemData(m_clbPages.GetCurSel()),
        csWork, FALSE);

    m_ceDeselect.SetModify(FALSE);

    m_pcgm -> Invocation(m_clbPages.GetItemData(m_clbPages.GetCurSel()),
        csWork, FALSE);
    m_ceDeselect.SetWindowText(csWork);
}

/******************************************************************************

  CCodePagePage::OnAddPage

  This is an event handler for the pressing of the "Add Page" button.  We invoke 
  the Select Code Page dialog, and if a new page is selected, we add it to the
  list of pages that are available.

******************************************************************************/

void CCodePagePage::OnAddPage() {
    CDWordArray cdaPages;

    m_pcgm -> CodePages(cdaPages);
    CSelectCodePage cscp(this, m_pcgm -> Name(), 0);
    cscp.Exclude(cdaPages);
	
    if  (cscp.DoModal() != IDOK)
        return;

    m_pcgm -> AddCodePage(cscp.SelectedCodePage());
    int id = 
        m_clbPages.AddString(m_pcgm -> PageName(m_pcgm -> CodePages() - 1));
    m_clbPages.SetItemData(id, m_pcgm -> CodePages() -1);
    m_clbPages.SetCurSel(id);
    //  Let OnSelchangeCodePageList do the rest (that's what happened, eh?)
    OnSelchangeCodePageList();
    m_ceSelect.SetFocus();  //  A friendly place to leave it...
}

/******************************************************************************

  CCodePagePage::OnSelchangeCodePageList

  This member function handles changes in the selected code page.  It fills
  the edit controls for the selected page's name, selection and deselection
  strings, and handles enabling of the "Remove Page" button (this message
  could mean nothing is now selected...)

******************************************************************************/

void CCodePagePage::OnSelchangeCodePageList() {

    int id = m_clbPages.GetCurSel();

    if  (id < 0) {
        m_ceSelect.SetWindowText(NULL);
        m_ceDeselect.SetWindowText(NULL);
        m_cbRemove.EnableWindow(FALSE);
        m_ceSelect.EnableWindow(FALSE);
        m_ceDeselect.EnableWindow(FALSE);
        return;
    }
	
    unsigned u = m_clbPages.GetItemData(id);

    SetDlgItemText(IDC_CurrentPage, m_pcgm -> PageName(u));

    CString csWork;

    m_pcgm -> Invocation(u, csWork, TRUE);
    m_ceSelect.SetWindowText(csWork);
    m_pcgm -> Invocation(u, csWork, FALSE);
    m_ceDeselect.SetWindowText(csWork);

    m_cbRemove.EnableWindow(m_pcgm -> CodePages() > 1);
    m_ceSelect.EnableWindow();
    m_ceDeselect.EnableWindow();
}

/******************************************************************************

  CCodePagePage::OnRemovePage

  This handles the Remove Page button.  Not much to it, here- we just tell the
  glyph map what we want done.

******************************************************************************/

void CCodePagePage::OnRemovePage() {
	
    int id = m_clbPages.GetCurSel();

    if  (id < 0 || m_clbPages.GetCount() < 2)
        return;

    unsigned u = m_clbPages.GetItemData(id);

    //  Query for code page to map this one to

    CSelectCodePage cscp(this, 
        CString(_TEXT("Replacing ")) + m_pcgm -> PageName(u), 0);

    CDWordArray cdaPages;

    m_pcgm -> CodePages(cdaPages);

    cdaPages.RemoveAt(u);

    cscp.LimitTo(cdaPages);

    if  (cscp.DoModal() != IDOK)
        return;

    for (unsigned uTo = 0; uTo < m_pcgm -> CodePages(); uTo++)
        if  (m_pcgm -> PageID(uTo) == cscp.SelectedCodePage())
            break;

    _ASSERTE(uTo < (unsigned) m_pcgm -> CodePages());
    
    if  (!m_pcgm -> RemovePage(u, uTo))
        return;

    //  Flush the list box and then refill it.

    m_clbPages.ResetContent();

    for (u = 0; u < m_pcgm -> CodePages(); u++) {
        int id = m_clbPages.AddString(m_pcgm -> PageName(u));
        m_clbPages.SetItemData(id, u);
    }

    //  Select whoever moved into our position, then update the rest

    m_clbPages.SetCurSel(id < m_clbPages.GetCount() ? id : id - 1);

	OnSelchangeCodePageList();
}

/******************************************************************************

  CPredefinedMaps   class

  This implements the class which handles the page for pre-defined mappings
  in a GTT file.

******************************************************************************/

CPredefinedMaps::CPredefinedMaps() : CPropertyPage(CPredefinedMaps::IDD) {
	//{{AFX_DATA_INIT(CPredefinedMaps)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT
}

CPredefinedMaps::~CPredefinedMaps() {
}

void CPredefinedMaps::DoDataExchange(CDataExchange* pDX) {
	CPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CPredefinedMaps)
	DDX_Control(pDX, IDC_PredefinedList, m_clbIDs);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CPredefinedMaps, CPropertyPage)
	//{{AFX_MSG_MAP(CPredefinedMaps)
	ON_BN_CLICKED(IDC_Overstrike, OnOverstrike)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CPredefinedMaps message handlers

/******************************************************************************

  CPredefinedMaps::OnInitDialog

  This override handles the WM_INITDIALOG message by initializing the various
  controls.

******************************************************************************/

BOOL CPredefinedMaps::OnInitDialog() {
	CPropertyPage::OnInitDialog();

    //  Fill the list box- first, with none, then with the defined IDs

    CString csWork;

    csWork.LoadString(IDS_NoPredefined);
    m_clbIDs.AddString(csWork);
    if  (m_pcgm -> PredefinedID()== CGlyphMap::NoPredefined)
        m_clbIDs.SetCurSel(0);
    m_clbIDs.SetItemData(0, CGlyphMap::NoPredefined);
	
    for (int i = CGlyphMap::Wansung; i < 1; i++) {
        csWork.LoadString(IDS_DefaultPage + i);
        if  (csWork.IsEmpty())
            continue;
        int id = m_clbIDs.AddString(csWork);
        m_clbIDs.SetItemData(id, i);
        if  (i == m_pcgm -> PredefinedID())
            m_clbIDs.SetCurSel(i);
    }

    m_clbIDs.SetTopIndex(m_clbIDs.GetCurSel());

    CheckDlgButton(IDC_Overstrike, m_pcgm -> OverStrike());
    	
	return TRUE;  // return TRUE unless you set the focus to a control
}

/******************************************************************************

  CPredefinedMaps::OnKillActive

  This is called when we leave the page.  Since changing pages can be very
  time-consuming, we only check when you leave, not every time the selection
  changes.  Occasionally even my aged brain works.

******************************************************************************/

BOOL    CPredefinedMaps::OnKillActive() {
	
    if  (m_clbIDs.GetCurSel() >= 0)
        m_pcgm -> UsePredefined(m_clbIDs.GetItemData(m_clbIDs.GetCurSel()));
    
    return CPropertyPage::OnKillActive();
}

/******************************************************************************

  CPredefinedMaps::OnOverstrike

  Called when the user clicks the check box for enabling / disabling overstrike

******************************************************************************/

void    CPredefinedMaps::OnOverstrike() {	
    m_pcgm -> OverStrike(IsDlgButtonChecked(IDC_Overstrike));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\tools\uni\minidev\gttview.h ===
/******************************************************************************

  Header File:  Glyph Map View.H

  This defines the classes used to edit and view the glyph mappings.

  Copyright (c) 1997 by Microsoft Corporation.  All Rights Reserved.

  A Pretty Penny Enterprises Production

  Change History:
  02-20-1997    Bob_Kjelgaard@Prodigy.Net   Began work on it.

******************************************************************************/

/******************************************************************************

  CGlyphMappingPage class

  This class handles the property sheet page which displays a list of the
  individual code points in the glyph translatin table.

******************************************************************************/

class CGlyphMappingPage : public CPropertyPage {

    //  Sorting members and methods
    enum {Strings, Codes, Pages, Columns};
    BOOL    m_abDirection[Columns];   //  Sort directions;
    BYTE    m_bSortFirst, m_bSortSecond, m_bSortLast;

    static int CALLBACK MapSorter(LPARAM lp1, LPARAM lp2, LPARAM lp3);

    CGlyphMap*  m_pcgm;
    BOOL        m_bJustChangedSelectString; //  Semi-flaky work-around
    long        m_lPredefinedID;    //  So we know if we need to change this.
    unsigned    m_uTimer;           //  Using a timer for long fills
    unsigned    m_uidGlyph;         //  Used to track where we are on fills

// Construction
public:
	CGlyphMappingPage();
	~CGlyphMappingPage();

    void    Init(CGlyphMap* pcgm) { m_pcgm = pcgm; }

// Dialog Data
	//{{AFX_DATA(CGlyphMappingPage)
	enum { IDD = IDD_GlyphMappings };
	CProgressCtrl	m_cpcBanner;
	CListCtrl	m_clcMap;
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CGlyphMappingPage)
	public:
	virtual BOOL OnSetActive();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
    //  Stuff Class Wizard doesn't know about, because we generate it from
    //  our on-the-fly context menus...
    afx_msg void    OnChangeInvocation();
    afx_msg void    OnChangeCodePage();
    afx_msg void    OnDeleteItem();
    afx_msg void    OnAddItem();
	// Generated message map functions
	//{{AFX_MSG(CGlyphMappingPage)
	virtual BOOL OnInitDialog();
	afx_msg void OnContextMenu(CWnd* pWnd, CPoint point);
	afx_msg void OnEndlabeleditGlyphMapping(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnItemchangedGlyphMapping(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnColumnclickGlyphMapping(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnGetdispinfoGlyphMapping(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnKeydownGlyphMapping(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnTimer(UINT nIDEvent);
	afx_msg void OnDestroy();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

/*****************************************************************************

  CCodePagePage class

  This class handles the property page which describes the code pages used
  along with their selection and deselection strings.

******************************************************************************/

class CCodePagePage : public CToolTipPage {
    CGlyphMap   *m_pcgm;

// Construction
public:
	CCodePagePage();
	~CCodePagePage();

    void    Init(CGlyphMap * pcgm) { m_pcgm = pcgm; }

// Dialog Data
	//{{AFX_DATA(CCodePagePage)
	enum { IDD = IDD_CodePageView };
	CEdit	m_ceSelect;
	CEdit	m_ceDeselect;
	CButton	m_cbRemove;
	CListBox	m_clbPages;
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CCodePagePage)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CCodePagePage)
	virtual BOOL OnInitDialog();
	afx_msg void OnKillfocusSelectString();
	afx_msg void OnKillfocusDeselectString();
	afx_msg void OnAddPage();
	afx_msg void OnSelchangeCodePageList();
	afx_msg void OnRemovePage();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};

/******************************************************************************

  CPredefinedMaps class

  This class allows the user to specify a predefined mapping (if desired) and
  the way the code points in the table are ro be considered in relation to the
  same.

******************************************************************************/

class CPredefinedMaps : public CPropertyPage {
    CGlyphMap   *m_pcgm;

// Construction
public:
	CPredefinedMaps();
	~CPredefinedMaps();

    void    Init(CGlyphMap *pcgm) { m_pcgm = pcgm; }

// Dialog Data
	//{{AFX_DATA(CPredefinedMaps)
	enum { IDD = IDD_PredefinedPage };
	CListBox	m_clbIDs;
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CPredefinedMaps)
	public:
	virtual BOOL OnKillActive();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CPredefinedMaps)
	virtual BOOL OnInitDialog();
	afx_msg void OnOverstrike();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};

/******************************************************************************

  CGlyphMapView class

  This class is the view class for glyph maps.  It creates a property sheet
  using the above pages.

******************************************************************************/

class CGlyphMapView : public CView {
    CPropertySheet      m_cps;
    CGlyphMappingPage   m_cgmp;
    CCodePagePage       m_ccpp;
    CPredefinedMaps     m_cpm;

protected:
	CGlyphMapView();           // protected constructor used by dynamic creation
	DECLARE_DYNCREATE(CGlyphMapView)

// Attributes
public:

    CGlyphMapContainer* GetDocument() { 
        return (CGlyphMapContainer *) m_pDocument; 
    }

// Operations
public:

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CGlyphMapView)
	protected:
	virtual void OnDraw(CDC* pDC);      // overridden to draw this view
	virtual void OnInitialUpdate();     // first time after construct
	virtual void OnActivateView(BOOL bActivate, CView* pActivateView, CView* pDeactiveView);
	//}}AFX_VIRTUAL

// Implementation
protected:
	virtual ~CGlyphMapView();
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif

	// Generated message map functions
	//{{AFX_MSG(CGlyphMapView)
	afx_msg void OnDestroy();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\tools\uni\minidev\minidev.cpp ===
/******************************************************************************

  Source File:  MiniDriver Developer Studio.CPP

  This implements the MFC application object and closely related classes.

  Copyright (c) 1997 by Microsoft Corporation.  All Rights Reserved.

  A Pretty Penny Enterprises Production.

  Change History:
  02-03-1997    Bob_Kjelgaard@Prodigy.Net   Created it
  03-03-1997    Bob_Kjelgaard@Prodigy.Net   Renamed it when the project was
                reorganized into an EXE with multiple DLLs

******************************************************************************/

#include    "StdAfx.H"
#include    "MiniDev.H"
#include    "MainFrm.H"
#include    "ChildFrm.H"
#include    "ModlData\Resource.H"
#include    "ProjView.H"
#include    "GTTView.H"
#include    "FontView.H"
#include    "GPDView.H"
#include    <CodePage.H>

#include    <Dos.H>
#include    <Direct.H>

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CMiniDriverStudio

BEGIN_MESSAGE_MAP(CMiniDriverStudio, CWinApp)
	ON_COMMAND(CG_IDS_TIPOFTHEDAY, ShowTipOfTheDay)
	//{{AFX_MSG_MAP(CMiniDriverStudio)
	ON_COMMAND(ID_APP_ABOUT, OnAppAbout)
	ON_UPDATE_COMMAND_UI(ID_FILE_GENERATEMAPS, OnUpdateFileGeneratemaps)
	ON_COMMAND(ID_FILE_GENERATEMAPS, OnFileGeneratemaps)
	//}}AFX_MSG_MAP
	// Standard file based document commands
#if defined(NOPOLLO)
	ON_COMMAND(ID_FILE_NEW, CWinApp::OnFileNew)
#else
	ON_COMMAND(ID_FILE_NEW, OnFileNew)
#endif
	ON_COMMAND(ID_FILE_OPEN, CWinApp::OnFileOpen)
	// Standard print setup command
	ON_COMMAND(ID_FILE_PRINT_SETUP, CWinApp::OnFilePrintSetup)
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CMiniDriverStudio construction

CMiniDriverStudio::CMiniDriverStudio() {
	// TODO: add construction code here,
	// Place all significant initialization in InitInstance
}

/////////////////////////////////////////////////////////////////////////////
// The one and only CMiniDriverStudio object

static CMiniDriverStudio theApp;

/////////////////////////////////////////////////////////////////////////////
// CMiniDriverStudio initialization

BOOL CMiniDriverStudio::InitInstance() {

    // Standard initialization
	// If you are not using these features and wish to reduce the size
	//  of your final executable, you should remove from the following
	//  the specific initialization routines you do not need.

#ifdef _AFXDLL
	Enable3dControls();			// Call this when using MFC in a shared DLL
#else
	Enable3dControlsStatic();	// Call this when linking to MFC statically
#endif

    SetRegistryKey(_TEXT("Microsoft"));

	LoadStdProfileSettings();  // Load standard INI file options (including MRU)

	// Register the application's document templates.  Document templates
	//  serve as the connection between documents, frame windows and views.

	m_pcmdtWorkspace = new CMultiDocTemplate(
		IDR_MINIWSTYPE,
		RUNTIME_CLASS(CProjectRecord),
		RUNTIME_CLASS(CChildFrame), // custom MDI child frame
		RUNTIME_CLASS(CProjectView));
	AddDocTemplate(m_pcmdtWorkspace);
    m_pcmdtGlyphMap = new CMultiDocTemplate(IDR_GLYPHMAP, 
        RUNTIME_CLASS(CGlyphMapContainer),
        RUNTIME_CLASS(CChildFrame),
        RUNTIME_CLASS(CGlyphMapView));
    AddDocTemplate(m_pcmdtGlyphMap);
    m_pcmdtFont = new CMultiDocTemplate(IDR_FONT_VIEWER, 
        RUNTIME_CLASS(CFontInfoContainer),
        RUNTIME_CLASS(CChildFrame),
        RUNTIME_CLASS(CFontViewer));
    AddDocTemplate(m_pcmdtFont);
    m_pcmdtModel = new CMultiDocTemplate(IDR_GPD_VIEWER,
        RUNTIME_CLASS(CGPDContainer),
        RUNTIME_CLASS(CChildFrame),
        RUNTIME_CLASS(CGPDViewer));
    AddDocTemplate(m_pcmdtModel);

	// create main MDI Frame window
	CMainFrame* pMainFrame = new CMainFrame;
	if (!pMainFrame->LoadFrame(IDR_MAINFRAME))
		return FALSE;
	m_pMainWnd = pMainFrame;

	// Enable drag/drop open
	m_pMainWnd->DragAcceptFiles();

	// Enable DDE Execute open
	EnableShellOpen();
	RegisterShellFileTypes(TRUE);

	// Parse command line for standard shell commands, DDE, file open
	CCommandLineInfo cmdInfo;
	ParseCommandLine(cmdInfo);

    //  Turn off New on startup

    if  (cmdInfo.m_nShellCommand == CCommandLineInfo::FileNew)
        cmdInfo.m_nShellCommand = CCommandLineInfo::FileNothing;

	// Dispatch commands specified on the command line
	if (!ProcessShellCommand(cmdInfo))
		return FALSE;

	// The main window has been initialized, so show and update it.
	pMainFrame->ShowWindow(m_nCmdShow);
	pMainFrame->UpdateWindow();

	// CG: This line inserted by 'Tip of the Day' component.
	ShowTipAtStartup();

	return TRUE;
}

/////////////////////////////////////////////////////////////////////////////
// CAboutDlg dialog used for App About

class CAboutDlg : public CDialog {
public:
	CAboutDlg();

// Dialog Data
	//{{AFX_DATA(CAboutDlg)
	enum { IDD = IDD_ABOUTBOX };
	CComboBox	m_ccbSupported;
	CComboBox	m_ccbInstalled;
	//}}AFX_DATA

	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CAboutDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	virtual BOOL OnInitDialog();
	//{{AFX_MSG(CAboutDlg)
		// No message handlers
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

CAboutDlg::CAboutDlg() : CDialog(CAboutDlg::IDD) {
	//{{AFX_DATA_INIT(CAboutDlg)
	//}}AFX_DATA_INIT
}

void CAboutDlg::DoDataExchange(CDataExchange* pDX) {
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CAboutDlg)
	DDX_Control(pDX, IDC_SupportedPages, m_ccbSupported);
	DDX_Control(pDX, IDC_InstalledPages, m_ccbInstalled);
	//}}AFX_DATA_MAP
}

BEGIN_MESSAGE_MAP(CAboutDlg, CDialog)
	//{{AFX_MSG_MAP(CAboutDlg)
		// No message handlers
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

// App command to run the dialog
void CMiniDriverStudio::OnAppAbout() {
	CAboutDlg aboutDlg;
	aboutDlg.DoModal();
}

/////////////////////////////////////////////////////////////////////////////
// CMiniDriverStudio commands


//  Handle the File GenerateMaps menu item.  We only enable it if there's
//  something new to see.

void CMiniDriverStudio::OnUpdateFileGeneratemaps(CCmdUI* pccui) {
	
    CCodePageInformation    ccpi;

    for (unsigned u = 0; u < ccpi.InstalledCount(); u++)
        if  (!ccpi.HaveMap(ccpi.Installed(u)))
            break;

    pccui -> Enable(u < ccpi.InstalledCount());
}

void CMiniDriverStudio::OnFileGeneratemaps() {
	CCodePageInformation    ccpi;

    AfxMessageBox(ccpi.GenerateAllMaps() ? IDS_MapsGenerated : IDS_MapsFailed);
}

void CMiniDriverStudio::ShowTipAtStartup(void) {
	// CG: This function added by 'Tip of the Day' component.

	CCommandLineInfo cmdInfo;
	ParseCommandLine(cmdInfo);
	if (cmdInfo.m_bShowSplash) 	{
		CTipOfTheDay dlg;
		if (dlg.m_bStartup)
			dlg.DoModal();
	}
}

void CMiniDriverStudio::ShowTipOfTheDay(void) {
	// CG: This function added by 'Tip of the Day' component.

	CTipOfTheDay dlg;
	dlg.DoModal();
}

#if !defined(NOPOLLO)

/******************************************************************************

  CMiniDriverStudio::OnFileNew

  This allows you to create a workspace by conversion.  Perhaps when the Co.
  Jones arrive, this will be invoked as a separate menu item, rather than the
  File New item...

******************************************************************************/

void CMiniDriverStudio::OnFileNew() {
    CDocument*  pcdWS = m_pcmdtWorkspace -> CreateNewDocument();
    if  (!pcdWS || !pcdWS -> OnNewDocument()) {
        if  (pcdWS)
            delete  pcdWS;
        return;
    }
    m_pcmdtWorkspace -> SetDefaultTitle(pcdWS);
    CFrameWnd*  pcfw = m_pcmdtWorkspace -> CreateNewFrame(pcdWS, NULL);
    if  (!pcfw) return;
    m_pcmdtWorkspace -> InitialUpdateFrame(pcfw, pcdWS);
}

#endif  //!defined(NOPOLLO)

//  Global Functions go here, saith the Bob...

CMiniDriverStudio&  ThisApp() { return theApp; }

CMultiDocTemplate*  GlyphMapDocTemplate() {
    return  theApp.GlyphMapTemplate();
}

CMultiDocTemplate* FontTemplate() { return theApp.FontTemplate(); }

CMultiDocTemplate*  GPDTemplate() { return theApp.GPDTemplate(); }

BOOL    LoadFile(LPCTSTR lpstrFile, CStringArray& csaContents) {

    CStdioFile  csiof;

    if  (!csiof.Open(lpstrFile, 
        CFile::modeRead | CFile::shareDenyWrite | CFile::typeText))

        return  FALSE;

    csaContents.RemoveAll();
    try {
        CString csContents;
        while   (csiof.ReadString(csContents))
            csaContents.Add(csContents);
    }
    catch(...) {
        return  FALSE;
    }

    return  TRUE;
}

//  CAboutDlg command handlers.

BOOL CAboutDlg::OnInitDialog() {

	CDialog::OnInitDialog();

    CString csWork, csFormat;

	// Fill available memory
    MEMORYSTATUS ms = {sizeof(MEMORYSTATUS)};
	GlobalMemoryStatus(&ms);
	csFormat.LoadString(CG_IDS_PHYSICAL_MEM);
	csWork.Format(csFormat, ms.dwAvailPhys / 1024L, ms.dwTotalPhys / 1024L);

	SetDlgItemText(IDC_PhysicalMemory, csWork);

	// Fill disk free information
	struct _diskfree_t diskfree;
	int nDrive = _getdrive(); // use current default drive
	if (_getdiskfree(nDrive, &diskfree) == 0) {
		csFormat.LoadString(CG_IDS_DISK_SPACE);
		csWork.Format(csFormat, (DWORD)diskfree.avail_clusters *
			(DWORD)diskfree.sectors_per_cluster *
			(DWORD)diskfree.bytes_per_sector / (DWORD)1024L,
			nDrive - 1 + _T('A'));
	}
 	else
 		csWork.LoadString(CG_IDS_DISK_SPACE_UNAVAIL);

	SetDlgItemText(IDC_FreeDiskSpace, csWork);

    csWork.Format(_TEXT("Code Pages:  ANSI %u OEM %u"), GetACP(), GetOEMCP());

    SetDlgItemText(IDC_CodePages, csWork);

    CCodePageInformation   ccpi;

    for    (unsigned u = 0; u < ccpi.InstalledCount(); u++)
        m_ccbInstalled.AddString(ccpi.Name(ccpi.Installed(u)));

    m_ccbInstalled.SetCurSel(0);
	
    for    (u = 0; u < ccpi.SupportedCount(); u++)
        m_ccbSupported.AddString(ccpi.Name(ccpi.Supported(u)));

    m_ccbSupported.SetCurSel(0);
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\tools\uni\minidev\minidev.h ===
/******************************************************************************

  Source File:  MiniDriver Developer Studio.H

  This defines the main application class, and other relatively global data.

  Copyright (c) 1997 By Microsoft Corporation.  All Rights Reserved.

  A Pretty Penny Enterprises Production.

  Change History:
  02-03-1997    Bob_Kjelgaard@Prodigy.Net   Created it.

******************************************************************************/

#ifndef __AFXWIN_H__
	#error include 'stdafx.h' before including this file for PCH
#endif

#include "resource.h"       // main symbols

/******************************************************************************

  CMiniDriverStudio class

  This is the application class for this application. 'Nuff said?

******************************************************************************/

class CMiniDriverStudio : public CWinApp {
    //  Document templates for the various editors
    CMultiDocTemplate   *m_pcmdtGlyphMap, *m_pcmdtFont, *m_pcmdtModel,
                        *m_pcmdtWorkspace;  //  Document templates

public:
	CMiniDriverStudio();

    CMultiDocTemplate*  GlyphMapTemplate() const { return m_pcmdtGlyphMap; }
    CMultiDocTemplate*  FontTemplate() const { return m_pcmdtFont; }
    CMultiDocTemplate*  GPDTemplate() const { return m_pcmdtModel; }
    
// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CMiniDriverStudio)
	public:
	virtual BOOL InitInstance();
	//}}AFX_VIRTUAL

// Implementation

	//{{AFX_MSG(CMiniDriverStudio)
	afx_msg void OnAppAbout();
	afx_msg void OnUpdateFileGeneratemaps(CCmdUI* pCmdUI);
	afx_msg void OnFileGeneratemaps();
	//}}AFX_MSG
#if !defined(NOPOLLO)
	afx_msg void OnFileNew();
#endif
	DECLARE_MESSAGE_MAP()
private:
	void ShowTipAtStartup(void);
private:
	void ShowTipOfTheDay(void);
};

//  App access function(s)

CMiniDriverStudio&  ThisApp();

CMultiDocTemplate*  GlyphMapDocTemplate();
CMultiDocTemplate*  FontTemplate();
CMultiDocTemplate*  GPDTemplate();

//  Text File Loading (into a CStringArray) function

BOOL    LoadFile(LPCTSTR lpstrFile, CStringArray& csaContents);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\tools\uni\minidev\newproj.cpp ===
/******************************************************************************

  Source File:  New Project Wizard.CPP

  This contains the implementation of the classes that make u the new project
  wizard- a key component of this tool.

  Copyright (c) 1997 by Microsoft Corporation.  All Rights Reserved.

  A Pretty Penny Enterprises Production

  Change History:
  02-03-1997    Bob_Kjelgaard@Prodigy.Net   Created it

******************************************************************************/

#include    "StdAfx.h"
#include    "MiniDev.H"
#include    "ModlData\Resource.H"
#include    "NewProj.H"
#include    <CodePage.H>

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CNewProjectWizard

//  We use "this" to allow the pages to hook back to us- disable the
//  warnings this causes, as none will use the pointer until after
//  we have been initialized.

#pragma warning(disable : 4355)
CNewProjectWizard::CNewProjectWizard(CProjectRecord& cprFor, CWnd* pParentWnd) :
	CPropertySheet(NewProjectWizardTitle, pParentWnd), m_cfnwp(*this),
    m_cprThis(cprFor), m_cst(*this), m_csd(*this), m_crut(*this),
    m_crng(*this), m_ccf(*this), m_cmcp(*this) {

    m_bFastConvert = TRUE;
    m_eGPDConvert = CommonRCWithSpoolerNames;

    AddPage(&m_cfnwp);
    AddPage(&m_cst);
    AddPage(&m_csd);
    AddPage(&m_crut);
    AddPage(&m_cmcp);
    AddPage(&m_ccf);
    AddPage(&m_crng);
    SetWizardMode();
}

#pragma warning(default : 4355)

CNewProjectWizard::~CNewProjectWizard() {
}

BEGIN_MESSAGE_MAP(CNewProjectWizard, CPropertySheet)
	//{{AFX_MSG_MAP(CNewProjectWizard)
	ON_WM_NCCREATE()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CNewProjectWizard message handlers

//  restore the system menu to the wizard, and allow it to be minimized

BOOL CNewProjectWizard::OnNcCreate(LPCREATESTRUCT lpCreateStruct) {
	ModifyStyle(WS_CHILD, WS_MINIMIZEBOX | WS_SYSMENU);
	
	if (!CPropertySheet::OnNcCreate(lpCreateStruct))
		return FALSE;
	
	return TRUE;
}

/////////////////////////////////////////////////////////////////////////////
// CFirstNewWizardPage property page

CFirstNewWizardPage::CFirstNewWizardPage(CNewProjectWizard& cnpwOwner) : 
    CPropertyPage(CFirstNewWizardPage::IDD), m_cnpwOwner(cnpwOwner) {
	//{{AFX_DATA_INIT(CFirstNewWizardPage)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT
}

CFirstNewWizardPage::~CFirstNewWizardPage() {
}

void CFirstNewWizardPage::DoDataExchange(CDataExchange* pDX) {
	CPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CFirstNewWizardPage)
		// NOTE: the ClassWizard will add DDX and DDV calls here
	//}}AFX_DATA_MAP
}

BEGIN_MESSAGE_MAP(CFirstNewWizardPage, CPropertyPage)
	//{{AFX_MSG_MAP(CFirstNewWizardPage)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CFirstNewWizardPage message handlers

BOOL CFirstNewWizardPage::OnSetActive() {
	//  We wish to disable the "Back" button here.
	
    m_cnpwOwner.SetWizardButtons(PSWIZB_NEXT);
    CheckRadioButton(NormalConversion, CustomConversion, 
        NormalConversion + !m_cnpwOwner.FastConvert());
	return  CPropertyPage::OnSetActive();
}

/******************************************************************************

  CFirstNewWizardPage::OnWizardNext

  When Next is pressed, we invoke a file open dialog to allow us to collect the
  source RC file information.

******************************************************************************/

LRESULT CFirstNewWizardPage::OnWizardNext() {

	//  When the "Next" button is pushed, we need to find the driver we are
    //  going to work with.

    CFileDialog cfd(TRUE, NULL, NULL, OFN_FILEMUSTEXIST | OFN_HIDEREADONLY,
        "Driver Resource Scripts (*.rc,*.w31)|*.rc;*.w31||",
        &m_cnpwOwner);

    CString csTitle;
    csTitle.LoadString(OpenRCDialogTitle);

    cfd.m_ofn.lpstrTitle = csTitle;
    
    if  (cfd.DoModal() != IDOK)
        return  -1;

    //  Collect the RC file name

    m_cnpwOwner.Project().SetSourceRCFile(cfd.GetPathName());

    m_cnpwOwner.FastConvert(GetCheckedRadioButton(NormalConversion, 
        CustomConversion) == NormalConversion);

    return m_cnpwOwner.FastConvert() ? CSelectDestinations::IDD :
        CPropertyPage::OnWizardNext();
}

/////////////////////////////////////////////////////////////////////////////
// CSelectTargets property page

CSelectTargets::CSelectTargets(CNewProjectWizard& cnpwOwner) : 
    CPropertyPage(CSelectTargets::IDD), m_cnpwOwner(cnpwOwner) {
	//{{AFX_DATA_INIT(CSelectTargets)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT
}

CSelectTargets::~CSelectTargets() {
}

void CSelectTargets::DoDataExchange(CDataExchange* pDX) {
	CPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CSelectTargets)
		// NOTE: the ClassWizard will add DDX and DDV calls here
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CSelectTargets, CPropertyPage)
	//{{AFX_MSG_MAP(CSelectTargets)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CSelectTargets message handlers

BOOL CSelectTargets::OnSetActive() {
	//  We need to enable the "Back" button...

    m_cnpwOwner.SetWizardButtons(PSWIZB_BACK | PSWIZB_NEXT);

    SetDlgItemText(IDC_DriverName, m_cnpwOwner.Project().DriverName());
	
	return CPropertyPage::OnSetActive();
}

//  Initialize the controls

BOOL CSelectTargets::OnInitDialog() {

	CPropertyPage::OnInitDialog();
	
	CheckDlgButton(IDC_TargetNT40,
        m_cnpwOwner.Project().IsTargetEnabled(WinNT40));
	CheckDlgButton(IDC_TargetNT3x,
        m_cnpwOwner.Project().IsTargetEnabled(WinNT3x));
	CheckDlgButton(IDC_TargetWin95, 
        m_cnpwOwner.Project().IsTargetEnabled(Win95));
	
	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

LRESULT CSelectTargets::OnWizardNext() {

	//  Set the flags according to the controls...

    m_cnpwOwner.Project().EnableTarget(WinNT40,
        IsDlgButtonChecked(IDC_TargetNT40));
	m_cnpwOwner.Project().EnableTarget(WinNT3x,
        IsDlgButtonChecked(IDC_TargetNT3x));
	m_cnpwOwner.Project().EnableTarget(Win95,
        IsDlgButtonChecked(IDC_TargetWin95));

	CString csName;
	GetDlgItemText(IDC_DriverName, csName);
    m_cnpwOwner.Project().Rename(csName);
	
	return CPropertyPage::OnWizardNext();
}

/////////////////////////////////////////////////////////////////////////////
// CSelectDestinations property page

//  This routine browses for a directory, beginning with the one named in the
//  given control.  If a directory is selected, the control is appropriately
//  updated.

void    CSelectDestinations::DoDirectoryBrowser(unsigned uControl) {

    //  TODO:   Alas, the common dialogs do not support this function.  as it
    //  isn't entirely trivial (especially since I still want to use the
    //  explorer interface), I'll punt this one for now.

    AfxMessageBox(IDS_Unimplemented);
}

/******************************************************************************

  CSelectDestinations::BuildStructure

  This private member function establishes the selected directory structure,
  if it can, and reports its success or failure as need be.

******************************************************************************/
    
BOOL    CSelectDestinations::BuildStructure() {
    //  Verify the directory exists (or can be created) for each of the 
    //  target directories that is enabled.

    CProjectRecord& cpr = m_cnpwOwner.Project();

    CString csPath;

    if  (cpr.IsTargetEnabled(WinNT50)) {
        GetDlgItemText(IDC_NT50Destination, csPath);
        if  (!cpr.SetPath(WinNT50, csPath) || !cpr.BuildStructure(WinNT50)) {
            AfxMessageBox(IDS_CannotMakeDirectory);
            GetDlgItem(IDC_NT50Destination) -> SetFocus();
            return  FALSE;
        }
    }

    if  (cpr.IsTargetEnabled(WinNT40)) {
        GetDlgItemText(IDC_NT40Destination, csPath);
        if  (!cpr.SetPath(WinNT40, csPath) || !cpr.BuildStructure(WinNT40)) {
            AfxMessageBox(IDS_CannotMakeDirectory);
            GetDlgItem(IDC_NT40Destination) -> SetFocus();
            return  FALSE;
        }
    }

    if  (cpr.IsTargetEnabled(WinNT3x)) {
        GetDlgItemText(IDC_NT3xDestination, csPath);
        if  (!cpr.SetPath(WinNT3x, csPath) || !cpr.BuildStructure(WinNT3x)) {
            AfxMessageBox(IDS_CannotMakeDirectory);
            GetDlgItem(IDC_NT3xDestination) -> SetFocus();
            return  FALSE;
        }
    }

    return  TRUE;
}

/******************************************************************************

  CSelectDestinations constructor, destructor, DDX routine and message map.

******************************************************************************/

CSelectDestinations::CSelectDestinations(CNewProjectWizard& cnpwOwner) : 
    CPropertyPage(CSelectDestinations::IDD), m_cnpwOwner(cnpwOwner) {
	//{{AFX_DATA_INIT(CSelectDestinations)
	//}}AFX_DATA_INIT
}

CSelectDestinations::~CSelectDestinations() {
}

void CSelectDestinations::DoDataExchange(CDataExchange* pDX) {
	CPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CSelectDestinations)
	DDX_Control(pDX, IDC_BrowseNT3x, m_cbBrowseNT3x);
	DDX_Control(pDX, IDC_BrowseNT40, m_cbBrowseNT40);
	DDX_Control(pDX, IDC_BrowseNT50, m_cbBrowseNT50);
	//}}AFX_DATA_MAP
}

BEGIN_MESSAGE_MAP(CSelectDestinations, CPropertyPage)
	//{{AFX_MSG_MAP(CSelectDestinations)
	ON_BN_CLICKED(IDC_BrowseNT40, OnBrowseNT40)
	ON_BN_CLICKED(IDC_BrowseNT50, OnBrowseNT50)
	ON_BN_CLICKED(IDC_BrowseNT3x, OnBrowseNT3x)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CSelectDestinations message handlers

BOOL CSelectDestinations::OnInitDialog() {

	CPropertyPage::OnInitDialog();

    //  TODO:   Find some way to do a consistent directory browser in under 
    //  6 weeks, or get 6 weeks time to do it.

#if 0

    //  Place the browser Icon in each of the buttons

    HICON   hiArrow = LoadIcon(AfxGetResourceHandle(), 
        MAKEINTRESOURCE(IDI_BrowseArrow));

	m_cbBrowseNT50.SetIcon(hiArrow);
	m_cbBrowseNT40.SetIcon(hiArrow);
	m_cbBrowseNT3x.SetIcon(hiArrow);

#else

    m_cbBrowseNT50.ShowWindow(SW_HIDE);
    m_cbBrowseNT40.ShowWindow(SW_HIDE);
    m_cbBrowseNT3x.ShowWindow(SW_HIDE);

#endif
	
    return TRUE;  
}

//  When we are made active, fill in the correct path names.  Note that these
//  might change as a result of activity on other pages, so we do not just do
//  this at init time.

BOOL CSelectDestinations::OnSetActive() {

    //  Fill in the correct path names

    SetDlgItemText(IDC_NT50Destination, 
        m_cnpwOwner.Project().TargetPath(WinNT50));
    SetDlgItemText(IDC_NT40Destination, 
        m_cnpwOwner.Project().TargetPath(WinNT40));
    SetDlgItemText(IDC_NT3xDestination, 
        m_cnpwOwner.Project().TargetPath(WinNT3x));
    SetDlgItemText(IDC_Win95Destination, 
        m_cnpwOwner.Project().TargetPath(Win95));

    //  Disable all controls related to non-operative targets

    GetDlgItem(IDC_NT50Destination) -> EnableWindow(
        m_cnpwOwner.Project().IsTargetEnabled(WinNT50));

    m_cbBrowseNT50.EnableWindow(
        m_cnpwOwner.Project().IsTargetEnabled(WinNT50));
	
    GetDlgItem(IDC_NT40Destination) -> EnableWindow(
        m_cnpwOwner.Project().IsTargetEnabled(WinNT40));

    m_cbBrowseNT40.EnableWindow(
        m_cnpwOwner.Project().IsTargetEnabled(WinNT40));

    GetDlgItem(IDC_NT3xDestination) -> EnableWindow(
        m_cnpwOwner.Project().IsTargetEnabled(WinNT3x));

    m_cbBrowseNT3x.EnableWindow(
        m_cnpwOwner.Project().IsTargetEnabled(WinNT3x));

    //  This is either the last page or one of many, depending upon
    //  whether or not this is a custom conversion.

    m_cnpwOwner.SetWizardButtons(PSWIZB_BACK |
        (m_cnpwOwner.FastConvert() ? PSWIZB_FINISH : PSWIZB_NEXT));

	return CPropertyPage::OnSetActive();
}

void CSelectDestinations::OnBrowseNT3x() {
	DoDirectoryBrowser(IDC_NT3xDestination);
}

void CSelectDestinations::OnBrowseNT40() {
	DoDirectoryBrowser(IDC_NT40Destination);
}

void CSelectDestinations::OnBrowseNT50() {
	DoDirectoryBrowser(IDC_NT50Destination);
}

LRESULT CSelectDestinations::OnWizardNext() {
    //  Verify the directory exists (or can be created) for each of the 
    //  target directories that is enabled.

    CProjectRecord& cpr = m_cnpwOwner.Project();

    //  Don't advance if the tree cannot be built.

    if  (!BuildStructure())
        return  -1;

    //  We only run Unitool if this isn't an NT 5 only conversion, or if the
    //  data load failed.

    if  (!cpr.IsTargetEnabled(WinNT3x | WinNT40 | Win95)) {
        if  (!cpr.LoadResources()) {
            AfxMessageBox(IDS_RCLoadFailed);
            return  CPropertyPage::OnWizardNext();
        }
        else
            return  CMapCodePages::IDD;
    }
    else
        return CPropertyPage::OnWizardNext();
}

/******************************************************************************

  CSelectDestinations::OnWizardBack

  This handles the response to the back button.  We must override the default
  handler in the case of a normal conversion, as the default will go back to
  the target selection page, and we will go back to the initial page in the
  fast-path case.

******************************************************************************/

LRESULT CSelectDestinations::OnWizardBack() {
    return m_cnpwOwner.FastConvert() ? 
        CFirstNewWizardPage::IDD : CPropertyPage::OnWizardBack();
}

/******************************************************************************

  CSelectDestinations::OnWizardFinish

  This function is caled when the Finish button is pushed.  We are interested
  only in the case where the Fast conversion flag is present.  In this case,
  we step through all of the remaining conversion steps (unless one fails)

******************************************************************************/

BOOL CSelectDestinations::OnWizardFinish() {
    //  Only the fast path is of interest to us.

    if  (m_cnpwOwner.FastConvert()) {

        //  This might take a while, so...
        CWaitCursor cwc;

        if  (!BuildStructure())
            return  -1;

        CProjectRecord& cpr = m_cnpwOwner.Project();
        
        if  (!cpr.LoadResources() || !cpr.LoadFontData()) {
            AfxMessageBox(IDS_RCLoadFailed);
            return  FALSE;
        }

        //  We now need to generate ALL of the necessary files
        cpr.GenerateTargets(m_cnpwOwner.GPDConvertFlag());
        return  cpr.ConversionsComplete();
    }
	return CPropertyPage::OnWizardFinish();
}

/////////////////////////////////////////////////////////////////////////////
// CRunUniTool property page

CRunUniTool::CRunUniTool(CNewProjectWizard& cnpwOwner) : 
    CPropertyPage(CRunUniTool::IDD), m_cnpwOwner(cnpwOwner) {
	//{{AFX_DATA_INIT(CRunUniTool)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT
}

CRunUniTool::~CRunUniTool() {
}

void CRunUniTool::DoDataExchange(CDataExchange* pDX) {
	CPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CRunUniTool)
		// NOTE: the ClassWizard will add DDX and DDV calls here
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CRunUniTool, CPropertyPage)
	//{{AFX_MSG_MAP(CRunUniTool)
	ON_BN_CLICKED(IDC_RunUniTool, OnRunUniTool)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CRunUniTool message handlers

void CRunUniTool::OnRunUniTool() {
	//  Not too terribly difficult, really.  Invoke UniTool, which resides
    //  in the same directory we came from.  Then wait for the user to close it.

    STARTUPINFO         si = {sizeof si, NULL, NULL, NULL, 0, 0, 0, 0, 0, 0, 0,
                        STARTF_FORCEONFEEDBACK, 0, 0, NULL, NULL, NULL, NULL};
    PROCESS_INFORMATION pi;

    CString csCommand("Unitool ");

    csCommand += m_cnpwOwner.Project().SourceFile();

    if  (!CreateProcess(NULL, const_cast <LPTSTR> ((LPCTSTR) csCommand), NULL,
        NULL, FALSE, CREATE_SEPARATE_WOW_VDM, NULL, 
        m_cnpwOwner.Project().TargetPath(Win95), &si, &pi)) {
        TRACE("Failed to run Unitool, reason %d <%X>\r\n", GetLastError(),
            GetLastError());
        AfxMessageBox(IDS_UnitoolNotRun);
        return;
    }

    CloseHandle(pi.hThread);    //  We'll wait on the process.
    WaitForSingleObject(pi.hProcess, INFINITE);
    CloseHandle(pi.hProcess);
}

/******************************************************************************

  CRunUniTool::OnSetActive

  We never force this to be run, anymore, so just enable both buttons.

******************************************************************************/

BOOL CRunUniTool::OnSetActive() {
	//  We need to deactivate the Next button if Unitool has not yet been run
    //  on this driver.

    m_cnpwOwner.SetWizardButtons(PSWIZB_BACK | PSWIZB_NEXT);
	
	return CPropertyPage::OnSetActive();
}

/******************************************************************************

  CRunUniTool::OnWizardNext

  Go right on ahead, unless the RC file isn't translatable...

******************************************************************************/

LRESULT CRunUniTool::OnWizardNext() {
	//  One last check- we must be able to load and understand the RC file
    //  before we proceed.

    if  (!m_cnpwOwner.Project().LoadResources()) {
        AfxMessageBox(IDS_RCLoadFailed);
        return  -1;
    }

    return CPropertyPage::OnWizardNext();
}

/////////////////////////////////////////////////////////////////////////////
// CConvertFiles property page

CConvertFiles::CConvertFiles(CNewProjectWizard& cnpwOwner) : 
CPropertyPage(CConvertFiles::IDD), m_cnpwOwner(cnpwOwner) {
	//{{AFX_DATA_INIT(CConvertFiles)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT
}

CConvertFiles::~CConvertFiles() {
}

void CConvertFiles::DoDataExchange(CDataExchange* pDX) {

    CPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CConvertFiles)
		// NOTE: the ClassWizard will add DDX and DDV calls here
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CConvertFiles, CPropertyPage)
	//{{AFX_MSG_MAP(CConvertFiles)
	ON_BN_CLICKED(IDC_ConvertFiles, OnConvertFiles)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CConvertFiles message handlers

/******************************************************************************

  CConvertFiles::OnSetActive

  This handler is called whenever the user navigates to where this sheet is 
  active.

******************************************************************************/

BOOL CConvertFiles::OnSetActive() {

    //  If there is no NT GPC work to be done, we can be done with it.
	m_cnpwOwner.SetWizardButtons(PSWIZB_BACK | 
        (m_cnpwOwner.Project().IsTargetEnabled(WinNT3x | WinNT40) ? 
            0 : PSWIZB_DISABLEDFINISH));

    //  Set the radio buttons according to the selected GPD conversions

    CheckRadioButton(IDC_Direct, IDC_SpoolerNames, 
        IDC_Direct + m_cnpwOwner.GPDConvertFlag());
	
	return CPropertyPage::OnSetActive();
}

/******************************************************************************

  CConvertFiles::OnConvertFiles

  Message handler for the user pressing the Convert Files button.

******************************************************************************/

void CConvertFiles::OnConvertFiles() {

    //  This might take a while, so...
    CWaitCursor cwc;

    //  We now need to generate ALL of the necessary files
    m_cnpwOwner.GPDConvertFlag(
        GetCheckedRadioButton(IDC_Direct, IDC_SpoolerNames) - IDC_Direct);
    m_cnpwOwner.Project().GenerateTargets(m_cnpwOwner.GPDConvertFlag());
    if  (m_cnpwOwner.Project().ConversionsComplete())
        m_cnpwOwner.SetWizardButtons(PSWIZB_BACK |
            (m_cnpwOwner.Project().IsTargetEnabled(WinNT3x | WinNT40) ? 
                PSWIZB_NEXT : PSWIZB_FINISH));
}

/******************************************************************************

  CConvertFiles::OnKillActive

  This is called whenever the page is dismissed.  We save the GPD conversion
  flag, in case we come back to this page later.

******************************************************************************/

BOOL CConvertFiles::OnKillActive() {
	m_cnpwOwner.GPDConvertFlag(
        GetCheckedRadioButton(IDC_Direct, IDC_SpoolerNames) - IDC_Direct);

    return CPropertyPage::OnKillActive();
}

/////////////////////////////////////////////////////////////////////////////
// CRunNTGPC property page

CRunNTGPC::CRunNTGPC(CNewProjectWizard &cnpwOwner) : 
    CPropertyPage(CRunNTGPC::IDD), m_cnpwOwner(cnpwOwner) {
	//{{AFX_DATA_INIT(CRunNTGPC)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT
}

CRunNTGPC::~CRunNTGPC() {
}

void CRunNTGPC::DoDataExchange(CDataExchange* pDX) {
	CPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CRunNTGPC)
		// NOTE: the ClassWizard will add DDX and DDV calls here
	//}}AFX_DATA_MAP
}

BEGIN_MESSAGE_MAP(CRunNTGPC, CPropertyPage)
	//{{AFX_MSG_MAP(CRunNTGPC)
	ON_BN_CLICKED(IDC_RunNtGpcEdit, OnRunNtGpcEdit)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CRunNTGPC message handlers

void CRunNTGPC::OnRunNtGpcEdit() {
	//  We only hit this step if we are building for NT 3.x or 4.0, so see
    //  which it is.

    CProjectRecord& cprThis = m_cnpwOwner.Project();

    UINT    ufEdit = cprThis.IsTargetEnabled(WinNT3x) ? WinNT3x : WinNT40;

    //  Not too terribly difficult, really.  Invoke the editor, which resides
    //  in the same directory we came from.  Wait for the user to close it.

    STARTUPINFO         si = {sizeof si, NULL, NULL, NULL, 0, 0, 0, 0, 0, 0, 0,
                        STARTF_FORCEONFEEDBACK, 0, 0, NULL, NULL, NULL, NULL};
    PROCESS_INFORMATION pi;

    CString csCommand("NTGPCEdt ");

    csCommand += cprThis.RCName(ufEdit);

    if  (!CreateProcess(NULL, const_cast <LPTSTR> ((LPCTSTR) csCommand), NULL,
        NULL, FALSE, CREATE_SEPARATE_WOW_VDM, NULL, 
        m_cnpwOwner.Project().TargetPath(ufEdit), &si, &pi)) {
        TRACE("Failed to run NTGPCEdt, reason %d <%X>\r\n", GetLastError(),
            GetLastError());
        AfxMessageBox(IDS_UnitoolNotRun);
        return;
    }

    CloseHandle(pi.hThread);    //  We'll wait on the process.
    WaitForSingleObject(pi.hProcess, INFINITE);
    CloseHandle(pi.hProcess);

    //  Copy the NT GPC file, if necessary}

    if  (ufEdit == WinNT3x && cprThis.IsTargetEnabled(WinNT40))
        CopyFile(cprThis.TargetPath(WinNT3x) + _TEXT("\\NT.GPC"), 
            cprThis.TargetPath(WinNT40) + _TEXT("\\NT.GPC"), FALSE);

    m_cnpwOwner.SetWizardButtons(PSWIZB_BACK | PSWIZB_FINISH);
    m_cnpwOwner.Project().OldStuffDone();
}

BOOL CRunNTGPC::OnSetActive() {
    m_cnpwOwner.SetWizardButtons(PSWIZB_BACK | 
        (m_cnpwOwner.Project().NTGPCCompleted() ?
            PSWIZB_FINISH : PSWIZB_DISABLEDFINISH));
	
	return CPropertyPage::OnSetActive();
}

/////////////////////////////////////////////////////////////////////////////
// CMapCodePages property page

CMapCodePages::CMapCodePages(CNewProjectWizard& cnpwOwner) : 
    CPropertyPage(CMapCodePages::IDD), m_cnpwOwner(cnpwOwner) {
	//{{AFX_DATA_INIT(CMapCodePages)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT
}

CMapCodePages::~CMapCodePages() {
}

void CMapCodePages::DoDataExchange(CDataExchange* pDX) {
	CPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CMapCodePages)
	DDX_Control(pDX, IDC_TableToPage, m_clbMapping);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CMapCodePages, CPropertyPage)
	//{{AFX_MSG_MAP(CMapCodePages)
	ON_BN_CLICKED(IDC_ChangeCodePage, OnChangeCodePage)
	ON_LBN_DBLCLK(IDC_TableToPage, OnChangeCodePage)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CMapCodePages message handlers

BOOL CMapCodePages::OnSetActive() {

    m_cnpwOwner.SetWizardButtons(PSWIZB_BACK | PSWIZB_NEXT);

    m_clbMapping.ResetContent();

    for (unsigned u = 0; u < m_cnpwOwner.Project().MapCount(); u++) {
        CGlyphMap& cgm = m_cnpwOwner.Project().GlyphMap(u);
        int id = m_clbMapping.AddString(cgm.Name() + _TEXT("->") +
            cgm.PageName(0));
        m_clbMapping.SetItemData(id, u);
    }

    m_clbMapping.SetCurSel(0);
	
	return CPropertyPage::OnSetActive();
}

/******************************************************************************

  CMapCodePages::OnChangeCodePaage

  Response to the Change Code Page button.  Invoke the change code page dialog,
  and pass the new selection to the underlying glyph map.  Update the info in
  list, too...

******************************************************************************/

void CMapCodePages::OnChangeCodePage() {
    int idSel = m_clbMapping.GetCurSel();
    if  (idSel < 0)
        return;

    unsigned uidTable = m_clbMapping.GetItemData(idSel);

    CGlyphMap&  cgm =  m_cnpwOwner.Project().GlyphMap(uidTable);
	CSelectCodePage cscp(this, cgm.Name(), cgm.PageID(0));

    if  (cscp.DoModal() == IDOK) {
        cgm.SetDefaultCodePage(cscp.SelectedCodePage());

        //  Update the control- alas, this means filling it all in.

        m_clbMapping.ResetContent();

        for (unsigned u = 0; u < m_cnpwOwner.Project().MapCount(); u++) {
            CGlyphMap& cgm = m_cnpwOwner.Project().GlyphMap(u);
            int id = m_clbMapping.AddString(cgm.Name() + _TEXT("->") +
                cgm.PageName(0));
            m_clbMapping.SetItemData(id, u);
            if  (u == uidTable)
                m_clbMapping.SetCurSel(id);
        }
    }
}

LRESULT CMapCodePages::OnWizardNext() {

	// If this fails, it will report why via a message box.

    CWaitCursor cwc;    //  Just in case this takes a while!
	
    return  m_cnpwOwner.Project().LoadFontData() ? 0 : -1;
}

/******************************************************************************

  CSelectCodePage class

  This class implements a dialog which is used in several places where 
  selection of a code page is desired.

******************************************************************************/

/******************************************************************************

  CSelectCodePage::CSelectCodePage

  The constructor for this class builds an array of the mapped code page names
  from the CCodePageInformation class.

******************************************************************************/

CSelectCodePage::CSelectCodePage(CWnd* pParent, CString csName, 
                                 unsigned uidCurrent)
	: CDialog(CSelectCodePage::IDD, pParent) {
	//{{AFX_DATA_INIT(CSelectCodePage)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT
    m_csName = csName;
    m_uidCurrent = uidCurrent;

    CCodePageInformation    ccpi;

    ccpi.Mapped(m_cdaPages);
}

void CSelectCodePage::DoDataExchange(CDataExchange* pDX) {
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CSelectCodePage)
	DDX_Control(pDX, IDC_SupportedPages, m_clbPages);
	//}}AFX_DATA_MAP
}

/******************************************************************************

  CSelectCodePage::GetCodePageName

  This returns the name of the selected code page.

******************************************************************************/

CString CSelectCodePage::GetCodePageName() const {
    CCodePageInformation    ccpi;

    return  ccpi.Name(m_uidCurrent);
}

/******************************************************************************

  CSelectCodePage::Exclude

  This member function receives a list of code pages which are not to be 
  displayed in the selection list.

******************************************************************************/

void    CSelectCodePage::Exclude(CDWordArray& cdaPariah) {

    for (int i = 0; i < cdaPariah.GetSize(); i++)
        for (int j = 0; j < m_cdaPages.GetSize(); j++)
            if  (cdaPariah[i] == m_cdaPages[j]) {
                m_cdaPages.RemoveAt(j);
                break;
            }
}

/******************************************************************************

  CSelectCodePage::LimitTo

  This member receives a list of the pages to select- this list supersedes the
  list of mapped tables we began with.

******************************************************************************/

void    CSelectCodePage::LimitTo(CDWordArray& cdaPages) {
    if  (!cdaPages.GetSize())
        return;

    m_cdaPages.Copy(cdaPages);
}

BEGIN_MESSAGE_MAP(CSelectCodePage, CDialog)
	//{{AFX_MSG_MAP(CSelectCodePage)
	ON_LBN_SELCHANGE(IDC_SupportedPages, OnSelchangeSupportedPages)
	ON_LBN_DBLCLK(IDC_SupportedPages, OnDblclkSupportedPages)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CSelectCodePage message handlers

BOOL CSelectCodePage::OnInitDialog() {
	CDialog::OnInitDialog();
	
	CString csTemp;

    GetWindowText(csTemp);
    csTemp += _TEXT(" ") + m_csName;
    SetWindowText(csTemp);

    CCodePageInformation    ccpi;

    for (int i = 0; i < m_cdaPages.GetSize(); i++) {
        int id = m_clbPages.AddString(ccpi.Name(m_cdaPages[i]));
        m_clbPages.SetItemData(id, m_cdaPages[i]);
    }

    //  The one to select is the current one

    for (i = 0; i < m_cdaPages.GetSize(); i++)
        if  (m_uidCurrent == m_clbPages.GetItemData(i))
        break;

    if  (i < m_cdaPages.GetSize())
        m_clbPages.SetCurSel(i);
    else {
        m_uidCurrent = m_clbPages.GetItemData(0);
        m_clbPages.SetCurSel(0);
    }
	
	return TRUE;  // return TRUE unless you set the focus to a control
}

//  When a new code page is selected, record its identity.

void CSelectCodePage::OnSelchangeSupportedPages() {
	//  Determine what the newly selected page is.

    int idCurrent = m_clbPages.GetCurSel();

    if  (idCurrent < 0)
        return;

    m_uidCurrent = m_clbPages.GetItemData(idCurrent);
}

void CSelectCodePage::OnDblclkSupportedPages() {
    CDialog::OnOK();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\tools\uni\minidev\newproj.h ===
/******************************************************************************

  Header File:  New Project Wizard.H

  This file defines the various classes which make up the new project/ new
  mini-driver wizard.  This is a key component of the studio, as it is the tool
  that kicks all the important conversions off for us.

  Copyright (c) 1997 by Microsoft Corporation.  All Rights Reserved.

  A Pretty Penny Enterprises Production

  Change History:
  02-03-1997    Bob_kjelgaard@Prodigy.Net   Created the initial version.

******************************************************************************/

#if !defined(NEW_PROJECT_WIZARD)
#define NEW_PROJECT_WIZARD

#if defined(LONG_NAMES)
#include    "Project Record.H"
#else
#include    "ProjRec.H"
#endif

//  An initial definition of the wizard class

class CNewProjectWizard;

/////////////////////////////////////////////////////////////////////////////
// CFirstNewWizardPage dialog

class CFirstNewWizardPage : public CPropertyPage {

    CNewProjectWizard&  m_cnpwOwner;

// Construction
public:
	CFirstNewWizardPage(CNewProjectWizard &cnpwOwner);
	~CFirstNewWizardPage();

// Dialog Data
	//{{AFX_DATA(CFirstNewWizardPage)
	enum { IDD = IDD_FirstPageNewWizard };
		// NOTE - ClassWizard will add data members here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CFirstNewWizardPage)
	public:
	virtual BOOL OnSetActive();
	virtual LRESULT OnWizardNext();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CFirstNewWizardPage)
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};

/////////////////////////////////////////////////////////////////////////////
// CSelectTargets dialog

class CSelectTargets : public CPropertyPage {

    CNewProjectWizard&  m_cnpwOwner;

// Construction
public:
	CSelectTargets(CNewProjectWizard& cnpwOwner);
	~CSelectTargets();

// Dialog Data
	//{{AFX_DATA(CSelectTargets)
	enum { IDD = IDD_NPWSelectTargets };
		// NOTE - ClassWizard will add data members here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CSelectTargets)
	public:
	virtual BOOL OnSetActive();
	virtual LRESULT OnWizardNext();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CSelectTargets)
	virtual BOOL OnInitDialog();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};

/////////////////////////////////////////////////////////////////////////////
// CSelectDestinations dialog

class CSelectDestinations : public CPropertyPage {

    CNewProjectWizard&  m_cnpwOwner;

    void    DoDirectoryBrowser(unsigned uControl);
    BOOL    BuildStructure();

// Construction
public:
	CSelectDestinations(CNewProjectWizard& cnpwOwner);
	~CSelectDestinations();

// Dialog Data
	//{{AFX_DATA(CSelectDestinations)
	enum { IDD = IDD_NPWSelectDest };
	CButton	m_cbBrowseNT3x;
	CButton	m_cbBrowseNT40;
	CButton	m_cbBrowseNT50;
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CSelectDestinations)
	public:
	virtual BOOL OnSetActive();
	virtual LRESULT OnWizardNext();
	virtual LRESULT OnWizardBack();
	virtual BOOL OnWizardFinish();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CSelectDestinations)
	virtual BOOL OnInitDialog();
	afx_msg void OnBrowseNT40();
	afx_msg void OnBrowseNT50();
	afx_msg void OnBrowseNT3x();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};

/////////////////////////////////////////////////////////////////////////////
// CRunUniTool dialog

class CRunUniTool : public CPropertyPage {
    CNewProjectWizard&  m_cnpwOwner;

// Construction
public:
	CRunUniTool(CNewProjectWizard& cnpwOwner);
	~CRunUniTool();

// Dialog Data
	//{{AFX_DATA(CRunUniTool)
	enum { IDD = IDD_RunUniTool };
		// NOTE - ClassWizard will add data members here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CRunUniTool)
	public:
	virtual BOOL OnSetActive();
	virtual LRESULT OnWizardNext();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CRunUniTool)
	afx_msg void OnRunUniTool();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};

/////////////////////////////////////////////////////////////////////////////
// CConvertFiles dialog

class CConvertFiles : public CPropertyPage {
    CNewProjectWizard&  m_cnpwOwner;

// Construction
public:
	CConvertFiles(CNewProjectWizard& cnpwOwner);
	~CConvertFiles();

// Dialog Data
	//{{AFX_DATA(CConvertFiles)
	enum { IDD = IDD_ConvertFiles };
		// NOTE - ClassWizard will add data members here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CConvertFiles)
	public:
	virtual BOOL OnSetActive();
	virtual BOOL OnKillActive();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CConvertFiles)
	afx_msg void OnConvertFiles();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};

/////////////////////////////////////////////////////////////////////////////
// CRunNTGPC dialog

class CRunNTGPC : public CPropertyPage {
    CNewProjectWizard&  m_cnpwOwner;

// Construction
public:
	CRunNTGPC(CNewProjectWizard& cnpwOwner);
	~CRunNTGPC();

// Dialog Data
	//{{AFX_DATA(CRunNTGPC)
	enum { IDD = IDD_GPCEditor };
		// NOTE - ClassWizard will add data members here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CRunNTGPC)
	public:
	virtual BOOL OnSetActive();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CRunNTGPC)
	afx_msg void OnRunNtGpcEdit();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};

/////////////////////////////////////////////////////////////////////////////
// CMapCodePages dialog

class CMapCodePages : public CPropertyPage {
    CNewProjectWizard&  m_cnpwOwner;

// Construction
public:
	CMapCodePages(CNewProjectWizard& cnpwOwner);
	~CMapCodePages();

// Dialog Data
	//{{AFX_DATA(CMapCodePages)
	enum { IDD = IDD_NPWCodePageSelection };
	CListBox	m_clbMapping;
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CMapCodePages)
	public:
	virtual BOOL OnSetActive();
	virtual LRESULT OnWizardNext();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CMapCodePages)
	afx_msg void OnChangeCodePage();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};

/////////////////////////////////////////////////////////////////////////////
// CNewProjectWizard

class CNewProjectWizard : public CPropertySheet {

    CProjectRecord& m_cprThis;  //  The project being set up
    BOOL                m_bFastConvert; //  Normal/Custom conversion flag
    WORD                m_eGPDConvert; //  Flag for GPD conversion

    //  Property pages contained in this wizard.
    CFirstNewWizardPage m_cfnwp;
    CSelectTargets      m_cst;
    CSelectDestinations m_csd;
    CRunUniTool         m_crut;
    CMapCodePages       m_cmcp;
    CRunNTGPC           m_crng;
    CConvertFiles       m_ccf;

// Construction
public:
	CNewProjectWizard(CProjectRecord& cprFor, CWnd* pParentWnd = NULL);
	
// Attributes
public:

    CProjectRecord& Project() { return m_cprThis; }
    BOOL            FastConvert() const { return m_bFastConvert; }

    enum    {Direct, Macro, CommonRC, CommonRCWithSpoolerNames};
    WORD            GPDConvertFlag() const { return m_eGPDConvert; }

// Operations
public:

    void            FastConvert(BOOL bFastConvert) { 
        m_bFastConvert = bFastConvert;
    }

    void            GPDConvertFlag(WORD wf) { m_eGPDConvert = wf; }

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CNewProjectWizard)
	//}}AFX_VIRTUAL

// Implementation
public:
	virtual ~CNewProjectWizard();

	// Generated message map functions
protected:
	//{{AFX_MSG(CNewProjectWizard)
	afx_msg BOOL OnNcCreate(LPCREATESTRUCT lpCreateStruct);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};
/////////////////////////////////////////////////////////////////////////////
// CSelectCodePage dialog

class CSelectCodePage : public CDialog {
    CString     m_csName;
    unsigned    m_uidCurrent;
    CDWordArray m_cdaPages;
// Construction
public:
	CSelectCodePage(CWnd* pParent, CString csName, unsigned uidPage);

    unsigned    SelectedCodePage() const { return m_uidCurrent; }
    CString     GetCodePageName() const;

    void        Exclude(CDWordArray& cdaExclude);
    void        LimitTo(CDWordArray& cdaExclusive);

// Dialog Data
	//{{AFX_DATA(CSelectCodePage)
	enum { IDD = IDD_SelectPage };
	CListBox	m_clbPages;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CSelectCodePage)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CSelectCodePage)
	virtual BOOL OnInitDialog();
	afx_msg void OnSelchangeSupportedPages();
	afx_msg void OnDblclkSupportedPages();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\tools\uni\minidev\projview.h ===
/******************************************************************************

  Header File:  Project View.H

  This defines the class which provides the UI for viewing and manipulating
  project level information for the studio.

  Copyright (c) 1997 by Microsoft Corporaiton.  All Rights Reserved.

  A Pretty Penny Enterprises Production.

  Change History:
  02-03-1997    Bob_Kjelgaard@Prodigy.Net   Created it

******************************************************************************/
#if defined(LONG_NAMES)
#include    "Project Record.H"
#else
#include    "ProjRec.H"
#endif

class CProjectView : public CFormView {
protected: // create from serialization only
	CProjectView();
	DECLARE_DYNCREATE(CProjectView)

// Attributes
public:
	//{{AFX_DATA(CProjectView)
	enum { IDD = IDD_ProjectForm };
	CTreeCtrl	m_ctcDriver;
	//}}AFX_DATA
	CProjectRecord* GetDocument();

// Operations
public:

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CProjectView)
	public:
	virtual BOOL PreCreateWindow(CREATESTRUCT& cs);
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	virtual void OnInitialUpdate(); // called first time after construct
	virtual BOOL OnPreparePrinting(CPrintInfo* pInfo);
	virtual void OnBeginPrinting(CDC* pDC, CPrintInfo* pInfo);
	virtual void OnEndPrinting(CDC* pDC, CPrintInfo* pInfo);
	//}}AFX_VIRTUAL

// Implementation
public:
	virtual ~CProjectView();
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif

protected:

    //  Messages generated by tree view nodes derived from CProjectNode
    afx_msg void    OnExpandBranch();
    afx_msg void    OnCollapseBranch();
    afx_msg void    OnRenameItem();
    afx_msg void    OnOpenItem();
    afx_msg void    OnGenerateItem();
    afx_msg void    OnImport();
    afx_msg void    OnDeleteItem();

// Generated message map functions
protected:
	//{{AFX_MSG(CProjectView)
	afx_msg void OnBeginlabeleditDriverView(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnEndLabelEdit(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnContextMenu(CWnd* pWnd, CPoint point);
	afx_msg void OnDblclkDriverView(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnFileParse();
	afx_msg void OnKeydownDriverView(NMHDR* pNMHDR, LRESULT* pResult);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

#ifndef _DEBUG  // debug version in Project View.cpp
inline CProjectRecord* CProjectView::GetDocument()
   { return (CProjectRecord*)m_pDocument; }
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\tools\uni\minidev\rcfile.cpp ===
/******************************************************************************

  Source File:  Driver Resources.CPP

  This implements the driver resource class, which tracks the resources in the
  driver.

  Copyright (c) 1997 by Microsoft Corporation.  All Rights Reserved.

  A Pretty Penny Enterprises Production.

  Change History:
  02-08-1997    Bob_Kjelgaard@Prodigy.Net   Created it

******************************************************************************/

#include    "StdAfx.h"
#include    "MiniDev.H"
#include    "ModlData\Resource.H"
#include    "ProjRec.H"

//  First, we're going to implement the CStringTable class

IMPLEMENT_SERIAL(CStringTable, CObject, 0)

CString CStringTable::operator[](WORD wKey) const {

    for (unsigned u = 0; u < Count(); u++)
        if  (wKey == m_cuaKeys[u])
            break;

    return  u < Count() ? m_csaValues[u] : m_csEmpty;
}

void    CStringTable::Map(WORD wKey, CString csValue) {
    if  (!wKey || csValue.IsEmpty()) return;

    if  (!Count() || wKey > m_cuaKeys[-1 + Count()]) {
        m_cuaKeys.Add(wKey);
        m_csaValues.Add(csValue);
        return;
    }

    for (unsigned u = 0; u < Count(); u++)
        if  (m_cuaKeys[u] >= wKey)
            break;

    if  (m_cuaKeys[u] != wKey){
        m_cuaKeys.InsertAt(u, wKey);
        m_csaValues.InsertAt(u, csValue);
    }
    else
        m_csaValues.SetAt(u, csValue);
}

void    CStringTable::Remove(WORD wKey) {

    for (unsigned u = 0; u < Count(); u++)
        if  (wKey >= m_cuaKeys[u])
            break;

    if  (u == Count() || wKey != m_cuaKeys[u])
        return;
    m_csaValues.RemoveAt(u);
    m_cuaKeys.RemoveAt(u);
}

void    CStringTable::Details(unsigned u, WORD &wKey, CString &csValue) {
    if  (u > Count()) u = 0;
    wKey = m_cuaKeys[u];

    csValue = operator[](wKey);
}

void    CStringTable::Serialize(CArchive& car) {
    CObject::Serialize(car);
    m_cuaKeys.Serialize(car);
    m_csaValues.Serialize(car);
}

IMPLEMENT_SERIAL(CDriverResources, CBasicNode, 0)

void    CDriverResources::Serialize(CArchive& car) {
    CBasicNode::Serialize(car);

    m_csaIncludes.Serialize(car);
    m_csoaFonts.Serialize(car);
    m_csaTables.Serialize(car);
    m_csoaAtlas.Serialize(car);
    m_csaDefineNames.Serialize(car);
    m_csaDefineValues.Serialize(car);
    m_cst.Serialize(car);
    m_csaRemnants.Serialize(car);
    m_csoaModels.Serialize(car);
}

/******************************************************************************

  CDriverResources::CheckTable(int iWhere, CString csLine, 
    CStringTable& cstTarget)

  Internal work routine- this looks at a line, and some parameters, decides
  whether to work on it or not, and if it does, validates the resource number
  and adds the file name and resource number to its list.

  This override is needed because the resource IDs for translation tables have
  not heretofore been a compact set.

******************************************************************************/

UINT    CDriverResources::CheckTable(int iWhere, CString csLine, 
                                     CStringTable& cstTarget) {
    if  (iWhere == -1)
        return  ItWasIrrelevant;

    //  See if the ID is valid or not.  It must be an integer > 0

    int iKey = atoi(csLine);

    if  (iKey < 0 || iKey > 0x7FFF) //  Valid range for resource IDs in Win16
        return  ItFailed;

    for (int i = -1 + csLine.GetLength(); i; i--) {
        if  (csLine[i] == _TEXT(' ') || csLine[i] == _TEXT('\t'))
            break;
    }

    if  (!i)
        return  ItFailed;

    cstTarget.Map((WORD) iKey, csLine.Mid(++i));

    return  ItWorked;
}

/******************************************************************************

  CDriverResources::CheckTable(int iWhere, CString csLine, 
    CStringArray& csaTarget)

  Internal work routine- this looks at a line, and some parameters, decides
  whether to work on it or not, and if it does, validates the resource number
  and adds the file name to its list.

******************************************************************************/

UINT    CDriverResources::CheckTable(int iWhere, CString csLine, 
                                     CStringArray& csaTarget, 
                                     BOOL bSansExtension) {
    if  (iWhere == -1)
        return  ItWasIrrelevant;

    //  See if the name is valid or not

    if  (atoi(csLine) != 1 +csaTarget.GetSize())
        return  ItFailed;

    for (int i = -1 + csLine.GetLength(); i; i--) {
        if  (csLine[i] == _TEXT(' ') || csLine[i] == _TEXT('\t'))
            break;
    }

    if  (!i)
        return  ItFailed;

    if  (!bSansExtension) {
        //  Don't bother to strip the extension
        csaTarget.Add(csLine.Mid(++i));
        return  ItWorked;
    }

    //  Strip everything after the last period.

    CString csName = csLine.Mid(++i);

    if  (csName.ReverseFind(_T('.')) > csName.ReverseFind(_T('\\')))
        csName = csName.Left(csName.ReverseFind(_T('.')));

    csaTarget.Add(csName);

    return  ItWorked;
}

//  Private work member.  This parses a line from a string table to extract
//  the value and the string itself.

BOOL    CDriverResources::AddStringEntry(CString csLine) {

    WORD    wKey = (WORD) atoi(csLine);

    if  (!wKey)
        return  FALSE;  //  0 is not a valid resource number...

    csLine = csLine.Mid(csLine.Find("\""));
    csLine = csLine.Mid(1, -2 + csLine.GetLength());

    m_cst.Map(wKey, csLine);

    return  TRUE;
}

//  Constructor- would be trivial, except we need to initialize some of the
//  fancier UI objects

CDriverResources::CDriverResources() : m_cfnAtlas(IDS_Atlas, m_csoaAtlas),
    m_cfnFonts(IDS_FontList, m_csoaFonts), 
    m_cfnModels(IDS_Models, m_csoaModels, GPDTemplate(), 
        RUNTIME_CLASS(CModelData)) {
    m_cwaMenuID.Add(ID_ExpandBranch);
    m_cwaMenuID.Add(ID_CollapseBranch);
    m_cfnAtlas.SetMenu(m_cwaMenuID);
    m_cfnFonts.SetMenu(m_cwaMenuID);
    m_cfnModels.SetMenu(m_cwaMenuID);
    m_cwaMenuID.InsertAt(0, 0, 1);
    m_cwaMenuID.InsertAt(0, ID_RenameItem);
    m_ucSynthesized = 0;
}

//  Member function for returning a GPC file name.  These come ready for
//  concatenation, so they are preceded by '\'

CString CDriverResources::GPCName(unsigned u) {
    CString csReturn('\\');
    
    csReturn += m_csaTables[u] + _TEXT(".GPC");

    return  csReturn;
}

/******************************************************************************

  ReportFileFailure

  This is a private routine- it loads a string table resource with an error
  message, formats it using the given file name, displays a message box,
  then returns FALSE.

******************************************************************************/

static BOOL ReportFileFailure(int idMessage, LPCTSTR lpstrFile) {
    CString csMessage;

    csMessage.Format(idMessage, lpstrFile);
    AfxMessageBox(csMessage.IsEmpty()? lpstrFile : csMessage, MB_ICONSTOP);
    return  FALSE;
}

/******************************************************************************

  CDriverResources::Load

  This function loads and reads the RC file for the driver, and determines all
  of the needed resources.  It initializes the structures used to fetermine the
  glyph map file set, font file set, etc.

******************************************************************************/

BOOL    CDriverResources::Load(class CProjectRecord& cprOwner) {

    CWaitCursor     cwc;    //  Just in case this takes a while...
    NoteOwner(cprOwner);

    CStringArray    csaContents;

    if  (!LoadFile(cprOwner.SourceFile(), csaContents))
        return  FALSE;

    //  Clean everything up, in case we were previously loaded...
    m_csaDefineNames.RemoveAll();
    m_csaDefineValues.RemoveAll();
    m_csoaFonts.RemoveAll();
    m_csaIncludes.RemoveAll();
    m_csoaAtlas.RemoveAll();
    m_csoaModels.RemoveAll();
    m_csaRemnants.RemoveAll();
    m_csaTables.RemoveAll();
    m_cst.Reset();

    //  Let the parsing begin

    BOOL    bLookingForBegin = FALSE, bLookingForEnd = FALSE;

    CStringArray    csaFonts;    //  Names First!

    //  03-14-1997  We can't assume sequential numbering of the table resources

    CStringTable    cstMaps;

    for (BOOL bInComment = FALSE; 
         csaContents.GetSize(); 
         csaContents.RemoveAt(0)) {

        //  If stripping out a comment, keep doing it until done.

        if  (bInComment) {

            if  (csaContents[0].Find(_TEXT("*/")) == -1)
                continue;

            csaContents[0] =
                csaContents[0].Mid(csaContents[0].Find(_TEXT("*/")) + 2);

            bInComment = FALSE;
        }

        //  Strike all empty lines and remove all comments and leading blanks

        if  (csaContents[0].Find(_TEXT("//")) != -1)
            csaContents[0] = 
            csaContents[0].Left(csaContents[0].Find(_TEXT("//")));

        //  If this is the other style comment, zap it, as well

        while   (-1 != csaContents[0].Find(_TEXT("/*"))) {

            if  (csaContents[0].Find(_TEXT("*/")) > 
                csaContents[0].Find(_TEXT("/*"))) {
                //  strip out everything between them

                csaContents[0] = 
                    csaContents[0].Left(csaContents[0].Find(_TEXT("/*"))) +
                    csaContents[0].Mid(csaContents[0].Find(_TEXT("*/")) + 2);
            }
            else {
                csaContents[0] = 
                    csaContents[0].Left(csaContents[0].Find(_TEXT("/*")));
                bInComment = TRUE;
            }
        }

        //  Now for the leading blanks and trailing blanks

        csaContents[0].TrimLeft();
        csaContents[0].TrimRight();

        if  (csaContents[0].IsEmpty())
            continue;

        //  If we are processing a string table, press onward...

        if  (bLookingForBegin) {
            if  (csaContents[0].CompareNoCase(_TEXT("BEGIN")))
                return  FALSE;  //  Parsing failure
            bLookingForBegin = FALSE;
            bLookingForEnd = TRUE;
            continue;
        }

        if  (bLookingForEnd) {
            if  (!csaContents[0].CompareNoCase(_TEXT("END"))) {
                bLookingForEnd = FALSE;
                continue;
            }

            if  (!AddStringEntry(csaContents[0]))
                return  FALSE;  //  Parsing error

            continue;
        }

        //  If it is an include, add it to the list

        if  (csaContents[0].Find(_TEXT("#include")) != -1) {
            csaContents[0] = 
                csaContents[0].Mid(csaContents[0].Find(_TEXT("#include")) + 8);
            csaContents[0].TrimLeft();
            m_csaIncludes.Add(csaContents[0]);
            continue;
        }

        //  If it is a #define, do the same

        if  (csaContents[0].Find(_TEXT("#define")) != -1) {
            csaContents[0] = 
                csaContents[0].Mid(csaContents[0].Find(_TEXT("#define")) + 7);
            csaContents[0].TrimLeft();
            //  TODO:   Handle macros with parameters
            m_csaDefineNames.Add(csaContents[0].SpanExcluding(_TEXT(" \t")));
            csaContents[0] = 
                csaContents[0].Mid(
                    m_csaDefineNames[-1 + m_csaDefineNames.GetSize()].
                    GetLength());
            csaContents[0].TrimLeft();
            m_csaDefineValues.Add(csaContents[0]);
            continue;
        }

        //  GPC Tables, fonts, Glyph Tables
        switch  (CheckTable(csaContents[0].Find(_TEXT("RC_TABLES")), 
                    csaContents[0], m_csaTables)) {
            case    ItWorked:
                continue;
            case    ItFailed:
                return  FALSE;  //  Parsing error
        }

        switch  (CheckTable(csaContents[0].Find(_TEXT("RC_FONT")),
                    csaContents[0], csaFonts, FALSE)) {
            case    ItWorked:
                continue;
            case    ItFailed:
                return  FALSE;  //  Parsing error
        }

        switch  (CheckTable(csaContents[0].Find(_TEXT("RC_TRANSTAB")),
                    csaContents[0], cstMaps)) {
            case    ItWorked:
                continue;
            case    ItFailed:
                return  FALSE;  //  Parsing error
        }

        //  String table...

        if  (csaContents[0].CompareNoCase(_TEXT("STRINGTABLE")))
            m_csaRemnants.Add(csaContents[0]);
        else
            bLookingForBegin = TRUE;
    }

    //  RAID 103242- people can load totally bogus files.  Die now if there is
    //  no GPC data as a result of this.

    if  (!m_csaTables.GetSize()) {
        AfxMessageBox(IDS_NoGPCData);
        return  FALSE;
    }

    //  End 103242

    if  (m_csaTables.GetSize() == 1)
        m_csaTables.Add(_TEXT("NT"));   //  Usually necessary.

    //  Now, let's name the translation tables- we wil load them later...

    for (unsigned u = 0; u < cstMaps.Count(); u++) {
        WORD    wKey;
        CString csName;
        m_csoaAtlas.Add(new CGlyphMap);
        cstMaps.Details(u, wKey, csName);
        GlyphTable(u).SetSourceName(cprOwner.TargetPath(Win95) + _T('\\') +
            csName);
        if  (!GlyphTable(u).SetFileName(cprOwner.TargetPath(WinNT50) + 
            _T("\\GTT\\") + GlyphTable(u).Name()))
            return  FALSE;
        GlyphTable(u).SetID(wKey);
    }

    //  Ditto for the fonts

    for (u = 0; u < (unsigned) csaFonts.GetSize(); u++) {
        m_csoaFonts.Add(new CFontInfo);
        Font(u).SetSourceName(cprOwner.TargetPath(Win95) + _T('\\') +
            csaFonts[u]);
        Font(u).SetUniqueName(m_csName);
        if  (!Font(u).SetFileName(cprOwner.TargetPath(WinNT50) + 
            _T("\\UFM\\") + Font(u).Name()))
            return  FALSE;
    }

    //  Now, cycle it again, but this time, make sure all of the root file
    //  names are unique

    for (u = 1; u < FontCount(); u++)
        for (unsigned uCompare = 0; uCompare < u; uCompare++)
            if  (!Font(uCompare).FileTitle().CompareNoCase(
                Font(u).FileTitle())) {
                //  Append an underscore to the name
                Font(u).ReTitle(Font(u).FileTitle() + _T('_'));
                uCompare = (unsigned) -1;   //  Check the names again
                Font(u).Rename(Font(u).Name() + _T('_'));
            }

    //  Attempt to load the GPC data if there is any.

    CFile               cfGPC;
    
    if  (!cfGPC.Open(cprOwner.TargetPath(Win95) + GPCName(0), 
        CFile::modeRead | CFile::shareDenyWrite) || !m_comdd.Load(cfGPC))

        return  ReportFileFailure(IDS_FileOpenError, 
            cprOwner.TargetPath(Win95) + GPCName(0));

    return  TRUE;
}

/******************************************************************************

  CDriverResource::LoadFontData

  This member function loads the CTT files from the Win 3.1 mini-driver to
  initialize the glyph table array.  It is a separate function because the
  Wizard must first verify the code page selection for each of the tables
  with the user.

******************************************************************************/

BOOL    CDriverResources::LoadFontData(CProjectRecord& cprOwner) {

    CWaitCursor cwc;

    //  Now, let's load the translation tables.

    for (unsigned u = 0; u < MapCount(); u++)
        //  Load the file..
        if  (!GlyphTable(u).ConvertCTT())
            return  ReportFileFailure(IDS_LoadFailure, 
                GlyphTable(u).SourceName());

    //  Now, let's load the Font Data.

    for (u = 0; u < FontCount() - m_ucSynthesized; u++) {

        //  Load the file..  (side effect of GetTranslation)
        if  (!Font(u).GetTranslation())
            return  ReportFileFailure(IDS_LoadFailure, Font(u).SourceName());

        //  Generate the CTT/PFM mapping so we generate UFMs correctly

        if  (!Font(u).Translation()) {
            /*
                For each model, check and see if this font is in its map.
                If it is, then add the CTT to the list used, and the model,
                as well.

            */

            CMapWordToDWord cmw2dCTT;   //  Used to count models per ID
            CWordArray      cwaModel;   //  Models which used this font
            DWORD           dwIgnore;

            for (unsigned uModel = 0; uModel < m_comdd.ModelCount(); uModel++)
                if  (m_comdd.FontMap(uModel).Lookup(u + 1, dwIgnore)) {
                    //  This model needs to be remembered, along with the CTT
                    cmw2dCTT[m_comdd.DefaultCTT(uModel)]++;
                    cwaModel.Add(uModel);
                }

            if  (!cmw2dCTT.Count()) {
                CString csDisplay;
                csDisplay.Format(IDS_UnusedFont, 
                    (LPCTSTR) Font(u).SourceName());
                AfxMessageBox(csDisplay);
                continue;
            }

            if  (cmw2dCTT.Count() == 1) {
                //  Only one CTT ID was actually used.
                Font(u).SetTranslation(m_comdd.DefaultCTT(cwaModel[0]));
                continue;   //  We're done with this one
            }

            /*

                OK, this font has multiple CTTs in different models.  Each
                will require a new UFM to be created.  The IDs of the new UFMs
                need to be added to the set, the new defaults established, and
                a list of the font ID remapping needed for each model all need
                maintenance.

            */

            unsigned uGreatest = 0;

            for (POSITION pos = cmw2dCTT.GetStartPosition(); pos; ) {
                WORD    widCTT;
                DWORD   dwcUses;
    
                cmw2dCTT.GetNextAssoc(pos, widCTT, dwcUses);
                if  (dwcUses > uGreatest) {
                    uGreatest = dwcUses;
                    Font(u).SetTranslation(widCTT);
                }
            }

            //  The models that used the most common CTT will be dropped from
            //  the list

            for (uModel = (unsigned) cwaModel.GetSize(); uModel--; )
                if  (m_comdd.DefaultCTT(cwaModel[uModel]) == Font(u).Translation())
                    cwaModel.RemoveAt(uModel);

            //  Now, we create a new UFM for each CTT ID, and add the new index to
            //  the mapping required for the each affected model.

            m_ucSynthesized += cmw2dCTT.Count() - 1;

            for (pos = cmw2dCTT.GetStartPosition(); pos; ) {

                WORD    widCTT;
                DWORD   dwcUses;

                cmw2dCTT.GetNextAssoc(pos, widCTT, dwcUses);

                if  (widCTT == Font(u).Translation())
                    continue;   //  This one has already been done.
                
                m_csoaFonts.Add(new CFontInfo(Font(u), widCTT));

                for (uModel = (unsigned) cwaModel.GetSize(); uModel--; )
                    if  (m_comdd.DefaultCTT(cwaModel[uModel]) == widCTT) {
                        m_comdd.NoteTranslation(cwaModel[uModel], u + 1, 
                            FontCount());
                        cwaModel.RemoveAt(uModel);
                    }
            }

        }
    }

    //  Point each font at its associated GTT file, if there is one

    for (u = 0; u < FontCount(); u++)
        for (unsigned uGTT = 0; uGTT < MapCount(); uGTT++)
            if  (Font(u).Translation() == GlyphTable(uGTT).GetID())
                Font(u).SetTranslation(&GlyphTable(uGTT));

    Changed();

    return  TRUE;
}

/******************************************************************************

  CDriverResources::ConvertGPCData

  This will handle the conversion of the GPC data to GPD format.  It has to be
  done after the framework (especially the target directory) is created.

******************************************************************************/

BOOL    CDriverResources::ConvertGPCData(CProjectRecord& cprOwner,
                                         WORD wfGPDConvert) {
    
    //  We've already loaded the GPC data, so now we just generate the files.

    for (unsigned u = 0; u < m_comdd.ModelCount(); u++) {
        m_csoaModels.Add(new CModelData);

        //  Some model names have invalid characters unsuitable for file names
        //  Remove these characters and warn the user about it.

        CString csModel = m_cst[m_comdd.ModelName(u)];

        while   (csModel.FindOneOf(_T(":<>/\\\"|")) >= 0)
            csModel.SetAt(csModel.FindOneOf(_T(":<>/\\\"|")), _T('_'));

        if  (csModel != m_cst[m_comdd.ModelName(u)]) {
            CString csDisplay;

            csDisplay.Format(IDS_RemovedInvalid, 
                (LPCTSTR) m_cst[m_comdd.ModelName(u)], (LPCTSTR) csModel);

            AfxMessageBox(csDisplay, MB_ICONINFORMATION);
        }

        if  (!Model(u).SetFileName(cprOwner.TargetPath(WinNT50) + _T("\\") + 
             csModel))
            return  FALSE;
        Model(u).Rename(m_cst[m_comdd.ModelName(u)]);
        Model(u).NoteOwner(cprOwner);
        Model(u).EditorInfo(GPDTemplate());
        if  (!Model(u).Load(m_comdd.Image(), Name(), u + 1, 
             m_comdd.FontMap(u), wfGPDConvert) || !Model(u).Store()) 
            return  ReportFileFailure(IDS_GPCConversionError, Model(u).Name());
    }

    Changed();
    return  TRUE;
}

/******************************************************************************

  CDriverResources::Generate

  This member function generates the RC file for one of the target environments

******************************************************************************/

BOOL    CDriverResources::Generate(UINT ufTarget, LPCTSTR lpstrPath) {

    CString csFontPrefix, csTransPrefix, csFontLabel, csTransLabel;
    unsigned    ucTables = 0, ucFonts = 
                    (ufTarget == WinNT50) ? FontCount() : OriginalFontCount();

    if  (ufTarget == WinNT50) {
        csFontLabel = _T("RC_UFM");
        csTransLabel = _T("RC_GTT");
    }
    else {
        csFontLabel = _T("RC_FONT");
        csTransLabel = _T("RC_TRANSTAB");
    }

    switch  (ufTarget) {
        case    WinNT50:
            csFontPrefix = _TEXT("UFM");
            csTransPrefix = _TEXT("GTT");
            break;

        case    WinNT40:
        case    WinNT3x:
            csFontPrefix = _TEXT("IFI");
            csTransPrefix = _TEXT("RLE");
            ucTables = 2;
            break;

        case    Win95:
            csFontPrefix = _TEXT("PFM");
            csTransPrefix = _TEXT("CTT");
            ucTables = 1;
            break;

        default:
            _ASSERTE(FALSE);    //  This shouldn't happen
            return  FALSE;
    }

    //  Create the RC file first.

    CStdioFile  csiof;

    if  (!csiof.Open(lpstrPath, CFile::modeCreate | CFile::modeWrite | 
            CFile::shareExclusive | CFile::typeText)) {
        _ASSERTE(FALSE);    //  This shouldn't be possible
        return  FALSE;
    }

    //  Write out our header- it identifies this tool as the source, and it
    //  will (eventually) include the Copyright and other strings used to
    //  customize the environment.
    try {
        csiof.WriteString(_TEXT("/********************************************")
            _TEXT("**********************************\n\n"));
        csiof.WriteString(_T("  RC file generated by the Minidriver ")
            _T("Development Tool\n\n"));
        csiof.WriteString(_TEXT("*********************************************")
            _TEXT("*********************************/\n\n"));

        //  Write out all of the includes except those with a ".ver" in them

        if  (ufTarget == WinNT50) { //  NT knows best.  What do developers know?
            csiof.WriteString(_T("#include <UniRC.H>\n"));
            if  (m_bUseCommonRC)
                csiof.WriteString(_T("#include <Common.RC>\n"));
            csiof.WriteString(_T("#include <Windows.H>\n"));
            csiof.WriteString(_T("#include <NTVerP.H>\n"));
            csiof.WriteString(_T("#define VER_FILETYPE VFT_DRV\n"));
            csiof.WriteString(_T("#define VER_FILESUBTYPE VFT2_DRV_PRINTER\n"));
            csiof.WriteString(_T("#define VER_FILEDESCRIPTION_STR \""));
            csiof.WriteString(Name());
            csiof.WriteString(_T(" Printer Driver\"\n"));
            csiof.WriteString(_T("#define VER_INTERNALNAME_STR \""));
            csiof.WriteString(Name().Left(5));
            csiof.WriteString(_T("res.dll\"\n"));
            csiof.WriteString(_T("#define VER_ORIGINALFILENAME_STR \""));
            csiof.WriteString(Name().Left(5));
            csiof.WriteString(_T("res.dll\"\n"));
            csiof.WriteString(_T("#include \"common.ver\"\n"));
        }
        else
            for (unsigned u = 0; u < (unsigned) m_csaIncludes.GetSize(); u++) {
                CString csTest = m_csaIncludes[u];
                csTest.MakeLower();
                if  (m_csaIncludes[u].Find(_TEXT(".ver")) != -1)
                    continue;
                csTest = _TEXT("#include ");
                csTest += m_csaIncludes[u] + _TEXT('\n');
                csiof.WriteString(csTest);
            }

        csiof.WriteString(_TEXT("\n"));

        //  Now, write out all of the #defines

        for (unsigned u = 0; u < (unsigned) m_csaDefineNames.GetSize(); u++) {
            CString csDefine;
            csDefine.Format(_TEXT("#define %-32s %s\n"), 
                (LPCTSTR) m_csaDefineNames[u], (LPCTSTR) m_csaDefineValues[u]);
            csiof.WriteString(csDefine);
        }

        csiof.WriteString(_TEXT("\n"));

        //  GPC tables

        if  (ufTarget != WinNT50)
            for (u = 0; u < ucTables; u++) {
                CString csLine;
                csLine.Format(_T("%-5u RC_TABLES PRELOAD MOVEABLE "), u + 1);
                if  (m_csaTables[u] != _T("NT"))
                    csLine += _T("\"");
                csLine += m_csaTables[u] + _T(".GPC");
                if  (m_csaTables[u] != _T("NT"))
                    csLine += _T("\"");
                csiof.WriteString(csLine + _T("\n"));
            }

        csiof.WriteString(_TEXT("\n"));

        //  Font tables
        
        for (u = 0; u < ucFonts; u++) {
            CString csLine;
#if defined(NOPOLLO)
            csLine.Format(_TEXT("%-5u %s LOADONCALL DISCARDABLE \""), 
                u + 1, (LPCTSTR) csFontLabel);
            csLine += csFontPrefix + _TEXT('\\') + Font(u).Name() + 
                _TEXT('.') + csFontPrefix + _TEXT("\"\n");
#else
            csLine.Format(_TEXT("%-5u %s LOADONCALL DISCARDABLE "), 
                u + 1, (LPCTSTR) csFontLabel);
            csLine += csFontPrefix + _TEXT('\\') + Font(u).Name() + 
                _TEXT('.') + csFontPrefix + _TEXT("\n");
#endif
            csiof.WriteString(csLine);
        }

        csiof.WriteString(_TEXT("\n"));

        //  Mapping tables
        
        for (u = 0; u < MapCount(); u++) {
            CString csLine;
#if defined(NOPOLLO)
            csLine.Format(_TEXT("%-5u %s LOADONCALL MOVEABLE \""), 
                u + 1, (LPCTSTR) csTransLabel);
            csLine += csTransPrefix + _TEXT('\\') + GlyphTable(u).Name() + 
                _TEXT('.') + csTransPrefix + _TEXT("\"\n");
#else
            csLine.Format(_TEXT("%-5u %s LOADONCALL MOVEABLE "), 
                u + 1, (LPCTSTR) csTransLabel);
            csLine += csTransPrefix + _TEXT('\\') + GlyphTable(u).Name() + 
                _TEXT('.') + csTransPrefix + _TEXT("\n");
#endif
            csiof.WriteString(csLine);
        }

        csiof.WriteString(_TEXT("\n"));

        //  Time to do the String Table
        if  (m_cst.Count()) {
            csiof.WriteString(_TEXT("STRINGTABLE\n  BEGIN\n"));
            for (u = 0; u < m_cst.Count(); u++) {
                WORD    wKey;
                CString csValue, csLine;

                m_cst.Details(u, wKey, csValue);

                csLine.Format(_TEXT("    %-5u  \""), wKey);
                csLine += csValue + _TEXT("\"\n");
                csiof.WriteString(csLine);
            }
            csiof.WriteString(_TEXT("  END\n\n"));
        }

        //  Now, write out any .ver includes

        if  (ufTarget != WinNT50)   //  Already hardcoded them here
            for (u = 0; u < (unsigned) m_csaIncludes.GetSize(); u++) {
                CString csTest = m_csaIncludes[u];
                csTest.MakeLower();
                if  (m_csaIncludes[u].Find(_TEXT(".ver")) == -1)
                    continue;
                csTest = _TEXT("#include ");
                csTest += m_csaIncludes[u] + _TEXT('\n');
                csiof.WriteString(csTest);
            }

        csiof.WriteString(_TEXT("\n"));
#if defined(NOPOLLO)
        //  Now, any of the remnants

        for (u = 0; u < (unsigned) m_csaRemnants.GetSize(); u++)
            csiof.WriteString(m_csaRemnants[u] + TEXT('\n'));
#endif
    }
    catch(CException* pce) {
        pce -> ReportError();
        pce -> Delete();
        return  FALSE;
    }

    return  TRUE;
}

/******************************************************************************

  CDriverResources::Fill

  This is a CProjectNode override- it fills in the material relevant to this
  driver.

******************************************************************************/

void    CDriverResources::Fill(CTreeCtrl *pctcWhere, CProjectRecord& cpr) {
    CWaitCursor cwc;

    NoteOwner(cpr);
    SetWorkspace(this);
    CBasicNode::Fill(pctcWhere);

    //  Fill in the font information
    m_cfnFonts.Fill(pctcWhere, m_hti);
    m_cfnFonts.NoteOwner(cpr);

    for (unsigned u = 0; u < FontCount(); u++) {
        Font(u).SetWorkspace(this);
        Font(u).EditorInfo(FontTemplate());
    }

    //  Fill in the glyph map information
    m_cfnAtlas.Fill(pctcWhere, m_hti);
    m_cfnAtlas.NoteOwner(cpr);
    for (u = 0; u < MapCount(); u++) {
        GlyphTable(u).SetWorkspace(this);
        GlyphTable(u).EditorInfo(GlyphMapDocTemplate());
    }

    //  Fill in the model data information.

    m_cfnModels.Fill(pctcWhere, m_hti);
    for (u = 0; u < Models(); u++) {
        Model(u).SetWorkspace(this);
        Model(u).EditorInfo(GPDTemplate());
    }
    m_cfnModels.NoteOwner(cpr);
    pctcWhere -> Expand(m_hti, TVE_EXPAND);

    //  Load the font and GTT files, then map them together.  Also load any
    //  predefined tables now.

    for (u = 0; u < MapCount(); u++)
        GlyphTable(u).Load();

    for (u = 0; u < FontCount(); u++) {
        Font(u).Load();
        if  (CGlyphMap::Public(Font(u).Translation()))
            Font(u).SetTranslation(CGlyphMap::Public(Font(u).Translation()));
        else
            for (unsigned uGTT = 0; uGTT < MapCount(); uGTT++)
                if  (Font(u).Translation() == GlyphTable(uGTT).GetID())
                    Font(u).SetTranslation(&GlyphTable(uGTT));
        Font(u).Load(); //  Try it again, now that we know the linkage.
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\tools\uni\minidev\projrec.h ===
/******************************************************************************

  Header File:  Project Record.H

  This defines the CProjectRecord class, which tracks and controls the progress
  and content of a single project workspace in the studio.

  Copyright (c) 1997 by Microsoft Corporation.  All Rights Reserved.

  A Pretty Penny Enterprises Production.

  Change History:
  02-03-1997    Bob_Kjelgaard@Prodigy.Net   Created it

******************************************************************************/

#if defined(LONG_NAMES)
#include    "Driver Resources.H"
#else
#include    "RCFile.H"
#endif

enum {Win95 = 1, WinNT3x, WinNT40 = 4, WinNT50 = 8};

class CProjectRecord : public CDocument {
    CString m_csSourceRCFile, m_csRCName;
    CString m_csNT50Path, m_csNT40Path, m_csNT3xPath, m_csWin95Path;

    UINT    m_ufTargets;

    CDriverResources    m_cdr;  //  A record of the RC file contents
    
    //  Enumerated flags for the project's status

    enum {UniToolRun = 1, ConversionsDone = 2, NTGPCDone = 4};
    UINT    m_ufStatus;

protected: // create from serialization only
	CProjectRecord();
	DECLARE_DYNCREATE(CProjectRecord)

// Attributes
public:

    BOOL    IsTargetEnabled(UINT ufTarget) const { 
        return m_ufTargets & ufTarget;
    }

    BOOL    UniToolHasBeenRun() const { return m_ufStatus & UniToolRun; }
    BOOL    ConversionsComplete() const { 
        return m_ufStatus & ConversionsDone; 
    }
    BOOL    NTGPCCompleted() const { return m_ufStatus & NTGPCDone; }

    CString SourceFile() const { return m_csSourceRCFile; }

    CString     DriverName() { return m_cdr.Name(); }

    CString TargetPath(UINT ufTarget) const;

    CString     RCName(UINT ufTarget) const {
        return  TargetPath(ufTarget) + _TEXT("\\") + m_csRCName;
    }

    unsigned    MapCount() const { return m_cdr.MapCount(); }
    CGlyphMap&  GlyphMap(unsigned u) { return m_cdr.GlyphTable(u); }

    unsigned    ModelCount() const { return m_cdr.Models(); }
    CModelData& Model(unsigned u) { return m_cdr.Model(u); }

// Operations
public:

    void    EnableTarget(UINT ufTarget, BOOL bOn = TRUE) {
        UINT    ufCurrent = m_ufTargets;
        if  (bOn)
            m_ufTargets |= ufTarget;
        else
            m_ufTargets &= ~ufTarget;
        if  (ufCurrent == m_ufTargets)
            return;
        if  (ufTarget & WinNT3x | WinNT40 | WinNT50) {
            m_ufStatus &=~(ConversionsDone | NTGPCDone);
            return;
        }
    }

    void    SetSourceRCFile(LPCTSTR lpstrSource);

    BOOL    LoadResources();

    BOOL    LoadFontData() { return m_cdr.LoadFontData(*this); }

    BOOL    SetPath(UINT ufTarget, LPCTSTR lpstrNewPath);

    BOOL    BuildStructure(unsigned uVersion);

    BOOL    GenerateTargets(WORD wfGPDConvert);

    void    OldStuffDone() { m_ufStatus |= NTGPCDone; }
    void    Rename(LPCTSTR lpstrNewName) { m_cdr.Rename(lpstrNewName); }
    void    InitUI(CTreeCtrl *pctc) { m_cdr.Fill(pctc, *this); }
    void    GPDConversionCheck(BOOL bReportSuccess = FALSE);
    
// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CProjectRecord)
	public:
	virtual BOOL OnNewDocument();
	virtual void Serialize(CArchive& ar);
	//}}AFX_VIRTUAL

// Implementation
public:
	virtual ~CProjectRecord();
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif

protected:

// Generated message map functions
protected:
	//{{AFX_MSG(CProjectRecord)
		// NOTE - the ClassWizard will add and remove member functions here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\tools\uni\minidev\rcfile.h ===
/******************************************************************************

  Header File:  Driver Resources.H

  This defines the CDriverResource class, which contains all of the information
  required to build the RC file for the mini-driver.

  It contains a list of all of the #include files, any #define'd constants
  (which will now go to a separate header file), the GPC tables, of all of the
  fonts (in all three formats) and glyph translation tables (again, in all 3
  formats).  It is designed to be initializaed by reading the Win 3.1 RC file,
  and a member function can then generate the RC file for any desired version.

  We allow UFM and GTT files to be added to the list without having an 
  associated PFM, as one purpose of this tool is to wean people away from
  UniTool.

  Copyright (c) 1997 by Microsoft Corporation.  All Rights Reserved.

  A Pretty Penny Enterprises Production.

  Change History:
  02-08-1997    Bob_Kjelgaard@Prodigy.Net   Created it

******************************************************************************/

#if !defined(DRIVER_RESOURCES)

#define DRIVER_RESOURCES

#include    <GTT.H>           //  Glyph Mapping classes
#include    <FontInfo.H>    //  Font information classes

#include    <GPDFile.H>

class CStringTable : public CObject {

    DECLARE_SERIAL(CStringTable)

    CString             m_csEmpty;
    CUIntArray          m_cuaKeys;
    CStringArray        m_csaValues;

public:

    CStringTable() {}

    //  Attributes
    unsigned    Count() const { return m_cuaKeys.GetSize(); }

    CString operator[](WORD wKey) const;

    void    Details(unsigned u, WORD &wKey, CString &csValue);

    //  Operations

    void    Map(WORD wKey, CString csValue);

    void    Remove(WORD wKey);

    void    Reset() {
        m_csaValues.RemoveAll();
        m_cuaKeys.RemoveAll();
    }

    virtual void    Serialize(CArchive& car);
};

class CDriverResources : public CBasicNode {

    DECLARE_SERIAL(CDriverResources)

    BOOL                m_bUseCommonRC;

    CStringArray        m_csaIncludes, m_csaTables;

    CStringArray        m_csaDefineNames, m_csaDefineValues;

    //  The String table is a separate class, defined above
    
    CStringTable        m_cst;

    //  TODO:   Handle the version resource so it is under project control

    //  For now, simply let it and any other untranslated lines sit in another
    //  array.

    CStringArray        m_csaRemnants;

    //  Collections of Various items of interest

    CFixedNode          m_cfnAtlas, m_cfnFonts, m_cfnModels;
    CSafeObArray        m_csoaAtlas, m_csoaFonts, m_csoaModels;
    COldMiniDriverData  m_comdd;
    unsigned            m_ucSynthesized;    //  "Artificial" UFM count

    enum    {ItWorked, ItFailed, ItWasIrrelevant};

    UINT    CheckTable(int iWhere, CString csLine, CStringArray& csaTarget,
                       BOOL bSansExtension = TRUE);
    UINT    CheckTable(int iWhere, CString csLine, CStringTable& cstTarget);

    BOOL    AddStringEntry(CString  csDefinition);

public:

    CDriverResources();

    //  Attributes
    CString     GPCName(unsigned u);
    unsigned    MapCount() const { return m_csoaAtlas.GetSize(); }
    CGlyphMap&  GlyphTable(unsigned u) { 
        return *(CGlyphMap *) m_csoaAtlas[u]; 
    }
    unsigned    FontCount() const { return m_csoaFonts.GetSize(); }
    unsigned    OriginalFontCount() const { 
        return FontCount() - m_ucSynthesized; 
    }
    CFontInfo&  Font(unsigned u) const { 
        return *(CFontInfo *) m_csoaFonts[u]; 
    }

    unsigned    Models() const { return m_csoaModels.GetSize(); }
    CModelData&  Model(unsigned u) const { 
        return *(CModelData *) m_csoaModels[u];
    }

    //  Operations
    BOOL    Load(class CProjectRecord& cpr);
    BOOL    LoadFontData(CProjectRecord& cpr);
    BOOL    ConvertGPCData(CProjectRecord& cpr, WORD wfGPDConvert);
    BOOL    Generate(UINT ufTarget, LPCTSTR lpstrPath);

    void    ForceCommonRC(BOOL bOn) { m_bUseCommonRC = bOn; }

    void    Fill(CTreeCtrl *pctcWhere, CProjectRecord& cpr);
    virtual void    Serialize(CArchive& car);
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\tools\uni\minidev\projrec.cpp ===
/******************************************************************************

  Source File:  Project Record.CPP

  This implements the project record class, which tracks the details for
  multiple mini-drivers.

  Copyright (c) 1997 by Microsoft Corporation.  All Rights Reserved.

  A Pretty Penny Enterprises Production.

  Change History:
  02-03-1997    Bob_Kjelgaard@prodigy.net   Created it

******************************************************************************/

#include    "StdAfx.H"
#include    "MiniDev.H"
#include    "ModlData\Resource.H"
#include    "NewProj.H"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CProjectRecord

IMPLEMENT_DYNCREATE(CProjectRecord, CDocument)

BEGIN_MESSAGE_MAP(CProjectRecord, CDocument)
	//{{AFX_MSG_MAP(CProjectRecord)
		// NOTE - the ClassWizard will add and remove mapping macros here.
		//    DO NOT EDIT what you see in these blocks of generated code!
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CProjectRecord construction/destruction

CProjectRecord::CProjectRecord() {
	m_ufTargets = WinNT50;
    m_ufStatus = 0;
}

CProjectRecord::~CProjectRecord() {
}

CString CProjectRecord::TargetPath(UINT ufFlags) const {

    switch(ufFlags) {
        case    Win95:
            return  m_csWin95Path;

        case    WinNT3x:
            return  m_csNT3xPath;

        case    WinNT40:
            return  m_csNT40Path;

        case    WinNT50:
            return  m_csNT50Path;
    }

    AfxThrowNotSupportedException();

    return  m_csWin95Path;
}

//  This routine establishes the source RC file's name, and the initial paths
//  for all of the potential targets.

void    CProjectRecord::SetSourceRCFile(LPCTSTR lpstrSource) {
    m_csSourceRCFile = lpstrSource;

    m_csNT50Path = m_csNT40Path = m_csNT3xPath = m_csWin95Path =
        m_csSourceRCFile.Left(m_csSourceRCFile.ReverseFind(_T('\\')));

    m_csNT50Path += _T("\\NT5");
    m_csNT40Path += _T("\\NT4");
    m_csNT3xPath += _T("\\NT3");

    //  Trim the path name (including trailing \) to get driver name and RC
    m_csRCName = m_csSourceRCFile.Mid(1 + m_csWin95Path.GetLength());
    if  (m_csRCName.Find('.') != -1)
        m_csRCName = m_csRCName.Left(m_csRCName.Find('.'));
    m_cdr.Rename(m_csRCName);
    m_csRCName += _T(".RC");
    m_ufStatus = 0;
}

//  This is a helper function- it validates a new path name, and if it is
//  valid, returns TRUE, and stores it in the given CString;

static BOOL ValidatePath(CString& csTarget, LPCTSTR lpstrPath) {

    if  (!csTarget.CompareNoCase(lpstrPath)) {
        //  Trivial- no change = success!
        return  TRUE;
    }

    //  Determine the current directory, so we don't lose it.

    CString csCurrentDirectory, csNewOne;

    GetCurrentDirectory(MAX_PATH, csCurrentDirectory.GetBuffer(MAX_PATH));

    csCurrentDirectory.ReleaseBuffer();

    //  Attempt to switch to the new directory.  If we succeed, we're done.

    if  (SetCurrentDirectory(lpstrPath)) {
        GetCurrentDirectory(MAX_PATH, csTarget.GetBuffer(MAX_PATH));
        csTarget.ReleaseBuffer();

        SetCurrentDirectory(csCurrentDirectory);
        return  TRUE;
    }

    //  Attempt to create the new directory.  If this succeeds, delete the
    //  directory, and note our success our failure, either way.

    if  (CreateDirectory(lpstrPath, NULL)) {
        SetCurrentDirectory(lpstrPath);
        GetCurrentDirectory(MAX_PATH, csTarget.GetBuffer(MAX_PATH));
        csTarget.ReleaseBuffer();

        SetCurrentDirectory(csCurrentDirectory);
        RemoveDirectory(csTarget);
        return  TRUE;
    }
    return  FALSE;  //  Nothing worked, give it up...
}

//  The following loads all of the driver resources.

BOOL    CProjectRecord::LoadResources() {

    if  (!m_cdr.Load(*this))
        return  FALSE;

    m_ufStatus |= UniToolRun;
    m_ufStatus &= ~(ConversionsDone | NTGPCDone);
    SetModifiedFlag();

    return  TRUE;
}

//  The following member validates a new target path name.

BOOL    CProjectRecord::SetPath(UINT ufTarget, LPCTSTR lpstrPath) {

    switch  (ufTarget) {
        case    WinNT50:
            m_ufStatus&= ~ConversionsDone;
            return  ValidatePath(m_csNT50Path, lpstrPath);

        case    WinNT40:
            m_ufStatus&= ~(ConversionsDone | NTGPCDone);
            return  ValidatePath(m_csNT40Path, lpstrPath);

        case    WinNT3x:
            m_ufStatus&= ~(ConversionsDone | NTGPCDone);
            return  ValidatePath(m_csNT3xPath, lpstrPath);
    }

    _ASSERTE(FALSE); //  This should never happen!
    return  FALSE;
}

//  When we create a new document (aka project, aka driver), we invoke the 
//  new project wizard

BOOL CProjectRecord::OnNewDocument() {
	if  (!CDocument::OnNewDocument())
        return  FALSE;

    //  Invoke the wizard.
    CNewProjectWizard cnpw(*this);
    return  cnpw.DoModal() == ID_WIZFINISH;
}

/////////////////////////////////////////////////////////////////////////////
// CProjectRecord serialization

void CProjectRecord::Serialize(CArchive& car) {
    m_cdr.Serialize(car);
	if (car.IsStoring()) {
		car << m_csNT50Path << m_csNT40Path << m_csNT3xPath << m_csWin95Path <<
            m_csSourceRCFile << m_ufTargets << m_ufStatus << m_csRCName;
	}
	else {
		car >> m_csNT50Path >> m_csNT40Path >> m_csNT3xPath >> m_csWin95Path >>
            m_csSourceRCFile >> m_ufTargets >> m_ufStatus >> m_csRCName;
	}
}

//  Private Worker Routine- this establishes a directory, by first attempting
//  to go to it, then creating it if that failes.  The current directory is
//  preserved.

static BOOL Establish(CString   csNew) {
    CString csCurrent;

    GetCurrentDirectory(MAX_PATH, csCurrent.GetBuffer(MAX_PATH));
    csCurrent.ReleaseBuffer();

    if  (SetCurrentDirectory(csNew)) {
        SetCurrentDirectory(csCurrent);
        return  TRUE;
    }

    return  CreateDirectory(csNew, NULL);
}

//  Private worker routine.  This establishes the directory structure given it,
//  consisting of a named route, and two branches.

static BOOL CreateStructure(const CString& csRoot, LPCTSTR lpstrFont, 
                            LPCTSTR lpstrMap) {
    return  Establish(csRoot) && Establish(csRoot + '\\' + lpstrFont) &&
        Establish(csRoot + '\\' + lpstrMap);
}

/******************************************************************************

  CProjectRecord::BuildStructure

  This builds the directory structure needed for all conversion targets.  This
  is done before files are generated so that the renaming calls in many of the
  project nodes do not fail.

******************************************************************************/

BOOL    CProjectRecord::BuildStructure(unsigned uVersion) {

    switch  (uVersion) {

        case    WinNT50:

            return  CreateStructure(TargetPath(WinNT50), _T("UFM"), _T("GTT"));

        case    WinNT40:

            return  CreateStructure(TargetPath(WinNT40), _T("IFI"), _T("RLE"));

        case    WinNT3x:

            return  CreateStructure(TargetPath(WinNT3x), _T("IFI"), _T("RLE"));
    }

    _ASSERTE(FALSE);

    return  FALSE;
}


/******************************************************************************

  CProjectRecord::GenerateTargets

  This one is a workhorse- it generates all of the files needed for all of the 
  enabled targets, using the Win 3.x files as a base, with the exception of the
  NT GPC extensions, which require an interactive step.

******************************************************************************/

BOOL    CProjectRecord::GenerateTargets(WORD wfGPDConvert) {

    //  Generate the files needed for NT 5.0

    if  (!CreateStructure(TargetPath(WinNT50), _TEXT("UFM"), _TEXT("GTT")))
        return  FALSE;  //  TODO:   Feedback

    //  Generate the RC file
    m_cdr.ForceCommonRC(wfGPDConvert > 1);  //  All higher values require it.

    if  (!m_cdr.Generate(WinNT50, TargetPath(WinNT50) + '\\' + m_csRCName))
        return  FALSE;  //  TODO:   Cleanup and feedback

    //  Generate the GTT files

    for (unsigned u = 0; u < m_cdr.MapCount(); u++) {

        try {
            CFile   cfGTT(m_cdr.GlyphTable(u).FileName(), 
                CFile::modeCreate | CFile::modeWrite | CFile::shareExclusive);

            if  (!m_cdr.GlyphTable(u).Generate(cfGTT))
                return  FALSE;  //  TODO:   Ditto
        }
        catch   (CException *pce) {
            pce -> ReportError();
            pce -> Delete();
            return  FALSE;
        }
    }

    //  Generate the UFM files
    for (u = 0; u < m_cdr.FontCount(); u++) {

        //  Map the UFM -> GTT, so we can convert the UFM

        if  (CGlyphMap::Public(m_cdr.Font(u).Translation())) {
            m_cdr.Font(u).SetTranslation(
                CGlyphMap::Public(m_cdr.Font(u).Translation()));
        }
        else
            for (unsigned uGTT = 0; uGTT < m_cdr.MapCount(); uGTT++)
                if  (m_cdr.Font(u).Translation() == 
                    m_cdr.GlyphTable(uGTT).GetID()) {
                    m_cdr.Font(u).SetTranslation(&m_cdr.GlyphTable(uGTT));
                    break;
                }

        if  (!m_cdr.Font(u).Generate(m_cdr.Font(u).FileName()))
            return  FALSE;  //  TODO:   Ditto
    }

    //  Generate the GPD files

    if  (!m_cdr.ConvertGPCData(*this, wfGPDConvert))
        return  FALSE;  //  Error will already have been reported to user.

    //  Simplest case is no NT versions selected.  By definition, we are done.

    if  (!IsTargetEnabled(WinNT40 | WinNT3x)) {
        m_ufStatus |= ConversionsDone;
        return  TRUE;
    }

    //  Generate the files needed for NT 4.0

    if  (IsTargetEnabled(WinNT40)) {
        if  (!CreateStructure(TargetPath(WinNT40), _TEXT("IFI"), _TEXT("RLE")))
            return  FALSE;  //  TODO:   Feedback

        //  Generate the RC file
        if  (!m_cdr.Generate(WinNT40, TargetPath(WinNT40) + '\\' + m_csRCName))
            return  FALSE;  //  TODO:   Cleanup and feedback

        //  Copy the GPC file
        if  (!CopyFile(TargetPath(Win95) + m_cdr.GPCName(0), 
             TargetPath(WinNT40) + m_cdr.GPCName(0), FALSE))
             return FALSE;  //  TODO:   Cleanup and feedback

        //  Generate the RLE files

        for (unsigned u = 0; u < m_cdr.MapCount(); u++) {
            CString csName = TargetPath(WinNT40) + _TEXT("\\RLE\\") +
                m_cdr.GlyphTable(u).Name() + _TEXT(".RLE");

            CFile   cfRLE;

            if  (!cfRLE.Open(csName, 
                CFile::modeCreate | CFile::modeWrite | CFile::shareExclusive))
                return  FALSE;  //  As usal, TODO:  Feedback...

            if  (!m_cdr.GlyphTable(u).RLE(cfRLE))
                return  FALSE;  //  TODO:   Ditto
        }

        //  Generate the IFI files
        for (u = 0; u < m_cdr.OriginalFontCount(); u++) {
            CString csName = TargetPath(WinNT40) + _TEXT("\\IFI\\") +
                m_cdr.Font(u).Name() + _TEXT(".IFI");
            if  (!m_cdr.Font(u).Generate(csName))
                return  FALSE;  //  TODO:   Ditto
        }
    }

    //  Generate the files needed for NT 3.x

    if  (IsTargetEnabled(WinNT3x)) {
        if  (!CreateStructure(TargetPath(WinNT3x), _TEXT("IFI"), _TEXT("RLE")))
            return  FALSE;  //  TODO:   Feedback

        //  Generate the RC file
        if  (!m_cdr.Generate(WinNT3x, TargetPath(WinNT3x) + '\\' + m_csRCName))
            return  FALSE;  //  TODO:   Cleanup and feedback

        //  Copy the GPC file
        if  (!CopyFile(TargetPath(Win95) + m_cdr.GPCName(0), 
             TargetPath(WinNT3x) + m_cdr.GPCName(0), FALSE))
             return FALSE;  //  TODO:   Cleanup and feedback

        //  Generate the RLE files

        for (unsigned u = 0; u < m_cdr.MapCount(); u++) {
            CString csName = TargetPath(WinNT40) + _TEXT("\\RLE\\") +
                m_cdr.GlyphTable(u).Name() + _TEXT(".RLE");

            CFile   cfRLE;

            if  (!cfRLE.Open(csName, 
                CFile::modeCreate | CFile::modeWrite | CFile::shareExclusive))
                return  FALSE;  //  As usal, TODO:  Feedback...

            if  (!m_cdr.GlyphTable(u).RLE(cfRLE))
                return  FALSE;  //  TODO:   Ditto
        }

        //  Generate the IFI files
        for (u = 0; u < m_cdr.OriginalFontCount(); u++) {
            CString csName = TargetPath(WinNT3x) + _TEXT("\\IFI\\") +
                m_cdr.Font(u).Name() + _TEXT(".IFI");
            if  (!m_cdr.Font(u).Generate(csName))
                return  FALSE;  //  TODO:   Ditto
        }
    }

    m_ufStatus |= ConversionsDone;

    return  TRUE;
}

/******************************************************************************

  CProjectRecord::GPDConversionCheck

  If any of the GPD files have unresolved errors from the conversion process,
  it will open all of them, if the user asks, so they can fix the problem(s) 
  forthwith- or leave them for the next time the workspace is edited.

******************************************************************************/

void    CProjectRecord::GPDConversionCheck(BOOL bReportSuccess) {
    CUIntArray  cuaSuspects;

    for (unsigned u = 0; u < m_cdr.Models(); u ++)
        if  (m_cdr.Model(u).HasErrors())
            cuaSuspects.Add(u);

    if  (!cuaSuspects.GetSize()) {
        if (bReportSuccess)
            AfxMessageBox(IDS_NoErrorsAnywhere);    
        return;
    }

    if  (AfxMessageBox(IDS_ConversionErrors, MB_YESNO) == IDNO)
        return;

    while   (cuaSuspects.GetSize()) {
        m_cdr.Model(cuaSuspects[0]).Edit();
        cuaSuspects.RemoveAt(0);
    }
}

/////////////////////////////////////////////////////////////////////////////
// CProjectRecord diagnostics

#ifdef _DEBUG
void CProjectRecord::AssertValid() const {
	CDocument::AssertValid();
}

void CProjectRecord::Dump(CDumpContext& dc) const {
	CDocument::Dump(dc);
}
#endif //_DEBUG

/////////////////////////////////////////////////////////////////////////////
// CProjectRecord commands
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\tools\uni\minidev\projview.cpp ===
/******************************************************************************

  Source File:  Project View.CPP

  This implements the view class for project level information.

  Copyright (c) 1997 by Microsoft Corporation.  All Rights Reserved.

  A Pretty Penny Enterprises Production.

  Change History:

  02-03-1997    Bob_Kjelgaard@Prodigy.Net   Created it

******************************************************************************/

#include    "StdAfx.h"
#include    "MiniDev.H"
#include    "ModlData\Resource.H"
#include    "ProjView.H"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CProjectView

IMPLEMENT_DYNCREATE(CProjectView, CFormView)

BEGIN_MESSAGE_MAP(CProjectView, CFormView)
	//{{AFX_MSG_MAP(CProjectView)
	ON_NOTIFY(TVN_BEGINLABELEDIT, IDC_DriverView, OnBeginlabeleditDriverView)
	ON_NOTIFY(TVN_ENDLABELEDIT, IDC_DriverView, OnEndLabelEdit)
	ON_WM_CONTEXTMENU()
	ON_NOTIFY(NM_DBLCLK, IDC_DriverView, OnDblclkDriverView)
	ON_COMMAND(ID_FILE_PARSE, OnFileParse)
	ON_NOTIFY(TVN_KEYDOWN, IDC_DriverView, OnKeydownDriverView)
	//}}AFX_MSG_MAP
	// Standard printing commands
	ON_COMMAND(ID_FILE_PRINT, CFormView::OnFilePrint)
	ON_COMMAND(ID_FILE_PRINT_DIRECT, CFormView::OnFilePrint)
	ON_COMMAND(ID_FILE_PRINT_PREVIEW, CFormView::OnFilePrintPreview)
    //  Commands we pop up from context menus
    ON_COMMAND(ID_ExpandBranch, OnExpandBranch)
    ON_COMMAND(ID_CollapseBranch, OnCollapseBranch)
    ON_COMMAND(ID_RenameItem, OnRenameItem)
    ON_COMMAND(ID_OpenItem, OnOpenItem)
    ON_COMMAND(ID_GenerateOne, OnGenerateItem)
    ON_COMMAND(IDOK, OnOpenItem)    //  We'll open an item if ENTER is hit
    ON_COMMAND(ID_Import, OnImport)
    ON_COMMAND(ID_DeleteItem, OnDeleteItem)
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CProjectView construction/destruction

CProjectView::CProjectView() : CFormView(CProjectView::IDD) {
	//{{AFX_DATA_INIT(CProjectView)
	//}}AFX_DATA_INIT
	// TODO: add construction code here
}

CProjectView::~CProjectView() {}

void CProjectView::DoDataExchange(CDataExchange* pDX) {
	CFormView::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CProjectView)
	DDX_Control(pDX, IDC_DriverView, m_ctcDriver);
	//}}AFX_DATA_MAP
}

BOOL CProjectView::PreCreateWindow(CREATESTRUCT& cs) {
	// TODO: Modify the Window class or styles here by modifying
	//  the CREATESTRUCT cs

	return CScrollView::PreCreateWindow(cs);
}

/////////////////////////////////////////////////////////////////////////////
// CProjectView drawing

void CProjectView::OnInitialUpdate() {
	CFormView::OnInitialUpdate();

    ResizeParentToFit(FALSE);

    GetDocument() -> InitUI(&m_ctcDriver);
    GetParentFrame() - ShowWindow(SW_SHOW);
    GetDocument() -> GPDConversionCheck();
}

/////////////////////////////////////////////////////////////////////////////
// CProjectView printing

BOOL CProjectView::OnPreparePrinting(CPrintInfo* pInfo) {
	// default preparation
	return DoPreparePrinting(pInfo);
}

void CProjectView::OnBeginPrinting(CDC* /*pDC*/, CPrintInfo* /*pInfo*/) {
	// TODO: add extra initialization before printing
}

void CProjectView::OnEndPrinting(CDC* /*pDC*/, CPrintInfo* /*pInfo*/) {
	// TODO: add cleanup after printing
}

/////////////////////////////////////////////////////////////////////////////
// CProjectView diagnostics

#ifdef _DEBUG
void CProjectView::AssertValid() const {
	CScrollView::AssertValid();
}

void CProjectView::Dump(CDumpContext& dc) const {
	CScrollView::Dump(dc);
}

CProjectRecord* CProjectView::GetDocument() {// non-debug version is inline
	ASSERT(m_pDocument->IsKindOf(RUNTIME_CLASS(CProjectRecord)));
	return (CProjectRecord*)m_pDocument;
}
#endif //_DEBUG

/////////////////////////////////////////////////////////////////////////////
// CProjectView message handlers

void CProjectView::OnBeginlabeleditDriverView(NMHDR* pnmh, LRESULT* plr) {
	TV_DISPINFO* ptvdi = (TV_DISPINFO*) pnmh;

    *plr = !((CBasicNode *) ptvdi -> item.lParam) -> CanEdit();
}

/******************************************************************************

  CProjectView::OnEndLabelEdit

  Called when a label in the view has been edited- the user has either
  canceled (new text in item will be empty), or changed the text.  We pass the
  whole information on to the CBasicNode which handles this object.

******************************************************************************/

void CProjectView::OnEndLabelEdit(NMHDR* pnmh, LRESULT* plr) {
	TV_DISPINFO* ptvdi = (TV_DISPINFO*) pnmh;

    *plr = ((CBasicNode *) ptvdi -> item.lParam) -> Rename(ptvdi -> 
        item.pszText);
}

/******************************************************************************

  CProjectView::OnContextMenu

  This is called when the user right-clicks the mouse.  We determine if the
  mouse is within an item in the tree view.  If it is, then we pass it on to
  the CBasicNode-derived object which handles that item.  That object is then
  responsible for displaying the proper context menu.

******************************************************************************/

void CProjectView::OnContextMenu(CWnd* pcw, CPoint cp) {
	if  (pcw != &m_ctcDriver)
        return;

    CPoint  cpThis(cp);

    m_ctcDriver.ScreenToClient(&cpThis);

    //  If the mouse is inside the area of any item, display its context menu

    UINT    ufItem;

    HTREEITEM hti = m_ctcDriver.HitTest(cpThis, &ufItem);

    if  (!hti || !(ufItem & (TVHT_ONITEM | TVHT_ONITEMBUTTON)))
        return;
        
    //  Some operations require we know which item, so we're going to
    //  select the given item.  If this is really a problem, we can change
    //  it later (cache it in a member).

    m_ctcDriver.SelectItem(hti);

    ((CBasicNode *) m_ctcDriver.GetItemData(hti)) -> ContextMenu(this, cp);
}

/******************************************************************************

  CProjectView::OnExpandBranch

  This is called when the user selects an expand item from a context menu.  In
  this case, we don't need to pass this through the CBasicNode- we just expand
  it using the normal common control methods (actually using an MFC method, 
  since this promises greater future portability).

******************************************************************************/

void    CProjectView::OnExpandBranch() {
    HTREEITEM   htiSelected = m_ctcDriver.GetSelectedItem();

    if  (!htiSelected)
        return;

    m_ctcDriver.Expand(htiSelected, TVE_EXPAND);
}

/******************************************************************************

  CProjectView::OnCollapseBranch

  In this case, the user has selected the Collapse item from a context menu.
  We collapse the branch at the selected tree view item.

******************************************************************************/

void    CProjectView::OnCollapseBranch() {
    HTREEITEM   htiSelected = m_ctcDriver.GetSelectedItem();

    if  (!htiSelected)
        return;

    m_ctcDriver.Expand(htiSelected, TVE_COLLAPSE);
}

/******************************************************************************

  CProjectView::OnRenameItem

  This handles a user selecting a Rename item.  This results in us ordering the
  view to begin label editing of the selected item.  The interactions regarding
  label editing are routed to the underlying CBasicNode object via 
  OnBeginLabelEdit and OnEndLabelEdit.

******************************************************************************/

void    CProjectView::OnRenameItem() {
    HTREEITEM   htiSelected = m_ctcDriver.GetSelectedItem();

    if  (!htiSelected)
        return;

    m_ctcDriver.EditLabel(htiSelected);
}

/******************************************************************************

  CProjectView::OnOpenItem

  This method is invoked when the user wishes to edit an item in the tree.
  This is always routed through the underlying CBasicNode-derived item.  Some
  items can't be edited, and will ignore this (in fact, this is the base class
  behavior).

******************************************************************************/

void    CProjectView::OnOpenItem() {
    HTREEITEM   htiSelected = m_ctcDriver.GetSelectedItem();

    if  (!htiSelected)
        return;

    ((CBasicNode *) m_ctcDriver.GetItemData(htiSelected)) -> Edit();
}

//  Generate an image of the selected item (usable for building)

void    CProjectView::OnGenerateItem() {
    HTREEITEM   htiSelected = m_ctcDriver.GetSelectedItem();

    if  (!htiSelected)
        return;

    //((CProjectNode *) m_ctcDriver.GetItemData(htiSelected)) -> Generate();
}

/******************************************************************************

  CProjectView::OnDblClkDriverView

  This is called when the user double-clicks anywhere in the tree view.  We
  route it through the Open message handler, as this will always be the desired
  action.

******************************************************************************/

void CProjectView::OnDblclkDriverView(NMHDR* pNMHDR, LRESULT* pResult) {
	OnOpenItem();
}

/******************************************************************************

  CProjectView::OnFileParse

  This method invokes the parser on each of the GPD files in the project.

******************************************************************************/

void CProjectView::OnFileParse() {
    {
        CWaitCursor cwc;    //  This could take a while...

        for (unsigned u = 0; u < GetDocument() -> ModelCount(); u++) {
            GetDocument() -> Model(u).Parse();
            GetDocument() -> Model(u).UpdateEditor();
        }
    }

    GetDocument() -> GPDConversionCheck(TRUE);

}

/******************************************************************************

  CProjectView::OnKeydownDriverView

  This handles various keystrokes we want handled over and above what the
  default handling by the control supplies.

******************************************************************************/

void CProjectView::OnKeydownDriverView(NMHDR* pnmh, LRESULT* plr) {
	TV_KEYDOWN* ptvkd = (TV_KEYDOWN*)pnmh;

    HTREEITEM htiSelected = m_ctcDriver.GetSelectedItem();

	*plr = 0;

    if  (!htiSelected)
        return;

    CRect   crThis;
    
    m_ctcDriver.GetItemRect(htiSelected, crThis, FALSE);

    CBasicNode& cbn = *(CBasicNode *) m_ctcDriver.GetItemData(htiSelected);
	
    switch  (ptvkd -> wVKey) {
        case    VK_F10:
            //  Create a context menu for this item.
            m_ctcDriver.ClientToScreen(crThis);
            cbn.ContextMenu(this, crThis.CenterPoint());
            return;

        case    VK_DELETE:
            //  If the item is successfully deleted, remove it from the
            //  view
            cbn.Delete();
            return;
    }
}

/******************************************************************************

  CProjectView::OnImport

  This method is invoked when the user selects an "Import" item on a context
  menu.  How this is handled is entirely the responsibility of the underlying
  CBasicNode-derived item, so the request gets routed there by this code.

******************************************************************************/

void    CProjectView::OnImport() {
    HTREEITEM   htiSelected = m_ctcDriver.GetSelectedItem();

    if  (!htiSelected)
        return;

    ((CBasicNode *) m_ctcDriver.GetItemData(htiSelected)) -> Import();
}

/******************************************************************************

  CProjectView::OnDeleteItem

  For item deletion via context menu.  The delete key is handled in 
  OnKeydownDriverView.  Once again, the underlying object handles what happens.

******************************************************************************/

void    CProjectView::OnDeleteItem() {
    HTREEITEM   htiSelected = m_ctcDriver.GetSelectedItem();

    if  (!htiSelected)
        return;

    ((CBasicNode *) m_ctcDriver.GetItemData(htiSelected)) -> Delete();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\tools\uni\minidev\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//	MiniDev.pch will be the pre-compiled header
//	stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\tools\uni\minidev\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by MiniDev.rc
//
#define NewProjectWizardTitle           1
#define OpenRCDialogTitle               2
#define IDS_UnitoolNotRun               3
#define IDP_UnitoolNotRun               3
#define IDS_RCLoadFailed                4
#define IDP_RCLoadFailed                4
#define IDS_Unimplemented               5
#define IDS_CannotMakeDirectory         6
#define IDP_CannotMakeDirectory         6
#define IDS_Atlas                       7
#define IDS_FontList                    8
#define ID_RenameItem                   9
#define ID_ExpandBranch                 10
#define ID_CollapseBranch               11
#define ID_OpenItem                     12
#define IDS_MapColumn0                  13
#define IDS_MapColumn1                  14
#define IDS_MapColumn2                  15
#define IDS_MapsGenerated               16
#define IDS_NoPredefined                16
#define IDS_MapsFailed                  17
#define IDS_NoErrorsAnywhere            17
#define ID_ChangeInvocation             18
#define ID_ChangeCodePage               19
#define ID_DeleteItem                   20
#define IDS_DeleteItemQuery             21
#define ID_GenerateOne                  22
#define IDS_DefaultPage                 41
#define ID_AddItem                      42
#define IDS_NoUnmappedGlyphs            43
#define IDP_NoUnmappedGlyphs            43
#define IDS_LengthMismatch              44
#define IDS_LoadFailure                 45
#define IDS_Models                      46
#define IDS_ConversionErrors            47
#define IDP_ConversionErrors            47
#define IDS_FileName                    48
#define IDS_InvalidFilename             49
#define IDS_OverwritePrompt             50
#define ID_Import                       51
#define IDS_FileOpenError               52
#define IDS_GPCConversionError          53
#define IDS_RemovedInvalid              54
#define IDS_UnusedFont                  55
#define IDS_ResourceID                  56
#define IDS_WidthColumn0                57
#define IDS_WidthColumn1                58
#define IDS_KernColumn0                 59
#define IDS_KernColumn1                 60
#define IDS_KernColumn2                 61
#define IDS_InvalidNumberFormat         62
#define ID_ChangeAmount                 63
#define IDS_CapH                        64
#define IDS_LowerX                      65
#define IDS_SuperSizeX                  66
#define IDS_SuperSizeY                  67
#define IDS_SubSizeX                    68
#define IDS_SubSizeY                    69
#define IDS_SuperMoveX                  70
#define IDS_SuperMoveY                  71
#define IDS_SubMoveX                    72
#define IDS_SubMoveY                    73
#define IDS_ItalicAngle                 74
#define IDS_UnderSize                   75
#define IDS_UnderOffset                 76
#define IDS_StrikeSize                  77
#define IDS_StrikeOffset                78
#define IDS_Baseline                    79
#define IDS_InterlineGap                80
#define IDS_Lowerp                      81
#define IDS_Lowerd                      82
#define IDS_InternalLeading             83
#define IDS_Overweight                  84
#define IDS_InvalidCharSet              85
#define IDS_InvalidCharacter            86
#define IDS_NoDBCS                      87
#define IDS_LimitsSwapped               88
#define IDS_NotWindowed                 89
#define IDS_ScaleReversed               90
#define IDS_WidthReversed               91
#define IDS_AngleTooBig                 92
#define IDS_BadCTTID                    93
#define IDS_NoSyntaxErrors              94
#define IDS_NoUnicodePoint              95
#define IDS_InvalidCTTFormat            96
#define IDS_WaitToFill                  97
#define IDS_NoGPCData                   98
#define IDD_ABOUTBOX                    100
#define CG_IDS_PHYSICAL_MEM             102
#define CG_IDS_DISK_SPACE               103
#define CG_IDS_DISK_SPACE_UNAVAIL       104
#define IDB_LIGHTBULB                   105
#define IDD_TIP                         106
#define CG_IDS_TIPOFTHEDAY              107
#define CG_IDS_TIPOFTHEDAYMENU          108
#define CG_IDS_DIDYOUKNOW               109
#define CG_IDS_FILE_ABSENT              110
#define CG_IDP_FILE_CORRUPT             111
#define CG_IDS_TIPOFTHEDAYHELP          112
#define ID_LineIndicator                113
#define IDR_CP1252                      114
#define IDR_MAINFRAME                   128
#define IDR_MINIWSTYPE                  129
#define IDD_FirstPageNewWizard          130
#define IDD_NPWSelectDest               131
#define IDD_NPWSelectTargets            132
#define IDD_RunUniTool                  136
#define IDD_ConvertFiles                137
#define IDD_GPCEditor                   138
#define IDD_ProjectForm                 139
#define IDR_GLYPHMAP                    140
#define IDD_GlyphMappings               142
#define IDD_NPWCodePageSelection        143
#define IDD_SelectPage                  144
#define IDD_CodePageView                145
#define IDD_PredefinedPage              146
#define IDD_AddCodePoints               147
#define IDR_FONT_VIEWER                 148
#define IDD_FontGeneralPage             150
#define IDB_PlusButton                  152
#define IDB_DeleteButton                153
#define IDD_FontMetrics                 154
#define IDR_GPD_VIEWER                  155
#define IDB_Wizard                      156
#define IDD_GPDErrors                   157
#define IDD_FontScaling                 164
#define IDD_KerningPairs                166
#define IDD_CharacterWidths             167
#define IDD_FontSimulations             168
#define IDD_FontSelection               169
#define IDD_FontGeneralPage2            170
#define IDI_BrowseArrow                 173
#define IDD_AddKernPair                 175
#define IDC_TargetNT50                  1000
#define IDC_BULB                        1000
#define IDC_TargetNT40                  1001
#define IDC_NT50Destination             1001
#define IDC_STARTUP                     1001
#define IDC_BrowseNT50                  1002
#define IDC_TargetNT3x                  1002
#define IDC_NEXTTIP                     1002
#define IDC_NT40Destination             1003
#define IDC_RunUniTool                  1003
#define IDC_TargetWin95                 1004
#define IDC_BrowseNT40                  1004
#define IDC_PhysicalMemory              1004
#define IDC_TIPSTRING                   1004
#define IDC_FreeDiskSpace               1005
#define IDC_NT3xDestination             1005
#define IDC_RunNtGpcEdit                1005
#define IDC_BrowseNT3x                  1006
#define IDC_ConvertFiles                1006
#define IDC_CodePages                   1006
#define IDC_DriverName                  1007
#define IDC_DriverView                  1008
#define IDC_Win95Destination            1009
#define IDC_GlyphMapping                1009
#define IDC_InstalledPages              1010
#define IDC_SupportedPages              1011
#define IDC_TableToPage                 1011
#define IDC_ChangeCodePage              1012
#define IDC_CodePageList                1014
#define IDC_CurrentPage                 1015
#define IDC_SelectString                1016
#define IDC_DeselectString              1017
#define IDC_AddPage                     1018
#define IDC_RemovePage                  1019
#define IDC_NoPredefined                1020
#define IDC_PredefinedAddTo             1021
#define IDC_RemovePredefined            1022
#define IDC_ReplacePredefined           1023
#define IDC_PredefinedList              1024
#define IDC_GlyphList                   1025
#define IDC_FamilyNames                 1026
#define IDC_FaceName                    1027
#define IDC_UniqueName                  1028
#define IDC_FixedPitch                  1029
#define IDC_VariablePitch               1030
#define IDC_Italic                      1031
#define IDC_Underline                   1032
#define IDC_StrikeOut                   1033
#define IDC_AddFamily                   1034
#define IDC_RemoveFamily                1035
#define IDC_StyleName                   1036
#define IDC_Errors                      1037
#define IDC_RemoveError                 1038
#define IDC_Previous                    1039
#define IDC_Next                        1040
#define NormalConversion                1041
#define CustomConversion                1042
#define IDC_Direct                      1043
#define IDC_Macros                      1044
#define IDC_Common                      1045
#define IDC_SpoolerNames                1046
#define IDC_FamilyBits                  1047
#define IDC_CharSet                     1048
#define IDC_FontWeight                  1049
#define IDC_FontHeight                  1051
#define IDC_FontWidth                   1052
#define IDC_SpecialMetric               1053
#define IDC_FontSpecialValue            1054
#define IDC_SpinFontSpecial             1055
#define IDC_Scalable                    1057
#define IDC_FontAnimation               1058
#define IDC_MasterDevice                1059
#define IDC_MasterFont                  1060
#define IDC_PortraitFont                1061
#define IDC_LandscapeFont               1062
#define IDC_MinimumScale                1063
#define IDC_MaximumScale                1064
#define IDC_ScalePoints                 1065
#define IDC_ScaleDevice                 1066
#define IDC_KerningTree                 1067
#define IDC_CharacterWidths             1068
#define IDC_FirstCharacter              1069
#define IDC_LastCharacter               1070
#define IDC_DefaultCharacter            1071
#define IDC_BreakCharacter              1072
#define IDC_ShowANSI                    1073
#define IDC_UnicodeShown                1074
#define IDC_AverageWidth                1075
#define IDC_EnableItalicSim             1076
#define IDC_EnableBoldSim               1077
#define IDC_EnableBISim                 1078
#define IDC_ItalicWeight                1079
#define IDC_IMaxWidth                   1080
#define IDC_IAverage                    1081
#define IDC_ItalicSlant                 1082
#define IDC_BoldWeight                  1083
#define IDC_BMaxWidth                   1084
#define IDC_BAverage                    1085
#define IDC_BIWeight                    1086
#define IDC_BIMaxWidth                  1087
#define IDC_BIAverage                   1088
#define IDC_BoldItalicSlant             1089
#define IDC_FontSelector                1090
#define IDC_FontUnselector              1091
#define IDC_FontLocation                1092
#define IDC_FontTechnology              1093
#define IDC_VerticalResolution          1094
#define IDC_HorizontalResolution        1095
#define IDC_PreAdjustY                  1096
#define IDC_PostAdjustY                 1097
#define IDC_CenteringAdjustment         1098
#define IDC_PrivateData                 1099
#define IDC_GTTDescription              1100
#define IDC_ItalicSim                   1101
#define IDC_CanUnderline                1102
#define IDC_CROK                        1103
#define IDC_BoldSim                     1104
#define IDC_DoubleUnderline             1105
#define IDC_StrikeThru                  1106
#define IDC_Backspace                   1107
#define IDC_KernFirst                   1112
#define IDC_KernSecond                  1113
#define IDC_KernAmount                  1114
#define IDC_Overstrike                  1115
#define IDC_Banner                      1116
#define ID_FILE_GENERATEMAPS            32771
#define ID_FILE_PARSE                   32772

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_3D_CONTROLS                     1
#define _APS_NEXT_RESOURCE_VALUE        176
#define _APS_NEXT_COMMAND_VALUE         32777
#define _APS_NEXT_CONTROL_VALUE         1119
#define _APS_NEXT_SYMED_VALUE           115
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\tools\uni\minidev\stdafx.h ===
/******************************************************************************

  Source File:  StdAfx.H

  This is a standard MFC file.  It includes everything we want to have 
  pre-compiled through StdAfx.CPP.  Hence items being worked on never belong 
  here.

  Copyright (c) 1997 by Microsoft Corporation.  All Rights Reserved.
  
  A Pretty Penny Enterprises Production

  Change History:
  03-03-1997    Bob_Kjelgaard@Prodigy.Net   Created it when I re-orged the
                project.

******************************************************************************/

#define VC_EXTRALEAN		// Exclude rarely-used stuff from Windows headers

#include    <AfxWin.H>      // MFC core and standard components
#include    <AfxExt.H>      // MFC extensions
#include    <AfxCmn.H>		// MFC support for Windows Common Controls
#include    <AfxRich.H>     // MFC Support for rich edit controls and views

#include "Tips.H"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\tools\uni\minidev\tips.h ===
/******************************************************************************

  Header File:  Tip of the Day.H

  This defines the Tip of the Day dialog class.  It was originally created by
  the Component Gallery, but I expect I will et around to tweaking it here and 
  there pretty soon.

  Copyright (c) 1997 by Microsoft Corporation.  All rights reserved.
  A Pretty Penny Enterprises Production

  Change History:
  03-02-1997    Bob_Kjelgaard@Prodigy.Net   Created it

******************************************************************************/

class CTipOfTheDay : public CDialog {
// Construction
public:
	CTipOfTheDay(CWnd* pParent = NULL);	 // standard constructor

// Dialog Data
	//{{AFX_DATA(CTipOfTheDay)
	// enum { IDD = IDD_TIP };
	BOOL	m_bStartup;
	CString	m_strTip;
	//}}AFX_DATA

	FILE* m_pStream;

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CTipOfTheDay)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
public:
	virtual ~CTipOfTheDay();

protected:
	// Generated message map functions
	//{{AFX_MSG(CTipOfTheDay)
	afx_msg void OnNextTip();
	afx_msg HBRUSH OnCtlColor(CDC* pDC, CWnd* pWnd, UINT nCtlColor);
	virtual void OnOK();
	virtual BOOL OnInitDialog();
	afx_msg void OnPaint();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

	void GetNextTipString(CString& strNext);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\tools\uni\minidev\tips.cpp ===
/******************************************************************************

  Source File:  Tip of the Day.CPP

  This implements the Tip of the Day dialog.  It was originally generated by
  Component Gallery, but I expect to be changing it shortly.

  Copyright (c) 1997 by Microsoft Corporation.  All Rights Reserved.
  A Pretty Penny Enterprises Production

  Change History:
  03-02-1997    Bob_Kjelgaard@Prodigy.Net   Created it

******************************************************************************/

#include    "StdAfx.H"
#include    "Resource.H"
// CG: This file added by 'Tip of the Day' component.

#include    <WinReg.H>
#include    <Sys\Stat.H>
#include    <Sys\Types.H>

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CTipOfTheDay dialog

#define MAX_BUFLEN 1000

static const TCHAR szSection[] = _T("Tip");
static const TCHAR szIntFilePos[] = _T("FilePos");
static const TCHAR szTimeStamp[] = _T("TimeStamp");
static const TCHAR szIntStartup[] = _T("StartUp");

CTipOfTheDay::CTipOfTheDay(CWnd* pParent /*=NULL*/)
	: CDialog(IDD_TIP, pParent) {

	//{{AFX_DATA_INIT(CTipOfTheDay)
	m_bStartup = TRUE;
	//}}AFX_DATA_INIT

	// We need to find out what the startup and file position parameters are
	// If startup does not exist, we assume that the Tips on startup is checked TRUE.
	CWinApp* pApp = AfxGetApp();
	m_bStartup = !pApp->GetProfileInt(szSection, szIntStartup, 0);
	UINT iFilePos = pApp->GetProfileInt(szSection, szIntFilePos, 0);

	// Now try to open the tips file
	m_pStream = fopen("tips.txt", "r");
	if (m_pStream == NULL) 
	{
		m_strTip.LoadString(CG_IDS_FILE_ABSENT);
		return;
	} 

	// If the timestamp in the INI file is different from the timestamp of
	// the tips file, then we know that the tips file has been modified
	// Reset the file position to 0 and write the latest timestamp to the
	// ini file
	struct _stat buf;
	_fstat(_fileno(m_pStream), &buf);
	CString strCurrentTime = ctime(&buf.st_ctime);
	strCurrentTime.TrimRight();
	CString strStoredTime = 
		pApp->GetProfileString(szSection, szTimeStamp, NULL);
	if (strCurrentTime != strStoredTime) 
	{
		iFilePos = 0;
		pApp->WriteProfileString(szSection, szTimeStamp, strCurrentTime);
	}

	if (fseek(m_pStream, iFilePos, SEEK_SET) != 0) 
	{
		AfxMessageBox(CG_IDP_FILE_CORRUPT);
	}
	else 
	{
		GetNextTipString(m_strTip);
	}
}

CTipOfTheDay::~CTipOfTheDay() {
	// This destructor is executed whether the user had pressed the escape key
	// or clicked on the close button. If the user had pressed the escape key,
	// it is still required to update the filepos in the ini file with the 
	// latest position so that we don't repeat the tips! 
    
	// But make sure the tips file existed in the first place....
	if (m_pStream != NULL) {
		CWinApp* pApp = AfxGetApp();
		pApp->WriteProfileInt(szSection, szIntFilePos, ftell(m_pStream));
		fclose(m_pStream);
	}
}
        
void CTipOfTheDay::DoDataExchange(CDataExchange* pDX) {
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CTipOfTheDay)
	DDX_Check(pDX, IDC_STARTUP, m_bStartup);
	DDX_Text(pDX, IDC_TIPSTRING, m_strTip);
	//}}AFX_DATA_MAP
}

BEGIN_MESSAGE_MAP(CTipOfTheDay, CDialog)
	//{{AFX_MSG_MAP(CTipOfTheDay)
	ON_BN_CLICKED(IDC_NEXTTIP, OnNextTip)
	ON_WM_CTLCOLOR()
	ON_WM_PAINT()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CTipOfTheDay message handlers

void CTipOfTheDay::OnNextTip() {
	GetNextTipString(m_strTip);
	UpdateData(FALSE);
}

void CTipOfTheDay::GetNextTipString(CString& strNext) {
	LPTSTR lpsz = strNext.GetBuffer(MAX_BUFLEN);

	// This routine identifies the next string that needs to be
	// read from the tips file
	BOOL bStop = FALSE;
	while (!bStop) 	{
		if (_fgetts(lpsz, MAX_BUFLEN, m_pStream) == NULL) {
			// We have either reached EOF or enocuntered some problem
			// In both cases reset the pointer to the beginning of the file
			// This behavior is same as VC++ Tips file
			if (fseek(m_pStream, 0, SEEK_SET) != 0) 
				AfxMessageBox(CG_IDP_FILE_CORRUPT);
		} 
		else {
			if (*lpsz != ' ' && *lpsz != '\t' && 
				*lpsz != '\n' && *lpsz != ';') {
				// There should be no space at the beginning of the tip
				// This behavior is same as VC++ Tips file
				// Comment lines are ignored and they start with a semicolon
				bStop = TRUE;
			}
		}
	}
	strNext.ReleaseBuffer();
}

HBRUSH CTipOfTheDay::OnCtlColor(CDC* pDC, CWnd* pWnd, UINT nCtlColor) {
	if (pWnd->GetDlgCtrlID() == IDC_TIPSTRING)
		return (HBRUSH)GetStockObject(WHITE_BRUSH);

	return CDialog::OnCtlColor(pDC, pWnd, nCtlColor);
}

void CTipOfTheDay::OnOK() {
	CDialog::OnOK();
	
    // Update the startup information stored in the INI file
	CWinApp* pApp = AfxGetApp();
	pApp->WriteProfileInt(szSection, szIntStartup, !m_bStartup);
}

BOOL CTipOfTheDay::OnInitDialog() {
	CDialog::OnInitDialog();

	// If Tips file does not exist then disable NextTip
	if (m_pStream == NULL)
		GetDlgItem(IDC_NEXTTIP)->EnableWindow(FALSE);

	return TRUE;  // return TRUE unless you set the focus to a control
}

void CTipOfTheDay::OnPaint() {
	CPaintDC dc(this); // device context for painting

	// Get paint area for the big static control
	CWnd* pStatic = GetDlgItem(IDC_BULB);
	CRect rect;
	pStatic->GetWindowRect(&rect);
	ScreenToClient(&rect);

	// Paint the background white.
	CBrush brush;
	brush.CreateStockObject(WHITE_BRUSH);
	dc.FillRect(rect, &brush);

	// Load bitmap and get dimensions of the bitmap
	CBitmap bmp;
	bmp.LoadBitmap(IDB_LIGHTBULB);
	BITMAP bmpInfo;
	bmp.GetBitmap(&bmpInfo);

	// Draw bitmap in top corner and validate only top portion of window
	CDC dcTmp;
	dcTmp.CreateCompatibleDC(&dc);
	dcTmp.SelectObject(&bmp);
	rect.bottom = bmpInfo.bmHeight + rect.top;
	dc.BitBlt(rect.left, rect.top, rect.Width(), rect.Height(), 
		&dcTmp, 0, 0, SRCCOPY);

	// Draw out "Did you know..." message next to the bitmap
	CString strMessage;
	strMessage.LoadString(CG_IDS_DIDYOUKNOW);
	rect.left += bmpInfo.bmWidth;
	dc.DrawText(strMessage, rect, DT_VCENTER | DT_SINGLELINE);

	// Do not call CDialog::OnPaint() for painting messages
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\tools\uni\minidev\codepage\codepage.h ===
/******************************************************************************

  Header File:  Code Page Knowledge Base.H

  This encapsulates a C++ class which will reside in this DLL.  It will provide
  all of the basic information needed to manage and translate code pages for the 
  Minidriver Development Tool.

  Copyright (c) 1997 by Microsoft Corporation

******************************************************************************/

class AFX_EXT_CLASS CCodePageInformation {
    DWORD   m_dwidMapped, m_dwidIn, m_dwidOut;  //  CP cached in each array
    CByteArray  m_cbaMap;                       //  Raw Map
    CWordArray  m_cwaIn, m_cwaOut;              //  Full MB2Uni and Uni2MB maps

    BOOL    Load(DWORD dwidMap);                //  Load the support page
    BOOL    Map(BOOL bUnicode);                 //  Map the requested direction
    BOOL    GenerateMap(DWORD dwidMap) const;   //  Create resource for RC file
                                                //  based on this code page

public:

    CCodePageInformation();

    //  Attributes

    const unsigned  InstalledCount() const;     //  Code pages in )S
    const unsigned  MappedCount() const;        //  Code pages in RC file
    const unsigned  SupportedCount() const;     //  Code pages supported by OS

    const DWORD     Installed(unsigned u) const;    //  Retrieve one
    const DWORD     Mapped(unsigned u) const;       //  Retrieve one
    void            Mapped(CDWordArray& cdwaReturn) const;  //  The IDs
    const DWORD     Supported(unsigned u) const;    //  Retrieve one

    CString         Name(DWORD dw) const;           //  Name of the code page
                                                    //  cf RC file
    BOOL            IsInstalled(DWORD dwPage) const;
    BOOL            HaveMap(DWORD dwPage) const;

    //  DBCS query- is page DBCS?  if so is this code point DBCS?

    BOOL            IsDBCS(DWORD dwidPage);
    BOOL            IsDBCS(DWORD dwidPage, WORD wCodePoint); 

    //  Operations
    unsigned        Convert(CByteArray& cbaMBCS, CWordArray& cbaWC, 
                            DWORD dwidPage);

    BOOL            GenerateAllMaps() const;        //  Gen resources for any 
                                                    //  installed & unsupported
    BOOL            Collect(DWORD dwidMap, CWordArray& cwaWhere, 
                            BOOL bUnicode = TRUE);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\tools\uni\minidev\codepage\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//	Code Page Knowledge Base.pch will be the pre-compiled header
//	stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\tools\uni\minidev\codepage\stdafx.h ===
// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#define VC_EXTRALEAN		// Exclude rarely-used stuff from Windows headers

#include <afxwin.h>         // MFC core and standard components
#include <afxext.h>         // MFC extensions

#ifndef _AFX_NO_OLE_SUPPORT
#include <afxole.h>         // MFC OLE classes
#include <afxodlgs.h>       // MFC OLE dialog classes
#include <afxdisp.h>        // MFC OLE automation classes
#endif // _AFX_NO_OLE_SUPPORT


#ifndef _AFX_NO_DB_SUPPORT
#include <afxdb.h>			// MFC ODBC database classes
#endif // _AFX_NO_DB_SUPPORT

#ifndef _AFX_NO_DAO_SUPPORT
#include <afxdao.h>			// MFC DAO database classes
#endif // _AFX_NO_DAO_SUPPORT

#ifndef _AFX_NO_AFXCMN_SUPPORT
#include <afxcmn.h>			// MFC support for Windows Common Controls
#endif // _AFX_NO_AFXCMN_SUPPORT
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\tools\uni\minidev\codepage\codepage.cpp ===
/******************************************************************************

  Source File:  Code Page Knowledge Base.CPP

  This implements the code page knowledge base.

  Copyright (c) 1997 by Microsoft Corporation.  All Rights Reserved.

  A Pretty Penny Enterprises Production.

  Change History:
  02-22-1997    Bob_Kjelgaard@Prodigy.Net   Created it

******************************************************************************/

#include    "StdAfx.h"
#include    <AfxDllx.h>
#include    "Resource.H"
#if defined(LONG_NAMES)
#include    "Code Page Knowledge Base.H"
#else
#include    "CodePage.H"
#endif

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

static AFX_EXTENSION_MODULE CodePageKnowledgeBaseDLL = { NULL, NULL };
static HINSTANCE hi;

extern "C" int APIENTRY
DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID lpReserved) {
	if (dwReason == DLL_PROCESS_ATTACH) {
        hi = hInstance;
		TRACE0("Code Page Knowledge Base.DLL Initializing!\n");
		
		// Extension DLL one-time initialization
		AfxInitExtensionModule(CodePageKnowledgeBaseDLL, hInstance);

		// Insert this DLL into the resource chain
		new CDynLinkLibrary(CodePageKnowledgeBaseDLL);
	}
	else if (dwReason == DLL_PROCESS_DETACH) 	{
		TRACE0("Code Page Knowledge Base.DLL Terminating!\n");
	}
	return 1;   // ok
}

static CDWordArray      cdaInstalled, cdaSupported, cdaMapped;

static BOOL CALLBACK    EnumProc(LPTSTR lpstrName) {
    cdaSupported.Add(atoi(lpstrName));
    return  TRUE;
}

/******************************************************************************

  CCodePageInformation::Load

  This loads the selected code page into the cache, if it isn't already there.

******************************************************************************/

BOOL    CCodePageInformation::Load(DWORD dwidPage) {

    if  (dwidPage == m_dwidMapped)
        return  TRUE;   //  Already done!

    if  (dwidPage > 65535)  //  We map words for code pages in civilized lands
        return  FALSE;

    HRSRC   hrsrc = FindResource(hi, MAKEINTRESOURCE((WORD) dwidPage), 
        MAKEINTRESOURCE(MAPPING_TABLE));

    HGLOBAL hgMap = LoadResource(hi, hrsrc);

    if  (!hgMap)
        return  FALSE;  //  This should never happen!

    LPVOID lpv = LockResource(hgMap);

    if  (!lpv)
        return  FALSE;

    try {
        m_cbaMap.RemoveAll();
        m_cbaMap.SetSize(SizeofResource(hi, hrsrc));
        memcpy(m_cbaMap.GetData(), lpv, m_cbaMap.GetSize());
    }

    catch   (CException * pce) {
        m_dwidMapped = 0;
        pce -> ReportError();
        pce -> Delete();
        return  FALSE;
    }

    m_dwidMapped = dwidPage;
    return  TRUE;
}

/******************************************************************************

  CCodePageInformation::Map

  This creates either the in or out of unicode translation table, as requested,
  using the loaded map.

******************************************************************************/

BOOL    CCodePageInformation::Map(BOOL bUnicode) {

    if  (!m_dwidMapped)
        return  FALSE;

    DWORD&  dwid = bUnicode ? m_dwidOut : m_dwidIn;

    if  (m_dwidMapped == dwid)
        return  TRUE;

    struct MB2WCMap {
        WORD    m_wMBCS;
        WORD    m_wWC;
    }   *psMap = (MB2WCMap *) m_cbaMap.GetData();

    if  (!psMap)
        return  0;

    DWORD   dwcEntries = m_cbaMap.GetSize() / sizeof *psMap;
    CWordArray&  cwaMap = bUnicode ? m_cwaOut : m_cwaIn;

    try {

        cwaMap.RemoveAll();
        cwaMap.InsertAt(0, 0xFFFF, 65536);  //  This is always an invalid value

        while   (dwcEntries--)
            if  (bUnicode)
                cwaMap[psMap[dwcEntries].m_wWC] = psMap[dwcEntries].m_wMBCS;
            else
                cwaMap[psMap[dwcEntries].m_wMBCS] = psMap[dwcEntries].m_wWC;
    }
    
    catch   (CException * pce) {
        dwid = 0;
        cwaMap.RemoveAll();
        pce -> ReportError();
        pce -> Delete();
        return  0;
    }

    dwid = m_dwidMapped;
    return  TRUE;
}

/******************************************************************************

  CCodePageInformation constructor

  If the statistics haven't been initialized, do it now.  Otherwise, this is 
  trivial.

******************************************************************************/

CCodePageInformation::CCodePageInformation() {
    m_dwidMapped = m_dwidIn = m_dwidOut = 0;
    //  Initialize the statics if we need to.

    if  (cdaInstalled.GetSize())
        return;

    EnumSystemCodePages(&EnumProc, CP_INSTALLED);
    cdaInstalled.Copy(cdaSupported);
    cdaSupported.RemoveAll();
    EnumSystemCodePages(&EnumProc, CP_SUPPORTED);

    //  Build a list of mappable code pages

    for (DWORD  dw = 400; dw < 32767; dw++)
        if  (HaveMap(dw)) 
            cdaMapped.Add(dw);
}

const unsigned  CCodePageInformation::SupportedCount() const {
    return  (unsigned) cdaSupported.GetSize();
}

const unsigned  CCodePageInformation::InstalledCount() const {
    return  (unsigned) cdaInstalled.GetSize();
}

const unsigned  CCodePageInformation::MappedCount() const {
    return  (unsigned) cdaMapped.GetSize();
}

const DWORD CCodePageInformation::Supported(unsigned u) const {
    return  cdaSupported[u];
}

const DWORD CCodePageInformation::Installed(unsigned u) const {
    return  cdaInstalled[u];
}

const DWORD CCodePageInformation::Mapped(unsigned u) const {
    return  cdaMapped[u];
}

/******************************************************************************

  CCodePageInformation::Mapped(CDWordArray& cdaReturn)

  Fills the given array with all of the mapped code page IDs.

******************************************************************************/

void    CCodePageInformation::Mapped(CDWordArray& cdaReturn) const {
    cdaReturn.Copy(cdaMapped);
}

CString  CCodePageInformation::Name(DWORD dwidPage) const {

    CString csTemp;
    csTemp.LoadString(dwidPage);
    csTemp.TrimLeft();
    csTemp.TrimRight();

    if   (csTemp.IsEmpty())
        csTemp.Format(_TEXT("Code Page %d"), dwidPage);
    return  csTemp;
}

/******************************************************************************

  CCodePageInformation::IsInstalled

  Rturns true if the font is either installed in the OS or one of our 
  resources.

******************************************************************************/

BOOL    CCodePageInformation::IsInstalled(DWORD dwidPage) const {
    for (unsigned u = 0; u < MappedCount(); u++)
        if  (Mapped(u) == dwidPage)
            return  TRUE;
    for (u = 0; u < InstalledCount(); u++)
        if  (Installed(u) == dwidPage)
            return  TRUE;

    return  FALSE;
}

/******************************************************************************

  CCodePageInformation::GenerateMap

  This private member generates a map representing the available one-to-one
  transformations in an installed code page, and writes it to a file using
  the code page id to form a unique name

******************************************************************************/

BOOL    CCodePageInformation::GenerateMap(DWORD dwidMap) const {

    //  If we can't get Code Page info for it, vanish

    CPINFO  cpi;

    if  (!GetCPInfo(dwidMap, &cpi))
        return  FALSE;

    CWordArray  cwaMap;

    for (unsigned u = 0; u < 65536; u++) {
        unsigned    uTo = 0;
        BOOL        bInvalid;

        int icTo = WideCharToMultiByte(dwidMap, 0, (PWSTR) &u, 1, (PSTR) &uTo,
         